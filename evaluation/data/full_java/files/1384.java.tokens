package org . apache . cassandra . cql3 . validation . entities ; import java . lang . reflect . Field ; import java . util . * ; import com . google . common . base . Joiner ; import com . google . common . collect . ImmutableSet ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . auth . * ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . Attributes ; import org . apache . cassandra . cql3 . CQLStatement ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . functions . FunctionName ; import org . apache . cassandra . cql3 . statements . BatchStatement ; import org . apache . cassandra . cql3 . statements . ModificationStatement ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . exceptions . * ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . utils . Pair ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class UFAuthTest extends CQLTester { String roleName = <str> ; AuthenticatedUser user ; RoleResource role ; ClientState clientState ; @BeforeClass public static void setupAuthorizer ( ) { try { IAuthorizer authorizer = new StubAuthorizer ( ) ; Field authorizerField = DatabaseDescriptor . class . getDeclaredField ( <str> ) ; authorizerField . setAccessible ( true ) ; authorizerField . set ( null , authorizer ) ; DatabaseDescriptor . setPermissionsValidity ( <int> ) ; } catch ( IllegalAccessException | NoSuchFieldException e ) { throw new RuntimeException ( e ) ; } } @Before public void setup ( ) throws Throwable { ( ( StubAuthorizer ) DatabaseDescriptor . getAuthorizer ( ) ) . clear ( ) ; setupClientState ( ) ; setupTable ( <str> ) ; } @Test public void functionInSelection ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , functionCall ( functionName ) , KEYSPACE + <str> + currentTable ( ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInSelectPKRestriction ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInSelectClusteringRestriction ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInSelectInRestriction ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInSelectMultiColumnInRestriction ( ) throws Throwable { setupTable ( <str> ) ; String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInSelectMultiColumnEQRestriction ( ) throws Throwable { setupTable ( <str> ) ; String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInSelectMultiColumnSliceRestriction ( ) throws Throwable { setupTable ( <str> ) ; String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInSelectTokenEQRestriction ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInSelectTokenSliceRestriction ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInPKForInsert ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInClusteringValuesForInsert ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInPKForDelete ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInClusteringValuesForDelete ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void testBatchStatement ( ) throws Throwable { List < ModificationStatement > statements = new ArrayList < > ( ) ; List < String > functions = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { String functionName = createSimpleFunction ( ) ; ModificationStatement stmt = ( ModificationStatement ) getStatement ( String . format ( <str> + <str> , KEYSPACE + <str> + currentTable ( ) , i , i , functionCall ( functionName ) ) ) ; functions . add ( functionName ) ; statements . add ( stmt ) ; } BatchStatement batch = new BatchStatement ( - <int> , BatchStatement . Type . LOGGED , statements , Attributes . none ( ) ) ; assertUnauthorized ( batch , functions ) ; grantExecuteOnFunction ( functions . get ( <int> ) ) ; assertUnauthorized ( batch , functions . subList ( <int> , functions . size ( ) ) ) ; grantExecuteOnFunction ( functions . get ( <int> ) ) ; assertUnauthorized ( batch , functions . subList ( <int> , functions . size ( ) ) ) ; grantExecuteOnFunction ( functions . get ( <int> ) ) ; batch . checkAccess ( clientState ) ; } @Test public void testNestedFunctions ( ) throws Throwable { String innerFunctionName = createSimpleFunction ( ) ; String outerFunctionName = createFunction ( <str> , <str> + <str> + <str> + <str> + <str> ) ; assertPermissionsOnNestedFunctions ( innerFunctionName , outerFunctionName ) ; } @Test public void functionInStaticColumnRestrictionInSelect ( ) throws Throwable { setupTable ( <str> ) ; String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInRegularCondition ( ) throws Throwable { String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInStaticColumnCondition ( ) throws Throwable { setupTable ( <str> ) ; String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInCollectionLiteralCondition ( ) throws Throwable { setupTable ( <str> ) ; String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void functionInCollectionElementCondition ( ) throws Throwable { setupTable ( <str> ) ; String functionName = createSimpleFunction ( ) ; String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) , functionCall ( functionName ) ) ; assertPermissionsOnFunction ( cql , functionName ) ; } @Test public void systemFunctionsRequireNoExplicitPrivileges ( ) throws Throwable { String cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) ) ; getStatement ( cql ) . checkAccess ( clientState ) ; String functionName = createSimpleFunction ( ) ; grantExecuteOnFunction ( functionName ) ; cql = String . format ( <str> , KEYSPACE + <str> + currentTable ( ) , functionCall ( functionName ) ) ; getStatement ( cql ) . checkAccess ( clientState ) ; } @Test public void requireExecutePermissionOnComponentFunctionsWhenDefiningAggregate ( ) throws Throwable { String sFunc = createSimpleStateFunction ( ) ; String fFunc = createSimpleFinalFunction ( ) ; DatabaseDescriptor . getAuthorizer ( ) . grant ( AuthenticatedUser . SYSTEM_USER , ImmutableSet . of ( Permission . CREATE ) , FunctionResource . keyspace ( KEYSPACE ) , role ) ; String aggDef = String . format ( aggregateCql ( sFunc , fFunc ) , KEYSPACE + <str> ) ; assertUnauthorized ( aggDef , sFunc , <str> ) ; grantExecuteOnFunction ( sFunc ) ; assertUnauthorized ( aggDef , fFunc , <str> ) ; grantExecuteOnFunction ( fFunc ) ; getStatement ( aggDef ) . checkAccess ( clientState ) ; } @Test public void revokeExecutePermissionsOnAggregateComponents ( ) throws Throwable { String sFunc = createSimpleStateFunction ( ) ; String fFunc = createSimpleFinalFunction ( ) ; String aggDef = aggregateCql ( sFunc , fFunc ) ; grantExecuteOnFunction ( sFunc ) ; grantExecuteOnFunction ( fFunc ) ; String aggregate = createAggregate ( KEYSPACE , <str> , aggDef ) ; grantExecuteOnFunction ( aggregate ) ; String cql = String . format ( <str> , aggregate , KEYSPACE + <str> + currentTable ( ) ) ; getStatement ( cql ) . checkAccess ( clientState ) ; revokeExecuteOnFunction ( aggregate ) ; assertUnauthorized ( cql , aggregate , <str> ) ; grantExecuteOnFunction ( aggregate ) ; getStatement ( cql ) . checkAccess ( clientState ) ; revokeExecuteOnFunction ( sFunc ) ; assertUnauthorized ( cql , sFunc , <str> ) ; grantExecuteOnFunction ( sFunc ) ; getStatement ( cql ) . checkAccess ( clientState ) ; revokeExecuteOnFunction ( fFunc ) ; assertUnauthorized ( cql , fFunc , <str> ) ; grantExecuteOnFunction ( fFunc ) ; getStatement ( cql ) . checkAccess ( clientState ) ; } @Test public void functionWrappingAggregate ( ) throws Throwable { String outerFunc = createFunction ( <str> , <str> + <str> + <str> + <str> + <str> ) ; String sFunc = createSimpleStateFunction ( ) ; String fFunc = createSimpleFinalFunction ( ) ; String aggDef = aggregateCql ( sFunc , fFunc ) ; grantExecuteOnFunction ( sFunc ) ; grantExecuteOnFunction ( fFunc ) ; String aggregate = createAggregate ( KEYSPACE , <str> , aggDef ) ; String cql = String . format ( <str> , outerFunc , aggregate , KEYSPACE + <str> + currentTable ( ) ) ; assertUnauthorized ( cql , outerFunc , <str> ) ; grantExecuteOnFunction ( outerFunc ) ; assertUnauthorized ( cql , aggregate , <str> ) ; grantExecuteOnFunction ( aggregate ) ; getStatement ( cql ) . checkAccess ( clientState ) ; } @Test public void aggregateWrappingFunction ( ) throws Throwable { String innerFunc = createFunction ( <str> , <str> + <str> + <str> + <str> + <str> ) ; String sFunc = createSimpleStateFunction ( ) ; String fFunc = createSimpleFinalFunction ( ) ; String aggDef = aggregateCql ( sFunc , fFunc ) ; grantExecuteOnFunction ( sFunc ) ; grantExecuteOnFunction ( fFunc ) ; String aggregate = createAggregate ( KEYSPACE , <str> , aggDef ) ; String cql = String . format ( <str> , aggregate , innerFunc , KEYSPACE + <str> + currentTable ( ) ) ; assertUnauthorized ( cql , aggregate , <str> ) ; grantExecuteOnFunction ( aggregate ) ; assertUnauthorized ( cql , innerFunc , <str> ) ; grantExecuteOnFunction ( innerFunc ) ; getStatement ( cql ) . checkAccess ( clientState ) ; } private void assertPermissionsOnNestedFunctions ( String innerFunction , String outerFunction ) throws Throwable { String cql = String . format ( <str> , functionCall ( outerFunction , functionCall ( innerFunction ) ) , KEYSPACE + <str> + currentTable ( ) ) ; assertUnauthorized ( cql , outerFunction , <str> ) ; grantExecuteOnFunction ( outerFunction ) ; assertUnauthorized ( cql , innerFunction , <str> ) ; grantExecuteOnFunction ( innerFunction ) ; getStatement ( cql ) . checkAccess ( clientState ) ; } private void assertPermissionsOnFunction ( String cql , String functionName ) throws Throwable { assertPermissionsOnFunction ( cql , functionName , <str> ) ; } private void assertPermissionsOnFunction ( String cql , String functionName , String argTypes ) throws Throwable { assertUnauthorized ( cql , functionName , argTypes ) ; grantExecuteOnFunction ( functionName ) ; getStatement ( cql ) . checkAccess ( clientState ) ; } private void assertUnauthorized ( BatchStatement batch , Iterable < String > functionNames ) throws Throwable { try { batch . checkAccess ( clientState ) ; fail ( <str> ) ; } catch ( UnauthorizedException e ) { String functions = String . format ( <str> , Joiner . on ( <str> ) . join ( functionNames ) ) ; assertTrue ( e . getLocalizedMessage ( ) . matches ( String . format ( <str> , roleName , functions ) ) ) ; } } private void assertUnauthorized ( String cql , String functionName , String argTypes ) throws Throwable { try { getStatement ( cql ) . checkAccess ( clientState ) ; fail ( <str> ) ; } catch ( UnauthorizedException e ) { assertEquals ( String . format ( <str> , roleName , functionName , argTypes ) , e . getLocalizedMessage ( ) ) ; } } private void grantExecuteOnFunction ( String functionName ) { DatabaseDescriptor . getAuthorizer ( ) . grant ( AuthenticatedUser . SYSTEM_USER , ImmutableSet . of ( Permission . EXECUTE ) , functionResource ( functionName ) , role ) ; } private void revokeExecuteOnFunction ( String functionName ) { DatabaseDescriptor . getAuthorizer ( ) . revoke ( AuthenticatedUser . SYSTEM_USER , ImmutableSet . of ( Permission . EXECUTE ) , functionResource ( functionName ) , role ) ; } void setupClientState ( ) { try { role = RoleResource . role ( roleName ) ; user = new AuthenticatedUser ( roleName ) ; clientState = ClientState . forInternalCalls ( ) ; Field userField = ClientState . class . getDeclaredField ( <str> ) ; userField . setAccessible ( true ) ; userField . set ( clientState , user ) ; } catch ( IllegalAccessException | NoSuchFieldException e ) { throw new RuntimeException ( e ) ; } } private void setupTable ( String tableDef ) throws Throwable { createTable ( tableDef ) ; DatabaseDescriptor . getAuthorizer ( ) . grant ( AuthenticatedUser . SYSTEM_USER , ImmutableSet . of ( Permission . SELECT , Permission . MODIFY ) , DataResource . table ( KEYSPACE , currentTable ( ) ) , RoleResource . role ( user . getName ( ) ) ) ; } private String aggregateCql ( String sFunc , String fFunc ) { return <str> + <str> + shortFunctionName ( sFunc ) + <str> + <str> + <str> + shortFunctionName ( fFunc ) + <str> + <str> ; } private String createSimpleStateFunction ( ) throws Throwable { return createFunction ( <str> , <str> + <str> + <str> + <str> + <str> ) ; } private String createSimpleFinalFunction ( ) throws Throwable { return createFunction ( <str> , <str> + <str> + <str> + <str> + <str> ) ; } private String createSimpleFunction ( ) throws Throwable { return createFunction ( <str> , <str> + <str> + <str> + <str> + <str> ) ; } private String createFunction ( String argTypes , String functionDef ) throws Throwable { return createFunction ( KEYSPACE , argTypes , functionDef ) ; } private CQLStatement getStatement ( String cql ) { return QueryProcessor . getStatement ( cql , clientState ) . statement ; } private FunctionResource functionResource ( String functionName ) { FunctionName fn = parseFunctionName ( functionName ) ; Collection < Function > functions = Schema . instance . getFunctions ( fn ) ; assertEquals ( String . format ( <str> , functionName , functions . size ( ) ) , <int> , functions . size ( ) ) ; return FunctionResource . function ( fn . keyspace , fn . name , functions . iterator ( ) . next ( ) . argTypes ( ) ) ; } private String functionCall ( String functionName , String . . . args ) { return String . format ( <str> , functionName , Joiner . on ( <str> ) . join ( args ) ) ; } static class StubAuthorizer implements IAuthorizer { Map < Pair < String , IResource > , Set < Permission > > userPermissions = new HashMap < > ( ) ; private void clear ( ) { userPermissions . clear ( ) ; } public Set < Permission > authorize ( AuthenticatedUser user , IResource resource ) { Pair < String , IResource > key = Pair . create ( user . getName ( ) , resource ) ; Set < Permission > perms = userPermissions . get ( key ) ; return perms ! = null ? perms : Collections . < Permission > emptySet ( ) ; } public void grant ( AuthenticatedUser performer , Set < Permission > permissions , IResource resource , RoleResource grantee ) throws RequestValidationException , RequestExecutionException { Pair < String , IResource > key = Pair . create ( grantee . getRoleName ( ) , resource ) ; Set < Permission > perms = userPermissions . get ( key ) ; if ( null = = perms ) { perms = new HashSet < > ( ) ; userPermissions . put ( key , perms ) ; } perms . addAll ( permissions ) ; } public void revoke ( AuthenticatedUser performer , Set < Permission > permissions , IResource resource , RoleResource revokee ) throws RequestValidationException , RequestExecutionException { Pair < String , IResource > key = Pair . create ( revokee . getRoleName ( ) , resource ) ; Set < Permission > perms = userPermissions . get ( key ) ; if ( null ! = perms ) perms . removeAll ( permissions ) ; if ( perms . isEmpty ( ) ) userPermissions . remove ( key ) ; } public Set < PermissionDetails > list ( AuthenticatedUser performer , Set < Permission > permissions , IResource resource , RoleResource grantee ) throws RequestValidationException , RequestExecutionException { Pair < String , IResource > key = Pair . create ( grantee . getRoleName ( ) , resource ) ; Set < Permission > perms = userPermissions . get ( key ) ; if ( perms = = null ) return Collections . emptySet ( ) ; Set < PermissionDetails > details = new HashSet < > ( ) ; for ( Permission permission : perms ) { if ( permissions . contains ( permission ) ) details . add ( new PermissionDetails ( grantee . getRoleName ( ) , resource , permission ) ) ; } return details ; } public void revokeAllFrom ( RoleResource revokee ) { for ( Pair < String , IResource > key : userPermissions . keySet ( ) ) if ( key . left . equals ( revokee . getRoleName ( ) ) ) userPermissions . remove ( key ) ; } public void revokeAllOn ( IResource droppedResource ) { for ( Pair < String , IResource > key : userPermissions . keySet ( ) ) if ( key . right . equals ( droppedResource ) ) userPermissions . remove ( key ) ; } public Set < ? extends IResource > protectedResources ( ) { return Collections . emptySet ( ) ; } public void validateConfiguration ( ) throws ConfigurationException { } public void setup ( ) { } } } 
