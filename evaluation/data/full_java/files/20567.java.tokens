package com . nostra13 . universalimageloader . core . download ; import android . annotation . TargetApi ; import android . content . ContentResolver ; import android . content . Context ; import android . graphics . Bitmap ; import android . graphics . Bitmap . CompressFormat ; import android . media . ThumbnailUtils ; import android . net . Uri ; import android . os . Build ; import android . provider . ContactsContract ; import android . provider . MediaStore ; import android . webkit . MimeTypeMap ; import com . nostra13 . universalimageloader . core . DisplayImageOptions ; import com . nostra13 . universalimageloader . core . assist . ContentLengthInputStream ; import com . nostra13 . universalimageloader . utils . IoUtils ; import java . io . BufferedInputStream ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStream ; import java . net . HttpURLConnection ; import java . net . URL ; import java . net . URLConnection ; public class BaseImageDownloader implements ImageDownloader { public static final int DEFAULT_HTTP_CONNECT_TIMEOUT = <int> * <int> ; public static final int DEFAULT_HTTP_READ_TIMEOUT = <int> * <int> ; protected static final int BUFFER_SIZE = <int> * <int> ; protected static final String ALLOWED_URI_CHARS = <str> ; protected static final int MAX_REDIRECT_COUNT = <int> ; protected static final String CONTENT_CONTACTS_URI_PREFIX = <str> ; private static final String ERROR_UNSUPPORTED_SCHEME = <str> + <str> ; protected final Context context ; protected final int connectTimeout ; protected final int readTimeout ; public BaseImageDownloader ( Context context ) { this ( context , DEFAULT_HTTP_CONNECT_TIMEOUT , DEFAULT_HTTP_READ_TIMEOUT ) ; } public BaseImageDownloader ( Context context , int connectTimeout , int readTimeout ) { this . context = context . getApplicationContext ( ) ; this . connectTimeout = connectTimeout ; this . readTimeout = readTimeout ; } @Override public InputStream getStream ( String imageUri , Object extra ) throws IOException { switch ( Scheme . ofUri ( imageUri ) ) { case HTTP : case HTTPS : return getStreamFromNetwork ( imageUri , extra ) ; case FILE : return getStreamFromFile ( imageUri , extra ) ; case CONTENT : return getStreamFromContent ( imageUri , extra ) ; case ASSETS : return getStreamFromAssets ( imageUri , extra ) ; case DRAWABLE : return getStreamFromDrawable ( imageUri , extra ) ; case UNKNOWN : default : return getStreamFromOtherSource ( imageUri , extra ) ; } } protected InputStream getStreamFromNetwork ( String imageUri , Object extra ) throws IOException { HttpURLConnection conn = createConnection ( imageUri , extra ) ; int redirectCount = <int> ; while ( conn . getResponseCode ( ) / <int> = = <int> & & redirectCount < MAX_REDIRECT_COUNT ) { conn = createConnection ( conn . getHeaderField ( <str> ) , extra ) ; redirectCount + + ; } InputStream imageStream ; try { imageStream = conn . getInputStream ( ) ; } catch ( IOException e ) { IoUtils . readAndCloseStream ( conn . getErrorStream ( ) ) ; throw e ; } if ( ! shouldBeProcessed ( conn ) ) { IoUtils . closeSilently ( imageStream ) ; throw new IOException ( <str> + conn . getResponseCode ( ) ) ; } return new ContentLengthInputStream ( new BufferedInputStream ( imageStream , BUFFER_SIZE ) , conn . getContentLength ( ) ) ; } protected boolean shouldBeProcessed ( HttpURLConnection conn ) throws IOException { return conn . getResponseCode ( ) = = <int> ; } protected HttpURLConnection createConnection ( String url , Object extra ) throws IOException { String encodedUrl = Uri . encode ( url , ALLOWED_URI_CHARS ) ; HttpURLConnection conn = ( HttpURLConnection ) new URL ( encodedUrl ) . openConnection ( ) ; conn . setConnectTimeout ( connectTimeout ) ; conn . setReadTimeout ( readTimeout ) ; return conn ; } protected InputStream getStreamFromFile ( String imageUri , Object extra ) throws IOException { String filePath = Scheme . FILE . crop ( imageUri ) ; if ( isVideoFileUri ( imageUri ) ) { return getVideoThumbnailStream ( filePath ) ; } else { BufferedInputStream imageStream = new BufferedInputStream ( new FileInputStream ( filePath ) , BUFFER_SIZE ) ; return new ContentLengthInputStream ( imageStream , ( int ) new File ( filePath ) . length ( ) ) ; } } @TargetApi ( Build . VERSION_CODES . FROYO ) private InputStream getVideoThumbnailStream ( String filePath ) { if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . FROYO ) { Bitmap bitmap = ThumbnailUtils . createVideoThumbnail ( filePath , MediaStore . Images . Thumbnails . FULL_SCREEN_KIND ) ; if ( bitmap ! = null ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; bitmap . compress ( CompressFormat . PNG , <int> , bos ) ; return new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } } return null ; } protected InputStream getStreamFromContent ( String imageUri , Object extra ) throws FileNotFoundException { ContentResolver res = context . getContentResolver ( ) ; Uri uri = Uri . parse ( imageUri ) ; if ( isVideoContentUri ( uri ) ) { Long origId = Long . valueOf ( uri . getLastPathSegment ( ) ) ; Bitmap bitmap = MediaStore . Video . Thumbnails . getThumbnail ( res , origId , MediaStore . Images . Thumbnails . MINI_KIND , null ) ; if ( bitmap ! = null ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; bitmap . compress ( CompressFormat . PNG , <int> , bos ) ; return new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } } else if ( imageUri . startsWith ( CONTENT_CONTACTS_URI_PREFIX ) ) { return getContactPhotoStream ( uri ) ; } return res . openInputStream ( uri ) ; } @TargetApi ( Build . VERSION_CODES . ICE_CREAM_SANDWICH ) protected InputStream getContactPhotoStream ( Uri uri ) { ContentResolver res = context . getContentResolver ( ) ; if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . ICE_CREAM_SANDWICH ) { return ContactsContract . Contacts . openContactPhotoInputStream ( res , uri , true ) ; } else { return ContactsContract . Contacts . openContactPhotoInputStream ( res , uri ) ; } } protected InputStream getStreamFromAssets ( String imageUri , Object extra ) throws IOException { String filePath = Scheme . ASSETS . crop ( imageUri ) ; return context . getAssets ( ) . open ( filePath ) ; } protected InputStream getStreamFromDrawable ( String imageUri , Object extra ) { String drawableIdString = Scheme . DRAWABLE . crop ( imageUri ) ; int drawableId = Integer . parseInt ( drawableIdString ) ; return context . getResources ( ) . openRawResource ( drawableId ) ; } protected InputStream getStreamFromOtherSource ( String imageUri , Object extra ) throws IOException { throw new UnsupportedOperationException ( String . format ( ERROR_UNSUPPORTED_SCHEME , imageUri ) ) ; } private boolean isVideoContentUri ( Uri uri ) { String mimeType = context . getContentResolver ( ) . getType ( uri ) ; return mimeType ! = null & & mimeType . startsWith ( <str> ) ; } private boolean isVideoFileUri ( String uri ) { String extension = MimeTypeMap . getFileExtensionFromUrl ( uri ) ; String mimeType = MimeTypeMap . getSingleton ( ) . getMimeTypeFromExtension ( extension ) ; return mimeType ! = null & & mimeType . startsWith ( <str> ) ; } } 
