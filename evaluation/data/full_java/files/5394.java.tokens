package org . elasticsearch . action . support ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ListenableActionFuture ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . ArrayList ; import java . util . List ; public abstract class AbstractListenableActionFuture < T , L > extends AdapterActionFuture < T , L > implements ListenableActionFuture < T > { private final static ESLogger logger = Loggers . getLogger ( AbstractListenableActionFuture . class ) ; final ThreadPool threadPool ; volatile Object listeners ; boolean executedListeners = false ; protected AbstractListenableActionFuture ( ThreadPool threadPool ) { this . threadPool = threadPool ; } public ThreadPool threadPool ( ) { return threadPool ; } @Override public void addListener ( final ActionListener < T > listener ) { internalAddListener ( listener ) ; } public void internalAddListener ( ActionListener < T > listener ) { listener = new ThreadedActionListener < > ( logger , threadPool , ThreadPool . Names . LISTENER , listener ) ; boolean executeImmediate = false ; synchronized ( this ) { if ( executedListeners ) { executeImmediate = true ; } else { Object listeners = this . listeners ; if ( listeners = = null ) { listeners = listener ; } else if ( listeners instanceof List ) { ( ( List ) this . listeners ) . add ( listener ) ; } else { Object orig = listeners ; listeners = new ArrayList < > ( <int> ) ; ( ( List ) listeners ) . add ( orig ) ; ( ( List ) listeners ) . add ( listener ) ; } this . listeners = listeners ; } } if ( executeImmediate ) { executeListener ( listener ) ; } } @Override protected void done ( ) { super . done ( ) ; synchronized ( this ) { executedListeners = true ; } Object listeners = this . listeners ; if ( listeners ! = null ) { if ( listeners instanceof List ) { List list = ( List ) listeners ; for ( Object listener : list ) { executeListener ( ( ActionListener < T > ) listener ) ; } } else { executeListener ( ( ActionListener < T > ) listeners ) ; } } } private void executeListener ( final ActionListener < T > listener ) { try { listener . onResponse ( actionGet ( <int> ) ) ; } catch ( Throwable e ) { listener . onFailure ( e ) ; } } } 
