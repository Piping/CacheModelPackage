package io . netty . buffer ; import io . netty . util . internal . StringUtil ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; final class PoolChunkList < T > implements PoolChunkListMetric { private static final Iterator < PoolChunkMetric > EMPTY_METRICS = Collections . < PoolChunkMetric > emptyList ( ) . iterator ( ) ; private final PoolChunkList < T > nextList ; private final int minUsage ; private final int maxUsage ; private PoolChunk < T > head ; private PoolChunkList < T > prevList ; PoolChunkList ( PoolChunkList < T > nextList , int minUsage , int maxUsage ) { this . nextList = nextList ; this . minUsage = minUsage ; this . maxUsage = maxUsage ; } void prevList ( PoolChunkList < T > prevList ) { assert this . prevList = = null ; this . prevList = prevList ; } boolean allocate ( PooledByteBuf < T > buf , int reqCapacity , int normCapacity ) { if ( head = = null ) { return false ; } for ( PoolChunk < T > cur = head ; ; ) { long handle = cur . allocate ( normCapacity ) ; if ( handle < <int> ) { cur = cur . next ; if ( cur = = null ) { return false ; } } else { cur . initBuf ( buf , handle , reqCapacity ) ; if ( cur . usage ( ) > = maxUsage ) { remove ( cur ) ; nextList . add ( cur ) ; } return true ; } } } boolean free ( PoolChunk < T > chunk , long handle ) { chunk . free ( handle ) ; if ( chunk . usage ( ) < minUsage ) { remove ( chunk ) ; if ( prevList = = null ) { assert chunk . usage ( ) = = <int> ; return false ; } else { prevList . add ( chunk ) ; return true ; } } return true ; } void add ( PoolChunk < T > chunk ) { if ( chunk . usage ( ) > = maxUsage ) { nextList . add ( chunk ) ; return ; } chunk . parent = this ; if ( head = = null ) { head = chunk ; chunk . prev = null ; chunk . next = null ; } else { chunk . prev = null ; chunk . next = head ; head . prev = chunk ; head = chunk ; } } private void remove ( PoolChunk < T > cur ) { if ( cur = = head ) { head = cur . next ; if ( head ! = null ) { head . prev = null ; } } else { PoolChunk < T > next = cur . next ; cur . prev . next = next ; if ( next ! = null ) { next . prev = cur . prev ; } } } @Override public int minUsage ( ) { return minUsage ; } @Override public int maxUsage ( ) { return maxUsage ; } @Override public Iterator < PoolChunkMetric > iterator ( ) { if ( head = = null ) { return EMPTY_METRICS ; } List < PoolChunkMetric > metrics = new ArrayList < PoolChunkMetric > ( ) ; for ( PoolChunk < T > cur = head ; ; ) { metrics . add ( cur ) ; cur = cur . next ; if ( cur = = null ) { break ; } } return metrics . iterator ( ) ; } @Override public String toString ( ) { if ( head = = null ) { return <str> ; } StringBuilder buf = new StringBuilder ( ) ; for ( PoolChunk < T > cur = head ; ; ) { buf . append ( cur ) ; cur = cur . next ; if ( cur = = null ) { break ; } buf . append ( StringUtil . NEWLINE ) ; } return buf . toString ( ) ; } } 
