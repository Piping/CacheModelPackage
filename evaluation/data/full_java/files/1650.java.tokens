package org . apache . cassandra . utils ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Random ; import org . junit . Test ; public class FastByteOperationsTest { private static final FastByteOperations . PureJavaOperations PJO = new FastByteOperations . PureJavaOperations ( ) ; private static final FastByteOperations . UnsafeOperations UO = new FastByteOperations . UnsafeOperations ( ) ; private static final Random rand = new Random ( <int> ) ; private static final ByteBuffer dbuf1 = ByteBuffer . allocateDirect ( <int> ) ; private static final ByteBuffer dbuf2 = ByteBuffer . allocateDirect ( <int> ) ; private static final ByteBuffer hbuf1 = ByteBuffer . allocate ( <int> ) ; private static final ByteBuffer hbuf2 = ByteBuffer . allocate ( <int> ) ; @Test public void testFastByteCopy ( ) { byte [ ] bytes1 = new byte [ <int> ] ; byte [ ] empty = new byte [ <int> ] ; rand . nextBytes ( bytes1 ) ; testCopy ( bytes1 , wrap1 ( bytes1 , true ) , wrap2 ( empty , true ) , PJO ) ; testCopy ( bytes1 , wrap1 ( bytes1 , true ) , wrap2 ( empty , false ) , PJO ) ; testCopy ( bytes1 , wrap1 ( bytes1 , false ) , wrap2 ( empty , true ) , PJO ) ; testCopy ( bytes1 , wrap1 ( bytes1 , false ) , wrap2 ( empty , false ) , PJO ) ; testCopy ( bytes1 , wrap1 ( bytes1 , true ) , wrap2 ( empty , true ) , UO ) ; testCopy ( bytes1 , wrap1 ( bytes1 , true ) , wrap2 ( empty , false ) , UO ) ; testCopy ( bytes1 , wrap1 ( bytes1 , false ) , wrap2 ( empty , true ) , UO ) ; testCopy ( bytes1 , wrap1 ( bytes1 , false ) , wrap2 ( empty , false ) , UO ) ; } private void testCopy ( byte [ ] canon , ByteBuffer src , ByteBuffer trg , FastByteOperations . ByteOperations ops ) { byte [ ] result = new byte [ src . remaining ( ) ] ; ops . copy ( src , src . position ( ) , trg , trg . position ( ) , src . remaining ( ) ) ; ops . copy ( trg , trg . position ( ) , result , <int> , trg . remaining ( ) ) ; assert firstdiff ( canon , result ) < <int> ; } private static int firstdiff ( byte [ ] canon , byte [ ] test ) { for ( int i = <int> ; i < canon . length ; i + + ) if ( canon [ i ] ! = test [ i ] ) return i ; return - <int> ; } @Test public void testFastByteComparisons ( ) { byte [ ] bytes1 = new byte [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) { rand . nextBytes ( bytes1 ) ; for ( int j = <int> ; j < <int> ; j + + ) { byte [ ] bytes2 = Arrays . copyOf ( bytes1 , bytes1 . length - j ) ; testTwiddleOneByteComparisons ( bytes1 , bytes2 , <int> , true , <int> ) ; testTwiddleOneByteComparisons ( bytes1 , bytes2 , <int> , true , - <int> ) ; testTwiddleOneByteComparisons ( bytes1 , bytes2 , <int> , false , <int> ) ; testTwiddleOneByteComparisons ( bytes1 , bytes2 , <int> , false , - <int> ) ; testTwiddleOneByteComparisons ( bytes1 , bytes2 , <int> , true , <int> ) ; testTwiddleOneByteComparisons ( bytes1 , bytes2 , <int> , false , <int> ) ; } } } private void testTwiddleOneByteComparisons ( byte [ ] bytes1 , byte [ ] bytes2 , int count , boolean start , int inc ) { for ( int j = <int> ; j < count ; j + + ) { int index = start ? j : bytes2 . length - ( j + <int> ) ; bytes2 [ index ] + = inc ; testComparisons ( bytes1 , bytes2 ) ; bytes2 [ index ] - = inc ; } } private static ByteBuffer wrap1 ( byte [ ] bytes , boolean direct ) { return slice ( bytes , direct ? dbuf1 : hbuf1 ) ; } private static ByteBuffer wrap2 ( byte [ ] bytes , boolean direct ) { return slice ( bytes , direct ? dbuf2 : hbuf2 ) ; } private static ByteBuffer slice ( byte [ ] bytes , ByteBuffer buf ) { buf = buf . duplicate ( ) ; buf . position ( ( buf . limit ( ) - bytes . length ) / <int> ) ; buf . limit ( buf . position ( ) + bytes . length ) ; buf . duplicate ( ) . put ( bytes ) ; return buf ; } private void testComparisons ( byte [ ] bytes1 , byte [ ] bytes2 ) { testComparison ( bytes1 , bytes2 ) ; testComparison ( bytes2 , bytes1 ) ; testComparison ( wrap1 ( bytes1 , false ) , bytes2 ) ; testComparison ( wrap2 ( bytes2 , false ) , bytes1 ) ; testComparison ( wrap1 ( bytes1 , false ) , wrap2 ( bytes2 , false ) ) ; testComparison ( wrap2 ( bytes2 , false ) , wrap1 ( bytes1 , false ) ) ; testComparison ( wrap1 ( bytes1 , true ) , bytes2 ) ; testComparison ( wrap2 ( bytes2 , true ) , bytes1 ) ; testComparison ( wrap1 ( bytes1 , true ) , wrap2 ( bytes2 , true ) ) ; testComparison ( wrap2 ( bytes2 , true ) , wrap1 ( bytes1 , true ) ) ; testComparison ( wrap1 ( bytes1 , true ) , wrap2 ( bytes2 , false ) ) ; testComparison ( wrap1 ( bytes1 , false ) , wrap2 ( bytes2 , true ) ) ; testComparison ( wrap2 ( bytes2 , true ) , wrap1 ( bytes1 , false ) ) ; testComparison ( wrap2 ( bytes2 , false ) , wrap1 ( bytes1 , true ) ) ; } private void testComparison ( byte [ ] bytes1 , byte [ ] bytes2 ) { assert sameComparisonResult ( PJO . compare ( bytes1 , <int> , bytes1 . length , bytes2 , <int> , bytes2 . length ) , UO . compare ( bytes1 , <int> , bytes1 . length , bytes2 , <int> , bytes2 . length ) ) ; assert sameComparisonResult ( PJO . compare ( bytes1 , <int> , bytes1 . length - <int> , bytes2 , <int> , bytes2 . length - <int> ) , UO . compare ( bytes1 , <int> , bytes1 . length - <int> , bytes2 , <int> , bytes2 . length - <int> ) ) ; } private void testComparison ( ByteBuffer bytes1 , byte [ ] bytes2 ) { assert sameComparisonResult ( PJO . compare ( bytes1 , bytes2 , <int> , bytes2 . length ) , UO . compare ( bytes1 , bytes2 , <int> , bytes2 . length ) ) ; assert sameComparisonResult ( PJO . compare ( bytes1 , bytes2 , <int> , bytes2 . length - <int> ) , UO . compare ( bytes1 , bytes2 , <int> , bytes2 . length - <int> ) ) ; } private void testComparison ( ByteBuffer bytes1 , ByteBuffer bytes2 ) { assert sameComparisonResult ( PJO . compare ( bytes1 , bytes2 ) , UO . compare ( bytes1 , bytes2 ) ) ; } static boolean sameComparisonResult ( int exp , int act ) { if ( exp < <int> ) return act < <int> ; if ( exp > <int> ) return act > <int> ; return act = = <int> ; } } 
