package org . apache . cassandra . cql3 . functions ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . * ; import java . nio . ByteBuffer ; import java . security . * ; import java . security . cert . Certificate ; import java . util . * ; import java . util . concurrent . ExecutorService ; import javax . script . * ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . exceptions . InvalidRequestException ; final class ScriptBasedUDFunction extends UDFunction { static final Map < String , Compilable > scriptEngines = new HashMap < > ( ) ; private static final ProtectionDomain protectionDomain ; private static final AccessControlContext accessControlContext ; private static final String [ ] allowedPackagesArray = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; private static final UDFExecutorService executor = new UDFExecutorService ( new NamedThreadFactory ( <str> , Thread . MIN_PRIORITY , udfClassLoader , new SecurityThreadGroup ( <str> , Collections . unmodifiableSet ( new HashSet < > ( Arrays . asList ( allowedPackagesArray ) ) ) , UDFunction : : initializeThread ) ) , <str> ) ; static { ScriptEngineManager scriptEngineManager = new ScriptEngineManager ( ) ; for ( ScriptEngineFactory scriptEngineFactory : scriptEngineManager . getEngineFactories ( ) ) { ScriptEngine scriptEngine = scriptEngineFactory . getScriptEngine ( ) ; boolean compilable = scriptEngine instanceof Compilable ; if ( compilable ) { logger . info ( <str> , scriptEngineFactory . getEngineName ( ) , scriptEngineFactory . getEngineVersion ( ) , scriptEngineFactory . getLanguageName ( ) , scriptEngineFactory . getLanguageVersion ( ) , scriptEngineFactory . getNames ( ) ) ; for ( String name : scriptEngineFactory . getNames ( ) ) scriptEngines . put ( name , ( Compilable ) scriptEngine ) ; } } try { protectionDomain = new ProtectionDomain ( new CodeSource ( new URL ( <str> , <str> , <int> , <str> , new URLStreamHandler ( ) { protected URLConnection openConnection ( URL u ) { return null ; } } ) , ( Certificate [ ] ) null ) , ThreadAwareSecurityManager . noPermissions ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( e ) ; } accessControlContext = new AccessControlContext ( new ProtectionDomain [ ] { protectionDomain } ) ; } private final CompiledScript script ; ScriptBasedUDFunction ( FunctionName name , List < ColumnIdentifier > argNames , List < AbstractType < ? > > argTypes , AbstractType < ? > returnType , boolean calledOnNullInput , String language , String body ) { super ( name , argNames , argTypes , returnType , calledOnNullInput , language , body ) ; Compilable scriptEngine = scriptEngines . get ( language ) ; if ( scriptEngine = = null ) throw new InvalidRequestException ( String . format ( <str> , language , name ) ) ; try { this . script = AccessController . doPrivileged ( ( PrivilegedExceptionAction < CompiledScript > ) ( ) - > scriptEngine . compile ( body ) , accessControlContext ) ; } catch ( PrivilegedActionException x ) { Throwable e = x . getCause ( ) ; logger . info ( <str> , name , language , e ) ; throw new InvalidRequestException ( String . format ( <str> , name , language , e ) ) ; } } protected ExecutorService executor ( ) { return executor ; } public ByteBuffer executeUserDefined ( int protocolVersion , List < ByteBuffer > parameters ) { Object [ ] params = new Object [ argTypes . size ( ) ] ; for ( int i = <int> ; i < params . length ; i + + ) params [ i ] = compose ( protocolVersion , i , parameters . get ( i ) ) ; ScriptContext scriptContext = new SimpleScriptContext ( ) ; scriptContext . setAttribute ( <str> , this . name . toString ( ) , ScriptContext . ENGINE_SCOPE ) ; Bindings bindings = scriptContext . getBindings ( ScriptContext . ENGINE_SCOPE ) ; for ( int i = <int> ; i < params . length ; i + + ) bindings . put ( argNames . get ( i ) . toString ( ) , params [ i ] ) ; Object result ; try { result = script . eval ( scriptContext ) ; } catch ( ScriptException e ) { throw new RuntimeException ( e ) ; } if ( result = = null ) return null ; Class < ? > javaReturnType = UDHelper . asJavaClass ( returnDataType ) ; Class < ? > resultType = result . getClass ( ) ; if ( ! javaReturnType . isAssignableFrom ( resultType ) ) { if ( result instanceof Number ) { Number rNumber = ( Number ) result ; if ( javaReturnType = = Integer . class ) result = rNumber . intValue ( ) ; else if ( javaReturnType = = Long . class ) result = rNumber . longValue ( ) ; else if ( javaReturnType = = Short . class ) result = rNumber . shortValue ( ) ; else if ( javaReturnType = = Byte . class ) result = rNumber . byteValue ( ) ; else if ( javaReturnType = = Float . class ) result = rNumber . floatValue ( ) ; else if ( javaReturnType = = Double . class ) result = rNumber . doubleValue ( ) ; else if ( javaReturnType = = BigInteger . class ) { if ( javaReturnType = = Integer . class ) result = rNumber . intValue ( ) ; else if ( javaReturnType = = Short . class ) result = rNumber . shortValue ( ) ; else if ( javaReturnType = = Byte . class ) result = rNumber . byteValue ( ) ; else if ( javaReturnType = = Long . class ) result = rNumber . longValue ( ) ; else if ( javaReturnType = = Float . class ) result = rNumber . floatValue ( ) ; else if ( javaReturnType = = Double . class ) result = rNumber . doubleValue ( ) ; else if ( javaReturnType = = BigInteger . class ) { if ( rNumber instanceof BigDecimal ) result = ( ( BigDecimal ) rNumber ) . toBigInteger ( ) ; else if ( rNumber instanceof Double | | rNumber instanceof Float ) result = new BigDecimal ( rNumber . toString ( ) ) . toBigInteger ( ) ; else result = BigInteger . valueOf ( rNumber . longValue ( ) ) ; } else if ( javaReturnType = = BigDecimal . class ) result = new BigDecimal ( rNumber . toString ( ) ) ; } else if ( javaReturnType = = BigDecimal . class ) result = new BigDecimal ( rNumber . toString ( ) ) ; } } return decompose ( protocolVersion , result ) ; } } 
