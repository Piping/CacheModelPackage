package org . elasticsearch . indices . state ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . admin . indices . mapping . put . PutMappingResponse ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . cluster . ClusterInfo ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDeciders ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . DiscoveryModule ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . gateway . GatewayAllocator ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . disruption . BlockClusterStateProcessing ; import org . elasticsearch . test . junit . annotations . TestLogging ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . Matchers . * ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> , numClientNodes = <int> , transportClientRatio = <int> ) @ESIntegTestCase.SuppressLocalMode public class RareClusterStateIT extends ESIntegTestCase { @Override protected int numberOfShards ( ) { return <int> ; } @Override protected int numberOfReplicas ( ) { return <int> ; } public void testUnassignedShardAndEmptyNodesInRoutingTable ( ) throws Exception { internalCluster ( ) . startNode ( ) ; createIndex ( <str> ) ; ensureSearchable ( <str> ) ; ClusterState current = clusterService ( ) . state ( ) ; GatewayAllocator allocator = internalCluster ( ) . getInstance ( GatewayAllocator . class ) ; AllocationDeciders allocationDeciders = new AllocationDeciders ( Settings . EMPTY , new AllocationDecider [ <int> ] ) ; RoutingNodes routingNodes = new RoutingNodes ( ClusterState . builder ( current ) . routingTable ( RoutingTable . builder ( current . routingTable ( ) ) . remove ( <str> ) . addAsRecovery ( current . metaData ( ) . index ( <str> ) ) . build ( ) ) . nodes ( DiscoveryNodes . EMPTY_NODES ) . build ( ) , false ) ; RoutingAllocation routingAllocation = new RoutingAllocation ( allocationDeciders , routingNodes , current . nodes ( ) , ClusterInfo . EMPTY , System . nanoTime ( ) ) ; allocator . allocateUnassigned ( routingAllocation ) ; } @TestLogging ( <str> ) public void testAssignmentWithJustAddedNodes ( ) throws Exception { internalCluster ( ) . startNode ( ) ; final String index = <str> ; prepareCreate ( index ) . setSettings ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> , IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . get ( ) ; ensureGreen ( index ) ; client ( ) . admin ( ) . indices ( ) . prepareClose ( index ) . get ( ) ; final String masterName = internalCluster ( ) . getMasterName ( ) ; final ClusterService clusterService = internalCluster ( ) . clusterService ( masterName ) ; final AllocationService allocationService = internalCluster ( ) . getInstance ( AllocationService . class , masterName ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { ClusterState . Builder builder = ClusterState . builder ( currentState ) ; builder . nodes ( DiscoveryNodes . builder ( currentState . nodes ( ) ) . put ( new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ) ) ; final IndexMetaData indexMetaData = IndexMetaData . builder ( currentState . metaData ( ) . index ( index ) ) . state ( IndexMetaData . State . OPEN ) . build ( ) ; builder . metaData ( MetaData . builder ( currentState . metaData ( ) ) . put ( indexMetaData , true ) ) ; builder . blocks ( ClusterBlocks . builder ( ) . blocks ( currentState . blocks ( ) ) . removeIndexBlocks ( index ) ) ; ClusterState updatedState = builder . build ( ) ; RoutingTable . Builder routingTable = RoutingTable . builder ( updatedState . routingTable ( ) ) ; routingTable . addAsRecovery ( updatedState . metaData ( ) . index ( index ) ) ; updatedState = ClusterState . builder ( updatedState ) . routingTable ( routingTable . build ( ) ) . build ( ) ; RoutingAllocation . Result result = allocationService . reroute ( updatedState , <str> ) ; return ClusterState . builder ( updatedState ) . routingResult ( result ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { } } ) ; ensureGreen ( index ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { ClusterState . Builder builder = ClusterState . builder ( currentState ) ; builder . nodes ( DiscoveryNodes . builder ( currentState . nodes ( ) ) . remove ( <str> ) ) ; currentState = builder . build ( ) ; RoutingAllocation . Result result = allocationService . reroute ( currentState , <str> ) ; return ClusterState . builder ( currentState ) . routingResult ( result ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { } } ) ; } @TestLogging ( <str> ) @AwaitsFix ( bugUrl = <str> ) public void testDeleteCreateInOneBulk ( ) throws Exception { internalCluster ( ) . startNodesAsync ( <int> , Settings . builder ( ) . put ( DiscoveryModule . DISCOVERY_TYPE_KEY , <str> ) . build ( ) ) . get ( ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) ) ; prepareCreate ( <str> ) . setSettings ( IndexMetaData . SETTING_AUTO_EXPAND_REPLICAS , true ) . addMapping ( <str> ) . get ( ) ; ensureGreen ( <str> ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( DiscoverySettings . PUBLISH_TIMEOUT , <str> ) ) ) ; Set < String > nodes = new HashSet < > ( Arrays . asList ( internalCluster ( ) . getNodeNames ( ) ) ) ; nodes . remove ( internalCluster ( ) . getMasterName ( ) ) ; BlockClusterStateProcessing disruption = new BlockClusterStateProcessing ( nodes . iterator ( ) . next ( ) , getRandom ( ) ) ; internalCluster ( ) . setDisruptionScheme ( disruption ) ; logger . info ( <str> ) ; index ( <str> , <str> , <str> ) ; refresh ( ) ; disruption . startDisrupting ( ) ; logger . info ( <str> ) ; assertFalse ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . setTimeout ( <str> ) . get ( ) . isAcknowledged ( ) ) ; assertFalse ( prepareCreate ( <str> ) . setTimeout ( <str> ) . setSettings ( IndexMetaData . SETTING_AUTO_EXPAND_REPLICAS , true ) . get ( ) . isAcknowledged ( ) ) ; logger . info ( <str> ) ; disruption . stopDisrupting ( ) ; ensureGreen ( TimeValue . timeValueMinutes ( <int> ) , <str> ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . get ( ) , <int> ) ; } public void testDelayedMappingPropagationOnPrimary ( ) throws Exception { Settings settings = Settings . builder ( ) . put ( DiscoverySettings . PUBLISH_TIMEOUT , <str> ) . build ( ) ; final List < String > nodeNames = internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) ) ; final String master = internalCluster ( ) . getMasterName ( ) ; assertThat ( nodeNames , hasItem ( master ) ) ; String otherNode = null ; for ( String node : nodeNames ) { if ( node . equals ( master ) = = false ) { otherNode = node ; break ; } } assertNotNull ( otherNode ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( <str> , master ) ) . get ( ) ) ; ensureGreen ( ) ; ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; assertEquals ( master , state . nodes ( ) . masterNode ( ) . name ( ) ) ; List < ShardRouting > shards = state . routingTable ( ) . allShards ( <str> ) ; assertThat ( shards , hasSize ( <int> ) ) ; for ( ShardRouting shard : shards ) { if ( shard . primary ( ) ) { assertFalse ( state . nodes ( ) . masterNodeId ( ) . equals ( shard . currentNodeId ( ) ) ) ; } else { fail ( ) ; } } BlockClusterStateProcessing disruption = new BlockClusterStateProcessing ( otherNode , getRandom ( ) ) ; internalCluster ( ) . setDisruptionScheme ( disruption ) ; disruption . startDisrupting ( ) ; final AtomicReference < Object > putMappingResponse = new AtomicReference < > ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( <str> , <str> ) . execute ( new ActionListener < PutMappingResponse > ( ) { @Override public void onResponse ( PutMappingResponse response ) { putMappingResponse . set ( response ) ; } @Override public void onFailure ( Throwable e ) { putMappingResponse . set ( e ) ; } } ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { ImmutableOpenMap < String , MappingMetaData > indexMappings = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . get ( ) . getMappings ( ) . get ( <str> ) ; assertNotNull ( indexMappings ) ; MappingMetaData typeMappings = indexMappings . get ( <str> ) ; assertNotNull ( typeMappings ) ; Object properties ; try { properties = typeMappings . getSourceAsMap ( ) . get ( <str> ) ; } catch ( IOException e ) { throw new AssertionError ( e ) ; } assertNotNull ( properties ) ; Object fieldMapping = ( ( Map < String , Object > ) properties ) . get ( <str> ) ; assertNotNull ( fieldMapping ) ; } } ) ; final AtomicReference < Object > docIndexResponse = new AtomicReference < > ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . execute ( new ActionListener < IndexResponse > ( ) { @Override public void onResponse ( IndexResponse response ) { docIndexResponse . set ( response ) ; } @Override public void onFailure ( Throwable e ) { docIndexResponse . set ( e ) ; } } ) ; Thread . sleep ( <int> ) ; assertThat ( putMappingResponse . get ( ) , equalTo ( null ) ) ; assertThat ( docIndexResponse . get ( ) , equalTo ( null ) ) ; disruption . stopDisrupting ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( putMappingResponse . get ( ) , instanceOf ( PutMappingResponse . class ) ) ; PutMappingResponse resp = ( PutMappingResponse ) putMappingResponse . get ( ) ; assertTrue ( resp . isAcknowledged ( ) ) ; assertThat ( docIndexResponse . get ( ) , instanceOf ( IndexResponse . class ) ) ; IndexResponse docResp = ( IndexResponse ) docIndexResponse . get ( ) ; assertEquals ( Arrays . toString ( docResp . getShardInfo ( ) . getFailures ( ) ) , <int> , docResp . getShardInfo ( ) . getTotal ( ) ) ; } } ) ; } public void testDelayedMappingPropagationOnReplica ( ) throws Exception { final List < String > nodeNames = internalCluster ( ) . startNodesAsync ( <int> ) . get ( ) ; assertFalse ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) . isTimedOut ( ) ) ; final String master = internalCluster ( ) . getMasterName ( ) ; assertThat ( nodeNames , hasItem ( master ) ) ; String otherNode = null ; for ( String node : nodeNames ) { if ( node . equals ( master ) = = false ) { otherNode = node ; break ; } } assertNotNull ( otherNode ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( <str> , master ) ) . get ( ) ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , <str> ) ) . get ( ) ) ; ensureGreen ( ) ; ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; assertEquals ( master , state . nodes ( ) . masterNode ( ) . name ( ) ) ; List < ShardRouting > shards = state . routingTable ( ) . allShards ( <str> ) ; assertThat ( shards , hasSize ( <int> ) ) ; for ( ShardRouting shard : shards ) { if ( shard . primary ( ) ) { assertEquals ( state . nodes ( ) . masterNodeId ( ) , shard . currentNodeId ( ) ) ; } else { assertTrue ( shard . active ( ) ) ; } } BlockClusterStateProcessing disruption = new BlockClusterStateProcessing ( otherNode , getRandom ( ) ) ; internalCluster ( ) . setDisruptionScheme ( disruption ) ; disruption . startDisrupting ( ) ; final AtomicReference < Object > putMappingResponse = new AtomicReference < > ( ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( <str> , <str> ) . execute ( new ActionListener < PutMappingResponse > ( ) { @Override public void onResponse ( PutMappingResponse response ) { putMappingResponse . set ( response ) ; } @Override public void onFailure ( Throwable e ) { putMappingResponse . set ( e ) ; } } ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { final IndicesService indicesService = internalCluster ( ) . getInstance ( IndicesService . class , master ) ; final IndexService indexService = indicesService . indexServiceSafe ( <str> ) ; assertNotNull ( indexService ) ; final MapperService mapperService = indexService . mapperService ( ) ; DocumentMapper mapper = mapperService . documentMapper ( <str> ) ; assertNotNull ( mapper ) ; assertNotNull ( mapper . mappers ( ) . getMapper ( <str> ) ) ; } } ) ; final AtomicReference < Object > docIndexResponse = new AtomicReference < > ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . execute ( new ActionListener < IndexResponse > ( ) { @Override public void onResponse ( IndexResponse response ) { docIndexResponse . set ( response ) ; } @Override public void onFailure ( Throwable e ) { docIndexResponse . set ( e ) ; } } ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertTrue ( client ( ) . prepareGet ( <str> , <str> , <str> ) . setPreference ( <str> ) . get ( ) . isExists ( ) ) ; } } ) ; Thread . sleep ( <int> ) ; assertThat ( putMappingResponse . get ( ) , equalTo ( null ) ) ; assertThat ( docIndexResponse . get ( ) , equalTo ( null ) ) ; disruption . stopDisrupting ( ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( putMappingResponse . get ( ) , instanceOf ( PutMappingResponse . class ) ) ; PutMappingResponse resp = ( PutMappingResponse ) putMappingResponse . get ( ) ; assertTrue ( resp . isAcknowledged ( ) ) ; assertThat ( docIndexResponse . get ( ) , instanceOf ( IndexResponse . class ) ) ; IndexResponse docResp = ( IndexResponse ) docIndexResponse . get ( ) ; assertEquals ( Arrays . toString ( docResp . getShardInfo ( ) . getFailures ( ) ) , <int> , docResp . getShardInfo ( ) . getTotal ( ) ) ; } } ) ; } } 
