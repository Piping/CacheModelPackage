package org . gradle . util ; import com . google . common . base . Objects ; import com . google . common . collect . Ordering ; import org . gradle . api . Nullable ; public class VersionNumber implements Comparable < VersionNumber > { private static final DefaultScheme DEFAULT_SCHEME = new DefaultScheme ( ) ; private static final SchemeWithPatchVersion PATCH_SCHEME = new SchemeWithPatchVersion ( ) ; public static final VersionNumber UNKNOWN = version ( <int> ) ; private final int major ; private final int minor ; private final int micro ; private final int patch ; private final String qualifier ; private final AbstractScheme scheme ; public VersionNumber ( int major , int minor , int micro , @Nullable String qualifier ) { this ( major , minor , micro , <int> , qualifier , DEFAULT_SCHEME ) ; } public VersionNumber ( int major , int minor , int micro , int patch , @Nullable String qualifier ) { this ( major , minor , micro , patch , qualifier , PATCH_SCHEME ) ; } private VersionNumber ( int major , int minor , int micro , int patch , @Nullable String qualifier , AbstractScheme scheme ) { this . major = major ; this . minor = minor ; this . micro = micro ; this . patch = patch ; this . qualifier = qualifier ; this . scheme = scheme ; } public int getMajor ( ) { return major ; } public int getMinor ( ) { return minor ; } public int getMicro ( ) { return micro ; } public int getPatch ( ) { return patch ; } public String getQualifier ( ) { return qualifier ; } public VersionNumber getBaseVersion ( ) { return new VersionNumber ( major , minor , micro , patch , null , scheme ) ; } public int compareTo ( VersionNumber other ) { if ( major ! = other . major ) { return major - other . major ; } if ( minor ! = other . minor ) { return minor - other . minor ; } if ( micro ! = other . micro ) { return micro - other . micro ; } if ( patch ! = other . patch ) { return patch - other . patch ; } return Ordering . natural ( ) . nullsLast ( ) . compare ( toLowerCase ( qualifier ) , toLowerCase ( other . qualifier ) ) ; } public boolean equals ( Object other ) { return other instanceof VersionNumber & & compareTo ( ( VersionNumber ) other ) = = <int> ; } public int hashCode ( ) { int result = major ; result = <int> * result + minor ; result = <int> * result + micro ; result = <int> * result + patch ; result = <int> * result + Objects . hashCode ( qualifier ) ; return result ; } public String toString ( ) { return scheme . format ( this ) ; } public static VersionNumber version ( int major ) { return new VersionNumber ( major , <int> , <int> , <int> , null , DEFAULT_SCHEME ) ; } public static Scheme scheme ( ) { return DEFAULT_SCHEME ; } public static Scheme withPatchNumber ( ) { return PATCH_SCHEME ; } public static VersionNumber parse ( String versionString ) { return DEFAULT_SCHEME . parse ( versionString ) ; } private String toLowerCase ( @Nullable String string ) { return string = = null ? null : string . toLowerCase ( ) ; } public interface Scheme { public VersionNumber parse ( String value ) ; public String format ( VersionNumber versionNumber ) ; } private abstract static class AbstractScheme implements Scheme { final int depth ; protected AbstractScheme ( int depth ) { this . depth = depth ; } public VersionNumber parse ( String versionString ) { if ( versionString = = null | | versionString . length ( ) = = <int> ) { return UNKNOWN ; } Scanner scanner = new Scanner ( versionString ) ; int major = <int> ; int minor = <int> ; int micro = <int> ; int patch = <int> ; if ( ! scanner . hasDigit ( ) ) { return UNKNOWN ; } major = scanner . scanDigit ( ) ; if ( scanner . isSeparatorAndDigit ( <str> ) ) { scanner . skipSeparator ( ) ; minor = scanner . scanDigit ( ) ; if ( scanner . isSeparatorAndDigit ( <str> ) ) { scanner . skipSeparator ( ) ; micro = scanner . scanDigit ( ) ; if ( depth > <int> & & scanner . isSeparatorAndDigit ( <str> , <str> ) ) { scanner . skipSeparator ( ) ; patch = scanner . scanDigit ( ) ; } } } if ( scanner . isEnd ( ) ) { return new VersionNumber ( major , minor , micro , patch , null , this ) ; } if ( scanner . isQualifier ( ) ) { scanner . skipSeparator ( ) ; return new VersionNumber ( major , minor , micro , patch , scanner . remainder ( ) , this ) ; } return UNKNOWN ; } private static class Scanner { int pos ; final String str ; private Scanner ( String string ) { this . str = string ; } boolean hasDigit ( ) { return pos < str . length ( ) & & Character . isDigit ( str . charAt ( pos ) ) ; } boolean isSeparatorAndDigit ( char . . . separators ) { return pos < str . length ( ) - <int> & & oneOf ( separators ) & & Character . isDigit ( str . charAt ( pos + <int> ) ) ; } private boolean oneOf ( char . . . separators ) { char current = str . charAt ( pos ) ; for ( int i = <int> ; i < separators . length ; i + + ) { char separator = separators [ i ] ; if ( current = = separator ) { return true ; } } return false ; } boolean isQualifier ( ) { return pos < str . length ( ) - <int> & & oneOf ( <str> , <str> ) ; } int scanDigit ( ) { int start = pos ; while ( hasDigit ( ) ) { pos + + ; } return Integer . parseInt ( str . substring ( start , pos ) ) ; } public boolean isEnd ( ) { return pos = = str . length ( ) ; } private boolean skip ( char ch ) { if ( pos < str . length ( ) & & str . charAt ( pos ) = = ch ) { pos + + ; return true ; } return false ; } public void skipSeparator ( ) { pos + + ; } public String remainder ( ) { return pos = = str . length ( ) ? null : str . substring ( pos ) ; } } } private static class DefaultScheme extends AbstractScheme { private static final String VERSION_TEMPLATE = <str> ; public DefaultScheme ( ) { super ( <int> ) ; } public String format ( VersionNumber versionNumber ) { return String . format ( VERSION_TEMPLATE , versionNumber . major , versionNumber . minor , versionNumber . micro , versionNumber . qualifier = = null ? <str> : <str> + versionNumber . qualifier ) ; } } private static class SchemeWithPatchVersion extends AbstractScheme { private static final String VERSION_TEMPLATE = <str> ; private SchemeWithPatchVersion ( ) { super ( <int> ) ; } public String format ( VersionNumber versionNumber ) { return String . format ( VERSION_TEMPLATE , versionNumber . major , versionNumber . minor , versionNumber . micro , versionNumber . patch , versionNumber . qualifier = = null ? <str> : <str> + versionNumber . qualifier ) ; } } } 
