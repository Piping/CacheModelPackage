package com . google . common . collect . testing . features ; import com . google . common . collect . testing . Helpers ; import java . lang . annotation . Annotation ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; public class FeatureUtil { private static Map < AnnotatedElement , Annotation [ ] > annotationCache = new HashMap < AnnotatedElement , Annotation [ ] > ( ) ; private static final Map < Class < ? > , TesterRequirements > classTesterRequirementsCache = new HashMap < Class < ? > , TesterRequirements > ( ) ; public static Set < Feature < ? > > addImpliedFeatures ( Set < Feature < ? > > features ) { if ( ! features . isEmpty ( ) ) { features . addAll ( impliedFeatures ( features ) ) ; } return features ; } public static Set < Feature < ? > > impliedFeatures ( Set < Feature < ? > > features ) { Set < Feature < ? > > implied = new LinkedHashSet < Feature < ? > > ( ) ; for ( Feature < ? > feature : features ) { implied . addAll ( feature . getImpliedFeatures ( ) ) ; } addImpliedFeatures ( implied ) ; return implied ; } public static TesterRequirements getTesterRequirements ( Class < ? > testerClass ) throws ConflictingRequirementsException { synchronized ( classTesterRequirementsCache ) { TesterRequirements requirements = classTesterRequirementsCache . get ( testerClass ) ; if ( requirements = = null ) { requirements = buildTesterRequirements ( testerClass ) ; classTesterRequirementsCache . put ( testerClass , requirements ) ; } return requirements ; } } public static TesterRequirements getTesterRequirements ( Method testerMethod ) throws ConflictingRequirementsException { return buildTesterRequirements ( testerMethod ) ; } static TesterRequirements buildTesterRequirements ( Class < ? > testerClass ) throws ConflictingRequirementsException { final TesterRequirements declaredRequirements = buildDeclaredTesterRequirements ( testerClass ) ; Class < ? > baseClass = testerClass . getSuperclass ( ) ; if ( baseClass = = null ) { return declaredRequirements ; } else { final TesterRequirements clonedBaseRequirements = new TesterRequirements ( getTesterRequirements ( baseClass ) ) ; return incorporateRequirements ( clonedBaseRequirements , declaredRequirements , testerClass ) ; } } static TesterRequirements buildTesterRequirements ( Method testerMethod ) throws ConflictingRequirementsException { TesterRequirements clonedClassRequirements = new TesterRequirements ( getTesterRequirements ( testerMethod . getDeclaringClass ( ) ) ) ; TesterRequirements declaredRequirements = buildDeclaredTesterRequirements ( testerMethod ) ; return incorporateRequirements ( clonedClassRequirements , declaredRequirements , testerMethod ) ; } public static TesterRequirements buildDeclaredTesterRequirements ( AnnotatedElement classOrMethod ) throws ConflictingRequirementsException { TesterRequirements requirements = new TesterRequirements ( ) ; Iterable < Annotation > testerAnnotations = getTesterAnnotations ( classOrMethod ) ; for ( Annotation testerAnnotation : testerAnnotations ) { TesterRequirements moreRequirements = buildTesterRequirements ( testerAnnotation ) ; incorporateRequirements ( requirements , moreRequirements , testerAnnotation ) ; } return requirements ; } public static Iterable < Annotation > getTesterAnnotations ( AnnotatedElement classOrMethod ) { List < Annotation > result = new ArrayList < Annotation > ( ) ; Annotation [ ] annotations ; synchronized ( annotationCache ) { annotations = annotationCache . get ( classOrMethod ) ; if ( annotations = = null ) { annotations = classOrMethod . getDeclaredAnnotations ( ) ; annotationCache . put ( classOrMethod , annotations ) ; } } for ( Annotation a : annotations ) { Class < ? extends Annotation > annotationClass = a . annotationType ( ) ; if ( annotationClass . isAnnotationPresent ( TesterAnnotation . class ) ) { result . add ( a ) ; } } return result ; } private static TesterRequirements buildTesterRequirements ( Annotation testerAnnotation ) throws ConflictingRequirementsException { Class < ? extends Annotation > annotationClass = testerAnnotation . annotationType ( ) ; final Feature < ? > [ ] presentFeatures ; final Feature < ? > [ ] absentFeatures ; try { presentFeatures = ( Feature [ ] ) annotationClass . getMethod ( <str> ) . invoke ( testerAnnotation ) ; absentFeatures = ( Feature [ ] ) annotationClass . getMethod ( <str> ) . invoke ( testerAnnotation ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> , e ) ; } Set < Feature < ? > > allPresentFeatures = addImpliedFeatures ( Helpers . < Feature < ? > > copyToSet ( presentFeatures ) ) ; Set < Feature < ? > > allAbsentFeatures = addImpliedFeatures ( Helpers . < Feature < ? > > copyToSet ( absentFeatures ) ) ; Set < Feature < ? > > conflictingFeatures = intersection ( allPresentFeatures , allAbsentFeatures ) ; if ( ! conflictingFeatures . isEmpty ( ) ) { throw new ConflictingRequirementsException ( <str> + <str> + <str> , conflictingFeatures , testerAnnotation ) ; } return new TesterRequirements ( allPresentFeatures , allAbsentFeatures ) ; } private static TesterRequirements incorporateRequirements ( TesterRequirements requirements , TesterRequirements moreRequirements , Object source ) throws ConflictingRequirementsException { Set < Feature < ? > > presentFeatures = requirements . getPresentFeatures ( ) ; Set < Feature < ? > > absentFeatures = requirements . getAbsentFeatures ( ) ; Set < Feature < ? > > morePresentFeatures = moreRequirements . getPresentFeatures ( ) ; Set < Feature < ? > > moreAbsentFeatures = moreRequirements . getAbsentFeatures ( ) ; checkConflict ( <str> , absentFeatures , <str> , morePresentFeatures , source ) ; checkConflict ( <str> , presentFeatures , <str> , moreAbsentFeatures , source ) ; presentFeatures . addAll ( morePresentFeatures ) ; absentFeatures . addAll ( moreAbsentFeatures ) ; return requirements ; } private static void checkConflict ( String earlierRequirement , Set < Feature < ? > > earlierFeatures , String newRequirement , Set < Feature < ? > > newFeatures , Object source ) throws ConflictingRequirementsException { Set < Feature < ? > > conflictingFeatures ; conflictingFeatures = intersection ( newFeatures , earlierFeatures ) ; if ( ! conflictingFeatures . isEmpty ( ) ) { throw new ConflictingRequirementsException ( String . format ( Locale . ROOT , <str> + <str> , newRequirement , earlierRequirement ) , conflictingFeatures , source ) ; } } @SuppressWarnings ( <str> ) public static < T > Set < T > intersection ( Set < ? extends T > set1 , Set < ? extends T > set2 ) { return intersection ( new Set [ ] { set1 , set2 } ) ; } public static < T > Set < T > intersection ( Set < ? extends T > . . . sets ) { if ( sets . length = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } Set < T > results = Helpers . copyToSet ( sets [ <int> ] ) ; for ( int i = <int> ; i < sets . length ; i + + ) { Set < ? extends T > set = sets [ i ] ; results . retainAll ( set ) ; } return results ; } } 
