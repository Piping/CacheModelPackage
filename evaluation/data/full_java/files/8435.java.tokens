package org . elasticsearch . search . aggregations ; import com . carrotsearch . hppc . IntIntHashMap ; import com . carrotsearch . hppc . IntIntMap ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . search . aggregations . bucket . missing . Missing ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . HashMap ; import java . util . Map ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . missing ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . CoreMatchers . equalTo ; public class MetaDataIT extends ESIntegTestCase { public void testMetaDataSetOnAggregationResult ( ) throws Exception { createIndex ( <str> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ randomInt ( <int> ) ] ; IntIntMap values = new IntIntHashMap ( ) ; long missingValues = <int> ; for ( int i = <int> ; i < builders . length ; i + + ) { String name = <str> + randomIntBetween ( <int> , <int> ) ; if ( rarely ( ) ) { missingValues + + ; builders [ i ] = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , name ) . endObject ( ) ) ; } else { int value = randomIntBetween ( <int> , <int> ) ; values . put ( value , values . getOrDefault ( value , <int> ) + <int> ) ; builders [ i ] = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , name ) . field ( <str> , value ) . endObject ( ) ) ; } } indexRandom ( true , builders ) ; ensureSearchable ( ) ; final Map < String , Object > nestedMetaData = new HashMap < String , Object > ( ) { { put ( <str> , <str> ) ; } } ; Map < String , Object > missingValueMetaData = new HashMap < String , Object > ( ) { { put ( <str> , <str> ) ; put ( <str> , <float> ) ; put ( <str> , true ) ; put ( <str> , nestedMetaData ) ; } } ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( missing ( <str> ) . field ( <str> ) . setMetaData ( missingValueMetaData ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Aggregations aggs = response . getAggregations ( ) ; assertNotNull ( aggs ) ; Missing missing = aggs . get ( <str> ) ; assertNotNull ( missing ) ; assertThat ( missing . getDocCount ( ) , equalTo ( missingValues ) ) ; Map < String , Object > returnedMetaData = missing . getMetaData ( ) ; assertNotNull ( returnedMetaData ) ; assertEquals ( <int> , returnedMetaData . size ( ) ) ; assertEquals ( <str> , returnedMetaData . get ( <str> ) ) ; assertEquals ( <float> , returnedMetaData . get ( <str> ) ) ; assertEquals ( true , returnedMetaData . get ( <str> ) ) ; Object nestedObject = returnedMetaData . get ( <str> ) ; assertNotNull ( nestedObject ) ; Map < String , Object > nestedMap = ( Map < String , Object > ) nestedObject ; assertEquals ( <str> , nestedMap . get ( <str> ) ) ; } } 
