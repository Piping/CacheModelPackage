package org . gradle . foundation . output . definitions ; import org . gradle . foundation . output . FileLink ; import java . io . File ; import java . util . List ; public class PrefixedFileLinkDefinition implements FileLinkDefinition { private String expression ; private String prefix ; private String lineNumberDelimiter ; private String extension ; private String name ; public PrefixedFileLinkDefinition ( String name , String prefix , String extension ) { this ( name , prefix , extension , null ) ; } public PrefixedFileLinkDefinition ( String name , String prefix , String extension , String lineNumberDelimiter ) { this . name = name ; this . prefix = prefix ; this . lineNumberDelimiter = lineNumberDelimiter ; this . extension = extension ; String regExLiteralPrefix = quoteLiteral ( prefix ) ; this . expression = regExLiteralPrefix + <str> + extension ; if ( lineNumberDelimiter ! = null ) { this . expression + = generateLineNumberExpression ( lineNumberDelimiter ) ; } } public String getName ( ) { return name ; } protected String generateLineNumberExpression ( String lineNumberDelimiter ) { return quoteLiteral ( lineNumberDelimiter ) + <str> ; } public static String quoteLiteral ( String literal ) { StringBuilder builder = new StringBuilder ( ) ; for ( int index = <int> ; index < literal . length ( ) ; index + + ) { char c = literal . charAt ( index ) ; if ( isEscapedCharater ( c ) ) { builder . append ( <str> ) . append ( c ) ; } else { builder . append ( c ) ; } } return builder . toString ( ) ; } private static boolean isEscapedCharater ( char c ) { return c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> | | c = = <str> ; } public String getSearchExpression ( ) { return expression ; } public int parseFileLink ( String fullSearchTest , String matchedText , int start , int end , boolean verifyFileExists , List < FileLink > fileLinks ) { int extensionIndex = matchedText . lastIndexOf ( extension ) ; if ( extensionIndex = = - <int> ) { return - <int> ; } int prefixIndex = getStartOfFile ( matchedText ) ; int realPathEnd = extensionIndex + extension . length ( ) ; String path = matchedText . substring ( prefixIndex , realPathEnd ) . trim ( ) ; File file = new File ( path ) ; if ( verifyFileExists & & ! file . exists ( ) ) { return - <int> ; } String remainder = matchedText . substring ( realPathEnd ) ; int lineNumber = getLineNumber ( remainder , lineNumberDelimiter ) ; fileLinks . add ( new FileLink ( file , start + prefixIndex , end , lineNumber , this ) ) ; return end ; } private int getStartOfFile ( String matchedText ) { int index = prefix . length ( ) ; while ( Character . isWhitespace ( matchedText . charAt ( index ) ) ) { index + + ; } return index ; } public static int getLineNumber ( String textAfterPath , String lineNumberDelimiter ) { if ( lineNumberDelimiter ! = null ) { int lineDelimterIndex = textAfterPath . indexOf ( lineNumberDelimiter ) ; if ( lineDelimterIndex ! = - <int> ) { String lineNumberText = textAfterPath . substring ( lineDelimterIndex + lineNumberDelimiter . length ( ) ) ; lineNumberText = lineNumberText . trim ( ) ; lineNumberText = getConsecutiveNumbers ( lineNumberText ) ; if ( ! <str> . equals ( lineNumberText ) ) { return Integer . parseInt ( lineNumberText ) ; } } } return - <int> ; } public static String getConsecutiveNumbers ( String text ) { StringBuilder numbersOnly = new StringBuilder ( ) ; boolean keepLooking = true ; int index = <int> ; while ( keepLooking & & index < text . length ( ) ) { char c = text . charAt ( index ) ; if ( Character . isDigit ( c ) ) { numbersOnly . append ( c ) ; } else { keepLooking = false ; } index + + ; } return numbersOnly . toString ( ) ; } @Override public String toString ( ) { return <str> + name + <str> + <str> + expression + <str> + <str> + prefix + <str> + <str> + lineNumberDelimiter + <str> + <str> + extension + <str> ; } } 
