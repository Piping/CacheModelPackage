package org . apache . cassandra . db ; import java . net . InetAddress ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Iterator ; import java . util . TreeSet ; import com . google . common . collect . Lists ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . cache . RowCacheKey ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . marshal . IntegerType ; import org . apache . cassandra . db . partitions . CachedPartition ; import org . apache . cassandra . dht . Bounds ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . dht . ByteOrderedPartitioner . BytesToken ; import org . apache . cassandra . locator . TokenMetadata ; import org . apache . cassandra . metrics . ClearableHistogram ; import org . apache . cassandra . schema . CachingParams ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . CacheService ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . junit . Assert . * ; public class RowCacheTest { private static final String KEYSPACE_CACHED = <str> ; private static final String CF_CACHED = <str> ; private static final String CF_CACHEDINT = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE_CACHED , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE_CACHED , CF_CACHED ) . caching ( CachingParams . CACHE_EVERYTHING ) , SchemaLoader . standardCFMD ( KEYSPACE_CACHED , CF_CACHEDINT , <int> , IntegerType . instance ) . caching ( new CachingParams ( true , <int> ) ) ) ; } @AfterClass public static void cleanup ( ) { SchemaLoader . cleanupSavedCaches ( ) ; } @Test public void testRoundTrip ( ) throws Exception { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE_CACHED ) ; String cf = <str> ; ColumnFamilyStore cachedStore = keyspace . getColumnFamilyStore ( cf ) ; long startRowCacheHits = cachedStore . metric . rowCacheHit . getCount ( ) ; long startRowCacheOutOfRange = cachedStore . metric . rowCacheHitOutOfRange . getCount ( ) ; CacheService . instance . invalidateRowCache ( ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; ByteBuffer key = ByteBufferUtil . bytes ( <str> ) ; DecoratedKey dk = cachedStore . decorateKey ( key ) ; RowCacheKey rck = new RowCacheKey ( cachedStore . metadata . ksAndCFName , dk ) ; RowUpdateBuilder rub = new RowUpdateBuilder ( cachedStore . metadata , System . currentTimeMillis ( ) , key ) ; rub . clustering ( String . valueOf ( <int> ) ) ; rub . add ( <str> , ByteBufferUtil . bytes ( <str> + <int> ) ) ; rub . build ( ) . applyUnsafe ( ) ; Util . getAll ( Util . cmd ( cachedStore , dk ) . withLimit ( <int> ) . build ( ) ) ; assertEquals ( startRowCacheHits , cachedStore . metric . rowCacheHit . getCount ( ) ) ; Util . getAll ( Util . cmd ( cachedStore , dk ) . withLimit ( <int> ) . build ( ) ) ; assertEquals ( + + startRowCacheHits , cachedStore . metric . rowCacheHit . getCount ( ) ) ; assertEquals ( startRowCacheOutOfRange , cachedStore . metric . rowCacheHitOutOfRange . getCount ( ) ) ; CachedPartition cachedCf = ( CachedPartition ) CacheService . instance . rowCache . get ( rck ) ; assertEquals ( <int> , cachedCf . rowCount ( ) ) ; for ( Unfiltered unfiltered : Util . once ( cachedCf . unfilteredIterator ( ColumnFilter . selection ( cachedCf . columns ( ) ) , Slices . ALL , false ) ) ) { Row r = ( Row ) unfiltered ; for ( ColumnData c : r ) { assertEquals ( ( ( Cell ) c ) . value ( ) , ByteBufferUtil . bytes ( <str> + <int> ) ) ; } } cachedStore . truncateBlocking ( ) ; } @Test public void testRowCache ( ) throws Exception { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE_CACHED ) ; ColumnFamilyStore cachedStore = keyspace . getColumnFamilyStore ( CF_CACHED ) ; CacheService . instance . invalidateRowCache ( ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; SchemaLoader . insertData ( KEYSPACE_CACHED , CF_CACHED , <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { DecoratedKey key = Util . dk ( <str> + i ) ; Util . getAll ( Util . cmd ( cachedStore , key ) . build ( ) ) ; assert CacheService . instance . rowCache . size ( ) = = i + <int> ; assert cachedStore . containsCachedParition ( key ) ; CachedPartition cp = cachedStore . getRawCachedPartition ( key ) ; try ( UnfilteredRowIterator ai = cp . unfilteredIterator ( ColumnFilter . selection ( cp . columns ( ) ) , Slices . ALL , false ) ) { assert ai . hasNext ( ) ; Row r = ( Row ) ai . next ( ) ; assertFalse ( ai . hasNext ( ) ) ; Iterator < Cell > ci = r . cells ( ) . iterator ( ) ; assert ( ci . hasNext ( ) ) ; Cell cell = ci . next ( ) ; assert cell . column ( ) . name . bytes . equals ( ByteBufferUtil . bytes ( <str> ) ) ; assert cell . value ( ) . equals ( ByteBufferUtil . bytes ( <str> + i ) ) ; } } SchemaLoader . insertData ( KEYSPACE_CACHED , CF_CACHED , <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { DecoratedKey key = Util . dk ( <str> + i ) ; Util . getAll ( Util . cmd ( cachedStore , key ) . build ( ) ) ; assert cachedStore . containsCachedParition ( key ) ; CachedPartition cp = cachedStore . getRawCachedPartition ( key ) ; try ( UnfilteredRowIterator ai = cp . unfilteredIterator ( ColumnFilter . selection ( cp . columns ( ) ) , Slices . ALL , false ) ) { assert ai . hasNext ( ) ; Row r = ( Row ) ai . next ( ) ; assertFalse ( ai . hasNext ( ) ) ; Iterator < Cell > ci = r . cells ( ) . iterator ( ) ; assert ( ci . hasNext ( ) ) ; Cell cell = ci . next ( ) ; assert cell . column ( ) . name . bytes . equals ( ByteBufferUtil . bytes ( <str> ) ) ; assert cell . value ( ) . equals ( ByteBufferUtil . bytes ( <str> + i ) ) ; } } int keysLeft = <int> ; for ( int i = <int> ; i > = <int> ; i - - ) { cachedStore . invalidateCachedPartition ( Util . dk ( <str> + i ) ) ; assert CacheService . instance . rowCache . size ( ) = = keysLeft ; keysLeft - - ; } CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; } @Test public void testRowCacheLoad ( ) throws Exception { CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; rowCacheLoad ( <int> , Integer . MAX_VALUE , <int> ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; } @Test public void testRowCacheCleanup ( ) throws Exception { StorageService . instance . initServer ( <int> ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; rowCacheLoad ( <int> , Integer . MAX_VALUE , <int> ) ; ColumnFamilyStore store = Keyspace . open ( KEYSPACE_CACHED ) . getColumnFamilyStore ( CF_CACHED ) ; assertEquals ( CacheService . instance . rowCache . size ( ) , <int> ) ; store . cleanupCache ( ) ; assertEquals ( CacheService . instance . rowCache . size ( ) , <int> ) ; TokenMetadata tmd = StorageService . instance . getTokenMetadata ( ) ; byte [ ] tk1 , tk2 ; tk1 = <str> . getBytes ( ) ; tk2 = <str> . getBytes ( ) ; tmd . updateNormalToken ( new BytesToken ( tk1 ) , InetAddress . getByName ( <str> ) ) ; tmd . updateNormalToken ( new BytesToken ( tk2 ) , InetAddress . getByName ( <str> ) ) ; store . cleanupCache ( ) ; assertEquals ( <int> , CacheService . instance . rowCache . size ( ) ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; } @Test public void testInvalidateRowCache ( ) throws Exception { StorageService . instance . initServer ( <int> ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; rowCacheLoad ( <int> , Integer . MAX_VALUE , <int> ) ; ColumnFamilyStore store = Keyspace . open ( KEYSPACE_CACHED ) . getColumnFamilyStore ( CF_CACHED ) ; assertEquals ( CacheService . instance . rowCache . size ( ) , <int> ) ; ArrayList < Bounds < Token > > subranges = getBounds ( <int> ) ; ArrayList < Bounds < Token > > boundsToInvalidate = Lists . newArrayList ( subranges . get ( <int> ) , subranges . get ( <int> ) , subranges . get ( <int> ) ) ; int invalidatedKeys = store . invalidateRowCache ( boundsToInvalidate ) ; assertEquals ( <int> , invalidatedKeys ) ; assertEquals ( CacheService . instance . rowCache . size ( ) , <int> ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; } private ArrayList < Bounds < Token > > getBounds ( int nElements ) { ColumnFamilyStore store = Keyspace . open ( KEYSPACE_CACHED ) . getColumnFamilyStore ( CF_CACHED ) ; TreeSet < DecoratedKey > orderedKeys = new TreeSet < > ( ) ; for ( Iterator < RowCacheKey > it = CacheService . instance . rowCache . keyIterator ( ) ; it . hasNext ( ) ; ) orderedKeys . add ( store . decorateKey ( ByteBuffer . wrap ( it . next ( ) . key ) ) ) ; ArrayList < Bounds < Token > > boundsToInvalidate = new ArrayList < > ( ) ; Iterator < DecoratedKey > iterator = orderedKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token startRange = iterator . next ( ) . getToken ( ) ; for ( int i = <int> ; i < nElements - <int> ; i + + ) iterator . next ( ) ; Token endRange = iterator . next ( ) . getToken ( ) ; boundsToInvalidate . add ( new Bounds < > ( startRange , endRange ) ) ; } return boundsToInvalidate ; } @Test public void testRowCachePartialLoad ( ) throws Exception { CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; rowCacheLoad ( <int> , <int> , <int> ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; } @Test public void testRowCacheDropSaveLoad ( ) throws Exception { CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; rowCacheLoad ( <int> , <int> , <int> ) ; CacheService . instance . rowCache . submitWrite ( Integer . MAX_VALUE ) . get ( ) ; Keyspace instance = Schema . instance . removeKeyspaceInstance ( KEYSPACE_CACHED ) ; try { CacheService . instance . rowCache . size ( ) ; CacheService . instance . rowCache . clear ( ) ; CacheService . instance . rowCache . loadSaved ( ) ; int after = CacheService . instance . rowCache . size ( ) ; assertEquals ( <int> , after ) ; } finally { Schema . instance . storeKeyspaceInstance ( instance ) ; } } @Test public void testRowCacheDisabled ( ) throws Exception { CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; rowCacheLoad ( <int> , <int> , <int> ) ; CacheService . instance . rowCache . submitWrite ( Integer . MAX_VALUE ) . get ( ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; CacheService . instance . rowCache . size ( ) ; CacheService . instance . rowCache . clear ( ) ; CacheService . instance . rowCache . loadSaved ( ) ; int after = CacheService . instance . rowCache . size ( ) ; assertEquals ( <int> , after ) ; } @Test public void testRowCacheRange ( ) { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE_CACHED ) ; String cf = <str> ; ColumnFamilyStore cachedStore = keyspace . getColumnFamilyStore ( cf ) ; long startRowCacheHits = cachedStore . metric . rowCacheHit . getCount ( ) ; long startRowCacheOutOfRange = cachedStore . metric . rowCacheHitOutOfRange . getCount ( ) ; CacheService . instance . invalidateRowCache ( ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; ByteBuffer key = ByteBufferUtil . bytes ( <str> ) ; DecoratedKey dk = cachedStore . decorateKey ( key ) ; RowCacheKey rck = new RowCacheKey ( cachedStore . metadata . ksAndCFName , dk ) ; String values [ ] = new String [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) { RowUpdateBuilder rub = new RowUpdateBuilder ( cachedStore . metadata , System . currentTimeMillis ( ) , key ) ; rub . clustering ( String . valueOf ( i ) ) ; values [ i ] = <str> + i ; rub . add ( <str> , ByteBufferUtil . bytes ( values [ i ] ) ) ; rub . build ( ) . applyUnsafe ( ) ; } Arrays . sort ( values ) ; Util . getAll ( Util . cmd ( cachedStore , dk ) . withLimit ( <int> ) . build ( ) ) ; assertEquals ( startRowCacheHits , cachedStore . metric . rowCacheHit . getCount ( ) ) ; Util . getAll ( Util . cmd ( cachedStore , dk ) . withLimit ( <int> ) . build ( ) ) ; assertEquals ( + + startRowCacheHits , cachedStore . metric . rowCacheHit . getCount ( ) ) ; assertEquals ( startRowCacheOutOfRange , cachedStore . metric . rowCacheHitOutOfRange . getCount ( ) ) ; Util . getAll ( Util . cmd ( cachedStore , dk ) . fromIncl ( String . valueOf ( <int> ) ) . toExcl ( String . valueOf ( <int> ) ) . build ( ) ) ; assertEquals ( startRowCacheHits , cachedStore . metric . rowCacheHit . getCount ( ) ) ; assertEquals ( + + startRowCacheOutOfRange , cachedStore . metric . rowCacheHitOutOfRange . getCount ( ) ) ; Util . getAll ( Util . cmd ( cachedStore , dk ) . withLimit ( <int> ) . build ( ) ) ; assertEquals ( startRowCacheHits , cachedStore . metric . rowCacheHit . getCount ( ) ) ; assertEquals ( + + startRowCacheOutOfRange , cachedStore . metric . rowCacheHitOutOfRange . getCount ( ) ) ; CacheService . instance . invalidateRowCache ( ) ; Util . getAll ( Util . cmd ( cachedStore , dk ) . withLimit ( <int> ) . build ( ) ) ; assertEquals ( startRowCacheHits , cachedStore . metric . rowCacheHit . getCount ( ) ) ; CachedPartition cachedCf = ( CachedPartition ) CacheService . instance . rowCache . get ( rck ) ; assertEquals ( cachedCf . rowCount ( ) , <int> ) ; int i = <int> ; for ( Unfiltered unfiltered : Util . once ( cachedCf . unfilteredIterator ( ColumnFilter . selection ( cachedCf . columns ( ) ) , Slices . ALL , false ) ) ) { Row r = ( Row ) unfiltered ; assertEquals ( r . clustering ( ) . get ( <int> ) , ByteBufferUtil . bytes ( values [ i ] . substring ( <int> ) ) ) ; for ( ColumnData c : r ) { assertEquals ( ( ( Cell ) c ) . value ( ) , ByteBufferUtil . bytes ( values [ i ] ) ) ; } i + + ; } cachedStore . truncateBlocking ( ) ; } @Test public void testSSTablesPerReadHistogramWhenRowCache ( ) { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE_CACHED ) ; ColumnFamilyStore cachedStore = keyspace . getColumnFamilyStore ( CF_CACHED ) ; CacheService . instance . invalidateRowCache ( ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; SchemaLoader . insertData ( KEYSPACE_CACHED , CF_CACHED , <int> , <int> ) ; cachedStore . forceBlockingFlush ( ) ; ( ( ClearableHistogram ) cachedStore . metric . sstablesPerReadHistogram . cf ) . clear ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { DecoratedKey key = Util . dk ( <str> + i ) ; Util . getAll ( Util . cmd ( cachedStore , key ) . build ( ) ) ; long count_before = cachedStore . metric . sstablesPerReadHistogram . cf . getCount ( ) ; Util . getAll ( Util . cmd ( cachedStore , key ) . build ( ) ) ; long count_after = cachedStore . metric . sstablesPerReadHistogram . cf . getCount ( ) ; double belowMedian = cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getValue ( <float> ) ; double mean_after = cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMean ( ) ; assertEquals ( <str> , count_before + <int> , count_after ) ; assertTrue ( <str> + <str> + belowMedian + <str> , belowMedian < <float> ) ; assertTrue ( <str> + <str> + mean_after + <str> , mean_after < <float> & & mean_after > <float> ) ; } assertEquals ( <str> , <int> , cachedStore . metric . sstablesPerReadHistogram . cf . getSnapshot ( ) . getMin ( ) ) ; CacheService . instance . setRowCacheCapacityInMB ( <int> ) ; } public void rowCacheLoad ( int totalKeys , int keysToSave , int offset ) throws Exception { CompactionManager . instance . disableAutoCompaction ( ) ; ColumnFamilyStore store = Keyspace . open ( KEYSPACE_CACHED ) . getColumnFamilyStore ( CF_CACHED ) ; CacheService . instance . invalidateRowCache ( ) ; assertEquals ( <int> , CacheService . instance . rowCache . size ( ) ) ; SchemaLoader . insertData ( KEYSPACE_CACHED , CF_CACHED , offset , totalKeys ) ; readData ( KEYSPACE_CACHED , CF_CACHED , offset , totalKeys ) ; assertEquals ( totalKeys , CacheService . instance . rowCache . size ( ) ) ; CacheService . instance . rowCache . submitWrite ( keysToSave ) . get ( ) ; CacheService . instance . invalidateRowCache ( ) ; assertEquals ( <int> , CacheService . instance . rowCache . size ( ) ) ; assertEquals ( keysToSave = = Integer . MAX_VALUE ? totalKeys : keysToSave , CacheService . instance . rowCache . loadSaved ( ) ) ; } private static void readData ( String keyspace , String columnFamily , int offset , int numberOfRows ) { ColumnFamilyStore store = Keyspace . open ( keyspace ) . getColumnFamilyStore ( columnFamily ) ; CFMetaData cfm = Schema . instance . getCFMetaData ( keyspace , columnFamily ) ; for ( int i = offset ; i < offset + numberOfRows ; i + + ) { DecoratedKey key = Util . dk ( <str> + i ) ; Clustering cl = new Clustering ( ByteBufferUtil . bytes ( <str> + i ) ) ; Util . getAll ( Util . cmd ( store , key ) . build ( ) ) ; } } } 
