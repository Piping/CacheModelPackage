package org . apache . cassandra . db . lifecycle ; import java . util . * ; import com . google . common . base . Predicate ; import com . google . common . collect . * ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . Throwables ; import static com . google . common . base . Predicates . * ; import static com . google . common . collect . Iterables . any ; import static com . google . common . collect . Iterables . concat ; import static com . google . common . collect . Iterables . filter ; import static com . google . common . collect . Iterables . getFirst ; import static org . apache . cassandra . utils . Throwables . merge ; class Helpers { static < T > Set < T > replace ( Set < T > original , Set < T > remove , Iterable < T > add ) { return ImmutableSet . copyOf ( replace ( identityMap ( original ) , remove , add ) . keySet ( ) ) ; } static < T > Map < T , T > replace ( Map < T , T > original , Set < T > remove , Iterable < T > add ) { for ( T reader : remove ) assert original . get ( reader ) = = reader ; assert ! any ( add , and ( not ( in ( remove ) ) , in ( original . keySet ( ) ) ) ) : String . format ( <str> , original . keySet ( ) , remove , add ) ; Map < T , T > result = identityMap ( concat ( add , filter ( original . keySet ( ) , not ( in ( remove ) ) ) ) ) ; assert result . size ( ) = = original . size ( ) - remove . size ( ) + Iterables . size ( add ) : String . format ( <str> , original . size ( ) - remove . size ( ) + Iterables . size ( add ) , result . size ( ) , remove , add , original . keySet ( ) ) ; return result ; } static void setupOnline ( Iterable < SSTableReader > readers ) { for ( SSTableReader reader : readers ) reader . setupOnline ( ) ; } static Throwable setReplaced ( Iterable < SSTableReader > readers , Throwable accumulate ) { for ( SSTableReader reader : readers ) { try { reader . setReplaced ( ) ; } catch ( Throwable t ) { accumulate = merge ( accumulate , t ) ; } } return accumulate ; } static void checkNotReplaced ( Iterable < SSTableReader > readers ) { for ( SSTableReader reader : readers ) assert ! reader . isReplaced ( ) ; } static Throwable markObsolete ( List < LogTransaction . Obsoletion > obsoletions , Throwable accumulate ) { if ( obsoletions = = null | | obsoletions . isEmpty ( ) ) return accumulate ; for ( LogTransaction . Obsoletion obsoletion : obsoletions ) { try { obsoletion . reader . markObsolete ( obsoletion . tidier ) ; } catch ( Throwable t ) { accumulate = merge ( accumulate , t ) ; } } return accumulate ; } static Throwable prepareForObsoletion ( Iterable < SSTableReader > readers , LogTransaction txnLogs , List < LogTransaction . Obsoletion > obsoletions , Throwable accumulate ) { for ( SSTableReader reader : readers ) { try { obsoletions . add ( new LogTransaction . Obsoletion ( reader , txnLogs . obsoleted ( reader ) ) ) ; } catch ( Throwable t ) { accumulate = Throwables . merge ( accumulate , t ) ; } } return accumulate ; } static Throwable abortObsoletion ( List < LogTransaction . Obsoletion > obsoletions , Throwable accumulate ) { if ( obsoletions = = null | | obsoletions . isEmpty ( ) ) return accumulate ; for ( LogTransaction . Obsoletion obsoletion : obsoletions ) { try { obsoletion . tidier . abort ( ) ; } catch ( Throwable t ) { accumulate = merge ( accumulate , t ) ; } } return accumulate ; } static < T > Map < T , T > identityMap ( Iterable < T > values ) { ImmutableMap . Builder < T , T > builder = ImmutableMap . < T , T > builder ( ) ; for ( T t : values ) builder . put ( t , t ) ; return builder . build ( ) ; } static < T > Iterable < T > concatUniq ( Set < T > . . . sets ) { List < Predicate < T > > notIn = new ArrayList < > ( sets . length ) ; for ( Set < T > set : sets ) notIn . add ( not ( in ( set ) ) ) ; List < Iterable < T > > results = new ArrayList < > ( sets . length ) ; for ( int i = <int> ; i < sets . length ; i + + ) results . add ( filter ( sets [ i ] , and ( notIn . subList ( <int> , i ) ) ) ) ; return concat ( results ) ; } static < T > Predicate < T > notIn ( Set < T > . . . sets ) { return not ( orIn ( sets ) ) ; } static < T > Predicate < T > orIn ( Collection < T > . . . sets ) { Predicate < T > [ ] orIn = new Predicate [ sets . length ] ; for ( int i = <int> ; i < orIn . length ; i + + ) orIn [ i ] = in ( sets [ i ] ) ; return or ( orIn ) ; } static < T > Iterable < T > filterOut ( Iterable < T > filter , Set < T > . . . inNone ) { return filter ( filter , notIn ( inNone ) ) ; } static < T > Iterable < T > filterIn ( Iterable < T > filter , Set < T > . . . inAny ) { return filter ( filter , orIn ( inAny ) ) ; } static Set < SSTableReader > emptySet ( ) { return Collections . emptySet ( ) ; } static < T > T select ( T t , Collection < T > col ) { if ( col instanceof Set & & ! col . contains ( t ) ) return null ; return getFirst ( filter ( col , equalTo ( t ) ) , null ) ; } static < T > T selectFirst ( T t , Collection < T > . . . sets ) { for ( Collection < T > set : sets ) { T select = select ( t , set ) ; if ( select ! = null ) return select ; } return null ; } static < T > Predicate < T > idIn ( Set < T > set ) { return idIn ( identityMap ( set ) ) ; } static < T > Predicate < T > idIn ( final Map < T , T > identityMap ) { return new Predicate < T > ( ) { public boolean apply ( T t ) { return identityMap . get ( t ) = = t ; } } ; } } 
