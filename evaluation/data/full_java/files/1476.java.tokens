package org . apache . cassandra . db . compaction ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Set ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . util . concurrent . RateLimiter ; import org . junit . BeforeClass ; import org . junit . After ; import org . junit . Test ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . db . rows . EncodingStats ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . dht . ByteOrderedPartitioner . BytesToken ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . * ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . concurrent . Refs ; import org . apache . cassandra . UpdateBuilder ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; public class AntiCompactionTest { private static final String KEYSPACE1 = <str> ; private static final String CF = <str> ; private static CFMetaData cfm ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; cfm = SchemaLoader . standardCFMD ( KEYSPACE1 , CF ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , cfm ) ; } @After public void truncateCF ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; store . truncateBlocking ( ) ; } @Test public void antiCompactOne ( ) throws Exception { ColumnFamilyStore store = prepareColumnFamilyStore ( ) ; Collection < SSTableReader > sstables = getUnrepairedSSTables ( store ) ; assertEquals ( store . getLiveSSTables ( ) . size ( ) , sstables . size ( ) ) ; Range < Token > range = new Range < Token > ( new BytesToken ( <str> . getBytes ( ) ) , new BytesToken ( <str> . getBytes ( ) ) ) ; List < Range < Token > > ranges = Arrays . asList ( range ) ; int repairedKeys = <int> ; int nonRepairedKeys = <int> ; try ( LifecycleTransaction txn = store . getTracker ( ) . tryModify ( sstables , OperationType . ANTICOMPACTION ) ; Refs < SSTableReader > refs = Refs . ref ( sstables ) ) { if ( txn = = null ) throw new IllegalStateException ( ) ; long repairedAt = <int> ; CompactionManager . instance . performAnticompaction ( store , ranges , refs , txn , repairedAt ) ; } assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { try ( ISSTableScanner scanner = sstable . getScanner ( ( RateLimiter ) null ) ) { while ( scanner . hasNext ( ) ) { UnfilteredRowIterator row = scanner . next ( ) ; if ( sstable . isRepaired ( ) ) { assertTrue ( range . contains ( row . partitionKey ( ) . getToken ( ) ) ) ; repairedKeys + + ; } else { assertFalse ( range . contains ( row . partitionKey ( ) . getToken ( ) ) ) ; nonRepairedKeys + + ; } } } } for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { assertFalse ( sstable . isMarkedCompacted ( ) ) ; assertEquals ( <int> , sstable . selfRef ( ) . globalCount ( ) ) ; } assertEquals ( <int> , store . getTracker ( ) . getCompacting ( ) . size ( ) ) ; assertEquals ( repairedKeys , <int> ) ; assertEquals ( nonRepairedKeys , <int> ) ; } @Test public void antiCompactionSizeTest ( ) throws InterruptedException , IOException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; cfs . disableAutoCompaction ( ) ; SSTableReader s = writeFile ( cfs , <int> ) ; cfs . addSSTable ( s ) ; long origSize = s . bytesOnDisk ( ) ; Range < Token > range = new Range < Token > ( new BytesToken ( ByteBufferUtil . bytes ( <int> ) ) , new BytesToken ( ByteBufferUtil . bytes ( <int> ) ) ) ; Collection < SSTableReader > sstables = cfs . getLiveSSTables ( ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( sstables , OperationType . ANTICOMPACTION ) ; Refs < SSTableReader > refs = Refs . ref ( sstables ) ) { CompactionManager . instance . performAnticompaction ( cfs , Arrays . asList ( range ) , refs , txn , <int> ) ; } long sum = <int> ; long rows = <int> ; for ( SSTableReader x : cfs . getLiveSSTables ( ) ) { sum + = x . bytesOnDisk ( ) ; rows + = x . getTotalRows ( ) ; } assertEquals ( sum , cfs . metric . liveDiskSpaceUsed . getCount ( ) ) ; assertEquals ( rows , <int> * ( <int> * <int> ) ) ; assertEquals ( origSize , cfs . metric . liveDiskSpaceUsed . getCount ( ) , <int> ) ; } private SSTableReader writeFile ( ColumnFamilyStore cfs , int count ) { File dir = cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) ; String filename = cfs . getSSTablePath ( dir ) ; try ( SSTableTxnWriter writer = SSTableTxnWriter . create ( cfs , filename , <int> , <int> , new SerializationHeader ( true , cfm , cfm . partitionColumns ( ) , EncodingStats . NO_STATS ) ) ) { for ( int i = <int> ; i < count ; i + + ) { UpdateBuilder builder = UpdateBuilder . create ( cfm , ByteBufferUtil . bytes ( i ) ) ; for ( int j = <int> ; j < count * <int> ; j + + ) builder . newRow ( <str> + j ) . add ( <str> , <str> ) ; writer . append ( builder . build ( ) . unfilteredIterator ( ) ) ; } Collection < SSTableReader > sstables = writer . finish ( true ) ; assertNotNull ( sstables ) ; assertEquals ( <int> , sstables . size ( ) ) ; return sstables . iterator ( ) . next ( ) ; } } public void generateSStable ( ColumnFamilyStore store , String Suffix ) { for ( int i = <int> ; i < <int> ; i + + ) { String localSuffix = Integer . toString ( i ) ; new RowUpdateBuilder ( cfm , System . currentTimeMillis ( ) , localSuffix + <str> + Suffix ) . clustering ( <str> ) . add ( <str> , <str> + localSuffix ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; } @Test public void antiCompactTenSTC ( ) throws InterruptedException , IOException { antiCompactTen ( <str> ) ; } @Test public void antiCompactTenLC ( ) throws InterruptedException , IOException { antiCompactTen ( <str> ) ; } public void antiCompactTen ( String compactionStrategy ) throws InterruptedException , IOException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; store . disableAutoCompaction ( ) ; for ( int table = <int> ; table < <int> ; table + + ) { generateSStable ( store , Integer . toString ( table ) ) ; } Collection < SSTableReader > sstables = getUnrepairedSSTables ( store ) ; assertEquals ( store . getLiveSSTables ( ) . size ( ) , sstables . size ( ) ) ; Range < Token > range = new Range < Token > ( new BytesToken ( <str> . getBytes ( ) ) , new BytesToken ( <str> . getBytes ( ) ) ) ; List < Range < Token > > ranges = Arrays . asList ( range ) ; long repairedAt = <int> ; try ( LifecycleTransaction txn = store . getTracker ( ) . tryModify ( sstables , OperationType . ANTICOMPACTION ) ; Refs < SSTableReader > refs = Refs . ref ( sstables ) ) { CompactionManager . instance . performAnticompaction ( store , ranges , refs , txn , repairedAt ) ; } assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; int repairedKeys = <int> ; int nonRepairedKeys = <int> ; for ( SSTableReader sstable : store . getLiveSSTables ( ) ) { try ( ISSTableScanner scanner = sstable . getScanner ( ( RateLimiter ) null ) ) { while ( scanner . hasNext ( ) ) { try ( UnfilteredRowIterator row = scanner . next ( ) ) { if ( sstable . isRepaired ( ) ) { assertTrue ( range . contains ( row . partitionKey ( ) . getToken ( ) ) ) ; assertEquals ( repairedAt , sstable . getSSTableMetadata ( ) . repairedAt ) ; repairedKeys + + ; } else { assertFalse ( range . contains ( row . partitionKey ( ) . getToken ( ) ) ) ; assertEquals ( ActiveRepairService . UNREPAIRED_SSTABLE , sstable . getSSTableMetadata ( ) . repairedAt ) ; nonRepairedKeys + + ; } } } } } assertEquals ( repairedKeys , <int> ) ; assertEquals ( nonRepairedKeys , <int> ) ; } @Test public void shouldMutateRepairedAt ( ) throws InterruptedException , IOException { ColumnFamilyStore store = prepareColumnFamilyStore ( ) ; Collection < SSTableReader > sstables = getUnrepairedSSTables ( store ) ; assertEquals ( store . getLiveSSTables ( ) . size ( ) , sstables . size ( ) ) ; Range < Token > range = new Range < Token > ( new BytesToken ( <str> . getBytes ( ) ) , new BytesToken ( <str> . getBytes ( ) ) ) ; List < Range < Token > > ranges = Arrays . asList ( range ) ; try ( LifecycleTransaction txn = store . getTracker ( ) . tryModify ( sstables , OperationType . ANTICOMPACTION ) ; Refs < SSTableReader > refs = Refs . ref ( sstables ) ) { CompactionManager . instance . performAnticompaction ( store , ranges , refs , txn , <int> ) ; } assertThat ( store . getLiveSSTables ( ) . size ( ) , is ( <int> ) ) ; assertThat ( Iterables . get ( store . getLiveSSTables ( ) , <int> ) . isRepaired ( ) , is ( true ) ) ; assertThat ( Iterables . get ( store . getLiveSSTables ( ) , <int> ) . selfRef ( ) . globalCount ( ) , is ( <int> ) ) ; assertThat ( store . getTracker ( ) . getCompacting ( ) . size ( ) , is ( <int> ) ) ; } @Test public void shouldSkipAntiCompactionForNonIntersectingRange ( ) throws InterruptedException , IOException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; store . disableAutoCompaction ( ) ; for ( int table = <int> ; table < <int> ; table + + ) { generateSStable ( store , Integer . toString ( table ) ) ; } Collection < SSTableReader > sstables = getUnrepairedSSTables ( store ) ; assertEquals ( store . getLiveSSTables ( ) . size ( ) , sstables . size ( ) ) ; Range < Token > range = new Range < Token > ( new BytesToken ( <str> . getBytes ( ) ) , new BytesToken ( <str> . getBytes ( ) ) ) ; List < Range < Token > > ranges = Arrays . asList ( range ) ; try ( LifecycleTransaction txn = store . getTracker ( ) . tryModify ( sstables , OperationType . ANTICOMPACTION ) ; Refs < SSTableReader > refs = Refs . ref ( sstables ) ) { CompactionManager . instance . performAnticompaction ( store , ranges , refs , txn , <int> ) ; } assertThat ( store . getLiveSSTables ( ) . size ( ) , is ( <int> ) ) ; assertThat ( Iterables . get ( store . getLiveSSTables ( ) , <int> ) . isRepaired ( ) , is ( false ) ) ; } private ColumnFamilyStore prepareColumnFamilyStore ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; store . disableAutoCompaction ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { new RowUpdateBuilder ( cfm , System . currentTimeMillis ( ) , Integer . toString ( i ) ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; return store ; } @After public void truncateCfs ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF ) ; store . truncateBlocking ( ) ; } private static Set < SSTableReader > getUnrepairedSSTables ( ColumnFamilyStore cfs ) { return ImmutableSet . copyOf ( cfs . getTracker ( ) . getView ( ) . sstables ( SSTableSet . LIVE , ( s ) - > ! s . isRepaired ( ) ) ) ; } } 
