package com . badlogic . gdx . graphics . g3d . particles . influencers ; import com . badlogic . gdx . graphics . g3d . particles . ParallelArray . FloatChannel ; import com . badlogic . gdx . graphics . g3d . particles . ParallelArray . ObjectChannel ; import com . badlogic . gdx . graphics . g3d . particles . ParticleChannels ; import com . badlogic . gdx . graphics . g3d . particles . ParticleController ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class ParticleControllerFinalizerInfluencer extends Influencer { FloatChannel positionChannel , scaleChannel , rotationChannel ; ObjectChannel < ParticleController > controllerChannel ; boolean hasScale , hasRotation ; public ParticleControllerFinalizerInfluencer ( ) { } @Override public void init ( ) { controllerChannel = controller . particles . getChannel ( ParticleChannels . ParticleController ) ; if ( controllerChannel = = null ) throw new GdxRuntimeException ( <str> ) ; scaleChannel = controller . particles . getChannel ( ParticleChannels . Scale ) ; rotationChannel = controller . particles . getChannel ( ParticleChannels . Rotation3D ) ; hasScale = scaleChannel ! = null ; hasRotation = rotationChannel ! = null ; } @Override public void allocateChannels ( ) { positionChannel = controller . particles . addChannel ( ParticleChannels . Position ) ; } @Override public void update ( ) { for ( int i = <int> , positionOffset = <int> , c = controller . particles . size ; i < c ; + + i , positionOffset + = positionChannel . strideSize ) { ParticleController particleController = controllerChannel . data [ i ] ; float scale = hasScale ? scaleChannel . data [ i ] : <int> ; float qx = <int> , qy = <int> , qz = <int> , qw = <int> ; if ( hasRotation ) { int rotationOffset = i * rotationChannel . strideSize ; qx = rotationChannel . data [ rotationOffset + ParticleChannels . XOffset ] ; qy = rotationChannel . data [ rotationOffset + ParticleChannels . YOffset ] ; qz = rotationChannel . data [ rotationOffset + ParticleChannels . ZOffset ] ; qw = rotationChannel . data [ rotationOffset + ParticleChannels . WOffset ] ; } particleController . setTransform ( positionChannel . data [ positionOffset + ParticleChannels . XOffset ] , positionChannel . data [ positionOffset + ParticleChannels . YOffset ] , positionChannel . data [ positionOffset + ParticleChannels . ZOffset ] , qx , qy , qz , qw , scale ) ; particleController . update ( ) ; } } @Override public ParticleControllerFinalizerInfluencer copy ( ) { return new ParticleControllerFinalizerInfluencer ( ) ; } } 
