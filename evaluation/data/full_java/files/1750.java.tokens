package org . apache . cassandra . stress . settings ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . google . common . base . Function ; import org . apache . commons . math3 . distribution . ExponentialDistribution ; import org . apache . commons . math3 . distribution . NormalDistribution ; import org . apache . commons . math3 . distribution . UniformRealDistribution ; import org . apache . commons . math3 . distribution . WeibullDistribution ; import org . apache . commons . math3 . random . JDKRandomGenerator ; import org . apache . cassandra . stress . generate . * ; public class OptionDistribution extends Option { public static final Function < String , DistributionFactory > BUILDER = new Function < String , DistributionFactory > ( ) { public DistributionFactory apply ( String s ) { return get ( s ) ; } } ; private static final Pattern FULL = Pattern . compile ( <str> , Pattern . CASE_INSENSITIVE ) ; private static final Pattern ARGS = Pattern . compile ( <str> ) ; final String prefix ; private String spec ; private final String defaultSpec ; private final String description ; private final boolean required ; public OptionDistribution ( String prefix , String defaultSpec , String description ) { this ( prefix , defaultSpec , description , defaultSpec = = null ) ; } public OptionDistribution ( String prefix , String defaultSpec , String description , boolean required ) { this . prefix = prefix ; this . defaultSpec = defaultSpec ; this . description = description ; this . required = required ; } @Override public boolean accept ( String param ) { if ( ! param . toLowerCase ( ) . startsWith ( prefix ) ) return false ; spec = param . substring ( prefix . length ( ) ) ; return true ; } public static DistributionFactory get ( String spec ) { Matcher m = FULL . matcher ( spec ) ; if ( ! m . matches ( ) ) throw new IllegalArgumentException ( <str> + spec ) ; boolean inverse = m . group ( <int> ) . equals ( <str> ) ; String name = m . group ( <int> ) ; Impl impl = LOOKUP . get ( name . toLowerCase ( ) ) ; if ( impl = = null ) throw new IllegalArgumentException ( <str> + name ) ; List < String > params = new ArrayList < > ( ) ; m = ARGS . matcher ( m . group ( <int> ) ) ; while ( m . find ( ) ) params . add ( m . group ( ) ) ; DistributionFactory factory = impl . getFactory ( params ) ; return inverse ? new InverseFactory ( factory ) : factory ; } public DistributionFactory get ( ) { return spec ! = null ? get ( spec ) : defaultSpec ! = null ? get ( defaultSpec ) : null ; } @Override public boolean happy ( ) { return ! required | | spec ! = null ; } public String longDisplay ( ) { return shortDisplay ( ) + <str> + description ; } @Override public List < String > multiLineDisplay ( ) { return Arrays . asList ( GroupedOptions . formatMultiLine ( <str> , <str> ) , GroupedOptions . formatMultiLine ( <str> , <str> ) , GroupedOptions . formatMultiLine ( <str> , <str> ) , GroupedOptions . formatMultiLine ( <str> , <str> ) , GroupedOptions . formatMultiLine ( <str> , <str> ) , GroupedOptions . formatMultiLine ( <str> , <str> ) , GroupedOptions . formatMultiLine ( <str> , <str> ) , <str> , <str> ) ; } boolean setByUser ( ) { return spec ! = null ; } boolean present ( ) { return setByUser ( ) | | defaultSpec ! = null ; } @Override public String shortDisplay ( ) { return ( defaultSpec ! = null ? <str> : <str> ) + prefix + <str> + ( defaultSpec ! = null ? <str> : <str> ) ; } private static final Map < String , Impl > LOOKUP ; static { final Map < String , Impl > lookup = new HashMap < > ( ) ; lookup . put ( <str> , new ExponentialImpl ( ) ) ; lookup . put ( <str> , new ExtremeImpl ( ) ) ; lookup . put ( <str> , new QuantizedExtremeImpl ( ) ) ; lookup . put ( <str> , lookup . get ( <str> ) ) ; lookup . put ( <str> , lookup . get ( <str> ) ) ; lookup . put ( <str> , lookup . get ( <str> ) ) ; lookup . put ( <str> , new GaussianImpl ( ) ) ; lookup . put ( <str> , lookup . get ( <str> ) ) ; lookup . put ( <str> , lookup . get ( <str> ) ) ; lookup . put ( <str> , lookup . get ( <str> ) ) ; lookup . put ( <str> , new UniformImpl ( ) ) ; lookup . put ( <str> , new FixedImpl ( ) ) ; LOOKUP = lookup ; } private static interface Impl { public DistributionFactory getFactory ( List < String > params ) ; } public static long parseLong ( String value ) { long multiplier = <int> ; value = value . trim ( ) . toLowerCase ( ) ; switch ( value . charAt ( value . length ( ) - <int> ) ) { case <str> : multiplier * = <int> ; case <str> : multiplier * = <int> ; case <str> : multiplier * = <int> ; value = value . substring ( <int> , value . length ( ) - <int> ) ; } return Long . parseLong ( value ) * multiplier ; } private static final class GaussianImpl implements Impl { @Override public DistributionFactory getFactory ( List < String > params ) { if ( params . size ( ) > <int> | | params . size ( ) < <int> ) throw new IllegalArgumentException ( <str> + params ) ; try { String [ ] bounds = params . get ( <int> ) . split ( <str> ) ; final long min = parseLong ( bounds [ <int> ] ) ; final long max = parseLong ( bounds [ <int> ] ) ; final double mean , stdev ; if ( params . size ( ) = = <int> ) { mean = Double . parseDouble ( params . get ( <int> ) ) ; stdev = Double . parseDouble ( params . get ( <int> ) ) ; } else { final double stdevsToEdge = params . size ( ) = = <int> ? <float> : Double . parseDouble ( params . get ( <int> ) ) ; mean = ( min + max ) / <float> ; stdev = ( ( max - min ) / <float> ) / stdevsToEdge ; } if ( min = = max ) return new FixedFactory ( min ) ; return new GaussianFactory ( min , max , mean , stdev ) ; } catch ( Exception ignore ) { throw new IllegalArgumentException ( <str> + params ) ; } } } private static final class ExponentialImpl implements Impl { @Override public DistributionFactory getFactory ( List < String > params ) { if ( params . size ( ) ! = <int> ) throw new IllegalArgumentException ( <str> + params ) ; try { String [ ] bounds = params . get ( <int> ) . split ( <str> ) ; final long min = parseLong ( bounds [ <int> ] ) ; final long max = parseLong ( bounds [ <int> ] ) ; if ( min = = max ) return new FixedFactory ( min ) ; ExponentialDistribution findBounds = new ExponentialDistribution ( <float> ) ; final double mean = ( max - min ) / findBounds . inverseCumulativeProbability ( <float> - Math . sqrt ( <float> / ( max - min ) ) ) ; return new ExpFactory ( min , max , mean ) ; } catch ( Exception ignore ) { throw new IllegalArgumentException ( <str> + params ) ; } } } private static final class ExtremeImpl implements Impl { @Override public DistributionFactory getFactory ( List < String > params ) { if ( params . size ( ) ! = <int> ) throw new IllegalArgumentException ( <str> + params ) ; try { String [ ] bounds = params . get ( <int> ) . split ( <str> ) ; final long min = parseLong ( bounds [ <int> ] ) ; final long max = parseLong ( bounds [ <int> ] ) ; if ( min = = max ) return new FixedFactory ( min ) ; final double shape = Double . parseDouble ( params . get ( <int> ) ) ; WeibullDistribution findBounds = new WeibullDistribution ( shape , <float> ) ; final double scale = ( max - min ) / findBounds . inverseCumulativeProbability ( <float> - Math . sqrt ( <float> / ( max - min ) ) ) ; return new ExtremeFactory ( min , max , shape , scale ) ; } catch ( Exception ignore ) { throw new IllegalArgumentException ( <str> + params ) ; } } } private static final class QuantizedExtremeImpl implements Impl { @Override public DistributionFactory getFactory ( List < String > params ) { if ( params . size ( ) ! = <int> ) throw new IllegalArgumentException ( <str> + params ) ; try { String [ ] bounds = params . get ( <int> ) . split ( <str> ) ; final long min = parseLong ( bounds [ <int> ] ) ; final long max = parseLong ( bounds [ <int> ] ) ; final double shape = Double . parseDouble ( params . get ( <int> ) ) ; final int quantas = Integer . parseInt ( params . get ( <int> ) ) ; WeibullDistribution findBounds = new WeibullDistribution ( shape , <float> ) ; final double scale = ( max - min ) / findBounds . inverseCumulativeProbability ( <float> - Math . sqrt ( <float> / ( max - min ) ) ) ; if ( min = = max ) return new FixedFactory ( min ) ; return new QuantizedExtremeFactory ( min , max , shape , scale , quantas ) ; } catch ( Exception ignore ) { throw new IllegalArgumentException ( <str> + params ) ; } } } private static final class UniformImpl implements Impl { @Override public DistributionFactory getFactory ( List < String > params ) { if ( params . size ( ) ! = <int> ) throw new IllegalArgumentException ( <str> + params ) ; try { String [ ] bounds = params . get ( <int> ) . split ( <str> ) ; final long min = parseLong ( bounds [ <int> ] ) ; final long max = parseLong ( bounds [ <int> ] ) ; if ( min = = max ) return new FixedFactory ( min ) ; return new UniformFactory ( min , max ) ; } catch ( Exception ignore ) { throw new IllegalArgumentException ( <str> + params ) ; } } } private static final class FixedImpl implements Impl { @Override public DistributionFactory getFactory ( List < String > params ) { if ( params . size ( ) ! = <int> ) throw new IllegalArgumentException ( <str> + params ) ; try { final long key = parseLong ( params . get ( <int> ) ) ; return new FixedFactory ( key ) ; } catch ( Exception ignore ) { throw new IllegalArgumentException ( <str> + params ) ; } } } private static final class InverseFactory implements DistributionFactory { final DistributionFactory wrapped ; private InverseFactory ( DistributionFactory wrapped ) { this . wrapped = wrapped ; } public Distribution get ( ) { return new DistributionInverted ( wrapped . get ( ) ) ; } } private static final class ExpFactory implements DistributionFactory { final long min , max ; final double mean ; private ExpFactory ( long min , long max , double mean ) { this . min = min ; this . max = max ; this . mean = mean ; } @Override public Distribution get ( ) { return new DistributionOffsetApache ( new ExponentialDistribution ( new JDKRandomGenerator ( ) , mean , ExponentialDistribution . DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) , min , max ) ; } } private static class ExtremeFactory implements DistributionFactory { final long min , max ; final double shape , scale ; private ExtremeFactory ( long min , long max , double shape , double scale ) { this . min = min ; this . max = max ; this . shape = shape ; this . scale = scale ; } @Override public Distribution get ( ) { return new DistributionOffsetApache ( new WeibullDistribution ( new JDKRandomGenerator ( ) , shape , scale , WeibullDistribution . DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) , min , max ) ; } } private static final class QuantizedExtremeFactory extends ExtremeFactory { final int quantas ; private QuantizedExtremeFactory ( long min , long max , double shape , double scale , int quantas ) { super ( min , max , shape , scale ) ; this . quantas = quantas ; } @Override public Distribution get ( ) { return new DistributionQuantized ( new DistributionOffsetApache ( new WeibullDistribution ( new JDKRandomGenerator ( ) , shape , scale , WeibullDistribution . DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) , min , max ) , quantas ) ; } } private static final class GaussianFactory implements DistributionFactory { final long min , max ; final double mean , stdev ; private GaussianFactory ( long min , long max , double mean , double stdev ) { this . min = min ; this . max = max ; this . stdev = stdev ; this . mean = mean ; } @Override public Distribution get ( ) { return new DistributionBoundApache ( new NormalDistribution ( new JDKRandomGenerator ( ) , mean , stdev , NormalDistribution . DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) , min , max ) ; } } private static final class UniformFactory implements DistributionFactory { final long min , max ; private UniformFactory ( long min , long max ) { this . min = min ; this . max = max ; } @Override public Distribution get ( ) { return new DistributionBoundApache ( new UniformRealDistribution ( new JDKRandomGenerator ( ) , min , max + <int> ) , min , max ) ; } } private static final class FixedFactory implements DistributionFactory { final long key ; private FixedFactory ( long key ) { this . key = key ; } @Override public Distribution get ( ) { return new DistributionFixed ( key ) ; } } @Override public int hashCode ( ) { return prefix . hashCode ( ) ; } @Override public boolean equals ( Object that ) { return super . equals ( that ) & & ( ( OptionDistribution ) that ) . prefix . equals ( this . prefix ) ; } } 
