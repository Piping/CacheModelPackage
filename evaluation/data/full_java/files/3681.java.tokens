package org . eclipse . debug . internal . core ; import java . util . ArrayList ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IDebugEventSetListener ; import org . eclipse . debug . core . IMemoryBlockListener ; import org . eclipse . debug . core . IMemoryBlockManager ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IMemoryBlockExtension ; import org . eclipse . debug . core . model . IMemoryBlockRetrieval ; public class MemoryBlockManager implements IMemoryBlockManager , IDebugEventSetListener { private ArrayList < IMemoryBlockListener > listeners = new ArrayList < IMemoryBlockListener > ( ) ; private ArrayList < IMemoryBlock > memoryBlocks = new ArrayList < IMemoryBlock > ( ) ; private static final int ADDED = <int> ; private static final int REMOVED = <int> ; class MemoryBlockNotifier implements ISafeRunnable { private IMemoryBlockListener fListener ; private int fType ; private IMemoryBlock [ ] fMemoryBlocks ; @Override public void handleException ( Throwable exception ) { DebugPlugin . log ( exception ) ; } @Override public void run ( ) throws Exception { switch ( fType ) { case ADDED : fListener . memoryBlocksAdded ( fMemoryBlocks ) ; break ; case REMOVED : fListener . memoryBlocksRemoved ( fMemoryBlocks ) ; break ; default : break ; } } public void notify ( IMemoryBlock [ ] memBlocks , int update ) { if ( listeners ! = null ) { fType = update ; Object [ ] copiedListeners = listeners . toArray ( new IMemoryBlockListener [ listeners . size ( ) ] ) ; for ( int i = <int> ; i < copiedListeners . length ; i + + ) { fListener = ( IMemoryBlockListener ) copiedListeners [ i ] ; fMemoryBlocks = memBlocks ; SafeRunner . run ( this ) ; } } fListener = null ; fMemoryBlocks = null ; } } private MemoryBlockNotifier getMemoryBlockNotifier ( ) { return new MemoryBlockNotifier ( ) ; } @Override public void addMemoryBlocks ( IMemoryBlock [ ] mem ) { if ( memoryBlocks = = null ) { return ; } if ( mem = = null ) { DebugPlugin . logMessage ( <str> , null ) ; return ; } if ( mem . length > <int> ) { ArrayList < IMemoryBlock > newMemoryBlocks = new ArrayList < IMemoryBlock > ( ) ; for ( int i = <int> ; i < mem . length ; i + + ) { if ( ! memoryBlocks . contains ( mem [ i ] ) ) { newMemoryBlocks . add ( mem [ i ] ) ; memoryBlocks . add ( mem [ i ] ) ; if ( memoryBlocks . size ( ) = = <int> ) { DebugPlugin . getDefault ( ) . addDebugEventListener ( this ) ; } } } notifyListeners ( newMemoryBlocks . toArray ( new IMemoryBlock [ newMemoryBlocks . size ( ) ] ) , ADDED ) ; } } @Override public void removeMemoryBlocks ( IMemoryBlock [ ] memBlocks ) { if ( memoryBlocks = = null ) { return ; } if ( memBlocks = = null ) { DebugPlugin . logMessage ( <str> , null ) ; return ; } if ( memBlocks . length > <int> ) { for ( int i = <int> ; i < memBlocks . length ; i + + ) { memoryBlocks . remove ( memBlocks [ i ] ) ; if ( memoryBlocks . size ( ) = = <int> ) { DebugPlugin . getDefault ( ) . removeDebugEventListener ( this ) ; } if ( memBlocks [ i ] instanceof IMemoryBlockExtension ) { try { ( ( IMemoryBlockExtension ) memBlocks [ i ] ) . dispose ( ) ; } catch ( DebugException e ) { DebugPlugin . log ( e ) ; } } } notifyListeners ( memBlocks , REMOVED ) ; } } @Override public void addListener ( IMemoryBlockListener listener ) { if ( listeners = = null ) { return ; } if ( listener = = null ) { DebugPlugin . logMessage ( <str> , null ) ; return ; } if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } } @Override public void removeListener ( IMemoryBlockListener listener ) { if ( listeners = = null ) { return ; } if ( listener = = null ) { DebugPlugin . logMessage ( <str> , null ) ; return ; } if ( listeners . contains ( listener ) ) { listeners . remove ( listener ) ; } } @Override public IMemoryBlock [ ] getMemoryBlocks ( ) { return memoryBlocks . toArray ( new IMemoryBlock [ memoryBlocks . size ( ) ] ) ; } @Override public IMemoryBlock [ ] getMemoryBlocks ( IDebugTarget debugTarget ) { ArrayList < IMemoryBlock > memoryBlocksList = new ArrayList < IMemoryBlock > ( ) ; for ( IMemoryBlock block : memoryBlocks ) { if ( block . getDebugTarget ( ) = = debugTarget ) { memoryBlocksList . add ( block ) ; } } return memoryBlocksList . toArray ( new IMemoryBlock [ memoryBlocksList . size ( ) ] ) ; } @Override public IMemoryBlock [ ] getMemoryBlocks ( IMemoryBlockRetrieval retrieve ) { ArrayList < IMemoryBlock > memoryBlocksList = new ArrayList < IMemoryBlock > ( ) ; for ( IMemoryBlock block : memoryBlocks ) { if ( block instanceof IMemoryBlockExtension ) { if ( ( ( IMemoryBlockExtension ) block ) . getMemoryBlockRetrieval ( ) = = retrieve ) { memoryBlocksList . add ( block ) ; } } else { IMemoryBlockRetrieval mbRetrieval = block . getAdapter ( IMemoryBlockRetrieval . class ) ; if ( mbRetrieval = = null ) { mbRetrieval = block . getDebugTarget ( ) ; } if ( mbRetrieval = = retrieve ) { memoryBlocksList . add ( block ) ; } } } return memoryBlocksList . toArray ( new IMemoryBlock [ memoryBlocksList . size ( ) ] ) ; } private void notifyListeners ( IMemoryBlock [ ] memBlocks , int event ) { getMemoryBlockNotifier ( ) . notify ( memBlocks , event ) ; } @Override public void handleDebugEvents ( DebugEvent [ ] events ) { for ( int i = <int> ; i < events . length ; i + + ) { handleDebugEvent ( events [ i ] ) ; } } public void handleDebugEvent ( DebugEvent event ) { Object obj = event . getSource ( ) ; IDebugTarget dt = null ; if ( event . getKind ( ) = = DebugEvent . TERMINATE ) { if ( obj instanceof IDebugTarget ) { dt = ( ( IDebugTarget ) obj ) ; IMemoryBlock [ ] deletedMemoryBlocks = getMemoryBlocks ( dt ) ; removeMemoryBlocks ( deletedMemoryBlocks ) ; } } } public void shutdown ( ) { if ( listeners ! = null ) { listeners . clear ( ) ; listeners = null ; } if ( memoryBlocks ! = null ) { memoryBlocks . clear ( ) ; memoryBlocks = null ; } } } 
