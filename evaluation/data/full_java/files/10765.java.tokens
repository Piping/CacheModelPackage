package org . gradle . api . plugins . antlr . internal ; import com . google . common . collect . Lists ; import org . gradle . api . GradleException ; import org . gradle . api . plugins . antlr . internal . antlr2 . GenerationPlan ; import org . gradle . api . plugins . antlr . internal . antlr2 . GenerationPlanBuilder ; import org . gradle . api . plugins . antlr . internal . antlr2 . MetadataExtracter ; import org . gradle . api . plugins . antlr . internal . antlr2 . XRef ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . internal . reflect . JavaReflectionUtil ; import org . gradle . util . GFileUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . util . List ; public class AntlrExecuter { private static final Logger LOGGER = LoggerFactory . getLogger ( AntlrExecuter . class ) ; AntlrResult runAntlr ( AntlrSpec spec ) throws IOException , InterruptedException { AntlrTool antlrTool = new Antlr4Tool ( ) ; if ( antlrTool . available ( ) ) { LOGGER . info ( <str> ) ; return antlrTool . process ( spec ) ; } antlrTool = new Antlr3Tool ( ) ; if ( antlrTool . available ( ) ) { LOGGER . info ( <str> ) ; return antlrTool . process ( spec ) ; } antlrTool = new Antlr2Tool ( ) ; if ( antlrTool . available ( ) ) { LOGGER . info ( <str> ) ; return antlrTool . process ( spec ) ; } throw new IllegalStateException ( <str> ) ; } private static class Antlr3Tool extends AntlrTool { public Antlr3Tool ( ) { } @Override int invoke ( List < String > arguments , File inputDirectory ) throws ClassNotFoundException { final Object backedObject = loadTool ( <str> , null ) ; String [ ] argArray = arguments . toArray ( new String [ arguments . size ( ) ] ) ; if ( inputDirectory ! = null ) { JavaReflectionUtil . method ( backedObject , Void . class , <str> , String . class ) . invoke ( backedObject , inputDirectory . getAbsolutePath ( ) ) ; JavaReflectionUtil . method ( backedObject , Void . class , <str> , boolean . class ) . invoke ( backedObject , true ) ; } JavaReflectionUtil . method ( backedObject , Void . class , <str> , String [ ] . class ) . invoke ( backedObject , new Object [ ] { argArray } ) ; JavaReflectionUtil . method ( backedObject , Void . class , <str> ) . invoke ( backedObject ) ; return JavaReflectionUtil . method ( backedObject , Integer . class , <str> ) . invoke ( backedObject ) ; } @Override public boolean available ( ) { try { loadTool ( <str> , null ) ; } catch ( ClassNotFoundException cnf ) { return false ; } return true ; } } private abstract static class AntlrTool { static Object loadTool ( String className , String [ ] args ) throws ClassNotFoundException { try { Class < ? > toolClass = Class . forName ( className ) ; if ( args = = null ) { return toolClass . newInstance ( ) ; } else { Constructor < ? > constructor = toolClass . getConstructor ( String [ ] . class ) ; return constructor . newInstance ( new Object [ ] { args } ) ; } } catch ( ClassNotFoundException cnf ) { throw cnf ; } catch ( InvocationTargetException e ) { throw new GradleException ( <str> , e . getCause ( ) ) ; } catch ( Exception e ) { throw new GradleException ( <str> , e ) ; } } public final AntlrResult process ( AntlrSpec spec ) { try { return doProcess ( spec ) ; } catch ( ClassNotFoundException e ) { throw new GradleException ( <str> , e ) ; } } public AntlrResult doProcess ( AntlrSpec spec ) throws ClassNotFoundException { int numErrors = <int> ; if ( spec . getInputDirectories ( ) . size ( ) = = <int> ) { numErrors + = invoke ( spec . asArgumentsWithFiles ( ) , null ) ; } else { boolean onWindows = OperatingSystem . current ( ) . isWindows ( ) ; for ( File inputDirectory : spec . getInputDirectories ( ) ) { final List < String > arguments = spec . getArguments ( ) ; arguments . add ( <str> ) ; arguments . add ( spec . getOutputDirectory ( ) . getAbsolutePath ( ) ) ; for ( File grammarFile : spec . getGrammarFiles ( ) ) { String relativeGrammarFilePath = GFileUtils . relativePath ( inputDirectory , grammarFile ) ; if ( onWindows ) { relativeGrammarFilePath = relativeGrammarFilePath . replace ( <str> , File . separatorChar ) ; } arguments . add ( relativeGrammarFilePath ) ; } numErrors + = invoke ( arguments , inputDirectory ) ; } } return new AntlrResult ( numErrors ) ; } abstract int invoke ( List < String > arguments , File inputDirectory ) throws ClassNotFoundException ; public abstract boolean available ( ) ; protected static String [ ] toArray ( List < String > strings ) { return strings . toArray ( new String [ strings . size ( ) ] ) ; } } static class Antlr4Tool extends AntlrTool { public Antlr4Tool ( ) { } @Override int invoke ( List < String > arguments , File inputDirectory ) throws ClassNotFoundException { final Object backedObject = loadTool ( <str> , toArray ( arguments ) ) ; if ( inputDirectory ! = null ) { JavaReflectionUtil . writeableField ( backedObject . getClass ( ) , <str> ) . setValue ( backedObject , inputDirectory ) ; } JavaReflectionUtil . method ( backedObject , Void . class , <str> ) . invoke ( backedObject ) ; return JavaReflectionUtil . method ( backedObject , Integer . class , <str> ) . invoke ( backedObject ) ; } @Override public boolean available ( ) { try { loadTool ( <str> , null ) ; } catch ( ClassNotFoundException cnf ) { return false ; } return true ; } } private static class Antlr2Tool extends AntlrTool { public Antlr2Tool ( ) { } public AntlrResult doProcess ( AntlrSpec spec ) throws ClassNotFoundException { XRef xref = new MetadataExtracter ( ) . extractMetadata ( spec . getGrammarFiles ( ) ) ; List < GenerationPlan > generationPlans = new GenerationPlanBuilder ( spec . getOutputDirectory ( ) ) . buildGenerationPlans ( xref ) ; for ( GenerationPlan generationPlan : generationPlans ) { List < String > generationPlanArguments = Lists . newArrayList ( spec . getArguments ( ) ) ; generationPlanArguments . add ( <str> ) ; generationPlanArguments . add ( generationPlan . getGenerationDirectory ( ) . getAbsolutePath ( ) ) ; generationPlanArguments . add ( generationPlan . getSource ( ) . getAbsolutePath ( ) ) ; invoke ( generationPlanArguments , null ) ; } return new AntlrResult ( <int> ) ; } @Override int invoke ( List < String > arguments , File inputDirectory ) throws ClassNotFoundException { final Object backedAntlrTool = loadTool ( <str> , null ) ; JavaReflectionUtil . method ( backedAntlrTool , Integer . class , <str> , String [ ] . class ) . invoke ( backedAntlrTool , new Object [ ] { toArray ( arguments ) } ) ; return <int> ; } @Override public boolean available ( ) { try { loadTool ( <str> , null ) ; } catch ( ClassNotFoundException cnf ) { return false ; } return true ; } } } 
