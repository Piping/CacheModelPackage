package com . google . common . hash ; import static com . google . common . base . Charsets . ISO_8859_1 ; import static com . google . common . base . Charsets . UTF_8 ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . base . Strings ; import junit . framework . TestCase ; import java . util . Arrays ; public class FarmHashFingerprint64Test extends TestCase { private static final HashFunction HASH_FN = Hashing . farmHashFingerprint64 ( ) ; public void testReallySimpleFingerprints ( ) { assertEquals ( <int> , fingerprint ( <str> . getBytes ( UTF_8 ) ) ) ; assertEquals ( - <int> , fingerprint ( Strings . repeat ( <str> , <int> ) . getBytes ( UTF_8 ) ) ) ; assertEquals ( <int> , fingerprint ( Strings . repeat ( <str> , <int> ) . getBytes ( UTF_8 ) ) ) ; } public void testStringsConsistency ( ) { for ( String s : Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) { assertEquals ( HASH_FN . newHasher ( ) . putUnencodedChars ( s ) . hash ( ) , HASH_FN . hashUnencodedChars ( s ) ) ; } } public void testUtf8 ( ) { char [ ] charsA = new char [ <int> ] ; char [ ] charsB = new char [ <int> ] ; for ( int i = <int> ; i < charsA . length ; i + + ) { if ( i < <int> ) { charsA [ i ] = <str> ; charsB [ i ] = <str> ; } else { charsA [ i ] = ( char ) ( <hex> + i ) ; charsB [ i ] = ( char ) ( <hex> + i ) ; } } String stringA = new String ( charsA ) ; String stringB = new String ( charsB ) ; assertThat ( stringA ) . isNotEqualTo ( stringB ) ; assertThat ( HASH_FN . hashUnencodedChars ( stringA ) ) . isNotEqualTo ( HASH_FN . hashUnencodedChars ( stringB ) ) ; assertThat ( fingerprint ( stringA . getBytes ( UTF_8 ) ) ) . isNotEqualTo ( fingerprint ( stringB . getBytes ( UTF_8 ) ) ) ; assertEquals ( fingerprint ( stringA . getBytes ( ISO_8859_1 ) ) , fingerprint ( stringB . getBytes ( ISO_8859_1 ) ) ) ; } public void testPutNonChars ( ) { Hasher hasher = HASH_FN . newHasher ( ) ; hasher . putBoolean ( true ) . putBoolean ( true ) . putBoolean ( false ) . putBoolean ( true ) . putBoolean ( false ) . putBoolean ( false ) . putBoolean ( false ) . putBoolean ( false ) ; final long hashCode = hasher . hash ( ) . asLong ( ) ; hasher = HASH_FN . newHasher ( ) ; hasher . putByte ( ( byte ) <hex> ) . putByte ( ( byte ) <hex> ) . putByte ( ( byte ) <hex> ) . putByte ( ( byte ) <hex> ) . putByte ( ( byte ) <hex> ) . putByte ( ( byte ) <hex> ) . putByte ( ( byte ) <hex> ) . putByte ( ( byte ) <hex> ) ; assertEquals ( hashCode , hasher . hash ( ) . asLong ( ) ) ; hasher = HASH_FN . newHasher ( ) ; hasher . putChar ( ( char ) <hex> ) . putChar ( ( char ) <hex> ) . putChar ( ( char ) <hex> ) . putChar ( ( char ) <hex> ) ; assertEquals ( hashCode , hasher . hash ( ) . asLong ( ) ) ; hasher = HASH_FN . newHasher ( ) ; hasher . putBytes ( new byte [ ] { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ) ; assertEquals ( hashCode , hasher . hash ( ) . asLong ( ) ) ; hasher = HASH_FN . newHasher ( ) ; hasher . putLong ( <hex> ) ; assertEquals ( hashCode , hasher . hash ( ) . asLong ( ) ) ; hasher = HASH_FN . newHasher ( ) ; hasher . putShort ( ( short ) <hex> ) . putShort ( ( short ) <hex> ) . putShort ( ( short ) <hex> ) . putShort ( ( short ) <hex> ) ; assertEquals ( hashCode , hasher . hash ( ) . asLong ( ) ) ; } public void testHashFloatIsStable ( ) { Hasher hasher = HASH_FN . newHasher ( ) ; hasher . putFloat ( <hex> ) . putFloat ( <float> ) ; assertEquals ( <hex> , hasher . hash ( ) . asLong ( ) ) ; hasher = HASH_FN . newHasher ( ) ; hasher . putDouble ( <hex> ) ; assertEquals ( <hex> , hasher . hash ( ) . asLong ( ) ) ; } private static long fingerprint ( byte [ ] bytes ) { return fingerprint ( bytes , bytes . length ) ; } private static long fingerprint ( byte [ ] bytes , int length ) { return HASH_FN . hashBytes ( bytes , <int> , length ) . asLong ( ) ; } public void testMultipleLengths ( ) { int iterations = <int> ; byte [ ] buf = new byte [ iterations * <int> ] ; int bufLen = <int> ; long h = <int> ; for ( int i = <int> ; i < iterations ; + + i ) { h ^ = fingerprint ( buf , i ) ; h = remix ( h ) ; buf [ bufLen + + ] = getChar ( h ) ; h ^ = fingerprint ( buf , i * i % bufLen ) ; h = remix ( h ) ; buf [ bufLen + + ] = getChar ( h ) ; h ^ = fingerprint ( buf , i * i * i % bufLen ) ; h = remix ( h ) ; buf [ bufLen + + ] = getChar ( h ) ; h ^ = fingerprint ( buf , bufLen ) ; h = remix ( h ) ; buf [ bufLen + + ] = getChar ( h ) ; int x0 = buf [ bufLen - <int> ] & <hex> ; int x1 = buf [ bufLen - <int> ] & <hex> ; int x2 = buf [ bufLen - <int> ] & <hex> ; int x3 = buf [ bufLen / <int> ] & <hex> ; buf [ ( ( x0 < < <int> ) + ( x1 < < <int> ) + x2 ) % bufLen ] ^ = x3 ; buf [ ( ( x1 < < <int> ) + ( x2 < < <int> ) + x3 ) % bufLen ] ^ = i % <int> ; } assertEquals ( <hex> , h ) ; } private static long remix ( long h ) { h ^ = h > > > <int> ; h * = <int> ; return h ; } private static byte getChar ( long h ) { return ( byte ) ( <str> + ( ( h & <hex> ) % <int> ) ) ; } } 
