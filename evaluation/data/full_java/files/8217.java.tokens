package org . elasticsearch . index . mapper . timestamp ; import org . apache . lucene . index . IndexOptions ; import org . elasticsearch . Version ; import org . elasticsearch . action . TimestampParsingException ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . SourceToParse ; import org . elasticsearch . index . mapper . internal . TimestampFieldMapper ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . io . IOException ; import java . nio . charset . StandardCharsets ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . Version . V_1_5_0 ; import static org . elasticsearch . Version . V_2_0_0_beta1 ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . elasticsearch . test . VersionUtils . randomVersionBetween ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . hasKey ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . isIn ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . Matchers . notNullValue ; public class TimestampMappingTests extends ESSingleNodeTestCase { Settings BWC_SETTINGS = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; public void testSimpleDisabled ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; BytesReference source = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ; ParsedDocument doc = docMapper . parse ( SourceToParse . source ( source ) . type ( <str> ) . id ( <str> ) . timestamp ( <int> ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , equalTo ( null ) ) ; } public void testEnabled ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; BytesReference source = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ; ParsedDocument doc = docMapper . parse ( SourceToParse . source ( source ) . type ( <str> ) . id ( <str> ) . timestamp ( <int> ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . stored ( ) , equalTo ( true ) ) ; assertNotSame ( IndexOptions . NONE , doc . rootDoc ( ) . getField ( <str> ) . fieldType ( ) . indexOptions ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . tokenStream ( docMapper . mappers ( ) . indexAnalyzer ( ) , null ) , notNullValue ( ) ) ; } public void testDefaultValues ( ) throws Exception { for ( Version version : Arrays . asList ( V_1_5_0 , V_2_0_0_beta1 , randomVersion ( random ( ) ) ) ) { for ( String mapping : Arrays . asList ( XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . string ( ) , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ) ) { DocumentMapper docMapper = createIndex ( <str> , Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; assertThat ( docMapper . timestampFieldMapper ( ) . enabled ( ) , equalTo ( TimestampFieldMapper . Defaults . ENABLED . enabled ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . stored ( ) , equalTo ( version . onOrAfter ( Version . V_2_0_0_beta1 ) ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . indexOptions ( ) , equalTo ( TimestampFieldMapper . Defaults . FIELD_TYPE . indexOptions ( ) ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . path ( ) , equalTo ( TimestampFieldMapper . Defaults . PATH ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . hasDocValues ( ) , equalTo ( version . onOrAfter ( Version . V_2_0_0_beta1 ) ) ) ; String expectedFormat = version . onOrAfter ( Version . V_2_0_0_beta1 ) ? TimestampFieldMapper . DEFAULT_DATE_TIME_FORMAT : TimestampFieldMapper . Defaults . DATE_TIME_FORMATTER_BEFORE_2_0 . format ( ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . dateTimeFormatter ( ) . format ( ) , equalTo ( expectedFormat ) ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . execute ( ) . get ( ) ) ; } } } public void testBackcompatSetValues ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; assertThat ( docMapper . timestampFieldMapper ( ) . enabled ( ) , equalTo ( true ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . stored ( ) , equalTo ( false ) ) ; assertEquals ( IndexOptions . NONE , docMapper . timestampFieldMapper ( ) . fieldType ( ) . indexOptions ( ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . path ( ) , equalTo ( <str> ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . dateTimeFormatter ( ) . format ( ) , equalTo ( <str> ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . hasDocValues ( ) , equalTo ( true ) ) ; } public void testThatDisablingDuringMergeIsWorking ( ) throws Exception { String enabledMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper enabledMapper = parser . parse ( enabledMapping ) ; String disabledMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper disabledMapper = parser . parse ( disabledMapping ) ; enabledMapper . merge ( disabledMapper . mapping ( ) , false , false ) ; assertThat ( enabledMapper . timestampFieldMapper ( ) . enabled ( ) , is ( false ) ) ; } public void testThatSerializationWorksCorrectlyForIndexField ( ) throws Exception { String enabledMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper enabledMapper = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) . parse ( enabledMapping ) ; XContentBuilder builder = JsonXContent . contentBuilder ( ) . startObject ( ) ; enabledMapper . timestampFieldMapper ( ) . toXContent ( builder , ToXContent . EMPTY_PARAMS ) . endObject ( ) ; builder . close ( ) ; Map < String , Object > serializedMap ; try ( XContentParser parser = JsonXContent . jsonXContent . createParser ( builder . bytes ( ) ) ) { serializedMap = parser . map ( ) ; } assertThat ( serializedMap , hasKey ( <str> ) ) ; assertThat ( serializedMap . get ( <str> ) , instanceOf ( Map . class ) ) ; Map < String , Object > timestampConfiguration = ( Map < String , Object > ) serializedMap . get ( <str> ) ; assertThat ( timestampConfiguration , hasKey ( <str> ) ) ; assertThat ( timestampConfiguration . get ( <str> ) . toString ( ) , is ( <str> ) ) ; } public void testBackcompatPathMissingDefaultValue ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; try { request . process ( metaData , mappingMetaData , true , <str> ) ; fail ( ) ; } catch ( TimestampParsingException e ) { assertThat ( e . getDetailedMessage ( ) , containsString ( <str> ) ) ; } } public void testTimestampDefaultValue ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertThat ( request . timestamp ( ) , notNullValue ( ) ) ; long delay = System . currentTimeMillis ( ) - Long . parseLong ( request . timestamp ( ) ) ; assertThat ( delay , lessThanOrEqualTo ( <int> ) ) ; } public void testBackcompatPathMissingDefaultToEpochValue ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; DocumentMapper docMapper = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; MetaData metaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . getMetaData ( ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertThat ( request . timestamp ( ) , notNullValue ( ) ) ; assertThat ( request . timestamp ( ) , is ( MappingMetaData . Timestamp . parseStringTimestamp ( <str> , Joda . forPattern ( <str> ) , Version . CURRENT ) ) ) ; } public void testTimestampMissingDefaultToEpochValue ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; MetaData metaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . getMetaData ( ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertThat ( request . timestamp ( ) , notNullValue ( ) ) ; assertThat ( request . timestamp ( ) , is ( MappingMetaData . Timestamp . parseStringTimestamp ( <str> , Joda . forPattern ( <str> ) , Version . CURRENT ) ) ) ; } public void testBackcompatPathMissingNowDefaultValue ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertThat ( request . timestamp ( ) , notNullValue ( ) ) ; long delay = System . currentTimeMillis ( ) - Long . parseLong ( request . timestamp ( ) ) ; assertThat ( delay , lessThanOrEqualTo ( <int> ) ) ; } public void testTimestampMissingNowDefaultValue ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertThat ( request . timestamp ( ) , notNullValue ( ) ) ; long delay = System . currentTimeMillis ( ) - Long . parseLong ( request . timestamp ( ) ) ; assertThat ( delay , lessThanOrEqualTo ( <int> ) ) ; } public void testPathMissingWithForcedNullDefaultShouldFail ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , ( String ) null ) . endObject ( ) . endObject ( ) . endObject ( ) ; try { createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; fail ( <str> ) ; } catch ( TimestampParsingException e ) { assertThat ( e . getDetailedMessage ( ) , containsString ( <str> ) ) ; } } public void testBackcompatPathMissingShouldFail ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; try { request . process ( metaData , mappingMetaData , true , <str> ) ; fail ( <str> ) ; } catch ( TimestampParsingException e ) { assertThat ( e . getDetailedMessage ( ) , containsString ( <str> ) ) ; } } public void testTimestampMissingWithForcedNullDefaultShouldFail ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , ( String ) null ) . endObject ( ) . endObject ( ) . endObject ( ) ; try { createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; fail ( <str> ) ; } catch ( TimestampParsingException e ) { assertThat ( e . getDetailedMessage ( ) , containsString ( <str> ) ) ; } } public void testTimestampDefaultAndIgnore ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) ; try { createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; fail ( <str> ) ; } catch ( TimestampParsingException e ) { assertThat ( e . getDetailedMessage ( ) , containsString ( <str> ) ) ; } } public void testTimestampMissingShouldNotFail ( ) throws Exception { XContentBuilder mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping . string ( ) ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertThat ( request . timestamp ( ) , notNullValue ( ) ) ; long delay = System . currentTimeMillis ( ) - Long . parseLong ( request . timestamp ( ) ) ; assertThat ( delay , lessThanOrEqualTo ( <int> ) ) ; } public void testDefaultTimestampStream ( ) throws IOException { { MappingMetaData . Timestamp timestamp = new MappingMetaData . Timestamp ( true , null , TimestampFieldMapper . DEFAULT_DATE_TIME_FORMAT , null , null ) ; MappingMetaData expected = new MappingMetaData ( <str> , new CompressedXContent ( <str> . getBytes ( StandardCharsets . UTF_8 ) ) , new MappingMetaData . Id ( null ) , new MappingMetaData . Routing ( false , null ) , timestamp , false ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; expected . writeTo ( out ) ; out . close ( ) ; BytesReference bytes = out . bytes ( ) ; MappingMetaData metaData = MappingMetaData . PROTO . readFrom ( StreamInput . wrap ( bytes ) ) ; assertThat ( metaData , is ( expected ) ) ; } { MappingMetaData . Timestamp timestamp = new MappingMetaData . Timestamp ( true , null , TimestampFieldMapper . DEFAULT_DATE_TIME_FORMAT , <str> , null ) ; MappingMetaData expected = new MappingMetaData ( <str> , new CompressedXContent ( <str> . getBytes ( StandardCharsets . UTF_8 ) ) , new MappingMetaData . Id ( null ) , new MappingMetaData . Routing ( false , null ) , timestamp , false ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; expected . writeTo ( out ) ; out . close ( ) ; BytesReference bytes = out . bytes ( ) ; MappingMetaData metaData = MappingMetaData . PROTO . readFrom ( StreamInput . wrap ( bytes ) ) ; assertThat ( metaData , is ( expected ) ) ; } { MappingMetaData . Timestamp timestamp = new MappingMetaData . Timestamp ( true , null , TimestampFieldMapper . DEFAULT_DATE_TIME_FORMAT , <str> , false ) ; MappingMetaData expected = new MappingMetaData ( <str> , new CompressedXContent ( <str> . getBytes ( StandardCharsets . UTF_8 ) ) , new MappingMetaData . Id ( null ) , new MappingMetaData . Routing ( false , null ) , timestamp , false ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; expected . writeTo ( out ) ; out . close ( ) ; BytesReference bytes = out . bytes ( ) ; MappingMetaData metaData = MappingMetaData . PROTO . readFrom ( StreamInput . wrap ( bytes ) ) ; assertThat ( metaData , is ( expected ) ) ; } } public void testMergingFielddataLoadingWorks ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , randomBoolean ( ) ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapperParser parser = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper docMapper = parser . parse ( mapping ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . fieldDataType ( ) . getLoading ( ) , equalTo ( MappedFieldType . Loading . LAZY ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . fieldDataType ( ) . getFormat ( indexSettings ) , equalTo ( <str> ) ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , randomBoolean ( ) ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; MergeResult mergeResult = docMapper . merge ( parser . parse ( mapping ) . mapping ( ) , false , false ) ; assertThat ( mergeResult . buildConflicts ( ) . length , equalTo ( <int> ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . fieldDataType ( ) . getLoading ( ) , equalTo ( MappedFieldType . Loading . EAGER ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . fieldDataType ( ) . getFormat ( indexSettings ) , equalTo ( <str> ) ) ; } public void testParsingNotDefaultTwiceDoesNotChangeMapping ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper docMapper = parser . parse ( mapping ) ; docMapper = parser . parse ( docMapper . mappingSource ( ) . string ( ) ) ; assertThat ( docMapper . mappingSource ( ) . string ( ) , equalTo ( mapping ) ) ; } public void testBackcompatParsingTwiceDoesNotChangeTokenizeValue ( ) throws Exception { String [ ] index_options = { <str> , <str> , <str> } ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , index_options [ randomInt ( <int> ) ] ) . field ( <str> , true ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper docMapper = parser . parse ( mapping ) ; boolean tokenized = docMapper . timestampFieldMapper ( ) . fieldType ( ) . tokenized ( ) ; docMapper = parser . parse ( docMapper . mappingSource ( ) . string ( ) ) ; assertThat ( tokenized , equalTo ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . tokenized ( ) ) ) ; } public void testMergingConflicts ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; MapperService mapperService = createIndex ( <str> , indexSettings ) . mapperService ( ) ; DocumentMapper docMapper = mapperService . merge ( <str> , new CompressedXContent ( mapping ) , true , false ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . fieldDataType ( ) . getLoading ( ) , equalTo ( MappedFieldType . Loading . LAZY ) ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; try { mapperService . merge ( <str> , new CompressedXContent ( mapping ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . fieldDataType ( ) . getLoading ( ) , equalTo ( MappedFieldType . Loading . LAZY ) ) ; assertTrue ( docMapper . timestampFieldMapper ( ) . enabled ( ) ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; try { mapperService . merge ( <str> , new CompressedXContent ( mapping ) , false , false ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testBackcompatMergingConflictsForIndexValues ( ) throws Exception { List < String > indexValues = new ArrayList < > ( ) ; indexValues . add ( <str> ) ; indexValues . add ( <str> ) ; indexValues . add ( <str> ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , indexValues . remove ( randomInt ( <int> ) ) ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapperParser parser = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper docMapper = parser . parse ( mapping ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , indexValues . remove ( randomInt ( <int> ) ) ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; MergeResult mergeResult = docMapper . merge ( parser . parse ( mapping ) . mapping ( ) , true , false ) ; List < String > expectedConflicts = new ArrayList < > ( ) ; expectedConflicts . add ( <str> ) ; expectedConflicts . add ( <str> ) ; if ( indexValues . get ( <int> ) . equals ( <str> ) = = false ) { expectedConflicts . add ( <str> ) ; } for ( String conflict : mergeResult . buildConflicts ( ) ) { assertThat ( conflict , isIn ( expectedConflicts ) ) ; } } public void testInitMappers ( ) throws IOException { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , ( String ) null ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; new MappingMetaData ( new CompressedXContent ( mapping ) ) ; } public void testBackcompatMergePaths ( ) throws Exception { String [ ] possiblePathValues = { <str> , <str> , null } ; DocumentMapperParser parser = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) ; XContentBuilder mapping1 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) ; String path1 = possiblePathValues [ randomInt ( <int> ) ] ; if ( path1 ! = null ) { mapping1 . field ( <str> , path1 ) ; } mapping1 . endObject ( ) . endObject ( ) . endObject ( ) ; XContentBuilder mapping2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) ; String path2 = possiblePathValues [ randomInt ( <int> ) ] ; if ( path2 ! = null ) { mapping2 . field ( <str> , path2 ) ; } mapping2 . endObject ( ) . endObject ( ) . endObject ( ) ; assertConflict ( mapping1 . string ( ) , mapping2 . string ( ) , parser , ( path1 = = path2 ? null : <str> ) ) ; } void assertConflict ( String mapping1 , String mapping2 , DocumentMapperParser parser , String conflict ) throws IOException { DocumentMapper docMapper = parser . parse ( mapping1 ) ; docMapper = parser . parse ( docMapper . mappingSource ( ) . string ( ) ) ; MergeResult mergeResult = docMapper . merge ( parser . parse ( mapping2 ) . mapping ( ) , true , false ) ; assertThat ( mergeResult . buildConflicts ( ) . length , equalTo ( conflict = = null ? <int> : <int> ) ) ; if ( conflict ! = null ) { assertThat ( mergeResult . buildConflicts ( ) [ <int> ] , containsString ( conflict ) ) ; } } public void testBackcompatDocValuesSerialization ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; assertDocValuesSerialization ( mapping ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; assertDocValuesSerialization ( mapping ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; assertDocValuesSerialization ( mapping ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; assertDocValuesSerialization ( mapping ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; assertDocValuesSerialization ( mapping ) ; mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , false ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; assertDocValuesSerialization ( mapping ) ; } void assertDocValuesSerialization ( String mapping ) throws Exception { DocumentMapperParser parser = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) ; DocumentMapper docMapper = parser . parse ( mapping ) ; boolean docValues = docMapper . timestampFieldMapper ( ) . fieldType ( ) . hasDocValues ( ) ; docMapper = parser . parse ( docMapper . mappingSource ( ) . string ( ) ) ; assertThat ( docMapper . timestampFieldMapper ( ) . fieldType ( ) . hasDocValues ( ) , equalTo ( docValues ) ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) ) ; } public void testBackcompatPath ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> , BWC_SETTINGS ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; MetaData metaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . getMetaData ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertThat ( request . timestamp ( ) , is ( <str> ) ) ; } public void testIncludeInObjectBackcompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; MetaData metaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . getMetaData ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertEquals ( MappingMetaData . Timestamp . parseStringTimestamp ( <str> , Joda . forPattern ( <str> ) , Version . V_1_4_2 ) , request . timestamp ( ) ) ; assertNull ( docMapper . parse ( <str> , <str> , <str> , doc . bytes ( ) ) . rootDoc ( ) . get ( <str> ) ) ; } public void testIncludeInObjectNotAllowed ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; try { docMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } } public void testThatEpochCanBeIgnoredWithCustomFormat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; MetaData metaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . getMetaData ( ) ; XContentBuilder doc = XContentFactory . jsonBuilder ( ) . startObject ( ) . endObject ( ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( doc ) . timestamp ( <str> ) ; MappingMetaData mappingMetaData = new MappingMetaData ( docMapper ) ; request . process ( metaData , mappingMetaData , true , <str> ) ; assertThat ( request . timestamp ( ) , is ( <str> ) ) ; } public void testThatIndicesBefore2xMustSupportUnixTimestampsInAnyDateFormat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; BytesReference source = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ; Settings oldSettings = settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , randomVersionBetween ( random ( ) , Version . V_0_90_0 , Version . V_1_6_0 ) ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , oldSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; MetaData metaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . getMetaData ( ) ; IndexRequest oldIndexDateIndexRequest = new IndexRequest ( <str> , <str> , <str> ) . source ( source ) . timestamp ( <str> ) ; oldIndexDateIndexRequest . process ( metaData , new MappingMetaData ( docMapper ) , true , <str> ) ; IndexRequest oldIndexTimestampIndexRequest = new IndexRequest ( <str> , <str> , <str> ) . source ( source ) . timestamp ( <str> ) ; oldIndexTimestampIndexRequest . process ( metaData , new MappingMetaData ( docMapper ) , true , <str> ) ; DocumentMapper currentMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; MetaData newMetaData = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . getMetaData ( ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) . source ( source ) . timestamp ( <str> ) ; request . process ( newMetaData , new MappingMetaData ( currentMapper ) , true , <str> ) ; request = new IndexRequest ( <str> , <str> , <str> ) . source ( source ) . timestamp ( <str> ) ; try { request . process ( newMetaData , new MappingMetaData ( currentMapper ) , true , <str> ) ; } catch ( Exception e ) { assertThat ( e . getCause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } } 
