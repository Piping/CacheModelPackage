package org . apache . cassandra . cql3 . statements ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . PartitionUpdate ; final class UpdatesCollector { private final Map < UUID , PartitionColumns > updatedColumns ; private final int updatedRows ; private final Map < String , Map < ByteBuffer , IMutation > > mutations = new HashMap < > ( ) ; public UpdatesCollector ( Map < UUID , PartitionColumns > updatedColumns , int updatedRows ) { super ( ) ; this . updatedColumns = updatedColumns ; this . updatedRows = updatedRows ; } public PartitionUpdate getPartitionUpdate ( CFMetaData cfm , DecoratedKey dk , ConsistencyLevel consistency ) { Mutation mut = getMutation ( cfm , dk , consistency ) ; PartitionUpdate upd = mut . get ( cfm ) ; if ( upd = = null ) { PartitionColumns columns = updatedColumns . get ( cfm . cfId ) ; assert columns ! = null ; upd = new PartitionUpdate ( cfm , dk , columns , updatedRows ) ; mut . add ( upd ) ; } return upd ; } public void validateIndexedColumns ( ) { for ( Map < ByteBuffer , IMutation > perKsMutations : mutations . values ( ) ) for ( IMutation mutation : perKsMutations . values ( ) ) for ( PartitionUpdate update : mutation . getPartitionUpdates ( ) ) Keyspace . openAndGetStore ( update . metadata ( ) ) . indexManager . validate ( update ) ; } private Mutation getMutation ( CFMetaData cfm , DecoratedKey dk , ConsistencyLevel consistency ) { String ksName = cfm . ksName ; IMutation mutation = keyspaceMap ( ksName ) . get ( dk . getKey ( ) ) ; if ( mutation = = null ) { Mutation mut = new Mutation ( ksName , dk ) ; mutation = cfm . isCounter ( ) ? new CounterMutation ( mut , consistency ) : mut ; keyspaceMap ( ksName ) . put ( dk . getKey ( ) , mutation ) ; return mut ; } return cfm . isCounter ( ) ? ( ( CounterMutation ) mutation ) . getMutation ( ) : ( Mutation ) mutation ; } public Collection < IMutation > toMutations ( ) { if ( mutations . size ( ) = = <int> ) return mutations . values ( ) . iterator ( ) . next ( ) . values ( ) ; List < IMutation > ms = new ArrayList < > ( ) ; for ( Map < ByteBuffer , IMutation > ksMap : mutations . values ( ) ) ms . addAll ( ksMap . values ( ) ) ; return ms ; } private Map < ByteBuffer , IMutation > keyspaceMap ( String ksName ) { Map < ByteBuffer , IMutation > ksMap = mutations . get ( ksName ) ; if ( ksMap = = null ) { ksMap = new HashMap < > ( ) ; mutations . put ( ksName , ksMap ) ; } return ksMap ; } } 
