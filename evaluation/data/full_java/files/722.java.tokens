package org . apache . cassandra . io . sstable . metadata ; import java . io . * ; import java . util . * ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . Version ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . io . util . DataOutputStreamPlus ; import org . apache . cassandra . io . util . FileDataInput ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . io . util . BufferedDataOutputStreamPlus ; import org . apache . cassandra . io . util . RandomAccessReader ; import org . apache . cassandra . utils . FBUtilities ; public class MetadataSerializer implements IMetadataSerializer { private static final Logger logger = LoggerFactory . getLogger ( MetadataSerializer . class ) ; public void serialize ( Map < MetadataType , MetadataComponent > components , DataOutputPlus out , Version version ) throws IOException { List < MetadataComponent > sortedComponents = Lists . newArrayList ( components . values ( ) ) ; Collections . sort ( sortedComponents ) ; out . writeInt ( components . size ( ) ) ; int lastPosition = <int> + ( <int> * sortedComponents . size ( ) ) ; for ( MetadataComponent component : sortedComponents ) { MetadataType type = component . getType ( ) ; out . writeInt ( type . ordinal ( ) ) ; out . writeInt ( lastPosition ) ; lastPosition + = type . serializer . serializedSize ( version , component ) ; } for ( MetadataComponent component : sortedComponents ) { component . getType ( ) . serializer . serialize ( version , component , out ) ; } } public Map < MetadataType , MetadataComponent > deserialize ( Descriptor descriptor , EnumSet < MetadataType > types ) throws IOException { Map < MetadataType , MetadataComponent > components ; logger . trace ( <str> , descriptor ) ; File statsFile = new File ( descriptor . filenameFor ( Component . STATS ) ) ; if ( ! statsFile . exists ( ) ) { logger . trace ( <str> , descriptor ) ; components = Maps . newHashMap ( ) ; components . put ( MetadataType . STATS , MetadataCollector . defaultStatsMetadata ( ) ) ; } else { try ( RandomAccessReader r = RandomAccessReader . open ( statsFile ) ) { components = deserialize ( descriptor , r , types ) ; } } return components ; } public MetadataComponent deserialize ( Descriptor descriptor , MetadataType type ) throws IOException { return deserialize ( descriptor , EnumSet . of ( type ) ) . get ( type ) ; } public Map < MetadataType , MetadataComponent > deserialize ( Descriptor descriptor , FileDataInput in , EnumSet < MetadataType > types ) throws IOException { Map < MetadataType , MetadataComponent > components = Maps . newHashMap ( ) ; int numComponents = in . readInt ( ) ; Map < MetadataType , Integer > toc = new HashMap < > ( numComponents ) ; MetadataType [ ] values = MetadataType . values ( ) ; for ( int i = <int> ; i < numComponents ; i + + ) { toc . put ( values [ in . readInt ( ) ] , in . readInt ( ) ) ; } for ( MetadataType type : types ) { Integer offset = toc . get ( type ) ; if ( offset ! = null ) { in . seek ( offset ) ; MetadataComponent component = type . serializer . deserialize ( descriptor . version , in ) ; components . put ( type , component ) ; } } return components ; } public void mutateLevel ( Descriptor descriptor , int newLevel ) throws IOException { logger . trace ( <str> , descriptor . filenameFor ( Component . STATS ) , newLevel ) ; Map < MetadataType , MetadataComponent > currentComponents = deserialize ( descriptor , EnumSet . allOf ( MetadataType . class ) ) ; StatsMetadata stats = ( StatsMetadata ) currentComponents . remove ( MetadataType . STATS ) ; currentComponents . put ( MetadataType . STATS , stats . mutateLevel ( newLevel ) ) ; rewriteSSTableMetadata ( descriptor , currentComponents ) ; } public void mutateRepairedAt ( Descriptor descriptor , long newRepairedAt ) throws IOException { logger . trace ( <str> , descriptor . filenameFor ( Component . STATS ) , newRepairedAt ) ; Map < MetadataType , MetadataComponent > currentComponents = deserialize ( descriptor , EnumSet . allOf ( MetadataType . class ) ) ; StatsMetadata stats = ( StatsMetadata ) currentComponents . remove ( MetadataType . STATS ) ; currentComponents . put ( MetadataType . STATS , stats . mutateRepairedAt ( newRepairedAt ) ) ; rewriteSSTableMetadata ( descriptor , currentComponents ) ; } private void rewriteSSTableMetadata ( Descriptor descriptor , Map < MetadataType , MetadataComponent > currentComponents ) throws IOException { String filePath = descriptor . tmpFilenameFor ( Component . STATS ) ; try ( DataOutputStreamPlus out = new BufferedDataOutputStreamPlus ( new FileOutputStream ( filePath ) ) ) { serialize ( currentComponents , out , descriptor . version ) ; out . flush ( ) ; } if ( FBUtilities . isWindows ( ) ) FileUtils . delete ( descriptor . filenameFor ( Component . STATS ) ) ; FileUtils . renameWithConfirm ( filePath , descriptor . filenameFor ( Component . STATS ) ) ; } } 
