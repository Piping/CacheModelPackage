package org . gradle . api . internal . resolve ; import com . google . common . base . Predicate ; import org . gradle . api . UnknownProjectException ; import org . gradle . api . artifacts . component . ComponentIdentifier ; import org . gradle . api . artifacts . component . LibraryBinaryIdentifier ; import org . gradle . api . artifacts . component . LibraryComponentSelector ; import org . gradle . api . internal . component . ArtifactType ; import org . gradle . internal . component . local . model . LocalComponentMetaData ; import org . gradle . internal . component . local . model . PublishArtifactLocalArtifactMetaData ; import org . gradle . internal . component . model . * ; import org . gradle . internal . resolve . ArtifactResolveException ; import org . gradle . internal . resolve . ModuleVersionResolveException ; import org . gradle . internal . resolve . resolver . ArtifactResolver ; import org . gradle . internal . resolve . resolver . ComponentMetaDataResolver ; import org . gradle . internal . resolve . resolver . DependencyToComponentIdResolver ; import org . gradle . internal . resolve . result . BuildableArtifactResolveResult ; import org . gradle . internal . resolve . result . BuildableArtifactSetResolveResult ; import org . gradle . internal . resolve . result . BuildableComponentIdResolveResult ; import org . gradle . internal . resolve . result . BuildableComponentResolveResult ; import org . gradle . language . base . internal . model . VariantAxisCompatibilityFactory ; import org . gradle . language . base . internal . model . VariantsMetaData ; import org . gradle . language . base . internal . resolve . LibraryResolveException ; import org . gradle . model . ModelMap ; import org . gradle . model . internal . manage . schema . ModelSchemaStore ; import org . gradle . model . internal . registry . ModelRegistry ; import org . gradle . platform . base . BinarySpec ; import org . gradle . platform . base . ComponentSpecContainer ; import org . gradle . platform . base . LibrarySpec ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Set ; public class LocalLibraryDependencyResolver < T extends BinarySpec > implements DependencyToComponentIdResolver , ComponentMetaDataResolver , ArtifactResolver { private final ProjectModelResolver projectModelResolver ; private final VariantsMetaData variantsMetaData ; private final VariantsMatcher matcher ; private final LibraryResolutionErrorMessageBuilder errorMessageBuilder ; private final LocalLibraryMetaDataAdapter libraryMetaDataAdapter ; private final Class < ? extends BinarySpec > binaryType ; private final Predicate < LibrarySpec > binarySpecPredicate ; public LocalLibraryDependencyResolver ( Class < T > binarySpecType , ProjectModelResolver projectModelResolver , List < VariantAxisCompatibilityFactory > selectorFactories , VariantsMetaData variantsMetaData , ModelSchemaStore schemaStore , LocalLibraryMetaDataAdapter libraryMetaDataAdapter , LibraryResolutionErrorMessageBuilder errorMessageBuilder ) { this . projectModelResolver = projectModelResolver ; this . libraryMetaDataAdapter = libraryMetaDataAdapter ; this . matcher = new VariantsMatcher ( selectorFactories , binarySpecType , schemaStore ) ; this . errorMessageBuilder = errorMessageBuilder ; this . variantsMetaData = variantsMetaData ; this . binaryType = binarySpecType ; this . binarySpecPredicate = new Predicate < LibrarySpec > ( ) { @Override public boolean apply ( LibrarySpec input ) { return ! input . getBinaries ( ) . withType ( binaryType ) . isEmpty ( ) ; } } ; } @Override public void resolve ( DependencyMetaData dependency , final BuildableComponentIdResolveResult result ) { if ( dependency . getSelector ( ) instanceof LibraryComponentSelector ) { LibraryComponentSelector selector = ( LibraryComponentSelector ) dependency . getSelector ( ) ; final String selectorProjectPath = selector . getProjectPath ( ) ; final String libraryName = selector . getLibraryName ( ) ; LibraryResolutionErrorMessageBuilder . LibraryResolutionResult resolutionResult = doResolve ( selectorProjectPath , libraryName ) ; LibrarySpec selectedLibrary = resolutionResult . getSelectedLibrary ( ) ; if ( selectedLibrary ! = null ) { Collection < BinarySpec > allBinaries = selectedLibrary . getBinaries ( ) . values ( ) ; Collection < ? extends BinarySpec > compatibleBinaries = matcher . filterBinaries ( variantsMetaData , allBinaries ) ; if ( ! allBinaries . isEmpty ( ) & & compatibleBinaries . isEmpty ( ) ) { result . failed ( new ModuleVersionResolveException ( selector , errorMessageBuilder . noCompatibleVariantErrorMessage ( libraryName , allBinaries ) ) ) ; } else if ( compatibleBinaries . size ( ) > <int> ) { result . failed ( new ModuleVersionResolveException ( selector , errorMessageBuilder . multipleCompatibleVariantsErrorMessage ( libraryName , compatibleBinaries ) ) ) ; } else { BinarySpec selectedBinary = compatibleBinaries . iterator ( ) . next ( ) ; LocalComponentMetaData metaData = libraryMetaDataAdapter . createLocalComponentMetaData ( selectedBinary , selectorProjectPath ) ; result . resolved ( metaData ) ; } } if ( ! result . hasResult ( ) ) { String message = resolutionResult . toResolutionErrorMessage ( binaryType , selector ) ; ModuleVersionResolveException failure = new ModuleVersionResolveException ( selector , new LibraryResolveException ( message ) ) ; result . failed ( failure ) ; } } } private LibraryResolutionErrorMessageBuilder . LibraryResolutionResult doResolve ( String projectPath , String libraryName ) { try { ModelRegistry projectModel = projectModelResolver . resolveProjectModel ( projectPath ) ; ComponentSpecContainer components = projectModel . find ( <str> , ComponentSpecContainer . class ) ; if ( components ! = null ) { ModelMap < ? extends LibrarySpec > libraries = components . withType ( LibrarySpec . class ) ; return LibraryResolutionErrorMessageBuilder . LibraryResolutionResult . of ( libraries . values ( ) , libraryName , binarySpecPredicate ) ; } else { return LibraryResolutionErrorMessageBuilder . LibraryResolutionResult . emptyResolutionResult ( ) ; } } catch ( UnknownProjectException e ) { return LibraryResolutionErrorMessageBuilder . LibraryResolutionResult . projectNotFound ( ) ; } } @Override public void resolve ( ComponentIdentifier identifier , ComponentOverrideMetadata componentOverrideMetadata , BuildableComponentResolveResult result ) { if ( isLibrary ( identifier ) ) { throw new RuntimeException ( <str> ) ; } } private boolean isLibrary ( ComponentIdentifier identifier ) { return identifier instanceof LibraryBinaryIdentifier ; } @Override public void resolveModuleArtifacts ( ComponentResolveMetaData component , ComponentUsage usage , BuildableArtifactSetResolveResult result ) { ComponentIdentifier componentId = component . getComponentId ( ) ; if ( isLibrary ( componentId ) ) { ConfigurationMetaData configuration = component . getConfiguration ( usage . getConfigurationName ( ) ) ; if ( configuration ! = null ) { Set < ComponentArtifactMetaData > artifacts = configuration . getArtifacts ( ) ; result . resolved ( artifacts ) ; } if ( ! result . hasResult ( ) ) { result . failed ( new ArtifactResolveException ( String . format ( <str> , componentId ) ) ) ; } } } @Override public void resolveModuleArtifacts ( ComponentResolveMetaData component , ArtifactType artifactType , BuildableArtifactSetResolveResult result ) { if ( isLibrary ( component . getComponentId ( ) ) ) { result . resolved ( Collections . < ComponentArtifactMetaData > emptyList ( ) ) ; } } @Override public void resolveArtifact ( ComponentArtifactMetaData artifact , ModuleSource moduleSource , BuildableArtifactResolveResult result ) { if ( isLibrary ( artifact . getComponentId ( ) ) ) { if ( artifact instanceof PublishArtifactLocalArtifactMetaData ) { result . resolved ( ( ( PublishArtifactLocalArtifactMetaData ) artifact ) . getFile ( ) ) ; } else { result . failed ( new ArtifactResolveException ( <str> + artifact ) ) ; } } } } 
