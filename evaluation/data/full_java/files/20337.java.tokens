package io . netty . channel ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; public class PendingWriteQueueTest { @Test public void testRemoveAndWrite ( ) { assertWrite ( new TestHandler ( ) { @Override public void flush ( ChannelHandlerContext ctx ) throws Exception { assertFalse ( <str> , ctx . channel ( ) . isWritable ( ) ) ; ChannelFuture future = queue . removeAndWrite ( ) ; future . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { assertQueueEmpty ( queue ) ; } } ) ; super . flush ( ctx ) ; } } , <int> ) ; } @Test public void testRemoveAndWriteAll ( ) { assertWrite ( new TestHandler ( ) { @Override public void flush ( ChannelHandlerContext ctx ) throws Exception { assertFalse ( <str> , ctx . channel ( ) . isWritable ( ) ) ; ChannelFuture future = queue . removeAndWriteAll ( ) ; future . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { assertQueueEmpty ( queue ) ; } } ) ; super . flush ( ctx ) ; } } , <int> ) ; } @Test public void testRemoveAndFail ( ) { assertWriteFails ( new TestHandler ( ) { @Override public void flush ( ChannelHandlerContext ctx ) throws Exception { queue . removeAndFail ( new TestException ( ) ) ; super . flush ( ctx ) ; } } , <int> ) ; } @Test public void testRemoveAndFailAll ( ) { assertWriteFails ( new TestHandler ( ) { @Override public void flush ( ChannelHandlerContext ctx ) throws Exception { queue . removeAndFailAll ( new TestException ( ) ) ; super . flush ( ctx ) ; } } , <int> ) ; } @Test public void shouldFireChannelWritabilityChangedAfterRemoval ( ) { final AtomicReference < ChannelHandlerContext > ctxRef = new AtomicReference < ChannelHandlerContext > ( ) ; final AtomicReference < PendingWriteQueue > queueRef = new AtomicReference < PendingWriteQueue > ( ) ; final ByteBuf msg = Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ; final EmbeddedChannel channel = new EmbeddedChannel ( new ChannelInboundHandlerAdapter ( ) { @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { ctxRef . set ( ctx ) ; queueRef . set ( new PendingWriteQueue ( ctx ) ) ; } @Override public void channelWritabilityChanged ( ChannelHandlerContext ctx ) throws Exception { final PendingWriteQueue queue = queueRef . get ( ) ; final ByteBuf msg = ( ByteBuf ) queue . current ( ) ; if ( msg = = null ) { return ; } assertThat ( msg . refCnt ( ) , is ( <int> ) ) ; queue . remove ( ) ; assertThat ( msg . refCnt ( ) , is ( <int> ) ) ; } } ) ; channel . config ( ) . setWriteBufferLowWaterMark ( <int> ) ; channel . config ( ) . setWriteBufferHighWaterMark ( <int> ) ; final PendingWriteQueue queue = queueRef . get ( ) ; queue . add ( msg , channel . newPromise ( ) ) ; channel . finish ( ) ; assertThat ( msg . refCnt ( ) , is ( <int> ) ) ; } private static void assertWrite ( ChannelHandler handler , int count ) { final ByteBuf buffer = Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ; final EmbeddedChannel channel = new EmbeddedChannel ( handler ) ; channel . config ( ) . setWriteBufferLowWaterMark ( <int> ) ; channel . config ( ) . setWriteBufferHighWaterMark ( <int> ) ; ByteBuf [ ] buffers = new ByteBuf [ count ] ; for ( int i = <int> ; i < buffers . length ; i + + ) { buffers [ i ] = buffer . duplicate ( ) . retain ( ) ; } assertTrue ( channel . writeOutbound ( buffers ) ) ; assertTrue ( channel . finish ( ) ) ; channel . closeFuture ( ) . syncUninterruptibly ( ) ; for ( int i = <int> ; i < buffers . length ; i + + ) { assertBuffer ( channel , buffer ) ; } buffer . release ( ) ; assertNull ( channel . readOutbound ( ) ) ; } private static void assertBuffer ( EmbeddedChannel channel , ByteBuf buffer ) { ByteBuf written = channel . readOutbound ( ) ; assertEquals ( buffer , written ) ; written . release ( ) ; } private static void assertQueueEmpty ( PendingWriteQueue queue ) { assertTrue ( queue . isEmpty ( ) ) ; assertEquals ( <int> , queue . size ( ) ) ; assertNull ( queue . current ( ) ) ; assertNull ( queue . removeAndWrite ( ) ) ; assertNull ( queue . removeAndWriteAll ( ) ) ; } private static void assertWriteFails ( ChannelHandler handler , int count ) { final ByteBuf buffer = Unpooled . copiedBuffer ( <str> , CharsetUtil . US_ASCII ) ; final EmbeddedChannel channel = new EmbeddedChannel ( handler ) ; ByteBuf [ ] buffers = new ByteBuf [ count ] ; for ( int i = <int> ; i < buffers . length ; i + + ) { buffers [ i ] = buffer . duplicate ( ) . retain ( ) ; } try { assertFalse ( channel . writeOutbound ( buffers ) ) ; fail ( ) ; } catch ( Exception e ) { assertTrue ( e instanceof TestException ) ; } assertFalse ( channel . finish ( ) ) ; channel . closeFuture ( ) . syncUninterruptibly ( ) ; buffer . release ( ) ; assertNull ( channel . readOutbound ( ) ) ; } @Test public void testRemoveAndFailAllReentrance ( ) { EmbeddedChannel channel = new EmbeddedChannel ( ) ; final PendingWriteQueue queue = new PendingWriteQueue ( channel . pipeline ( ) . firstContext ( ) ) ; ChannelPromise promise = channel . newPromise ( ) ; promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { queue . removeAndFailAll ( new IllegalStateException ( ) ) ; } } ) ; queue . add ( <int> , promise ) ; ChannelPromise promise2 = channel . newPromise ( ) ; queue . add ( <int> , promise2 ) ; queue . removeAndFailAll ( new Exception ( ) ) ; assertFalse ( promise . isSuccess ( ) ) ; assertFalse ( promise2 . isSuccess ( ) ) ; assertFalse ( channel . finish ( ) ) ; } @Test public void testRemoveAndWriteAllReentrance ( ) { EmbeddedChannel channel = new EmbeddedChannel ( ) ; final PendingWriteQueue queue = new PendingWriteQueue ( channel . pipeline ( ) . firstContext ( ) ) ; ChannelPromise promise = channel . newPromise ( ) ; promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { queue . removeAndWriteAll ( ) ; } } ) ; queue . add ( <int> , promise ) ; ChannelPromise promise2 = channel . newPromise ( ) ; queue . add ( <int> , promise2 ) ; queue . removeAndWriteAll ( ) ; channel . flush ( ) ; assertTrue ( promise . isSuccess ( ) ) ; assertTrue ( promise2 . isSuccess ( ) ) ; assertTrue ( channel . finish ( ) ) ; assertEquals ( <int> , channel . readOutbound ( ) ) ; assertEquals ( <int> , channel . readOutbound ( ) ) ; assertNull ( channel . readOutbound ( ) ) ; assertNull ( channel . readInbound ( ) ) ; } @Test public void testCloseChannelOnCreation ( ) { EmbeddedChannel channel = new EmbeddedChannel ( new ChannelInboundHandlerAdapter ( ) ) ; ChannelHandlerContext context = channel . pipeline ( ) . firstContext ( ) ; channel . close ( ) . syncUninterruptibly ( ) ; final PendingWriteQueue queue = new PendingWriteQueue ( context ) ; IllegalStateException ex = new IllegalStateException ( ) ; ChannelPromise promise = channel . newPromise ( ) ; queue . add ( <int> , promise ) ; queue . removeAndFailAll ( ex ) ; assertSame ( ex , promise . cause ( ) ) ; } private static class TestHandler extends ChannelDuplexHandler { protected PendingWriteQueue queue ; private int expectedSize ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { super . channelActive ( ctx ) ; assertQueueEmpty ( queue ) ; assertTrue ( <str> , ctx . channel ( ) . isWritable ( ) ) ; } @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { queue . add ( msg , promise ) ; assertFalse ( queue . isEmpty ( ) ) ; assertEquals ( + + expectedSize , queue . size ( ) ) ; assertNotNull ( queue . current ( ) ) ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { queue = new PendingWriteQueue ( ctx ) ; } } private static final class TestException extends Exception { } } 
