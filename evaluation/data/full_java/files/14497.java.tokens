package org . gradle . model . dsl . internal . transform ; import com . google . common . base . Joiner ; import org . codehaus . groovy . ast . * ; import org . codehaus . groovy . ast . expr . * ; import org . codehaus . groovy . ast . stmt . BlockStatement ; import org . codehaus . groovy . ast . stmt . ExpressionStatement ; import org . codehaus . groovy . ast . stmt . ReturnStatement ; import org . codehaus . groovy . ast . stmt . Statement ; import org . codehaus . groovy . control . SourceUnit ; import org . codehaus . groovy . syntax . SyntaxException ; import org . codehaus . groovy . syntax . Token ; import org . codehaus . groovy . syntax . Types ; import org . gradle . api . Transformer ; import org . gradle . groovy . scripts . internal . AstUtils ; import org . gradle . groovy . scripts . internal . ExpressionReplacingVisitorSupport ; import org . gradle . internal . SystemProperties ; import org . gradle . model . dsl . internal . inputs . PotentialInputs ; import org . gradle . model . internal . core . ModelPath ; import org . gradle . util . CollectionUtils ; import java . lang . reflect . Modifier ; import java . net . URI ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class RuleVisitor extends ExpressionReplacingVisitorSupport { public static final String INVALID_ARGUMENT_LIST = <str> ; private static final String AST_NODE_METADATA_INPUTS_KEY = RuleVisitor . class . getName ( ) + <str> ; private static final String AST_NODE_METADATA_LOCATION_KEY = RuleVisitor . class . getName ( ) + <str> ; private static final String DOLLAR = <str> ; private static final String GET = <str> ; private static final ClassNode POTENTIAL_INPUTS = new ClassNode ( PotentialInputs . class ) ; private static final ClassNode TRANSFORMED_CLOSURE = new ClassNode ( TransformedClosure . class ) ; private static final ClassNode INPUT_REFERENCES = new ClassNode ( InputReferences . class ) ; private static final ClassNode SOURCE_LOCATION = new ClassNode ( SourceLocation . class ) ; private static final ClassNode RULE_FACTORY = new ClassNode ( ClosureBackedRuleFactory . class ) ; private static final String INPUTS_FIELD_NAME = <str> ; private static final String RULE_FACTORY_FIELD_NAME = <str> ; private static final Token ASSIGN = new Token ( Types . ASSIGN , <str> , - <int> , - <int> ) ; private final String scriptSourceDescription ; private final URI location ; private final SourceUnit sourceUnit ; private InputReferences inputs ; private VariableExpression inputsVariable ; private int nestingDepth ; private int counter ; public RuleVisitor ( SourceUnit sourceUnit , String scriptSourceDescription , URI location ) { this . scriptSourceDescription = scriptSourceDescription ; this . location = location ; this . sourceUnit = sourceUnit ; } public static void visitGeneratedClosure ( ClassNode node ) { MethodNode closureCallMethod = AstUtils . getGeneratedClosureImplMethod ( node ) ; Statement closureCode = closureCallMethod . getCode ( ) ; InputReferences inputs = closureCode . getNodeMetaData ( AST_NODE_METADATA_INPUTS_KEY ) ; if ( inputs ! = null ) { SourceLocation sourceLocation = closureCode . getNodeMetaData ( AST_NODE_METADATA_LOCATION_KEY ) ; node . addInterface ( TRANSFORMED_CLOSURE ) ; FieldNode inputsField = new FieldNode ( INPUTS_FIELD_NAME , Modifier . PRIVATE , POTENTIAL_INPUTS , node , null ) ; FieldNode ruleFactoryField = new FieldNode ( RULE_FACTORY_FIELD_NAME , Modifier . PRIVATE , RULE_FACTORY , node , null ) ; node . addField ( inputsField ) ; node . addField ( ruleFactoryField ) ; List < Statement > statements = new ArrayList < Statement > ( ) ; statements . add ( new ExpressionStatement ( new BinaryExpression ( new FieldExpression ( inputsField ) , ASSIGN , new VariableExpression ( <str> ) ) ) ) ; statements . add ( new ExpressionStatement ( new BinaryExpression ( new FieldExpression ( ruleFactoryField ) , ASSIGN , new VariableExpression ( <str> ) ) ) ) ; node . addMethod ( new MethodNode ( <str> , Modifier . PUBLIC , ClassHelper . VOID_TYPE , new Parameter [ ] { new Parameter ( POTENTIAL_INPUTS , <str> ) , new Parameter ( RULE_FACTORY , <str> ) } , new ClassNode [ <int> ] , new BlockStatement ( statements , new VariableScope ( ) ) ) ) ; VariableExpression inputsVar = new VariableExpression ( <str> , INPUT_REFERENCES ) ; VariableScope methodVarScope = new VariableScope ( ) ; methodVarScope . putDeclaredVariable ( inputsVar ) ; statements = new ArrayList < Statement > ( ) ; statements . add ( new ExpressionStatement ( new DeclarationExpression ( inputsVar , ASSIGN , new ConstructorCallExpression ( INPUT_REFERENCES , new ArgumentListExpression ( ) ) ) ) ) ; for ( InputReference inputReference : inputs . getOwnReferences ( ) ) { statements . add ( new ExpressionStatement ( new MethodCallExpression ( inputsVar , <str> , new ArgumentListExpression ( new ConstantExpression ( inputReference . getPath ( ) ) , new ConstantExpression ( inputReference . getLineNumber ( ) ) ) ) ) ) ; } for ( InputReference inputReference : inputs . getNestedReferences ( ) ) { statements . add ( new ExpressionStatement ( new MethodCallExpression ( inputsVar , <str> , new ArgumentListExpression ( new ConstantExpression ( inputReference . getPath ( ) ) , new ConstantExpression ( inputReference . getLineNumber ( ) ) ) ) ) ) ; } statements . add ( new ReturnStatement ( inputsVar ) ) ; node . addMethod ( new MethodNode ( <str> , Modifier . PUBLIC , INPUT_REFERENCES , new Parameter [ <int> ] , new ClassNode [ <int> ] , new BlockStatement ( statements , methodVarScope ) ) ) ; statements = new ArrayList < Statement > ( ) ; statements . add ( new ReturnStatement ( new ConstructorCallExpression ( SOURCE_LOCATION , new ArgumentListExpression ( Arrays . < Expression > asList ( new ConstantExpression ( sourceLocation . getUri ( ) . toString ( ) ) , new ConstantExpression ( sourceLocation . toString ( ) ) , new ConstantExpression ( sourceLocation . getExpression ( ) ) , new ConstantExpression ( sourceLocation . getLineNumber ( ) ) , new ConstantExpression ( sourceLocation . getColumnNumber ( ) ) ) ) ) ) ) ; node . addMethod ( new MethodNode ( <str> , Modifier . PUBLIC , SOURCE_LOCATION , new Parameter [ <int> ] , new ClassNode [ <int> ] , new BlockStatement ( statements , new VariableScope ( ) ) ) ) ; } } public void visitRuleClosure ( ClosureExpression expression , Expression invocation , String invocationDisplayName ) { InputReferences parentInputs = inputs ; VariableExpression parentInputsVariable = inputsVariable ; try { inputs = new InputReferences ( ) ; inputsVariable = new VariableExpression ( <str> + ( counter + + ) , POTENTIAL_INPUTS ) ; inputsVariable . setClosureSharedVariable ( true ) ; super . visitClosureExpression ( expression ) ; BlockStatement code = ( BlockStatement ) expression . getCode ( ) ; code . setNodeMetaData ( AST_NODE_METADATA_LOCATION_KEY , new SourceLocation ( location , scriptSourceDescription , invocationDisplayName , invocation . getLineNumber ( ) , invocation . getColumnNumber ( ) ) ) ; code . setNodeMetaData ( AST_NODE_METADATA_INPUTS_KEY , inputs ) ; if ( parentInputsVariable ! = null ) { expression . getVariableScope ( ) . putReferencedLocalVariable ( parentInputsVariable ) ; } code . getVariableScope ( ) . putDeclaredVariable ( inputsVariable ) ; if ( parentInputsVariable = = null ) { DeclarationExpression variableDeclaration = new DeclarationExpression ( inputsVariable , ASSIGN , new VariableExpression ( INPUTS_FIELD_NAME ) ) ; code . getStatements ( ) . add ( <int> , new ExpressionStatement ( variableDeclaration ) ) ; } else { DeclarationExpression variableDeclaration = new DeclarationExpression ( inputsVariable , ASSIGN , new ElvisOperatorExpression ( new VariableExpression ( INPUTS_FIELD_NAME ) , parentInputsVariable ) ) ; code . getStatements ( ) . add ( <int> , new ExpressionStatement ( variableDeclaration ) ) ; } for ( Parameter parameter : expression . getParameters ( ) ) { if ( parameter . hasInitialExpression ( ) ) { code . getStatements ( ) . add ( <int> , new ExpressionStatement ( new BinaryExpression ( new VariableExpression ( parameter . getName ( ) ) , ASSIGN , parameter . getInitialExpression ( ) ) ) ) ; parameter . setInitialExpression ( ConstantExpression . NULL ) ; } } } finally { if ( parentInputs ! = null ) { parentInputs . addNestedReferences ( inputs ) ; } inputs = parentInputs ; inputsVariable = parentInputsVariable ; } } @Override public void visitClosureExpression ( ClosureExpression expression ) { nestingDepth + + ; try { expression . getVariableScope ( ) . putReferencedLocalVariable ( inputsVariable ) ; super . visitClosureExpression ( expression ) ; } finally { nestingDepth - - ; } } @Override public void visitPropertyExpression ( PropertyExpression expr ) { String modelPath = isDollarPathExpression ( expr ) ; if ( modelPath ! = null ) { inputs . ownReference ( modelPath , expr . getLineNumber ( ) ) ; replaceVisitedExpressionWith ( inputReferenceExpression ( modelPath ) ) ; } else { super . visitPropertyExpression ( expr ) ; } } private String isDollarPathExpression ( PropertyExpression expr ) { if ( expr . isSafe ( ) | | expr . isSpreadSafe ( ) ) { return null ; } if ( expr . getObjectExpression ( ) instanceof VariableExpression ) { VariableExpression objectExpression = ( VariableExpression ) expr . getObjectExpression ( ) ; if ( objectExpression . getName ( ) . equals ( DOLLAR ) ) { return expr . getPropertyAsString ( ) ; } else { return null ; } } if ( expr . getObjectExpression ( ) instanceof PropertyExpression ) { PropertyExpression objectExpression = ( PropertyExpression ) expr . getObjectExpression ( ) ; String path = isDollarPathExpression ( objectExpression ) ; if ( path ! = null ) { return path + <str> + expr . getPropertyAsString ( ) ; } else { return null ; } } return null ; } @Override public void visitExpressionStatement ( ExpressionStatement stat ) { if ( nestingDepth = = <int> & & stat . getExpression ( ) instanceof MethodCallExpression ) { MethodCallExpression call = ( MethodCallExpression ) stat . getExpression ( ) ; if ( call . isImplicitThis ( ) & & call . getArguments ( ) instanceof ArgumentListExpression ) { ArgumentListExpression arguments = ( ArgumentListExpression ) call . getArguments ( ) ; if ( ! arguments . getExpressions ( ) . isEmpty ( ) ) { Expression lastArg = arguments . getExpression ( arguments . getExpressions ( ) . size ( ) - <int> ) ; if ( lastArg instanceof ClosureExpression ) { ClosureExpression closureExpression = ( ClosureExpression ) lastArg ; visitRuleClosure ( closureExpression , call , displayName ( call ) ) ; Expression replaced = new StaticMethodCallExpression ( RULE_FACTORY , <str> , new ArgumentListExpression ( new VariableExpression ( RULE_FACTORY_FIELD_NAME ) , closureExpression ) ) ; arguments . getExpressions ( ) . set ( arguments . getExpressions ( ) . size ( ) - <int> , replaced ) ; return ; } } } } super . visitExpressionStatement ( stat ) ; } @Override public void visitMethodCallExpression ( MethodCallExpression call ) { String methodName = call . getMethodAsString ( ) ; if ( call . isImplicitThis ( ) & & methodName ! = null & & methodName . equals ( DOLLAR ) ) { visitInputMethod ( call ) ; return ; } super . visitMethodCallExpression ( call ) ; } private void visitInputMethod ( MethodCallExpression call ) { ConstantExpression argExpression = AstUtils . hasSingleConstantStringArg ( call ) ; if ( argExpression = = null ) { error ( call , INVALID_ARGUMENT_LIST ) ; } else { String modelPath = argExpression . getText ( ) ; if ( modelPath . isEmpty ( ) ) { error ( argExpression , INVALID_ARGUMENT_LIST ) ; return ; } try { ModelPath . validatePath ( modelPath ) ; } catch ( ModelPath . InvalidPathException e ) { String message = <str> + SystemProperties . getInstance ( ) . getLineSeparator ( ) + <str> + e . getMessage ( ) ; if ( e . getCause ( ) ! = null ) { message + = SystemProperties . getInstance ( ) . getLineSeparator ( ) + <str> + e . getCause ( ) . getMessage ( ) ; } error ( argExpression , message ) ; return ; } inputs . ownReference ( modelPath , call . getLineNumber ( ) ) ; replaceVisitedExpressionWith ( inputReferenceExpression ( modelPath ) ) ; } } private MethodCallExpression inputReferenceExpression ( String modelPath ) { return new MethodCallExpression ( new VariableExpression ( inputsVariable ) , new ConstantExpression ( GET ) , new ArgumentListExpression ( new ConstantExpression ( modelPath ) ) ) ; } private void error ( ASTNode call , String message ) { SyntaxException syntaxException = new SyntaxException ( message , call . getLineNumber ( ) , call . getColumnNumber ( ) ) ; sourceUnit . getErrorCollector ( ) . addError ( syntaxException , sourceUnit ) ; } public static String displayName ( MethodCallExpression expression ) { StringBuilder builder = new StringBuilder ( ) ; if ( ! expression . isImplicitThis ( ) ) { builder . append ( expression . getObjectExpression ( ) . getText ( ) ) ; builder . append ( <str> ) ; } builder . append ( expression . getMethodAsString ( ) ) ; if ( expression . getArguments ( ) instanceof ArgumentListExpression ) { ArgumentListExpression arguments = ( ArgumentListExpression ) expression . getArguments ( ) ; boolean hasTrailingClosure = ! arguments . getExpressions ( ) . isEmpty ( ) & & arguments . getExpression ( arguments . getExpressions ( ) . size ( ) - <int> ) instanceof ClosureExpression ; List < Expression > otherArgs = hasTrailingClosure ? arguments . getExpressions ( ) . subList ( <int> , arguments . getExpressions ( ) . size ( ) - <int> ) : arguments . getExpressions ( ) ; if ( ! otherArgs . isEmpty ( ) | | ! hasTrailingClosure ) { builder . append ( <str> ) ; builder . append ( Joiner . on ( <str> ) . join ( CollectionUtils . collect ( otherArgs , new Transformer < Object , Expression > ( ) { @Override public Object transform ( Expression expression ) { return expression . getText ( ) ; } } ) ) ) ; builder . append ( <str> ) ; } if ( hasTrailingClosure ) { builder . append ( <str> ) ; } } else { builder . append ( <str> ) ; } return builder . toString ( ) ; } } 
