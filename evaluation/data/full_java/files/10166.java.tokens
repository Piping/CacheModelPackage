package com . google . common . testing ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . base . Converter ; import com . google . common . base . Function ; import com . google . common . base . Supplier ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableMultimap ; import com . google . common . collect . ImmutableMultiset ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . ImmutableSortedSet ; import com . google . common . collect . ImmutableTable ; import com . google . common . collect . Maps ; import com . google . common . collect . Multimap ; import com . google . common . collect . Multiset ; import com . google . common . collect . Table ; import com . google . common . reflect . TypeToken ; import com . google . common . testing . NullPointerTester . Visibility ; import com . google . common . testing . anotherpackage . SomeClassThatDoesNotUseNullable ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . SortedSet ; import javax . annotation . Nullable ; public class NullPointerTesterTest extends TestCase { public static class FooException extends RuntimeException { private static final long serialVersionUID = <int> ; } @SuppressWarnings ( <str> ) public static class OneArg { public static void staticOneArgCorrectlyThrowsNpe ( String s ) { checkNotNull ( s ) ; } public static void staticOneArgThrowsOtherThanNpe ( String s ) { throw new FooException ( ) ; } public static void staticOneArgShouldThrowNpeButDoesnt ( String s ) { } public static void staticOneArgNullableCorrectlyDoesNotThrowNPE ( @Nullable String s ) { } public static void staticOneArgNullableCorrectlyThrowsOtherThanNPE ( @Nullable String s ) { throw new FooException ( ) ; } public static void staticOneArgNullableThrowsNPE ( @Nullable String s ) { checkNotNull ( s ) ; } public void oneArgCorrectlyThrowsNpe ( String s ) { checkNotNull ( s ) ; } public void oneArgThrowsOtherThanNpe ( String s ) { throw new FooException ( ) ; } public void oneArgShouldThrowNpeButDoesnt ( String s ) { } public void oneArgNullableCorrectlyDoesNotThrowNPE ( @Nullable String s ) { } public void oneArgNullableCorrectlyThrowsOtherThanNPE ( @Nullable String s ) { throw new FooException ( ) ; } public void oneArgNullableThrowsNPE ( @Nullable String s ) { checkNotNull ( s ) ; } } private static final String [ ] STATIC_ONE_ARG_METHODS_SHOULD_PASS = { <str> , <str> , <str> , <str> , } ; private static final String [ ] STATIC_ONE_ARG_METHODS_SHOULD_FAIL = { <str> , <str> , } ; private static final String [ ] NONSTATIC_ONE_ARG_METHODS_SHOULD_PASS = { <str> , <str> , <str> , <str> , } ; private static final String [ ] NONSTATIC_ONE_ARG_METHODS_SHOULD_FAIL = { <str> , <str> , } ; private static class ThrowsIae { public static void christenPoodle ( String name ) { checkArgument ( name ! = null ) ; } } private static class ThrowsNpe { public static void christenPoodle ( String name ) { checkNotNull ( name ) ; } } private static class ThrowsUoe { public static void christenPoodle ( String name ) { throw new UnsupportedOperationException ( ) ; } } private static class ThrowsSomethingElse { public static void christenPoodle ( String name ) { throw new RuntimeException ( ) ; } } public void testDontAcceptIae ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( ThrowsNpe . class ) ; tester . testAllPublicStaticMethods ( ThrowsUoe . class ) ; try { tester . testAllPublicStaticMethods ( ThrowsIae . class ) ; } catch ( AssertionFailedError expected ) { return ; } fail ( ) ; } public void testStaticOneArgMethodsThatShouldPass ( ) throws Exception { for ( String methodName : STATIC_ONE_ARG_METHODS_SHOULD_PASS ) { Method method = OneArg . class . getMethod ( methodName , String . class ) ; try { new NullPointerTester ( ) . testMethodParameter ( new OneArg ( ) , method , <int> ) ; } catch ( AssertionFailedError unexpected ) { fail ( <str> + methodName ) ; } } } public void testStaticOneArgMethodsThatShouldFail ( ) throws Exception { for ( String methodName : STATIC_ONE_ARG_METHODS_SHOULD_FAIL ) { Method method = OneArg . class . getMethod ( methodName , String . class ) ; boolean foundProblem = false ; try { new NullPointerTester ( ) . testMethodParameter ( new OneArg ( ) , method , <int> ) ; } catch ( AssertionFailedError expected ) { foundProblem = true ; } assertTrue ( <str> + methodName , foundProblem ) ; } } public void testNonStaticOneArgMethodsThatShouldPass ( ) throws Exception { OneArg foo = new OneArg ( ) ; for ( String methodName : NONSTATIC_ONE_ARG_METHODS_SHOULD_PASS ) { Method method = OneArg . class . getMethod ( methodName , String . class ) ; try { new NullPointerTester ( ) . testMethodParameter ( foo , method , <int> ) ; } catch ( AssertionFailedError unexpected ) { fail ( <str> + methodName ) ; } } } public void testNonStaticOneArgMethodsThatShouldFail ( ) throws Exception { OneArg foo = new OneArg ( ) ; for ( String methodName : NONSTATIC_ONE_ARG_METHODS_SHOULD_FAIL ) { Method method = OneArg . class . getMethod ( methodName , String . class ) ; boolean foundProblem = false ; try { new NullPointerTester ( ) . testMethodParameter ( foo , method , <int> ) ; } catch ( AssertionFailedError expected ) { foundProblem = true ; } assertTrue ( <str> + methodName , foundProblem ) ; } } public static class TwoArg { public enum Action { THROW_A_NPE { @Override public void act ( ) { throw new NullPointerException ( ) ; } } , THROW_OTHER { @Override public void act ( ) { throw new FooException ( ) ; } } , JUST_RETURN { @Override public void act ( ) { } } ; public abstract void act ( ) ; } Action actionWhenFirstParamIsNull ; Action actionWhenSecondParamIsNull ; public TwoArg ( Action actionWhenFirstParamIsNull , Action actionWhenSecondParamIsNull ) { this . actionWhenFirstParamIsNull = actionWhenFirstParamIsNull ; this . actionWhenSecondParamIsNull = actionWhenSecondParamIsNull ; } public void reactToNullParameters ( Object first , Object second ) { if ( first = = null ) { actionWhenFirstParamIsNull . act ( ) ; } if ( second = = null ) { actionWhenSecondParamIsNull . act ( ) ; } } public void normalNormal ( String first , Integer second ) { reactToNullParameters ( first , second ) ; } public void normalNullable ( String first , @Nullable Integer second ) { reactToNullParameters ( first , second ) ; } public void nullableNormal ( @Nullable String first , Integer second ) { reactToNullParameters ( first , second ) ; } public void nullableNullable ( @Nullable String first , @Nullable Integer second ) { reactToNullParameters ( first , second ) ; } @Override public String toString ( ) { return rootLocaleFormat ( <str> , actionWhenFirstParamIsNull , actionWhenSecondParamIsNull ) ; } } public void verifyBarPass ( Method method , TwoArg bar ) { try { new NullPointerTester ( ) . testMethod ( bar , method ) ; } catch ( AssertionFailedError incorrectError ) { String errorMessage = rootLocaleFormat ( <str> , method . getName ( ) , bar ) ; assertNull ( errorMessage , incorrectError ) ; } } public void verifyBarFail ( Method method , TwoArg bar ) { try { new NullPointerTester ( ) . testMethod ( bar , method ) ; } catch ( AssertionFailedError expected ) { return ; } String errorMessage = rootLocaleFormat ( <str> , method . getName ( ) , bar ) ; fail ( errorMessage ) ; } public void testTwoArgNormalNormal ( ) throws Exception { Method method = TwoArg . class . getMethod ( <str> , String . class , Integer . class ) ; for ( TwoArg . Action first : TwoArg . Action . values ( ) ) { for ( TwoArg . Action second : TwoArg . Action . values ( ) ) { TwoArg bar = new TwoArg ( first , second ) ; if ( first . equals ( TwoArg . Action . THROW_A_NPE ) & & second . equals ( TwoArg . Action . THROW_A_NPE ) ) { verifyBarPass ( method , bar ) ; } else { verifyBarFail ( method , bar ) ; } } } } public void testTwoArgNormalNullable ( ) throws Exception { Method method = TwoArg . class . getMethod ( <str> , String . class , Integer . class ) ; for ( TwoArg . Action first : TwoArg . Action . values ( ) ) { for ( TwoArg . Action second : TwoArg . Action . values ( ) ) { TwoArg bar = new TwoArg ( first , second ) ; if ( first . equals ( TwoArg . Action . THROW_A_NPE ) ) { verifyBarPass ( method , bar ) ; } else { verifyBarFail ( method , bar ) ; } } } } public void testTwoArgNullableNormal ( ) throws Exception { Method method = TwoArg . class . getMethod ( <str> , String . class , Integer . class ) ; for ( TwoArg . Action first : TwoArg . Action . values ( ) ) { for ( TwoArg . Action second : TwoArg . Action . values ( ) ) { TwoArg bar = new TwoArg ( first , second ) ; if ( second . equals ( TwoArg . Action . THROW_A_NPE ) ) { verifyBarPass ( method , bar ) ; } else { verifyBarFail ( method , bar ) ; } } } } public void testTwoArgNullableNullable ( ) throws Exception { Method method = TwoArg . class . getMethod ( <str> , String . class , Integer . class ) ; for ( TwoArg . Action first : TwoArg . Action . values ( ) ) { for ( TwoArg . Action second : TwoArg . Action . values ( ) ) { TwoArg bar = new TwoArg ( first , second ) ; verifyBarPass ( method , bar ) ; } } } @SuppressWarnings ( <str> ) private static class PassObject extends SomeClassThatDoesNotUseNullable { public static void doThrow ( Object arg ) { if ( arg = = null ) { throw new FooException ( ) ; } } public void noArg ( ) { } public void oneArg ( String s ) { checkNotNull ( s ) ; } void packagePrivateOneArg ( String s ) { checkNotNull ( s ) ; } protected void protectedOneArg ( String s ) { checkNotNull ( s ) ; } public void oneNullableArg ( @Nullable String s ) { } public void oneNullableArgThrows ( @Nullable String s ) { doThrow ( s ) ; } public void twoArg ( String s , Integer i ) { checkNotNull ( s ) ; i . intValue ( ) ; } public void twoMixedArgs ( String s , @Nullable Integer i ) { checkNotNull ( s ) ; } public void twoMixedArgsThrows ( String s , @Nullable Integer i ) { checkNotNull ( s ) ; doThrow ( i ) ; } public void twoMixedArgs ( @Nullable Integer i , String s ) { checkNotNull ( s ) ; } public void twoMixedArgsThrows ( @Nullable Integer i , String s ) { checkNotNull ( s ) ; doThrow ( i ) ; } public void twoNullableArgs ( @Nullable String s , @javax.annotation.Nullable Integer i ) { } public void twoNullableArgsThrowsFirstArg ( @Nullable String s , @Nullable Integer i ) { doThrow ( s ) ; } public void twoNullableArgsThrowsSecondArg ( @Nullable String s , @Nullable Integer i ) { doThrow ( i ) ; } public static void staticOneArg ( String s ) { checkNotNull ( s ) ; } public static void staticOneNullableArg ( @Nullable String s ) { } public static void staticOneNullableArgThrows ( @Nullable String s ) { doThrow ( s ) ; } } public void testGoodClass ( ) { shouldPass ( new PassObject ( ) ) ; } private static class FailOneArgDoesntThrowNPE extends PassObject { @Override public void oneArg ( String s ) { } } public void testFailOneArgDoesntThrowNpe ( ) { shouldFail ( new FailOneArgDoesntThrowNPE ( ) ) ; } private static class FailOneArgThrowsWrongType extends PassObject { @Override public void oneArg ( String s ) { doThrow ( s ) ; } } public void testFailOneArgThrowsWrongType ( ) { shouldFail ( new FailOneArgThrowsWrongType ( ) ) ; } private static class PassOneNullableArgThrowsNPE extends PassObject { @Override public void oneNullableArg ( @Nullable String s ) { checkNotNull ( s ) ; } } public void testPassOneNullableArgThrowsNPE ( ) { shouldPass ( new PassOneNullableArgThrowsNPE ( ) ) ; } private static class FailTwoArgsFirstArgDoesntThrowNPE extends PassObject { @Override public void twoArg ( String s , Integer i ) { i . intValue ( ) ; } } public void testFailTwoArgsFirstArgDoesntThrowNPE ( ) { shouldFail ( new FailTwoArgsFirstArgDoesntThrowNPE ( ) ) ; } private static class FailTwoArgsFirstArgThrowsWrongType extends PassObject { @Override public void twoArg ( String s , Integer i ) { doThrow ( s ) ; i . intValue ( ) ; } } public void testFailTwoArgsFirstArgThrowsWrongType ( ) { shouldFail ( new FailTwoArgsFirstArgThrowsWrongType ( ) ) ; } private static class FailTwoArgsSecondArgDoesntThrowNPE extends PassObject { @Override public void twoArg ( String s , Integer i ) { checkNotNull ( s ) ; } } public void testFailTwoArgsSecondArgDoesntThrowNPE ( ) { shouldFail ( new FailTwoArgsSecondArgDoesntThrowNPE ( ) ) ; } private static class FailTwoArgsSecondArgThrowsWrongType extends PassObject { @Override public void twoArg ( String s , Integer i ) { checkNotNull ( s ) ; doThrow ( i ) ; } } public void testFailTwoArgsSecondArgThrowsWrongType ( ) { shouldFail ( new FailTwoArgsSecondArgThrowsWrongType ( ) ) ; } private static class FailTwoMixedArgsFirstArgDoesntThrowNPE extends PassObject { @Override public void twoMixedArgs ( String s , @Nullable Integer i ) { } } public void testFailTwoMixedArgsFirstArgDoesntThrowNPE ( ) { shouldFail ( new FailTwoMixedArgsFirstArgDoesntThrowNPE ( ) ) ; } private static class FailTwoMixedArgsFirstArgThrowsWrongType extends PassObject { @Override public void twoMixedArgs ( String s , @Nullable Integer i ) { doThrow ( s ) ; } } public void testFailTwoMixedArgsFirstArgThrowsWrongType ( ) { shouldFail ( new FailTwoMixedArgsFirstArgThrowsWrongType ( ) ) ; } private static class PassTwoMixedArgsNullableArgThrowsNPE extends PassObject { @Override public void twoMixedArgs ( String s , @Nullable Integer i ) { checkNotNull ( s ) ; i . intValue ( ) ; } } public void testPassTwoMixedArgsNullableArgThrowsNPE ( ) { shouldPass ( new PassTwoMixedArgsNullableArgThrowsNPE ( ) ) ; } private static class PassTwoMixedArgSecondNullableArgThrowsOther extends PassObject { @Override public void twoMixedArgs ( String s , @Nullable Integer i ) { checkNotNull ( s ) ; doThrow ( i ) ; } } public void testPassTwoMixedArgSecondNullableArgThrowsOther ( ) { shouldPass ( new PassTwoMixedArgSecondNullableArgThrowsOther ( ) ) ; } private static class FailTwoMixedArgsSecondArgDoesntThrowNPE extends PassObject { @Override public void twoMixedArgs ( @Nullable Integer i , String s ) { } } public void testFailTwoMixedArgsSecondArgDoesntThrowNPE ( ) { shouldFail ( new FailTwoMixedArgsSecondArgDoesntThrowNPE ( ) ) ; } private static class FailTwoMixedArgsSecondArgThrowsWrongType extends PassObject { @Override public void twoMixedArgs ( @Nullable Integer i , String s ) { doThrow ( s ) ; } } public void testFailTwoMixedArgsSecondArgThrowsWrongType ( ) { shouldFail ( new FailTwoMixedArgsSecondArgThrowsWrongType ( ) ) ; } private static class PassTwoNullableArgsFirstThrowsNPE extends PassObject { @Override public void twoNullableArgs ( @Nullable String s , @Nullable Integer i ) { checkNotNull ( s ) ; } } public void testPassTwoNullableArgsFirstThrowsNPE ( ) { shouldPass ( new PassTwoNullableArgsFirstThrowsNPE ( ) ) ; } private static class PassTwoNullableArgsFirstThrowsOther extends PassObject { @Override public void twoNullableArgs ( @Nullable String s , @Nullable Integer i ) { doThrow ( s ) ; } } public void testPassTwoNullableArgsFirstThrowsOther ( ) { shouldPass ( new PassTwoNullableArgsFirstThrowsOther ( ) ) ; } private static class PassTwoNullableArgsSecondThrowsNPE extends PassObject { @Override public void twoNullableArgs ( @Nullable String s , @Nullable Integer i ) { i . intValue ( ) ; } } public void testPassTwoNullableArgsSecondThrowsNPE ( ) { shouldPass ( new PassTwoNullableArgsSecondThrowsNPE ( ) ) ; } private static class PassTwoNullableArgsSecondThrowsOther extends PassObject { @Override public void twoNullableArgs ( @Nullable String s , @Nullable Integer i ) { doThrow ( i ) ; } } public void testPassTwoNullableArgsSecondThrowsOther ( ) { shouldPass ( new PassTwoNullableArgsSecondThrowsOther ( ) ) ; } private static class PassTwoNullableArgsNeitherThrowsAnything extends PassObject { @Override public void twoNullableArgs ( @Nullable String s , @Nullable Integer i ) { } } public void testPassTwoNullableArgsNeitherThrowsAnything ( ) { shouldPass ( new PassTwoNullableArgsNeitherThrowsAnything ( ) ) ; } @SuppressWarnings ( <str> ) private abstract static class BaseClassThatFailsToThrow { public void oneArg ( String s ) { } } private static class SubclassWithBadSuperclass extends BaseClassThatFailsToThrow { } public void testSubclassWithBadSuperclass ( ) { shouldFail ( new SubclassWithBadSuperclass ( ) ) ; } @SuppressWarnings ( <str> ) private abstract static class BaseClassThatFailsToThrowForPackagePrivate { void packagePrivateOneArg ( String s ) { } } private static class SubclassWithBadSuperclassForPackagePrivate extends BaseClassThatFailsToThrowForPackagePrivate { } public void testSubclassWithBadSuperclassForPackagePrivateMethod ( ) { shouldFail ( new SubclassWithBadSuperclassForPackagePrivate ( ) , Visibility . PACKAGE ) ; } @SuppressWarnings ( <str> ) private abstract static class BaseClassThatFailsToThrowForProtected { protected void protectedOneArg ( String s ) { } } private static class SubclassWithBadSuperclassForProtected extends BaseClassThatFailsToThrowForProtected { } public void testSubclassWithBadSuperclassForPackageProtectedMethod ( ) { shouldFail ( new SubclassWithBadSuperclassForProtected ( ) , Visibility . PROTECTED ) ; } private static class SubclassThatOverridesBadSuperclassMethod extends BaseClassThatFailsToThrow { @Override public void oneArg ( @Nullable String s ) { } } public void testSubclassThatOverridesBadSuperclassMethod ( ) { shouldPass ( new SubclassThatOverridesBadSuperclassMethod ( ) ) ; } @SuppressWarnings ( <str> ) private static class SubclassOverridesTheWrongMethod extends BaseClassThatFailsToThrow { public void oneArg ( @Nullable CharSequence s ) { } } public void testSubclassOverridesTheWrongMethod ( ) { shouldFail ( new SubclassOverridesTheWrongMethod ( ) ) ; } @SuppressWarnings ( <str> ) private static class ClassThatFailsToThrowForStatic { static void staticOneArg ( String s ) { } } public void testClassThatFailsToThrowForStatic ( ) { shouldFail ( ClassThatFailsToThrowForStatic . class ) ; } private static class SubclassThatFailsToThrowForStatic extends ClassThatFailsToThrowForStatic { } public void testSubclassThatFailsToThrowForStatic ( ) { shouldFail ( SubclassThatFailsToThrowForStatic . class ) ; } private static class SubclassThatTriesToOverrideBadStaticMethod extends ClassThatFailsToThrowForStatic { static void staticOneArg ( @Nullable String s ) { } } public void testSubclassThatTriesToOverrideBadStaticMethod ( ) { shouldFail ( SubclassThatTriesToOverrideBadStaticMethod . class ) ; } private static final class HardToCreate { private HardToCreate ( HardToCreate x ) { } } @SuppressWarnings ( <str> ) private static class CanCreateDefault { public void foo ( @Nullable HardToCreate ignored , String required ) { checkNotNull ( required ) ; } } public void testCanCreateDefault ( ) { shouldPass ( new CanCreateDefault ( ) ) ; } @SuppressWarnings ( <str> ) private static class CannotCreateDefault { public void foo ( HardToCreate ignored , String required ) { checkNotNull ( ignored ) ; checkNotNull ( required ) ; } } public void testCannotCreateDefault ( ) { shouldFail ( new CannotCreateDefault ( ) ) ; } private static void shouldPass ( Object instance , Visibility visibility ) { new NullPointerTester ( ) . testInstanceMethods ( instance , visibility ) ; } private static void shouldPass ( Object instance ) { shouldPass ( instance , Visibility . PACKAGE ) ; shouldPass ( instance , Visibility . PROTECTED ) ; shouldPass ( instance , Visibility . PUBLIC ) ; } private static void shouldFail ( Object instance , Visibility visibility ) { try { new NullPointerTester ( ) . testInstanceMethods ( instance , visibility ) ; } catch ( AssertionFailedError expected ) { return ; } fail ( <str> + instance . getClass ( ) . getSimpleName ( ) ) ; } private static void shouldFail ( Object instance ) { shouldFail ( instance , Visibility . PACKAGE ) ; shouldFail ( instance , Visibility . PROTECTED ) ; shouldFail ( instance , Visibility . PUBLIC ) ; } private static void shouldFail ( Class < ? > cls , Visibility visibility ) { try { new NullPointerTester ( ) . testStaticMethods ( cls , visibility ) ; } catch ( AssertionFailedError expected ) { return ; } fail ( <str> + cls . getSimpleName ( ) ) ; } private static void shouldFail ( Class < ? > cls ) { shouldFail ( cls , Visibility . PACKAGE ) ; } @SuppressWarnings ( <str> ) private static class PrivateClassWithPrivateConstructor { private PrivateClassWithPrivateConstructor ( @Nullable Integer argument ) { } } public void testPrivateClass ( ) { NullPointerTester tester = new NullPointerTester ( ) ; for ( Constructor < ? > constructor : PrivateClassWithPrivateConstructor . class . getDeclaredConstructors ( ) ) { tester . testConstructor ( constructor ) ; } } private interface Foo < T > { void doSomething ( T bar , Integer baz ) ; } private static class StringFoo implements Foo < String > { @Override public void doSomething ( String bar , Integer baz ) { checkNotNull ( bar ) ; checkNotNull ( baz ) ; } } public void testBridgeMethodIgnored ( ) { new NullPointerTester ( ) . testAllPublicInstanceMethods ( new StringFoo ( ) ) ; } private abstract static class DefaultValueChecker { private final Map < Integer , Object > arguments = Maps . newHashMap ( ) ; final DefaultValueChecker runTester ( ) { new NullPointerTester ( ) . testInstanceMethods ( this , Visibility . PACKAGE ) ; return this ; } final void assertNonNullValues ( Object . . . expectedValues ) { assertEquals ( expectedValues . length , arguments . size ( ) ) ; for ( int i = <int> ; i < expectedValues . length ; i + + ) { assertEquals ( <str> + i , expectedValues [ i ] , arguments . get ( i ) ) ; } } final Object getDefaultParameterValue ( int position ) { return arguments . get ( position ) ; } final void calledWith ( Object . . . args ) { for ( int i = <int> ; i < args . length ; i + + ) { if ( args [ i ] ! = null ) { arguments . put ( i , args [ i ] ) ; } } for ( Object arg : args ) { checkNotNull ( arg ) ; } } } private enum Gender { MALE , FEMALE } private static class AllDefaultValuesChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkDefaultValuesForTheseTypes ( Gender gender , Integer integer , int i , String string , CharSequence charSequence , List < String > list , ImmutableList < Integer > immutableList , Map < String , Integer > map , ImmutableMap < String , String > immutableMap , Set < String > set , ImmutableSet < Integer > immutableSet , SortedSet < Number > sortedSet , ImmutableSortedSet < Number > immutableSortedSet , Multiset < String > multiset , ImmutableMultiset < Integer > immutableMultiset , Multimap < String , Integer > multimap , ImmutableMultimap < String , Integer > immutableMultimap , Table < String , Integer , Exception > table , ImmutableTable < Integer , String , Exception > immutableTable ) { calledWith ( gender , integer , i , string , charSequence , list , immutableList , map , immutableMap , set , immutableSet , sortedSet , immutableSortedSet , multiset , immutableMultiset , multimap , immutableMultimap , table , immutableTable ) ; } final void check ( ) { runTester ( ) . assertNonNullValues ( Gender . MALE , Integer . valueOf ( <int> ) , <int> , <str> , <str> , ImmutableList . of ( ) , ImmutableList . of ( ) , ImmutableMap . of ( ) , ImmutableMap . of ( ) , ImmutableSet . of ( ) , ImmutableSet . of ( ) , ImmutableSortedSet . of ( ) , ImmutableSortedSet . of ( ) , ImmutableMultiset . of ( ) , ImmutableMultiset . of ( ) , ImmutableMultimap . of ( ) , ImmutableMultimap . of ( ) , ImmutableTable . of ( ) , ImmutableTable . of ( ) ) ; } } public void testDefaultValues ( ) { new AllDefaultValuesChecker ( ) . check ( ) ; } private static class ObjectArrayDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( Object [ ] array , String s ) { calledWith ( array , s ) ; } void check ( ) { runTester ( ) ; Object [ ] defaultArray = ( Object [ ] ) getDefaultParameterValue ( <int> ) ; assertThat ( defaultArray ) . isEmpty ( ) ; } } public void testObjectArrayDefaultValue ( ) { new ObjectArrayDefaultValueChecker ( ) . check ( ) ; } private static class StringArrayDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( String [ ] array , String s ) { calledWith ( array , s ) ; } void check ( ) { runTester ( ) ; String [ ] defaultArray = ( String [ ] ) getDefaultParameterValue ( <int> ) ; assertThat ( defaultArray ) . isEmpty ( ) ; } } public void testStringArrayDefaultValue ( ) { new StringArrayDefaultValueChecker ( ) . check ( ) ; } private static class IntArrayDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( int [ ] array , String s ) { calledWith ( array , s ) ; } void check ( ) { runTester ( ) ; int [ ] defaultArray = ( int [ ] ) getDefaultParameterValue ( <int> ) ; assertEquals ( <int> , defaultArray . length ) ; } } public void testIntArrayDefaultValue ( ) { new IntArrayDefaultValueChecker ( ) . check ( ) ; } private enum EmptyEnum { } private static class EmptyEnumDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( EmptyEnum object , String s ) { calledWith ( object , s ) ; } void check ( ) { try { runTester ( ) ; } catch ( AssertionFailedError expected ) { return ; } fail ( <str> ) ; } } public void testEmptyEnumDefaultValue ( ) { new EmptyEnumDefaultValueChecker ( ) . check ( ) ; } private static class GenericClassTypeDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( Class < ? extends List < ? > > cls , String s ) { calledWith ( cls , s ) ; } void check ( ) { runTester ( ) ; Class < ? > defaultClass = ( Class < ? > ) getDefaultParameterValue ( <int> ) ; assertEquals ( List . class , defaultClass ) ; } } public void testGenericClassDefaultValue ( ) { new GenericClassTypeDefaultValueChecker ( ) . check ( ) ; } private static class NonGenericClassTypeDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( @SuppressWarnings ( <str> ) Class cls , String s ) { calledWith ( cls , s ) ; } void check ( ) { runTester ( ) ; Class < ? > defaultClass = ( Class < ? > ) getDefaultParameterValue ( <int> ) ; assertEquals ( Object . class , defaultClass ) ; } } public void testNonGenericClassDefaultValue ( ) { new NonGenericClassTypeDefaultValueChecker ( ) . check ( ) ; } private static class GenericTypeTokenDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( TypeToken < ? extends List < ? super Number > > type , String s ) { calledWith ( type , s ) ; } void check ( ) { runTester ( ) ; TypeToken < ? > defaultType = ( TypeToken < ? > ) getDefaultParameterValue ( <int> ) ; assertTrue ( new TypeToken < List < ? super Number > > ( ) { } . isSupertypeOf ( defaultType ) ) ; } } public void testGenericTypeTokenDefaultValue ( ) { new GenericTypeTokenDefaultValueChecker ( ) . check ( ) ; } private static class NonGenericTypeTokenDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( @SuppressWarnings ( <str> ) TypeToken type , String s ) { calledWith ( type , s ) ; } void check ( ) { runTester ( ) ; TypeToken < ? > defaultType = ( TypeToken < ? > ) getDefaultParameterValue ( <int> ) ; assertEquals ( new TypeToken < Object > ( ) { } , defaultType ) ; } } public void testNonGenericTypeTokenDefaultValue ( ) { new NonGenericTypeTokenDefaultValueChecker ( ) . check ( ) ; } private interface FromTo < F , T > extends Function < F , T > { } private static class GenericInterfaceDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( FromTo < String , Integer > f , String s ) { calledWith ( f , s ) ; } void check ( ) { runTester ( ) ; FromTo < ? , ? > defaultFunction = ( FromTo < ? , ? > ) getDefaultParameterValue ( <int> ) ; assertEquals ( <int> , defaultFunction . apply ( null ) ) ; } } public void testGenericInterfaceDefaultValue ( ) { new GenericInterfaceDefaultValueChecker ( ) . check ( ) ; } private interface NullRejectingFromTo < F , T > extends Function < F , T > { @Override public abstract T apply ( F from ) ; } private static class NullRejectingInterfaceDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( NullRejectingFromTo < String , Integer > f , String s ) { calledWith ( f , s ) ; } void check ( ) { runTester ( ) ; NullRejectingFromTo < ? , ? > defaultFunction = ( NullRejectingFromTo < ? , ? > ) getDefaultParameterValue ( <int> ) ; assertNotNull ( defaultFunction ) ; try { defaultFunction . apply ( null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } } public void testNullRejectingInterfaceDefaultValue ( ) { new NullRejectingInterfaceDefaultValueChecker ( ) . check ( ) ; } private static class MultipleInterfacesDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public < T extends FromTo < String , Integer > & Supplier < Long > > void checkArray ( T f , String s ) { calledWith ( f , s ) ; } void check ( ) { runTester ( ) ; FromTo < ? , ? > defaultFunction = ( FromTo < ? , ? > ) getDefaultParameterValue ( <int> ) ; assertEquals ( <int> , defaultFunction . apply ( null ) ) ; Supplier < ? > defaultSupplier = ( Supplier < ? > ) defaultFunction ; assertEquals ( Long . valueOf ( <int> ) , defaultSupplier . get ( ) ) ; } } public void testMultipleInterfacesDefaultValue ( ) { new MultipleInterfacesDefaultValueChecker ( ) . check ( ) ; } private static class GenericInterface2DefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( FromTo < String , FromTo < Integer , String > > f , String s ) { calledWith ( f , s ) ; } void check ( ) { runTester ( ) ; FromTo < ? , ? > defaultFunction = ( FromTo < ? , ? > ) getDefaultParameterValue ( <int> ) ; FromTo < ? , ? > returnValue = ( FromTo < ? , ? > ) defaultFunction . apply ( null ) ; assertEquals ( <str> , returnValue . apply ( null ) ) ; } } public void testGenericInterfaceReturnedByGenericMethod ( ) { new GenericInterface2DefaultValueChecker ( ) . check ( ) ; } private abstract static class AbstractGenericDefaultValueChecker < T > extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkGeneric ( T value , String s ) { calledWith ( value , s ) ; } } private static class GenericDefaultValueResolvedToStringChecker extends AbstractGenericDefaultValueChecker < String > { void check ( ) { runTester ( ) ; assertEquals ( <str> , getDefaultParameterValue ( <int> ) ) ; } } public void testGenericTypeResolvedForDefaultValue ( ) { new GenericDefaultValueResolvedToStringChecker ( ) . check ( ) ; } private abstract static class AbstractGenericDefaultValueForPackagePrivateMethodChecker < T > extends DefaultValueChecker { @SuppressWarnings ( <str> ) void checkGeneric ( T value , String s ) { calledWith ( value , s ) ; } } private static class DefaultValueForPackagePrivateMethodResolvedToStringChecker extends AbstractGenericDefaultValueForPackagePrivateMethodChecker < String > { void check ( ) { runTester ( ) ; assertEquals ( <str> , getDefaultParameterValue ( <int> ) ) ; } } public void testDefaultValueResolvedForPackagePrivateMethod ( ) { new DefaultValueForPackagePrivateMethodResolvedToStringChecker ( ) . check ( ) ; } private static class ConverterDefaultValueChecker extends DefaultValueChecker { @SuppressWarnings ( <str> ) public void checkArray ( Converter < String , Integer > c , String s ) { calledWith ( c , s ) ; } void check ( ) { runTester ( ) ; @SuppressWarnings ( <str> ) Converter < String , Integer > defaultConverter = ( Converter < String , Integer > ) getDefaultParameterValue ( <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , defaultConverter . convert ( <str> ) ) ; assertEquals ( <str> , defaultConverter . reverse ( ) . convert ( <int> ) ) ; assertNull ( defaultConverter . convert ( null ) ) ; assertNull ( defaultConverter . reverse ( ) . convert ( null ) ) ; } } public void testConverterDefaultValue ( ) { new ConverterDefaultValueChecker ( ) . check ( ) ; } private static class VisibilityMethods { @SuppressWarnings ( <str> ) private void privateMethod ( ) { } @SuppressWarnings ( <str> ) void packagePrivateMethod ( ) { } @SuppressWarnings ( <str> ) protected void protectedMethod ( ) { } @SuppressWarnings ( <str> ) public void publicMethod ( ) { } } public void testVisibility_public ( ) throws Exception { assertFalse ( Visibility . PUBLIC . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertFalse ( Visibility . PUBLIC . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertFalse ( Visibility . PUBLIC . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertTrue ( Visibility . PUBLIC . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; } public void testVisibility_protected ( ) throws Exception { assertFalse ( Visibility . PROTECTED . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertFalse ( Visibility . PROTECTED . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertTrue ( Visibility . PROTECTED . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertTrue ( Visibility . PROTECTED . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; } public void testVisibility_package ( ) throws Exception { assertFalse ( Visibility . PACKAGE . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertTrue ( Visibility . PACKAGE . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertTrue ( Visibility . PACKAGE . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; assertTrue ( Visibility . PACKAGE . isVisible ( VisibilityMethods . class . getDeclaredMethod ( <str> ) ) ) ; } private class Inner { public Inner ( String s ) { checkNotNull ( s ) ; } } public void testNonStaticInnerClass ( ) { try { new NullPointerTester ( ) . testAllPublicConstructors ( Inner . class ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertThat ( expected . getMessage ( ) ) . contains ( <str> ) ; } } private static String rootLocaleFormat ( String format , Object . . . args ) { return String . format ( Locale . ROOT , format , args ) ; } } 
