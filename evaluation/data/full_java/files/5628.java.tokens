package org . elasticsearch . cluster . routing . allocation . decider ; import com . carrotsearch . hppc . ObjectLookupContainer ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . ClusterInfo ; import org . elasticsearch . cluster . ClusterInfoService ; import org . elasticsearch . cluster . DiskUsage ; import org . elasticsearch . cluster . EmptyClusterInfoService ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . RatioValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . util . Set ; public class DiskThresholdDecider extends AllocationDecider { public static final String NAME = <str> ; private volatile Double freeDiskThresholdLow ; private volatile Double freeDiskThresholdHigh ; private volatile ByteSizeValue freeBytesThresholdLow ; private volatile ByteSizeValue freeBytesThresholdHigh ; private volatile boolean includeRelocations ; private volatile boolean enabled ; private volatile TimeValue rerouteInterval ; public static final String CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS = <str> ; public static final String CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL = <str> ; class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { String newLowWatermark = settings . get ( CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , null ) ; String newHighWatermark = settings . get ( CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , null ) ; Boolean newRelocationsSetting = settings . getAsBoolean ( CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS , null ) ; Boolean newEnableSetting = settings . getAsBoolean ( CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , null ) ; TimeValue newRerouteInterval = settings . getAsTime ( CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL , null ) ; if ( newEnableSetting ! = null ) { logger . info ( <str> , CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , DiskThresholdDecider . this . enabled , newEnableSetting ) ; DiskThresholdDecider . this . enabled = newEnableSetting ; } if ( newRelocationsSetting ! = null ) { logger . info ( <str> , CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS , DiskThresholdDecider . this . includeRelocations , newRelocationsSetting ) ; DiskThresholdDecider . this . includeRelocations = newRelocationsSetting ; } if ( newLowWatermark ! = null ) { if ( ! validWatermarkSetting ( newLowWatermark , CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK ) ) { throw new ElasticsearchParseException ( <str> , newLowWatermark ) ; } logger . info ( <str> , CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , newLowWatermark ) ; DiskThresholdDecider . this . freeDiskThresholdLow = <float> - thresholdPercentageFromWatermark ( newLowWatermark ) ; DiskThresholdDecider . this . freeBytesThresholdLow = thresholdBytesFromWatermark ( newLowWatermark , CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK ) ; } if ( newHighWatermark ! = null ) { if ( ! validWatermarkSetting ( newHighWatermark , CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK ) ) { throw new ElasticsearchParseException ( <str> , newHighWatermark ) ; } logger . info ( <str> , CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , newHighWatermark ) ; DiskThresholdDecider . this . freeDiskThresholdHigh = <float> - thresholdPercentageFromWatermark ( newHighWatermark ) ; DiskThresholdDecider . this . freeBytesThresholdHigh = thresholdBytesFromWatermark ( newHighWatermark , CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK ) ; } if ( newRerouteInterval ! = null ) { logger . info ( <str> , CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL , newRerouteInterval ) ; DiskThresholdDecider . this . rerouteInterval = newRerouteInterval ; } } } class DiskListener implements ClusterInfoService . Listener { private final Client client ; private final Set < String > nodeHasPassedWatermark = Sets . newConcurrentHashSet ( ) ; private long lastRunNS ; DiskListener ( Client client ) { this . client = client ; } private void warnAboutDiskIfNeeded ( DiskUsage usage ) { if ( usage . getFreeBytes ( ) < DiskThresholdDecider . this . freeBytesThresholdHigh . bytes ( ) ) { logger . warn ( <str> , DiskThresholdDecider . this . freeBytesThresholdHigh , usage ) ; } else if ( usage . getFreeBytes ( ) < DiskThresholdDecider . this . freeBytesThresholdLow . bytes ( ) ) { logger . info ( <str> , DiskThresholdDecider . this . freeBytesThresholdLow , usage ) ; } if ( usage . getFreeDiskAsPercentage ( ) < DiskThresholdDecider . this . freeDiskThresholdHigh ) { logger . warn ( <str> , Strings . format1Decimals ( <float> - DiskThresholdDecider . this . freeDiskThresholdHigh , <str> ) , usage ) ; } else if ( usage . getFreeDiskAsPercentage ( ) < DiskThresholdDecider . this . freeDiskThresholdLow ) { logger . info ( <str> , Strings . format1Decimals ( <float> - DiskThresholdDecider . this . freeDiskThresholdLow , <str> ) , usage ) ; } } @Override public void onNewInfo ( ClusterInfo info ) { ImmutableOpenMap < String , DiskUsage > usages = info . getNodeLeastAvailableDiskUsages ( ) ; if ( usages ! = null ) { boolean reroute = false ; String explanation = <str> ; ObjectLookupContainer < String > nodes = usages . keys ( ) ; for ( String node : nodeHasPassedWatermark ) { if ( nodes . contains ( node ) = = false ) { nodeHasPassedWatermark . remove ( node ) ; } } for ( ObjectObjectCursor < String , DiskUsage > entry : usages ) { String node = entry . key ; DiskUsage usage = entry . value ; warnAboutDiskIfNeeded ( usage ) ; if ( usage . getFreeBytes ( ) < DiskThresholdDecider . this . freeBytesThresholdHigh . bytes ( ) | | usage . getFreeDiskAsPercentage ( ) < DiskThresholdDecider . this . freeDiskThresholdHigh ) { if ( ( System . nanoTime ( ) - lastRunNS ) > DiskThresholdDecider . this . rerouteInterval . nanos ( ) ) { lastRunNS = System . nanoTime ( ) ; reroute = true ; explanation = <str> ; } else { logger . debug ( <str> , node , DiskThresholdDecider . this . rerouteInterval ) ; } nodeHasPassedWatermark . add ( node ) ; } else if ( usage . getFreeBytes ( ) < DiskThresholdDecider . this . freeBytesThresholdLow . bytes ( ) | | usage . getFreeDiskAsPercentage ( ) < DiskThresholdDecider . this . freeDiskThresholdLow ) { nodeHasPassedWatermark . add ( node ) ; } else { if ( nodeHasPassedWatermark . contains ( node ) ) { if ( ( System . nanoTime ( ) - lastRunNS ) > DiskThresholdDecider . this . rerouteInterval . nanos ( ) ) { lastRunNS = System . nanoTime ( ) ; reroute = true ; explanation = <str> ; nodeHasPassedWatermark . remove ( node ) ; } else { logger . debug ( <str> , node , DiskThresholdDecider . this . rerouteInterval ) ; } } } } if ( reroute ) { logger . info ( <str> , explanation ) ; client . admin ( ) . cluster ( ) . prepareReroute ( ) . execute ( ) ; } } } } public DiskThresholdDecider ( Settings settings ) { this ( settings , new NodeSettingsService ( settings ) , EmptyClusterInfoService . INSTANCE , null ) ; } @Inject public DiskThresholdDecider ( Settings settings , NodeSettingsService nodeSettingsService , ClusterInfoService infoService , Client client ) { super ( settings ) ; String lowWatermark = settings . get ( CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK , <str> ) ; String highWatermark = settings . get ( CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK , <str> ) ; if ( ! validWatermarkSetting ( lowWatermark , CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK ) ) { throw new ElasticsearchParseException ( <str> , lowWatermark ) ; } if ( ! validWatermarkSetting ( highWatermark , CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK ) ) { throw new ElasticsearchParseException ( <str> , highWatermark ) ; } this . freeDiskThresholdLow = <float> - thresholdPercentageFromWatermark ( lowWatermark ) ; this . freeDiskThresholdHigh = <float> - thresholdPercentageFromWatermark ( highWatermark ) ; this . freeBytesThresholdLow = thresholdBytesFromWatermark ( lowWatermark , CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK ) ; this . freeBytesThresholdHigh = thresholdBytesFromWatermark ( highWatermark , CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK ) ; this . includeRelocations = settings . getAsBoolean ( CLUSTER_ROUTING_ALLOCATION_INCLUDE_RELOCATIONS , true ) ; this . rerouteInterval = settings . getAsTime ( CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL , TimeValue . timeValueSeconds ( <int> ) ) ; this . enabled = settings . getAsBoolean ( CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; infoService . addListener ( new DiskListener ( client ) ) ; } ApplySettings newApplySettings ( ) { return new ApplySettings ( ) ; } public Double getFreeDiskThresholdLow ( ) { return freeDiskThresholdLow ; } public Double getFreeDiskThresholdHigh ( ) { return freeDiskThresholdHigh ; } public Double getUsedDiskThresholdLow ( ) { return <float> - freeDiskThresholdLow ; } public Double getUsedDiskThresholdHigh ( ) { return <float> - freeDiskThresholdHigh ; } public ByteSizeValue getFreeBytesThresholdLow ( ) { return freeBytesThresholdLow ; } public ByteSizeValue getFreeBytesThresholdHigh ( ) { return freeBytesThresholdHigh ; } public boolean isIncludeRelocations ( ) { return includeRelocations ; } public boolean isEnabled ( ) { return enabled ; } public TimeValue getRerouteInterval ( ) { return rerouteInterval ; } public static long sizeOfRelocatingShards ( RoutingNode node , ClusterInfo clusterInfo , boolean subtractShardsMovingAway , String dataPath ) { long totalSize = <int> ; for ( ShardRouting routing : node . shardsWithState ( ShardRoutingState . RELOCATING , ShardRoutingState . INITIALIZING ) ) { String actualPath = clusterInfo . getDataPath ( routing ) ; if ( dataPath . equals ( actualPath ) ) { if ( routing . initializing ( ) & & routing . relocatingNodeId ( ) ! = null ) { totalSize + = getShardSize ( routing , clusterInfo ) ; } else if ( subtractShardsMovingAway & & routing . relocating ( ) ) { totalSize - = getShardSize ( routing , clusterInfo ) ; } } } return totalSize ; } static long getShardSize ( ShardRouting routing , ClusterInfo clusterInfo ) { Long shardSize = clusterInfo . getShardSize ( routing ) ; return shardSize = = null ? <int> : shardSize ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { ClusterInfo clusterInfo = allocation . clusterInfo ( ) ; ImmutableOpenMap < String , DiskUsage > usages = clusterInfo . getNodeMostAvailableDiskUsages ( ) ; final Decision decision = earlyTerminate ( allocation , usages ) ; if ( decision ! = null ) { return decision ; } final double usedDiskThresholdLow = <float> - DiskThresholdDecider . this . freeDiskThresholdLow ; final double usedDiskThresholdHigh = <float> - DiskThresholdDecider . this . freeDiskThresholdHigh ; DiskUsage usage = getDiskUsage ( node , allocation , usages ) ; double freeDiskPercentage = usage . getFreeDiskAsPercentage ( ) ; double usedDiskPercentage = usage . getUsedDiskAsPercentage ( ) ; long freeBytes = usage . getFreeBytes ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , node . nodeId ( ) , usedDiskPercentage ) ; } boolean primaryHasBeenAllocated = shardRouting . primary ( ) & & shardRouting . allocatedPostIndexCreate ( ) ; if ( freeBytes < freeBytesThresholdLow . bytes ( ) ) { if ( ! shardRouting . primary ( ) | | ( shardRouting . primary ( ) & & primaryHasBeenAllocated ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , freeBytesThresholdLow , freeBytes , node . nodeId ( ) ) ; } return allocation . decision ( Decision . NO , NAME , <str> , freeBytesThresholdLow , new ByteSizeValue ( freeBytes ) ) ; } else if ( freeBytes > freeBytesThresholdHigh . bytes ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + <str> , freeBytesThresholdLow , freeBytes , node . nodeId ( ) ) ; } return allocation . decision ( Decision . YES , NAME , <str> ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + <str> , freeBytesThresholdHigh , freeBytes , node . nodeId ( ) ) ; } return allocation . decision ( Decision . NO , NAME , <str> , freeBytesThresholdHigh , new ByteSizeValue ( freeBytes ) ) ; } } if ( freeDiskPercentage < freeDiskThresholdLow ) { if ( ! shardRouting . primary ( ) | | ( shardRouting . primary ( ) & & primaryHasBeenAllocated ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , Strings . format1Decimals ( usedDiskThresholdLow , <str> ) , Strings . format1Decimals ( usedDiskPercentage , <str> ) , node . nodeId ( ) ) ; } return allocation . decision ( Decision . NO , NAME , <str> , usedDiskThresholdLow , freeDiskPercentage ) ; } else if ( freeDiskPercentage > freeDiskThresholdHigh ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + <str> , Strings . format1Decimals ( usedDiskThresholdLow , <str> ) , Strings . format1Decimals ( usedDiskPercentage , <str> ) , node . nodeId ( ) ) ; } return allocation . decision ( Decision . YES , NAME , <str> ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + <str> , Strings . format1Decimals ( freeDiskThresholdHigh , <str> ) , Strings . format1Decimals ( freeDiskPercentage , <str> ) , node . nodeId ( ) ) ; } return allocation . decision ( Decision . NO , NAME , <str> , usedDiskThresholdHigh , freeDiskPercentage ) ; } } final long shardSize = getShardSize ( shardRouting , allocation . clusterInfo ( ) ) ; double freeSpaceAfterShard = freeDiskPercentageAfterShardAssigned ( usage , shardSize ) ; long freeBytesAfterShard = freeBytes - shardSize ; if ( freeBytesAfterShard < freeBytesThresholdHigh . bytes ( ) ) { logger . warn ( <str> , node . nodeId ( ) , freeBytesThresholdHigh , freeBytesAfterShard ) ; return allocation . decision ( Decision . NO , NAME , <str> , freeBytesThresholdLow , new ByteSizeValue ( freeBytesAfterShard ) ) ; } if ( freeSpaceAfterShard < freeDiskThresholdHigh ) { logger . warn ( <str> , node . nodeId ( ) , Strings . format1Decimals ( freeDiskThresholdHigh , <str> ) , Strings . format1Decimals ( freeSpaceAfterShard , <str> ) ) ; return allocation . decision ( Decision . NO , NAME , <str> , usedDiskThresholdLow , freeSpaceAfterShard ) ; } return allocation . decision ( Decision . YES , NAME , <str> , new ByteSizeValue ( freeBytes ) ) ; } @Override public Decision canRemain ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { if ( shardRouting . currentNodeId ( ) . equals ( node . nodeId ( ) ) = = false ) { throw new IllegalArgumentException ( <str> + shardRouting + <str> + node . nodeId ( ) + <str> ) ; } final ClusterInfo clusterInfo = allocation . clusterInfo ( ) ; final ImmutableOpenMap < String , DiskUsage > usages = clusterInfo . getNodeLeastAvailableDiskUsages ( ) ; final Decision decision = earlyTerminate ( allocation , usages ) ; if ( decision ! = null ) { return decision ; } final DiskUsage usage = getDiskUsage ( node , allocation , usages ) ; final String dataPath = clusterInfo . getDataPath ( shardRouting ) ; final double freeDiskPercentage = usage . getFreeDiskAsPercentage ( ) ; final long freeBytes = usage . getFreeBytes ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , node . nodeId ( ) , freeDiskPercentage , freeBytes ) ; } if ( dataPath = = null | | usage . getPath ( ) . equals ( dataPath ) = = false ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } if ( freeBytes < freeBytesThresholdHigh . bytes ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , freeBytesThresholdHigh , freeBytes , node . nodeId ( ) ) ; } return allocation . decision ( Decision . NO , NAME , <str> , freeBytesThresholdHigh , new ByteSizeValue ( freeBytes ) ) ; } if ( freeDiskPercentage < freeDiskThresholdHigh ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , freeDiskThresholdHigh , freeDiskPercentage , node . nodeId ( ) ) ; } return allocation . decision ( Decision . NO , NAME , <str> , freeDiskThresholdHigh , freeDiskPercentage ) ; } return allocation . decision ( Decision . YES , NAME , <str> , new ByteSizeValue ( freeBytes ) ) ; } private DiskUsage getDiskUsage ( RoutingNode node , RoutingAllocation allocation , ImmutableOpenMap < String , DiskUsage > usages ) { ClusterInfo clusterInfo = allocation . clusterInfo ( ) ; DiskUsage usage = usages . get ( node . nodeId ( ) ) ; if ( usage = = null ) { usage = averageUsage ( node , usages ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , node . nodeId ( ) , usage . getTotalBytes ( ) , usage . getFreeBytes ( ) , usage . getFreeDiskAsPercentage ( ) ) ; } } if ( includeRelocations ) { long relocatingShardsSize = sizeOfRelocatingShards ( node , clusterInfo , true , usage . getPath ( ) ) ; DiskUsage usageIncludingRelocations = new DiskUsage ( node . nodeId ( ) , node . node ( ) . name ( ) , usage . getPath ( ) , usage . getTotalBytes ( ) , usage . getFreeBytes ( ) - relocatingShardsSize ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , usage ) ; logger . trace ( <str> , relocatingShardsSize , usageIncludingRelocations ) ; } usage = usageIncludingRelocations ; } return usage ; } public DiskUsage averageUsage ( RoutingNode node , ImmutableOpenMap < String , DiskUsage > usages ) { if ( usages . size ( ) = = <int> ) { return new DiskUsage ( node . nodeId ( ) , node . node ( ) . name ( ) , <str> , <int> , <int> ) ; } long totalBytes = <int> ; long freeBytes = <int> ; for ( ObjectCursor < DiskUsage > du : usages . values ( ) ) { totalBytes + = du . value . getTotalBytes ( ) ; freeBytes + = du . value . getFreeBytes ( ) ; } return new DiskUsage ( node . nodeId ( ) , node . node ( ) . name ( ) , <str> , totalBytes / usages . size ( ) , freeBytes / usages . size ( ) ) ; } public double freeDiskPercentageAfterShardAssigned ( DiskUsage usage , Long shardSize ) { shardSize = ( shardSize = = null ) ? <int> : shardSize ; DiskUsage newUsage = new DiskUsage ( usage . getNodeId ( ) , usage . getNodeName ( ) , usage . getPath ( ) , usage . getTotalBytes ( ) , usage . getFreeBytes ( ) - shardSize ) ; return newUsage . getFreeDiskAsPercentage ( ) ; } public double thresholdPercentageFromWatermark ( String watermark ) { try { return RatioValue . parseRatioValue ( watermark ) . getAsPercent ( ) ; } catch ( ElasticsearchParseException ex ) { return <float> ; } } public ByteSizeValue thresholdBytesFromWatermark ( String watermark , String settingName ) { try { return ByteSizeValue . parseBytesSizeValue ( watermark , settingName ) ; } catch ( ElasticsearchParseException ex ) { return ByteSizeValue . parseBytesSizeValue ( <str> , settingName ) ; } } public boolean validWatermarkSetting ( String watermark , String settingName ) { try { RatioValue . parseRatioValue ( watermark ) ; return true ; } catch ( ElasticsearchParseException e ) { try { ByteSizeValue . parseBytesSizeValue ( watermark , settingName ) ; return true ; } catch ( ElasticsearchParseException ex ) { return false ; } } } private Decision earlyTerminate ( RoutingAllocation allocation , ImmutableOpenMap < String , DiskUsage > usages ) { if ( ! enabled ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } if ( allocation . nodes ( ) . dataNodes ( ) . size ( ) < = <int> ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } return allocation . decision ( Decision . YES , NAME , <str> ) ; } final ClusterInfo clusterInfo = allocation . clusterInfo ( ) ; if ( clusterInfo = = null ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } return allocation . decision ( Decision . YES , NAME , <str> ) ; } if ( usages . isEmpty ( ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } return allocation . decision ( Decision . YES , NAME , <str> ) ; } return null ; } } 
