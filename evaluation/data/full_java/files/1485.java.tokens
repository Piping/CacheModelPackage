package org . apache . cassandra . db . compaction ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . metrics . RestorableMeter ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . Pair ; import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . getBuckets ; import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . mostInterestingBucket ; import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . trimToThresholdWithHotness ; import static org . apache . cassandra . db . compaction . SizeTieredCompactionStrategy . validateOptions ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class SizeTieredCompactionStrategyTest { public static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) ) ; } @Test public void testOptionsValidation ( ) throws ConfigurationException { Map < String , String > options = new HashMap < > ( ) ; options . put ( SizeTieredCompactionStrategyOptions . BUCKET_LOW_KEY , <str> ) ; options . put ( SizeTieredCompactionStrategyOptions . BUCKET_HIGH_KEY , <str> ) ; options . put ( SizeTieredCompactionStrategyOptions . MIN_SSTABLE_SIZE_KEY , <str> ) ; Map < String , String > unvalidated = validateOptions ( options ) ; assertTrue ( unvalidated . isEmpty ( ) ) ; try { options . put ( SizeTieredCompactionStrategyOptions . BUCKET_LOW_KEY , <str> ) ; validateOptions ( options ) ; fail ( <str> ) ; } catch ( ConfigurationException e ) { options . put ( SizeTieredCompactionStrategyOptions . BUCKET_LOW_KEY , <str> ) ; } options . put ( <str> , <str> ) ; unvalidated = validateOptions ( options ) ; assertTrue ( unvalidated . containsKey ( <str> ) ) ; } @Test public void testGetBuckets ( ) { List < Pair < String , Long > > pairs = new ArrayList < Pair < String , Long > > ( ) ; String [ ] strings = { <str> , <str> , <str> , <str> , <str> , <str> } ; for ( String st : strings ) { Pair < String , Long > pair = Pair . create ( st , new Long ( st . length ( ) ) ) ; pairs . add ( pair ) ; } List < List < String > > buckets = getBuckets ( pairs , <float> , <float> , <int> ) ; assertEquals ( <int> , buckets . size ( ) ) ; for ( List < String > bucket : buckets ) { assertEquals ( <int> , bucket . size ( ) ) ; assertEquals ( bucket . get ( <int> ) . length ( ) , bucket . get ( <int> ) . length ( ) ) ; assertEquals ( bucket . get ( <int> ) . charAt ( <int> ) , bucket . get ( <int> ) . charAt ( <int> ) ) ; } pairs . clear ( ) ; buckets . clear ( ) ; String [ ] strings2 = { <str> , <str> , <str> , <str> , <str> , <str> } ; for ( String st : strings2 ) { Pair < String , Long > pair = Pair . create ( st , new Long ( st . length ( ) ) ) ; pairs . add ( pair ) ; } buckets = getBuckets ( pairs , <float> , <float> , <int> ) ; assertEquals ( <int> , buckets . size ( ) ) ; for ( List < String > bucket : buckets ) { assertEquals ( <int> , bucket . size ( ) ) ; assertEquals ( bucket . get ( <int> ) . charAt ( <int> ) , bucket . get ( <int> ) . charAt ( <int> ) ) ; assertEquals ( bucket . get ( <int> ) . charAt ( <int> ) , bucket . get ( <int> ) . charAt ( <int> ) ) ; } pairs . clear ( ) ; buckets . clear ( ) ; String [ ] strings3 = { <str> , <str> , <str> , <str> , <str> , <str> } ; for ( String st : strings3 ) { Pair < String , Long > pair = Pair . create ( st , new Long ( st . length ( ) ) ) ; pairs . add ( pair ) ; } buckets = getBuckets ( pairs , <float> , <float> , <int> ) ; assertEquals ( <int> , buckets . size ( ) ) ; } @Test public void testPrepBucket ( ) throws Exception { String ksname = KEYSPACE1 ; String cfname = <str> ; Keyspace keyspace = Keyspace . open ( ksname ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; cfs . truncateBlocking ( ) ; cfs . disableAutoCompaction ( ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> ] ) ; int numSSTables = <int> ; for ( int r = <int> ; r < numSSTables ; r + + ) { String key = String . valueOf ( r ) ; new RowUpdateBuilder ( cfs . metadata , <int> , key ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } cfs . forceBlockingFlush ( ) ; List < SSTableReader > sstrs = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; Pair < List < SSTableReader > , Double > bucket ; List < SSTableReader > interestingBucket = mostInterestingBucket ( Collections . singletonList ( sstrs . subList ( <int> , <int> ) ) , <int> , <int> ) ; assertTrue ( <str> , interestingBucket . isEmpty ( ) ) ; sstrs . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; sstrs . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; sstrs . get ( <int> ) . overrideReadMeter ( new RestorableMeter ( <float> , <float> ) ) ; long estimatedKeys = sstrs . get ( <int> ) . estimatedKeys ( ) ; bucket = trimToThresholdWithHotness ( sstrs , <int> ) ; assertEquals ( <str> , <int> , bucket . left . size ( ) ) ; double expectedBucketHotness = ( <float> + <float> ) / estimatedKeys ; assertEquals ( String . format ( <str> , bucket . right , expectedBucketHotness ) , expectedBucketHotness , bucket . right , <float> ) ; } } 
