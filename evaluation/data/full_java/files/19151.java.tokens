package io . netty . handler . codec . http . multipart ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . http . HttpConstants ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . http . QueryStringDecoder ; import io . netty . handler . codec . http . multipart . HttpPostBodyUtil . SeekAheadNoBackArrayException ; import io . netty . handler . codec . http . multipart . HttpPostBodyUtil . SeekAheadOptimize ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . EndOfDataDecoderException ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . ErrorDataDecoderException ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . MultiPartStatus ; import io . netty . handler . codec . http . multipart . HttpPostRequestDecoder . NotEnoughDataDecoderException ; import java . io . IOException ; import java . nio . charset . Charset ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . TreeMap ; import static io . netty . buffer . Unpooled . * ; public class HttpPostStandardRequestDecoder implements InterfaceHttpPostRequestDecoder { private final HttpDataFactory factory ; private final HttpRequest request ; private final Charset charset ; private boolean isLastChunk ; private final List < InterfaceHttpData > bodyListHttpData = new ArrayList < InterfaceHttpData > ( ) ; private final Map < String , List < InterfaceHttpData > > bodyMapHttpData = new TreeMap < String , List < InterfaceHttpData > > ( CaseIgnoringComparator . INSTANCE ) ; private ByteBuf undecodedChunk ; private int bodyListHttpDataRank ; private MultiPartStatus currentStatus = MultiPartStatus . NOTSTARTED ; private Attribute currentAttribute ; private boolean destroyed ; private int discardThreshold = HttpPostRequestDecoder . DEFAULT_DISCARD_THRESHOLD ; public HttpPostStandardRequestDecoder ( HttpRequest request ) { this ( new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) , request , HttpConstants . DEFAULT_CHARSET ) ; } public HttpPostStandardRequestDecoder ( HttpDataFactory factory , HttpRequest request ) { this ( factory , request , HttpConstants . DEFAULT_CHARSET ) ; } public HttpPostStandardRequestDecoder ( HttpDataFactory factory , HttpRequest request , Charset charset ) { if ( factory = = null ) { throw new NullPointerException ( <str> ) ; } if ( request = = null ) { throw new NullPointerException ( <str> ) ; } if ( charset = = null ) { throw new NullPointerException ( <str> ) ; } this . request = request ; this . charset = charset ; this . factory = factory ; if ( request instanceof HttpContent ) { offer ( ( HttpContent ) request ) ; } else { undecodedChunk = buffer ( ) ; parseBody ( ) ; } } private void checkDestroyed ( ) { if ( destroyed ) { throw new IllegalStateException ( HttpPostStandardRequestDecoder . class . getSimpleName ( ) + <str> ) ; } } @Override public boolean isMultipart ( ) { checkDestroyed ( ) ; return false ; } @Override public void setDiscardThreshold ( int discardThreshold ) { if ( discardThreshold < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . discardThreshold = discardThreshold ; } @Override public int getDiscardThreshold ( ) { return discardThreshold ; } @Override public List < InterfaceHttpData > getBodyHttpDatas ( ) { checkDestroyed ( ) ; if ( ! isLastChunk ) { throw new NotEnoughDataDecoderException ( ) ; } return bodyListHttpData ; } @Override public List < InterfaceHttpData > getBodyHttpDatas ( String name ) { checkDestroyed ( ) ; if ( ! isLastChunk ) { throw new NotEnoughDataDecoderException ( ) ; } return bodyMapHttpData . get ( name ) ; } @Override public InterfaceHttpData getBodyHttpData ( String name ) { checkDestroyed ( ) ; if ( ! isLastChunk ) { throw new NotEnoughDataDecoderException ( ) ; } List < InterfaceHttpData > list = bodyMapHttpData . get ( name ) ; if ( list ! = null ) { return list . get ( <int> ) ; } return null ; } @Override public HttpPostStandardRequestDecoder offer ( HttpContent content ) { checkDestroyed ( ) ; ByteBuf buf = content . content ( ) ; if ( undecodedChunk = = null ) { undecodedChunk = buf . copy ( ) ; } else { undecodedChunk . writeBytes ( buf ) ; } if ( content instanceof LastHttpContent ) { isLastChunk = true ; } parseBody ( ) ; if ( undecodedChunk ! = null & & undecodedChunk . writerIndex ( ) > discardThreshold ) { undecodedChunk . discardReadBytes ( ) ; } return this ; } @Override public boolean hasNext ( ) { checkDestroyed ( ) ; if ( currentStatus = = MultiPartStatus . EPILOGUE ) { if ( bodyListHttpDataRank > = bodyListHttpData . size ( ) ) { throw new EndOfDataDecoderException ( ) ; } } return ! bodyListHttpData . isEmpty ( ) & & bodyListHttpDataRank < bodyListHttpData . size ( ) ; } @Override public InterfaceHttpData next ( ) { checkDestroyed ( ) ; if ( hasNext ( ) ) { return bodyListHttpData . get ( bodyListHttpDataRank + + ) ; } return null ; } @Override public InterfaceHttpData currentPartialHttpData ( ) { return currentAttribute ; } private void parseBody ( ) { if ( currentStatus = = MultiPartStatus . PREEPILOGUE | | currentStatus = = MultiPartStatus . EPILOGUE ) { if ( isLastChunk ) { currentStatus = MultiPartStatus . EPILOGUE ; } return ; } parseBodyAttributes ( ) ; } protected void addHttpData ( InterfaceHttpData data ) { if ( data = = null ) { return ; } List < InterfaceHttpData > datas = bodyMapHttpData . get ( data . getName ( ) ) ; if ( datas = = null ) { datas = new ArrayList < InterfaceHttpData > ( <int> ) ; bodyMapHttpData . put ( data . getName ( ) , datas ) ; } datas . add ( data ) ; bodyListHttpData . add ( data ) ; } private void parseBodyAttributesStandard ( ) { int firstpos = undecodedChunk . readerIndex ( ) ; int currentpos = firstpos ; int equalpos ; int ampersandpos ; if ( currentStatus = = MultiPartStatus . NOTSTARTED ) { currentStatus = MultiPartStatus . DISPOSITION ; } boolean contRead = true ; try { while ( undecodedChunk . isReadable ( ) & & contRead ) { char read = ( char ) undecodedChunk . readUnsignedByte ( ) ; currentpos + + ; switch ( currentStatus ) { case DISPOSITION : if ( read = = <str> ) { currentStatus = MultiPartStatus . FIELD ; equalpos = currentpos - <int> ; String key = decodeAttribute ( undecodedChunk . toString ( firstpos , equalpos - firstpos , charset ) , charset ) ; currentAttribute = factory . createAttribute ( request , key ) ; firstpos = currentpos ; } else if ( read = = <str> ) { currentStatus = MultiPartStatus . DISPOSITION ; ampersandpos = currentpos - <int> ; String key = decodeAttribute ( undecodedChunk . toString ( firstpos , ampersandpos - firstpos , charset ) , charset ) ; currentAttribute = factory . createAttribute ( request , key ) ; currentAttribute . setValue ( <str> ) ; addHttpData ( currentAttribute ) ; currentAttribute = null ; firstpos = currentpos ; contRead = true ; } break ; case FIELD : if ( read = = <str> ) { currentStatus = MultiPartStatus . DISPOSITION ; ampersandpos = currentpos - <int> ; setFinalBuffer ( undecodedChunk . copy ( firstpos , ampersandpos - firstpos ) ) ; firstpos = currentpos ; contRead = true ; } else if ( read = = HttpConstants . CR ) { if ( undecodedChunk . isReadable ( ) ) { read = ( char ) undecodedChunk . readUnsignedByte ( ) ; currentpos + + ; if ( read = = HttpConstants . LF ) { currentStatus = MultiPartStatus . PREEPILOGUE ; ampersandpos = currentpos - <int> ; setFinalBuffer ( undecodedChunk . copy ( firstpos , ampersandpos - firstpos ) ) ; firstpos = currentpos ; contRead = false ; } else { throw new ErrorDataDecoderException ( <str> ) ; } } else { currentpos - - ; } } else if ( read = = HttpConstants . LF ) { currentStatus = MultiPartStatus . PREEPILOGUE ; ampersandpos = currentpos - <int> ; setFinalBuffer ( undecodedChunk . copy ( firstpos , ampersandpos - firstpos ) ) ; firstpos = currentpos ; contRead = false ; } break ; default : contRead = false ; } } if ( isLastChunk & & currentAttribute ! = null ) { ampersandpos = currentpos ; if ( ampersandpos > firstpos ) { setFinalBuffer ( undecodedChunk . copy ( firstpos , ampersandpos - firstpos ) ) ; } else if ( ! currentAttribute . isCompleted ( ) ) { setFinalBuffer ( EMPTY_BUFFER ) ; } firstpos = currentpos ; currentStatus = MultiPartStatus . EPILOGUE ; undecodedChunk . readerIndex ( firstpos ) ; return ; } if ( contRead & & currentAttribute ! = null ) { if ( currentStatus = = MultiPartStatus . FIELD ) { currentAttribute . addContent ( undecodedChunk . copy ( firstpos , currentpos - firstpos ) , false ) ; firstpos = currentpos ; } undecodedChunk . readerIndex ( firstpos ) ; } else { undecodedChunk . readerIndex ( firstpos ) ; } } catch ( ErrorDataDecoderException e ) { undecodedChunk . readerIndex ( firstpos ) ; throw e ; } catch ( IOException e ) { undecodedChunk . readerIndex ( firstpos ) ; throw new ErrorDataDecoderException ( e ) ; } } private void parseBodyAttributes ( ) { SeekAheadOptimize sao ; try { sao = new SeekAheadOptimize ( undecodedChunk ) ; } catch ( SeekAheadNoBackArrayException ignored ) { parseBodyAttributesStandard ( ) ; return ; } int firstpos = undecodedChunk . readerIndex ( ) ; int currentpos = firstpos ; int equalpos ; int ampersandpos ; if ( currentStatus = = MultiPartStatus . NOTSTARTED ) { currentStatus = MultiPartStatus . DISPOSITION ; } boolean contRead = true ; try { loop : while ( sao . pos < sao . limit ) { char read = ( char ) ( sao . bytes [ sao . pos + + ] & <hex> ) ; currentpos + + ; switch ( currentStatus ) { case DISPOSITION : if ( read = = <str> ) { currentStatus = MultiPartStatus . FIELD ; equalpos = currentpos - <int> ; String key = decodeAttribute ( undecodedChunk . toString ( firstpos , equalpos - firstpos , charset ) , charset ) ; currentAttribute = factory . createAttribute ( request , key ) ; firstpos = currentpos ; } else if ( read = = <str> ) { currentStatus = MultiPartStatus . DISPOSITION ; ampersandpos = currentpos - <int> ; String key = decodeAttribute ( undecodedChunk . toString ( firstpos , ampersandpos - firstpos , charset ) , charset ) ; currentAttribute = factory . createAttribute ( request , key ) ; currentAttribute . setValue ( <str> ) ; addHttpData ( currentAttribute ) ; currentAttribute = null ; firstpos = currentpos ; contRead = true ; } break ; case FIELD : if ( read = = <str> ) { currentStatus = MultiPartStatus . DISPOSITION ; ampersandpos = currentpos - <int> ; setFinalBuffer ( undecodedChunk . copy ( firstpos , ampersandpos - firstpos ) ) ; firstpos = currentpos ; contRead = true ; } else if ( read = = HttpConstants . CR ) { if ( sao . pos < sao . limit ) { read = ( char ) ( sao . bytes [ sao . pos + + ] & <hex> ) ; currentpos + + ; if ( read = = HttpConstants . LF ) { currentStatus = MultiPartStatus . PREEPILOGUE ; ampersandpos = currentpos - <int> ; sao . setReadPosition ( <int> ) ; setFinalBuffer ( undecodedChunk . copy ( firstpos , ampersandpos - firstpos ) ) ; firstpos = currentpos ; contRead = false ; break loop ; } else { sao . setReadPosition ( <int> ) ; throw new ErrorDataDecoderException ( <str> ) ; } } else { if ( sao . limit > <int> ) { currentpos - - ; } } } else if ( read = = HttpConstants . LF ) { currentStatus = MultiPartStatus . PREEPILOGUE ; ampersandpos = currentpos - <int> ; sao . setReadPosition ( <int> ) ; setFinalBuffer ( undecodedChunk . copy ( firstpos , ampersandpos - firstpos ) ) ; firstpos = currentpos ; contRead = false ; break loop ; } break ; default : sao . setReadPosition ( <int> ) ; contRead = false ; break loop ; } } if ( isLastChunk & & currentAttribute ! = null ) { ampersandpos = currentpos ; if ( ampersandpos > firstpos ) { setFinalBuffer ( undecodedChunk . copy ( firstpos , ampersandpos - firstpos ) ) ; } else if ( ! currentAttribute . isCompleted ( ) ) { setFinalBuffer ( EMPTY_BUFFER ) ; } firstpos = currentpos ; currentStatus = MultiPartStatus . EPILOGUE ; undecodedChunk . readerIndex ( firstpos ) ; return ; } if ( contRead & & currentAttribute ! = null ) { if ( currentStatus = = MultiPartStatus . FIELD ) { currentAttribute . addContent ( undecodedChunk . copy ( firstpos , currentpos - firstpos ) , false ) ; firstpos = currentpos ; } undecodedChunk . readerIndex ( firstpos ) ; } else { undecodedChunk . readerIndex ( firstpos ) ; } } catch ( ErrorDataDecoderException e ) { undecodedChunk . readerIndex ( firstpos ) ; throw e ; } catch ( IOException e ) { undecodedChunk . readerIndex ( firstpos ) ; throw new ErrorDataDecoderException ( e ) ; } } private void setFinalBuffer ( ByteBuf buffer ) throws IOException { currentAttribute . addContent ( buffer , true ) ; String value = decodeAttribute ( currentAttribute . getByteBuf ( ) . toString ( charset ) , charset ) ; currentAttribute . setValue ( value ) ; addHttpData ( currentAttribute ) ; currentAttribute = null ; } private static String decodeAttribute ( String s , Charset charset ) { try { return QueryStringDecoder . decodeComponent ( s , charset ) ; } catch ( IllegalArgumentException e ) { throw new ErrorDataDecoderException ( <str> + s + <str> , e ) ; } } void skipControlCharacters ( ) { SeekAheadOptimize sao ; try { sao = new SeekAheadOptimize ( undecodedChunk ) ; } catch ( SeekAheadNoBackArrayException ignored ) { try { skipControlCharactersStandard ( ) ; } catch ( IndexOutOfBoundsException e ) { throw new NotEnoughDataDecoderException ( e ) ; } return ; } while ( sao . pos < sao . limit ) { char c = ( char ) ( sao . bytes [ sao . pos + + ] & <hex> ) ; if ( ! Character . isISOControl ( c ) & & ! Character . isWhitespace ( c ) ) { sao . setReadPosition ( <int> ) ; return ; } } throw new NotEnoughDataDecoderException ( <str> ) ; } void skipControlCharactersStandard ( ) { for ( ; ; ) { char c = ( char ) undecodedChunk . readUnsignedByte ( ) ; if ( ! Character . isISOControl ( c ) & & ! Character . isWhitespace ( c ) ) { undecodedChunk . readerIndex ( undecodedChunk . readerIndex ( ) - <int> ) ; break ; } } } @Override public void destroy ( ) { checkDestroyed ( ) ; cleanFiles ( ) ; destroyed = true ; if ( undecodedChunk ! = null & & undecodedChunk . refCnt ( ) > <int> ) { undecodedChunk . release ( ) ; undecodedChunk = null ; } for ( int i = bodyListHttpDataRank ; i < bodyListHttpData . size ( ) ; i + + ) { bodyListHttpData . get ( i ) . release ( ) ; } } @Override public void cleanFiles ( ) { checkDestroyed ( ) ; factory . cleanRequestHttpData ( request ) ; } @Override public void removeHttpDataFromClean ( InterfaceHttpData data ) { checkDestroyed ( ) ; factory . removeHttpDataFromClean ( request , data ) ; } } 
