package io . netty . util . internal ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Formatter ; import java . util . List ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public final class StringUtil { public static final String EMPTY_STRING = <str> ; public static final String NEWLINE ; public static final char DOUBLE_QUOTE = <str> ; public static final char COMMA = <str> ; public static final char LINE_FEED = <str> ; public static final char CARRIAGE_RETURN = <str> ; public static final char TAB = <str> ; private static final String [ ] BYTE2HEX_PAD = new String [ <int> ] ; private static final String [ ] BYTE2HEX_NOPAD = new String [ <int> ] ; private static final int CSV_NUMBER_ESCAPE_CHARACTERS = <int> + <int> ; private static final char PACKAGE_SEPARATOR_CHAR = <str> ; static { String newLine ; Formatter formatter = new Formatter ( ) ; try { newLine = formatter . format ( <str> ) . toString ( ) ; } catch ( Exception e ) { newLine = <str> ; } finally { formatter . close ( ) ; } NEWLINE = newLine ; int i ; for ( i = <int> ; i < <int> ; i + + ) { StringBuilder buf = new StringBuilder ( <int> ) ; buf . append ( <str> ) ; buf . append ( i ) ; BYTE2HEX_PAD [ i ] = buf . toString ( ) ; BYTE2HEX_NOPAD [ i ] = String . valueOf ( i ) ; } for ( ; i < <int> ; i + + ) { StringBuilder buf = new StringBuilder ( <int> ) ; char c = ( char ) ( <str> + i - <int> ) ; buf . append ( <str> ) ; buf . append ( c ) ; BYTE2HEX_PAD [ i ] = buf . toString ( ) ; BYTE2HEX_NOPAD [ i ] = String . valueOf ( c ) ; } for ( ; i < BYTE2HEX_PAD . length ; i + + ) { StringBuilder buf = new StringBuilder ( <int> ) ; buf . append ( Integer . toHexString ( i ) ) ; String str = buf . toString ( ) ; BYTE2HEX_PAD [ i ] = str ; BYTE2HEX_NOPAD [ i ] = str ; } } public static String [ ] split ( String value , char delim ) { final int end = value . length ( ) ; final List < String > res = new ArrayList < String > ( ) ; int start = <int> ; for ( int i = <int> ; i < end ; i + + ) { if ( value . charAt ( i ) = = delim ) { if ( start = = i ) { res . add ( EMPTY_STRING ) ; } else { res . add ( value . substring ( start , i ) ) ; } start = i + <int> ; } } if ( start = = <int> ) { res . add ( value ) ; } else { if ( start ! = end ) { res . add ( value . substring ( start , end ) ) ; } else { for ( int i = res . size ( ) - <int> ; i > = <int> ; i - - ) { if ( res . get ( i ) . isEmpty ( ) ) { res . remove ( i ) ; } else { break ; } } } } return res . toArray ( new String [ res . size ( ) ] ) ; } public static String [ ] split ( String value , char delim , int maxParts ) { final int end = value . length ( ) ; final List < String > res = new ArrayList < String > ( ) ; int start = <int> ; int cpt = <int> ; for ( int i = <int> ; i < end & & cpt < maxParts ; i + + ) { if ( value . charAt ( i ) = = delim ) { if ( start = = i ) { res . add ( EMPTY_STRING ) ; } else { res . add ( value . substring ( start , i ) ) ; } start = i + <int> ; cpt + + ; } } if ( start = = <int> ) { res . add ( value ) ; } else { if ( start ! = end ) { res . add ( value . substring ( start , end ) ) ; } else { for ( int i = res . size ( ) - <int> ; i > = <int> ; i - - ) { if ( res . get ( i ) . isEmpty ( ) ) { res . remove ( i ) ; } else { break ; } } } } return res . toArray ( new String [ res . size ( ) ] ) ; } public static String substringAfter ( String value , char delim ) { int pos = value . indexOf ( delim ) ; if ( pos > = <int> ) { return value . substring ( pos + <int> ) ; } return null ; } public static String byteToHexStringPadded ( int value ) { return BYTE2HEX_PAD [ value & <hex> ] ; } public static < T extends Appendable > T byteToHexStringPadded ( T buf , int value ) { try { buf . append ( byteToHexStringPadded ( value ) ) ; } catch ( IOException e ) { PlatformDependent . throwException ( e ) ; } return buf ; } public static String toHexStringPadded ( byte [ ] src ) { return toHexStringPadded ( src , <int> , src . length ) ; } public static String toHexStringPadded ( byte [ ] src , int offset , int length ) { return toHexStringPadded ( new StringBuilder ( length < < <int> ) , src , offset , length ) . toString ( ) ; } public static < T extends Appendable > T toHexStringPadded ( T dst , byte [ ] src ) { return toHexStringPadded ( dst , src , <int> , src . length ) ; } public static < T extends Appendable > T toHexStringPadded ( T dst , byte [ ] src , int offset , int length ) { final int end = offset + length ; for ( int i = offset ; i < end ; i + + ) { byteToHexStringPadded ( dst , src [ i ] ) ; } return dst ; } public static String byteToHexString ( int value ) { return BYTE2HEX_NOPAD [ value & <hex> ] ; } public static < T extends Appendable > T byteToHexString ( T buf , int value ) { try { buf . append ( byteToHexString ( value ) ) ; } catch ( IOException e ) { PlatformDependent . throwException ( e ) ; } return buf ; } public static String toHexString ( byte [ ] src ) { return toHexString ( src , <int> , src . length ) ; } public static String toHexString ( byte [ ] src , int offset , int length ) { return toHexString ( new StringBuilder ( length < < <int> ) , src , offset , length ) . toString ( ) ; } public static < T extends Appendable > T toHexString ( T dst , byte [ ] src ) { return toHexString ( dst , src , <int> , src . length ) ; } public static < T extends Appendable > T toHexString ( T dst , byte [ ] src , int offset , int length ) { assert length > = <int> ; if ( length = = <int> ) { return dst ; } final int end = offset + length ; final int endMinusOne = end - <int> ; int i ; for ( i = offset ; i < endMinusOne ; i + + ) { if ( src [ i ] ! = <int> ) { break ; } } byteToHexString ( dst , src [ i + + ] ) ; int remaining = end - i ; toHexStringPadded ( dst , src , i , remaining ) ; return dst ; } public static String simpleClassName ( Object o ) { if ( o = = null ) { return <str> ; } else { return simpleClassName ( o . getClass ( ) ) ; } } public static String simpleClassName ( Class < ? > clazz ) { String className = ObjectUtil . checkNotNull ( clazz , <str> ) . getName ( ) ; final int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( lastDotIdx > - <int> ) { return className . substring ( lastDotIdx + <int> ) ; } return className ; } public static CharSequence escapeCsv ( CharSequence value ) { int length = checkNotNull ( value , <str> ) . length ( ) ; if ( length = = <int> ) { return value ; } int last = length - <int> ; boolean quoted = isDoubleQuote ( value . charAt ( <int> ) ) & & isDoubleQuote ( value . charAt ( last ) ) & & length ! = <int> ; boolean foundSpecialCharacter = false ; boolean escapedDoubleQuote = false ; StringBuilder escaped = new StringBuilder ( length + CSV_NUMBER_ESCAPE_CHARACTERS ) . append ( DOUBLE_QUOTE ) ; for ( int i = <int> ; i < length ; i + + ) { char current = value . charAt ( i ) ; switch ( current ) { case DOUBLE_QUOTE : if ( i = = <int> | | i = = last ) { if ( ! quoted ) { escaped . append ( DOUBLE_QUOTE ) ; } else { continue ; } } else { boolean isNextCharDoubleQuote = isDoubleQuote ( value . charAt ( i + <int> ) ) ; if ( ! isDoubleQuote ( value . charAt ( i - <int> ) ) & & ( ! isNextCharDoubleQuote | | i + <int> = = last ) ) { escaped . append ( DOUBLE_QUOTE ) ; escapedDoubleQuote = true ; } break ; } case LINE_FEED : case CARRIAGE_RETURN : case COMMA : foundSpecialCharacter = true ; } escaped . append ( current ) ; } return escapedDoubleQuote | | foundSpecialCharacter & & ! quoted ? escaped . append ( DOUBLE_QUOTE ) : value ; } public static int length ( String s ) { return s = = null ? <int> : s . length ( ) ; } public static boolean isNullOrEmpty ( String s ) { return s = = null | | s . isEmpty ( ) ; } private static boolean isDoubleQuote ( char c ) { return c = = DOUBLE_QUOTE ; } private StringUtil ( ) { } } 
