package io . netty . test . udt . util ; import com . yammer . metrics . core . Meter ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . udt . UdtMessage ; import io . netty . channel . udt . nio . NioUdtProvider ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; public class EchoMessageHandler extends ChannelInboundHandlerAdapter { private static final InternalLogger log = InternalLoggerFactory . getInstance ( EchoMessageHandler . class ) ; private final Meter meter ; private final UdtMessage message ; public Meter meter ( ) { return meter ; } public EchoMessageHandler ( final Meter meter , final int messageSize ) { this . meter = meter ; final ByteBuf byteBuf = Unpooled . buffer ( messageSize ) ; for ( int i = <int> ; i < byteBuf . capacity ( ) ; i + + ) { byteBuf . writeByte ( ( byte ) i ) ; } message = new UdtMessage ( byteBuf ) ; } @Override public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { log . info ( <str> , NioUdtProvider . socketUDT ( ctx . channel ( ) ) . toStringOptions ( ) ) ; ctx . writeAndFlush ( message ) ; } @Override public void exceptionCaught ( final ChannelHandlerContext ctx , final Throwable e ) { log . error ( <str> , e ) ; ctx . close ( ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { UdtMessage udtMsg = ( UdtMessage ) msg ; if ( meter ! = null ) { meter . mark ( udtMsg . content ( ) . readableBytes ( ) ) ; } ctx . writeAndFlush ( msg ) ; } } 
