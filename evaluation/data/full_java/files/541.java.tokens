package org . apache . cassandra . dht ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . BufferDecoratedKey ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Hex ; import org . apache . cassandra . utils . ObjectSizes ; import org . apache . cassandra . utils . Pair ; import org . apache . commons . lang3 . ArrayUtils ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Random ; public class ByteOrderedPartitioner implements IPartitioner { public static final BytesToken MINIMUM = new BytesToken ( ArrayUtils . EMPTY_BYTE_ARRAY ) ; public static final BigInteger BYTE_MASK = new BigInteger ( <str> ) ; private static final long EMPTY_SIZE = ObjectSizes . measure ( MINIMUM ) ; public static final ByteOrderedPartitioner instance = new ByteOrderedPartitioner ( ) ; public static class BytesToken extends Token { static final long serialVersionUID = - <int> ; final byte [ ] token ; public BytesToken ( ByteBuffer token ) { this ( ByteBufferUtil . getArray ( token ) ) ; } public BytesToken ( byte [ ] token ) { this . token = token ; } @Override public String toString ( ) { return Hex . bytesToHex ( token ) ; } public int compareTo ( Token other ) { BytesToken o = ( BytesToken ) other ; return FBUtilities . compareUnsigned ( token , o . token , <int> , <int> , token . length , o . token . length ) ; } @Override public int hashCode ( ) { final int prime = <int> ; return prime + Arrays . hashCode ( token ) ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( ! ( obj instanceof BytesToken ) ) return false ; BytesToken other = ( BytesToken ) obj ; return Arrays . equals ( token , other . token ) ; } @Override public IPartitioner getPartitioner ( ) { return instance ; } @Override public long getHeapSize ( ) { return EMPTY_SIZE + ObjectSizes . sizeOfArray ( token ) ; } @Override public Object getTokenValue ( ) { return token ; } @Override public double size ( Token next ) { throw new UnsupportedOperationException ( String . format ( <str> , getClass ( ) . getSimpleName ( ) ) ) ; } @Override public Token increaseSlightly ( ) { throw new UnsupportedOperationException ( String . format ( <str> , getClass ( ) . getSimpleName ( ) ) ) ; } } public BytesToken getToken ( ByteBuffer key ) { if ( key . remaining ( ) = = <int> ) return MINIMUM ; return new BytesToken ( key ) ; } public DecoratedKey decorateKey ( ByteBuffer key ) { return new BufferDecoratedKey ( getToken ( key ) , key ) ; } public BytesToken midpoint ( Token lt , Token rt ) { BytesToken ltoken = ( BytesToken ) lt ; BytesToken rtoken = ( BytesToken ) rt ; int sigbytes = Math . max ( ltoken . token . length , rtoken . token . length ) ; BigInteger left = bigForBytes ( ltoken . token , sigbytes ) ; BigInteger right = bigForBytes ( rtoken . token , sigbytes ) ; Pair < BigInteger , Boolean > midpair = FBUtilities . midpoint ( left , right , <int> * sigbytes ) ; return new BytesToken ( bytesForBig ( midpair . left , sigbytes , midpair . right ) ) ; } private BigInteger bigForBytes ( byte [ ] bytes , int sigbytes ) { byte [ ] b ; if ( sigbytes ! = bytes . length ) { b = new byte [ sigbytes ] ; System . arraycopy ( bytes , <int> , b , <int> , bytes . length ) ; } else b = bytes ; return new BigInteger ( <int> , b ) ; } private byte [ ] bytesForBig ( BigInteger big , int sigbytes , boolean remainder ) { byte [ ] bytes = new byte [ sigbytes + ( remainder ? <int> : <int> ) ] ; if ( remainder ) { bytes [ sigbytes ] | = <hex> ; } for ( int i = <int> ; i < sigbytes ; i + + ) { int maskpos = <int> * ( sigbytes - ( i + <int> ) ) ; bytes [ i ] = ( byte ) ( big . and ( BYTE_MASK . shiftLeft ( maskpos ) ) . shiftRight ( maskpos ) . intValue ( ) & <hex> ) ; } return bytes ; } public BytesToken getMinimumToken ( ) { return MINIMUM ; } public BytesToken getRandomToken ( ) { Random r = new Random ( ) ; byte [ ] buffer = new byte [ <int> ] ; r . nextBytes ( buffer ) ; return new BytesToken ( buffer ) ; } private final Token . TokenFactory tokenFactory = new Token . TokenFactory ( ) { public ByteBuffer toByteArray ( Token token ) { BytesToken bytesToken = ( BytesToken ) token ; return ByteBuffer . wrap ( bytesToken . token ) ; } public Token fromByteArray ( ByteBuffer bytes ) { return new BytesToken ( bytes ) ; } public String toString ( Token token ) { BytesToken bytesToken = ( BytesToken ) token ; return Hex . bytesToHex ( bytesToken . token ) ; } public void validate ( String token ) throws ConfigurationException { try { if ( token . length ( ) % <int> = = <int> ) token = <str> + token ; Hex . hexToBytes ( token ) ; } catch ( NumberFormatException e ) { throw new ConfigurationException ( <str> + token + <str> ) ; } } public Token fromString ( String string ) { if ( string . length ( ) % <int> = = <int> ) string = <str> + string ; return new BytesToken ( Hex . hexToBytes ( string ) ) ; } } ; public Token . TokenFactory getTokenFactory ( ) { return tokenFactory ; } public boolean preservesOrder ( ) { return true ; } public Map < Token , Float > describeOwnership ( List < Token > sortedTokens ) { Map < Token , Float > allTokens = new HashMap < Token , Float > ( ) ; List < Range < Token > > sortedRanges = new ArrayList < Range < Token > > ( sortedTokens . size ( ) ) ; Token lastToken = sortedTokens . get ( sortedTokens . size ( ) - <int> ) ; for ( Token node : sortedTokens ) { allTokens . put ( node , new Float ( <float> ) ) ; sortedRanges . add ( new Range < Token > ( lastToken , node ) ) ; lastToken = node ; } for ( String ks : Schema . instance . getKeyspaces ( ) ) { for ( CFMetaData cfmd : Schema . instance . getTablesAndViews ( ks ) ) { for ( Range < Token > r : sortedRanges ) { allTokens . put ( r . right , allTokens . get ( r . right ) + StorageService . instance . getSplits ( ks , cfmd . cfName , r , <int> ) . size ( ) ) ; } } } Float total = new Float ( <float> ) ; for ( Float f : allTokens . values ( ) ) total + = f ; for ( Map . Entry < Token , Float > row : allTokens . entrySet ( ) ) allTokens . put ( row . getKey ( ) , row . getValue ( ) / total ) ; return allTokens ; } public AbstractType < ? > getTokenValidator ( ) { return BytesType . instance ; } public AbstractType < ? > partitionOrdering ( ) { return BytesType . instance ; } } 
