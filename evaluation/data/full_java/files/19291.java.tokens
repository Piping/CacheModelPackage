package io . netty . handler . codec . http . multipart ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . SlicedByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http . multipart . HttpPostRequestEncoder . EncoderMode ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . StringUtil ; import org . junit . Test ; import java . io . File ; import java . util . Arrays ; import java . util . List ; import static io . netty . handler . codec . http . HttpHeaderNames . * ; import static org . junit . Assert . * ; public class HttpPostRequestEncoderTest { @Test public void testSingleFileUpload ( ) throws Exception { DefaultFullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; HttpPostRequestEncoder encoder = new HttpPostRequestEncoder ( request , true ) ; File file1 = new File ( getClass ( ) . getResource ( <str> ) . toURI ( ) ) ; encoder . addBodyAttribute ( <str> , <str> ) ; encoder . addBodyFileUpload ( <str> , file1 , <str> , false ) ; String multipartDataBoundary = encoder . multipartDataBoundary ; String content = getRequestBody ( encoder ) ; String expected = <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + <str> + CONTENT_TYPE + <str> + <str> + <str> + <str> + <str> + <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + file1 . length ( ) + <str> + CONTENT_TYPE + <str> + <str> + CONTENT_TRANSFER_ENCODING + <str> + <str> + <str> + <str> + StringUtil . NEWLINE + <str> + <str> + multipartDataBoundary + <str> + <str> ; assertEquals ( expected , content ) ; } @Test public void testMultiFileUploadInMixedMode ( ) throws Exception { DefaultFullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; HttpPostRequestEncoder encoder = new HttpPostRequestEncoder ( request , true ) ; File file1 = new File ( getClass ( ) . getResource ( <str> ) . toURI ( ) ) ; File file2 = new File ( getClass ( ) . getResource ( <str> ) . toURI ( ) ) ; encoder . addBodyAttribute ( <str> , <str> ) ; encoder . addBodyFileUpload ( <str> , file1 , <str> , false ) ; encoder . addBodyFileUpload ( <str> , file2 , <str> , false ) ; String multipartDataBoundary = encoder . multipartDataBoundary ; String multipartMixedBoundary = encoder . multipartMixedBoundary ; String content = getRequestBody ( encoder ) ; String expected = <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + <str> + CONTENT_TYPE + <str> + <str> + <str> + <str> + <str> + <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_TYPE + <str> + multipartMixedBoundary + <str> + <str> + <str> + multipartMixedBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + file1 . length ( ) + <str> + CONTENT_TYPE + <str> + <str> + CONTENT_TRANSFER_ENCODING + <str> + <str> + <str> + <str> + StringUtil . NEWLINE + <str> + <str> + multipartMixedBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + file2 . length ( ) + <str> + CONTENT_TYPE + <str> + <str> + CONTENT_TRANSFER_ENCODING + <str> + <str> + <str> + <str> + StringUtil . NEWLINE + <str> + <str> + multipartMixedBoundary + <str> + <str> + <str> + multipartDataBoundary + <str> + <str> ; assertEquals ( expected , content ) ; } @Test public void testSingleFileUploadInHtml5Mode ( ) throws Exception { DefaultFullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; DefaultHttpDataFactory factory = new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) ; HttpPostRequestEncoder encoder = new HttpPostRequestEncoder ( factory , request , true , CharsetUtil . UTF_8 , EncoderMode . HTML5 ) ; File file1 = new File ( getClass ( ) . getResource ( <str> ) . toURI ( ) ) ; File file2 = new File ( getClass ( ) . getResource ( <str> ) . toURI ( ) ) ; encoder . addBodyAttribute ( <str> , <str> ) ; encoder . addBodyFileUpload ( <str> , file1 , <str> , false ) ; encoder . addBodyFileUpload ( <str> , file2 , <str> , false ) ; String multipartDataBoundary = encoder . multipartDataBoundary ; String content = getRequestBody ( encoder ) ; String expected = <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + <str> + CONTENT_TYPE + <str> + <str> + <str> + <str> + <str> + <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + file1 . length ( ) + <str> + CONTENT_TYPE + <str> + <str> + CONTENT_TRANSFER_ENCODING + <str> + <str> + <str> + <str> + StringUtil . NEWLINE + <str> + <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + file2 . length ( ) + <str> + CONTENT_TYPE + <str> + <str> + CONTENT_TRANSFER_ENCODING + <str> + <str> + <str> + <str> + StringUtil . NEWLINE + <str> + <str> + multipartDataBoundary + <str> + <str> ; assertEquals ( expected , content ) ; } @Test public void testMultiFileUploadInHtml5Mode ( ) throws Exception { DefaultFullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; DefaultHttpDataFactory factory = new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) ; HttpPostRequestEncoder encoder = new HttpPostRequestEncoder ( factory , request , true , CharsetUtil . UTF_8 , EncoderMode . HTML5 ) ; File file1 = new File ( getClass ( ) . getResource ( <str> ) . toURI ( ) ) ; encoder . addBodyAttribute ( <str> , <str> ) ; encoder . addBodyFileUpload ( <str> , file1 , <str> , false ) ; String multipartDataBoundary = encoder . multipartDataBoundary ; String content = getRequestBody ( encoder ) ; String expected = <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + <str> + CONTENT_TYPE + <str> + <str> + <str> + <str> + <str> + <str> + multipartDataBoundary + <str> + CONTENT_DISPOSITION + <str> + <str> + CONTENT_LENGTH + <str> + file1 . length ( ) + <str> + CONTENT_TYPE + <str> + <str> + CONTENT_TRANSFER_ENCODING + <str> + <str> + <str> + <str> + StringUtil . NEWLINE + <str> + <str> + multipartDataBoundary + <str> + <str> ; assertEquals ( expected , content ) ; } @Test public void testHttpPostRequestEncoderSlicedBuffer ( ) throws Exception { DefaultFullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; HttpPostRequestEncoder encoder = new HttpPostRequestEncoder ( request , true ) ; encoder . addBodyAttribute ( <str> , <str> ) ; encoder . addBodyAttribute ( <str> , <str> ) ; encoder . addBodyAttribute ( <str> , <str> ) ; encoder . addBodyAttribute ( <str> , <str> ) ; int length = <int> ; char [ ] array = new char [ length ] ; Arrays . fill ( array , <str> ) ; String longText = new String ( array ) ; encoder . addBodyAttribute ( <str> , longText . substring ( <int> , <int> ) ) ; File file1 = new File ( getClass ( ) . getResource ( <str> ) . toURI ( ) ) ; encoder . addBodyFileUpload ( <str> , file1 , <str> , false ) ; encoder . finalizeRequest ( ) ; while ( ! encoder . isEndOfInput ( ) ) { HttpContent httpContent = encoder . readChunk ( null ) ; if ( httpContent . content ( ) instanceof SlicedByteBuf ) { assertEquals ( <int> , httpContent . content ( ) . refCnt ( ) ) ; } else { assertEquals ( <int> , httpContent . content ( ) . refCnt ( ) ) ; } httpContent . release ( ) ; } encoder . cleanFiles ( ) ; encoder . close ( ) ; } private static String getRequestBody ( HttpPostRequestEncoder encoder ) throws Exception { encoder . finalizeRequest ( ) ; List < InterfaceHttpData > chunks = encoder . multipartHttpDatas ; ByteBuf [ ] buffers = new ByteBuf [ chunks . size ( ) ] ; for ( int i = <int> ; i < buffers . length ; i + + ) { InterfaceHttpData data = chunks . get ( i ) ; if ( data instanceof InternalAttribute ) { buffers [ i ] = ( ( InternalAttribute ) data ) . toByteBuf ( ) ; } else if ( data instanceof HttpData ) { buffers [ i ] = ( ( HttpData ) data ) . getByteBuf ( ) ; } } ByteBuf content = Unpooled . wrappedBuffer ( buffers ) ; String contentStr = content . toString ( CharsetUtil . UTF_8 ) ; content . release ( ) ; return contentStr ; } } 
