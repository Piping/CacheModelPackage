package org . gradle . foundation . common ; import java . util . * ; public class ReorderableList < E > implements List < E > { protected List < E > elements ; public ReorderableList ( ) { elements = new ArrayList < E > ( ) ; } public ReorderableList ( List < E > elementList ) { this . elements = elementList ; } public boolean add ( E object ) { return elements . add ( object ) ; } public E get ( int index ) { return elements . get ( index ) ; } public void addAll ( List < E > list ) { elements . addAll ( list ) ; } public boolean remove ( Object object ) { return elements . remove ( object ) ; } public int indexOf ( Object object ) { return elements . indexOf ( object ) ; } public int size ( ) { return elements . size ( ) ; } public boolean isEmpty ( ) { return elements . isEmpty ( ) ; } public boolean moveBefore ( E objectToMove ) { return ListReorderer . moveBefore ( elements , objectToMove ) ; } public void moveBefore ( List < E > elementsToMove ) { ListReorderer . moveBefore ( elements , elementsToMove ) ; } public void moveTo ( List < E > objectsToMove , int newIndex ) { ListReorderer . moveTo ( elements , objectsToMove , newIndex ) ; } public boolean moveToFront ( E objectToMove ) { return ListReorderer . moveToFront ( elements , objectToMove ) ; } public void moveToFront ( List < E > elementsToMove ) { ListReorderer . moveToFront ( elements , elementsToMove ) ; } public boolean moveAfter ( E objectToMove ) { return ListReorderer . moveAfter ( elements , objectToMove ) ; } public void moveAfter ( List < E > elementsToMove ) { ListReorderer . moveAfter ( elements , elementsToMove ) ; } public boolean moveToBack ( E objectToMove ) { return ListReorderer . moveToBack ( elements , objectToMove ) ; } public void moveToBack ( List < E > elementsToMove ) { ListReorderer . moveToBack ( elements , elementsToMove ) ; } public boolean allElementsInFront ( List < E > checkList ) { return ListReorderer . allElementsInFront ( elements , checkList ) ; } public boolean allElementsInBack ( List < E > checkList ) { return ListReorderer . allElementsInBack ( elements , checkList ) ; } public Iterator < E > iterator ( ) { return elements . iterator ( ) ; } public void clear ( ) { elements . clear ( ) ; } public Object [ ] toArray ( ) { return elements . toArray ( ) ; } public E remove ( int index ) { return elements . remove ( index ) ; } public void add ( int index , E element ) { elements . add ( index , element ) ; } public int lastIndexOf ( Object object ) { return elements . lastIndexOf ( object ) ; } public boolean contains ( Object object ) { return elements . contains ( object ) ; } public boolean addAll ( int index , Collection < ? extends E > c ) { return elements . addAll ( index , c ) ; } public boolean addAll ( Collection < ? extends E > c ) { return elements . addAll ( c ) ; } public boolean containsAll ( Collection < ? > c ) { return elements . containsAll ( c ) ; } public boolean removeAll ( Collection < ? > c ) { return elements . removeAll ( c ) ; } public boolean retainAll ( Collection < ? > c ) { return elements . retainAll ( c ) ; } public List < E > subList ( int fromIndex , int toIndex ) { return elements . subList ( fromIndex , toIndex ) ; } public ListIterator < E > listIterator ( ) { return elements . listIterator ( ) ; } public ListIterator < E > listIterator ( int index ) { return elements . listIterator ( index ) ; } public E set ( int index , E element ) { return elements . set ( index , element ) ; } public < T > T [ ] toArray ( T [ ] objectArray ) { return elements . toArray ( objectArray ) ; } public int [ ] getIndices ( List < E > elementsToMove ) { return ListReorderer . getIndices ( elements , elementsToMove ) ; } } 
