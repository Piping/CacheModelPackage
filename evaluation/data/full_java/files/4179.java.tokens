package org . eclipse . debug . internal . ui . importexport . breakpoints ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Map ; import java . util . Vector ; import org . eclipse . core . runtime . Assert ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . DelegatingModelPresentation ; import org . eclipse . debug . internal . ui . SWTFactory ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointContainer ; import org . eclipse . debug . internal . ui . breakpoints . provisional . IBreakpointOrganizer ; import org . eclipse . debug . internal . ui . views . breakpoints . BreakpointContainer ; import org . eclipse . debug . internal . ui . views . breakpoints . BreakpointsComparator ; import org . eclipse . debug . internal . ui . views . breakpoints . BreakpointsContentProvider ; import org . eclipse . debug . internal . ui . views . breakpoints . BreakpointsLabelProvider ; import org . eclipse . debug . internal . ui . views . breakpoints . BreakpointsView ; import org . eclipse . debug . internal . ui . views . breakpoints . BreakpointsViewer ; import org . eclipse . debug . ui . IDebugModelPresentation ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . jface . viewers . CheckStateChangedEvent ; import org . eclipse . jface . viewers . ICheckStateListener ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeItem ; import org . eclipse . swt . widgets . Widget ; import org . eclipse . ui . IViewPart ; public class EmbeddedBreakpointsViewer { private IStructuredSelection fSelection = null ; private BreakpointsContentProvider fProvider = null ; private Tree fTree = null ; private BreakpointsViewer fViewer = null ; private ICheckStateListener fCheckListener = new ICheckStateListener ( ) { @Override public void checkStateChanged ( CheckStateChangedEvent event ) { updateCheckedState ( event . getElement ( ) , event . getChecked ( ) ) ; } } ; public EmbeddedBreakpointsViewer ( Composite parent , Object input , IStructuredSelection selection ) { Assert . isNotNull ( parent ) ; Assert . isNotNull ( input ) ; createControl ( parent , input , selection ) ; } private void createControl ( Composite parent , Object input , IStructuredSelection selection ) { fSelection = selection ; if ( fSelection = = null ) { IViewPart fViewpart = DebugUIPlugin . getActiveWorkbenchWindow ( ) . getActivePage ( ) . findView ( IDebugUIConstants . ID_BREAKPOINT_VIEW ) ; if ( fViewpart ! = null ) { fSelection = ( IStructuredSelection ) fViewpart . getViewSite ( ) . getSelectionProvider ( ) . getSelection ( ) ; } else { fSelection = new StructuredSelection ( ) ; } } Composite composite = SWTFactory . createComposite ( parent , parent . getFont ( ) , <int> , <int> , GridData . FILL_BOTH , <int> , <int> ) ; fTree = new Tree ( composite , SWT . BORDER | SWT . MULTI | SWT . H_SCROLL | SWT . V_SCROLL | SWT . CHECK ) ; GridData gd = new GridData ( GridData . FILL_BOTH ) ; gd . heightHint = <int> ; fTree . setLayoutData ( gd ) ; fProvider = new BreakpointsContentProvider ( ) ; BreakpointsView view = ( ( BreakpointsView ) DebugUIPlugin . getActiveWorkbenchWindow ( ) . getActivePage ( ) . findView ( IDebugUIConstants . ID_BREAKPOINT_VIEW ) ) ; fViewer = new BreakpointsViewer ( fTree ) ; BreakpointsLabelProvider labelprovider = new BreakpointsLabelProvider ( ) ; if ( view ! = null ) { Map < String , Object > map = null ; IDebugModelPresentation current = view . getAdapter ( IDebugModelPresentation . class ) ; if ( current instanceof DelegatingModelPresentation ) { map = ( ( DelegatingModelPresentation ) current ) . getAttributes ( ) ; } if ( map ! = null ) { Object key = null ; IDebugModelPresentation newpres = labelprovider . getPresentation ( ) ; for ( Iterator < String > iter = map . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { key = iter . next ( ) ; newpres . setAttribute ( ( String ) key , map . get ( key ) ) ; } } } fViewer . setComparator ( new BreakpointsComparator ( ) ) ; fViewer . setLabelProvider ( labelprovider ) ; fViewer . addCheckStateListener ( fCheckListener ) ; IBreakpointOrganizer [ ] orgs = null ; if ( view ! = null ) { orgs = view . getBreakpointOrganizers ( ) ; } fViewer . setContentProvider ( fProvider ) ; fViewer . setInput ( input ) ; fProvider . setOrganizers ( orgs ) ; initViewerState ( ) ; } private void initViewerState ( ) { Object [ ] items = fSelection . toArray ( ) ; fViewer . setGrayedElements ( new Object [ ] { } ) ; fViewer . setCheckedElements ( new Object [ ] { } ) ; ArrayList < IBreakpoint > list = new ArrayList < IBreakpoint > ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { Object item = items [ i ] ; IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( item , IBreakpoint . class ) ; if ( breakpoint ! = null ) { list . add ( breakpoint ) ; } else if ( item instanceof IBreakpointContainer ) { getBreakpointsFromContainers ( ( IBreakpointContainer ) item , list ) ; } } for ( int i = <int> ; i < list . size ( ) ; i + + ) { updateCheckedState ( list . get ( i ) , true ) ; } } private void getBreakpointsFromContainers ( IBreakpointContainer container , ArrayList < IBreakpoint > list ) { IBreakpoint [ ] bps = container . getBreakpoints ( ) ; list . ensureCapacity ( list . size ( ) + bps . length ) ; for ( int j = <int> ; j < bps . length ; j + + ) { list . add ( bps [ j ] ) ; } } public IStructuredSelection getCheckedElements ( ) { Object [ ] list = fViewer . getCheckedElements ( ) ; Vector < Object > selected = new Vector < Object > ( ) ; for ( int i = <int> ; i < list . length ; i + + ) { if ( ! selected . contains ( list [ i ] ) ) { selected . addElement ( list [ i ] ) ; } } return new StructuredSelection ( selected ) ; } public BreakpointsViewer getViewer ( ) { return fViewer ; } private Widget [ ] searchItems ( Object element ) { ArrayList < TreeItem > list = new ArrayList < TreeItem > ( ) ; TreeItem [ ] items = fTree . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { findAllOccurrences ( items [ i ] , element , list ) ; } return list . toArray ( new Widget [ <int> ] ) ; } private void findAllOccurrences ( TreeItem item , Object element , ArrayList < TreeItem > list ) { if ( element . equals ( item . getData ( ) ) ) { list . add ( item ) ; } TreeItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { findAllOccurrences ( items [ i ] , element , list ) ; } } private void updateCheckedState ( Object obj , boolean enable ) { IBreakpoint breakpoint = ( IBreakpoint ) DebugPlugin . getAdapter ( obj , IBreakpoint . class ) ; if ( breakpoint ! = null ) { Widget [ ] list = searchItems ( obj ) ; TreeItem item = null ; for ( int i = <int> ; i < list . length ; i + + ) { item = ( TreeItem ) list [ i ] ; item . setChecked ( enable ) ; refreshParents ( item ) ; } } else if ( obj instanceof BreakpointContainer ) { ArrayList < IBreakpoint > bps = new ArrayList < IBreakpoint > ( ) ; getBreakpointsFromContainers ( ( BreakpointContainer ) obj , bps ) ; for ( int j = <int> ; j < bps . size ( ) ; j + + ) { updateCheckedState ( bps . get ( j ) , enable ) ; } } } private void refreshParents ( TreeItem item ) { TreeItem parent = item . getParentItem ( ) ; while ( parent ! = null ) { int checked = getNumberChildrenChecked ( parent ) ; if ( checked = = <int> ) { parent . setGrayed ( false ) ; parent . setChecked ( false ) ; } else if ( checked = = parent . getItemCount ( ) ) { if ( getNumberChildrenGrayed ( parent ) > <int> ) { parent . setGrayed ( true ) ; } else { parent . setGrayed ( false ) ; } parent . setChecked ( true ) ; } else { parent . setGrayed ( true ) ; parent . setChecked ( true ) ; } parent = parent . getParentItem ( ) ; } } private int getNumberChildrenGrayed ( TreeItem parent ) { TreeItem [ ] children = parent . getItems ( ) ; int count = <int> ; for ( int i = <int> ; i < children . length ; i + + ) { if ( children [ i ] . getGrayed ( ) ) { count + + ; } } return count ; } private int getNumberChildrenChecked ( TreeItem parent ) { TreeItem [ ] children = parent . getItems ( ) ; int count = <int> ; for ( int i = <int> ; i < children . length ; i + + ) { if ( children [ i ] . getChecked ( ) ) { count + + ; } } return count ; } } 
