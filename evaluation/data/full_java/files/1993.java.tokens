package org . nd4j . linalg . api . ops ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; public abstract class BaseAccumulation extends BaseOp implements Accumulation { protected Number finalResult ; protected IComplexNumber finalResultComplex ; protected boolean applyFinalTransform = true ; public BaseAccumulation ( ) { } public BaseAccumulation ( INDArray x , INDArray y , INDArray z , int n ) { super ( x , y , z , n ) ; init ( ) ; } public BaseAccumulation ( INDArray x , INDArray y , int n ) { this ( x , y , x , n ) ; } public BaseAccumulation ( INDArray x ) { this ( x , null , x , x . length ( ) ) ; } public BaseAccumulation ( INDArray x , INDArray y ) { this ( x , y , x , x . length ( ) ) ; } private void init ( ) { init ( x , y , x , x . length ( ) ) ; } @Override public boolean applyFinalTransform ( ) { return applyFinalTransform ; } @Override public void setApplyFinalTransform ( boolean applyFinalTransform ) { this . applyFinalTransform = applyFinalTransform ; } @Override public IComplexNumber op ( IComplexNumber origin , double other ) { numProcessed + + ; return origin ; } @Override public IComplexNumber op ( IComplexNumber origin , float other ) { numProcessed + + ; return origin ; } @Override public IComplexNumber op ( IComplexNumber origin , IComplexNumber other ) { numProcessed + + ; return origin ; } @Override public float op ( float origin , float other ) { numProcessed + + ; return origin ; } @Override public double op ( double origin , double other ) { numProcessed + + ; return origin ; } @Override public double op ( double origin ) { numProcessed + + ; return origin ; } @Override public float op ( float origin ) { numProcessed + + ; return origin ; } @Override public IComplexNumber op ( IComplexNumber origin ) { numProcessed + + ; return origin ; } @Override public double zeroDouble ( ) { return <float> ; } @Override public float zeroFloat ( ) { return <float> ; } @Override public IComplexNumber zeroComplex ( ) { return Nd4j . createComplexNumber ( <float> , <float> ) ; } @Override public int numProcessed ( ) { return numProcessed ; } @Override public void init ( INDArray x , INDArray y , INDArray z , int n ) { super . init ( x , y , z , n ) ; this . extraArgs = new Object [ ] { zeroDouble ( ) } ; } @Override public double combineSubResults ( double first , double second ) { return update ( first , second ) ; } @Override public float combineSubResults ( float first , float second ) { return update ( first , second ) ; } @Override public IComplexNumber combineSubResults ( IComplexNumber first , IComplexNumber second ) { return update ( first , second ) ; } @Override public double getAndSetFinalResult ( double accum ) { this . finalResult = accum ; return accum ; } @Override public float getAndSetFinalResult ( float accum ) { this . finalResult = accum ; return accum ; } @Override public IComplexNumber getAndSetFinalResult ( IComplexNumber accum ) { this . finalResultComplex = accum ; return accum ; } @Override public double calculateFinalResult ( double accum , int n ) { return accum ; } @Override public float calculateFinalResult ( float accum , int n ) { return accum ; } @Override public Number currentResult ( ) { return finalResult ; } @Override public void setFinalResult ( Number number ) { this . finalResult = number ; } @Override public void setFinalResultComplex ( IComplexNumber number ) { this . finalResultComplex = number ; } @Override public Number getFinalResult ( ) { return finalResult ; } @Override public IComplexNumber getFinalResultComplex ( ) { return finalResultComplex ; } } 
