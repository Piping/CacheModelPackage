package org . elasticsearch . common . xcontent . support ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . * ; public abstract class AbstractXContentParser implements XContentParser { private ParseFieldMatcher matcher = ParseFieldMatcher . STRICT ; public static final boolean DEFAULT_NUMBER_COEERCE_POLICY = true ; private static void checkCoerceString ( boolean coeerce , Class < ? extends Number > clazz ) { if ( ! coeerce ) { throw new IllegalArgumentException ( clazz . getSimpleName ( ) + <str> ) ; } } void ensureNumberConversion ( boolean coerce , long result , Class < ? extends Number > clazz ) throws IOException { if ( ! coerce ) { double fullVal = doDoubleValue ( ) ; if ( result ! = fullVal ) { throw new IllegalArgumentException ( fullVal + <str> + clazz . getSimpleName ( ) + <str> ) ; } } } @Override public boolean isBooleanValue ( ) throws IOException { switch ( currentToken ( ) ) { case VALUE_BOOLEAN : return true ; case VALUE_NUMBER : NumberType numberType = numberType ( ) ; return numberType = = NumberType . LONG | | numberType = = NumberType . INT ; case VALUE_STRING : return Booleans . isBoolean ( textCharacters ( ) , textOffset ( ) , textLength ( ) ) ; default : return false ; } } @Override public boolean booleanValue ( ) throws IOException { Token token = currentToken ( ) ; if ( token = = Token . VALUE_NUMBER ) { return intValue ( ) ! = <int> ; } else if ( token = = Token . VALUE_STRING ) { return Booleans . parseBoolean ( textCharacters ( ) , textOffset ( ) , textLength ( ) , false ) ; } return doBooleanValue ( ) ; } protected abstract boolean doBooleanValue ( ) throws IOException ; @Override public short shortValue ( ) throws IOException { return shortValue ( DEFAULT_NUMBER_COEERCE_POLICY ) ; } @Override public short shortValue ( boolean coerce ) throws IOException { Token token = currentToken ( ) ; if ( token = = Token . VALUE_STRING ) { checkCoerceString ( coerce , Short . class ) ; return Short . parseShort ( text ( ) ) ; } short result = doShortValue ( ) ; ensureNumberConversion ( coerce , result , Short . class ) ; return result ; } protected abstract short doShortValue ( ) throws IOException ; @Override public int intValue ( ) throws IOException { return intValue ( DEFAULT_NUMBER_COEERCE_POLICY ) ; } @Override public int intValue ( boolean coerce ) throws IOException { Token token = currentToken ( ) ; if ( token = = Token . VALUE_STRING ) { checkCoerceString ( coerce , Integer . class ) ; return Integer . parseInt ( text ( ) ) ; } int result = doIntValue ( ) ; ensureNumberConversion ( coerce , result , Integer . class ) ; return result ; } protected abstract int doIntValue ( ) throws IOException ; @Override public long longValue ( ) throws IOException { return longValue ( DEFAULT_NUMBER_COEERCE_POLICY ) ; } @Override public long longValue ( boolean coerce ) throws IOException { Token token = currentToken ( ) ; if ( token = = Token . VALUE_STRING ) { checkCoerceString ( coerce , Long . class ) ; return Long . parseLong ( text ( ) ) ; } long result = doLongValue ( ) ; ensureNumberConversion ( coerce , result , Long . class ) ; return result ; } protected abstract long doLongValue ( ) throws IOException ; @Override public float floatValue ( ) throws IOException { return floatValue ( DEFAULT_NUMBER_COEERCE_POLICY ) ; } @Override public float floatValue ( boolean coerce ) throws IOException { Token token = currentToken ( ) ; if ( token = = Token . VALUE_STRING ) { checkCoerceString ( coerce , Float . class ) ; return Float . parseFloat ( text ( ) ) ; } return doFloatValue ( ) ; } protected abstract float doFloatValue ( ) throws IOException ; @Override public double doubleValue ( ) throws IOException { return doubleValue ( DEFAULT_NUMBER_COEERCE_POLICY ) ; } @Override public double doubleValue ( boolean coerce ) throws IOException { Token token = currentToken ( ) ; if ( token = = Token . VALUE_STRING ) { checkCoerceString ( coerce , Double . class ) ; return Double . parseDouble ( text ( ) ) ; } return doDoubleValue ( ) ; } protected abstract double doDoubleValue ( ) throws IOException ; @Override public String textOrNull ( ) throws IOException { if ( currentToken ( ) = = Token . VALUE_NULL ) { return null ; } return text ( ) ; } @Override public BytesRef utf8BytesOrNull ( ) throws IOException { if ( currentToken ( ) = = Token . VALUE_NULL ) { return null ; } return utf8Bytes ( ) ; } @Override public Map < String , Object > map ( ) throws IOException { return readMap ( this ) ; } @Override public Map < String , Object > mapOrdered ( ) throws IOException { return readOrderedMap ( this ) ; } @Override public List < Object > list ( ) throws IOException { return readList ( this ) ; } @Override public List < Object > listOrderedMap ( ) throws IOException { return readListOrderedMap ( this ) ; } static interface MapFactory { Map < String , Object > newMap ( ) ; } static final MapFactory SIMPLE_MAP_FACTORY = new MapFactory ( ) { @Override public Map < String , Object > newMap ( ) { return new HashMap < > ( ) ; } } ; static final MapFactory ORDERED_MAP_FACTORY = new MapFactory ( ) { @Override public Map < String , Object > newMap ( ) { return new LinkedHashMap < > ( ) ; } } ; static Map < String , Object > readMap ( XContentParser parser ) throws IOException { return readMap ( parser , SIMPLE_MAP_FACTORY ) ; } static Map < String , Object > readOrderedMap ( XContentParser parser ) throws IOException { return readMap ( parser , ORDERED_MAP_FACTORY ) ; } static List < Object > readList ( XContentParser parser ) throws IOException { return readList ( parser , SIMPLE_MAP_FACTORY ) ; } static List < Object > readListOrderedMap ( XContentParser parser ) throws IOException { return readList ( parser , ORDERED_MAP_FACTORY ) ; } static Map < String , Object > readMap ( XContentParser parser , MapFactory mapFactory ) throws IOException { Map < String , Object > map = mapFactory . newMap ( ) ; XContentParser . Token token = parser . currentToken ( ) ; if ( token = = null ) { token = parser . nextToken ( ) ; } if ( token = = XContentParser . Token . START_OBJECT ) { token = parser . nextToken ( ) ; } for ( ; token = = XContentParser . Token . FIELD_NAME ; token = parser . nextToken ( ) ) { String fieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; Object value = readValue ( parser , mapFactory , token ) ; map . put ( fieldName , value ) ; } return map ; } static List < Object > readList ( XContentParser parser , MapFactory mapFactory ) throws IOException { XContentParser . Token token = parser . currentToken ( ) ; if ( token = = XContentParser . Token . FIELD_NAME ) { token = parser . nextToken ( ) ; } if ( token = = XContentParser . Token . START_ARRAY ) { token = parser . nextToken ( ) ; } ArrayList < Object > list = new ArrayList < > ( ) ; for ( ; token ! = XContentParser . Token . END_ARRAY ; token = parser . nextToken ( ) ) { list . add ( readValue ( parser , mapFactory , token ) ) ; } return list ; } static Object readValue ( XContentParser parser , MapFactory mapFactory , XContentParser . Token token ) throws IOException { if ( token = = XContentParser . Token . VALUE_NULL ) { return null ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { return parser . text ( ) ; } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { XContentParser . NumberType numberType = parser . numberType ( ) ; if ( numberType = = XContentParser . NumberType . INT ) { return parser . intValue ( ) ; } else if ( numberType = = XContentParser . NumberType . LONG ) { return parser . longValue ( ) ; } else if ( numberType = = XContentParser . NumberType . FLOAT ) { return parser . floatValue ( ) ; } else if ( numberType = = XContentParser . NumberType . DOUBLE ) { return parser . doubleValue ( ) ; } } else if ( token = = XContentParser . Token . VALUE_BOOLEAN ) { return parser . booleanValue ( ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { return readMap ( parser , mapFactory ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { return readList ( parser , mapFactory ) ; } else if ( token = = XContentParser . Token . VALUE_EMBEDDED_OBJECT ) { return parser . binaryValue ( ) ; } return null ; } @Override public abstract boolean isClosed ( ) ; public ParseFieldMatcher getParseFieldMatcher ( ) { return matcher ; } public void setParseFieldMatcher ( ParseFieldMatcher matcher ) { this . matcher = matcher ; } } 
