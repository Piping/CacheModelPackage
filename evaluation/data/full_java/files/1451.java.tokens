package org . apache . cassandra . db ; import java . util . * ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . db . rows . Rows ; import org . apache . cassandra . db . rows . UnfilteredRowIterators ; import org . apache . cassandra . db . partitions . ImmutableBTreePartition ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . dht . ByteOrderedPartitioner ; import org . apache . cassandra . dht . IPartitioner ; import static org . junit . Assert . assertEquals ; public class ReadResponseTest extends CQLTester { private IPartitioner partitionerToRestore ; @Before public void setupPartitioner ( ) { partitionerToRestore = DatabaseDescriptor . setPartitionerUnsafe ( ByteOrderedPartitioner . instance ) ; } @After public void resetPartitioner ( ) { DatabaseDescriptor . setPartitionerUnsafe ( partitionerToRestore ) ; } @Test public void testLegacyResponseSkipWrongBounds ( ) { createTable ( <str> ) ; ColumnFamilyStore cfs = getCurrentColumnFamilyStore ( ) ; List < ImmutableBTreePartition > responses = Arrays . asList ( makePartition ( cfs . metadata , <str> ) , makePartition ( cfs . metadata , <str> ) , makePartition ( cfs . metadata , <str> ) ) ; ReadResponse . LegacyRemoteDataResponse response = new ReadResponse . LegacyRemoteDataResponse ( responses ) ; assertPartitions ( response . makeIterator ( cfs . metadata , Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyExcl ( <str> ) . build ( ) ) , <str> ) ; assertPartitions ( response . makeIterator ( cfs . metadata , Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyExcl ( <str> ) . build ( ) ) , <str> , <str> ) ; assertPartitions ( response . makeIterator ( cfs . metadata , Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyExcl ( <str> ) . build ( ) ) , <str> , <str> ) ; assertPartitions ( response . makeIterator ( cfs . metadata , Util . cmd ( cfs ) . fromKeyIncl ( <str> ) . toKeyExcl ( <str> ) . build ( ) ) , <str> , <str> ) ; assertPartitions ( response . makeIterator ( cfs . metadata , Util . cmd ( cfs ) . fromKeyIncl ( <str> ) . toKeyExcl ( <str> ) . build ( ) ) , <str> , <str> , <str> ) ; } private void assertPartitions ( UnfilteredPartitionIterator actual , String . . . expectedKeys ) { int i = <int> ; while ( i < expectedKeys . length & & actual . hasNext ( ) ) { String actualKey = AsciiType . instance . getString ( actual . next ( ) . partitionKey ( ) . getKey ( ) ) ; assertEquals ( expectedKeys [ i + + ] , actualKey ) ; } if ( i < expectedKeys . length ) throw new AssertionError ( <str> + expectedKeys [ i ] + <str> ) ; if ( actual . hasNext ( ) ) throw new AssertionError ( <str> + AsciiType . instance . getString ( actual . next ( ) . partitionKey ( ) . getKey ( ) ) ) ; } private static ImmutableBTreePartition makePartition ( CFMetaData metadata , String key ) { return ImmutableBTreePartition . create ( UnfilteredRowIterators . noRowsIterator ( metadata , Util . dk ( key ) , Rows . EMPTY_STATIC_ROW , new DeletionTime ( <int> , <int> ) , false ) ) ; } } 
