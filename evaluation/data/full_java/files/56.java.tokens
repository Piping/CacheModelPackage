package org . apache . cassandra . auth ; import java . util . ArrayList ; import java . util . List ; import java . util . Optional ; import java . util . Set ; import com . google . common . base . Joiner ; import com . google . common . base . Objects ; import com . google . common . base . Splitter ; import com . google . common . collect . Sets ; import org . apache . commons . lang3 . StringUtils ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . CQL3Type ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . functions . FunctionName ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . TypeParser ; public class FunctionResource implements IResource { enum Level { ROOT , KEYSPACE , FUNCTION } private static final Set < Permission > COLLECTION_LEVEL_PERMISSIONS = Sets . immutableEnumSet ( Permission . CREATE , Permission . ALTER , Permission . DROP , Permission . AUTHORIZE , Permission . EXECUTE ) ; private static final Set < Permission > SCALAR_FUNCTION_PERMISSIONS = Sets . immutableEnumSet ( Permission . ALTER , Permission . DROP , Permission . AUTHORIZE , Permission . EXECUTE ) ; private static final Set < Permission > AGGREGATE_FUNCTION_PERMISSIONS = Sets . immutableEnumSet ( Permission . ALTER , Permission . DROP , Permission . AUTHORIZE , Permission . EXECUTE ) ; private static final String ROOT_NAME = <str> ; private static final FunctionResource ROOT_RESOURCE = new FunctionResource ( ) ; private final Level level ; private final String keyspace ; private final String name ; private final List < AbstractType < ? > > argTypes ; private FunctionResource ( ) { level = Level . ROOT ; keyspace = null ; name = null ; argTypes = null ; } private FunctionResource ( String keyspace ) { level = Level . KEYSPACE ; this . keyspace = keyspace ; name = null ; argTypes = null ; } private FunctionResource ( String keyspace , String name , List < AbstractType < ? > > argTypes ) { level = Level . FUNCTION ; this . keyspace = keyspace ; this . name = name ; this . argTypes = argTypes ; } public static FunctionResource root ( ) { return ROOT_RESOURCE ; } public static FunctionResource keyspace ( String keyspace ) { return new FunctionResource ( keyspace ) ; } public static FunctionResource function ( String keyspace , String name , List < AbstractType < ? > > argTypes ) { return new FunctionResource ( keyspace , name , argTypes ) ; } public static FunctionResource functionFromCql ( String keyspace , String name , List < CQL3Type . Raw > argTypes ) { List < AbstractType < ? > > abstractTypes = new ArrayList < > ( ) ; for ( CQL3Type . Raw cqlType : argTypes ) abstractTypes . add ( cqlType . prepare ( keyspace ) . getType ( ) ) ; return new FunctionResource ( keyspace , name , abstractTypes ) ; } public static FunctionResource fromName ( String name ) { String [ ] parts = StringUtils . split ( name , <str> ) ; if ( ! parts [ <int> ] . equals ( ROOT_NAME ) | | parts . length > <int> ) throw new IllegalArgumentException ( String . format ( <str> , name ) ) ; if ( parts . length = = <int> ) return root ( ) ; if ( parts . length = = <int> ) return keyspace ( parts [ <int> ] ) ; String [ ] nameAndArgs = StringUtils . split ( parts [ <int> ] , <str> ) ; return function ( parts [ <int> ] , nameAndArgs [ <int> ] , argsListFromString ( nameAndArgs [ <int> ] ) ) ; } public String getName ( ) { switch ( level ) { case ROOT : return ROOT_NAME ; case KEYSPACE : return String . format ( <str> , ROOT_NAME , keyspace ) ; case FUNCTION : return String . format ( <str> , ROOT_NAME , keyspace , name , argListAsString ( ) ) ; } throw new AssertionError ( ) ; } public String getKeyspace ( ) { return keyspace ; } public FunctionName getFunctionName ( ) { if ( level ! = Level . FUNCTION ) throw new IllegalStateException ( String . format ( <str> , level ) ) ; return new FunctionName ( keyspace , name ) ; } public IResource getParent ( ) { switch ( level ) { case KEYSPACE : return root ( ) ; case FUNCTION : return keyspace ( keyspace ) ; } throw new IllegalStateException ( <str> ) ; } public boolean hasParent ( ) { return level ! = Level . ROOT ; } public boolean exists ( ) { switch ( level ) { case ROOT : return true ; case KEYSPACE : return Schema . instance . getKeyspaces ( ) . contains ( keyspace ) ; case FUNCTION : return Schema . instance . findFunction ( getFunctionName ( ) , argTypes ) . isPresent ( ) ; } throw new AssertionError ( ) ; } public Set < Permission > applicablePermissions ( ) { switch ( level ) { case ROOT : case KEYSPACE : return COLLECTION_LEVEL_PERMISSIONS ; case FUNCTION : { Optional < Function > function = Schema . instance . findFunction ( getFunctionName ( ) , argTypes ) ; assert function . isPresent ( ) : <str> + toString ( ) ; return function . get ( ) . isAggregate ( ) ? AGGREGATE_FUNCTION_PERMISSIONS : SCALAR_FUNCTION_PERMISSIONS ; } } throw new AssertionError ( ) ; } public int compareTo ( FunctionResource o ) { return this . name . compareTo ( o . name ) ; } @Override public String toString ( ) { switch ( level ) { case ROOT : return <str> ; case KEYSPACE : return String . format ( <str> , keyspace ) ; case FUNCTION : return String . format ( <str> , keyspace , name , Joiner . on ( <str> ) . join ( AbstractType . asCQLTypeStringList ( argTypes ) ) ) ; } throw new AssertionError ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof FunctionResource ) ) return false ; FunctionResource f = ( FunctionResource ) o ; return Objects . equal ( level , f . level ) & & Objects . equal ( keyspace , f . keyspace ) & & Objects . equal ( name , f . name ) & & Objects . equal ( argTypes , f . argTypes ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( level , keyspace , name , argTypes ) ; } private String argListAsString ( ) { return Joiner . on ( <str> ) . join ( argTypes ) ; } private static List < AbstractType < ? > > argsListFromString ( String s ) { List < AbstractType < ? > > argTypes = new ArrayList < > ( ) ; for ( String type : Splitter . on ( <str> ) . omitEmptyStrings ( ) . trimResults ( ) . split ( s ) ) argTypes . add ( TypeParser . parse ( type ) ) ; return argTypes ; } } 
