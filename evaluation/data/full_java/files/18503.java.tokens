package com . badlogic . gdx . tests ; import java . util . Random ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . SpriteCache ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . tests . utils . OrthoCamController ; import com . badlogic . gdx . utils . TimeUtils ; public class IsometricTileTest extends GdxTest { static final int LAYERS = <int> ; static final int WIDTH = <int> ; static final int HEIGHT = <int> ; static final int TILES_PER_LAYER = WIDTH * HEIGHT ; static final int TILE_WIDTH = <int> ; static final int TILE_HEIGHT = <int> ; static final int TILE_HEIGHT_DIAMOND = <int> ; static final int BOUND_X = HEIGHT * TILE_WIDTH / <int> + WIDTH * TILE_WIDTH / <int> ; static final int BOUND_Y = HEIGHT * TILE_HEIGHT_DIAMOND / <int> + WIDTH * TILE_HEIGHT_DIAMOND / <int> ; Texture texture ; SpriteCache [ ] caches = new SpriteCache [ LAYERS ] ; int [ ] layers = new int [ LAYERS ] ; OrthographicCamera cam ; OrthoCamController camController ; ShapeRenderer renderer ; long startTime = TimeUtils . nanoTime ( ) ; @Override public void create ( ) { cam = new OrthographicCamera ( <int> , <int> ) ; camController = new OrthoCamController ( cam ) ; Gdx . input . setInputProcessor ( camController ) ; renderer = new ShapeRenderer ( ) ; texture = new Texture ( Gdx . files . internal ( <str> ) ) ; Random rand = new Random ( ) ; for ( int i = <int> ; i < LAYERS ; i + + ) { caches [ i ] = new SpriteCache ( ) ; SpriteCache cache = caches [ i ] ; cache . beginCache ( ) ; int colX = HEIGHT * TILE_WIDTH / <int> - TILE_WIDTH / <int> ; int colY = BOUND_Y - TILE_HEIGHT_DIAMOND ; for ( int x = <int> ; x < WIDTH ; x + + ) { for ( int y = <int> ; y < HEIGHT ; y + + ) { int tileX = colX - y * TILE_WIDTH / <int> ; int tileY = colY - y * TILE_HEIGHT_DIAMOND / <int> ; cache . add ( texture , tileX , tileY , rand . nextInt ( <int> ) * <int> , <int> , TILE_WIDTH , TILE_HEIGHT ) ; } colX + = TILE_WIDTH / <int> ; colY - = TILE_HEIGHT_DIAMOND / <int> ; } layers [ i ] = cache . endCache ( ) ; } } @Override public void dispose ( ) { renderer . dispose ( ) ; texture . dispose ( ) ; for ( SpriteCache cache : caches ) cache . dispose ( ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; cam . update ( ) ; Gdx . gl . glEnable ( GL20 . GL_BLEND ) ; Gdx . gl . glBlendFunc ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; for ( int i = <int> ; i < LAYERS ; i + + ) { SpriteCache cache = caches [ i ] ; cache . setProjectionMatrix ( cam . combined ) ; cache . begin ( ) ; cache . draw ( layers [ i ] ) ; cache . end ( ) ; } renderer . setProjectionMatrix ( cam . combined ) ; renderer . begin ( ShapeType . Line ) ; renderer . setColor ( <int> , <int> , <int> , <int> ) ; renderer . line ( <int> , <int> , <int> , <int> ) ; renderer . line ( <int> , <int> , <int> , <int> ) ; renderer . setColor ( <int> , <int> , <int> , <int> ) ; renderer . line ( <int> , BOUND_Y , BOUND_X , BOUND_Y ) ; renderer . setColor ( <int> , <int> , <int> , <int> ) ; renderer . line ( BOUND_X , <int> , BOUND_X , BOUND_Y ) ; renderer . end ( ) ; } } 
