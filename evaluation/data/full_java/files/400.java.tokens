package org . apache . cassandra . db . compaction . writers ; import java . util . Collection ; import java . util . Set ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . db . compaction . CompactionTask ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . io . sstable . SSTableRewriter ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . concurrent . Transactional ; public abstract class CompactionAwareWriter extends Transactional . AbstractTransactional implements Transactional { protected final ColumnFamilyStore cfs ; protected final Directories directories ; protected final Set < SSTableReader > nonExpiredSSTables ; protected final long estimatedTotalKeys ; protected final long maxAge ; protected final long minRepairedAt ; protected final LifecycleTransaction txn ; protected final SSTableRewriter sstableWriter ; private boolean isInitialized = false ; public CompactionAwareWriter ( ColumnFamilyStore cfs , Directories directories , LifecycleTransaction txn , Set < SSTableReader > nonExpiredSSTables , boolean offline , boolean keepOriginals ) { this . cfs = cfs ; this . directories = directories ; this . nonExpiredSSTables = nonExpiredSSTables ; this . estimatedTotalKeys = SSTableReader . getApproximateKeyCount ( nonExpiredSSTables ) ; this . maxAge = CompactionTask . getMaxDataAge ( nonExpiredSSTables ) ; this . minRepairedAt = CompactionTask . getMinRepairedAt ( nonExpiredSSTables ) ; this . txn = txn ; this . sstableWriter = SSTableRewriter . constructKeepingOriginals ( txn , keepOriginals , maxAge , offline ) ; } @Override protected Throwable doAbort ( Throwable accumulate ) { return sstableWriter . abort ( accumulate ) ; } @Override protected Throwable doCommit ( Throwable accumulate ) { return sstableWriter . commit ( accumulate ) ; } @Override protected void doPrepare ( ) { sstableWriter . prepareToCommit ( ) ; } @Override public Collection < SSTableReader > finish ( ) { super . finish ( ) ; return sstableWriter . finished ( ) ; } public long estimatedKeys ( ) { return estimatedTotalKeys ; } public final boolean append ( UnfilteredRowIterator partition ) { maybeSwitchWriter ( partition . partitionKey ( ) ) ; return realAppend ( partition ) ; } @Override protected Throwable doPostCleanup ( Throwable accumulate ) { sstableWriter . close ( ) ; return super . doPostCleanup ( accumulate ) ; } protected abstract boolean realAppend ( UnfilteredRowIterator partition ) ; protected void maybeSwitchWriter ( DecoratedKey key ) { if ( ! isInitialized ) switchCompactionLocation ( getDirectories ( ) . getWriteableLocation ( cfs . getExpectedCompactedFileSize ( nonExpiredSSTables , txn . opType ( ) ) ) ) ; isInitialized = true ; } protected abstract void switchCompactionLocation ( Directories . DataDirectory directory ) ; public Directories getDirectories ( ) { return directories ; } public Directories . DataDirectory getWriteDirectory ( long expectedWriteSize ) { Directories . DataDirectory directory = getDirectories ( ) . getWriteableLocation ( expectedWriteSize ) ; if ( directory = = null ) throw new RuntimeException ( <str> + expectedWriteSize + <str> ) ; return directory ; } } 
