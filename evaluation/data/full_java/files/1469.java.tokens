package org . apache . cassandra . db ; import com . google . common . base . Charsets ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . UpdateBuilder ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . compaction . Verifier ; import org . apache . cassandra . db . marshal . UUIDType ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . WriteTimeoutException ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . schema . CompressionParams ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . commons . lang3 . StringUtils ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . io . * ; import java . nio . file . Files ; import java . util . zip . CRC32 ; import java . util . zip . CheckedInputStream ; import static org . junit . Assert . fail ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class VerifyTest { public static final String KEYSPACE = <str> ; public static final String CF = <str> ; public static final String CF2 = <str> ; public static final String CF3 = <str> ; public static final String CF4 = <str> ; public static final String COUNTER_CF = <str> ; public static final String COUNTER_CF2 = <str> ; public static final String COUNTER_CF3 = <str> ; public static final String COUNTER_CF4 = <str> ; public static final String CORRUPT_CF = <str> ; public static final String CORRUPT_CF2 = <str> ; public static final String CORRUPTCOUNTER_CF = <str> ; public static final String CORRUPTCOUNTER_CF2 = <str> ; public static final String CF_UUID = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { CompressionParams compressionParameters = CompressionParams . snappy ( <int> ) ; SchemaLoader . loadSchema ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE , CF ) . compression ( compressionParameters ) , SchemaLoader . standardCFMD ( KEYSPACE , CF2 ) . compression ( compressionParameters ) , SchemaLoader . standardCFMD ( KEYSPACE , CF3 ) , SchemaLoader . standardCFMD ( KEYSPACE , CF4 ) , SchemaLoader . standardCFMD ( KEYSPACE , CORRUPT_CF ) , SchemaLoader . standardCFMD ( KEYSPACE , CORRUPT_CF2 ) , SchemaLoader . counterCFMD ( KEYSPACE , COUNTER_CF ) . compression ( compressionParameters ) , SchemaLoader . counterCFMD ( KEYSPACE , COUNTER_CF2 ) . compression ( compressionParameters ) , SchemaLoader . counterCFMD ( KEYSPACE , COUNTER_CF3 ) , SchemaLoader . counterCFMD ( KEYSPACE , COUNTER_CF4 ) , SchemaLoader . counterCFMD ( KEYSPACE , CORRUPTCOUNTER_CF ) , SchemaLoader . counterCFMD ( KEYSPACE , CORRUPTCOUNTER_CF2 ) , SchemaLoader . standardCFMD ( KEYSPACE , CF_UUID , <int> , UUIDType . instance ) ) ; } @Test public void testVerifyCorrect ( ) throws IOException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; fillCF ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( false ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } } @Test public void testVerifyCounterCorrect ( ) throws IOException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( COUNTER_CF ) ; fillCounterCF ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( false ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } } @Test public void testExtendedVerifyCorrect ( ) throws IOException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF2 ) ; fillCF ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( true ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } } @Test public void testExtendedVerifyCounterCorrect ( ) throws IOException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( COUNTER_CF2 ) ; fillCounterCF ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( true ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } } @Test public void testVerifyCorrectUncompressed ( ) throws IOException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF3 ) ; fillCF ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( false ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } } @Test public void testVerifyCounterCorrectUncompressed ( ) throws IOException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( COUNTER_CF3 ) ; fillCounterCF ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( false ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } } @Test public void testExtendedVerifyCorrectUncompressed ( ) throws IOException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF4 ) ; fillCF ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( true ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } } @Test public void testExtendedVerifyCounterCorrectUncompressed ( ) throws IOException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( COUNTER_CF4 ) ; fillCounterCF ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( true ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } } @Test public void testVerifyIncorrectDigest ( ) throws IOException , WriteTimeoutException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CORRUPT_CF ) ; fillCF ( cfs , <int> ) ; Util . getAll ( Util . cmd ( cfs ) . build ( ) ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; RandomAccessFile file = new RandomAccessFile ( sstable . descriptor . filenameFor ( sstable . descriptor . digestComponent ) , <str> ) ; Long correctChecksum = Long . parseLong ( file . readLine ( ) ) ; file . close ( ) ; writeChecksum ( + + correctChecksum , sstable . descriptor . filenameFor ( sstable . descriptor . digestComponent ) ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { verifier . verify ( false ) ; fail ( <str> ) ; } catch ( CorruptSSTableException err ) { } } @Test public void testVerifyCorruptRowCorrectDigest ( ) throws IOException , WriteTimeoutException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CORRUPT_CF2 ) ; fillCF ( cfs , <int> ) ; Util . getAll ( Util . cmd ( cfs ) . build ( ) ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; long row0Start = sstable . getPosition ( PartitionPosition . ForKey . get ( ByteBufferUtil . bytes ( <str> ) , cfs . getPartitioner ( ) ) , SSTableReader . Operator . EQ ) . position ; long row1Start = sstable . getPosition ( PartitionPosition . ForKey . get ( ByteBufferUtil . bytes ( <str> ) , cfs . getPartitioner ( ) ) , SSTableReader . Operator . EQ ) . position ; long startPosition = row0Start < row1Start ? row0Start : row1Start ; long endPosition = row0Start < row1Start ? row1Start : row0Start ; RandomAccessFile file = new RandomAccessFile ( sstable . getFilename ( ) , <str> ) ; file . seek ( startPosition ) ; file . writeBytes ( StringUtils . repeat ( <str> , ( int ) <int> ) ) ; file . close ( ) ; writeChecksum ( simpleFullChecksum ( sstable . getFilename ( ) ) , sstable . descriptor . filenameFor ( sstable . descriptor . digestComponent ) ) ; try ( Verifier verifier = new Verifier ( cfs , sstable , false ) ) { try { verifier . verify ( false ) ; } catch ( CorruptSSTableException err ) { fail ( <str> ) ; } try { verifier . verify ( true ) ; } catch ( CorruptSSTableException err ) { return ; } fail ( <str> ) ; } } protected void fillCF ( ColumnFamilyStore cfs , int partitionsPerSSTable ) { for ( int i = <int> ; i < partitionsPerSSTable ; i + + ) { UpdateBuilder . create ( cfs . metadata , String . valueOf ( i ) ) . newRow ( <str> ) . add ( <str> , <str> ) . newRow ( <str> ) . add ( <str> , <str> ) . apply ( ) ; } cfs . forceBlockingFlush ( ) ; } protected void fillCounterCF ( ColumnFamilyStore cfs , int partitionsPerSSTable ) throws WriteTimeoutException { for ( int i = <int> ; i < partitionsPerSSTable ; i + + ) { UpdateBuilder . create ( cfs . metadata , String . valueOf ( i ) ) . newRow ( <str> ) . add ( <str> , <int> ) . apply ( ) ; } cfs . forceBlockingFlush ( ) ; } protected long simpleFullChecksum ( String filename ) throws IOException { FileInputStream inputStream = new FileInputStream ( filename ) ; CRC32 checksum = new CRC32 ( ) ; CheckedInputStream cinStream = new CheckedInputStream ( inputStream , checksum ) ; byte [ ] b = new byte [ <int> ] ; while ( cinStream . read ( b ) > = <int> ) { } return cinStream . getChecksum ( ) . getValue ( ) ; } protected void writeChecksum ( long checksum , String filePath ) { File outFile = new File ( filePath ) ; BufferedWriter out = null ; try { out = Files . newBufferedWriter ( outFile . toPath ( ) , Charsets . UTF_8 ) ; out . write ( String . valueOf ( checksum ) ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException e ) { throw new FSWriteError ( e , outFile ) ; } finally { FileUtils . closeQuietly ( out ) ; } } } 
