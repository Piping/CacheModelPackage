package clojure . asm ; public class ByteVector { byte [ ] data ; int length ; public ByteVector ( ) { data = new byte [ <int> ] ; } public ByteVector ( final int initialSize ) { data = new byte [ initialSize ] ; } public ByteVector putByte ( final int b ) { int length = this . length ; if ( length + <int> > data . length ) { enlarge ( <int> ) ; } data [ length + + ] = ( byte ) b ; this . length = length ; return this ; } ByteVector put11 ( final int b1 , final int b2 ) { int length = this . length ; if ( length + <int> > data . length ) { enlarge ( <int> ) ; } byte [ ] data = this . data ; data [ length + + ] = ( byte ) b1 ; data [ length + + ] = ( byte ) b2 ; this . length = length ; return this ; } public ByteVector putShort ( final int s ) { int length = this . length ; if ( length + <int> > data . length ) { enlarge ( <int> ) ; } byte [ ] data = this . data ; data [ length + + ] = ( byte ) ( s > > > <int> ) ; data [ length + + ] = ( byte ) s ; this . length = length ; return this ; } ByteVector put12 ( final int b , final int s ) { int length = this . length ; if ( length + <int> > data . length ) { enlarge ( <int> ) ; } byte [ ] data = this . data ; data [ length + + ] = ( byte ) b ; data [ length + + ] = ( byte ) ( s > > > <int> ) ; data [ length + + ] = ( byte ) s ; this . length = length ; return this ; } public ByteVector putInt ( final int i ) { int length = this . length ; if ( length + <int> > data . length ) { enlarge ( <int> ) ; } byte [ ] data = this . data ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) i ; this . length = length ; return this ; } public ByteVector putLong ( final long l ) { int length = this . length ; if ( length + <int> > data . length ) { enlarge ( <int> ) ; } byte [ ] data = this . data ; int i = ( int ) ( l > > > <int> ) ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) i ; i = ( int ) l ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) ( i > > > <int> ) ; data [ length + + ] = ( byte ) i ; this . length = length ; return this ; } public ByteVector putUTF8 ( final String s ) { int charLength = s . length ( ) ; int len = length ; if ( len + <int> + charLength > data . length ) { enlarge ( <int> + charLength ) ; } byte [ ] data = this . data ; data [ len + + ] = ( byte ) ( charLength > > > <int> ) ; data [ len + + ] = ( byte ) charLength ; for ( int i = <int> ; i < charLength ; + + i ) { char c = s . charAt ( i ) ; if ( c > = <oct> & & c < = <int> ) { data [ len + + ] = ( byte ) c ; } else { int byteLength = i ; for ( int j = i ; j < charLength ; + + j ) { c = s . charAt ( j ) ; if ( c > = <oct> & & c < = <int> ) { byteLength + + ; } else if ( c > <str> ) { byteLength + = <int> ; } else { byteLength + = <int> ; } } data [ length ] = ( byte ) ( byteLength > > > <int> ) ; data [ length + <int> ] = ( byte ) byteLength ; if ( length + <int> + byteLength > data . length ) { length = len ; enlarge ( <int> + byteLength ) ; data = this . data ; } for ( int j = i ; j < charLength ; + + j ) { c = s . charAt ( j ) ; if ( c > = <oct> & & c < = <int> ) { data [ len + + ] = ( byte ) c ; } else if ( c > <str> ) { data [ len + + ] = ( byte ) ( <hex> | c > > <int> & <hex> ) ; data [ len + + ] = ( byte ) ( <hex> | c > > <int> & <hex> ) ; data [ len + + ] = ( byte ) ( <hex> | c & <hex> ) ; } else { data [ len + + ] = ( byte ) ( <hex> | c > > <int> & <hex> ) ; data [ len + + ] = ( byte ) ( <hex> | c & <hex> ) ; } } break ; } } length = len ; return this ; } public ByteVector putByteArray ( final byte [ ] b , final int off , final int len ) { if ( length + len > data . length ) { enlarge ( len ) ; } if ( b ! = null ) { System . arraycopy ( b , off , data , length , len ) ; } length + = len ; return this ; } private void enlarge ( final int size ) { int length1 = <int> * data . length ; int length2 = length + size ; byte [ ] newData = new byte [ length1 > length2 ? length1 : length2 ] ; System . arraycopy ( data , <int> , newData , <int> , length ) ; data = newData ; } } 
