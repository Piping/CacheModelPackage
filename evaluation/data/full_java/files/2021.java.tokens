package org . nd4j . linalg . api . ops . impl . accum ; import org . apache . commons . math3 . util . FastMath ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . BaseAccumulation ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . util . ComplexUtil ; public class NormMax extends BaseAccumulation { public NormMax ( ) { } public NormMax ( INDArray x , INDArray y , INDArray z , int n ) { super ( x , y , z , n ) ; } public NormMax ( INDArray x , INDArray y , int n ) { super ( x , y , n ) ; } public NormMax ( INDArray x ) { super ( x ) ; } public NormMax ( INDArray x , INDArray y ) { super ( x , y ) ; } @Override public double update ( double accum , double x ) { numProcessed + + ; return FastMath . max ( FastMath . abs ( x ) , accum ) ; } @Override public double update ( double accum , double x , double y ) { return update ( accum , x ) ; } @Override public float update ( float accum , float x ) { return ( x > = <int> ? ( x > accum ? x : accum ) : ( - x > accum ? - x : accum ) ) ; } @Override public float update ( float accum , float x , float y ) { return ( x > = <int> ? ( x > accum ? x : accum ) : ( - x > accum ? - x : accum ) ) ; } @Override public IComplexNumber update ( IComplexNumber accum , double x ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = FastMath . abs ( x ) ? accum : Nd4j . createComplexNumber ( FastMath . abs ( x ) , <int> ) ) ; } @Override public IComplexNumber update ( IComplexNumber accum , double x , double y ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = FastMath . abs ( x ) ? accum : Nd4j . createComplexNumber ( FastMath . abs ( x ) , <int> ) ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = x . absoluteValue ( ) . doubleValue ( ) ? accum : Nd4j . createComplexNumber ( x . absoluteValue ( ) , <int> ) ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x , IComplexNumber y ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = x . absoluteValue ( ) . doubleValue ( ) ? accum : Nd4j . createComplexNumber ( x . absoluteValue ( ) , <int> ) ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x , double y ) { return ( accum . absoluteValue ( ) . doubleValue ( ) > = x . absoluteValue ( ) . doubleValue ( ) ? accum : Nd4j . createComplexNumber ( x . absoluteValue ( ) , <int> ) ) ; } @Override public String name ( ) { return <str> ; } @Override public Op opForDimension ( int index , int dimension ) { INDArray xAlongDimension = x . vectorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new NormMax ( xAlongDimension , y . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new NormMax ( x . vectorAlongDimension ( index , dimension ) ) ; } @Override public Op opForDimension ( int index , int . . . dimension ) { INDArray xAlongDimension = x . tensorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new NormMax ( xAlongDimension , y . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new NormMax ( x . tensorAlongDimension ( index , dimension ) ) ; } } 
