package org . jbox2d . collision . shapes ; import org . jbox2d . collision . AABB ; import org . jbox2d . collision . RayCastInput ; import org . jbox2d . collision . RayCastOutput ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; public class EdgeShape extends Shape { public final Vec2 m_vertex1 = new Vec2 ( ) ; public final Vec2 m_vertex2 = new Vec2 ( ) ; public final Vec2 m_vertex0 = new Vec2 ( ) ; public final Vec2 m_vertex3 = new Vec2 ( ) ; public boolean m_hasVertex0 = false , m_hasVertex3 = false ; public EdgeShape ( ) { super ( ShapeType . EDGE ) ; m_radius = Settings . polygonRadius ; } @Override public int getChildCount ( ) { return <int> ; } public void set ( Vec2 v1 , Vec2 v2 ) { m_vertex1 . set ( v1 ) ; m_vertex2 . set ( v2 ) ; m_hasVertex0 = m_hasVertex3 = false ; } @Override public boolean testPoint ( Transform xf , Vec2 p ) { return false ; } private final Vec2 normal = new Vec2 ( ) ; @Override public float computeDistanceToOut ( Transform xf , Vec2 p , int childIndex , Vec2 normalOut ) { float xfqc = xf . q . c ; float xfqs = xf . q . s ; float xfpx = xf . p . x ; float xfpy = xf . p . y ; float v1x = ( xfqc * m_vertex1 . x - xfqs * m_vertex1 . y ) + xfpx ; float v1y = ( xfqs * m_vertex1 . x + xfqc * m_vertex1 . y ) + xfpy ; float v2x = ( xfqc * m_vertex2 . x - xfqs * m_vertex2 . y ) + xfpx ; float v2y = ( xfqs * m_vertex2 . x + xfqc * m_vertex2 . y ) + xfpy ; float dx = p . x - v1x ; float dy = p . y - v1y ; float sx = v2x - v1x ; float sy = v2y - v1y ; float ds = dx * sx + dy * sy ; if ( ds > <int> ) { float s2 = sx * sx + sy * sy ; if ( ds > s2 ) { dx = p . x - v2x ; dy = p . y - v2y ; } else { dx - = ds / s2 * sx ; dy - = ds / s2 * sy ; } } float d1 = MathUtils . sqrt ( dx * dx + dy * dy ) ; if ( d1 > <int> ) { normalOut . x = <int> / d1 * dx ; normalOut . y = <int> / d1 * dy ; } else { normalOut . x = <int> ; normalOut . y = <int> ; } return d1 ; } @Override public boolean raycast ( RayCastOutput output , RayCastInput input , Transform xf , int childIndex ) { float tempx , tempy ; final Vec2 v1 = m_vertex1 ; final Vec2 v2 = m_vertex2 ; final Rot xfq = xf . q ; final Vec2 xfp = xf . p ; tempx = input . p1 . x - xfp . x ; tempy = input . p1 . y - xfp . y ; final float p1x = xfq . c * tempx + xfq . s * tempy ; final float p1y = - xfq . s * tempx + xfq . c * tempy ; tempx = input . p2 . x - xfp . x ; tempy = input . p2 . y - xfp . y ; final float p2x = xfq . c * tempx + xfq . s * tempy ; final float p2y = - xfq . s * tempx + xfq . c * tempy ; final float dx = p2x - p1x ; final float dy = p2y - p1y ; normal . x = v2 . y - v1 . y ; normal . y = v1 . x - v2 . x ; normal . normalize ( ) ; final float normalx = normal . x ; final float normaly = normal . y ; tempx = v1 . x - p1x ; tempy = v1 . y - p1y ; float numerator = normalx * tempx + normaly * tempy ; float denominator = normalx * dx + normaly * dy ; if ( denominator = = <float> ) { return false ; } float t = numerator / denominator ; if ( t < <float> | | <float> < t ) { return false ; } final float qx = p1x + t * dx ; final float qy = p1y + t * dy ; final float rx = v2 . x - v1 . x ; final float ry = v2 . y - v1 . y ; final float rr = rx * rx + ry * ry ; if ( rr = = <float> ) { return false ; } tempx = qx - v1 . x ; tempy = qy - v1 . y ; float s = ( tempx * rx + tempy * ry ) / rr ; if ( s < <float> | | <float> < s ) { return false ; } output . fraction = t ; if ( numerator > <float> ) { output . normal . x = - xfq . c * normal . x + xfq . s * normal . y ; output . normal . y = - xfq . s * normal . x - xfq . c * normal . y ; } else { output . normal . x = xfq . c * normal . x - xfq . s * normal . y ; output . normal . y = xfq . s * normal . x + xfq . c * normal . y ; } return true ; } @Override public void computeAABB ( AABB aabb , Transform xf , int childIndex ) { final Vec2 lowerBound = aabb . lowerBound ; final Vec2 upperBound = aabb . upperBound ; final Rot xfq = xf . q ; final float v1x = ( xfq . c * m_vertex1 . x - xfq . s * m_vertex1 . y ) + xf . p . x ; final float v1y = ( xfq . s * m_vertex1 . x + xfq . c * m_vertex1 . y ) + xf . p . y ; final float v2x = ( xfq . c * m_vertex2 . x - xfq . s * m_vertex2 . y ) + xf . p . x ; final float v2y = ( xfq . s * m_vertex2 . x + xfq . c * m_vertex2 . y ) + xf . p . y ; lowerBound . x = v1x < v2x ? v1x : v2x ; lowerBound . y = v1y < v2y ? v1y : v2y ; upperBound . x = v1x > v2x ? v1x : v2x ; upperBound . y = v1y > v2y ? v1y : v2y ; lowerBound . x - = m_radius ; lowerBound . y - = m_radius ; upperBound . x + = m_radius ; upperBound . y + = m_radius ; } @Override public void computeMass ( MassData massData , float density ) { massData . mass = <float> ; massData . center . set ( m_vertex1 ) . addLocal ( m_vertex2 ) . mulLocal ( <float> ) ; massData . I = <float> ; } @Override public Shape clone ( ) { EdgeShape edge = new EdgeShape ( ) ; edge . m_radius = this . m_radius ; edge . m_hasVertex0 = this . m_hasVertex0 ; edge . m_hasVertex3 = this . m_hasVertex3 ; edge . m_vertex0 . set ( this . m_vertex0 ) ; edge . m_vertex1 . set ( this . m_vertex1 ) ; edge . m_vertex2 . set ( this . m_vertex2 ) ; edge . m_vertex3 . set ( this . m_vertex3 ) ; return edge ; } } 
