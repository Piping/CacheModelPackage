package org . elasticsearch . search . aggregations . pipeline . having ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . Script . ScriptField ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilder ; import java . io . IOException ; import java . util . Map ; public class BucketSelectorBuilder extends PipelineAggregatorBuilder < BucketSelectorBuilder > { private GapPolicy gapPolicy ; private Script script ; private Map < String , String > bucketsPathsMap ; public BucketSelectorBuilder ( String name ) { super ( name , BucketSelectorPipelineAggregator . TYPE . name ( ) ) ; } public BucketSelectorBuilder script ( Script script ) { this . script = script ; return this ; } public BucketSelectorBuilder gapPolicy ( GapPolicy gapPolicy ) { this . gapPolicy = gapPolicy ; return this ; } public BucketSelectorBuilder setBucketsPathsMap ( Map < String , String > bucketsPathsMap ) { this . bucketsPathsMap = bucketsPathsMap ; return this ; } @Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params builderParams ) throws IOException { if ( script ! = null ) { builder . field ( ScriptField . SCRIPT . getPreferredName ( ) , script ) ; } if ( gapPolicy ! = null ) { builder . field ( BucketSelectorParser . GAP_POLICY . getPreferredName ( ) , gapPolicy . getName ( ) ) ; } if ( bucketsPathsMap ! = null ) { builder . field ( PipelineAggregator . Parser . BUCKETS_PATH . getPreferredName ( ) , bucketsPathsMap ) ; } return builder ; } } 
