package com . badlogic . gdx . tests . g3d ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . Cubemap ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . CubemapAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . graphics . g3d . loader . ObjLoader ; import com . badlogic . gdx . graphics . g3d . utils . TextureDescriptor ; import com . badlogic . gdx . graphics . glutils . FrameBufferCubemap ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; public class FrameBufferCubemapTest extends Basic3DSceneTest { protected PerspectiveCamera camFb ; protected PerspectiveCamera camCube ; protected FrameBufferCubemap fb ; protected Cubemap cubemap ; protected Model cubeMesh ; protected ModelInstance cubeInstance ; protected ModelBatch cubeBatch ; @Override public void create ( ) { super . create ( ) ; camFb = new PerspectiveCamera ( <int> , <int> , <int> ) ; camFb . position . set ( <int> f , <int> f , <int> f ) ; camFb . lookAt ( <int> , <int> , <int> ) ; camFb . near = <float> ; camFb . far = <int> f ; camFb . update ( ) ; fb = new FrameBufferCubemap ( Format . RGBA8888 , <int> , <int> , true ) ; ObjLoader objLoader = new ObjLoader ( ) ; cubeMesh = objLoader . loadModel ( Gdx . files . internal ( <str> ) ) ; cubeInstance = new ModelInstance ( cubeMesh ) ; cubeBatch = new ModelBatch ( Gdx . files . internal ( <str> ) , Gdx . files . internal ( <str> ) ) ; cubeMesh . materials . get ( <int> ) . set ( new CubemapAttribute ( CubemapAttribute . EnvironmentMap , cubemap ) ) ; camCube = new PerspectiveCamera ( <int> , Gdx . graphics . getWidth ( ) * <float> , Gdx . graphics . getHeight ( ) * <float> ) ; camCube . position . set ( <float> , <float> , <float> ) ; camCube . lookAt ( <int> , <int> , <int> ) ; camCube . near = <float> ; camCube . far = <int> f ; camCube . update ( ) ; } @Override public void render ( ) { renderScene ( ) ; renderCube ( ) ; } public void renderScene ( ) { Gdx . gl . glViewport ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; Gdx . gl . glDisable ( GL20 . GL_SCISSOR_TEST ) ; super . render ( ) ; camFb . position . set ( cam . position ) ; camFb . near = cam . near ; camFb . far = cam . far ; fb . begin ( ) ; while ( fb . nextSide ( ) ) { fb . getSide ( ) . getUp ( camFb . up ) ; fb . getSide ( ) . getDirection ( camFb . direction ) ; camFb . update ( ) ; Gdx . gl . glClearColor ( <int> , <int> , <int> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; modelBatch . begin ( camFb ) ; for ( ModelInstance instance : instances ) modelBatch . render ( instance , lights ) ; if ( space ! = null ) modelBatch . render ( space ) ; modelBatch . end ( ) ; } fb . end ( ) ; cubemap = fb . getColorBufferTexture ( ) ; } float yaw , pitch , roll ; public void renderCube ( ) { int w = Gdx . graphics . getWidth ( ) ; int h = Gdx . graphics . getHeight ( ) ; int x = ( int ) ( w - w * <float> ) ; int y = ( int ) ( h - h * <float> ) ; w * = <float> ; h * = <float> ; Gdx . gl . glViewport ( x , y , w , h ) ; Gdx . gl . glEnable ( GL20 . GL_SCISSOR_TEST ) ; Gdx . gl . glScissor ( x , y , w , h ) ; Gdx . gl . glClearColor ( <int> , <int> , <int> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; pitch + = <int> * Gdx . graphics . getDeltaTime ( ) ; yaw + = <int> * Gdx . graphics . getDeltaTime ( ) ; cubeInstance . transform . setFromEulerAngles ( yaw , pitch , roll ) ; cubeBatch . begin ( camCube ) ; cubeBatch . render ( cubeInstance ) ; cubeBatch . end ( ) ; } } 
