package org . elasticsearch . rest ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . bootstrap . Elasticsearch ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . ESLoggerFactory ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; import java . util . Collections ; public class BytesRestResponse extends RestResponse { public static final String TEXT_CONTENT_TYPE = <str> ; private final RestStatus status ; private final BytesReference content ; private final String contentType ; public BytesRestResponse ( RestStatus status ) { this ( status , TEXT_CONTENT_TYPE , BytesArray . EMPTY ) ; } public BytesRestResponse ( RestStatus status , XContentBuilder builder ) { this ( status , builder . contentType ( ) . restContentType ( ) , builder . bytes ( ) ) ; } public BytesRestResponse ( RestStatus status , String content ) { this ( status , TEXT_CONTENT_TYPE , new BytesArray ( content ) ) ; } public BytesRestResponse ( RestStatus status , String contentType , String content ) { this ( status , contentType , new BytesArray ( content ) ) ; } public BytesRestResponse ( RestStatus status , String contentType , byte [ ] content ) { this ( status , contentType , new BytesArray ( content ) ) ; } public BytesRestResponse ( RestStatus status , String contentType , BytesReference content ) { this . status = status ; this . content = content ; this . contentType = contentType ; } public BytesRestResponse ( RestChannel channel , Throwable t ) throws IOException { this ( channel , ExceptionsHelper . status ( t ) , t ) ; } public BytesRestResponse ( RestChannel channel , RestStatus status , Throwable t ) throws IOException { this . status = status ; if ( channel . request ( ) . method ( ) = = RestRequest . Method . HEAD ) { this . content = BytesArray . EMPTY ; this . contentType = TEXT_CONTENT_TYPE ; } else { XContentBuilder builder = convert ( channel , status , t ) ; this . content = builder . bytes ( ) ; this . contentType = builder . contentType ( ) . restContentType ( ) ; } if ( t instanceof ElasticsearchException ) { copyHeaders ( ( ( ElasticsearchException ) t ) ) ; } } @Override public String contentType ( ) { return this . contentType ; } @Override public BytesReference content ( ) { return this . content ; } @Override public RestStatus status ( ) { return this . status ; } private static final ESLogger SUPPRESSED_ERROR_LOGGER = ESLoggerFactory . getLogger ( <str> ) ; private static XContentBuilder convert ( RestChannel channel , RestStatus status , Throwable t ) throws IOException { XContentBuilder builder = channel . newErrorBuilder ( ) . startObject ( ) ; if ( t = = null ) { builder . field ( <str> , <str> ) ; } else if ( channel . detailedErrorsEnabled ( ) ) { final ToXContent . Params params ; if ( channel . request ( ) . paramAsBoolean ( <str> , ! ElasticsearchException . REST_EXCEPTION_SKIP_STACK_TRACE_DEFAULT ) ) { params = new ToXContent . DelegatingMapParams ( Collections . singletonMap ( ElasticsearchException . REST_EXCEPTION_SKIP_STACK_TRACE , <str> ) , channel . request ( ) ) ; } else { SUPPRESSED_ERROR_LOGGER . info ( <str> , t , channel . request ( ) . path ( ) , channel . request ( ) . params ( ) ) ; params = channel . request ( ) ; } builder . field ( <str> ) ; builder . startObject ( ) ; final ElasticsearchException [ ] rootCauses = ElasticsearchException . guessRootCauses ( t ) ; builder . field ( <str> ) ; builder . startArray ( ) ; for ( ElasticsearchException rootCause : rootCauses ) { builder . startObject ( ) ; rootCause . toXContent ( builder , new ToXContent . DelegatingMapParams ( Collections . singletonMap ( ElasticsearchException . REST_EXCEPTION_SKIP_CAUSE , <str> ) , params ) ) ; builder . endObject ( ) ; } builder . endArray ( ) ; ElasticsearchException . toXContent ( builder , params , t ) ; builder . endObject ( ) ; } else { builder . field ( <str> , simpleMessage ( t ) ) ; } builder . field ( <str> , status . getStatus ( ) ) ; builder . endObject ( ) ; return builder ; } private static String simpleMessage ( Throwable t ) throws IOException { int counter = <int> ; Throwable next = t ; while ( next ! = null & & counter + + < <int> ) { if ( t instanceof ElasticsearchException ) { return next . getClass ( ) . getSimpleName ( ) + <str> + next . getMessage ( ) + <str> ; } next = next . getCause ( ) ; } return <str> ; } } 
