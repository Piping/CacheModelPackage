package com . google . common . eventbus ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . testing . EqualsTester ; import junit . framework . TestCase ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; public class SubscriberTest extends TestCase { private static final Object FIXTURE_ARGUMENT = new Object ( ) ; private EventBus bus ; private boolean methodCalled ; private Object methodArgument ; @Override protected void setUp ( ) throws Exception { bus = new EventBus ( ) ; methodCalled = false ; methodArgument = null ; } public void testCreate ( ) { Subscriber s1 = Subscriber . create ( bus , this , getTestSubscriberMethod ( <str> ) ) ; assertThat ( s1 ) . isInstanceOf ( Subscriber . SynchronizedSubscriber . class ) ; Subscriber s2 = Subscriber . create ( bus , this , getTestSubscriberMethod ( <str> ) ) ; assertThat ( s2 ) . isNotInstanceOf ( Subscriber . SynchronizedSubscriber . class ) ; } public void testInvokeSubscriberMethod_basicMethodCall ( ) throws Throwable { Method method = getTestSubscriberMethod ( <str> ) ; Subscriber subscriber = Subscriber . create ( bus , this , method ) ; subscriber . invokeSubscriberMethod ( FIXTURE_ARGUMENT ) ; assertTrue ( <str> , methodCalled ) ; assertTrue ( <str> , methodArgument = = FIXTURE_ARGUMENT ) ; } public void testInvokeSubscriberMethod_exceptionWrapping ( ) throws Throwable { Method method = getTestSubscriberMethod ( <str> ) ; Subscriber subscriber = Subscriber . create ( bus , this , method ) ; try { subscriber . invokeSubscriberMethod ( FIXTURE_ARGUMENT ) ; fail ( <str> ) ; } catch ( InvocationTargetException expected ) { assertThat ( expected . getCause ( ) ) . isInstanceOf ( IntentionalException . class ) ; } } public void testInvokeSubscriberMethod_errorPassthrough ( ) throws Throwable { Method method = getTestSubscriberMethod ( <str> ) ; Subscriber subscriber = Subscriber . create ( bus , this , method ) ; try { subscriber . invokeSubscriberMethod ( FIXTURE_ARGUMENT ) ; fail ( <str> ) ; } catch ( JudgmentError expected ) { } } public void testEquals ( ) throws Exception { Method charAt = String . class . getMethod ( <str> , int . class ) ; Method concat = String . class . getMethod ( <str> , String . class ) ; new EqualsTester ( ) . addEqualityGroup ( Subscriber . create ( bus , <str> , charAt ) , Subscriber . create ( bus , <str> , charAt ) ) . addEqualityGroup ( Subscriber . create ( bus , <str> , charAt ) ) . addEqualityGroup ( Subscriber . create ( bus , <str> , concat ) ) . testEquals ( ) ; } private Method getTestSubscriberMethod ( String name ) { try { return getClass ( ) . getDeclaredMethod ( name , Object . class ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( ) ; } } @Subscribe public void recordingMethod ( Object arg ) { assertFalse ( methodCalled ) ; methodCalled = true ; methodArgument = arg ; } @Subscribe public void exceptionThrowingMethod ( Object arg ) throws Exception { throw new IntentionalException ( ) ; } class IntentionalException extends Exception { private static final long serialVersionUID = - <int> ; } @Subscribe public void errorThrowingMethod ( Object arg ) { throw new JudgmentError ( ) ; } @Subscribe @AllowConcurrentEvents public void threadSafeMethod ( Object arg ) { } class JudgmentError extends Error { private static final long serialVersionUID = <int> ; } } 
