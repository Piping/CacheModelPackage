package org . gradle . api . internal . artifacts . ivyservice . resolveengine . graph . conflicts ; import com . google . common . base . Joiner ; import com . google . common . collect . LinkedHashMultimap ; import com . google . common . collect . Multimap ; import com . google . common . collect . Sets ; import org . gradle . api . Nullable ; import java . util . * ; import static com . google . common . collect . Lists . newLinkedList ; import static com . google . common . collect . Maps . newHashMap ; import static java . util . Arrays . asList ; class ConflictContainer < K , T > { final LinkedList < Conflict > conflicts = newLinkedList ( ) ; private final Map < K , Collection < ? extends T > > elements = newHashMap ( ) ; private final Multimap < K , K > targetToSource = LinkedHashMultimap . create ( ) ; public Conflict newElement ( K target , Collection < ? extends T > candidates , @Nullable K replacedBy ) { elements . put ( target , candidates ) ; if ( replacedBy ! = null ) { targetToSource . put ( replacedBy , target ) ; if ( elements . containsKey ( replacedBy ) ) { return registerConflict ( target , replacedBy ) ; } } Collection < K > replacementSource = targetToSource . get ( target ) ; if ( ! replacementSource . isEmpty ( ) ) { return registerConflict ( replacementSource , target ) ; } if ( candidates . size ( ) > <int> ) { return registerConflict ( target , target ) ; } return null ; } private Conflict registerConflict ( Collection < K > targets , K replacedBy ) { assert ! targets . isEmpty ( ) ; Collection < ? extends T > candidates = elements . get ( replacedBy ) ; assert candidates ! = null ; Set < K > participants = new LinkedHashSet < K > ( ) ; participants . addAll ( targets ) ; participants . add ( replacedBy ) ; for ( Conflict c : conflicts ) { if ( ! Sets . intersection ( participants , c . participants ) . isEmpty ( ) ) { c . candidates = candidates ; c . participants . addAll ( participants ) ; return c ; } } Conflict c = new Conflict ( participants , candidates ) ; conflicts . add ( c ) ; return c ; } private Conflict registerConflict ( K target , K replacedBy ) { return registerConflict ( asList ( target ) , replacedBy ) ; } public int getSize ( ) { return conflicts . size ( ) ; } public Conflict popConflict ( ) { assert ! conflicts . isEmpty ( ) ; return conflicts . pop ( ) ; } class Conflict { Set < K > participants ; Collection < ? extends T > candidates ; public Conflict ( Set < K > participants , Collection < ? extends T > candidates ) { this . participants = participants ; this . candidates = candidates ; } public String toString ( ) { return Joiner . on ( <str> ) . join ( participants ) + <str> + Joiner . on ( <str> ) . join ( candidates ) ; } } } 
