package org . apache . cassandra . streaming ; import java . net . InetAddress ; import java . util . * ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . utils . UUIDGen ; public class StreamPlan { private final UUID planId = UUIDGen . getTimeUUID ( ) ; private final String description ; private final List < StreamEventHandler > handlers = new ArrayList < > ( ) ; private final long repairedAt ; private final StreamCoordinator coordinator ; private boolean flushBeforeTransfer = true ; public StreamPlan ( String description ) { this ( description , ActiveRepairService . UNREPAIRED_SSTABLE , <int> , false , false ) ; } public StreamPlan ( String description , boolean keepSSTableLevels ) { this ( description , ActiveRepairService . UNREPAIRED_SSTABLE , <int> , keepSSTableLevels , false ) ; } public StreamPlan ( String description , long repairedAt , int connectionsPerHost , boolean keepSSTableLevels , boolean isIncremental ) { this . description = description ; this . repairedAt = repairedAt ; this . coordinator = new StreamCoordinator ( connectionsPerHost , keepSSTableLevels , isIncremental , new DefaultConnectionFactory ( ) ) ; } public StreamPlan requestRanges ( InetAddress from , InetAddress connecting , String keyspace , Collection < Range < Token > > ranges ) { return requestRanges ( from , connecting , keyspace , ranges , new String [ <int> ] ) ; } public StreamPlan requestRanges ( InetAddress from , InetAddress connecting , String keyspace , Collection < Range < Token > > ranges , String . . . columnFamilies ) { StreamSession session = coordinator . getOrCreateNextSession ( from , connecting ) ; session . addStreamRequest ( keyspace , ranges , Arrays . asList ( columnFamilies ) , repairedAt ) ; return this ; } public StreamPlan transferRanges ( InetAddress to , String keyspace , Collection < Range < Token > > ranges , String . . . columnFamilies ) { return transferRanges ( to , to , keyspace , ranges , columnFamilies ) ; } public StreamPlan transferRanges ( InetAddress to , InetAddress connecting , String keyspace , Collection < Range < Token > > ranges ) { return transferRanges ( to , connecting , keyspace , ranges , new String [ <int> ] ) ; } public StreamPlan transferRanges ( InetAddress to , InetAddress connecting , String keyspace , Collection < Range < Token > > ranges , String . . . columnFamilies ) { StreamSession session = coordinator . getOrCreateNextSession ( to , connecting ) ; session . addTransferRanges ( keyspace , ranges , Arrays . asList ( columnFamilies ) , flushBeforeTransfer , repairedAt ) ; return this ; } public StreamPlan transferFiles ( InetAddress to , Collection < StreamSession . SSTableStreamingSections > sstableDetails ) { coordinator . transferFiles ( to , sstableDetails ) ; return this ; } public StreamPlan listeners ( StreamEventHandler handler , StreamEventHandler . . . handlers ) { this . handlers . add ( handler ) ; if ( handlers ! = null ) Collections . addAll ( this . handlers , handlers ) ; return this ; } public StreamPlan connectionFactory ( StreamConnectionFactory factory ) { this . coordinator . setConnectionFactory ( factory ) ; return this ; } public boolean isEmpty ( ) { return ! coordinator . hasActiveSessions ( ) ; } public StreamResultFuture execute ( ) { return StreamResultFuture . init ( planId , description , handlers , coordinator ) ; } public StreamPlan flushBeforeTransfer ( boolean flushBeforeTransfer ) { this . flushBeforeTransfer = flushBeforeTransfer ; return this ; } } 
