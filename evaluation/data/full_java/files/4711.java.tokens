package org . eclipse . debug . ui . actions ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . io . StringReader ; import java . io . UnsupportedEncodingException ; import java . lang . reflect . InvocationTargetException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import org . eclipse . core . resources . IMarker ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . IWorkspaceRoot ; import org . eclipse . core . resources . ResourcesPlugin ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . SubMonitor ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . core . model . IBreakpointImportParticipant ; import org . eclipse . debug . internal . core . BreakpointManager ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . internal . ui . importexport . breakpoints . IImportExportConstants ; import org . eclipse . debug . internal . ui . importexport . breakpoints . ImportExportMessages ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . jface . operation . IRunnableWithProgress ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . IWorkingSet ; import org . eclipse . ui . IWorkingSetManager ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . XMLMemento ; import com . ibm . icu . text . MessageFormat ; public class ImportBreakpointsOperation implements IRunnableWithProgress { private boolean fOverwriteAll = false ; private String fFileName = null ; private boolean fCreateWorkingSets = false ; private ArrayList < IBreakpoint > fAdded = new ArrayList < IBreakpoint > ( ) ; private String fCurrentWorkingSetProperty = null ; private BreakpointManager fManager = ( BreakpointManager ) DebugPlugin . getDefault ( ) . getBreakpointManager ( ) ; private StringBuffer fBuffer = null ; private boolean fImportBreakpoints = true ; public ImportBreakpointsOperation ( String fileName , boolean overwrite , boolean createWorkingSets ) { this ( fileName , overwrite , createWorkingSets , true ) ; } public ImportBreakpointsOperation ( String fileName , boolean overwrite , boolean createWorkingSets , boolean importBreakpoints ) { fFileName = fileName ; fOverwriteAll = overwrite ; fCreateWorkingSets = createWorkingSets ; fImportBreakpoints = importBreakpoints ; } public ImportBreakpointsOperation ( StringBuffer buffer , boolean overwrite , boolean createWorkingSets ) { this ( buffer , overwrite , createWorkingSets , true ) ; } public ImportBreakpointsOperation ( StringBuffer buffer , boolean overwrite , boolean createWorkingSets , boolean importBreakpoints ) { fBuffer = buffer ; fOverwriteAll = overwrite ; fCreateWorkingSets = createWorkingSets ; fImportBreakpoints = importBreakpoints ; } @Override public void run ( final IProgressMonitor monitor ) throws InvocationTargetException { SubMonitor localmonitor = SubMonitor . convert ( monitor , ImportExportMessages . ImportOperation_0 , <int> ) ; try { XMLMemento memento = null ; if ( fBuffer = = null ) { try ( Reader reader = new InputStreamReader ( new FileInputStream ( fFileName ) , <str> ) ) { memento = XMLMemento . createReadRoot ( reader ) ; } catch ( FileNotFoundException e ) { throw new InvocationTargetException ( e , MessageFormat . format ( <str> , new Object [ ] { fFileName } ) ) ; } catch ( UnsupportedEncodingException e ) { throw new InvocationTargetException ( e , MessageFormat . format ( <str> , new Object [ ] { fFileName } ) ) ; } catch ( IOException e ) { throw new InvocationTargetException ( e ) ; } } else { try ( Reader reader = new StringReader ( fBuffer . toString ( ) ) ) { memento = XMLMemento . createReadRoot ( reader ) ; } catch ( IOException e ) { throw new InvocationTargetException ( e ) ; } } IMemento [ ] nodes = memento . getChildren ( IImportExportConstants . IE_NODE_BREAKPOINT ) ; IWorkspaceRoot workspace = ResourcesPlugin . getWorkspace ( ) . getRoot ( ) ; localmonitor . setWorkRemaining ( nodes . length ) ; Map < String , Object > attributes = null ; IBreakpointImportParticipant [ ] participants = null ; for ( int i = <int> ; i < nodes . length ; i + + ) { if ( localmonitor . isCanceled ( ) ) { return ; } attributes = collectBreakpointProperties ( nodes [ i ] ) ; if ( attributes = = null ) { continue ; } IResource resource ; if ( fImportBreakpoints ) { resource = workspace . findMember ( ( String ) attributes . get ( IImportExportConstants . IE_NODE_PATH ) ) ; } else { resource = workspace ; } if ( resource ! = null ) { try { participants = fManager . getImportParticipants ( ( String ) attributes . get ( IImportExportConstants . IE_NODE_TYPE ) ) ; } catch ( CoreException ce ) { } IMarker marker = findExistingMarker ( attributes , participants ) ; if ( marker = = null ) { marker = resource . createMarker ( ( String ) attributes . get ( IImportExportConstants . IE_NODE_TYPE ) ) ; restoreBreakpoint ( marker , attributes , participants ) ; } else { if ( fOverwriteAll ) { if ( ! fImportBreakpoints ) { marker = resource . createMarker ( ( String ) attributes . get ( IImportExportConstants . IE_NODE_TYPE ) ) ; } else { marker . setAttributes ( null ) ; } restoreBreakpoint ( marker , attributes , participants ) ; } } } fCurrentWorkingSetProperty = null ; localmonitor . worked ( <int> ) ; } if ( fAdded . size ( ) > <int> & & fImportBreakpoints ) { fManager . addBreakpoints ( fAdded . toArray ( new IBreakpoint [ fAdded . size ( ) ] ) ) ; } } catch ( CoreException ce ) { throw new InvocationTargetException ( ce , MessageFormat . format ( <str> , new Object [ ] { fFileName } ) ) ; } finally { localmonitor . done ( ) ; } } protected IMarker findExistingMarker ( Map < String , Object > attributes , IBreakpointImportParticipant [ ] participants ) { IBreakpoint [ ] bps = fManager . getBreakpoints ( ) ; for ( int i = <int> ; i < bps . length ; i + + ) { for ( int j = <int> ; j < participants . length ; j + + ) { try { if ( participants [ j ] . matches ( attributes , bps [ i ] ) ) { return bps [ i ] . getMarker ( ) ; } } catch ( CoreException ce ) { } } } return null ; } protected Map < String , Object > collectBreakpointProperties ( IMemento memento ) { HashMap < String , Object > map = new HashMap < String , Object > ( ) ; map . put ( IImportExportConstants . IE_BP_ENABLED , memento . getBoolean ( IImportExportConstants . IE_BP_ENABLED ) ) ; map . put ( IImportExportConstants . IE_BP_PERSISTANT , memento . getBoolean ( IImportExportConstants . IE_BP_PERSISTANT ) ) ; map . put ( IImportExportConstants . IE_BP_REGISTERED , memento . getBoolean ( IImportExportConstants . IE_BP_REGISTERED ) ) ; IMemento child = memento . getChild ( IImportExportConstants . IE_NODE_MARKER ) ; map . put ( IImportExportConstants . IE_NODE_TYPE , child . getString ( IImportExportConstants . IE_NODE_TYPE ) ) ; map . put ( IMarker . LINE_NUMBER , child . getInteger ( IMarker . LINE_NUMBER ) ) ; IMemento [ ] children = child . getChildren ( IImportExportConstants . IE_NODE_ATTRIB ) ; for ( int i = <int> ; i < children . length ; i + + ) { readAttribute ( children [ i ] , map ) ; } child = memento . getChild ( IImportExportConstants . IE_NODE_RESOURCE ) ; map . put ( IImportExportConstants . IE_NODE_PATH , child . getString ( IImportExportConstants . IE_NODE_PATH ) ) ; return map ; } private void readAttribute ( IMemento memento , Map < String , Object > map ) { String name = memento . getString ( IImportExportConstants . IE_NODE_NAME ) , value = memento . getString ( IImportExportConstants . IE_NODE_VALUE ) ; if ( value ! = null & & name ! = null ) { if ( name . equals ( IInternalDebugUIConstants . WORKING_SET_NAME ) ) { fCurrentWorkingSetProperty = value ; } Object val = value ; try { val = Integer . valueOf ( value ) ; } catch ( NumberFormatException e ) { if ( value . equalsIgnoreCase ( <str> ) | | value . equalsIgnoreCase ( <str> ) ) { val = Boolean . valueOf ( value ) ; } } if ( val ! = null ) { map . put ( name , val ) ; } } } protected void restoreBreakpoint ( IMarker marker , final Map < String , Object > attributes , IBreakpointImportParticipant [ ] participants ) { for ( Entry < String , Object > entry : attributes . entrySet ( ) ) { try { marker . setAttribute ( entry . getKey ( ) , entry . getValue ( ) ) ; } catch ( CoreException ce ) { } } IBreakpoint breakpoint = null ; try { breakpoint = fManager . createBreakpoint ( marker ) ; breakpoint . setEnabled ( ( ( Boolean ) attributes . get ( IImportExportConstants . IE_BP_ENABLED ) ) . booleanValue ( ) ) ; breakpoint . setPersisted ( ( ( Boolean ) attributes . get ( IImportExportConstants . IE_BP_PERSISTANT ) ) . booleanValue ( ) ) ; breakpoint . setRegistered ( ( ( Boolean ) attributes . get ( IImportExportConstants . IE_BP_REGISTERED ) ) . booleanValue ( ) ) ; fAdded . add ( breakpoint ) ; if ( fImportBreakpoints & & fCreateWorkingSets & & fCurrentWorkingSetProperty ! = null ) { String [ ] names = fCurrentWorkingSetProperty . split ( <str> + IImportExportConstants . DELIMITER ) ; updateWorkingSets ( names , breakpoint ) ; } if ( participants ! = null ) { for ( int i = <int> ; i < participants . length ; i + + ) { participants [ i ] . verify ( breakpoint ) ; } } } catch ( CoreException ce ) { if ( breakpoint ! = null ) { try { fAdded . remove ( breakpoint ) ; marker . delete ( ) ; } catch ( CoreException e ) { } } } } private void updateWorkingSets ( String [ ] wsnames , IBreakpoint breakpoint ) { IWorkingSetManager mgr = PlatformUI . getWorkbench ( ) . getWorkingSetManager ( ) ; ArrayList < IWorkingSet > sets = new ArrayList < IWorkingSet > ( ) ; collectContainingWorkingsets ( breakpoint , sets ) ; for ( int i = <int> ; i < wsnames . length ; i + + ) { if ( <str> . equals ( wsnames [ i ] ) ) { continue ; } IWorkingSet set = mgr . getWorkingSet ( wsnames [ i ] ) ; if ( set = = null ) { set = mgr . createWorkingSet ( wsnames [ i ] , new IAdaptable [ ] { } ) ; set . setId ( IDebugUIConstants . BREAKPOINT_WORKINGSET_ID ) ; mgr . addWorkingSet ( set ) ; } if ( ! sets . contains ( set ) ) { IAdaptable [ ] elements = set . getElements ( ) ; IAdaptable [ ] newElements = new IAdaptable [ elements . length + <int> ] ; newElements [ newElements . length - <int> ] = breakpoint ; System . arraycopy ( elements , <int> , newElements , <int> , elements . length ) ; set . setElements ( newElements ) ; } sets . remove ( set ) ; } ArrayList < IAdaptable > items = null ; for ( IWorkingSet set : sets ) { items = new ArrayList < IAdaptable > ( Arrays . asList ( set . getElements ( ) ) ) ; if ( items . remove ( breakpoint ) ) { set . setElements ( items . toArray ( new IAdaptable [ items . size ( ) ] ) ) ; } } } private void collectContainingWorkingsets ( IBreakpoint breakpoint , List < IWorkingSet > collector ) { IWorkingSetManager mgr = PlatformUI . getWorkbench ( ) . getWorkingSetManager ( ) ; IWorkingSet [ ] sets = mgr . getWorkingSets ( ) ; for ( int i = <int> ; i < sets . length ; i + + ) { if ( IDebugUIConstants . BREAKPOINT_WORKINGSET_ID . equals ( sets [ i ] . getId ( ) ) & & containsBreakpoint ( sets [ i ] , breakpoint ) ) { collector . add ( sets [ i ] ) ; } } } private boolean containsBreakpoint ( IWorkingSet set , IBreakpoint breakpoint ) { IAdaptable [ ] elements = set . getElements ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { if ( elements [ i ] . equals ( breakpoint ) ) { return true ; } } return false ; } public IBreakpoint [ ] getImportedBreakpoints ( ) { return fAdded . toArray ( new IBreakpoint [ fAdded . size ( ) ] ) ; } } 
