package org . apache . cassandra . repair ; import java . io . IOException ; import java . net . InetAddress ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import com . google . common . collect . Lists ; import com . google . common . util . concurrent . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . DebuggableThreadPoolExecutor ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . gms . * ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . MerkleTrees ; import org . apache . cassandra . utils . Pair ; public class RepairSession extends AbstractFuture < RepairSessionResult > implements IEndpointStateChangeSubscriber , IFailureDetectionEventListener { private static Logger logger = LoggerFactory . getLogger ( RepairSession . class ) ; public final UUID parentRepairSession ; private final UUID id ; public final String keyspace ; private final String [ ] cfnames ; public final RepairParallelism parallelismDegree ; public final Collection < Range < Token > > ranges ; public final Set < InetAddress > endpoints ; public final long repairedAt ; private final AtomicInteger validationRemaining ; private final AtomicBoolean isFailed = new AtomicBoolean ( false ) ; private final ConcurrentMap < Pair < RepairJobDesc , InetAddress > , ValidationTask > validating = new ConcurrentHashMap < > ( ) ; private final ConcurrentMap < Pair < RepairJobDesc , NodePair > , RemoteSyncTask > syncingTasks = new ConcurrentHashMap < > ( ) ; public final ListeningExecutorService taskExecutor = MoreExecutors . listeningDecorator ( DebuggableThreadPoolExecutor . createCachedThreadpoolWithMaxSize ( <str> ) ) ; private volatile boolean terminated = false ; public RepairSession ( UUID parentRepairSession , UUID id , Collection < Range < Token > > ranges , String keyspace , RepairParallelism parallelismDegree , Set < InetAddress > endpoints , long repairedAt , String . . . cfnames ) { assert cfnames . length > <int> : <str> ; this . parentRepairSession = parentRepairSession ; this . id = id ; this . parallelismDegree = parallelismDegree ; this . keyspace = keyspace ; this . cfnames = cfnames ; this . ranges = ranges ; this . endpoints = endpoints ; this . repairedAt = repairedAt ; this . validationRemaining = new AtomicInteger ( cfnames . length ) ; } public UUID getId ( ) { return id ; } public Collection < Range < Token > > getRanges ( ) { return ranges ; } public void waitForValidation ( Pair < RepairJobDesc , InetAddress > key , ValidationTask task ) { validating . put ( key , task ) ; } public void waitForSync ( Pair < RepairJobDesc , NodePair > key , RemoteSyncTask task ) { syncingTasks . put ( key , task ) ; } public void validationComplete ( RepairJobDesc desc , InetAddress endpoint , MerkleTrees trees ) { ValidationTask task = validating . remove ( Pair . create ( desc , endpoint ) ) ; if ( task = = null ) { assert terminated ; return ; } String message = String . format ( <str> , desc . columnFamily , endpoint ) ; logger . info ( <str> , getId ( ) , message ) ; Tracing . traceRepair ( message ) ; task . treesReceived ( trees ) ; if ( validationRemaining . decrementAndGet ( ) = = <int> ) { FailureDetector . instance . unregisterFailureDetectionEventListener ( this ) ; } } public void syncComplete ( RepairJobDesc desc , NodePair nodes , boolean success ) { RemoteSyncTask task = syncingTasks . get ( Pair . create ( desc , nodes ) ) ; if ( task = = null ) { assert terminated ; return ; } logger . debug ( String . format ( <str> , getId ( ) , nodes . endpoint1 , nodes . endpoint2 , desc . columnFamily ) ) ; task . syncComplete ( success ) ; } private String repairedNodes ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( FBUtilities . getBroadcastAddress ( ) ) ; for ( InetAddress ep : endpoints ) sb . append ( <str> ) . append ( ep ) ; return sb . toString ( ) ; } public void start ( ListeningExecutorService executor ) { String message ; if ( terminated ) return ; logger . info ( String . format ( <str> , getId ( ) , repairedNodes ( ) , ranges , keyspace , Arrays . toString ( cfnames ) ) ) ; Tracing . traceRepair ( <str> , ranges ) ; SystemDistributedKeyspace . startRepairs ( getId ( ) , parentRepairSession , keyspace , cfnames , ranges , endpoints ) ; if ( endpoints . isEmpty ( ) ) { logger . info ( <str> , getId ( ) , message = String . format ( <str> , ranges ) ) ; Tracing . traceRepair ( message ) ; set ( new RepairSessionResult ( id , keyspace , ranges , Lists . < RepairResult > newArrayList ( ) ) ) ; SystemDistributedKeyspace . failRepairs ( getId ( ) , keyspace , cfnames , new RuntimeException ( message ) ) ; return ; } for ( InetAddress endpoint : endpoints ) { if ( ! FailureDetector . instance . isAlive ( endpoint ) ) { message = String . format ( <str> , endpoint ) ; logger . error ( <str> , getId ( ) , message ) ; Exception e = new IOException ( message ) ; setException ( e ) ; SystemDistributedKeyspace . failRepairs ( getId ( ) , keyspace , cfnames , e ) ; return ; } } List < ListenableFuture < RepairResult > > jobs = new ArrayList < > ( cfnames . length ) ; for ( String cfname : cfnames ) { RepairJob job = new RepairJob ( this , cfname ) ; executor . execute ( job ) ; jobs . add ( job ) ; } Futures . addCallback ( Futures . allAsList ( jobs ) , new FutureCallback < List < RepairResult > > ( ) { public void onSuccess ( List < RepairResult > results ) { logger . info ( <str> , getId ( ) , <str> ) ; Tracing . traceRepair ( <str> , ranges ) ; set ( new RepairSessionResult ( id , keyspace , ranges , results ) ) ; taskExecutor . shutdown ( ) ; terminate ( ) ; } public void onFailure ( Throwable t ) { logger . error ( String . format ( <str> , getId ( ) ) , t ) ; Tracing . traceRepair ( <str> , t ) ; forceShutdown ( t ) ; } } ) ; } public void terminate ( ) { terminated = true ; validating . clear ( ) ; syncingTasks . clear ( ) ; } public void forceShutdown ( Throwable reason ) { setException ( reason ) ; taskExecutor . shutdownNow ( ) ; terminate ( ) ; } public void onJoin ( InetAddress endpoint , EndpointState epState ) { } public void beforeChange ( InetAddress endpoint , EndpointState currentState , ApplicationState newStateKey , VersionedValue newValue ) { } public void onChange ( InetAddress endpoint , ApplicationState state , VersionedValue value ) { } public void onAlive ( InetAddress endpoint , EndpointState state ) { } public void onDead ( InetAddress endpoint , EndpointState state ) { } public void onRemove ( InetAddress endpoint ) { convict ( endpoint , Double . MAX_VALUE ) ; } public void onRestart ( InetAddress endpoint , EndpointState epState ) { convict ( endpoint , Double . MAX_VALUE ) ; } public void convict ( InetAddress endpoint , double phi ) { if ( ! endpoints . contains ( endpoint ) ) return ; if ( phi < <int> * DatabaseDescriptor . getPhiConvictThreshold ( ) ) return ; if ( ! isFailed . compareAndSet ( false , true ) ) return ; Exception exception = new IOException ( String . format ( <str> , endpoint ) ) ; logger . error ( String . format ( <str> , getId ( ) ) , exception ) ; forceShutdown ( exception ) ; } } 
