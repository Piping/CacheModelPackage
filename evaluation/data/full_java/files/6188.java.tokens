package org . elasticsearch . discovery . zen . publish ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . logging . ESLogger ; import java . util . ArrayList ; import java . util . Locale ; import java . util . Objects ; public class PendingClusterStatesQueue { interface StateProcessedListener { void onNewClusterStateProcessed ( ) ; void onNewClusterStateFailed ( Throwable t ) ; } final ArrayList < ClusterStateContext > pendingStates = new ArrayList < > ( ) ; final ESLogger logger ; final int maxQueueSize ; public PendingClusterStatesQueue ( ESLogger logger , int maxQueueSize ) { this . logger = logger ; this . maxQueueSize = maxQueueSize ; } public synchronized void addPending ( ClusterState state ) { pendingStates . add ( new ClusterStateContext ( state ) ) ; if ( pendingStates . size ( ) > maxQueueSize ) { ClusterStateContext context = pendingStates . remove ( <int> ) ; logger . warn ( <str> , context , maxQueueSize ) ; if ( context . committed ( ) ) { context . listener . onNewClusterStateFailed ( new ElasticsearchException ( <str> , maxQueueSize ) ) ; } } } public synchronized ClusterState markAsCommitted ( String stateUUID , StateProcessedListener listener ) { final ClusterStateContext context = findState ( stateUUID ) ; if ( context = = null ) { listener . onNewClusterStateFailed ( new IllegalStateException ( <str> + stateUUID + <str> ) ) ; return null ; } if ( context . committed ( ) ) { listener . onNewClusterStateFailed ( new IllegalStateException ( <str> + stateUUID + <str> ) ) ; return null ; } context . markAsCommitted ( listener ) ; return context . state ; } public synchronized void markAsFailed ( ClusterState state , Throwable reason ) { final ClusterStateContext failedContext = findState ( state . stateUUID ( ) ) ; if ( failedContext = = null ) { throw new IllegalArgumentException ( <str> + state . stateUUID ( ) + <str> + state . version ( ) + <str> ) ; } if ( failedContext . committed ( ) = = false ) { throw new IllegalArgumentException ( <str> + state ) ; } ArrayList < ClusterStateContext > statesToRemove = new ArrayList < > ( ) ; for ( int index = <int> ; index < pendingStates . size ( ) ; index + + ) { final ClusterStateContext pendingContext = pendingStates . get ( index ) ; if ( pendingContext . committed ( ) = = false ) { continue ; } final ClusterState pendingState = pendingContext . state ; if ( pendingContext . equals ( failedContext ) ) { statesToRemove . add ( pendingContext ) ; pendingContext . listener . onNewClusterStateFailed ( reason ) ; } else if ( state . supersedes ( pendingState ) ) { statesToRemove . add ( pendingContext ) ; logger . debug ( <str> , pendingContext , failedContext ) ; pendingContext . listener . onNewClusterStateFailed ( reason ) ; } } pendingStates . removeAll ( statesToRemove ) ; assert findState ( state . stateUUID ( ) ) = = null : <str> + state ; } public synchronized void markAsProcessed ( ClusterState state ) { if ( findState ( state . stateUUID ( ) ) = = null ) { throw new IllegalStateException ( <str> + state . stateUUID ( ) + <str> + state . version ( ) + <str> ) ; } final DiscoveryNode currentMaster = state . nodes ( ) . masterNode ( ) ; assert currentMaster ! = null : <str> + state ; ArrayList < ClusterStateContext > contextsToRemove = new ArrayList < > ( ) ; for ( int index = <int> ; index < pendingStates . size ( ) ; index + + ) { final ClusterStateContext pendingContext = pendingStates . get ( index ) ; final ClusterState pendingState = pendingContext . state ; final DiscoveryNode pendingMasterNode = pendingState . nodes ( ) . masterNode ( ) ; if ( Objects . equals ( currentMaster , pendingMasterNode ) = = false ) { contextsToRemove . add ( pendingContext ) ; if ( pendingContext . committed ( ) ) { logger . warn ( <str> , pendingState . stateUUID ( ) , pendingState . version ( ) , pendingMasterNode , currentMaster ) ; pendingContext . listener . onNewClusterStateFailed ( new IllegalStateException ( <str> + pendingMasterNode + <str> + currentMaster + <str> ) ) ; } else { logger . trace ( <str> , pendingState . stateUUID ( ) , pendingState . version ( ) , pendingMasterNode , currentMaster ) ; } } else if ( state . supersedes ( pendingState ) & & pendingContext . committed ( ) ) { logger . trace ( <str> , pendingState . stateUUID ( ) , pendingState . version ( ) , state . stateUUID ( ) , state . version ( ) ) ; contextsToRemove . add ( pendingContext ) ; pendingContext . listener . onNewClusterStateProcessed ( ) ; } else if ( pendingState . stateUUID ( ) . equals ( state . stateUUID ( ) ) ) { assert pendingContext . committed ( ) : <str> + state ; contextsToRemove . add ( pendingContext ) ; pendingContext . listener . onNewClusterStateProcessed ( ) ; } } pendingStates . removeAll ( contextsToRemove ) ; assert findState ( state . stateUUID ( ) ) = = null : <str> + state ; } ClusterStateContext findState ( String stateUUID ) { for ( int i = <int> ; i < pendingStates . size ( ) ; i + + ) { final ClusterStateContext context = pendingStates . get ( i ) ; if ( context . stateUUID ( ) . equals ( stateUUID ) ) { return context ; } } return null ; } public synchronized void failAllStatesAndClear ( Throwable reason ) { for ( ClusterStateContext pendingState : pendingStates ) { if ( pendingState . committed ( ) ) { pendingState . listener . onNewClusterStateFailed ( reason ) ; } } pendingStates . clear ( ) ; } public synchronized ClusterState getNextClusterStateToProcess ( ) { if ( pendingStates . isEmpty ( ) ) { return null ; } ClusterStateContext stateToProcess = null ; int index = <int> ; for ( ; index < pendingStates . size ( ) ; index + + ) { ClusterStateContext potentialState = pendingStates . get ( index ) ; if ( potentialState . committed ( ) ) { stateToProcess = potentialState ; break ; } } if ( stateToProcess = = null ) { return null ; } for ( ; index < pendingStates . size ( ) ; index + + ) { ClusterStateContext potentialState = pendingStates . get ( index ) ; if ( potentialState . state . supersedes ( stateToProcess . state ) & & potentialState . committed ( ) ) { stateToProcess = potentialState ; } } assert stateToProcess . committed ( ) : <str> + stateToProcess . state ; return stateToProcess . state ; } public synchronized ClusterState [ ] pendingClusterStates ( ) { ArrayList < ClusterState > states = new ArrayList < > ( ) ; for ( ClusterStateContext context : pendingStates ) { states . add ( context . state ) ; } return states . toArray ( new ClusterState [ states . size ( ) ] ) ; } static class ClusterStateContext { final ClusterState state ; StateProcessedListener listener ; ClusterStateContext ( ClusterState clusterState ) { this . state = clusterState ; } void markAsCommitted ( StateProcessedListener listener ) { if ( this . listener ! = null ) { throw new IllegalStateException ( toString ( ) + <str> ) ; } this . listener = listener ; } boolean committed ( ) { return listener ! = null ; } public String stateUUID ( ) { return state . stateUUID ( ) ; } @Override public String toString ( ) { return String . format ( Locale . ROOT , <str> , stateUUID ( ) , state . version ( ) , state . nodes ( ) . masterNodeId ( ) ) ; } } public synchronized PendingClusterStateStats stats ( ) { int committed = <int> ; for ( ClusterStateContext clusterStatsContext : pendingStates ) { if ( clusterStatsContext . committed ( ) ) { committed + = <int> ; } } return new PendingClusterStateStats ( pendingStates . size ( ) , pendingStates . size ( ) - committed , committed ) ; } } 
