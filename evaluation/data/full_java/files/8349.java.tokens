package org . elasticsearch . indices . recovery ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . StringField ; import org . apache . lucene . document . TextField ; import org . apache . lucene . index . CorruptIndexException ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . RandomIndexWriter ; import org . apache . lucene . store . BaseDirectoryWrapper ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . IOContext ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . lucene . store . IndexOutputOutputStream ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . store . DirectoryService ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . index . store . StoreFileMetaData ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . test . CorruptionUtils ; import org . elasticsearch . test . DummyShardLock ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; public class RecoverySourceHandlerTests extends ESTestCase { private static final IndexSettings INDEX_SETTINGS = IndexSettingsModule . newIndexSettings ( new Index ( <str> ) , Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , org . elasticsearch . Version . CURRENT ) . build ( ) ) ; private final ShardId shardId = new ShardId ( INDEX_SETTINGS . getIndex ( ) , <int> ) ; private final NodeSettingsService service = new NodeSettingsService ( Settings . EMPTY ) ; public void testSendFiles ( ) throws Throwable { Settings settings = Settings . builder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; final RecoverySettings recoverySettings = new RecoverySettings ( settings , service ) ; StartRecoveryRequest request = new StartRecoveryRequest ( shardId , new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) , new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) , randomBoolean ( ) , null , RecoveryState . Type . STORE , randomLong ( ) ) ; Store store = newStore ( createTempDir ( ) ) ; RecoverySourceHandler handler = new RecoverySourceHandler ( null , request , recoverySettings , null , logger ) ; Directory dir = store . directory ( ) ; RandomIndexWriter writer = new RandomIndexWriter ( random ( ) , dir , newIndexWriterConfig ( ) ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { Document document = new Document ( ) ; document . add ( new StringField ( <str> , Integer . toString ( i ) , Field . Store . YES ) ) ; document . add ( newField ( <str> , randomUnicodeOfCodepointLengthBetween ( <int> , <int> ) , TextField . TYPE_STORED ) ) ; writer . addDocument ( document ) ; } writer . commit ( ) ; Store . MetadataSnapshot metadata = store . getMetadata ( ) ; List < StoreFileMetaData > metas = new ArrayList < > ( ) ; for ( StoreFileMetaData md : metadata ) { metas . add ( md ) ; } Store targetStore = newStore ( createTempDir ( ) ) ; handler . sendFiles ( store , metas . toArray ( new StoreFileMetaData [ <int> ] ) , ( md ) - > { try { return new IndexOutputOutputStream ( targetStore . createVerifyingOutput ( md . name ( ) , md , IOContext . DEFAULT ) ) { @Override public void close ( ) throws IOException { super . close ( ) ; store . directory ( ) . sync ( Collections . singleton ( md . name ( ) ) ) ; } } ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } ) ; Store . MetadataSnapshot targetStoreMetadata = targetStore . getMetadata ( ) ; Store . RecoveryDiff recoveryDiff = targetStoreMetadata . recoveryDiff ( metadata ) ; assertEquals ( metas . size ( ) , recoveryDiff . identical . size ( ) ) ; assertEquals ( <int> , recoveryDiff . different . size ( ) ) ; assertEquals ( <int> , recoveryDiff . missing . size ( ) ) ; IndexReader reader = DirectoryReader . open ( targetStore . directory ( ) ) ; assertEquals ( numDocs , reader . maxDoc ( ) ) ; IOUtils . close ( reader , writer , store , targetStore , recoverySettings ) ; } public void testHandleCorruptedIndexOnSendSendFiles ( ) throws Throwable { Settings settings = Settings . builder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; final RecoverySettings recoverySettings = new RecoverySettings ( settings , service ) ; StartRecoveryRequest request = new StartRecoveryRequest ( shardId , new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) , new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) , randomBoolean ( ) , null , RecoveryState . Type . STORE , randomLong ( ) ) ; Path tempDir = createTempDir ( ) ; Store store = newStore ( tempDir , false ) ; AtomicBoolean failedEngine = new AtomicBoolean ( false ) ; RecoverySourceHandler handler = new RecoverySourceHandler ( null , request , recoverySettings , null , logger ) { @Override protected void failEngine ( IOException cause ) { assertFalse ( failedEngine . get ( ) ) ; failedEngine . set ( true ) ; } } ; Directory dir = store . directory ( ) ; RandomIndexWriter writer = new RandomIndexWriter ( random ( ) , dir , newIndexWriterConfig ( ) ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { Document document = new Document ( ) ; document . add ( new StringField ( <str> , Integer . toString ( i ) , Field . Store . YES ) ) ; document . add ( newField ( <str> , randomUnicodeOfCodepointLengthBetween ( <int> , <int> ) , TextField . TYPE_STORED ) ) ; writer . addDocument ( document ) ; } writer . commit ( ) ; writer . close ( ) ; Store . MetadataSnapshot metadata = store . getMetadata ( ) ; List < StoreFileMetaData > metas = new ArrayList < > ( ) ; for ( StoreFileMetaData md : metadata ) { metas . add ( md ) ; } CorruptionUtils . corruptFile ( getRandom ( ) , FileSystemUtils . files ( tempDir , ( p ) - > ( p . getFileName ( ) . toString ( ) . equals ( <str> ) | | p . getFileName ( ) . toString ( ) . startsWith ( <str> ) ) = = false ) ) ; Store targetStore = newStore ( createTempDir ( ) , false ) ; try { handler . sendFiles ( store , metas . toArray ( new StoreFileMetaData [ <int> ] ) , ( md ) - > { try { return new IndexOutputOutputStream ( targetStore . createVerifyingOutput ( md . name ( ) , md , IOContext . DEFAULT ) ) { @Override public void close ( ) throws IOException { super . close ( ) ; store . directory ( ) . sync ( Collections . singleton ( md . name ( ) ) ) ; } } ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } ) ; fail ( <str> ) ; } catch ( IOException ex ) { assertNotNull ( ExceptionsHelper . unwrapCorruption ( ex ) ) ; } assertTrue ( failedEngine . get ( ) ) ; IOUtils . close ( store , targetStore , recoverySettings ) ; } public void testHandleExceptinoOnSendSendFiles ( ) throws Throwable { Settings settings = Settings . builder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; final RecoverySettings recoverySettings = new RecoverySettings ( settings , service ) ; StartRecoveryRequest request = new StartRecoveryRequest ( shardId , new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) , new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) , randomBoolean ( ) , null , RecoveryState . Type . STORE , randomLong ( ) ) ; Path tempDir = createTempDir ( ) ; Store store = newStore ( tempDir , false ) ; AtomicBoolean failedEngine = new AtomicBoolean ( false ) ; RecoverySourceHandler handler = new RecoverySourceHandler ( null , request , recoverySettings , null , logger ) { @Override protected void failEngine ( IOException cause ) { assertFalse ( failedEngine . get ( ) ) ; failedEngine . set ( true ) ; } } ; Directory dir = store . directory ( ) ; RandomIndexWriter writer = new RandomIndexWriter ( random ( ) , dir , newIndexWriterConfig ( ) ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { Document document = new Document ( ) ; document . add ( new StringField ( <str> , Integer . toString ( i ) , Field . Store . YES ) ) ; document . add ( newField ( <str> , randomUnicodeOfCodepointLengthBetween ( <int> , <int> ) , TextField . TYPE_STORED ) ) ; writer . addDocument ( document ) ; } writer . commit ( ) ; writer . close ( ) ; Store . MetadataSnapshot metadata = store . getMetadata ( ) ; List < StoreFileMetaData > metas = new ArrayList < > ( ) ; for ( StoreFileMetaData md : metadata ) { metas . add ( md ) ; } final boolean throwCorruptedIndexException = randomBoolean ( ) ; Store targetStore = newStore ( createTempDir ( ) , false ) ; try { handler . sendFiles ( store , metas . toArray ( new StoreFileMetaData [ <int> ] ) , ( md ) - > { if ( throwCorruptedIndexException ) { throw new RuntimeException ( new CorruptIndexException ( <str> , <str> ) ) ; } else { throw new RuntimeException ( <str> ) ; } } ) ; fail ( <str> ) ; } catch ( RuntimeException ex ) { assertNull ( ExceptionsHelper . unwrapCorruption ( ex ) ) ; if ( throwCorruptedIndexException ) { assertEquals ( ex . getMessage ( ) , <str> ) ; } else { assertEquals ( ex . getMessage ( ) , <str> ) ; } } catch ( CorruptIndexException ex ) { fail ( <str> ) ; } assertFalse ( failedEngine . get ( ) ) ; IOUtils . close ( store , targetStore , recoverySettings ) ; } private Store newStore ( Path path ) throws IOException { return newStore ( path , true ) ; } private Store newStore ( Path path , boolean checkIndex ) throws IOException { DirectoryService directoryService = new DirectoryService ( shardId , INDEX_SETTINGS ) { @Override public long throttleTimeInNanos ( ) { return <int> ; } @Override public Directory newDirectory ( ) throws IOException { BaseDirectoryWrapper baseDirectoryWrapper = RecoverySourceHandlerTests . newFSDirectory ( path ) ; if ( checkIndex = = false ) { baseDirectoryWrapper . setCheckIndexOnClose ( false ) ; } return baseDirectoryWrapper ; } } ; return new Store ( shardId , INDEX_SETTINGS , directoryService , new DummyShardLock ( shardId ) ) ; } } 
