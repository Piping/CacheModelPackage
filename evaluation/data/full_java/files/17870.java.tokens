package com . badlogic . gdx . tools . particleeditor ; import java . awt . * ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import java . io . File ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URL ; import java . util . HashMap ; import javax . swing . * ; import javax . swing . UIManager . LookAndFeelInfo ; import javax . swing . border . CompoundBorder ; import javax . swing . plaf . basic . BasicSplitPaneUI ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Files . FileType ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . backends . lwjgl . LwjglCanvas ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . ParticleEffect ; import com . badlogic . gdx . graphics . g2d . ParticleEmitter ; import com . badlogic . gdx . graphics . g2d . ParticleEmitter . GradientColorValue ; import com . badlogic . gdx . graphics . g2d . ParticleEmitter . NumericValue ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class ParticleEditor extends JFrame { public static final String DEFAULT_PARTICLE = <str> ; public static final String DEFAULT_PREMULT_PARTICLE = <str> ; LwjglCanvas lwjglCanvas ; JPanel rowsPanel ; JPanel editRowsPanel ; EffectPanel effectPanel ; private JSplitPane splitPane ; OrthographicCamera worldCamera ; OrthographicCamera textCamera ; NumericValue pixelsPerMeter ; NumericValue zoomLevel ; NumericValue deltaMultiplier ; GradientColorValue backgroundColor ; float pixelsPerMeterPrev ; float zoomLevelPrev ; ParticleEffect effect = new ParticleEffect ( ) ; File effectFile ; final HashMap < ParticleEmitter , ParticleData > particleData = new HashMap ( ) ; public ParticleEditor ( ) { super ( <str> ) ; lwjglCanvas = new LwjglCanvas ( new Renderer ( ) ) ; addWindowListener ( new WindowAdapter ( ) { public void windowClosed ( WindowEvent event ) { System . exit ( <int> ) ; } } ) ; initializeComponents ( ) ; setSize ( <int> , <int> ) ; setLocationRelativeTo ( null ) ; setDefaultCloseOperation ( DISPOSE_ON_CLOSE ) ; setVisible ( true ) ; } void reloadRows ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { editRowsPanel . removeAll ( ) ; addEditorRow ( new NumericPanel ( pixelsPerMeter , <str> , <str> ) ) ; addEditorRow ( new NumericPanel ( zoomLevel , <str> , <str> ) ) ; addEditorRow ( new NumericPanel ( deltaMultiplier , <str> , <str> ) ) ; addEditorRow ( new GradientPanel ( backgroundColor , <str> , <str> , true ) ) ; rowsPanel . removeAll ( ) ; ParticleEmitter emitter = getEmitter ( ) ; addRow ( new ImagePanel ( ParticleEditor . this , <str> , <str> ) ) ; addRow ( new CountPanel ( ParticleEditor . this , <str> , <str> ) ) ; addRow ( new RangedNumericPanel ( emitter . getDelay ( ) , <str> , <str> ) ) ; addRow ( new RangedNumericPanel ( emitter . getDuration ( ) , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getEmission ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getLife ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getLifeOffset ( ) , <str> , <str> , <str> ) ) ; addRow ( new RangedNumericPanel ( emitter . getXOffsetValue ( ) , <str> , <str> ) ) ; addRow ( new RangedNumericPanel ( emitter . getYOffsetValue ( ) , <str> , <str> ) ) ; addRow ( new SpawnPanel ( ParticleEditor . this , emitter . getSpawnShape ( ) , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getSpawnWidth ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getSpawnHeight ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getScale ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getVelocity ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getAngle ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getRotation ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getWind ( ) , <str> , <str> , <str> ) ) ; addRow ( new ScaledNumericPanel ( emitter . getGravity ( ) , <str> , <str> , <str> ) ) ; addRow ( new GradientPanel ( emitter . getTint ( ) , <str> , <str> , false ) ) ; addRow ( new PercentagePanel ( emitter . getTransparency ( ) , <str> , <str> , <str> ) ) ; addRow ( new OptionsPanel ( ParticleEditor . this , <str> , <str> ) ) ; for ( Component component : rowsPanel . getComponents ( ) ) if ( component instanceof EditorPanel ) ( ( EditorPanel ) component ) . update ( ParticleEditor . this ) ; rowsPanel . repaint ( ) ; } } ) ; } void addEditorRow ( JPanel row ) { row . setBorder ( BorderFactory . createMatteBorder ( <int> , <int> , <int> , <int> , java . awt . Color . black ) ) ; editRowsPanel . add ( row , new GridBagConstraints ( <int> , - <int> , <int> , <int> , <int> , <int> , GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; } void addRow ( JPanel row ) { row . setBorder ( BorderFactory . createMatteBorder ( <int> , <int> , <int> , <int> , java . awt . Color . black ) ) ; rowsPanel . add ( row , new GridBagConstraints ( <int> , - <int> , <int> , <int> , <int> , <int> , GridBagConstraints . CENTER , GridBagConstraints . HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; } public void setVisible ( String name , boolean visible ) { for ( Component component : rowsPanel . getComponents ( ) ) if ( component instanceof EditorPanel & & ( ( EditorPanel ) component ) . getName ( ) . equals ( name ) ) component . setVisible ( visible ) ; } public ParticleEmitter getEmitter ( ) { return effect . getEmitters ( ) . get ( effectPanel . editIndex ) ; } public ImageIcon getIcon ( ParticleEmitter emitter ) { ParticleData data = particleData . get ( emitter ) ; if ( data = = null ) particleData . put ( emitter , data = new ParticleData ( ) ) ; String imagePath = emitter . getImagePath ( ) ; if ( data . icon = = null & & imagePath ! = null ) { try { URL url ; File file = new File ( imagePath ) ; if ( file . exists ( ) ) url = file . toURI ( ) . toURL ( ) ; else { url = ParticleEditor . class . getResource ( imagePath ) ; if ( url = = null ) return null ; } data . icon = new ImageIcon ( url ) ; } catch ( MalformedURLException ex ) { ex . printStackTrace ( ) ; } } return data . icon ; } public void setIcon ( ParticleEmitter emitters , ImageIcon icon ) { ParticleData data = particleData . get ( emitters ) ; if ( data = = null ) particleData . put ( emitters , data = new ParticleData ( ) ) ; data . icon = icon ; } public void setEnabled ( ParticleEmitter emitter , boolean enabled ) { ParticleData data = particleData . get ( emitter ) ; if ( data = = null ) particleData . put ( emitter , data = new ParticleData ( ) ) ; data . enabled = enabled ; emitter . reset ( ) ; } public boolean isEnabled ( ParticleEmitter emitter ) { ParticleData data = particleData . get ( emitter ) ; if ( data = = null ) return true ; return data . enabled ; } private void initializeComponents ( ) { splitPane = new JSplitPane ( ) ; splitPane . setUI ( new BasicSplitPaneUI ( ) { public void paint ( Graphics g , JComponent jc ) { } } ) ; splitPane . setDividerSize ( <int> ) ; getContentPane ( ) . add ( splitPane , BorderLayout . CENTER ) ; { JSplitPane rightSplit = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; rightSplit . setUI ( new BasicSplitPaneUI ( ) { public void paint ( Graphics g , JComponent jc ) { } } ) ; rightSplit . setDividerSize ( <int> ) ; splitPane . add ( rightSplit , JSplitPane . RIGHT ) ; { JPanel propertiesPanel = new JPanel ( new GridBagLayout ( ) ) ; rightSplit . add ( propertiesPanel , JSplitPane . TOP ) ; propertiesPanel . setBorder ( new CompoundBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) , BorderFactory . createTitledBorder ( <str> ) ) ) ; { JScrollPane scroll = new JScrollPane ( ) ; propertiesPanel . add ( scroll , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , GridBagConstraints . NORTH , GridBagConstraints . BOTH , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; scroll . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; { editRowsPanel = new JPanel ( new GridBagLayout ( ) ) ; scroll . setViewportView ( editRowsPanel ) ; scroll . getVerticalScrollBar ( ) . setUnitIncrement ( <int> ) ; } } } { JPanel propertiesPanel = new JPanel ( new GridBagLayout ( ) ) ; rightSplit . add ( propertiesPanel , JSplitPane . BOTTOM ) ; propertiesPanel . setBorder ( new CompoundBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) , BorderFactory . createTitledBorder ( <str> ) ) ) ; { JScrollPane scroll = new JScrollPane ( ) ; propertiesPanel . add ( scroll , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , GridBagConstraints . NORTH , GridBagConstraints . BOTH , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; scroll . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; { rowsPanel = new JPanel ( new GridBagLayout ( ) ) ; scroll . setViewportView ( rowsPanel ) ; scroll . getVerticalScrollBar ( ) . setUnitIncrement ( <int> ) ; } } } rightSplit . setDividerLocation ( <int> ) ; } { JSplitPane leftSplit = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; leftSplit . setUI ( new BasicSplitPaneUI ( ) { public void paint ( Graphics g , JComponent jc ) { } } ) ; leftSplit . setDividerSize ( <int> ) ; splitPane . add ( leftSplit , JSplitPane . LEFT ) ; { JPanel spacer = new JPanel ( new BorderLayout ( ) ) ; leftSplit . add ( spacer , JSplitPane . TOP ) ; spacer . add ( lwjglCanvas . getCanvas ( ) ) ; spacer . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; } { JPanel emittersPanel = new JPanel ( new BorderLayout ( ) ) ; leftSplit . add ( emittersPanel , JSplitPane . BOTTOM ) ; emittersPanel . setBorder ( new CompoundBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) , BorderFactory . createTitledBorder ( <str> ) ) ) ; { effectPanel = new EffectPanel ( this ) ; emittersPanel . add ( effectPanel ) ; } } leftSplit . setDividerLocation ( <int> ) ; } splitPane . setDividerLocation ( <int> ) ; } class Renderer implements ApplicationListener , InputProcessor { private float maxActiveTimer ; private int maxActive , lastMaxActive ; private boolean mouseDown ; private int activeCount ; private int mouseX , mouseY ; private BitmapFont font ; private SpriteBatch spriteBatch ; private Sprite bgImage ; public void create ( ) { if ( spriteBatch ! = null ) return ; spriteBatch = new SpriteBatch ( ) ; worldCamera = new OrthographicCamera ( ) ; textCamera = new OrthographicCamera ( ) ; pixelsPerMeter = new NumericValue ( ) ; pixelsPerMeter . setValue ( <float> ) ; pixelsPerMeter . setAlwaysActive ( true ) ; zoomLevel = new NumericValue ( ) ; zoomLevel . setValue ( <float> ) ; zoomLevel . setAlwaysActive ( true ) ; deltaMultiplier = new NumericValue ( ) ; deltaMultiplier . setValue ( <float> ) ; deltaMultiplier . setAlwaysActive ( true ) ; backgroundColor = new GradientColorValue ( ) ; backgroundColor . setColors ( new float [ ] { <float> , <float> , <float> } ) ; font = new BitmapFont ( Gdx . files . getFileHandle ( <str> , FileType . Internal ) , Gdx . files . getFileHandle ( <str> , FileType . Internal ) , true ) ; effectPanel . newExampleEmitter ( <str> , true ) ; Gdx . input . setInputProcessor ( this ) ; } @Override public void resize ( int width , int height ) { Gdx . gl . glViewport ( <int> , <int> , width , height ) ; if ( pixelsPerMeter . getValue ( ) < = <int> ) { pixelsPerMeter . setValue ( <int> ) ; } worldCamera . setToOrtho ( false , width / pixelsPerMeter . getValue ( ) , height / pixelsPerMeter . getValue ( ) ) ; worldCamera . update ( ) ; textCamera . setToOrtho ( true , width , height ) ; textCamera . update ( ) ; effect . setPosition ( worldCamera . viewportWidth / <int> , worldCamera . viewportHeight / <int> ) ; } public void render ( ) { int viewWidth = Gdx . graphics . getWidth ( ) ; int viewHeight = Gdx . graphics . getHeight ( ) ; float delta = Math . max ( <int> , Gdx . graphics . getDeltaTime ( ) * deltaMultiplier . getValue ( ) ) ; float [ ] colors = backgroundColor . getColors ( ) ; Gdx . gl . glClearColor ( colors [ <int> ] , colors [ <int> ] , colors [ <int> ] , <float> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; if ( ( pixelsPerMeter . getValue ( ) ! = pixelsPerMeterPrev ) | | ( zoomLevel . getValue ( ) ! = zoomLevelPrev ) ) { if ( pixelsPerMeter . getValue ( ) < = <int> ) { pixelsPerMeter . setValue ( <int> ) ; } worldCamera . setToOrtho ( false , viewWidth / pixelsPerMeter . getValue ( ) , viewHeight / pixelsPerMeter . getValue ( ) ) ; worldCamera . zoom = zoomLevel . getValue ( ) ; worldCamera . update ( ) ; effect . setPosition ( worldCamera . viewportWidth / <int> , worldCamera . viewportHeight / <int> ) ; zoomLevelPrev = zoomLevel . getValue ( ) ; pixelsPerMeterPrev = pixelsPerMeter . getValue ( ) ; } spriteBatch . setProjectionMatrix ( worldCamera . combined ) ; spriteBatch . begin ( ) ; spriteBatch . enableBlending ( ) ; spriteBatch . setBlendFunction ( GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; if ( bgImage ! = null ) { bgImage . setPosition ( viewWidth / <int> - bgImage . getWidth ( ) / <int> , viewHeight / <int> - bgImage . getHeight ( ) / <int> ) ; bgImage . draw ( spriteBatch ) ; } activeCount = <int> ; boolean complete = true ; for ( ParticleEmitter emitter : effect . getEmitters ( ) ) { if ( emitter . getSprite ( ) = = null & & emitter . getImagePath ( ) ! = null ) loadImage ( emitter ) ; boolean enabled = isEnabled ( emitter ) ; if ( enabled ) { if ( emitter . getSprite ( ) ! = null ) emitter . draw ( spriteBatch , delta ) ; activeCount + = emitter . getActiveCount ( ) ; if ( ! emitter . isComplete ( ) ) complete = false ; } } if ( complete ) effect . start ( ) ; maxActive = Math . max ( maxActive , activeCount ) ; maxActiveTimer + = delta ; if ( maxActiveTimer > <int> ) { maxActiveTimer = <int> ; lastMaxActive = maxActive ; maxActive = <int> ; } if ( mouseDown ) { } spriteBatch . setProjectionMatrix ( textCamera . combined ) ; font . draw ( spriteBatch , <str> + Gdx . graphics . getFramesPerSecond ( ) , <int> , <int> ) ; font . draw ( spriteBatch , <str> + activeCount , <int> , <int> ) ; font . draw ( spriteBatch , <str> + lastMaxActive , <int> , <int> ) ; font . draw ( spriteBatch , ( int ) ( getEmitter ( ) . getPercentComplete ( ) * <int> ) + <str> , <int> , <int> ) ; spriteBatch . end ( ) ; } private void loadImage ( ParticleEmitter emitter ) { final String imagePath = emitter . getImagePath ( ) ; String imageName = new File ( imagePath . replace ( <str> , <str> ) ) . getName ( ) ; try { FileHandle file ; if ( imagePath . equals ( ParticleEditor . DEFAULT_PARTICLE ) | | imagePath . equals ( ParticleEditor . DEFAULT_PREMULT_PARTICLE ) ) { file = Gdx . files . classpath ( imagePath ) ; } else { if ( ( imagePath . contains ( <str> ) | | imagePath . contains ( <str> ) ) & & ! imageName . contains ( <str> ) ) { file = Gdx . files . absolute ( imagePath ) ; if ( ! file . exists ( ) ) { file = Gdx . files . absolute ( new File ( effectFile . getParentFile ( ) , imageName ) . getAbsolutePath ( ) ) ; } } else { file = Gdx . files . absolute ( new File ( effectFile . getParentFile ( ) , imagePath ) . getAbsolutePath ( ) ) ; } } emitter . setSprite ( new Sprite ( new Texture ( file ) ) ) ; if ( effectFile ! = null ) { URI relativeUri = effectFile . getParentFile ( ) . toURI ( ) . relativize ( file . file ( ) . toURI ( ) ) ; emitter . setImagePath ( relativeUri . getPath ( ) ) ; } } catch ( GdxRuntimeException ex ) { ex . printStackTrace ( ) ; EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { JOptionPane . showMessageDialog ( ParticleEditor . this , <str> + imagePath ) ; } } ) ; emitter . setImagePath ( null ) ; } } public boolean keyDown ( int keycode ) { return false ; } public boolean keyUp ( int keycode ) { return false ; } public boolean keyTyped ( char character ) { return false ; } public boolean touchDown ( int x , int y , int pointer , int newParam ) { Vector3 touchPoint = new Vector3 ( x , y , <int> ) ; worldCamera . unproject ( touchPoint ) ; effect . setPosition ( touchPoint . x , touchPoint . y ) ; return false ; } public boolean touchUp ( int x , int y , int pointer , int button ) { ParticleEditor . this . dispatchEvent ( new WindowEvent ( ParticleEditor . this , WindowEvent . WINDOW_LOST_FOCUS ) ) ; ParticleEditor . this . dispatchEvent ( new WindowEvent ( ParticleEditor . this , WindowEvent . WINDOW_GAINED_FOCUS ) ) ; ParticleEditor . this . requestFocusInWindow ( ) ; return false ; } public boolean touchDragged ( int x , int y , int pointer ) { Vector3 touchPoint = new Vector3 ( x , y , <int> ) ; worldCamera . unproject ( touchPoint ) ; effect . setPosition ( touchPoint . x , touchPoint . y ) ; return false ; } @Override public void dispose ( ) { } @Override public void pause ( ) { } @Override public void resume ( ) { } @Override public boolean mouseMoved ( int x , int y ) { return false ; } @Override public boolean scrolled ( int amount ) { return false ; } } static class ParticleData { public ImageIcon icon ; public String imagePath ; public boolean enabled = true ; } public static void main ( String [ ] args ) { for ( LookAndFeelInfo info : UIManager . getInstalledLookAndFeels ( ) ) { if ( <str> . equals ( info . getName ( ) ) ) { try { UIManager . setLookAndFeel ( info . getClassName ( ) ) ; } catch ( Throwable ignored ) { } break ; } } EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { new ParticleEditor ( ) ; } } ) ; } } 
