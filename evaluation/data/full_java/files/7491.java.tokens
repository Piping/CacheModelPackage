package org . elasticsearch . search . fetch . source ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class FetchSourceParseElement implements SearchParseElement { @Override public void parse ( XContentParser parser , SearchContext context ) throws Exception { context . fetchSourceContext ( parse ( parser ) ) ; } public FetchSourceContext parse ( XContentParser parser ) throws IOException { XContentParser . Token token ; List < String > includes = null , excludes = null ; String currentFieldName = null ; token = parser . currentToken ( ) ; if ( parser . isBooleanValue ( ) ) { return new FetchSourceContext ( parser . booleanValue ( ) ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { return new FetchSourceContext ( new String [ ] { parser . text ( ) } ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { includes = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { includes . add ( parser . text ( ) ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { List < String > currentList = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { currentList = includes ! = null ? includes : ( includes = new ArrayList < > ( <int> ) ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { currentList = excludes ! = null ? excludes : ( excludes = new ArrayList < > ( <int> ) ) ; } else { throw new ElasticsearchParseException ( <str> , parser . text ( ) ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { currentList . add ( parser . text ( ) ) ; } } else if ( token . isValue ( ) ) { currentList . add ( parser . text ( ) ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } } } else { throw new ElasticsearchParseException ( <str> , token . name ( ) ) ; } return new FetchSourceContext ( includes = = null ? Strings . EMPTY_ARRAY : includes . toArray ( new String [ includes . size ( ) ] ) , excludes = = null ? Strings . EMPTY_ARRAY : excludes . toArray ( new String [ excludes . size ( ) ] ) ) ; } } 
