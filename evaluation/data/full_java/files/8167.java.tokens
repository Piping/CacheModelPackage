package org . elasticsearch . index . mapper . date ; import org . apache . lucene . analysis . NumericTokenStream . NumericTermAttribute ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . index . DocValuesType ; import org . apache . lucene . index . IndexableField ; import org . apache . lucene . search . NumericRangeQuery ; import org . apache . lucene . util . Constants ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . mapping . get . GetMappingsResponse ; import org . elasticsearch . action . admin . indices . mapping . put . PutMappingResponse ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . LocaleUtils ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . mapper . * ; import org . elasticsearch . index . mapper . ParseContext . Document ; import org . elasticsearch . index . mapper . core . DateFieldMapper ; import org . elasticsearch . index . mapper . core . LongFieldMapper ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . elasticsearch . test . TestSearchContext ; import org . elasticsearch . test . VersionUtils ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import org . junit . Before ; import java . io . IOException ; import java . util . * ; import static com . carrotsearch . randomizedtesting . RandomizedTest . systemPropertyAsBoolean ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . index . mapper . string . SimpleStringMappingTests . docValuesType ; import static org . hamcrest . Matchers . * ; public class SimpleDateMappingTests extends ESSingleNodeTestCase { public void testAutomaticDateParser ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertNotNull ( doc . dynamicMappingsUpdate ( ) ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( doc . dynamicMappingsUpdate ( ) . toString ( ) ) . get ( ) ; FieldMapper fieldMapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( DateFieldMapper . class ) ) ; DateFieldMapper dateFieldMapper = ( DateFieldMapper ) fieldMapper ; assertEquals ( <str> , dateFieldMapper . fieldType ( ) . dateTimeFormatter ( ) . format ( ) ) ; assertEquals ( <int> , dateFieldMapper . fieldType ( ) . dateTimeFormatter ( ) . parser ( ) . parseMillis ( <str> ) ) ; fieldMapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( DateFieldMapper . class ) ) ; fieldMapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( StringFieldMapper . class ) ) ; fieldMapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( StringFieldMapper . class ) ) ; fieldMapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( fieldMapper , instanceOf ( StringFieldMapper . class ) ) ; } public void testParseLocal ( ) { assertThat ( Locale . GERMAN , equalTo ( LocaleUtils . parse ( <str> ) ) ) ; assertThat ( Locale . GERMANY , equalTo ( LocaleUtils . parse ( <str> ) ) ) ; assertThat ( new Locale ( <str> , <str> , <str> ) , equalTo ( LocaleUtils . parse ( <str> ) ) ) ; try { LocaleUtils . parse ( <str> ) ; fail ( ) ; } catch ( IllegalArgumentException ex ) { } assertThat ( Locale . ROOT , equalTo ( LocaleUtils . parse ( <str> ) ) ) ; assertThat ( Locale . ROOT , equalTo ( LocaleUtils . parse ( <str> ) ) ) ; } public void testLocale ( ) throws IOException { assumeFalse ( <str> , Constants . JRE_IS_MINIMUM_JAVA9 & & systemPropertyAsBoolean ( <str> , false ) ) ; String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertNumericTokensEqual ( doc , defaultMapper , <str> , <str> ) ; assertNumericTokensEqual ( doc , defaultMapper , <str> , <str> ) ; } @Before public void reset ( ) { i = <int> ; } int i = <int> ; private DocumentMapper mapper ( String indexName , String type , String mapping ) throws IOException { return mapper ( indexName , type , mapping , Version . CURRENT ) ; } private DocumentMapper mapper ( String indexName , String type , String mapping , Version version ) throws IOException { IndexService index ; if ( version . equals ( Version . CURRENT ) ) { index = createIndex ( indexName ) ; } else { index = createIndex ( indexName , settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ) ; } client ( ) . admin ( ) . indices ( ) . preparePutMapping ( indexName ) . setType ( type ) . setSource ( mapping ) . get ( ) ; return index . mapperService ( ) . documentMapper ( type ) ; } private void assertNumericTokensEqual ( ParsedDocument doc , DocumentMapper defaultMapper , String fieldA , String fieldB ) throws IOException { assertThat ( doc . rootDoc ( ) . getField ( fieldA ) . tokenStream ( defaultMapper . mappers ( ) . indexAnalyzer ( ) , null ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( fieldB ) . tokenStream ( defaultMapper . mappers ( ) . indexAnalyzer ( ) , null ) , notNullValue ( ) ) ; TokenStream tokenStream = doc . rootDoc ( ) . getField ( fieldA ) . tokenStream ( defaultMapper . mappers ( ) . indexAnalyzer ( ) , null ) ; tokenStream . reset ( ) ; NumericTermAttribute nta = tokenStream . addAttribute ( NumericTermAttribute . class ) ; List < Long > values = new ArrayList < > ( ) ; while ( tokenStream . incrementToken ( ) ) { values . add ( nta . getRawValue ( ) ) ; } tokenStream = doc . rootDoc ( ) . getField ( fieldB ) . tokenStream ( defaultMapper . mappers ( ) . indexAnalyzer ( ) , null ) ; tokenStream . reset ( ) ; nta = tokenStream . addAttribute ( NumericTermAttribute . class ) ; int pos = <int> ; while ( tokenStream . incrementToken ( ) ) { assertThat ( values . get ( pos + + ) , equalTo ( nta . getRawValue ( ) ) ) ; } assertThat ( pos , equalTo ( values . size ( ) ) ) ; } public void testTimestampAsDate ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; long value = System . currentTimeMillis ( ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , value ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) . tokenStream ( defaultMapper . mappers ( ) . indexAnalyzer ( ) , null ) , notNullValue ( ) ) ; } public void testDateDetection ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , false ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( doc . rootDoc ( ) . get ( <str> ) , equalTo ( <str> ) ) ; } public void testHourFormat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , false ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( ( ( LongFieldMapper . CustomLongNumericField ) doc . rootDoc ( ) . getField ( <str> ) ) . numericAsString ( ) , equalTo ( Long . toString ( new DateTime ( TimeValue . timeValueHours ( <int> ) . millis ( ) , DateTimeZone . UTC ) . getMillis ( ) ) ) ) ; NumericRangeQuery < Long > rangeQuery ; try { SearchContext . setCurrent ( new TestSearchContext ( ) ) ; rangeQuery = ( NumericRangeQuery < Long > ) defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) . fieldType ( ) . rangeQuery ( <str> , <str> , true , true ) . rewrite ( null ) ; } finally { SearchContext . removeCurrent ( ) ; } assertThat ( rangeQuery . getMax ( ) , equalTo ( new DateTime ( TimeValue . timeValueHours ( <int> ) . millis ( ) , DateTimeZone . UTC ) . getMillis ( ) ) ) ; assertThat ( rangeQuery . getMin ( ) , equalTo ( new DateTime ( TimeValue . timeValueHours ( <int> ) . millis ( ) , DateTimeZone . UTC ) . getMillis ( ) ) ) ; } public void testDayWithoutYearFormat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , false ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( ( ( LongFieldMapper . CustomLongNumericField ) doc . rootDoc ( ) . getField ( <str> ) ) . numericAsString ( ) , equalTo ( Long . toString ( new DateTime ( TimeValue . timeValueHours ( <int> ) . millis ( ) , DateTimeZone . UTC ) . getMillis ( ) ) ) ) ; NumericRangeQuery < Long > rangeQuery ; try { SearchContext . setCurrent ( new TestSearchContext ( ) ) ; rangeQuery = ( NumericRangeQuery < Long > ) defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) . fieldType ( ) . rangeQuery ( <str> , <str> , true , true ) . rewrite ( null ) ; } finally { SearchContext . removeCurrent ( ) ; } assertThat ( rangeQuery . getMax ( ) , equalTo ( new DateTime ( TimeValue . timeValueHours ( <int> ) . millis ( ) , DateTimeZone . UTC ) . getMillis ( ) ) ) ; assertThat ( rangeQuery . getMin ( ) , equalTo ( new DateTime ( TimeValue . timeValueHours ( <int> ) . millis ( ) , DateTimeZone . UTC ) . getMillis ( ) ) ) ; } public void testIgnoreMalformedOption ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } Settings indexSettings = settingsBuilder ( ) . put ( <str> , true ) . build ( ) ; defaultMapper = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testThatMergingWorks ( ) throws Exception { String initialMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; String updatedMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , initialMapping ) ; DocumentMapper mergeMapper = mapper ( <str> , <str> , updatedMapping ) ; assertThat ( defaultMapper . mappers ( ) . getMapper ( <str> ) , is ( instanceOf ( DateFieldMapper . class ) ) ) ; DateFieldMapper initialDateFieldMapper = ( DateFieldMapper ) defaultMapper . mappers ( ) . getMapper ( <str> ) ; Map < String , String > config = getConfigurationViaXContent ( initialDateFieldMapper ) ; assertThat ( config . get ( <str> ) , is ( <str> ) ) ; MergeResult mergeResult = defaultMapper . merge ( mergeMapper . mapping ( ) , false , false ) ; assertThat ( <str> + Arrays . asList ( mergeResult . buildConflicts ( ) ) , mergeResult . hasConflicts ( ) , is ( false ) ) ; assertThat ( defaultMapper . mappers ( ) . getMapper ( <str> ) , is ( instanceOf ( DateFieldMapper . class ) ) ) ; DateFieldMapper mergedFieldMapper = ( DateFieldMapper ) defaultMapper . mappers ( ) . getMapper ( <str> ) ; Map < String , String > mergedConfig = getConfigurationViaXContent ( mergedFieldMapper ) ; assertThat ( mergedConfig . get ( <str> ) , is ( <str> ) ) ; } public void testDefaultDocValues ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; ParsedDocument parsedDoc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; ParseContext . Document doc = parsedDoc . rootDoc ( ) ; assertEquals ( DocValuesType . SORTED_NUMERIC , docValuesType ( doc , <str> ) ) ; } private Map < String , String > getConfigurationViaXContent ( DateFieldMapper dateFieldMapper ) throws IOException { XContentBuilder builder = JsonXContent . contentBuilder ( ) . startObject ( ) ; dateFieldMapper . toXContent ( builder , ToXContent . EMPTY_PARAMS ) . endObject ( ) ; Map < String , Object > dateFieldMapperMap ; try ( XContentParser parser = JsonXContent . jsonXContent . createParser ( builder . bytes ( ) ) ) { dateFieldMapperMap = parser . map ( ) ; } assertThat ( dateFieldMapperMap , hasKey ( <str> ) ) ; assertThat ( dateFieldMapperMap . get ( <str> ) , is ( instanceOf ( Map . class ) ) ) ; return ( Map < String , String > ) dateFieldMapperMap . get ( <str> ) ; } private static long getDateAsMillis ( Document doc , String field ) { for ( IndexableField f : doc . getFields ( field ) ) { if ( f . numericValue ( ) ! = null ) { return f . numericValue ( ) . longValue ( ) ; } } throw new AssertionError ( <str> ) ; } public void testNumericResolutionBackwardsCompat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping , Version . V_0_90_0 ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . bytes ( ) ) ; assertThat ( getDateAsMillis ( doc . rootDoc ( ) , <str> ) , equalTo ( <int> ) ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( getDateAsMillis ( doc . rootDoc ( ) , <str> ) , equalTo ( <int> ) ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( getDateAsMillis ( doc . rootDoc ( ) , <str> ) , equalTo ( <int> ) ) ; DocumentMapper currentMapper = mapper ( <str> , <str> , mapping ) ; try { currentMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , randomBoolean ( ) ? <str> : <int> ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } } public void testThatEpochCanBeIgnoredWithCustomFormat ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = mapper ( <str> , <str> , mapping ) ; XContentBuilder document = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , document . bytes ( ) ) ; assertThat ( getDateAsMillis ( doc . rootDoc ( ) , <str> ) , equalTo ( <int> ) ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( document ) . get ( ) ; assertThat ( indexResponse . isCreated ( ) , is ( true ) ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . bytes ( ) ) ; assertThat ( getDateAsMillis ( doc . rootDoc ( ) , <str> ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( document ) . get ( ) ; assertThat ( indexResponse . isCreated ( ) , is ( true ) ) ; } public void testThatOlderIndicesAllowNonStrictDates ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version randomVersion = VersionUtils . randomVersionBetween ( getRandom ( ) , Version . V_0_90_0 , Version . V_1_6_1 ) ; IndexService index = createIndex ( <str> , settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , randomVersion ) . build ( ) ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( mapping ) . get ( ) ; assertDateFormat ( <str> ) ; DocumentMapper defaultMapper = index . mapperService ( ) . documentMapper ( <str> ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; } public void testThatNewIndicesOnlyAllowStrictDates ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; IndexService index = createIndex ( <str> ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( mapping ) . get ( ) ; assertDateFormat ( DateFieldMapper . Defaults . DATE_TIME_FORMATTER . format ( ) ) ; DocumentMapper defaultMapper = index . mapperService ( ) . documentMapper ( <str> ) ; defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; } } public void testThatUpgradingAnOlderIndexToStrictDateWorks ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Version randomVersion = VersionUtils . randomVersionBetween ( getRandom ( ) , Version . V_0_90_0 , Version . V_1_6_1 ) ; createIndex ( <str> , settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , randomVersion ) . build ( ) ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( mapping ) . get ( ) ; assertDateFormat ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . get ( ) ; String newMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; PutMappingResponse putMappingResponse = client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( newMapping ) . get ( ) ; assertThat ( putMappingResponse . isAcknowledged ( ) , is ( true ) ) ; assertDateFormat ( <str> ) ; } private void assertDateFormat ( String expectedFormat ) throws IOException { GetMappingsResponse response = client ( ) . admin ( ) . indices ( ) . prepareGetMappings ( <str> ) . setTypes ( <str> ) . get ( ) ; Map < String , Object > mappingMap = response . getMappings ( ) . get ( <str> ) . get ( <str> ) . getSourceAsMap ( ) ; Map < String , Object > properties = ( Map < String , Object > ) mappingMap . get ( <str> ) ; Map < String , Object > dateField = ( Map < String , Object > ) properties . get ( <str> ) ; assertThat ( ( String ) dateField . get ( <str> ) , is ( expectedFormat ) ) ; } } 
