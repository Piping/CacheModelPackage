package org . apache . cassandra . utils ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; import java . util . Objects ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; public class ConcurrentBiMap < K , V > implements Map < K , V > { protected final Map < K , V > forwardMap ; protected final Map < V , K > reverseMap ; public ConcurrentBiMap ( ) { this ( new ConcurrentHashMap < K , V > ( <int> , <float> , <int> ) , new ConcurrentHashMap < V , K > ( <int> , <float> , <int> ) ) ; } protected ConcurrentBiMap ( Map < K , V > forwardMap , Map < V , K > reverseMap ) { this . forwardMap = forwardMap ; this . reverseMap = reverseMap ; } public Map < V , K > inverse ( ) { return Collections . unmodifiableMap ( reverseMap ) ; } public void clear ( ) { forwardMap . clear ( ) ; reverseMap . clear ( ) ; } public boolean containsKey ( Object key ) { return forwardMap . containsKey ( key ) ; } public boolean containsValue ( Object value ) { return reverseMap . containsKey ( value ) ; } public Set < Entry < K , V > > entrySet ( ) { return forwardMap . entrySet ( ) ; } public V get ( Object key ) { return forwardMap . get ( key ) ; } public boolean isEmpty ( ) { return forwardMap . isEmpty ( ) ; } public Set < K > keySet ( ) { return forwardMap . keySet ( ) ; } public synchronized V put ( K key , V value ) { K oldKey = reverseMap . get ( value ) ; if ( oldKey ! = null & & ! key . equals ( oldKey ) ) throw new IllegalArgumentException ( value + <str> + oldKey ) ; V oldVal = forwardMap . put ( key , value ) ; if ( oldVal ! = null & & ! Objects . equals ( reverseMap . remove ( oldVal ) , key ) ) throw new IllegalStateException ( ) ; reverseMap . put ( value , key ) ; return oldVal ; } public synchronized void putAll ( Map < ? extends K , ? extends V > m ) { for ( Entry < ? extends K , ? extends V > entry : m . entrySet ( ) ) put ( entry . getKey ( ) , entry . getValue ( ) ) ; } public synchronized V remove ( Object key ) { V oldVal = forwardMap . remove ( key ) ; if ( oldVal = = null ) return null ; Object oldKey = reverseMap . remove ( oldVal ) ; if ( oldKey = = null | | ! oldKey . equals ( key ) ) throw new IllegalStateException ( ) ; return oldVal ; } public int size ( ) { return forwardMap . size ( ) ; } public Collection < V > values ( ) { return reverseMap . keySet ( ) ; } } 
