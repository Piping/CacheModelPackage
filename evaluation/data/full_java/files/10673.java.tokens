package com . google . common . util . concurrent ; import static com . google . common . collect . Iterables . concat ; import com . google . common . base . Functions ; import com . google . common . base . Supplier ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import com . google . common . collect . Sets ; import com . google . common . testing . GcFinalization ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . lang . ref . WeakReference ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . Semaphore ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReadWriteLock ; import java . util . concurrent . locks . ReentrantLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; public class StripedTest extends TestCase { private static List < Striped < ? > > strongImplementations ( ) { return ImmutableList . of ( Striped . readWriteLock ( <int> ) , Striped . readWriteLock ( <int> ) , Striped . lock ( <int> ) , Striped . lock ( <int> ) , Striped . semaphore ( <int> , <int> ) , Striped . semaphore ( <int> , <int> ) ) ; } private static final Supplier < ReadWriteLock > READ_WRITE_LOCK_SUPPLIER = new Supplier < ReadWriteLock > ( ) { @Override public ReadWriteLock get ( ) { return new ReentrantReadWriteLock ( ) ; } } ; private static final Supplier < Lock > LOCK_SUPPLER = new Supplier < Lock > ( ) { @Override public Lock get ( ) { return new ReentrantLock ( ) ; } } ; private static final Supplier < Semaphore > SEMAPHORE_SUPPLER = new Supplier < Semaphore > ( ) { @Override public Semaphore get ( ) { return new Semaphore ( <int> , false ) ; } } ; private static List < Striped < ? > > weakImplementations ( ) { return ImmutableList . < Striped < ? > > builder ( ) . add ( new Striped . SmallLazyStriped < ReadWriteLock > ( <int> , READ_WRITE_LOCK_SUPPLIER ) ) . add ( new Striped . SmallLazyStriped < ReadWriteLock > ( <int> , READ_WRITE_LOCK_SUPPLIER ) ) . add ( new Striped . LargeLazyStriped < ReadWriteLock > ( <int> , READ_WRITE_LOCK_SUPPLIER ) ) . add ( new Striped . LargeLazyStriped < ReadWriteLock > ( <int> , READ_WRITE_LOCK_SUPPLIER ) ) . add ( new Striped . SmallLazyStriped < Lock > ( <int> , LOCK_SUPPLER ) ) . add ( new Striped . SmallLazyStriped < Lock > ( <int> , LOCK_SUPPLER ) ) . add ( new Striped . LargeLazyStriped < Lock > ( <int> , LOCK_SUPPLER ) ) . add ( new Striped . LargeLazyStriped < Lock > ( <int> , LOCK_SUPPLER ) ) . add ( new Striped . SmallLazyStriped < Semaphore > ( <int> , SEMAPHORE_SUPPLER ) ) . add ( new Striped . SmallLazyStriped < Semaphore > ( <int> , SEMAPHORE_SUPPLER ) ) . add ( new Striped . LargeLazyStriped < Semaphore > ( <int> , SEMAPHORE_SUPPLER ) ) . add ( new Striped . LargeLazyStriped < Semaphore > ( <int> , SEMAPHORE_SUPPLER ) ) . build ( ) ; } private static Iterable < Striped < ? > > allImplementations ( ) { return concat ( strongImplementations ( ) , weakImplementations ( ) ) ; } public void testNull ( ) throws Exception { for ( Striped < ? > striped : allImplementations ( ) ) { new NullPointerTester ( ) . testAllPublicInstanceMethods ( striped ) ; } } public void testSizes ( ) { assertTrue ( Striped . lock ( <int> ) . size ( ) > = <int> ) ; assertTrue ( Striped . lock ( <int> ) . size ( ) = = <int> ) ; assertTrue ( Striped . lazyWeakLock ( <int> ) . size ( ) > = <int> ) ; assertTrue ( Striped . lazyWeakLock ( <int> ) . size ( ) = = <int> ) ; } public void testWeakImplementations ( ) { for ( Striped < ? > striped : weakImplementations ( ) ) { WeakReference < Object > weakRef = new WeakReference < Object > ( striped . get ( new Object ( ) ) ) ; GcFinalization . awaitClear ( weakRef ) ; } } public void testStrongImplementations ( ) { for ( Striped < ? > striped : strongImplementations ( ) ) { WeakReference < Object > weakRef = new WeakReference < Object > ( striped . get ( new Object ( ) ) ) ; WeakReference < Object > garbage = new WeakReference < Object > ( new Object ( ) ) ; GcFinalization . awaitClear ( garbage ) ; assertNotNull ( weakRef . get ( ) ) ; } } public void testMaximalWeakStripedLock ( ) { Striped < Lock > stripedLock = Striped . lazyWeakLock ( Integer . MAX_VALUE ) ; for ( int i = <int> ; i < <int> ; i + + ) { stripedLock . get ( new Object ( ) ) . lock ( ) ; } } public void testBulkGetReturnsSorted ( ) { for ( Striped < ? > striped : allImplementations ( ) ) { Map < Object , Integer > indexByLock = Maps . newHashMap ( ) ; for ( int i = <int> ; i < striped . size ( ) ; i + + ) { indexByLock . put ( striped . getAt ( i ) , i ) ; } for ( int objectsNum = <int> ; objectsNum < = striped . size ( ) * <int> ; objectsNum + + ) { Set < Object > objects = Sets . newHashSetWithExpectedSize ( objectsNum ) ; for ( int i = <int> ; i < objectsNum ; i + + ) { objects . add ( new Object ( ) ) ; } Iterable < ? > locks = striped . bulkGet ( objects ) ; assertTrue ( Ordering . natural ( ) . onResultOf ( Functions . forMap ( indexByLock ) ) . isOrdered ( locks ) ) ; Iterable < ? > locks2 = striped . bulkGet ( objects ) ; assertEquals ( Lists . newArrayList ( locks ) , Lists . newArrayList ( locks2 ) ) ; } } } public void testBasicInvariants ( ) { for ( Striped < ? > striped : allImplementations ( ) ) { assertBasicInvariants ( striped ) ; } } private static void assertBasicInvariants ( Striped < ? > striped ) { Set < Object > observed = Sets . newIdentityHashSet ( ) ; for ( int i = <int> ; i < striped . size ( ) ; i + + ) { Object object = striped . getAt ( i ) ; assertNotNull ( object ) ; assertSame ( object , striped . getAt ( i ) ) ; observed . add ( object ) ; } assertTrue ( <str> , observed . size ( ) = = striped . size ( ) ) ; for ( int i = <int> ; i < striped . size ( ) * <int> ; i + + ) { assertTrue ( observed . contains ( striped . get ( new Object ( ) ) ) ) ; } try { striped . getAt ( - <int> ) ; fail ( ) ; } catch ( RuntimeException expected ) { } try { striped . getAt ( striped . size ( ) ) ; fail ( ) ; } catch ( RuntimeException expected ) { } } public void testMaxSize ( ) { for ( Striped < ? > striped : ImmutableList . of ( Striped . lazyWeakLock ( Integer . MAX_VALUE ) , Striped . lazyWeakSemaphore ( Integer . MAX_VALUE , Integer . MAX_VALUE ) , Striped . lazyWeakReadWriteLock ( Integer . MAX_VALUE ) ) ) { for ( int i = <int> ; i < <int> ; i + + ) { striped . getAt ( Integer . MAX_VALUE - i ) ; } } } } 
