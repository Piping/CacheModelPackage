package org . apache . cassandra . batchlog ; import java . io . IOException ; import java . net . InetAddress ; import java . util . * ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import com . google . common . collect . Lists ; import org . junit . * ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . Util . PartitionerSwitcher ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . Mutation ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . SystemKeyspace ; import org . apache . cassandra . db . commitlog . ReplayPosition ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . db . partitions . ImmutableBTreePartition ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . dht . Murmur3Partitioner ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . locator . TokenMetadata ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . UUIDGen ; import static org . apache . cassandra . cql3 . QueryProcessor . executeInternal ; import static org . junit . Assert . * ; public class BatchlogManagerTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; private static final String CF_STANDARD2 = <str> ; private static final String CF_STANDARD3 = <str> ; private static final String CF_STANDARD4 = <str> ; private static final String CF_STANDARD5 = <str> ; static PartitionerSwitcher sw ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { sw = Util . switchPartitioner ( Murmur3Partitioner . instance ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 , <int> , BytesType . instance ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD2 , <int> , BytesType . instance ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD3 , <int> , BytesType . instance ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD4 , <int> , BytesType . instance ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD5 , <int> , BytesType . instance ) ) ; } @AfterClass public static void cleanup ( ) { sw . close ( ) ; } @Before @SuppressWarnings ( <str> ) public void setUp ( ) throws Exception { TokenMetadata metadata = StorageService . instance . getTokenMetadata ( ) ; InetAddress localhost = InetAddress . getByName ( <str> ) ; metadata . updateNormalToken ( Util . token ( <str> ) , localhost ) ; metadata . updateHostId ( UUIDGen . getTimeUUID ( ) , localhost ) ; Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . BATCHES ) . truncateBlocking ( ) ; Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . LEGACY_BATCHLOG ) . truncateBlocking ( ) ; } @Test public void testDelete ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; CFMetaData cfm = cfs . metadata ; new RowUpdateBuilder ( cfm , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( <str> ) ) . clustering ( <str> ) . add ( <str> , <str> + <int> ) . build ( ) . applyUnsafe ( ) ; DecoratedKey dk = cfs . decorateKey ( ByteBufferUtil . bytes ( <str> ) ) ; ImmutableBTreePartition results = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , dk ) . build ( ) ) ; Iterator < Row > iter = results . iterator ( ) ; assert iter . hasNext ( ) ; Mutation mutation = new Mutation ( PartitionUpdate . fullPartitionDelete ( cfm , dk , FBUtilities . timestampMicros ( ) , FBUtilities . nowInSeconds ( ) ) ) ; mutation . applyUnsafe ( ) ; Util . assertEmpty ( Util . cmd ( cfs , dk ) . build ( ) ) ; } @Test public void testReplay ( ) throws Exception { testReplay ( false ) ; } @Test public void testLegacyReplay ( ) throws Exception { testReplay ( true ) ; } @SuppressWarnings ( <str> ) private static void testReplay ( boolean legacy ) throws Exception { long initialAllBatches = BatchlogManager . instance . countAllBatches ( ) ; long initialReplayedBatches = BatchlogManager . instance . getTotalBatchesReplayed ( ) ; CFMetaData cfm = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) . metadata ; for ( int i = <int> ; i < <int> ; i + + ) { List < Mutation > mutations = new ArrayList < > ( <int> ) ; for ( int j = <int> ; j < <int> ; j + + ) { mutations . add ( new RowUpdateBuilder ( cfm , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( i ) ) . clustering ( <str> + j ) . add ( <str> , <str> + j ) . build ( ) ) ; } long timestamp = i < <int> ? ( System . currentTimeMillis ( ) - BatchlogManager . getBatchlogTimeout ( ) ) : ( System . currentTimeMillis ( ) + BatchlogManager . getBatchlogTimeout ( ) ) ; if ( legacy ) LegacyBatchlogMigrator . store ( Batch . createLocal ( UUIDGen . getTimeUUID ( timestamp , i ) , timestamp * <int> , mutations ) , MessagingService . current_version ) ; else BatchlogManager . store ( Batch . createLocal ( UUIDGen . getTimeUUID ( timestamp , i ) , timestamp * <int> , mutations ) ) ; } if ( legacy ) { Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . LEGACY_BATCHLOG ) . forceBlockingFlush ( ) ; LegacyBatchlogMigrator . migrate ( ) ; } Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . BATCHES ) . forceBlockingFlush ( ) ; assertEquals ( <int> , BatchlogManager . instance . countAllBatches ( ) - initialAllBatches ) ; assertEquals ( <int> , BatchlogManager . instance . getTotalBatchesReplayed ( ) - initialReplayedBatches ) ; BatchlogManager . instance . startBatchlogReplay ( ) . get ( ) ; assertEquals ( <int> , BatchlogManager . instance . countAllBatches ( ) - initialAllBatches ) ; assertEquals ( <int> , BatchlogManager . instance . getTotalBatchesReplayed ( ) - initialReplayedBatches ) ; for ( int i = <int> ; i < <int> ; i + + ) { String query = String . format ( <str> , KEYSPACE1 , CF_STANDARD1 , i ) ; UntypedResultSet result = executeInternal ( query ) ; assertNotNull ( result ) ; if ( i < <int> ) { Iterator < UntypedResultSet . Row > it = result . iterator ( ) ; assertNotNull ( it ) ; for ( int j = <int> ; j < <int> ; j + + ) { assertTrue ( it . hasNext ( ) ) ; UntypedResultSet . Row row = it . next ( ) ; assertEquals ( ByteBufferUtil . bytes ( i ) , row . getBytes ( <str> ) ) ; assertEquals ( <str> + j , row . getString ( <str> ) ) ; assertEquals ( <str> + j , row . getString ( <str> ) ) ; } assertFalse ( it . hasNext ( ) ) ; } else { assertTrue ( result . isEmpty ( ) ) ; } } UntypedResultSet result = executeInternal ( String . format ( <str> , KEYSPACE1 , CF_STANDARD1 ) ) ; assertNotNull ( result ) ; assertEquals ( <int> , result . one ( ) . getLong ( <str> ) ) ; } @Test public void testTruncatedReplay ( ) throws InterruptedException , ExecutionException { CFMetaData cf2 = Schema . instance . getCFMetaData ( KEYSPACE1 , CF_STANDARD2 ) ; CFMetaData cf3 = Schema . instance . getCFMetaData ( KEYSPACE1 , CF_STANDARD3 ) ; for ( int i = <int> ; i < <int> ; i + + ) { Mutation mutation1 = new RowUpdateBuilder ( cf2 , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( i ) ) . clustering ( <str> + i ) . add ( <str> , <str> + i ) . build ( ) ; Mutation mutation2 = new RowUpdateBuilder ( cf3 , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( i ) ) . clustering ( <str> + i ) . add ( <str> , <str> + i ) . build ( ) ; List < Mutation > mutations = Lists . newArrayList ( mutation1 , mutation2 ) ; long timestamp = System . currentTimeMillis ( ) - BatchlogManager . getBatchlogTimeout ( ) ; if ( i = = <int> ) SystemKeyspace . saveTruncationRecord ( Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD2 ) , timestamp , ReplayPosition . NONE ) ; if ( i > = <int> ) timestamp + + ; else timestamp - - ; BatchlogManager . store ( Batch . createLocal ( UUIDGen . getTimeUUID ( timestamp , i ) , FBUtilities . timestampMicros ( ) , mutations ) ) ; } Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . BATCHES ) . forceBlockingFlush ( ) ; BatchlogManager . instance . startBatchlogReplay ( ) . get ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { UntypedResultSet result = executeInternal ( String . format ( <str> , KEYSPACE1 , CF_STANDARD2 , i ) ) ; assertNotNull ( result ) ; if ( i > = <int> ) { assertEquals ( ByteBufferUtil . bytes ( i ) , result . one ( ) . getBytes ( <str> ) ) ; assertEquals ( <str> + i , result . one ( ) . getString ( <str> ) ) ; assertEquals ( <str> + i , result . one ( ) . getString ( <str> ) ) ; } else { assertTrue ( result . isEmpty ( ) ) ; } } for ( int i = <int> ; i < <int> ; i + + ) { UntypedResultSet result = executeInternal ( String . format ( <str> , KEYSPACE1 , CF_STANDARD3 , i ) ) ; assertNotNull ( result ) ; assertEquals ( ByteBufferUtil . bytes ( i ) , result . one ( ) . getBytes ( <str> ) ) ; assertEquals ( <str> + i , result . one ( ) . getString ( <str> ) ) ; assertEquals ( <str> + i , result . one ( ) . getString ( <str> ) ) ; } } @Test @SuppressWarnings ( <str> ) public void testConversion ( ) throws Exception { long initialAllBatches = BatchlogManager . instance . countAllBatches ( ) ; long initialReplayedBatches = BatchlogManager . instance . getTotalBatchesReplayed ( ) ; CFMetaData cfm = Schema . instance . getCFMetaData ( KEYSPACE1 , CF_STANDARD4 ) ; for ( int i = <int> ; i < <int> ; i + + ) { Mutation mutation = new RowUpdateBuilder ( cfm , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( i ) ) . clustering ( <str> + i ) . add ( <str> , <str> + i ) . build ( ) ; long timestamp = i < <int> ? ( System . currentTimeMillis ( ) - BatchlogManager . getBatchlogTimeout ( ) ) : ( System . currentTimeMillis ( ) + BatchlogManager . getBatchlogTimeout ( ) ) ; Mutation batchMutation = LegacyBatchlogMigrator . getStoreMutation ( Batch . createLocal ( UUIDGen . getTimeUUID ( timestamp , i ) , TimeUnit . MILLISECONDS . toMicros ( timestamp ) , Collections . singleton ( mutation ) ) , MessagingService . VERSION_20 ) ; assertTrue ( LegacyBatchlogMigrator . isLegacyBatchlogMutation ( batchMutation ) ) ; LegacyBatchlogMigrator . handleLegacyMutation ( batchMutation ) ; } for ( int i = <int> ; i < <int> ; i + + ) { Mutation mutation = new RowUpdateBuilder ( cfm , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( i ) ) . clustering ( <str> + i ) . add ( <str> , <str> + i ) . build ( ) ; long timestamp = i < <int> ? ( System . currentTimeMillis ( ) - BatchlogManager . getBatchlogTimeout ( ) ) : ( System . currentTimeMillis ( ) + BatchlogManager . getBatchlogTimeout ( ) ) ; BatchlogManager . store ( Batch . createLocal ( UUIDGen . getTimeUUID ( timestamp , i ) , FBUtilities . timestampMicros ( ) , Collections . singleton ( mutation ) ) ) ; } Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . BATCHES ) . forceBlockingFlush ( ) ; assertEquals ( <int> , BatchlogManager . instance . countAllBatches ( ) - initialAllBatches ) ; assertEquals ( <int> , BatchlogManager . instance . getTotalBatchesReplayed ( ) - initialReplayedBatches ) ; UntypedResultSet result = executeInternal ( String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . LEGACY_BATCHLOG ) ) ; assertNotNull ( result ) ; assertEquals ( <str> , <int> , result . one ( ) . getLong ( <str> ) ) ; result = executeInternal ( String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . BATCHES ) ) ; assertNotNull ( result ) ; assertEquals ( <str> , <int> , result . one ( ) . getLong ( <str> ) ) ; BatchlogManager . instance . performInitialReplay ( ) ; assertEquals ( <int> , BatchlogManager . instance . countAllBatches ( ) - initialAllBatches ) ; assertEquals ( <int> , BatchlogManager . instance . getTotalBatchesReplayed ( ) - initialReplayedBatches ) ; for ( int i = <int> ; i < <int> ; i + + ) { result = executeInternal ( String . format ( <str> , KEYSPACE1 , CF_STANDARD4 , i ) ) ; assertNotNull ( result ) ; if ( i < <int> | | i > = <int> & & i < <int> ) { assertEquals ( ByteBufferUtil . bytes ( i ) , result . one ( ) . getBytes ( <str> ) ) ; assertEquals ( <str> + i , result . one ( ) . getString ( <str> ) ) ; assertEquals ( <str> + i , result . one ( ) . getString ( <str> ) ) ; } else { assertTrue ( <str> + i , result . isEmpty ( ) ) ; } } result = executeInternal ( String . format ( <str> , KEYSPACE1 , CF_STANDARD4 ) ) ; assertNotNull ( result ) ; assertEquals ( <int> , result . one ( ) . getLong ( <str> ) ) ; result = executeInternal ( String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . BATCHES ) ) ; assertNotNull ( result ) ; assertEquals ( <str> , <int> , result . one ( ) . getLong ( <str> ) ) ; result = executeInternal ( String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . LEGACY_BATCHLOG ) ) ; assertNotNull ( result ) ; assertEquals ( <str> , <int> , result . one ( ) . getLong ( <str> ) ) ; } @Test public void testAddBatch ( ) throws IOException { long initialAllBatches = BatchlogManager . instance . countAllBatches ( ) ; CFMetaData cfm = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD5 ) . metadata ; long timestamp = ( System . currentTimeMillis ( ) - DatabaseDescriptor . getWriteRpcTimeout ( ) * <int> ) * <int> ; UUID uuid = UUIDGen . getTimeUUID ( ) ; List < Mutation > mutations = new ArrayList < > ( <int> ) ; for ( int j = <int> ; j < <int> ; j + + ) { mutations . add ( new RowUpdateBuilder ( cfm , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( j ) ) . clustering ( <str> + j ) . add ( <str> , <str> + j ) . build ( ) ) ; } BatchlogManager . store ( Batch . createLocal ( uuid , timestamp , mutations ) ) ; Assert . assertEquals ( initialAllBatches + <int> , BatchlogManager . instance . countAllBatches ( ) ) ; String query = String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . BATCHES , uuid ) ; UntypedResultSet result = executeInternal ( query ) ; assertNotNull ( result ) ; assertEquals ( <int> , result . one ( ) . getLong ( <str> ) ) ; } @Test public void testRemoveBatch ( ) { long initialAllBatches = BatchlogManager . instance . countAllBatches ( ) ; CFMetaData cfm = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD5 ) . metadata ; long timestamp = ( System . currentTimeMillis ( ) - DatabaseDescriptor . getWriteRpcTimeout ( ) * <int> ) * <int> ; UUID uuid = UUIDGen . getTimeUUID ( ) ; List < Mutation > mutations = new ArrayList < > ( <int> ) ; for ( int j = <int> ; j < <int> ; j + + ) { mutations . add ( new RowUpdateBuilder ( cfm , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( j ) ) . clustering ( <str> + j ) . add ( <str> , <str> + j ) . build ( ) ) ; } BatchlogManager . store ( Batch . createLocal ( uuid , timestamp , mutations ) ) ; Assert . assertEquals ( initialAllBatches + <int> , BatchlogManager . instance . countAllBatches ( ) ) ; BatchlogManager . remove ( uuid ) ; assertEquals ( initialAllBatches , BatchlogManager . instance . countAllBatches ( ) ) ; String query = String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . BATCHES , uuid ) ; UntypedResultSet result = executeInternal ( query ) ; assertNotNull ( result ) ; assertEquals ( <int> L , result . one ( ) . getLong ( <str> ) ) ; } @Test public void testReplayWithNoPeers ( ) throws Exception { StorageService . instance . getTokenMetadata ( ) . removeEndpoint ( InetAddress . getByName ( <str> ) ) ; long initialAllBatches = BatchlogManager . instance . countAllBatches ( ) ; long initialReplayedBatches = BatchlogManager . instance . getTotalBatchesReplayed ( ) ; CFMetaData cfm = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) . metadata ; long timestamp = ( System . currentTimeMillis ( ) - DatabaseDescriptor . getWriteRpcTimeout ( ) * <int> ) * <int> ; UUID uuid = UUIDGen . getTimeUUID ( ) ; List < Mutation > mutations = new ArrayList < > ( <int> ) ; for ( int j = <int> ; j < <int> ; j + + ) { mutations . add ( new RowUpdateBuilder ( cfm , FBUtilities . timestampMicros ( ) , ByteBufferUtil . bytes ( j ) ) . clustering ( <str> + j ) . add ( <str> , <str> + j ) . build ( ) ) ; } BatchlogManager . store ( Batch . createLocal ( uuid , timestamp , mutations ) ) ; assertEquals ( <int> , BatchlogManager . instance . countAllBatches ( ) - initialAllBatches ) ; Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . BATCHES ) . forceBlockingFlush ( ) ; assertEquals ( <int> , BatchlogManager . instance . countAllBatches ( ) - initialAllBatches ) ; assertEquals ( <int> , BatchlogManager . instance . getTotalBatchesReplayed ( ) - initialReplayedBatches ) ; BatchlogManager . instance . startBatchlogReplay ( ) . get ( ) ; assertEquals ( <int> , BatchlogManager . instance . countAllBatches ( ) - initialAllBatches ) ; } } 
