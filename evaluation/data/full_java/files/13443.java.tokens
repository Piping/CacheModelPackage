package org . gradle . api . internal . tasks ; import org . gradle . api . JavaVersion ; import org . gradle . api . internal . tasks . compile . JavaCompileSpec ; import org . gradle . api . internal . tasks . compile . JavaCompilerFactory ; import org . gradle . api . tasks . javadoc . internal . JavadocGenerator ; import org . gradle . api . tasks . javadoc . internal . JavadocSpec ; import org . gradle . jvm . internal . toolchain . JavaToolChainInternal ; import org . gradle . jvm . platform . JavaPlatform ; import org . gradle . language . base . internal . compile . CompileSpec ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . platform . base . internal . toolchain . ToolProvider ; import org . gradle . process . internal . ExecActionFactory ; import org . gradle . util . TreeVisitor ; public class DefaultJavaToolChain implements JavaToolChainInternal { private final JavaCompilerFactory compilerFactory ; private final ExecActionFactory execActionFactory ; private final JavaVersion javaVersion ; public DefaultJavaToolChain ( JavaCompilerFactory compilerFactory , ExecActionFactory execActionFactory ) { this . compilerFactory = compilerFactory ; this . execActionFactory = execActionFactory ; this . javaVersion = JavaVersion . current ( ) ; } public String getName ( ) { return String . format ( <str> , javaVersion ) ; } public String getDisplayName ( ) { return String . format ( <str> , javaVersion . getMajorVersion ( ) , javaVersion ) ; } @Override public String toString ( ) { return getDisplayName ( ) ; } public ToolProvider select ( JavaPlatform targetPlatform ) { if ( targetPlatform ! = null & & targetPlatform . getTargetCompatibility ( ) . compareTo ( javaVersion ) > <int> ) { return new UnavailableToolProvider ( targetPlatform ) ; } return new JavaToolProvider ( ) ; } private class JavaToolProvider implements ToolProvider { public < T extends CompileSpec > Compiler < T > newCompiler ( Class < T > spec ) { if ( JavaCompileSpec . class . isAssignableFrom ( spec ) ) { @SuppressWarnings ( <str> ) Compiler < T > compiler = ( Compiler < T > ) compilerFactory . create ( spec ) ; return compiler ; } if ( JavadocSpec . class . isAssignableFrom ( spec ) ) { @SuppressWarnings ( <str> ) Compiler < T > compiler = ( Compiler < T > ) new JavadocGenerator ( execActionFactory ) ; return compiler ; } throw new IllegalArgumentException ( String . format ( <str> , spec . getClass ( ) . getSimpleName ( ) ) ) ; } @Override public < T > T get ( Class < T > toolType ) { throw new IllegalArgumentException ( String . format ( <str> , toolType . getSimpleName ( ) ) ) ; } public boolean isAvailable ( ) { return true ; } public void explain ( TreeVisitor < ? super String > visitor ) { } } private class UnavailableToolProvider implements ToolProvider { private final JavaPlatform targetPlatform ; private UnavailableToolProvider ( JavaPlatform targetPlatform ) { this . targetPlatform = targetPlatform ; } public < T extends CompileSpec > Compiler < T > newCompiler ( Class < T > spec ) { throw new IllegalArgumentException ( getMessage ( ) ) ; } @Override public < T > T get ( Class < T > toolType ) { throw new IllegalArgumentException ( getMessage ( ) ) ; } public boolean isAvailable ( ) { return false ; } public void explain ( TreeVisitor < ? super String > visitor ) { visitor . node ( getMessage ( ) ) ; } private String getMessage ( ) { return String . format ( <str> , targetPlatform . getDisplayName ( ) , DefaultJavaToolChain . this . getDisplayName ( ) ) ; } } } 
