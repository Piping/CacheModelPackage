package jcuda . utils ; import java . util . * ; public class Timer { private static Map < Object , Timer > timers = new LinkedHashMap < Object , Timer > ( ) ; public static synchronized void createTimer ( Object name ) { timers . put ( name , new Timer ( ) ) ; } public static synchronized void deleteTimer ( Object name ) { timers . remove ( name ) ; } public static synchronized void startTimer ( Object name ) { getTimer ( name ) . start ( ) ; } public static synchronized void stopTimer ( Object name ) { getTimer ( name ) . stop ( ) ; } public static synchronized void resetTimer ( Object name ) { getTimer ( name ) . reset ( ) ; } public static synchronized int getTimerValue ( Object name ) { return getTimer ( name ) . getValue ( ) ; } public static synchronized int getAverageTimerValue ( Object name ) { return getTimer ( name ) . getAverageValue ( ) ; } public static synchronized void prettyPrint ( ) { System . out . println ( createPrettyString ( ) ) ; } public static synchronized String createPrettyString ( ) { int maxLength = <int> ; for ( Object object : timers . keySet ( ) ) { maxLength = Math . max ( maxLength , String . valueOf ( object ) . length ( ) ) ; } StringBuilder sb = new StringBuilder ( ) ; int headerIndent = Math . max ( <int> , maxLength - <int> ) ; sb . append ( String . format ( <str> + headerIndent + <str> , <str> ) ) ; sb . append ( <str> ) ; for ( Map . Entry < Object , Timer > entry : timers . entrySet ( ) ) { Object key = entry . getKey ( ) ; String keyString = String . valueOf ( key ) ; sb . append ( String . format ( <str> + ( maxLength + <int> ) + <str> , keyString ) ) ; Timer timer = entry . getValue ( ) ; sb . append ( String . format ( <str> , timer . getValue ( ) ) + <str> ) ; sb . append ( String . format ( <str> , timer . getAverageValue ( ) ) ) ; if ( timer . running ) { sb . append ( <str> ) ; } sb . append ( <str> ) ; } return sb . toString ( ) ; } private static Timer getTimer ( Object name ) { Timer timer = timers . get ( name ) ; if ( timer = = null ) { timer = new Timer ( ) ; timers . put ( name , timer ) ; } return timer ; } private long startTime ; private long totalTimeNS = <int> ; private int runs = <int> ; private boolean running = false ; private Timer ( ) { } private void start ( ) { startTime = System . nanoTime ( ) ; running = true ; } private void stop ( ) { long stopTime = System . nanoTime ( ) ; totalTimeNS + = ( stopTime - startTime ) ; runs + + ; running = false ; } private void reset ( ) { runs = <int> ; totalTimeNS = <int> ; running = false ; } private int getValue ( ) { if ( running ) { long currentTime = System . nanoTime ( ) ; long time = totalTimeNS + ( currentTime - startTime ) ; return ( int ) ( time / <int> ) ; } return ( int ) ( totalTimeNS / <int> ) ; } private int getAverageValue ( ) { if ( runs = = <int> ) { return <int> ; } return ( int ) ( totalTimeNS / <int> / runs ) ; } } 
