package org . elasticsearch . common . inject ; import org . elasticsearch . common . inject . matcher . Matcher ; import org . elasticsearch . common . inject . name . Names ; import org . elasticsearch . common . inject . spi . Message ; import java . lang . reflect . Type ; import java . util . HashSet ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; public class Injectors { public static Throwable getFirstErrorFailure ( CreationException e ) { if ( e . getErrorMessages ( ) . isEmpty ( ) ) { return e ; } for ( Message message : e . getErrorMessages ( ) ) { if ( message . getCause ( ) ! = null ) { return message . getCause ( ) ; } } return e ; } public static < T > T getInstance ( Injector injector , java . lang . Class < T > type , String name ) { return injector . getInstance ( Key . get ( type , Names . named ( name ) ) ) ; } public static < T > Set < T > getInstancesOf ( Injector injector , Class < T > baseClass ) { Set < T > answer = new HashSet < > ( ) ; Set < Entry < Key < ? > , Binding < ? > > > entries = injector . getBindings ( ) . entrySet ( ) ; for ( Entry < Key < ? > , Binding < ? > > entry : entries ) { Key < ? > key = entry . getKey ( ) ; Class < ? > keyType = getKeyType ( key ) ; if ( keyType ! = null & & baseClass . isAssignableFrom ( keyType ) ) { Binding < ? > binding = entry . getValue ( ) ; Object value = binding . getProvider ( ) . get ( ) ; if ( value ! = null ) { T castValue = baseClass . cast ( value ) ; answer . add ( castValue ) ; } } } return answer ; } public static < T > Set < T > getInstancesOf ( Injector injector , Matcher < Class > matcher ) { Set < T > answer = new HashSet < > ( ) ; Set < Entry < Key < ? > , Binding < ? > > > entries = injector . getBindings ( ) . entrySet ( ) ; for ( Entry < Key < ? > , Binding < ? > > entry : entries ) { Key < ? > key = entry . getKey ( ) ; Class < ? > keyType = getKeyType ( key ) ; if ( keyType ! = null & & matcher . matches ( keyType ) ) { Binding < ? > binding = entry . getValue ( ) ; Object value = binding . getProvider ( ) . get ( ) ; answer . add ( ( T ) value ) ; } } return answer ; } public static < T > Set < Provider < T > > getProvidersOf ( Injector injector , Matcher < Class > matcher ) { Set < Provider < T > > answer = new HashSet < > ( ) ; Set < Entry < Key < ? > , Binding < ? > > > entries = injector . getBindings ( ) . entrySet ( ) ; for ( Entry < Key < ? > , Binding < ? > > entry : entries ) { Key < ? > key = entry . getKey ( ) ; Class < ? > keyType = getKeyType ( key ) ; if ( keyType ! = null & & matcher . matches ( keyType ) ) { Binding < ? > binding = entry . getValue ( ) ; answer . add ( ( Provider < T > ) binding . getProvider ( ) ) ; } } return answer ; } public static < T > Set < Provider < T > > getProvidersOf ( Injector injector , Class < T > baseClass ) { Set < Provider < T > > answer = new HashSet < > ( ) ; Set < Entry < Key < ? > , Binding < ? > > > entries = injector . getBindings ( ) . entrySet ( ) ; for ( Entry < Key < ? > , Binding < ? > > entry : entries ) { Key < ? > key = entry . getKey ( ) ; Class < ? > keyType = getKeyType ( key ) ; if ( keyType ! = null & & baseClass . isAssignableFrom ( keyType ) ) { Binding < ? > binding = entry . getValue ( ) ; answer . add ( ( Provider < T > ) binding . getProvider ( ) ) ; } } return answer ; } public static boolean hasBinding ( Injector injector , Matcher < Class > matcher ) { return ! getBindingsOf ( injector , matcher ) . isEmpty ( ) ; } public static boolean hasBinding ( Injector injector , Class < ? > baseClass ) { return ! getBindingsOf ( injector , baseClass ) . isEmpty ( ) ; } public static boolean hasBinding ( Injector injector , Key < ? > key ) { Binding < ? > binding = getBinding ( injector , key ) ; return binding ! = null ; } public static Binding < ? > getBinding ( Injector injector , Key < ? > key ) { Map < Key < ? > , Binding < ? > > bindings = injector . getBindings ( ) ; Binding < ? > binding = bindings . get ( key ) ; return binding ; } public static Set < Binding < ? > > getBindingsOf ( Injector injector , Matcher < Class > matcher ) { Set < Binding < ? > > answer = new HashSet < > ( ) ; Set < Entry < Key < ? > , Binding < ? > > > entries = injector . getBindings ( ) . entrySet ( ) ; for ( Entry < Key < ? > , Binding < ? > > entry : entries ) { Key < ? > key = entry . getKey ( ) ; Class < ? > keyType = getKeyType ( key ) ; if ( keyType ! = null & & matcher . matches ( keyType ) ) { answer . add ( entry . getValue ( ) ) ; } } return answer ; } public static Set < Binding < ? > > getBindingsOf ( Injector injector , Class < ? > baseClass ) { Set < Binding < ? > > answer = new HashSet < > ( ) ; Set < Entry < Key < ? > , Binding < ? > > > entries = injector . getBindings ( ) . entrySet ( ) ; for ( Entry < Key < ? > , Binding < ? > > entry : entries ) { Key < ? > key = entry . getKey ( ) ; Class < ? > keyType = getKeyType ( key ) ; if ( keyType ! = null & & baseClass . isAssignableFrom ( keyType ) ) { answer . add ( entry . getValue ( ) ) ; } } return answer ; } public static < T > Class < ? > getKeyType ( Key < ? > key ) { Class < ? > keyType = null ; TypeLiteral < ? > typeLiteral = key . getTypeLiteral ( ) ; Type type = typeLiteral . getType ( ) ; if ( type instanceof Class ) { keyType = ( Class < ? > ) type ; } return keyType ; } public static void cleanCaches ( Injector injector ) { ( ( InjectorImpl ) injector ) . clearCache ( ) ; if ( injector . getParent ( ) ! = null ) { cleanCaches ( injector . getParent ( ) ) ; } } } 
