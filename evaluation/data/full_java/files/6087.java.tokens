package org . elasticsearch . common . util ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . RamUsageEstimator ; import java . util . Arrays ; import static org . elasticsearch . common . util . BigArrays . OBJECT_PAGE_SIZE ; final class BigObjectArray < T > extends AbstractBigArray implements ObjectArray < T > { private Object [ ] [ ] pages ; public BigObjectArray ( long size , BigArrays bigArrays ) { super ( OBJECT_PAGE_SIZE , bigArrays , true ) ; this . size = size ; pages = new Object [ numPages ( size ) ] [ ] ; for ( int i = <int> ; i < pages . length ; + + i ) { pages [ i ] = newObjectPage ( i ) ; } } @SuppressWarnings ( <str> ) @Override public T get ( long index ) { final int pageIndex = pageIndex ( index ) ; final int indexInPage = indexInPage ( index ) ; return ( T ) pages [ pageIndex ] [ indexInPage ] ; } @Override public T set ( long index , T value ) { final int pageIndex = pageIndex ( index ) ; final int indexInPage = indexInPage ( index ) ; final Object [ ] page = pages [ pageIndex ] ; @SuppressWarnings ( <str> ) final T ret = ( T ) page [ indexInPage ] ; page [ indexInPage ] = value ; return ret ; } @Override protected int numBytesPerElement ( ) { return RamUsageEstimator . NUM_BYTES_INT ; } @Override public void resize ( long newSize ) { final int numPages = numPages ( newSize ) ; if ( numPages > pages . length ) { pages = Arrays . copyOf ( pages , ArrayUtil . oversize ( numPages , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ) ; } for ( int i = numPages - <int> ; i > = <int> & & pages [ i ] = = null ; - - i ) { pages [ i ] = newObjectPage ( i ) ; } for ( int i = numPages ; i < pages . length & & pages [ i ] ! = null ; + + i ) { pages [ i ] = null ; releasePage ( i ) ; } this . size = newSize ; } } 
