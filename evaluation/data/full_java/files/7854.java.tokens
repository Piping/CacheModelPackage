package org . elasticsearch . cluster . routing . allocation ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . decider . ClusterRebalanceAllocationDecider ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . test . ESAllocationTestCase ; import org . elasticsearch . test . VersionUtils ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import static org . elasticsearch . cluster . routing . ShardRoutingState . * ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . hamcrest . Matchers . * ; public class NodeVersionAllocationDeciderTests extends ESAllocationTestCase { private final ESLogger logger = Loggers . getLogger ( NodeVersionAllocationDeciderTests . class ) ; public void testDoNotAllocateFromPrimary ( ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , nullValue ( ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , nullValue ( ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , nullValue ( ) ) ; } logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; RoutingTable prevRoutingTable = routingTable ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( INITIALIZING ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; } logger . info ( <str> ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; } routingNodes = clusterState . getRoutingNodes ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; } clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> , VersionUtils . getPreviousVersion ( ) ) ) ) . build ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; } clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; } routingNodes = clusterState . getRoutingNodes ( ) ; prevRoutingTable = routingTable ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . primaryShard ( ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . replicaShardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; } } public void testRandom ( ) { AllocationService service = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) ) ; logger . info ( <str> ) ; MetaData . Builder builder = MetaData . builder ( ) ; RoutingTable . Builder rtBuilder = RoutingTable . builder ( ) ; int numIndices = between ( <int> , <int> ) ; for ( int i = <int> ; i < numIndices ; i + + ) { builder . put ( IndexMetaData . builder ( <str> + i ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( between ( <int> , <int> ) ) . numberOfReplicas ( between ( <int> , <int> ) ) ) ; } MetaData metaData = builder . build ( ) ; for ( int i = <int> ; i < numIndices ; i + + ) { rtBuilder . addAsNew ( metaData . index ( <str> + i ) ) ; } RoutingTable routingTable = rtBuilder . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; assertThat ( routingTable . shardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( routingTable . allShards ( ) . size ( ) ) ) ; List < DiscoveryNode > nodes = new ArrayList < > ( ) ; int nodeIdx = <int> ; int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { DiscoveryNodes . Builder nodesBuilder = DiscoveryNodes . builder ( ) ; int numNodes = between ( <int> , <int> ) ; if ( nodes . size ( ) > numNodes ) { Collections . shuffle ( nodes , random ( ) ) ; nodes = nodes . subList ( <int> , numNodes ) ; } else { for ( int j = nodes . size ( ) ; j < numNodes ; j + + ) { if ( frequently ( ) ) { nodes . add ( newNode ( <str> + ( nodeIdx + + ) , randomBoolean ( ) ? VersionUtils . getPreviousVersion ( ) : Version . CURRENT ) ) ; } else { nodes . add ( newNode ( <str> + ( nodeIdx + + ) , randomVersion ( random ( ) ) ) ) ; } } } for ( DiscoveryNode node : nodes ) { nodesBuilder . put ( node ) ; } clusterState = ClusterState . builder ( clusterState ) . nodes ( nodesBuilder ) . build ( ) ; clusterState = stabilize ( clusterState , service ) ; } } public void testRollingRestart ( ) { AllocationService service = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , - <int> ) . build ( ) ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; assertThat ( routingTable . index ( <str> ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( UNASSIGNED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , nullValue ( ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , nullValue ( ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , nullValue ( ) ) ; } clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> , VersionUtils . getPreviousVersion ( ) ) ) . put ( newNode ( <str> , VersionUtils . getPreviousVersion ( ) ) ) . put ( newNode ( <str> , VersionUtils . getPreviousVersion ( ) ) ) ) . build ( ) ; clusterState = stabilize ( clusterState , service ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> , VersionUtils . getPreviousVersion ( ) ) ) . put ( newNode ( <str> , VersionUtils . getPreviousVersion ( ) ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = stabilize ( clusterState , service ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> , VersionUtils . getPreviousVersion ( ) ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = stabilize ( clusterState , service ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = stabilize ( clusterState , service ) ; routingTable = clusterState . routingTable ( ) ; for ( int i = <int> ; i < routingTable . index ( <str> ) . shards ( ) . size ( ) ; i + + ) { assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . state ( ) , equalTo ( STARTED ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , notNullValue ( ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , notNullValue ( ) ) ; assertThat ( routingTable . index ( <str> ) . shard ( i ) . shards ( ) . get ( <int> ) . currentNodeId ( ) , notNullValue ( ) ) ; } } private ClusterState stabilize ( ClusterState clusterState , AllocationService service ) { logger . trace ( <str> , clusterState . getRoutingNodes ( ) . prettyPrint ( ) ) ; RoutingTable routingTable = service . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; assertRecoveryNodeVersions ( routingNodes ) ; logger . info ( <str> ) ; RoutingTable prev = routingTable ; boolean stable = false ; for ( int i = <int> ; i < <int> ; i + + ) { logger . trace ( <str> , clusterState . getRoutingNodes ( ) . prettyPrint ( ) ) ; routingTable = service . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; if ( stable = ( routingTable = = prev ) ) { break ; } assertRecoveryNodeVersions ( routingNodes ) ; prev = routingTable ; } logger . info ( <str> , stable ) ; assertThat ( stable , is ( true ) ) ; return clusterState ; } private final void assertRecoveryNodeVersions ( RoutingNodes routingNodes ) { logger . trace ( <str> , routingNodes . prettyPrint ( ) ) ; List < ShardRouting > mutableShardRoutings = routingNodes . shardsWithState ( ShardRoutingState . RELOCATING ) ; for ( ShardRouting r : mutableShardRoutings ) { String toId = r . relocatingNodeId ( ) ; String fromId = r . currentNodeId ( ) ; assertThat ( fromId , notNullValue ( ) ) ; assertThat ( toId , notNullValue ( ) ) ; logger . trace ( <str> + fromId + <str> + routingNodes . node ( fromId ) . node ( ) . version ( ) + <str> + toId + <str> + routingNodes . node ( toId ) . node ( ) . version ( ) ) ; assertTrue ( routingNodes . node ( toId ) . node ( ) . version ( ) . onOrAfter ( routingNodes . node ( fromId ) . node ( ) . version ( ) ) ) ; } mutableShardRoutings = routingNodes . shardsWithState ( ShardRoutingState . INITIALIZING ) ; for ( ShardRouting r : mutableShardRoutings ) { if ( r . initializing ( ) & & r . relocatingNodeId ( ) = = null & & ! r . primary ( ) ) { ShardRouting primary = routingNodes . activePrimary ( r ) ; assertThat ( primary , notNullValue ( ) ) ; String fromId = primary . currentNodeId ( ) ; String toId = r . currentNodeId ( ) ; logger . trace ( <str> + fromId + <str> + routingNodes . node ( fromId ) . node ( ) . version ( ) + <str> + toId + <str> + routingNodes . node ( toId ) . node ( ) . version ( ) ) ; assertTrue ( routingNodes . node ( toId ) . node ( ) . version ( ) . onOrAfter ( routingNodes . node ( fromId ) . node ( ) . version ( ) ) ) ; } } } } 
