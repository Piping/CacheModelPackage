package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandler . Sharable ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToMessageEncoder ; import java . util . List ; @Sharable public class WebSocket00FrameEncoder extends MessageToMessageEncoder < WebSocketFrame > implements WebSocketFrameEncoder { private static final ByteBuf _0X00 = Unpooled . unreleasableBuffer ( Unpooled . directBuffer ( <int> , <int> ) . writeByte ( ( byte ) <hex> ) ) ; private static final ByteBuf _0XFF = Unpooled . unreleasableBuffer ( Unpooled . directBuffer ( <int> , <int> ) . writeByte ( ( byte ) <hex> ) ) ; private static final ByteBuf _0XFF_0X00 = Unpooled . unreleasableBuffer ( Unpooled . directBuffer ( <int> , <int> ) . writeByte ( ( byte ) <hex> ) . writeByte ( ( byte ) <hex> ) ) ; @Override protected void encode ( ChannelHandlerContext ctx , WebSocketFrame msg , List < Object > out ) throws Exception { if ( msg instanceof TextWebSocketFrame ) { ByteBuf data = msg . content ( ) ; out . add ( _0X00 . duplicate ( ) ) ; out . add ( data . retain ( ) ) ; out . add ( _0XFF . duplicate ( ) ) ; } else if ( msg instanceof CloseWebSocketFrame ) { out . add ( _0XFF_0X00 . duplicate ( ) ) ; } else { ByteBuf data = msg . content ( ) ; int dataLen = data . readableBytes ( ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( <int> ) ; boolean release = true ; try { buf . writeByte ( ( byte ) <hex> ) ; int b1 = dataLen > > > <int> & <hex> ; int b2 = dataLen > > > <int> & <hex> ; int b3 = dataLen > > > <int> & <hex> ; int b4 = dataLen & <hex> ; if ( b1 = = <int> ) { if ( b2 = = <int> ) { if ( b3 = = <int> ) { buf . writeByte ( b4 ) ; } else { buf . writeByte ( b3 | <hex> ) ; buf . writeByte ( b4 ) ; } } else { buf . writeByte ( b2 | <hex> ) ; buf . writeByte ( b3 | <hex> ) ; buf . writeByte ( b4 ) ; } } else { buf . writeByte ( b1 | <hex> ) ; buf . writeByte ( b2 | <hex> ) ; buf . writeByte ( b3 | <hex> ) ; buf . writeByte ( b4 ) ; } out . add ( buf ) ; out . add ( data . retain ( ) ) ; release = false ; } finally { if ( release ) { buf . release ( ) ; } } } } } 
