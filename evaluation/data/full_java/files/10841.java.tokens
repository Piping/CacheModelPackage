package org . gradle . internal . exceptions ; import org . gradle . api . GradleException ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . PrintStream ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; public class DefaultMultiCauseException extends GradleException implements MultiCauseException { private final List < Throwable > causes = new CopyOnWriteArrayList < Throwable > ( ) ; private transient ThreadLocal < Boolean > hideCause = threadLocal ( ) ; public DefaultMultiCauseException ( String message ) { super ( message ) ; } public DefaultMultiCauseException ( String message , Throwable . . . causes ) { super ( message ) ; this . causes . addAll ( Arrays . asList ( causes ) ) ; } public DefaultMultiCauseException ( String message , Iterable < ? extends Throwable > causes ) { super ( message ) ; initCauses ( causes ) ; } private void readObject ( ObjectInputStream inputStream ) throws IOException , ClassNotFoundException { inputStream . defaultReadObject ( ) ; hideCause = threadLocal ( ) ; } private ThreadLocal < Boolean > threadLocal ( ) { return new ThreadLocal < Boolean > ( ) { @Override protected Boolean initialValue ( ) { return false ; } } ; } public List < ? extends Throwable > getCauses ( ) { return causes ; } @Override public Throwable initCause ( Throwable throwable ) { causes . clear ( ) ; causes . add ( throwable ) ; return null ; } public void initCauses ( Iterable < ? extends Throwable > causes ) { this . causes . clear ( ) ; for ( Throwable cause : causes ) { this . causes . add ( cause ) ; } } @Override public Throwable getCause ( ) { if ( hideCause . get ( ) ) { return null ; } return causes . isEmpty ( ) ? null : causes . get ( <int> ) ; } @Override public void printStackTrace ( PrintStream printStream ) { PrintWriter writer = new PrintWriter ( printStream ) ; printStackTrace ( writer ) ; writer . flush ( ) ; } @Override public void printStackTrace ( PrintWriter printWriter ) { if ( causes . size ( ) < = <int> ) { super . printStackTrace ( printWriter ) ; return ; } hideCause . set ( true ) ; try { super . printStackTrace ( printWriter ) ; for ( int i = <int> ; i < causes . size ( ) ; i + + ) { Throwable cause = causes . get ( i ) ; printWriter . format ( <str> , i + <int> ) ; cause . printStackTrace ( printWriter ) ; } } finally { hideCause . set ( false ) ; } } } 
