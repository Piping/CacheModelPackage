package org . elasticsearch . action . support ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; public final class DestructiveOperations extends AbstractComponent implements NodeSettingsService . Listener { public static final String REQUIRES_NAME = <str> ; private volatile boolean destructiveRequiresName ; @Inject public DestructiveOperations ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; destructiveRequiresName = settings . getAsBoolean ( DestructiveOperations . REQUIRES_NAME , false ) ; nodeSettingsService . addListener ( this ) ; } public void failDestructive ( String [ ] aliasesOrIndices ) { if ( ! destructiveRequiresName ) { return ; } if ( aliasesOrIndices = = null | | aliasesOrIndices . length = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } else if ( aliasesOrIndices . length = = <int> ) { if ( hasWildcardUsage ( aliasesOrIndices [ <int> ] ) ) { throw new IllegalArgumentException ( <str> ) ; } } else { for ( String aliasesOrIndex : aliasesOrIndices ) { if ( hasWildcardUsage ( aliasesOrIndex ) ) { throw new IllegalArgumentException ( <str> ) ; } } } } @Override public void onRefreshSettings ( Settings settings ) { boolean newValue = settings . getAsBoolean ( DestructiveOperations . REQUIRES_NAME , destructiveRequiresName ) ; if ( destructiveRequiresName ! = newValue ) { logger . info ( <str> , destructiveRequiresName , newValue ) ; this . destructiveRequiresName = newValue ; } } private static boolean hasWildcardUsage ( String aliasOrIndex ) { return <str> . equals ( aliasOrIndex ) | | aliasOrIndex . indexOf ( <str> ) ! = - <int> ; } } 
