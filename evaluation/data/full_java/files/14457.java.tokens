package org . gradle . model . internal . type ; import com . google . common . base . Objects ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import java . lang . annotation . Annotation ; import java . lang . reflect . * ; import java . security . AccessControlException ; import java . util . Arrays ; class TypeVariableTypeWrapper < D extends GenericDeclaration > implements TypeWrapper { private static final Class < ? > [ ] TYPE_VARIABLE_INTERFACE = { TypeVariable . class } ; private final String name ; private final TypeWrapper [ ] bounds ; private final int hashCode ; public TypeVariableTypeWrapper ( String name , TypeWrapper [ ] bounds , int hashCode ) { this . name = name ; this . bounds = bounds ; this . hashCode = hashCode ; } @Override public Type unwrap ( ) { return ( Type ) Proxy . newProxyInstance ( getClass ( ) . getClassLoader ( ) , TYPE_VARIABLE_INTERFACE , new TypeVariableInvocationHandler ( this ) ) ; } @Override public void collectClasses ( ImmutableList . Builder < Class < ? > > builder ) { for ( TypeWrapper bound : bounds ) { bound . collectClasses ( builder ) ; } } @Override public String getRepresentation ( boolean full ) { return name ; } public String getName ( ) { return name ; } public Type [ ] getBounds ( ) { return ModelType . unwrap ( bounds ) ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof TypeVariable ) ) { return false ; } else { TypeVariable < ? > var2 = ( TypeVariable < ? > ) o ; return Objects . equal ( this . getName ( ) , var2 . getName ( ) ) & & Arrays . equals ( this . getBounds ( ) , var2 . getBounds ( ) ) ; } } @Override public int hashCode ( ) { return hashCode ; } public boolean isAnnotationPresent ( Class < ? extends Annotation > annotationClass ) { return false ; } public Annotation [ ] getDeclaredAnnotations ( ) { return new Annotation [ <int> ] ; } public Annotation [ ] getAnnotations ( ) { return new Annotation [ <int> ] ; } public < A extends Annotation > A getAnnotation ( Class < A > annotationClass ) { return null ; } public D getGenericDeclaration ( ) { throw new UnsupportedOperationException ( ) ; } private static final class TypeVariableInvocationHandler implements InvocationHandler { private static final ImmutableMap < String , Method > TYPE_VARIABLE_METHODS ; static { ImmutableMap . Builder < String , Method > builder = ImmutableMap . builder ( ) ; for ( Method method : TypeVariableTypeWrapper . class . getMethods ( ) ) { if ( method . getDeclaringClass ( ) . equals ( TypeVariableTypeWrapper . class ) ) { try { method . setAccessible ( true ) ; } catch ( AccessControlException e ) { } builder . put ( method . getName ( ) , method ) ; } } TYPE_VARIABLE_METHODS = builder . build ( ) ; } private final TypeVariableTypeWrapper < ? > wrapper ; TypeVariableInvocationHandler ( TypeVariableTypeWrapper < ? > wrapper ) { this . wrapper = wrapper ; } @Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { String methodName = method . getName ( ) ; Method typeVariableMethod = TYPE_VARIABLE_METHODS . get ( methodName ) ; if ( typeVariableMethod = = null ) { throw new UnsupportedOperationException ( methodName ) ; } else { try { return typeVariableMethod . invoke ( wrapper , args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } } } } } 
