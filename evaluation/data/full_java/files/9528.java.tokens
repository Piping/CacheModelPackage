package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . MoreObjects ; import com . google . common . base . Preconditions ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Lists ; import com . google . common . collect . MapMaker ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import com . google . j2objc . annotations . Weak ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . EnumMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . ReentrantLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . annotation . Nullable ; import javax . annotation . concurrent . ThreadSafe ; @Beta @ThreadSafe public class CycleDetectingLockFactory { @Beta @ThreadSafe public interface Policy { void handlePotentialDeadlock ( PotentialDeadlockException exception ) ; } @Beta public enum Policies implements Policy { THROW { @Override public void handlePotentialDeadlock ( PotentialDeadlockException e ) { throw e ; } } , WARN { @Override public void handlePotentialDeadlock ( PotentialDeadlockException e ) { logger . log ( Level . SEVERE , <str> , e ) ; } } , DISABLED { @Override public void handlePotentialDeadlock ( PotentialDeadlockException e ) { } } ; } public static CycleDetectingLockFactory newInstance ( Policy policy ) { return new CycleDetectingLockFactory ( policy ) ; } public ReentrantLock newReentrantLock ( String lockName ) { return newReentrantLock ( lockName , false ) ; } public ReentrantLock newReentrantLock ( String lockName , boolean fair ) { return policy = = Policies . DISABLED ? new ReentrantLock ( fair ) : new CycleDetectingReentrantLock ( new LockGraphNode ( lockName ) , fair ) ; } public ReentrantReadWriteLock newReentrantReadWriteLock ( String lockName ) { return newReentrantReadWriteLock ( lockName , false ) ; } public ReentrantReadWriteLock newReentrantReadWriteLock ( String lockName , boolean fair ) { return policy = = Policies . DISABLED ? new ReentrantReadWriteLock ( fair ) : new CycleDetectingReentrantReadWriteLock ( new LockGraphNode ( lockName ) , fair ) ; } private static final ConcurrentMap < Class < ? extends Enum > , Map < ? extends Enum , LockGraphNode > > lockGraphNodesPerType = new MapMaker ( ) . weakKeys ( ) . makeMap ( ) ; public static < E extends Enum < E > > WithExplicitOrdering < E > newInstanceWithExplicitOrdering ( Class < E > enumClass , Policy policy ) { checkNotNull ( enumClass ) ; checkNotNull ( policy ) ; @SuppressWarnings ( <str> ) Map < E , LockGraphNode > lockGraphNodes = ( Map < E , LockGraphNode > ) getOrCreateNodes ( enumClass ) ; return new WithExplicitOrdering < E > ( policy , lockGraphNodes ) ; } private static Map < ? extends Enum , LockGraphNode > getOrCreateNodes ( Class < ? extends Enum > clazz ) { Map < ? extends Enum , LockGraphNode > existing = lockGraphNodesPerType . get ( clazz ) ; if ( existing ! = null ) { return existing ; } Map < ? extends Enum , LockGraphNode > created = createNodes ( clazz ) ; existing = lockGraphNodesPerType . putIfAbsent ( clazz , created ) ; return MoreObjects . firstNonNull ( existing , created ) ; } @VisibleForTesting static < E extends Enum < E > > Map < E , LockGraphNode > createNodes ( Class < E > clazz ) { EnumMap < E , LockGraphNode > map = Maps . newEnumMap ( clazz ) ; E [ ] keys = clazz . getEnumConstants ( ) ; final int numKeys = keys . length ; ArrayList < LockGraphNode > nodes = Lists . newArrayListWithCapacity ( numKeys ) ; for ( E key : keys ) { LockGraphNode node = new LockGraphNode ( getLockName ( key ) ) ; nodes . add ( node ) ; map . put ( key , node ) ; } for ( int i = <int> ; i < numKeys ; i + + ) { nodes . get ( i ) . checkAcquiredLocks ( Policies . THROW , nodes . subList ( <int> , i ) ) ; } for ( int i = <int> ; i < numKeys - <int> ; i + + ) { nodes . get ( i ) . checkAcquiredLocks ( Policies . DISABLED , nodes . subList ( i + <int> , numKeys ) ) ; } return Collections . unmodifiableMap ( map ) ; } private static String getLockName ( Enum < ? > rank ) { return rank . getDeclaringClass ( ) . getSimpleName ( ) + <str> + rank . name ( ) ; } @Beta public static final class WithExplicitOrdering < E extends Enum < E > > extends CycleDetectingLockFactory { private final Map < E , LockGraphNode > lockGraphNodes ; @VisibleForTesting WithExplicitOrdering ( Policy policy , Map < E , LockGraphNode > lockGraphNodes ) { super ( policy ) ; this . lockGraphNodes = lockGraphNodes ; } public ReentrantLock newReentrantLock ( E rank ) { return newReentrantLock ( rank , false ) ; } public ReentrantLock newReentrantLock ( E rank , boolean fair ) { return policy = = Policies . DISABLED ? new ReentrantLock ( fair ) : new CycleDetectingReentrantLock ( lockGraphNodes . get ( rank ) , fair ) ; } public ReentrantReadWriteLock newReentrantReadWriteLock ( E rank ) { return newReentrantReadWriteLock ( rank , false ) ; } public ReentrantReadWriteLock newReentrantReadWriteLock ( E rank , boolean fair ) { return policy = = Policies . DISABLED ? new ReentrantReadWriteLock ( fair ) : new CycleDetectingReentrantReadWriteLock ( lockGraphNodes . get ( rank ) , fair ) ; } } private static final Logger logger = Logger . getLogger ( CycleDetectingLockFactory . class . getName ( ) ) ; final Policy policy ; private CycleDetectingLockFactory ( Policy policy ) { this . policy = checkNotNull ( policy ) ; } private static final ThreadLocal < ArrayList < LockGraphNode > > acquiredLocks = new ThreadLocal < ArrayList < LockGraphNode > > ( ) { @Override protected ArrayList < LockGraphNode > initialValue ( ) { return Lists . < LockGraphNode > newArrayListWithCapacity ( <int> ) ; } } ; private static class ExampleStackTrace extends IllegalStateException { static final StackTraceElement [ ] EMPTY_STACK_TRACE = new StackTraceElement [ <int> ] ; static final Set < String > EXCLUDED_CLASS_NAMES = ImmutableSet . of ( CycleDetectingLockFactory . class . getName ( ) , ExampleStackTrace . class . getName ( ) , LockGraphNode . class . getName ( ) ) ; ExampleStackTrace ( LockGraphNode node1 , LockGraphNode node2 ) { super ( node1 . getLockName ( ) + <str> + node2 . getLockName ( ) ) ; StackTraceElement [ ] origStackTrace = getStackTrace ( ) ; for ( int i = <int> , n = origStackTrace . length ; i < n ; i + + ) { if ( WithExplicitOrdering . class . getName ( ) . equals ( origStackTrace [ i ] . getClassName ( ) ) ) { setStackTrace ( EMPTY_STACK_TRACE ) ; break ; } if ( ! EXCLUDED_CLASS_NAMES . contains ( origStackTrace [ i ] . getClassName ( ) ) ) { setStackTrace ( Arrays . copyOfRange ( origStackTrace , i , n ) ) ; break ; } } } } @Beta public static final class PotentialDeadlockException extends ExampleStackTrace { private final ExampleStackTrace conflictingStackTrace ; private PotentialDeadlockException ( LockGraphNode node1 , LockGraphNode node2 , ExampleStackTrace conflictingStackTrace ) { super ( node1 , node2 ) ; this . conflictingStackTrace = conflictingStackTrace ; initCause ( conflictingStackTrace ) ; } public ExampleStackTrace getConflictingStackTrace ( ) { return conflictingStackTrace ; } @Override public String getMessage ( ) { StringBuilder message = new StringBuilder ( super . getMessage ( ) ) ; for ( Throwable t = conflictingStackTrace ; t ! = null ; t = t . getCause ( ) ) { message . append ( <str> ) . append ( t . getMessage ( ) ) ; } return message . toString ( ) ; } } private interface CycleDetectingLock { LockGraphNode getLockGraphNode ( ) ; boolean isAcquiredByCurrentThread ( ) ; } private static class LockGraphNode { final Map < LockGraphNode , ExampleStackTrace > allowedPriorLocks = new MapMaker ( ) . weakKeys ( ) . makeMap ( ) ; final Map < LockGraphNode , PotentialDeadlockException > disallowedPriorLocks = new MapMaker ( ) . weakKeys ( ) . makeMap ( ) ; final String lockName ; LockGraphNode ( String lockName ) { this . lockName = Preconditions . checkNotNull ( lockName ) ; } String getLockName ( ) { return lockName ; } void checkAcquiredLocks ( Policy policy , List < LockGraphNode > acquiredLocks ) { for ( int i = <int> , size = acquiredLocks . size ( ) ; i < size ; i + + ) { checkAcquiredLock ( policy , acquiredLocks . get ( i ) ) ; } } void checkAcquiredLock ( Policy policy , LockGraphNode acquiredLock ) { Preconditions . checkState ( this ! = acquiredLock , <str> , acquiredLock . getLockName ( ) ) ; if ( allowedPriorLocks . containsKey ( acquiredLock ) ) { return ; } PotentialDeadlockException previousDeadlockException = disallowedPriorLocks . get ( acquiredLock ) ; if ( previousDeadlockException ! = null ) { PotentialDeadlockException exception = new PotentialDeadlockException ( acquiredLock , this , previousDeadlockException . getConflictingStackTrace ( ) ) ; policy . handlePotentialDeadlock ( exception ) ; return ; } Set < LockGraphNode > seen = Sets . newIdentityHashSet ( ) ; ExampleStackTrace path = acquiredLock . findPathTo ( this , seen ) ; if ( path = = null ) { allowedPriorLocks . put ( acquiredLock , new ExampleStackTrace ( acquiredLock , this ) ) ; } else { PotentialDeadlockException exception = new PotentialDeadlockException ( acquiredLock , this , path ) ; disallowedPriorLocks . put ( acquiredLock , exception ) ; policy . handlePotentialDeadlock ( exception ) ; } } @Nullable private ExampleStackTrace findPathTo ( LockGraphNode node , Set < LockGraphNode > seen ) { if ( ! seen . add ( this ) ) { return null ; } ExampleStackTrace found = allowedPriorLocks . get ( node ) ; if ( found ! = null ) { return found ; } for ( Map . Entry < LockGraphNode , ExampleStackTrace > entry : allowedPriorLocks . entrySet ( ) ) { LockGraphNode preAcquiredLock = entry . getKey ( ) ; found = preAcquiredLock . findPathTo ( node , seen ) ; if ( found ! = null ) { ExampleStackTrace path = new ExampleStackTrace ( preAcquiredLock , this ) ; path . setStackTrace ( entry . getValue ( ) . getStackTrace ( ) ) ; path . initCause ( found ) ; return path ; } } return null ; } } private void aboutToAcquire ( CycleDetectingLock lock ) { if ( ! lock . isAcquiredByCurrentThread ( ) ) { ArrayList < LockGraphNode > acquiredLockList = acquiredLocks . get ( ) ; LockGraphNode node = lock . getLockGraphNode ( ) ; node . checkAcquiredLocks ( policy , acquiredLockList ) ; acquiredLockList . add ( node ) ; } } private static void lockStateChanged ( CycleDetectingLock lock ) { if ( ! lock . isAcquiredByCurrentThread ( ) ) { ArrayList < LockGraphNode > acquiredLockList = acquiredLocks . get ( ) ; LockGraphNode node = lock . getLockGraphNode ( ) ; for ( int i = acquiredLockList . size ( ) - <int> ; i > = <int> ; i - - ) { if ( acquiredLockList . get ( i ) = = node ) { acquiredLockList . remove ( i ) ; break ; } } } } final class CycleDetectingReentrantLock extends ReentrantLock implements CycleDetectingLock { private final LockGraphNode lockGraphNode ; private CycleDetectingReentrantLock ( LockGraphNode lockGraphNode , boolean fair ) { super ( fair ) ; this . lockGraphNode = Preconditions . checkNotNull ( lockGraphNode ) ; } @Override public LockGraphNode getLockGraphNode ( ) { return lockGraphNode ; } @Override public boolean isAcquiredByCurrentThread ( ) { return isHeldByCurrentThread ( ) ; } @Override public void lock ( ) { aboutToAcquire ( this ) ; try { super . lock ( ) ; } finally { lockStateChanged ( this ) ; } } @Override public void lockInterruptibly ( ) throws InterruptedException { aboutToAcquire ( this ) ; try { super . lockInterruptibly ( ) ; } finally { lockStateChanged ( this ) ; } } @Override public boolean tryLock ( ) { aboutToAcquire ( this ) ; try { return super . tryLock ( ) ; } finally { lockStateChanged ( this ) ; } } @Override public boolean tryLock ( long timeout , TimeUnit unit ) throws InterruptedException { aboutToAcquire ( this ) ; try { return super . tryLock ( timeout , unit ) ; } finally { lockStateChanged ( this ) ; } } @Override public void unlock ( ) { try { super . unlock ( ) ; } finally { lockStateChanged ( this ) ; } } } final class CycleDetectingReentrantReadWriteLock extends ReentrantReadWriteLock implements CycleDetectingLock { private final CycleDetectingReentrantReadLock readLock ; private final CycleDetectingReentrantWriteLock writeLock ; private final LockGraphNode lockGraphNode ; private CycleDetectingReentrantReadWriteLock ( LockGraphNode lockGraphNode , boolean fair ) { super ( fair ) ; this . readLock = new CycleDetectingReentrantReadLock ( this ) ; this . writeLock = new CycleDetectingReentrantWriteLock ( this ) ; this . lockGraphNode = Preconditions . checkNotNull ( lockGraphNode ) ; } @Override public ReadLock readLock ( ) { return readLock ; } @Override public WriteLock writeLock ( ) { return writeLock ; } @Override public LockGraphNode getLockGraphNode ( ) { return lockGraphNode ; } @Override public boolean isAcquiredByCurrentThread ( ) { return isWriteLockedByCurrentThread ( ) | | getReadHoldCount ( ) > <int> ; } } private class CycleDetectingReentrantReadLock extends ReentrantReadWriteLock . ReadLock { @Weak final CycleDetectingReentrantReadWriteLock readWriteLock ; CycleDetectingReentrantReadLock ( CycleDetectingReentrantReadWriteLock readWriteLock ) { super ( readWriteLock ) ; this . readWriteLock = readWriteLock ; } @Override public void lock ( ) { aboutToAcquire ( readWriteLock ) ; try { super . lock ( ) ; } finally { lockStateChanged ( readWriteLock ) ; } } @Override public void lockInterruptibly ( ) throws InterruptedException { aboutToAcquire ( readWriteLock ) ; try { super . lockInterruptibly ( ) ; } finally { lockStateChanged ( readWriteLock ) ; } } @Override public boolean tryLock ( ) { aboutToAcquire ( readWriteLock ) ; try { return super . tryLock ( ) ; } finally { lockStateChanged ( readWriteLock ) ; } } @Override public boolean tryLock ( long timeout , TimeUnit unit ) throws InterruptedException { aboutToAcquire ( readWriteLock ) ; try { return super . tryLock ( timeout , unit ) ; } finally { lockStateChanged ( readWriteLock ) ; } } @Override public void unlock ( ) { try { super . unlock ( ) ; } finally { lockStateChanged ( readWriteLock ) ; } } } private class CycleDetectingReentrantWriteLock extends ReentrantReadWriteLock . WriteLock { @Weak final CycleDetectingReentrantReadWriteLock readWriteLock ; CycleDetectingReentrantWriteLock ( CycleDetectingReentrantReadWriteLock readWriteLock ) { super ( readWriteLock ) ; this . readWriteLock = readWriteLock ; } @Override public void lock ( ) { aboutToAcquire ( readWriteLock ) ; try { super . lock ( ) ; } finally { lockStateChanged ( readWriteLock ) ; } } @Override public void lockInterruptibly ( ) throws InterruptedException { aboutToAcquire ( readWriteLock ) ; try { super . lockInterruptibly ( ) ; } finally { lockStateChanged ( readWriteLock ) ; } } @Override public boolean tryLock ( ) { aboutToAcquire ( readWriteLock ) ; try { return super . tryLock ( ) ; } finally { lockStateChanged ( readWriteLock ) ; } } @Override public boolean tryLock ( long timeout , TimeUnit unit ) throws InterruptedException { aboutToAcquire ( readWriteLock ) ; try { return super . tryLock ( timeout , unit ) ; } finally { lockStateChanged ( readWriteLock ) ; } } @Override public void unlock ( ) { try { super . unlock ( ) ; } finally { lockStateChanged ( readWriteLock ) ; } } } } 
