package org . elasticsearch . index . query ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import com . fasterxml . jackson . core . JsonParseException ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . join . ScoreMode ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . admin . indices . mapping . put . PutMappingRequest ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . query . support . QueryInnerHits ; import org . elasticsearch . script . Script . ScriptParseException ; import org . elasticsearch . search . fetch . innerhits . InnerHitsBuilder ; import org . elasticsearch . search . fetch . innerhits . InnerHitsContext ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . TestSearchContext ; import java . io . IOException ; import java . util . Arrays ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; public class HasParentQueryBuilderTests extends AbstractQueryTestCase < HasParentQueryBuilder > { protected static final String PARENT_TYPE = <str> ; protected static final String CHILD_TYPE = <str> ; @Override public void setUp ( ) throws Exception { super . setUp ( ) ; MapperService mapperService = queryShardContext ( ) . getMapperService ( ) ; mapperService . merge ( PARENT_TYPE , new CompressedXContent ( PutMappingRequest . buildFromSimplifiedDef ( PARENT_TYPE , STRING_FIELD_NAME , <str> , INT_FIELD_NAME , <str> , DOUBLE_FIELD_NAME , <str> , BOOLEAN_FIELD_NAME , <str> , DATE_FIELD_NAME , <str> , OBJECT_FIELD_NAME , <str> ) . string ( ) ) , false , false ) ; mapperService . merge ( CHILD_TYPE , new CompressedXContent ( PutMappingRequest . buildFromSimplifiedDef ( CHILD_TYPE , <str> , <str> + PARENT_TYPE , STRING_FIELD_NAME , <str> , INT_FIELD_NAME , <str> , DOUBLE_FIELD_NAME , <str> , BOOLEAN_FIELD_NAME , <str> , DATE_FIELD_NAME , <str> , OBJECT_FIELD_NAME , <str> ) . string ( ) ) , false , false ) ; } @Override protected void setSearchContext ( String [ ] types ) { final MapperService mapperService = queryShardContext ( ) . getMapperService ( ) ; final IndexFieldDataService fieldData = indexFieldDataService ( ) ; TestSearchContext testSearchContext = new TestSearchContext ( ) { private InnerHitsContext context ; @Override public void innerHits ( InnerHitsContext innerHitsContext ) { context = innerHitsContext ; } @Override public InnerHitsContext innerHits ( ) { return context ; } @Override public MapperService mapperService ( ) { return mapperService ; } @Override public IndexFieldDataService fieldData ( ) { return fieldData ; } } ; testSearchContext . setTypes ( types ) ; SearchContext . setCurrent ( testSearchContext ) ; } @Override protected HasParentQueryBuilder doCreateTestQueryBuilder ( ) { InnerHitsBuilder . InnerHit innerHit = new InnerHitsBuilder . InnerHit ( ) . setSize ( <int> ) . addSort ( STRING_FIELD_NAME , SortOrder . ASC ) ; return new HasParentQueryBuilder ( PARENT_TYPE , RandomQueryBuilder . createQuery ( random ( ) ) , randomBoolean ( ) , randomBoolean ( ) ? null : new QueryInnerHits ( <str> , innerHit ) ) ; } @Override protected void doAssertLuceneQuery ( HasParentQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { QueryBuilder innerQueryBuilder = queryBuilder . query ( ) ; if ( innerQueryBuilder instanceof EmptyQueryBuilder ) { assertNull ( query ) ; } else { assertThat ( query , instanceOf ( HasChildQueryBuilder . LateParsingQuery . class ) ) ; HasChildQueryBuilder . LateParsingQuery lpq = ( HasChildQueryBuilder . LateParsingQuery ) query ; assertEquals ( queryBuilder . score ( ) ? ScoreMode . Max : ScoreMode . None , lpq . getScoreMode ( ) ) ; } if ( queryBuilder . innerHit ( ) ! = null ) { assertNotNull ( SearchContext . current ( ) ) ; if ( query ! = null ) { assertNotNull ( SearchContext . current ( ) . innerHits ( ) ) ; assertEquals ( <int> , SearchContext . current ( ) . innerHits ( ) . getInnerHits ( ) . size ( ) ) ; assertTrue ( SearchContext . current ( ) . innerHits ( ) . getInnerHits ( ) . containsKey ( <str> ) ) ; InnerHitsContext . BaseInnerHits innerHits = SearchContext . current ( ) . innerHits ( ) . getInnerHits ( ) . get ( <str> ) ; assertEquals ( innerHits . size ( ) , <int> ) ; assertEquals ( innerHits . sort ( ) . getSort ( ) . length , <int> ) ; assertEquals ( innerHits . sort ( ) . getSort ( ) [ <int> ] . getField ( ) , STRING_FIELD_NAME ) ; } else { assertNull ( SearchContext . current ( ) . innerHits ( ) ) ; } } } public void testIllegalValues ( ) { QueryBuilder query = RandomQueryBuilder . createQuery ( random ( ) ) ; try { new HasParentQueryBuilder ( null , query ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } try { new HasParentQueryBuilder ( <str> , null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { } } public void testDeprecatedXContent ( ) throws IOException { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; builder . startObject ( ) ; builder . startObject ( <str> ) ; builder . field ( <str> ) ; EmptyQueryBuilder . PROTOTYPE . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; builder . field ( <str> , <str> ) ; builder . endObject ( ) ; builder . endObject ( ) ; try { parseQuery ( builder . string ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException ex ) { assertEquals ( <str> , ex . getMessage ( ) ) ; } HasParentQueryBuilder queryBuilder = ( HasParentQueryBuilder ) parseQuery ( builder . string ( ) , ParseFieldMatcher . EMPTY ) ; assertEquals ( <str> , queryBuilder . type ( ) ) ; boolean score = randomBoolean ( ) ; String key = RandomPicks . randomFrom ( random ( ) , Arrays . asList ( <str> , <str> ) ) ; builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; builder . startObject ( ) ; builder . startObject ( <str> ) ; builder . field ( <str> ) ; EmptyQueryBuilder . PROTOTYPE . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; builder . field ( key , score ? <str> : <str> ) ; builder . field ( <str> , <str> ) ; builder . endObject ( ) ; builder . endObject ( ) ; try { parseQuery ( builder . string ( ) ) ; fail ( key + <str> ) ; } catch ( IllegalArgumentException ex ) { assertEquals ( <str> + key + <str> , ex . getMessage ( ) ) ; } queryBuilder = ( HasParentQueryBuilder ) parseQuery ( builder . string ( ) , ParseFieldMatcher . EMPTY ) ; assertEquals ( score , queryBuilder . score ( ) ) ; } public void testToQueryInnerQueryType ( ) throws IOException { String [ ] searchTypes = new String [ ] { CHILD_TYPE } ; QueryShardContext . setTypes ( searchTypes ) ; HasParentQueryBuilder hasParentQueryBuilder = new HasParentQueryBuilder ( PARENT_TYPE , new IdsQueryBuilder ( ) . addIds ( <str> ) ) ; Query query = hasParentQueryBuilder . toQuery ( createShardContext ( ) ) ; assertThat ( QueryShardContext . getTypes ( ) , equalTo ( searchTypes ) ) ; HasChildQueryBuilderTests . assertLateParsingQuery ( query , PARENT_TYPE , <str> ) ; } @Override public void testUnknownObjectException ( ) throws IOException { String validQuery = createTestQueryBuilder ( ) . toString ( ) ; assertThat ( validQuery , containsString ( <str> ) ) ; int endPosition = validQuery . indexOf ( <str> ) ; if ( endPosition = = - <int> ) { endPosition = validQuery . length ( ) - <int> ; } for ( int insertionPosition = <int> ; insertionPosition < endPosition ; insertionPosition + + ) { if ( validQuery . charAt ( insertionPosition ) = = <str> ) { String testQuery = validQuery . substring ( <int> , insertionPosition ) + <str> + validQuery . substring ( insertionPosition ) + <str> ; try { parseQuery ( testQuery ) ; fail ( <str> + testQuery ) ; } catch ( ParsingException | ScriptParseException | ElasticsearchParseException e ) { } catch ( JsonParseException e ) { } } } } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; HasParentQueryBuilder parsed = ( HasParentQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <str> , parsed . type ( ) ) ; assertEquals ( json , <str> , ( ( TermQueryBuilder ) parsed . query ( ) ) . value ( ) ) ; } } 
