package org . elasticsearch . action . fieldstats ; import org . elasticsearch . Version ; import org . elasticsearch . common . io . stream . StreamInput ; import java . io . IOException ; import java . util . Locale ; import java . util . Objects ; public class IndexConstraint { private final String field ; private final Property property ; private final Comparison comparison ; private final String value ; private final String optionalFormat ; IndexConstraint ( StreamInput input ) throws IOException { this . field = input . readString ( ) ; this . property = Property . read ( input . readByte ( ) ) ; this . comparison = Comparison . read ( input . readByte ( ) ) ; this . value = input . readString ( ) ; if ( input . getVersion ( ) . onOrAfter ( Version . V_2_0_1 ) ) { this . optionalFormat = input . readOptionalString ( ) ; } else { this . optionalFormat = null ; } } public IndexConstraint ( String field , Property property , Comparison comparison , String value ) { this ( field , property , comparison , value , null ) ; } public IndexConstraint ( String field , Property property , Comparison comparison , String value , String optionalFormat ) { this . field = Objects . requireNonNull ( field ) ; this . property = Objects . requireNonNull ( property ) ; this . comparison = Objects . requireNonNull ( comparison ) ; this . value = Objects . requireNonNull ( value ) ; this . optionalFormat = optionalFormat ; } public String getField ( ) { return field ; } public Comparison getComparison ( ) { return comparison ; } public Property getProperty ( ) { return property ; } public String getValue ( ) { return value ; } public String getOptionalFormat ( ) { return optionalFormat ; } public enum Property { MIN ( ( byte ) <int> ) , MAX ( ( byte ) <int> ) ; private final byte id ; Property ( byte id ) { this . id = id ; } public byte getId ( ) { return id ; } public static Property read ( byte id ) { switch ( id ) { case <int> : return MIN ; case <int> : return MAX ; default : throw new IllegalArgumentException ( <str> + id + <str> ) ; } } public static Property parse ( String value ) { value = value . toLowerCase ( Locale . ROOT ) ; switch ( value ) { case <str> : return MIN ; case <str> : return MAX ; default : throw new IllegalArgumentException ( <str> + value + <str> ) ; } } } public enum Comparison { LT ( ( byte ) <int> ) , LTE ( ( byte ) <int> ) , GT ( ( byte ) <int> ) , GTE ( ( byte ) <int> ) ; private final byte id ; Comparison ( byte id ) { this . id = id ; } public byte getId ( ) { return id ; } public static Comparison read ( byte id ) { switch ( id ) { case <int> : return LT ; case <int> : return LTE ; case <int> : return GT ; case <int> : return GTE ; default : throw new IllegalArgumentException ( <str> + id + <str> ) ; } } public static Comparison parse ( String value ) { value = value . toLowerCase ( Locale . ROOT ) ; switch ( value ) { case <str> : return LT ; case <str> : return LTE ; case <str> : return GT ; case <str> : return GTE ; default : throw new IllegalArgumentException ( <str> + value + <str> ) ; } } } } 
