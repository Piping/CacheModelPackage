package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . CodecException ; import io . netty . handler . codec . MessageToMessageDecoder ; import io . netty . util . ReferenceCountUtil ; import java . util . List ; public abstract class HttpContentDecoder extends MessageToMessageDecoder < HttpObject > { static final String IDENTITY = HttpHeaderValues . IDENTITY . toString ( ) ; private EmbeddedChannel decoder ; private boolean continueResponse ; @Override protected void decode ( ChannelHandlerContext ctx , HttpObject msg , List < Object > out ) throws Exception { if ( msg instanceof HttpResponse & & ( ( HttpResponse ) msg ) . status ( ) . code ( ) = = <int> ) { if ( ! ( msg instanceof LastHttpContent ) ) { continueResponse = true ; } out . add ( ReferenceCountUtil . retain ( msg ) ) ; return ; } if ( continueResponse ) { if ( msg instanceof LastHttpContent ) { continueResponse = false ; } out . add ( ReferenceCountUtil . retain ( msg ) ) ; return ; } if ( msg instanceof HttpMessage ) { cleanup ( ) ; final HttpMessage message = ( HttpMessage ) msg ; final HttpHeaders headers = message . headers ( ) ; String contentEncoding = headers . get ( HttpHeaderNames . CONTENT_ENCODING ) ; if ( contentEncoding ! = null ) { contentEncoding = contentEncoding . trim ( ) ; } else { contentEncoding = IDENTITY ; } decoder = newContentDecoder ( contentEncoding ) ; if ( decoder = = null ) { if ( message instanceof HttpContent ) { ( ( HttpContent ) message ) . retain ( ) ; } out . add ( message ) ; return ; } headers . remove ( HttpHeaderNames . CONTENT_LENGTH ) ; CharSequence targetContentEncoding = getTargetContentEncoding ( contentEncoding ) ; if ( HttpHeaderValues . IDENTITY . equals ( targetContentEncoding ) ) { headers . remove ( HttpHeaderNames . CONTENT_ENCODING ) ; } else { headers . set ( HttpHeaderNames . CONTENT_ENCODING , targetContentEncoding ) ; } if ( message instanceof HttpContent ) { HttpMessage copy ; if ( message instanceof HttpRequest ) { HttpRequest r = ( HttpRequest ) message ; copy = new DefaultHttpRequest ( r . protocolVersion ( ) , r . method ( ) , r . uri ( ) ) ; } else if ( message instanceof HttpResponse ) { HttpResponse r = ( HttpResponse ) message ; copy = new DefaultHttpResponse ( r . protocolVersion ( ) , r . status ( ) ) ; } else { throw new CodecException ( <str> + message . getClass ( ) . getName ( ) + <str> ) ; } copy . headers ( ) . set ( message . headers ( ) ) ; copy . setDecoderResult ( message . decoderResult ( ) ) ; out . add ( copy ) ; } else { out . add ( message ) ; } } if ( msg instanceof HttpContent ) { final HttpContent c = ( HttpContent ) msg ; if ( decoder = = null ) { out . add ( c . retain ( ) ) ; } else { decodeContent ( c , out ) ; } } } private void decodeContent ( HttpContent c , List < Object > out ) { ByteBuf content = c . content ( ) ; decode ( content , out ) ; if ( c instanceof LastHttpContent ) { finishDecode ( out ) ; LastHttpContent last = ( LastHttpContent ) c ; HttpHeaders headers = last . trailingHeaders ( ) ; if ( headers . isEmpty ( ) ) { out . add ( LastHttpContent . EMPTY_LAST_CONTENT ) ; } else { out . add ( new ComposedLastHttpContent ( headers ) ) ; } } } protected abstract EmbeddedChannel newContentDecoder ( String contentEncoding ) throws Exception ; protected String getTargetContentEncoding ( @SuppressWarnings ( <str> ) String contentEncoding ) throws Exception { return IDENTITY ; } @Override public void handlerRemoved ( ChannelHandlerContext ctx ) throws Exception { cleanup ( ) ; super . handlerRemoved ( ctx ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { cleanup ( ) ; super . channelInactive ( ctx ) ; } private void cleanup ( ) { if ( decoder ! = null ) { if ( decoder . finish ( ) ) { for ( ; ; ) { ByteBuf buf = decoder . readInbound ( ) ; if ( buf = = null ) { break ; } buf . release ( ) ; } } decoder = null ; } } private void decode ( ByteBuf in , List < Object > out ) { decoder . writeInbound ( in . retain ( ) ) ; fetchDecoderOutput ( out ) ; } private void finishDecode ( List < Object > out ) { if ( decoder . finish ( ) ) { fetchDecoderOutput ( out ) ; } decoder = null ; } private void fetchDecoderOutput ( List < Object > out ) { for ( ; ; ) { ByteBuf buf = decoder . readInbound ( ) ; if ( buf = = null ) { break ; } if ( ! buf . isReadable ( ) ) { buf . release ( ) ; continue ; } out . add ( new DefaultHttpContent ( buf ) ) ; } } } 
