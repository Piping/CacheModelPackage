package io . netty . handler . codec . http2 ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufInputStream ; import io . netty . handler . codec . http2 . hpack . Decoder ; import io . netty . handler . codec . http2 . hpack . HeaderListener ; import io . netty . util . AsciiString ; import java . io . IOException ; import java . io . InputStream ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_HEADER_TABLE_SIZE ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_MAX_HEADER_SIZE ; import static io . netty . handler . codec . http2 . Http2Error . COMPRESSION_ERROR ; import static io . netty . handler . codec . http2 . Http2Error . ENHANCE_YOUR_CALM ; import static io . netty . handler . codec . http2 . Http2Error . INTERNAL_ERROR ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; public class DefaultHttp2HeadersDecoder implements Http2HeadersDecoder , Http2HeadersDecoder . Configuration { private static final float HEADERS_COUNT_WEIGHT_NEW = <int> / <int> ; private static final float HEADERS_COUNT_WEIGHT_HISTORICAL = <int> - HEADERS_COUNT_WEIGHT_NEW ; private final int maxHeaderSize ; private final Decoder decoder ; private final Http2HeaderTable headerTable ; private final boolean validateHeaders ; private float headerArraySizeAccumulator = <int> ; public DefaultHttp2HeadersDecoder ( ) { this ( true ) ; } public DefaultHttp2HeadersDecoder ( boolean validateHeaders ) { this ( DEFAULT_MAX_HEADER_SIZE , DEFAULT_HEADER_TABLE_SIZE , validateHeaders ) ; } public DefaultHttp2HeadersDecoder ( int maxHeaderSize , int maxHeaderTableSize , boolean validateHeaders ) { if ( maxHeaderSize < = <int> ) { throw new IllegalArgumentException ( <str> + maxHeaderSize ) ; } decoder = new Decoder ( maxHeaderSize , maxHeaderTableSize ) ; headerTable = new Http2HeaderTableDecoder ( ) ; this . maxHeaderSize = maxHeaderSize ; this . validateHeaders = validateHeaders ; } @Override public Http2HeaderTable headerTable ( ) { return headerTable ; } @Override public int maxHeaderSize ( ) { return maxHeaderSize ; } @Override public Configuration configuration ( ) { return this ; } protected void maxHeaderSizeExceeded ( ) throws Http2Exception { throw connectionError ( ENHANCE_YOUR_CALM , <str> , maxHeaderSize ) ; } @Override public Http2Headers decodeHeaders ( ByteBuf headerBlock ) throws Http2Exception { InputStream in = new ByteBufInputStream ( headerBlock ) ; try { final Http2Headers headers = new DefaultHttp2Headers ( validateHeaders , ( int ) headerArraySizeAccumulator ) ; HeaderListener listener = new HeaderListener ( ) { @Override public void addHeader ( byte [ ] key , byte [ ] value , boolean sensitive ) { headers . add ( new AsciiString ( key , false ) , new AsciiString ( value , false ) ) ; } } ; decoder . decode ( in , listener ) ; if ( decoder . endHeaderBlock ( ) ) { maxHeaderSizeExceeded ( ) ; } if ( headers . size ( ) > headerTable . maxHeaderListSize ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> , headers . size ( ) , headerTable . maxHeaderListSize ( ) ) ; } headerArraySizeAccumulator = HEADERS_COUNT_WEIGHT_NEW * headers . size ( ) + HEADERS_COUNT_WEIGHT_HISTORICAL * headerArraySizeAccumulator ; return headers ; } catch ( IOException e ) { throw connectionError ( COMPRESSION_ERROR , e , e . getMessage ( ) ) ; } catch ( Http2Exception e ) { throw e ; } catch ( Throwable e ) { throw connectionError ( COMPRESSION_ERROR , e , e . getMessage ( ) ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { throw connectionError ( INTERNAL_ERROR , e , e . getMessage ( ) ) ; } } } private final class Http2HeaderTableDecoder extends DefaultHttp2HeaderTableListSize implements Http2HeaderTable { @Override public void maxHeaderTableSize ( int max ) throws Http2Exception { if ( max < <int> ) { throw connectionError ( PROTOCOL_ERROR , <str> , max ) ; } try { decoder . setMaxHeaderTableSize ( max ) ; } catch ( Throwable t ) { throw connectionError ( PROTOCOL_ERROR , t . getMessage ( ) , t ) ; } } @Override public int maxHeaderTableSize ( ) { return decoder . getMaxHeaderTableSize ( ) ; } } } 
