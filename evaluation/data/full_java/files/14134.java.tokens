package org . gradle . messaging . remote . internal ; import org . gradle . messaging . remote . internal . protocol . ChannelAvailable ; import org . gradle . messaging . remote . internal . protocol . ChannelUnavailable ; import org . gradle . messaging . remote . internal . protocol . DiscoveryMessage ; import org . gradle . messaging . remote . internal . protocol . LookupRequest ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . HashMap ; import java . util . Map ; public class ChannelRegistrationProtocol implements Protocol < DiscoveryMessage > { private static final Logger LOGGER = LoggerFactory . getLogger ( ChannelRegistrationProtocol . class ) ; private final Map < String , ChannelAvailable > channels = new HashMap < String , ChannelAvailable > ( ) ; private final MessageOriginator messageOriginator ; private ProtocolContext < DiscoveryMessage > context ; public ChannelRegistrationProtocol ( MessageOriginator messageOriginator ) { this . messageOriginator = messageOriginator ; } public void start ( ProtocolContext < DiscoveryMessage > context ) { this . context = context ; } public void handleIncoming ( DiscoveryMessage message ) { if ( message instanceof LookupRequest ) { handleLookup ( ( LookupRequest ) message ) ; } else if ( ! ( message instanceof ChannelAvailable ) & & ! ( message instanceof ChannelUnavailable ) ) { LOGGER . info ( <str> , message ) ; } else { LOGGER . info ( <str> , message ) ; } } public void handleOutgoing ( DiscoveryMessage message ) { if ( message instanceof ChannelAvailable ) { ChannelAvailable channelAvailable = ( ChannelAvailable ) message ; channels . put ( channelAvailable . getChannel ( ) , channelAvailable ) ; LOGGER . info ( <str> , message ) ; context . dispatchOutgoing ( message ) ; } else if ( message instanceof ChannelUnavailable ) { ChannelUnavailable channelUnavailable = ( ChannelUnavailable ) message ; channels . remove ( channelUnavailable . getChannel ( ) ) ; LOGGER . info ( <str> , message ) ; context . dispatchOutgoing ( message ) ; } else { throw new UnsupportedOperationException ( ) ; } } private void handleLookup ( LookupRequest request ) { ChannelAvailable response = channels . get ( request . getChannel ( ) ) ; if ( response ! = null ) { LOGGER . info ( <str> , request , response ) ; context . dispatchOutgoing ( response ) ; } else { LOGGER . info ( <str> , request ) ; } } public void stopRequested ( ) { try { for ( ChannelAvailable channelAvailable : channels . values ( ) ) { context . dispatchOutgoing ( new ChannelUnavailable ( messageOriginator , channelAvailable . getGroup ( ) , channelAvailable . getChannel ( ) , channelAvailable . getAddress ( ) ) ) ; } } finally { channels . clear ( ) ; context . stopped ( ) ; } } } 
