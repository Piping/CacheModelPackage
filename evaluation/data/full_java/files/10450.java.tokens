package com . google . common . escape ; import com . google . common . annotations . GwtCompatible ; import junit . framework . TestCase ; @GwtCompatible public class UnicodeEscaperTest extends TestCase { private static final String SMALLEST_SURROGATE = <str> + Character . MIN_HIGH_SURROGATE + Character . MIN_LOW_SURROGATE ; private static final String LARGEST_SURROGATE = <str> + Character . MAX_HIGH_SURROGATE + Character . MAX_LOW_SURROGATE ; private static final String TEST_STRING = <str> + SMALLEST_SURROGATE + <str> + LARGEST_SURROGATE ; private static final UnicodeEscaper NOP_ESCAPER = new UnicodeEscaper ( ) { @Override protected char [ ] escape ( int c ) { return null ; } } ; private static final UnicodeEscaper SIMPLE_ESCAPER = new UnicodeEscaper ( ) { @Override protected char [ ] escape ( int cp ) { return ( <str> < = cp & & cp < = <str> ) | | ( <str> < = cp & & cp < = <str> ) | | ( <str> < = cp & & cp < = <str> ) ? null : ( <str> + String . valueOf ( cp ) + <str> ) . toCharArray ( ) ; } } ; public void testNopEscaper ( ) { UnicodeEscaper e = NOP_ESCAPER ; assertEquals ( TEST_STRING , escapeAsString ( e , TEST_STRING ) ) ; } public void testSimpleEscaper ( ) { UnicodeEscaper e = SIMPLE_ESCAPER ; String expected = <str> + <str> + Character . MIN_SUPPLEMENTARY_CODE_POINT + <str> + <str> + Character . MAX_CODE_POINT + <str> ; assertEquals ( expected , escapeAsString ( e , TEST_STRING ) ) ; } public void testGrowBuffer ( ) { StringBuffer input = new StringBuffer ( ) ; StringBuffer expected = new StringBuffer ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { input . append ( ( char ) i ) ; expected . append ( <str> + i + <str> ) ; } assertEquals ( expected . toString ( ) , SIMPLE_ESCAPER . escape ( input . toString ( ) ) ) ; } public void testSurrogatePairs ( ) { UnicodeEscaper e = SIMPLE_ESCAPER ; final int min = Character . MIN_SUPPLEMENTARY_CODE_POINT ; final int max = Character . MAX_CODE_POINT ; final int range = max - min ; final int s1 = min + ( <int> * range ) / <int> ; final int s2 = min + ( <int> * range ) / <int> ; final int s3 = min + ( <int> * range ) / <int> ; final char [ ] dst = new char [ <int> ] ; dst [ <int> ] = <str> ; Character . toChars ( min , dst , <int> ) ; Character . toChars ( s1 , dst , <int> ) ; Character . toChars ( s2 , dst , <int> ) ; Character . toChars ( s3 , dst , <int> ) ; Character . toChars ( max , dst , <int> ) ; dst [ <int> ] = <str> ; String test = new String ( dst ) ; String expected = <str> + min + <str> + s1 + <str> + s2 + <str> + s3 + <str> + max + <str> ; assertEquals ( expected , escapeAsString ( e , test ) ) ; } public void testTrailingHighSurrogate ( ) { String test = <str> + Character . MIN_HIGH_SURROGATE ; try { escapeAsString ( NOP_ESCAPER , test ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { escapeAsString ( SIMPLE_ESCAPER , test ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testNullInput ( ) { UnicodeEscaper e = SIMPLE_ESCAPER ; try { e . escape ( ( String ) null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testBadStrings ( ) { UnicodeEscaper e = SIMPLE_ESCAPER ; String [ ] BAD_STRINGS = { String . valueOf ( Character . MIN_LOW_SURROGATE ) , Character . MIN_LOW_SURROGATE + <str> , <str> + Character . MIN_LOW_SURROGATE , <str> + Character . MIN_LOW_SURROGATE + <str> , String . valueOf ( Character . MAX_LOW_SURROGATE ) , Character . MAX_LOW_SURROGATE + <str> , <str> + Character . MAX_LOW_SURROGATE , <str> + Character . MAX_LOW_SURROGATE + <str> , } ; for ( String s : BAD_STRINGS ) { try { escapeAsString ( e , s ) ; fail ( <str> + s + <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testFalsePositivesForNextEscapedIndex ( ) { UnicodeEscaper e = new UnicodeEscaper ( ) { @Override protected char [ ] escape ( int cp ) { return ( <str> < = cp & & cp < = <str> ) ? new char [ ] { Character . toUpperCase ( ( char ) cp ) } : null ; } @Override protected int nextEscapeIndex ( CharSequence csq , int index , int end ) { while ( index < end & & ! Character . isLetter ( csq . charAt ( index ) ) ) { index + + ; } return index ; } } ; assertEquals ( <str> , e . escape ( <str> ) ) ; } public void testCodePointAt_IndexOutOfBoundsException ( ) { try { UnicodeEscaper . codePointAt ( <str> , <int> , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } private static String escapeAsString ( Escaper e , String s ) { return e . escape ( s ) ; } } 
