package org . apache . cassandra . db ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . nio . charset . CharacterCodingException ; import java . util . List ; import org . junit . BeforeClass ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import org . apache . cassandra . * ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . marshal . IntegerType ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; public class PartitionRangeReadTest { public static final String KEYSPACE1 = <str> ; public static final String KEYSPACE2 = <str> ; public static final String CF_STANDARD1 = <str> ; public static final String CF_STANDARDINT = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) , SchemaLoader . denseCFMD ( KEYSPACE1 , CF_STANDARDINT , IntegerType . instance ) ) ; SchemaLoader . createKeyspace ( KEYSPACE2 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE2 , CF_STANDARD1 ) ) ; } @Test public void testInclusiveBounds ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE2 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; new RowUpdateBuilder ( cfs . metadata , <int> , ByteBufferUtil . bytes ( <str> ) ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , ByteBufferUtil . bytes ( <str> ) ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; assertEquals ( <int> , Util . getAll ( Util . cmd ( cfs ) . fromIncl ( <str> ) . toIncl ( <str> ) . build ( ) ) . size ( ) ) ; } @Test public void testCassandra6778 ( ) throws CharacterCodingException { String cfname = CF_STANDARDINT ; Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfname ) ; cfs . truncateBlocking ( ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; ColumnDefinition cDef = cfs . metadata . getColumnDefinition ( col ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( new BigInteger ( new byte [ ] { <int> } ) ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( new BigInteger ( new byte [ ] { <int> , <int> , <int> } ) ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; Row row = Util . getOnlyRow ( Util . cmd ( cfs , <str> ) . includeRow ( new BigInteger ( new byte [ ] { <int> } ) ) . build ( ) ) ; assertTrue ( row . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; row = Util . getOnlyRow ( Util . cmd ( cfs , <str> ) . includeRow ( new BigInteger ( new byte [ ] { <int> , <int> , <int> } ) ) . build ( ) ) ; assertTrue ( row . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; } @Test public void testRangeSliceInclusionExclusion ( ) throws Throwable { String keyspaceName = KEYSPACE1 ; String cfName = CF_STANDARD1 ; Keyspace keyspace = Keyspace . open ( keyspaceName ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; cfs . clearUnsafe ( ) ; for ( int i = <int> ; i < <int> ; + + i ) { RowUpdateBuilder builder = new RowUpdateBuilder ( cfs . metadata , <int> , String . valueOf ( i ) ) ; builder . clustering ( <str> ) ; builder . add ( <str> , String . valueOf ( i ) ) ; builder . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; ColumnDefinition cDef = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; List < FilteredPartition > partitions ; partitions = Util . getAll ( Util . cmd ( cfs ) . fromKeyIncl ( <str> ) . toKeyIncl ( <str> ) . build ( ) ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertTrue ( partitions . get ( <int> ) . iterator ( ) . next ( ) . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; assertTrue ( partitions . get ( partitions . size ( ) - <int> ) . iterator ( ) . next ( ) . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; partitions = Util . getAll ( Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyExcl ( <str> ) . build ( ) ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertTrue ( partitions . get ( <int> ) . iterator ( ) . next ( ) . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; assertTrue ( partitions . get ( partitions . size ( ) - <int> ) . iterator ( ) . next ( ) . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; partitions = Util . getAll ( Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyIncl ( <str> ) . build ( ) ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertTrue ( partitions . get ( <int> ) . iterator ( ) . next ( ) . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; assertTrue ( partitions . get ( partitions . size ( ) - <int> ) . iterator ( ) . next ( ) . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; partitions = Util . getAll ( Util . cmd ( cfs ) . fromKeyIncl ( <str> ) . toKeyExcl ( <str> ) . build ( ) ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertTrue ( partitions . get ( <int> ) . iterator ( ) . next ( ) . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; assertTrue ( partitions . get ( partitions . size ( ) - <int> ) . iterator ( ) . next ( ) . getCell ( cDef ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; } } 
