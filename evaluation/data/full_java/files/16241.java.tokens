package org . gradle . gradleplugin . userinterface . swing . common ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . gradleplugin . foundation . search . BasicTextSearchCriteria ; import org . gradle . gradleplugin . foundation . search . TextBlockSearchEditor ; import org . gradle . gradleplugin . userinterface . swing . generic . Utility ; import javax . swing . * ; import javax . swing . event . DocumentEvent ; import javax . swing . event . DocumentListener ; import java . awt . * ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . KeyEvent ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . LinkedBlockingQueue ; public class SearchPanel { private final Logger logger = Logging . getLogger ( SearchPanel . class ) ; private JPanel mainPanel ; private JTextField textToMatchField ; private JCheckBox isCaseSensitiveCheckBox ; private JCheckBox useRegularExpressionsCheckBox ; private JButton findNextButton ; private JButton findPreviousButton ; private SearchInteraction searchInteraction ; private TextBlockSearchEditor editor = new TextBlockSearchEditor ( ) ; private Color notFoundColor = Color . red . brighter ( ) ; private volatile LinkedBlockingQueue < SearchRequest > searchRequests = new LinkedBlockingQueue < SearchRequest > ( ) ; private ExecutorService executorService ; public interface SearchInteraction { public String getTextToSearch ( ) ; public int getCaretLocation ( ) ; public void highlightAndScrollToResult ( TextBlockSearchEditor editor , TextBlockSearchEditor . SearchResult searchResult ) ; public void searchComplete ( TextBlockSearchEditor editor ) ; public void removeResultHighlights ( ) ; } public SearchPanel ( SearchInteraction searchInteraction ) { this . searchInteraction = searchInteraction ; executorService = Executors . newSingleThreadExecutor ( ) ; executorService . submit ( new SearchTask ( ) ) ; setupUI ( ) ; hide ( ) ; } public JComponent getComponent ( ) { return mainPanel ; } private void setupUI ( ) { mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new BoxLayout ( mainPanel , BoxLayout . X_AXIS ) ) ; isCaseSensitiveCheckBox = new JCheckBox ( <str> ) ; isCaseSensitiveCheckBox . setMnemonic ( <str> ) ; isCaseSensitiveCheckBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { requestSearch ( ) ; } } ) ; useRegularExpressionsCheckBox = new JCheckBox ( <str> ) ; useRegularExpressionsCheckBox . setMnemonic ( <str> ) ; useRegularExpressionsCheckBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { requestSearch ( ) ; } } ) ; findNextButton = Utility . createButton ( getClass ( ) , <str> , <str> , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { goToNextMatch ( ) ; } } ) ; findPreviousButton = Utility . createButton ( getClass ( ) , <str> , <str> , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { goToPreviousMatch ( ) ; } } ) ; JButton closeButton = Utility . createButton ( getClass ( ) , <str> , <str> , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { hide ( ) ; } } ) ; mainPanel . add ( createTextToMatchField ( ) ) ; mainPanel . add ( Box . createHorizontalStrut ( <int> ) ) ; mainPanel . add ( findPreviousButton ) ; mainPanel . add ( Box . createHorizontalStrut ( <int> ) ) ; mainPanel . add ( findNextButton ) ; mainPanel . add ( Box . createHorizontalStrut ( <int> ) ) ; mainPanel . add ( isCaseSensitiveCheckBox ) ; mainPanel . add ( Box . createHorizontalStrut ( <int> ) ) ; mainPanel . add ( useRegularExpressionsCheckBox ) ; addAdditionalFields ( mainPanel ) ; mainPanel . add ( Box . createHorizontalGlue ( ) ) ; mainPanel . add ( closeButton ) ; } private Component createTextToMatchField ( ) { textToMatchField = new JTextField ( ) ; textToMatchField . setMinimumSize ( new Dimension ( <int> , <int> ) ) ; textToMatchField . registerKeyboardAction ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { hide ( ) ; } } , KeyStroke . getKeyStroke ( KeyEvent . VK_ESCAPE , <int> ) , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; ActionListener performSearchNextAction = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { goToNextMatch ( ) ; } } ; ActionListener performSearchPreviousAction = new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { goToPreviousMatch ( ) ; } } ; textToMatchField . registerKeyboardAction ( performSearchNextAction , KeyStroke . getKeyStroke ( KeyEvent . VK_ENTER , <int> ) , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; textToMatchField . registerKeyboardAction ( performSearchNextAction , KeyStroke . getKeyStroke ( KeyEvent . VK_F3 , <int> ) , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; textToMatchField . registerKeyboardAction ( performSearchPreviousAction , KeyStroke . getKeyStroke ( KeyEvent . VK_F3 , KeyEvent . SHIFT_MASK ) , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; textToMatchField . getDocument ( ) . addDocumentListener ( new DocumentListener ( ) { public void insertUpdate ( DocumentEvent e ) { requestSearch ( ) ; } public void removeUpdate ( DocumentEvent e ) { requestSearch ( ) ; } public void changedUpdate ( DocumentEvent e ) { requestSearch ( ) ; } } ) ; return textToMatchField ; } private void requestSearch ( ) { String textToMatch = textToMatchField . getText ( ) ; boolean isCaseSensitive = isCaseSensitiveCheckBox . isSelected ( ) ; boolean useRegularExpressions = useRegularExpressionsCheckBox . isSelected ( ) ; String textToSearch = searchInteraction . getTextToSearch ( ) ; searchRequests . offer ( new SearchRequest ( textToMatch , isCaseSensitive , useRegularExpressions , textToSearch ) ) ; } private SearchRequest getNextAvailableRequest ( ) { try { SearchRequest searchRequest = searchRequests . take ( ) ; if ( searchRequests . size ( ) > <int> ) { List < SearchRequest > tasks = new ArrayList < SearchRequest > ( ) ; searchRequests . drainTo ( tasks ) ; if ( ! tasks . isEmpty ( ) ) { searchRequest = tasks . get ( tasks . size ( ) - <int> ) ; } } return searchRequest ; } catch ( Exception e ) { logger . error ( <str> , e ) ; return null ; } } private class SearchRequest { private String textToMatch ; private boolean isCaseSensitive ; private boolean useRegularExpressions ; private String textToSearch ; private SearchRequest ( String textToMatch , boolean caseSensitive , boolean useRegularExpressions , String textToSearch ) { this . textToMatch = textToMatch ; isCaseSensitive = caseSensitive ; this . useRegularExpressions = useRegularExpressions ; this . textToSearch = textToSearch ; } @Override public String toString ( ) { return <str> + textToMatch + <str> + <str> + isCaseSensitive + <str> + useRegularExpressions ; } } private class SearchTask implements Runnable { private BasicTextSearchCriteria criteria = new BasicTextSearchCriteria ( ) ; public void run ( ) { while ( true ) { SearchRequest request = getNextAvailableRequest ( ) ; if ( request ! = null ) { criteria . setTextToMatch ( request . textToMatch ) ; criteria . setCaseSensitive ( request . isCaseSensitive ) ; criteria . setUseRegularExpressions ( request . useRegularExpressions ) ; editor . searchAllText ( request . textToSearch , criteria ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { searchInteraction . searchComplete ( editor ) ; enableButtonsAndFieldsAppropriately ( editor . hasMatches ( ) ) ; } } ) ; } } } } public void performSearchAgain ( ) { if ( mainPanel . isVisible ( ) ) { requestSearch ( ) ; } } private void goToNextMatch ( ) { TextBlockSearchEditor . SearchResult searchResult = editor . getNextSearchResult ( searchInteraction . getCaretLocation ( ) ) ; if ( searchResult ! = null ) { searchInteraction . highlightAndScrollToResult ( editor , searchResult ) ; } } private void goToPreviousMatch ( ) { TextBlockSearchEditor . SearchResult searchResult = editor . getPreviousSearchResult ( searchInteraction . getCaretLocation ( ) ) ; if ( searchResult ! = null ) { searchInteraction . highlightAndScrollToResult ( editor , searchResult ) ; } } protected void addAdditionalFields ( JPanel panel ) { } public void hide ( ) { if ( this . searchInteraction ! = null ) { this . searchInteraction . removeResultHighlights ( ) ; } mainPanel . setVisible ( false ) ; } public void show ( ) { mainPanel . setVisible ( true ) ; showNormalColor ( ) ; textToMatchField . selectAll ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { textToMatchField . requestFocus ( ) ; } } ) ; requestSearch ( ) ; } private void showNormalColor ( ) { textToMatchField . setForeground ( UIManager . getColor ( <str> ) ) ; } private void showNoMatchColor ( ) { textToMatchField . setForeground ( notFoundColor ) ; } public void enableButtonsAndFieldsAppropriately ( boolean foundAMatch ) { if ( foundAMatch ) { showNormalColor ( ) ; } else { showNoMatchColor ( ) ; } findNextButton . setEnabled ( foundAMatch ) ; findPreviousButton . setEnabled ( foundAMatch ) ; } } 
