package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import static java . util . concurrent . atomic . AtomicReferenceFieldUpdater . newUpdater ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Throwables ; import java . security . AccessController ; import java . security . PrivilegedActionException ; import java . security . PrivilegedExceptionAction ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executor ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; import java . util . concurrent . locks . LockSupport ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public abstract class AbstractFuture < V > implements ListenableFuture < V > { private static final boolean GENERATE_CANCELLATION_CAUSES = Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ; abstract static class TrustedFuture < V > extends AbstractFuture < V > { @Override public final V get ( ) throws InterruptedException , ExecutionException { return super . get ( ) ; } @Override public final V get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { return super . get ( timeout , unit ) ; } @Override public final boolean isDone ( ) { return super . isDone ( ) ; } @Override public final boolean isCancelled ( ) { return super . isCancelled ( ) ; } @Override public final void addListener ( Runnable listener , Executor executor ) { super . addListener ( listener , executor ) ; } } private static final Logger log = Logger . getLogger ( AbstractFuture . class . getName ( ) ) ; private static final long SPIN_THRESHOLD_NANOS = <int> ; private static final AtomicHelper ATOMIC_HELPER ; static { AtomicHelper helper ; try { helper = new UnsafeAtomicHelper ( ) ; } catch ( Throwable unsafeFailure ) { try { helper = new SafeAtomicHelper ( newUpdater ( Waiter . class , Thread . class , <str> ) , newUpdater ( Waiter . class , Waiter . class , <str> ) , newUpdater ( AbstractFuture . class , Waiter . class , <str> ) , newUpdater ( AbstractFuture . class , Listener . class , <str> ) , newUpdater ( AbstractFuture . class , Object . class , <str> ) ) ; } catch ( Throwable atomicReferenceFieldUpdaterFailure ) { log . log ( Level . SEVERE , <str> , unsafeFailure ) ; log . log ( Level . SEVERE , <str> , atomicReferenceFieldUpdaterFailure ) ; helper = new SynchronizedHelper ( ) ; } } ATOMIC_HELPER = helper ; @SuppressWarnings ( <str> ) Class < ? > ensureLoaded = LockSupport . class ; } private static final class Waiter { static final Waiter TOMBSTONE = new Waiter ( false ) ; @Nullable volatile Thread thread ; @Nullable volatile Waiter next ; Waiter ( boolean unused ) { } Waiter ( ) { ATOMIC_HELPER . putThread ( this , Thread . currentThread ( ) ) ; } void setNext ( Waiter next ) { ATOMIC_HELPER . putNext ( this , next ) ; } void unpark ( ) { Thread w = thread ; if ( w ! = null ) { thread = null ; LockSupport . unpark ( w ) ; } } } private void removeWaiter ( Waiter node ) { node . thread = null ; restart : while ( true ) { Waiter pred = null ; Waiter curr = waiters ; if ( curr = = Waiter . TOMBSTONE ) { return ; } Waiter succ ; while ( curr ! = null ) { succ = curr . next ; if ( curr . thread ! = null ) { pred = curr ; } else if ( pred ! = null ) { pred . next = succ ; if ( pred . thread = = null ) { continue restart ; } } else if ( ! ATOMIC_HELPER . casWaiters ( this , curr , succ ) ) { continue restart ; } curr = succ ; } break ; } } private static final class Listener { static final Listener TOMBSTONE = new Listener ( null , null ) ; final Runnable task ; final Executor executor ; @Nullable Listener next ; Listener ( Runnable task , Executor executor ) { this . task = task ; this . executor = executor ; } } private static final Object NULL = new Object ( ) ; private static final class Failure { static final Failure FALLBACK_INSTANCE = new Failure ( new Throwable ( <str> ) { @Override public synchronized Throwable fillInStackTrace ( ) { return this ; } } ) ; final Throwable exception ; Failure ( Throwable exception ) { this . exception = checkNotNull ( exception ) ; } } private static final class Cancellation { final boolean wasInterrupted ; @Nullable final Throwable cause ; Cancellation ( boolean wasInterrupted , @Nullable Throwable cause ) { this . wasInterrupted = wasInterrupted ; this . cause = cause ; } } private final class SetFuture implements Runnable { final ListenableFuture < ? extends V > future ; SetFuture ( ListenableFuture < ? extends V > future ) { this . future = future ; } @Override public void run ( ) { if ( value ! = this ) { return ; } completeWithFuture ( future , this ) ; } } private volatile Object value ; private volatile Listener listeners ; private volatile Waiter waiters ; protected AbstractFuture ( ) { } @Override public V get ( long timeout , TimeUnit unit ) throws InterruptedException , TimeoutException , ExecutionException { long remainingNanos = unit . toNanos ( timeout ) ; if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } Object localValue = value ; if ( localValue ! = null & ! ( localValue instanceof AbstractFuture . SetFuture ) ) { return getDoneValue ( localValue ) ; } final long endNanos = remainingNanos > <int> ? System . nanoTime ( ) + remainingNanos : <int> ; long_wait_loop : if ( remainingNanos > = SPIN_THRESHOLD_NANOS ) { Waiter oldHead = waiters ; if ( oldHead ! = Waiter . TOMBSTONE ) { Waiter node = new Waiter ( ) ; do { node . setNext ( oldHead ) ; if ( ATOMIC_HELPER . casWaiters ( this , oldHead , node ) ) { while ( true ) { LockSupport . parkNanos ( this , remainingNanos ) ; if ( Thread . interrupted ( ) ) { removeWaiter ( node ) ; throw new InterruptedException ( ) ; } localValue = value ; if ( localValue ! = null & ! ( localValue instanceof AbstractFuture . SetFuture ) ) { return getDoneValue ( localValue ) ; } remainingNanos = endNanos - System . nanoTime ( ) ; if ( remainingNanos < SPIN_THRESHOLD_NANOS ) { removeWaiter ( node ) ; break long_wait_loop ; } } } oldHead = waiters ; } while ( oldHead ! = Waiter . TOMBSTONE ) ; } return getDoneValue ( value ) ; } while ( remainingNanos > <int> ) { localValue = value ; if ( localValue ! = null & ! ( localValue instanceof AbstractFuture . SetFuture ) ) { return getDoneValue ( localValue ) ; } if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } remainingNanos = endNanos - System . nanoTime ( ) ; } throw new TimeoutException ( ) ; } @Override public V get ( ) throws InterruptedException , ExecutionException { if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } Object localValue = value ; if ( localValue ! = null & ! ( localValue instanceof AbstractFuture . SetFuture ) ) { return getDoneValue ( localValue ) ; } Waiter oldHead = waiters ; if ( oldHead ! = Waiter . TOMBSTONE ) { Waiter node = new Waiter ( ) ; do { node . setNext ( oldHead ) ; if ( ATOMIC_HELPER . casWaiters ( this , oldHead , node ) ) { while ( true ) { LockSupport . park ( this ) ; if ( Thread . interrupted ( ) ) { removeWaiter ( node ) ; throw new InterruptedException ( ) ; } localValue = value ; if ( localValue ! = null & ! ( localValue instanceof AbstractFuture . SetFuture ) ) { return getDoneValue ( localValue ) ; } } } oldHead = waiters ; } while ( oldHead ! = Waiter . TOMBSTONE ) ; } return getDoneValue ( value ) ; } private V getDoneValue ( Object obj ) throws ExecutionException { if ( obj instanceof Cancellation ) { throw cancellationExceptionWithCause ( <str> , ( ( Cancellation ) obj ) . cause ) ; } else if ( obj instanceof Failure ) { throw new ExecutionException ( ( ( Failure ) obj ) . exception ) ; } else if ( obj = = NULL ) { return null ; } else { @SuppressWarnings ( <str> ) V asV = ( V ) obj ; return asV ; } } @Override public boolean isDone ( ) { final Object localValue = value ; return localValue ! = null & ! ( localValue instanceof AbstractFuture . SetFuture ) ; } @Override public boolean isCancelled ( ) { final Object localValue = value ; return localValue instanceof Cancellation ; } @Override public boolean cancel ( boolean mayInterruptIfRunning ) { Object localValue = value ; if ( localValue = = null | localValue instanceof AbstractFuture . SetFuture ) { Throwable cause = GENERATE_CANCELLATION_CAUSES ? new CancellationException ( <str> ) : null ; Object valueToSet = new Cancellation ( mayInterruptIfRunning , cause ) ; do { if ( ATOMIC_HELPER . casValue ( this , localValue , valueToSet ) ) { if ( mayInterruptIfRunning ) { interruptTask ( ) ; } complete ( ) ; if ( localValue instanceof AbstractFuture . SetFuture ) { ( ( AbstractFuture < ? > . SetFuture ) localValue ) . future . cancel ( mayInterruptIfRunning ) ; } return true ; } localValue = value ; } while ( localValue instanceof AbstractFuture . SetFuture ) ; } return false ; } protected void interruptTask ( ) { } protected final boolean wasInterrupted ( ) { final Object localValue = value ; return ( localValue instanceof Cancellation ) & & ( ( Cancellation ) localValue ) . wasInterrupted ; } @Override public void addListener ( Runnable listener , Executor executor ) { checkNotNull ( listener , <str> ) ; checkNotNull ( executor , <str> ) ; Listener oldHead = listeners ; if ( oldHead ! = Listener . TOMBSTONE ) { Listener newNode = new Listener ( listener , executor ) ; do { newNode . next = oldHead ; if ( ATOMIC_HELPER . casListeners ( this , oldHead , newNode ) ) { return ; } oldHead = listeners ; } while ( oldHead ! = Listener . TOMBSTONE ) ; } executeListener ( listener , executor ) ; } protected boolean set ( @Nullable V value ) { Object valueToSet = value = = null ? NULL : value ; if ( ATOMIC_HELPER . casValue ( this , null , valueToSet ) ) { complete ( ) ; return true ; } return false ; } protected boolean setException ( Throwable throwable ) { Object valueToSet = new Failure ( checkNotNull ( throwable ) ) ; if ( ATOMIC_HELPER . casValue ( this , null , valueToSet ) ) { complete ( ) ; return true ; } return false ; } @Beta protected boolean setFuture ( ListenableFuture < ? extends V > future ) { checkNotNull ( future ) ; Object localValue = value ; if ( localValue = = null ) { if ( future . isDone ( ) ) { return completeWithFuture ( future , null ) ; } SetFuture valueToSet = new SetFuture ( future ) ; if ( ATOMIC_HELPER . casValue ( this , null , valueToSet ) ) { try { future . addListener ( valueToSet , directExecutor ( ) ) ; } catch ( Throwable t ) { Failure failure ; try { failure = new Failure ( t ) ; } catch ( Throwable oomMostLikely ) { failure = Failure . FALLBACK_INSTANCE ; } ATOMIC_HELPER . casValue ( this , valueToSet , failure ) ; } return true ; } localValue = value ; } if ( localValue instanceof Cancellation ) { future . cancel ( ( ( Cancellation ) localValue ) . wasInterrupted ) ; } return false ; } private boolean completeWithFuture ( ListenableFuture < ? extends V > future , Object expected ) { Object valueToSet ; if ( future instanceof TrustedFuture ) { valueToSet = ( ( AbstractFuture < ? > ) future ) . value ; } else { try { V v = Uninterruptibles . getUninterruptibly ( future ) ; valueToSet = v = = null ? NULL : v ; } catch ( ExecutionException exception ) { valueToSet = new Failure ( exception . getCause ( ) ) ; } catch ( CancellationException cancellation ) { valueToSet = new Cancellation ( false , cancellation ) ; } catch ( Throwable t ) { valueToSet = new Failure ( t ) ; } } if ( ATOMIC_HELPER . casValue ( AbstractFuture . this , expected , valueToSet ) ) { complete ( ) ; return true ; } return false ; } private void complete ( ) { for ( Waiter currentWaiter = clearWaiters ( ) ; currentWaiter ! = null ; currentWaiter = currentWaiter . next ) { currentWaiter . unpark ( ) ; } Listener currentListener = clearListeners ( ) ; Listener reversedList = null ; while ( currentListener ! = null ) { Listener tmp = currentListener ; currentListener = currentListener . next ; tmp . next = reversedList ; reversedList = tmp ; } for ( ; reversedList ! = null ; reversedList = reversedList . next ) { executeListener ( reversedList . task , reversedList . executor ) ; } done ( ) ; } void done ( ) { } final Throwable trustedGetException ( ) { return ( ( Failure ) value ) . exception ; } final void maybePropagateCancellation ( @Nullable Future < ? > related ) { if ( related ! = null & isCancelled ( ) ) { related . cancel ( wasInterrupted ( ) ) ; } } private Waiter clearWaiters ( ) { Waiter head ; do { head = waiters ; } while ( ! ATOMIC_HELPER . casWaiters ( this , head , Waiter . TOMBSTONE ) ) ; return head ; } private Listener clearListeners ( ) { Listener head ; do { head = listeners ; } while ( ! ATOMIC_HELPER . casListeners ( this , head , Listener . TOMBSTONE ) ) ; return head ; } private static void executeListener ( Runnable runnable , Executor executor ) { try { executor . execute ( runnable ) ; } catch ( RuntimeException e ) { log . log ( Level . SEVERE , <str> + runnable + <str> + executor , e ) ; } } static final CancellationException cancellationExceptionWithCause ( @Nullable String message , @Nullable Throwable cause ) { CancellationException exception = new CancellationException ( message ) ; exception . initCause ( cause ) ; return exception ; } private abstract static class AtomicHelper { abstract void putThread ( Waiter waiter , Thread newValue ) ; abstract void putNext ( Waiter waiter , Waiter newValue ) ; abstract boolean casWaiters ( AbstractFuture < ? > future , Waiter expect , Waiter update ) ; abstract boolean casListeners ( AbstractFuture < ? > future , Listener expect , Listener update ) ; abstract boolean casValue ( AbstractFuture < ? > future , Object expect , Object update ) ; } private static final class UnsafeAtomicHelper extends AtomicHelper { static final sun . misc . Unsafe UNSAFE ; static final long LISTENERS_OFFSET ; static final long WAITERS_OFFSET ; static final long VALUE_OFFSET ; static final long WAITER_THREAD_OFFSET ; static final long WAITER_NEXT_OFFSET ; static { sun . misc . Unsafe unsafe = null ; try { unsafe = sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { try { unsafe = AccessController . doPrivileged ( new PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { @Override public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) { return k . cast ( x ) ; } } throw new NoSuchFieldError ( <str> ) ; } } ) ; } catch ( PrivilegedActionException e ) { throw new RuntimeException ( <str> , e . getCause ( ) ) ; } } try { Class < ? > abstractFuture = AbstractFuture . class ; WAITERS_OFFSET = unsafe . objectFieldOffset ( abstractFuture . getDeclaredField ( <str> ) ) ; LISTENERS_OFFSET = unsafe . objectFieldOffset ( abstractFuture . getDeclaredField ( <str> ) ) ; VALUE_OFFSET = unsafe . objectFieldOffset ( abstractFuture . getDeclaredField ( <str> ) ) ; WAITER_THREAD_OFFSET = unsafe . objectFieldOffset ( Waiter . class . getDeclaredField ( <str> ) ) ; WAITER_NEXT_OFFSET = unsafe . objectFieldOffset ( Waiter . class . getDeclaredField ( <str> ) ) ; UNSAFE = unsafe ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } } @Override void putThread ( Waiter waiter , Thread newValue ) { UNSAFE . putObject ( waiter , WAITER_THREAD_OFFSET , newValue ) ; } @Override void putNext ( Waiter waiter , Waiter newValue ) { UNSAFE . putObject ( waiter , WAITER_NEXT_OFFSET , newValue ) ; } @Override boolean casWaiters ( AbstractFuture < ? > future , Waiter expect , Waiter update ) { return UNSAFE . compareAndSwapObject ( future , WAITERS_OFFSET , expect , update ) ; } @Override boolean casListeners ( AbstractFuture < ? > future , Listener expect , Listener update ) { return UNSAFE . compareAndSwapObject ( future , LISTENERS_OFFSET , expect , update ) ; } @Override boolean casValue ( AbstractFuture < ? > future , Object expect , Object update ) { return UNSAFE . compareAndSwapObject ( future , VALUE_OFFSET , expect , update ) ; } } private static final class SafeAtomicHelper extends AtomicHelper { final AtomicReferenceFieldUpdater < Waiter , Thread > waiterThreadUpdater ; final AtomicReferenceFieldUpdater < Waiter , Waiter > waiterNextUpdater ; final AtomicReferenceFieldUpdater < AbstractFuture , Waiter > waitersUpdater ; final AtomicReferenceFieldUpdater < AbstractFuture , Listener > listenersUpdater ; final AtomicReferenceFieldUpdater < AbstractFuture , Object > valueUpdater ; SafeAtomicHelper ( AtomicReferenceFieldUpdater < Waiter , Thread > waiterThreadUpdater , AtomicReferenceFieldUpdater < Waiter , Waiter > waiterNextUpdater , AtomicReferenceFieldUpdater < AbstractFuture , Waiter > waitersUpdater , AtomicReferenceFieldUpdater < AbstractFuture , Listener > listenersUpdater , AtomicReferenceFieldUpdater < AbstractFuture , Object > valueUpdater ) { this . waiterThreadUpdater = waiterThreadUpdater ; this . waiterNextUpdater = waiterNextUpdater ; this . waitersUpdater = waitersUpdater ; this . listenersUpdater = listenersUpdater ; this . valueUpdater = valueUpdater ; } @Override void putThread ( Waiter waiter , Thread newValue ) { waiterThreadUpdater . lazySet ( waiter , newValue ) ; } @Override void putNext ( Waiter waiter , Waiter newValue ) { waiterNextUpdater . lazySet ( waiter , newValue ) ; } @Override boolean casWaiters ( AbstractFuture < ? > future , Waiter expect , Waiter update ) { return waitersUpdater . compareAndSet ( future , expect , update ) ; } @Override boolean casListeners ( AbstractFuture < ? > future , Listener expect , Listener update ) { return listenersUpdater . compareAndSet ( future , expect , update ) ; } @Override boolean casValue ( AbstractFuture < ? > future , Object expect , Object update ) { return valueUpdater . compareAndSet ( future , expect , update ) ; } } private static final class SynchronizedHelper extends AtomicHelper { @Override void putThread ( Waiter waiter , Thread newValue ) { waiter . thread = newValue ; } @Override void putNext ( Waiter waiter , Waiter newValue ) { waiter . next = newValue ; } @Override boolean casWaiters ( AbstractFuture < ? > future , Waiter expect , Waiter update ) { synchronized ( future ) { if ( future . waiters = = expect ) { future . waiters = update ; return true ; } return false ; } } @Override boolean casListeners ( AbstractFuture < ? > future , Listener expect , Listener update ) { synchronized ( future ) { if ( future . listeners = = expect ) { future . listeners = update ; return true ; } return false ; } } @Override boolean casValue ( AbstractFuture < ? > future , Object expect , Object update ) { synchronized ( future ) { if ( future . value = = expect ) { future . value = update ; return true ; } return false ; } } } } 
