package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . base . Throwables ; import com . google . j2objc . annotations . Weak ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . ReentrantLock ; import javax . annotation . concurrent . GuardedBy ; @Beta public final class Monitor { @Beta public abstract static class Guard { @Weak final Monitor monitor ; final Condition condition ; @GuardedBy ( <str> ) int waiterCount = <int> ; @GuardedBy ( <str> ) Guard next ; protected Guard ( Monitor monitor ) { this . monitor = checkNotNull ( monitor , <str> ) ; this . condition = monitor . lock . newCondition ( ) ; } public abstract boolean isSatisfied ( ) ; } private final boolean fair ; private final ReentrantLock lock ; @GuardedBy ( <str> ) private Guard activeGuards = null ; public Monitor ( ) { this ( false ) ; } public Monitor ( boolean fair ) { this . fair = fair ; this . lock = new ReentrantLock ( fair ) ; } public void enter ( ) { lock . lock ( ) ; } public void enterInterruptibly ( ) throws InterruptedException { lock . lockInterruptibly ( ) ; } public boolean enter ( long time , TimeUnit unit ) { final long timeoutNanos = toSafeNanos ( time , unit ) ; final ReentrantLock lock = this . lock ; if ( ! fair & & lock . tryLock ( ) ) { return true ; } boolean interrupted = Thread . interrupted ( ) ; try { final long startTime = System . nanoTime ( ) ; for ( long remainingNanos = timeoutNanos ; ; ) { try { return lock . tryLock ( remainingNanos , TimeUnit . NANOSECONDS ) ; } catch ( InterruptedException interrupt ) { interrupted = true ; remainingNanos = remainingNanos ( startTime , timeoutNanos ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } public boolean enterInterruptibly ( long time , TimeUnit unit ) throws InterruptedException { return lock . tryLock ( time , unit ) ; } public boolean tryEnter ( ) { return lock . tryLock ( ) ; } public void enterWhen ( Guard guard ) throws InterruptedException { if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } final ReentrantLock lock = this . lock ; boolean signalBeforeWaiting = lock . isHeldByCurrentThread ( ) ; lock . lockInterruptibly ( ) ; boolean satisfied = false ; try { if ( ! guard . isSatisfied ( ) ) { await ( guard , signalBeforeWaiting ) ; } satisfied = true ; } finally { if ( ! satisfied ) { leave ( ) ; } } } public void enterWhenUninterruptibly ( Guard guard ) { if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } final ReentrantLock lock = this . lock ; boolean signalBeforeWaiting = lock . isHeldByCurrentThread ( ) ; lock . lock ( ) ; boolean satisfied = false ; try { if ( ! guard . isSatisfied ( ) ) { awaitUninterruptibly ( guard , signalBeforeWaiting ) ; } satisfied = true ; } finally { if ( ! satisfied ) { leave ( ) ; } } } public boolean enterWhen ( Guard guard , long time , TimeUnit unit ) throws InterruptedException { final long timeoutNanos = toSafeNanos ( time , unit ) ; if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } final ReentrantLock lock = this . lock ; boolean reentrant = lock . isHeldByCurrentThread ( ) ; long startTime = <int> L ; locked: { if ( ! fair ) { if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } if ( lock . tryLock ( ) ) { break locked ; } } startTime = initNanoTime ( timeoutNanos ) ; if ( ! lock . tryLock ( time , unit ) ) { return false ; } } boolean satisfied = false ; boolean threw = true ; try { satisfied = guard . isSatisfied ( ) | | awaitNanos ( guard , ( startTime = = <int> L ) ? timeoutNanos : remainingNanos ( startTime , timeoutNanos ) , reentrant ) ; threw = false ; return satisfied ; } finally { if ( ! satisfied ) { try { if ( threw & & ! reentrant ) { signalNextWaiter ( ) ; } } finally { lock . unlock ( ) ; } } } } public boolean enterWhenUninterruptibly ( Guard guard , long time , TimeUnit unit ) { final long timeoutNanos = toSafeNanos ( time , unit ) ; if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } final ReentrantLock lock = this . lock ; long startTime = <int> L ; boolean signalBeforeWaiting = lock . isHeldByCurrentThread ( ) ; boolean interrupted = Thread . interrupted ( ) ; try { if ( fair | | ! lock . tryLock ( ) ) { startTime = initNanoTime ( timeoutNanos ) ; for ( long remainingNanos = timeoutNanos ; ; ) { try { if ( lock . tryLock ( remainingNanos , TimeUnit . NANOSECONDS ) ) { break ; } else { return false ; } } catch ( InterruptedException interrupt ) { interrupted = true ; remainingNanos = remainingNanos ( startTime , timeoutNanos ) ; } } } boolean satisfied = false ; try { while ( true ) { try { if ( guard . isSatisfied ( ) ) { satisfied = true ; } else { final long remainingNanos ; if ( startTime = = <int> L ) { startTime = initNanoTime ( timeoutNanos ) ; remainingNanos = timeoutNanos ; } else { remainingNanos = remainingNanos ( startTime , timeoutNanos ) ; } satisfied = awaitNanos ( guard , remainingNanos , signalBeforeWaiting ) ; } return satisfied ; } catch ( InterruptedException interrupt ) { interrupted = true ; signalBeforeWaiting = false ; } } } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } public boolean enterIf ( Guard guard ) { if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } final ReentrantLock lock = this . lock ; lock . lock ( ) ; boolean satisfied = false ; try { return satisfied = guard . isSatisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } } public boolean enterIfInterruptibly ( Guard guard ) throws InterruptedException { if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } final ReentrantLock lock = this . lock ; lock . lockInterruptibly ( ) ; boolean satisfied = false ; try { return satisfied = guard . isSatisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } } public boolean enterIf ( Guard guard , long time , TimeUnit unit ) { if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } if ( ! enter ( time , unit ) ) { return false ; } boolean satisfied = false ; try { return satisfied = guard . isSatisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } } public boolean enterIfInterruptibly ( Guard guard , long time , TimeUnit unit ) throws InterruptedException { if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } final ReentrantLock lock = this . lock ; if ( ! lock . tryLock ( time , unit ) ) { return false ; } boolean satisfied = false ; try { return satisfied = guard . isSatisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } } public boolean tryEnterIf ( Guard guard ) { if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } final ReentrantLock lock = this . lock ; if ( ! lock . tryLock ( ) ) { return false ; } boolean satisfied = false ; try { return satisfied = guard . isSatisfied ( ) ; } finally { if ( ! satisfied ) { lock . unlock ( ) ; } } } public void waitFor ( Guard guard ) throws InterruptedException { if ( ! ( ( guard . monitor = = this ) & lock . isHeldByCurrentThread ( ) ) ) { throw new IllegalMonitorStateException ( ) ; } if ( ! guard . isSatisfied ( ) ) { await ( guard , true ) ; } } public void waitForUninterruptibly ( Guard guard ) { if ( ! ( ( guard . monitor = = this ) & lock . isHeldByCurrentThread ( ) ) ) { throw new IllegalMonitorStateException ( ) ; } if ( ! guard . isSatisfied ( ) ) { awaitUninterruptibly ( guard , true ) ; } } public boolean waitFor ( Guard guard , long time , TimeUnit unit ) throws InterruptedException { final long timeoutNanos = toSafeNanos ( time , unit ) ; if ( ! ( ( guard . monitor = = this ) & lock . isHeldByCurrentThread ( ) ) ) { throw new IllegalMonitorStateException ( ) ; } if ( guard . isSatisfied ( ) ) { return true ; } if ( Thread . interrupted ( ) ) { throw new InterruptedException ( ) ; } return awaitNanos ( guard , timeoutNanos , true ) ; } public boolean waitForUninterruptibly ( Guard guard , long time , TimeUnit unit ) { final long timeoutNanos = toSafeNanos ( time , unit ) ; if ( ! ( ( guard . monitor = = this ) & lock . isHeldByCurrentThread ( ) ) ) { throw new IllegalMonitorStateException ( ) ; } if ( guard . isSatisfied ( ) ) { return true ; } boolean signalBeforeWaiting = true ; final long startTime = initNanoTime ( timeoutNanos ) ; boolean interrupted = Thread . interrupted ( ) ; try { for ( long remainingNanos = timeoutNanos ; ; ) { try { return awaitNanos ( guard , remainingNanos , signalBeforeWaiting ) ; } catch ( InterruptedException interrupt ) { interrupted = true ; if ( guard . isSatisfied ( ) ) { return true ; } signalBeforeWaiting = false ; remainingNanos = remainingNanos ( startTime , timeoutNanos ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } public void leave ( ) { final ReentrantLock lock = this . lock ; try { if ( lock . getHoldCount ( ) = = <int> ) { signalNextWaiter ( ) ; } } finally { lock . unlock ( ) ; } } public boolean isFair ( ) { return fair ; } public boolean isOccupied ( ) { return lock . isLocked ( ) ; } public boolean isOccupiedByCurrentThread ( ) { return lock . isHeldByCurrentThread ( ) ; } public int getOccupiedDepth ( ) { return lock . getHoldCount ( ) ; } public int getQueueLength ( ) { return lock . getQueueLength ( ) ; } public boolean hasQueuedThreads ( ) { return lock . hasQueuedThreads ( ) ; } public boolean hasQueuedThread ( Thread thread ) { return lock . hasQueuedThread ( thread ) ; } public boolean hasWaiters ( Guard guard ) { return getWaitQueueLength ( guard ) > <int> ; } public int getWaitQueueLength ( Guard guard ) { if ( guard . monitor ! = this ) { throw new IllegalMonitorStateException ( ) ; } lock . lock ( ) ; try { return guard . waiterCount ; } finally { lock . unlock ( ) ; } } private static long toSafeNanos ( long time , TimeUnit unit ) { long timeoutNanos = unit . toNanos ( time ) ; return ( timeoutNanos < = <int> L ) ? <int> L : ( timeoutNanos > ( Long . MAX_VALUE / <int> ) * <int> ) ? ( Long . MAX_VALUE / <int> ) * <int> : timeoutNanos ; } private static long initNanoTime ( long timeoutNanos ) { if ( timeoutNanos < = <int> L ) { return <int> L ; } else { long startTime = System . nanoTime ( ) ; return ( startTime = = <int> L ) ? <int> : startTime ; } } private static long remainingNanos ( long startTime , long timeoutNanos ) { return ( timeoutNanos < = <int> L ) ? <int> L : timeoutNanos - ( System . nanoTime ( ) - startTime ) ; } @GuardedBy ( <str> ) private void signalNextWaiter ( ) { for ( Guard guard = activeGuards ; guard ! = null ; guard = guard . next ) { if ( isSatisfied ( guard ) ) { guard . condition . signal ( ) ; break ; } } } @GuardedBy ( <str> ) private boolean isSatisfied ( Guard guard ) { try { return guard . isSatisfied ( ) ; } catch ( Throwable throwable ) { signalAllWaiters ( ) ; throw Throwables . propagate ( throwable ) ; } } @GuardedBy ( <str> ) private void signalAllWaiters ( ) { for ( Guard guard = activeGuards ; guard ! = null ; guard = guard . next ) { guard . condition . signalAll ( ) ; } } @GuardedBy ( <str> ) private void beginWaitingFor ( Guard guard ) { int waiters = guard . waiterCount + + ; if ( waiters = = <int> ) { guard . next = activeGuards ; activeGuards = guard ; } } @GuardedBy ( <str> ) private void endWaitingFor ( Guard guard ) { int waiters = - - guard . waiterCount ; if ( waiters = = <int> ) { for ( Guard p = activeGuards , pred = null ; ; pred = p , p = p . next ) { if ( p = = guard ) { if ( pred = = null ) { activeGuards = p . next ; } else { pred . next = p . next ; } p . next = null ; break ; } } } } @GuardedBy ( <str> ) private void await ( Guard guard , boolean signalBeforeWaiting ) throws InterruptedException { if ( signalBeforeWaiting ) { signalNextWaiter ( ) ; } beginWaitingFor ( guard ) ; try { do { guard . condition . await ( ) ; } while ( ! guard . isSatisfied ( ) ) ; } finally { endWaitingFor ( guard ) ; } } @GuardedBy ( <str> ) private void awaitUninterruptibly ( Guard guard , boolean signalBeforeWaiting ) { if ( signalBeforeWaiting ) { signalNextWaiter ( ) ; } beginWaitingFor ( guard ) ; try { do { guard . condition . awaitUninterruptibly ( ) ; } while ( ! guard . isSatisfied ( ) ) ; } finally { endWaitingFor ( guard ) ; } } @GuardedBy ( <str> ) private boolean awaitNanos ( Guard guard , long nanos , boolean signalBeforeWaiting ) throws InterruptedException { boolean firstTime = true ; try { do { if ( nanos < = <int> L ) { return false ; } if ( firstTime ) { if ( signalBeforeWaiting ) { signalNextWaiter ( ) ; } beginWaitingFor ( guard ) ; firstTime = false ; } nanos = guard . condition . awaitNanos ( nanos ) ; } while ( ! guard . isSatisfied ( ) ) ; return true ; } finally { if ( ! firstTime ) { endWaitingFor ( guard ) ; } } } } 
