package io . netty . channel . oio ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . socket . oio . OioServerSocketChannel ; import io . netty . channel . socket . oio . OioSocketChannel ; import io . netty . util . NetUtil ; import org . junit . Test ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . util . concurrent . CountDownLatch ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; public class OioEventLoopTest { @Test public void testTooManyServerChannels ( ) throws Exception { EventLoopGroup g = new OioEventLoopGroup ( <int> ) ; ServerBootstrap b = new ServerBootstrap ( ) ; b . channel ( OioServerSocketChannel . class ) ; b . group ( g ) ; b . childHandler ( new ChannelInboundHandlerAdapter ( ) ) ; ChannelFuture f1 = b . bind ( <int> ) ; f1 . sync ( ) ; ChannelFuture f2 = b . bind ( <int> ) ; f2 . await ( ) ; assertThat ( f2 . cause ( ) , is ( instanceOf ( ChannelException . class ) ) ) ; assertThat ( f2 . cause ( ) . getMessage ( ) . toLowerCase ( ) , containsString ( <str> ) ) ; final CountDownLatch notified = new CountDownLatch ( <int> ) ; f2 . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { notified . countDown ( ) ; } } ) ; notified . await ( ) ; g . shutdownGracefully ( ) ; } @Test public void testTooManyClientChannels ( ) throws Exception { EventLoopGroup g = new OioEventLoopGroup ( <int> ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . channel ( OioServerSocketChannel . class ) ; sb . group ( g ) ; sb . childHandler ( new ChannelInboundHandlerAdapter ( ) ) ; ChannelFuture f1 = sb . bind ( <int> ) ; f1 . sync ( ) ; Bootstrap cb = new Bootstrap ( ) ; cb . channel ( OioSocketChannel . class ) ; cb . group ( g ) ; cb . handler ( new ChannelInboundHandlerAdapter ( ) ) ; ChannelFuture f2 = cb . connect ( NetUtil . LOCALHOST , ( ( InetSocketAddress ) f1 . channel ( ) . localAddress ( ) ) . getPort ( ) ) ; f2 . await ( ) ; assertThat ( f2 . cause ( ) , is ( instanceOf ( ChannelException . class ) ) ) ; assertThat ( f2 . cause ( ) . getMessage ( ) . toLowerCase ( ) , containsString ( <str> ) ) ; final CountDownLatch notified = new CountDownLatch ( <int> ) ; f2 . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { notified . countDown ( ) ; } } ) ; notified . await ( ) ; g . shutdownGracefully ( ) ; } @Test public void testTooManyAcceptedChannels ( ) throws Exception { EventLoopGroup g = new OioEventLoopGroup ( <int> ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . channel ( OioServerSocketChannel . class ) ; sb . group ( g ) ; sb . childHandler ( new ChannelInboundHandlerAdapter ( ) ) ; ChannelFuture f1 = sb . bind ( <int> ) ; f1 . sync ( ) ; Socket s = new Socket ( NetUtil . LOCALHOST , ( ( InetSocketAddress ) f1 . channel ( ) . localAddress ( ) ) . getPort ( ) ) ; assertThat ( s . getInputStream ( ) . read ( ) , is ( - <int> ) ) ; s . close ( ) ; g . shutdownGracefully ( ) ; } } 
