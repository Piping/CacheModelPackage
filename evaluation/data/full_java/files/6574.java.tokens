package org . elasticsearch . index . mapper . internal ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . IndexOptions ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . AlreadyExpiredException ; import org . elasticsearch . index . analysis . NumericLongAnalyzer ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . MergeResult ; import org . elasticsearch . index . mapper . MetadataFieldMapper ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . SourceToParse ; import org . elasticsearch . index . mapper . core . LongFieldMapper ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . Date ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeBooleanValue ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeTimeValue ; public class TTLFieldMapper extends MetadataFieldMapper { public static final String NAME = <str> ; public static final String CONTENT_TYPE = <str> ; public static class Defaults extends LongFieldMapper . Defaults { public static final String NAME = TTLFieldMapper . CONTENT_TYPE ; public static final TTLFieldType TTL_FIELD_TYPE = new TTLFieldType ( ) ; static { TTL_FIELD_TYPE . setIndexOptions ( IndexOptions . DOCS ) ; TTL_FIELD_TYPE . setStored ( true ) ; TTL_FIELD_TYPE . setTokenized ( false ) ; TTL_FIELD_TYPE . setNumericPrecisionStep ( Defaults . PRECISION_STEP_64_BIT ) ; TTL_FIELD_TYPE . setIndexAnalyzer ( NumericLongAnalyzer . buildNamedAnalyzer ( Defaults . PRECISION_STEP_64_BIT ) ) ; TTL_FIELD_TYPE . setSearchAnalyzer ( NumericLongAnalyzer . buildNamedAnalyzer ( Integer . MAX_VALUE ) ) ; TTL_FIELD_TYPE . setNames ( new MappedFieldType . Names ( NAME ) ) ; TTL_FIELD_TYPE . freeze ( ) ; } public static final EnabledAttributeMapper ENABLED_STATE = EnabledAttributeMapper . UNSET_DISABLED ; public static final long DEFAULT = - <int> ; } public static class Builder extends MetadataFieldMapper . Builder < Builder , TTLFieldMapper > { private EnabledAttributeMapper enabledState = EnabledAttributeMapper . UNSET_DISABLED ; private long defaultTTL = Defaults . DEFAULT ; public Builder ( ) { super ( Defaults . NAME , Defaults . TTL_FIELD_TYPE ) ; } public Builder enabled ( EnabledAttributeMapper enabled ) { this . enabledState = enabled ; return builder ; } public Builder defaultTTL ( long defaultTTL ) { this . defaultTTL = defaultTTL ; return builder ; } @Override public TTLFieldMapper build ( BuilderContext context ) { setupFieldType ( context ) ; fieldType . setHasDocValues ( false ) ; return new TTLFieldMapper ( fieldType , enabledState , defaultTTL , fieldDataSettings , context . indexSettings ( ) ) ; } } public static class TypeParser implements MetadataFieldMapper . TypeParser { @Override public MetadataFieldMapper . Builder parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { Builder builder = new Builder ( ) ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String fieldName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object fieldNode = entry . getValue ( ) ; if ( fieldName . equals ( <str> ) ) { EnabledAttributeMapper enabledState = nodeBooleanValue ( fieldNode ) ? EnabledAttributeMapper . ENABLED : EnabledAttributeMapper . DISABLED ; builder . enabled ( enabledState ) ; iterator . remove ( ) ; } else if ( fieldName . equals ( <str> ) ) { TimeValue ttlTimeValue = nodeTimeValue ( fieldNode , null ) ; if ( ttlTimeValue ! = null ) { builder . defaultTTL ( ttlTimeValue . millis ( ) ) ; } iterator . remove ( ) ; } } return builder ; } @Override public MetadataFieldMapper getDefault ( Settings indexSettings , MappedFieldType fieldType , String typeName ) { return new TTLFieldMapper ( indexSettings ) ; } } public static final class TTLFieldType extends LongFieldMapper . LongFieldType { public TTLFieldType ( ) { } protected TTLFieldType ( TTLFieldType ref ) { super ( ref ) ; } @Override public TTLFieldType clone ( ) { return new TTLFieldType ( this ) ; } @Override public Object valueForSearch ( Object value ) { long now ; SearchContext searchContext = SearchContext . current ( ) ; if ( searchContext ! = null ) { now = searchContext . nowInMillis ( ) ; } else { now = System . currentTimeMillis ( ) ; } long val = value ( value ) ; return val - now ; } } private EnabledAttributeMapper enabledState ; private long defaultTTL ; private TTLFieldMapper ( Settings indexSettings ) { this ( Defaults . TTL_FIELD_TYPE . clone ( ) , Defaults . ENABLED_STATE , Defaults . DEFAULT , null , indexSettings ) ; } private TTLFieldMapper ( MappedFieldType fieldType , EnabledAttributeMapper enabled , long defaultTTL , @Nullable Settings fieldDataSettings , Settings indexSettings ) { super ( NAME , fieldType , Defaults . TTL_FIELD_TYPE , indexSettings ) ; this . enabledState = enabled ; this . defaultTTL = defaultTTL ; } public boolean enabled ( ) { return this . enabledState . enabled ; } public long defaultTTL ( ) { return this . defaultTTL ; } public Object valueForSearch ( long expirationTime ) { return expirationTime - System . currentTimeMillis ( ) ; } @Override public void preParse ( ParseContext context ) throws IOException { } @Override public void postParse ( ParseContext context ) throws IOException { super . parse ( context ) ; } @Override public Mapper parse ( ParseContext context ) throws IOException , MapperParsingException { if ( context . sourceToParse ( ) . ttl ( ) < <int> ) { long ttl ; if ( context . parser ( ) . currentToken ( ) = = XContentParser . Token . VALUE_STRING ) { ttl = TimeValue . parseTimeValue ( context . parser ( ) . text ( ) , null , <str> ) . millis ( ) ; } else { ttl = context . parser ( ) . longValue ( true ) ; } if ( ttl < = <int> ) { throw new MapperParsingException ( <str> + ttl + <str> ) ; } context . sourceToParse ( ) . ttl ( ttl ) ; } return null ; } @Override protected void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException , AlreadyExpiredException { if ( enabledState . enabled & & ! context . sourceToParse ( ) . flyweight ( ) ) { long ttl = context . sourceToParse ( ) . ttl ( ) ; if ( ttl < = <int> & & defaultTTL > <int> ) { ttl = defaultTTL ; context . sourceToParse ( ) . ttl ( ttl ) ; } if ( ttl > <int> ) { long timestamp = context . sourceToParse ( ) . timestamp ( ) ; long expire = new Date ( timestamp + ttl ) . getTime ( ) ; long now = System . currentTimeMillis ( ) ; if ( context . sourceToParse ( ) . origin ( ) = = SourceToParse . Origin . PRIMARY & & now > = expire ) { throw new AlreadyExpiredException ( context . index ( ) , context . type ( ) , context . id ( ) , timestamp , ttl , now ) ; } fields . add ( new LongFieldMapper . CustomLongNumericField ( expire , fieldType ( ) ) ) ; } } } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { boolean includeDefaults = params . paramAsBoolean ( <str> , false ) ; if ( ! includeDefaults & & enabledState = = Defaults . ENABLED_STATE & & defaultTTL = = Defaults . DEFAULT ) { return builder ; } builder . startObject ( CONTENT_TYPE ) ; if ( includeDefaults | | enabledState ! = Defaults . ENABLED_STATE ) { builder . field ( <str> , enabledState . enabled ) ; } if ( includeDefaults | | defaultTTL ! = Defaults . DEFAULT & & enabledState . enabled ) { builder . field ( <str> , defaultTTL ) ; } builder . endObject ( ) ; return builder ; } @Override protected String contentType ( ) { return NAME ; } @Override public void merge ( Mapper mergeWith , MergeResult mergeResult ) { TTLFieldMapper ttlMergeWith = ( TTLFieldMapper ) mergeWith ; if ( ( ( TTLFieldMapper ) mergeWith ) . enabledState ! = Defaults . ENABLED_STATE ) { if ( this . enabledState = = EnabledAttributeMapper . ENABLED & & ( ( TTLFieldMapper ) mergeWith ) . enabledState = = EnabledAttributeMapper . DISABLED ) { mergeResult . addConflict ( <str> ) ; } else { if ( ! mergeResult . simulate ( ) ) { this . enabledState = ttlMergeWith . enabledState ; } } } if ( ttlMergeWith . defaultTTL ! = - <int> ) { if ( ! mergeResult . simulate ( ) & & ( enabledState = = EnabledAttributeMapper . ENABLED ) ) { this . defaultTTL = ttlMergeWith . defaultTTL ; } } } } 
