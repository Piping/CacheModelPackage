package com . badlogic . gdx . scenes . scene2d . ui ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . GlyphLayout ; import com . badlogic . gdx . scenes . scene2d . InputEvent ; import com . badlogic . gdx . scenes . scene2d . InputListener ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . utils . Drawable ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . Pool ; import com . badlogic . gdx . utils . Pools ; public class TextArea extends TextField { IntArray linesBreak ; private String lastText ; int cursorLine ; int firstLineShowing ; private int linesShowing ; float moveOffset ; private float prefRows ; public TextArea ( String text , Skin skin ) { super ( text , skin ) ; } public TextArea ( String text , Skin skin , String styleName ) { super ( text , skin , styleName ) ; } public TextArea ( String text , TextFieldStyle style ) { super ( text , style ) ; } @Override protected void initialize ( ) { super . initialize ( ) ; writeEnters = true ; linesBreak = new IntArray ( ) ; cursorLine = <int> ; firstLineShowing = <int> ; moveOffset = - <int> ; linesShowing = <int> ; } protected int letterUnderCursor ( float x ) { if ( linesBreak . size > <int> ) { if ( cursorLine * <int> > = linesBreak . size ) { return text . length ( ) ; } else { int start = linesBreak . items [ cursorLine * <int> ] ; int end = linesBreak . items [ cursorLine * <int> + <int> ] ; int i = start ; boolean found = false ; while ( i < = end & & ! found ) { if ( glyphPositions . items [ i ] - glyphPositions . items [ start ] > x ) { found = true ; } else { i + + ; } } return Math . max ( <int> , i - <int> ) ; } } else { return <int> ; } } public void setPrefRows ( float prefRows ) { this . prefRows = prefRows ; } @Override public float getPrefHeight ( ) { if ( prefRows < = <int> ) { return super . getPrefHeight ( ) ; } else { float prefHeight = textHeight * prefRows ; if ( style . background ! = null ) { prefHeight = Math . max ( prefHeight + style . background . getBottomHeight ( ) + style . background . getTopHeight ( ) , style . background . getMinHeight ( ) ) ; } return prefHeight ; } } public int getLines ( ) { return linesBreak . size / <int> + ( newLineAtEnd ( ) ? <int> : <int> ) ; } public boolean newLineAtEnd ( ) { return text . length ( ) ! = <int> & & ( text . charAt ( text . length ( ) - <int> ) = = ENTER_ANDROID | | text . charAt ( text . length ( ) - <int> ) = = ENTER_DESKTOP ) ; } public void moveCursorLine ( int line ) { if ( line < <int> ) { cursorLine = <int> ; cursor = <int> ; moveOffset = - <int> ; } else if ( line > = getLines ( ) ) { int newLine = getLines ( ) - <int> ; cursor = text . length ( ) ; if ( line > getLines ( ) | | newLine = = cursorLine ) { moveOffset = - <int> ; } cursorLine = newLine ; } else if ( line ! = cursorLine ) { if ( moveOffset < <int> ) { moveOffset = linesBreak . size < = cursorLine * <int> ? <int> : glyphPositions . get ( cursor ) - glyphPositions . get ( linesBreak . get ( cursorLine * <int> ) ) ; } cursorLine = line ; cursor = cursorLine * <int> > = linesBreak . size ? text . length ( ) : linesBreak . get ( cursorLine * <int> ) ; while ( cursor < text . length ( ) & & cursor < = linesBreak . get ( cursorLine * <int> + <int> ) - <int> & & glyphPositions . get ( cursor ) - glyphPositions . get ( linesBreak . get ( cursorLine * <int> ) ) < moveOffset ) { cursor + + ; } showCursor ( ) ; } } void updateCurrentLine ( ) { int index = calculateCurrentLineIndex ( cursor ) ; int line = index / <int> ; if ( index % <int> = = <int> | | index + <int> > = linesBreak . size | | cursor ! = linesBreak . items [ index ] | | linesBreak . items [ index + <int> ] ! = linesBreak . items [ index ] ) { if ( line < linesBreak . size / <int> | | text . length ( ) = = <int> | | text . charAt ( text . length ( ) - <int> ) = = ENTER_ANDROID | | text . charAt ( text . length ( ) - <int> ) = = ENTER_DESKTOP ) { cursorLine = line ; } } } void showCursor ( ) { updateCurrentLine ( ) ; if ( cursorLine ! = firstLineShowing ) { int step = cursorLine > = firstLineShowing ? <int> : - <int> ; while ( firstLineShowing > cursorLine | | firstLineShowing + linesShowing - <int> < cursorLine ) { firstLineShowing + = step ; } } } private int calculateCurrentLineIndex ( int cursor ) { int index = <int> ; while ( index < linesBreak . size & & cursor > linesBreak . items [ index ] ) { index + + ; } return index ; } @Override protected void sizeChanged ( ) { lastText = null ; BitmapFont font = style . font ; Drawable background = style . background ; float availableHeight = getHeight ( ) - ( background = = null ? <int> : background . getBottomHeight ( ) + background . getTopHeight ( ) ) ; linesShowing = ( int ) Math . floor ( availableHeight / font . getLineHeight ( ) ) ; } @Override protected float getTextY ( BitmapFont font , Drawable background ) { float textY = getHeight ( ) ; if ( background ! = null ) { textY = ( int ) ( textY - background . getTopHeight ( ) ) ; } return textY ; } @Override protected void drawSelection ( Drawable selection , Batch batch , BitmapFont font , float x , float y ) { int i = firstLineShowing * <int> ; float offsetY = <int> ; int minIndex = Math . min ( cursor , selectionStart ) ; int maxIndex = Math . max ( cursor , selectionStart ) ; while ( i + <int> < linesBreak . size & & i < ( firstLineShowing + linesShowing ) * <int> ) { int lineStart = linesBreak . get ( i ) ; int lineEnd = linesBreak . get ( i + <int> ) ; if ( ! ( ( minIndex < lineStart & & minIndex < lineEnd & & maxIndex < lineStart & & maxIndex < lineEnd ) | | ( minIndex > lineStart & & minIndex > lineEnd & & maxIndex > lineStart & & maxIndex > lineEnd ) ) ) { int start = Math . max ( linesBreak . get ( i ) , minIndex ) ; int end = Math . min ( linesBreak . get ( i + <int> ) , maxIndex ) ; float selectionX = glyphPositions . get ( start ) - glyphPositions . get ( linesBreak . get ( i ) ) ; float selectionWidth = glyphPositions . get ( end ) - glyphPositions . get ( start ) ; selection . draw ( batch , x + selectionX + fontOffset , y - textHeight - font . getDescent ( ) - offsetY , selectionWidth , font . getLineHeight ( ) ) ; } offsetY + = font . getLineHeight ( ) ; i + = <int> ; } } @Override protected void drawText ( Batch batch , BitmapFont font , float x , float y ) { float offsetY = <int> ; for ( int i = firstLineShowing * <int> ; i < ( firstLineShowing + linesShowing ) * <int> & & i < linesBreak . size ; i + = <int> ) { font . draw ( batch , displayText , x , y + offsetY , linesBreak . items [ i ] , linesBreak . items [ i + <int> ] , <int> , Align . left , false ) ; offsetY - = font . getLineHeight ( ) ; } } @Override protected void drawCursor ( Drawable cursorPatch , Batch batch , BitmapFont font , float x , float y ) { float textOffset = cursor > = glyphPositions . size | | cursorLine * <int> > = linesBreak . size ? <int> : glyphPositions . get ( cursor ) - glyphPositions . get ( linesBreak . items [ cursorLine * <int> ] ) ; cursorPatch . draw ( batch , x + textOffset + fontOffset + font . getData ( ) . cursorX , y - font . getDescent ( ) / <int> - ( cursorLine - firstLineShowing + <int> ) * font . getLineHeight ( ) , cursorPatch . getMinWidth ( ) , font . getLineHeight ( ) ) ; } @Override protected void calculateOffsets ( ) { super . calculateOffsets ( ) ; if ( ! this . text . equals ( lastText ) ) { this . lastText = text ; BitmapFont font = style . font ; float maxWidthLine = this . getWidth ( ) - ( style . background ! = null ? style . background . getLeftWidth ( ) + style . background . getRightWidth ( ) : <int> ) ; linesBreak . clear ( ) ; int lineStart = <int> ; int lastSpace = <int> ; char lastCharacter ; Pool < GlyphLayout > layoutPool = Pools . get ( GlyphLayout . class ) ; GlyphLayout layout = layoutPool . obtain ( ) ; for ( int i = <int> ; i < text . length ( ) ; i + + ) { lastCharacter = text . charAt ( i ) ; if ( lastCharacter = = ENTER_DESKTOP | | lastCharacter = = ENTER_ANDROID ) { linesBreak . add ( lineStart ) ; linesBreak . add ( i ) ; lineStart = i + <int> ; } else { lastSpace = ( continueCursor ( i , <int> ) ? lastSpace : i ) ; layout . setText ( font , text . subSequence ( lineStart , i + <int> ) ) ; if ( layout . width > maxWidthLine ) { if ( lineStart > = lastSpace ) { lastSpace = i - <int> ; } linesBreak . add ( lineStart ) ; linesBreak . add ( lastSpace + <int> ) ; lineStart = lastSpace + <int> ; lastSpace = lineStart ; } } } layoutPool . free ( layout ) ; if ( lineStart < text . length ( ) ) { linesBreak . add ( lineStart ) ; linesBreak . add ( text . length ( ) ) ; } showCursor ( ) ; } } @Override protected InputListener createInputListener ( ) { return new TextAreaListener ( ) ; } @Override public void setSelection ( int selectionStart , int selectionEnd ) { super . setSelection ( selectionStart , selectionEnd ) ; updateCurrentLine ( ) ; } @Override protected void moveCursor ( boolean forward , boolean jump ) { int count = forward ? <int> : - <int> ; int index = ( cursorLine * <int> ) + count ; if ( index > = <int> & & index + <int> < linesBreak . size & & linesBreak . items [ index ] = = cursor & & linesBreak . items [ index + <int> ] = = cursor ) { cursorLine + = count ; if ( jump ) { super . moveCursor ( forward , jump ) ; } showCursor ( ) ; } else { super . moveCursor ( forward , jump ) ; } updateCurrentLine ( ) ; } @Override protected boolean continueCursor ( int index , int offset ) { int pos = calculateCurrentLineIndex ( index + offset ) ; return super . continueCursor ( index , offset ) & & ( pos < <int> | | pos > = linesBreak . size - <int> | | ( linesBreak . items [ pos + <int> ] ! = index ) | | ( linesBreak . items [ pos + <int> ] = = linesBreak . items [ pos + <int> ] ) ) ; } public int getCursorLine ( ) { return cursorLine ; } public int getFirstLineShowing ( ) { return firstLineShowing ; } public int getLinesShowing ( ) { return linesShowing ; } public class TextAreaListener extends TextFieldClickListener { @Override protected void setCursorPosition ( float x , float y ) { moveOffset = - <int> ; Drawable background = style . background ; BitmapFont font = style . font ; float height = getHeight ( ) ; if ( background ! = null ) { height - = background . getTopHeight ( ) ; x - = background . getLeftWidth ( ) ; } x = Math . max ( <int> , x ) ; if ( background ! = null ) { y - = background . getTopHeight ( ) ; } cursorLine = ( int ) Math . floor ( ( height - y ) / font . getLineHeight ( ) ) + firstLineShowing ; cursorLine = Math . max ( <int> , Math . min ( cursorLine , getLines ( ) - <int> ) ) ; super . setCursorPosition ( x , y ) ; updateCurrentLine ( ) ; } @Override public boolean keyDown ( InputEvent event , int keycode ) { super . keyDown ( event , keycode ) ; Stage stage = getStage ( ) ; if ( stage ! = null & & stage . getKeyboardFocus ( ) = = TextArea . this ) { boolean repeat = false ; boolean shift = Gdx . input . isKeyPressed ( Input . Keys . SHIFT_LEFT ) | | Gdx . input . isKeyPressed ( Input . Keys . SHIFT_RIGHT ) ; if ( keycode = = Input . Keys . DOWN ) { if ( shift ) { if ( ! hasSelection ) { selectionStart = cursor ; hasSelection = true ; } } else { clearSelection ( ) ; } moveCursorLine ( cursorLine + <int> ) ; repeat = true ; } else if ( keycode = = Input . Keys . UP ) { if ( shift ) { if ( ! hasSelection ) { selectionStart = cursor ; hasSelection = true ; } } else { clearSelection ( ) ; } moveCursorLine ( cursorLine - <int> ) ; repeat = true ; } else { moveOffset = - <int> ; } if ( repeat ) { scheduleKeyRepeatTask ( keycode ) ; } showCursor ( ) ; return true ; } return false ; } @Override public boolean keyTyped ( InputEvent event , char character ) { boolean result = super . keyTyped ( event , character ) ; showCursor ( ) ; return result ; } @Override protected void goHome ( boolean jump ) { if ( jump ) { cursor = <int> ; } else if ( cursorLine * <int> < linesBreak . size ) { cursor = linesBreak . get ( cursorLine * <int> ) ; } } @Override protected void goEnd ( boolean jump ) { if ( jump | | cursorLine > = getLines ( ) ) { cursor = text . length ( ) ; } else if ( cursorLine * <int> + <int> < linesBreak . size ) { cursor = linesBreak . get ( cursorLine * <int> + <int> ) ; } } } } 
