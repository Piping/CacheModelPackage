package com . google . common . base ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . caliper . runner . CaliperMain ; import java . util . BitSet ; import java . util . Random ; public class WhitespaceMatcherBenchmark { private static final int STRING_LENGTH = <int> ; private static final String OLD_WHITESPACE_TABLE = <str> + <str> + <str> + <str> + <str> + <str> ; public static final CharMatcher OLD_WHITESPACE = new CharMatcher ( ) { @Override public boolean matches ( char c ) { return OLD_WHITESPACE_TABLE . charAt ( c % <int> ) = = c ; } } ; @Param private boolean useNew ; @Param ( { <str> , <str> , <str> } ) private int percentMatching ; private String teststring ; private CharMatcher matcher ; public static void main ( String [ ] args ) throws Exception { CaliperMain . main ( WhitespaceMatcherBenchmark . class , new String [ ] { } ) ; } @BeforeExperiment protected void setUp ( ) { BitSet bitSet = new BitSet ( ) ; for ( int i = <int> ; i < OLD_WHITESPACE_TABLE . length ( ) ; i + + ) { bitSet . set ( OLD_WHITESPACE_TABLE . charAt ( i ) ) ; } bitSet . clear ( <int> ) ; bitSet . clear ( <int> ) ; matcher = useNew ? CharMatcher . WHITESPACE : OLD_WHITESPACE ; teststring = newTestString ( new Random ( <int> ) , bitSet , percentMatching ) ; } @Benchmark public int countIn ( int reps ) { int result = <int> ; CharMatcher matcher = this . matcher ; String teststring = this . teststring ; for ( int i = <int> ; i < reps ; i + + ) { result + = matcher . countIn ( teststring ) ; } return result ; } @Benchmark public int collapseFrom ( int reps ) { int result = <int> ; CharMatcher matcher = this . matcher ; String teststring = this . teststring ; for ( int i = <int> ; i < reps ; i + + ) { result + = System . identityHashCode ( matcher . collapseFrom ( teststring , <str> ) ) ; } return result ; } private static String allMatchingChars ( BitSet bitSet ) { final char [ ] result = new char [ bitSet . cardinality ( ) ] ; for ( int j = <int> , c = bitSet . nextSetBit ( <int> ) ; j < result . length ; + + j ) { result [ j ] = ( char ) c ; c = bitSet . nextSetBit ( c + <int> ) ; } return new String ( result ) ; } private static String newTestString ( Random random , BitSet bitSet , int percentMatching ) { final String allMatchingChars = allMatchingChars ( bitSet ) ; final char [ ] result = new char [ STRING_LENGTH ] ; for ( int i = <int> ; i < result . length ; i + + ) { result [ i ] = allMatchingChars . charAt ( random . nextInt ( allMatchingChars . length ( ) ) ) ; } int remaining = ( int ) ( ( <int> - percentMatching ) * result . length / <float> + <float> ) ; while ( remaining > <int> ) { final char c = ( char ) random . nextInt ( ) ; if ( bitSet . get ( c ) ) { final int pos = random . nextInt ( result . length ) ; if ( bitSet . get ( result [ pos ] ) ) { result [ pos ] = c ; remaining - - ; } } } return new String ( result ) ; } } 
