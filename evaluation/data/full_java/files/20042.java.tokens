package io . netty . handler . stream ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import java . io . ByteArrayInputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . channels . Channels ; import java . util . concurrent . atomic . AtomicBoolean ; import static io . netty . util . ReferenceCountUtil . * ; import static org . junit . Assert . * ; public class ChunkedWriteHandlerTest { private static final byte [ ] BYTES = new byte [ <int> * <int> ] ; private static final File TMP ; static { for ( int i = <int> ; i < BYTES . length ; i + + ) { BYTES [ i ] = ( byte ) i ; } FileOutputStream out = null ; try { TMP = File . createTempFile ( <str> , <str> ) ; TMP . deleteOnExit ( ) ; out = new FileOutputStream ( TMP ) ; out . write ( BYTES ) ; out . flush ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { if ( out ! = null ) { try { out . close ( ) ; } catch ( IOException e ) { } } } } @Test public void testChunkedStream ( ) { check ( new ChunkedStream ( new ByteArrayInputStream ( BYTES ) ) ) ; check ( new ChunkedStream ( new ByteArrayInputStream ( BYTES ) ) , new ChunkedStream ( new ByteArrayInputStream ( BYTES ) ) , new ChunkedStream ( new ByteArrayInputStream ( BYTES ) ) ) ; } @Test public void testChunkedNioStream ( ) { check ( new ChunkedNioStream ( Channels . newChannel ( new ByteArrayInputStream ( BYTES ) ) ) ) ; check ( new ChunkedNioStream ( Channels . newChannel ( new ByteArrayInputStream ( BYTES ) ) ) , new ChunkedNioStream ( Channels . newChannel ( new ByteArrayInputStream ( BYTES ) ) ) , new ChunkedNioStream ( Channels . newChannel ( new ByteArrayInputStream ( BYTES ) ) ) ) ; } @Test public void testChunkedFile ( ) throws IOException { check ( new ChunkedFile ( TMP ) ) ; check ( new ChunkedFile ( TMP ) , new ChunkedFile ( TMP ) , new ChunkedFile ( TMP ) ) ; } @Test public void testChunkedNioFile ( ) throws IOException { check ( new ChunkedNioFile ( TMP ) ) ; check ( new ChunkedNioFile ( TMP ) , new ChunkedNioFile ( TMP ) , new ChunkedNioFile ( TMP ) ) ; } @Test public void testListenerNotifiedWhenIsEnd ( ) { ByteBuf buffer = Unpooled . copiedBuffer ( <str> , CharsetUtil . ISO_8859_1 ) ; ChunkedInput < ByteBuf > input = new ChunkedInput < ByteBuf > ( ) { private boolean done ; private final ByteBuf buffer = releaseLater ( Unpooled . copiedBuffer ( <str> , CharsetUtil . ISO_8859_1 ) ) ; @Override public boolean isEndOfInput ( ) throws Exception { return done ; } @Override public void close ( ) throws Exception { } @Override public ByteBuf readChunk ( ChannelHandlerContext ctx ) throws Exception { if ( done ) { return null ; } done = true ; return buffer . duplicate ( ) . retain ( ) ; } @Override public long length ( ) { return - <int> ; } @Override public long progress ( ) { return <int> ; } } ; final AtomicBoolean listenerNotified = new AtomicBoolean ( false ) ; final ChannelFutureListener listener = new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { listenerNotified . set ( true ) ; } } ; EmbeddedChannel ch = new EmbeddedChannel ( new ChunkedWriteHandler ( ) ) ; ch . writeAndFlush ( input ) . addListener ( listener ) . syncUninterruptibly ( ) ; ch . checkException ( ) ; ch . finish ( ) ; assertTrue ( listenerNotified . get ( ) ) ; assertEquals ( releaseLater ( buffer ) , releaseLater ( ch . readOutbound ( ) ) ) ; assertNull ( ch . readOutbound ( ) ) ; } @Test public void testChunkedMessageInput ( ) { ChunkedInput < Object > input = new ChunkedInput < Object > ( ) { private boolean done ; @Override public boolean isEndOfInput ( ) throws Exception { return done ; } @Override public void close ( ) throws Exception { } @Override public Object readChunk ( ChannelHandlerContext ctx ) throws Exception { if ( done ) { return false ; } done = true ; return <int> ; } @Override public long length ( ) { return - <int> ; } @Override public long progress ( ) { return <int> ; } } ; EmbeddedChannel ch = new EmbeddedChannel ( new ChunkedWriteHandler ( ) ) ; ch . writeAndFlush ( input ) . syncUninterruptibly ( ) ; ch . checkException ( ) ; assertTrue ( ch . finish ( ) ) ; assertEquals ( <int> , ch . readOutbound ( ) ) ; assertNull ( ch . readOutbound ( ) ) ; } private static void check ( ChunkedInput < ? > . . . inputs ) { EmbeddedChannel ch = new EmbeddedChannel ( new ChunkedWriteHandler ( ) ) ; for ( ChunkedInput < ? > input : inputs ) { ch . writeOutbound ( input ) ; } assertTrue ( ch . finish ( ) ) ; int i = <int> ; int read = <int> ; for ( ; ; ) { ByteBuf buffer = ch . readOutbound ( ) ; if ( buffer = = null ) { break ; } while ( buffer . isReadable ( ) ) { assertEquals ( BYTES [ i + + ] , buffer . readByte ( ) ) ; read + + ; if ( i = = BYTES . length ) { i = <int> ; } } buffer . release ( ) ; } assertEquals ( BYTES . length * inputs . length , read ) ; } } 
