package org . elasticsearch . cluster ; import java . util . IdentityHashMap ; import java . util . List ; import java . util . Map ; import java . util . function . Consumer ; public interface ClusterStateTaskExecutor < T > { BatchResult < T > execute ( ClusterState currentState , List < T > tasks ) throws Exception ; default boolean runOnlyOnMaster ( ) { return true ; } class BatchResult < T > { final public ClusterState resultingState ; final public Map < T , TaskResult > executionResults ; BatchResult ( ClusterState resultingState , Map < T , TaskResult > executionResults ) { this . resultingState = resultingState ; this . executionResults = executionResults ; } public static < T > Builder < T > builder ( ) { return new Builder < > ( ) ; } public static class Builder < T > { private final Map < T , TaskResult > executionResults = new IdentityHashMap < > ( ) ; public Builder < T > success ( T task ) { return result ( task , TaskResult . success ( ) ) ; } public Builder < T > successes ( Iterable < T > tasks ) { for ( T task : tasks ) { success ( task ) ; } return this ; } public Builder < T > failure ( T task , Throwable t ) { return result ( task , TaskResult . failure ( t ) ) ; } public Builder < T > failures ( Iterable < T > tasks , Throwable t ) { for ( T task : tasks ) { failure ( task , t ) ; } return this ; } private Builder < T > result ( T task , TaskResult executionResult ) { executionResults . put ( task , executionResult ) ; return this ; } public BatchResult < T > build ( ClusterState resultingState ) { return new BatchResult < > ( resultingState , executionResults ) ; } } } final class TaskResult { private final Throwable failure ; private static final TaskResult SUCCESS = new TaskResult ( null ) ; public static TaskResult success ( ) { return SUCCESS ; } public static TaskResult failure ( Throwable failure ) { return new TaskResult ( failure ) ; } private TaskResult ( Throwable failure ) { this . failure = failure ; } public boolean isSuccess ( ) { return failure ! = null ; } public void handle ( Runnable onSuccess , Consumer < Throwable > onFailure ) { if ( failure = = null ) { onSuccess . run ( ) ; } else { onFailure . accept ( failure ) ; } } } } 
