package org . elasticsearch . test . disruption ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . InternalTestCluster ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicReference ; public class BlockClusterStateProcessing extends SingleNodeDisruption { AtomicReference < CountDownLatch > disruptionLatch = new AtomicReference < > ( ) ; public BlockClusterStateProcessing ( Random random ) { this ( null , random ) ; } public BlockClusterStateProcessing ( String disruptedNode , Random random ) { super ( random ) ; this . disruptedNode = disruptedNode ; } @Override public void startDisrupting ( ) { final String disruptionNodeCopy = disruptedNode ; if ( disruptionNodeCopy = = null ) { return ; } ClusterService clusterService = cluster . getInstance ( ClusterService . class , disruptionNodeCopy ) ; if ( clusterService = = null ) { return ; } logger . info ( <str> , disruptionNodeCopy ) ; boolean success = disruptionLatch . compareAndSet ( null , new CountDownLatch ( <int> ) ) ; assert success : <str> ; final CountDownLatch started = new CountDownLatch ( <int> ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { started . countDown ( ) ; CountDownLatch latch = disruptionLatch . get ( ) ; if ( latch ! = null ) { latch . await ( ) ; } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t ) ; } } ) ; try { started . await ( ) ; } catch ( InterruptedException e ) { } } @Override public void stopDisrupting ( ) { CountDownLatch latch = disruptionLatch . get ( ) ; if ( latch ! = null ) { latch . countDown ( ) ; } } @Override public void removeAndEnsureHealthy ( InternalTestCluster cluster ) { removeFromCluster ( cluster ) ; } @Override public TimeValue expectedTimeToHeal ( ) { return TimeValue . timeValueMinutes ( <int> ) ; } } 
