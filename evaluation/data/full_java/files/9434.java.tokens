package com . google . common . io ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import com . google . common . annotations . Beta ; import java . io . Closeable ; import java . io . EOFException ; import java . io . IOException ; import java . io . Reader ; import java . io . Writer ; import java . nio . CharBuffer ; import java . util . ArrayList ; import java . util . List ; @Beta public final class CharStreams { private static final int BUF_SIZE = <hex> ; private CharStreams ( ) { } public static long copy ( Readable from , Appendable to ) throws IOException { checkNotNull ( from ) ; checkNotNull ( to ) ; CharBuffer buf = CharBuffer . allocate ( BUF_SIZE ) ; long total = <int> ; while ( from . read ( buf ) ! = - <int> ) { buf . flip ( ) ; to . append ( buf ) ; total + = buf . remaining ( ) ; buf . clear ( ) ; } return total ; } public static String toString ( Readable r ) throws IOException { return toStringBuilder ( r ) . toString ( ) ; } private static StringBuilder toStringBuilder ( Readable r ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; copy ( r , sb ) ; return sb ; } public static List < String > readLines ( Readable r ) throws IOException { List < String > result = new ArrayList < String > ( ) ; LineReader lineReader = new LineReader ( r ) ; String line ; while ( ( line = lineReader . readLine ( ) ) ! = null ) { result . add ( line ) ; } return result ; } public static < T > T readLines ( Readable readable , LineProcessor < T > processor ) throws IOException { checkNotNull ( readable ) ; checkNotNull ( processor ) ; LineReader lineReader = new LineReader ( readable ) ; String line ; while ( ( line = lineReader . readLine ( ) ) ! = null ) { if ( ! processor . processLine ( line ) ) { break ; } } return processor . getResult ( ) ; } public static void skipFully ( Reader reader , long n ) throws IOException { checkNotNull ( reader ) ; while ( n > <int> ) { long amt = reader . skip ( n ) ; if ( amt = = <int> ) { throw new EOFException ( ) ; } n - = amt ; } } public static Writer nullWriter ( ) { return NullWriter . INSTANCE ; } private static final class NullWriter extends Writer { private static final NullWriter INSTANCE = new NullWriter ( ) ; @Override public void write ( int c ) { } @Override public void write ( char [ ] cbuf ) { checkNotNull ( cbuf ) ; } @Override public void write ( char [ ] cbuf , int off , int len ) { checkPositionIndexes ( off , off + len , cbuf . length ) ; } @Override public void write ( String str ) { checkNotNull ( str ) ; } @Override public void write ( String str , int off , int len ) { checkPositionIndexes ( off , off + len , str . length ( ) ) ; } @Override public Writer append ( CharSequence csq ) { checkNotNull ( csq ) ; return this ; } @Override public Writer append ( CharSequence csq , int start , int end ) { checkPositionIndexes ( start , end , csq . length ( ) ) ; return this ; } @Override public Writer append ( char c ) { return this ; } @Override public void flush ( ) { } @Override public void close ( ) { } @Override public String toString ( ) { return <str> ; } } public static Writer asWriter ( Appendable target ) { if ( target instanceof Writer ) { return ( Writer ) target ; } return new AppendableWriter ( target ) ; } } 
