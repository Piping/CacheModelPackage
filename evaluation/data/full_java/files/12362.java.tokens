package org . gradle . api . internal ; import org . gradle . api . Action ; import org . gradle . api . DomainObjectCollection ; import org . gradle . api . specs . Spec ; import org . gradle . util . TestUtil ; import org . gradle . util . TestClosure ; import org . hamcrest . Description ; import org . jmock . Expectations ; import org . jmock . api . Invocation ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . util . Collection ; import java . util . Iterator ; import java . util . LinkedHashSet ; import java . util . List ; import static org . gradle . util . WrapUtil . toList ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; @RunWith ( JMock . class ) public class DefaultDomainObjectCollectionTest { private final JUnit4Mockery context = new JUnit4Mockery ( ) ; private final DefaultDomainObjectCollection < CharSequence > container = new DefaultDomainObjectCollection < CharSequence > ( CharSequence . class , new LinkedHashSet < CharSequence > ( ) ) ; @Test public void canGetAllDomainObjectsForEmptyCollection ( ) { assertTrue ( container . isEmpty ( ) ) ; } @Test public void canGetAllDomainObjectsOrderedByOrderAdded ( ) { container . add ( <str> ) ; container . add ( <str> ) ; container . add ( <str> ) ; assertThat ( toList ( container ) , equalTo ( toList ( ( CharSequence ) <str> , <str> , <str> ) ) ) ; } @Test public void canIterateOverEmptyCollection ( ) { Iterator < CharSequence > iterator = container . iterator ( ) ; assertFalse ( iterator . hasNext ( ) ) ; } @Test public void canIterateOverDomainObjectsOrderedByOrderAdded ( ) { container . add ( <str> ) ; container . add ( <str> ) ; container . add ( <str> ) ; Iterator < CharSequence > iterator = container . iterator ( ) ; assertThat ( iterator . next ( ) , equalTo ( ( CharSequence ) <str> ) ) ; assertThat ( iterator . next ( ) , equalTo ( ( CharSequence ) <str> ) ) ; assertThat ( iterator . next ( ) , equalTo ( ( CharSequence ) <str> ) ) ; assertFalse ( iterator . hasNext ( ) ) ; } @Test public void canGetAllMatchingDomainObjectsOrderedByOrderAdded ( ) { Spec < CharSequence > spec = new Spec < CharSequence > ( ) { public boolean isSatisfiedBy ( CharSequence element ) { return ! element . equals ( <str> ) ; } } ; container . add ( <str> ) ; container . add ( <str> ) ; container . add ( <str> ) ; assertThat ( toList ( container . matching ( spec ) ) , equalTo ( toList ( ( CharSequence ) <str> , <str> ) ) ) ; } @Test public void getAllMatchingDomainObjectsReturnsEmptySetWhenNoMatches ( ) { Spec < CharSequence > spec = new Spec < CharSequence > ( ) { public boolean isSatisfiedBy ( CharSequence element ) { return false ; } } ; container . add ( <str> ) ; assertTrue ( container . matching ( spec ) . isEmpty ( ) ) ; } @Test public void canGetFilteredCollectionContainingAllObjectsWhichMeetSpec ( ) { Spec < CharSequence > spec = new Spec < CharSequence > ( ) { public boolean isSatisfiedBy ( CharSequence element ) { return ! element . equals ( <str> ) ; } } ; TestClosure testClosure = new TestClosure ( ) { public Object call ( Object param ) { return ! param . equals ( <str> ) ; } } ; container . add ( <str> ) ; container . add ( <str> ) ; container . add ( <str> ) ; assertThat ( toList ( container . matching ( spec ) ) , equalTo ( toList ( ( CharSequence ) <str> , <str> ) ) ) ; assertThat ( toList ( container . matching ( TestUtil . toClosure ( testClosure ) ) ) , equalTo ( toList ( ( CharSequence ) <str> , <str> ) ) ) ; } @Test public void canGetFilteredCollectionContainingAllObjectsWhichHaveType ( ) { container . add ( <str> ) ; container . add ( <str> ) ; container . add ( new StringBuffer ( <str> ) ) ; assertThat ( toList ( container . withType ( CharSequence . class ) ) , equalTo ( toList ( container ) ) ) ; assertThat ( toList ( container . withType ( String . class ) ) , equalTo ( toList ( <str> , <str> ) ) ) ; } @Test public void canExecuteClosureForAllElementsInATypeFilteredCollection ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; container . add ( <str> ) ; container . add ( new StringBuffer ( <str> ) ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( <str> ) ; one ( closure ) . call ( <str> ) ; } } ) ; container . withType ( String . class , TestUtil . toClosure ( closure ) ) ; container . add ( <str> ) ; } @Test public void filteredCollectionIsLive ( ) { Spec < CharSequence > spec = new Spec < CharSequence > ( ) { public boolean isSatisfiedBy ( CharSequence element ) { return ! element . equals ( <str> ) ; } } ; container . add ( <str> ) ; DomainObjectCollection < CharSequence > filteredCollection = container . matching ( spec ) ; assertTrue ( filteredCollection . isEmpty ( ) ) ; container . add ( <str> ) ; container . add ( <str> ) ; assertThat ( toList ( filteredCollection ) , equalTo ( toList ( ( CharSequence ) <str> , <str> ) ) ) ; } @Test public void filteredCollectionExecutesActionWhenMatchingObjectAdded ( ) { @SuppressWarnings ( <str> ) final Action < CharSequence > action = context . mock ( Action . class ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( <str> ) ; } } ) ; Spec < CharSequence > spec = new Spec < CharSequence > ( ) { public boolean isSatisfiedBy ( CharSequence element ) { return ! element . equals ( <str> ) ; } } ; container . matching ( spec ) . whenObjectAdded ( action ) ; container . add ( <str> ) ; container . add ( <str> ) ; } @Test public void filteredCollectionExecutesClosureWhenMatchingObjectAdded ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( <str> ) ; } } ) ; Spec < CharSequence > spec = new Spec < CharSequence > ( ) { public boolean isSatisfiedBy ( CharSequence element ) { return ! element . equals ( <str> ) ; } } ; container . matching ( spec ) . whenObjectAdded ( TestUtil . toClosure ( closure ) ) ; container . add ( <str> ) ; container . add ( <str> ) ; } @Test public void canChainFilteredCollections ( ) { Spec < CharSequence > spec = new Spec < CharSequence > ( ) { public boolean isSatisfiedBy ( CharSequence element ) { return ! element . equals ( <str> ) ; } } ; Spec < String > spec2 = new Spec < String > ( ) { public boolean isSatisfiedBy ( String element ) { return ! element . equals ( <str> ) ; } } ; container . add ( <str> ) ; container . add ( <str> ) ; container . add ( <str> ) ; container . add ( new StringBuffer ( <str> ) ) ; DomainObjectCollection < String > collection = container . matching ( spec ) . withType ( String . class ) . matching ( spec2 ) ; assertThat ( toList ( collection ) , equalTo ( toList ( <str> ) ) ) ; } @Test public void findAllRetainsIterationOrder ( ) { container . add ( <str> ) ; container . add ( <str> ) ; container . add ( <str> ) ; Collection < CharSequence > collection = container . findAll ( TestUtil . toClosure ( <str> ) ) ; assertThat ( collection , instanceOf ( List . class ) ) ; assertThat ( collection , equalTo ( ( Collection ) toList ( <str> , <str> ) ) ) ; } @Test public void findAllDoesNotReturnALiveCollection ( ) { container . add ( <str> ) ; container . add ( <str> ) ; container . add ( <str> ) ; Collection < CharSequence > collection = container . findAll ( TestUtil . toClosure ( <str> ) ) ; container . add ( <str> ) ; assertThat ( collection , equalTo ( ( Collection ) toList ( <str> , <str> ) ) ) ; } @Test public void callsActionWhenObjectAdded ( ) { @SuppressWarnings ( <str> ) final Action < CharSequence > action = context . mock ( Action . class ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( <str> ) ; } } ) ; container . whenObjectAdded ( action ) ; container . add ( <str> ) ; } @Test public void callsClosureWithNewObjectAsParameterWhenObjectAdded ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( <str> ) ; } } ) ; container . whenObjectAdded ( TestUtil . toClosure ( closure ) ) ; container . add ( <str> ) ; } @Test public void callsClosureWithRemovedObjectAsParameterWhenObjectRemoved ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; container . add ( <str> ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( <str> ) ; } } ) ; container . whenObjectRemoved ( TestUtil . toClosure ( closure ) ) ; container . remove ( <str> ) ; } @Test public void callsClosureWithNewObjectAsDelegateWhenObjectAdded ( ) { container . whenObjectAdded ( TestUtil . toClosure ( <str> ) ) ; container . add ( <str> ) ; } @Test public void callsRemoveActionWhenObjectRemoved ( ) { @SuppressWarnings ( <str> ) final Action < CharSequence > action = context . mock ( Action . class ) ; final String original = <str> ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( with ( sameInstance ( original ) ) ) ; } } ) ; container . whenObjectRemoved ( action ) ; container . add ( original ) ; assertTrue ( container . remove ( original ) ) ; } @Test public void callsRemoveActionWhenObjectRemovedUsingIterator ( ) { @SuppressWarnings ( <str> ) final Action < CharSequence > action = context . mock ( Action . class ) ; container . whenObjectRemoved ( action ) ; container . add ( <str> ) ; container . add ( <str> ) ; Iterator < CharSequence > iterator = container . iterator ( ) ; iterator . next ( ) ; iterator . next ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( <str> ) ; } } ) ; iterator . remove ( ) ; } @Test public void allCallsActionForEachExistingObject ( ) { @SuppressWarnings ( <str> ) final Action < CharSequence > action = context . mock ( Action . class ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( <str> ) ; } } ) ; container . add ( <str> ) ; container . all ( action ) ; } @Test public void allCallsClosureForEachExistingObject ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( <str> ) ; } } ) ; container . add ( <str> ) ; container . all ( TestUtil . toClosure ( closure ) ) ; } @Test public void allCallsActionForEachNewObject ( ) { @SuppressWarnings ( <str> ) final Action < CharSequence > action = context . mock ( Action . class ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( <str> ) ; } } ) ; container . all ( action ) ; container . add ( <str> ) ; } @Test public void allCallsClosureForEachNewObject ( ) { final TestClosure closure = context . mock ( TestClosure . class ) ; context . checking ( new Expectations ( ) { { one ( closure ) . call ( <str> ) ; } } ) ; container . all ( TestUtil . toClosure ( closure ) ) ; container . add ( <str> ) ; } @Test public void allCallsClosureWithObjectAsDelegate ( ) { container . all ( TestUtil . toClosure ( <str> ) ) ; container . add ( <str> ) ; } @Test public void allCallsActionForEachNewObjectAddedByTheAction ( ) { @SuppressWarnings ( <str> ) final Action < CharSequence > action = context . mock ( Action . class ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( <str> ) ; will ( new org . jmock . api . Action ( ) { public Object invoke ( Invocation invocation ) throws Throwable { container . add ( <str> ) ; return null ; } public void describeTo ( Description description ) { description . appendText ( <str> ) ; } } ) ; one ( action ) . execute ( <str> ) ; one ( action ) . execute ( <str> ) ; } } ) ; container . add ( <str> ) ; container . add ( <str> ) ; container . all ( action ) ; } @Test public void callsVetoActionBeforeObjectIsAdded ( ) { final Runnable action = context . mock ( Runnable . class ) ; container . beforeChange ( action ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; } } ) ; container . add ( <str> ) ; } @Test public void objectIsNotAddedWhenVetoActionThrowsAnException ( ) { final Runnable action = context . mock ( Runnable . class ) ; final RuntimeException failure = new RuntimeException ( ) ; container . beforeChange ( action ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; will ( throwException ( failure ) ) ; } } ) ; try { container . add ( <str> ) ; fail ( ) ; } catch ( RuntimeException e ) { assertThat ( e , sameInstance ( failure ) ) ; } assertThat ( container , not ( hasItem ( ( CharSequence ) <str> ) ) ) ; } @Test public void callsVetoActionOnceBeforeCollectionIsAdded ( ) { final Runnable action = context . mock ( Runnable . class ) ; container . beforeChange ( action ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; } } ) ; container . addAll ( toList ( <str> , <str> ) ) ; } @Test public void callsVetoActionBeforeObjectIsRemoved ( ) { final Runnable action = context . mock ( Runnable . class ) ; container . beforeChange ( action ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; } } ) ; container . remove ( <str> ) ; } @Test public void callsVetoActionBeforeObjectIsRemovedUsingIterator ( ) { final Runnable action = context . mock ( Runnable . class ) ; container . add ( <str> ) ; container . beforeChange ( action ) ; Iterator < CharSequence > iterator = container . iterator ( ) ; iterator . next ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; } } ) ; iterator . remove ( ) ; } @Test public void objectIsNotRemovedWhenVetoActionThrowsAnException ( ) { final Runnable action = context . mock ( Runnable . class ) ; final RuntimeException failure = new RuntimeException ( ) ; container . add ( <str> ) ; container . beforeChange ( action ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; will ( throwException ( failure ) ) ; } } ) ; try { container . remove ( <str> ) ; fail ( ) ; } catch ( RuntimeException e ) { assertThat ( e , sameInstance ( failure ) ) ; } assertThat ( container , hasItem ( ( CharSequence ) <str> ) ) ; } @Test public void callsVetoActionBeforeCollectionIsCleared ( ) { final Runnable action = context . mock ( Runnable . class ) ; container . beforeChange ( action ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; } } ) ; container . clear ( ) ; } @Test public void callsVetoActionOnceBeforeCollectionIsRemoved ( ) { final Runnable action = context . mock ( Runnable . class ) ; container . beforeChange ( action ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; } } ) ; container . removeAll ( toList ( <str> , <str> ) ) ; } @Test public void callsVetoActionOnceBeforeCollectionIsIntersected ( ) { final Runnable action = context . mock ( Runnable . class ) ; container . add ( <str> ) ; container . add ( <str> ) ; container . beforeChange ( action ) ; context . checking ( new Expectations ( ) { { one ( action ) . run ( ) ; } } ) ; container . retainAll ( toList ( ) ) ; } @Test public void canRemoveAndMaintainOrder ( ) { container . add ( <str> ) ; container . add ( <str> ) ; container . add ( <str> ) ; assertTrue ( container . remove ( <str> ) ) ; assertThat ( toList ( container ) , equalTo ( toList ( ( CharSequence ) <str> , <str> ) ) ) ; } @Test public void canRemoveNonExistentObject ( ) { assertFalse ( container . remove ( <str> ) ) ; } } 
