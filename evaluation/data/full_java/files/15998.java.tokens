package org . gradle . tooling . internal . consumer . loader ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . logging . ProgressLoggerFactory ; import org . gradle . tooling . internal . consumer . ConnectionParameters ; import org . gradle . tooling . internal . consumer . Distribution ; import org . gradle . tooling . internal . consumer . connection . ConsumerConnection ; import java . io . Closeable ; import java . util . HashMap ; import java . util . Map ; public class CachingToolingImplementationLoader implements ToolingImplementationLoader , Closeable { private final ToolingImplementationLoader loader ; private final Map < ClassPath , ConsumerConnection > connections = new HashMap < ClassPath , ConsumerConnection > ( ) ; public CachingToolingImplementationLoader ( ToolingImplementationLoader loader ) { this . loader = loader ; } public ConsumerConnection create ( Distribution distribution , ProgressLoggerFactory progressLoggerFactory , ConnectionParameters connectionParameters , BuildCancellationToken cancellationToken ) { ClassPath classpath = distribution . getToolingImplementationClasspath ( progressLoggerFactory , connectionParameters . getGradleUserHomeDir ( ) , cancellationToken ) ; ConsumerConnection connection = connections . get ( classpath ) ; if ( connection = = null ) { connection = loader . create ( distribution , progressLoggerFactory , connectionParameters , cancellationToken ) ; connections . put ( classpath , connection ) ; } return connection ; } public void close ( ) { try { CompositeStoppable . stoppable ( connections . values ( ) ) . stop ( ) ; } finally { connections . clear ( ) ; } } } 
