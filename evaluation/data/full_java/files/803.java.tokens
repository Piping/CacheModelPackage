package org . apache . cassandra . metrics ; import java . util . Set ; import com . codahale . metrics . Gauge ; import com . codahale . metrics . Histogram ; import com . codahale . metrics . Timer ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import static org . apache . cassandra . metrics . CassandraMetricsRegistry . Metrics ; public class KeyspaceMetrics { public final Gauge < Long > memtableLiveDataSize ; public final Gauge < Long > memtableOnHeapDataSize ; public final Gauge < Long > memtableOffHeapDataSize ; public final Gauge < Long > allMemtablesLiveDataSize ; public final Gauge < Long > allMemtablesOnHeapDataSize ; public final Gauge < Long > allMemtablesOffHeapDataSize ; public final Gauge < Long > memtableColumnsCount ; public final Gauge < Long > memtableSwitchCount ; public final Gauge < Long > pendingFlushes ; public final Gauge < Long > pendingCompactions ; public final Gauge < Long > liveDiskSpaceUsed ; public final Gauge < Long > totalDiskSpaceUsed ; public final Gauge < Long > bloomFilterDiskSpaceUsed ; public final Gauge < Long > bloomFilterOffHeapMemoryUsed ; public final Gauge < Long > indexSummaryOffHeapMemoryUsed ; public final Gauge < Long > compressionMetadataOffHeapMemoryUsed ; public final LatencyMetrics readLatency ; public final LatencyMetrics rangeLatency ; public final LatencyMetrics writeLatency ; public final Histogram sstablesPerReadHistogram ; public final Histogram tombstoneScannedHistogram ; public final Histogram liveScannedHistogram ; public final Histogram colUpdateTimeDeltaHistogram ; public final Timer viewLockAcquireTime ; public final Timer viewReadTime ; public final LatencyMetrics casPrepare ; public final LatencyMetrics casPropose ; public final LatencyMetrics casCommit ; public final MetricNameFactory factory ; private Keyspace keyspace ; private Set < String > allMetrics = Sets . newHashSet ( ) ; public KeyspaceMetrics ( final Keyspace ks ) { factory = new KeyspaceMetricNameFactory ( ks ) ; keyspace = ks ; memtableColumnsCount = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . memtableColumnsCount . getValue ( ) ; } } ) ; memtableLiveDataSize = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . memtableLiveDataSize . getValue ( ) ; } } ) ; memtableOnHeapDataSize = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . memtableOnHeapSize . getValue ( ) ; } } ) ; memtableOffHeapDataSize = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . memtableOffHeapSize . getValue ( ) ; } } ) ; allMemtablesLiveDataSize = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . allMemtablesLiveDataSize . getValue ( ) ; } } ) ; allMemtablesOnHeapDataSize = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . allMemtablesOnHeapSize . getValue ( ) ; } } ) ; allMemtablesOffHeapDataSize = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . allMemtablesOffHeapSize . getValue ( ) ; } } ) ; memtableSwitchCount = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . memtableSwitchCount . getCount ( ) ; } } ) ; pendingCompactions = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return ( long ) metric . pendingCompactions . getValue ( ) ; } } ) ; pendingFlushes = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return ( long ) metric . pendingFlushes . getCount ( ) ; } } ) ; liveDiskSpaceUsed = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . liveDiskSpaceUsed . getCount ( ) ; } } ) ; totalDiskSpaceUsed = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . totalDiskSpaceUsed . getCount ( ) ; } } ) ; bloomFilterDiskSpaceUsed = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . bloomFilterDiskSpaceUsed . getValue ( ) ; } } ) ; bloomFilterOffHeapMemoryUsed = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . bloomFilterOffHeapMemoryUsed . getValue ( ) ; } } ) ; indexSummaryOffHeapMemoryUsed = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . indexSummaryOffHeapMemoryUsed . getValue ( ) ; } } ) ; compressionMetadataOffHeapMemoryUsed = createKeyspaceGauge ( <str> , new MetricValue ( ) { public Long getValue ( TableMetrics metric ) { return metric . compressionMetadataOffHeapMemoryUsed . getValue ( ) ; } } ) ; readLatency = new LatencyMetrics ( factory , <str> ) ; writeLatency = new LatencyMetrics ( factory , <str> ) ; rangeLatency = new LatencyMetrics ( factory , <str> ) ; sstablesPerReadHistogram = Metrics . histogram ( factory . createMetricName ( <str> ) , true ) ; tombstoneScannedHistogram = Metrics . histogram ( factory . createMetricName ( <str> ) , false ) ; liveScannedHistogram = Metrics . histogram ( factory . createMetricName ( <str> ) , false ) ; colUpdateTimeDeltaHistogram = Metrics . histogram ( factory . createMetricName ( <str> ) , false ) ; viewLockAcquireTime = Metrics . timer ( factory . createMetricName ( <str> ) ) ; viewReadTime = Metrics . timer ( factory . createMetricName ( <str> ) ) ; allMetrics . addAll ( Lists . newArrayList ( <str> , <str> , <str> ) ) ; casPrepare = new LatencyMetrics ( factory , <str> ) ; casPropose = new LatencyMetrics ( factory , <str> ) ; casCommit = new LatencyMetrics ( factory , <str> ) ; } public void release ( ) { for ( String name : allMetrics ) { Metrics . remove ( factory . createMetricName ( name ) ) ; } readLatency . release ( ) ; writeLatency . release ( ) ; rangeLatency . release ( ) ; } private interface MetricValue { public Long getValue ( TableMetrics metric ) ; } private Gauge < Long > createKeyspaceGauge ( String name , final MetricValue extractor ) { allMetrics . add ( name ) ; return Metrics . register ( factory . createMetricName ( name ) , new Gauge < Long > ( ) { public Long getValue ( ) { long sum = <int> ; for ( ColumnFamilyStore cf : keyspace . getColumnFamilyStores ( ) ) { sum + = extractor . getValue ( cf . metric ) ; } return sum ; } } ) ; } static class KeyspaceMetricNameFactory implements MetricNameFactory { private final String keyspaceName ; KeyspaceMetricNameFactory ( Keyspace ks ) { this . keyspaceName = ks . getName ( ) ; } public CassandraMetricsRegistry . MetricName createMetricName ( String metricName ) { String groupName = TableMetrics . class . getPackage ( ) . getName ( ) ; StringBuilder mbeanName = new StringBuilder ( ) ; mbeanName . append ( groupName ) . append ( <str> ) ; mbeanName . append ( <str> ) ; mbeanName . append ( <str> ) . append ( keyspaceName ) ; mbeanName . append ( <str> ) . append ( metricName ) ; return new CassandraMetricsRegistry . MetricName ( groupName , <str> , metricName , keyspaceName , mbeanName . toString ( ) ) ; } } } 
