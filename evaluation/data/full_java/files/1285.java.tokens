package org . apache . cassandra . utils . memory ; import java . util . concurrent . atomic . AtomicLongFieldUpdater ; import org . apache . cassandra . utils . concurrent . WaitQueue ; public abstract class MemtablePool { final MemtableCleanerThread < ? > cleaner ; public final SubPool onHeap ; public final SubPool offHeap ; final WaitQueue hasRoom = new WaitQueue ( ) ; MemtablePool ( long maxOnHeapMemory , long maxOffHeapMemory , float cleanThreshold , Runnable cleaner ) { this . onHeap = getSubPool ( maxOnHeapMemory , cleanThreshold ) ; this . offHeap = getSubPool ( maxOffHeapMemory , cleanThreshold ) ; this . cleaner = getCleaner ( cleaner ) ; if ( this . cleaner ! = null ) this . cleaner . start ( ) ; } SubPool getSubPool ( long limit , float cleanThreshold ) { return new SubPool ( limit , cleanThreshold ) ; } MemtableCleanerThread < ? > getCleaner ( Runnable cleaner ) { return cleaner = = null ? null : new MemtableCleanerThread < > ( this , cleaner ) ; } public abstract boolean needToCopyOnHeap ( ) ; public abstract MemtableAllocator newAllocator ( ) ; public class SubPool { public final long limit ; public final float cleanThreshold ; volatile long allocated ; volatile long reclaiming ; volatile long nextClean ; public SubPool ( long limit , float cleanThreshold ) { this . limit = limit ; this . cleanThreshold = cleanThreshold ; } boolean needsCleaning ( ) { return used ( ) > nextClean & & updateNextClean ( ) ; } void maybeClean ( ) { if ( needsCleaning ( ) & & cleaner ! = null ) cleaner . trigger ( ) ; } private boolean updateNextClean ( ) { while ( true ) { long current = nextClean ; long reclaiming = this . reclaiming ; long next = reclaiming + ( long ) ( this . limit * cleanThreshold ) ; if ( current = = next | | nextCleanUpdater . compareAndSet ( this , current , next ) ) return used ( ) > next ; } } boolean tryAllocate ( long size ) { while ( true ) { long cur ; if ( ( cur = allocated ) + size > limit ) return false ; if ( allocatedUpdater . compareAndSet ( this , cur , cur + size ) ) return true ; } } private void adjustAllocated ( long size ) { while ( true ) { long cur = allocated ; if ( allocatedUpdater . compareAndSet ( this , cur , cur + size ) ) return ; } } void allocated ( long size ) { assert size > = <int> ; if ( size = = <int> ) return ; adjustAllocated ( size ) ; maybeClean ( ) ; } void acquired ( long size ) { maybeClean ( ) ; } void released ( long size ) { assert size > = <int> ; adjustAllocated ( - size ) ; hasRoom . signalAll ( ) ; } void reclaiming ( long size ) { if ( size = = <int> ) return ; reclaimingUpdater . addAndGet ( this , size ) ; } void reclaimed ( long size ) { if ( size = = <int> ) return ; reclaimingUpdater . addAndGet ( this , - size ) ; if ( updateNextClean ( ) & & cleaner ! = null ) cleaner . trigger ( ) ; } public long used ( ) { return allocated ; } public float reclaimingRatio ( ) { float r = reclaiming / ( float ) limit ; if ( Float . isNaN ( r ) ) return <int> ; return r ; } public float usedRatio ( ) { float r = allocated / ( float ) limit ; if ( Float . isNaN ( r ) ) return <int> ; return r ; } public MemtableAllocator . SubAllocator newAllocator ( ) { return new MemtableAllocator . SubAllocator ( this ) ; } public WaitQueue hasRoom ( ) { return hasRoom ; } } private static final AtomicLongFieldUpdater < SubPool > reclaimingUpdater = AtomicLongFieldUpdater . newUpdater ( SubPool . class , <str> ) ; private static final AtomicLongFieldUpdater < SubPool > allocatedUpdater = AtomicLongFieldUpdater . newUpdater ( SubPool . class , <str> ) ; private static final AtomicLongFieldUpdater < SubPool > nextCleanUpdater = AtomicLongFieldUpdater . newUpdater ( SubPool . class , <str> ) ; } 
