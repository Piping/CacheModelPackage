package org . elasticsearch . common . inject ; import org . elasticsearch . common . inject . internal . BindingImpl ; import org . elasticsearch . common . inject . internal . Errors ; import org . elasticsearch . common . inject . internal . ErrorsException ; import org . elasticsearch . common . inject . internal . InternalContext ; import org . elasticsearch . common . inject . internal . Stopwatch ; import org . elasticsearch . common . inject . spi . Dependency ; import java . util . List ; import java . util . Map ; class InjectorBuilder { private final Stopwatch stopwatch = new Stopwatch ( ) ; private final Errors errors = new Errors ( ) ; private Stage stage ; private final Initializer initializer = new Initializer ( ) ; private final BindingProcessor bindingProcesor ; private final InjectionRequestProcessor injectionRequestProcessor ; private final InjectorShell . Builder shellBuilder = new InjectorShell . Builder ( ) ; private List < InjectorShell > shells ; InjectorBuilder ( ) { injectionRequestProcessor = new InjectionRequestProcessor ( errors , initializer ) ; bindingProcesor = new BindingProcessor ( errors , initializer ) ; } InjectorBuilder stage ( Stage stage ) { shellBuilder . stage ( stage ) ; this . stage = stage ; return this ; } InjectorBuilder parentInjector ( InjectorImpl parent ) { shellBuilder . parent ( parent ) ; return stage ( parent . getInstance ( Stage . class ) ) ; } InjectorBuilder addModules ( Iterable < ? extends Module > modules ) { shellBuilder . addModules ( modules ) ; return this ; } Injector build ( ) { if ( shellBuilder = = null ) { throw new AssertionError ( <str> ) ; } synchronized ( shellBuilder . lock ( ) ) { shells = shellBuilder . build ( initializer , bindingProcesor , stopwatch , errors ) ; stopwatch . resetAndLog ( <str> ) ; initializeStatically ( ) ; } if ( stage = = Stage . TOOL ) { return new ToolStageInjector ( primaryInjector ( ) ) ; } injectDynamically ( ) ; return primaryInjector ( ) ; } private void initializeStatically ( ) { bindingProcesor . initializeBindings ( ) ; stopwatch . resetAndLog ( <str> ) ; for ( InjectorShell shell : shells ) { shell . getInjector ( ) . index ( ) ; } stopwatch . resetAndLog ( <str> ) ; injectionRequestProcessor . process ( shells ) ; stopwatch . resetAndLog ( <str> ) ; bindingProcesor . runCreationListeners ( ) ; stopwatch . resetAndLog ( <str> ) ; injectionRequestProcessor . validate ( ) ; stopwatch . resetAndLog ( <str> ) ; initializer . validateOustandingInjections ( errors ) ; stopwatch . resetAndLog ( <str> ) ; new LookupProcessor ( errors ) . process ( shells ) ; for ( InjectorShell shell : shells ) { ( ( DeferredLookups ) shell . getInjector ( ) . lookups ) . initialize ( errors ) ; } stopwatch . resetAndLog ( <str> ) ; for ( InjectorShell shell : shells ) { if ( ! shell . getElements ( ) . isEmpty ( ) ) { throw new AssertionError ( <str> + shell . getElements ( ) ) ; } } errors . throwCreationExceptionIfErrorsExist ( ) ; } private Injector primaryInjector ( ) { return shells . get ( <int> ) . getInjector ( ) ; } private void injectDynamically ( ) { injectionRequestProcessor . injectMembers ( ) ; stopwatch . resetAndLog ( <str> ) ; initializer . injectAll ( errors ) ; stopwatch . resetAndLog ( <str> ) ; errors . throwCreationExceptionIfErrorsExist ( ) ; for ( InjectorShell shell : shells ) { loadEagerSingletons ( shell . getInjector ( ) , stage , errors ) ; } stopwatch . resetAndLog ( <str> ) ; errors . throwCreationExceptionIfErrorsExist ( ) ; } public void loadEagerSingletons ( InjectorImpl injector , Stage stage , Errors errors ) { for ( final Binding < ? > binding : injector . state . getExplicitBindingsThisLevel ( ) . values ( ) ) { loadEagerSingletons ( injector , stage , errors , ( BindingImpl < ? > ) binding ) ; } for ( final Binding < ? > binding : injector . jitBindings . values ( ) ) { loadEagerSingletons ( injector , stage , errors , ( BindingImpl < ? > ) binding ) ; } } private void loadEagerSingletons ( InjectorImpl injector , Stage stage , final Errors errors , BindingImpl < ? > binding ) { if ( binding . getScoping ( ) . isEagerSingleton ( stage ) ) { try { injector . callInContext ( new ContextualCallable < Void > ( ) { Dependency < ? > dependency = Dependency . get ( binding . getKey ( ) ) ; @Override public Void call ( InternalContext context ) { context . setDependency ( dependency ) ; Errors errorsForBinding = errors . withSource ( dependency ) ; try { binding . getInternalFactory ( ) . get ( errorsForBinding , context , dependency ) ; } catch ( ErrorsException e ) { errorsForBinding . merge ( e . getErrors ( ) ) ; } finally { context . setDependency ( null ) ; } return null ; } } ) ; } catch ( ErrorsException e ) { throw new AssertionError ( ) ; } } } static class ToolStageInjector implements Injector { private final Injector delegateInjector ; ToolStageInjector ( Injector delegateInjector ) { this . delegateInjector = delegateInjector ; } @Override public void injectMembers ( Object o ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public Map < Key < ? > , Binding < ? > > getBindings ( ) { return this . delegateInjector . getBindings ( ) ; } @Override public < T > Binding < T > getBinding ( Key < T > key ) { return this . delegateInjector . getBinding ( key ) ; } @Override public < T > Binding < T > getBinding ( Class < T > type ) { return this . delegateInjector . getBinding ( type ) ; } @Override public < T > List < Binding < T > > findBindingsByType ( TypeLiteral < T > type ) { return this . delegateInjector . findBindingsByType ( type ) ; } @Override public Injector getParent ( ) { return delegateInjector . getParent ( ) ; } @Override public Injector createChildInjector ( Iterable < ? extends Module > modules ) { return delegateInjector . createChildInjector ( modules ) ; } @Override public Injector createChildInjector ( Module . . . modules ) { return delegateInjector . createChildInjector ( modules ) ; } @Override public < T > Provider < T > getProvider ( Key < T > key ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public < T > Provider < T > getProvider ( Class < T > type ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public < T > MembersInjector < T > getMembersInjector ( TypeLiteral < T > typeLiteral ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public < T > MembersInjector < T > getMembersInjector ( Class < T > type ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public < T > T getInstance ( Key < T > key ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public < T > T getInstance ( Class < T > type ) { throw new UnsupportedOperationException ( <str> ) ; } } } 
