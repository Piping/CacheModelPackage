package com . badlogic . gdx . utils ; import com . badlogic . gdx . Application ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . LifecycleListener ; public class Timer { static final Array < Timer > instances = new Array ( <int> ) ; static TimerThread thread ; static private final int CANCELLED = - <int> ; static private final int FOREVER = - <int> ; static Timer instance = new Timer ( ) ; static public Timer instance ( ) { if ( instance = = null ) { instance = new Timer ( ) ; } return instance ; } private final Array < Task > tasks = new Array ( false , <int> ) ; public Timer ( ) { start ( ) ; } public Task postTask ( Task task ) { return scheduleTask ( task , <int> , <int> , <int> ) ; } public Task scheduleTask ( Task task , float delaySeconds ) { return scheduleTask ( task , delaySeconds , <int> , <int> ) ; } public Task scheduleTask ( Task task , float delaySeconds , float intervalSeconds ) { return scheduleTask ( task , delaySeconds , intervalSeconds , FOREVER ) ; } public Task scheduleTask ( Task task , float delaySeconds , float intervalSeconds , int repeatCount ) { if ( task . repeatCount ! = CANCELLED ) throw new IllegalArgumentException ( <str> ) ; task . executeTimeMillis = TimeUtils . nanoTime ( ) / <int> + ( long ) ( delaySeconds * <int> ) ; task . intervalMillis = ( long ) ( intervalSeconds * <int> ) ; task . repeatCount = repeatCount ; synchronized ( tasks ) { tasks . add ( task ) ; } wake ( ) ; return task ; } public void stop ( ) { synchronized ( instances ) { instances . removeValue ( this , true ) ; } } public void start ( ) { synchronized ( instances ) { if ( instances . contains ( this , true ) ) return ; instances . add ( this ) ; if ( thread = = null ) thread = new TimerThread ( ) ; wake ( ) ; } } public void clear ( ) { synchronized ( tasks ) { for ( int i = <int> , n = tasks . size ; i < n ; i + + ) tasks . get ( i ) . cancel ( ) ; tasks . clear ( ) ; } } long update ( long timeMillis , long waitMillis ) { synchronized ( tasks ) { for ( int i = <int> , n = tasks . size ; i < n ; i + + ) { Task task = tasks . get ( i ) ; if ( task . executeTimeMillis > timeMillis ) { waitMillis = Math . min ( waitMillis , task . executeTimeMillis - timeMillis ) ; continue ; } if ( task . repeatCount ! = CANCELLED ) { if ( task . repeatCount = = <int> ) { task . repeatCount = CANCELLED ; } Gdx . app . postRunnable ( task ) ; } if ( task . repeatCount = = CANCELLED ) { tasks . removeIndex ( i ) ; i - - ; n - - ; } else { task . executeTimeMillis = timeMillis + task . intervalMillis ; waitMillis = Math . min ( waitMillis , task . intervalMillis ) ; if ( task . repeatCount > <int> ) task . repeatCount - - ; } } } return waitMillis ; } public void delay ( long delayMillis ) { synchronized ( tasks ) { for ( int i = <int> , n = tasks . size ; i < n ; i + + ) { Task task = tasks . get ( i ) ; task . executeTimeMillis + = delayMillis ; } } } static void wake ( ) { synchronized ( instances ) { thread . schedule ( <int> ) ; } } static public Task post ( Task task ) { return instance ( ) . postTask ( task ) ; } static public Task schedule ( Task task , float delaySeconds ) { return instance ( ) . scheduleTask ( task , delaySeconds ) ; } static public Task schedule ( Task task , float delaySeconds , float intervalSeconds ) { return instance ( ) . scheduleTask ( task , delaySeconds , intervalSeconds ) ; } static public Task schedule ( Task task , float delaySeconds , float intervalSeconds , int repeatCount ) { return instance ( ) . scheduleTask ( task , delaySeconds , intervalSeconds , repeatCount ) ; } static abstract public class Task implements Runnable { long executeTimeMillis ; long intervalMillis ; int repeatCount = CANCELLED ; abstract public void run ( ) ; public void cancel ( ) { executeTimeMillis = <int> ; repeatCount = CANCELLED ; } public boolean isScheduled ( ) { return repeatCount ! = CANCELLED ; } public long getExecuteTimeMillis ( ) { return executeTimeMillis ; } } static class TimerThread extends com . google . gwt . user . client . Timer implements Runnable , LifecycleListener { private Application app ; private long pauseMillis ; public TimerThread ( ) { Gdx . app . addLifecycleListener ( this ) ; resume ( ) ; } public void run ( ) { synchronized ( instances ) { if ( app ! = Gdx . app ) return ; long timeMillis = TimeUtils . nanoTime ( ) / <int> ; long waitMillis = <int> ; for ( int i = <int> , n = instances . size ; i < n ; i + + ) { try { waitMillis = instances . get ( i ) . update ( timeMillis , waitMillis ) ; } catch ( Throwable ex ) { throw new GdxRuntimeException ( <str> + instances . get ( i ) . getClass ( ) . getName ( ) , ex ) ; } } if ( app ! = Gdx . app ) return ; schedule ( ( int ) Math . max ( <int> , waitMillis ) ) ; } } public void resume ( ) { long delayMillis = TimeUtils . nanoTime ( ) / <int> - pauseMillis ; synchronized ( instances ) { for ( int i = <int> , n = instances . size ; i < n ; i + + ) instances . get ( i ) . delay ( delayMillis ) ; } app = Gdx . app ; run ( ) ; } public void pause ( ) { pauseMillis = TimeUtils . nanoTime ( ) / <int> ; synchronized ( instances ) { app = null ; wake ( ) ; } } public void dispose ( ) { pause ( ) ; Gdx . app . removeLifecycleListener ( this ) ; thread = null ; instances . clear ( ) ; instance = null ; } } } 
