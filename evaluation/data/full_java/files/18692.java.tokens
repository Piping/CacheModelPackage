package com . badlogic . gdx . tests . g3d . shadows . utils ; import com . badlogic . gdx . graphics . g3d . environment . BaseLight ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class FixedShadowMapAllocator implements ShadowMapAllocator { public static final int QUALITY_MIN = <int> ; public static final int QUALITY_MED = <int> ; public static final int QUALITY_MAX = <int> ; public static final int QUANTITY_MAP_MIN = <int> ; public static final int QUANTITY_MAP_MED = <int> ; public static final int QUANTITY_MAP_MAX = <int> ; protected final int size ; protected final int mapQuantity ; protected int currentMap ; protected ShadowMapRegion result = new ShadowMapRegion ( ) ; protected boolean allocating = false ; public FixedShadowMapAllocator ( int size , int nbMap ) { this . size = size ; this . mapQuantity = nbMap ; } @Override public int getWidth ( ) { return size ; } @Override public int getHeight ( ) { return size ; } public int getMapQuantity ( ) { return mapQuantity ; } @Override public void begin ( ) { if ( allocating ) { throw new GdxRuntimeException ( <str> ) ; } allocating = true ; currentMap = <int> ; } @Override public void end ( ) { if ( ! allocating ) { throw new GdxRuntimeException ( <str> ) ; } allocating = false ; } @Override public ShadowMapRegion nextResult ( BaseLight light ) { if ( ! allocating ) { throw new GdxRuntimeException ( <str> ) ; } int nbOnLine = ( int ) Math . round ( Math . sqrt ( mapQuantity ) ) ; int i = currentMap % nbOnLine ; int j = currentMap / nbOnLine ; int sizeMap = size / nbOnLine ; result . x = i * sizeMap ; result . y = j * sizeMap ; result . width = sizeMap ; result . height = sizeMap ; if ( result . x > = size | | result . y > = size ) return null ; currentMap + = <int> ; return result ; } } 
