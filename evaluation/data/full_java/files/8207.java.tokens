package org . elasticsearch . index . mapper . numeric ; import org . apache . lucene . analysis . NumericTokenStream ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . document . Field ; import org . apache . lucene . index . DocValuesType ; import org . apache . lucene . index . IndexableField ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . ParseContext . Document ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . core . DoubleFieldMapper ; import org . elasticsearch . index . mapper . core . LongFieldMapper ; import org . elasticsearch . index . mapper . core . NumberFieldMapper ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . elasticsearch . index . mapper . string . SimpleStringMappingTests ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . io . IOException ; import java . util . Arrays ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class SimpleNumericTests extends ESSingleNodeTestCase { public void testNumericDetectionEnabled ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . string ( ) ; IndexService index = createIndex ( <str> ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( mapping ) . get ( ) ; DocumentMapper defaultMapper = index . mapperService ( ) . documentMapper ( <str> ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertNotNull ( doc . dynamicMappingsUpdate ( ) ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( doc . dynamicMappingsUpdate ( ) . toString ( ) ) . get ( ) ; FieldMapper mapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( mapper , instanceOf ( LongFieldMapper . class ) ) ; mapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( mapper , instanceOf ( DoubleFieldMapper . class ) ) ; } public void testNumericDetectionDefault ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; IndexService index = createIndex ( <str> ) ; client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( mapping ) . get ( ) ; DocumentMapper defaultMapper = index . mapperService ( ) . documentMapper ( <str> ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertNotNull ( doc . dynamicMappingsUpdate ( ) ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . preparePutMapping ( <str> ) . setType ( <str> ) . setSource ( doc . dynamicMappingsUpdate ( ) . toString ( ) ) . get ( ) ) ; FieldMapper mapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( mapper , instanceOf ( StringFieldMapper . class ) ) ; mapper = defaultMapper . mappers ( ) . smartNameFieldMapper ( <str> ) ; assertThat ( mapper , instanceOf ( StringFieldMapper . class ) ) ; } public void testIgnoreMalformedOption ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( NumberFormatException . class ) ) ; } try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( NumberFormatException . class ) ) ; } Settings indexSettings = settingsBuilder ( ) . put ( <str> , true ) . build ( ) ; defaultMapper = createIndex ( <str> , indexSettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( NumberFormatException . class ) ) ; } } public void testCoerceOption ( ) throws Exception { String [ ] nonFractionNumericFieldTypes = { <str> , <str> , <str> } ; DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; for ( String nonFractionNumericFieldType : nonFractionNumericFieldTypes ) { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , nonFractionNumericFieldType ) . field ( <str> , true ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . field ( <str> , nonFractionNumericFieldType ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , nonFractionNumericFieldType ) . field ( <str> , false ) . endObject ( ) . startObject ( <str> ) . field ( <str> , nonFractionNumericFieldType ) . field ( <str> , false ) . field ( <str> , false ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = parser . parse ( mapping ) ; String invalidJsonNumberAsString = <str> ; ParsedDocument doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , invalidJsonNumberAsString ) . field ( <str> , invalidJsonNumberAsString ) . field ( <str> , invalidJsonNumberAsString ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , notNullValue ( ) ) ; int validNumber = <int> ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , validNumber ) . field ( <str> , validNumber ) . field ( <str> , validNumber ) . endObject ( ) . bytes ( ) ) ; assertEquals ( validNumber , doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . intValue ( ) ) ; assertEquals ( validNumber , doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . intValue ( ) ) ; assertEquals ( validNumber , doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . intValue ( ) ) ; int validNegativeNumber = - <int> ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , validNegativeNumber ) . field ( <str> , validNegativeNumber ) . field ( <str> , validNegativeNumber ) . endObject ( ) . bytes ( ) ) ; assertEquals ( validNegativeNumber , doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . intValue ( ) ) ; assertEquals ( validNegativeNumber , doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . intValue ( ) ) ; assertEquals ( validNegativeNumber , doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . intValue ( ) ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , invalidJsonNumberAsString ) . endObject ( ) . bytes ( ) ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; } float invalidJsonForInteger = <float> ; int coercedFloatValue = <int> ; doc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , invalidJsonForInteger ) . field ( <str> , invalidJsonForInteger ) . field ( <str> , invalidJsonForInteger ) . endObject ( ) . bytes ( ) ) ; assertThat ( doc . rootDoc ( ) . getField ( <str> ) , nullValue ( ) ) ; assertEquals ( coercedFloatValue , doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . intValue ( ) ) ; assertEquals ( coercedFloatValue , doc . rootDoc ( ) . getField ( <str> ) . numericValue ( ) . intValue ( ) ) ; try { defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , invalidJsonForInteger ) . endObject ( ) . bytes ( ) ) ; } catch ( MapperParsingException e ) { assertThat ( e . getCause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; } } } public void testDocValues ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument parsedDoc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; final Document doc = parsedDoc . rootDoc ( ) ; assertEquals ( DocValuesType . SORTED_NUMERIC , SimpleStringMappingTests . docValuesType ( doc , <str> ) ) ; assertEquals ( DocValuesType . SORTED_NUMERIC , SimpleStringMappingTests . docValuesType ( doc , <str> ) ) ; } public void testDocValuesOnNested ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper defaultMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument parsedDoc = defaultMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . bytes ( ) ) ; for ( Document doc : parsedDoc . docs ( ) ) { if ( doc = = parsedDoc . rootDoc ( ) ) { continue ; } assertEquals ( DocValuesType . SORTED_NUMERIC , SimpleStringMappingTests . docValuesType ( doc , <str> ) ) ; assertEquals ( DocValuesType . SORTED_NUMERIC , SimpleStringMappingTests . docValuesType ( doc , <str> ) ) ; } } public void testPrecisionStepDefaultsDetected ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , true ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = mapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertEquals ( <int> , doc . docs ( ) . size ( ) ) ; Document luceneDoc = doc . docs ( ) . get ( <int> ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_64_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_64_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_64_BIT , luceneDoc . getField ( <str> ) ) ; } public void testPrecisionStepDefaultsMapped ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = mapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertEquals ( <int> , doc . docs ( ) . size ( ) ) ; Document luceneDoc = doc . docs ( ) . get ( <int> ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_64_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_64_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_64_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_64_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_32_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_32_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_16_BIT , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( NumberFieldMapper . Defaults . PRECISION_STEP_8_BIT , luceneDoc . getField ( <str> ) ) ; } public void testPrecisionStepExplicit ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper mapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = mapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertEquals ( <int> , doc . docs ( ) . size ( ) ) ; Document luceneDoc = doc . docs ( ) . get ( <int> ) ; assertPrecisionStepEquals ( <int> , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( <int> , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( <int> , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( <int> , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( <int> , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( <int> , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( <int> , luceneDoc . getField ( <str> ) ) ; assertPrecisionStepEquals ( <int> , luceneDoc . getField ( <str> ) ) ; } private static void assertPrecisionStepEquals ( int expected , IndexableField field ) throws IOException { assertNotNull ( field ) ; assertThat ( field , instanceOf ( Field . class ) ) ; assertEquals ( expected , ( ( Field ) field ) . fieldType ( ) . numericPrecisionStep ( ) ) ; TokenStream ts = field . tokenStream ( null , null ) ; assertThat ( ts , instanceOf ( NumericTokenStream . class ) ) ; assertEquals ( expected , ( ( NumericTokenStream ) ts ) . getPrecisionStep ( ) ) ; } public void testTermVectorsBackCompat ( ) throws Exception { for ( String type : Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) { doTestTermVectorsBackCompat ( type ) ; } } private void doTestTermVectorsBackCompat ( String type ) throws Exception { DocumentMapperParser parser = createIndex ( <str> + type ) . mapperService ( ) . documentMapperParser ( ) ; String mappingWithTV = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , type ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; try { parser . parse ( mappingWithTV ) ; fail ( ) ; } catch ( MapperParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } Settings oldIndexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_2_1_0 ) . build ( ) ; parser = createIndex ( <str> + type , oldIndexSettings ) . mapperService ( ) . documentMapperParser ( ) ; parser . parse ( mappingWithTV ) ; } public void testAnalyzerBackCompat ( ) throws Exception { for ( String type : Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) { doTestAnalyzerBackCompat ( type ) ; } } private void doTestAnalyzerBackCompat ( String type ) throws Exception { DocumentMapperParser parser = createIndex ( <str> + type ) . mapperService ( ) . documentMapperParser ( ) ; String mappingWithTV = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , type ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; try { parser . parse ( mappingWithTV ) ; fail ( ) ; } catch ( MapperParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } Settings oldIndexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_2_1_0 ) . build ( ) ; parser = createIndex ( <str> + type , oldIndexSettings ) . mapperService ( ) . documentMapperParser ( ) ; parser . parse ( mappingWithTV ) ; } } 
