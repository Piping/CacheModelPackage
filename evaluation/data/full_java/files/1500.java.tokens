package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . nio . charset . CharacterCodingException ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . UUID ; import org . junit . BeforeClass ; import org . junit . Test ; import static org . junit . Assert . fail ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . db . partitions . ImmutableBTreePartition ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . * ; public class DynamicCompositeTypeTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARDDYNCOMPOSITE = <str> ; private static Map < Byte , AbstractType < ? > > aliases = new HashMap < > ( ) ; private static final DynamicCompositeType comparator ; static { aliases . put ( ( byte ) <str> , BytesType . instance ) ; aliases . put ( ( byte ) <str> , ReversedType . getInstance ( BytesType . instance ) ) ; aliases . put ( ( byte ) <str> , TimeUUIDType . instance ) ; aliases . put ( ( byte ) <str> , ReversedType . getInstance ( TimeUUIDType . instance ) ) ; comparator = DynamicCompositeType . getInstance ( aliases ) ; } private static final int UUID_COUNT = <int> ; private static final UUID [ ] uuids = new UUID [ UUID_COUNT ] ; static { for ( int i = <int> ; i < UUID_COUNT ; + + i ) uuids [ i ] = UUIDGen . getTimeUUID ( ) ; } @BeforeClass public static void defineSchema ( ) throws ConfigurationException { AbstractType < ? > dynamicComposite = DynamicCompositeType . getInstance ( aliases ) ; SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . denseCFMD ( KEYSPACE1 , CF_STANDARDDYNCOMPOSITE , dynamicComposite ) ) ; } @Test public void testEndOfComponent ( ) { ByteBuffer [ ] cnames = { createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , false ) , createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) , createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) , createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) , createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , false ) , createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) , } ; ByteBuffer start = createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , false ) ; ByteBuffer stop = createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , true ) ; for ( int i = <int> ; i < <int> ; + + i ) { assert comparator . compare ( start , cnames [ i ] ) > <int> ; assert comparator . compare ( stop , cnames [ i ] ) > <int> ; } for ( int i = <int> ; i < <int> ; + + i ) { assert comparator . compare ( start , cnames [ i ] ) < <int> ; assert comparator . compare ( stop , cnames [ i ] ) > <int> ; } for ( int i = <int> ; i < cnames . length ; + + i ) { assert comparator . compare ( start , cnames [ i ] ) < <int> ; assert comparator . compare ( stop , cnames [ i ] ) < <int> ; } } @Test public void testGetString ( ) { String test1Hex = ByteBufferUtil . bytesToHex ( ByteBufferUtil . bytes ( <str> ) ) ; ByteBuffer key = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; assert comparator . getString ( key ) . equals ( <str> + test1Hex + <str> + uuids [ <int> ] + <str> ) ; key = createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , true ) ; assert comparator . getString ( key ) . equals ( <str> + test1Hex + <str> + uuids [ <int> ] + <str> ) ; } @Test public void testFromString ( ) { String test1Hex = ByteBufferUtil . bytesToHex ( ByteBufferUtil . bytes ( <str> ) ) ; ByteBuffer key = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; assert key . equals ( comparator . fromString ( <str> + test1Hex + <str> + uuids [ <int> ] + <str> ) ) ; key = createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , true ) ; assert key . equals ( comparator . fromString ( <str> + test1Hex + <str> + uuids [ <int> ] + <str> ) ) ; } @Test public void testValidate ( ) { ByteBuffer key = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; comparator . validate ( key ) ; key = createDynamicCompositeKey ( <str> , null , - <int> , false ) ; comparator . validate ( key ) ; key = createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , true ) ; comparator . validate ( key ) ; key . get ( ) ; try { comparator . validate ( key ) ; fail ( <str> ) ; } catch ( MarshalException e ) { } key = ByteBuffer . allocate ( <int> + <str> . length ( ) + <int> + <int> ) ; key . putShort ( ( short ) ( <hex> | <str> ) ) ; key . putShort ( ( short ) <str> . length ( ) ) ; key . put ( ByteBufferUtil . bytes ( <str> ) ) ; key . put ( ( byte ) <int> ) ; key . putShort ( ( short ) ( <hex> | <str> ) ) ; key . putShort ( ( short ) <int> ) ; key . rewind ( ) ; try { comparator . validate ( key ) ; fail ( <str> ) ; } catch ( MarshalException e ) { assert e . toString ( ) . contains ( <str> ) ; } key = createDynamicCompositeKey ( <str> , UUID . randomUUID ( ) , <int> , false ) ; try { comparator . validate ( key ) ; fail ( <str> ) ; } catch ( MarshalException e ) { assert e . toString ( ) . contains ( <str> ) ; } } @Test public void testFullRound ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARDDYNCOMPOSITE ) ; ByteBuffer cname1 = createDynamicCompositeKey ( <str> , null , - <int> , false ) ; ByteBuffer cname2 = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; ByteBuffer cname3 = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; ByteBuffer cname4 = createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , false ) ; ByteBuffer cname5 = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false ) ; ByteBuffer key = ByteBufferUtil . bytes ( <str> ) ; long ts = FBUtilities . timestampMicros ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname5 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname1 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname4 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname2 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname3 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; ColumnDefinition cdef = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; ImmutableBTreePartition readPartition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) ; Iterator < Row > iter = readPartition . iterator ( ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; } private void compareValues ( Cell c , String r ) throws CharacterCodingException { assert ByteBufferUtil . string ( c . value ( ) ) . equals ( r ) : <str> + ByteBufferUtil . string ( c . value ( ) ) + <str> + r + <str> ; } @Test public void testFullRoundReversed ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARDDYNCOMPOSITE ) ; ByteBuffer cname1 = createDynamicCompositeKey ( <str> , null , - <int> , false , true ) ; ByteBuffer cname2 = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false , true ) ; ByteBuffer cname3 = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false , true ) ; ByteBuffer cname4 = createDynamicCompositeKey ( <str> , uuids [ <int> ] , - <int> , false , true ) ; ByteBuffer cname5 = createDynamicCompositeKey ( <str> , uuids [ <int> ] , <int> , false , true ) ; ByteBuffer key = ByteBufferUtil . bytes ( <str> ) ; long ts = FBUtilities . timestampMicros ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname5 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname1 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname4 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname2 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , ts , key ) . clustering ( cname3 ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; ColumnDefinition cdef = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; ImmutableBTreePartition readPartition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( cfs , key ) . build ( ) ) ; Iterator < Row > iter = readPartition . iterator ( ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; compareValues ( iter . next ( ) . getCell ( cdef ) , <str> ) ; } @Test public void testUncomparableColumns ( ) { ByteBuffer bytes = ByteBuffer . allocate ( <int> + <int> + <int> + <int> ) ; bytes . putShort ( ( short ) ( <hex> | <str> ) ) ; bytes . putShort ( ( short ) <int> ) ; bytes . put ( new byte [ <int> ] ) ; bytes . put ( ( byte ) <int> ) ; bytes . rewind ( ) ; ByteBuffer uuid = ByteBuffer . allocate ( <int> + <int> + <int> + <int> ) ; uuid . putShort ( ( short ) ( <hex> | <str> ) ) ; uuid . putShort ( ( short ) <int> ) ; uuid . put ( UUIDGen . decompose ( uuids [ <int> ] ) ) ; uuid . put ( ( byte ) <int> ) ; uuid . rewind ( ) ; try { int c = comparator . compare ( bytes , uuid ) ; assert c = = - <int> : <str> + c ; } catch ( Exception e ) { fail ( <str> ) ; } } @Test public void testUncomparableReversedColumns ( ) { ByteBuffer uuid = ByteBuffer . allocate ( <int> + <int> + <int> + <int> ) ; uuid . putShort ( ( short ) ( <hex> | <str> ) ) ; uuid . putShort ( ( short ) <int> ) ; uuid . put ( UUIDGen . decompose ( uuids [ <int> ] ) ) ; uuid . put ( ( byte ) <int> ) ; uuid . rewind ( ) ; ByteBuffer bytes = ByteBuffer . allocate ( <int> + <int> + <int> + <int> ) ; bytes . putShort ( ( short ) ( <hex> | <str> ) ) ; bytes . putShort ( ( short ) <int> ) ; bytes . put ( new byte [ <int> ] ) ; bytes . put ( ( byte ) <int> ) ; bytes . rewind ( ) ; try { int c = comparator . compare ( uuid , bytes ) ; assert c = = <int> : <str> + c ; } catch ( Exception e ) { fail ( <str> ) ; } } public void testCompatibility ( ) throws Exception { assert TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; assert TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; assert TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; assert ! TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; assert ! TypeParser . parse ( <str> ) . isCompatibleWith ( TypeParser . parse ( <str> ) ) ; } private ByteBuffer createDynamicCompositeKey ( String s , UUID uuid , int i , boolean lastIsOne ) { return createDynamicCompositeKey ( s , uuid , i , lastIsOne , false ) ; } private ByteBuffer createDynamicCompositeKey ( String s , UUID uuid , int i , boolean lastIsOne , final boolean reversed ) { String intType = ( reversed ? <str> : <str> ) ; ByteBuffer bytes = ByteBufferUtil . bytes ( s ) ; int totalSize = <int> ; if ( s ! = null ) { totalSize + = <int> + <int> + bytes . remaining ( ) + <int> ; if ( uuid ! = null ) { totalSize + = <int> + <int> + <int> + <int> ; if ( i ! = - <int> ) { totalSize + = <int> + intType . length ( ) + <int> + <int> + <int> ; } } } ByteBuffer bb = ByteBuffer . allocate ( totalSize ) ; if ( s ! = null ) { bb . putShort ( ( short ) ( <hex> | ( reversed ? <str> : <str> ) ) ) ; bb . putShort ( ( short ) bytes . remaining ( ) ) ; bb . put ( bytes ) ; bb . put ( uuid = = null & & lastIsOne ? ( byte ) <int> : ( byte ) <int> ) ; if ( uuid ! = null ) { bb . putShort ( ( short ) ( <hex> | ( reversed ? <str> : <str> ) ) ) ; bb . putShort ( ( short ) <int> ) ; bb . put ( UUIDGen . decompose ( uuid ) ) ; bb . put ( i = = - <int> & & lastIsOne ? ( byte ) <int> : ( byte ) <int> ) ; if ( i ! = - <int> ) { bb . putShort ( ( short ) intType . length ( ) ) ; bb . put ( ByteBufferUtil . bytes ( intType ) ) ; bb . putShort ( ( short ) <int> ) ; bb . put ( ( byte ) i ) ; bb . put ( lastIsOne ? ( byte ) <int> : ( byte ) <int> ) ; } } } bb . rewind ( ) ; return bb ; } } 
