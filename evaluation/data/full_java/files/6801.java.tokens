package org . elasticsearch . index . translog ; import org . apache . lucene . store . BufferedChecksum ; import org . elasticsearch . common . io . stream . StreamInput ; import java . io . IOException ; import java . util . zip . CRC32 ; import java . util . zip . Checksum ; public final class BufferedChecksumStreamInput extends StreamInput { private static final int SKIP_BUFFER_SIZE = <int> ; private byte [ ] skipBuffer ; private final StreamInput in ; private final Checksum digest ; public BufferedChecksumStreamInput ( StreamInput in ) { this . in = in ; this . digest = new BufferedChecksum ( new CRC32 ( ) ) ; } public BufferedChecksumStreamInput ( StreamInput in , BufferedChecksumStreamInput reuse ) { this . in = in ; if ( reuse = = null ) { this . digest = new BufferedChecksum ( new CRC32 ( ) ) ; } else { this . digest = reuse . digest ; digest . reset ( ) ; this . skipBuffer = reuse . skipBuffer ; } } public long getChecksum ( ) { return this . digest . getValue ( ) ; } @Override public byte readByte ( ) throws IOException { final byte b = in . readByte ( ) ; digest . update ( b ) ; return b ; } @Override public void readBytes ( byte [ ] b , int offset , int len ) throws IOException { in . readBytes ( b , offset , len ) ; digest . update ( b , offset , len ) ; } @Override public void reset ( ) throws IOException { in . reset ( ) ; digest . reset ( ) ; } @Override public int read ( ) throws IOException { return readByte ( ) & <hex> ; } @Override public void close ( ) throws IOException { in . close ( ) ; } @Override public boolean markSupported ( ) { return in . markSupported ( ) ; } @Override public long skip ( long numBytes ) throws IOException { if ( numBytes < <int> ) { throw new IllegalArgumentException ( <str> + numBytes ) ; } if ( skipBuffer = = null ) { skipBuffer = new byte [ SKIP_BUFFER_SIZE ] ; } assert skipBuffer . length = = SKIP_BUFFER_SIZE ; long skipped = <int> ; for ( ; skipped < numBytes ; ) { final int step = ( int ) Math . min ( SKIP_BUFFER_SIZE , numBytes - skipped ) ; readBytes ( skipBuffer , <int> , step ) ; skipped + = step ; } return skipped ; } @Override public int available ( ) throws IOException { return in . available ( ) ; } @Override public synchronized void mark ( int readlimit ) { in . mark ( readlimit ) ; } public void resetDigest ( ) { digest . reset ( ) ; } } 
