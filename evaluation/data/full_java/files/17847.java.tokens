package com . badlogic . gdx . tools . hiero . unicodefont ; import java . awt . Font ; import java . awt . FontFormatException ; import java . awt . FontMetrics ; import java . awt . Rectangle ; import java . awt . font . GlyphVector ; import java . awt . font . TextAttribute ; import java . io . IOException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import org . lwjgl . opengl . GL11 ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . tools . hiero . unicodefont . effects . Effect ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class UnicodeFont { static private final int DISPLAY_LIST_CACHE_SIZE = <int> ; static private final int MAX_GLYPH_CODE = <hex> ; static private final int PAGE_SIZE = <int> ; static private final int PAGES = MAX_GLYPH_CODE / PAGE_SIZE ; private Font font ; private FontMetrics metrics ; private String ttfFileRef ; private int ascent , descent , leading , spaceWidth ; private final Glyph [ ] [ ] glyphs = new Glyph [ PAGES ] [ ] ; private final List glyphPages = new ArrayList ( ) ; private final List queuedGlyphs = new ArrayList ( <int> ) ; private final List effects = new ArrayList ( ) ; private int paddingTop , paddingLeft , paddingBottom , paddingRight , paddingAdvanceX , paddingAdvanceY ; private Glyph missingGlyph ; private int glyphPageWidth = <int> , glyphPageHeight = <int> ; private final DisplayList emptyDisplayList = new DisplayList ( ) ; private boolean nativeRendering ; private int baseDisplayListID = - <int> ; int eldestDisplayListID ; private final LinkedHashMap displayLists = new LinkedHashMap ( DISPLAY_LIST_CACHE_SIZE , <int> , true ) { protected boolean removeEldestEntry ( Entry eldest ) { DisplayList displayList = ( DisplayList ) eldest . getValue ( ) ; if ( displayList ! = null ) eldestDisplayListID = displayList . id ; return size ( ) > DISPLAY_LIST_CACHE_SIZE ; } } ; public UnicodeFont ( String ttfFileRef , String hieroFileRef ) { this ( ttfFileRef , new HieroSettings ( hieroFileRef ) ) ; } public UnicodeFont ( String ttfFileRef , HieroSettings settings ) { this . ttfFileRef = ttfFileRef ; Font font = createFont ( ttfFileRef ) ; initializeFont ( font , settings . getFontSize ( ) , settings . isBold ( ) , settings . isItalic ( ) ) ; loadSettings ( settings ) ; } public UnicodeFont ( String ttfFileRef , int size , boolean bold , boolean italic ) { this . ttfFileRef = ttfFileRef ; initializeFont ( createFont ( ttfFileRef ) , size , bold , italic ) ; } public UnicodeFont ( Font font , String hieroFileRef ) { this ( font , new HieroSettings ( hieroFileRef ) ) ; } public UnicodeFont ( Font font , HieroSettings settings ) { initializeFont ( font , settings . getFontSize ( ) , settings . isBold ( ) , settings . isItalic ( ) ) ; loadSettings ( settings ) ; } public UnicodeFont ( Font font ) { initializeFont ( font , font . getSize ( ) , font . isBold ( ) , font . isItalic ( ) ) ; } public UnicodeFont ( Font font , int size , boolean bold , boolean italic ) { initializeFont ( font , size , bold , italic ) ; } private void initializeFont ( Font baseFont , int size , boolean bold , boolean italic ) { Map attributes = baseFont . getAttributes ( ) ; attributes . put ( TextAttribute . SIZE , new Float ( size ) ) ; attributes . put ( TextAttribute . WEIGHT , bold ? TextAttribute . WEIGHT_BOLD : TextAttribute . WEIGHT_REGULAR ) ; attributes . put ( TextAttribute . POSTURE , italic ? TextAttribute . POSTURE_OBLIQUE : TextAttribute . POSTURE_REGULAR ) ; try { attributes . put ( TextAttribute . class . getDeclaredField ( <str> ) . get ( null ) , TextAttribute . class . getDeclaredField ( <str> ) . get ( null ) ) ; } catch ( Throwable ignored ) { } font = baseFont . deriveFont ( attributes ) ; metrics = GlyphPage . scratchGraphics . getFontMetrics ( font ) ; ascent = metrics . getAscent ( ) ; descent = metrics . getDescent ( ) ; leading = metrics . getLeading ( ) ; char [ ] chars = <str> . toCharArray ( ) ; GlyphVector vector = font . layoutGlyphVector ( GlyphPage . renderContext , chars , <int> , chars . length , Font . LAYOUT_LEFT_TO_RIGHT ) ; spaceWidth = vector . getGlyphLogicalBounds ( <int> ) . getBounds ( ) . width ; } private void loadSettings ( HieroSettings settings ) { paddingTop = settings . getPaddingTop ( ) ; paddingLeft = settings . getPaddingLeft ( ) ; paddingBottom = settings . getPaddingBottom ( ) ; paddingRight = settings . getPaddingRight ( ) ; paddingAdvanceX = settings . getPaddingAdvanceX ( ) ; paddingAdvanceY = settings . getPaddingAdvanceY ( ) ; glyphPageWidth = settings . getGlyphPageWidth ( ) ; glyphPageHeight = settings . getGlyphPageHeight ( ) ; effects . addAll ( settings . getEffects ( ) ) ; } public void addGlyphs ( int startCodePoint , int endCodePoint ) { for ( int codePoint = startCodePoint ; codePoint < = endCodePoint ; codePoint + + ) addGlyphs ( new String ( Character . toChars ( codePoint ) ) ) ; } public void addGlyphs ( String text ) { if ( text = = null ) throw new IllegalArgumentException ( <str> ) ; char [ ] chars = text . toCharArray ( ) ; GlyphVector vector = font . layoutGlyphVector ( GlyphPage . renderContext , chars , <int> , chars . length , Font . LAYOUT_LEFT_TO_RIGHT ) ; for ( int i = <int> , n = vector . getNumGlyphs ( ) ; i < n ; i + + ) { int codePoint = text . codePointAt ( vector . getGlyphCharIndex ( i ) ) ; Rectangle bounds = getGlyphBounds ( vector , i , codePoint ) ; getGlyph ( vector . getGlyphCode ( i ) , codePoint , bounds , vector , i ) ; } } public void addAsciiGlyphs ( ) { addGlyphs ( <int> , <int> ) ; } public void addNeheGlyphs ( ) { addGlyphs ( <int> , <int> + <int> ) ; } public boolean loadGlyphs ( ) { return loadGlyphs ( - <int> ) ; } public boolean loadGlyphs ( int maxGlyphsToLoad ) { if ( queuedGlyphs . isEmpty ( ) ) return false ; if ( effects . isEmpty ( ) ) throw new IllegalStateException ( <str> ) ; for ( Iterator iter = queuedGlyphs . iterator ( ) ; iter . hasNext ( ) ; ) { Glyph glyph = ( Glyph ) iter . next ( ) ; int codePoint = glyph . getCodePoint ( ) ; if ( glyph . getWidth ( ) = = <int> | | codePoint = = <str> ) { iter . remove ( ) ; continue ; } if ( glyph . isMissing ( ) ) { if ( missingGlyph ! = null ) { if ( glyph ! = missingGlyph ) iter . remove ( ) ; continue ; } missingGlyph = glyph ; } } Collections . sort ( queuedGlyphs , heightComparator ) ; for ( Iterator iter = glyphPages . iterator ( ) ; iter . hasNext ( ) ; ) { GlyphPage glyphPage = ( GlyphPage ) iter . next ( ) ; maxGlyphsToLoad - = glyphPage . loadGlyphs ( queuedGlyphs , maxGlyphsToLoad ) ; if ( maxGlyphsToLoad = = <int> | | queuedGlyphs . isEmpty ( ) ) return true ; } while ( ! queuedGlyphs . isEmpty ( ) ) { GlyphPage glyphPage = new GlyphPage ( this , glyphPageWidth , glyphPageHeight ) ; glyphPages . add ( glyphPage ) ; maxGlyphsToLoad - = glyphPage . loadGlyphs ( queuedGlyphs , maxGlyphsToLoad ) ; if ( maxGlyphsToLoad = = <int> ) return true ; } return true ; } public void clearGlyphs ( ) { for ( int i = <int> ; i < PAGES ; i + + ) glyphs [ i ] = null ; for ( Iterator iter = glyphPages . iterator ( ) ; iter . hasNext ( ) ; ) { GlyphPage page = ( GlyphPage ) iter . next ( ) ; page . getTexture ( ) . dispose ( ) ; } glyphPages . clear ( ) ; if ( baseDisplayListID ! = - <int> ) { GL11 . glDeleteLists ( baseDisplayListID , displayLists . size ( ) ) ; baseDisplayListID = - <int> ; } queuedGlyphs . clear ( ) ; missingGlyph = null ; } public void destroy ( ) { clearGlyphs ( ) ; } public void drawDisplayList ( float x , float y , String text , Color color , int startIndex , int endIndex ) { if ( text = = null ) throw new IllegalArgumentException ( <str> ) ; if ( text . length ( ) = = <int> ) return ; if ( color = = null ) throw new IllegalArgumentException ( <str> ) ; x - = paddingLeft ; y - = paddingTop ; String displayListKey = text . substring ( startIndex , endIndex ) ; GL11 . glColor4f ( color . r , color . g , color . b , color . a ) ; GL11 . glTranslatef ( x , y , <int> ) ; char [ ] chars = text . substring ( <int> , endIndex ) . toCharArray ( ) ; GlyphVector vector = font . layoutGlyphVector ( GlyphPage . renderContext , chars , <int> , chars . length , Font . LAYOUT_LEFT_TO_RIGHT ) ; int maxWidth = <int> , totalHeight = <int> , lines = <int> ; int extraX = <int> , extraY = ascent ; boolean startNewLine = false ; Texture lastBind = null ; int offsetX = <int> ; for ( int glyphIndex = <int> , n = vector . getNumGlyphs ( ) ; glyphIndex < n ; glyphIndex + + ) { int charIndex = vector . getGlyphCharIndex ( glyphIndex ) ; if ( charIndex < startIndex ) continue ; if ( charIndex > endIndex ) break ; int codePoint = text . codePointAt ( charIndex ) ; Rectangle bounds = getGlyphBounds ( vector , glyphIndex , codePoint ) ; bounds . x + = offsetX ; Glyph glyph = getGlyph ( vector . getGlyphCode ( glyphIndex ) , codePoint , bounds , vector , glyphIndex ) ; if ( startNewLine & & codePoint ! = <str> ) { extraX = - bounds . x ; startNewLine = false ; } if ( glyph . getTexture ( ) = = null & & missingGlyph ! = null & & glyph . isMissing ( ) ) glyph = missingGlyph ; if ( glyph . getTexture ( ) ! = null ) { Texture texture = glyph . getTexture ( ) ; if ( lastBind ! = null & & lastBind ! = texture ) { GL11 . glEnd ( ) ; lastBind = null ; } if ( lastBind = = null ) { texture . bind ( ) ; GL11 . glBegin ( GL11 . GL_QUADS ) ; lastBind = texture ; } int glyphX = bounds . x + extraX ; int glyphY = bounds . y + extraY ; GL11 . glTexCoord2f ( glyph . getU ( ) , glyph . getV ( ) ) ; GL11 . glVertex3f ( glyphX , glyphY , <int> ) ; GL11 . glTexCoord2f ( glyph . getU ( ) , glyph . getV2 ( ) ) ; GL11 . glVertex3f ( glyphX , glyphY + glyph . getHeight ( ) , <int> ) ; GL11 . glTexCoord2f ( glyph . getU2 ( ) , glyph . getV2 ( ) ) ; GL11 . glVertex3f ( glyphX + glyph . getWidth ( ) , glyphY + glyph . getHeight ( ) , <int> ) ; GL11 . glTexCoord2f ( glyph . getU2 ( ) , glyph . getV ( ) ) ; GL11 . glVertex3f ( glyphX + glyph . getWidth ( ) , glyphY , <int> ) ; } if ( glyphIndex > <int> ) extraX + = paddingRight + paddingLeft + paddingAdvanceX ; maxWidth = Math . max ( maxWidth , bounds . x + extraX + bounds . width ) ; totalHeight = Math . max ( totalHeight , ascent + bounds . y + bounds . height ) ; if ( codePoint = = <str> ) { startNewLine = true ; extraY + = getLineHeight ( ) ; lines + + ; totalHeight = <int> ; } else if ( nativeRendering ) offsetX + = bounds . width ; } if ( lastBind ! = null ) GL11 . glEnd ( ) ; GL11 . glTranslatef ( - x , - y , <int> ) ; } public void drawString ( float x , float y , String text , Color color , int startIndex , int endIndex ) { drawDisplayList ( x , y , text , color , startIndex , endIndex ) ; } public void drawString ( float x , float y , String text ) { drawString ( x , y , text , Color . WHITE ) ; } public void drawString ( float x , float y , String text , Color col ) { drawString ( x , y , text , col , <int> , text . length ( ) ) ; } private Glyph getGlyph ( int glyphCode , int codePoint , Rectangle bounds , GlyphVector vector , int index ) { if ( glyphCode < <int> | | glyphCode > = MAX_GLYPH_CODE ) { return new Glyph ( codePoint , bounds , vector , index , this ) { public boolean isMissing ( ) { return true ; } } ; } int pageIndex = glyphCode / PAGE_SIZE ; int glyphIndex = glyphCode & ( PAGE_SIZE - <int> ) ; Glyph glyph = null ; Glyph [ ] page = glyphs [ pageIndex ] ; if ( page ! = null ) { glyph = page [ glyphIndex ] ; if ( glyph ! = null ) return glyph ; } else page = glyphs [ pageIndex ] = new Glyph [ PAGE_SIZE ] ; glyph = page [ glyphIndex ] = new Glyph ( codePoint , bounds , vector , index , this ) ; queuedGlyphs . add ( glyph ) ; return glyph ; } private Rectangle getGlyphBounds ( GlyphVector vector , int index , int codePoint ) { Rectangle bounds ; bounds = vector . getGlyphPixelBounds ( index , GlyphPage . renderContext , <int> , <int> ) ; if ( nativeRendering ) { if ( bounds . width = = <int> | | bounds . height = = <int> ) bounds = new Rectangle ( ) ; else bounds = metrics . getStringBounds ( <str> + ( char ) codePoint , GlyphPage . scratchGraphics ) . getBounds ( ) ; } if ( codePoint = = <str> ) bounds . width = spaceWidth ; return bounds ; } public int getSpaceWidth ( ) { return spaceWidth ; } public int getWidth ( String text ) { if ( text = = null ) throw new IllegalArgumentException ( <str> ) ; if ( text . length ( ) = = <int> ) return <int> ; char [ ] chars = text . toCharArray ( ) ; GlyphVector vector = font . layoutGlyphVector ( GlyphPage . renderContext , chars , <int> , chars . length , Font . LAYOUT_LEFT_TO_RIGHT ) ; int width = <int> ; int extraX = <int> ; boolean startNewLine = false ; for ( int glyphIndex = <int> , n = vector . getNumGlyphs ( ) ; glyphIndex < n ; glyphIndex + + ) { int charIndex = vector . getGlyphCharIndex ( glyphIndex ) ; int codePoint = text . codePointAt ( charIndex ) ; Rectangle bounds = getGlyphBounds ( vector , glyphIndex , codePoint ) ; if ( startNewLine & & codePoint ! = <str> ) extraX = - bounds . x ; if ( glyphIndex > <int> ) extraX + = paddingLeft + paddingRight + paddingAdvanceX ; width = Math . max ( width , bounds . x + extraX + bounds . width ) ; if ( codePoint = = <str> ) startNewLine = true ; } return width ; } public int getHeight ( String text ) { if ( text = = null ) throw new IllegalArgumentException ( <str> ) ; if ( text . length ( ) = = <int> ) return <int> ; char [ ] chars = text . toCharArray ( ) ; GlyphVector vector = font . layoutGlyphVector ( GlyphPage . renderContext , chars , <int> , chars . length , Font . LAYOUT_LEFT_TO_RIGHT ) ; int lines = <int> , height = <int> ; for ( int i = <int> , n = vector . getNumGlyphs ( ) ; i < n ; i + + ) { int charIndex = vector . getGlyphCharIndex ( i ) ; int codePoint = text . codePointAt ( charIndex ) ; if ( codePoint = = <str> ) continue ; Rectangle bounds = getGlyphBounds ( vector , i , codePoint ) ; height = Math . max ( height , ascent + bounds . y + bounds . height ) ; if ( codePoint = = <str> ) { lines + + ; height = <int> ; } } return lines * getLineHeight ( ) + height ; } public int getYOffset ( String text ) { if ( text = = null ) throw new IllegalArgumentException ( <str> ) ; int index = text . indexOf ( <str> ) ; if ( index ! = - <int> ) text = text . substring ( <int> , index ) ; char [ ] chars = text . toCharArray ( ) ; GlyphVector vector = font . layoutGlyphVector ( GlyphPage . renderContext , chars , <int> , chars . length , Font . LAYOUT_LEFT_TO_RIGHT ) ; int yOffset = ascent + vector . getPixelBounds ( null , <int> , <int> ) . y ; return yOffset ; } public Font getFont ( ) { return font ; } public int getPaddingTop ( ) { return paddingTop ; } public void setPaddingTop ( int paddingTop ) { this . paddingTop = paddingTop ; } public int getPaddingLeft ( ) { return paddingLeft ; } public void setPaddingLeft ( int paddingLeft ) { this . paddingLeft = paddingLeft ; } public int getPaddingBottom ( ) { return paddingBottom ; } public void setPaddingBottom ( int paddingBottom ) { this . paddingBottom = paddingBottom ; } public int getPaddingRight ( ) { return paddingRight ; } public void setPaddingRight ( int paddingRight ) { this . paddingRight = paddingRight ; } public int getPaddingAdvanceX ( ) { return paddingAdvanceX ; } public void setPaddingAdvanceX ( int paddingAdvanceX ) { this . paddingAdvanceX = paddingAdvanceX ; } public int getPaddingAdvanceY ( ) { return paddingAdvanceY ; } public void setPaddingAdvanceY ( int paddingAdvanceY ) { this . paddingAdvanceY = paddingAdvanceY ; } public int getLineHeight ( ) { return descent + ascent + leading + paddingTop + paddingBottom + paddingAdvanceY ; } public int getAscent ( ) { return ascent ; } public int getDescent ( ) { return descent ; } public int getLeading ( ) { return leading ; } public int getGlyphPageWidth ( ) { return glyphPageWidth ; } public void setGlyphPageWidth ( int glyphPageWidth ) { this . glyphPageWidth = glyphPageWidth ; } public int getGlyphPageHeight ( ) { return glyphPageHeight ; } public void setGlyphPageHeight ( int glyphPageHeight ) { this . glyphPageHeight = glyphPageHeight ; } public List getGlyphPages ( ) { return glyphPages ; } public List getEffects ( ) { return effects ; } public void setNativeRendering ( boolean nativeRendering ) { this . nativeRendering = nativeRendering ; } public boolean getNativeRendering ( ) { return nativeRendering ; } public String getFontFile ( ) { if ( ttfFileRef = = null ) { try { Object font2D = Class . forName ( <str> ) . getDeclaredMethod ( <str> , new Class [ ] { Font . class } ) . invoke ( null , new Object [ ] { font } ) ; Field platNameField = Class . forName ( <str> ) . getDeclaredField ( <str> ) ; platNameField . setAccessible ( true ) ; ttfFileRef = ( String ) platNameField . get ( font2D ) ; } catch ( Throwable ignored ) { } if ( ttfFileRef = = null ) ttfFileRef = <str> ; } if ( ttfFileRef . length ( ) = = <int> ) return null ; return ttfFileRef ; } static private Font createFont ( String ttfFileRef ) { try { return Font . createFont ( Font . TRUETYPE_FONT , Gdx . files . absolute ( ttfFileRef ) . read ( ) ) ; } catch ( FontFormatException ex ) { throw new GdxRuntimeException ( <str> + ttfFileRef , ex ) ; } catch ( IOException ex ) { throw new GdxRuntimeException ( <str> + ttfFileRef , ex ) ; } } static private final Comparator heightComparator = new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { return ( ( Glyph ) o1 ) . getHeight ( ) - ( ( Glyph ) o2 ) . getHeight ( ) ; } } ; public class DisplayList { boolean invalid ; int id ; Short yOffset ; public short width , height ; public Object userData ; DisplayList ( ) { } } } 
