package io . netty . handler . stream ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . FileRegion ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; public class ChunkedFile implements ChunkedInput < ByteBuf > { private final RandomAccessFile file ; private final long startOffset ; private final long endOffset ; private final int chunkSize ; private long offset ; public ChunkedFile ( File file ) throws IOException { this ( file , ChunkedStream . DEFAULT_CHUNK_SIZE ) ; } public ChunkedFile ( File file , int chunkSize ) throws IOException { this ( new RandomAccessFile ( file , <str> ) , chunkSize ) ; } public ChunkedFile ( RandomAccessFile file ) throws IOException { this ( file , ChunkedStream . DEFAULT_CHUNK_SIZE ) ; } public ChunkedFile ( RandomAccessFile file , int chunkSize ) throws IOException { this ( file , <int> , file . length ( ) , chunkSize ) ; } public ChunkedFile ( RandomAccessFile file , long offset , long length , int chunkSize ) throws IOException { if ( file = = null ) { throw new NullPointerException ( <str> ) ; } if ( offset < <int> ) { throw new IllegalArgumentException ( <str> + offset + <str> ) ; } if ( length < <int> ) { throw new IllegalArgumentException ( <str> + length + <str> ) ; } if ( chunkSize < = <int> ) { throw new IllegalArgumentException ( <str> + chunkSize + <str> ) ; } this . file = file ; this . offset = startOffset = offset ; endOffset = offset + length ; this . chunkSize = chunkSize ; file . seek ( offset ) ; } public long startOffset ( ) { return startOffset ; } public long endOffset ( ) { return endOffset ; } public long currentOffset ( ) { return offset ; } @Override public boolean isEndOfInput ( ) throws Exception { return ! ( offset < endOffset & & file . getChannel ( ) . isOpen ( ) ) ; } @Override public void close ( ) throws Exception { file . close ( ) ; } @Override public ByteBuf readChunk ( ChannelHandlerContext ctx ) throws Exception { long offset = this . offset ; if ( offset > = endOffset ) { return null ; } int chunkSize = ( int ) Math . min ( this . chunkSize , endOffset - offset ) ; ByteBuf buf = ctx . alloc ( ) . heapBuffer ( chunkSize ) ; boolean release = true ; try { file . readFully ( buf . array ( ) , buf . arrayOffset ( ) , chunkSize ) ; buf . writerIndex ( chunkSize ) ; this . offset = offset + chunkSize ; release = false ; return buf ; } finally { if ( release ) { buf . release ( ) ; } } } @Override public long length ( ) { return endOffset - startOffset ; } @Override public long progress ( ) { return offset - startOffset ; } } 
