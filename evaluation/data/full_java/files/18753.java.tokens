package io . netty . buffer ; import io . netty . util . AsciiString ; import io . netty . util . ByteProcessor ; import io . netty . util . CharsetUtil ; import io . netty . util . Recycler ; import io . netty . util . Recycler . Handle ; import io . netty . util . concurrent . FastThreadLocal ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . CharBuffer ; import java . nio . charset . CharacterCodingException ; import java . nio . charset . Charset ; import java . nio . charset . CharsetDecoder ; import java . nio . charset . CharsetEncoder ; import java . nio . charset . CoderResult ; import java . util . Arrays ; import java . util . Locale ; import static io . netty . util . internal . StringUtil . NEWLINE ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static io . netty . util . internal . MathUtil . isOutOfBounds ; public final class ByteBufUtil { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ByteBufUtil . class ) ; private static final FastThreadLocal < CharBuffer > CHAR_BUFFERS = new FastThreadLocal < CharBuffer > ( ) { @Override protected CharBuffer initialValue ( ) throws Exception { return CharBuffer . allocate ( <int> ) ; } } ; private static final int MAX_CHAR_BUFFER_SIZE ; private static final int THREAD_LOCAL_BUFFER_SIZE ; static final ByteBufAllocator DEFAULT_ALLOCATOR ; static { String allocType = SystemPropertyUtil . get ( <str> , PlatformDependent . isAndroid ( ) ? <str> : <str> ) ; allocType = allocType . toLowerCase ( Locale . US ) . trim ( ) ; ByteBufAllocator alloc ; if ( <str> . equals ( allocType ) ) { alloc = UnpooledByteBufAllocator . DEFAULT ; logger . debug ( <str> , allocType ) ; } else if ( <str> . equals ( allocType ) ) { alloc = PooledByteBufAllocator . DEFAULT ; logger . debug ( <str> , allocType ) ; } else { alloc = PooledByteBufAllocator . DEFAULT ; logger . debug ( <str> , allocType ) ; } DEFAULT_ALLOCATOR = alloc ; THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil . getInt ( <str> , <int> * <int> ) ; logger . debug ( <str> , THREAD_LOCAL_BUFFER_SIZE ) ; MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil . getInt ( <str> , <int> * <int> ) ; logger . debug ( <str> , MAX_CHAR_BUFFER_SIZE ) ; } public static String hexDump ( ByteBuf buffer ) { return hexDump ( buffer , buffer . readerIndex ( ) , buffer . readableBytes ( ) ) ; } public static String hexDump ( ByteBuf buffer , int fromIndex , int length ) { return HexUtil . hexDump ( buffer , fromIndex , length ) ; } public static String hexDump ( byte [ ] array ) { return hexDump ( array , <int> , array . length ) ; } public static String hexDump ( byte [ ] array , int fromIndex , int length ) { return HexUtil . hexDump ( array , fromIndex , length ) ; } public static int hashCode ( ByteBuf buffer ) { final int aLen = buffer . readableBytes ( ) ; final int intCount = aLen > > > <int> ; final int byteCount = aLen & <int> ; int hashCode = <int> ; int arrayIndex = buffer . readerIndex ( ) ; if ( buffer . order ( ) = = ByteOrder . BIG_ENDIAN ) { for ( int i = intCount ; i > <int> ; i - - ) { hashCode = <int> * hashCode + buffer . getInt ( arrayIndex ) ; arrayIndex + = <int> ; } } else { for ( int i = intCount ; i > <int> ; i - - ) { hashCode = <int> * hashCode + swapInt ( buffer . getInt ( arrayIndex ) ) ; arrayIndex + = <int> ; } } for ( int i = byteCount ; i > <int> ; i - - ) { hashCode = <int> * hashCode + buffer . getByte ( arrayIndex + + ) ; } if ( hashCode = = <int> ) { hashCode = <int> ; } return hashCode ; } public static boolean equals ( ByteBuf a , int aStartIndex , ByteBuf b , int bStartIndex , int length ) { if ( aStartIndex < <int> | | bStartIndex < <int> | | length < <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( a . writerIndex ( ) - length < aStartIndex | | b . writerIndex ( ) - length < bStartIndex ) { return false ; } final int longCount = length > > > <int> ; final int byteCount = length & <int> ; if ( a . order ( ) = = b . order ( ) ) { for ( int i = longCount ; i > <int> ; i - - ) { if ( a . getLong ( aStartIndex ) ! = b . getLong ( bStartIndex ) ) { return false ; } aStartIndex + = <int> ; bStartIndex + = <int> ; } } else { for ( int i = longCount ; i > <int> ; i - - ) { if ( a . getLong ( aStartIndex ) ! = swapLong ( b . getLong ( bStartIndex ) ) ) { return false ; } aStartIndex + = <int> ; bStartIndex + = <int> ; } } for ( int i = byteCount ; i > <int> ; i - - ) { if ( a . getByte ( aStartIndex ) ! = b . getByte ( bStartIndex ) ) { return false ; } aStartIndex + + ; bStartIndex + + ; } return true ; } public static boolean equals ( ByteBuf bufferA , ByteBuf bufferB ) { final int aLen = bufferA . readableBytes ( ) ; if ( aLen ! = bufferB . readableBytes ( ) ) { return false ; } return equals ( bufferA , bufferA . readerIndex ( ) , bufferB , bufferB . readerIndex ( ) , aLen ) ; } public static int compare ( ByteBuf bufferA , ByteBuf bufferB ) { final int aLen = bufferA . readableBytes ( ) ; final int bLen = bufferB . readableBytes ( ) ; final int minLength = Math . min ( aLen , bLen ) ; final int uintCount = minLength > > > <int> ; final int byteCount = minLength & <int> ; int aIndex = bufferA . readerIndex ( ) ; int bIndex = bufferB . readerIndex ( ) ; if ( bufferA . order ( ) = = bufferB . order ( ) ) { for ( int i = uintCount ; i > <int> ; i - - ) { long va = bufferA . getUnsignedInt ( aIndex ) ; long vb = bufferB . getUnsignedInt ( bIndex ) ; if ( va > vb ) { return <int> ; } if ( va < vb ) { return - <int> ; } aIndex + = <int> ; bIndex + = <int> ; } } else { for ( int i = uintCount ; i > <int> ; i - - ) { long va = bufferA . getUnsignedInt ( aIndex ) ; long vb = swapInt ( bufferB . getInt ( bIndex ) ) & <hex> ; if ( va > vb ) { return <int> ; } if ( va < vb ) { return - <int> ; } aIndex + = <int> ; bIndex + = <int> ; } } for ( int i = byteCount ; i > <int> ; i - - ) { short va = bufferA . getUnsignedByte ( aIndex ) ; short vb = bufferB . getUnsignedByte ( bIndex ) ; if ( va > vb ) { return <int> ; } if ( va < vb ) { return - <int> ; } aIndex + + ; bIndex + + ; } return aLen - bLen ; } public static int indexOf ( ByteBuf buffer , int fromIndex , int toIndex , byte value ) { if ( fromIndex < = toIndex ) { return firstIndexOf ( buffer , fromIndex , toIndex , value ) ; } else { return lastIndexOf ( buffer , fromIndex , toIndex , value ) ; } } public static short swapShort ( short value ) { return Short . reverseBytes ( value ) ; } public static int swapMedium ( int value ) { int swapped = value < < <int> & <hex> | value & <hex> | value > > > <int> & <hex> ; if ( ( swapped & <hex> ) ! = <int> ) { swapped | = <hex> ; } return swapped ; } public static int swapInt ( int value ) { return Integer . reverseBytes ( value ) ; } public static long swapLong ( long value ) { return Long . reverseBytes ( value ) ; } public static ByteBuf readBytes ( ByteBufAllocator alloc , ByteBuf buffer , int length ) { boolean release = true ; ByteBuf dst = alloc . buffer ( length ) ; try { buffer . readBytes ( dst ) ; release = false ; return dst ; } finally { if ( release ) { dst . release ( ) ; } } } private static int firstIndexOf ( ByteBuf buffer , int fromIndex , int toIndex , byte value ) { fromIndex = Math . max ( fromIndex , <int> ) ; if ( fromIndex > = toIndex | | buffer . capacity ( ) = = <int> ) { return - <int> ; } return buffer . forEachByte ( fromIndex , toIndex - fromIndex , new ByteProcessor . IndexOfProcessor ( value ) ) ; } private static int lastIndexOf ( ByteBuf buffer , int fromIndex , int toIndex , byte value ) { fromIndex = Math . min ( fromIndex , buffer . capacity ( ) ) ; if ( fromIndex < <int> | | buffer . capacity ( ) = = <int> ) { return - <int> ; } return buffer . forEachByteDesc ( toIndex , fromIndex - toIndex , new ByteProcessor . IndexOfProcessor ( value ) ) ; } public static int writeUtf8 ( ByteBuf buf , CharSequence seq ) { if ( buf = = null ) { throw new NullPointerException ( <str> ) ; } if ( seq = = null ) { throw new NullPointerException ( <str> ) ; } final int len = seq . length ( ) ; final int maxSize = len * <int> ; buf . ensureWritable ( maxSize ) ; for ( ; ; ) { if ( buf instanceof AbstractByteBuf ) { return writeUtf8 ( ( AbstractByteBuf ) buf , seq , len ) ; } else if ( buf instanceof WrappedByteBuf ) { buf = buf . unwrap ( ) ; } else { byte [ ] bytes = seq . toString ( ) . getBytes ( CharsetUtil . UTF_8 ) ; buf . writeBytes ( bytes ) ; return bytes . length ; } } } private static int writeUtf8 ( AbstractByteBuf buffer , CharSequence seq , int len ) { int oldWriterIndex = buffer . writerIndex ; int writerIndex = oldWriterIndex ; for ( int i = <int> ; i < len ; i + + ) { char c = seq . charAt ( i ) ; if ( c < <hex> ) { buffer . _setByte ( writerIndex + + , ( byte ) c ) ; } else if ( c < <hex> ) { buffer . _setByte ( writerIndex + + , ( byte ) ( <hex> | ( c > > <int> ) ) ) ; buffer . _setByte ( writerIndex + + , ( byte ) ( <hex> | ( c & <hex> ) ) ) ; } else { buffer . _setByte ( writerIndex + + , ( byte ) ( <hex> | ( c > > <int> ) ) ) ; buffer . _setByte ( writerIndex + + , ( byte ) ( <hex> | ( ( c > > <int> ) & <hex> ) ) ) ; buffer . _setByte ( writerIndex + + , ( byte ) ( <hex> | ( c & <hex> ) ) ) ; } } buffer . writerIndex = writerIndex ; return writerIndex - oldWriterIndex ; } public static int writeAscii ( ByteBuf buf , CharSequence seq ) { if ( buf = = null ) { throw new NullPointerException ( <str> ) ; } if ( seq = = null ) { throw new NullPointerException ( <str> ) ; } final int len = seq . length ( ) ; buf . ensureWritable ( len ) ; if ( seq instanceof AsciiString ) { AsciiString asciiString = ( AsciiString ) seq ; buf . writeBytes ( asciiString . array ( ) , asciiString . arrayOffset ( ) , asciiString . length ( ) ) ; } else { for ( ; ; ) { if ( buf instanceof AbstractByteBuf ) { writeAscii ( ( AbstractByteBuf ) buf , seq , len ) ; break ; } else if ( buf instanceof WrappedByteBuf ) { buf = buf . unwrap ( ) ; } else { buf . writeBytes ( seq . toString ( ) . getBytes ( CharsetUtil . US_ASCII ) ) ; } } } return len ; } private static void writeAscii ( AbstractByteBuf buffer , CharSequence seq , int len ) { int writerIndex = buffer . writerIndex ; for ( int i = <int> ; i < len ; i + + ) { buffer . _setByte ( writerIndex + + , ( byte ) seq . charAt ( i ) ) ; } buffer . writerIndex = writerIndex ; } public static ByteBuf encodeString ( ByteBufAllocator alloc , CharBuffer src , Charset charset ) { return encodeString0 ( alloc , false , src , charset ) ; } static ByteBuf encodeString0 ( ByteBufAllocator alloc , boolean enforceHeap , CharBuffer src , Charset charset ) { final CharsetEncoder encoder = CharsetUtil . getEncoder ( charset ) ; int length = ( int ) ( ( double ) src . remaining ( ) * encoder . maxBytesPerChar ( ) ) ; boolean release = true ; final ByteBuf dst ; if ( enforceHeap ) { dst = alloc . heapBuffer ( length ) ; } else { dst = alloc . buffer ( length ) ; } try { final ByteBuffer dstBuf = dst . internalNioBuffer ( <int> , length ) ; final int pos = dstBuf . position ( ) ; CoderResult cr = encoder . encode ( src , dstBuf , true ) ; if ( ! cr . isUnderflow ( ) ) { cr . throwException ( ) ; } cr = encoder . flush ( dstBuf ) ; if ( ! cr . isUnderflow ( ) ) { cr . throwException ( ) ; } dst . writerIndex ( dst . writerIndex ( ) + dstBuf . position ( ) - pos ) ; release = false ; return dst ; } catch ( CharacterCodingException x ) { throw new IllegalStateException ( x ) ; } finally { if ( release ) { dst . release ( ) ; } } } static String decodeString ( ByteBuf src , int readerIndex , int len , Charset charset ) { if ( len = = <int> ) { return StringUtil . EMPTY_STRING ; } final CharsetDecoder decoder = CharsetUtil . getDecoder ( charset ) ; final int maxLength = ( int ) ( ( double ) len * decoder . maxCharsPerByte ( ) ) ; CharBuffer dst = CHAR_BUFFERS . get ( ) ; if ( dst . length ( ) < maxLength ) { dst = CharBuffer . allocate ( maxLength ) ; if ( maxLength < = MAX_CHAR_BUFFER_SIZE ) { CHAR_BUFFERS . set ( dst ) ; } } else { dst . clear ( ) ; } if ( src . nioBufferCount ( ) = = <int> ) { decodeString ( decoder , src . internalNioBuffer ( readerIndex , len ) , dst ) ; } else { ByteBuf buffer = src . alloc ( ) . heapBuffer ( len ) ; try { buffer . writeBytes ( src , readerIndex , len ) ; decodeString ( decoder , buffer . internalNioBuffer ( readerIndex , len ) , dst ) ; } finally { buffer . release ( ) ; } } return dst . flip ( ) . toString ( ) ; } private static void decodeString ( CharsetDecoder decoder , ByteBuffer src , CharBuffer dst ) { try { CoderResult cr = decoder . decode ( src , dst , true ) ; if ( ! cr . isUnderflow ( ) ) { cr . throwException ( ) ; } cr = decoder . flush ( dst ) ; if ( ! cr . isUnderflow ( ) ) { cr . throwException ( ) ; } } catch ( CharacterCodingException x ) { throw new IllegalStateException ( x ) ; } } public static ByteBuf threadLocalDirectBuffer ( ) { if ( THREAD_LOCAL_BUFFER_SIZE < = <int> ) { return null ; } if ( PlatformDependent . hasUnsafe ( ) ) { return ThreadLocalUnsafeDirectByteBuf . newInstance ( ) ; } else { return ThreadLocalDirectByteBuf . newInstance ( ) ; } } public static byte [ ] getBytes ( ByteBuf buf ) { return getBytes ( buf , buf . readerIndex ( ) , buf . readableBytes ( ) ) ; } public static byte [ ] getBytes ( ByteBuf buf , int start , int length ) { return getBytes ( buf , start , length , true ) ; } public static byte [ ] getBytes ( ByteBuf buf , int start , int length , boolean copy ) { if ( isOutOfBounds ( start , length , buf . capacity ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + start + <str> + length + <str> + <str> + buf . capacity ( ) + <str> ) ; } if ( buf . hasArray ( ) ) { if ( copy | | start ! = <int> | | length ! = buf . capacity ( ) ) { int baseOffset = buf . arrayOffset ( ) + start ; return Arrays . copyOfRange ( buf . array ( ) , baseOffset , baseOffset + length ) ; } else { return buf . array ( ) ; } } byte [ ] v = new byte [ length ] ; buf . getBytes ( start , v ) ; return v ; } public static void copy ( AsciiString src , int srcIdx , ByteBuf dst , int dstIdx , int length ) { if ( isOutOfBounds ( srcIdx , length , src . length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + srcIdx + <str> + length + <str> + src . length ( ) + <str> ) ; } checkNotNull ( dst , <str> ) . setBytes ( dstIdx , src . array ( ) , srcIdx + src . arrayOffset ( ) , length ) ; } public static void copy ( AsciiString src , int srcIdx , ByteBuf dst , int length ) { if ( isOutOfBounds ( srcIdx , length , src . length ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + srcIdx + <str> + length + <str> + src . length ( ) + <str> ) ; } checkNotNull ( dst , <str> ) . writeBytes ( src . array ( ) , srcIdx + src . arrayOffset ( ) , length ) ; } public static String prettyHexDump ( ByteBuf buffer ) { return prettyHexDump ( buffer , buffer . readerIndex ( ) , buffer . readableBytes ( ) ) ; } public static String prettyHexDump ( ByteBuf buffer , int offset , int length ) { return HexUtil . prettyHexDump ( buffer , offset , length ) ; } public static void appendPrettyHexDump ( StringBuilder dump , ByteBuf buf ) { appendPrettyHexDump ( dump , buf , buf . readerIndex ( ) , buf . readableBytes ( ) ) ; } public static void appendPrettyHexDump ( StringBuilder dump , ByteBuf buf , int offset , int length ) { HexUtil . appendPrettyHexDump ( dump , buf , offset , length ) ; } private static final class HexUtil { private static final char [ ] BYTE2CHAR = new char [ <int> ] ; private static final char [ ] HEXDUMP_TABLE = new char [ <int> * <int> ] ; private static final String [ ] HEXPADDING = new String [ <int> ] ; private static final String [ ] HEXDUMP_ROWPREFIXES = new String [ <int> > > > <int> ] ; private static final String [ ] BYTE2HEX = new String [ <int> ] ; private static final String [ ] BYTEPADDING = new String [ <int> ] ; static { final char [ ] DIGITS = <str> . toCharArray ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { HEXDUMP_TABLE [ i < < <int> ] = DIGITS [ i > > > <int> & <hex> ] ; HEXDUMP_TABLE [ ( i < < <int> ) + <int> ] = DIGITS [ i & <hex> ] ; } int i ; for ( i = <int> ; i < HEXPADDING . length ; i + + ) { int padding = HEXPADDING . length - i ; StringBuilder buf = new StringBuilder ( padding * <int> ) ; for ( int j = <int> ; j < padding ; j + + ) { buf . append ( <str> ) ; } HEXPADDING [ i ] = buf . toString ( ) ; } for ( i = <int> ; i < HEXDUMP_ROWPREFIXES . length ; i + + ) { StringBuilder buf = new StringBuilder ( <int> ) ; buf . append ( NEWLINE ) ; buf . append ( Long . toHexString ( i < < <int> & <hex> | <hex> ) ) ; buf . setCharAt ( buf . length ( ) - <int> , <str> ) ; buf . append ( <str> ) ; HEXDUMP_ROWPREFIXES [ i ] = buf . toString ( ) ; } for ( i = <int> ; i < BYTE2HEX . length ; i + + ) { BYTE2HEX [ i ] = <str> + StringUtil . byteToHexStringPadded ( i ) ; } for ( i = <int> ; i < BYTEPADDING . length ; i + + ) { int padding = BYTEPADDING . length - i ; StringBuilder buf = new StringBuilder ( padding ) ; for ( int j = <int> ; j < padding ; j + + ) { buf . append ( <str> ) ; } BYTEPADDING [ i ] = buf . toString ( ) ; } for ( i = <int> ; i < BYTE2CHAR . length ; i + + ) { if ( i < = <hex> | | i > = <hex> ) { BYTE2CHAR [ i ] = <str> ; } else { BYTE2CHAR [ i ] = ( char ) i ; } } } private static String hexDump ( ByteBuf buffer , int fromIndex , int length ) { if ( length < <int> ) { throw new IllegalArgumentException ( <str> + length ) ; } if ( length = = <int> ) { return <str> ; } int endIndex = fromIndex + length ; char [ ] buf = new char [ length < < <int> ] ; int srcIdx = fromIndex ; int dstIdx = <int> ; for ( ; srcIdx < endIndex ; srcIdx + + , dstIdx + = <int> ) { System . arraycopy ( HEXDUMP_TABLE , buffer . getUnsignedByte ( srcIdx ) < < <int> , buf , dstIdx , <int> ) ; } return new String ( buf ) ; } private static String hexDump ( byte [ ] array , int fromIndex , int length ) { if ( length < <int> ) { throw new IllegalArgumentException ( <str> + length ) ; } if ( length = = <int> ) { return <str> ; } int endIndex = fromIndex + length ; char [ ] buf = new char [ length < < <int> ] ; int srcIdx = fromIndex ; int dstIdx = <int> ; for ( ; srcIdx < endIndex ; srcIdx + + , dstIdx + = <int> ) { System . arraycopy ( HEXDUMP_TABLE , ( array [ srcIdx ] & <hex> ) < < <int> , buf , dstIdx , <int> ) ; } return new String ( buf ) ; } private static String prettyHexDump ( ByteBuf buffer , int offset , int length ) { if ( length = = <int> ) { return StringUtil . EMPTY_STRING ; } else { int rows = length / <int> + ( length % <int> = = <int> ? <int> : <int> ) + <int> ; StringBuilder buf = new StringBuilder ( rows * <int> ) ; appendPrettyHexDump ( buf , buffer , offset , length ) ; return buf . toString ( ) ; } } private static void appendPrettyHexDump ( StringBuilder dump , ByteBuf buf , int offset , int length ) { if ( isOutOfBounds ( offset , length , buf . capacity ( ) ) ) { throw new IndexOutOfBoundsException ( <str> + <str> + offset + <str> + length + <str> + <str> + buf . capacity ( ) + <str> ) ; } if ( length = = <int> ) { return ; } dump . append ( <str> + NEWLINE + <str> + NEWLINE + <str> ) ; final int startIndex = offset ; final int fullRows = length > > > <int> ; final int remainder = length & <hex> ; for ( int row = <int> ; row < fullRows ; row + + ) { int rowStartIndex = ( row < < <int> ) + startIndex ; appendHexDumpRowPrefix ( dump , row , rowStartIndex ) ; int rowEndIndex = rowStartIndex + <int> ; for ( int j = rowStartIndex ; j < rowEndIndex ; j + + ) { dump . append ( BYTE2HEX [ buf . getUnsignedByte ( j ) ] ) ; } dump . append ( <str> ) ; for ( int j = rowStartIndex ; j < rowEndIndex ; j + + ) { dump . append ( BYTE2CHAR [ buf . getUnsignedByte ( j ) ] ) ; } dump . append ( <str> ) ; } if ( remainder ! = <int> ) { int rowStartIndex = ( fullRows < < <int> ) + startIndex ; appendHexDumpRowPrefix ( dump , fullRows , rowStartIndex ) ; int rowEndIndex = rowStartIndex + remainder ; for ( int j = rowStartIndex ; j < rowEndIndex ; j + + ) { dump . append ( BYTE2HEX [ buf . getUnsignedByte ( j ) ] ) ; } dump . append ( HEXPADDING [ remainder ] ) ; dump . append ( <str> ) ; for ( int j = rowStartIndex ; j < rowEndIndex ; j + + ) { dump . append ( BYTE2CHAR [ buf . getUnsignedByte ( j ) ] ) ; } dump . append ( BYTEPADDING [ remainder ] ) ; dump . append ( <str> ) ; } dump . append ( NEWLINE + <str> ) ; } private static void appendHexDumpRowPrefix ( StringBuilder dump , int row , int rowStartIndex ) { if ( row < HEXDUMP_ROWPREFIXES . length ) { dump . append ( HEXDUMP_ROWPREFIXES [ row ] ) ; } else { dump . append ( NEWLINE ) ; dump . append ( Long . toHexString ( rowStartIndex & <hex> | <hex> ) ) ; dump . setCharAt ( dump . length ( ) - <int> , <str> ) ; dump . append ( <str> ) ; } } } static final class ThreadLocalUnsafeDirectByteBuf extends UnpooledUnsafeDirectByteBuf { private static final Recycler < ThreadLocalUnsafeDirectByteBuf > RECYCLER = new Recycler < ThreadLocalUnsafeDirectByteBuf > ( ) { @Override protected ThreadLocalUnsafeDirectByteBuf newObject ( Handle handle ) { return new ThreadLocalUnsafeDirectByteBuf ( handle ) ; } } ; static ThreadLocalUnsafeDirectByteBuf newInstance ( ) { ThreadLocalUnsafeDirectByteBuf buf = RECYCLER . get ( ) ; buf . setRefCnt ( <int> ) ; return buf ; } private final Handle handle ; private ThreadLocalUnsafeDirectByteBuf ( Handle handle ) { super ( UnpooledByteBufAllocator . DEFAULT , <int> , Integer . MAX_VALUE ) ; this . handle = handle ; } @Override protected void deallocate ( ) { if ( capacity ( ) > THREAD_LOCAL_BUFFER_SIZE ) { super . deallocate ( ) ; } else { clear ( ) ; RECYCLER . recycle ( this , handle ) ; } } } static final class ThreadLocalDirectByteBuf extends UnpooledDirectByteBuf { private static final Recycler < ThreadLocalDirectByteBuf > RECYCLER = new Recycler < ThreadLocalDirectByteBuf > ( ) { @Override protected ThreadLocalDirectByteBuf newObject ( Handle handle ) { return new ThreadLocalDirectByteBuf ( handle ) ; } } ; static ThreadLocalDirectByteBuf newInstance ( ) { ThreadLocalDirectByteBuf buf = RECYCLER . get ( ) ; buf . setRefCnt ( <int> ) ; return buf ; } private final Handle handle ; private ThreadLocalDirectByteBuf ( Handle handle ) { super ( UnpooledByteBufAllocator . DEFAULT , <int> , Integer . MAX_VALUE ) ; this . handle = handle ; } @Override protected void deallocate ( ) { if ( capacity ( ) > THREAD_LOCAL_BUFFER_SIZE ) { super . deallocate ( ) ; } else { clear ( ) ; RECYCLER . recycle ( this , handle ) ; } } } private ByteBufUtil ( ) { } } 
