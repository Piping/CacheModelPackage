package io . netty . handler . codec . json ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufUtil ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . channel . ChannelHandler ; import io . netty . handler . codec . CorruptedFrameException ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . channel . ChannelPipeline ; import java . util . List ; public class JsonObjectDecoder extends ByteToMessageDecoder { private static final int ST_CORRUPTED = - <int> ; private static final int ST_INIT = <int> ; private static final int ST_DECODING_NORMAL = <int> ; private static final int ST_DECODING_ARRAY_STREAM = <int> ; private int openBraces ; private int idx ; private int state ; private boolean insideString ; private final int maxObjectLength ; private final boolean streamArrayElements ; public JsonObjectDecoder ( ) { this ( <int> * <int> ) ; } public JsonObjectDecoder ( int maxObjectLength ) { this ( maxObjectLength , false ) ; } public JsonObjectDecoder ( boolean streamArrayElements ) { this ( <int> * <int> , streamArrayElements ) ; } public JsonObjectDecoder ( int maxObjectLength , boolean streamArrayElements ) { if ( maxObjectLength < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maxObjectLength = maxObjectLength ; this . streamArrayElements = streamArrayElements ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( state = = ST_CORRUPTED ) { in . skipBytes ( in . readableBytes ( ) ) ; return ; } int idx = this . idx ; int wrtIdx = in . writerIndex ( ) ; if ( wrtIdx > maxObjectLength ) { in . skipBytes ( in . readableBytes ( ) ) ; reset ( ) ; throw new TooLongFrameException ( <str> + maxObjectLength + <str> + wrtIdx + <str> ) ; } for ( ; idx < wrtIdx ; idx + + ) { byte c = in . getByte ( idx ) ; if ( state = = ST_DECODING_NORMAL ) { decodeByte ( c , in , idx ) ; if ( openBraces = = <int> ) { ByteBuf json = extractObject ( ctx , in , in . readerIndex ( ) , idx + <int> - in . readerIndex ( ) ) ; if ( json ! = null ) { out . add ( json ) ; } in . readerIndex ( idx + <int> ) ; reset ( ) ; } } else if ( state = = ST_DECODING_ARRAY_STREAM ) { decodeByte ( c , in , idx ) ; if ( ! insideString & & ( openBraces = = <int> & & c = = <str> | | openBraces = = <int> & & c = = <str> ) ) { for ( int i = in . readerIndex ( ) ; Character . isWhitespace ( in . getByte ( i ) ) ; i + + ) { in . skipBytes ( <int> ) ; } int idxNoSpaces = idx - <int> ; while ( idxNoSpaces > = in . readerIndex ( ) & & Character . isWhitespace ( in . getByte ( idxNoSpaces ) ) ) { idxNoSpaces - - ; } ByteBuf json = extractObject ( ctx , in , in . readerIndex ( ) , idxNoSpaces + <int> - in . readerIndex ( ) ) ; if ( json ! = null ) { out . add ( json ) ; } in . readerIndex ( idx + <int> ) ; if ( c = = <str> ) { reset ( ) ; } } } else if ( c = = <str> | | c = = <str> ) { initDecoding ( c ) ; if ( state = = ST_DECODING_ARRAY_STREAM ) { in . skipBytes ( <int> ) ; } } else if ( Character . isWhitespace ( c ) ) { in . skipBytes ( <int> ) ; } else { state = ST_CORRUPTED ; throw new CorruptedFrameException ( <str> + idx + <str> + ByteBufUtil . hexDump ( in ) ) ; } } if ( in . readableBytes ( ) = = <int> ) { this . idx = <int> ; } else { this . idx = idx ; } } @SuppressWarnings ( <str> ) protected ByteBuf extractObject ( ChannelHandlerContext ctx , ByteBuf buffer , int index , int length ) { return buffer . slice ( index , length ) . retain ( ) ; } private void decodeByte ( byte c , ByteBuf in , int idx ) { if ( ( c = = <str> | | c = = <str> ) & & ! insideString ) { openBraces + + ; } else if ( ( c = = <str> | | c = = <str> ) & & ! insideString ) { openBraces - - ; } else if ( c = = <str> ) { if ( ! insideString ) { insideString = true ; } else if ( in . getByte ( idx - <int> ) ! = <str> ) { insideString = false ; } } } private void initDecoding ( byte openingBrace ) { openBraces = <int> ; if ( openingBrace = = <str> & & streamArrayElements ) { state = ST_DECODING_ARRAY_STREAM ; } else { state = ST_DECODING_NORMAL ; } } private void reset ( ) { insideString = false ; state = ST_INIT ; openBraces = <int> ; } } 
