package io . netty . handler . codec . compression ; import static io . netty . handler . codec . compression . Bzip2Constants . * ; final class Bzip2BlockDecompressor { private final Bzip2BitReader reader ; private final Crc32 crc = new Crc32 ( ) ; private final int blockCRC ; private final boolean blockRandomised ; int huffmanEndOfBlockSymbol ; int huffmanInUse16 ; final byte [ ] huffmanSymbolMap = new byte [ <int> ] ; private final int [ ] bwtByteCounts = new int [ <int> ] ; private final byte [ ] bwtBlock ; private final int bwtStartPointer ; private int [ ] bwtMergedPointers ; private int bwtCurrentMergedPointer ; private int bwtBlockLength ; private int bwtBytesDecoded ; private int rleLastDecodedByte = - <int> ; private int rleAccumulator ; private int rleRepeat ; private int randomIndex ; private int randomCount = Bzip2Rand . rNums ( <int> ) - <int> ; private final Bzip2MoveToFrontTable symbolMTF = new Bzip2MoveToFrontTable ( ) ; private int repeatCount ; private int repeatIncrement = <int> ; private int mtfValue ; Bzip2BlockDecompressor ( final int blockSize , final int blockCRC , final boolean blockRandomised , final int bwtStartPointer , final Bzip2BitReader reader ) { bwtBlock = new byte [ blockSize ] ; this . blockCRC = blockCRC ; this . blockRandomised = blockRandomised ; this . bwtStartPointer = bwtStartPointer ; this . reader = reader ; } boolean decodeHuffmanData ( final Bzip2HuffmanStageDecoder huffmanDecoder ) { final Bzip2BitReader reader = this . reader ; final byte [ ] bwtBlock = this . bwtBlock ; final byte [ ] huffmanSymbolMap = this . huffmanSymbolMap ; final int streamBlockSize = this . bwtBlock . length ; final int huffmanEndOfBlockSymbol = this . huffmanEndOfBlockSymbol ; final int [ ] bwtByteCounts = this . bwtByteCounts ; final Bzip2MoveToFrontTable symbolMTF = this . symbolMTF ; int bwtBlockLength = this . bwtBlockLength ; int repeatCount = this . repeatCount ; int repeatIncrement = this . repeatIncrement ; int mtfValue = this . mtfValue ; for ( ; ; ) { if ( ! reader . hasReadableBits ( HUFFMAN_DECODE_MAX_CODE_LENGTH ) ) { this . bwtBlockLength = bwtBlockLength ; this . repeatCount = repeatCount ; this . repeatIncrement = repeatIncrement ; this . mtfValue = mtfValue ; return false ; } final int nextSymbol = huffmanDecoder . nextSymbol ( ) ; if ( nextSymbol = = HUFFMAN_SYMBOL_RUNA ) { repeatCount + = repeatIncrement ; repeatIncrement < < = <int> ; } else if ( nextSymbol = = HUFFMAN_SYMBOL_RUNB ) { repeatCount + = repeatIncrement < < <int> ; repeatIncrement < < = <int> ; } else { if ( repeatCount > <int> ) { if ( bwtBlockLength + repeatCount > streamBlockSize ) { throw new DecompressionException ( <str> ) ; } final byte nextByte = huffmanSymbolMap [ mtfValue ] ; bwtByteCounts [ nextByte & <hex> ] + = repeatCount ; while ( - - repeatCount > = <int> ) { bwtBlock [ bwtBlockLength + + ] = nextByte ; } repeatCount = <int> ; repeatIncrement = <int> ; } if ( nextSymbol = = huffmanEndOfBlockSymbol ) { break ; } if ( bwtBlockLength > = streamBlockSize ) { throw new DecompressionException ( <str> ) ; } mtfValue = symbolMTF . indexToFront ( nextSymbol - <int> ) & <hex> ; final byte nextByte = huffmanSymbolMap [ mtfValue ] ; bwtByteCounts [ nextByte & <hex> ] + + ; bwtBlock [ bwtBlockLength + + ] = nextByte ; } } this . bwtBlockLength = bwtBlockLength ; initialiseInverseBWT ( ) ; return true ; } private void initialiseInverseBWT ( ) { final int bwtStartPointer = this . bwtStartPointer ; final byte [ ] bwtBlock = this . bwtBlock ; final int [ ] bwtMergedPointers = new int [ bwtBlockLength ] ; final int [ ] characterBase = new int [ <int> ] ; if ( bwtStartPointer < <int> | | bwtStartPointer > = bwtBlockLength ) { throw new DecompressionException ( <str> ) ; } System . arraycopy ( bwtByteCounts , <int> , characterBase , <int> , <int> ) ; for ( int i = <int> ; i < = <int> ; i + + ) { characterBase [ i ] + = characterBase [ i - <int> ] ; } for ( int i = <int> ; i < bwtBlockLength ; i + + ) { int value = bwtBlock [ i ] & <hex> ; bwtMergedPointers [ characterBase [ value ] + + ] = ( i < < <int> ) + value ; } this . bwtMergedPointers = bwtMergedPointers ; bwtCurrentMergedPointer = bwtMergedPointers [ bwtStartPointer ] ; } public int read ( ) { while ( rleRepeat < <int> ) { if ( bwtBytesDecoded = = bwtBlockLength ) { return - <int> ; } int nextByte = decodeNextBWTByte ( ) ; if ( nextByte ! = rleLastDecodedByte ) { rleLastDecodedByte = nextByte ; rleRepeat = <int> ; rleAccumulator = <int> ; crc . updateCRC ( nextByte ) ; } else { if ( + + rleAccumulator = = <int> ) { int rleRepeat = decodeNextBWTByte ( ) + <int> ; this . rleRepeat = rleRepeat ; rleAccumulator = <int> ; crc . updateCRC ( nextByte , rleRepeat ) ; } else { rleRepeat = <int> ; crc . updateCRC ( nextByte ) ; } } } rleRepeat - - ; return rleLastDecodedByte ; } private int decodeNextBWTByte ( ) { int mergedPointer = bwtCurrentMergedPointer ; int nextDecodedByte = mergedPointer & <hex> ; bwtCurrentMergedPointer = bwtMergedPointers [ mergedPointer > > > <int> ] ; if ( blockRandomised ) { if ( - - randomCount = = <int> ) { nextDecodedByte ^ = <int> ; randomIndex = ( randomIndex + <int> ) % <int> ; randomCount = Bzip2Rand . rNums ( randomIndex ) ; } } bwtBytesDecoded + + ; return nextDecodedByte ; } public int blockLength ( ) { return bwtBlockLength ; } int checkCRC ( ) { final int computedBlockCRC = crc . getCRC ( ) ; if ( blockCRC ! = computedBlockCRC ) { throw new DecompressionException ( <str> ) ; } return computedBlockCRC ; } } 
