package org . gradle . internal . rules ; import com . google . common . collect . Lists ; import groovy . lang . Closure ; import java . util . Arrays ; import java . util . List ; public class ClosureBackedRuleAction < T > implements RuleAction < T > { private final Closure closure ; private final Class < ? super T > subjectType ; private List < Class < ? > > inputTypes ; public ClosureBackedRuleAction ( Class < T > subjectType , Closure < ? > closure ) { this . subjectType = subjectType ; this . closure = closure ; this . inputTypes = parseInputTypes ( closure ) ; } public List < Class < ? > > getInputTypes ( ) { return inputTypes ; } public void execute ( T subject , List < ? > inputs ) { Closure copy = ( Closure ) closure . clone ( ) ; copy . setResolveStrategy ( Closure . DELEGATE_FIRST ) ; copy . setDelegate ( subject ) ; if ( closure . getMaximumNumberOfParameters ( ) = = <int> ) { copy . call ( ) ; } else { Object [ ] argList = new Object [ inputs . size ( ) + <int> ] ; argList [ <int> ] = subject ; int i = <int> ; for ( Object arg : inputs ) { argList [ i + + ] = arg ; } copy . call ( argList ) ; } } private List < Class < ? > > parseInputTypes ( Closure < ? > closure ) { Class < ? > [ ] parameterTypes = closure . getParameterTypes ( ) ; List < Class < ? > > inputTypes = Lists . newArrayList ( ) ; if ( parameterTypes . length ! = <int> ) { if ( parameterTypes [ <int> ] . isAssignableFrom ( subjectType ) ) { for ( Class < ? > parameterType : Arrays . asList ( parameterTypes ) . subList ( <int> , parameterTypes . length ) ) { inputTypes . add ( parameterType ) ; } } else { throw new RuleActionValidationException ( String . format ( <str> , subjectType . getSimpleName ( ) ) ) ; } } return inputTypes ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } ClosureBackedRuleAction that = ( ClosureBackedRuleAction ) o ; return closure . equals ( that . closure ) & & subjectType . equals ( that . subjectType ) ; } @Override public int hashCode ( ) { int result = closure . hashCode ( ) ; result = <int> * result + subjectType . hashCode ( ) ; return result ; } } 
