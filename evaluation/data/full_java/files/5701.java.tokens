package org . elasticsearch . common . collect ; import org . apache . lucene . util . mutable . MutableValueInt ; import java . lang . reflect . Array ; import java . util . * ; import java . util . stream . Stream ; public final class CopyOnWriteHashMap < K , V > extends AbstractMap < K , V > { private static final int TOTAL_HASH_BITS = <int> ; private static final Object [ ] EMPTY_ARRAY = new Object [ <int> ] ; private static final int HASH_BITS = <int> ; private static final int HASH_MASK = <hex> ; public static < K , V > CopyOnWriteHashMap < K , V > copyOf ( Map < ? extends K , ? extends V > map ) { if ( map instanceof CopyOnWriteHashMap ) { @SuppressWarnings ( <str> ) final CopyOnWriteHashMap < K , V > cowMap = ( CopyOnWriteHashMap < K , V > ) map ; return cowMap ; } else { return new CopyOnWriteHashMap < K , V > ( ) . copyAndPutAll ( map ) ; } } private static abstract class Node < K , V > { abstract V get ( Object key , int hash ) ; abstract Node < K , V > put ( K key , int hash , int hashBits , V value , MutableValueInt newValue ) ; abstract Node < K , V > remove ( Object key , int hash ) ; abstract void visit ( Deque < Map . Entry < K , V > > entries , Deque < Node < K , V > > nodes ) ; abstract boolean isEmpty ( ) ; } private static class Leaf < K , V > extends Node < K , V > { private final K [ ] keys ; private final V [ ] values ; Leaf ( K [ ] keys , V [ ] values ) { this . keys = keys ; this . values = values ; } @SuppressWarnings ( <str> ) Leaf ( ) { this ( ( K [ ] ) EMPTY_ARRAY , ( V [ ] ) EMPTY_ARRAY ) ; } @Override boolean isEmpty ( ) { return keys . length = = <int> ; } @Override void visit ( Deque < Map . Entry < K , V > > entries , Deque < Node < K , V > > nodes ) { for ( int i = <int> ; i < keys . length ; + + i ) { entries . add ( new AbstractMap . SimpleImmutableEntry < > ( keys [ i ] , values [ i ] ) ) ; } } @Override V get ( Object key , int hash ) { for ( int i = <int> ; i < keys . length ; i + + ) { if ( key . equals ( keys [ i ] ) ) { return values [ i ] ; } } return null ; } private static < T > T [ ] replace ( T [ ] array , int index , T value ) { final T [ ] copy = Arrays . copyOf ( array , array . length ) ; copy [ index ] = value ; return copy ; } @Override Leaf < K , V > put ( K key , int hash , int hashBits , V value , MutableValueInt newValue ) { assert hashBits < = <int> : hashBits ; int slot = - <int> ; for ( int i = <int> ; i < keys . length ; i + + ) { if ( key . equals ( keys [ i ] ) ) { slot = i ; break ; } } final K [ ] keys2 ; final V [ ] values2 ; if ( slot < <int> ) { keys2 = appendElement ( keys , key ) ; values2 = appendElement ( values , value ) ; newValue . value = <int> ; } else { keys2 = replace ( keys , slot , key ) ; values2 = replace ( values , slot , value ) ; } return new Leaf < > ( keys2 , values2 ) ; } @Override Leaf < K , V > remove ( Object key , int hash ) { int slot = - <int> ; for ( int i = <int> ; i < keys . length ; i + + ) { if ( key . equals ( keys [ i ] ) ) { slot = i ; break ; } } if ( slot < <int> ) { return this ; } final K [ ] keys2 = removeArrayElement ( keys , slot ) ; final V [ ] values2 = removeArrayElement ( values , slot ) ; return new Leaf < > ( keys2 , values2 ) ; } } private static < T > T [ ] removeArrayElement ( T [ ] array , int index ) { final Object result = Array . newInstance ( array . getClass ( ) . getComponentType ( ) , array . length - <int> ) ; System . arraycopy ( array , <int> , result , <int> , index ) ; if ( index < array . length - <int> ) { System . arraycopy ( array , index + <int> , result , index , array . length - index - <int> ) ; } return ( T [ ] ) result ; } public static < T > T [ ] appendElement ( final T [ ] array , final T element ) { final T [ ] newArray = Arrays . copyOf ( array , array . length + <int> ) ; newArray [ newArray . length - <int> ] = element ; return newArray ; } public static < T > T [ ] insertElement ( final T [ ] array , final T element , final int index ) { final T [ ] result = Arrays . copyOf ( array , array . length + <int> ) ; System . arraycopy ( array , <int> , result , <int> , index ) ; result [ index ] = element ; if ( index < array . length ) { System . arraycopy ( array , index , result , index + <int> , array . length - index ) ; } return result ; } private static class InnerNode < K , V > extends Node < K , V > { private final long mask ; private final K [ ] keys ; final Object [ ] subNodes ; InnerNode ( long mask , K [ ] keys , Object [ ] subNodes ) { this . mask = mask ; this . keys = keys ; this . subNodes = subNodes ; assert consistent ( ) ; } private boolean consistent ( ) { assert Long . bitCount ( mask ) = = keys . length ; assert Long . bitCount ( mask ) = = subNodes . length ; for ( int i = <int> ; i < keys . length ; + + i ) { if ( subNodes [ i ] instanceof Node ) { assert keys [ i ] = = null ; } else { assert keys [ i ] ! = null ; } } return true ; } @Override boolean isEmpty ( ) { return mask = = <int> ; } @SuppressWarnings ( <str> ) InnerNode ( ) { this ( <int> , ( K [ ] ) EMPTY_ARRAY , EMPTY_ARRAY ) ; } @Override void visit ( Deque < Map . Entry < K , V > > entries , Deque < Node < K , V > > nodes ) { for ( int i = <int> ; i < keys . length ; + + i ) { final Object sub = subNodes [ i ] ; if ( sub instanceof Node ) { @SuppressWarnings ( <str> ) final Node < K , V > subNode = ( Node < K , V > ) sub ; assert keys [ i ] = = null ; nodes . add ( subNode ) ; } else { @SuppressWarnings ( <str> ) final V value = ( V ) sub ; entries . add ( new AbstractMap . SimpleImmutableEntry < > ( keys [ i ] , value ) ) ; } } } private boolean exists ( int hash6 ) { return ( mask & ( <int> < < hash6 ) ) ! = <int> ; } private int slot ( int hash6 ) { return Long . bitCount ( mask & ( ( <int> < < hash6 ) - <int> ) ) ; } @Override V get ( Object key , int hash ) { final int hash6 = hash & HASH_MASK ; if ( ! exists ( hash6 ) ) { return null ; } final int slot = slot ( hash6 ) ; final Object sub = subNodes [ slot ] ; assert sub ! = null ; if ( sub instanceof Node ) { assert keys [ slot ] = = null ; @SuppressWarnings ( <str> ) final Node < K , V > subNode = ( Node < K , V > ) sub ; return subNode . get ( key , hash > > > HASH_BITS ) ; } else { if ( keys [ slot ] . equals ( key ) ) { @SuppressWarnings ( <str> ) final V v = ( V ) sub ; return v ; } else { return null ; } } } private Node < K , V > newSubNode ( int hashBits ) { if ( hashBits < = <int> ) { return new Leaf < K , V > ( ) ; } else { return new InnerNode < K , V > ( ) ; } } private InnerNode < K , V > putExisting ( K key , int hash , int hashBits , int slot , V value , MutableValueInt newValue ) { final K [ ] keys2 = Arrays . copyOf ( keys , keys . length ) ; final Object [ ] subNodes2 = Arrays . copyOf ( subNodes , subNodes . length ) ; final Object previousValue = subNodes2 [ slot ] ; if ( previousValue instanceof Node ) { assert keys [ slot ] = = null ; subNodes2 [ slot ] = ( ( Node < K , V > ) previousValue ) . put ( key , hash , hashBits , value , newValue ) ; } else if ( keys [ slot ] . equals ( key ) ) { subNodes2 [ slot ] = value ; } else { final K previousKey = keys [ slot ] ; final int previousHash = previousKey . hashCode ( ) > > > ( TOTAL_HASH_BITS - hashBits ) ; Node < K , V > subNode = newSubNode ( hashBits ) ; subNode = subNode . put ( previousKey , previousHash , hashBits , ( V ) previousValue , newValue ) ; subNode = subNode . put ( key , hash , hashBits , value , newValue ) ; keys2 [ slot ] = null ; subNodes2 [ slot ] = subNode ; } return new InnerNode < > ( mask , keys2 , subNodes2 ) ; } private InnerNode < K , V > putNew ( K key , int hash6 , int slot , V value ) { final long mask2 = mask | ( <int> < < hash6 ) ; final K [ ] keys2 = insertElement ( keys , key , slot ) ; final Object [ ] subNodes2 = insertElement ( subNodes , value , slot ) ; return new InnerNode < > ( mask2 , keys2 , subNodes2 ) ; } @Override InnerNode < K , V > put ( K key , int hash , int hashBits , V value , MutableValueInt newValue ) { final int hash6 = hash & HASH_MASK ; final int slot = slot ( hash6 ) ; if ( exists ( hash6 ) ) { hash > > > = HASH_BITS ; hashBits - = HASH_BITS ; return putExisting ( key , hash , hashBits , slot , value , newValue ) ; } else { newValue . value = <int> ; return putNew ( key , hash6 , slot , value ) ; } } private InnerNode < K , V > removeSlot ( int hash6 , int slot ) { final long mask2 = mask & ~ ( <int> < < hash6 ) ; final K [ ] keys2 = removeArrayElement ( keys , slot ) ; final Object [ ] subNodes2 = removeArrayElement ( subNodes , slot ) ; return new InnerNode < > ( mask2 , keys2 , subNodes2 ) ; } @Override InnerNode < K , V > remove ( Object key , int hash ) { final int hash6 = hash & HASH_MASK ; if ( ! exists ( hash6 ) ) { return this ; } final int slot = slot ( hash6 ) ; final Object previousValue = subNodes [ slot ] ; if ( previousValue instanceof Node ) { @SuppressWarnings ( <str> ) final Node < K , V > subNode = ( Node < K , V > ) previousValue ; final Node < K , V > removed = subNode . remove ( key , hash > > > HASH_BITS ) ; if ( removed = = subNode ) { return this ; } if ( removed . isEmpty ( ) ) { return removeSlot ( hash6 , slot ) ; } final K [ ] keys2 = Arrays . copyOf ( keys , keys . length ) ; final Object [ ] subNodes2 = Arrays . copyOf ( subNodes , subNodes . length ) ; subNodes2 [ slot ] = removed ; return new InnerNode < > ( mask , keys2 , subNodes2 ) ; } else if ( keys [ slot ] . equals ( key ) ) { return removeSlot ( hash6 , slot ) ; } else { return this ; } } } private static class EntryIterator < K , V > implements Iterator < Map . Entry < K , V > > { private final Deque < Map . Entry < K , V > > entries ; private final Deque < Node < K , V > > nodes ; public EntryIterator ( Node < K , V > node ) { entries = new ArrayDeque < > ( ) ; nodes = new ArrayDeque < > ( ) ; node . visit ( entries , nodes ) ; } @Override public boolean hasNext ( ) { return ! entries . isEmpty ( ) | | ! nodes . isEmpty ( ) ; } @Override public Map . Entry < K , V > next ( ) { while ( entries . isEmpty ( ) ) { if ( nodes . isEmpty ( ) ) { throw new NoSuchElementException ( ) ; } final Node < K , V > nextNode = nodes . pop ( ) ; nextNode . visit ( entries , nodes ) ; } return entries . pop ( ) ; } @Override public final void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private final InnerNode < K , V > root ; private final int size ; public CopyOnWriteHashMap ( ) { this ( new InnerNode < K , V > ( ) , <int> ) ; } private CopyOnWriteHashMap ( InnerNode < K , V > root , int size ) { this . root = root ; this . size = size ; } @Override public boolean containsKey ( Object key ) { return get ( key ) ! = null ; } @Override public V get ( Object key ) { if ( key = = null ) { throw new IllegalArgumentException ( <str> ) ; } final int hash = key . hashCode ( ) ; return root . get ( key , hash ) ; } @Override public int size ( ) { assert size ! = <int> | | root . isEmpty ( ) ; return size ; } public CopyOnWriteHashMap < K , V > copyAndPut ( K key , V value ) { if ( key = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( value = = null ) { throw new IllegalArgumentException ( <str> ) ; } final int hash = key . hashCode ( ) ; final MutableValueInt newValue = new MutableValueInt ( ) ; final InnerNode < K , V > newRoot = root . put ( key , hash , TOTAL_HASH_BITS , value , newValue ) ; final int newSize = size + newValue . value ; return new CopyOnWriteHashMap < > ( newRoot , newSize ) ; } public CopyOnWriteHashMap < K , V > copyAndPutAll ( Map < ? extends K , ? extends V > other ) { return copyAndPutAll ( other . entrySet ( ) ) ; } public < K1 extends K , V1 extends V > CopyOnWriteHashMap < K , V > copyAndPutAll ( Iterable < Entry < K1 , V1 > > entries ) { CopyOnWriteHashMap < K , V > result = this ; for ( Entry < K1 , V1 > entry : entries ) { result = result . copyAndPut ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } public < K1 extends K , V1 extends V > CopyOnWriteHashMap < K , V > copyAndPutAll ( Stream < Entry < K1 , V1 > > entries ) { return copyAndPutAll ( entries : : iterator ) ; } public CopyOnWriteHashMap < K , V > copyAndRemove ( Object key ) { if ( key = = null ) { throw new IllegalArgumentException ( <str> ) ; } final int hash = key . hashCode ( ) ; final InnerNode < K , V > newRoot = root . remove ( key , hash ) ; if ( root = = newRoot ) { return this ; } else { return new CopyOnWriteHashMap < > ( newRoot , size - <int> ) ; } } public CopyOnWriteHashMap < K , V > copyAndRemoveAll ( Collection < ? > keys ) { CopyOnWriteHashMap < K , V > result = this ; for ( Object key : keys ) { result = result . copyAndRemove ( key ) ; } return result ; } @Override public Set < Map . Entry < K , V > > entrySet ( ) { return new AbstractSet < Map . Entry < K , V > > ( ) { @Override public Iterator < java . util . Map . Entry < K , V > > iterator ( ) { return new EntryIterator < > ( root ) ; } @Override public boolean contains ( Object o ) { if ( o = = null | | ! ( o instanceof Map . Entry ) ) { return false ; } Map . Entry < ? , ? > entry = ( java . util . Map . Entry < ? , ? > ) o ; return entry . getValue ( ) . equals ( CopyOnWriteHashMap . this . get ( entry . getKey ( ) ) ) ; } @Override public int size ( ) { return CopyOnWriteHashMap . this . size ( ) ; } } ; } } 
