package io . netty . handler . codec ; import org . junit . Test ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . NoSuchElementException ; import static io . netty . util . AsciiString . of ; import static java . util . Arrays . asList ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotEquals ; import static org . junit . Assert . assertNotSame ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; public class DefaultHeadersTest { private static final class TestDefaultHeaders extends DefaultHeaders < CharSequence , CharSequence , TestDefaultHeaders > { public TestDefaultHeaders ( ) { super ( CharSequenceValueConverter . INSTANCE ) ; } } private TestDefaultHeaders newInstance ( ) { return new TestDefaultHeaders ( ) ; } @Test public void addShouldIncreaseAndRemoveShouldDecreaseTheSize ( ) { TestDefaultHeaders headers = newInstance ( ) ; assertEquals ( <int> , headers . size ( ) ) ; headers . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; headers . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; headers . remove ( of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; headers . remove ( of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; headers . remove ( of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; assertTrue ( headers . isEmpty ( ) ) ; } @Test public void afterClearHeadersShouldBeEmpty ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; headers . clear ( ) ; assertEquals ( <int> , headers . size ( ) ) ; assertTrue ( headers . isEmpty ( ) ) ; assertFalse ( headers . contains ( of ( <str> ) ) ) ; assertFalse ( headers . contains ( of ( <str> ) ) ) ; } @Test public void removingANameForASecondTimeShouldReturnFalse ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; assertTrue ( headers . remove ( of ( <str> ) ) ) ; assertFalse ( headers . remove ( of ( <str> ) ) ) ; } @Test public void multipleValuesPerNameShouldBeAllowed ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; List < CharSequence > values = headers . getAll ( of ( <str> ) ) ; assertEquals ( <int> , values . size ( ) ) ; assertTrue ( values . containsAll ( asList ( of ( <str> ) , of ( <str> ) , of ( <str> ) ) ) ) ; } @Test public void testContains ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . addBoolean ( of ( <str> ) , true ) ; assertTrue ( headers . containsBoolean ( of ( <str> ) , true ) ) ; assertFalse ( headers . containsBoolean ( of ( <str> ) , false ) ) ; headers . addLong ( of ( <str> ) , Long . MAX_VALUE ) ; assertTrue ( headers . containsLong ( of ( <str> ) , Long . MAX_VALUE ) ) ; assertFalse ( headers . containsLong ( of ( <str> ) , Long . MIN_VALUE ) ) ; headers . addInt ( of ( <str> ) , Integer . MIN_VALUE ) ; assertTrue ( headers . containsInt ( of ( <str> ) , Integer . MIN_VALUE ) ) ; assertFalse ( headers . containsInt ( of ( <str> ) , Integer . MAX_VALUE ) ) ; headers . addShort ( of ( <str> ) , Short . MAX_VALUE ) ; assertTrue ( headers . containsShort ( of ( <str> ) , Short . MAX_VALUE ) ) ; assertFalse ( headers . containsShort ( of ( <str> ) , Short . MIN_VALUE ) ) ; headers . addChar ( of ( <str> ) , Character . MAX_VALUE ) ; assertTrue ( headers . containsChar ( of ( <str> ) , Character . MAX_VALUE ) ) ; assertFalse ( headers . containsChar ( of ( <str> ) , Character . MIN_VALUE ) ) ; headers . addByte ( of ( <str> ) , Byte . MAX_VALUE ) ; assertTrue ( headers . containsByte ( of ( <str> ) , Byte . MAX_VALUE ) ) ; assertFalse ( headers . containsLong ( of ( <str> ) , Byte . MIN_VALUE ) ) ; headers . addDouble ( of ( <str> ) , Double . MAX_VALUE ) ; assertTrue ( headers . containsDouble ( of ( <str> ) , Double . MAX_VALUE ) ) ; assertFalse ( headers . containsDouble ( of ( <str> ) , Double . MIN_VALUE ) ) ; headers . addFloat ( of ( <str> ) , Float . MAX_VALUE ) ; assertTrue ( headers . containsFloat ( of ( <str> ) , Float . MAX_VALUE ) ) ; assertFalse ( headers . containsFloat ( of ( <str> ) , Float . MIN_VALUE ) ) ; long millis = System . currentTimeMillis ( ) ; headers . addTimeMillis ( of ( <str> ) , millis ) ; assertTrue ( headers . containsTimeMillis ( of ( <str> ) , millis ) ) ; assertFalse ( headers . containsTimeMillis ( of ( <str> ) , <int> ) ) ; headers . addObject ( of ( <str> ) , <str> ) ; assertTrue ( headers . containsObject ( of ( <str> ) , <str> ) ) ; assertFalse ( headers . containsObject ( of ( <str> ) , <str> ) ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; assertTrue ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; assertFalse ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; } @Test public void testCopy ( ) throws Exception { TestDefaultHeaders headers = newInstance ( ) ; headers . addBoolean ( of ( <str> ) , true ) ; headers . addLong ( of ( <str> ) , Long . MAX_VALUE ) ; headers . addInt ( of ( <str> ) , Integer . MIN_VALUE ) ; headers . addShort ( of ( <str> ) , Short . MAX_VALUE ) ; headers . addChar ( of ( <str> ) , Character . MAX_VALUE ) ; headers . addByte ( of ( <str> ) , Byte . MAX_VALUE ) ; headers . addDouble ( of ( <str> ) , Double . MAX_VALUE ) ; headers . addFloat ( of ( <str> ) , Float . MAX_VALUE ) ; long millis = System . currentTimeMillis ( ) ; headers . addTimeMillis ( of ( <str> ) , millis ) ; headers . addObject ( of ( <str> ) , <str> ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; headers = newInstance ( ) . add ( headers ) ; assertTrue ( headers . containsBoolean ( of ( <str> ) , true ) ) ; assertFalse ( headers . containsBoolean ( of ( <str> ) , false ) ) ; assertTrue ( headers . containsLong ( of ( <str> ) , Long . MAX_VALUE ) ) ; assertFalse ( headers . containsLong ( of ( <str> ) , Long . MIN_VALUE ) ) ; assertTrue ( headers . containsInt ( of ( <str> ) , Integer . MIN_VALUE ) ) ; assertFalse ( headers . containsInt ( of ( <str> ) , Integer . MAX_VALUE ) ) ; assertTrue ( headers . containsShort ( of ( <str> ) , Short . MAX_VALUE ) ) ; assertFalse ( headers . containsShort ( of ( <str> ) , Short . MIN_VALUE ) ) ; assertTrue ( headers . containsChar ( of ( <str> ) , Character . MAX_VALUE ) ) ; assertFalse ( headers . containsChar ( of ( <str> ) , Character . MIN_VALUE ) ) ; assertTrue ( headers . containsByte ( of ( <str> ) , Byte . MAX_VALUE ) ) ; assertFalse ( headers . containsLong ( of ( <str> ) , Byte . MIN_VALUE ) ) ; assertTrue ( headers . containsDouble ( of ( <str> ) , Double . MAX_VALUE ) ) ; assertFalse ( headers . containsDouble ( of ( <str> ) , Double . MIN_VALUE ) ) ; assertTrue ( headers . containsFloat ( of ( <str> ) , Float . MAX_VALUE ) ) ; assertFalse ( headers . containsFloat ( of ( <str> ) , Float . MIN_VALUE ) ) ; assertTrue ( headers . containsTimeMillis ( of ( <str> ) , millis ) ) ; assertFalse ( headers . containsTimeMillis ( of ( <str> ) , <int> ) ) ; assertTrue ( headers . containsObject ( of ( <str> ) , <str> ) ) ; assertFalse ( headers . containsObject ( of ( <str> ) , <str> ) ) ; assertTrue ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; assertFalse ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; } @Test public void canMixConvertedAndNormalValues ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; headers . addInt ( of ( <str> ) , <int> ) ; headers . addBoolean ( of ( <str> ) , false ) ; assertEquals ( <int> , headers . size ( ) ) ; assertTrue ( headers . contains ( of ( <str> ) ) ) ; assertTrue ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; assertTrue ( headers . containsInt ( of ( <str> ) , <int> ) ) ; assertTrue ( headers . containsBoolean ( of ( <str> ) , false ) ) ; } @Test public void testGetAndRemove ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; headers . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; headers . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; assertEquals ( of ( <str> ) , headers . getAndRemove ( of ( <str> ) , of ( <str> ) ) ) ; assertEquals ( of ( <str> ) , headers . getAndRemove ( of ( <str> ) ) ) ; assertNull ( headers . getAndRemove ( of ( <str> ) ) ) ; assertEquals ( asList ( of ( <str> ) , of ( <str> ) , of ( <str> ) ) , headers . getAllAndRemove ( of ( <str> ) ) ) ; assertEquals ( <int> , headers . size ( ) ) ; assertNull ( headers . getAndRemove ( of ( <str> ) ) ) ; assertEquals ( of ( <str> ) , headers . getAndRemove ( of ( <str> ) , of ( <str> ) ) ) ; } @Test public void whenNameContainsMultipleValuesGetShouldReturnTheFirst ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; assertEquals ( of ( <str> ) , headers . get ( of ( <str> ) ) ) ; } @Test public void getWithDefaultValueWorks ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; assertEquals ( of ( <str> ) , headers . get ( of ( <str> ) , of ( <str> ) ) ) ; assertEquals ( of ( <str> ) , headers . get ( of ( <str> ) , of ( <str> ) ) ) ; } @Test public void setShouldOverWritePreviousValue ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . set ( of ( <str> ) , of ( <str> ) ) ; headers . set ( of ( <str> ) , of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; assertEquals ( <int> , headers . getAll ( of ( <str> ) ) . size ( ) ) ; assertEquals ( of ( <str> ) , headers . getAll ( of ( <str> ) ) . get ( <int> ) ) ; assertEquals ( of ( <str> ) , headers . get ( of ( <str> ) ) ) ; } @Test public void setAllShouldOverwriteSomeAndLeaveOthersUntouched ( ) { TestDefaultHeaders h1 = newInstance ( ) ; h1 . add ( of ( <str> ) , of ( <str> ) ) ; h1 . add ( of ( <str> ) , of ( <str> ) ) ; h1 . add ( of ( <str> ) , of ( <str> ) ) ; h1 . add ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders h2 = newInstance ( ) ; h2 . add ( of ( <str> ) , of ( <str> ) ) ; h2 . add ( of ( <str> ) , of ( <str> ) ) ; h2 . add ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders expected = newInstance ( ) ; expected . add ( of ( <str> ) , of ( <str> ) ) ; expected . add ( of ( <str> ) , of ( <str> ) ) ; expected . add ( of ( <str> ) , of ( <str> ) ) ; expected . add ( of ( <str> ) , of ( <str> ) ) ; h1 . setAll ( h2 ) ; assertEquals ( expected , h1 ) ; } @Test public void headersWithSameNamesAndValuesShouldBeEquivalent ( ) { TestDefaultHeaders headers1 = newInstance ( ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders headers2 = newInstance ( ) ; headers2 . add ( of ( <str> ) , of ( <str> ) ) ; headers2 . add ( of ( <str> ) , of ( <str> ) ) ; headers2 . add ( of ( <str> ) , of ( <str> ) ) ; assertEquals ( headers1 , headers2 ) ; assertEquals ( headers2 , headers1 ) ; assertEquals ( headers1 , headers1 ) ; assertEquals ( headers2 , headers2 ) ; assertEquals ( headers1 . hashCode ( ) , headers2 . hashCode ( ) ) ; assertEquals ( headers1 . hashCode ( ) , headers1 . hashCode ( ) ) ; assertEquals ( headers2 . hashCode ( ) , headers2 . hashCode ( ) ) ; } @Test public void emptyHeadersShouldBeEqual ( ) { TestDefaultHeaders headers1 = newInstance ( ) ; TestDefaultHeaders headers2 = newInstance ( ) ; assertNotSame ( headers1 , headers2 ) ; assertEquals ( headers1 , headers2 ) ; assertEquals ( headers1 . hashCode ( ) , headers2 . hashCode ( ) ) ; } @Test public void headersWithSameNamesButDifferentValuesShouldNotBeEquivalent ( ) { TestDefaultHeaders headers1 = newInstance ( ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders headers2 = newInstance ( ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; assertNotEquals ( headers1 , headers2 ) ; } @Test public void subsetOfHeadersShouldNotBeEquivalent ( ) { TestDefaultHeaders headers1 = newInstance ( ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders headers2 = newInstance ( ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; assertNotEquals ( headers1 , headers2 ) ; } @Test public void headersWithDifferentNamesAndValuesShouldNotBeEquivalent ( ) { TestDefaultHeaders h1 = newInstance ( ) ; h1 . set ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders h2 = newInstance ( ) ; h2 . set ( of ( <str> ) , of ( <str> ) ) ; assertNotEquals ( h1 , h2 ) ; assertNotEquals ( h2 , h1 ) ; assertEquals ( h1 , h1 ) ; assertEquals ( h2 , h2 ) ; } @Test ( expected = NoSuchElementException . class ) public void iterateEmptyHeadersShouldThrow ( ) { Iterator < Map . Entry < CharSequence , CharSequence > > iterator = newInstance ( ) . iterator ( ) ; assertFalse ( iterator . hasNext ( ) ) ; iterator . next ( ) ; } @Test public void iteratorShouldReturnAllNameValuePairs ( ) { TestDefaultHeaders headers1 = newInstance ( ) ; headers1 . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; headers1 . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; headers1 . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; assertEquals ( <int> , headers1 . size ( ) ) ; TestDefaultHeaders headers2 = newInstance ( ) ; for ( Entry < CharSequence , CharSequence > entry : headers1 ) { headers2 . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } assertEquals ( headers1 , headers2 ) ; } @Test public void iteratorSetValueShouldChangeHeaderValue ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( of ( <str> ) , of ( <str> ) , of ( <str> ) , of ( <str> ) ) ; headers . add ( of ( <str> ) , of ( <str> ) ) ; assertEquals ( <int> , headers . size ( ) ) ; Iterator < Entry < CharSequence , CharSequence > > iter = headers . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < CharSequence , CharSequence > header = iter . next ( ) ; if ( of ( <str> ) . equals ( header . getKey ( ) ) & & of ( <str> ) . equals ( header . getValue ( ) ) ) { header . setValue ( of ( <str> ) ) ; assertEquals ( of ( <str> ) , header . getValue ( ) ) ; } if ( of ( <str> ) . equals ( header . getKey ( ) ) & & of ( <str> ) . equals ( header . getValue ( ) ) ) { header . setValue ( of ( <str> ) ) ; assertEquals ( of ( <str> ) , header . getValue ( ) ) ; } } assertEquals ( <int> , headers . size ( ) ) ; assertTrue ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; assertFalse ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; assertTrue ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; assertFalse ( headers . contains ( of ( <str> ) , of ( <str> ) ) ) ; } @Test public void getAllReturnsEmptyListForUnknownName ( ) { TestDefaultHeaders headers = newInstance ( ) ; assertEquals ( <int> , headers . getAll ( of ( <str> ) ) . size ( ) ) ; } @Test public void setHeadersShouldClearAndOverwrite ( ) { TestDefaultHeaders headers1 = newInstance ( ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders headers2 = newInstance ( ) ; headers2 . add ( of ( <str> ) , of ( <str> ) ) ; headers2 . add ( of ( <str> ) , of ( <str> ) ) ; headers1 . set ( headers2 ) ; assertEquals ( headers1 , headers2 ) ; } @Test public void setAllHeadersShouldOnlyOverwriteHeaders ( ) { TestDefaultHeaders headers1 = newInstance ( ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; headers1 . add ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders headers2 = newInstance ( ) ; headers2 . add ( of ( <str> ) , of ( <str> ) ) ; headers2 . add ( of ( <str> ) , of ( <str> ) ) ; TestDefaultHeaders expected = newInstance ( ) ; expected . add ( of ( <str> ) , of ( <str> ) ) ; expected . add ( of ( <str> ) , of ( <str> ) ) ; expected . add ( of ( <str> ) , of ( <str> ) ) ; headers1 . setAll ( headers2 ) ; assertEquals ( headers1 , expected ) ; } @Test ( expected = IllegalArgumentException . class ) public void testAddSelf ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( headers ) ; } @Test public void testSetSelfIsNoOp ( ) { TestDefaultHeaders headers = newInstance ( ) ; headers . add ( <str> , <str> ) ; headers . set ( headers ) ; assertEquals ( <int> , headers . size ( ) ) ; } } 
