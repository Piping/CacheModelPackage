package org . apache . cassandra . db . lifecycle ; import java . io . File ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . stream . Collectors ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . collect . Iterables ; import org . apache . commons . lang3 . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . db . lifecycle . LogRecord . Type ; import org . apache . cassandra . io . sstable . SSTable ; import org . apache . cassandra . io . sstable . format . big . BigFormat ; import org . apache . cassandra . utils . Throwables ; import static org . apache . cassandra . utils . Throwables . merge ; final class LogFile { private static final Logger logger = LoggerFactory . getLogger ( LogFile . class ) ; static String EXT = <str> ; static char SEP = <str> ; static Pattern FILE_REGEX = Pattern . compile ( String . format ( <str> , EXT ) ) ; private final LogReplicaSet replicas = new LogReplicaSet ( ) ; private final LinkedHashSet < LogRecord > records = new LinkedHashSet < > ( ) ; private final OperationType type ; private final UUID id ; static LogFile make ( File logReplica ) { return make ( logReplica . getName ( ) , Collections . singletonList ( logReplica ) ) ; } static LogFile make ( String fileName , List < File > logReplicas ) { Matcher matcher = LogFile . FILE_REGEX . matcher ( fileName ) ; boolean matched = matcher . matches ( ) ; assert matched & & matcher . groupCount ( ) = = <int> ; OperationType operationType = OperationType . fromFileName ( matcher . group ( <int> ) ) ; UUID id = UUID . fromString ( matcher . group ( <int> ) ) ; return new LogFile ( operationType , id , logReplicas ) ; } Throwable syncFolder ( Throwable accumulate ) { return replicas . syncFolder ( accumulate ) ; } OperationType type ( ) { return type ; } UUID id ( ) { return id ; } Throwable removeUnfinishedLeftovers ( Throwable accumulate ) { try { deleteFilesForRecordsOfType ( committed ( ) ? Type . REMOVE : Type . ADD ) ; Throwables . maybeFail ( syncFolder ( accumulate ) ) ; accumulate = replicas . delete ( accumulate ) ; } catch ( Throwable t ) { accumulate = merge ( accumulate , t ) ; } return accumulate ; } static boolean isLogFile ( File file ) { return LogFile . FILE_REGEX . matcher ( file . getName ( ) ) . matches ( ) ; } LogFile ( OperationType type , UUID id , List < File > replicas ) { this ( type , id ) ; this . replicas . addReplicas ( replicas ) ; } LogFile ( OperationType type , UUID id ) { this . type = type ; this . id = id ; } boolean verify ( ) { assert records . isEmpty ( ) ; if ( ! replicas . readRecords ( records ) ) { logger . error ( <str> , replicas ) ; return false ; } records . forEach ( LogFile : : verifyRecord ) ; Optional < LogRecord > firstInvalid = records . stream ( ) . filter ( LogRecord : : isInvalidOrPartial ) . findFirst ( ) ; if ( ! firstInvalid . isPresent ( ) ) return true ; LogRecord failedOn = firstInvalid . get ( ) ; if ( getLastRecord ( ) ! = failedOn ) { logError ( failedOn ) ; return false ; } records . stream ( ) . filter ( ( r ) - > r ! = failedOn ) . forEach ( LogFile : : verifyRecordWithCorruptedLastRecord ) ; if ( records . stream ( ) . filter ( ( r ) - > r ! = failedOn ) . filter ( LogRecord : : isInvalid ) . map ( LogFile : : logError ) . findFirst ( ) . isPresent ( ) ) { logError ( failedOn ) ; return false ; } logger . warn ( String . format ( <str> + <str> , id , failedOn . error ( ) ) ) ; return true ; } static LogRecord logError ( LogRecord record ) { logger . error ( <str> , record . error ( ) ) ; return record ; } static void verifyRecord ( LogRecord record ) { if ( record . checksum ! = record . computeChecksum ( ) ) { record . setError ( String . format ( <str> , record . fileName ( ) , record , record . checksum , record . computeChecksum ( ) ) ) ; return ; } if ( record . type ! = Type . REMOVE ) return ; record . status . onDiskRecord = record . withExistingFiles ( ) ; if ( record . updateTime ! = record . status . onDiskRecord . updateTime & & record . status . onDiskRecord . numFiles > <int> ) { record . setError ( String . format ( <str> + <str> , record . fileName ( ) , record , record . status . onDiskRecord . updateTime , record . updateTime ) ) ; } } static void verifyRecordWithCorruptedLastRecord ( LogRecord record ) { if ( record . type = = Type . REMOVE & & record . status . onDiskRecord . numFiles < record . numFiles ) { record . setError ( String . format ( <str> + <str> + <str> , record . fileName ( ) , record . raw , record . status . onDiskRecord . numFiles , record . numFiles ) ) ; } } void commit ( ) { assert ! completed ( ) : <str> ; addRecord ( LogRecord . makeCommit ( System . currentTimeMillis ( ) ) ) ; } void abort ( ) { assert ! completed ( ) : <str> ; addRecord ( LogRecord . makeAbort ( System . currentTimeMillis ( ) ) ) ; } private boolean isLastRecordValidWithType ( Type type ) { LogRecord lastRecord = getLastRecord ( ) ; return lastRecord ! = null & & lastRecord . type = = type & & lastRecord . isValid ( ) ; } boolean committed ( ) { return isLastRecordValidWithType ( Type . COMMIT ) ; } boolean aborted ( ) { return isLastRecordValidWithType ( Type . ABORT ) ; } boolean completed ( ) { return committed ( ) | | aborted ( ) ; } void add ( Type type , SSTable table ) { if ( ! addRecord ( makeRecord ( type , table ) ) ) throw new IllegalStateException ( ) ; } private LogRecord makeRecord ( Type type , SSTable table ) { assert type = = Type . ADD | | type = = Type . REMOVE ; File folder = table . descriptor . directory ; replicas . maybeCreateReplica ( folder , getFileName ( folder ) , records ) ; return LogRecord . make ( type , table ) ; } private boolean addRecord ( LogRecord record ) { if ( records . contains ( record ) ) return false ; replicas . append ( record ) ; return records . add ( record ) ; } void remove ( Type type , SSTable table ) { LogRecord record = makeRecord ( type , table ) ; assert records . contains ( record ) : String . format ( <str> , record , id ) ; deleteRecordFiles ( record ) ; records . remove ( record ) ; } boolean contains ( Type type , SSTable table ) { return records . contains ( makeRecord ( type , table ) ) ; } void deleteFilesForRecordsOfType ( Type type ) { records . stream ( ) . filter ( type : : matches ) . forEach ( LogFile : : deleteRecordFiles ) ; records . clear ( ) ; } private static void deleteRecordFiles ( LogRecord record ) { List < File > files = record . getExistingFiles ( ) ; files . sort ( ( f1 , f2 ) - > Long . compare ( f1 . lastModified ( ) , f2 . lastModified ( ) ) ) ; files . forEach ( LogTransaction : : delete ) ; } Map < LogRecord , Set < File > > getFilesOfType ( NavigableSet < File > files , Type type ) { Map < LogRecord , Set < File > > ret = new HashMap < > ( ) ; records . stream ( ) . filter ( type : : matches ) . filter ( LogRecord : : isValid ) . forEach ( ( r ) - > ret . put ( r , getRecordFiles ( files , r ) ) ) ; return ret ; } LogRecord getLastRecord ( ) { return Iterables . getLast ( records , null ) ; } private static Set < File > getRecordFiles ( NavigableSet < File > files , LogRecord record ) { String fileName = record . fileName ( ) ; return files . stream ( ) . filter ( f - > f . getName ( ) . startsWith ( fileName ) ) . collect ( Collectors . toSet ( ) ) ; } boolean exists ( ) { return replicas . exists ( ) ; } void close ( ) { replicas . close ( ) ; } @Override public String toString ( ) { return replicas . toString ( ) ; } @VisibleForTesting List < File > getFiles ( ) { return replicas . getFiles ( ) ; } @VisibleForTesting List < String > getFilePaths ( ) { return replicas . getFilePaths ( ) ; } private String getFileName ( File folder ) { String fileName = StringUtils . join ( BigFormat . latestVersion , LogFile . SEP , <str> , LogFile . SEP , type . fileName , LogFile . SEP , id . toString ( ) , LogFile . EXT ) ; return StringUtils . join ( folder , File . separator , fileName ) ; } } 
