package com . google . common . cache ; import com . google . common . cache . AbstractCache . SimpleStatsCounter ; import com . google . common . cache . AbstractCache . StatsCounter ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Lists ; import junit . framework . TestCase ; import java . util . List ; import java . util . concurrent . atomic . AtomicReference ; public class AbstractCacheTest extends TestCase { public void testGetIfPresent ( ) { final AtomicReference < Object > valueRef = new AtomicReference < Object > ( ) ; Cache < Object , Object > cache = new AbstractCache < Object , Object > ( ) { @Override public Object getIfPresent ( Object key ) { return valueRef . get ( ) ; } } ; assertNull ( cache . getIfPresent ( new Object ( ) ) ) ; Object newValue = new Object ( ) ; valueRef . set ( newValue ) ; assertSame ( newValue , cache . getIfPresent ( new Object ( ) ) ) ; } public void testGetAllPresent_empty ( ) { Cache < Object , Object > cache = new AbstractCache < Object , Object > ( ) { @Override public Object getIfPresent ( Object key ) { return null ; } } ; assertEquals ( ImmutableMap . of ( ) , cache . getAllPresent ( ImmutableList . of ( new Object ( ) ) ) ) ; } public void testGetAllPresent_cached ( ) { final Object cachedKey = new Object ( ) ; final Object cachedValue = new Object ( ) ; Cache < Object , Object > cache = new AbstractCache < Object , Object > ( ) { @Override public Object getIfPresent ( Object key ) { return cachedKey . equals ( key ) ? cachedValue : null ; } } ; assertEquals ( ImmutableMap . of ( cachedKey , cachedValue ) , cache . getAllPresent ( ImmutableList . of ( cachedKey , new Object ( ) ) ) ) ; } public void testInvalidateAll ( ) { final List < Object > invalidated = Lists . newArrayList ( ) ; Cache < Integer , Integer > cache = new AbstractCache < Integer , Integer > ( ) { @Override public Integer getIfPresent ( Object key ) { throw new UnsupportedOperationException ( ) ; } @Override public void invalidate ( Object key ) { invalidated . add ( key ) ; } } ; List < Integer > toInvalidate = ImmutableList . of ( <int> , <int> , <int> , <int> ) ; cache . invalidateAll ( toInvalidate ) ; assertEquals ( toInvalidate , invalidated ) ; } public void testEmptySimpleStats ( ) { StatsCounter counter = new SimpleStatsCounter ( ) ; CacheStats stats = counter . snapshot ( ) ; assertEquals ( <int> , stats . requestCount ( ) ) ; assertEquals ( <int> , stats . hitCount ( ) ) ; assertEquals ( <float> , stats . hitRate ( ) ) ; assertEquals ( <int> , stats . missCount ( ) ) ; assertEquals ( <float> , stats . missRate ( ) ) ; assertEquals ( <int> , stats . loadSuccessCount ( ) ) ; assertEquals ( <int> , stats . loadExceptionCount ( ) ) ; assertEquals ( <int> , stats . loadCount ( ) ) ; assertEquals ( <int> , stats . totalLoadTime ( ) ) ; assertEquals ( <float> , stats . averageLoadPenalty ( ) ) ; assertEquals ( <int> , stats . evictionCount ( ) ) ; } public void testSingleSimpleStats ( ) { StatsCounter counter = new SimpleStatsCounter ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { counter . recordHits ( <int> ) ; } for ( int i = <int> ; i < <int> ; i + + ) { counter . recordLoadSuccess ( i ) ; } for ( int i = <int> ; i < <int> ; i + + ) { counter . recordLoadException ( i ) ; } for ( int i = <int> ; i < <int> ; i + + ) { counter . recordMisses ( <int> ) ; } for ( int i = <int> ; i < <int> ; i + + ) { counter . recordEviction ( ) ; } CacheStats stats = counter . snapshot ( ) ; int requestCount = <int> + <int> ; assertEquals ( requestCount , stats . requestCount ( ) ) ; assertEquals ( <int> , stats . hitCount ( ) ) ; assertEquals ( <float> / requestCount , stats . hitRate ( ) ) ; int missCount = <int> ; assertEquals ( missCount , stats . missCount ( ) ) ; assertEquals ( ( ( double ) missCount ) / requestCount , stats . missRate ( ) ) ; assertEquals ( <int> , stats . loadSuccessCount ( ) ) ; assertEquals ( <int> , stats . loadExceptionCount ( ) ) ; assertEquals ( <int> + <int> , stats . loadCount ( ) ) ; assertEquals ( <int> , stats . totalLoadTime ( ) ) ; assertEquals ( <float> / ( <int> + <int> ) , stats . averageLoadPenalty ( ) ) ; assertEquals ( <int> , stats . evictionCount ( ) ) ; } public void testSimpleStatsIncrementBy ( ) { long totalLoadTime = <int> ; SimpleStatsCounter counter1 = new SimpleStatsCounter ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { counter1 . recordHits ( <int> ) ; } for ( int i = <int> ; i < <int> ; i + + ) { counter1 . recordLoadSuccess ( i ) ; totalLoadTime + = i ; } for ( int i = <int> ; i < <int> ; i + + ) { counter1 . recordLoadException ( i ) ; totalLoadTime + = i ; } for ( int i = <int> ; i < <int> ; i + + ) { counter1 . recordMisses ( <int> ) ; } for ( int i = <int> ; i < <int> ; i + + ) { counter1 . recordEviction ( ) ; } SimpleStatsCounter counter2 = new SimpleStatsCounter ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { counter2 . recordHits ( <int> ) ; } for ( int i = <int> ; i < <int> ; i + + ) { counter2 . recordLoadSuccess ( i ) ; totalLoadTime + = i ; } for ( int i = <int> ; i < <int> ; i + + ) { counter2 . recordLoadException ( i ) ; totalLoadTime + = i ; } for ( int i = <int> ; i < <int> ; i + + ) { counter2 . recordMisses ( <int> ) ; } for ( int i = <int> ; i < <int> ; i + + ) { counter2 . recordEviction ( ) ; } counter1 . incrementBy ( counter2 ) ; assertEquals ( new CacheStats ( <int> , <int> , <int> , <int> , totalLoadTime , <int> ) , counter1 . snapshot ( ) ) ; } } 
