package org . elasticsearch . index . analysis ; import com . carrotsearch . randomizedtesting . annotations . Listeners ; import com . carrotsearch . randomizedtesting . annotations . ThreadLeakScope ; import com . carrotsearch . randomizedtesting . annotations . ThreadLeakScope . Scope ; import com . carrotsearch . randomizedtesting . annotations . TimeoutSuite ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . RamUsageEstimator ; import org . apache . lucene . util . TimeUnits ; import org . elasticsearch . test . junit . listeners . ReproduceInfoPrinter ; import org . junit . BeforeClass ; import java . util . Locale ; @Deprecated @Listeners ( { ReproduceInfoPrinter . class } ) @ThreadLeakScope ( Scope . NONE ) @TimeoutSuite ( millis = TimeUnits . HOUR ) @LuceneTestCase.SuppressSysoutChecks ( bugUrl = <str> ) public class TestIndexableBinaryStringTools extends LuceneTestCase { private static int NUM_RANDOM_TESTS ; private static int MAX_RANDOM_BINARY_LENGTH ; @BeforeClass public static void beforeClass ( ) throws Exception { NUM_RANDOM_TESTS = atLeast ( <int> ) ; MAX_RANDOM_BINARY_LENGTH = atLeast ( <int> ) ; } public void testSingleBinaryRoundTrip ( ) { byte [ ] binary = new byte [ ] { ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> } ; int encodedLen = IndexableBinaryStringTools . getEncodedLength ( binary , <int> , binary . length ) ; char encoded [ ] = new char [ encodedLen ] ; IndexableBinaryStringTools . encode ( binary , <int> , binary . length , encoded , <int> , encoded . length ) ; int decodedLen = IndexableBinaryStringTools . getDecodedLength ( encoded , <int> , encoded . length ) ; byte decoded [ ] = new byte [ decodedLen ] ; IndexableBinaryStringTools . decode ( encoded , <int> , encoded . length , decoded , <int> , decoded . length ) ; assertEquals ( <str> + System . getProperty ( <str> ) + <str> + binaryDump ( binary , binary . length ) + System . getProperty ( <str> ) + <str> + charArrayDump ( encoded , encoded . length ) + System . getProperty ( <str> ) + <str> + binaryDump ( decoded , decoded . length ) , binaryDump ( binary , binary . length ) , binaryDump ( decoded , decoded . length ) ) ; } public void testEncodedSortability ( ) { byte [ ] originalArray1 = new byte [ MAX_RANDOM_BINARY_LENGTH ] ; char [ ] originalString1 = new char [ MAX_RANDOM_BINARY_LENGTH ] ; char [ ] encoded1 = new char [ MAX_RANDOM_BINARY_LENGTH * <int> ] ; byte [ ] original2 = new byte [ MAX_RANDOM_BINARY_LENGTH ] ; char [ ] originalString2 = new char [ MAX_RANDOM_BINARY_LENGTH ] ; char [ ] encoded2 = new char [ MAX_RANDOM_BINARY_LENGTH * <int> ] ; for ( int testNum = <int> ; testNum < NUM_RANDOM_TESTS ; + + testNum ) { int numBytes1 = random ( ) . nextInt ( MAX_RANDOM_BINARY_LENGTH - <int> ) + <int> ; for ( int byteNum = <int> ; byteNum < numBytes1 ; + + byteNum ) { int randomInt = random ( ) . nextInt ( <hex> ) ; originalArray1 [ byteNum ] = ( byte ) randomInt ; originalString1 [ byteNum ] = ( char ) randomInt ; } int numBytes2 = random ( ) . nextInt ( MAX_RANDOM_BINARY_LENGTH - <int> ) + <int> ; for ( int byteNum = <int> ; byteNum < numBytes2 ; + + byteNum ) { int randomInt = random ( ) . nextInt ( <hex> ) ; original2 [ byteNum ] = ( byte ) randomInt ; originalString2 [ byteNum ] = ( char ) randomInt ; } int originalComparison = new String ( originalString1 , <int> , numBytes1 ) . compareTo ( new String ( originalString2 , <int> , numBytes2 ) ) ; originalComparison = originalComparison < <int> ? - <int> : originalComparison > <int> ? <int> : <int> ; int encodedLen1 = IndexableBinaryStringTools . getEncodedLength ( originalArray1 , <int> , numBytes1 ) ; if ( encodedLen1 > encoded1 . length ) encoded1 = new char [ ArrayUtil . oversize ( encodedLen1 , RamUsageEstimator . NUM_BYTES_CHAR ) ] ; IndexableBinaryStringTools . encode ( originalArray1 , <int> , numBytes1 , encoded1 , <int> , encodedLen1 ) ; int encodedLen2 = IndexableBinaryStringTools . getEncodedLength ( original2 , <int> , numBytes2 ) ; if ( encodedLen2 > encoded2 . length ) encoded2 = new char [ ArrayUtil . oversize ( encodedLen2 , RamUsageEstimator . NUM_BYTES_CHAR ) ] ; IndexableBinaryStringTools . encode ( original2 , <int> , numBytes2 , encoded2 , <int> , encodedLen2 ) ; int encodedComparison = new String ( encoded1 , <int> , encodedLen1 ) . compareTo ( new String ( encoded2 , <int> , encodedLen2 ) ) ; encodedComparison = encodedComparison < <int> ? - <int> : encodedComparison > <int> ? <int> : <int> ; assertEquals ( <str> + ( testNum + <int> ) + <str> + System . getProperty ( <str> ) + <str> + binaryDump ( originalArray1 , numBytes1 ) + System . getProperty ( <str> ) + <str> + binaryDump ( original2 , numBytes2 ) + System . getProperty ( <str> ) + <str> + charArrayDump ( encoded1 , encodedLen1 ) + System . getProperty ( <str> ) + <str> + charArrayDump ( encoded2 , encodedLen2 ) + System . getProperty ( <str> ) , originalComparison , encodedComparison ) ; } } public void testEmptyInput ( ) { byte [ ] binary = new byte [ <int> ] ; int encodedLen = IndexableBinaryStringTools . getEncodedLength ( binary , <int> , binary . length ) ; char [ ] encoded = new char [ encodedLen ] ; IndexableBinaryStringTools . encode ( binary , <int> , binary . length , encoded , <int> , encoded . length ) ; int decodedLen = IndexableBinaryStringTools . getDecodedLength ( encoded , <int> , encoded . length ) ; byte [ ] decoded = new byte [ decodedLen ] ; IndexableBinaryStringTools . decode ( encoded , <int> , encoded . length , decoded , <int> , decoded . length ) ; assertEquals ( <str> , decoded . length , <int> ) ; } public void testAllNullInput ( ) { byte [ ] binary = new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; int encodedLen = IndexableBinaryStringTools . getEncodedLength ( binary , <int> , binary . length ) ; char encoded [ ] = new char [ encodedLen ] ; IndexableBinaryStringTools . encode ( binary , <int> , binary . length , encoded , <int> , encoded . length ) ; int decodedLen = IndexableBinaryStringTools . getDecodedLength ( encoded , <int> , encoded . length ) ; byte [ ] decoded = new byte [ decodedLen ] ; IndexableBinaryStringTools . decode ( encoded , <int> , encoded . length , decoded , <int> , decoded . length ) ; assertEquals ( <str> + System . getProperty ( <str> ) + <str> + binaryDump ( binary , binary . length ) + System . getProperty ( <str> ) + <str> + binaryDump ( decoded , decoded . length ) , binaryDump ( binary , binary . length ) , binaryDump ( decoded , decoded . length ) ) ; } public void testRandomBinaryRoundTrip ( ) { byte [ ] binary = new byte [ MAX_RANDOM_BINARY_LENGTH ] ; char [ ] encoded = new char [ MAX_RANDOM_BINARY_LENGTH * <int> ] ; byte [ ] decoded = new byte [ MAX_RANDOM_BINARY_LENGTH ] ; for ( int testNum = <int> ; testNum < NUM_RANDOM_TESTS ; + + testNum ) { int numBytes = random ( ) . nextInt ( MAX_RANDOM_BINARY_LENGTH - <int> ) + <int> ; for ( int byteNum = <int> ; byteNum < numBytes ; + + byteNum ) { binary [ byteNum ] = ( byte ) random ( ) . nextInt ( <hex> ) ; } int encodedLen = IndexableBinaryStringTools . getEncodedLength ( binary , <int> , numBytes ) ; if ( encoded . length < encodedLen ) encoded = new char [ ArrayUtil . oversize ( encodedLen , RamUsageEstimator . NUM_BYTES_CHAR ) ] ; IndexableBinaryStringTools . encode ( binary , <int> , numBytes , encoded , <int> , encodedLen ) ; int decodedLen = IndexableBinaryStringTools . getDecodedLength ( encoded , <int> , encodedLen ) ; IndexableBinaryStringTools . decode ( encoded , <int> , encodedLen , decoded , <int> , decodedLen ) ; assertEquals ( <str> + ( testNum + <int> ) + <str> + System . getProperty ( <str> ) + <str> + binaryDump ( binary , numBytes ) + System . getProperty ( <str> ) + <str> + charArrayDump ( encoded , encodedLen ) + System . getProperty ( <str> ) + <str> + binaryDump ( decoded , decodedLen ) , binaryDump ( binary , numBytes ) , binaryDump ( decoded , decodedLen ) ) ; } } public String binaryDump ( byte [ ] binary , int numBytes ) { StringBuilder buf = new StringBuilder ( ) ; for ( int byteNum = <int> ; byteNum < numBytes ; + + byteNum ) { String hex = Integer . toHexString ( binary [ byteNum ] & <hex> ) ; if ( hex . length ( ) = = <int> ) { buf . append ( <str> ) ; } buf . append ( hex . toUpperCase ( Locale . ROOT ) ) ; if ( byteNum < numBytes - <int> ) { buf . append ( <str> ) ; } } return buf . toString ( ) ; } public String charArrayDump ( char [ ] charArray , int numBytes ) { StringBuilder buf = new StringBuilder ( ) ; for ( int charNum = <int> ; charNum < numBytes ; + + charNum ) { String hex = Integer . toHexString ( charArray [ charNum ] ) ; for ( int digit = <int> ; digit < <int> - hex . length ( ) ; + + digit ) { buf . append ( <str> ) ; } buf . append ( hex . toUpperCase ( Locale . ROOT ) ) ; if ( charNum < numBytes - <int> ) { buf . append ( <str> ) ; } } return buf . toString ( ) ; } } 
