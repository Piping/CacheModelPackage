package org . elasticsearch . index . mapper ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . elasticsearch . action . DocumentRequest ; import org . elasticsearch . common . lucene . BytesRefs ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; public final class Uid { public static final char DELIMITER = <str> ; public static final byte DELIMITER_BYTE = <hex> ; public static final BytesRef DELIMITER_BYTES = new BytesRef ( new byte [ ] { DELIMITER_BYTE } ) ; private final String type ; private final String id ; public Uid ( String type , String id ) { this . type = type ; this . id = id ; } public String type ( ) { return type ; } public String id ( ) { return id ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Uid uid = ( Uid ) o ; if ( id ! = null ? ! id . equals ( uid . id ) : uid . id ! = null ) return false ; if ( type ! = null ? ! type . equals ( uid . type ) : uid . type ! = null ) return false ; return true ; } @Override public int hashCode ( ) { int result = type ! = null ? type . hashCode ( ) : <int> ; result = <int> * result + ( id ! = null ? id . hashCode ( ) : <int> ) ; return result ; } @Override public String toString ( ) { return createUid ( type , id ) ; } public BytesRef toBytesRef ( ) { return createUidAsBytes ( type , id ) ; } public static BytesRef typePrefixAsBytes ( BytesRef type ) { BytesRefBuilder bytesRef = new BytesRefBuilder ( ) ; bytesRef . append ( type ) ; bytesRef . append ( DELIMITER_BYTES ) ; return bytesRef . toBytesRef ( ) ; } public static Uid createUid ( String uid ) { int delimiterIndex = uid . indexOf ( DELIMITER ) ; return new Uid ( uid . substring ( <int> , delimiterIndex ) , uid . substring ( delimiterIndex + <int> ) ) ; } public static BytesRef [ ] createUids ( List < ? extends DocumentRequest > requests ) { BytesRef [ ] uids = new BytesRef [ requests . size ( ) ] ; int idx = <int> ; for ( DocumentRequest item : requests ) { uids [ idx + + ] = createUidAsBytes ( item . type ( ) , item . id ( ) ) ; } return uids ; } public static BytesRef createUidAsBytes ( String type , String id ) { return createUidAsBytes ( new BytesRef ( type ) , new BytesRef ( id ) ) ; } public static BytesRef createUidAsBytes ( String type , BytesRef id ) { return createUidAsBytes ( new BytesRef ( type ) , id ) ; } public static BytesRef createUidAsBytes ( BytesRef type , BytesRef id ) { final BytesRef ref = new BytesRef ( type . length + <int> + id . length ) ; System . arraycopy ( type . bytes , type . offset , ref . bytes , <int> , type . length ) ; ref . offset = type . length ; ref . bytes [ ref . offset + + ] = DELIMITER_BYTE ; System . arraycopy ( id . bytes , id . offset , ref . bytes , ref . offset , id . length ) ; ref . offset = <int> ; ref . length = ref . bytes . length ; return ref ; } public static BytesRef createUidAsBytes ( BytesRef type , BytesRef id , BytesRefBuilder spare ) { spare . copyBytes ( type ) ; spare . append ( DELIMITER_BYTES ) ; spare . append ( id ) ; return spare . get ( ) ; } public static BytesRef [ ] createUidsForTypesAndId ( Collection < String > types , Object id ) { return createUidsForTypesAndIds ( types , Collections . singletonList ( id ) ) ; } public static BytesRef [ ] createUidsForTypesAndIds ( Collection < String > types , Collection < ? > ids ) { BytesRef [ ] uids = new BytesRef [ types . size ( ) * ids . size ( ) ] ; BytesRefBuilder typeBytes = new BytesRefBuilder ( ) ; BytesRefBuilder idBytes = new BytesRefBuilder ( ) ; int index = <int> ; for ( String type : types ) { typeBytes . copyChars ( type ) ; for ( Object id : ids ) { uids [ index + + ] = Uid . createUidAsBytes ( typeBytes . get ( ) , BytesRefs . toBytesRef ( id , idBytes ) ) ; } } return uids ; } public static String createUid ( String type , String id ) { return createUid ( new StringBuilder ( ) , type , id ) ; } public static String createUid ( StringBuilder sb , String type , String id ) { return sb . append ( type ) . append ( DELIMITER ) . append ( id ) . toString ( ) ; } public static boolean hasDelimiter ( BytesRef uid ) { final int limit = uid . offset + uid . length ; for ( int i = uid . offset ; i < limit ; i + + ) { if ( uid . bytes [ i ] = = DELIMITER_BYTE ) { return true ; } } return false ; } public static BytesRef [ ] splitUidIntoTypeAndId ( BytesRef uid ) { int loc = - <int> ; final int limit = uid . offset + uid . length ; for ( int i = uid . offset ; i < limit ; i + + ) { if ( uid . bytes [ i ] = = DELIMITER_BYTE ) { loc = i ; break ; } } if ( loc = = - <int> ) { return null ; } int idStart = loc + <int> ; return new BytesRef [ ] { new BytesRef ( uid . bytes , uid . offset , loc - uid . offset ) , new BytesRef ( uid . bytes , idStart , limit - idStart ) } ; } } 
