package org . nd4j . linalg . api . ops . factory ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . * ; import org . nd4j . linalg . api . ops . impl . accum . * ; import org . nd4j . linalg . api . ops . impl . accum . distances . CosineSimilarity ; import org . nd4j . linalg . api . ops . impl . accum . distances . EuclideanDistance ; import org . nd4j . linalg . api . ops . impl . accum . distances . ManhattanDistance ; import org . nd4j . linalg . api . ops . impl . indexaccum . IAMax ; import org . nd4j . linalg . api . ops . impl . indexaccum . IMax ; import org . nd4j . linalg . api . ops . impl . indexaccum . IMin ; import org . nd4j . linalg . api . ops . impl . transforms . * ; import org . nd4j . linalg . api . ops . impl . broadcast . * ; import org . reflections . Reflections ; import java . lang . reflect . Constructor ; import java . lang . reflect . Modifier ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; public class DefaultOpFactory implements OpFactory { private Map < String , Class < ? extends Op > > opClazzes ; public DefaultOpFactory ( ) { opClazzes = new HashMap < > ( ) ; Set < Class < ? extends Op > > clazzes = new Reflections ( <str> ) . getSubTypesOf ( Op . class ) ; for ( Class < ? extends Op > clazz : clazzes ) { if ( Modifier . isAbstract ( clazz . getModifiers ( ) ) | | clazz . isInterface ( ) ) continue ; try { opClazzes . put ( clazz . newInstance ( ) . name ( ) , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } @Override public LossFunction createLossFunction ( String name , INDArray x , INDArray y ) { Class < ? extends Op > clazz = opClazzes . get ( name ) ; try { Constructor < Op > constructor = ( Constructor < Op > ) clazz . getDeclaredConstructor ( INDArray . class , INDArray . class ) ; Op create = constructor . newInstance ( x , y ) ; return ( LossFunction ) create ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> + name ) ; } } @Override public Accumulation createAccum ( String name , INDArray x ) { switch ( name ) { case <str> : return new Sum ( x ) ; case <str> : return new Max ( x ) ; case <str> : return new Min ( x ) ; case <str> : return new Norm1 ( x ) ; case <str> : return new Norm2 ( x ) ; case <str> : return new Prod ( x ) ; case <str> : return new StandardDeviation ( x ) ; case <str> : return new Variance ( x ) ; case <str> : return new EuclideanDistance ( x ) ; case <str> : case <str> : return new CosineSimilarity ( x ) ; case <str> : return new ManhattanDistance ( x ) ; default: throw new IllegalArgumentException ( <str> + name ) ; } } @Override public Accumulation createAccum ( String name , INDArray x , INDArray y , INDArray z ) { switch ( name ) { case <str> : return new Sum ( x , y , x . length ( ) ) ; case <str> : return new Max ( x , y , x . length ( ) ) ; case <str> : return new Min ( x , y , x . length ( ) ) ; case <str> : return new Norm1 ( x , y , x . length ( ) ) ; case <str> : return new Norm2 ( x , y , x . length ( ) ) ; case <str> : return new Prod ( x , y , x . length ( ) ) ; case <str> : return new StandardDeviation ( x , y , x . length ( ) ) ; case <str> : return new Variance ( x , y , x . length ( ) ) ; case <str> : return new EuclideanDistance ( x , y , x . length ( ) ) ; case <str> : case <str> : return new CosineSimilarity ( x , y , x . length ( ) ) ; case <str> : return new ManhattanDistance ( x , y , x . length ( ) ) ; default: throw new IllegalArgumentException ( <str> + name ) ; } } @Override public Accumulation createAccum ( String name , INDArray x , INDArray y ) { switch ( name ) { case <str> : return new Sum ( x , y ) ; case <str> : return new Max ( x , y ) ; case <str> : return new Min ( x , y ) ; case <str> : return new Norm1 ( x , y ) ; case <str> : return new Norm2 ( x , y ) ; case <str> : return new Prod ( x , y ) ; case <str> : return new StandardDeviation ( x , y ) ; case <str> : return new Variance ( x , y ) ; case <str> : return new EuclideanDistance ( x , y , x . length ( ) ) ; case <str> : case <str> : return new CosineSimilarity ( x , y , x . length ( ) ) ; case <str> : return new ManhattanDistance ( x , y , x . length ( ) ) ; default: throw new IllegalArgumentException ( <str> + name ) ; } } @Override public IndexAccumulation createIndexAccum ( String name , INDArray x ) { switch ( name ) { case <str> : return new IAMax ( x ) ; case <str> : return new IMax ( x ) ; case <str> : return new IMin ( x ) ; default : throw new IllegalArgumentException ( <str> + name ) ; } } @Override public IndexAccumulation createIndexAccum ( String name , INDArray x , INDArray y ) { switch ( name ) { case <str> : return new IAMax ( x , y ) ; case <str> : return new IMax ( x , y ) ; case <str> : return new IMin ( x , y ) ; default : throw new IllegalArgumentException ( <str> + name ) ; } } @Override public TransformOp createTransform ( String name , INDArray x , INDArray y ) { switch ( name ) { case <str> : return new RectifedLinear ( x , <int> ) ; case <str> : return new Abs ( x , y ) ; case <str> : return new ACos ( x , y ) ; case <str> : return new ASin ( x , y ) ; case <str> : return new ATan ( x , y ) ; case <str> : return new Ceil ( x , y ) ; case <str> : return new Cos ( x , y ) ; case <str> : return new Exp ( x , y ) ; case <str> : return new ELU ( x , y ) ; case <str> : return new Floor ( x , y ) ; case <str> : return new HardTanh ( x , y ) ; case <str> : return new Identity ( x , y ) ; case <str> : return new Log ( x , y ) ; case <str> : return new LogSoftMax ( x , y ) ; case <str> : return new LeakyReLU ( x , y ) ; case <str> : return new MaxOut ( x , y ) ; case <str> : return new Negative ( x , y ) ; case <str> : return new Pow ( x , y , <int> ) ; case <str> : return new Round ( x , y ) ; case <str> : return new Sigmoid ( x , y ) ; case <str> : return new Sign ( x , y ) ; case <str> : return new Sin ( x , y ) ; case <str> : return new SoftSign ( x , y ) ; case <str> : return new Sqrt ( x , y ) ; case <str> : return new Stabilize ( x , y , <int> ) ; case <str> : return new Tanh ( x , y ) ; case <str> : return new TimesOneMinus ( x , y ) ; case <str> : return new SoftMax ( x , y ) ; case <str> : return new SoftPlus ( x ) ; case <str> : return new Step ( x , y ) ; default : throw new IllegalArgumentException ( <str> + name ) ; } } @Override public TransformOp createTransform ( String name , INDArray x ) { switch ( name ) { case <str> : return new RectifedLinear ( x , <int> ) ; case <str> : return new Abs ( x ) ; case <str> : return new ACos ( x ) ; case <str> : return new ASin ( x ) ; case <str> : return new ATan ( x ) ; case <str> : return new Ceil ( x ) ; case <str> : return new Cos ( x ) ; case <str> : return new ELU ( x ) ; case <str> : return new Exp ( x ) ; case <str> : return new Floor ( x ) ; case <str> : return new HardTanh ( x ) ; case <str> : return new Identity ( x ) ; case <str> : return new LeakyReLU ( x ) ; case <str> : return new Log ( x ) ; case <str> : return new LogSoftMax ( x ) ; case <str> : return new MaxOut ( x ) ; case <str> : return new Negative ( x ) ; case <str> : return new Pow ( x , <int> ) ; case <str> : return new Round ( x ) ; case <str> : return new Sigmoid ( x ) ; case <str> : return new Sign ( x ) ; case <str> : return new Sin ( x ) ; case <str> : return new SoftSign ( x ) ; case <str> : return new Sqrt ( x ) ; case <str> : return new Stabilize ( x , <int> ) ; case <str> : return new Tanh ( x ) ; case <str> : return new TimesOneMinus ( x ) ; case <str> : return new SoftMax ( x ) ; case <str> : return new SoftPlus ( x ) ; case <str> : return new Step ( x ) ; default : throw new IllegalArgumentException ( <str> + name ) ; } } @Override public TransformOp createTransform ( String name , INDArray x , INDArray y , INDArray z ) { switch ( name ) { case <str> : return new RectifedLinear ( x , z , <int> ) ; case <str> : return new Abs ( x , z ) ; case <str> : return new ACos ( x , z ) ; case <str> : return new ASin ( x , z ) ; case <str> : return new ATan ( x , z ) ; case <str> : return new Ceil ( x , z ) ; case <str> : return new Cos ( x , z ) ; case <str> : return new Exp ( x , z ) ; case <str> : return new ELU ( x , z ) ; case <str> : return new Floor ( x , z ) ; case <str> : return new HardTanh ( x , z ) ; case <str> : return new Identity ( x , z ) ; case <str> : return new LeakyReLU ( x , z ) ; case <str> : return new Log ( x , z ) ; case <str> : return new LogSoftMax ( x , z ) ; case <str> : return new MaxOut ( x , z ) ; case <str> : return new Negative ( x , z ) ; case <str> : return new Pow ( x , z , <int> ) ; case <str> : return new Round ( x , z ) ; case <str> : return new Sigmoid ( x , z ) ; case <str> : return new Sign ( x , z ) ; case <str> : return new Sin ( x , z ) ; case <str> : return new SoftSign ( x , z ) ; case <str> : return new Sqrt ( x , z ) ; case <str> : return new Stabilize ( x , z , <int> ) ; case <str> : return new Tanh ( x , z ) ; case <str> : return new TimesOneMinus ( x , z ) ; case <str> : return new SoftMax ( x , z ) ; case <str> : return new SoftPlus ( x , z ) ; default: throw new IllegalArgumentException ( <str> + name ) ; } } protected Class < ? extends Op > lookupFunctionByName ( String name ) { return opClazzes . get ( name ) ; } @Override public BroadcastOp createBroadcastOp ( String name , INDArray x , INDArray y , INDArray z , int . . . dimension ) { switch ( name ) { case <str> : return new BroadcastAddOp ( x , y , z , dimension ) ; case <str> : return new BroadcastSubOp ( x , y , z , dimension ) ; case <str> : return new BroadcastMulOp ( x , y , z , dimension ) ; case <str> : return new BroadcastDivOp ( x , y , z , dimension ) ; case <str> : return new BroadcastRSubOp ( x , y , z , dimension ) ; case <str> : return new BroadcastRDivOp ( x , y , z , dimension ) ; case <str> : return new BroadcastCopyOp ( x , y , z , dimension ) ; default : throw new IllegalArgumentException ( <str> + name ) ; } } @Override public BroadcastOp createBroadcastOp ( String name , INDArray x , INDArray y , int . . . dimension ) { switch ( name ) { case <str> : return new BroadcastAddOp ( x , y , x , dimension ) ; case <str> : return new BroadcastSubOp ( x , y , x , dimension ) ; case <str> : return new BroadcastMulOp ( x , y , x , dimension ) ; case <str> : return new BroadcastDivOp ( x , y , x , dimension ) ; case <str> : return new BroadcastRSubOp ( x , y , x , dimension ) ; case <str> : return new BroadcastRDivOp ( x , y , x , dimension ) ; case <str> : return new BroadcastCopyOp ( x , y , x , dimension ) ; default : throw new IllegalArgumentException ( <str> + name ) ; } } } 
