package com . badlogic . gdx . tests ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . input . GestureDetector ; import com . badlogic . gdx . input . GestureDetector . GestureListener ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . tests . utils . GdxTest ; public class GestureDetectorTest extends GdxTest implements ApplicationListener { Texture texture ; SpriteBatch batch ; OrthographicCamera camera ; CameraController controller ; GestureDetector gestureDetector ; class CameraController implements GestureListener { float velX , velY ; boolean flinging = false ; float initialScale = <int> ; public boolean touchDown ( float x , float y , int pointer , int button ) { flinging = false ; initialScale = camera . zoom ; return false ; } @Override public boolean tap ( float x , float y , int count , int button ) { Gdx . app . log ( <str> , <str> + x + <str> + y + <str> + count ) ; return false ; } @Override public boolean longPress ( float x , float y ) { Gdx . app . log ( <str> , <str> + x + <str> + y ) ; return false ; } @Override public boolean fling ( float velocityX , float velocityY , int button ) { Gdx . app . log ( <str> , <str> + velocityX + <str> + velocityY ) ; flinging = true ; velX = camera . zoom * velocityX * <float> ; velY = camera . zoom * velocityY * <float> ; return false ; } @Override public boolean pan ( float x , float y , float deltaX , float deltaY ) { camera . position . add ( - deltaX * camera . zoom , deltaY * camera . zoom , <int> ) ; return false ; } @Override public boolean panStop ( float x , float y , int pointer , int button ) { Gdx . app . log ( <str> , <str> + x + <str> + y ) ; return false ; } @Override public boolean zoom ( float originalDistance , float currentDistance ) { float ratio = originalDistance / currentDistance ; camera . zoom = initialScale * ratio ; System . out . println ( camera . zoom ) ; return false ; } @Override public boolean pinch ( Vector2 initialFirstPointer , Vector2 initialSecondPointer , Vector2 firstPointer , Vector2 secondPointer ) { return false ; } public void update ( ) { if ( flinging ) { velX * = <float> ; velY * = <float> ; camera . position . add ( - velX * Gdx . graphics . getDeltaTime ( ) , velY * Gdx . graphics . getDeltaTime ( ) , <int> ) ; if ( Math . abs ( velX ) < <float> ) velX = <int> ; if ( Math . abs ( velY ) < <float> ) velY = <int> ; } } } @Override public void create ( ) { texture = new Texture ( <str> ) ; batch = new SpriteBatch ( ) ; camera = new OrthographicCamera ( Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; controller = new CameraController ( ) ; gestureDetector = new GestureDetector ( <int> , <float> , <int> , <float> , controller ) ; Gdx . input . setInputProcessor ( gestureDetector ) ; } @Override public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; controller . update ( ) ; camera . update ( ) ; batch . setProjectionMatrix ( camera . combined ) ; batch . begin ( ) ; batch . draw ( texture , <int> , <int> , texture . getWidth ( ) * <int> , texture . getHeight ( ) * <int> ) ; batch . end ( ) ; } @Override public void dispose ( ) { texture . dispose ( ) ; batch . dispose ( ) ; } } 
