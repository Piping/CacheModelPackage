package org . elasticsearch . index . query ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . query . SimpleQueryParser . Settings ; import java . io . IOException ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import java . util . Objects ; import java . util . TreeMap ; public class SimpleQueryStringBuilder extends AbstractQueryBuilder < SimpleQueryStringBuilder > { public static final Locale DEFAULT_LOCALE = Locale . ROOT ; public static final boolean DEFAULT_LOWERCASE_EXPANDED_TERMS = true ; public static final boolean DEFAULT_LENIENT = false ; public static final boolean DEFAULT_ANALYZE_WILDCARD = false ; public static final Operator DEFAULT_OPERATOR = Operator . OR ; public static final int DEFAULT_FLAGS = SimpleQueryStringFlag . ALL . value ; public static final String NAME = <str> ; static final SimpleQueryStringBuilder PROTOTYPE = new SimpleQueryStringBuilder ( <str> ) ; private final String queryText ; private final Map < String , Float > fieldsAndWeights = new TreeMap < > ( ) ; private String analyzer ; private Operator defaultOperator = DEFAULT_OPERATOR ; private String minimumShouldMatch ; private int flags = DEFAULT_FLAGS ; private Settings settings = new Settings ( ) ; public SimpleQueryStringBuilder ( String queryText ) { if ( queryText = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . queryText = queryText ; } public String value ( ) { return this . queryText ; } public SimpleQueryStringBuilder field ( String field ) { if ( Strings . isEmpty ( field ) ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldsAndWeights . put ( field , AbstractQueryBuilder . DEFAULT_BOOST ) ; return this ; } public SimpleQueryStringBuilder field ( String field , float boost ) { if ( Strings . isEmpty ( field ) ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldsAndWeights . put ( field , boost ) ; return this ; } public SimpleQueryStringBuilder fields ( Map < String , Float > fields ) { Objects . requireNonNull ( fields , <str> ) ; this . fieldsAndWeights . putAll ( fields ) ; return this ; } public Map < String , Float > fields ( ) { return this . fieldsAndWeights ; } public SimpleQueryStringBuilder analyzer ( String analyzer ) { this . analyzer = analyzer ; return this ; } public String analyzer ( ) { return this . analyzer ; } public SimpleQueryStringBuilder defaultOperator ( Operator defaultOperator ) { this . defaultOperator = ( defaultOperator ! = null ) ? defaultOperator : DEFAULT_OPERATOR ; return this ; } public Operator defaultOperator ( ) { return this . defaultOperator ; } public SimpleQueryStringBuilder flags ( SimpleQueryStringFlag . . . flags ) { if ( flags ! = null & & flags . length > <int> ) { int value = <int> ; for ( SimpleQueryStringFlag flag : flags ) { value | = flag . value ; } this . flags = value ; } else { this . flags = DEFAULT_FLAGS ; } return this ; } SimpleQueryStringBuilder flags ( int flags ) { this . flags = flags ; return this ; } int flags ( ) { return this . flags ; } public SimpleQueryStringBuilder lowercaseExpandedTerms ( boolean lowercaseExpandedTerms ) { this . settings . lowercaseExpandedTerms ( lowercaseExpandedTerms ) ; return this ; } public boolean lowercaseExpandedTerms ( ) { return this . settings . lowercaseExpandedTerms ( ) ; } public SimpleQueryStringBuilder locale ( Locale locale ) { this . settings . locale ( locale ) ; return this ; } public Locale locale ( ) { return this . settings . locale ( ) ; } public SimpleQueryStringBuilder lenient ( boolean lenient ) { this . settings . lenient ( lenient ) ; return this ; } public boolean lenient ( ) { return this . settings . lenient ( ) ; } public SimpleQueryStringBuilder analyzeWildcard ( boolean analyzeWildcard ) { this . settings . analyzeWildcard ( analyzeWildcard ) ; return this ; } public boolean analyzeWildcard ( ) { return this . settings . analyzeWildcard ( ) ; } public SimpleQueryStringBuilder minimumShouldMatch ( String minimumShouldMatch ) { this . minimumShouldMatch = minimumShouldMatch ; return this ; } public String minimumShouldMatch ( ) { return minimumShouldMatch ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { Map < String , Float > resolvedFieldsAndWeights = new TreeMap < > ( ) ; if ( fieldsAndWeights . isEmpty ( ) ) { resolvedFieldsAndWeights . put ( resolveIndexName ( context . defaultField ( ) , context ) , AbstractQueryBuilder . DEFAULT_BOOST ) ; } else { for ( Map . Entry < String , Float > fieldEntry : fieldsAndWeights . entrySet ( ) ) { if ( Regex . isSimpleMatchPattern ( fieldEntry . getKey ( ) ) ) { for ( String fieldName : context . getMapperService ( ) . simpleMatchToIndexNames ( fieldEntry . getKey ( ) ) ) { resolvedFieldsAndWeights . put ( fieldName , fieldEntry . getValue ( ) ) ; } } else { resolvedFieldsAndWeights . put ( resolveIndexName ( fieldEntry . getKey ( ) , context ) , fieldEntry . getValue ( ) ) ; } } } Analyzer luceneAnalyzer ; if ( analyzer = = null ) { luceneAnalyzer = context . getMapperService ( ) . searchAnalyzer ( ) ; } else { luceneAnalyzer = context . getAnalysisService ( ) . analyzer ( analyzer ) ; if ( luceneAnalyzer = = null ) { throw new QueryShardException ( context , <str> + SimpleQueryStringBuilder . NAME + <str> + analyzer + <str> ) ; } } SimpleQueryParser sqp = new SimpleQueryParser ( luceneAnalyzer , resolvedFieldsAndWeights , flags , settings ) ; sqp . setDefaultOperator ( defaultOperator . toBooleanClauseOccur ( ) ) ; Query query = sqp . parse ( queryText ) ; if ( minimumShouldMatch ! = null & & query instanceof BooleanQuery ) { query = Queries . applyMinimumShouldMatch ( ( BooleanQuery ) query , minimumShouldMatch ) ; } return query ; } private static String resolveIndexName ( String fieldName , QueryShardContext context ) { MappedFieldType fieldType = context . fieldMapper ( fieldName ) ; if ( fieldType ! = null ) { return fieldType . names ( ) . indexName ( ) ; } return fieldName ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . field ( SimpleQueryStringParser . QUERY_FIELD . getPreferredName ( ) , queryText ) ; if ( fieldsAndWeights . size ( ) > <int> ) { builder . startArray ( SimpleQueryStringParser . FIELDS_FIELD . getPreferredName ( ) ) ; for ( Map . Entry < String , Float > entry : fieldsAndWeights . entrySet ( ) ) { builder . value ( entry . getKey ( ) + <str> + entry . getValue ( ) ) ; } builder . endArray ( ) ; } if ( analyzer ! = null ) { builder . field ( SimpleQueryStringParser . ANALYZER_FIELD . getPreferredName ( ) , analyzer ) ; } builder . field ( SimpleQueryStringParser . FLAGS_FIELD . getPreferredName ( ) , flags ) ; builder . field ( SimpleQueryStringParser . DEFAULT_OPERATOR_FIELD . getPreferredName ( ) , defaultOperator . name ( ) . toLowerCase ( Locale . ROOT ) ) ; builder . field ( SimpleQueryStringParser . LOWERCASE_EXPANDED_TERMS_FIELD . getPreferredName ( ) , settings . lowercaseExpandedTerms ( ) ) ; builder . field ( SimpleQueryStringParser . LENIENT_FIELD . getPreferredName ( ) , settings . lenient ( ) ) ; builder . field ( SimpleQueryStringParser . ANALYZE_WILDCARD_FIELD . getPreferredName ( ) , settings . analyzeWildcard ( ) ) ; builder . field ( SimpleQueryStringParser . LOCALE_FIELD . getPreferredName ( ) , ( settings . locale ( ) . toLanguageTag ( ) ) ) ; if ( minimumShouldMatch ! = null ) { builder . field ( SimpleQueryStringParser . MINIMUM_SHOULD_MATCH_FIELD . getPreferredName ( ) , minimumShouldMatch ) ; } printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override public String getWriteableName ( ) { return NAME ; } @Override protected SimpleQueryStringBuilder doReadFrom ( StreamInput in ) throws IOException { SimpleQueryStringBuilder result = new SimpleQueryStringBuilder ( in . readString ( ) ) ; int size = in . readInt ( ) ; Map < String , Float > fields = new HashMap < > ( ) ; for ( int i = <int> ; i < size ; i + + ) { String field = in . readString ( ) ; Float weight = in . readFloat ( ) ; fields . put ( field , weight ) ; } result . fieldsAndWeights . putAll ( fields ) ; result . flags = in . readInt ( ) ; result . analyzer = in . readOptionalString ( ) ; result . defaultOperator = Operator . readOperatorFrom ( in ) ; result . settings . lowercaseExpandedTerms ( in . readBoolean ( ) ) ; result . settings . lenient ( in . readBoolean ( ) ) ; result . settings . analyzeWildcard ( in . readBoolean ( ) ) ; String localeStr = in . readString ( ) ; result . settings . locale ( Locale . forLanguageTag ( localeStr ) ) ; result . minimumShouldMatch = in . readOptionalString ( ) ; return result ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( queryText ) ; out . writeInt ( fieldsAndWeights . size ( ) ) ; for ( Map . Entry < String , Float > entry : fieldsAndWeights . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; out . writeFloat ( entry . getValue ( ) ) ; } out . writeInt ( flags ) ; out . writeOptionalString ( analyzer ) ; defaultOperator . writeTo ( out ) ; out . writeBoolean ( settings . lowercaseExpandedTerms ( ) ) ; out . writeBoolean ( settings . lenient ( ) ) ; out . writeBoolean ( settings . analyzeWildcard ( ) ) ; out . writeString ( settings . locale ( ) . toLanguageTag ( ) ) ; out . writeOptionalString ( minimumShouldMatch ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( fieldsAndWeights , analyzer , defaultOperator , queryText , minimumShouldMatch , settings , flags ) ; } @Override protected boolean doEquals ( SimpleQueryStringBuilder other ) { return Objects . equals ( fieldsAndWeights , other . fieldsAndWeights ) & & Objects . equals ( analyzer , other . analyzer ) & & Objects . equals ( defaultOperator , other . defaultOperator ) & & Objects . equals ( queryText , other . queryText ) & & Objects . equals ( minimumShouldMatch , other . minimumShouldMatch ) & & Objects . equals ( settings , other . settings ) & & ( flags = = other . flags ) ; } } 
