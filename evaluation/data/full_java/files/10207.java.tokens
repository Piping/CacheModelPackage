package com . google . common . hash ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import java . util . Random ; import java . util . zip . Adler32 ; import java . util . zip . CRC32 ; import java . util . zip . Checksum ; public class ChecksumBenchmark { private static final int RANDOM_SEED = new Random ( ) . nextInt ( ) ; @Param ( { <str> , <str> , <str> , <str> } ) private int size ; private byte [ ] testBytes ; @BeforeExperiment void setUp ( ) { testBytes = new byte [ size ] ; new Random ( RANDOM_SEED ) . nextBytes ( testBytes ) ; } @Benchmark byte crc32HashFunction ( int reps ) { return runHashFunction ( reps , Hashing . crc32 ( ) ) ; } @Benchmark byte crc32Checksum ( int reps ) throws Exception { byte result = <hex> ; for ( int i = <int> ; i < reps ; i + + ) { CRC32 checksum = new CRC32 ( ) ; checksum . update ( testBytes ) ; result = ( byte ) ( result ^ checksum . getValue ( ) ) ; } return result ; } @Benchmark byte adler32HashFunction ( int reps ) { return runHashFunction ( reps , Hashing . adler32 ( ) ) ; } @Benchmark byte adler32Checksum ( int reps ) throws Exception { byte result = <hex> ; for ( int i = <int> ; i < reps ; i + + ) { Adler32 checksum = new Adler32 ( ) ; checksum . update ( testBytes ) ; result = ( byte ) ( result ^ checksum . getValue ( ) ) ; } return result ; } private byte runHashFunction ( int reps , HashFunction hashFunction ) { byte result = <hex> ; result ^ = Hashing . crc32 ( ) . hashInt ( reps ) . asBytes ( ) [ <int> ] ; result ^ = Hashing . adler32 ( ) . hashInt ( reps ) . asBytes ( ) [ <int> ] ; for ( int i = <int> ; i < reps ; i + + ) { result ^ = hashFunction . hashBytes ( testBytes ) . asBytes ( ) [ <int> ] ; } return result ; } } 
