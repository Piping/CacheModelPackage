package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . physics . bullet . collision . Collision ; import com . badlogic . gdx . physics . bullet . collision . btCollisionDispatcher ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObject ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObjectWrapper ; import com . badlogic . gdx . physics . bullet . collision . btCollisionWorld ; import com . badlogic . gdx . physics . bullet . collision . ContactResultCallback ; import com . badlogic . gdx . physics . bullet . collision . btConvexHullShape ; import com . badlogic . gdx . physics . bullet . collision . btDbvtBroadphase ; import com . badlogic . gdx . physics . bullet . collision . btDefaultCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . collision . btManifoldPoint ; import com . badlogic . gdx . physics . bullet . collision . btShapeHull ; import com . badlogic . gdx . physics . bullet . linearmath . btVector3 ; public class ConvexHullDistanceTest extends BaseBulletTest { private ConvexHullDistance distance ; private ShapeRenderer shapeRenderer ; @Override public void create ( ) { super . create ( ) ; final Model carModel = objLoader . loadModel ( Gdx . files . internal ( <str> ) ) ; disposables . add ( carModel ) ; carModel . materials . get ( <int> ) . clear ( ) ; carModel . materials . get ( <int> ) . set ( ColorAttribute . createDiffuse ( Color . WHITE ) , ColorAttribute . createSpecular ( Color . WHITE ) ) ; world . addConstructor ( <str> , new BulletConstructor ( carModel , <float> , createConvexHullShape ( carModel , true ) ) ) ; world . add ( <str> , <float> , <float> , <float> ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; for ( float y = <int> f ; y < <int> f ; y + = <float> ) world . add ( <str> , - <float> + ( float ) Math . random ( ) * <float> , y , - <float> + ( float ) Math . random ( ) * <float> ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; distance = new ConvexHullDistance ( ) ; shapeRenderer = new ShapeRenderer ( ) ; } @Override public boolean tap ( float x , float y , int count , int button ) { shoot ( x , y ) ; return true ; } @Override public void render ( ) { super . render ( ) ; camera . update ( ) ; shapeRenderer . setProjectionMatrix ( camera . combined ) ; shapeRenderer . begin ( ShapeType . Line ) ; shapeRenderer . setColor ( <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < world . entities . size ; i + + ) { btCollisionObject collisionObject0 = world . entities . get ( i ) . body ; for ( int j = <int> ; j < world . entities . size ; j + + ) { if ( i ! = j ) { btCollisionObject collisionObject1 = world . entities . get ( j ) . body ; distance . calculateDistance ( collisionObject0 , collisionObject1 ) ; shapeRenderer . line ( distance . getVector3 ( ) [ <int> ] , distance . getVector3 ( ) [ <int> ] ) ; } } } shapeRenderer . end ( ) ; } public static btConvexHullShape createConvexHullShape ( final Model model , boolean optimize ) { final Mesh mesh = model . meshes . get ( <int> ) ; final btConvexHullShape shape = new btConvexHullShape ( mesh . getVerticesBuffer ( ) , mesh . getNumVertices ( ) , mesh . getVertexSize ( ) ) ; if ( ! optimize ) return shape ; final btShapeHull hull = new btShapeHull ( shape ) ; hull . buildHull ( shape . getMargin ( ) ) ; final btConvexHullShape result = new btConvexHullShape ( hull ) ; shape . dispose ( ) ; hull . dispose ( ) ; return result ; } private class ConvexHullDistance { private btDefaultCollisionConfiguration collisionConfiguration ; private btCollisionDispatcher dispatcher ; private btDbvtBroadphase pairCache ; private btCollisionWorld collisionWorld ; Vector3 [ ] vectors = new Vector3 [ ] { new Vector3 ( ) , new Vector3 ( ) } ; public ConvexHullDistance ( ) { collisionConfiguration = new btDefaultCollisionConfiguration ( ) ; dispatcher = new btCollisionDispatcher ( collisionConfiguration ) ; pairCache = new btDbvtBroadphase ( ) ; collisionWorld = new btCollisionWorld ( dispatcher , pairCache , collisionConfiguration ) ; } public Vector3 [ ] getVector3 ( ) { return vectors ; } public void calculateDistance ( btCollisionObject colObjA , btCollisionObject colObjB ) { DistanceInternalResultCallback result = new DistanceInternalResultCallback ( ) ; Collision . setGContactBreakingThreshold ( <int> f ) ; collisionWorld . contactPairTest ( colObjA , colObjB , result ) ; Collision . setGContactBreakingThreshold ( <float> ) ; } private class DistanceInternalResultCallback extends ContactResultCallback { public DistanceInternalResultCallback ( ) { } @Override public float addSingleResult ( btManifoldPoint cp , btCollisionObjectWrapper colObj0Wrap , int partId0 , int index0 , btCollisionObjectWrapper colObj1Wrap , int partId1 , int index1 ) { cp . getPositionWorldOnA ( vectors [ <int> ] ) ; cp . getPositionWorldOnB ( vectors [ <int> ] ) ; return <float> ; } } } } 
