package io . netty . util . internal . chmv8 ; import java . util . concurrent . RecursiveAction ; @SuppressWarnings ( <str> ) public abstract class CountedCompleter < T > extends ForkJoinTask < T > { private static final long serialVersionUID = <int> ; final CountedCompleter < ? > completer ; volatile int pending ; protected CountedCompleter ( CountedCompleter < ? > completer , int initialPendingCount ) { this . completer = completer ; this . pending = initialPendingCount ; } protected CountedCompleter ( CountedCompleter < ? > completer ) { this . completer = completer ; } protected CountedCompleter ( ) { this . completer = null ; } public abstract void compute ( ) ; public void onCompletion ( CountedCompleter < ? > caller ) { } public boolean onExceptionalCompletion ( Throwable ex , CountedCompleter < ? > caller ) { return true ; } public final CountedCompleter < ? > getCompleter ( ) { return completer ; } public final int getPendingCount ( ) { return pending ; } public final void setPendingCount ( int count ) { pending = count ; } public final void addToPendingCount ( int delta ) { int c ; do { } while ( ! U . compareAndSwapInt ( this , PENDING , c = pending , c + delta ) ) ; } public final boolean compareAndSetPendingCount ( int expected , int count ) { return U . compareAndSwapInt ( this , PENDING , expected , count ) ; } public final int decrementPendingCountUnlessZero ( ) { int c ; do { } while ( ( c = pending ) ! = <int> & & ! U . compareAndSwapInt ( this , PENDING , c , c - <int> ) ) ; return c ; } public final CountedCompleter < ? > getRoot ( ) { CountedCompleter < ? > a = this , p ; while ( ( p = a . completer ) ! = null ) a = p ; return a ; } public final void tryComplete ( ) { CountedCompleter < ? > a = this , s = a ; for ( int c ; ; ) { if ( ( c = a . pending ) = = <int> ) { a . onCompletion ( s ) ; if ( ( a = ( s = a ) . completer ) = = null ) { s . quietlyComplete ( ) ; return ; } } else if ( U . compareAndSwapInt ( a , PENDING , c , c - <int> ) ) return ; } } public final void propagateCompletion ( ) { CountedCompleter < ? > a = this , s = a ; for ( int c ; ; ) { if ( ( c = a . pending ) = = <int> ) { if ( ( a = ( s = a ) . completer ) = = null ) { s . quietlyComplete ( ) ; return ; } } else if ( U . compareAndSwapInt ( a , PENDING , c , c - <int> ) ) return ; } } public void complete ( T rawResult ) { CountedCompleter < ? > p ; setRawResult ( rawResult ) ; onCompletion ( this ) ; quietlyComplete ( ) ; if ( ( p = completer ) ! = null ) p . tryComplete ( ) ; } public final CountedCompleter < ? > firstComplete ( ) { for ( int c ; ; ) { if ( ( c = pending ) = = <int> ) return this ; else if ( U . compareAndSwapInt ( this , PENDING , c , c - <int> ) ) return null ; } } public final CountedCompleter < ? > nextComplete ( ) { CountedCompleter < ? > p ; if ( ( p = completer ) ! = null ) return p . firstComplete ( ) ; else { quietlyComplete ( ) ; return null ; } } public final void quietlyCompleteRoot ( ) { for ( CountedCompleter < ? > a = this , p ; ; ) { if ( ( p = a . completer ) = = null ) { a . quietlyComplete ( ) ; return ; } a = p ; } } void internalPropagateException ( Throwable ex ) { CountedCompleter < ? > a = this , s = a ; while ( a . onExceptionalCompletion ( ex , s ) & & ( a = ( s = a ) . completer ) ! = null & & a . status > = <int> & & a . recordExceptionalCompletion ( ex ) = = EXCEPTIONAL ) ; } protected final boolean exec ( ) { compute ( ) ; return false ; } public T getRawResult ( ) { return null ; } protected void setRawResult ( T t ) { } private static final sun . misc . Unsafe U ; private static final long PENDING ; static { try { U = getUnsafe ( ) ; PENDING = U . objectFieldOffset ( CountedCompleter . class . getDeclaredField ( <str> ) ) ; } catch ( Exception e ) { throw new Error ( e ) ; } } private static sun . misc . Unsafe getUnsafe ( ) { try { return sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { } try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) return k . cast ( x ) ; } throw new NoSuchFieldError ( <str> ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw new RuntimeException ( <str> , e . getCause ( ) ) ; } } } 
