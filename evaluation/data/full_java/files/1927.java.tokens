package clojure . lang ; public class Repeat extends ASeq implements IReduce { private static final long INFINITE = - <int> ; private final long count ; private final Object val ; private volatile ISeq _next ; private Repeat ( long count , Object val ) { this . count = count ; this . val = val ; } private Repeat ( IPersistentMap meta , long count , Object val ) { super ( meta ) ; this . count = count ; this . val = val ; } public static Repeat create ( Object val ) { return new Repeat ( INFINITE , val ) ; } public static ISeq create ( long count , Object val ) { if ( count < = <int> ) return PersistentList . EMPTY ; return new Repeat ( count , val ) ; } public Object first ( ) { return val ; } public ISeq next ( ) { if ( _next = = null ) { if ( count > <int> ) _next = new Repeat ( count - <int> , val ) ; else if ( count = = INFINITE ) _next = this ; } return _next ; } public Repeat withMeta ( IPersistentMap meta ) { return new Repeat ( meta , count , val ) ; } public Object reduce ( IFn f ) { Object ret = val ; if ( count = = INFINITE ) { while ( true ) { ret = f . invoke ( ret , val ) ; if ( RT . isReduced ( ret ) ) return ( ( IDeref ) ret ) . deref ( ) ; } } else { for ( long i = <int> ; i < count ; i + + ) { ret = f . invoke ( ret , val ) ; if ( RT . isReduced ( ret ) ) return ( ( IDeref ) ret ) . deref ( ) ; } return ret ; } } public Object reduce ( IFn f , Object start ) { Object ret = start ; if ( count = = INFINITE ) { while ( true ) { ret = f . invoke ( ret , val ) ; if ( RT . isReduced ( ret ) ) return ( ( IDeref ) ret ) . deref ( ) ; } } else { for ( long i = <int> ; i < count ; i + + ) { ret = f . invoke ( ret , val ) ; if ( RT . isReduced ( ret ) ) return ( ( IDeref ) ret ) . deref ( ) ; } return ret ; } } } 
