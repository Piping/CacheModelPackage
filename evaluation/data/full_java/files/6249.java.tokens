package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . NumericTokenStream ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . ar . ArabicAnalyzer ; import org . apache . lucene . analysis . bg . BulgarianAnalyzer ; import org . apache . lucene . analysis . br . BrazilianAnalyzer ; import org . apache . lucene . analysis . ca . CatalanAnalyzer ; import org . apache . lucene . analysis . ckb . SoraniAnalyzer ; import org . apache . lucene . analysis . cz . CzechAnalyzer ; import org . apache . lucene . analysis . da . DanishAnalyzer ; import org . apache . lucene . analysis . de . GermanAnalyzer ; import org . apache . lucene . analysis . el . GreekAnalyzer ; import org . apache . lucene . analysis . en . EnglishAnalyzer ; import org . apache . lucene . analysis . es . SpanishAnalyzer ; import org . apache . lucene . analysis . eu . BasqueAnalyzer ; import org . apache . lucene . analysis . fa . PersianAnalyzer ; import org . apache . lucene . analysis . fi . FinnishAnalyzer ; import org . apache . lucene . analysis . fr . FrenchAnalyzer ; import org . apache . lucene . analysis . ga . IrishAnalyzer ; import org . apache . lucene . analysis . gl . GalicianAnalyzer ; import org . apache . lucene . analysis . hi . HindiAnalyzer ; import org . apache . lucene . analysis . hu . HungarianAnalyzer ; import org . apache . lucene . analysis . hy . ArmenianAnalyzer ; import org . apache . lucene . analysis . id . IndonesianAnalyzer ; import org . apache . lucene . analysis . it . ItalianAnalyzer ; import org . apache . lucene . analysis . lt . LithuanianAnalyzer ; import org . apache . lucene . analysis . lv . LatvianAnalyzer ; import org . apache . lucene . analysis . nl . DutchAnalyzer ; import org . apache . lucene . analysis . no . NorwegianAnalyzer ; import org . apache . lucene . analysis . pt . PortugueseAnalyzer ; import org . apache . lucene . analysis . ro . RomanianAnalyzer ; import org . apache . lucene . analysis . ru . RussianAnalyzer ; import org . apache . lucene . analysis . sv . SwedishAnalyzer ; import org . apache . lucene . analysis . th . ThaiAnalyzer ; import org . apache . lucene . analysis . tokenattributes . CharTermAttribute ; import org . apache . lucene . analysis . tr . TurkishAnalyzer ; import org . apache . lucene . analysis . util . CharArraySet ; import org . apache . lucene . util . Version ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . nio . charset . StandardCharsets ; import java . nio . file . Path ; import java . util . * ; import static java . util . Collections . unmodifiableMap ; public class Analysis { public static Version parseAnalysisVersion ( Settings indexSettings , Settings settings , ESLogger logger ) { String sVersion = settings . get ( <str> ) ; if ( sVersion ! = null ) { return Lucene . parseVersion ( sVersion , Lucene . ANALYZER_VERSION , logger ) ; } sVersion = indexSettings . get ( <str> ) ; if ( sVersion ! = null ) { return Lucene . parseVersion ( sVersion , Lucene . ANALYZER_VERSION , logger ) ; } return org . elasticsearch . Version . indexCreated ( indexSettings ) . luceneVersion ; } public static boolean isNoStopwords ( Settings settings ) { String value = settings . get ( <str> ) ; return value ! = null & & <str> . equals ( value ) ; } public static CharArraySet parseStemExclusion ( Settings settings , CharArraySet defaultStemExclusion ) { String value = settings . get ( <str> ) ; if ( value ! = null ) { if ( <str> . equals ( value ) ) { return CharArraySet . EMPTY_SET ; } else { return new CharArraySet ( Strings . commaDelimitedListToSet ( value ) , false ) ; } } String [ ] stemExclusion = settings . getAsArray ( <str> , null ) ; if ( stemExclusion ! = null ) { return new CharArraySet ( Arrays . asList ( stemExclusion ) , false ) ; } else { return defaultStemExclusion ; } } public static final Map < String , Set < ? > > NAMED_STOP_WORDS ; static { Map < String , Set < ? > > namedStopWords = new HashMap < > ( ) ; namedStopWords . put ( <str> , ArabicAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , ArmenianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , BasqueAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , BrazilianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , BulgarianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , CatalanAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , CzechAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , DanishAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , DutchAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , EnglishAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , FinnishAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , FrenchAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , GalicianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , GermanAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , GreekAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , HindiAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , HungarianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , IndonesianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , IrishAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , ItalianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , LatvianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , LithuanianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , NorwegianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , PersianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , PortugueseAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , RomanianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , RussianAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , SoraniAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , SpanishAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , SwedishAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , ThaiAnalyzer . getDefaultStopSet ( ) ) ; namedStopWords . put ( <str> , TurkishAnalyzer . getDefaultStopSet ( ) ) ; NAMED_STOP_WORDS = unmodifiableMap ( namedStopWords ) ; } public static CharArraySet parseWords ( Environment env , Settings settings , String name , CharArraySet defaultWords , Map < String , Set < ? > > namedWords , boolean ignoreCase ) { String value = settings . get ( name ) ; if ( value ! = null ) { if ( <str> . equals ( value ) ) { return CharArraySet . EMPTY_SET ; } else { return resolveNamedWords ( Strings . commaDelimitedListToSet ( value ) , namedWords , ignoreCase ) ; } } List < String > pathLoadedWords = getWordList ( env , settings , name ) ; if ( pathLoadedWords ! = null ) { return resolveNamedWords ( pathLoadedWords , namedWords , ignoreCase ) ; } return defaultWords ; } public static CharArraySet parseCommonWords ( Environment env , Settings settings , CharArraySet defaultCommonWords , boolean ignoreCase ) { return parseWords ( env , settings , <str> , defaultCommonWords , NAMED_STOP_WORDS , ignoreCase ) ; } public static CharArraySet parseArticles ( Environment env , Settings settings ) { return parseWords ( env , settings , <str> , null , null , settings . getAsBoolean ( <str> , false ) ) ; } public static CharArraySet parseStopWords ( Environment env , Settings settings , CharArraySet defaultStopWords ) { return parseStopWords ( env , settings , defaultStopWords , settings . getAsBoolean ( <str> , false ) ) ; } public static CharArraySet parseStopWords ( Environment env , Settings settings , CharArraySet defaultStopWords , boolean ignoreCase ) { return parseWords ( env , settings , <str> , defaultStopWords , NAMED_STOP_WORDS , ignoreCase ) ; } private static CharArraySet resolveNamedWords ( Collection < String > words , Map < String , Set < ? > > namedWords , boolean ignoreCase ) { if ( namedWords = = null ) { return new CharArraySet ( words , ignoreCase ) ; } CharArraySet setWords = new CharArraySet ( words . size ( ) , ignoreCase ) ; for ( String word : words ) { if ( namedWords . containsKey ( word ) ) { setWords . addAll ( namedWords . get ( word ) ) ; } else { setWords . add ( word ) ; } } return setWords ; } public static CharArraySet getWordSet ( Environment env , Settings settings , String settingsPrefix ) { List < String > wordList = getWordList ( env , settings , settingsPrefix ) ; if ( wordList = = null ) { return null ; } return new CharArraySet ( wordList , settings . getAsBoolean ( settingsPrefix + <str> , false ) ) ; } public static List < String > getWordList ( Environment env , Settings settings , String settingPrefix ) { String wordListPath = settings . get ( settingPrefix + <str> , null ) ; if ( wordListPath = = null ) { String [ ] explicitWordList = settings . getAsArray ( settingPrefix , null ) ; if ( explicitWordList = = null ) { return null ; } else { return Arrays . asList ( explicitWordList ) ; } } final Path wordListFile = env . configFile ( ) . resolve ( wordListPath ) ; try ( BufferedReader reader = FileSystemUtils . newBufferedReader ( wordListFile . toUri ( ) . toURL ( ) , StandardCharsets . UTF_8 ) ) { return loadWordList ( reader , <str> ) ; } catch ( IOException ioe ) { String message = String . format ( Locale . ROOT , <str> , settingPrefix ) ; throw new IllegalArgumentException ( message , ioe ) ; } } public static List < String > loadWordList ( Reader reader , String comment ) throws IOException { final List < String > result = new ArrayList < > ( ) ; BufferedReader br = null ; try { if ( reader instanceof BufferedReader ) { br = ( BufferedReader ) reader ; } else { br = new BufferedReader ( reader ) ; } String word = null ; while ( ( word = br . readLine ( ) ) ! = null ) { if ( ! Strings . hasText ( word ) ) { continue ; } if ( ! word . startsWith ( comment ) ) { result . add ( word . trim ( ) ) ; } } } finally { if ( br ! = null ) br . close ( ) ; } return result ; } public static Reader getReaderFromFile ( Environment env , Settings settings , String settingPrefix ) { String filePath = settings . get ( settingPrefix , null ) ; if ( filePath = = null ) { return null ; } final Path path = env . configFile ( ) . resolve ( filePath ) ; try { return FileSystemUtils . newBufferedReader ( path . toUri ( ) . toURL ( ) , StandardCharsets . UTF_8 ) ; } catch ( IOException ioe ) { String message = String . format ( Locale . ROOT , <str> , settingPrefix ) ; throw new IllegalArgumentException ( message , ioe ) ; } } public static boolean isCharacterTokenStream ( TokenStream tokenStream ) { try { tokenStream . addAttribute ( CharTermAttribute . class ) ; return true ; } catch ( IllegalArgumentException e ) { return false ; } } public static boolean generatesCharacterTokenStream ( Analyzer analyzer , String fieldName ) throws IOException { try ( TokenStream ts = analyzer . tokenStream ( fieldName , <str> ) ) { return isCharacterTokenStream ( ts ) ; } } } 
