package org . apache . cassandra . schema ; import java . nio . ByteBuffer ; import java . util . * ; import javax . annotation . Nullable ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import org . apache . cassandra . cql3 . CQL3Type ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . UserType ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . jgrapht . graph . DefaultDirectedGraph ; import org . jgrapht . graph . DefaultEdge ; import org . jgrapht . traverse . TopologicalOrderIterator ; import static com . google . common . collect . Iterables . filter ; import static java . util . stream . Collectors . toList ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; public final class Types implements Iterable < UserType > { private static final Types NONE = new Types ( ImmutableMap . of ( ) ) ; private final Map < ByteBuffer , UserType > types ; private Types ( Builder builder ) { types = builder . types . build ( ) ; } private Types ( Map < ByteBuffer , UserType > types ) { this . types = types ; } public static Builder builder ( ) { return new Builder ( ) ; } public static RawBuilder rawBuilder ( String keyspace ) { return new RawBuilder ( keyspace ) ; } public static Types none ( ) { return NONE ; } public static Types of ( UserType . . . types ) { return builder ( ) . add ( types ) . build ( ) ; } public Iterator < UserType > iterator ( ) { return types . values ( ) . iterator ( ) ; } public Optional < UserType > get ( ByteBuffer name ) { return Optional . ofNullable ( types . get ( name ) ) ; } @Nullable public UserType getNullable ( ByteBuffer name ) { return types . get ( name ) ; } public Types with ( UserType type ) { if ( get ( type . name ) . isPresent ( ) ) throw new IllegalStateException ( String . format ( <str> , type . name ) ) ; return builder ( ) . add ( this ) . add ( type ) . build ( ) ; } public Types without ( ByteBuffer name ) { UserType type = get ( name ) . orElseThrow ( ( ) - > new IllegalStateException ( String . format ( <str> , name ) ) ) ; return builder ( ) . add ( filter ( this , t - > t ! = type ) ) . build ( ) ; } MapDifference < ByteBuffer , UserType > diff ( Types other ) { return Maps . difference ( types , other . types ) ; } @Override public boolean equals ( Object o ) { return this = = o | | ( o instanceof Types & & types . equals ( ( ( Types ) o ) . types ) ) ; } @Override public int hashCode ( ) { return types . hashCode ( ) ; } @Override public String toString ( ) { return types . values ( ) . toString ( ) ; } public static final class Builder { final ImmutableMap . Builder < ByteBuffer , UserType > types = ImmutableMap . builder ( ) ; private Builder ( ) { } public Types build ( ) { return new Types ( this ) ; } public Builder add ( UserType type ) { types . put ( type . name , type ) ; return this ; } public Builder add ( UserType . . . types ) { for ( UserType type : types ) add ( type ) ; return this ; } public Builder add ( Iterable < UserType > types ) { types . forEach ( this : : add ) ; return this ; } } public static final class RawBuilder { final String keyspace ; final List < RawUDT > definitions ; private RawBuilder ( String keyspace ) { this . keyspace = keyspace ; this . definitions = new ArrayList < > ( ) ; } public Types build ( ) { if ( definitions . isEmpty ( ) ) return Types . none ( ) ; DefaultDirectedGraph < RawUDT , DefaultEdge > graph = new DefaultDirectedGraph < > ( DefaultEdge . class ) ; definitions . forEach ( graph : : addVertex ) ; for ( RawUDT udt1 : definitions ) for ( RawUDT udt2 : definitions ) if ( udt1 ! = udt2 & & udt1 . referencesUserType ( udt2 . name ) ) graph . addEdge ( udt2 , udt1 ) ; Types types = new Types ( new HashMap < > ( ) ) ; TopologicalOrderIterator < RawUDT , DefaultEdge > iterator = new TopologicalOrderIterator < > ( graph ) ; while ( iterator . hasNext ( ) ) { UserType udt = iterator . next ( ) . prepare ( keyspace , types ) ; types . types . put ( udt . name , udt ) ; } return Types . builder ( ) . add ( types ) . build ( ) ; } public void add ( String name , List < String > fieldNames , List < String > fieldTypes ) { List < CQL3Type . Raw > rawFieldTypes = fieldTypes . stream ( ) . map ( CQLTypeParser : : parseRaw ) . collect ( toList ( ) ) ; definitions . add ( new RawUDT ( name , fieldNames , rawFieldTypes ) ) ; } private static final class RawUDT { final String name ; final List < String > fieldNames ; final List < CQL3Type . Raw > fieldTypes ; RawUDT ( String name , List < String > fieldNames , List < CQL3Type . Raw > fieldTypes ) { this . name = name ; this . fieldNames = fieldNames ; this . fieldTypes = fieldTypes ; } boolean referencesUserType ( String typeName ) { return fieldTypes . stream ( ) . anyMatch ( t - > t . referencesUserType ( typeName ) ) ; } UserType prepare ( String keyspace , Types types ) { List < ByteBuffer > preparedFieldNames = fieldNames . stream ( ) . map ( ByteBufferUtil : : bytes ) . collect ( toList ( ) ) ; List < AbstractType < ? > > preparedFieldTypes = fieldTypes . stream ( ) . map ( t - > t . prepareInternal ( keyspace , types ) . getType ( ) ) . collect ( toList ( ) ) ; return new UserType ( keyspace , bytes ( name ) , preparedFieldNames , preparedFieldTypes ) ; } } } } 
