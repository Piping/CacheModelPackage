package org . elasticsearch . common . geo ; import org . apache . lucene . spatial . prefix . tree . GeohashPrefixTree ; import org . apache . lucene . spatial . prefix . tree . QuadPrefixTree ; import org . apache . lucene . util . SloppyMath ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . Numbers ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentParser . Token ; import org . elasticsearch . index . mapper . geo . GeoPointFieldMapper ; import java . io . IOException ; public class GeoUtils { public static final double MAX_LAT = <float> ; public static final double MIN_LAT = - <float> ; public static final double MAX_LON = <float> ; public static final double MIN_LON = - <float> ; public static final String LATITUDE = GeoPointFieldMapper . Names . LAT ; public static final String LONGITUDE = GeoPointFieldMapper . Names . LON ; public static final String GEOHASH = GeoPointFieldMapper . Names . GEOHASH ; public static final double EARTH_SEMI_MAJOR_AXIS = <float> ; public static final double EARTH_SEMI_MINOR_AXIS = <float> ; public static final double EARTH_MEAN_RADIUS = <float> ; public static final double EARTH_AXIS_RATIO = EARTH_SEMI_MINOR_AXIS / EARTH_SEMI_MAJOR_AXIS ; public static final double EARTH_EQUATOR = <int> * Math . PI * EARTH_SEMI_MAJOR_AXIS ; public static final double EARTH_POLAR_DISTANCE = Math . PI * EARTH_SEMI_MINOR_AXIS ; public static double maxRadialDistance ( GeoPoint center ) { if ( Math . abs ( center . lat ( ) ) = = <float> ) { return SloppyMath . haversin ( center . lat ( ) , center . lon ( ) , <int> , center . lon ( ) ) * <float> ; } return SloppyMath . haversin ( center . lat ( ) , center . lon ( ) , center . lat ( ) , ( <float> + center . lon ( ) ) % <int> ) * <float> ; } public static double maxRadialDistance ( GeoPoint center , double initialRadius ) { final double maxRadius = maxRadialDistance ( center ) ; return Math . min ( initialRadius , maxRadius ) ; } public static boolean isValidLatitude ( double latitude ) { if ( Double . isNaN ( latitude ) | | Double . isInfinite ( latitude ) | | latitude < GeoUtils . MIN_LAT | | latitude > GeoUtils . MAX_LAT ) { return false ; } return true ; } public static boolean isValidLongitude ( double longitude ) { if ( Double . isNaN ( longitude ) | | Double . isNaN ( longitude ) | | longitude < GeoUtils . MIN_LON | | longitude > GeoUtils . MAX_LON ) { return false ; } return true ; } public static double earthDiameter ( double latitude ) { return SloppyMath . earthDiameter ( latitude ) * <int> ; } public static double geoHashCellWidth ( int level ) { assert level > = <int> ; return EARTH_EQUATOR / ( <int> < < ( ( ( ( level + <int> ) / <int> ) * <int> ) + ( ( level / <int> ) * <int> ) ) ) ; } public static double quadTreeCellWidth ( int level ) { assert level > = <int> ; return EARTH_EQUATOR / ( <int> < < level ) ; } public static double geoHashCellHeight ( int level ) { assert level > = <int> ; return EARTH_POLAR_DISTANCE / ( <int> < < ( ( ( ( level + <int> ) / <int> ) * <int> ) + ( ( level / <int> ) * <int> ) ) ) ; } public static double quadTreeCellHeight ( int level ) { assert level > = <int> ; return EARTH_POLAR_DISTANCE / ( <int> < < level ) ; } public static double geoHashCellSize ( int level ) { assert level > = <int> ; final double w = geoHashCellWidth ( level ) ; final double h = geoHashCellHeight ( level ) ; return Math . sqrt ( w * w + h * h ) ; } public static double quadTreeCellSize ( int level ) { assert level > = <int> ; return Math . sqrt ( EARTH_POLAR_DISTANCE * EARTH_POLAR_DISTANCE + EARTH_EQUATOR * EARTH_EQUATOR ) / ( <int> < < level ) ; } public static int quadTreeLevelsForPrecision ( double meters ) { assert meters > = <int> ; if ( meters = = <int> ) { return QuadPrefixTree . MAX_LEVELS_POSSIBLE ; } else { final double ratio = <int> + ( EARTH_POLAR_DISTANCE / EARTH_EQUATOR ) ; final double width = Math . sqrt ( ( meters * meters ) / ( ratio * ratio ) ) ; final long part = Math . round ( Math . ceil ( EARTH_EQUATOR / width ) ) ; final int level = Long . SIZE - Long . numberOfLeadingZeros ( part ) - <int> ; return ( part < = ( <int> < < level ) ) ? level : ( level + <int> ) ; } } public static int quadTreeLevelsForPrecision ( String distance ) { return quadTreeLevelsForPrecision ( DistanceUnit . METERS . parse ( distance , DistanceUnit . DEFAULT ) ) ; } public static int geoHashLevelsForPrecision ( double meters ) { assert meters > = <int> ; if ( meters = = <int> ) { return GeohashPrefixTree . getMaxLevelsPossible ( ) ; } else { final double ratio = <int> + ( EARTH_POLAR_DISTANCE / EARTH_EQUATOR ) ; final double width = Math . sqrt ( ( meters * meters ) / ( ratio * ratio ) ) ; final double part = Math . ceil ( EARTH_EQUATOR / width ) ; if ( part = = <int> ) return <int> ; final int bits = ( int ) Math . round ( Math . ceil ( Math . log ( part ) / Math . log ( <int> ) ) ) ; final int full = bits / <int> ; final int left = bits - full * <int> ; final int even = full + ( left > <int> ? <int> : <int> ) ; final int odd = full + ( left > <int> ? <int> : <int> ) ; return even + odd ; } } public static int geoHashLevelsForPrecision ( String distance ) { return geoHashLevelsForPrecision ( DistanceUnit . METERS . parse ( distance , DistanceUnit . DEFAULT ) ) ; } public static double normalizeLon ( double lon ) { return centeredModulus ( lon , <int> ) ; } public static double normalizeLat ( double lat ) { lat = centeredModulus ( lat , <int> ) ; if ( lat < - <int> ) { lat = - <int> - lat ; } else if ( lat > <int> ) { lat = <int> - lat ; } return lat ; } public static void normalizePoint ( GeoPoint point ) { normalizePoint ( point , true , true ) ; } public static void normalizePoint ( GeoPoint point , boolean normLat , boolean normLon ) { double [ ] pt = { point . lon ( ) , point . lat ( ) } ; normalizePoint ( pt , normLon , normLat ) ; point . reset ( pt [ <int> ] , pt [ <int> ] ) ; } public static void normalizePoint ( double [ ] lonLat ) { normalizePoint ( lonLat , true , true ) ; } public static void normalizePoint ( double [ ] lonLat , boolean normLon , boolean normLat ) { assert lonLat ! = null & & lonLat . length = = <int> ; normLat = normLat & & ( lonLat [ <int> ] > <int> | | lonLat [ <int> ] < - <int> ) ; normLon = normLon & & ( lonLat [ <int> ] > <int> | | lonLat [ <int> ] < - <int> ) ; if ( normLat ) { lonLat [ <int> ] = centeredModulus ( lonLat [ <int> ] , <int> ) ; boolean shift = true ; if ( lonLat [ <int> ] < - <int> ) { lonLat [ <int> ] = - <int> - lonLat [ <int> ] ; } else if ( lonLat [ <int> ] > <int> ) { lonLat [ <int> ] = <int> - lonLat [ <int> ] ; } else { shift = false ; } if ( shift ) { if ( normLon ) { lonLat [ <int> ] + = <int> ; } else { lonLat [ <int> ] + = normalizeLon ( lonLat [ <int> ] ) > <int> ? - <int> : <int> ; } } } if ( normLon ) { lonLat [ <int> ] = centeredModulus ( lonLat [ <int> ] , <int> ) ; } } private static double centeredModulus ( double dividend , double divisor ) { double rtn = dividend % divisor ; if ( rtn < = <int> ) { rtn + = divisor ; } if ( rtn > divisor / <int> ) { rtn - = divisor ; } return rtn ; } public static GeoPoint parseGeoPoint ( XContentParser parser ) throws IOException , ElasticsearchParseException { return parseGeoPoint ( parser , new GeoPoint ( ) ) ; } public static GeoPoint parseGeoPoint ( XContentParser parser , GeoPoint point ) throws IOException , ElasticsearchParseException { double lat = Double . NaN ; double lon = Double . NaN ; String geohash = null ; if ( parser . currentToken ( ) = = Token . START_OBJECT ) { while ( parser . nextToken ( ) ! = Token . END_OBJECT ) { if ( parser . currentToken ( ) = = Token . FIELD_NAME ) { String field = parser . text ( ) ; if ( LATITUDE . equals ( field ) ) { parser . nextToken ( ) ; switch ( parser . currentToken ( ) ) { case VALUE_NUMBER : case VALUE_STRING : lat = parser . doubleValue ( true ) ; break ; default : throw new ElasticsearchParseException ( <str> ) ; } } else if ( LONGITUDE . equals ( field ) ) { parser . nextToken ( ) ; switch ( parser . currentToken ( ) ) { case VALUE_NUMBER : case VALUE_STRING : lon = parser . doubleValue ( true ) ; break ; default : throw new ElasticsearchParseException ( <str> ) ; } } else if ( GEOHASH . equals ( field ) ) { if ( parser . nextToken ( ) = = Token . VALUE_STRING ) { geohash = parser . text ( ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } } else { throw new ElasticsearchParseException ( <str> , LATITUDE , LONGITUDE , GEOHASH ) ; } } else { throw new ElasticsearchParseException ( <str> , parser . currentToken ( ) ) ; } } if ( geohash ! = null ) { if ( ! Double . isNaN ( lat ) | | ! Double . isNaN ( lon ) ) { throw new ElasticsearchParseException ( <str> ) ; } else { return point . resetFromGeoHash ( geohash ) ; } } else if ( Double . isNaN ( lat ) ) { throw new ElasticsearchParseException ( <str> , LATITUDE ) ; } else if ( Double . isNaN ( lon ) ) { throw new ElasticsearchParseException ( <str> , LONGITUDE ) ; } else { return point . reset ( lat , lon ) ; } } else if ( parser . currentToken ( ) = = Token . START_ARRAY ) { int element = <int> ; while ( parser . nextToken ( ) ! = Token . END_ARRAY ) { if ( parser . currentToken ( ) = = Token . VALUE_NUMBER ) { element + + ; if ( element = = <int> ) { lon = parser . doubleValue ( ) ; } else if ( element = = <int> ) { lat = parser . doubleValue ( ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } } else { throw new ElasticsearchParseException ( <str> ) ; } } return point . reset ( lat , lon ) ; } else if ( parser . currentToken ( ) = = Token . VALUE_STRING ) { String data = parser . text ( ) ; return parseGeoPoint ( data , point ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } } public static GeoPoint parseGeoPoint ( String data , GeoPoint point ) { int comma = data . indexOf ( <str> ) ; if ( comma > <int> ) { double lat = Double . parseDouble ( data . substring ( <int> , comma ) . trim ( ) ) ; double lon = Double . parseDouble ( data . substring ( comma + <int> ) . trim ( ) ) ; return point . reset ( lat , lon ) ; } else { return point . resetFromGeoHash ( data ) ; } } private GeoUtils ( ) { } } 
