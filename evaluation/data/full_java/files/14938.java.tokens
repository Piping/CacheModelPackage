package org . gradle . nativeplatform . internal . configure ; import org . gradle . internal . BiAction ; import org . gradle . model . ModelMap ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . core . rule . describe . SimpleModelRuleDescriptor ; import org . gradle . model . internal . manage . instance . ManagedInstance ; import org . gradle . nativeplatform . * ; import org . gradle . nativeplatform . internal . NativeBinarySpecInternal ; import org . gradle . nativeplatform . internal . resolve . NativeDependencyResolver ; import org . gradle . nativeplatform . platform . NativePlatform ; import org . gradle . platform . base . internal . BinaryNamingScheme ; public class NativeBinaries { public static void createNativeBinaries ( NativeComponentSpec component , ModelMap < NativeBinarySpec > binaries , NativeDependencyResolver resolver , BinaryNamingScheme namingScheme , NativePlatform platform , BuildType buildType , Flavor flavor ) { if ( component instanceof NativeLibrarySpec ) { createNativeBinary ( SharedLibraryBinarySpec . class , binaries , resolver , namingScheme . withBinaryType ( <str> ) . withRole ( <str> , false ) , platform , buildType , flavor ) ; createNativeBinary ( StaticLibraryBinarySpec . class , binaries , resolver , namingScheme . withBinaryType ( <str> ) . withRole ( <str> , false ) , platform , buildType , flavor ) ; } else { createNativeBinary ( NativeExecutableBinarySpec . class , binaries , resolver , namingScheme . withBinaryType ( <str> ) . withRole ( <str> , true ) , platform , buildType , flavor ) ; } } private static < T extends NativeBinarySpec > void createNativeBinary ( Class < T > type , ModelMap < NativeBinarySpec > binaries , final NativeDependencyResolver resolver , final BinaryNamingScheme namingScheme , final NativePlatform platform , final BuildType buildType , final Flavor flavor ) { final String name = namingScheme . getBinaryName ( ) ; binaries . create ( name , type ) ; MutableModelNode backingNode = ( ( ManagedInstance ) binaries ) . getBackingNode ( ) ; ModelPath binaryPath = backingNode . getPath ( ) . child ( name ) ; backingNode . applyToLink ( ModelActionRole . Defaults , DirectNodeNoInputsModelAction . of ( ModelReference . of ( binaryPath , NativeBinarySpec . class ) , new SimpleModelRuleDescriptor ( <str> + binaryPath ) , new BiAction < MutableModelNode , NativeBinarySpec > ( ) { @Override public void execute ( MutableModelNode mutableModelNode , NativeBinarySpec nativeBinarySpec ) { initialize ( nativeBinarySpec , namingScheme , resolver , platform , buildType , flavor ) ; } } ) ) ; binaries . named ( name , NativeBinaryRules . class ) ; } public static void initialize ( NativeBinarySpec nativeBinarySpec , BinaryNamingScheme namingScheme , NativeDependencyResolver resolver , NativePlatform platform , BuildType buildType , Flavor flavor ) { NativeBinarySpecInternal nativeBinary = ( NativeBinarySpecInternal ) nativeBinarySpec ; nativeBinary . setNamingScheme ( namingScheme ) ; nativeBinary . setTargetPlatform ( platform ) ; nativeBinary . setBuildType ( buildType ) ; nativeBinary . setFlavor ( flavor ) ; nativeBinary . setResolver ( resolver ) ; } } 
