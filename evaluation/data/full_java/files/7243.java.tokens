package org . elasticsearch . search . aggregations . bucket . significant ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . bucket . BucketUtils ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . JLHScore ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . SignificanceHeuristic ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . SignificanceHeuristicParserMapper ; import org . elasticsearch . search . aggregations . bucket . terms . TermsAggregator ; import org . elasticsearch . search . aggregations . bucket . terms . support . IncludeExclude ; import org . elasticsearch . search . aggregations . support . ValuesSourceParser ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; public class SignificantTermsParser implements Aggregator . Parser { private final SignificanceHeuristicParserMapper significanceHeuristicParserMapper ; @Inject public SignificantTermsParser ( SignificanceHeuristicParserMapper significanceHeuristicParserMapper ) { this . significanceHeuristicParserMapper = significanceHeuristicParserMapper ; } @Override public String type ( ) { return SignificantStringTerms . TYPE . name ( ) ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { SignificantTermsParametersParser aggParser = new SignificantTermsParametersParser ( significanceHeuristicParserMapper ) ; ValuesSourceParser vsParser = ValuesSourceParser . any ( aggregationName , SignificantStringTerms . TYPE , context ) . scriptable ( false ) . formattable ( true ) . build ( ) ; IncludeExclude . Parser incExcParser = new IncludeExclude . Parser ( ) ; aggParser . parse ( aggregationName , parser , context , vsParser , incExcParser ) ; TermsAggregator . BucketCountThresholds bucketCountThresholds = aggParser . getBucketCountThresholds ( ) ; if ( bucketCountThresholds . getShardSize ( ) = = aggParser . getDefaultBucketCountThresholds ( ) . getShardSize ( ) ) { bucketCountThresholds . setShardSize ( <int> * BucketUtils . suggestShardSideQueueSize ( bucketCountThresholds . getRequiredSize ( ) , context . numberOfShards ( ) ) ) ; } bucketCountThresholds . ensureValidity ( ) ; SignificanceHeuristic significanceHeuristic = aggParser . getSignificanceHeuristic ( ) ; if ( significanceHeuristic = = null ) { significanceHeuristic = JLHScore . INSTANCE ; } return new SignificantTermsAggregatorFactory ( aggregationName , vsParser . config ( ) , bucketCountThresholds , aggParser . getIncludeExclude ( ) , aggParser . getExecutionHint ( ) , aggParser . getFilter ( ) , significanceHeuristic ) ; } } 
