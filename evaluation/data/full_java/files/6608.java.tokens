package org . elasticsearch . index . query ; import org . apache . lucene . search . GeoPointInBBoxQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . Version ; import org . elasticsearch . common . Numbers ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . fielddata . IndexGeoPointFieldData ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . geo . BaseGeoPointFieldMapper ; import org . elasticsearch . index . mapper . geo . GeoPointFieldMapperLegacy ; import org . elasticsearch . index . search . geo . InMemoryGeoBoundingBoxQuery ; import org . elasticsearch . index . search . geo . IndexedGeoBoundingBoxQuery ; import java . io . IOException ; import java . util . Objects ; public class GeoBoundingBoxQueryBuilder extends AbstractQueryBuilder < GeoBoundingBoxQueryBuilder > { public static final String NAME = <str> ; public static final GeoExecType DEFAULT_TYPE = GeoExecType . MEMORY ; static final GeoBoundingBoxQueryBuilder PROTOTYPE = new GeoBoundingBoxQueryBuilder ( <str> ) ; private final String fieldName ; private GeoPoint topLeft = new GeoPoint ( Double . NaN , Double . NaN ) ; private GeoPoint bottomRight = new GeoPoint ( Double . NaN , Double . NaN ) ; private GeoValidationMethod validationMethod = GeoValidationMethod . DEFAULT ; private GeoExecType type = DEFAULT_TYPE ; public GeoBoundingBoxQueryBuilder ( String fieldName ) { if ( fieldName = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldName = fieldName ; } public GeoBoundingBoxQueryBuilder setCorners ( double top , double left , double bottom , double right ) { if ( GeoValidationMethod . isIgnoreMalformed ( validationMethod ) = = false ) { if ( Numbers . isValidDouble ( top ) = = false ) { throw new IllegalArgumentException ( <str> + top ) ; } if ( Numbers . isValidDouble ( left ) = = false ) { throw new IllegalArgumentException ( <str> + left ) ; } if ( Numbers . isValidDouble ( bottom ) = = false ) { throw new IllegalArgumentException ( <str> + bottom ) ; } if ( Numbers . isValidDouble ( right ) = = false ) { throw new IllegalArgumentException ( <str> + right ) ; } if ( top < bottom ) { throw new IllegalArgumentException ( <str> + top + <str> + bottom ) ; } } topLeft . reset ( top , left ) ; bottomRight . reset ( bottom , right ) ; return this ; } public GeoBoundingBoxQueryBuilder setCorners ( GeoPoint topLeft , GeoPoint bottomRight ) { return setCorners ( topLeft . getLat ( ) , topLeft . getLon ( ) , bottomRight . getLat ( ) , bottomRight . getLon ( ) ) ; } public GeoBoundingBoxQueryBuilder setCorners ( String topLeft , String bottomRight ) { return setCorners ( GeoPoint . fromGeohash ( topLeft ) , GeoPoint . fromGeohash ( bottomRight ) ) ; } public GeoPoint topLeft ( ) { return topLeft ; } public GeoPoint bottomRight ( ) { return bottomRight ; } public GeoBoundingBoxQueryBuilder setCornersOGC ( GeoPoint bottomLeft , GeoPoint topRight ) { return setCorners ( topRight . getLat ( ) , bottomLeft . getLon ( ) , bottomLeft . getLat ( ) , topRight . getLon ( ) ) ; } public GeoBoundingBoxQueryBuilder setCornersOGC ( String bottomLeft , String topRight ) { return setCornersOGC ( GeoPoint . fromGeohash ( bottomLeft ) , GeoPoint . fromGeohash ( topRight ) ) ; } public GeoBoundingBoxQueryBuilder setValidationMethod ( GeoValidationMethod method ) { this . validationMethod = method ; return this ; } public GeoValidationMethod getValidationMethod ( ) { return this . validationMethod ; } public GeoBoundingBoxQueryBuilder type ( GeoExecType type ) { if ( type = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . type = type ; return this ; } public GeoBoundingBoxQueryBuilder type ( String type ) { this . type = GeoExecType . fromString ( type ) ; return this ; } public GeoExecType type ( ) { return type ; } public String fieldName ( ) { return this . fieldName ; } QueryValidationException checkLatLon ( boolean indexCreatedBeforeV2_0 ) { if ( GeoValidationMethod . isIgnoreMalformed ( validationMethod ) = = true | | indexCreatedBeforeV2_0 ) { return null ; } QueryValidationException validationException = null ; if ( GeoUtils . isValidLatitude ( topLeft . getLat ( ) ) = = false ) { validationException = addValidationError ( <str> + topLeft . getLat ( ) , validationException ) ; } if ( GeoUtils . isValidLongitude ( topLeft . getLon ( ) ) = = false ) { validationException = addValidationError ( <str> + topLeft . getLon ( ) , validationException ) ; } if ( GeoUtils . isValidLatitude ( bottomRight . getLat ( ) ) = = false ) { validationException = addValidationError ( <str> + bottomRight . getLat ( ) , validationException ) ; } if ( GeoUtils . isValidLongitude ( bottomRight . getLon ( ) ) = = false ) { validationException = addValidationError ( <str> + bottomRight . getLon ( ) , validationException ) ; } return validationException ; } @Override public Query doToQuery ( QueryShardContext context ) { MappedFieldType fieldType = context . fieldMapper ( fieldName ) ; if ( fieldType = = null ) { throw new QueryShardException ( context , <str> + fieldName + <str> ) ; } if ( ! ( fieldType instanceof BaseGeoPointFieldMapper . GeoPointFieldType ) ) { throw new QueryShardException ( context , <str> + fieldName + <str> ) ; } QueryValidationException exception = checkLatLon ( context . indexVersionCreated ( ) . before ( Version . V_2_0_0 ) ) ; if ( exception ! = null ) { throw new QueryShardException ( context , <str> , exception ) ; } GeoPoint luceneTopLeft = new GeoPoint ( topLeft ) ; GeoPoint luceneBottomRight = new GeoPoint ( bottomRight ) ; if ( GeoValidationMethod . isCoerce ( validationMethod ) ) { double right = luceneBottomRight . getLon ( ) ; double left = luceneTopLeft . getLon ( ) ; boolean completeLonRange = ( ( right - left ) % <int> = = <int> & & right > left ) ; GeoUtils . normalizePoint ( luceneTopLeft , true , ! completeLonRange ) ; GeoUtils . normalizePoint ( luceneBottomRight , true , ! completeLonRange ) ; if ( completeLonRange ) { luceneTopLeft . resetLon ( - <int> ) ; luceneBottomRight . resetLon ( <int> ) ; } } if ( context . indexVersionCreated ( ) . onOrAfter ( Version . V_2_2_0 ) ) { return new GeoPointInBBoxQuery ( fieldType . names ( ) . fullName ( ) , luceneTopLeft . lon ( ) , luceneBottomRight . lat ( ) , luceneBottomRight . lon ( ) , luceneTopLeft . lat ( ) ) ; } Query query ; switch ( type ) { case INDEXED : GeoPointFieldMapperLegacy . GeoPointFieldType geoFieldType = ( ( GeoPointFieldMapperLegacy . GeoPointFieldType ) fieldType ) ; query = IndexedGeoBoundingBoxQuery . create ( luceneTopLeft , luceneBottomRight , geoFieldType ) ; break ; case MEMORY : IndexGeoPointFieldData indexFieldData = context . getForField ( fieldType ) ; query = new InMemoryGeoBoundingBoxQuery ( luceneTopLeft , luceneBottomRight , indexFieldData ) ; break ; default : throw new IllegalStateException ( <str> + type + <str> ) ; } return query ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . startObject ( fieldName ) ; builder . array ( GeoBoundingBoxQueryParser . TOP_LEFT_FIELD . getPreferredName ( ) , topLeft . getLon ( ) , topLeft . getLat ( ) ) ; builder . array ( GeoBoundingBoxQueryParser . BOTTOM_RIGHT_FIELD . getPreferredName ( ) , bottomRight . getLon ( ) , bottomRight . getLat ( ) ) ; builder . endObject ( ) ; builder . field ( GeoBoundingBoxQueryParser . VALIDATION_METHOD_FIELD . getPreferredName ( ) , validationMethod ) ; builder . field ( GeoBoundingBoxQueryParser . TYPE_FIELD . getPreferredName ( ) , type ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override protected boolean doEquals ( GeoBoundingBoxQueryBuilder other ) { return Objects . equals ( topLeft , other . topLeft ) & & Objects . equals ( bottomRight , other . bottomRight ) & & Objects . equals ( type , other . type ) & & Objects . equals ( validationMethod , other . validationMethod ) & & Objects . equals ( fieldName , other . fieldName ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( topLeft , bottomRight , type , validationMethod , fieldName ) ; } @Override protected GeoBoundingBoxQueryBuilder doReadFrom ( StreamInput in ) throws IOException { String fieldName = in . readString ( ) ; GeoBoundingBoxQueryBuilder geo = new GeoBoundingBoxQueryBuilder ( fieldName ) ; geo . topLeft = in . readGeoPoint ( ) ; geo . bottomRight = in . readGeoPoint ( ) ; geo . type = GeoExecType . readTypeFrom ( in ) ; geo . validationMethod = GeoValidationMethod . readGeoValidationMethodFrom ( in ) ; return geo ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( fieldName ) ; out . writeGeoPoint ( topLeft ) ; out . writeGeoPoint ( bottomRight ) ; type . writeTo ( out ) ; validationMethod . writeTo ( out ) ; } @Override public String getWriteableName ( ) { return NAME ; } } 
