package org . apache . cassandra ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Writer ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . Date ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . Properties ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import org . apache . tools . ant . BuildException ; import org . apache . tools . ant . taskdefs . optional . junit . IgnoredTestListener ; import org . apache . tools . ant . taskdefs . optional . junit . JUnitResultFormatter ; import org . apache . tools . ant . taskdefs . optional . junit . JUnitTest ; import org . apache . tools . ant . taskdefs . optional . junit . JUnitTestRunner ; import org . apache . tools . ant . taskdefs . optional . junit . JUnitVersionHelper ; import org . apache . tools . ant . taskdefs . optional . junit . XMLConstants ; import org . apache . tools . ant . util . DOMElementWriter ; import org . apache . tools . ant . util . DateUtils ; import org . apache . tools . ant . util . FileUtils ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Text ; public class CassandraXMLJUnitResultFormatter implements JUnitResultFormatter , XMLConstants , IgnoredTestListener { private static final double ONE_SECOND = <float> ; private static final String UNKNOWN = <str> ; private static DocumentBuilder getDocumentBuilder ( ) { try { return DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; } catch ( final Exception exc ) { throw new ExceptionInInitializerError ( exc ) ; } } private static final String tag = System . getProperty ( <str> , <str> ) ; static { String command = System . getProperty ( <str> ) ; String args [ ] = command . split ( <str> ) ; System . setProperty ( <str> , args [ <int> ] ) ; } private Document doc ; private Element rootElement ; private final Hashtable < String , Element > testElements = new Hashtable < String , Element > ( ) ; private final Hashtable failedTests = new Hashtable ( ) ; private final Hashtable < String , Test > skippedTests = new Hashtable < String , Test > ( ) ; private final Hashtable < String , Test > ignoredTests = new Hashtable < String , Test > ( ) ; private final Hashtable < String , Long > testStarts = new Hashtable < String , Long > ( ) ; private OutputStream out ; public CassandraXMLJUnitResultFormatter ( ) { } public void setOutput ( final OutputStream out ) { this . out = out ; } public void setSystemOutput ( final String out ) { formatOutput ( SYSTEM_OUT , out ) ; } public void setSystemError ( final String out ) { formatOutput ( SYSTEM_ERR , out ) ; } public void startTestSuite ( final JUnitTest suite ) { doc = getDocumentBuilder ( ) . newDocument ( ) ; rootElement = doc . createElement ( TESTSUITE ) ; String n = suite . getName ( ) ; rootElement . setAttribute ( ATTR_NAME , n = = null ? UNKNOWN : n ) ; final String timestamp = DateUtils . format ( new Date ( ) , DateUtils . ISO8601_DATETIME_PATTERN ) ; rootElement . setAttribute ( TIMESTAMP , timestamp ) ; rootElement . setAttribute ( HOSTNAME , getHostname ( ) ) ; final Element propsElement = doc . createElement ( PROPERTIES ) ; rootElement . appendChild ( propsElement ) ; final Properties props = suite . getProperties ( ) ; if ( props ! = null ) { final Enumeration e = props . propertyNames ( ) ; while ( e . hasMoreElements ( ) ) { final String name = ( String ) e . nextElement ( ) ; final Element propElement = doc . createElement ( PROPERTY ) ; propElement . setAttribute ( ATTR_NAME , name ) ; propElement . setAttribute ( ATTR_VALUE , props . getProperty ( name ) ) ; propsElement . appendChild ( propElement ) ; } } } private String getHostname ( ) { String hostname = <str> ; try { final InetAddress localHost = InetAddress . getLocalHost ( ) ; if ( localHost ! = null ) { hostname = localHost . getHostName ( ) ; } } catch ( final UnknownHostException e ) { } return hostname ; } public void endTestSuite ( final JUnitTest suite ) throws BuildException { rootElement . setAttribute ( ATTR_TESTS , <str> + suite . runCount ( ) ) ; rootElement . setAttribute ( ATTR_FAILURES , <str> + suite . failureCount ( ) ) ; rootElement . setAttribute ( ATTR_ERRORS , <str> + suite . errorCount ( ) ) ; rootElement . setAttribute ( ATTR_SKIPPED , <str> + suite . skipCount ( ) ) ; rootElement . setAttribute ( ATTR_TIME , <str> + ( suite . getRunTime ( ) / ONE_SECOND ) ) ; if ( out ! = null ) { Writer wri = null ; try { wri = new BufferedWriter ( new OutputStreamWriter ( out , <str> ) ) ; wri . write ( <str> ) ; ( new DOMElementWriter ( ) ) . write ( rootElement , wri , <int> , <str> ) ; } catch ( final IOException exc ) { throw new BuildException ( <str> , exc ) ; } finally { if ( wri ! = null ) { try { wri . flush ( ) ; } catch ( final IOException ex ) { } } if ( out ! = System . out & & out ! = System . err ) { FileUtils . close ( wri ) ; } } } } public void startTest ( final Test t ) { testStarts . put ( createDescription ( t ) , System . currentTimeMillis ( ) ) ; } private static String createDescription ( final Test test ) throws BuildException { if ( ! tag . isEmpty ( ) ) return JUnitVersionHelper . getTestCaseName ( test ) + <str> + tag + <str> + JUnitVersionHelper . getTestCaseClassName ( test ) + <str> ; return JUnitVersionHelper . getTestCaseName ( test ) + <str> + JUnitVersionHelper . getTestCaseClassName ( test ) + <str> ; } public void endTest ( final Test test ) { final String testDescription = createDescription ( test ) ; if ( ! testStarts . containsKey ( testDescription ) ) { startTest ( test ) ; } Element currentTest ; if ( ! failedTests . containsKey ( test ) & & ! skippedTests . containsKey ( testDescription ) & & ! ignoredTests . containsKey ( testDescription ) ) { currentTest = doc . createElement ( TESTCASE ) ; String n = JUnitVersionHelper . getTestCaseName ( test ) ; if ( n ! = null & & ! tag . isEmpty ( ) ) n = n + <str> + tag ; currentTest . setAttribute ( ATTR_NAME , n = = null ? UNKNOWN : n ) ; currentTest . setAttribute ( ATTR_CLASSNAME , JUnitVersionHelper . getTestCaseClassName ( test ) ) ; rootElement . appendChild ( currentTest ) ; testElements . put ( createDescription ( test ) , currentTest ) ; } else { currentTest = testElements . get ( testDescription ) ; } final Long l = testStarts . get ( createDescription ( test ) ) ; currentTest . setAttribute ( ATTR_TIME , <str> + ( ( System . currentTimeMillis ( ) - l ) / ONE_SECOND ) ) ; } public void addFailure ( final Test test , final Throwable t ) { formatError ( FAILURE , test , t ) ; } public void addFailure ( final Test test , final AssertionFailedError t ) { addFailure ( test , ( Throwable ) t ) ; } public void addError ( final Test test , final Throwable t ) { formatError ( ERROR , test , t ) ; } private void formatError ( final String type , final Test test , final Throwable t ) { if ( test ! = null ) { endTest ( test ) ; failedTests . put ( test , test ) ; } final Element nested = doc . createElement ( type ) ; Element currentTest ; if ( test ! = null ) { currentTest = testElements . get ( createDescription ( test ) ) ; } else { currentTest = rootElement ; } currentTest . appendChild ( nested ) ; final String message = t . getMessage ( ) ; if ( message ! = null & & message . length ( ) > <int> ) { nested . setAttribute ( ATTR_MESSAGE , t . getMessage ( ) ) ; } nested . setAttribute ( ATTR_TYPE , t . getClass ( ) . getName ( ) ) ; final String strace = JUnitTestRunner . getFilteredTrace ( t ) ; final Text trace = doc . createTextNode ( strace ) ; nested . appendChild ( trace ) ; } private void formatOutput ( final String type , final String output ) { final Element nested = doc . createElement ( type ) ; rootElement . appendChild ( nested ) ; nested . appendChild ( doc . createCDATASection ( output ) ) ; } public void testIgnored ( final Test test ) { formatSkip ( test , JUnitVersionHelper . getIgnoreMessage ( test ) ) ; if ( test ! = null ) { ignoredTests . put ( createDescription ( test ) , test ) ; } } public void formatSkip ( final Test test , final String message ) { if ( test ! = null ) { endTest ( test ) ; } final Element nested = doc . createElement ( <str> ) ; if ( message ! = null ) { nested . setAttribute ( <str> , message ) ; } Element currentTest ; if ( test ! = null ) { currentTest = testElements . get ( createDescription ( test ) ) ; } else { currentTest = rootElement ; } currentTest . appendChild ( nested ) ; } public void testAssumptionFailure ( final Test test , final Throwable failure ) { formatSkip ( test , failure . getMessage ( ) ) ; skippedTests . put ( createDescription ( test ) , test ) ; } } 
