package org . elasticsearch . search . aggregations . bucket . significant ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . search . aggregations . AggregationBuilder ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . SignificanceHeuristic ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . SignificanceHeuristicBuilder ; import org . elasticsearch . search . aggregations . bucket . terms . AbstractTermsParametersParser ; import org . elasticsearch . search . aggregations . bucket . terms . TermsAggregator ; import java . io . IOException ; public class SignificantTermsBuilder extends AggregationBuilder < SignificantTermsBuilder > { private TermsAggregator . BucketCountThresholds bucketCountThresholds = new TermsAggregator . BucketCountThresholds ( - <int> , - <int> , - <int> , - <int> ) ; private String field ; private String executionHint ; private String includePattern ; private int includeFlags ; private String excludePattern ; private int excludeFlags ; private String [ ] includeTerms = null ; private String [ ] excludeTerms = null ; private QueryBuilder filterBuilder ; private SignificanceHeuristicBuilder significanceHeuristicBuilder ; public SignificantTermsBuilder ( String name ) { super ( name , SignificantStringTerms . TYPE . name ( ) ) ; } public SignificantTermsBuilder field ( String field ) { this . field = field ; return this ; } public SignificantTermsBuilder size ( int requiredSize ) { bucketCountThresholds . setRequiredSize ( requiredSize ) ; return this ; } public SignificantTermsBuilder shardSize ( int shardSize ) { bucketCountThresholds . setShardSize ( shardSize ) ; return this ; } public SignificantTermsBuilder minDocCount ( int minDocCount ) { bucketCountThresholds . setMinDocCount ( minDocCount ) ; return this ; } public SignificantTermsBuilder backgroundFilter ( QueryBuilder filter ) { this . filterBuilder = filter ; return this ; } public SignificantTermsBuilder shardMinDocCount ( int shardMinDocCount ) { bucketCountThresholds . setShardMinDocCount ( shardMinDocCount ) ; return this ; } public SignificantTermsBuilder executionHint ( String executionHint ) { this . executionHint = executionHint ; return this ; } public SignificantTermsBuilder include ( String regex ) { return include ( regex , <int> ) ; } public SignificantTermsBuilder include ( String regex , int flags ) { if ( includeTerms ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . includePattern = regex ; this . includeFlags = flags ; return this ; } public SignificantTermsBuilder include ( String [ ] terms ) { if ( includePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . includeTerms = terms ; return this ; } public SignificantTermsBuilder include ( long [ ] terms ) { if ( includePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . includeTerms = longsArrToStringArr ( terms ) ; return this ; } private String [ ] longsArrToStringArr ( long [ ] terms ) { String [ ] termsAsString = new String [ terms . length ] ; for ( int i = <int> ; i < terms . length ; i + + ) { termsAsString [ i ] = Long . toString ( terms [ i ] ) ; } return termsAsString ; } public SignificantTermsBuilder exclude ( String regex ) { return exclude ( regex , <int> ) ; } public SignificantTermsBuilder exclude ( String regex , int flags ) { if ( excludeTerms ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . excludePattern = regex ; this . excludeFlags = flags ; return this ; } public SignificantTermsBuilder exclude ( String [ ] terms ) { if ( excludePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . excludeTerms = terms ; return this ; } public SignificantTermsBuilder exclude ( long [ ] terms ) { if ( excludePattern ! = null ) { throw new IllegalArgumentException ( <str> ) ; } this . excludeTerms = longsArrToStringArr ( terms ) ; return this ; } @Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; if ( field ! = null ) { builder . field ( <str> , field ) ; } bucketCountThresholds . toXContent ( builder ) ; if ( executionHint ! = null ) { builder . field ( AbstractTermsParametersParser . EXECUTION_HINT_FIELD_NAME . getPreferredName ( ) , executionHint ) ; } if ( includePattern ! = null ) { if ( includeFlags = = <int> ) { builder . field ( <str> , includePattern ) ; } else { builder . startObject ( <str> ) . field ( <str> , includePattern ) . field ( <str> , includeFlags ) . endObject ( ) ; } } if ( includeTerms ! = null ) { builder . array ( <str> , includeTerms ) ; } if ( excludePattern ! = null ) { if ( excludeFlags = = <int> ) { builder . field ( <str> , excludePattern ) ; } else { builder . startObject ( <str> ) . field ( <str> , excludePattern ) . field ( <str> , excludeFlags ) . endObject ( ) ; } } if ( excludeTerms ! = null ) { builder . array ( <str> , excludeTerms ) ; } if ( filterBuilder ! = null ) { builder . field ( SignificantTermsParametersParser . BACKGROUND_FILTER . getPreferredName ( ) ) ; filterBuilder . toXContent ( builder , params ) ; } if ( significanceHeuristicBuilder ! = null ) { significanceHeuristicBuilder . toXContent ( builder , params ) ; } return builder . endObject ( ) ; } public SignificantTermsBuilder significanceHeuristic ( SignificanceHeuristicBuilder significanceHeuristicBuilder ) { this . significanceHeuristicBuilder = significanceHeuristicBuilder ; return this ; } } 
