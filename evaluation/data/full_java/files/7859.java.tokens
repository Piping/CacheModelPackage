package org . elasticsearch . cluster . routing . allocation ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . EmptyClusterInfoService ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . MetaData . Builder ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . allocator . ShardsAllocators ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDeciders ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . cluster . routing . allocation . decider . SameShardAllocationDecider ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESAllocationTestCase ; import org . elasticsearch . test . gateway . NoopGatewayAllocator ; import org . hamcrest . Matchers ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Random ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . equalTo ; public class RandomAllocationDeciderTests extends ESAllocationTestCase { public void testRandomDecisions ( ) { RandomAllocationDecider randomAllocationDecider = new RandomAllocationDecider ( getRandom ( ) ) ; AllocationService strategy = new AllocationService ( settingsBuilder ( ) . build ( ) , new AllocationDeciders ( Settings . EMPTY , new HashSet < > ( Arrays . asList ( new SameShardAllocationDecider ( Settings . EMPTY ) , randomAllocationDecider ) ) ) , new ShardsAllocators ( NoopGatewayAllocator . INSTANCE ) , EmptyClusterInfoService . INSTANCE ) ; int indices = scaledRandomIntBetween ( <int> , <int> ) ; Builder metaBuilder = MetaData . builder ( ) ; int maxNumReplicas = <int> ; int totalNumShards = <int> ; for ( int i = <int> ; i < indices ; i + + ) { int replicas = scaledRandomIntBetween ( <int> , <int> ) ; maxNumReplicas = Math . max ( maxNumReplicas , replicas + <int> ) ; int numShards = scaledRandomIntBetween ( <int> , <int> ) ; totalNumShards + = numShards * ( replicas + <int> ) ; metaBuilder . put ( IndexMetaData . builder ( <str> + i ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( numShards ) . numberOfReplicas ( replicas ) ) ; } MetaData metaData = metaBuilder . build ( ) ; RoutingTable . Builder routingTableBuilder = RoutingTable . builder ( ) ; for ( int i = <int> ; i < indices ; i + + ) { routingTableBuilder . addAsNew ( metaData . index ( <str> + i ) ) ; } RoutingTable routingTable = routingTableBuilder . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; int numIters = scaledRandomIntBetween ( <int> , <int> ) ; int nodeIdCounter = <int> ; int atMostNodes = scaledRandomIntBetween ( Math . max ( <int> , maxNumReplicas ) , <int> ) ; final boolean frequentNodes = randomBoolean ( ) ; for ( int i = <int> ; i < numIters ; i + + ) { logger . info ( <str> , i ) ; ClusterState . Builder stateBuilder = ClusterState . builder ( clusterState ) ; DiscoveryNodes . Builder newNodesBuilder = DiscoveryNodes . builder ( clusterState . nodes ( ) ) ; if ( clusterState . nodes ( ) . size ( ) < = atMostNodes & & ( nodeIdCounter = = <int> | | ( frequentNodes ? frequently ( ) : rarely ( ) ) ) ) { int numNodes = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < numNodes ; j + + ) { logger . info ( <str> , nodeIdCounter ) ; newNodesBuilder . put ( newNode ( <str> + ( nodeIdCounter + + ) ) ) ; } } if ( nodeIdCounter > <int> & & rarely ( ) ) { int nodeId = scaledRandomIntBetween ( <int> , nodeIdCounter - <int> ) ; logger . info ( <str> , nodeId ) ; newNodesBuilder . remove ( <str> + nodeId ) ; } stateBuilder . nodes ( newNodesBuilder . build ( ) ) ; clusterState = stateBuilder . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; if ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) > <int> ) { routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; } } logger . info ( <str> ) ; if ( clusterState . nodes ( ) . size ( ) < maxNumReplicas ) { ClusterState . Builder stateBuilder = ClusterState . builder ( clusterState ) ; DiscoveryNodes . Builder newNodesBuilder = DiscoveryNodes . builder ( clusterState . nodes ( ) ) ; for ( int j = <int> ; j < ( maxNumReplicas - clusterState . nodes ( ) . size ( ) ) ; j + + ) { logger . info ( <str> , nodeIdCounter ) ; newNodesBuilder . put ( newNode ( <str> + ( nodeIdCounter + + ) ) ) ; } stateBuilder . nodes ( newNodesBuilder . build ( ) ) ; clusterState = stateBuilder . build ( ) ; } randomAllocationDecider . alwaysSayYes = true ; logger . info ( <str> ) ; int iterations = <int> ; do { iterations + + ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; if ( clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) . size ( ) > <int> ) { routingTable = strategy . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; } } while ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) ! = <int> | | clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) ! = <int> & & iterations < <int> ) ; logger . info ( <str> , iterations ) ; assertThat ( <str> , iterations , Matchers . lessThan ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; int shards = clusterState . getRoutingNodes ( ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) ; assertThat ( shards , equalTo ( totalNumShards ) ) ; final int numNodes = clusterState . nodes ( ) . size ( ) ; final int upperBound = ( int ) Math . round ( ( ( shards / numNodes ) * <float> ) ) ; final int lowerBound = ( int ) Math . round ( ( ( shards / numNodes ) * <float> ) ) ; for ( int i = <int> ; i < nodeIdCounter ; i + + ) { if ( clusterState . getRoutingNodes ( ) . node ( <str> + i ) = = null ) { continue ; } assertThat ( clusterState . getRoutingNodes ( ) . node ( <str> + i ) . size ( ) , Matchers . anyOf ( Matchers . anyOf ( equalTo ( ( shards / numNodes ) + <int> ) , equalTo ( ( shards / numNodes ) - <int> ) , equalTo ( ( shards / numNodes ) ) ) , Matchers . allOf ( Matchers . greaterThanOrEqualTo ( lowerBound ) , Matchers . lessThanOrEqualTo ( upperBound ) ) ) ) ; } } private static final class RandomAllocationDecider extends AllocationDecider { private final Random random ; public RandomAllocationDecider ( Random random ) { super ( Settings . EMPTY ) ; this . random = random ; } public boolean alwaysSayYes = false ; @Override public Decision canRebalance ( ShardRouting shardRouting , RoutingAllocation allocation ) { return getRandomDecision ( ) ; } private Decision getRandomDecision ( ) { if ( alwaysSayYes ) { return Decision . YES ; } switch ( random . nextInt ( <int> ) ) { case <int> : case <int> : case <int> : case <int> : case <int> : return Decision . NO ; case <int> : return Decision . THROTTLE ; case <int> : case <int> : case <int> : return Decision . YES ; default : return Decision . ALWAYS ; } } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return getRandomDecision ( ) ; } @Override public Decision canRemain ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return getRandomDecision ( ) ; } } } 
