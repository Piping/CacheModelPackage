package org . apache . cassandra . tools ; import java . io . File ; import java . io . IOException ; import java . net . InetAddress ; import java . net . MalformedURLException ; import java . net . UnknownHostException ; import java . util . * ; import com . google . common . collect . HashMultimap ; import com . google . common . collect . Multimap ; import org . apache . commons . cli . * ; import com . datastax . driver . core . SSLOptions ; import javax . net . ssl . SSLContext ; import org . apache . cassandra . config . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . SSTableLoader ; import org . apache . cassandra . security . SSLFactory ; import org . apache . cassandra . streaming . * ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . NativeSSTableLoaderClient ; import org . apache . cassandra . utils . OutputHandler ; public class BulkLoader { private static final String TOOL_NAME = <str> ; private static final String VERBOSE_OPTION = <str> ; private static final String HELP_OPTION = <str> ; private static final String NOPROGRESS_OPTION = <str> ; private static final String IGNORE_NODES_OPTION = <str> ; private static final String INITIAL_HOST_ADDRESS_OPTION = <str> ; private static final String NATIVE_PORT_OPTION = <str> ; private static final String USER_OPTION = <str> ; private static final String PASSWD_OPTION = <str> ; private static final String THROTTLE_MBITS = <str> ; private static final String SSL_TRUSTSTORE = <str> ; private static final String SSL_TRUSTSTORE_PW = <str> ; private static final String SSL_KEYSTORE = <str> ; private static final String SSL_KEYSTORE_PW = <str> ; private static final String SSL_PROTOCOL = <str> ; private static final String SSL_ALGORITHM = <str> ; private static final String SSL_STORE_TYPE = <str> ; private static final String SSL_CIPHER_SUITES = <str> ; private static final String CONNECTIONS_PER_HOST = <str> ; private static final String CONFIG_PATH = <str> ; public static void main ( String args [ ] ) { Config . setClientMode ( true ) ; LoaderOptions options = LoaderOptions . parseArgs ( args ) ; OutputHandler handler = new OutputHandler . SystemOutput ( options . verbose , options . debug ) ; SSTableLoader loader = new SSTableLoader ( options . directory , new ExternalClient ( options . hosts , options . nativePort , options . user , options . passwd , options . storagePort , options . sslStoragePort , options . serverEncOptions , buildSSLOptions ( ( EncryptionOptions . ClientEncryptionOptions ) options . encOptions ) ) , handler , options . connectionsPerHost ) ; DatabaseDescriptor . setStreamThroughputOutboundMegabitsPerSec ( options . throttle ) ; StreamResultFuture future = null ; ProgressIndicator indicator = new ProgressIndicator ( ) ; try { if ( options . noProgress ) { future = loader . stream ( options . ignores ) ; } else { future = loader . stream ( options . ignores , indicator ) ; } } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; System . err . println ( e . getMessage ( ) ) ; if ( e . getCause ( ) ! = null ) System . err . println ( e . getCause ( ) ) ; e . printStackTrace ( System . err ) ; System . exit ( <int> ) ; } try { future . get ( ) ; if ( ! options . noProgress ) indicator . printSummary ( options . connectionsPerHost ) ; Thread . sleep ( <int> ) ; System . exit ( <int> ) ; } catch ( Exception e ) { System . err . println ( <str> ) ; System . err . println ( loader . getFailedHosts ( ) ) ; e . printStackTrace ( System . err ) ; System . exit ( <int> ) ; } } static class ProgressIndicator implements StreamEventHandler { private long start ; private long lastProgress ; private long lastTime ; private int peak = <int> ; private int totalFiles = <int> ; private final Multimap < InetAddress , SessionInfo > sessionsByHost = HashMultimap . create ( ) ; public ProgressIndicator ( ) { start = lastTime = System . nanoTime ( ) ; } public void onSuccess ( StreamState finalState ) { } public void onFailure ( Throwable t ) { } public synchronized void handleStreamEvent ( StreamEvent event ) { if ( event . eventType = = StreamEvent . Type . STREAM_PREPARED ) { SessionInfo session = ( ( StreamEvent . SessionPreparedEvent ) event ) . session ; sessionsByHost . put ( session . peer , session ) ; } else if ( event . eventType = = StreamEvent . Type . FILE_PROGRESS | | event . eventType = = StreamEvent . Type . STREAM_COMPLETE ) { ProgressInfo progressInfo = null ; if ( event . eventType = = StreamEvent . Type . FILE_PROGRESS ) { progressInfo = ( ( StreamEvent . ProgressEvent ) event ) . progress ; } long time = System . nanoTime ( ) ; long deltaTime = time - lastTime ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; long totalProgress = <int> ; long totalSize = <int> ; boolean updateTotalFiles = totalFiles = = <int> ; for ( InetAddress peer : sessionsByHost . keySet ( ) ) { sb . append ( <str> ) . append ( peer ) . append ( <str> ) ; for ( SessionInfo session : sessionsByHost . get ( peer ) ) { long size = session . getTotalSizeToSend ( ) ; long current = <int> ; int completed = <int> ; if ( progressInfo ! = null & & session . peer . equals ( progressInfo . peer ) & & ( session . sessionIndex = = progressInfo . sessionIndex ) ) { session . updateProgress ( progressInfo ) ; } for ( ProgressInfo progress : session . getSendingFiles ( ) ) { if ( progress . isCompleted ( ) ) completed + + ; current + = progress . currentBytes ; } totalProgress + = current ; totalSize + = size ; sb . append ( session . sessionIndex ) . append ( <str> ) ; sb . append ( completed ) . append ( <str> ) . append ( session . getTotalFilesToSend ( ) ) ; sb . append ( <str> ) . append ( String . format ( <str> , size = = <int> ? <int> : current * <int> / size ) ) . append ( <str> ) ; if ( updateTotalFiles ) totalFiles + = session . getTotalFilesToSend ( ) ; } } lastTime = time ; long deltaProgress = totalProgress - lastProgress ; lastProgress = totalProgress ; sb . append ( <str> ) . append ( totalSize = = <int> ? <int> : totalProgress * <int> / totalSize ) . append ( <str> ) ; sb . append ( String . format ( <str> , mbPerSec ( deltaProgress , deltaTime ) ) ) . append ( <str> ) ; int average = mbPerSec ( totalProgress , ( time - start ) ) ; if ( average > peak ) peak = average ; sb . append ( <str> ) . append ( average ) . append ( <str> ) ; System . out . print ( sb . toString ( ) ) ; } } private int mbPerSec ( long bytes , long timeInNano ) { double bytesPerNano = ( ( double ) bytes ) / timeInNano ; return ( int ) ( ( bytesPerNano * <int> * <int> * <int> ) / ( <int> * <int> ) ) ; } private void printSummary ( int connectionsPerHost ) { long end = System . nanoTime ( ) ; long durationMS = ( ( end - start ) / ( <int> ) ) ; int average = mbPerSec ( lastProgress , ( end - start ) ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; sb . append ( String . format ( <str> , <str> , connectionsPerHost ) ) ; sb . append ( String . format ( <str> , <str> , totalFiles ) ) ; sb . append ( String . format ( <str> , <str> , lastProgress ) ) ; sb . append ( String . format ( <str> , <str> , durationMS ) ) ; sb . append ( String . format ( <str> , <str> , + average ) ) ; sb . append ( String . format ( <str> , <str> , + peak ) ) ; System . out . println ( sb . toString ( ) ) ; } } private static SSLOptions buildSSLOptions ( EncryptionOptions . ClientEncryptionOptions clientEncryptionOptions ) { if ( ! clientEncryptionOptions . enabled ) return null ; SSLContext sslContext ; try { sslContext = SSLFactory . createSSLContext ( clientEncryptionOptions , true ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } return new SSLOptions ( sslContext , clientEncryptionOptions . cipher_suites ) ; } static class ExternalClient extends NativeSSTableLoaderClient { private final int storagePort ; private final int sslStoragePort ; private final EncryptionOptions . ServerEncryptionOptions serverEncOptions ; public ExternalClient ( Set < InetAddress > hosts , int port , String user , String passwd , int storagePort , int sslStoragePort , EncryptionOptions . ServerEncryptionOptions serverEncryptionOptions , SSLOptions sslOptions ) { super ( hosts , port , user , passwd , sslOptions ) ; this . storagePort = storagePort ; this . sslStoragePort = sslStoragePort ; this . serverEncOptions = serverEncryptionOptions ; } @Override public StreamConnectionFactory getConnectionFactory ( ) { return new BulkLoadConnectionFactory ( storagePort , sslStoragePort , serverEncOptions , false ) ; } } static class LoaderOptions { public final File directory ; public boolean debug ; public boolean verbose ; public boolean noProgress ; public int nativePort = <int> ; public String user ; public String passwd ; public int throttle = <int> ; public int storagePort ; public int sslStoragePort ; public EncryptionOptions encOptions = new EncryptionOptions . ClientEncryptionOptions ( ) ; public int connectionsPerHost = <int> ; public EncryptionOptions . ServerEncryptionOptions serverEncOptions = new EncryptionOptions . ServerEncryptionOptions ( ) ; public final Set < InetAddress > hosts = new HashSet < > ( ) ; public final Set < InetAddress > ignores = new HashSet < > ( ) ; LoaderOptions ( File directory ) { this . directory = directory ; } public static LoaderOptions parseArgs ( String cmdArgs [ ] ) { CommandLineParser parser = new GnuParser ( ) ; CmdLineOptions options = getCmdLineOptions ( ) ; try { CommandLine cmd = parser . parse ( options , cmdArgs , false ) ; if ( cmd . hasOption ( HELP_OPTION ) ) { printUsage ( options ) ; System . exit ( <int> ) ; } String [ ] args = cmd . getArgs ( ) ; if ( args . length = = <int> ) { System . err . println ( <str> ) ; printUsage ( options ) ; System . exit ( <int> ) ; } if ( args . length > <int> ) { System . err . println ( <str> ) ; printUsage ( options ) ; System . exit ( <int> ) ; } String dirname = args [ <int> ] ; File dir = new File ( dirname ) ; if ( ! dir . exists ( ) ) errorMsg ( <str> + dirname , options ) ; if ( ! dir . isDirectory ( ) ) errorMsg ( dirname + <str> , options ) ; LoaderOptions opts = new LoaderOptions ( dir ) ; opts . verbose = cmd . hasOption ( VERBOSE_OPTION ) ; opts . noProgress = cmd . hasOption ( NOPROGRESS_OPTION ) ; if ( cmd . hasOption ( NATIVE_PORT_OPTION ) ) opts . nativePort = Integer . parseInt ( cmd . getOptionValue ( NATIVE_PORT_OPTION ) ) ; if ( cmd . hasOption ( USER_OPTION ) ) opts . user = cmd . getOptionValue ( USER_OPTION ) ; if ( cmd . hasOption ( PASSWD_OPTION ) ) opts . passwd = cmd . getOptionValue ( PASSWD_OPTION ) ; if ( cmd . hasOption ( INITIAL_HOST_ADDRESS_OPTION ) ) { String [ ] nodes = cmd . getOptionValue ( INITIAL_HOST_ADDRESS_OPTION ) . split ( <str> ) ; try { for ( String node : nodes ) { opts . hosts . add ( InetAddress . getByName ( node . trim ( ) ) ) ; } } catch ( UnknownHostException e ) { errorMsg ( <str> + e . getMessage ( ) , options ) ; } } else { System . err . println ( <str> ) ; printUsage ( options ) ; System . exit ( <int> ) ; } if ( cmd . hasOption ( IGNORE_NODES_OPTION ) ) { String [ ] nodes = cmd . getOptionValue ( IGNORE_NODES_OPTION ) . split ( <str> ) ; try { for ( String node : nodes ) { opts . ignores . add ( InetAddress . getByName ( node . trim ( ) ) ) ; } } catch ( UnknownHostException e ) { errorMsg ( <str> + e . getMessage ( ) , options ) ; } } if ( cmd . hasOption ( CONNECTIONS_PER_HOST ) ) opts . connectionsPerHost = Integer . parseInt ( cmd . getOptionValue ( CONNECTIONS_PER_HOST ) ) ; Config config ; if ( cmd . hasOption ( CONFIG_PATH ) ) { File configFile = new File ( cmd . getOptionValue ( CONFIG_PATH ) ) ; if ( ! configFile . exists ( ) ) { errorMsg ( <str> , options ) ; } config = new YamlConfigurationLoader ( ) . loadConfig ( configFile . toURI ( ) . toURL ( ) ) ; } else { config = new Config ( ) ; } opts . storagePort = config . storage_port ; opts . sslStoragePort = config . ssl_storage_port ; opts . throttle = config . stream_throughput_outbound_megabits_per_sec ; opts . encOptions = config . client_encryption_options ; opts . serverEncOptions = config . server_encryption_options ; if ( cmd . hasOption ( THROTTLE_MBITS ) ) { opts . throttle = Integer . parseInt ( cmd . getOptionValue ( THROTTLE_MBITS ) ) ; } if ( cmd . hasOption ( SSL_TRUSTSTORE ) ) { opts . encOptions . truststore = cmd . getOptionValue ( SSL_TRUSTSTORE ) ; } if ( cmd . hasOption ( SSL_TRUSTSTORE_PW ) ) { opts . encOptions . truststore_password = cmd . getOptionValue ( SSL_TRUSTSTORE_PW ) ; } if ( cmd . hasOption ( SSL_KEYSTORE ) ) { opts . encOptions . keystore = cmd . getOptionValue ( SSL_KEYSTORE ) ; opts . encOptions . require_client_auth = true ; } if ( cmd . hasOption ( SSL_KEYSTORE_PW ) ) { opts . encOptions . keystore_password = cmd . getOptionValue ( SSL_KEYSTORE_PW ) ; } if ( cmd . hasOption ( SSL_PROTOCOL ) ) { opts . encOptions . protocol = cmd . getOptionValue ( SSL_PROTOCOL ) ; } if ( cmd . hasOption ( SSL_ALGORITHM ) ) { opts . encOptions . algorithm = cmd . getOptionValue ( SSL_ALGORITHM ) ; } if ( cmd . hasOption ( SSL_STORE_TYPE ) ) { opts . encOptions . store_type = cmd . getOptionValue ( SSL_STORE_TYPE ) ; } if ( cmd . hasOption ( SSL_CIPHER_SUITES ) ) { opts . encOptions . cipher_suites = cmd . getOptionValue ( SSL_CIPHER_SUITES ) . split ( <str> ) ; } return opts ; } catch ( ParseException | ConfigurationException | MalformedURLException e ) { errorMsg ( e . getMessage ( ) , options ) ; return null ; } } private static void errorMsg ( String msg , CmdLineOptions options ) { System . err . println ( msg ) ; printUsage ( options ) ; System . exit ( <int> ) ; } private static CmdLineOptions getCmdLineOptions ( ) { CmdLineOptions options = new CmdLineOptions ( ) ; options . addOption ( <str> , VERBOSE_OPTION , <str> ) ; options . addOption ( <str> , HELP_OPTION , <str> ) ; options . addOption ( null , NOPROGRESS_OPTION , <str> ) ; options . addOption ( <str> , IGNORE_NODES_OPTION , <str> , <str> ) ; options . addOption ( <str> , INITIAL_HOST_ADDRESS_OPTION , <str> , <str> ) ; options . addOption ( <str> , NATIVE_PORT_OPTION , <str> , <str> ) ; options . addOption ( <str> , THROTTLE_MBITS , <str> , <str> ) ; options . addOption ( <str> , USER_OPTION , <str> , <str> ) ; options . addOption ( <str> , PASSWD_OPTION , <str> , <str> ) ; options . addOption ( <str> , CONNECTIONS_PER_HOST , <str> , <str> ) ; options . addOption ( <str> , SSL_TRUSTSTORE , <str> , <str> ) ; options . addOption ( <str> , SSL_TRUSTSTORE_PW , <str> , <str> ) ; options . addOption ( <str> , SSL_KEYSTORE , <str> , <str> ) ; options . addOption ( <str> , SSL_KEYSTORE_PW , <str> , <str> ) ; options . addOption ( <str> , SSL_PROTOCOL , <str> , <str> ) ; options . addOption ( <str> , SSL_ALGORITHM , <str> , <str> ) ; options . addOption ( <str> , SSL_STORE_TYPE , <str> , <str> ) ; options . addOption ( <str> , SSL_CIPHER_SUITES , <str> , <str> ) ; options . addOption ( <str> , CONFIG_PATH , <str> , <str> ) ; return options ; } public static void printUsage ( Options options ) { String usage = String . format ( <str> , TOOL_NAME ) ; String header = System . lineSeparator ( ) + <str> + <str> + <str> + <str> ; String footer = System . lineSeparator ( ) + <str> + <str> + <str> ; new HelpFormatter ( ) . printHelp ( usage , header , options , footer ) ; } } public static class CmdLineOptions extends Options { public Options addOption ( String opt , String longOpt , String argName , String description ) { Option option = new Option ( opt , longOpt , true , description ) ; option . setArgName ( argName ) ; return addOption ( option ) ; } public Options addOption ( String opt , String longOpt , String description ) { return addOption ( new Option ( opt , longOpt , false , description ) ) ; } } } 
