package org . elasticsearch . search . aggregations . pipeline . movavg . models ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . search . SearchParseException ; import java . io . IOException ; import java . text . ParseException ; import java . util . Arrays ; import java . util . Collection ; import java . util . Map ; public abstract class MovAvgModel { public boolean minimizeByDefault ( ) { return false ; } public abstract boolean canBeMinimized ( ) ; public abstract MovAvgModel neighboringModel ( ) ; public boolean hasValue ( int valuesAvailable ) { return valuesAvailable > <int> ; } public abstract < T extends Number > double next ( Collection < T > values ) ; public < T extends Number > double [ ] predict ( Collection < T > values , int numPredictions ) { assert ( numPredictions > = <int> ) ; if ( values . isEmpty ( ) ) { return emptyPredictions ( numPredictions ) ; } return doPredict ( values , numPredictions ) ; } protected abstract < T extends Number > double [ ] doPredict ( Collection < T > values , int numPredictions ) ; protected double [ ] emptyPredictions ( int numPredictions ) { double [ ] predictions = new double [ numPredictions ] ; Arrays . fill ( predictions , Double . NaN ) ; return predictions ; } public abstract void writeTo ( StreamOutput out ) throws IOException ; public abstract MovAvgModel clone ( ) ; public abstract static class AbstractModelParser { public abstract String getName ( ) ; public abstract MovAvgModel parse ( @Nullable Map < String , Object > settings , String pipelineName , int windowSize , ParseFieldMatcher parseFieldMatcher ) throws ParseException ; protected double parseDoubleParam ( @Nullable Map < String , Object > settings , String name , double defaultValue ) throws ParseException { if ( settings = = null ) { return defaultValue ; } Object value = settings . get ( name ) ; if ( value = = null ) { return defaultValue ; } else if ( value instanceof Number ) { double v = ( ( Number ) value ) . doubleValue ( ) ; if ( v > = <int> & & v < = <int> ) { settings . remove ( name ) ; return v ; } throw new ParseException ( <str> + name + <str> + <str> + v + <str> , <int> ) ; } throw new ParseException ( <str> + name + <str> + value . getClass ( ) . getSimpleName ( ) + <str> , <int> ) ; } protected int parseIntegerParam ( @Nullable Map < String , Object > settings , String name , int defaultValue ) throws ParseException { if ( settings = = null ) { return defaultValue ; } Object value = settings . get ( name ) ; if ( value = = null ) { return defaultValue ; } else if ( value instanceof Number ) { settings . remove ( name ) ; return ( ( Number ) value ) . intValue ( ) ; } throw new ParseException ( <str> + name + <str> + value . getClass ( ) . getSimpleName ( ) + <str> , <int> ) ; } protected boolean parseBoolParam ( @Nullable Map < String , Object > settings , String name , boolean defaultValue ) throws ParseException { if ( settings = = null ) { return defaultValue ; } Object value = settings . get ( name ) ; if ( value = = null ) { return defaultValue ; } else if ( value instanceof Boolean ) { settings . remove ( name ) ; return ( Boolean ) value ; } throw new ParseException ( <str> + name + <str> + value . getClass ( ) . getSimpleName ( ) + <str> , <int> ) ; } protected void checkUnrecognizedParams ( @Nullable Map < String , Object > settings ) throws ParseException { if ( settings ! = null & & settings . size ( ) > <int> ) { throw new ParseException ( <str> + settings . keySet ( ) + <str> , <int> ) ; } } } } 
