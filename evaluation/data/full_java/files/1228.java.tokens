package org . apache . cassandra . utils ; import java . io . Closeable ; import java . util . * ; import org . apache . cassandra . utils . AbstractIterator ; public abstract class MergeIterator < In , Out > extends AbstractIterator < Out > implements IMergeIterator < In , Out > { protected final Reducer < In , Out > reducer ; protected final List < ? extends Iterator < In > > iterators ; protected MergeIterator ( List < ? extends Iterator < In > > iters , Reducer < In , Out > reducer ) { this . iterators = iters ; this . reducer = reducer ; } public static < In , Out > MergeIterator < In , Out > get ( List < ? extends Iterator < In > > sources , Comparator < ? super In > comparator , Reducer < In , Out > reducer ) { if ( sources . size ( ) = = <int> ) { return reducer . trivialReduceIsTrivial ( ) ? new TrivialOneToOne < > ( sources , reducer ) : new OneToOne < > ( sources , reducer ) ; } return new ManyToOne < > ( sources , comparator , reducer ) ; } public Iterable < ? extends Iterator < In > > iterators ( ) { return iterators ; } public void close ( ) { for ( Iterator < In > iterator : this . iterators ) { try { if ( iterator instanceof AutoCloseable ) ( ( AutoCloseable ) iterator ) . close ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } reducer . close ( ) ; } static final class ManyToOne < In , Out > extends MergeIterator < In , Out > { protected final Candidate < In > [ ] heap ; int size ; int needingAdvance ; static final int SORTED_SECTION_SIZE = <int> ; public ManyToOne ( List < ? extends Iterator < In > > iters , Comparator < ? super In > comp , Reducer < In , Out > reducer ) { super ( iters , reducer ) ; @SuppressWarnings ( <str> ) Candidate < In > [ ] heap = new Candidate [ iters . size ( ) ] ; this . heap = heap ; size = <int> ; for ( int i = <int> ; i < iters . size ( ) ; i + + ) { Candidate < In > candidate = new Candidate < > ( i , iters . get ( i ) , comp ) ; heap [ size + + ] = candidate ; } needingAdvance = size ; } protected final Out computeNext ( ) { advance ( ) ; return consume ( ) ; } private void advance ( ) { for ( int i = needingAdvance - <int> ; i > = <int> ; - - i ) { Candidate < In > candidate = heap [ i ] ; if ( candidate . needsAdvance ( ) ) replaceAndSink ( candidate . advance ( ) , i ) ; } } private Out consume ( ) { if ( size = = <int> ) return endOfData ( ) ; reducer . onKeyChange ( ) ; assert ! heap [ <int> ] . equalParent ; reducer . reduce ( heap [ <int> ] . idx , heap [ <int> ] . consume ( ) ) ; final int size = this . size ; final int sortedSectionSize = Math . min ( size , SORTED_SECTION_SIZE ) ; int i ; consume : { for ( i = <int> ; i < sortedSectionSize ; + + i ) { if ( ! heap [ i ] . equalParent ) break consume ; reducer . reduce ( heap [ i ] . idx , heap [ i ] . consume ( ) ) ; } i = Math . max ( i , consumeHeap ( i ) + <int> ) ; } needingAdvance = i ; return reducer . getReduced ( ) ; } private int consumeHeap ( int idx ) { if ( idx > = size | | ! heap [ idx ] . equalParent ) return - <int> ; reducer . reduce ( heap [ idx ] . idx , heap [ idx ] . consume ( ) ) ; int nextIdx = ( idx < < <int> ) - ( SORTED_SECTION_SIZE - <int> ) ; return Math . max ( idx , Math . max ( consumeHeap ( nextIdx ) , consumeHeap ( nextIdx + <int> ) ) ) ; } private void replaceAndSink ( Candidate < In > candidate , int currIdx ) { if ( candidate = = null ) { candidate = heap [ - - size ] ; heap [ size ] = null ; } candidate . equalParent = false ; final int size = this . size ; final int sortedSectionSize = Math . min ( size - <int> , SORTED_SECTION_SIZE ) ; int nextIdx ; while ( ( nextIdx = currIdx + <int> ) < = sortedSectionSize ) { if ( ! heap [ nextIdx ] . equalParent ) { int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; if ( cmp < = <int> ) { heap [ nextIdx ] . equalParent = cmp = = <int> ; heap [ currIdx ] = candidate ; return ; } } heap [ currIdx ] = heap [ nextIdx ] ; currIdx = nextIdx ; } while ( ( nextIdx = ( currIdx * <int> ) - ( sortedSectionSize - <int> ) ) + <int> < size ) { if ( ! heap [ nextIdx ] . equalParent ) { if ( ! heap [ nextIdx + <int> ] . equalParent ) { int siblingCmp = heap [ nextIdx + <int> ] . compareTo ( heap [ nextIdx ] ) ; if ( siblingCmp < <int> ) + + nextIdx ; int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; if ( cmp < = <int> ) { if ( cmp = = <int> ) { heap [ nextIdx ] . equalParent = true ; if ( siblingCmp = = <int> ) heap [ nextIdx + <int> ] . equalParent = true ; } heap [ currIdx ] = candidate ; return ; } if ( siblingCmp = = <int> ) { heap [ nextIdx + <int> ] . equalParent = true ; } } else + + nextIdx ; } heap [ currIdx ] = heap [ nextIdx ] ; currIdx = nextIdx ; } if ( nextIdx > = size ) { heap [ currIdx ] = candidate ; return ; } if ( ! heap [ nextIdx ] . equalParent ) { int cmp = candidate . compareTo ( heap [ nextIdx ] ) ; if ( cmp < = <int> ) { heap [ nextIdx ] . equalParent = cmp = = <int> ; heap [ currIdx ] = candidate ; return ; } } heap [ currIdx ] = heap [ nextIdx ] ; heap [ nextIdx ] = candidate ; } } protected static final class Candidate < In > implements Comparable < Candidate < In > > { private final Iterator < ? extends In > iter ; private final Comparator < ? super In > comp ; private final int idx ; private In item ; boolean equalParent ; public Candidate ( int idx , Iterator < ? extends In > iter , Comparator < ? super In > comp ) { this . iter = iter ; this . comp = comp ; this . idx = idx ; } protected Candidate < In > advance ( ) { if ( ! iter . hasNext ( ) ) return null ; item = iter . next ( ) ; return this ; } public int compareTo ( Candidate < In > that ) { assert item ! = null & & that . item ! = null ; return comp . compare ( this . item , that . item ) ; } public In consume ( ) { In temp = item ; item = null ; assert temp ! = null ; return temp ; } public boolean needsAdvance ( ) { return item = = null ; } } public static abstract class Reducer < In , Out > { public boolean trivialReduceIsTrivial ( ) { return false ; } public abstract void reduce ( int idx , In current ) ; protected abstract Out getReduced ( ) ; protected void onKeyChange ( ) { } public void close ( ) { } } private static class OneToOne < In , Out > extends MergeIterator < In , Out > { private final Iterator < In > source ; public OneToOne ( List < ? extends Iterator < In > > sources , Reducer < In , Out > reducer ) { super ( sources , reducer ) ; source = sources . get ( <int> ) ; } protected Out computeNext ( ) { if ( ! source . hasNext ( ) ) return endOfData ( ) ; reducer . onKeyChange ( ) ; reducer . reduce ( <int> , source . next ( ) ) ; return reducer . getReduced ( ) ; } } private static class TrivialOneToOne < In , Out > extends MergeIterator < In , Out > { private final Iterator < In > source ; public TrivialOneToOne ( List < ? extends Iterator < In > > sources , Reducer < In , Out > reducer ) { super ( sources , reducer ) ; source = sources . get ( <int> ) ; } @SuppressWarnings ( <str> ) protected Out computeNext ( ) { if ( ! source . hasNext ( ) ) return endOfData ( ) ; return ( Out ) source . next ( ) ; } } } 
