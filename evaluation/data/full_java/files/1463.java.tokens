package org . apache . cassandra . db ; import java . io . * ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . ExecutionException ; import org . apache . commons . lang3 . StringUtils ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . apache . cassandra . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . db . compaction . Scrubber ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . db . marshal . LongType ; import org . apache . cassandra . db . marshal . UUIDType ; import org . apache . cassandra . db . partitions . Partition ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . db . rows . EncodingStats ; import org . apache . cassandra . dht . ByteOrderedPartitioner ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . exceptions . WriteTimeoutException ; import org . apache . cassandra . io . compress . CompressionMetadata ; import org . apache . cassandra . io . sstable . * ; import org . apache . cassandra . io . sstable . format . SSTableFormat ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . format . SSTableWriter ; import org . apache . cassandra . io . sstable . format . big . BigTableWriter ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . junit . Assume . assumeTrue ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class ScrubTest { public static final String KEYSPACE = <str> ; public static final String CF = <str> ; public static final String CF2 = <str> ; public static final String CF3 = <str> ; public static final String COUNTER_CF = <str> ; public static final String CF_UUID = <str> ; public static final String CF_INDEX1 = <str> ; public static final String CF_INDEX2 = <str> ; public static final String CF_INDEX1_BYTEORDERED = <str> ; public static final String CF_INDEX2_BYTEORDERED = <str> ; public static final String COL_INDEX = <str> ; public static final String COL_NON_INDEX = <str> ; public static final Integer COMPRESSION_CHUNK_LENGTH = <int> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . loadSchema ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE , CF ) , SchemaLoader . standardCFMD ( KEYSPACE , CF2 ) , SchemaLoader . standardCFMD ( KEYSPACE , CF3 ) , SchemaLoader . counterCFMD ( KEYSPACE , COUNTER_CF ) . compression ( SchemaLoader . getCompressionParameters ( COMPRESSION_CHUNK_LENGTH ) ) , SchemaLoader . standardCFMD ( KEYSPACE , CF_UUID , <int> , UUIDType . instance ) , SchemaLoader . keysIndexCFMD ( KEYSPACE , CF_INDEX1 , true ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE , CF_INDEX2 , true ) , SchemaLoader . keysIndexCFMD ( KEYSPACE , CF_INDEX1_BYTEORDERED , true ) . copy ( ByteOrderedPartitioner . instance ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE , CF_INDEX2_BYTEORDERED , true ) . copy ( ByteOrderedPartitioner . instance ) ) ; } @Test public void testScrubOneRow ( ) throws ExecutionException , InterruptedException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; cfs . clearUnsafe ( ) ; fillCF ( cfs , <int> ) ; assertOrderedAll ( cfs , <int> ) ; CompactionManager . instance . performScrub ( cfs , false , true ) ; assertOrderedAll ( cfs , <int> ) ; } @Test public void testScrubCorruptedCounterRow ( ) throws IOException , WriteTimeoutException { int numPartitions = <int> ; CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( COUNTER_CF ) ; cfs . clearUnsafe ( ) ; fillCounterCF ( cfs , numPartitions ) ; assertOrderedAll ( cfs , numPartitions ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; overrideWithGarbage ( sstable , ByteBufferUtil . bytes ( <str> ) , ByteBufferUtil . bytes ( <str> ) ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( Arrays . asList ( sstable ) , OperationType . SCRUB ) ; Scrubber scrubber = new Scrubber ( cfs , txn , false , false , true ) ) { scrubber . scrub ( ) ; fail ( <str> ) ; } catch ( IOError err ) { } Scrubber . ScrubResult scrubResult ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( Arrays . asList ( sstable ) , OperationType . SCRUB ) ; Scrubber scrubber = new Scrubber ( cfs , txn , true , false , true ) ) { scrubResult = scrubber . scrubWithResult ( ) ; } assertNotNull ( scrubResult ) ; boolean compression = Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ; if ( compression ) { assertEquals ( <int> , scrubResult . emptyRows ) ; assertEquals ( numPartitions , scrubResult . badRows + scrubResult . goodRows ) ; assertTrue ( scrubResult . goodRows > = scrubResult . badRows * <int> ) ; } else { assertEquals ( <int> , scrubResult . emptyRows ) ; assertEquals ( <int> , scrubResult . badRows ) ; assertEquals ( numPartitions - <int> , scrubResult . goodRows ) ; } assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; assertOrderedAll ( cfs , scrubResult . goodRows ) ; } @Test public void testScrubCorruptedRowInSmallFile ( ) throws IOException , WriteTimeoutException { assumeTrue ( ! Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ) ; CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( COUNTER_CF ) ; cfs . clearUnsafe ( ) ; fillCounterCF ( cfs , <int> ) ; assertOrderedAll ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; overrideWithGarbage ( sstable , ByteBufferUtil . bytes ( <str> ) , ByteBufferUtil . bytes ( <str> ) ) ; try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( Arrays . asList ( sstable ) , OperationType . SCRUB ) ; Scrubber scrubber = new Scrubber ( cfs , txn , false , false , true ) ) { scrubber . scrub ( ) ; fail ( <str> ) ; } catch ( IOError err ) { } try ( LifecycleTransaction txn = cfs . getTracker ( ) . tryModify ( Arrays . asList ( sstable ) , OperationType . SCRUB ) ; Scrubber scrubber = new Scrubber ( cfs , txn , true , false , true ) ) { scrubber . scrub ( ) ; scrubber . close ( ) ; } assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; assertOrderedAll ( cfs , <int> ) ; } @Test public void testScrubOneRowWithCorruptedKey ( ) throws IOException , ExecutionException , InterruptedException , ConfigurationException { assumeTrue ( ! Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ) ; CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; cfs . clearUnsafe ( ) ; fillCF ( cfs , <int> ) ; assertOrderedAll ( cfs , <int> ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; overrideWithGarbage ( sstable , <int> , <int> ) ; CompactionManager . instance . performScrub ( cfs , false , true ) ; assertOrderedAll ( cfs , <int> ) ; } @Test public void testScrubCorruptedCounterRowNoEarlyOpen ( ) throws IOException , WriteTimeoutException { boolean oldDisabledVal = SSTableRewriter . disableEarlyOpeningForTests ; try { SSTableRewriter . disableEarlyOpeningForTests = true ; testScrubCorruptedCounterRow ( ) ; } finally { SSTableRewriter . disableEarlyOpeningForTests = oldDisabledVal ; } } @Test public void testScrubMultiRow ( ) throws ExecutionException , InterruptedException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; cfs . clearUnsafe ( ) ; fillCF ( cfs , <int> ) ; assertOrderedAll ( cfs , <int> ) ; CompactionManager . instance . performScrub ( cfs , false , true ) ; assertOrderedAll ( cfs , <int> ) ; } @Test public void testScrubNoIndex ( ) throws IOException , ExecutionException , InterruptedException , ConfigurationException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF ) ; cfs . clearUnsafe ( ) ; fillCF ( cfs , <int> ) ; assertOrderedAll ( cfs , <int> ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) new File ( sstable . descriptor . filenameFor ( Component . PRIMARY_INDEX ) ) . delete ( ) ; CompactionManager . instance . performScrub ( cfs , false , true , true ) ; assertOrderedAll ( cfs , <int> ) ; } @Test public void testScrubOutOfOrder ( ) throws Exception { IPartitioner oldPartitioner = DatabaseDescriptor . getPartitioner ( ) ; DatabaseDescriptor . setPartitionerUnsafe ( new ByteOrderedPartitioner ( ) ) ; File tempDir = File . createTempFile ( <str> , <str> ) . getParentFile ( ) ; File tempDataDir = new File ( tempDir , String . join ( File . separator , KEYSPACE , CF3 ) ) ; tempDataDir . mkdirs ( ) ; try { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; String columnFamily = CF3 ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( columnFamily ) ; cfs . clearUnsafe ( ) ; List < String > keys = Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; String filename = cfs . getSSTablePath ( tempDataDir ) ; Descriptor desc = Descriptor . fromFilename ( filename ) ; LifecycleTransaction txn = LifecycleTransaction . offline ( OperationType . WRITE ) ; try ( SSTableTxnWriter writer = new SSTableTxnWriter ( txn , createTestWriter ( desc , ( long ) keys . size ( ) , cfs . metadata , txn ) ) ) { for ( String k : keys ) { PartitionUpdate update = UpdateBuilder . create ( cfs . metadata , Util . dk ( k ) ) . newRow ( <str> ) . add ( <str> , <str> ) . build ( ) ; writer . append ( update . unfilteredIterator ( ) ) ; } writer . finish ( false ) ; } try { SSTableReader . open ( desc , cfs . metadata ) ; fail ( <str> ) ; } catch ( IllegalStateException ise ) { } Set < Component > components = new HashSet < > ( ) ; if ( new File ( desc . filenameFor ( Component . COMPRESSION_INFO ) ) . exists ( ) ) components . add ( Component . COMPRESSION_INFO ) ; components . add ( Component . DATA ) ; components . add ( Component . PRIMARY_INDEX ) ; components . add ( Component . FILTER ) ; components . add ( Component . STATS ) ; components . add ( Component . SUMMARY ) ; components . add ( Component . TOC ) ; SSTableReader sstable = SSTableReader . openNoValidation ( desc , components , cfs ) ; if ( sstable . last . compareTo ( sstable . first ) < <int> ) sstable . last = sstable . first ; try ( LifecycleTransaction scrubTxn = LifecycleTransaction . offline ( OperationType . SCRUB , sstable ) ; Scrubber scrubber = new Scrubber ( cfs , scrubTxn , false , true , true ) ) { scrubber . scrub ( ) ; } LifecycleTransaction . waitForDeletions ( ) ; cfs . loadNewSSTables ( ) ; assertOrderedAll ( cfs , <int> ) ; } finally { FileUtils . deleteRecursive ( tempDataDir ) ; DatabaseDescriptor . setPartitionerUnsafe ( oldPartitioner ) ; } } private void overrideWithGarbage ( SSTableReader sstable , ByteBuffer key1 , ByteBuffer key2 ) throws IOException { boolean compression = Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ; long startPosition , endPosition ; if ( compression ) { CompressionMetadata compData = CompressionMetadata . create ( sstable . getFilename ( ) ) ; CompressionMetadata . Chunk chunk1 = compData . chunkFor ( sstable . getPosition ( PartitionPosition . ForKey . get ( key1 , sstable . getPartitioner ( ) ) , SSTableReader . Operator . EQ ) . position ) ; CompressionMetadata . Chunk chunk2 = compData . chunkFor ( sstable . getPosition ( PartitionPosition . ForKey . get ( key2 , sstable . getPartitioner ( ) ) , SSTableReader . Operator . EQ ) . position ) ; startPosition = Math . min ( chunk1 . offset , chunk2 . offset ) ; endPosition = Math . max ( chunk1 . offset + chunk1 . length , chunk2 . offset + chunk2 . length ) ; compData . close ( ) ; } else { long row0Start = sstable . getPosition ( PartitionPosition . ForKey . get ( key1 , sstable . getPartitioner ( ) ) , SSTableReader . Operator . EQ ) . position ; long row1Start = sstable . getPosition ( PartitionPosition . ForKey . get ( key2 , sstable . getPartitioner ( ) ) , SSTableReader . Operator . EQ ) . position ; startPosition = Math . min ( row0Start , row1Start ) ; endPosition = Math . max ( row0Start , row1Start ) ; } overrideWithGarbage ( sstable , startPosition , endPosition ) ; } private void overrideWithGarbage ( SSTableReader sstable , long startPosition , long endPosition ) throws IOException { RandomAccessFile file = new RandomAccessFile ( sstable . getFilename ( ) , <str> ) ; file . seek ( startPosition ) ; file . writeBytes ( StringUtils . repeat ( <str> , ( int ) ( endPosition - startPosition ) ) ) ; file . close ( ) ; } private static void assertOrderedAll ( ColumnFamilyStore cfs , int expectedSize ) { assertOrdered ( Util . cmd ( cfs ) . build ( ) , expectedSize ) ; } private static void assertOrdered ( ReadCommand cmd , int expectedSize ) { int size = <int> ; DecoratedKey prev = null ; for ( Partition partition : Util . getAllUnfiltered ( cmd ) ) { DecoratedKey current = partition . partitionKey ( ) ; assertTrue ( <str> + current + <str> + prev , prev = = null | | prev . compareTo ( current ) < <int> ) ; prev = current ; + + size ; } assertEquals ( expectedSize , size ) ; } protected void fillCF ( ColumnFamilyStore cfs , int partitionsPerSSTable ) { for ( int i = <int> ; i < partitionsPerSSTable ; i + + ) { PartitionUpdate update = UpdateBuilder . create ( cfs . metadata , String . valueOf ( i ) ) . newRow ( <str> ) . add ( <str> , <str> ) . newRow ( <str> ) . add ( <str> , <str> ) . build ( ) ; new Mutation ( update ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; } public static void fillIndexCF ( ColumnFamilyStore cfs , boolean composite , long . . . values ) { assertTrue ( values . length % <int> = = <int> ) ; for ( int i = <int> ; i < values . length ; i + = <int> ) { UpdateBuilder builder = UpdateBuilder . create ( cfs . metadata , String . valueOf ( i ) ) ; if ( composite ) { builder . newRow ( <str> + i ) . add ( COL_INDEX , values [ i ] ) . add ( COL_NON_INDEX , values [ i + <int> ] ) ; } else { builder . newRow ( ) . add ( COL_INDEX , values [ i ] ) . add ( COL_NON_INDEX , values [ i + <int> ] ) ; } new Mutation ( builder . build ( ) ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; } protected void fillCounterCF ( ColumnFamilyStore cfs , int partitionsPerSSTable ) throws WriteTimeoutException { for ( int i = <int> ; i < partitionsPerSSTable ; i + + ) { PartitionUpdate update = UpdateBuilder . create ( cfs . metadata , String . valueOf ( i ) ) . newRow ( <str> ) . add ( <str> , <int> ) . build ( ) ; new CounterMutation ( new Mutation ( update ) , ConsistencyLevel . ONE ) . apply ( ) ; } cfs . forceBlockingFlush ( ) ; } @Test public void testScrubColumnValidation ( ) throws InterruptedException , RequestExecutionException , ExecutionException { QueryProcessor . process ( String . format ( <str> , KEYSPACE ) , ConsistencyLevel . ONE ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( <str> ) ; QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE ) ) ; cfs . forceBlockingFlush ( ) ; CompactionManager . instance . performScrub ( cfs , false , true ) ; QueryProcessor . process ( <str> , ConsistencyLevel . ONE ) ; ColumnFamilyStore cfs2 = keyspace . getColumnFamilyStore ( <str> ) ; new Mutation ( UpdateBuilder . create ( cfs2 . metadata , <str> ) . newRow ( ) . add ( <str> , LongType . instance . decompose ( <int> ) ) . build ( ) ) . apply ( ) ; cfs2 . forceBlockingFlush ( ) ; CompactionManager . instance . performScrub ( cfs2 , false , false ) ; } @Test public void testValidationCompactStorage ( ) throws Exception { QueryProcessor . process ( String . format ( <str> , KEYSPACE ) , ConsistencyLevel . ONE ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( <str> ) ; QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE ) ) ; cfs . forceBlockingFlush ( ) ; CompactionManager . instance . performScrub ( cfs , true , true ) ; UntypedResultSet rs = QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE ) ) ; assertEquals ( <int> , rs . size ( ) ) ; Iterator < UntypedResultSet . Row > iter = rs . iterator ( ) ; assertEquals ( <str> , iter . next ( ) . getString ( <str> ) ) ; assertEquals ( <str> , iter . next ( ) . getString ( <str> ) ) ; assertEquals ( <str> , iter . next ( ) . getString ( <str> ) ) ; } @Test public void testScrubKeysIndex_preserveOrder ( ) throws IOException , ExecutionException , InterruptedException { testScrubIndex ( CF_INDEX1_BYTEORDERED , COL_INDEX , false , true ) ; } @Test public void testScrubCompositeIndex_preserveOrder ( ) throws IOException , ExecutionException , InterruptedException { testScrubIndex ( CF_INDEX2_BYTEORDERED , COL_INDEX , true , true ) ; } @Test public void testScrubKeysIndex ( ) throws IOException , ExecutionException , InterruptedException { testScrubIndex ( CF_INDEX1 , COL_INDEX , false , true ) ; } @Test public void testScrubCompositeIndex ( ) throws IOException , ExecutionException , InterruptedException { testScrubIndex ( CF_INDEX2 , COL_INDEX , true , true ) ; } @Test public void testFailScrubKeysIndex ( ) throws IOException , ExecutionException , InterruptedException { testScrubIndex ( CF_INDEX1 , COL_INDEX , false , false ) ; } @Test public void testFailScrubCompositeIndex ( ) throws IOException , ExecutionException , InterruptedException { testScrubIndex ( CF_INDEX2 , COL_INDEX , true , false ) ; } @Test public void testScrubTwice ( ) throws IOException , ExecutionException , InterruptedException { testScrubIndex ( CF_INDEX1 , COL_INDEX , false , true , true ) ; } private void testScrubIndex ( String cfName , String colName , boolean composite , boolean . . . scrubs ) throws IOException , ExecutionException , InterruptedException { CompactionManager . instance . disableAutoCompaction ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; cfs . clearUnsafe ( ) ; int numRows = <int> ; long [ ] colValues = new long [ numRows * <int> ] ; for ( int i = <int> ; i < colValues . length ; i + = <int> ) { colValues [ i ] = ( i % <int> = = <int> ? <int> : <int> ) ; colValues [ i + <int> ] = <int> ; } fillIndexCF ( cfs , composite , colValues ) ; assertOrdered ( Util . cmd ( cfs ) . filterOn ( colName , Operator . EQ , <int> ) . build ( ) , numRows / <int> ) ; Set < ColumnFamilyStore > indexCfss = cfs . indexManager . getAllIndexColumnFamilyStores ( ) ; assertTrue ( indexCfss . size ( ) = = <int> ) ; for ( ColumnFamilyStore indexCfs : indexCfss ) { for ( int i = <int> ; i < scrubs . length ; i + + ) { boolean failure = ! scrubs [ i ] ; if ( failure ) { overrideWithGarbage ( indexCfs . getLiveSSTables ( ) . iterator ( ) . next ( ) , ByteBufferUtil . bytes ( <int> ) , ByteBufferUtil . bytes ( <int> ) ) ; } CompactionManager . AllSSTableOpStatus result = indexCfs . scrub ( false , false , true , true ) ; assertEquals ( failure ? CompactionManager . AllSSTableOpStatus . ABORTED : CompactionManager . AllSSTableOpStatus . SUCCESSFUL , result ) ; } } assertOrdered ( Util . cmd ( cfs ) . filterOn ( colName , Operator . EQ , <int> ) . build ( ) , numRows / <int> ) ; } private static SSTableMultiWriter createTestWriter ( Descriptor descriptor , long keyCount , CFMetaData metadata , LifecycleTransaction txn ) { SerializationHeader header = new SerializationHeader ( true , metadata , metadata . partitionColumns ( ) , EncodingStats . NO_STATS ) ; MetadataCollector collector = new MetadataCollector ( metadata . comparator ) . sstableLevel ( <int> ) ; return new TestMultiWriter ( new TestWriter ( descriptor , keyCount , <int> , metadata , collector , header , txn ) ) ; } private static class TestMultiWriter extends SimpleSSTableMultiWriter { TestMultiWriter ( SSTableWriter writer ) { super ( writer ) ; } } private static class TestWriter extends BigTableWriter { TestWriter ( Descriptor descriptor , long keyCount , long repairedAt , CFMetaData metadata , MetadataCollector collector , SerializationHeader header , LifecycleTransaction txn ) { super ( descriptor , keyCount , repairedAt , metadata , collector , header , Collections . emptySet ( ) , txn ) ; } @Override protected long beforeAppend ( DecoratedKey decoratedKey ) { return dataFile . position ( ) ; } } } 
