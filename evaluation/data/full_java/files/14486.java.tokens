package org . gradle . model . dsl . internal ; import groovy . lang . Closure ; import groovy . lang . GroovyObjectSupport ; import groovy . lang . MissingMethodException ; import groovy . lang . MissingPropertyException ; import net . jcip . annotations . NotThreadSafe ; import org . gradle . api . Action ; import org . gradle . api . GradleException ; import org . gradle . api . internal . ClosureBackedAction ; import org . gradle . internal . Actions ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . core . rule . describe . ModelRuleDescriptor ; import org . gradle . model . internal . core . rule . describe . SimpleModelRuleDescriptor ; import org . gradle . model . internal . registry . ModelRegistry ; import org . gradle . model . internal . type . ModelType ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . gradle . model . internal . core . DefaultNodeInitializerRegistry . DEFAULT_REFERENCE ; import static org . gradle . model . internal . core . NodeInitializerContext . forType ; @NotThreadSafe public class NonTransformedModelDslBacking extends GroovyObjectSupport { public static final String ATTEMPTED_INPUT_SYNTAX_USED_MESSAGE = <str> ; private final ModelPath modelPath ; private final ModelRegistry modelRegistry ; private AtomicBoolean executingDsl ; public NonTransformedModelDslBacking ( ModelRegistry modelRegistry ) { this ( new AtomicBoolean ( ) , null , modelRegistry ) ; } private NonTransformedModelDslBacking ( AtomicBoolean executingDsl , ModelPath modelPath , ModelRegistry modelRegistry ) { this . executingDsl = executingDsl ; this . modelPath = modelPath ; this . modelRegistry = modelRegistry ; } private NonTransformedModelDslBacking getChildPath ( String name ) { ModelPath path = modelPath = = null ? ModelPath . path ( name ) : modelPath . child ( name ) ; return new NonTransformedModelDslBacking ( executingDsl , path , modelRegistry ) ; } private void registerConfigurationAction ( final Closure < ? > action ) { modelRegistry . configure ( ModelActionRole . Mutate , new NoInputsModelAction < Object > ( ModelReference . untyped ( modelPath ) , new SimpleModelRuleDescriptor ( <str> + modelPath ) , new ClosureBackedAction < Object > ( action ) ) ) ; } private < T > void register ( Class < T > type , Closure < ? > closure ) { register ( type , new ClosureBackedAction < T > ( closure ) ) ; } private < T > void register ( Class < T > type , Action < ? super T > action ) { ModelRuleDescriptor descriptor = new SimpleModelRuleDescriptor ( <str> + modelPath ) ; NodeInitializerRegistry nodeInitializerRegistry = modelRegistry . realize ( DEFAULT_REFERENCE . getPath ( ) , DEFAULT_REFERENCE . getType ( ) ) ; ModelType < T > modelType = ModelType . of ( type ) ; NodeInitializer nodeInitializer = nodeInitializerRegistry . getNodeInitializer ( forType ( modelType ) ) ; modelRegistry . register ( ModelRegistrations . of ( modelPath , nodeInitializer ) . descriptor ( descriptor ) . action ( ModelActionRole . Initialize , NoInputsModelAction . of ( ModelReference . of ( modelPath , modelType ) , descriptor , action ) ) . build ( ) ) ; } public void configure ( Closure < ? > action ) { executingDsl . set ( true ) ; try { new ClosureBackedAction < Object > ( action ) . execute ( this ) ; } finally { executingDsl . set ( false ) ; } } public NonTransformedModelDslBacking propertyMissing ( String name ) { if ( ! executingDsl . get ( ) ) { throw new MissingPropertyException ( name , getClass ( ) ) ; } return getChildPath ( name ) ; } public Void methodMissing ( String name , Object argsObj ) { Object [ ] args = ( Object [ ] ) argsObj ; if ( ! executingDsl . get ( ) ) { if ( name . equals ( <str> ) ) { throw new GradleException ( ATTEMPTED_INPUT_SYNTAX_USED_MESSAGE ) ; } else { throw new MissingMethodException ( name , getClass ( ) , args ) ; } } else { if ( args . length = = <int> & & args [ <int> ] instanceof Closure ) { Closure < ? > closure = ( Closure ) args [ <int> ] ; getChildPath ( name ) . registerConfigurationAction ( closure ) ; return null ; } else if ( args . length = = <int> & & args [ <int> ] instanceof Class & & args [ <int> ] instanceof Closure ) { Class < ? > clazz = ( Class < ? > ) args [ <int> ] ; Closure < ? > closure = ( Closure < ? > ) args [ <int> ] ; getChildPath ( name ) . register ( clazz , closure ) ; return null ; } else if ( args . length = = <int> & & args [ <int> ] instanceof Class ) { Class < ? > clazz = ( Class < ? > ) args [ <int> ] ; getChildPath ( name ) . register ( clazz , Actions . doNothing ( ) ) ; return null ; } else { throw new MissingMethodException ( name , getClass ( ) , args ) ; } } } } 
