package org . nd4j . linalg . jcublas . context ; import com . google . common . collect . HashBasedTable ; import com . google . common . collect . Table ; import jcuda . CudaException ; import jcuda . Pointer ; import jcuda . driver . * ; import jcuda . jcublas . JCublas2 ; import jcuda . jcublas . cublasHandle ; import jcuda . runtime . JCuda ; import jcuda . runtime . cudaDeviceProp ; import jcuda . runtime . cudaStream_t ; import lombok . Data ; import org . apache . commons . pool2 . impl . GenericObjectPoolConfig ; import org . nd4j . linalg . api . ops . Accumulation ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . api . ops . TransformOp ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . jcublas . buffer . allocation . MemoryStrategy ; import org . nd4j . linalg . jcublas . context . pool . CublasHandlePool ; import org . nd4j . linalg . jcublas . context . pool . OldStreamPool ; import org . nd4j . linalg . jcublas . context . pool . StreamPool ; import org . nd4j . linalg . jcublas . context . pool . factory . CublasHandlePooledItemFactory ; import org . nd4j . linalg . jcublas . context . pool . factory . OldStreamItemFactory ; import org . nd4j . linalg . jcublas . context . pool . factory . StreamItemFactory ; import org . nd4j . linalg . jcublas . device . conf . DeviceConfiguration ; import org . nd4j . linalg . jcublas . kernel . KernelFunctionLoader ; import org . nd4j . linalg . jcublas . util . PointerUtil ; import org . nd4j . linalg . util . SynchronizedTable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . nd4j . linalg . io . ClassPathResource ; import org . apache . commons . pool2 . ObjectPool ; import java . io . IOException ; import java . io . InputStream ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicBoolean ; import static jcuda . driver . JCudaDriver . * ; @Data public class ContextHolder { private Map < Integer , CUdevice > devices = new ConcurrentHashMap < > ( ) ; private Map < Integer , GpuInformation > info = new ConcurrentHashMap < > ( ) ; private Table < Integer , String , CUcontext > deviceIDContexts = HashBasedTable . create ( ) ; private Map < String , Integer > threadNameToDeviceNumber = new ConcurrentHashMap < > ( ) ; private Table < CUcontext , String , CUstream > contextStreams = HashBasedTable . create ( ) ; private Table < CUcontext , String , cudaStream_t > cudaStreams = HashBasedTable . create ( ) ; private Map < String , cublasHandle > handleMap = new ConcurrentHashMap < > ( ) ; private Map < String , Integer > threads = new ConcurrentHashMap < > ( ) ; private List < Integer > bannedDevices ; private int numDevices = <int> ; private Map < Integer , DeviceConfiguration > confs = new ConcurrentHashMap < > ( ) ; private ObjectPool < cublasHandle > handlePool ; private ObjectPool < CUstream > streamPool ; private ObjectPool < cudaStream_t > oldStreamPool ; private static ContextHolder INSTANCE ; public final static String DEVICES_TO_BAN = <str> ; private static AtomicBoolean deviceSetup = new AtomicBoolean ( false ) ; private boolean confCalled = false ; private static Logger log = LoggerFactory . getLogger ( ContextHolder . class ) ; private AtomicBoolean shutdown = new AtomicBoolean ( false ) ; public static synchronized ContextHolder getInstance ( ) { if ( INSTANCE = = null ) { Properties props = new Properties ( ) ; try { props . load ( new ClassPathResource ( <str> , ContextHolder . class . getClassLoader ( ) ) . getInputStream ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } INSTANCE = new ContextHolder ( ) ; INSTANCE . configure ( ) ; for ( String pair : props . stringPropertyNames ( ) ) System . getProperties ( ) . put ( pair , props . getProperty ( pair ) ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( new Runnable ( ) { @Override public void run ( ) { INSTANCE . destroy ( ) ; } } ) ) ; } return INSTANCE ; } public ObjectPool < cublasHandle > getHandlePool ( ) { return handlePool ; } public ObjectPool < CUstream > getStreamPool ( ) { return streamPool ; } public ObjectPool < cudaStream_t > getOldStreamPool ( ) { return oldStreamPool ; } public int getNumThreads ( Op op ) { String functionName = op instanceof TransformOp | | op instanceof Accumulation ? op . name ( ) + <str> : op . name ( ) ; Integer threadsForFunction = ContextHolder . getInstance ( ) . getThreads ( ) . get ( functionName ) ; int maxThreads = ContextHolder . getInstance ( ) . getInfoFor ( ContextHolder . getInstance ( ) . getDeviceForThread ( ) ) . getMaxThreadsPerBlock ( ) ; if ( threadsForFunction = = null ) return PointerUtil . getNumThreads ( op . n ( ) , maxThreads ) ; return threadsForFunction ; } public Map < String , Integer > getThreads ( ) { return threads ; } public int deviceNum ( ) { return numDevices ; } public DeviceConfiguration getConf ( ) { return getConf ( getDeviceForThread ( ) ) ; } public MemoryStrategy getMemoryStrategy ( ) { return getConf ( ) . getMemoryStrategy ( ) ; } public void configure ( ) { if ( confCalled ) return ; JCublas2 . setExceptionsEnabled ( true ) ; JCudaDriver . setExceptionsEnabled ( true ) ; JCuda . setExceptionsEnabled ( true ) ; if ( deviceSetup . get ( ) ) return ; JCudaDriver . cuInit ( <int> ) ; int count [ ] = new int [ <int> ] ; cuDeviceGetCount ( count ) ; numDevices = count [ <int> ] ; log . debug ( <str> + numDevices + <str> ) ; if ( numDevices < <int> ) numDevices = <int> ; bannedDevices = new ArrayList < > ( ) ; String props = System . getProperty ( DEVICES_TO_BAN , <str> ) ; String [ ] split = props . split ( <str> ) ; if ( split . length > = <int> ) for ( String s : split ) { Integer i = Integer . parseInt ( s ) ; if ( i > = <int> ) bannedDevices . add ( Integer . parseInt ( s ) ) ; } deviceSetup . set ( true ) ; Set < Thread > threadSet = Thread . getAllStackTraces ( ) . keySet ( ) ; for ( int i = <int> ; i < numDevices ; i + + ) { for ( Thread thread : threadSet ) getContext ( i , thread . getName ( ) ) ; } setContext ( ) ; try { KernelFunctionLoader . getInstance ( ) . load ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } cudaDeviceProp deviceProperties = new cudaDeviceProp ( ) ; JCuda . cudaGetDeviceProperties ( deviceProperties , <int> ) ; if ( deviceProperties . canMapHostMemory = = <int> ) { System . err . println ( <str> ) ; System . err . println ( deviceProperties . toFormattedString ( ) ) ; return ; } Properties threadProps = new Properties ( ) ; try { InputStream is = ContextHolder . class . getResourceAsStream ( <str> ) ; threadProps . load ( is ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } for ( String prop : threadProps . stringPropertyNames ( ) ) { threads . put ( prop , Integer . parseInt ( threadProps . getProperty ( prop ) ) ) ; } try { GenericObjectPoolConfig config = new GenericObjectPoolConfig ( ) ; config . setJmxEnabled ( true ) ; config . setBlockWhenExhausted ( false ) ; config . setMaxIdle ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; config . setMaxTotal ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; config . setMinIdle ( Runtime . getRuntime ( ) . availableProcessors ( ) ) ; config . setJmxNameBase ( <str> ) ; handlePool = new CublasHandlePool ( new CublasHandlePooledItemFactory ( ) , config ) ; GenericObjectPoolConfig confClone = config . clone ( ) ; confClone . setMaxTotal ( Runtime . getRuntime ( ) . availableProcessors ( ) * <int> ) ; confClone . setMaxIdle ( Runtime . getRuntime ( ) . availableProcessors ( ) * <int> ) ; confClone . setMinIdle ( Runtime . getRuntime ( ) . availableProcessors ( ) * <int> ) ; GenericObjectPoolConfig streamConf = confClone . clone ( ) ; streamConf . setJmxNameBase ( <str> ) ; streamPool = new StreamPool ( new StreamItemFactory ( ) , streamConf ) ; GenericObjectPoolConfig oldStreamConf = streamConf . clone ( ) ; oldStreamConf . setJmxNameBase ( <str> ) ; oldStreamPool = new OldStreamPool ( new OldStreamItemFactory ( ) , oldStreamConf ) ; setContext ( ) ; for ( int i = <int> ; i < Runtime . getRuntime ( ) . availableProcessors ( ) ; i + + ) { streamPool . addObject ( ) ; oldStreamPool . addObject ( ) ; } JCuda . cudaFree ( Pointer . to ( new int [ ] { <int> } ) ) ; } catch ( Exception e ) { log . warn ( <str> , e ) ; } for ( int i = <int> ; i < numDevices ; i + + ) { ClassPathResource confFile = new ClassPathResource ( <str> + i , ContextHolder . class . getClassLoader ( ) ) ; if ( confFile . exists ( ) ) { Properties props2 = new Properties ( ) ; try { props2 . load ( confFile . getInputStream ( ) ) ; confs . put ( i , new DeviceConfiguration ( i , props2 ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } else confs . put ( i , new DeviceConfiguration ( i ) ) ; } confCalled = true ; } public void setNumDevices ( int numDevices ) { this . numDevices = numDevices ; } public GpuInformation getCurrentGpuInformation ( ) { return getGpuInfo ( getDeviceForThread ( ) ) ; } public GpuInformation getGpuInfo ( int device ) { return info . get ( device ) ; } public Map < Integer , GpuInformation > getInfo ( ) { return info ; } public DeviceConfiguration getConf ( int device ) { return confs . get ( device ) ; } public synchronized void setContext ( ) { JCudaDriver . cuCtxSetCurrent ( getContext ( ) ) ; } public int getDeviceForThread ( ) { if ( numDevices > <int> ) { Integer device = threadNameToDeviceNumber . get ( Thread . currentThread ( ) . getName ( ) ) ; if ( device = = null ) { org . nd4j . linalg . api . rng . Random random = Nd4j . getRandom ( ) ; if ( random = = null ) throw new IllegalStateException ( <str> ) ; device = Nd4j . getRandom ( ) . nextInt ( numDevices ) ; while ( bannedDevices ! = null & & bannedDevices . contains ( device ) ) device = Nd4j . getRandom ( ) . nextInt ( numDevices ) ; threadNameToDeviceNumber . put ( Thread . currentThread ( ) . getName ( ) , device ) ; return device ; } } return <int> ; } public cublasHandle getHandle ( ) { cublasHandle handle = handleMap . get ( Thread . currentThread ( ) . getName ( ) ) ; if ( handle ! = null ) return handle ; handle = new cublasHandle ( ) ; JCublas2 . cublasCreate ( handle ) ; handleMap . put ( Thread . currentThread ( ) . getName ( ) , handle ) ; return handle ; } public CUcontext getContext ( ) { return getContext ( getDeviceForThread ( ) , Thread . currentThread ( ) . getName ( ) ) ; } public synchronized cudaStream_t getCudaStream ( ) { Thread currentThread = Thread . currentThread ( ) ; CUcontext ctx = getContext ( getDeviceForThread ( ) , currentThread . getName ( ) ) ; cudaStream_t stream = cudaStreams . get ( ctx , currentThread . getName ( ) ) ; if ( stream = = null ) { stream = new cudaStream_t ( ) ; checkResult ( JCudaDriver . cuCtxSetCurrent ( ctx ) ) ; JCuda . cudaStreamCreate ( stream ) ; checkResult ( JCuda . cudaStreamCreate ( stream ) ) ; cudaStreams . put ( ctx , currentThread . getName ( ) , stream ) ; } return stream ; } private void checkResult ( int result ) { if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } } public synchronized CUcontext getContext ( int deviceToUse , String threadName ) { CUcontext ctx = deviceIDContexts . get ( deviceToUse , threadName ) ; if ( ctx = = null ) { ctx = new CUcontext ( ) ; for ( int device = <int> ; device < numDevices ; device + + ) { initialize ( ctx , device ) ; CUdevice currDevice = createDevice ( ctx , device ) ; devices . put ( device , currDevice ) ; info . put ( device , new GpuInformation ( currDevice ) ) ; deviceIDContexts . put ( device , threadName , ctx ) ; } } return ctx ; } private void initialize ( CUcontext context , int deviceNumber ) { cuCtxGetCurrent ( context ) ; CUcontext nullContext = new CUcontext ( ) ; if ( context . equals ( nullContext ) ) createContext ( context , deviceNumber ) ; } private void createContext ( CUcontext context , int deviceNumber ) { CUdevice device = new CUdevice ( ) ; int result = cuDeviceGet ( device , deviceNumber ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } result = cuCtxCreate ( context , <int> , device ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } } public static CUdevice createDevice ( CUcontext context , int deviceNumber ) { CUdevice device = new CUdevice ( ) ; int result = cuDeviceGet ( device , deviceNumber ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } result = cuCtxCreate ( context , <int> , device ) ; if ( result ! = CUresult . CUDA_SUCCESS ) { throw new CudaException ( <str> + CUresult . stringFor ( result ) ) ; } return device ; } public GpuInformation getInfoFor ( int cUdevice ) { getContext ( cUdevice , Thread . currentThread ( ) . getName ( ) ) ; return info . get ( cUdevice ) ; } public synchronized void destroy ( ) { if ( shutdown . get ( ) ) return ; shutdown . set ( true ) ; } } 
