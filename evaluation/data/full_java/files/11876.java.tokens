package org . gradle . cache . internal . filelock ; import java . io . * ; import java . nio . channels . FileLock ; public class LockStateAccess { private final LockStateSerializer protocol ; private static final int REGION_START = <int> ; private static final int STATE_CONTENT_START = <int> ; private final int stateRegionSize ; public LockStateAccess ( LockStateSerializer protocol ) { this . protocol = protocol ; stateRegionSize = STATE_CONTENT_START + protocol . getSize ( ) ; } public LockState ensureLockState ( RandomAccessFile lockFileAccess ) throws IOException { if ( lockFileAccess . length ( ) = = <int> ) { LockState state = protocol . createInitialState ( ) ; writeState ( lockFileAccess , state ) ; return state ; } else { return readState ( lockFileAccess ) ; } } public void writeState ( RandomAccessFile lockFileAccess , LockState lockState ) throws IOException { ByteArrayOutputStream outstr = new ByteArrayOutputStream ( ) ; DataOutputStream dataOutput = new DataOutputStream ( outstr ) ; dataOutput . writeByte ( protocol . getVersion ( ) ) ; protocol . write ( dataOutput , lockState ) ; dataOutput . flush ( ) ; lockFileAccess . seek ( REGION_START ) ; lockFileAccess . write ( outstr . toByteArray ( ) ) ; assert lockFileAccess . getFilePointer ( ) = = stateRegionSize ; } public LockState readState ( RandomAccessFile lockFileAccess ) throws IOException { try { byte [ ] buffer = new byte [ stateRegionSize ] ; lockFileAccess . seek ( REGION_START ) ; int readPos = <int> ; while ( readPos < buffer . length ) { int nread = lockFileAccess . read ( buffer , readPos , buffer . length - readPos ) ; if ( nread < <int> ) { break ; } readPos + = nread ; } ByteArrayInputStream inputStream = new ByteArrayInputStream ( buffer , <int> , readPos ) ; DataInputStream dataInput = new DataInputStream ( inputStream ) ; byte protocolVersion = dataInput . readByte ( ) ; if ( protocolVersion ! = protocol . getVersion ( ) ) { throw new IllegalStateException ( String . format ( <str> , protocol . getVersion ( ) , protocolVersion ) ) ; } return protocol . read ( dataInput ) ; } catch ( EOFException e ) { return protocol . createInitialState ( ) ; } } public FileLock tryLock ( RandomAccessFile lockFileAccess , boolean shared ) throws IOException { return lockFileAccess . getChannel ( ) . tryLock ( REGION_START , stateRegionSize , shared ) ; } public int getRegionEnd ( ) { return stateRegionSize ; } } 
