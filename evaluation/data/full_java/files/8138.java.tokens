package org . elasticsearch . index . mapper ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; public class FieldTypeLookupTests extends ESTestCase { public void testEmpty ( ) { FieldTypeLookup lookup = new FieldTypeLookup ( ) ; assertNull ( lookup . get ( <str> ) ) ; assertNull ( lookup . getByIndexName ( <str> ) ) ; assertEquals ( Collections . emptySet ( ) , lookup . getTypes ( <str> ) ) ; assertEquals ( Collections . emptySet ( ) , lookup . getTypesByIndexName ( <str> ) ) ; Collection < String > names = lookup . simpleMatchToFullName ( <str> ) ; assertNotNull ( names ) ; assertTrue ( names . isEmpty ( ) ) ; names = lookup . simpleMatchToIndexNames ( <str> ) ; assertNotNull ( names ) ; assertTrue ( names . isEmpty ( ) ) ; Iterator < MappedFieldType > itr = lookup . iterator ( ) ; assertNotNull ( itr ) ; assertFalse ( itr . hasNext ( ) ) ; } public void testDefaultMapping ( ) { FieldTypeLookup lookup = new FieldTypeLookup ( ) ; try { lookup . copyAndAddAll ( MapperService . DEFAULT_MAPPING , Collections . emptyList ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertEquals ( <str> , expected . getMessage ( ) ) ; } } public void testAddNewField ( ) { FieldTypeLookup lookup = new FieldTypeLookup ( ) ; FakeFieldMapper f = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup2 = lookup . copyAndAddAll ( <str> , newList ( f ) ) ; assertNull ( lookup . get ( <str> ) ) ; assertNull ( lookup . get ( <str> ) ) ; assertNull ( lookup . getByIndexName ( <str> ) ) ; assertNull ( lookup . getByIndexName ( <str> ) ) ; assertEquals ( f . fieldType ( ) , lookup2 . get ( <str> ) ) ; assertNull ( lookup . get ( <str> ) ) ; assertEquals ( f . fieldType ( ) , lookup2 . getByIndexName ( <str> ) ) ; assertNull ( lookup . getByIndexName ( <str> ) ) ; assertEquals ( Collections . emptySet ( ) , lookup . getTypes ( <str> ) ) ; assertEquals ( Collections . emptySet ( ) , lookup . getTypesByIndexName ( <str> ) ) ; assertEquals ( Collections . emptySet ( ) , lookup . getTypes ( <str> ) ) ; assertEquals ( Collections . emptySet ( ) , lookup . getTypesByIndexName ( <str> ) ) ; assertEquals ( Collections . singleton ( <str> ) , lookup2 . getTypes ( <str> ) ) ; assertEquals ( Collections . emptySet ( ) , lookup2 . getTypesByIndexName ( <str> ) ) ; assertEquals ( Collections . emptySet ( ) , lookup2 . getTypes ( <str> ) ) ; assertEquals ( Collections . singleton ( <str> ) , lookup2 . getTypesByIndexName ( <str> ) ) ; assertEquals ( <int> , size ( lookup2 . iterator ( ) ) ) ; } public void testAddExistingField ( ) { FakeFieldMapper f = new FakeFieldMapper ( <str> , <str> ) ; MappedFieldType originalFieldType = f . fieldType ( ) ; FakeFieldMapper f2 = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f ) ) ; FieldTypeLookup lookup2 = lookup . copyAndAddAll ( <str> , newList ( f2 ) ) ; assertNotSame ( originalFieldType , f . fieldType ( ) ) ; assertSame ( f . fieldType ( ) , f2 . fieldType ( ) ) ; assertSame ( f . fieldType ( ) , lookup2 . get ( <str> ) ) ; assertSame ( f . fieldType ( ) , lookup2 . getByIndexName ( <str> ) ) ; assertEquals ( <int> , size ( lookup2 . iterator ( ) ) ) ; } public void testAddExistingIndexName ( ) { FakeFieldMapper f = new FakeFieldMapper ( <str> , <str> ) ; FakeFieldMapper f2 = new FakeFieldMapper ( <str> , <str> ) ; MappedFieldType originalFieldType = f . fieldType ( ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f ) ) ; FieldTypeLookup lookup2 = lookup . copyAndAddAll ( <str> , newList ( f2 ) ) ; assertNotSame ( originalFieldType , f . fieldType ( ) ) ; assertSame ( f . fieldType ( ) , f2 . fieldType ( ) ) ; assertSame ( f . fieldType ( ) , lookup2 . get ( <str> ) ) ; assertSame ( f . fieldType ( ) , lookup2 . get ( <str> ) ) ; assertSame ( f . fieldType ( ) , lookup2 . getByIndexName ( <str> ) ) ; assertEquals ( <int> , size ( lookup2 . iterator ( ) ) ) ; } public void testAddExistingFullName ( ) { FakeFieldMapper f = new FakeFieldMapper ( <str> , <str> ) ; FakeFieldMapper f2 = new FakeFieldMapper ( <str> , <str> ) ; MappedFieldType originalFieldType = f . fieldType ( ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f ) ) ; FieldTypeLookup lookup2 = lookup . copyAndAddAll ( <str> , newList ( f2 ) ) ; assertNotSame ( originalFieldType , f . fieldType ( ) ) ; assertSame ( f . fieldType ( ) , f2 . fieldType ( ) ) ; assertSame ( f . fieldType ( ) , lookup2 . get ( <str> ) ) ; assertSame ( f . fieldType ( ) , lookup2 . getByIndexName ( <str> ) ) ; assertSame ( f . fieldType ( ) , lookup2 . getByIndexName ( <str> ) ) ; assertEquals ( <int> , size ( lookup2 . iterator ( ) ) ) ; } public void testAddExistingBridgeName ( ) { FakeFieldMapper f = new FakeFieldMapper ( <str> , <str> ) ; FakeFieldMapper f2 = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f , f2 ) ) ; try { FakeFieldMapper f3 = new FakeFieldMapper ( <str> , <str> ) ; lookup . copyAndAddAll ( <str> , newList ( f3 ) ) ; } catch ( IllegalStateException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } try { FakeFieldMapper f3 = new FakeFieldMapper ( <str> , <str> ) ; lookup . copyAndAddAll ( <str> , newList ( f3 ) ) ; } catch ( IllegalStateException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } } public void testCheckCompatibilityNewField ( ) { FakeFieldMapper f1 = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup . checkCompatibility ( <str> , newList ( f1 ) , false ) ; } public void testCheckCompatibilityMismatchedTypes ( ) { FieldMapper f1 = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f1 ) ) ; MappedFieldType ft2 = FakeFieldMapper . makeOtherFieldType ( <str> , <str> ) ; FieldMapper f2 = new FakeFieldMapper ( <str> , ft2 ) ; try { lookup . checkCompatibility ( <str> , newList ( f2 ) , false ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } try { lookup . checkCompatibility ( <str> , newList ( f2 ) , true ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } } public void testCheckCompatibilityConflict ( ) { FieldMapper f1 = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f1 ) ) ; MappedFieldType ft2 = FakeFieldMapper . makeFieldType ( <str> , <str> ) ; ft2 . setBoost ( <float> ) ; FieldMapper f2 = new FakeFieldMapper ( <str> , ft2 ) ; try { lookup . checkCompatibility ( <str> , newList ( f2 ) , false ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } lookup . checkCompatibility ( <str> , newList ( f2 ) , false ) ; lookup . checkCompatibility ( <str> , newList ( f2 ) , true ) ; MappedFieldType ft3 = FakeFieldMapper . makeFieldType ( <str> , <str> ) ; ft3 . setStored ( true ) ; FieldMapper f3 = new FakeFieldMapper ( <str> , ft3 ) ; try { lookup . checkCompatibility ( <str> , newList ( f3 ) , false ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } try { lookup . checkCompatibility ( <str> , newList ( f3 ) , true ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) . contains ( <str> ) ) ; } } public void testSimpleMatchIndexNames ( ) { FakeFieldMapper f1 = new FakeFieldMapper ( <str> , <str> ) ; FakeFieldMapper f2 = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f1 , f2 ) ) ; Collection < String > names = lookup . simpleMatchToIndexNames ( <str> ) ; assertTrue ( names . contains ( <str> ) ) ; assertTrue ( names . contains ( <str> ) ) ; } public void testSimpleMatchFullNames ( ) { FakeFieldMapper f1 = new FakeFieldMapper ( <str> , <str> ) ; FakeFieldMapper f2 = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f1 , f2 ) ) ; Collection < String > names = lookup . simpleMatchToFullName ( <str> ) ; assertTrue ( names . contains ( <str> ) ) ; assertTrue ( names . contains ( <str> ) ) ; } public void testIteratorImmutable ( ) { FakeFieldMapper f1 = new FakeFieldMapper ( <str> , <str> ) ; FieldTypeLookup lookup = new FieldTypeLookup ( ) ; lookup = lookup . copyAndAddAll ( <str> , newList ( f1 ) ) ; try { Iterator < MappedFieldType > itr = lookup . iterator ( ) ; assertTrue ( itr . hasNext ( ) ) ; assertEquals ( f1 . fieldType ( ) , itr . next ( ) ) ; itr . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException e ) { } } static List < FieldMapper > newList ( FieldMapper . . . mapper ) { return Arrays . asList ( mapper ) ; } static class FakeFieldMapper extends FieldMapper { static Settings dummySettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT . id ) . build ( ) ; public FakeFieldMapper ( String fullName , String indexName ) { super ( fullName , makeFieldType ( fullName , indexName ) , makeFieldType ( fullName , indexName ) , dummySettings , null , null ) ; } public FakeFieldMapper ( String fullName , MappedFieldType fieldType ) { super ( fullName , fieldType , fieldType , dummySettings , null , null ) ; } static MappedFieldType makeFieldType ( String fullName , String indexName ) { FakeFieldType fieldType = new FakeFieldType ( ) ; fieldType . setNames ( new MappedFieldType . Names ( indexName , indexName , fullName ) ) ; return fieldType ; } static MappedFieldType makeOtherFieldType ( String fullName , String indexName ) { OtherFakeFieldType fieldType = new OtherFakeFieldType ( ) ; fieldType . setNames ( new MappedFieldType . Names ( indexName , indexName , fullName ) ) ; return fieldType ; } static class FakeFieldType extends MappedFieldType { public FakeFieldType ( ) { } protected FakeFieldType ( FakeFieldType ref ) { super ( ref ) ; } @Override public MappedFieldType clone ( ) { return new FakeFieldType ( this ) ; } @Override public String typeName ( ) { return <str> ; } } static class OtherFakeFieldType extends MappedFieldType { public OtherFakeFieldType ( ) { } protected OtherFakeFieldType ( OtherFakeFieldType ref ) { super ( ref ) ; } @Override public MappedFieldType clone ( ) { return new OtherFakeFieldType ( this ) ; } @Override public String typeName ( ) { return <str> ; } } @Override protected String contentType ( ) { return null ; } @Override protected void parseCreateField ( ParseContext context , List list ) throws IOException { } } private int size ( Iterator < MappedFieldType > iterator ) { if ( iterator = = null ) { throw new NullPointerException ( <str> ) ; } int count = <int> ; while ( iterator . hasNext ( ) ) { count + + ; iterator . next ( ) ; } return count ; } } 
