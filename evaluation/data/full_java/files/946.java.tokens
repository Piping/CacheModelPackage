package org . apache . cassandra . service ; import java . lang . management . GarbageCollectorMXBean ; import java . lang . management . ManagementFactory ; import java . lang . management . MemoryUsage ; import java . lang . reflect . Field ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; import javax . management . MBeanServer ; import javax . management . Notification ; import javax . management . NotificationListener ; import javax . management . ObjectName ; import javax . management . openmbean . CompositeData ; import com . sun . management . GarbageCollectionNotificationInfo ; import com . sun . management . GcInfo ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . utils . StatusLogger ; public class GCInspector implements NotificationListener , GCInspectorMXBean { public static final String MBEAN_NAME = <str> ; private static final Logger logger = LoggerFactory . getLogger ( GCInspector . class ) ; final static long MIN_LOG_DURATION = <int> ; final static long GC_WARN_THRESHOLD_IN_MS = DatabaseDescriptor . getGCWarnThreshold ( ) ; final static long STAT_THRESHOLD = Math . min ( GC_WARN_THRESHOLD_IN_MS ! = <int> ? GC_WARN_THRESHOLD_IN_MS : MIN_LOG_DURATION , MIN_LOG_DURATION ) ; final static Field BITS_TOTAL_CAPACITY ; static { Field temp = null ; try { Class < ? > bitsClass = Class . forName ( <str> ) ; Field f = bitsClass . getDeclaredField ( <str> ) ; f . setAccessible ( true ) ; temp = f ; } catch ( Throwable t ) { logger . debug ( <str> , t ) ; } BITS_TOTAL_CAPACITY = temp ; } static final class State { final double maxRealTimeElapsed ; final double totalRealTimeElapsed ; final double sumSquaresRealTimeElapsed ; final double totalBytesReclaimed ; final double count ; final long startNanos ; State ( double extraElapsed , double extraBytes , State prev ) { this . totalRealTimeElapsed = prev . totalRealTimeElapsed + extraElapsed ; this . totalBytesReclaimed = prev . totalBytesReclaimed + extraBytes ; this . sumSquaresRealTimeElapsed = prev . sumSquaresRealTimeElapsed + ( extraElapsed * extraElapsed ) ; this . startNanos = prev . startNanos ; this . count = prev . count + <int> ; this . maxRealTimeElapsed = Math . max ( prev . maxRealTimeElapsed , extraElapsed ) ; } State ( ) { count = maxRealTimeElapsed = sumSquaresRealTimeElapsed = totalRealTimeElapsed = totalBytesReclaimed = <int> ; startNanos = System . nanoTime ( ) ; } } static final class GCState { final GarbageCollectorMXBean gcBean ; final boolean assumeGCIsPartiallyConcurrent ; final boolean assumeGCIsOldGen ; private String [ ] keys ; long lastGcTotalDuration = <int> ; GCState ( GarbageCollectorMXBean gcBean , boolean assumeGCIsPartiallyConcurrent , boolean assumeGCIsOldGen ) { this . gcBean = gcBean ; this . assumeGCIsPartiallyConcurrent = assumeGCIsPartiallyConcurrent ; this . assumeGCIsOldGen = assumeGCIsOldGen ; } String [ ] keys ( GarbageCollectionNotificationInfo info ) { if ( keys ! = null ) return keys ; keys = info . getGcInfo ( ) . getMemoryUsageBeforeGc ( ) . keySet ( ) . toArray ( new String [ <int> ] ) ; Arrays . sort ( keys ) ; return keys ; } } final AtomicReference < State > state = new AtomicReference < > ( new State ( ) ) ; final Map < String , GCState > gcStates = new HashMap < > ( ) ; public GCInspector ( ) { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { ObjectName gcName = new ObjectName ( ManagementFactory . GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + <str> ) ; for ( ObjectName name : mbs . queryNames ( gcName , null ) ) { GarbageCollectorMXBean gc = ManagementFactory . newPlatformMXBeanProxy ( mbs , name . getCanonicalName ( ) , GarbageCollectorMXBean . class ) ; gcStates . put ( gc . getName ( ) , new GCState ( gc , assumeGCIsPartiallyConcurrent ( gc ) , assumeGCIsOldGen ( gc ) ) ) ; } mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public static void register ( ) throws Exception { GCInspector inspector = new GCInspector ( ) ; MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; ObjectName gcName = new ObjectName ( ManagementFactory . GARBAGE_COLLECTOR_MXBEAN_DOMAIN_TYPE + <str> ) ; for ( ObjectName name : server . queryNames ( gcName , null ) ) { server . addNotificationListener ( name , inspector , null , null ) ; } } private static boolean assumeGCIsPartiallyConcurrent ( GarbageCollectorMXBean gc ) { switch ( gc . getName ( ) ) { case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : return false ; case <str> : case <str> : return true ; default : return true ; } } private static boolean assumeGCIsOldGen ( GarbageCollectorMXBean gc ) { switch ( gc . getName ( ) ) { case <str> : case <str> : case <str> : case <str> : return false ; case <str> : case <str> : case <str> : case <str> : return true ; default : return false ; } } public void handleNotification ( final Notification notification , final Object handback ) { String type = notification . getType ( ) ; if ( type . equals ( GarbageCollectionNotificationInfo . GARBAGE_COLLECTION_NOTIFICATION ) ) { CompositeData cd = ( CompositeData ) notification . getUserData ( ) ; GarbageCollectionNotificationInfo info = GarbageCollectionNotificationInfo . from ( cd ) ; String gcName = info . getGcName ( ) ; GcInfo gcInfo = info . getGcInfo ( ) ; long duration = gcInfo . getDuration ( ) ; GCState gcState = gcStates . get ( gcName ) ; if ( gcState . assumeGCIsPartiallyConcurrent ) { long previousTotal = gcState . lastGcTotalDuration ; long total = gcState . gcBean . getCollectionTime ( ) ; gcState . lastGcTotalDuration = total ; duration = total - previousTotal ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( info . getGcName ( ) ) . append ( <str> ) . append ( duration ) . append ( <str> ) ; long bytes = <int> ; Map < String , MemoryUsage > beforeMemoryUsage = gcInfo . getMemoryUsageBeforeGc ( ) ; Map < String , MemoryUsage > afterMemoryUsage = gcInfo . getMemoryUsageAfterGc ( ) ; for ( String key : gcState . keys ( info ) ) { MemoryUsage before = beforeMemoryUsage . get ( key ) ; MemoryUsage after = afterMemoryUsage . get ( key ) ; if ( after ! = null & & after . getUsed ( ) ! = before . getUsed ( ) ) { sb . append ( key ) . append ( <str> ) . append ( before . getUsed ( ) ) ; sb . append ( <str> ) ; sb . append ( after . getUsed ( ) ) ; if ( ! key . equals ( gcState . keys [ gcState . keys . length - <int> ] ) ) sb . append ( <str> ) ; bytes + = before . getUsed ( ) - after . getUsed ( ) ; } } while ( true ) { State prev = state . get ( ) ; if ( state . compareAndSet ( prev , new State ( duration , bytes , prev ) ) ) break ; } String st = sb . toString ( ) ; if ( GC_WARN_THRESHOLD_IN_MS ! = <int> & & duration > GC_WARN_THRESHOLD_IN_MS ) logger . warn ( st ) ; else if ( duration > MIN_LOG_DURATION ) logger . info ( st ) ; else if ( logger . isTraceEnabled ( ) ) logger . trace ( st ) ; if ( duration > STAT_THRESHOLD ) StatusLogger . log ( ) ; if ( gcState . assumeGCIsOldGen ) LifecycleTransaction . rescheduleFailedDeletions ( ) ; } } public State getTotalSinceLastCheck ( ) { return state . getAndSet ( new State ( ) ) ; } public double [ ] getAndResetStats ( ) { State state = getTotalSinceLastCheck ( ) ; double [ ] r = new double [ <int> ] ; r [ <int> ] = TimeUnit . NANOSECONDS . toMillis ( System . nanoTime ( ) - state . startNanos ) ; r [ <int> ] = state . maxRealTimeElapsed ; r [ <int> ] = state . totalRealTimeElapsed ; r [ <int> ] = state . sumSquaresRealTimeElapsed ; r [ <int> ] = state . totalBytesReclaimed ; r [ <int> ] = state . count ; r [ <int> ] = getAllocatedDirectMemory ( ) ; return r ; } private static long getAllocatedDirectMemory ( ) { if ( BITS_TOTAL_CAPACITY = = null ) return - <int> ; try { return BITS_TOTAL_CAPACITY . getLong ( null ) ; } catch ( Throwable t ) { logger . trace ( <str> , t ) ; return - <int> ; } } } 
