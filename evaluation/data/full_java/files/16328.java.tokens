package junit . runner ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . io . StringReader ; import java . io . StringWriter ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . text . NumberFormat ; import java . util . Properties ; import junit . framework . AssertionFailedError ; import junit . framework . Test ; import junit . framework . TestListener ; import junit . framework . TestSuite ; public abstract class BaseTestRunner implements TestListener { public static final String SUITE_METHODNAME = <str> ; private static Properties fPreferences ; static int fgMaxMessageLength = <int> ; static boolean fgFilterStack = true ; boolean fLoading = true ; public synchronized void startTest ( Test test ) { testStarted ( test . toString ( ) ) ; } protected static void setPreferences ( Properties preferences ) { fPreferences = preferences ; } protected static Properties getPreferences ( ) { if ( fPreferences = = null ) { fPreferences = new Properties ( ) ; fPreferences . put ( <str> , <str> ) ; fPreferences . put ( <str> , <str> ) ; readPreferences ( ) ; } return fPreferences ; } public static void savePreferences ( ) throws IOException { FileOutputStream fos = new FileOutputStream ( getPreferencesFile ( ) ) ; try { getPreferences ( ) . store ( fos , <str> ) ; } finally { fos . close ( ) ; } } public static void setPreference ( String key , String value ) { getPreferences ( ) . put ( key , value ) ; } public synchronized void endTest ( Test test ) { testEnded ( test . toString ( ) ) ; } public synchronized void addError ( final Test test , final Throwable e ) { testFailed ( TestRunListener . STATUS_ERROR , test , e ) ; } public synchronized void addFailure ( final Test test , final AssertionFailedError e ) { testFailed ( TestRunListener . STATUS_FAILURE , test , e ) ; } public abstract void testStarted ( String testName ) ; public abstract void testEnded ( String testName ) ; public abstract void testFailed ( int status , Test test , Throwable e ) ; public Test getTest ( String suiteClassName ) { if ( suiteClassName . length ( ) < = <int> ) { clearStatus ( ) ; return null ; } Class < ? > testClass = null ; try { testClass = loadSuiteClass ( suiteClassName ) ; } catch ( ClassNotFoundException e ) { String clazz = e . getMessage ( ) ; if ( clazz = = null ) { clazz = suiteClassName ; } runFailed ( <str> + clazz + <str> ) ; return null ; } catch ( Exception e ) { runFailed ( <str> + e . toString ( ) ) ; return null ; } Method suiteMethod = null ; try { suiteMethod = testClass . getMethod ( SUITE_METHODNAME ) ; } catch ( Exception e ) { clearStatus ( ) ; return new TestSuite ( testClass ) ; } if ( ! Modifier . isStatic ( suiteMethod . getModifiers ( ) ) ) { runFailed ( <str> ) ; return null ; } Test test = null ; try { test = ( Test ) suiteMethod . invoke ( null ) ; if ( test = = null ) { return test ; } } catch ( InvocationTargetException e ) { runFailed ( <str> + e . getTargetException ( ) . toString ( ) ) ; return null ; } catch ( IllegalAccessException e ) { runFailed ( <str> + e . toString ( ) ) ; return null ; } clearStatus ( ) ; return test ; } public String elapsedTimeAsString ( long runTime ) { return NumberFormat . getInstance ( ) . format ( ( double ) runTime / <int> ) ; } protected String processArguments ( String [ ] args ) { String suiteName = null ; for ( int i = <int> ; i < args . length ; i + + ) { if ( args [ i ] . equals ( <str> ) ) { setLoading ( false ) ; } else if ( args [ i ] . equals ( <str> ) ) { fgFilterStack = false ; } else if ( args [ i ] . equals ( <str> ) ) { if ( args . length > i + <int> ) { suiteName = extractClassName ( args [ i + <int> ] ) ; } else { System . out . println ( <str> ) ; } i + + ; } else { suiteName = args [ i ] ; } } return suiteName ; } public void setLoading ( boolean enable ) { fLoading = enable ; } public String extractClassName ( String className ) { if ( className . startsWith ( <str> ) ) { return className . substring ( className . lastIndexOf ( <str> ) + <int> ) ; } return className ; } public static String truncate ( String s ) { if ( fgMaxMessageLength ! = - <int> & & s . length ( ) > fgMaxMessageLength ) { s = s . substring ( <int> , fgMaxMessageLength ) + <str> ; } return s ; } protected abstract void runFailed ( String message ) ; protected Class < ? > loadSuiteClass ( String suiteClassName ) throws ClassNotFoundException { return Class . forName ( suiteClassName ) ; } protected void clearStatus ( ) { } protected boolean useReloadingTestSuiteLoader ( ) { return getPreference ( <str> ) . equals ( <str> ) & & fLoading ; } private static File getPreferencesFile ( ) { String home = System . getProperty ( <str> ) ; return new File ( home , <str> ) ; } private static void readPreferences ( ) { InputStream is = null ; try { is = new FileInputStream ( getPreferencesFile ( ) ) ; setPreferences ( new Properties ( getPreferences ( ) ) ) ; getPreferences ( ) . load ( is ) ; } catch ( IOException ignored ) { } finally { try { if ( is ! = null ) { is . close ( ) ; } } catch ( IOException e1 ) { } } } public static String getPreference ( String key ) { return getPreferences ( ) . getProperty ( key ) ; } public static int getPreference ( String key , int dflt ) { String value = getPreference ( key ) ; int intValue = dflt ; if ( value = = null ) { return intValue ; } try { intValue = Integer . parseInt ( value ) ; } catch ( NumberFormatException ne ) { } return intValue ; } public static String getFilteredTrace ( Throwable e ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; e . printStackTrace ( writer ) ; String trace = stringWriter . toString ( ) ; return BaseTestRunner . getFilteredTrace ( trace ) ; } public static String getFilteredTrace ( String stack ) { if ( showStackRaw ( ) ) { return stack ; } StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; StringReader sr = new StringReader ( stack ) ; BufferedReader br = new BufferedReader ( sr ) ; String line ; try { while ( ( line = br . readLine ( ) ) ! = null ) { if ( ! filterLine ( line ) ) { pw . println ( line ) ; } } } catch ( Exception IOException ) { return stack ; } return sw . toString ( ) ; } protected static boolean showStackRaw ( ) { return ! getPreference ( <str> ) . equals ( <str> ) | | fgFilterStack = = false ; } static boolean filterLine ( String line ) { String [ ] patterns = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; for ( int i = <int> ; i < patterns . length ; i + + ) { if ( line . indexOf ( patterns [ i ] ) > <int> ) { return true ; } } return false ; } static { fgMaxMessageLength = getPreference ( <str> , fgMaxMessageLength ) ; } } 
