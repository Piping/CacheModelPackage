package com . badlogic . gdx . graphics . glutils ; import java . nio . ByteBuffer ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . GL30 ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . utils . BufferUtils ; public class VertexBufferObjectWithVAO implements VertexData { final static IntBuffer tmpHandle = BufferUtils . newIntBuffer ( <int> ) ; final VertexAttributes attributes ; final FloatBuffer buffer ; final ByteBuffer byteBuffer ; int bufferHandle ; final boolean isStatic ; final int usage ; boolean isDirty = false ; boolean isBound = false ; boolean vaoDirty = true ; int vaoHandle = - <int> ; public VertexBufferObjectWithVAO ( boolean isStatic , int numVertices , VertexAttribute . . . attributes ) { this ( isStatic , numVertices , new VertexAttributes ( attributes ) ) ; } public VertexBufferObjectWithVAO ( boolean isStatic , int numVertices , VertexAttributes attributes ) { this . isStatic = isStatic ; this . attributes = attributes ; byteBuffer = BufferUtils . newUnsafeByteBuffer ( this . attributes . vertexSize * numVertices ) ; buffer = byteBuffer . asFloatBuffer ( ) ; buffer . flip ( ) ; byteBuffer . flip ( ) ; bufferHandle = Gdx . gl20 . glGenBuffer ( ) ; usage = isStatic ? GL20 . GL_STATIC_DRAW : GL20 . GL_DYNAMIC_DRAW ; } @Override public VertexAttributes getAttributes ( ) { return attributes ; } @Override public int getNumVertices ( ) { return buffer . limit ( ) * <int> / attributes . vertexSize ; } @Override public int getNumMaxVertices ( ) { return byteBuffer . capacity ( ) / attributes . vertexSize ; } @Override public FloatBuffer getBuffer ( ) { isDirty = true ; return buffer ; } private void bufferChanged ( ) { if ( isBound ) { Gdx . gl20 . glBufferData ( GL20 . GL_ARRAY_BUFFER , byteBuffer . limit ( ) , byteBuffer , usage ) ; isDirty = false ; } } @Override public void setVertices ( float [ ] vertices , int offset , int count ) { isDirty = true ; BufferUtils . copy ( vertices , byteBuffer , count , offset ) ; buffer . position ( <int> ) ; buffer . limit ( count ) ; bufferChanged ( ) ; } @Override public void updateVertices ( int targetOffset , float [ ] vertices , int sourceOffset , int count ) { isDirty = true ; final int pos = byteBuffer . position ( ) ; byteBuffer . position ( targetOffset * <int> ) ; BufferUtils . copy ( vertices , sourceOffset , count , byteBuffer ) ; byteBuffer . position ( pos ) ; buffer . position ( <int> ) ; bufferChanged ( ) ; } @Override public void bind ( ShaderProgram shader ) { bind ( shader , null ) ; } @Override public void bind ( ShaderProgram shader , int [ ] locations ) { GL30 gl = Gdx . gl30 ; if ( vaoDirty | | ! gl . glIsVertexArray ( vaoHandle ) ) { tmpHandle . clear ( ) ; gl . glGenVertexArrays ( <int> , tmpHandle ) ; vaoHandle = tmpHandle . get ( <int> ) ; gl . glBindVertexArray ( vaoHandle ) ; vaoDirty = false ; } else { gl . glBindVertexArray ( vaoHandle ) ; } bindAttributes ( shader , locations ) ; bindData ( gl ) ; isBound = true ; } private void bindAttributes ( ShaderProgram shader , int [ ] locations ) { final GL20 gl = Gdx . gl20 ; gl . glBindBuffer ( GL20 . GL_ARRAY_BUFFER , bufferHandle ) ; final int numAttributes = attributes . size ( ) ; if ( locations = = null ) { for ( int i = <int> ; i < numAttributes ; i + + ) { final VertexAttribute attribute = attributes . get ( i ) ; final int location = shader . getAttributeLocation ( attribute . alias ) ; if ( location < <int> ) continue ; shader . enableVertexAttribute ( location ) ; shader . setVertexAttribute ( location , attribute . numComponents , attribute . type , attribute . normalized , attributes . vertexSize , attribute . offset ) ; } } else { for ( int i = <int> ; i < numAttributes ; i + + ) { final VertexAttribute attribute = attributes . get ( i ) ; final int location = locations [ i ] ; if ( location < <int> ) continue ; shader . enableVertexAttribute ( location ) ; shader . setVertexAttribute ( location , attribute . numComponents , attribute . type , attribute . normalized , attributes . vertexSize , attribute . offset ) ; } } } private void bindData ( GL20 gl ) { if ( isDirty ) { gl . glBindBuffer ( GL20 . GL_ARRAY_BUFFER , bufferHandle ) ; byteBuffer . limit ( buffer . limit ( ) * <int> ) ; gl . glBufferData ( GL20 . GL_ARRAY_BUFFER , byteBuffer . limit ( ) , byteBuffer , usage ) ; isDirty = false ; } } @Override public void unbind ( final ShaderProgram shader ) { unbind ( shader , null ) ; } @Override public void unbind ( final ShaderProgram shader , final int [ ] locations ) { GL30 gl = Gdx . gl30 ; gl . glBindVertexArray ( <int> ) ; isBound = false ; } @Override public void invalidate ( ) { bufferHandle = Gdx . gl20 . glGenBuffer ( ) ; isDirty = true ; vaoDirty = true ; } @Override public void dispose ( ) { GL30 gl = Gdx . gl30 ; gl . glBindBuffer ( GL20 . GL_ARRAY_BUFFER , <int> ) ; gl . glDeleteBuffer ( bufferHandle ) ; bufferHandle = <int> ; BufferUtils . disposeUnsafeByteBuffer ( byteBuffer ) ; if ( gl . glIsVertexArray ( vaoHandle ) ) { tmpHandle . clear ( ) ; tmpHandle . put ( vaoHandle ) ; tmpHandle . flip ( ) ; gl . glDeleteVertexArrays ( <int> , tmpHandle ) ; } } } 
