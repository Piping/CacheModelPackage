package org . elasticsearch . common . collect ; import org . elasticsearch . test . ESTestCase ; import java . util . * ; public class IteratorsTests extends ESTestCase { public void testConcatentation ( ) { List < Integer > threeTwoOne = Arrays . asList ( <int> , <int> , <int> ) ; List < Integer > fourFiveSix = Arrays . asList ( <int> , <int> , <int> ) ; Iterator < Integer > concat = Iterators . concat ( threeTwoOne . iterator ( ) , fourFiveSix . iterator ( ) ) ; assertContainsInOrder ( concat , <int> , <int> , <int> , <int> , <int> , <int> ) ; } public void testNoConcatenation ( ) { Iterator < Integer > iterator = Iterators . < Integer > concat ( ) ; assertEmptyIterator ( iterator ) ; } public void testEmptyConcatenation ( ) { Iterator < Integer > iterator = Iterators . < Integer > concat ( empty ( ) ) ; assertEmptyIterator ( iterator ) ; } public void testMultipleEmptyConcatenation ( ) { Iterator < Integer > iterator = Iterators . concat ( empty ( ) , empty ( ) ) ; assertEmptyIterator ( iterator ) ; } public void testSingleton ( ) { int value = randomInt ( ) ; assertSingleton ( value , singletonIterator ( value ) ) ; } public void testEmptyBeforeSingleton ( ) { int value = randomInt ( ) ; assertSingleton ( value , empty ( ) , singletonIterator ( value ) ) ; } public void testEmptyAfterSingleton ( ) { int value = randomInt ( ) ; assertSingleton ( value , singletonIterator ( value ) , empty ( ) ) ; } public void testRandomSingleton ( ) { int numberOfIterators = randomIntBetween ( <int> , <int> ) ; int singletonIndex = randomIntBetween ( <int> , numberOfIterators - <int> ) ; int value = randomInt ( ) ; Iterator < Integer > [ ] iterators = new Iterator [ numberOfIterators ] ; for ( int i = <int> ; i < numberOfIterators ; i + + ) { iterators [ i ] = i ! = singletonIndex ? empty ( ) : singletonIterator ( value ) ; } assertSingleton ( value , iterators ) ; } public void testRandomIterators ( ) { int numberOfIterators = randomIntBetween ( <int> , <int> ) ; Iterator < Integer > [ ] iterators = new Iterator [ numberOfIterators ] ; List < Integer > values = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfIterators ; i + + ) { int numberOfValues = randomIntBetween ( <int> , <int> ) ; List < Integer > theseValues = new ArrayList < > ( ) ; for ( int j = <int> ; j < numberOfValues ; j + + ) { int value = randomInt ( ) ; values . add ( value ) ; theseValues . add ( value ) ; } iterators [ i ] = theseValues . iterator ( ) ; } assertContainsInOrder ( Iterators . concat ( iterators ) , values . toArray ( new Integer [ values . size ( ) ] ) ) ; } public void testTwoEntries ( ) { int first = randomInt ( ) ; int second = randomInt ( ) ; Iterator < Integer > concat = Iterators . concat ( singletonIterator ( first ) , empty ( ) , empty ( ) , singletonIterator ( second ) ) ; assertContainsInOrder ( concat , first , second ) ; } public void testNull ( ) { try { Iterators . concat ( ( Iterator < ? > ) null ) ; fail ( <str> + NullPointerException . class . getSimpleName ( ) ) ; } catch ( NullPointerException e ) { } } public void testNullIterator ( ) { try { Iterators . concat ( singletonIterator ( <int> ) , empty ( ) , null , empty ( ) , singletonIterator ( <int> ) ) ; fail ( <str> + NullPointerException . class . getSimpleName ( ) ) ; } catch ( NullPointerException e ) { } } private < T > Iterator < T > singletonIterator ( T value ) { return Collections . singleton ( value ) . iterator ( ) ; } private < T > void assertSingleton ( T value , Iterator < T > . . . iterators ) { Iterator < T > concat = Iterators . concat ( iterators ) ; assertContainsInOrder ( concat , value ) ; } private < T > Iterator < T > empty ( ) { return new Iterator < T > ( ) { @Override public boolean hasNext ( ) { return false ; } @Override public T next ( ) { throw new NoSuchElementException ( ) ; } } ; } private < T > void assertContainsInOrder ( Iterator < T > iterator , T . . . values ) { for ( T value : values ) { assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( value , iterator . next ( ) ) ; } assertNoSuchElementException ( iterator ) ; } private < T > void assertEmptyIterator ( Iterator < T > iterator ) { assertFalse ( iterator . hasNext ( ) ) ; assertNoSuchElementException ( iterator ) ; } private < T > void assertNoSuchElementException ( Iterator < T > iterator ) { try { iterator . next ( ) ; fail ( <str> + NoSuchElementException . class . getSimpleName ( ) ) ; } catch ( NoSuchElementException e ) { } } } 
