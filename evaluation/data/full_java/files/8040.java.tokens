package org . elasticsearch . gateway ; import org . elasticsearch . Version ; import org . elasticsearch . action . FailedNodeException ; import org . elasticsearch . action . support . nodes . BaseNodeResponse ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . threadpool . ThreadPool ; import org . junit . After ; import org . junit . Before ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicInteger ; import static java . util . Collections . emptySet ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . sameInstance ; public class AsyncShardFetchTests extends ESTestCase { private final DiscoveryNode node1 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; private final Response response1 = new Response ( node1 ) ; private final Throwable failure1 = new Throwable ( <str> ) ; private final DiscoveryNode node2 = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; private final Response response2 = new Response ( node2 ) ; private final Throwable failure2 = new Throwable ( <str> ) ; private ThreadPool threadPool ; private TestFetch test ; @Override @Before public void setUp ( ) throws Exception { super . setUp ( ) ; this . threadPool = new ThreadPool ( getTestName ( ) ) ; this . test = new TestFetch ( threadPool ) ; } @After public void terminate ( ) throws Exception { terminate ( threadPool ) ; } public void testClose ( ) throws Exception { DiscoveryNodes nodes = DiscoveryNodes . builder ( ) . put ( node1 ) . build ( ) ; test . addSimulation ( node1 . getId ( ) , response1 ) ; AsyncShardFetch . FetchResult < Response > fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; test . fireSimulationAndWait ( node1 . getId ( ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; test . close ( ) ; try { test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { } } public void testFullCircleSingleNodeSuccess ( ) throws Exception { DiscoveryNodes nodes = DiscoveryNodes . builder ( ) . put ( node1 ) . build ( ) ; test . addSimulation ( node1 . getId ( ) , response1 ) ; AsyncShardFetch . FetchResult < Response > fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; test . fireSimulationAndWait ( node1 . getId ( ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( true ) ) ; assertThat ( fetchData . getData ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( fetchData . getData ( ) . get ( node1 ) , sameInstance ( response1 ) ) ; } public void testFullCircleSingleNodeFailure ( ) throws Exception { DiscoveryNodes nodes = DiscoveryNodes . builder ( ) . put ( node1 ) . build ( ) ; test . addSimulation ( node1 . getId ( ) , failure1 ) ; AsyncShardFetch . FetchResult < Response > fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; test . fireSimulationAndWait ( node1 . getId ( ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( true ) ) ; assertThat ( fetchData . getData ( ) . size ( ) , equalTo ( <int> ) ) ; test . addSimulation ( node1 . getId ( ) , response1 ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; test . fireSimulationAndWait ( node1 . getId ( ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( true ) ) ; assertThat ( fetchData . getData ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( fetchData . getData ( ) . get ( node1 ) , sameInstance ( response1 ) ) ; } public void testTwoNodesOnSetup ( ) throws Exception { DiscoveryNodes nodes = DiscoveryNodes . builder ( ) . put ( node1 ) . put ( node2 ) . build ( ) ; test . addSimulation ( node1 . getId ( ) , response1 ) ; test . addSimulation ( node2 . getId ( ) , response2 ) ; AsyncShardFetch . FetchResult < Response > fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; test . fireSimulationAndWait ( node1 . getId ( ) ) ; assertThat ( test . getNumberOfInFlightFetches ( ) , equalTo ( <int> ) ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; test . fireSimulationAndWait ( node2 . getId ( ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( true ) ) ; assertThat ( fetchData . getData ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( fetchData . getData ( ) . get ( node1 ) , sameInstance ( response1 ) ) ; assertThat ( fetchData . getData ( ) . get ( node2 ) , sameInstance ( response2 ) ) ; } public void testTwoNodesOnSetupAndFailure ( ) throws Exception { DiscoveryNodes nodes = DiscoveryNodes . builder ( ) . put ( node1 ) . put ( node2 ) . build ( ) ; test . addSimulation ( node1 . getId ( ) , response1 ) ; test . addSimulation ( node2 . getId ( ) , failure2 ) ; AsyncShardFetch . FetchResult < Response > fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; test . fireSimulationAndWait ( node1 . getId ( ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; test . fireSimulationAndWait ( node2 . getId ( ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( true ) ) ; assertThat ( fetchData . getData ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( fetchData . getData ( ) . get ( node1 ) , sameInstance ( response1 ) ) ; } public void testTwoNodesAddedInBetween ( ) throws Exception { DiscoveryNodes nodes = DiscoveryNodes . builder ( ) . put ( node1 ) . build ( ) ; test . addSimulation ( node1 . getId ( ) , response1 ) ; AsyncShardFetch . FetchResult < Response > fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; assertThat ( test . reroute . get ( ) , equalTo ( <int> ) ) ; test . fireSimulationAndWait ( node1 . getId ( ) ) ; nodes = DiscoveryNodes . builder ( nodes ) . put ( node2 ) . build ( ) ; test . addSimulation ( node2 . getId ( ) , response2 ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( false ) ) ; test . fireSimulationAndWait ( node2 . getId ( ) ) ; fetchData = test . fetchData ( nodes , MetaData . EMPTY_META_DATA , emptySet ( ) ) ; assertThat ( fetchData . hasData ( ) , equalTo ( true ) ) ; assertThat ( fetchData . getData ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( fetchData . getData ( ) . get ( node1 ) , sameInstance ( response1 ) ) ; assertThat ( fetchData . getData ( ) . get ( node2 ) , sameInstance ( response2 ) ) ; } static class TestFetch extends AsyncShardFetch < Response > { static class Entry { public final Response response ; public final Throwable failure ; private final CountDownLatch executeLatch = new CountDownLatch ( <int> ) ; private final CountDownLatch waitLatch = new CountDownLatch ( <int> ) ; public Entry ( Response response , Throwable failure ) { this . response = response ; this . failure = failure ; } } private final ThreadPool threadPool ; private final Map < String , Entry > simulations = new ConcurrentHashMap < > ( ) ; private AtomicInteger reroute = new AtomicInteger ( ) ; public TestFetch ( ThreadPool threadPool ) { super ( Loggers . getLogger ( TestFetch . class ) , <str> , new ShardId ( <str> , <int> ) , null ) ; this . threadPool = threadPool ; } public void addSimulation ( String nodeId , Response response ) { simulations . put ( nodeId , new Entry ( response , null ) ) ; } public void addSimulation ( String nodeId , Throwable t ) { simulations . put ( nodeId , new Entry ( null , t ) ) ; } public void fireSimulationAndWait ( String nodeId ) throws InterruptedException { simulations . get ( nodeId ) . executeLatch . countDown ( ) ; simulations . get ( nodeId ) . waitLatch . await ( ) ; simulations . remove ( nodeId ) ; } @Override protected void reroute ( ShardId shardId , String reason ) { reroute . incrementAndGet ( ) ; } @Override protected void asyncFetch ( final ShardId shardId , String [ ] nodesIds , MetaData metaData ) { for ( final String nodeId : nodesIds ) { threadPool . generic ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { Entry entry = null ; try { entry = simulations . get ( nodeId ) ; if ( entry = = null ) { awaitBusy ( ( ) - > simulations . containsKey ( nodeId ) ) ; } assert entry ! = null ; entry . executeLatch . await ( ) ; if ( entry . failure ! = null ) { processAsyncFetch ( shardId , null , new FailedNodeException [ ] { new FailedNodeException ( nodeId , <str> , entry . failure ) } ) ; } else { processAsyncFetch ( shardId , new Response [ ] { entry . response } , null ) ; } } catch ( Throwable e ) { logger . error ( <str> , e ) ; } finally { if ( entry ! = null ) { entry . waitLatch . countDown ( ) ; } } } } ) ; } } } static class Response extends BaseNodeResponse { public Response ( DiscoveryNode node ) { super ( node ) ; } } } 
