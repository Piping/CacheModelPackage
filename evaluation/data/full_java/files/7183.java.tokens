package org . elasticsearch . search . aggregations . bucket . histogram ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . rounding . DateTimeUnit ; import org . elasticsearch . common . rounding . Rounding ; import org . elasticsearch . common . rounding . TimeZoneRounding ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValueType ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import org . elasticsearch . search . aggregations . support . ValuesSourceParser ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public class DateHistogramParser implements Aggregator . Parser { static final ParseField EXTENDED_BOUNDS = new ParseField ( <str> ) ; static final ParseField OFFSET = new ParseField ( <str> ) ; static final ParseField INTERVAL = new ParseField ( <str> ) ; public static final Map < String , DateTimeUnit > DATE_FIELD_UNITS ; static { Map < String , DateTimeUnit > dateFieldUnits = new HashMap < > ( ) ; dateFieldUnits . put ( <str> , DateTimeUnit . YEAR_OF_CENTURY ) ; dateFieldUnits . put ( <str> , DateTimeUnit . YEAR_OF_CENTURY ) ; dateFieldUnits . put ( <str> , DateTimeUnit . QUARTER ) ; dateFieldUnits . put ( <str> , DateTimeUnit . QUARTER ) ; dateFieldUnits . put ( <str> , DateTimeUnit . MONTH_OF_YEAR ) ; dateFieldUnits . put ( <str> , DateTimeUnit . MONTH_OF_YEAR ) ; dateFieldUnits . put ( <str> , DateTimeUnit . WEEK_OF_WEEKYEAR ) ; dateFieldUnits . put ( <str> , DateTimeUnit . WEEK_OF_WEEKYEAR ) ; dateFieldUnits . put ( <str> , DateTimeUnit . DAY_OF_MONTH ) ; dateFieldUnits . put ( <str> , DateTimeUnit . DAY_OF_MONTH ) ; dateFieldUnits . put ( <str> , DateTimeUnit . HOUR_OF_DAY ) ; dateFieldUnits . put ( <str> , DateTimeUnit . HOUR_OF_DAY ) ; dateFieldUnits . put ( <str> , DateTimeUnit . MINUTES_OF_HOUR ) ; dateFieldUnits . put ( <str> , DateTimeUnit . MINUTES_OF_HOUR ) ; dateFieldUnits . put ( <str> , DateTimeUnit . SECOND_OF_MINUTE ) ; dateFieldUnits . put ( <str> , DateTimeUnit . SECOND_OF_MINUTE ) ; DATE_FIELD_UNITS = unmodifiableMap ( dateFieldUnits ) ; } @Override public String type ( ) { return InternalDateHistogram . TYPE . name ( ) ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { ValuesSourceParser vsParser = ValuesSourceParser . numeric ( aggregationName , InternalDateHistogram . TYPE , context ) . targetValueType ( ValueType . DATE ) . formattable ( true ) . timezoneAware ( true ) . build ( ) ; boolean keyed = false ; long minDocCount = <int> ; ExtendedBounds extendedBounds = null ; InternalOrder order = ( InternalOrder ) Histogram . Order . KEY_ASC ; String interval = null ; long offset = <int> ; XContentParser . Token token ; String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( vsParser . token ( currentFieldName , token , parser ) ) { continue ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , OFFSET ) ) { offset = parseOffset ( parser . text ( ) ) ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , INTERVAL ) ) { interval = parser . text ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_BOOLEAN ) { if ( <str> . equals ( currentFieldName ) ) { keyed = parser . booleanValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { minDocCount = parser . longValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( currentFieldName ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { String dir = parser . text ( ) ; boolean asc = <str> . equals ( dir ) ; order = resolveOrder ( currentFieldName , asc ) ; } } } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , EXTENDED_BOUNDS ) ) { extendedBounds = new ExtendedBounds ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { if ( <str> . equals ( currentFieldName ) ) { extendedBounds . minAsStr = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { extendedBounds . maxAsStr = parser . text ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { if ( <str> . equals ( currentFieldName ) ) { extendedBounds . min = parser . longValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { extendedBounds . max = parser . longValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } if ( interval = = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } TimeZoneRounding . Builder tzRoundingBuilder ; DateTimeUnit dateTimeUnit = DATE_FIELD_UNITS . get ( interval ) ; if ( dateTimeUnit ! = null ) { tzRoundingBuilder = TimeZoneRounding . builder ( dateTimeUnit ) ; } else { tzRoundingBuilder = TimeZoneRounding . builder ( TimeValue . parseTimeValue ( interval , null , getClass ( ) . getSimpleName ( ) + <str> ) ) ; } Rounding rounding = tzRoundingBuilder . timeZone ( vsParser . input ( ) . timezone ( ) ) . offset ( offset ) . build ( ) ; ValuesSourceConfig config = vsParser . config ( ) ; return new HistogramAggregator . Factory ( aggregationName , config , rounding , order , keyed , minDocCount , extendedBounds , new InternalDateHistogram . Factory ( ) ) ; } private static InternalOrder resolveOrder ( String key , boolean asc ) { if ( <str> . equals ( key ) | | <str> . equals ( key ) ) { return ( InternalOrder ) ( asc ? InternalOrder . KEY_ASC : InternalOrder . KEY_DESC ) ; } if ( <str> . equals ( key ) ) { return ( InternalOrder ) ( asc ? InternalOrder . COUNT_ASC : InternalOrder . COUNT_DESC ) ; } return new InternalOrder . Aggregation ( key , asc ) ; } private long parseOffset ( String offset ) throws IOException { if ( offset . charAt ( <int> ) = = <str> ) { return - TimeValue . parseTimeValue ( offset . substring ( <int> ) , null , getClass ( ) . getSimpleName ( ) + <str> ) . millis ( ) ; } int beginIndex = offset . charAt ( <int> ) = = <str> ? <int> : <int> ; return TimeValue . parseTimeValue ( offset . substring ( beginIndex ) , null , getClass ( ) . getSimpleName ( ) + <str> ) . millis ( ) ; } } 
