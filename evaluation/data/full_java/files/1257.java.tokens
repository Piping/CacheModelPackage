package org . apache . cassandra . utils . btree ; import org . apache . cassandra . utils . ObjectSizes ; import java . util . Arrays ; import java . util . Comparator ; import static org . apache . cassandra . utils . btree . BTree . * ; final class NodeBuilder { private static final int MAX_KEYS = <int> + ( FAN_FACTOR * <int> ) ; private NodeBuilder parent , child ; private Object [ ] buildKeys = new Object [ MAX_KEYS ] ; private Object [ ] buildChildren = new Object [ <int> + MAX_KEYS ] ; private int buildKeyPosition ; private int buildChildPosition ; private int maxBuildKeyPosition ; private Object [ ] copyFrom ; private int copyFromKeyPosition ; private int copyFromChildPosition ; private UpdateFunction updateFunction ; private Comparator comparator ; private Object upperBound ; void clear ( ) { NodeBuilder current = this ; while ( current ! = null & & current . upperBound ! = null ) { current . clearSelf ( ) ; current = current . child ; } current = parent ; while ( current ! = null & & current . upperBound ! = null ) { current . clearSelf ( ) ; current = current . parent ; } } void clearSelf ( ) { reset ( null , null , null , null ) ; Arrays . fill ( buildKeys , <int> , maxBuildKeyPosition , null ) ; Arrays . fill ( buildChildren , <int> , maxBuildKeyPosition + <int> , null ) ; maxBuildKeyPosition = <int> ; } void reset ( Object [ ] copyFrom , Object upperBound , UpdateFunction updateFunction , Comparator comparator ) { this . copyFrom = copyFrom ; this . upperBound = upperBound ; this . updateFunction = updateFunction ; this . comparator = comparator ; maxBuildKeyPosition = Math . max ( maxBuildKeyPosition , buildKeyPosition ) ; buildKeyPosition = <int> ; buildChildPosition = <int> ; copyFromKeyPosition = <int> ; copyFromChildPosition = <int> ; } NodeBuilder finish ( ) { assert copyFrom ! = null ; int copyFromKeyEnd = getKeyEnd ( copyFrom ) ; if ( buildKeyPosition + buildChildPosition > <int> ) { copyKeys ( copyFromKeyEnd ) ; if ( ! isLeaf ( copyFrom ) ) copyChildren ( copyFromKeyEnd + <int> ) ; } return isRoot ( ) ? null : ascend ( ) ; } NodeBuilder update ( Object key ) { assert copyFrom ! = null ; int copyFromKeyEnd = getKeyEnd ( copyFrom ) ; int i = copyFromKeyPosition ; boolean found ; boolean owns = true ; if ( i = = copyFromKeyEnd ) { found = false ; } else { int c = - comparator . compare ( key , copyFrom [ i ] ) ; if ( c > = <int> ) { found = c = = <int> ; } else { i = Arrays . binarySearch ( copyFrom , i + <int> , copyFromKeyEnd , key , comparator ) ; found = i > = <int> ; if ( ! found ) i = - i - <int> ; } } if ( found ) { Object prev = copyFrom [ i ] ; Object next = updateFunction . apply ( prev , key ) ; if ( prev = = next ) return null ; key = next ; } else if ( i = = copyFromKeyEnd & & compareUpperBound ( comparator , key , upperBound ) > = <int> ) owns = false ; if ( isLeaf ( copyFrom ) ) { if ( owns ) { copyKeys ( i ) ; if ( found ) { replaceNextKey ( key ) ; } else { addNewKey ( key ) ; } return null ; } else { if ( buildKeyPosition > <int> ) copyKeys ( i ) ; } } else { if ( found ) { copyKeys ( i ) ; replaceNextKey ( key ) ; copyChildren ( i + <int> ) ; return null ; } else if ( owns ) { copyKeys ( i ) ; copyChildren ( i ) ; Object newUpperBound = i < copyFromKeyEnd ? copyFrom [ i ] : upperBound ; Object [ ] descendInto = ( Object [ ] ) copyFrom [ copyFromKeyEnd + i ] ; ensureChild ( ) . reset ( descendInto , newUpperBound , updateFunction , comparator ) ; return child ; } else if ( buildKeyPosition > <int> | | buildChildPosition > <int> ) { copyKeys ( copyFromKeyEnd ) ; copyChildren ( copyFromKeyEnd + <int> ) ; } } return ascend ( ) ; } private static < V > int compareUpperBound ( Comparator < V > comparator , Object value , Object upperBound ) { return upperBound = = POSITIVE_INFINITY ? - <int> : comparator . compare ( ( V ) value , ( V ) upperBound ) ; } boolean isRoot ( ) { return ( parent = = null | | parent . upperBound = = null ) & & buildKeyPosition < = FAN_FACTOR ; } NodeBuilder ascendToRoot ( ) { NodeBuilder current = this ; while ( ! current . isRoot ( ) ) current = current . ascend ( ) ; return current ; } Object [ ] toNode ( ) { assert buildKeyPosition < = FAN_FACTOR : buildKeyPosition ; return buildFromRange ( <int> , buildKeyPosition , isLeaf ( copyFrom ) , false ) ; } private NodeBuilder ascend ( ) { ensureParent ( ) ; boolean isLeaf = isLeaf ( copyFrom ) ; if ( buildKeyPosition > FAN_FACTOR ) { int mid = buildKeyPosition / <int> ; parent . addExtraChild ( buildFromRange ( <int> , mid , isLeaf , true ) , buildKeys [ mid ] ) ; parent . finishChild ( buildFromRange ( mid + <int> , buildKeyPosition - ( mid + <int> ) , isLeaf , false ) ) ; } else { parent . finishChild ( buildFromRange ( <int> , buildKeyPosition , isLeaf , false ) ) ; } return parent ; } private void copyKeys ( int upToKeyPosition ) { if ( copyFromKeyPosition > = upToKeyPosition ) return ; int len = upToKeyPosition - copyFromKeyPosition ; assert len < = FAN_FACTOR : upToKeyPosition + <str> + copyFromKeyPosition ; ensureRoom ( buildKeyPosition + len ) ; if ( len > <int> ) { System . arraycopy ( copyFrom , copyFromKeyPosition , buildKeys , buildKeyPosition , len ) ; copyFromKeyPosition = upToKeyPosition ; buildKeyPosition + = len ; } } private void replaceNextKey ( Object with ) { ensureRoom ( buildKeyPosition + <int> ) ; buildKeys [ buildKeyPosition + + ] = with ; copyFromKeyPosition + + ; } void addNewKey ( Object key ) { ensureRoom ( buildKeyPosition + <int> ) ; buildKeys [ buildKeyPosition + + ] = updateFunction . apply ( key ) ; } private void copyChildren ( int upToChildPosition ) { if ( copyFromChildPosition > = upToChildPosition ) return ; int len = upToChildPosition - copyFromChildPosition ; if ( len > <int> ) { System . arraycopy ( copyFrom , getKeyEnd ( copyFrom ) + copyFromChildPosition , buildChildren , buildChildPosition , len ) ; copyFromChildPosition = upToChildPosition ; buildChildPosition + = len ; } } private void addExtraChild ( Object [ ] child , Object upperBound ) { ensureRoom ( buildKeyPosition + <int> ) ; buildKeys [ buildKeyPosition + + ] = upperBound ; buildChildren [ buildChildPosition + + ] = child ; } private void finishChild ( Object [ ] child ) { buildChildren [ buildChildPosition + + ] = child ; copyFromChildPosition + + ; } private void ensureRoom ( int nextBuildKeyPosition ) { if ( nextBuildKeyPosition < MAX_KEYS ) return ; Object [ ] flushUp = buildFromRange ( <int> , FAN_FACTOR , isLeaf ( copyFrom ) , true ) ; ensureParent ( ) . addExtraChild ( flushUp , buildKeys [ FAN_FACTOR ] ) ; int size = FAN_FACTOR + <int> ; assert size < = buildKeyPosition : buildKeyPosition + <str> + nextBuildKeyPosition ; System . arraycopy ( buildKeys , size , buildKeys , <int> , buildKeyPosition - size ) ; buildKeyPosition - = size ; maxBuildKeyPosition = buildKeys . length ; if ( buildChildPosition > <int> ) { System . arraycopy ( buildChildren , size , buildChildren , <int> , buildChildPosition - size ) ; buildChildPosition - = size ; } } private Object [ ] buildFromRange ( int offset , int keyLength , boolean isLeaf , boolean isExtra ) { if ( keyLength = = <int> ) return copyFrom ; Object [ ] a ; if ( isLeaf ) { a = new Object [ keyLength | <int> ] ; System . arraycopy ( buildKeys , offset , a , <int> , keyLength ) ; } else { a = new Object [ <int> + ( keyLength * <int> ) ] ; System . arraycopy ( buildKeys , offset , a , <int> , keyLength ) ; System . arraycopy ( buildChildren , offset , a , keyLength , keyLength + <int> ) ; int [ ] indexOffsets = new int [ keyLength + <int> ] ; int size = BTree . size ( ( Object [ ] ) a [ keyLength ] ) ; for ( int i = <int> ; i < keyLength ; i + + ) { indexOffsets [ i ] = size ; size + = <int> + BTree . size ( ( Object [ ] ) a [ keyLength + <int> + i ] ) ; } indexOffsets [ keyLength ] = size ; a [ a . length - <int> ] = indexOffsets ; } if ( isExtra ) updateFunction . allocated ( ObjectSizes . sizeOfArray ( a ) ) ; else if ( a . length ! = copyFrom . length ) updateFunction . allocated ( ObjectSizes . sizeOfArray ( a ) - ( copyFrom . length = = <int> ? <int> : ObjectSizes . sizeOfArray ( copyFrom ) ) ) ; return a ; } private NodeBuilder ensureParent ( ) { if ( parent = = null ) { parent = new NodeBuilder ( ) ; parent . child = this ; } if ( parent . upperBound = = null ) parent . reset ( EMPTY_BRANCH , upperBound , updateFunction , comparator ) ; return parent ; } NodeBuilder ensureChild ( ) { if ( child = = null ) { child = new NodeBuilder ( ) ; child . parent = this ; } return child ; } } 
