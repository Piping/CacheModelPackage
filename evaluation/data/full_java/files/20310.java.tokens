package io . netty . channel . socket . nio ; import io . netty . buffer . ByteBuf ; import io . netty . channel . AddressedEnvelope ; import io . netty . channel . Channel ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultAddressedEnvelope ; import io . netty . channel . RecvByteBufAllocator ; import io . netty . channel . nio . AbstractNioMessageChannel ; import io . netty . channel . socket . DatagramChannelConfig ; import io . netty . channel . socket . DatagramPacket ; import io . netty . channel . socket . InternetProtocolFamily ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . NetworkInterface ; import java . net . SocketAddress ; import java . net . SocketException ; import java . nio . ByteBuffer ; import java . nio . channels . DatagramChannel ; import java . nio . channels . MembershipKey ; import java . nio . channels . SelectionKey ; import java . nio . channels . spi . SelectorProvider ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; public final class NioDatagramChannel extends AbstractNioMessageChannel implements io . netty . channel . socket . DatagramChannel { private static final ChannelMetadata METADATA = new ChannelMetadata ( true ) ; private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider . provider ( ) ; private static final String EXPECTED_TYPES = <str> + StringUtil . simpleClassName ( DatagramPacket . class ) + <str> + StringUtil . simpleClassName ( AddressedEnvelope . class ) + <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> + StringUtil . simpleClassName ( SocketAddress . class ) + <str> + StringUtil . simpleClassName ( ByteBuf . class ) + <str> ; private final DatagramChannelConfig config ; private Map < InetAddress , List < MembershipKey > > memberships ; private static DatagramChannel newSocket ( SelectorProvider provider ) { try { return provider . openDatagramChannel ( ) ; } catch ( IOException e ) { throw new ChannelException ( <str> , e ) ; } } private static DatagramChannel newSocket ( SelectorProvider provider , InternetProtocolFamily ipFamily ) { if ( ipFamily = = null ) { return newSocket ( provider ) ; } checkJavaVersion ( ) ; try { return provider . openDatagramChannel ( ProtocolFamilyConverter . convert ( ipFamily ) ) ; } catch ( IOException e ) { throw new ChannelException ( <str> , e ) ; } } private static void checkJavaVersion ( ) { if ( PlatformDependent . javaVersion ( ) < <int> ) { throw new UnsupportedOperationException ( <str> ) ; } } public NioDatagramChannel ( ) { this ( newSocket ( DEFAULT_SELECTOR_PROVIDER ) ) ; } public NioDatagramChannel ( SelectorProvider provider ) { this ( newSocket ( provider ) ) ; } public NioDatagramChannel ( InternetProtocolFamily ipFamily ) { this ( newSocket ( DEFAULT_SELECTOR_PROVIDER , ipFamily ) ) ; } public NioDatagramChannel ( SelectorProvider provider , InternetProtocolFamily ipFamily ) { this ( newSocket ( provider , ipFamily ) ) ; } public NioDatagramChannel ( DatagramChannel socket ) { super ( null , socket , SelectionKey . OP_READ ) ; config = new NioDatagramChannelConfig ( this , socket ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override public DatagramChannelConfig config ( ) { return config ; } @Override @SuppressWarnings ( <str> ) public boolean isActive ( ) { DatagramChannel ch = javaChannel ( ) ; return ch . isOpen ( ) & & ( config . getOption ( ChannelOption . DATAGRAM_CHANNEL_ACTIVE_ON_REGISTRATION ) & & isRegistered ( ) | | ch . socket ( ) . isBound ( ) ) ; } @Override public boolean isConnected ( ) { return javaChannel ( ) . isConnected ( ) ; } @Override protected DatagramChannel javaChannel ( ) { return ( DatagramChannel ) super . javaChannel ( ) ; } @Override protected SocketAddress localAddress0 ( ) { return javaChannel ( ) . socket ( ) . getLocalSocketAddress ( ) ; } @Override protected SocketAddress remoteAddress0 ( ) { return javaChannel ( ) . socket ( ) . getRemoteSocketAddress ( ) ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { javaChannel ( ) . socket ( ) . bind ( localAddress ) ; } @Override protected boolean doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { if ( localAddress ! = null ) { javaChannel ( ) . socket ( ) . bind ( localAddress ) ; } boolean success = false ; try { javaChannel ( ) . connect ( remoteAddress ) ; success = true ; return true ; } finally { if ( ! success ) { doClose ( ) ; } } } @Override protected void doFinishConnect ( ) throws Exception { throw new Error ( ) ; } @Override protected void doDisconnect ( ) throws Exception { javaChannel ( ) . disconnect ( ) ; } @Override protected void doClose ( ) throws Exception { javaChannel ( ) . close ( ) ; } @Override protected int doReadMessages ( List < Object > buf ) throws Exception { DatagramChannel ch = javaChannel ( ) ; DatagramChannelConfig config = config ( ) ; RecvByteBufAllocator . Handle allocHandle = unsafe ( ) . recvBufAllocHandle ( ) ; ByteBuf data = allocHandle . allocate ( config . getAllocator ( ) ) ; allocHandle . attemptedBytesRead ( data . writableBytes ( ) ) ; boolean free = true ; try { ByteBuffer nioData = data . internalNioBuffer ( data . writerIndex ( ) , data . writableBytes ( ) ) ; int pos = nioData . position ( ) ; InetSocketAddress remoteAddress = ( InetSocketAddress ) ch . receive ( nioData ) ; if ( remoteAddress = = null ) { return <int> ; } allocHandle . lastBytesRead ( nioData . position ( ) - pos ) ; buf . add ( new DatagramPacket ( data . writerIndex ( data . writerIndex ( ) + allocHandle . lastBytesRead ( ) ) , localAddress ( ) , remoteAddress ) ) ; free = false ; return <int> ; } catch ( Throwable cause ) { PlatformDependent . throwException ( cause ) ; return - <int> ; } finally { if ( free ) { data . release ( ) ; } } } @Override protected boolean doWriteMessage ( Object msg , ChannelOutboundBuffer in ) throws Exception { final SocketAddress remoteAddress ; final ByteBuf data ; if ( msg instanceof AddressedEnvelope ) { @SuppressWarnings ( <str> ) AddressedEnvelope < ByteBuf , SocketAddress > envelope = ( AddressedEnvelope < ByteBuf , SocketAddress > ) msg ; remoteAddress = envelope . recipient ( ) ; data = envelope . content ( ) ; } else { data = ( ByteBuf ) msg ; remoteAddress = null ; } final int dataLen = data . readableBytes ( ) ; if ( dataLen = = <int> ) { return true ; } final ByteBuffer nioData = data . internalNioBuffer ( data . readerIndex ( ) , dataLen ) ; final int writtenBytes ; if ( remoteAddress ! = null ) { writtenBytes = javaChannel ( ) . send ( nioData , remoteAddress ) ; } else { writtenBytes = javaChannel ( ) . write ( nioData ) ; } return writtenBytes > <int> ; } @Override protected Object filterOutboundMessage ( Object msg ) { if ( msg instanceof DatagramPacket ) { DatagramPacket p = ( DatagramPacket ) msg ; ByteBuf content = p . content ( ) ; if ( isSingleDirectBuffer ( content ) ) { return p ; } return new DatagramPacket ( newDirectBuffer ( p , content ) , p . recipient ( ) ) ; } if ( msg instanceof ByteBuf ) { ByteBuf buf = ( ByteBuf ) msg ; if ( isSingleDirectBuffer ( buf ) ) { return buf ; } return newDirectBuffer ( buf ) ; } if ( msg instanceof AddressedEnvelope ) { @SuppressWarnings ( <str> ) AddressedEnvelope < Object , SocketAddress > e = ( AddressedEnvelope < Object , SocketAddress > ) msg ; if ( e . content ( ) instanceof ByteBuf ) { ByteBuf content = ( ByteBuf ) e . content ( ) ; if ( isSingleDirectBuffer ( content ) ) { return e ; } return new DefaultAddressedEnvelope < ByteBuf , SocketAddress > ( newDirectBuffer ( e , content ) , e . recipient ( ) ) ; } } throw new UnsupportedOperationException ( <str> + StringUtil . simpleClassName ( msg ) + EXPECTED_TYPES ) ; } private static boolean isSingleDirectBuffer ( ByteBuf buf ) { return buf . isDirect ( ) & & buf . nioBufferCount ( ) = = <int> ; } @Override protected boolean continueOnWriteError ( ) { return true ; } @Override public InetSocketAddress localAddress ( ) { return ( InetSocketAddress ) super . localAddress ( ) ; } @Override public InetSocketAddress remoteAddress ( ) { return ( InetSocketAddress ) super . remoteAddress ( ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress ) { return joinGroup ( multicastAddress , newPromise ( ) ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress , ChannelPromise promise ) { try { return joinGroup ( multicastAddress , NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , null , promise ) ; } catch ( SocketException e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture joinGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { return joinGroup ( multicastAddress , networkInterface , newPromise ( ) ) ; } @Override public ChannelFuture joinGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface , ChannelPromise promise ) { return joinGroup ( multicastAddress . getAddress ( ) , networkInterface , null , promise ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { return joinGroup ( multicastAddress , networkInterface , source , newPromise ( ) ) ; } @Override public ChannelFuture joinGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , ChannelPromise promise ) { checkJavaVersion ( ) ; if ( multicastAddress = = null ) { throw new NullPointerException ( <str> ) ; } if ( networkInterface = = null ) { throw new NullPointerException ( <str> ) ; } try { MembershipKey key ; if ( source = = null ) { key = javaChannel ( ) . join ( multicastAddress , networkInterface ) ; } else { key = javaChannel ( ) . join ( multicastAddress , networkInterface , source ) ; } synchronized ( this ) { List < MembershipKey > keys = null ; if ( memberships = = null ) { memberships = new HashMap < InetAddress , List < MembershipKey > > ( ) ; } else { keys = memberships . get ( multicastAddress ) ; } if ( keys = = null ) { keys = new ArrayList < MembershipKey > ( ) ; memberships . put ( multicastAddress , keys ) ; } keys . add ( key ) ; } promise . setSuccess ( ) ; } catch ( Throwable e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress ) { return leaveGroup ( multicastAddress , newPromise ( ) ) ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress , ChannelPromise promise ) { try { return leaveGroup ( multicastAddress , NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , null , promise ) ; } catch ( SocketException e ) { promise . setFailure ( e ) ; } return promise ; } @Override public ChannelFuture leaveGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface ) { return leaveGroup ( multicastAddress , networkInterface , newPromise ( ) ) ; } @Override public ChannelFuture leaveGroup ( InetSocketAddress multicastAddress , NetworkInterface networkInterface , ChannelPromise promise ) { return leaveGroup ( multicastAddress . getAddress ( ) , networkInterface , null , promise ) ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source ) { return leaveGroup ( multicastAddress , networkInterface , source , newPromise ( ) ) ; } @Override public ChannelFuture leaveGroup ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress source , ChannelPromise promise ) { checkJavaVersion ( ) ; if ( multicastAddress = = null ) { throw new NullPointerException ( <str> ) ; } if ( networkInterface = = null ) { throw new NullPointerException ( <str> ) ; } synchronized ( this ) { if ( memberships ! = null ) { List < MembershipKey > keys = memberships . get ( multicastAddress ) ; if ( keys ! = null ) { Iterator < MembershipKey > keyIt = keys . iterator ( ) ; while ( keyIt . hasNext ( ) ) { MembershipKey key = keyIt . next ( ) ; if ( networkInterface . equals ( key . networkInterface ( ) ) ) { if ( source = = null & & key . sourceAddress ( ) = = null | | source ! = null & & source . equals ( key . sourceAddress ( ) ) ) { key . drop ( ) ; keyIt . remove ( ) ; } } } if ( keys . isEmpty ( ) ) { memberships . remove ( multicastAddress ) ; } } } } promise . setSuccess ( ) ; return promise ; } @Override public ChannelFuture block ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress sourceToBlock ) { return block ( multicastAddress , networkInterface , sourceToBlock , newPromise ( ) ) ; } @Override public ChannelFuture block ( InetAddress multicastAddress , NetworkInterface networkInterface , InetAddress sourceToBlock , ChannelPromise promise ) { checkJavaVersion ( ) ; if ( multicastAddress = = null ) { throw new NullPointerException ( <str> ) ; } if ( sourceToBlock = = null ) { throw new NullPointerException ( <str> ) ; } if ( networkInterface = = null ) { throw new NullPointerException ( <str> ) ; } synchronized ( this ) { if ( memberships ! = null ) { List < MembershipKey > keys = memberships . get ( multicastAddress ) ; for ( MembershipKey key : keys ) { if ( networkInterface . equals ( key . networkInterface ( ) ) ) { try { key . block ( sourceToBlock ) ; } catch ( IOException e ) { promise . setFailure ( e ) ; } } } } } promise . setSuccess ( ) ; return promise ; } @Override public ChannelFuture block ( InetAddress multicastAddress , InetAddress sourceToBlock ) { return block ( multicastAddress , sourceToBlock , newPromise ( ) ) ; } @Override public ChannelFuture block ( InetAddress multicastAddress , InetAddress sourceToBlock , ChannelPromise promise ) { try { return block ( multicastAddress , NetworkInterface . getByInetAddress ( localAddress ( ) . getAddress ( ) ) , sourceToBlock , promise ) ; } catch ( SocketException e ) { promise . setFailure ( e ) ; } return promise ; } @Override protected void setReadPending ( boolean readPending ) { super . setReadPending ( readPending ) ; } } 
