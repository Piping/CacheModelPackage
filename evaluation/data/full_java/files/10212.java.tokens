package com . google . common . io ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . StringReader ; import java . io . StringWriter ; import java . util . Random ; public class BaseEncodingBenchmark { private static final int INPUTS_COUNT = <hex> ; private static final int INPUTS_MASK = <hex> ; enum EncodingOption { BASE64 ( BaseEncoding . base64 ( ) ) , BASE64_URL ( BaseEncoding . base64Url ( ) ) , BASE32 ( BaseEncoding . base32 ( ) ) , BASE32_HEX ( BaseEncoding . base32Hex ( ) ) , BASE16 ( BaseEncoding . base16 ( ) ) ; final BaseEncoding encoding ; EncodingOption ( BaseEncoding encoding ) { this . encoding = encoding ; } } @Param EncodingOption encoding ; @Param ( { <str> , <str> , <str> } ) int n ; private final byte [ ] [ ] encodingInputs = new byte [ INPUTS_COUNT ] [ ] ; private final String [ ] decodingInputs = new String [ INPUTS_COUNT ] ; @BeforeExperiment public void setUp ( ) { Random rng = new Random ( ) ; for ( int i = <int> ; i < encodingInputs . length ; i + + ) { encodingInputs [ i ] = new byte [ n ] ; rng . nextBytes ( encodingInputs [ i ] ) ; decodingInputs [ i ] = encoding . encoding . encode ( encodingInputs [ i ] ) ; } } @Benchmark public int encode ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { tmp + = System . identityHashCode ( encoding . encoding . encode ( encodingInputs [ i & INPUTS_MASK ] ) ) ; } return tmp ; } @Benchmark public int decode ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { tmp + = System . identityHashCode ( encoding . encoding . decode ( decodingInputs [ i & INPUTS_MASK ] ) ) ; } return tmp ; } @Benchmark public int encodingStream ( int reps ) throws IOException { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { StringWriter target = new StringWriter ( <int> * n ) ; OutputStream encodingStream = encoding . encoding . encodingStream ( target ) ; encodingStream . write ( encodingInputs [ i & INPUTS_MASK ] ) ; encodingStream . close ( ) ; tmp + = target . getBuffer ( ) . length ( ) ; } return tmp ; } @Benchmark public int decodingStream ( int reps ) throws IOException { int tmp = <int> ; byte [ ] target = new byte [ n ] ; for ( int i = <int> ; i < reps ; i + + ) { StringReader source = new StringReader ( decodingInputs [ i & INPUTS_MASK ] ) ; InputStream decodingStream = encoding . encoding . decodingStream ( source ) ; decodingStream . read ( target ) ; decodingStream . close ( ) ; tmp + = target [ <int> ] ; } return tmp ; } } 
