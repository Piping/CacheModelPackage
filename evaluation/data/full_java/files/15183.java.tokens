package org . gradle . play . internal . twirl ; import com . google . common . collect . Lists ; import org . gradle . api . internal . file . RelativeFile ; import org . gradle . api . internal . tasks . SimpleWorkResult ; import org . gradle . api . tasks . WorkResult ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . scala . internal . reflect . ScalaMethod ; import org . gradle . scala . internal . reflect . ScalaOptionInvocationWrapper ; import java . io . File ; import java . io . Serializable ; import java . util . ArrayList ; public class TwirlCompiler implements Compiler < TwirlCompileSpec > , Serializable { private final VersionedTwirlCompilerAdapter adapter ; public TwirlCompiler ( VersionedTwirlCompilerAdapter adapter ) { this . adapter = adapter ; } public WorkResult execute ( TwirlCompileSpec spec ) { ArrayList < File > outputFiles = Lists . newArrayList ( ) ; try { ClassLoader cl = getClass ( ) . getClassLoader ( ) ; ScalaMethod compile = adapter . getCompileMethod ( cl ) ; Iterable < RelativeFile > sources = spec . getSources ( ) ; for ( RelativeFile sourceFile : sources ) { Object result = compile . invoke ( adapter . createCompileParameters ( cl , sourceFile . getFile ( ) , sourceFile . getBaseDir ( ) , spec . getDestinationDir ( ) , spec . isJavaProject ( ) ) ) ; ScalaOptionInvocationWrapper < File > maybeFile = new ScalaOptionInvocationWrapper < File > ( result ) ; if ( maybeFile . isDefined ( ) ) { outputFiles . add ( maybeFile . get ( ) ) ; } } } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } return new SimpleWorkResult ( ! outputFiles . isEmpty ( ) ) ; } public Object getDependencyNotation ( ) { return adapter . getDependencyNotation ( ) ; } public Iterable < String > getClassLoaderPackages ( ) { return adapter . getClassLoaderPackages ( ) ; } } 
