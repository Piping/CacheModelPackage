package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http2 . Http2Error . INTERNAL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static java . lang . Math . max ; import static java . lang . Math . min ; import java . util . ArrayDeque ; import java . util . Deque ; public final class UniformStreamByteDistributor implements StreamByteDistributor { static final int DEFAULT_MIN_ALLOCATION_CHUNK = <int> ; private final Http2Connection . PropertyKey stateKey ; private final Deque < State > queue = new ArrayDeque < State > ( <int> ) ; private int minAllocationChunk = DEFAULT_MIN_ALLOCATION_CHUNK ; private long totalStreamableBytes ; public UniformStreamByteDistributor ( Http2Connection connection ) { checkNotNull ( connection , <str> ) ; stateKey = connection . newKey ( ) ; Http2Stream connectionStream = connection . connectionStream ( ) ; connectionStream . setProperty ( stateKey , new State ( connectionStream ) ) ; connection . addListener ( new Http2ConnectionAdapter ( ) { @Override public void onStreamAdded ( Http2Stream stream ) { stream . setProperty ( stateKey , new State ( stream ) ) ; } @Override public void onStreamClosed ( Http2Stream stream ) { state ( stream ) . close ( ) ; } } ) ; } public void minAllocationChunk ( int minAllocationChunk ) { if ( minAllocationChunk < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . minAllocationChunk = minAllocationChunk ; } @Override public void updateStreamableBytes ( StreamState streamState ) { State state = state ( streamState . stream ( ) ) ; state . updateStreamableBytes ( streamState . streamableBytes ( ) , streamState . hasFrame ( ) ) ; } @Override public boolean distribute ( int maxBytes , Writer writer ) throws Http2Exception { checkNotNull ( writer , <str> ) ; final int size = queue . size ( ) ; if ( size = = <int> ) { return totalStreamableBytes > <int> ; } final int chunkSize = max ( minAllocationChunk , maxBytes / size ) ; State state = queue . pollFirst ( ) ; do { state . enqueued = false ; if ( state . streamableBytes > <int> & & maxBytes = = <int> ) { queue . addFirst ( state ) ; state . enqueued = true ; break ; } int chunk = min ( chunkSize , min ( maxBytes , state . streamableBytes ) ) ; maxBytes - = chunk ; state . write ( chunk , writer ) ; } while ( ( state = queue . pollFirst ( ) ) ! = null ) ; return totalStreamableBytes > <int> ; } private State state ( Http2Stream stream ) { return checkNotNull ( stream , <str> ) . getProperty ( stateKey ) ; } private final class State { final Http2Stream stream ; int streamableBytes ; boolean enqueued ; State ( Http2Stream stream ) { this . stream = stream ; } void updateStreamableBytes ( int newStreamableBytes , boolean hasFrame ) { assert hasFrame | | newStreamableBytes = = <int> ; int delta = newStreamableBytes - streamableBytes ; if ( delta ! = <int> ) { streamableBytes = newStreamableBytes ; totalStreamableBytes + = delta ; } if ( hasFrame ) { addToQueue ( ) ; } } void write ( int numBytes , Writer writer ) throws Http2Exception { int newStreamableBytes = streamableBytes - numBytes ; updateStreamableBytes ( newStreamableBytes , newStreamableBytes > <int> ) ; try { writer . write ( stream , numBytes ) ; } catch ( Throwable t ) { throw connectionError ( INTERNAL_ERROR , t , <str> ) ; } } void addToQueue ( ) { if ( ! enqueued ) { enqueued = true ; queue . addLast ( this ) ; } } void removeFromQueue ( ) { if ( enqueued ) { enqueued = false ; queue . remove ( this ) ; } } void close ( ) { removeFromQueue ( ) ; updateStreamableBytes ( <int> , false ) ; } } } 
