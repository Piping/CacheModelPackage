package org . nd4j . linalg . ops ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . Accumulation ; import org . nd4j . linalg . api . ops . IndexAccumulation ; import org . nd4j . linalg . api . ops . ScalarOp ; import org . nd4j . linalg . api . ops . TransformOp ; import org . nd4j . linalg . api . ops . exception . IllegalOpException ; import org . nd4j . linalg . api . ops . executioner . DefaultOpExecutioner ; import org . nd4j . linalg . api . ops . executioner . OpExecutioner ; import org . nd4j . linalg . api . ops . impl . accum . * ; import org . nd4j . linalg . api . ops . impl . accum . distances . EuclideanDistance ; import org . nd4j . linalg . api . ops . impl . indexaccum . IAMax ; import org . nd4j . linalg . api . ops . impl . indexaccum . IMax ; import org . nd4j . linalg . api . ops . impl . indexaccum . IMin ; import org . nd4j . linalg . api . ops . impl . scalar . * ; import org . nd4j . linalg . api . ops . impl . scalar . comparison . ScalarEquals ; import org . nd4j . linalg . api . ops . impl . scalar . comparison . ScalarGreaterThan ; import org . nd4j . linalg . api . ops . impl . scalar . comparison . ScalarLessThan ; import org . nd4j . linalg . api . ops . impl . scalar . comparison . ScalarSetValue ; import org . nd4j . linalg . api . ops . impl . transforms . * ; import org . nd4j . linalg . api . ops . impl . transforms . arithmetic . * ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . nd4j . linalg . ops . transforms . Transforms ; import org . nd4j . linalg . io . ClassPathResource ; import java . io . DataInputStream ; import java . lang . reflect . Constructor ; import java . util . ArrayList ; import java . util . List ; import static org . junit . Assert . assertArrayEquals ; import static org . junit . Assert . assertEquals ; public class OpExecutionerTestsC extends BaseNd4jTest { public OpExecutionerTestsC ( ) { } public OpExecutionerTestsC ( Nd4jBackend backend ) { super ( backend ) ; } public OpExecutionerTestsC ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } public OpExecutionerTestsC ( String name ) { super ( name ) ; } @Test public void testCosineSimilarity ( ) { INDArray vec1 = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> , <int> } ) ; INDArray vec2 = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> , <int> } ) ; double sim = Transforms . cosineSim ( vec1 , vec2 ) ; assertEquals ( getFailureMessage ( ) , <int> , sim , <float> ) ; } @Test public void testLog ( ) { INDArray log = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray transformed = Transforms . log ( log ) ; INDArray assertion = Nd4j . create ( new double [ ] { <float> , <float> , <float> , <float> , <float> , <float> } ) ; assertEquals ( assertion , transformed ) ; } @Test public void testNorm1AlongDimension ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray arrNorm1 = arr . norm2 ( <int> ) ; INDArray assertion = Nd4j . create ( new double [ ] { <float> , <float> } ) ; assertEquals ( assertion , arrNorm1 ) ; } @Test public void testEuclideanDistance ( ) { INDArray arr = Nd4j . create ( new double [ ] { <int> , <int> } ) ; INDArray arr2 = Nd4j . create ( new double [ ] { <int> , <int> } ) ; double result = Nd4j . getExecutioner ( ) . execAndReturn ( new EuclideanDistance ( arr , arr2 ) ) . currentResult ( ) . doubleValue ( ) ; assertEquals ( getFailureMessage ( ) , <float> , result , <float> ) ; } @Test public void testScalarMaxOp ( ) { INDArray scalarMax = Nd4j . linspace ( <int> , <int> , <int> ) . negi ( ) ; INDArray postMax = Nd4j . ones ( <int> ) ; Nd4j . getExecutioner ( ) . exec ( new ScalarMax ( scalarMax , <int> ) ) ; assertEquals ( getFailureMessage ( ) , scalarMax , postMax ) ; } @Test public void testSetRange ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; Nd4j . getExecutioner ( ) . exec ( new SetRange ( linspace , <int> , <int> ) ) ; for ( int i = <int> ; i < linspace . length ( ) ; i + + ) { double val = linspace . getDouble ( i ) ; assertTrue ( getFailureMessage ( ) , val > = <int> & & val < = <int> ) ; } INDArray linspace2 = Nd4j . linspace ( <int> , <int> , <int> ) ; Nd4j . getExecutioner ( ) . exec ( new SetRange ( linspace2 , <int> , <int> ) ) ; for ( int i = <int> ; i < linspace2 . length ( ) ; i + + ) { double val = linspace2 . getDouble ( i ) ; assertTrue ( getFailureMessage ( ) , val > = <int> & & val < = <int> ) ; } } @Test public void testAlongDimension ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; Sigmoid sigmoid = new Sigmoid ( arr . dup ( ) ) ; Nd4j . getExecutioner ( ) . exec ( sigmoid , <int> ) ; INDArray sigmoidREsult = Transforms . sigmoid ( arr ) ; assertEquals ( sigmoidREsult , sigmoid . z ( ) ) ; } @Test public void testNormMax ( ) { INDArray arr = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } ) ; double normMax = Nd4j . getExecutioner ( ) . execAndReturn ( new NormMax ( arr ) ) . currentResult ( ) . doubleValue ( ) ; assertEquals ( getFailureMessage ( ) , <int> , normMax , <float> ) ; } @Test public void testNorm2 ( ) { INDArray arr = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } ) ; double norm2 = Nd4j . getExecutioner ( ) . execAndReturn ( new Norm2 ( arr ) ) . currentResult ( ) . doubleValue ( ) ; assertEquals ( getFailureMessage ( ) , <float> , norm2 , <float> ) ; } @Test public void testAdd ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray x = Nd4j . ones ( <int> ) ; INDArray xDup = x . dup ( ) ; INDArray solution = Nd4j . valueArrayOf ( <int> , <float> ) ; opExecutioner . exec ( new AddOp ( x , xDup , x ) ) ; assertEquals ( getFailureMessage ( ) , solution , x ) ; } @Test public void testMul ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray x = Nd4j . ones ( <int> ) ; INDArray xDup = x . dup ( ) ; INDArray solution = Nd4j . valueArrayOf ( <int> , <float> ) ; opExecutioner . exec ( new MulOp ( x , xDup , x ) ) ; assertEquals ( solution , x ) ; } @Test public void testExecutioner ( ) throws IllegalOpException { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray x = Nd4j . ones ( <int> ) ; INDArray xDup = x . dup ( ) ; INDArray solution = Nd4j . valueArrayOf ( <int> , <float> ) ; opExecutioner . exec ( new AddOp ( x , xDup , x ) ) ; assertEquals ( getFailureMessage ( ) , solution , x ) ; Sum acc = new Sum ( x . dup ( ) ) ; opExecutioner . exec ( acc ) ; assertEquals ( getFailureMessage ( ) , <float> , acc . currentResult ( ) . doubleValue ( ) , <float> ) ; Prod prod = new Prod ( x . dup ( ) ) ; opExecutioner . exec ( prod ) ; assertEquals ( getFailureMessage ( ) , <float> , prod . currentResult ( ) . doubleValue ( ) , <float> ) ; } @Test public void testMaxMin ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray x = Nd4j . linspace ( <int> , <int> , <int> ) ; Max max = new Max ( x ) ; opExecutioner . exec ( max ) ; assertEquals ( <int> , max . currentResult ( ) . doubleValue ( ) , <float> ) ; Min min = new Min ( x ) ; opExecutioner . exec ( min ) ; assertEquals ( <int> , min . currentResult ( ) . doubleValue ( ) , <float> ) ; } @Test public void testProd ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; Prod prod = new Prod ( linspace ) ; double prod2 = Nd4j . getExecutioner ( ) . execAndReturn ( prod ) . currentResult ( ) . doubleValue ( ) ; assertEquals ( <int> , prod2 , <float> ) ; } @Test public void testSum ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; Sum sum = new Sum ( linspace ) ; double sum2 = Nd4j . getExecutioner ( ) . execAndReturn ( sum ) . currentResult ( ) . doubleValue ( ) ; assertEquals ( <int> , sum2 , <float> ) ; INDArray matrixSums = linspace . reshape ( <int> , <int> ) ; INDArray rowSums = matrixSums . sum ( <int> ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , rowSums ) ; } @Test public void testDescriptiveStatsDouble ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray x = Nd4j . linspace ( <int> , <int> , <int> ) ; Mean mean = new Mean ( x ) ; opExecutioner . exec ( mean ) ; assertEquals ( <float> , mean . currentResult ( ) . doubleValue ( ) , <float> ) ; Variance variance = new Variance ( x . dup ( ) , true ) ; opExecutioner . exec ( variance ) ; assertEquals ( getFailureMessage ( ) , <float> , variance . currentResult ( ) . doubleValue ( ) , <float> ) ; } @Test public void testBias ( ) { INDArray bias = Nd4j . linspace ( <int> , <int> , <int> ) ; Bias biaOp = new Bias ( bias ) ; Nd4j . getExecutioner ( ) . exec ( biaOp ) ; assertEquals ( <float> , biaOp . currentResult ( ) . doubleValue ( ) , <float> ) ; } @Test public void testIamax ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; assertEquals ( getFailureMessage ( ) , <int> , Nd4j . getBlasWrapper ( ) . iamax ( linspace ) ) ; int iamax = Nd4j . getExecutioner ( ) . execAndReturn ( new IAMax ( linspace ) ) . getFinalResult ( ) ; assertEquals ( <int> , iamax ) ; } @Test public void testDescriptiveStats ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray x = Nd4j . linspace ( <int> , <int> , <int> ) ; Mean mean = new Mean ( x ) ; opExecutioner . exec ( mean ) ; assertEquals ( getFailureMessage ( ) , <float> , mean . currentResult ( ) . doubleValue ( ) , <float> ) ; Variance variance = new Variance ( x . dup ( ) , true ) ; opExecutioner . exec ( variance ) ; assertEquals ( getFailureMessage ( ) , <float> , variance . currentResult ( ) . doubleValue ( ) , <float> ) ; } @Test public void testRowSoftmax ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) ; SoftMax softMax = new SoftMax ( arr ) ; opExecutioner . exec ( softMax ) ; assertEquals ( getFailureMessage ( ) , <float> , softMax . z ( ) . sumNumber ( ) . doubleValue ( ) , <float> ) ; } @Test public void testRowLogSoftMax ( ) { int [ ] [ ] shapes = new int [ ] [ ] { { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , { <int> , <int> } } ; double eps = <float> ; for ( int [ ] shape : shapes ) { INDArray orig = Nd4j . rand ( shape ) ; INDArray orig1 = orig . dup ( ) ; INDArray orig2 = orig . dup ( ) ; Nd4j . getExecutioner ( ) . exec ( new SoftMax ( orig1 ) , <int> ) ; Nd4j . getExecutioner ( ) . exec ( new Log ( orig1 ) ) ; Nd4j . getExecutioner ( ) . exec ( new LogSoftMax ( orig2 ) , <int> ) ; for ( int i = <int> ; i < shape [ <int> ] ; i + + ) { for ( int j = <int> ; j < shape [ <int> ] ; j + + ) { double o1 = orig1 . getDouble ( i ) ; double o2 = orig2 . getDouble ( i ) ; if ( Math . abs ( o1 - o2 ) > eps ) { System . out . println ( ) ; } assertEquals ( o1 , o2 , eps ) ; } } } } @Test public void testPow ( ) { INDArray oneThroughSix = Nd4j . linspace ( <int> , <int> , <int> ) ; Pow pow = new Pow ( oneThroughSix , <int> ) ; Nd4j . getExecutioner ( ) . exec ( pow ) ; INDArray answer = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> , <int> , <int> } ) ; assertEquals ( getFailureMessage ( ) , answer , pow . z ( ) ) ; } @Test public void testComparisonOps ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray ones = Nd4j . ones ( <int> ) ; INDArray zeros = Nd4j . zeros ( <int> ) ; assertEquals ( ones , Nd4j . getExecutioner ( ) . execAndReturn ( new ScalarGreaterThan ( linspace , <int> ) ) ) ; assertEquals ( zeros , Nd4j . getExecutioner ( ) . execAndReturn ( new ScalarGreaterThan ( linspace , <int> ) ) ) ; assertEquals ( zeros , Nd4j . getExecutioner ( ) . execAndReturn ( new ScalarLessThan ( linspace , <int> ) ) ) ; assertEquals ( ones , Nd4j . getExecutioner ( ) . execAndReturn ( new ScalarLessThan ( linspace , <int> ) ) ) ; } @Test public void testScalarArithmetic ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray plusOne = Nd4j . linspace ( <int> , <int> , <int> ) ; Nd4j . getExecutioner ( ) . exec ( new ScalarAdd ( linspace , <int> ) ) ; assertEquals ( plusOne , linspace ) ; } @Test public void testNegativeNumbersSoftmax ( ) throws Exception { Nd4j . MAX_ELEMENTS_PER_SLICE = Integer . MAX_VALUE ; Nd4j . MAX_SLICES_TO_PRINT = Integer . MAX_VALUE ; DataInputStream dis = new DataInputStream ( new ClassPathResource ( <str> ) . getInputStream ( ) ) ; INDArray read = Nd4j . read ( dis ) ; dis . close ( ) ; INDArray max1 = read . max ( <int> ) ; SoftMax softMax = new SoftMax ( read ) ; softMax . exec ( <int> ) ; INDArray z = softMax . z ( ) ; INDArray zSums = z . sum ( <int> ) ; assertEquals ( zSums . length ( ) , zSums . sumNumber ( ) . doubleValue ( ) , <float> ) ; } @Test public void testDimensionMax ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; int axis = <int> ; INDArray row = linspace . slice ( axis ) ; Max max = new Max ( row ) ; double max2 = Nd4j . getExecutioner ( ) . execAndReturn ( max ) . currentResult ( ) . doubleValue ( ) ; assertEquals ( <float> , max2 , <float> ) ; Min min = new Min ( row ) ; double min2 = Nd4j . getExecutioner ( ) . execAndReturn ( min ) . currentResult ( ) . doubleValue ( ) ; assertEquals ( <float> , min2 , <float> ) ; Max matrixMax = new Max ( linspace ) ; INDArray exec2 = Nd4j . getExecutioner ( ) . exec ( matrixMax , <int> ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , exec2 ) ; } @Test public void testStridedLog ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray slice = arr . slice ( <int> ) ; Log exp = new Log ( slice ) ; opExecutioner . exec ( exp ) ; INDArray assertion = Nd4j . create ( Nd4j . createBuffer ( new double [ ] { <float> , <float> , <float> } ) ) ; assertEquals ( getFailureMessage ( ) , assertion , slice ) ; } @Test public void testStridedExp ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray slice = arr . slice ( <int> ) ; float [ ] expected = new float [ slice . length ( ) ] ; for ( int i = <int> ; i < slice . length ( ) ; i + + ) expected [ i ] = ( float ) Math . exp ( slice . getDouble ( i ) ) ; Exp exp = new Exp ( slice ) ; opExecutioner . exec ( exp ) ; assertEquals ( getFailureMessage ( ) , Nd4j . create ( Nd4j . createBuffer ( expected ) ) , slice ) ; } @Test public void testSoftMax ( ) { OpExecutioner opExecutioner = Nd4j . getExecutioner ( ) ; INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) ; SoftMax softMax = new SoftMax ( arr ) ; opExecutioner . exec ( softMax ) ; assertEquals ( getFailureMessage ( ) , <float> , softMax . z ( ) . sumNumber ( ) . doubleValue ( ) , <float> ) ; INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; SoftMax softmax = new SoftMax ( linspace . dup ( ) ) ; Nd4j . getExecutioner ( ) . exec ( softmax ) ; assertEquals ( linspace . rows ( ) , softmax . z ( ) . sumNumber ( ) . doubleValue ( ) , <float> ) ; } @Test public void testDimensionSoftMax ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; SoftMax max = new SoftMax ( linspace ) ; Nd4j . getExecutioner ( ) . exec ( max , <int> ) ; linspace . assign ( max . z ( ) ) ; assertEquals ( getFailureMessage ( ) , linspace . getRow ( <int> ) . sumNumber ( ) . doubleValue ( ) , <float> , <float> ) ; } @Test public void testColumnMean ( ) { INDArray twoByThree = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray columnMean = twoByThree . mean ( <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <int> , <int> } ) ; assertEquals ( assertion , columnMean ) ; } @Test public void testColumnVar ( ) { INDArray twoByThree = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray columnStd = twoByThree . var ( <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <int> f , <int> f , <int> f , <int> f } ) ; assertEquals ( assertion , columnStd ) ; } @Test public void testColumnStd ( ) { Nd4j . MAX_ELEMENTS_PER_SLICE = Integer . MAX_VALUE ; Nd4j . MAX_SLICES_TO_PRINT = Integer . MAX_VALUE ; INDArray twoByThree = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray columnStd = twoByThree . std ( <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } ) ; assertEquals ( assertion , columnStd ) ; } @Test public void testDim1 ( ) { INDArray sum = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray same = sum . dup ( ) ; assertEquals ( same . sum ( <int> ) , sum ) ; } @Test public void testIMax ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) ; IMax imax = new IMax ( arr ) ; assertEquals ( <int> , ( ( IndexAccumulation ) Nd4j . getExecutioner ( ) . exec ( imax ) ) . getFinalResult ( ) ) ; arr . muli ( - <int> ) ; imax = new IMax ( arr ) ; int maxIdx = ( ( IndexAccumulation ) Nd4j . getExecutioner ( ) . exec ( imax ) ) . getFinalResult ( ) ; assertEquals ( <int> , maxIdx ) ; } @Test public void testIMin ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) ; IMin imin = new IMin ( arr ) ; assertEquals ( <int> , ( ( IndexAccumulation ) Nd4j . getExecutioner ( ) . exec ( imin ) ) . getFinalResult ( ) ) ; arr . muli ( - <int> ) ; imin = new IMin ( arr ) ; int minIdx = ( ( IndexAccumulation ) Nd4j . getExecutioner ( ) . exec ( imin ) ) . getFinalResult ( ) ; assertEquals ( <int> , minIdx ) ; } @Test public void testMeanSumSimple ( ) { System . out . println ( <str> ) ; INDArray arr = Nd4j . ones ( <int> , <int> , <int> ) ; assertEquals ( Nd4j . ones ( <int> ) , arr . mean ( <int> , <int> ) ) ; assertEquals ( Nd4j . ones ( <int> ) . muli ( <int> ) , arr . sum ( <int> , <int> ) ) ; System . out . println ( <str> ) ; INDArray arr4 = Nd4j . ones ( <int> , <int> , <int> , <int> ) ; INDArray arr4m = arr4 . mean ( <int> , <int> ) ; INDArray arr4s = arr4 . sum ( <int> , <int> ) ; for ( int i = <int> ; i < arr4m . length ( ) ; i + + ) assertEquals ( arr4m . getDouble ( i ) , <int> , <float> ) ; for ( int i = <int> ; i < arr4s . length ( ) ; i + + ) assertEquals ( arr4s . getDouble ( i ) , <int> , <float> ) ; System . out . println ( <str> ) ; INDArray arr5 = Nd4j . ones ( <int> , <int> , <int> , <int> , <int> ) ; INDArray arr5m = arr5 . mean ( <int> , <int> ) ; INDArray arr5s = arr5 . sum ( <int> , <int> ) ; for ( int i = <int> ; i < arr5m . length ( ) ; i + + ) assertEquals ( arr5m . getDouble ( i ) , <int> , <float> ) ; for ( int i = <int> ; i < arr5s . length ( ) ; i + + ) assertEquals ( arr5s . getDouble ( i ) , <int> , <float> ) ; System . out . println ( <str> ) ; INDArray arr6 = Nd4j . ones ( <int> , <int> , <int> , <int> , <int> , <int> ) ; INDArray arr6m = arr6 . mean ( <int> , <int> ) ; INDArray arr6s = arr6 . sum ( <int> , <int> ) ; for ( int i = <int> ; i < arr6m . length ( ) ; i + + ) assertEquals ( arr6m . getDouble ( i ) , <int> , <float> ) ; for ( int i = <int> ; i < arr6s . length ( ) ; i + + ) assertEquals ( arr6s . getDouble ( i ) , <int> , <float> ) ; } @Test public void testStdev ( ) { INDArray arr = Nd4j . create ( new float [ ] { <float> , <float> , <float> } , new int [ ] { <int> , <int> } , ordering ( ) ) ; double stdev = arr . stdNumber ( ) . doubleValue ( ) ; double stdev2 = arr . std ( <int> ) . getDouble ( <int> ) ; assertEquals ( stdev , stdev2 , <float> ) ; double exp = <float> ; assertEquals ( exp , stdev , <float> ) ; } @Test public void testVariance ( ) { INDArray arr = Nd4j . create ( new float [ ] { <float> , <float> , <float> } , new int [ ] { <int> , <int> } , ordering ( ) ) ; double var = arr . varNumber ( ) . doubleValue ( ) ; INDArray temp = arr . var ( <int> ) ; double var2 = arr . var ( <int> ) . getDouble ( <int> ) ; assertEquals ( var , var2 , <float> ) ; double exp = <float> ; assertEquals ( exp , var , <float> ) ; } @Override public char ordering ( ) { return <str> ; } } 
