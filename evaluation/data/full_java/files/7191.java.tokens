package org . elasticsearch . search . aggregations . bucket . histogram ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . bucket . MultiBucketsAggregation ; import java . io . IOException ; import java . util . Comparator ; class InternalOrder extends Histogram . Order { final byte id ; final String key ; final boolean asc ; final Comparator < InternalHistogram . Bucket > comparator ; InternalOrder ( byte id , String key , boolean asc , Comparator < InternalHistogram . Bucket > comparator ) { this . id = id ; this . key = key ; this . asc = asc ; this . comparator = comparator ; } byte id ( ) { return id ; } String key ( ) { return key ; } boolean asc ( ) { return asc ; } @Override Comparator < InternalHistogram . Bucket > comparator ( ) { return comparator ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { return builder . startObject ( ) . field ( key , asc ? <str> : <str> ) . endObject ( ) ; } static class Aggregation extends InternalOrder { static final byte ID = <int> ; Aggregation ( String key , boolean asc ) { super ( ID , key , asc , new MultiBucketsAggregation . Bucket . SubAggregationComparator < InternalHistogram . Bucket > ( key , asc ) ) ; } private static String key ( String aggName , String valueName ) { return ( valueName = = null ) ? aggName : aggName + <str> + valueName ; } } static class Streams { public static void writeOrder ( InternalOrder order , StreamOutput out ) throws IOException { out . writeByte ( order . id ( ) ) ; if ( order instanceof InternalOrder . Aggregation ) { out . writeBoolean ( order . asc ( ) ) ; out . writeString ( order . key ( ) ) ; } } public static InternalOrder readOrder ( StreamInput in ) throws IOException { byte id = in . readByte ( ) ; switch ( id ) { case <int> : return ( InternalOrder ) Histogram . Order . KEY_ASC ; case <int> : return ( InternalOrder ) Histogram . Order . KEY_DESC ; case <int> : return ( InternalOrder ) Histogram . Order . COUNT_ASC ; case <int> : return ( InternalOrder ) Histogram . Order . COUNT_DESC ; case <int> : boolean asc = in . readBoolean ( ) ; String key = in . readString ( ) ; return new InternalOrder . Aggregation ( key , asc ) ; default : throw new RuntimeException ( <str> ) ; } } } } 
