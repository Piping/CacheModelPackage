package org . elasticsearch . action . support . replication ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ReplicationResponse ; import org . elasticsearch . action . UnavailableShardsException ; import org . elasticsearch . action . WriteConsistencyLevel ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . TransportAction ; import org . elasticsearch . action . support . TransportActions ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateObserver ; import org . elasticsearch . cluster . action . index . MappingUpdatedAction ; import org . elasticsearch . cluster . action . shard . ShardStateAction ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . lease . Releasable ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . engine . VersionConflictEngineException ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . translog . Translog ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . node . NodeClosedException ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . function . Supplier ; public abstract class TransportReplicationAction < Request extends ReplicationRequest , ReplicaRequest extends ReplicationRequest , Response extends ReplicationResponse > extends TransportAction < Request , Response > { public static final String SHARD_FAILURE_TIMEOUT = <str> ; protected final TransportService transportService ; protected final ClusterService clusterService ; protected final IndicesService indicesService ; protected final ShardStateAction shardStateAction ; protected final WriteConsistencyLevel defaultWriteConsistencyLevel ; protected final TransportRequestOptions transportOptions ; protected final MappingUpdatedAction mappingUpdatedAction ; private final TimeValue shardFailedTimeout ; final String transportReplicaAction ; final String transportPrimaryAction ; final String executor ; final boolean checkWriteConsistency ; protected TransportReplicationAction ( Settings settings , String actionName , TransportService transportService , ClusterService clusterService , IndicesService indicesService , ThreadPool threadPool , ShardStateAction shardStateAction , MappingUpdatedAction mappingUpdatedAction , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , Supplier < Request > request , Supplier < ReplicaRequest > replicaRequest , String executor ) { super ( settings , actionName , threadPool , actionFilters , indexNameExpressionResolver ) ; this . transportService = transportService ; this . clusterService = clusterService ; this . indicesService = indicesService ; this . shardStateAction = shardStateAction ; this . mappingUpdatedAction = mappingUpdatedAction ; this . transportPrimaryAction = actionName + <str> ; this . transportReplicaAction = actionName + <str> ; this . executor = executor ; this . checkWriteConsistency = checkWriteConsistency ( ) ; transportService . registerRequestHandler ( actionName , request , ThreadPool . Names . SAME , new OperationTransportHandler ( ) ) ; transportService . registerRequestHandler ( transportPrimaryAction , request , executor , new PrimaryOperationTransportHandler ( ) ) ; transportService . registerRequestHandler ( transportReplicaAction , replicaRequest , executor , true , new ReplicaOperationTransportHandler ( ) ) ; this . transportOptions = transportOptions ( ) ; this . defaultWriteConsistencyLevel = WriteConsistencyLevel . fromString ( settings . get ( <str> , <str> ) ) ; shardFailedTimeout = settings . getAsTime ( SHARD_FAILURE_TIMEOUT , null ) ; } @Override protected void doExecute ( Request request , ActionListener < Response > listener ) { new ReroutePhase ( request , listener ) . run ( ) ; } protected abstract Response newResponseInstance ( ) ; protected void resolveRequest ( MetaData metaData , String concreteIndex , Request request ) { } protected abstract Tuple < Response , ReplicaRequest > shardOperationOnPrimary ( MetaData metaData , Request shardRequest ) throws Throwable ; protected abstract void shardOperationOnReplica ( ReplicaRequest shardRequest ) ; protected boolean checkWriteConsistency ( ) { return true ; } protected ClusterBlockLevel globalBlockLevel ( ) { return ClusterBlockLevel . WRITE ; } protected ClusterBlockLevel indexBlockLevel ( ) { return ClusterBlockLevel . WRITE ; } protected boolean resolveIndex ( ) { return true ; } protected TransportRequestOptions transportOptions ( ) { return TransportRequestOptions . EMPTY ; } protected boolean retryPrimaryException ( Throwable e ) { return e . getClass ( ) = = RetryOnPrimaryException . class | | TransportActions . isShardNotAvailableException ( e ) ; } protected boolean ignoreReplicaException ( Throwable e ) { if ( TransportActions . isShardNotAvailableException ( e ) ) { return true ; } if ( isConflictException ( e ) ) { return true ; } return false ; } protected boolean isConflictException ( Throwable e ) { Throwable cause = ExceptionsHelper . unwrapCause ( e ) ; if ( cause instanceof VersionConflictEngineException ) { return true ; } return false ; } protected static class WriteResult < T extends ReplicationResponse > { public final T response ; public final Translog . Location location ; public WriteResult ( T response , Translog . Location location ) { this . response = response ; this . location = location ; } @SuppressWarnings ( <str> ) public < T extends ReplicationResponse > T response ( ) { response . setShardInfo ( new ReplicationResponse . ShardInfo ( ) ) ; return ( T ) response ; } } class OperationTransportHandler implements TransportRequestHandler < Request > { @Override public void messageReceived ( final Request request , final TransportChannel channel ) throws Exception { execute ( request , new ActionListener < Response > ( ) { @Override public void onResponse ( Response result ) { try { channel . sendResponse ( result ) ; } catch ( Throwable e ) { onFailure ( e ) ; } } @Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( e ) ; } catch ( Throwable e1 ) { logger . warn ( <str> + actionName , e1 ) ; } } } ) ; } } class PrimaryOperationTransportHandler implements TransportRequestHandler < Request > { @Override public void messageReceived ( final Request request , final TransportChannel channel ) throws Exception { new PrimaryPhase ( request , channel ) . run ( ) ; } } class ReplicaOperationTransportHandler implements TransportRequestHandler < ReplicaRequest > { @Override public void messageReceived ( final ReplicaRequest request , final TransportChannel channel ) throws Exception { new AsyncReplicaAction ( request , channel ) . run ( ) ; } } public static class RetryOnReplicaException extends ElasticsearchException { public RetryOnReplicaException ( ShardId shardId , String msg ) { super ( msg ) ; setShard ( shardId ) ; } public RetryOnReplicaException ( StreamInput in ) throws IOException { super ( in ) ; } } private final class AsyncReplicaAction extends AbstractRunnable { private final ReplicaRequest request ; private final TransportChannel channel ; private final ClusterStateObserver observer = new ClusterStateObserver ( clusterService , null , logger ) ; AsyncReplicaAction ( ReplicaRequest request , TransportChannel channel ) { this . request = request ; this . channel = channel ; } @Override public void onFailure ( Throwable t ) { if ( t instanceof RetryOnReplicaException ) { logger . trace ( <str> , t , actionName , request ) ; observer . waitForNextChange ( new ClusterStateObserver . Listener ( ) { @Override public void onNewClusterState ( ClusterState state ) { threadPool . executor ( executor ) . execute ( AsyncReplicaAction . this ) ; } @Override public void onClusterServiceClose ( ) { responseWithFailure ( new NodeClosedException ( clusterService . localNode ( ) ) ) ; } @Override public void onTimeout ( TimeValue timeout ) { throw new AssertionError ( <str> ) ; } } ) ; } else { try { failReplicaIfNeeded ( t ) ; } catch ( Throwable unexpected ) { logger . error ( <str> , unexpected , request . shardId ( ) . id ( ) ) ; } finally { responseWithFailure ( t ) ; } } } private void failReplicaIfNeeded ( Throwable t ) { String index = request . shardId ( ) . getIndex ( ) ; int shardId = request . shardId ( ) . id ( ) ; logger . trace ( <str> , t , index , shardId , actionName , request ) ; if ( ignoreReplicaException ( t ) = = false ) { IndexService indexService = indicesService . indexService ( index ) ; if ( indexService = = null ) { logger . debug ( <str> , index , shardId ) ; return ; } IndexShard indexShard = indexService . getShardOrNull ( shardId ) ; if ( indexShard = = null ) { logger . debug ( <str> , index , shardId ) ; return ; } indexShard . failShard ( actionName + <str> , t ) ; } } protected void responseWithFailure ( Throwable t ) { try { channel . sendResponse ( t ) ; } catch ( IOException responseException ) { logger . warn ( <str> + transportReplicaAction + <str> , responseException ) ; logger . warn ( <str> , t ) ; } } @Override protected void doRun ( ) throws Exception { assert request . shardId ( ) ! = null : <str> ; try ( Releasable ignored = getIndexShardOperationsCounter ( request . shardId ( ) ) ) { shardOperationOnReplica ( request ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , transportReplicaAction , request . shardId ( ) , request ) ; } } channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } public static class RetryOnPrimaryException extends ElasticsearchException { public RetryOnPrimaryException ( ShardId shardId , String msg ) { super ( msg ) ; setShard ( shardId ) ; } public RetryOnPrimaryException ( StreamInput in ) throws IOException { super ( in ) ; } } final class ReroutePhase extends AbstractRunnable { private final ActionListener < Response > listener ; private final Request request ; private final ClusterStateObserver observer ; private final AtomicBoolean finished = new AtomicBoolean ( ) ; ReroutePhase ( Request request , ActionListener < Response > listener ) { this . request = request ; this . listener = listener ; this . observer = new ClusterStateObserver ( clusterService , request . timeout ( ) , logger ) ; } @Override public void onFailure ( Throwable e ) { finishWithUnexpectedFailure ( e ) ; } @Override protected void doRun ( ) { final ClusterState state = observer . observedState ( ) ; ClusterBlockException blockException = state . blocks ( ) . globalBlockedException ( globalBlockLevel ( ) ) ; if ( blockException ! = null ) { handleBlockException ( blockException ) ; return ; } final String concreteIndex = resolveIndex ( ) ? indexNameExpressionResolver . concreteSingleIndex ( state , request ) : request . index ( ) ; blockException = state . blocks ( ) . indexBlockedException ( indexBlockLevel ( ) , concreteIndex ) ; if ( blockException ! = null ) { handleBlockException ( blockException ) ; return ; } resolveRequest ( state . metaData ( ) , concreteIndex , request ) ; assert request . shardId ( ) ! = null : <str> ; IndexShardRoutingTable indexShard = state . getRoutingTable ( ) . shardRoutingTable ( request . shardId ( ) . getIndex ( ) , request . shardId ( ) . id ( ) ) ; final ShardRouting primary = indexShard . primaryShard ( ) ; if ( primary = = null | | primary . active ( ) = = false ) { logger . trace ( <str> , request . shardId ( ) , actionName , request , state . version ( ) ) ; retryBecauseUnavailable ( request . shardId ( ) , <str> ) ; return ; } if ( state . nodes ( ) . nodeExists ( primary . currentNodeId ( ) ) = = false ) { logger . trace ( <str> , request . shardId ( ) , primary . currentNodeId ( ) , actionName , request , state . version ( ) ) ; retryBecauseUnavailable ( request . shardId ( ) , <str> ) ; return ; } final DiscoveryNode node = state . nodes ( ) . get ( primary . currentNodeId ( ) ) ; if ( primary . currentNodeId ( ) . equals ( state . nodes ( ) . localNodeId ( ) ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , transportPrimaryAction , request . shardId ( ) , request , state . version ( ) , primary . currentNodeId ( ) ) ; } performAction ( node , transportPrimaryAction , true ) ; } else { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , actionName , request . shardId ( ) , request , state . version ( ) , primary . currentNodeId ( ) ) ; } performAction ( node , actionName , false ) ; } } private void handleBlockException ( ClusterBlockException blockException ) { if ( blockException . retryable ( ) ) { logger . trace ( <str> , blockException . getMessage ( ) ) ; retry ( blockException ) ; } else { finishAsFailed ( blockException ) ; } } private void performAction ( final DiscoveryNode node , final String action , final boolean isPrimaryAction ) { transportService . sendRequest ( node , action , request , transportOptions , new BaseTransportResponseHandler < Response > ( ) { @Override public Response newInstance ( ) { return newResponseInstance ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } @Override public void handleResponse ( Response response ) { finishOnSuccess ( response ) ; } @Override public void handleException ( TransportException exp ) { try { if ( exp . unwrapCause ( ) instanceof ConnectTransportException | | exp . unwrapCause ( ) instanceof NodeClosedException | | ( isPrimaryAction & & retryPrimaryException ( exp . unwrapCause ( ) ) ) ) { logger . trace ( <str> , exp , node . id ( ) , request ) ; retry ( exp ) ; } else { finishAsFailed ( exp ) ; } } catch ( Throwable t ) { finishWithUnexpectedFailure ( t ) ; } } } ) ; } void retry ( Throwable failure ) { assert failure ! = null ; if ( observer . isTimedOut ( ) ) { finishAsFailed ( failure ) ; return ; } observer . waitForNextChange ( new ClusterStateObserver . Listener ( ) { @Override public void onNewClusterState ( ClusterState state ) { run ( ) ; } @Override public void onClusterServiceClose ( ) { finishAsFailed ( new NodeClosedException ( clusterService . localNode ( ) ) ) ; } @Override public void onTimeout ( TimeValue timeout ) { run ( ) ; } } ) ; } void finishAsFailed ( Throwable failure ) { if ( finished . compareAndSet ( false , true ) ) { logger . trace ( <str> , failure , actionName , request ) ; listener . onFailure ( failure ) ; } else { assert false : <str> ; } } void finishWithUnexpectedFailure ( Throwable failure ) { logger . warn ( <str> , failure , actionName , request ) ; if ( finished . compareAndSet ( false , true ) ) { listener . onFailure ( failure ) ; } else { assert false : <str> ; } } void finishOnSuccess ( Response response ) { if ( finished . compareAndSet ( false , true ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , actionName , request ) ; } listener . onResponse ( response ) ; } else { assert false : <str> ; } } void retryBecauseUnavailable ( ShardId shardId , String message ) { retry ( new UnavailableShardsException ( shardId , <str> , message , request . timeout ( ) , request ) ) ; } } final class PrimaryPhase extends AbstractRunnable { private final Request request ; private final TransportChannel channel ; private final ClusterState state ; private final AtomicBoolean finished = new AtomicBoolean ( ) ; private Releasable indexShardReference ; PrimaryPhase ( Request request , TransportChannel channel ) { this . state = clusterService . state ( ) ; this . request = request ; this . channel = channel ; } @Override public void onFailure ( Throwable e ) { finishAsFailed ( e ) ; } @Override protected void doRun ( ) throws Exception { assert request . shardId ( ) ! = null : <str> ; final ShardId shardId = request . shardId ( ) ; final String writeConsistencyFailure = checkWriteConsistency ( shardId ) ; if ( writeConsistencyFailure ! = null ) { finishBecauseUnavailable ( shardId , writeConsistencyFailure ) ; return ; } final ReplicationPhase replicationPhase ; try { indexShardReference = getIndexShardOperationsCounter ( shardId ) ; Tuple < Response , ReplicaRequest > primaryResponse = shardOperationOnPrimary ( state . metaData ( ) , request ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , transportPrimaryAction , shardId , request , state . version ( ) ) ; } replicationPhase = new ReplicationPhase ( primaryResponse . v2 ( ) , primaryResponse . v1 ( ) , shardId , channel , indexShardReference , shardFailedTimeout ) ; } catch ( Throwable e ) { if ( ExceptionsHelper . status ( e ) = = RestStatus . CONFLICT ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , e , request , shardId ) ; } } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , e , request , shardId ) ; } } finishAsFailed ( e ) ; return ; } finishAndMoveToReplication ( replicationPhase ) ; } String checkWriteConsistency ( ShardId shardId ) { if ( checkWriteConsistency = = false ) { return null ; } final WriteConsistencyLevel consistencyLevel ; if ( request . consistencyLevel ( ) ! = WriteConsistencyLevel . DEFAULT ) { consistencyLevel = request . consistencyLevel ( ) ; } else { consistencyLevel = defaultWriteConsistencyLevel ; } final int sizeActive ; final int requiredNumber ; IndexRoutingTable indexRoutingTable = state . getRoutingTable ( ) . index ( shardId . getIndex ( ) ) ; if ( indexRoutingTable ! = null ) { IndexShardRoutingTable shardRoutingTable = indexRoutingTable . shard ( shardId . getId ( ) ) ; if ( shardRoutingTable ! = null ) { sizeActive = shardRoutingTable . activeShards ( ) . size ( ) ; if ( consistencyLevel = = WriteConsistencyLevel . QUORUM & & shardRoutingTable . getSize ( ) > <int> ) { requiredNumber = ( shardRoutingTable . getSize ( ) / <int> ) + <int> ; } else if ( consistencyLevel = = WriteConsistencyLevel . ALL ) { requiredNumber = shardRoutingTable . getSize ( ) ; } else { requiredNumber = <int> ; } } else { sizeActive = <int> ; requiredNumber = <int> ; } } else { sizeActive = <int> ; requiredNumber = <int> ; } if ( sizeActive < requiredNumber ) { logger . trace ( <str> , shardId , consistencyLevel , sizeActive , requiredNumber , transportPrimaryAction , request ) ; return <str> + consistencyLevel + <str> + sizeActive + <str> + requiredNumber + <str> ; } else { return null ; } } void finishAndMoveToReplication ( ReplicationPhase replicationPhase ) { if ( finished . compareAndSet ( false , true ) ) { replicationPhase . run ( ) ; } else { assert false : <str> ; } } void finishAsFailed ( Throwable failure ) { if ( finished . compareAndSet ( false , true ) ) { Releasables . close ( indexShardReference ) ; logger . trace ( <str> , failure ) ; try { channel . sendResponse ( failure ) ; } catch ( IOException responseException ) { logger . warn ( <str> , responseException , transportPrimaryAction ) ; } } else { assert false : <str> ; } } void finishBecauseUnavailable ( ShardId shardId , String message ) { finishAsFailed ( new UnavailableShardsException ( shardId , <str> , message , request . timeout ( ) , request ) ) ; } } protected Releasable getIndexShardOperationsCounter ( ShardId shardId ) { IndexService indexService = indicesService . indexServiceSafe ( shardId . index ( ) . getName ( ) ) ; IndexShard indexShard = indexService . getShard ( shardId . id ( ) ) ; return new IndexShardReference ( indexShard ) ; } final class ReplicationPhase extends AbstractRunnable { private final ReplicaRequest replicaRequest ; private final Response finalResponse ; private final TransportChannel channel ; private final ShardId shardId ; private final List < ShardRouting > shards ; private final DiscoveryNodes nodes ; private final boolean executeOnReplica ; private final String indexUUID ; private final AtomicBoolean finished = new AtomicBoolean ( ) ; private final AtomicInteger success = new AtomicInteger ( <int> ) ; private final ConcurrentMap < String , Throwable > shardReplicaFailures = ConcurrentCollections . newConcurrentMap ( ) ; private final AtomicInteger pending ; private final int totalShards ; private final Releasable indexShardReference ; private final TimeValue shardFailedTimeout ; public ReplicationPhase ( ReplicaRequest replicaRequest , Response finalResponse , ShardId shardId , TransportChannel channel , Releasable indexShardReference , TimeValue shardFailedTimeout ) { this . replicaRequest = replicaRequest ; this . channel = channel ; this . finalResponse = finalResponse ; this . indexShardReference = indexShardReference ; this . shardFailedTimeout = shardFailedTimeout ; this . shardId = shardId ; final ClusterState state = clusterService . state ( ) ; final IndexRoutingTable index = state . getRoutingTable ( ) . index ( shardId . getIndex ( ) ) ; final IndexShardRoutingTable shardRoutingTable = ( index ! = null ) ? index . shard ( shardId . id ( ) ) : null ; final IndexMetaData indexMetaData = state . getMetaData ( ) . index ( shardId . getIndex ( ) ) ; this . shards = ( shardRoutingTable ! = null ) ? shardRoutingTable . shards ( ) : Collections . emptyList ( ) ; this . executeOnReplica = ( indexMetaData = = null ) | | shouldExecuteReplication ( indexMetaData . getSettings ( ) ) ; this . indexUUID = ( indexMetaData ! = null ) ? indexMetaData . getIndexUUID ( ) : null ; this . nodes = state . getNodes ( ) ; if ( shards . isEmpty ( ) ) { logger . debug ( <str> , replicaRequest , shardId ) ; } int numberOfIgnoredShardInstances = <int> ; int numberOfPendingShardInstances = <int> ; for ( ShardRouting shard : shards ) { if ( shard . primary ( ) = = false & & executeOnReplica = = false ) { numberOfIgnoredShardInstances + + ; } else if ( shard . unassigned ( ) ) { numberOfIgnoredShardInstances + + ; } else { if ( shard . currentNodeId ( ) . equals ( nodes . localNodeId ( ) ) = = false ) { numberOfPendingShardInstances + + ; } if ( shard . relocating ( ) ) { numberOfPendingShardInstances + + ; } } } this . totalShards = <int> + numberOfPendingShardInstances + numberOfIgnoredShardInstances ; this . pending = new AtomicInteger ( numberOfPendingShardInstances ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , pending . get ( ) , transportReplicaAction , replicaRequest , state . version ( ) ) ; } } int totalShards ( ) { return totalShards ; } int successful ( ) { return success . get ( ) ; } int pending ( ) { return pending . get ( ) ; } @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t , actionName , shardId ) ; forceFinishAsFailed ( t ) ; } @Override protected void doRun ( ) { if ( pending . get ( ) = = <int> ) { doFinish ( ) ; return ; } for ( ShardRouting shard : shards ) { if ( shard . primary ( ) = = false & & executeOnReplica = = false ) { continue ; } if ( shard . unassigned ( ) ) { continue ; } if ( nodes . localNodeId ( ) . equals ( shard . currentNodeId ( ) ) = = false ) { performOnReplica ( shard , shard . currentNodeId ( ) ) ; } if ( shard . relocating ( ) ) { performOnReplica ( shard , shard . relocatingNodeId ( ) ) ; } } } void performOnReplica ( final ShardRouting shard , final String nodeId ) { if ( ! nodes . nodeExists ( nodeId ) ) { logger . trace ( <str> , transportReplicaAction , shard . shardId ( ) , replicaRequest , nodeId ) ; onReplicaFailure ( nodeId , null ) ; return ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , transportReplicaAction , shard . shardId ( ) , replicaRequest , nodeId ) ; } final DiscoveryNode node = nodes . get ( nodeId ) ; transportService . sendRequest ( node , transportReplicaAction , replicaRequest , transportOptions , new EmptyTransportResponseHandler ( ThreadPool . Names . SAME ) { @Override public void handleResponse ( TransportResponse . Empty vResponse ) { onReplicaSuccess ( ) ; } @Override public void handleException ( TransportException exp ) { logger . trace ( <str> , exp , node , replicaRequest , transportReplicaAction ) ; if ( ignoreReplicaException ( exp ) ) { onReplicaFailure ( nodeId , exp ) ; } else { logger . warn ( <str> , exp , shardId , transportReplicaAction , node ) ; shardStateAction . shardFailed ( shard , indexUUID , <str> + transportReplicaAction + <str> + node , exp , shardFailedTimeout , new ReplicationFailedShardStateListener ( nodeId , exp ) ) ; } } } ) ; } void onReplicaFailure ( String nodeId , @Nullable Throwable e ) { if ( e ! = null & & ignoreReplicaException ( e ) = = false ) { shardReplicaFailures . put ( nodeId , e ) ; } decPendingAndFinishIfNeeded ( ) ; } void onReplicaSuccess ( ) { success . incrementAndGet ( ) ; decPendingAndFinishIfNeeded ( ) ; } private void decPendingAndFinishIfNeeded ( ) { if ( pending . decrementAndGet ( ) < = <int> ) { doFinish ( ) ; } } private void forceFinishAsFailed ( Throwable t ) { if ( finished . compareAndSet ( false , true ) ) { Releasables . close ( indexShardReference ) ; try { channel . sendResponse ( t ) ; } catch ( IOException responseException ) { logger . warn ( <str> , responseException , transportReplicaAction ) ; logger . warn ( <str> , t ) ; } } } private void doFinish ( ) { if ( finished . compareAndSet ( false , true ) ) { Releasables . close ( indexShardReference ) ; final ReplicationResponse . ShardInfo . Failure [ ] failuresArray ; if ( ! shardReplicaFailures . isEmpty ( ) ) { int slot = <int> ; failuresArray = new ReplicationResponse . ShardInfo . Failure [ shardReplicaFailures . size ( ) ] ; for ( Map . Entry < String , Throwable > entry : shardReplicaFailures . entrySet ( ) ) { RestStatus restStatus = ExceptionsHelper . status ( entry . getValue ( ) ) ; failuresArray [ slot + + ] = new ReplicationResponse . ShardInfo . Failure ( shardId . getIndex ( ) , shardId . getId ( ) , entry . getKey ( ) , entry . getValue ( ) , restStatus , false ) ; } } else { failuresArray = ReplicationResponse . EMPTY ; } finalResponse . setShardInfo ( new ReplicationResponse . ShardInfo ( totalShards , success . get ( ) , failuresArray ) ) ; try { channel . sendResponse ( finalResponse ) ; } catch ( IOException responseException ) { logger . warn ( <str> + transportReplicaAction + <str> , responseException ) ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , transportReplicaAction , shardId , replicaRequest ) ; } } } public class ReplicationFailedShardStateListener implements ShardStateAction . Listener { private final String nodeId ; private Throwable failure ; public ReplicationFailedShardStateListener ( String nodeId , Throwable failure ) { this . nodeId = nodeId ; this . failure = failure ; } @Override public void onSuccess ( ) { onReplicaFailure ( nodeId , failure ) ; } @Override public void onShardFailedNoMaster ( ) { onReplicaFailure ( nodeId , failure ) ; } @Override public void onShardFailedFailure ( DiscoveryNode master , TransportException e ) { if ( e instanceof ReceiveTimeoutTransportException ) { logger . trace ( <str> , e , master ) ; } onReplicaFailure ( nodeId , failure ) ; } } } protected boolean shouldExecuteReplication ( Settings settings ) { return IndexMetaData . isIndexUsingShadowReplicas ( settings ) = = false ; } static class IndexShardReference implements Releasable { final private IndexShard counter ; private final AtomicBoolean closed = new AtomicBoolean ( ) ; IndexShardReference ( IndexShard counter ) { counter . incrementOperationCounter ( ) ; this . counter = counter ; } @Override public void close ( ) { if ( closed . compareAndSet ( false , true ) ) { counter . decrementOperationCounter ( ) ; } } } protected final void processAfterWrite ( boolean refresh , IndexShard indexShard , Translog . Location location ) { if ( refresh ) { try { indexShard . refresh ( <str> ) ; } catch ( Throwable e ) { } } if ( indexShard . getTranslogDurability ( ) = = Translog . Durabilty . REQUEST & & location ! = null ) { indexShard . sync ( location ) ; } indexShard . maybeFlush ( ) ; } } 
