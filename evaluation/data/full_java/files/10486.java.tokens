package com . google . common . hash ; import static com . google . common . base . Charsets . UTF_16LE ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import com . google . common . hash . AbstractStreamingHashFunction . AbstractStreamingHasher ; import com . google . common . hash . HashTestUtils . RandomHasherAction ; import junit . framework . TestCase ; import java . io . ByteArrayOutputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . charset . Charset ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Random ; public class AbstractStreamingHasherTest extends TestCase { public void testBytes ( ) { Sink sink = new Sink ( <int> ) ; byte [ ] expected = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; sink . putByte ( ( byte ) <int> ) ; sink . putBytes ( new byte [ ] { <int> , <int> , <int> , <int> , <int> } ) ; sink . putByte ( ( byte ) <int> ) ; sink . putBytes ( new byte [ ] { } ) ; sink . putBytes ( new byte [ ] { <int> } ) ; sink . hash ( ) ; sink . assertInvariants ( <int> ) ; sink . assertBytes ( expected ) ; } public void testShort ( ) { Sink sink = new Sink ( <int> ) ; sink . putShort ( ( short ) <hex> ) ; sink . hash ( ) ; sink . assertInvariants ( <int> ) ; sink . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; } public void testInt ( ) { Sink sink = new Sink ( <int> ) ; sink . putInt ( <hex> ) ; sink . hash ( ) ; sink . assertInvariants ( <int> ) ; sink . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; } public void testLong ( ) { Sink sink = new Sink ( <int> ) ; sink . putLong ( <hex> ) ; sink . hash ( ) ; sink . assertInvariants ( <int> ) ; sink . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; } public void testChar ( ) { Sink sink = new Sink ( <int> ) ; sink . putChar ( ( char ) <hex> ) ; sink . hash ( ) ; sink . assertInvariants ( <int> ) ; sink . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; } public void testString ( ) { Random random = new Random ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] bytes = new byte [ <int> ] ; random . nextBytes ( bytes ) ; String s = new String ( bytes , UTF_16LE ) ; assertEquals ( new Sink ( <int> ) . putUnencodedChars ( s ) . hash ( ) , new Sink ( <int> ) . putBytes ( s . getBytes ( UTF_16LE ) ) . hash ( ) ) ; assertEquals ( new Sink ( <int> ) . putUnencodedChars ( s ) . hash ( ) , new Sink ( <int> ) . putString ( s , UTF_16LE ) . hash ( ) ) ; } } public void testFloat ( ) { Sink sink = new Sink ( <int> ) ; sink . putFloat ( Float . intBitsToFloat ( <hex> ) ) ; sink . hash ( ) ; sink . assertInvariants ( <int> ) ; sink . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; } public void testDouble ( ) { Sink sink = new Sink ( <int> ) ; sink . putDouble ( Double . longBitsToDouble ( <hex> ) ) ; sink . hash ( ) ; sink . assertInvariants ( <int> ) ; sink . assertBytes ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ) ; } public void testCorrectExceptions ( ) { Sink sink = new Sink ( <int> ) ; try { sink . putBytes ( new byte [ <int> ] , - <int> , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException ok ) { } try { sink . putBytes ( new byte [ <int> ] , <int> , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException ok ) { } try { sink . putBytes ( new byte [ <int> ] , <int> , - <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException ok ) { } } @AndroidIncompatible public void testExhaustive ( ) throws Exception { Random random = new Random ( <int> ) ; for ( int totalInsertions = <int> ; totalInsertions < <int> ; totalInsertions + + ) { List < Sink > sinks = Lists . newArrayList ( ) ; for ( int chunkSize = <int> ; chunkSize < = <int> ; chunkSize + + ) { for ( int bufferSize = chunkSize ; bufferSize < = chunkSize * <int> ; bufferSize + = chunkSize ) { sinks . add ( new Sink ( chunkSize , bufferSize ) ) ; } } Control control = new Control ( ) ; Hasher controlSink = control . newHasher ( <int> ) ; Iterable < Hasher > sinksAndControl = Iterables . concat ( sinks , Collections . singleton ( controlSink ) ) ; for ( int insertion = <int> ; insertion < totalInsertions ; insertion + + ) { RandomHasherAction . pickAtRandom ( random ) . performAction ( random , sinksAndControl ) ; } int intToPut = random . nextInt ( ) ; for ( Hasher hasher : sinksAndControl ) { hasher . putInt ( intToPut ) ; } for ( Sink sink : sinks ) { sink . hash ( ) ; } byte [ ] expected = controlSink . hash ( ) . asBytes ( ) ; for ( Sink sink : sinks ) { sink . assertInvariants ( expected . length ) ; sink . assertBytes ( expected ) ; } } } private static class Sink extends AbstractStreamingHasher { final int chunkSize ; final int bufferSize ; final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; int processCalled = <int> ; boolean remainingCalled = false ; Sink ( int chunkSize , int bufferSize ) { super ( chunkSize , bufferSize ) ; this . chunkSize = chunkSize ; this . bufferSize = bufferSize ; } Sink ( int chunkSize ) { super ( chunkSize ) ; this . chunkSize = chunkSize ; this . bufferSize = chunkSize ; } @Override HashCode makeHash ( ) { return HashCode . fromBytes ( out . toByteArray ( ) ) ; } @Override protected void process ( ByteBuffer bb ) { processCalled + + ; assertEquals ( ByteOrder . LITTLE_ENDIAN , bb . order ( ) ) ; assertTrue ( bb . remaining ( ) > = chunkSize ) ; for ( int i = <int> ; i < chunkSize ; i + + ) { out . write ( bb . get ( ) ) ; } } @Override protected void processRemaining ( ByteBuffer bb ) { assertFalse ( remainingCalled ) ; remainingCalled = true ; assertEquals ( ByteOrder . LITTLE_ENDIAN , bb . order ( ) ) ; assertTrue ( bb . remaining ( ) > <int> ) ; assertTrue ( bb . remaining ( ) < bufferSize ) ; int before = processCalled ; super . processRemaining ( bb ) ; int after = processCalled ; assertEquals ( before + <int> , after ) ; processCalled - - ; } void assertInvariants ( int expectedBytes ) { assertEquals ( out . toByteArray ( ) . length , ceilToMultiple ( expectedBytes , chunkSize ) ) ; assertEquals ( expectedBytes / chunkSize , processCalled ) ; assertEquals ( expectedBytes % chunkSize ! = <int> , remainingCalled ) ; } private static int ceilToMultiple ( int a , int b ) { int remainder = a % b ; return remainder = = <int> ? a : a + b - remainder ; } void assertBytes ( byte [ ] expected ) { byte [ ] got = out . toByteArray ( ) ; for ( int i = <int> ; i < expected . length ; i + + ) { assertEquals ( expected [ i ] , got [ i ] ) ; } } } private static class Control extends AbstractNonStreamingHashFunction { @Override public HashCode hashBytes ( byte [ ] input ) { return HashCode . fromBytes ( input ) ; } @Override public HashCode hashBytes ( byte [ ] input , int off , int len ) { return hashBytes ( Arrays . copyOfRange ( input , off , off + len ) ) ; } @Override public int bits ( ) { throw new UnsupportedOperationException ( ) ; } @Override public HashCode hashString ( CharSequence input , Charset charset ) { throw new UnsupportedOperationException ( ) ; } @Override public HashCode hashLong ( long input ) { throw new UnsupportedOperationException ( ) ; } @Override public HashCode hashInt ( int input ) { throw new UnsupportedOperationException ( ) ; } } } 
