package com . badlogic . gdx . graphics . glutils ; import java . nio . ByteBuffer ; import java . nio . ShortBuffer ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class IndexBufferObjectSubData implements IndexData { ShortBuffer buffer ; ByteBuffer byteBuffer ; int bufferHandle ; final boolean isDirect ; boolean isDirty = true ; boolean isBound = false ; final int usage ; public IndexBufferObjectSubData ( boolean isStatic , int maxIndices ) { byteBuffer = BufferUtils . newByteBuffer ( maxIndices * <int> ) ; isDirect = true ; usage = isStatic ? GL20 . GL_STATIC_DRAW : GL20 . GL_DYNAMIC_DRAW ; buffer = byteBuffer . asShortBuffer ( ) ; buffer . flip ( ) ; byteBuffer . flip ( ) ; bufferHandle = createBufferObject ( ) ; } public IndexBufferObjectSubData ( int maxIndices ) { byteBuffer = BufferUtils . newByteBuffer ( maxIndices * <int> ) ; this . isDirect = true ; usage = GL20 . GL_STATIC_DRAW ; buffer = byteBuffer . asShortBuffer ( ) ; buffer . flip ( ) ; byteBuffer . flip ( ) ; bufferHandle = createBufferObject ( ) ; } private int createBufferObject ( ) { int result = Gdx . gl20 . glGenBuffer ( ) ; Gdx . gl20 . glBindBuffer ( GL20 . GL_ELEMENT_ARRAY_BUFFER , result ) ; Gdx . gl20 . glBufferData ( GL20 . GL_ELEMENT_ARRAY_BUFFER , byteBuffer . capacity ( ) , null , usage ) ; Gdx . gl20 . glBindBuffer ( GL20 . GL_ELEMENT_ARRAY_BUFFER , <int> ) ; return result ; } public int getNumIndices ( ) { return buffer . limit ( ) ; } public int getNumMaxIndices ( ) { return buffer . capacity ( ) ; } public void setIndices ( short [ ] indices , int offset , int count ) { isDirty = true ; buffer . clear ( ) ; buffer . put ( indices , offset , count ) ; buffer . flip ( ) ; byteBuffer . position ( <int> ) ; byteBuffer . limit ( count < < <int> ) ; if ( isBound ) { Gdx . gl20 . glBufferSubData ( GL20 . GL_ELEMENT_ARRAY_BUFFER , <int> , byteBuffer . limit ( ) , byteBuffer ) ; isDirty = false ; } } public void setIndices ( ShortBuffer indices ) { int pos = indices . position ( ) ; isDirty = true ; buffer . clear ( ) ; buffer . put ( indices ) ; buffer . flip ( ) ; indices . position ( pos ) ; byteBuffer . position ( <int> ) ; byteBuffer . limit ( buffer . limit ( ) < < <int> ) ; if ( isBound ) { Gdx . gl20 . glBufferSubData ( GL20 . GL_ELEMENT_ARRAY_BUFFER , <int> , byteBuffer . limit ( ) , byteBuffer ) ; isDirty = false ; } } public ShortBuffer getBuffer ( ) { isDirty = true ; return buffer ; } public void bind ( ) { if ( bufferHandle = = <int> ) throw new GdxRuntimeException ( <str> ) ; Gdx . gl20 . glBindBuffer ( GL20 . GL_ELEMENT_ARRAY_BUFFER , bufferHandle ) ; if ( isDirty ) { byteBuffer . limit ( buffer . limit ( ) * <int> ) ; Gdx . gl20 . glBufferSubData ( GL20 . GL_ELEMENT_ARRAY_BUFFER , <int> , byteBuffer . limit ( ) , byteBuffer ) ; isDirty = false ; } isBound = true ; } public void unbind ( ) { Gdx . gl20 . glBindBuffer ( GL20 . GL_ELEMENT_ARRAY_BUFFER , <int> ) ; isBound = false ; } public void invalidate ( ) { bufferHandle = createBufferObject ( ) ; isDirty = true ; } public void dispose ( ) { GL20 gl = Gdx . gl20 ; gl . glBindBuffer ( GL20 . GL_ELEMENT_ARRAY_BUFFER , <int> ) ; gl . glDeleteBuffer ( bufferHandle ) ; bufferHandle = <int> ; } } 
