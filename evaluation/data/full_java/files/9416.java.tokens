package com . google . common . hash ; import static com . google . common . primitives . UnsignedBytes . toInt ; import java . io . Serializable ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import javax . annotation . Nullable ; final class Murmur3_128HashFunction extends AbstractStreamingHashFunction implements Serializable { private final int seed ; Murmur3_128HashFunction ( int seed ) { this . seed = seed ; } @Override public int bits ( ) { return <int> ; } @Override public Hasher newHasher ( ) { return new Murmur3_128Hasher ( seed ) ; } @Override public String toString ( ) { return <str> + seed + <str> ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof Murmur3_128HashFunction ) { Murmur3_128HashFunction other = ( Murmur3_128HashFunction ) object ; return seed = = other . seed ; } return false ; } @Override public int hashCode ( ) { return getClass ( ) . hashCode ( ) ^ seed ; } private static final class Murmur3_128Hasher extends AbstractStreamingHasher { private static final int CHUNK_SIZE = <int> ; private static final long C1 = <hex> ; private static final long C2 = <hex> ; private long h1 ; private long h2 ; private int length ; Murmur3_128Hasher ( int seed ) { super ( CHUNK_SIZE ) ; this . h1 = seed ; this . h2 = seed ; this . length = <int> ; } @Override protected void process ( ByteBuffer bb ) { long k1 = bb . getLong ( ) ; long k2 = bb . getLong ( ) ; bmix64 ( k1 , k2 ) ; length + = CHUNK_SIZE ; } private void bmix64 ( long k1 , long k2 ) { h1 ^ = mixK1 ( k1 ) ; h1 = Long . rotateLeft ( h1 , <int> ) ; h1 + = h2 ; h1 = h1 * <int> + <hex> ; h2 ^ = mixK2 ( k2 ) ; h2 = Long . rotateLeft ( h2 , <int> ) ; h2 + = h1 ; h2 = h2 * <int> + <hex> ; } @Override protected void processRemaining ( ByteBuffer bb ) { long k1 = <int> ; long k2 = <int> ; length + = bb . remaining ( ) ; switch ( bb . remaining ( ) ) { case <int> : k2 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k2 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k2 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k2 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k2 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k2 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k2 ^ = ( long ) toInt ( bb . get ( <int> ) ) ; case <int> : k1 ^ = bb . getLong ( ) ; break ; case <int> : k1 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k1 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k1 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k1 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k1 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k1 ^ = ( long ) toInt ( bb . get ( <int> ) ) < < <int> ; case <int> : k1 ^ = ( long ) toInt ( bb . get ( <int> ) ) ; break ; default : throw new AssertionError ( <str> ) ; } h1 ^ = mixK1 ( k1 ) ; h2 ^ = mixK2 ( k2 ) ; } @Override public HashCode makeHash ( ) { h1 ^ = length ; h2 ^ = length ; h1 + = h2 ; h2 + = h1 ; h1 = fmix64 ( h1 ) ; h2 = fmix64 ( h2 ) ; h1 + = h2 ; h2 + = h1 ; return HashCode . fromBytesNoCopy ( ByteBuffer . wrap ( new byte [ CHUNK_SIZE ] ) . order ( ByteOrder . LITTLE_ENDIAN ) . putLong ( h1 ) . putLong ( h2 ) . array ( ) ) ; } private static long fmix64 ( long k ) { k ^ = k > > > <int> ; k * = <hex> ; k ^ = k > > > <int> ; k * = <hex> ; k ^ = k > > > <int> ; return k ; } private static long mixK1 ( long k1 ) { k1 * = C1 ; k1 = Long . rotateLeft ( k1 , <int> ) ; k1 * = C2 ; return k1 ; } private static long mixK2 ( long k2 ) { k2 * = C2 ; k2 = Long . rotateLeft ( k2 , <int> ) ; k2 * = C1 ; return k2 ; } } private static final long serialVersionUID = <int> L ; } 
