package org . gradle . launcher . daemon . server ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . launcher . daemon . context . DaemonContext ; import org . gradle . launcher . daemon . logging . DaemonMessages ; import org . gradle . launcher . daemon . protocol . Command ; import org . gradle . launcher . daemon . protocol . Failure ; import org . gradle . launcher . daemon . protocol . Message ; import org . gradle . launcher . daemon . server . api . DaemonConnection ; import org . gradle . launcher . daemon . server . api . DaemonStateControl ; import org . gradle . launcher . daemon . server . exec . DaemonCommandExecuter ; import org . gradle . messaging . remote . internal . Connection ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DefaultIncomingConnectionHandler implements IncomingConnectionHandler , Stoppable { private static final Logger LOGGER = Logging . getLogger ( DefaultIncomingConnectionHandler . class ) ; private final StoppableExecutor workers ; private final DaemonContext daemonContext ; private final DaemonCommandExecuter commandExecuter ; private final DaemonStateControl daemonStateControl ; private final ExecutorFactory executorFactory ; private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private final Set < Connection < ? > > inProgress = new HashSet < Connection < ? > > ( ) ; public DefaultIncomingConnectionHandler ( DaemonCommandExecuter commandExecuter , DaemonContext daemonContext , DaemonStateControl daemonStateControl , ExecutorFactory executorFactory ) { this . commandExecuter = commandExecuter ; this . daemonContext = daemonContext ; this . daemonStateControl = daemonStateControl ; this . executorFactory = executorFactory ; workers = executorFactory . create ( <str> ) ; } public void handle ( final Connection < Message > connection ) { onStartHandling ( connection ) ; workers . execute ( new ConnectionWorker ( connection ) ) ; } private void onStartHandling ( Connection < ? > connection ) { lock . lock ( ) ; try { inProgress . add ( connection ) ; } finally { lock . unlock ( ) ; } } private void onFinishHandling ( Connection < ? > connection ) { lock . lock ( ) ; try { inProgress . remove ( connection ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } public void stop ( ) { lock . lock ( ) ; try { while ( ! inProgress . isEmpty ( ) ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } finally { lock . unlock ( ) ; } } private class ConnectionWorker implements Runnable { private final Connection < Message > connection ; public ConnectionWorker ( Connection < Message > connection ) { this . connection = connection ; } public void run ( ) { try { receiveAndHandleCommand ( ) ; } finally { onFinishHandling ( connection ) ; } } private void receiveAndHandleCommand ( ) { try { DefaultDaemonConnection daemonConnection = new DefaultDaemonConnection ( connection , executorFactory ) ; try { Command command = receiveCommand ( daemonConnection ) ; if ( command ! = null ) { handleCommand ( command , daemonConnection ) ; } } finally { daemonConnection . stop ( ) ; } } finally { connection . stop ( ) ; } } private Command receiveCommand ( DaemonConnection daemonConnection ) { try { Command command = ( Command ) daemonConnection . receive ( <int> , TimeUnit . SECONDS ) ; LOGGER . info ( <str> , command ) ; return command ; } catch ( Throwable e ) { LOGGER . warn ( String . format ( <str> , connection ) , e ) ; daemonConnection . completed ( new Failure ( e ) ) ; return null ; } } private void handleCommand ( Command command , DaemonConnection daemonConnection ) { LOGGER . debug ( <str> , DaemonMessages . STARTED_EXECUTING_COMMAND , command , connection ) ; try { commandExecuter . executeCommand ( daemonConnection , command , daemonContext , daemonStateControl ) ; } catch ( Throwable e ) { LOGGER . warn ( String . format ( <str> , command , connection ) , e ) ; daemonConnection . completed ( new Failure ( e ) ) ; } finally { LOGGER . debug ( <str> , DaemonMessages . FINISHED_EXECUTING_COMMAND , command ) ; } Object finished = daemonConnection . receive ( <int> , TimeUnit . SECONDS ) ; LOGGER . debug ( <str> , finished ) ; } } } 
