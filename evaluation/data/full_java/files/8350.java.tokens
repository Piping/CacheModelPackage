package org . elasticsearch . indices . recovery ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . recovery . RecoveryState . * ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . hamcrest . Matchers . * ; public class RecoveryStateTests extends ESTestCase { abstract class Streamer < T extends Streamable > extends Thread { private T lastRead ; final private AtomicBoolean shouldStop ; final private T source ; final AtomicReference < Throwable > error = new AtomicReference < > ( ) ; final Version streamVersion ; Streamer ( AtomicBoolean shouldStop , T source ) { this ( shouldStop , source , randomVersion ( random ( ) ) ) ; } Streamer ( AtomicBoolean shouldStop , T source , Version streamVersion ) { this . shouldStop = shouldStop ; this . source = source ; this . streamVersion = streamVersion ; } public T lastRead ( ) throws Throwable { Throwable t = error . get ( ) ; if ( t ! = null ) { throw t ; } return lastRead ; } public T serializeDeserialize ( ) throws IOException { BytesStreamOutput out = new BytesStreamOutput ( ) ; source . writeTo ( out ) ; out . close ( ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ; T obj = deserialize ( in ) ; lastRead = obj ; return obj ; } protected T deserialize ( StreamInput in ) throws IOException { T obj = createObj ( ) ; obj . readFrom ( in ) ; return obj ; } abstract T createObj ( ) ; @Override public void run ( ) { try { while ( shouldStop . get ( ) = = false ) { serializeDeserialize ( ) ; } serializeDeserialize ( ) ; } catch ( Throwable t ) { error . set ( t ) ; } } } public void testTimers ( ) throws Throwable { final Timer timer ; Streamer < Timer > streamer ; AtomicBoolean stop = new AtomicBoolean ( ) ; if ( randomBoolean ( ) ) { timer = new Timer ( ) ; streamer = new Streamer < Timer > ( stop , timer ) { @Override Timer createObj ( ) { return new Timer ( ) ; } } ; } else if ( randomBoolean ( ) ) { timer = new Index ( ) ; streamer = new Streamer < Timer > ( stop , timer ) { @Override Timer createObj ( ) { return new Index ( ) ; } } ; } else if ( randomBoolean ( ) ) { timer = new VerifyIndex ( ) ; streamer = new Streamer < Timer > ( stop , timer ) { @Override Timer createObj ( ) { return new VerifyIndex ( ) ; } } ; } else { timer = new Translog ( ) ; streamer = new Streamer < Timer > ( stop , timer ) { @Override Timer createObj ( ) { return new Translog ( ) ; } } ; } timer . start ( ) ; assertThat ( timer . startTime ( ) , greaterThan ( <int> l ) ) ; assertThat ( timer . stopTime ( ) , equalTo ( <int> l ) ) ; Timer lastRead = streamer . serializeDeserialize ( ) ; final long time = lastRead . time ( ) ; assertThat ( time , lessThanOrEqualTo ( timer . time ( ) ) ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertThat ( <str> , time , lessThan ( timer . time ( ) ) ) ; } } ) ; assertThat ( <str> , lastRead . time ( ) , equalTo ( time ) ) ; if ( randomBoolean ( ) ) { timer . stop ( ) ; assertThat ( timer . stopTime ( ) , greaterThanOrEqualTo ( timer . startTime ( ) ) ) ; assertThat ( timer . time ( ) , greaterThan ( <int> l ) ) ; lastRead = streamer . serializeDeserialize ( ) ; assertThat ( lastRead . startTime ( ) , equalTo ( timer . startTime ( ) ) ) ; assertThat ( lastRead . time ( ) , equalTo ( timer . time ( ) ) ) ; assertThat ( lastRead . stopTime ( ) , equalTo ( timer . stopTime ( ) ) ) ; } timer . reset ( ) ; assertThat ( timer . startTime ( ) , equalTo ( <int> l ) ) ; assertThat ( timer . time ( ) , equalTo ( <int> l ) ) ; assertThat ( timer . stopTime ( ) , equalTo ( <int> l ) ) ; lastRead = streamer . serializeDeserialize ( ) ; assertThat ( lastRead . startTime ( ) , equalTo ( <int> l ) ) ; assertThat ( lastRead . time ( ) , equalTo ( <int> l ) ) ; assertThat ( lastRead . stopTime ( ) , equalTo ( <int> l ) ) ; } public void testIndex ( ) throws Throwable { File [ ] files = new File [ randomIntBetween ( <int> , <int> ) ] ; ArrayList < File > filesToRecover = new ArrayList < > ( ) ; long totalFileBytes = <int> ; long totalReusedBytes = <int> ; int totalReused = <int> ; for ( int i = <int> ; i < files . length ; i + + ) { final int fileLength = randomIntBetween ( <int> , <int> ) ; final boolean reused = randomBoolean ( ) ; totalFileBytes + = fileLength ; files [ i ] = new RecoveryState . File ( <str> + i , fileLength , reused ) ; if ( reused ) { totalReused + + ; totalReusedBytes + = fileLength ; } else { filesToRecover . add ( files [ i ] ) ; } } Collections . shuffle ( Arrays . asList ( files ) , random ( ) ) ; final RecoveryState . Index index = new RecoveryState . Index ( ) ; if ( randomBoolean ( ) ) { index . start ( ) ; for ( int i = randomIntBetween ( <int> , <int> ) ; i > <int> ; i - - ) { index . addFileDetail ( <str> + i , randomIntBetween ( <int> , <int> ) , randomBoolean ( ) ) ; if ( randomBoolean ( ) ) { index . addSourceThrottling ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { index . addTargetThrottling ( randomIntBetween ( <int> , <int> ) ) ; } } if ( randomBoolean ( ) ) { index . stop ( ) ; } index . reset ( ) ; } assertThat ( index . recoveredFilesPercent ( ) , equalTo ( ( float ) <float> ) ) ; assertThat ( index . recoveredBytesPercent ( ) , equalTo ( ( float ) <float> ) ) ; assertThat ( index . sourceThrottling ( ) . nanos ( ) , equalTo ( Index . UNKNOWN ) ) ; assertThat ( index . targetThrottling ( ) . nanos ( ) , equalTo ( Index . UNKNOWN ) ) ; index . start ( ) ; for ( File file : files ) { index . addFileDetail ( file . name ( ) , file . length ( ) , file . reused ( ) ) ; } logger . info ( <str> ) ; assertThat ( index . totalBytes ( ) , equalTo ( totalFileBytes ) ) ; assertThat ( index . reusedBytes ( ) , equalTo ( totalReusedBytes ) ) ; assertThat ( index . totalRecoverBytes ( ) , equalTo ( totalFileBytes - totalReusedBytes ) ) ; assertThat ( index . totalFileCount ( ) , equalTo ( files . length ) ) ; assertThat ( index . reusedFileCount ( ) , equalTo ( totalReused ) ) ; assertThat ( index . totalRecoverFiles ( ) , equalTo ( filesToRecover . size ( ) ) ) ; assertThat ( index . recoveredFileCount ( ) , equalTo ( <int> ) ) ; assertThat ( index . recoveredBytes ( ) , equalTo ( <int> l ) ) ; assertThat ( index . recoveredFilesPercent ( ) , equalTo ( filesToRecover . size ( ) = = <int> ? <float> : <float> ) ) ; assertThat ( index . recoveredBytesPercent ( ) , equalTo ( filesToRecover . size ( ) = = <int> ? <float> : <float> ) ) ; long bytesToRecover = totalFileBytes - totalReusedBytes ; boolean completeRecovery = bytesToRecover = = <int> | | randomBoolean ( ) ; if ( completeRecovery = = false ) { bytesToRecover = randomIntBetween ( <int> , ( int ) bytesToRecover ) ; logger . info ( <str> , bytesToRecover , totalFileBytes - totalReusedBytes ) ; } AtomicBoolean streamShouldStop = new AtomicBoolean ( ) ; Streamer < Index > backgroundReader = new Streamer < RecoveryState . Index > ( streamShouldStop , index ) { @Override Index createObj ( ) { return new Index ( ) ; } } ; backgroundReader . start ( ) ; long recoveredBytes = <int> ; long sourceThrottling = Index . UNKNOWN ; long targetThrottling = Index . UNKNOWN ; while ( bytesToRecover > <int> ) { File file = randomFrom ( filesToRecover ) ; final long toRecover = Math . min ( bytesToRecover , randomIntBetween ( <int> , ( int ) ( file . length ( ) - file . recovered ( ) ) ) ) ; final long throttledOnSource = rarely ( ) ? randomIntBetween ( <int> , <int> ) : <int> ; index . addSourceThrottling ( throttledOnSource ) ; if ( sourceThrottling = = Index . UNKNOWN ) { sourceThrottling = throttledOnSource ; } else { sourceThrottling + = throttledOnSource ; } index . addRecoveredBytesToFile ( file . name ( ) , toRecover ) ; file . addRecoveredBytes ( toRecover ) ; final long throttledOnTarget = rarely ( ) ? randomIntBetween ( <int> , <int> ) : <int> ; if ( targetThrottling = = Index . UNKNOWN ) { targetThrottling = throttledOnTarget ; } else { targetThrottling + = throttledOnTarget ; } index . addTargetThrottling ( throttledOnTarget ) ; bytesToRecover - = toRecover ; recoveredBytes + = toRecover ; if ( file . reused ( ) | | file . fullyRecovered ( ) ) { filesToRecover . remove ( file ) ; } } if ( completeRecovery ) { assertThat ( filesToRecover . size ( ) , equalTo ( <int> ) ) ; index . stop ( ) ; assertThat ( index . time ( ) , greaterThanOrEqualTo ( <int> l ) ) ; } logger . info ( <str> ) ; streamShouldStop . set ( true ) ; backgroundReader . join ( ) ; final Index lastRead = backgroundReader . lastRead ( ) ; assertThat ( lastRead . fileDetails ( ) . toArray ( ) , arrayContainingInAnyOrder ( index . fileDetails ( ) . toArray ( ) ) ) ; assertThat ( lastRead . startTime ( ) , equalTo ( index . startTime ( ) ) ) ; if ( completeRecovery ) { assertThat ( lastRead . time ( ) , equalTo ( index . time ( ) ) ) ; } else { assertThat ( lastRead . time ( ) , lessThanOrEqualTo ( index . time ( ) ) ) ; } assertThat ( lastRead . stopTime ( ) , equalTo ( index . stopTime ( ) ) ) ; assertThat ( lastRead . targetThrottling ( ) , equalTo ( index . targetThrottling ( ) ) ) ; assertThat ( lastRead . sourceThrottling ( ) , equalTo ( index . sourceThrottling ( ) ) ) ; logger . info ( <str> ) ; assertThat ( index . totalBytes ( ) , equalTo ( totalFileBytes ) ) ; assertThat ( index . reusedBytes ( ) , equalTo ( totalReusedBytes ) ) ; assertThat ( index . totalRecoverBytes ( ) , equalTo ( totalFileBytes - totalReusedBytes ) ) ; assertThat ( index . totalFileCount ( ) , equalTo ( files . length ) ) ; assertThat ( index . reusedFileCount ( ) , equalTo ( totalReused ) ) ; assertThat ( index . totalRecoverFiles ( ) , equalTo ( files . length - totalReused ) ) ; assertThat ( index . recoveredFileCount ( ) , equalTo ( index . totalRecoverFiles ( ) - filesToRecover . size ( ) ) ) ; assertThat ( index . recoveredBytes ( ) , equalTo ( recoveredBytes ) ) ; assertThat ( index . targetThrottling ( ) . nanos ( ) , equalTo ( targetThrottling ) ) ; assertThat ( index . sourceThrottling ( ) . nanos ( ) , equalTo ( sourceThrottling ) ) ; if ( index . totalRecoverFiles ( ) = = <int> ) { assertThat ( ( double ) index . recoveredFilesPercent ( ) , equalTo ( <float> ) ) ; assertThat ( ( double ) index . recoveredBytesPercent ( ) , equalTo ( <float> ) ) ; } else { assertThat ( ( double ) index . recoveredFilesPercent ( ) , closeTo ( <float> * index . recoveredFileCount ( ) / index . totalRecoverFiles ( ) , <float> ) ) ; assertThat ( ( double ) index . recoveredBytesPercent ( ) , closeTo ( <float> * index . recoveredBytes ( ) / index . totalRecoverBytes ( ) , <float> ) ) ; } } public void testStageSequenceEnforcement ( ) { final DiscoveryNode discoveryNode = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; Stage [ ] stages = Stage . values ( ) ; int i = randomIntBetween ( <int> , stages . length - <int> ) ; int j ; do { j = randomIntBetween ( <int> , stages . length - <int> ) ; } while ( j = = i ) ; Stage t = stages [ i ] ; stages [ i ] = stages [ j ] ; stages [ j ] = t ; try { RecoveryState state = new RecoveryState ( new ShardId ( <str> , <int> ) , randomBoolean ( ) , randomFrom ( Type . values ( ) ) , discoveryNode , discoveryNode ) ; for ( Stage stage : stages ) { state . setStage ( stage ) ; } fail ( <str> + Strings . arrayToCommaDelimitedString ( stages ) + <str> ) ; } catch ( IllegalStateException e ) { } stages = Stage . values ( ) ; i = randomIntBetween ( <int> , stages . length - <int> ) ; ArrayList < Stage > list = new ArrayList < > ( Arrays . asList ( Arrays . copyOfRange ( stages , <int> , i ) ) ) ; list . addAll ( Arrays . asList ( stages ) ) ; RecoveryState state = new RecoveryState ( new ShardId ( <str> , <int> ) , randomBoolean ( ) , randomFrom ( Type . values ( ) ) , discoveryNode , discoveryNode ) ; for ( Stage stage : list ) { state . setStage ( stage ) ; } assertThat ( state . getStage ( ) , equalTo ( Stage . DONE ) ) ; } public void testTranslog ( ) throws Throwable { final Translog translog = new Translog ( ) ; AtomicBoolean stop = new AtomicBoolean ( ) ; Streamer < Translog > streamer = new Streamer < Translog > ( stop , translog ) { @Override Translog createObj ( ) { return new Translog ( ) ; } } ; translog . start ( ) ; assertThat ( translog . recoveredOperations ( ) , equalTo ( <int> ) ) ; assertThat ( translog . totalOperations ( ) , equalTo ( Translog . UNKNOWN ) ) ; assertThat ( translog . totalOperationsOnStart ( ) , equalTo ( Translog . UNKNOWN ) ) ; streamer . start ( ) ; streamer . serializeDeserialize ( ) ; int ops = <int> ; int totalOps = <int> ; int totalOpsOnStart = randomIntBetween ( <int> , <int> ) ; translog . totalOperationsOnStart ( totalOpsOnStart ) ; for ( int i = scaledRandomIntBetween ( <int> , <int> ) ; i > <int> ; i - - ) { final int iterationOps = randomIntBetween ( <int> , <int> ) ; totalOps + = iterationOps ; translog . totalOperations ( totalOps ) ; assertThat ( ( double ) translog . recoveredPercent ( ) , closeTo ( <float> * ops / totalOps , <float> ) ) ; for ( int j = iterationOps ; j > <int> ; j - - ) { ops + + ; translog . incrementRecoveredOperations ( ) ; if ( randomBoolean ( ) ) { translog . decrementRecoveredOperations ( <int> ) ; translog . incrementRecoveredOperations ( ) ; } } assertThat ( translog . recoveredOperations ( ) , equalTo ( ops ) ) ; assertThat ( translog . totalOperations ( ) , equalTo ( totalOps ) ) ; assertThat ( translog . recoveredPercent ( ) , equalTo ( <float> ) ) ; assertThat ( streamer . lastRead ( ) . recoveredOperations ( ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( streamer . lastRead ( ) . recoveredOperations ( ) , lessThanOrEqualTo ( ops ) ) ; assertThat ( streamer . lastRead ( ) . totalOperations ( ) , lessThanOrEqualTo ( totalOps ) ) ; assertThat ( streamer . lastRead ( ) . totalOperationsOnStart ( ) , lessThanOrEqualTo ( totalOpsOnStart ) ) ; assertThat ( streamer . lastRead ( ) . recoveredPercent ( ) , either ( greaterThanOrEqualTo ( <float> ) ) . or ( equalTo ( - <float> ) ) ) ; } boolean stopped = false ; if ( randomBoolean ( ) ) { translog . stop ( ) ; stopped = true ; } if ( randomBoolean ( ) ) { translog . reset ( ) ; ops = <int> ; totalOps = Translog . UNKNOWN ; totalOpsOnStart = Translog . UNKNOWN ; assertThat ( translog . recoveredOperations ( ) , equalTo ( <int> ) ) ; assertThat ( translog . totalOperationsOnStart ( ) , equalTo ( Translog . UNKNOWN ) ) ; assertThat ( translog . totalOperations ( ) , equalTo ( Translog . UNKNOWN ) ) ; } stop . set ( true ) ; streamer . join ( ) ; final Translog lastRead = streamer . lastRead ( ) ; assertThat ( lastRead . recoveredOperations ( ) , equalTo ( ops ) ) ; assertThat ( lastRead . totalOperations ( ) , equalTo ( totalOps ) ) ; assertThat ( lastRead . totalOperationsOnStart ( ) , equalTo ( totalOpsOnStart ) ) ; assertThat ( lastRead . startTime ( ) , equalTo ( translog . startTime ( ) ) ) ; assertThat ( lastRead . stopTime ( ) , equalTo ( translog . stopTime ( ) ) ) ; if ( stopped ) { assertThat ( lastRead . time ( ) , equalTo ( translog . time ( ) ) ) ; } else { assertThat ( lastRead . time ( ) , lessThanOrEqualTo ( translog . time ( ) ) ) ; } } public void testStart ( ) throws IOException { final VerifyIndex verifyIndex = new VerifyIndex ( ) ; AtomicBoolean stop = new AtomicBoolean ( ) ; Streamer < VerifyIndex > streamer = new Streamer < VerifyIndex > ( stop , verifyIndex ) { @Override VerifyIndex createObj ( ) { return new VerifyIndex ( ) ; } } ; verifyIndex . start ( ) ; assertThat ( verifyIndex . checkIndexTime ( ) , equalTo ( <int> l ) ) ; VerifyIndex lastRead = streamer . serializeDeserialize ( ) ; assertThat ( lastRead . checkIndexTime ( ) , equalTo ( <int> l ) ) ; long took = randomLong ( ) ; if ( took < <int> ) { took = - took ; took = Math . max ( <int> l , took ) ; } verifyIndex . checkIndexTime ( took ) ; assertThat ( verifyIndex . checkIndexTime ( ) , equalTo ( took ) ) ; boolean stopped = false ; if ( randomBoolean ( ) ) { verifyIndex . stop ( ) ; stopped = true ; } if ( randomBoolean ( ) ) { verifyIndex . reset ( ) ; took = <int> ; assertThat ( verifyIndex . checkIndexTime ( ) , equalTo ( took ) ) ; } lastRead = streamer . serializeDeserialize ( ) ; assertThat ( lastRead . checkIndexTime ( ) , equalTo ( took ) ) ; assertThat ( lastRead . startTime ( ) , equalTo ( verifyIndex . startTime ( ) ) ) ; assertThat ( lastRead . stopTime ( ) , equalTo ( verifyIndex . stopTime ( ) ) ) ; if ( stopped ) { assertThat ( lastRead . time ( ) , equalTo ( verifyIndex . time ( ) ) ) ; } else { assertThat ( lastRead . time ( ) , lessThanOrEqualTo ( verifyIndex . time ( ) ) ) ; } } public void testConcurrentModificationIndexFileDetailsMap ( ) throws InterruptedException { final Index index = new Index ( ) ; final AtomicBoolean stop = new AtomicBoolean ( false ) ; Streamer < Index > readWriteIndex = new Streamer < Index > ( stop , index ) { @Override Index createObj ( ) { return new Index ( ) ; } } ; Thread modifyThread = new Thread ( ) { @Override public void run ( ) { for ( int i = <int> ; i < <int> ; i + + ) { index . addFileDetail ( randomAsciiOfLength ( <int> ) , <int> , true ) ; } stop . set ( true ) ; } } ; readWriteIndex . start ( ) ; modifyThread . start ( ) ; modifyThread . join ( ) ; readWriteIndex . join ( ) ; assertThat ( readWriteIndex . error . get ( ) , equalTo ( null ) ) ; } public void testFileHashCodeAndEquals ( ) { File f = new File ( <str> , randomIntBetween ( <int> , <int> ) , randomBoolean ( ) ) ; File anotherFile = new File ( f . name ( ) , f . length ( ) , f . reused ( ) ) ; assertEquals ( f , anotherFile ) ; assertEquals ( f . hashCode ( ) , anotherFile . hashCode ( ) ) ; int iters = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { f = new File ( <str> , randomIntBetween ( <int> , <int> ) , randomBoolean ( ) ) ; anotherFile = new File ( f . name ( ) , randomIntBetween ( <int> , <int> ) , randomBoolean ( ) ) ; if ( f . equals ( anotherFile ) ) { assertEquals ( f . hashCode ( ) , anotherFile . hashCode ( ) ) ; } else if ( f . hashCode ( ) ! = anotherFile . hashCode ( ) ) { assertFalse ( f . equals ( anotherFile ) ) ; } } } } 
