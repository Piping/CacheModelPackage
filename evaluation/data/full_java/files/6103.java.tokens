package org . elasticsearch . common . util ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . lease . Releasables ; import java . util . Iterator ; import java . util . NoSuchElementException ; public class LongObjectPagedHashMap < T > extends AbstractPagedHashMap implements Iterable < LongObjectPagedHashMap . Cursor < T > > { private LongArray keys ; private ObjectArray < T > values ; public LongObjectPagedHashMap ( BigArrays bigArrays ) { this ( <int> , bigArrays ) ; } public LongObjectPagedHashMap ( long capacity , BigArrays bigArrays ) { this ( capacity , DEFAULT_MAX_LOAD_FACTOR , bigArrays ) ; } public LongObjectPagedHashMap ( long capacity , float maxLoadFactor , BigArrays bigArrays ) { super ( capacity , maxLoadFactor , bigArrays ) ; keys = bigArrays . newLongArray ( capacity ( ) , false ) ; values = bigArrays . newObjectArray ( capacity ( ) ) ; } public T get ( long key ) { for ( long i = slot ( hash ( key ) , mask ) ; ; i = nextSlot ( i , mask ) ) { final T value = values . get ( i ) ; if ( value = = null ) { return null ; } else if ( keys . get ( i ) = = key ) { return value ; } } } public T put ( long key , T value ) { if ( size > = maxSize ) { assert size = = maxSize ; grow ( ) ; } assert size < maxSize ; return set ( key , value ) ; } public T remove ( long key ) { for ( long i = slot ( hash ( key ) , mask ) ; ; i = nextSlot ( i , mask ) ) { final T previous = values . set ( i , null ) ; if ( previous = = null ) { return null ; } else if ( keys . get ( i ) = = key ) { - - size ; for ( long j = nextSlot ( i , mask ) ; used ( j ) ; j = nextSlot ( j , mask ) ) { removeAndAdd ( j ) ; } return previous ; } else { values . set ( i , previous ) ; } } } private T set ( long key , T value ) { if ( value = = null ) { throw new IllegalArgumentException ( <str> ) ; } for ( long i = slot ( hash ( key ) , mask ) ; ; i = nextSlot ( i , mask ) ) { final T previous = values . set ( i , value ) ; if ( previous = = null ) { keys . set ( i , key ) ; + + size ; return null ; } else if ( key = = keys . get ( i ) ) { return previous ; } else { values . set ( i , previous ) ; } } } @Override public Iterator < Cursor < T > > iterator ( ) { return new Iterator < Cursor < T > > ( ) { boolean cached ; final Cursor < T > cursor ; { cursor = new Cursor < > ( ) ; cursor . index = - <int> ; cached = false ; } @Override public boolean hasNext ( ) { if ( ! cached ) { while ( true ) { + + cursor . index ; if ( cursor . index > = capacity ( ) ) { break ; } else if ( used ( cursor . index ) ) { cursor . key = keys . get ( cursor . index ) ; cursor . value = values . get ( cursor . index ) ; break ; } } cached = true ; } return cursor . index < capacity ( ) ; } @Override public Cursor < T > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } cached = false ; return cursor ; } @Override public final void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @Override public void close ( ) { Releasables . close ( keys , values ) ; } @Override protected void resize ( long capacity ) { keys = bigArrays . resize ( keys , capacity ) ; values = bigArrays . resize ( values , capacity ) ; } @Override protected boolean used ( long bucket ) { return values . get ( bucket ) ! = null ; } @Override protected void removeAndAdd ( long index ) { final long key = keys . get ( index ) ; final T value = values . set ( index , null ) ; - - size ; final T removed = set ( key , value ) ; assert removed = = null ; } public static final class Cursor < T > { public long index ; public long key ; public T value ; } } 
