package org . elasticsearch . cluster . routing ; import com . carrotsearch . hppc . IntSet ; import com . carrotsearch . hppc . cursors . IntCursor ; import com . carrotsearch . hppc . cursors . IntObjectCursor ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . cluster . AbstractDiffable ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . collect . ImmutableOpenIntMap ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . ThreadLocalRandom ; public class IndexRoutingTable extends AbstractDiffable < IndexRoutingTable > implements Iterable < IndexShardRoutingTable > { public static final IndexRoutingTable PROTO = builder ( <str> ) . build ( ) ; private final String index ; private final ShardShuffler shuffler ; private final ImmutableOpenIntMap < IndexShardRoutingTable > shards ; private final List < ShardRouting > allActiveShards ; IndexRoutingTable ( String index , ImmutableOpenIntMap < IndexShardRoutingTable > shards ) { this . index = index ; this . shuffler = new RotationShardShuffler ( ThreadLocalRandom . current ( ) . nextInt ( ) ) ; this . shards = shards ; List < ShardRouting > allActiveShards = new ArrayList < > ( ) ; for ( IntObjectCursor < IndexShardRoutingTable > cursor : shards ) { for ( ShardRouting shardRouting : cursor . value ) { shardRouting . freeze ( ) ; if ( shardRouting . active ( ) ) { allActiveShards . add ( shardRouting ) ; } } } this . allActiveShards = Collections . unmodifiableList ( allActiveShards ) ; } public String index ( ) { return this . index ; } public String getIndex ( ) { return index ( ) ; } public IndexRoutingTable normalizeVersions ( ) { IndexRoutingTable . Builder builder = new Builder ( this . index ) ; for ( IntObjectCursor < IndexShardRoutingTable > cursor : shards ) { builder . addIndexShard ( cursor . value . normalizeVersions ( ) ) ; } return builder . build ( ) ; } public void validate ( RoutingTableValidation validation , MetaData metaData ) { if ( ! metaData . hasIndex ( index ( ) ) ) { validation . addIndexFailure ( index ( ) , <str> ) ; return ; } IndexMetaData indexMetaData = metaData . index ( index ( ) ) ; for ( String failure : validate ( indexMetaData ) ) { validation . addIndexFailure ( index , failure ) ; } } public List < String > validate ( IndexMetaData indexMetaData ) { ArrayList < String > failures = new ArrayList < > ( ) ; if ( indexMetaData . getNumberOfShards ( ) ! = shards ( ) . size ( ) ) { Set < Integer > expected = new HashSet < > ( ) ; for ( int i = <int> ; i < indexMetaData . getNumberOfShards ( ) ; i + + ) { expected . add ( i ) ; } for ( IndexShardRoutingTable indexShardRoutingTable : this ) { expected . remove ( indexShardRoutingTable . shardId ( ) . id ( ) ) ; } failures . add ( <str> + expected ) ; } for ( IndexShardRoutingTable indexShardRoutingTable : this ) { int routingNumberOfReplicas = indexShardRoutingTable . size ( ) - <int> ; if ( routingNumberOfReplicas ! = indexMetaData . getNumberOfReplicas ( ) ) { failures . add ( <str> + indexShardRoutingTable . shardId ( ) . id ( ) + <str> + indexMetaData . getNumberOfReplicas ( ) + <str> + routingNumberOfReplicas + <str> ) ; } for ( ShardRouting shardRouting : indexShardRoutingTable ) { if ( ! shardRouting . index ( ) . equals ( index ( ) ) ) { failures . add ( <str> + shardRouting . index ( ) + <str> ) ; } } } return failures ; } @Override public Iterator < IndexShardRoutingTable > iterator ( ) { return shards . valuesIt ( ) ; } public int numberOfNodesShardsAreAllocatedOn ( String . . . excludedNodes ) { Set < String > nodes = new HashSet < > ( ) ; for ( IndexShardRoutingTable shardRoutingTable : this ) { for ( ShardRouting shardRouting : shardRoutingTable ) { if ( shardRouting . assignedToNode ( ) ) { String currentNodeId = shardRouting . currentNodeId ( ) ; boolean excluded = false ; if ( excludedNodes ! = null ) { for ( String excludedNode : excludedNodes ) { if ( currentNodeId . equals ( excludedNode ) ) { excluded = true ; break ; } } } if ( ! excluded ) { nodes . add ( currentNodeId ) ; } } } } return nodes . size ( ) ; } public ImmutableOpenIntMap < IndexShardRoutingTable > shards ( ) { return shards ; } public ImmutableOpenIntMap < IndexShardRoutingTable > getShards ( ) { return shards ( ) ; } public IndexShardRoutingTable shard ( int shardId ) { return shards . get ( shardId ) ; } public boolean allPrimaryShardsActive ( ) { return primaryShardsActive ( ) = = shards ( ) . size ( ) ; } public int primaryShardsActive ( ) { int counter = <int> ; for ( IndexShardRoutingTable shardRoutingTable : this ) { if ( shardRoutingTable . primaryShard ( ) . active ( ) ) { counter + + ; } } return counter ; } public boolean allPrimaryShardsUnassigned ( ) { return primaryShardsUnassigned ( ) = = shards . size ( ) ; } public int primaryShardsUnassigned ( ) { int counter = <int> ; for ( IndexShardRoutingTable shardRoutingTable : this ) { if ( shardRoutingTable . primaryShard ( ) . unassigned ( ) ) { counter + + ; } } return counter ; } public List < ShardRouting > shardsWithState ( ShardRoutingState state ) { List < ShardRouting > shards = new ArrayList < > ( ) ; for ( IndexShardRoutingTable shardRoutingTable : this ) { shards . addAll ( shardRoutingTable . shardsWithState ( state ) ) ; } return shards ; } public ShardsIterator randomAllActiveShardsIt ( ) { return new PlainShardsIterator ( shuffler . shuffle ( allActiveShards ) ) ; } public GroupShardsIterator groupByShardsIt ( ) { ArrayList < ShardIterator > set = new ArrayList < > ( shards . size ( ) ) ; for ( IndexShardRoutingTable indexShard : this ) { set . add ( indexShard . shardsIt ( ) ) ; } return new GroupShardsIterator ( set ) ; } public GroupShardsIterator groupByAllIt ( ) { ArrayList < ShardIterator > set = new ArrayList < > ( ) ; for ( IndexShardRoutingTable indexShard : this ) { for ( ShardRouting shardRouting : indexShard ) { set . add ( shardRouting . shardsIt ( ) ) ; } } return new GroupShardsIterator ( set ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; IndexRoutingTable that = ( IndexRoutingTable ) o ; if ( ! index . equals ( that . index ) ) return false ; if ( ! shards . equals ( that . shards ) ) return false ; return true ; } @Override public int hashCode ( ) { int result = index . hashCode ( ) ; result = <int> * result + shards . hashCode ( ) ; return result ; } public void validate ( ) throws RoutingValidationException { } @Override public IndexRoutingTable readFrom ( StreamInput in ) throws IOException { String index = in . readString ( ) ; Builder builder = new Builder ( index ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { builder . addIndexShard ( IndexShardRoutingTable . Builder . readFromThin ( in , index ) ) ; } return builder . build ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( index ) ; out . writeVInt ( shards . size ( ) ) ; for ( IndexShardRoutingTable indexShard : this ) { IndexShardRoutingTable . Builder . writeToThin ( indexShard , out ) ; } } public static Builder builder ( String index ) { return new Builder ( index ) ; } public static class Builder { private final String index ; private final ImmutableOpenIntMap . Builder < IndexShardRoutingTable > shards = ImmutableOpenIntMap . builder ( ) ; public Builder ( String index ) { this . index = index ; } public static IndexRoutingTable readFrom ( StreamInput in ) throws IOException { return PROTO . readFrom ( in ) ; } public Builder initializeAsNew ( IndexMetaData indexMetaData ) { return initializeEmpty ( indexMetaData , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , null ) ) ; } public Builder initializeAsRecovery ( IndexMetaData indexMetaData ) { return initializeEmpty ( indexMetaData , new UnassignedInfo ( UnassignedInfo . Reason . CLUSTER_RECOVERED , null ) ) ; } public Builder initializeAsFromDangling ( IndexMetaData indexMetaData ) { return initializeEmpty ( indexMetaData , new UnassignedInfo ( UnassignedInfo . Reason . DANGLING_INDEX_IMPORTED , null ) ) ; } public Builder initializeAsFromCloseToOpen ( IndexMetaData indexMetaData ) { return initializeEmpty ( indexMetaData , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_REOPENED , null ) ) ; } public Builder initializeAsNewRestore ( IndexMetaData indexMetaData , RestoreSource restoreSource , IntSet ignoreShards ) { return initializeAsRestore ( indexMetaData , restoreSource , ignoreShards , true , new UnassignedInfo ( UnassignedInfo . Reason . NEW_INDEX_RESTORED , <str> + restoreSource . snapshotId ( ) . getRepository ( ) + <str> + restoreSource . snapshotId ( ) . getSnapshot ( ) + <str> ) ) ; } public Builder initializeAsRestore ( IndexMetaData indexMetaData , RestoreSource restoreSource ) { return initializeAsRestore ( indexMetaData , restoreSource , null , false , new UnassignedInfo ( UnassignedInfo . Reason . EXISTING_INDEX_RESTORED , <str> + restoreSource . snapshotId ( ) . getRepository ( ) + <str> + restoreSource . snapshotId ( ) . getSnapshot ( ) + <str> ) ) ; } private Builder initializeAsRestore ( IndexMetaData indexMetaData , RestoreSource restoreSource , IntSet ignoreShards , boolean asNew , UnassignedInfo unassignedInfo ) { if ( ! shards . isEmpty ( ) ) { throw new IllegalStateException ( <str> ) ; } for ( int shardId = <int> ; shardId < indexMetaData . getNumberOfShards ( ) ; shardId + + ) { IndexShardRoutingTable . Builder indexShardRoutingBuilder = new IndexShardRoutingTable . Builder ( new ShardId ( indexMetaData . getIndex ( ) , shardId ) ) ; for ( int i = <int> ; i < = indexMetaData . getNumberOfReplicas ( ) ; i + + ) { if ( asNew & & ignoreShards . contains ( shardId ) ) { indexShardRoutingBuilder . addShard ( ShardRouting . newUnassigned ( index , shardId , null , i = = <int> , unassignedInfo ) ) ; } else { indexShardRoutingBuilder . addShard ( ShardRouting . newUnassigned ( index , shardId , i = = <int> ? restoreSource : null , i = = <int> , unassignedInfo ) ) ; } } shards . put ( shardId , indexShardRoutingBuilder . build ( ) ) ; } return this ; } private Builder initializeEmpty ( IndexMetaData indexMetaData , UnassignedInfo unassignedInfo ) { if ( ! shards . isEmpty ( ) ) { throw new IllegalStateException ( <str> ) ; } for ( int shardId = <int> ; shardId < indexMetaData . getNumberOfShards ( ) ; shardId + + ) { IndexShardRoutingTable . Builder indexShardRoutingBuilder = new IndexShardRoutingTable . Builder ( new ShardId ( indexMetaData . getIndex ( ) , shardId ) ) ; for ( int i = <int> ; i < = indexMetaData . getNumberOfReplicas ( ) ; i + + ) { indexShardRoutingBuilder . addShard ( ShardRouting . newUnassigned ( index , shardId , null , i = = <int> , unassignedInfo ) ) ; } shards . put ( shardId , indexShardRoutingBuilder . build ( ) ) ; } return this ; } public Builder addReplica ( ) { for ( IntCursor cursor : shards . keys ( ) ) { int shardId = cursor . value ; ShardRouting shard = ShardRouting . newUnassigned ( index , shardId , null , false , new UnassignedInfo ( UnassignedInfo . Reason . REPLICA_ADDED , null ) ) ; shards . put ( shardId , new IndexShardRoutingTable . Builder ( shards . get ( shard . id ( ) ) ) . addShard ( shard ) . build ( ) ) ; } return this ; } public Builder removeReplica ( ) { for ( IntCursor cursor : shards . keys ( ) ) { int shardId = cursor . value ; IndexShardRoutingTable indexShard = shards . get ( shardId ) ; if ( indexShard . replicaShards ( ) . isEmpty ( ) ) { return this ; } IndexShardRoutingTable . Builder builder = new IndexShardRoutingTable . Builder ( indexShard . shardId ( ) ) ; for ( ShardRouting shardRouting : indexShard ) { builder . addShard ( new ShardRouting ( shardRouting ) ) ; } boolean removed = false ; for ( ShardRouting shardRouting : indexShard ) { if ( ! shardRouting . primary ( ) & & ! shardRouting . assignedToNode ( ) ) { builder . removeShard ( shardRouting ) ; removed = true ; break ; } } if ( ! removed ) { for ( ShardRouting shardRouting : indexShard ) { if ( ! shardRouting . primary ( ) ) { builder . removeShard ( shardRouting ) ; break ; } } } shards . put ( shardId , builder . build ( ) ) ; } return this ; } public Builder addIndexShard ( IndexShardRoutingTable indexShard ) { shards . put ( indexShard . shardId ( ) . id ( ) , indexShard ) ; return this ; } public Builder addShard ( IndexShardRoutingTable refData , ShardRouting shard ) { IndexShardRoutingTable indexShard = shards . get ( shard . id ( ) ) ; if ( indexShard = = null ) { indexShard = new IndexShardRoutingTable . Builder ( refData . shardId ( ) ) . addShard ( new ShardRouting ( shard ) ) . build ( ) ; } else { indexShard = new IndexShardRoutingTable . Builder ( indexShard ) . addShard ( new ShardRouting ( shard ) ) . build ( ) ; } shards . put ( indexShard . shardId ( ) . id ( ) , indexShard ) ; return this ; } public IndexRoutingTable build ( ) throws RoutingValidationException { IndexRoutingTable indexRoutingTable = new IndexRoutingTable ( index , shards . build ( ) ) ; indexRoutingTable . validate ( ) ; return indexRoutingTable ; } } public String prettyPrint ( ) { StringBuilder sb = new StringBuilder ( <str> + index + <str> ) ; List < IndexShardRoutingTable > ordered = new ArrayList < > ( ) ; for ( IndexShardRoutingTable indexShard : this ) { ordered . add ( indexShard ) ; } CollectionUtil . timSort ( ordered , new Comparator < IndexShardRoutingTable > ( ) { @Override public int compare ( IndexShardRoutingTable o1 , IndexShardRoutingTable o2 ) { int v = o1 . shardId ( ) . index ( ) . name ( ) . compareTo ( o2 . shardId ( ) . index ( ) . name ( ) ) ; if ( v = = <int> ) { v = Integer . compare ( o1 . shardId ( ) . id ( ) , o2 . shardId ( ) . id ( ) ) ; } return v ; } } ) ; for ( IndexShardRoutingTable indexShard : ordered ) { sb . append ( <str> ) . append ( indexShard . shardId ( ) . index ( ) . name ( ) ) . append ( <str> ) . append ( indexShard . shardId ( ) . id ( ) ) . append ( <str> ) ; for ( ShardRouting shard : indexShard ) { sb . append ( <str> ) . append ( shard . shortSummary ( ) ) . append ( <str> ) ; } } return sb . toString ( ) ; } } 
