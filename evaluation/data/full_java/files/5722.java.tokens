package org . elasticsearch . common . geo ; import org . apache . lucene . util . Bits ; import org . apache . lucene . util . SloppyMath ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . index . fielddata . FieldData ; import org . elasticsearch . index . fielddata . GeoPointValues ; import org . elasticsearch . index . fielddata . MultiGeoPointValues ; import org . elasticsearch . index . fielddata . NumericDoubleValues ; import org . elasticsearch . index . fielddata . SortedNumericDoubleValues ; import org . elasticsearch . index . fielddata . SortingNumericDoubleValues ; import java . io . IOException ; import java . util . Locale ; public enum GeoDistance implements Writeable < GeoDistance > { PLANE { @Override public double calculate ( double sourceLatitude , double sourceLongitude , double targetLatitude , double targetLongitude , DistanceUnit unit ) { double px = targetLongitude - sourceLongitude ; double py = targetLatitude - sourceLatitude ; return Math . sqrt ( px * px + py * py ) * unit . getDistancePerDegree ( ) ; } @Override public double normalize ( double distance , DistanceUnit unit ) { return distance ; } @Override public FixedSourceDistance fixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { return new PlaneFixedSourceDistance ( sourceLatitude , sourceLongitude , unit ) ; } } , FACTOR { @Override public double calculate ( double sourceLatitude , double sourceLongitude , double targetLatitude , double targetLongitude , DistanceUnit unit ) { double longitudeDifference = targetLongitude - sourceLongitude ; double a = Math . toRadians ( <int> D - sourceLatitude ) ; double c = Math . toRadians ( <int> D - targetLatitude ) ; return ( Math . cos ( a ) * Math . cos ( c ) ) + ( Math . sin ( a ) * Math . sin ( c ) * Math . cos ( Math . toRadians ( longitudeDifference ) ) ) ; } @Override public double normalize ( double distance , DistanceUnit unit ) { return Math . cos ( distance / unit . getEarthRadius ( ) ) ; } @Override public FixedSourceDistance fixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { return new FactorFixedSourceDistance ( sourceLatitude , sourceLongitude , unit ) ; } } , ARC { @Override public double calculate ( double sourceLatitude , double sourceLongitude , double targetLatitude , double targetLongitude , DistanceUnit unit ) { double x1 = sourceLatitude * Math . PI / <int> D ; double x2 = targetLatitude * Math . PI / <int> D ; double h1 = <float> - Math . cos ( x1 - x2 ) ; double h2 = <float> - Math . cos ( ( sourceLongitude - targetLongitude ) * Math . PI / <int> D ) ; double h = ( h1 + Math . cos ( x1 ) * Math . cos ( x2 ) * h2 ) / <int> ; double averageLatitude = ( x1 + x2 ) / <int> ; double diameter = GeoUtils . earthDiameter ( averageLatitude ) ; return unit . fromMeters ( diameter * Math . asin ( Math . min ( <int> , Math . sqrt ( h ) ) ) ) ; } @Override public double normalize ( double distance , DistanceUnit unit ) { return distance ; } @Override public FixedSourceDistance fixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { return new ArcFixedSourceDistance ( sourceLatitude , sourceLongitude , unit ) ; } } , SLOPPY_ARC { @Override public double normalize ( double distance , DistanceUnit unit ) { return distance ; } @Override public double calculate ( double sourceLatitude , double sourceLongitude , double targetLatitude , double targetLongitude , DistanceUnit unit ) { return unit . fromMeters ( SloppyMath . haversin ( sourceLatitude , sourceLongitude , targetLatitude , targetLongitude ) * <float> ) ; } @Override public FixedSourceDistance fixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { return new SloppyArcFixedSourceDistance ( sourceLatitude , sourceLongitude , unit ) ; } } ; @Override public GeoDistance readFrom ( StreamInput in ) throws IOException { int ord = in . readVInt ( ) ; if ( ord < <int> | | ord > = values ( ) . length ) { throw new IOException ( <str> + ord + <str> ) ; } return GeoDistance . values ( ) [ ord ] ; } public static GeoDistance readGeoDistanceFrom ( StreamInput in ) throws IOException { return DEFAULT . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( this . ordinal ( ) ) ; } public static final GeoDistance DEFAULT = SLOPPY_ARC ; public abstract double normalize ( double distance , DistanceUnit unit ) ; public abstract double calculate ( double sourceLatitude , double sourceLongitude , double targetLatitude , double targetLongitude , DistanceUnit unit ) ; public abstract FixedSourceDistance fixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) ; private static final double MIN_LAT = Math . toRadians ( - <int> d ) ; private static final double MAX_LAT = Math . toRadians ( <int> d ) ; private static final double MIN_LON = Math . toRadians ( - <int> d ) ; private static final double MAX_LON = Math . toRadians ( <int> d ) ; public static DistanceBoundingCheck distanceBoundingCheck ( double sourceLatitude , double sourceLongitude , double distance , DistanceUnit unit ) { double radDist = unit . toMeters ( distance ) / GeoUtils . EARTH_SEMI_MINOR_AXIS ; double radLat = Math . toRadians ( sourceLatitude ) ; double radLon = Math . toRadians ( sourceLongitude ) ; double minLat = radLat - radDist ; double maxLat = radLat + radDist ; double minLon , maxLon ; if ( minLat > MIN_LAT & & maxLat < MAX_LAT ) { double deltaLon = Math . asin ( Math . sin ( radDist ) / Math . cos ( radLat ) ) ; minLon = radLon - deltaLon ; if ( minLon < MIN_LON ) minLon + = <float> * Math . PI ; maxLon = radLon + deltaLon ; if ( maxLon > MAX_LON ) maxLon - = <float> * Math . PI ; } else { minLat = Math . max ( minLat , MIN_LAT ) ; maxLat = Math . min ( maxLat , MAX_LAT ) ; minLon = MIN_LON ; maxLon = MAX_LON ; } GeoPoint topLeft = new GeoPoint ( Math . toDegrees ( maxLat ) , Math . toDegrees ( minLon ) ) ; GeoPoint bottomRight = new GeoPoint ( Math . toDegrees ( minLat ) , Math . toDegrees ( maxLon ) ) ; if ( minLon > maxLon ) { return new Meridian180DistanceBoundingCheck ( topLeft , bottomRight ) ; } return new SimpleDistanceBoundingCheck ( topLeft , bottomRight ) ; } public static GeoDistance fromString ( String name ) { name = name . toLowerCase ( Locale . ROOT ) ; if ( <str> . equals ( name ) ) { return PLANE ; } else if ( <str> . equals ( name ) ) { return ARC ; } else if ( <str> . equals ( name ) ) { return SLOPPY_ARC ; } else if ( <str> . equals ( name ) ) { return FACTOR ; } throw new IllegalArgumentException ( <str> + name + <str> ) ; } public static interface FixedSourceDistance { double calculate ( double targetLatitude , double targetLongitude ) ; } public static interface DistanceBoundingCheck { boolean isWithin ( double targetLatitude , double targetLongitude ) ; GeoPoint topLeft ( ) ; GeoPoint bottomRight ( ) ; } public static final AlwaysDistanceBoundingCheck ALWAYS_INSTANCE = new AlwaysDistanceBoundingCheck ( ) ; private static class AlwaysDistanceBoundingCheck implements DistanceBoundingCheck { @Override public boolean isWithin ( double targetLatitude , double targetLongitude ) { return true ; } @Override public GeoPoint topLeft ( ) { return null ; } @Override public GeoPoint bottomRight ( ) { return null ; } } public static class Meridian180DistanceBoundingCheck implements DistanceBoundingCheck { private final GeoPoint topLeft ; private final GeoPoint bottomRight ; public Meridian180DistanceBoundingCheck ( GeoPoint topLeft , GeoPoint bottomRight ) { this . topLeft = topLeft ; this . bottomRight = bottomRight ; } @Override public boolean isWithin ( double targetLatitude , double targetLongitude ) { return ( targetLatitude > = bottomRight . lat ( ) & & targetLatitude < = topLeft . lat ( ) ) & & ( targetLongitude > = topLeft . lon ( ) | | targetLongitude < = bottomRight . lon ( ) ) ; } @Override public GeoPoint topLeft ( ) { return topLeft ; } @Override public GeoPoint bottomRight ( ) { return bottomRight ; } } public static class SimpleDistanceBoundingCheck implements DistanceBoundingCheck { private final GeoPoint topLeft ; private final GeoPoint bottomRight ; public SimpleDistanceBoundingCheck ( GeoPoint topLeft , GeoPoint bottomRight ) { this . topLeft = topLeft ; this . bottomRight = bottomRight ; } @Override public boolean isWithin ( double targetLatitude , double targetLongitude ) { return ( targetLatitude > = bottomRight . lat ( ) & & targetLatitude < = topLeft . lat ( ) ) & & ( targetLongitude > = topLeft . lon ( ) & & targetLongitude < = bottomRight . lon ( ) ) ; } @Override public GeoPoint topLeft ( ) { return topLeft ; } @Override public GeoPoint bottomRight ( ) { return bottomRight ; } } public static class PlaneFixedSourceDistance implements FixedSourceDistance { private final double sourceLatitude ; private final double sourceLongitude ; private final double distancePerDegree ; public PlaneFixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { this . sourceLatitude = sourceLatitude ; this . sourceLongitude = sourceLongitude ; this . distancePerDegree = unit . getDistancePerDegree ( ) ; } @Override public double calculate ( double targetLatitude , double targetLongitude ) { double px = targetLongitude - sourceLongitude ; double py = targetLatitude - sourceLatitude ; return Math . sqrt ( px * px + py * py ) * distancePerDegree ; } } public static class FactorFixedSourceDistance implements FixedSourceDistance { private final double sourceLongitude ; private final double a ; private final double sinA ; private final double cosA ; public FactorFixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { this . sourceLongitude = sourceLongitude ; this . a = Math . toRadians ( <int> D - sourceLatitude ) ; this . sinA = Math . sin ( a ) ; this . cosA = Math . cos ( a ) ; } @Override public double calculate ( double targetLatitude , double targetLongitude ) { double longitudeDifference = targetLongitude - sourceLongitude ; double c = Math . toRadians ( <int> D - targetLatitude ) ; return ( cosA * Math . cos ( c ) ) + ( sinA * Math . sin ( c ) * Math . cos ( Math . toRadians ( longitudeDifference ) ) ) ; } } public static abstract class FixedSourceDistanceBase implements FixedSourceDistance { protected final double sourceLatitude ; protected final double sourceLongitude ; protected final DistanceUnit unit ; public FixedSourceDistanceBase ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { this . sourceLatitude = sourceLatitude ; this . sourceLongitude = sourceLongitude ; this . unit = unit ; } } public static class ArcFixedSourceDistance extends FixedSourceDistanceBase { public ArcFixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { super ( sourceLatitude , sourceLongitude , unit ) ; } @Override public double calculate ( double targetLatitude , double targetLongitude ) { return ARC . calculate ( sourceLatitude , sourceLongitude , targetLatitude , targetLongitude , unit ) ; } } public static class SloppyArcFixedSourceDistance extends FixedSourceDistanceBase { public SloppyArcFixedSourceDistance ( double sourceLatitude , double sourceLongitude , DistanceUnit unit ) { super ( sourceLatitude , sourceLongitude , unit ) ; } @Override public double calculate ( double targetLatitude , double targetLongitude ) { return SLOPPY_ARC . calculate ( sourceLatitude , sourceLongitude , targetLatitude , targetLongitude , unit ) ; } } public static SortedNumericDoubleValues distanceValues ( final MultiGeoPointValues geoPointValues , final FixedSourceDistance . . . distances ) { final GeoPointValues singleValues = FieldData . unwrapSingleton ( geoPointValues ) ; if ( singleValues ! = null & & distances . length = = <int> ) { final Bits docsWithField = FieldData . unwrapSingletonBits ( geoPointValues ) ; return FieldData . singleton ( new NumericDoubleValues ( ) { @Override public double get ( int docID ) { if ( docsWithField ! = null & & ! docsWithField . get ( docID ) ) { return <float> ; } final GeoPoint point = singleValues . get ( docID ) ; return distances [ <int> ] . calculate ( point . lat ( ) , point . lon ( ) ) ; } } , docsWithField ) ; } else { return new SortingNumericDoubleValues ( ) { @Override public void setDocument ( int doc ) { geoPointValues . setDocument ( doc ) ; resize ( geoPointValues . count ( ) * distances . length ) ; int valueCounter = <int> ; for ( FixedSourceDistance distance : distances ) { for ( int i = <int> ; i < geoPointValues . count ( ) ; + + i ) { final GeoPoint point = geoPointValues . valueAt ( i ) ; values [ valueCounter ] = distance . calculate ( point . lat ( ) , point . lon ( ) ) ; valueCounter + + ; } } sort ( ) ; } } ; } } } 
