package org . elasticsearch . indices . flush ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . admin . indices . flush . FlushRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . common . util . concurrent . CountDown ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . shard . IndexEventListener ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . shard . ShardNotFoundException ; import org . elasticsearch . indices . IndexClosedException ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . BaseTransportResponseHandler ; import org . elasticsearch . transport . TransportChannel ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestHandler ; import org . elasticsearch . transport . TransportResponse ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentMap ; public class SyncedFlushService extends AbstractComponent implements IndexEventListener { private static final String PRE_SYNCED_FLUSH_ACTION_NAME = <str> ; private static final String SYNCED_FLUSH_ACTION_NAME = <str> ; private static final String IN_FLIGHT_OPS_ACTION_NAME = <str> ; private final IndicesService indicesService ; private final ClusterService clusterService ; private final TransportService transportService ; private final IndexNameExpressionResolver indexNameExpressionResolver ; @Inject public SyncedFlushService ( Settings settings , IndicesService indicesService , ClusterService clusterService , TransportService transportService , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings ) ; this . indicesService = indicesService ; this . clusterService = clusterService ; this . transportService = transportService ; this . indexNameExpressionResolver = indexNameExpressionResolver ; transportService . registerRequestHandler ( PRE_SYNCED_FLUSH_ACTION_NAME , PreSyncedFlushRequest : : new , ThreadPool . Names . FLUSH , new PreSyncedFlushTransportHandler ( ) ) ; transportService . registerRequestHandler ( SYNCED_FLUSH_ACTION_NAME , SyncedFlushRequest : : new , ThreadPool . Names . FLUSH , new SyncedFlushTransportHandler ( ) ) ; transportService . registerRequestHandler ( IN_FLIGHT_OPS_ACTION_NAME , InFlightOpsRequest : : new , ThreadPool . Names . SAME , new InFlightOpCountTransportHandler ( ) ) ; } @Override public void onShardInactive ( final IndexShard indexShard ) { if ( indexShard . routingEntry ( ) . primary ( ) ) { attemptSyncedFlush ( indexShard . shardId ( ) , new ActionListener < ShardsSyncedFlushResult > ( ) { @Override public void onResponse ( ShardsSyncedFlushResult syncedFlushResult ) { logger . trace ( <str> , syncedFlushResult . getShardId ( ) , syncedFlushResult . syncId ( ) ) ; } @Override public void onFailure ( Throwable e ) { logger . debug ( <str> , e , indexShard . shardId ( ) ) ; } } ) ; } } public void attemptSyncedFlush ( final String [ ] aliasesOrIndices , IndicesOptions indicesOptions , final ActionListener < IndicesSyncedFlushResult > listener ) { final ClusterState state = clusterService . state ( ) ; final String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( state , indicesOptions , aliasesOrIndices ) ; final Map < String , List < ShardsSyncedFlushResult > > results = ConcurrentCollections . newConcurrentMap ( ) ; int totalNumberOfShards = <int> ; int numberOfShards = <int> ; for ( String index : concreteIndices ) { final IndexMetaData indexMetaData = state . metaData ( ) . index ( index ) ; totalNumberOfShards + = indexMetaData . getTotalNumberOfShards ( ) ; numberOfShards + = indexMetaData . getNumberOfShards ( ) ; results . put ( index , Collections . synchronizedList ( new ArrayList < ShardsSyncedFlushResult > ( ) ) ) ; } if ( numberOfShards = = <int> ) { listener . onResponse ( new IndicesSyncedFlushResult ( results ) ) ; return ; } final int finalTotalNumberOfShards = totalNumberOfShards ; final CountDown countDown = new CountDown ( numberOfShards ) ; for ( final String index : concreteIndices ) { final int indexNumberOfShards = state . metaData ( ) . index ( index ) . getNumberOfShards ( ) ; for ( int shard = <int> ; shard < indexNumberOfShards ; shard + + ) { final ShardId shardId = new ShardId ( index , shard ) ; attemptSyncedFlush ( shardId , new ActionListener < ShardsSyncedFlushResult > ( ) { @Override public void onResponse ( ShardsSyncedFlushResult syncedFlushResult ) { results . get ( index ) . add ( syncedFlushResult ) ; if ( countDown . countDown ( ) ) { listener . onResponse ( new IndicesSyncedFlushResult ( results ) ) ; } } @Override public void onFailure ( Throwable e ) { logger . debug ( <str> , shardId ) ; results . get ( index ) . add ( new ShardsSyncedFlushResult ( shardId , finalTotalNumberOfShards , e . getMessage ( ) ) ) ; if ( countDown . countDown ( ) ) { listener . onResponse ( new IndicesSyncedFlushResult ( results ) ) ; } } } ) ; } } } public void attemptSyncedFlush ( final ShardId shardId , final ActionListener < ShardsSyncedFlushResult > actionListener ) { try { final ClusterState state = clusterService . state ( ) ; final IndexShardRoutingTable shardRoutingTable = getShardRoutingTable ( shardId , state ) ; final List < ShardRouting > activeShards = shardRoutingTable . activeShards ( ) ; final int totalShards = shardRoutingTable . getSize ( ) ; if ( activeShards . size ( ) = = <int> ) { actionListener . onResponse ( new ShardsSyncedFlushResult ( shardId , totalShards , <str> ) ) ; return ; } final ActionListener < Map < String , Engine . CommitId > > commitIdsListener = new ActionListener < Map < String , Engine . CommitId > > ( ) { @Override public void onResponse ( final Map < String , Engine . CommitId > commitIds ) { if ( commitIds . isEmpty ( ) ) { actionListener . onResponse ( new ShardsSyncedFlushResult ( shardId , totalShards , <str> ) ) ; return ; } final ActionListener < InFlightOpsResponse > inflightOpsListener = new ActionListener < InFlightOpsResponse > ( ) { @Override public void onResponse ( InFlightOpsResponse response ) { final int inflight = response . opCount ( ) ; assert inflight > = <int> ; if ( inflight ! = <int> ) { actionListener . onResponse ( new ShardsSyncedFlushResult ( shardId , totalShards , <str> + inflight + <str> ) ) ; } else { String syncId = Strings . base64UUID ( ) ; sendSyncRequests ( syncId , activeShards , state , commitIds , shardId , totalShards , actionListener ) ; } } @Override public void onFailure ( Throwable e ) { actionListener . onFailure ( e ) ; } } ; getInflightOpsCount ( shardId , state , shardRoutingTable , inflightOpsListener ) ; } @Override public void onFailure ( Throwable e ) { actionListener . onFailure ( e ) ; } } ; sendPreSyncRequests ( activeShards , state , shardId , commitIdsListener ) ; } catch ( Throwable t ) { actionListener . onFailure ( t ) ; } } final IndexShardRoutingTable getShardRoutingTable ( ShardId shardId , ClusterState state ) { final IndexRoutingTable indexRoutingTable = state . routingTable ( ) . index ( shardId . index ( ) . name ( ) ) ; if ( indexRoutingTable = = null ) { IndexMetaData index = state . getMetaData ( ) . index ( shardId . index ( ) . getName ( ) ) ; if ( index ! = null & & index . getState ( ) = = IndexMetaData . State . CLOSE ) { throw new IndexClosedException ( shardId . index ( ) ) ; } throw new IndexNotFoundException ( shardId . index ( ) . getName ( ) ) ; } final IndexShardRoutingTable shardRoutingTable = indexRoutingTable . shard ( shardId . id ( ) ) ; if ( shardRoutingTable = = null ) { throw new ShardNotFoundException ( shardId ) ; } return shardRoutingTable ; } protected void getInflightOpsCount ( final ShardId shardId , ClusterState state , IndexShardRoutingTable shardRoutingTable , final ActionListener < InFlightOpsResponse > listener ) { try { final ShardRouting primaryShard = shardRoutingTable . primaryShard ( ) ; final DiscoveryNode primaryNode = state . nodes ( ) . get ( primaryShard . currentNodeId ( ) ) ; if ( primaryNode = = null ) { logger . trace ( <str> , shardId , primaryShard ) ; listener . onResponse ( new InFlightOpsResponse ( - <int> ) ) ; return ; } logger . trace ( <str> , shardId ) ; transportService . sendRequest ( primaryNode , IN_FLIGHT_OPS_ACTION_NAME , new InFlightOpsRequest ( shardId ) , new BaseTransportResponseHandler < InFlightOpsResponse > ( ) { @Override public InFlightOpsResponse newInstance ( ) { return new InFlightOpsResponse ( ) ; } @Override public void handleResponse ( InFlightOpsResponse response ) { listener . onResponse ( response ) ; } @Override public void handleException ( TransportException exp ) { logger . debug ( <str> , shardId ) ; listener . onFailure ( exp ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) ; } catch ( Throwable t ) { listener . onFailure ( t ) ; } } void sendSyncRequests ( final String syncId , final List < ShardRouting > shards , ClusterState state , Map < String , Engine . CommitId > expectedCommitIds , final ShardId shardId , final int totalShards , final ActionListener < ShardsSyncedFlushResult > listener ) { final CountDown countDown = new CountDown ( shards . size ( ) ) ; final Map < ShardRouting , SyncedFlushResponse > results = ConcurrentCollections . newConcurrentMap ( ) ; for ( final ShardRouting shard : shards ) { final DiscoveryNode node = state . nodes ( ) . get ( shard . currentNodeId ( ) ) ; if ( node = = null ) { logger . trace ( <str> , shardId , syncId , shard ) ; results . put ( shard , new SyncedFlushResponse ( <str> ) ) ; contDownAndSendResponseIfDone ( syncId , shards , shardId , totalShards , listener , countDown , results ) ; continue ; } final Engine . CommitId expectedCommitId = expectedCommitIds . get ( shard . currentNodeId ( ) ) ; if ( expectedCommitId = = null ) { logger . trace ( <str> , shardId , syncId , shard ) ; results . put ( shard , new SyncedFlushResponse ( <str> ) ) ; contDownAndSendResponseIfDone ( syncId , shards , shardId , totalShards , listener , countDown , results ) ; continue ; } logger . trace ( <str> , shardId , shard , syncId ) ; transportService . sendRequest ( node , SYNCED_FLUSH_ACTION_NAME , new SyncedFlushRequest ( shard . shardId ( ) , syncId , expectedCommitId ) , new BaseTransportResponseHandler < SyncedFlushResponse > ( ) { @Override public SyncedFlushResponse newInstance ( ) { return new SyncedFlushResponse ( ) ; } @Override public void handleResponse ( SyncedFlushResponse response ) { SyncedFlushResponse existing = results . put ( shard , response ) ; assert existing = = null : <str> + node + <str> ; contDownAndSendResponseIfDone ( syncId , shards , shardId , totalShards , listener , countDown , results ) ; } @Override public void handleException ( TransportException exp ) { logger . trace ( <str> , exp , shardId , shard ) ; results . put ( shard , new SyncedFlushResponse ( exp . getMessage ( ) ) ) ; contDownAndSendResponseIfDone ( syncId , shards , shardId , totalShards , listener , countDown , results ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) ; } } private void contDownAndSendResponseIfDone ( String syncId , List < ShardRouting > shards , ShardId shardId , int totalShards , ActionListener < ShardsSyncedFlushResult > listener , CountDown countDown , Map < ShardRouting , SyncedFlushResponse > results ) { if ( countDown . countDown ( ) ) { assert results . size ( ) = = shards . size ( ) ; listener . onResponse ( new ShardsSyncedFlushResult ( shardId , syncId , totalShards , results ) ) ; } } void sendPreSyncRequests ( final List < ShardRouting > shards , final ClusterState state , final ShardId shardId , final ActionListener < Map < String , Engine . CommitId > > listener ) { final CountDown countDown = new CountDown ( shards . size ( ) ) ; final ConcurrentMap < String , Engine . CommitId > commitIds = ConcurrentCollections . newConcurrentMap ( ) ; for ( final ShardRouting shard : shards ) { logger . trace ( <str> , shardId , shard ) ; final DiscoveryNode node = state . nodes ( ) . get ( shard . currentNodeId ( ) ) ; if ( node = = null ) { logger . trace ( <str> , shardId , shard ) ; if ( countDown . countDown ( ) ) { listener . onResponse ( commitIds ) ; } continue ; } transportService . sendRequest ( node , PRE_SYNCED_FLUSH_ACTION_NAME , new PreSyncedFlushRequest ( shard . shardId ( ) ) , new BaseTransportResponseHandler < PreSyncedFlushResponse > ( ) { @Override public PreSyncedFlushResponse newInstance ( ) { return new PreSyncedFlushResponse ( ) ; } @Override public void handleResponse ( PreSyncedFlushResponse response ) { Engine . CommitId existing = commitIds . putIfAbsent ( node . id ( ) , response . commitId ( ) ) ; assert existing = = null : <str> + node + <str> ; if ( countDown . countDown ( ) ) { listener . onResponse ( commitIds ) ; } } @Override public void handleException ( TransportException exp ) { logger . trace ( <str> , exp , shardId , shard ) ; if ( countDown . countDown ( ) ) { listener . onResponse ( commitIds ) ; } } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } } ) ; } } private PreSyncedFlushResponse performPreSyncedFlush ( PreSyncedFlushRequest request ) { IndexShard indexShard = indicesService . indexServiceSafe ( request . shardId ( ) . getIndex ( ) ) . getShard ( request . shardId ( ) . id ( ) ) ; FlushRequest flushRequest = new FlushRequest ( ) . force ( false ) . waitIfOngoing ( true ) ; logger . trace ( <str> , request . shardId ( ) ) ; Engine . CommitId commitId = indexShard . flush ( flushRequest ) ; logger . trace ( <str> , request . shardId ( ) , commitId ) ; return new PreSyncedFlushResponse ( commitId ) ; } private SyncedFlushResponse performSyncedFlush ( SyncedFlushRequest request ) { IndexService indexService = indicesService . indexServiceSafe ( request . shardId ( ) . getIndex ( ) ) ; IndexShard indexShard = indexService . getShard ( request . shardId ( ) . id ( ) ) ; logger . trace ( <str> , request . shardId ( ) , request . syncId ( ) , request . expectedCommitId ( ) ) ; Engine . SyncedFlushResult result = indexShard . syncFlush ( request . syncId ( ) , request . expectedCommitId ( ) ) ; logger . trace ( <str> , request . shardId ( ) , request . syncId ( ) , result ) ; switch ( result ) { case SUCCESS : return new SyncedFlushResponse ( ) ; case COMMIT_MISMATCH : return new SyncedFlushResponse ( <str> ) ; case PENDING_OPERATIONS : return new SyncedFlushResponse ( <str> ) ; default : throw new ElasticsearchException ( <str> + result + <str> ) ; } } private InFlightOpsResponse performInFlightOps ( InFlightOpsRequest request ) { IndexService indexService = indicesService . indexServiceSafe ( request . shardId ( ) . getIndex ( ) ) ; IndexShard indexShard = indexService . getShard ( request . shardId ( ) . id ( ) ) ; if ( indexShard . routingEntry ( ) . primary ( ) = = false ) { throw new IllegalStateException ( <str> + request . shardId ( ) + <str> ) ; } int opCount = indexShard . getOperationsCount ( ) ; logger . trace ( <str> , request . shardId ( ) , opCount ) ; return new InFlightOpsResponse ( opCount ) ; } public final static class PreSyncedFlushRequest extends TransportRequest { private ShardId shardId ; public PreSyncedFlushRequest ( ) { } public PreSyncedFlushRequest ( ShardId shardId ) { this . shardId = shardId ; } @Override public String toString ( ) { return <str> + <str> + shardId + <str> ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; shardId . writeTo ( out ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; this . shardId = ShardId . readShardId ( in ) ; } public ShardId shardId ( ) { return shardId ; } } final static class PreSyncedFlushResponse extends TransportResponse { Engine . CommitId commitId ; PreSyncedFlushResponse ( ) { } PreSyncedFlushResponse ( Engine . CommitId commitId ) { this . commitId = commitId ; } public Engine . CommitId commitId ( ) { return commitId ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; commitId = new Engine . CommitId ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; commitId . writeTo ( out ) ; } } public static final class SyncedFlushRequest extends TransportRequest { private String syncId ; private Engine . CommitId expectedCommitId ; private ShardId shardId ; public SyncedFlushRequest ( ) { } public SyncedFlushRequest ( ShardId shardId , String syncId , Engine . CommitId expectedCommitId ) { this . expectedCommitId = expectedCommitId ; this . shardId = shardId ; this . syncId = syncId ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; shardId = ShardId . readShardId ( in ) ; expectedCommitId = new Engine . CommitId ( in ) ; syncId = in . readString ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; shardId . writeTo ( out ) ; expectedCommitId . writeTo ( out ) ; out . writeString ( syncId ) ; } public ShardId shardId ( ) { return shardId ; } public String syncId ( ) { return syncId ; } public Engine . CommitId expectedCommitId ( ) { return expectedCommitId ; } @Override public String toString ( ) { return <str> + <str> + shardId + <str> + syncId + <str> + <str> ; } } public static final class SyncedFlushResponse extends TransportResponse { String failureReason ; public SyncedFlushResponse ( ) { failureReason = null ; } public SyncedFlushResponse ( String failureReason ) { this . failureReason = failureReason ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; failureReason = in . readOptionalString ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeOptionalString ( failureReason ) ; } public boolean success ( ) { return failureReason = = null ; } public String failureReason ( ) { return failureReason ; } @Override public String toString ( ) { return <str> + <str> + success ( ) + <str> + failureReason + <str> + <str> ; } } public static final class InFlightOpsRequest extends TransportRequest { private ShardId shardId ; public InFlightOpsRequest ( ) { } public InFlightOpsRequest ( ShardId shardId ) { this . shardId = shardId ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; shardId = ShardId . readShardId ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; shardId . writeTo ( out ) ; } public ShardId shardId ( ) { return shardId ; } @Override public String toString ( ) { return <str> + <str> + shardId + <str> ; } } static final class InFlightOpsResponse extends TransportResponse { int opCount ; public InFlightOpsResponse ( ) { } public InFlightOpsResponse ( int opCount ) { this . opCount = opCount ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; opCount = in . readVInt ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( opCount ) ; } public int opCount ( ) { return opCount ; } @Override public String toString ( ) { return <str> + <str> + opCount + <str> ; } } private final class PreSyncedFlushTransportHandler implements TransportRequestHandler < PreSyncedFlushRequest > { @Override public void messageReceived ( PreSyncedFlushRequest request , TransportChannel channel ) throws Exception { channel . sendResponse ( performPreSyncedFlush ( request ) ) ; } } private final class SyncedFlushTransportHandler implements TransportRequestHandler < SyncedFlushRequest > { @Override public void messageReceived ( SyncedFlushRequest request , TransportChannel channel ) throws Exception { channel . sendResponse ( performSyncedFlush ( request ) ) ; } } private final class InFlightOpCountTransportHandler implements TransportRequestHandler < InFlightOpsRequest > { @Override public void messageReceived ( InFlightOpsRequest request , TransportChannel channel ) throws Exception { channel . sendResponse ( performInFlightOps ( request ) ) ; } } } 
