package org . gradle . api . internal . artifacts ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . artifacts . ExcludeRule ; import org . gradle . util . WrapUtil ; import org . junit . Test ; import java . util . * ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . assertThat ; public class DefaultExcludeRuleContainerTest { @Test public void testInit ( ) { assertThat ( new DefaultExcludeRuleContainer ( ) . getRules ( ) . size ( ) , equalTo ( <int> ) ) ; } @Test public void testInitWithRules ( ) { Set < ExcludeRule > sourceExcludeRules = new HashSet < ExcludeRule > ( ) ; sourceExcludeRules . add ( new DefaultExcludeRule ( <str> , null ) ) ; DefaultExcludeRuleContainer defaultExcludeRuleContainer = new DefaultExcludeRuleContainer ( sourceExcludeRules ) ; assertThat ( defaultExcludeRuleContainer . getRules ( ) , equalTo ( sourceExcludeRules ) ) ; assertThat ( defaultExcludeRuleContainer . getRules ( ) , not ( sameInstance ( sourceExcludeRules ) ) ) ; } @Test public void testAdd ( ) { DefaultExcludeRuleContainer excludeRuleContainer = new DefaultExcludeRuleContainer ( ) ; Map < String , String > excludeRuleArgs1 = WrapUtil . toMap ( <str> , <str> ) ; Map < String , String > excludeRuleArgs2 = WrapUtil . toMap ( <str> , <str> ) ; excludeRuleContainer . add ( excludeRuleArgs1 ) ; excludeRuleContainer . add ( excludeRuleArgs2 ) ; assertThat ( excludeRuleContainer . getRules ( ) . size ( ) , equalTo ( <int> ) ) ; assertExcludeRuleContainerHasCorrectExcludeRules ( excludeRuleContainer . getRules ( ) , excludeRuleArgs1 , excludeRuleArgs2 ) ; } @Test ( expected = InvalidUserDataException . class ) public void testInvalidExcludeDefinitionThrowsInvalidUserDataException ( ) { DefaultExcludeRuleContainer excludeRuleContainer = new DefaultExcludeRuleContainer ( ) ; Map < String , String > excludeRuleArgs1 = WrapUtil . toMap ( <str> , <str> ) ; Map < String , String > excludeRuleArgs2 = WrapUtil . toMap ( <str> , <str> ) ; excludeRuleContainer . add ( excludeRuleArgs1 ) ; excludeRuleContainer . add ( excludeRuleArgs2 ) ; } private void assertExcludeRuleContainerHasCorrectExcludeRules ( Set < ExcludeRule > excludeRules , Map . . . excludeRuleArgs ) { List < Map > foundRules = new ArrayList < Map > ( ) ; for ( ExcludeRule excludeRule : excludeRules ) { for ( Map excludeRuleArg : excludeRuleArgs ) { if ( matchingExcludeRule ( excludeRule , excludeRuleArg ) ) { foundRules . add ( excludeRuleArg ) ; continue ; } } } assertThat ( Arrays . asList ( excludeRuleArgs ) , equalTo ( foundRules ) ) ; } private boolean matchingExcludeRule ( ExcludeRule excludeRule , Map excludeRuleArg ) { final DefaultExcludeRule expectedExcludeRule = new DefaultExcludeRule ( ( String ) excludeRuleArg . get ( ExcludeRule . GROUP_KEY ) , ( String ) excludeRuleArg . get ( ExcludeRule . MODULE_KEY ) ) ; return excludeRule . equals ( expectedExcludeRule ) ; } } 
