package io . netty . handler . timeout ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelDuplexHandler ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOutboundHandlerAdapter ; import io . netty . channel . ChannelPromise ; import io . netty . util . internal . OneTimeTask ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; public class WriteTimeoutHandler extends ChannelOutboundHandlerAdapter { private static final long MIN_TIMEOUT_NANOS = TimeUnit . MILLISECONDS . toNanos ( <int> ) ; private final long timeoutNanos ; private boolean closed ; public WriteTimeoutHandler ( int timeoutSeconds ) { this ( timeoutSeconds , TimeUnit . SECONDS ) ; } public WriteTimeoutHandler ( long timeout , TimeUnit unit ) { if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } if ( timeout < = <int> ) { timeoutNanos = <int> ; } else { timeoutNanos = Math . max ( unit . toNanos ( timeout ) , MIN_TIMEOUT_NANOS ) ; } } @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { if ( timeoutNanos > <int> ) { promise = promise . unvoid ( ) ; scheduleTimeout ( ctx , promise ) ; } ctx . write ( msg , promise ) ; } private void scheduleTimeout ( final ChannelHandlerContext ctx , final ChannelPromise future ) { final ScheduledFuture < ? > sf = ctx . executor ( ) . schedule ( new OneTimeTask ( ) { @Override public void run ( ) { if ( ! future . isDone ( ) ) { try { writeTimedOut ( ctx ) ; } catch ( Throwable t ) { ctx . fireExceptionCaught ( t ) ; } } } } , timeoutNanos , TimeUnit . NANOSECONDS ) ; future . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { sf . cancel ( false ) ; } } ) ; } protected void writeTimedOut ( ChannelHandlerContext ctx ) throws Exception { if ( ! closed ) { ctx . fireExceptionCaught ( WriteTimeoutException . INSTANCE ) ; ctx . close ( ) ; closed = true ; } } } 
