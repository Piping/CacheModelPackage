package org . gradle . plugin . use . resolve . internal ; import org . gradle . api . internal . initialization . ClassLoaderScope ; import org . gradle . api . internal . plugins . DefaultPluginRegistry ; import org . gradle . api . internal . plugins . PluginImplementation ; import org . gradle . api . internal . plugins . PluginInspector ; import org . gradle . api . internal . plugins . PluginRegistry ; import org . gradle . api . plugins . UnknownPluginException ; import org . gradle . internal . Factory ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . plugin . internal . PluginId ; public class ClassPathPluginResolution implements PluginResolution { private final PluginId pluginId ; private final ClassLoaderScope parent ; private final Factory < ? extends ClassPath > classPathFactory ; private final PluginInspector pluginInspector ; public ClassPathPluginResolution ( PluginId pluginId , ClassLoaderScope parent , Factory < ? extends ClassPath > classPathFactory , PluginInspector pluginInspector ) { this . pluginId = pluginId ; this . parent = parent ; this . classPathFactory = classPathFactory ; this . pluginInspector = pluginInspector ; } public PluginId getPluginId ( ) { return pluginId ; } @Override public void execute ( PluginResolveContext pluginResolveContext ) { ClassPath classPath = classPathFactory . create ( ) ; ClassLoaderScope loaderScope = parent . createChild ( <str> + pluginId . asString ( ) ) ; loaderScope . local ( classPath ) ; loaderScope . lock ( ) ; PluginRegistry pluginRegistry = new DefaultPluginRegistry ( pluginInspector , loaderScope ) ; PluginImplementation < ? > plugin = pluginRegistry . lookup ( pluginId ) ; if ( plugin = = null ) { throw new UnknownPluginException ( <str> + pluginId + <str> ) ; } pluginResolveContext . add ( plugin ) ; } } 
