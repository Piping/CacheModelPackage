package org . apache . lucene . queries ; import org . apache . lucene . index . * ; import org . apache . lucene . search . * ; import org . apache . lucene . search . BooleanClause . Occur ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . InPlaceMergeSorter ; import org . apache . lucene . util . ToStringUtils ; import java . io . IOException ; import java . util . Arrays ; import java . util . List ; import java . util . Objects ; public abstract class BlendedTermQuery extends Query { private final Term [ ] terms ; private final float [ ] boosts ; public BlendedTermQuery ( Term [ ] terms , float [ ] boosts ) { if ( terms = = null | | terms . length = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( boosts ! = null & & boosts . length ! = terms . length ) { throw new IllegalArgumentException ( <str> ) ; } this . terms = terms ; this . boosts = boosts ; } @Override public Query rewrite ( IndexReader reader ) throws IOException { Query rewritten = super . rewrite ( reader ) ; if ( rewritten ! = this ) { return rewritten ; } IndexReaderContext context = reader . getContext ( ) ; TermContext [ ] ctx = new TermContext [ terms . length ] ; int [ ] docFreqs = new int [ ctx . length ] ; for ( int i = <int> ; i < terms . length ; i + + ) { ctx [ i ] = TermContext . build ( context , terms [ i ] ) ; docFreqs [ i ] = ctx [ i ] . docFreq ( ) ; } final int maxDoc = reader . maxDoc ( ) ; blend ( ctx , maxDoc , reader ) ; return topLevelQuery ( terms , ctx , docFreqs , maxDoc ) ; } protected abstract Query topLevelQuery ( Term [ ] terms , TermContext [ ] ctx , int [ ] docFreqs , int maxDoc ) ; protected void blend ( final TermContext [ ] contexts , int maxDoc , IndexReader reader ) throws IOException { if ( contexts . length < = <int> ) { return ; } int max = <int> ; long minSumTTF = Long . MAX_VALUE ; for ( int i = <int> ; i < contexts . length ; i + + ) { TermContext ctx = contexts [ i ] ; int df = ctx . docFreq ( ) ; max = Math . max ( df , max ) ; if ( minSumTTF ! = - <int> & & ctx . totalTermFreq ( ) ! = - <int> ) { minSumTTF = Math . min ( minSumTTF , reader . getSumTotalTermFreq ( terms [ i ] . field ( ) ) ) ; } else { minSumTTF = - <int> ; } } if ( minSumTTF ! = - <int> & & maxDoc > minSumTTF ) { maxDoc = ( int ) minSumTTF ; } if ( max = = <int> ) { return ; } long sumTTF = minSumTTF = = - <int> ? - <int> : <int> ; final int [ ] tieBreak = new int [ contexts . length ] ; for ( int i = <int> ; i < tieBreak . length ; + + i ) { tieBreak [ i ] = i ; } new InPlaceMergeSorter ( ) { @Override protected void swap ( int i , int j ) { final int tmp = tieBreak [ i ] ; tieBreak [ i ] = tieBreak [ j ] ; tieBreak [ j ] = tmp ; } @Override protected int compare ( int i , int j ) { return Integer . compare ( contexts [ tieBreak [ j ] ] . docFreq ( ) , contexts [ tieBreak [ i ] ] . docFreq ( ) ) ; } } . sort ( <int> , tieBreak . length ) ; int prev = contexts [ tieBreak [ <int> ] ] . docFreq ( ) ; int actualDf = Math . min ( maxDoc , max ) ; assert actualDf > = <int> : <str> ; for ( int i : tieBreak ) { TermContext ctx = contexts [ i ] ; if ( ctx . docFreq ( ) = = <int> ) { break ; } final int current = ctx . docFreq ( ) ; if ( prev > current ) { actualDf + + ; } contexts [ i ] = ctx = adjustDF ( ctx , Math . min ( maxDoc , actualDf ) ) ; prev = current ; if ( sumTTF > = <int> & & ctx . totalTermFreq ( ) > = <int> ) { sumTTF + = ctx . totalTermFreq ( ) ; } else { sumTTF = - <int> ; } } sumTTF = Math . min ( sumTTF , minSumTTF ) ; for ( int i = <int> ; i < contexts . length ; i + + ) { int df = contexts [ i ] . docFreq ( ) ; if ( df = = <int> ) { continue ; } final long fixedTTF = sumTTF = = - <int> ? - <int> : sumTTF ; contexts [ i ] = adjustTTF ( contexts [ i ] , fixedTTF ) ; } } private TermContext adjustTTF ( TermContext termContext , long sumTTF ) { if ( sumTTF = = - <int> & & termContext . totalTermFreq ( ) = = - <int> ) { return termContext ; } TermContext newTermContext = new TermContext ( termContext . topReaderContext ) ; List < LeafReaderContext > leaves = termContext . topReaderContext . leaves ( ) ; final int len ; if ( leaves = = null ) { len = <int> ; } else { len = leaves . size ( ) ; } int df = termContext . docFreq ( ) ; long ttf = sumTTF ; for ( int i = <int> ; i < len ; i + + ) { TermState termState = termContext . get ( i ) ; if ( termState = = null ) { continue ; } newTermContext . register ( termState , i , df , ttf ) ; df = <int> ; ttf = <int> ; } return newTermContext ; } private static TermContext adjustDF ( TermContext ctx , int newDocFreq ) { long newTTF ; if ( ctx . totalTermFreq ( ) < <int> ) { newTTF = - <int> ; } else { newTTF = Math . max ( ctx . totalTermFreq ( ) , newDocFreq ) ; } List < LeafReaderContext > leaves = ctx . topReaderContext . leaves ( ) ; final int len ; if ( leaves = = null ) { len = <int> ; } else { len = leaves . size ( ) ; } TermContext newCtx = new TermContext ( ctx . topReaderContext ) ; for ( int i = <int> ; i < len ; + + i ) { TermState termState = ctx . get ( i ) ; if ( termState = = null ) { continue ; } newCtx . register ( termState , i , newDocFreq , newTTF ) ; newDocFreq = <int> ; newTTF = <int> ; } return newCtx ; } @Override public String toString ( String field ) { StringBuilder builder = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < terms . length ; + + i ) { builder . append ( terms [ i ] ) ; float boost = <float> ; if ( boosts ! = null ) { boost = boosts [ i ] ; } builder . append ( ToStringUtils . boost ( boost ) ) ; builder . append ( <str> ) ; } if ( terms . length > <int> ) { builder . setLength ( builder . length ( ) - <int> ) ; } builder . append ( <str> ) ; builder . append ( ToStringUtils . boost ( getBoost ( ) ) ) ; return builder . toString ( ) ; } private volatile Term [ ] equalTerms = null ; private Term [ ] equalsTerms ( ) { if ( terms . length = = <int> ) { return terms ; } if ( equalTerms = = null ) { final Term [ ] t = new Term [ terms . length ] ; System . arraycopy ( terms , <int> , t , <int> , terms . length ) ; ArrayUtil . timSort ( t ) ; equalTerms = t ; } return equalTerms ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! super . equals ( o ) ) return false ; BlendedTermQuery that = ( BlendedTermQuery ) o ; return Arrays . equals ( equalsTerms ( ) , that . equalsTerms ( ) ) ; } @Override public int hashCode ( ) { return Objects . hash ( super . hashCode ( ) , Arrays . hashCode ( equalsTerms ( ) ) ) ; } public static BlendedTermQuery booleanBlendedQuery ( Term [ ] terms , final boolean disableCoord ) { return booleanBlendedQuery ( terms , null , disableCoord ) ; } public static BlendedTermQuery booleanBlendedQuery ( Term [ ] terms , final float [ ] boosts , final boolean disableCoord ) { return new BlendedTermQuery ( terms , boosts ) { @Override protected Query topLevelQuery ( Term [ ] terms , TermContext [ ] ctx , int [ ] docFreqs , int maxDoc ) { BooleanQuery . Builder booleanQueryBuilder = new BooleanQuery . Builder ( ) ; booleanQueryBuilder . setDisableCoord ( disableCoord ) ; for ( int i = <int> ; i < terms . length ; i + + ) { Query query = new TermQuery ( terms [ i ] , ctx [ i ] ) ; if ( boosts ! = null & & boosts [ i ] ! = <float> ) { query = new BoostQuery ( query , boosts [ i ] ) ; } booleanQueryBuilder . add ( query , BooleanClause . Occur . SHOULD ) ; } return booleanQueryBuilder . build ( ) ; } } ; } public static BlendedTermQuery commonTermsBlendedQuery ( Term [ ] terms , final float [ ] boosts , final boolean disableCoord , final float maxTermFrequency ) { return new BlendedTermQuery ( terms , boosts ) { @Override protected Query topLevelQuery ( Term [ ] terms , TermContext [ ] ctx , int [ ] docFreqs , int maxDoc ) { BooleanQuery . Builder highBuilder = new BooleanQuery . Builder ( ) ; highBuilder . setDisableCoord ( disableCoord ) ; BooleanQuery . Builder lowBuilder = new BooleanQuery . Builder ( ) ; lowBuilder . setDisableCoord ( disableCoord ) ; for ( int i = <int> ; i < terms . length ; i + + ) { Query query = new TermQuery ( terms [ i ] , ctx [ i ] ) ; if ( boosts ! = null & & boosts [ i ] ! = <float> ) { query = new BoostQuery ( query , boosts [ i ] ) ; } if ( ( maxTermFrequency > = <float> & & docFreqs [ i ] > maxTermFrequency ) | | ( docFreqs [ i ] > ( int ) Math . ceil ( maxTermFrequency * ( float ) maxDoc ) ) ) { highBuilder . add ( query , BooleanClause . Occur . SHOULD ) ; } else { lowBuilder . add ( query , BooleanClause . Occur . SHOULD ) ; } } BooleanQuery high = highBuilder . build ( ) ; BooleanQuery low = lowBuilder . build ( ) ; if ( low . clauses ( ) . isEmpty ( ) ) { BooleanQuery . Builder queryBuilder = new BooleanQuery . Builder ( ) ; queryBuilder . setDisableCoord ( disableCoord ) ; for ( BooleanClause booleanClause : high ) { queryBuilder . add ( booleanClause . getQuery ( ) , Occur . MUST ) ; } return queryBuilder . build ( ) ; } else if ( high . clauses ( ) . isEmpty ( ) ) { return low ; } else { return new BooleanQuery . Builder ( ) . setDisableCoord ( true ) . add ( high , BooleanClause . Occur . SHOULD ) . add ( low , BooleanClause . Occur . MUST ) . build ( ) ; } } } ; } public static BlendedTermQuery dismaxBlendedQuery ( Term [ ] terms , final float tieBreakerMultiplier ) { return dismaxBlendedQuery ( terms , null , tieBreakerMultiplier ) ; } public static BlendedTermQuery dismaxBlendedQuery ( Term [ ] terms , final float [ ] boosts , final float tieBreakerMultiplier ) { return new BlendedTermQuery ( terms , boosts ) { @Override protected Query topLevelQuery ( Term [ ] terms , TermContext [ ] ctx , int [ ] docFreqs , int maxDoc ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( tieBreakerMultiplier ) ; for ( int i = <int> ; i < terms . length ; i + + ) { Query query = new TermQuery ( terms [ i ] , ctx [ i ] ) ; if ( boosts ! = null & & boosts [ i ] ! = <float> ) { query = new BoostQuery ( query , boosts [ i ] ) ; } disMaxQuery . add ( query ) ; } return disMaxQuery ; } } ; } } 
