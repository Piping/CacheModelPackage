package org . nd4j . linalg . checkutil ; import org . apache . commons . math3 . util . Pair ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . NDArrayIndex ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class NDArrayCreationUtil { public static List < Pair < INDArray , String > > getAllTestMatricesWithShape ( int rows , int cols , int seed ) { List < Pair < INDArray , String > > all = new ArrayList < > ( ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; all . add ( new Pair < > ( Nd4j . rand ( rows , cols ) , <str> ) ) ; all . add ( getTransposedMatrixWithShape ( rows , cols , seed ) ) ; all . addAll ( getSubMatricesWithShape ( rows , cols , seed ) ) ; all . addAll ( getTensorAlongDimensionMatricesWithShape ( rows , cols , seed ) ) ; all . add ( getPermutedWithShape ( rows , cols , seed ) ) ; all . add ( getReshapedWithShape ( rows , cols , seed ) ) ; return all ; } public static Pair < INDArray , String > getTransposedMatrixWithShape ( int rows , int cols , int seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray out = Nd4j . rand ( new int [ ] { cols , rows } ) ; return new Pair < > ( out . transpose ( ) , <str> + rows + <str> + cols + <str> + seed + <str> ) ; } public static List < Pair < INDArray , String > > getSubMatricesWithShape ( int rows , int cols , int seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray orig = Nd4j . rand ( new int [ ] { <int> * rows + <int> , <int> * cols + <int> } ) ; INDArray first = orig . get ( NDArrayIndex . interval ( <int> , rows ) , NDArrayIndex . interval ( <int> , cols ) ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; orig = Nd4j . rand ( new int [ ] { <int> * rows + <int> , <int> * cols + <int> } ) ; INDArray second = orig . get ( NDArrayIndex . interval ( <int> , rows + <int> ) , NDArrayIndex . interval ( <int> , cols + <int> ) ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; orig = Nd4j . rand ( new int [ ] { <int> * rows + <int> , <int> * cols + <int> } ) ; INDArray third = orig . get ( NDArrayIndex . interval ( rows , <int> * rows ) , NDArrayIndex . interval ( cols , <int> * cols ) ) ; String baseMsg = <str> + rows + <str> + cols + <str> + seed + <str> ; List < Pair < INDArray , String > > list = new ArrayList < > ( <int> ) ; list . add ( new Pair < > ( first , baseMsg + <str> ) ) ; list . add ( new Pair < > ( second , baseMsg + <str> ) ) ; list . add ( new Pair < > ( third , baseMsg + <str> ) ) ; return list ; } public static List < Pair < INDArray , String > > getTensorAlongDimensionMatricesWithShape ( int rows , int cols , int seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray [ ] out = new INDArray [ <int> ] ; INDArray temp01 = Nd4j . rand ( new int [ ] { cols , rows , <int> } ) ; out [ <int> ] = temp01 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; temp01 = Nd4j . rand ( new int [ ] { cols , rows , <int> } ) ; out [ <int> ] = temp01 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray temp02 = Nd4j . rand ( new int [ ] { cols , <int> , rows } ) ; out [ <int> ] = temp02 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; temp02 = Nd4j . rand ( new int [ ] { cols , <int> , rows } ) ; out [ <int> ] = temp02 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray temp10 = Nd4j . rand ( new int [ ] { rows , cols , <int> } ) ; out [ <int> ] = temp10 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; temp10 = Nd4j . rand ( new int [ ] { rows , cols , <int> } ) ; out [ <int> ] = temp10 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray temp12 = Nd4j . rand ( new int [ ] { <int> , cols , rows } ) ; out [ <int> ] = temp12 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; temp12 = Nd4j . rand ( new int [ ] { <int> , cols , rows } ) ; out [ <int> ] = temp12 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray temp20 = Nd4j . rand ( new int [ ] { rows , <int> , cols } ) ; out [ <int> ] = temp20 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; temp20 = Nd4j . rand ( new int [ ] { rows , <int> , cols } ) ; out [ <int> ] = temp20 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray temp21 = Nd4j . rand ( new int [ ] { <int> , rows , cols } ) ; out [ <int> ] = temp21 . tensorAlongDimension ( <int> , <int> , <int> ) ; Nd4j . getRandom ( ) . setSeed ( seed ) ; temp21 = Nd4j . rand ( new int [ ] { <int> , rows , cols } ) ; out [ <int> ] = temp21 . tensorAlongDimension ( <int> , <int> , <int> ) ; String baseMsg = <str> + rows + <str> + cols + <str> + seed + <str> ; List < Pair < INDArray , String > > list = new ArrayList < > ( <int> ) ; for ( int i = <int> ; i < out . length ; i + + ) list . add ( new Pair < > ( out [ i ] , baseMsg + <str> + i + <str> ) ) ; return list ; } public static Pair < INDArray , String > getPermutedWithShape ( int rows , int cols , int seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray arr = Nd4j . rand ( new int [ ] { cols , rows } ) ; return new Pair < > ( arr . permute ( <int> , <int> ) , <str> + rows + <str> + cols + <str> + seed + <str> ) ; } public static Pair < INDArray , String > getReshapedWithShape ( int rows , int cols , int seed ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] origShape = new int [ <int> ] ; if ( rows % <int> = = <int> ) { origShape [ <int> ] = rows / <int> ; origShape [ <int> ] = cols ; origShape [ <int> ] = <int> ; } else if ( cols % <int> = = <int> ) { origShape [ <int> ] = rows ; origShape [ <int> ] = cols / <int> ; origShape [ <int> ] = <int> ; } else { origShape [ <int> ] = <int> ; origShape [ <int> ] = rows ; origShape [ <int> ] = cols ; } INDArray orig = Nd4j . rand ( origShape ) ; return new Pair < > ( orig . reshape ( rows , cols ) , <str> + rows + <str> + cols + <str> + seed + <str> ) ; } public static List < Pair < INDArray , String > > getAll3dTestArraysWithShape ( int seed , int . . . shape ) { if ( shape . length ! = <int> ) throw new IllegalArgumentException ( <str> ) ; List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray stdC = Nd4j . rand ( shape , <str> ) ; INDArray stdF = Nd4j . rand ( shape , <str> ) ; list . add ( new Pair < > ( stdC , baseMsg + <str> + Arrays . toString ( shape ) + <str> ) ) ; list . add ( new Pair < > ( stdF , baseMsg + <str> + Arrays . toString ( shape ) + <str> ) ) ; list . addAll ( get3dSubArraysWithShape ( seed , shape ) ) ; list . addAll ( get3dTensorAlongDimensionWithShape ( seed , shape ) ) ; list . addAll ( get3dPermutedWithShape ( seed , shape ) ) ; list . addAll ( get3dReshapedWithShape ( seed , shape ) ) ; return list ; } public static List < Pair < INDArray , String > > get3dSubArraysWithShape ( int seed , int . . . shape ) { List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] newShape1 = Arrays . copyOf ( shape , shape . length ) ; newShape1 [ <int> ] + = <int> ; INDArray temp1 = Nd4j . rand ( newShape1 ) ; INDArray subset1 = temp1 . get ( NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset1 , baseMsg + <str> ) ) ; int [ ] newShape2 = Arrays . copyOf ( shape , shape . length ) ; newShape2 [ <int> ] + = <int> ; INDArray temp2 = Nd4j . rand ( newShape2 ) ; INDArray subset2 = temp2 . get ( NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset2 , baseMsg + <str> ) ) ; int [ ] newShape3 = Arrays . copyOf ( shape , shape . length ) ; newShape3 [ <int> ] + = <int> ; INDArray temp3 = Nd4j . rand ( newShape3 ) ; INDArray subset3 = temp3 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) ) ; list . add ( new Pair < > ( subset3 , baseMsg + <str> ) ) ; int [ ] newShape4 = Arrays . copyOf ( shape , shape . length ) ; newShape4 [ <int> ] + = <int> ; newShape4 [ <int> ] + = <int> ; newShape4 [ <int> ] + = <int> ; INDArray temp4 = Nd4j . rand ( newShape4 ) ; INDArray subset4 = temp4 . get ( NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) ) ; list . add ( new Pair < > ( subset4 , baseMsg + <str> ) ) ; return list ; } public static List < Pair < INDArray , String > > get3dTensorAlongDimensionWithShape ( int seed , int . . . shape ) { List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] shape4d1 = { shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , <int> } ; INDArray orig1a = Nd4j . rand ( shape4d1 ) ; INDArray tad1a = orig1a . tensorAlongDimension ( <int> , <int> , <int> , <int> ) ; INDArray orig1b = Nd4j . rand ( shape4d1 ) ; INDArray tad1b = orig1b . tensorAlongDimension ( <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad1a , baseMsg + <str> ) ) ; list . add ( new Pair < > ( tad1b , baseMsg + <str> ) ) ; int [ ] shape4d2 = { <int> , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray orig2 = Nd4j . rand ( shape4d2 ) ; INDArray tad2 = orig2 . tensorAlongDimension ( <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad2 , baseMsg + <str> ) ) ; int [ ] shape4d3 = { shape [ <int> ] , shape [ <int> ] , <int> , shape [ <int> ] } ; INDArray orig3 = Nd4j . rand ( shape4d3 ) ; INDArray tad3 = orig3 . tensorAlongDimension ( <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad3 , baseMsg + <str> ) ) ; int [ ] shape4d4 = { shape [ <int> ] , <int> , shape [ <int> ] , shape [ <int> ] } ; INDArray orig4 = Nd4j . rand ( shape4d4 ) ; INDArray tad4 = orig4 . tensorAlongDimension ( <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad4 , baseMsg + <str> ) ) ; return list ; } public static List < Pair < INDArray , String > > get3dPermutedWithShape ( int seed , int . . . shape ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] createdShape = { shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray arr = Nd4j . rand ( createdShape ) ; INDArray permuted = arr . permute ( <int> , <int> , <int> ) ; return Collections . singletonList ( new Pair < INDArray , String > ( permuted , <str> + seed + <str> + Arrays . toString ( shape ) + <str> ) ) ; } public static List < Pair < INDArray , String > > get3dReshapedWithShape ( int seed , int . . . shape ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] shape2d = { shape [ <int> ] * shape [ <int> ] , shape [ <int> ] } ; INDArray array2d = Nd4j . rand ( shape2d ) ; INDArray array3d = array2d . reshape ( shape ) ; return Collections . singletonList ( new Pair < INDArray , String > ( array3d , <str> + seed + <str> + Arrays . toString ( shape ) + <str> ) ) ; } public static List < Pair < INDArray , String > > getAll4dTestArraysWithShape ( int seed , int . . . shape ) { if ( shape . length ! = <int> ) throw new IllegalArgumentException ( <str> ) ; List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray stdC = Nd4j . rand ( shape , <str> ) ; INDArray stdF = Nd4j . rand ( shape , <str> ) ; list . add ( new Pair < > ( stdC , baseMsg + <str> + Arrays . toString ( shape ) + <str> ) ) ; list . add ( new Pair < > ( stdF , baseMsg + <str> + Arrays . toString ( shape ) + <str> ) ) ; list . addAll ( get4dSubArraysWithShape ( seed , shape ) ) ; list . addAll ( get4dTensorAlongDimensionWithShape ( seed , shape ) ) ; list . addAll ( get4dPermutedWithShape ( seed , shape ) ) ; list . addAll ( get4dReshapedWithShape ( seed , shape ) ) ; return list ; } public static List < Pair < INDArray , String > > get4dSubArraysWithShape ( int seed , int . . . shape ) { List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] newShape1 = Arrays . copyOf ( shape , shape . length ) ; newShape1 [ <int> ] + = <int> ; INDArray temp1 = Nd4j . rand ( newShape1 ) ; INDArray subset1 = temp1 . get ( NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset1 , baseMsg + <str> ) ) ; int [ ] newShape2 = Arrays . copyOf ( shape , shape . length ) ; newShape2 [ <int> ] + = <int> ; INDArray temp2 = Nd4j . rand ( newShape2 ) ; INDArray subset2 = temp2 . get ( NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset2 , baseMsg + <str> ) ) ; int [ ] newShape3 = Arrays . copyOf ( shape , shape . length ) ; newShape3 [ <int> ] + = <int> ; INDArray temp3 = Nd4j . rand ( newShape3 ) ; INDArray subset3 = temp3 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset3 , baseMsg + <str> ) ) ; int [ ] newShape4 = Arrays . copyOf ( shape , shape . length ) ; newShape4 [ <int> ] + = <int> ; INDArray temp4 = Nd4j . rand ( newShape4 ) ; INDArray subset4 = temp4 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) ) ; list . add ( new Pair < > ( subset4 , baseMsg + <str> ) ) ; int [ ] newShape5 = Arrays . copyOf ( shape , shape . length ) ; newShape5 [ <int> ] + = <int> ; newShape5 [ <int> ] + = <int> ; newShape5 [ <int> ] + = <int> ; newShape5 [ <int> ] + = <int> ; INDArray temp5 = Nd4j . rand ( newShape5 ) ; INDArray subset5 = temp5 . get ( NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) ) ; list . add ( new Pair < > ( subset5 , baseMsg + <str> ) ) ; return list ; } public static List < Pair < INDArray , String > > get4dTensorAlongDimensionWithShape ( int seed , int . . . shape ) { List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] shape4d1 = { <int> , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray orig1a = Nd4j . rand ( shape4d1 ) ; INDArray tad1a = orig1a . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> ) ; INDArray orig1b = Nd4j . rand ( shape4d1 ) ; INDArray tad1b = orig1b . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad1a , baseMsg + <str> ) ) ; list . add ( new Pair < > ( tad1b , baseMsg + <str> ) ) ; int [ ] shape4d2 = { <int> , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray orig2 = Nd4j . rand ( shape4d2 ) ; INDArray tad2 = orig2 . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad2 , baseMsg + <str> ) ) ; int [ ] shape4d3 = { shape [ <int> ] , shape [ <int> ] , <int> , shape [ <int> ] , shape [ <int> ] } ; INDArray orig3 = Nd4j . rand ( shape4d3 ) ; INDArray tad3 = orig3 . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad3 , baseMsg + <str> ) ) ; int [ ] shape4d4 = { shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , <int> } ; INDArray orig4 = Nd4j . rand ( shape4d4 ) ; INDArray tad4 = orig4 . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad4 , baseMsg + <str> ) ) ; return list ; } public static List < Pair < INDArray , String > > get4dPermutedWithShape ( int seed , int . . . shape ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] createdShape = { shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray arr = Nd4j . rand ( createdShape ) ; INDArray permuted = arr . permute ( <int> , <int> , <int> , <int> ) ; return Collections . singletonList ( new Pair < INDArray , String > ( permuted , <str> + seed + <str> + Arrays . toString ( shape ) + <str> ) ) ; } public static List < Pair < INDArray , String > > get4dReshapedWithShape ( int seed , int . . . shape ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] shape2d = { shape [ <int> ] * shape [ <int> ] , shape [ <int> ] * shape [ <int> ] } ; INDArray array2d = Nd4j . rand ( shape2d ) ; INDArray array3d = array2d . reshape ( shape ) ; return Collections . singletonList ( new Pair < INDArray , String > ( array3d , <str> + seed + <str> + Arrays . toString ( shape ) + <str> ) ) ; } public static List < Pair < INDArray , String > > getAll5dTestArraysWithShape ( int seed , int . . . shape ) { if ( shape . length ! = <int> ) throw new IllegalArgumentException ( <str> ) ; List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray stdC = Nd4j . rand ( shape , <str> ) ; INDArray stdF = Nd4j . rand ( shape , <str> ) ; list . add ( new Pair < > ( stdC , baseMsg + <str> + Arrays . toString ( shape ) + <str> ) ) ; list . add ( new Pair < > ( stdF , baseMsg + <str> + Arrays . toString ( shape ) + <str> ) ) ; list . addAll ( get5dSubArraysWithShape ( seed , shape ) ) ; list . addAll ( get5dTensorAlongDimensionWithShape ( seed , shape ) ) ; list . addAll ( get5dPermutedWithShape ( seed , shape ) ) ; list . addAll ( get5dReshapedWithShape ( seed , shape ) ) ; return list ; } public static List < Pair < INDArray , String > > get5dSubArraysWithShape ( int seed , int . . . shape ) { List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] newShape1 = Arrays . copyOf ( shape , shape . length ) ; newShape1 [ <int> ] + = <int> ; INDArray temp1 = Nd4j . rand ( newShape1 ) ; INDArray subset1 = temp1 . get ( NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset1 , baseMsg + <str> ) ) ; int [ ] newShape2 = Arrays . copyOf ( shape , shape . length ) ; newShape2 [ <int> ] + = <int> ; INDArray temp2 = Nd4j . rand ( newShape2 ) ; INDArray subset2 = temp2 . get ( NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset2 , baseMsg + <str> ) ) ; int [ ] newShape3 = Arrays . copyOf ( shape , shape . length ) ; newShape3 [ <int> ] + = <int> ; INDArray temp3 = Nd4j . rand ( newShape3 ) ; INDArray subset3 = temp3 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset3 , baseMsg + <str> ) ) ; int [ ] newShape4 = Arrays . copyOf ( shape , shape . length ) ; newShape4 [ <int> ] + = <int> ; INDArray temp4 = Nd4j . rand ( newShape4 ) ; INDArray subset4 = temp4 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset4 , baseMsg + <str> ) ) ; int [ ] newShape5 = Arrays . copyOf ( shape , shape . length ) ; newShape5 [ <int> ] + = <int> ; INDArray temp5 = Nd4j . rand ( newShape5 ) ; INDArray subset5 = temp5 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) ) ; list . add ( new Pair < > ( subset5 , baseMsg + <str> ) ) ; int [ ] newShape6 = Arrays . copyOf ( shape , shape . length ) ; newShape6 [ <int> ] + = <int> ; newShape6 [ <int> ] + = <int> ; newShape6 [ <int> ] + = <int> ; newShape6 [ <int> ] + = <int> ; newShape6 [ <int> ] + = <int> ; INDArray temp6 = Nd4j . rand ( newShape6 ) ; INDArray subset6 = temp6 . get ( NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) ) ; list . add ( new Pair < > ( subset6 , baseMsg + <str> ) ) ; return list ; } public static List < Pair < INDArray , String > > get5dTensorAlongDimensionWithShape ( int seed , int . . . shape ) { List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] shape4d1 = { <int> , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray orig1a = Nd4j . rand ( shape4d1 ) ; INDArray tad1a = orig1a . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> , <int> ) ; INDArray orig1b = Nd4j . rand ( shape4d1 ) ; INDArray tad1b = orig1b . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad1a , baseMsg + <str> ) ) ; list . add ( new Pair < > ( tad1b , baseMsg + <str> ) ) ; int [ ] shape4d2 = { <int> , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray orig2 = Nd4j . rand ( shape4d2 ) ; INDArray tad2 = orig2 . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad2 , baseMsg + <str> ) ) ; int [ ] shape4d3 = { shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , <int> } ; INDArray orig3 = Nd4j . rand ( shape4d3 ) ; INDArray tad3 = orig3 . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad3 , baseMsg + <str> ) ) ; int [ ] shape4d4 = { shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , <int> , shape [ <int> ] } ; INDArray orig4 = Nd4j . rand ( shape4d4 ) ; INDArray tad4 = orig4 . tensorAlongDimension ( <int> , <int> , <int> , <int> , <int> , <int> ) ; list . add ( new Pair < > ( tad4 , baseMsg + <str> ) ) ; return list ; } public static List < Pair < INDArray , String > > get5dPermutedWithShape ( int seed , int . . . shape ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] createdShape = { shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray arr = Nd4j . rand ( createdShape ) ; INDArray permuted = arr . permute ( <int> , <int> , <int> , <int> , <int> ) ; return Collections . singletonList ( new Pair < > ( permuted , <str> + seed + <str> + Arrays . toString ( shape ) + <str> ) ) ; } public static List < Pair < INDArray , String > > get5dReshapedWithShape ( int seed , int . . . shape ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] shape2d = { shape [ <int> ] * shape [ <int> ] , shape [ <int> ] , shape [ <int> ] * shape [ <int> ] } ; INDArray array3d = Nd4j . rand ( shape2d ) ; INDArray array5d = array3d . reshape ( shape ) ; return Collections . singletonList ( new Pair < > ( array5d , <str> + seed + <str> + Arrays . toString ( shape ) + <str> ) ) ; } public static List < Pair < INDArray , String > > getAll6dTestArraysWithShape ( int seed , int . . . shape ) { if ( shape . length ! = <int> ) throw new IllegalArgumentException ( <str> ) ; List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; INDArray stdC = Nd4j . rand ( shape , <str> ) ; INDArray stdF = Nd4j . rand ( shape , <str> ) ; list . add ( new Pair < > ( stdC , baseMsg + <str> + Arrays . toString ( shape ) + <str> ) ) ; list . add ( new Pair < > ( stdF , baseMsg + <str> + Arrays . toString ( shape ) + <str> ) ) ; list . addAll ( get6dSubArraysWithShape ( seed , shape ) ) ; list . addAll ( get6dPermutedWithShape ( seed , shape ) ) ; list . addAll ( get6dReshapedWithShape ( seed , shape ) ) ; return list ; } public static List < Pair < INDArray , String > > get6dSubArraysWithShape ( int seed , int . . . shape ) { List < Pair < INDArray , String > > list = new ArrayList < > ( ) ; String baseMsg = <str> + seed + <str> + Arrays . toString ( shape ) + <str> ; Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] newShape1 = Arrays . copyOf ( shape , shape . length ) ; newShape1 [ <int> ] + = <int> ; INDArray temp1 = Nd4j . rand ( newShape1 ) ; INDArray subset1 = temp1 . get ( NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset1 , baseMsg + <str> ) ) ; int [ ] newShape2 = Arrays . copyOf ( shape , shape . length ) ; newShape2 [ <int> ] + = <int> ; INDArray temp2 = Nd4j . rand ( newShape2 ) ; INDArray subset2 = temp2 . get ( NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset2 , baseMsg + <str> ) ) ; int [ ] newShape3 = Arrays . copyOf ( shape , shape . length ) ; newShape3 [ <int> ] + = <int> ; INDArray temp3 = Nd4j . rand ( newShape3 ) ; INDArray subset3 = temp3 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset3 , baseMsg + <str> ) ) ; int [ ] newShape4 = Arrays . copyOf ( shape , shape . length ) ; newShape4 [ <int> ] + = <int> ; INDArray temp4 = Nd4j . rand ( newShape4 ) ; INDArray subset4 = temp4 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset4 , baseMsg + <str> ) ) ; int [ ] newShape5 = Arrays . copyOf ( shape , shape . length ) ; newShape5 [ <int> ] + = <int> ; INDArray temp5 = Nd4j . rand ( newShape5 ) ; INDArray subset5 = temp5 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . all ( ) ) ; list . add ( new Pair < > ( subset5 , baseMsg + <str> ) ) ; int [ ] newShape6 = Arrays . copyOf ( shape , shape . length ) ; newShape6 [ <int> ] + = <int> ; INDArray temp6 = Nd4j . rand ( newShape6 ) ; INDArray subset6 = temp6 . get ( NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . all ( ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) ) ; list . add ( new Pair < > ( subset6 , baseMsg + <str> ) ) ; int [ ] newShape7 = Arrays . copyOf ( shape , shape . length ) ; newShape7 [ <int> ] + = <int> ; newShape7 [ <int> ] + = <int> ; newShape7 [ <int> ] + = <int> ; newShape7 [ <int> ] + = <int> ; newShape7 [ <int> ] + = <int> ; newShape7 [ <int> ] + = <int> ; INDArray temp7 = Nd4j . rand ( newShape7 ) ; INDArray subset7 = temp7 . get ( NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) , NDArrayIndex . interval ( <int> , shape [ <int> ] + <int> ) ) ; list . add ( new Pair < > ( subset7 , baseMsg + <str> ) ) ; return list ; } public static List < Pair < INDArray , String > > get6dPermutedWithShape ( int seed , int . . . shape ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] createdShape = { shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] , shape [ <int> ] } ; INDArray arr = Nd4j . rand ( createdShape ) ; INDArray permuted = arr . permute ( <int> , <int> , <int> , <int> , <int> , <int> ) ; return Collections . singletonList ( new Pair < > ( permuted , <str> + seed + <str> + Arrays . toString ( shape ) + <str> ) ) ; } public static List < Pair < INDArray , String > > get6dReshapedWithShape ( int seed , int . . . shape ) { Nd4j . getRandom ( ) . setSeed ( seed ) ; int [ ] shape3d = { shape [ <int> ] * shape [ <int> ] , shape [ <int> ] * shape [ <int> ] , shape [ <int> ] * shape [ <int> ] } ; INDArray array3d = Nd4j . rand ( shape3d ) ; INDArray array6d = array3d . reshape ( shape ) ; return Collections . singletonList ( new Pair < > ( array6d , <str> + seed + <str> + Arrays . toString ( shape ) + <str> ) ) ; } } 
