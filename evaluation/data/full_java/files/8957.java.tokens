package org . elasticsearch . test ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . FilterClient ; import org . elasticsearch . common . breaker . CircuitBreaker ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . util . * ; import java . util . stream . Collectors ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoTimeout ; import static org . hamcrest . Matchers . equalTo ; import static org . junit . Assert . assertThat ; public class CompositeTestCluster extends TestCluster { private final InternalTestCluster cluster ; private final ExternalNode [ ] externalNodes ; private final ExternalClient client = new ExternalClient ( ) ; private static final String NODE_PREFIX = <str> ; public CompositeTestCluster ( InternalTestCluster cluster , int numExternalNodes , ExternalNode externalNode ) throws IOException { super ( cluster . seed ( ) ) ; this . cluster = cluster ; this . externalNodes = new ExternalNode [ numExternalNodes ] ; for ( int i = <int> ; i < externalNodes . length ; i + + ) { externalNodes [ i ] = externalNode ; } } @Override public synchronized void afterTest ( ) throws IOException { cluster . afterTest ( ) ; } @Override public synchronized void beforeTest ( Random random , double transportClientRatio ) throws IOException , InterruptedException { super . beforeTest ( random , transportClientRatio ) ; cluster . beforeTest ( random , transportClientRatio ) ; Settings defaultSettings = cluster . getDefaultSettings ( ) ; final Client client = cluster . size ( ) > <int> ? cluster . client ( ) : cluster . clientNodeClient ( ) ; for ( int i = <int> ; i < externalNodes . length ; i + + ) { if ( ! externalNodes [ i ] . running ( ) ) { externalNodes [ i ] = externalNodes [ i ] . start ( client , defaultSettings , NODE_PREFIX + i , cluster . getClusterName ( ) , i ) ; } externalNodes [ i ] . reset ( random . nextLong ( ) ) ; } if ( size ( ) > <int> ) { client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> + Integer . toString ( this . size ( ) ) ) . get ( ) ; } } private Collection < ExternalNode > runningNodes ( ) { return Arrays . stream ( externalNodes ) . filter ( input - > input . running ( ) ) . collect ( Collectors . toCollection ( ArrayList : : new ) ) ; } public synchronized boolean upgradeOneNode ( ) throws InterruptedException , IOException { return upgradeOneNode ( Settings . EMPTY ) ; } public synchronized boolean upgradeAllNodes ( ) throws InterruptedException , IOException { return upgradeAllNodes ( Settings . EMPTY ) ; } public synchronized boolean upgradeAllNodes ( Settings nodeSettings ) throws InterruptedException , IOException { boolean upgradedOneNode = false ; while ( upgradeOneNode ( nodeSettings ) ) { upgradedOneNode = true ; } return upgradedOneNode ; } public synchronized boolean upgradeOneNode ( Settings nodeSettings ) throws InterruptedException , IOException { Collection < ExternalNode > runningNodes = runningNodes ( ) ; if ( ! runningNodes . isEmpty ( ) ) { final Client existingClient = cluster . client ( ) ; ExternalNode externalNode = RandomPicks . randomFrom ( random , runningNodes ) ; externalNode . stop ( ) ; String s = cluster . startNode ( nodeSettings ) ; ExternalNode . waitForNode ( existingClient , s ) ; assertNoTimeout ( existingClient . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( Integer . toString ( size ( ) ) ) . get ( ) ) ; return true ; } return false ; } public String newNodePattern ( ) { return cluster . nodePrefix ( ) + <str> ; } public String backwardsNodePattern ( ) { return NODE_PREFIX + <str> ; } public void allowOnAllNodes ( String . . . index ) { Settings build = Settings . builder ( ) . put ( <str> , <str> ) . build ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( index ) . setSettings ( build ) . execute ( ) . actionGet ( ) ; } public void allowOnlyNewNodes ( String . . . index ) { Settings build = Settings . builder ( ) . put ( <str> , backwardsNodePattern ( ) ) . build ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( index ) . setSettings ( build ) . execute ( ) . actionGet ( ) ; } public void startNewNode ( ) { cluster . startNode ( ) ; } @Override public synchronized Client client ( ) { return client ; } @Override public synchronized int size ( ) { return runningNodes ( ) . size ( ) + cluster . size ( ) ; } @Override public int numDataNodes ( ) { return runningNodes ( ) . size ( ) + cluster . numDataNodes ( ) ; } @Override public int numDataAndMasterNodes ( ) { return runningNodes ( ) . size ( ) + cluster . numDataAndMasterNodes ( ) ; } @Override public InetSocketAddress [ ] httpAddresses ( ) { return cluster . httpAddresses ( ) ; } @Override public void close ( ) throws IOException { try { IOUtils . close ( externalNodes ) ; } finally { IOUtils . close ( cluster ) ; } } @Override public void ensureEstimatedStats ( ) { if ( size ( ) > <int> ) { NodesStatsResponse nodeStats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . clear ( ) . setBreaker ( true ) . execute ( ) . actionGet ( ) ; for ( NodeStats stats : nodeStats . getNodes ( ) ) { assertThat ( <str> + stats . getNode ( ) , stats . getBreaker ( ) . getStats ( CircuitBreaker . FIELDDATA ) . getEstimated ( ) , equalTo ( <int> L ) ) ; } } } @Override public String getClusterName ( ) { return cluster . getClusterName ( ) ; } @Override public synchronized Iterator < Client > iterator ( ) { return Collections . singleton ( client ( ) ) . iterator ( ) ; } public void fullRestartInternalCluster ( ) throws Exception { cluster . fullRestart ( ) ; } public int numNewDataNodes ( ) { return cluster . numDataNodes ( ) ; } public int numBackwardsDataNodes ( ) { return runningNodes ( ) . size ( ) ; } public TransportAddress externalTransportAddress ( ) { return RandomPicks . randomFrom ( random , externalNodes ) . getTransportAddress ( ) ; } public InternalTestCluster internalCluster ( ) { return cluster ; } private synchronized Client internalClient ( ) { Collection < ExternalNode > externalNodes = runningNodes ( ) ; return random . nextBoolean ( ) & & ! externalNodes . isEmpty ( ) ? RandomPicks . randomFrom ( random , externalNodes ) . getClient ( ) : cluster . client ( ) ; } private final class ExternalClient extends FilterClient { public ExternalClient ( ) { super ( internalClient ( ) ) ; } @Override public void close ( ) { } } } 
