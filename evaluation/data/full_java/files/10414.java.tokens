package com . google . common . collect ; import static com . google . common . collect . Iterables . unmodifiableIterable ; import static com . google . common . collect . Sets . newEnumSet ; import static com . google . common . collect . Sets . newHashSet ; import static com . google . common . collect . Sets . newLinkedHashSet ; import static com . google . common . collect . Sets . powerSet ; import static com . google . common . collect . Sets . unmodifiableNavigableSet ; import static com . google . common . collect . testing . IteratorFeature . UNMODIFIABLE ; import static com . google . common . truth . Truth . assertThat ; import static java . io . ObjectStreamConstants . TC_REFERENCE ; import static java . io . ObjectStreamConstants . baseWireHandle ; import static java . util . Collections . emptySet ; import static java . util . Collections . singleton ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . AnEnum ; import com . google . common . collect . testing . IteratorTester ; import com . google . common . collect . testing . MinimalIterable ; import com . google . common . collect . testing . NavigableSetTestSuiteBuilder ; import com . google . common . collect . testing . SafeTreeSet ; import com . google . common . collect . testing . SetTestSuiteBuilder ; import com . google . common . collect . testing . TestEnumSetGenerator ; import com . google . common . collect . testing . TestStringSetGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . SetFeature ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . EnumSet ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Map ; import java . util . NavigableSet ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . SortedSet ; import java . util . TreeSet ; import java . util . concurrent . CopyOnWriteArraySet ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public class SetsTest extends TestCase { private static final IteratorTester . KnownOrder KNOWN_ORDER = IteratorTester . KnownOrder . KNOWN_ORDER ; private static final Collection < Integer > EMPTY_COLLECTION = Arrays . < Integer > asList ( ) ; private static final Collection < Integer > SOME_COLLECTION = Arrays . asList ( <int> , <int> , <int> ) ; private static final Iterable < Integer > SOME_ITERABLE = new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return SOME_COLLECTION . iterator ( ) ; } } ; private static final List < Integer > LONGER_LIST = Arrays . asList ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; private static final Comparator < Integer > SOME_COMPARATOR = Collections . reverseOrder ( ) ; @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( SetsTest . class ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { return Sets . newConcurrentHashSet ( Arrays . asList ( elements ) ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , SetFeature . GENERAL_PURPOSE ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { int size = elements . length ; Set < String > set1 = ( size > <int> ) ? Sets . newHashSet ( Arrays . asList ( elements ) . subList ( <int> , size - <int> ) ) : Sets . newHashSet ( elements ) ; Set < String > set2 = ( size > <int> ) ? Sets . newHashSet ( Arrays . asList ( elements ) . subList ( <int> , size ) ) : Sets . < String > newHashSet ( ) ; return Sets . union ( set1 , set2 ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Set < String > set1 = Sets . newHashSet ( elements ) ; set1 . add ( samples ( ) . e3 ( ) ) ; Set < String > set2 = Sets . newHashSet ( elements ) ; set2 . add ( samples ( ) . e4 ( ) ) ; return Sets . intersection ( set1 , set2 ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { Set < String > set1 = Sets . newHashSet ( elements ) ; set1 . add ( samples ( ) . e3 ( ) ) ; Set < String > set2 = Sets . newHashSet ( samples ( ) . e3 ( ) ) ; return Sets . difference ( set1 , set2 ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES ) . createTestSuite ( ) ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestEnumSetGenerator ( ) { @Override protected Set < AnEnum > create ( AnEnum [ ] elements ) { AnEnum [ ] otherElements = new AnEnum [ elements . length - <int> ] ; System . arraycopy ( elements , <int> , otherElements , <int> , otherElements . length ) ; return Sets . immutableEnumSet ( elements [ <int> ] , otherElements ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ONE , CollectionSize . SEVERAL , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override protected Set < String > create ( String [ ] elements ) { SafeTreeSet < String > set = new SafeTreeSet < String > ( Arrays . asList ( elements ) ) ; return Sets . unmodifiableNavigableSet ( set ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE ) . createTestSuite ( ) ) ; suite . addTest ( testsForFilter ( ) ) ; suite . addTest ( testsForFilterNoNulls ( ) ) ; suite . addTest ( testsForFilterFiltered ( ) ) ; return suite ; } @GwtIncompatible ( <str> ) private static Test testsForFilter ( ) { return SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override public Set < String > create ( String [ ] elements ) { Set < String > unfiltered = Sets . newLinkedHashSet ( ) ; unfiltered . add ( <str> ) ; Collections . addAll ( unfiltered , elements ) ; unfiltered . add ( <str> ) ; return Sets . filter ( unfiltered , Collections2Test . NOT_YYY_ZZZ ) ; } } ) . named ( <str> ) . withFeatures ( CollectionFeature . SUPPORTS_ADD , CollectionFeature . SUPPORTS_REMOVE , CollectionFeature . ALLOWS_NULL_VALUES , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY ) . createTestSuite ( ) ; } @GwtIncompatible ( <str> ) private static Test testsForFilterNoNulls ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override public Set < String > create ( String [ ] elements ) { Set < String > unfiltered = Sets . newLinkedHashSet ( ) ; unfiltered . add ( <str> ) ; unfiltered . addAll ( ImmutableList . copyOf ( elements ) ) ; unfiltered . add ( <str> ) ; return Sets . filter ( unfiltered , Collections2Test . LENGTH_1 ) ; } } ) . named ( <str> ) . withFeatures ( CollectionFeature . SUPPORTS_ADD , CollectionFeature . SUPPORTS_REMOVE , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override public NavigableSet < String > create ( String [ ] elements ) { NavigableSet < String > unfiltered = Sets . newTreeSet ( ) ; unfiltered . add ( <str> ) ; unfiltered . addAll ( ImmutableList . copyOf ( elements ) ) ; unfiltered . add ( <str> ) ; return Sets . filter ( unfiltered , Collections2Test . LENGTH_1 ) ; } @Override public List < String > order ( List < String > insertionOrder ) { return Ordering . natural ( ) . sortedCopy ( insertionOrder ) ; } } ) . named ( <str> ) . withFeatures ( CollectionFeature . SUPPORTS_ADD , CollectionFeature . SUPPORTS_REMOVE , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; return suite ; } @GwtIncompatible ( <str> ) private static Test testsForFilterFiltered ( ) { return SetTestSuiteBuilder . using ( new TestStringSetGenerator ( ) { @Override public Set < String > create ( String [ ] elements ) { Set < String > unfiltered = Sets . newLinkedHashSet ( ) ; unfiltered . add ( <str> ) ; unfiltered . addAll ( ImmutableList . copyOf ( elements ) ) ; unfiltered . add ( <str> ) ; unfiltered . add ( <str> ) ; return Sets . filter ( Sets . filter ( unfiltered , Collections2Test . LENGTH_1 ) , Collections2Test . NOT_YYY_ZZZ ) ; } } ) . named ( <str> ) . withFeatures ( CollectionFeature . SUPPORTS_ADD , CollectionFeature . SUPPORTS_REMOVE , CollectionFeature . KNOWN_ORDER , CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ; } private enum SomeEnum { A , B , C , D } public void testImmutableEnumSet ( ) { Set < SomeEnum > units = Sets . immutableEnumSet ( SomeEnum . D , SomeEnum . B ) ; assertThat ( units ) . containsExactly ( SomeEnum . B , SomeEnum . D ) . inOrder ( ) ; try { units . remove ( SomeEnum . B ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { units . add ( SomeEnum . C ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } @GwtIncompatible ( <str> ) public void testImmutableEnumSet_serialized ( ) { Set < SomeEnum > units = Sets . immutableEnumSet ( SomeEnum . D , SomeEnum . B ) ; assertThat ( units ) . containsExactly ( SomeEnum . B , SomeEnum . D ) . inOrder ( ) ; Set < SomeEnum > copy = SerializableTester . reserializeAndAssert ( units ) ; assertTrue ( copy instanceof ImmutableEnumSet ) ; } public void testImmutableEnumSet_fromIterable ( ) { ImmutableSet < SomeEnum > none = Sets . immutableEnumSet ( MinimalIterable . < SomeEnum > of ( ) ) ; assertThat ( none ) . isEmpty ( ) ; ImmutableSet < SomeEnum > one = Sets . immutableEnumSet ( MinimalIterable . of ( SomeEnum . B ) ) ; assertThat ( one ) . contains ( SomeEnum . B ) ; ImmutableSet < SomeEnum > two = Sets . immutableEnumSet ( MinimalIterable . of ( SomeEnum . D , SomeEnum . B ) ) ; assertThat ( two ) . containsExactly ( SomeEnum . B , SomeEnum . D ) . inOrder ( ) ; } @GwtIncompatible ( <str> ) public void testImmutableEnumSet_deserializationMakesDefensiveCopy ( ) throws Exception { ImmutableSet < SomeEnum > original = Sets . immutableEnumSet ( SomeEnum . A , SomeEnum . B ) ; int handleOffset = <int> ; byte [ ] serializedForm = serializeWithBackReference ( original , handleOffset ) ; ObjectInputStream in = new ObjectInputStream ( new ByteArrayInputStream ( serializedForm ) ) ; ImmutableSet < ? > deserialized = ( ImmutableSet < ? > ) in . readObject ( ) ; EnumSet < ? > delegate = ( EnumSet < ? > ) in . readObject ( ) ; assertEquals ( original , deserialized ) ; assertTrue ( delegate . remove ( SomeEnum . A ) ) ; assertTrue ( deserialized . contains ( SomeEnum . A ) ) ; } @GwtIncompatible ( <str> ) private static byte [ ] serializeWithBackReference ( Object original , int handleOffset ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream out = new ObjectOutputStream ( bos ) ; out . writeObject ( original ) ; byte [ ] handle = toByteArray ( baseWireHandle + handleOffset ) ; byte [ ] ref = prepended ( TC_REFERENCE , handle ) ; bos . write ( ref ) ; return bos . toByteArray ( ) ; } private static byte [ ] prepended ( byte b , byte [ ] array ) { byte [ ] out = new byte [ array . length + <int> ] ; out [ <int> ] = b ; System . arraycopy ( array , <int> , out , <int> , array . length ) ; return out ; } @GwtIncompatible ( <str> ) private static byte [ ] toByteArray ( int h ) { return ByteBuffer . allocate ( <int> ) . putInt ( h ) . array ( ) ; } public void testNewEnumSet_empty ( ) { EnumSet < SomeEnum > copy = newEnumSet ( Collections . < SomeEnum > emptySet ( ) , SomeEnum . class ) ; assertEquals ( EnumSet . noneOf ( SomeEnum . class ) , copy ) ; } public void testNewEnumSet_enumSet ( ) { EnumSet < SomeEnum > set = EnumSet . of ( SomeEnum . A , SomeEnum . D ) ; assertEquals ( set , newEnumSet ( set , SomeEnum . class ) ) ; } public void testNewEnumSet_collection ( ) { Set < SomeEnum > set = ImmutableSet . of ( SomeEnum . B , SomeEnum . C ) ; assertEquals ( set , newEnumSet ( set , SomeEnum . class ) ) ; } public void testNewEnumSet_iterable ( ) { Set < SomeEnum > set = ImmutableSet . of ( SomeEnum . A , SomeEnum . B , SomeEnum . C ) ; assertEquals ( set , newEnumSet ( unmodifiableIterable ( set ) , SomeEnum . class ) ) ; } public void testNewHashSetEmpty ( ) { HashSet < Integer > set = Sets . newHashSet ( ) ; verifySetContents ( set , EMPTY_COLLECTION ) ; } public void testNewHashSetVarArgs ( ) { HashSet < Integer > set = Sets . newHashSet ( <int> , <int> , <int> ) ; verifySetContents ( set , Arrays . asList ( <int> , <int> ) ) ; } public void testNewHashSetFromCollection ( ) { HashSet < Integer > set = Sets . newHashSet ( SOME_COLLECTION ) ; verifySetContents ( set , SOME_COLLECTION ) ; } public void testNewHashSetFromIterable ( ) { HashSet < Integer > set = Sets . newHashSet ( SOME_ITERABLE ) ; verifySetContents ( set , SOME_ITERABLE ) ; } public void testNewHashSetWithExpectedSizeSmall ( ) { HashSet < Integer > set = Sets . newHashSetWithExpectedSize ( <int> ) ; verifySetContents ( set , EMPTY_COLLECTION ) ; } public void testNewHashSetWithExpectedSizeLarge ( ) { HashSet < Integer > set = Sets . newHashSetWithExpectedSize ( <int> ) ; verifySetContents ( set , EMPTY_COLLECTION ) ; } public void testNewHashSetFromIterator ( ) { HashSet < Integer > set = Sets . newHashSet ( SOME_COLLECTION . iterator ( ) ) ; verifySetContents ( set , SOME_COLLECTION ) ; } public void testNewConcurrentHashSetEmpty ( ) { Set < Integer > set = Sets . newConcurrentHashSet ( ) ; verifySetContents ( set , EMPTY_COLLECTION ) ; } public void testNewConcurrentHashSetFromCollection ( ) { Set < Integer > set = Sets . newConcurrentHashSet ( SOME_COLLECTION ) ; verifySetContents ( set , SOME_COLLECTION ) ; } public void testNewLinkedHashSetEmpty ( ) { LinkedHashSet < Integer > set = Sets . newLinkedHashSet ( ) ; verifyLinkedHashSetContents ( set , EMPTY_COLLECTION ) ; } public void testNewLinkedHashSetFromCollection ( ) { LinkedHashSet < Integer > set = Sets . newLinkedHashSet ( LONGER_LIST ) ; verifyLinkedHashSetContents ( set , LONGER_LIST ) ; } public void testNewLinkedHashSetFromIterable ( ) { LinkedHashSet < Integer > set = Sets . newLinkedHashSet ( new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return LONGER_LIST . iterator ( ) ; } } ) ; verifyLinkedHashSetContents ( set , LONGER_LIST ) ; } public void testNewLinkedHashSetWithExpectedSizeSmall ( ) { LinkedHashSet < Integer > set = Sets . newLinkedHashSetWithExpectedSize ( <int> ) ; verifySetContents ( set , EMPTY_COLLECTION ) ; } public void testNewLinkedHashSetWithExpectedSizeLarge ( ) { LinkedHashSet < Integer > set = Sets . newLinkedHashSetWithExpectedSize ( <int> ) ; verifySetContents ( set , EMPTY_COLLECTION ) ; } public void testNewTreeSetEmpty ( ) { TreeSet < Integer > set = Sets . newTreeSet ( ) ; verifySortedSetContents ( set , EMPTY_COLLECTION , null ) ; } public void testNewTreeSetEmptyDerived ( ) { TreeSet < Derived > set = Sets . newTreeSet ( ) ; assertTrue ( set . isEmpty ( ) ) ; set . add ( new Derived ( <str> ) ) ; set . add ( new Derived ( <str> ) ) ; assertThat ( set ) . containsExactly ( new Derived ( <str> ) , new Derived ( <str> ) ) . inOrder ( ) ; } public void testNewTreeSetEmptyNonGeneric ( ) { TreeSet < LegacyComparable > set = Sets . newTreeSet ( ) ; assertTrue ( set . isEmpty ( ) ) ; set . add ( new LegacyComparable ( <str> ) ) ; set . add ( new LegacyComparable ( <str> ) ) ; assertThat ( set ) . containsExactly ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) . inOrder ( ) ; } public void testNewTreeSetFromCollection ( ) { TreeSet < Integer > set = Sets . newTreeSet ( SOME_COLLECTION ) ; verifySortedSetContents ( set , SOME_COLLECTION , null ) ; } public void testNewTreeSetFromIterable ( ) { TreeSet < Integer > set = Sets . newTreeSet ( SOME_ITERABLE ) ; verifySortedSetContents ( set , SOME_ITERABLE , null ) ; } public void testNewTreeSetFromIterableDerived ( ) { Iterable < Derived > iterable = Arrays . asList ( new Derived ( <str> ) , new Derived ( <str> ) ) ; TreeSet < Derived > set = Sets . newTreeSet ( iterable ) ; assertThat ( set ) . containsExactly ( new Derived ( <str> ) , new Derived ( <str> ) ) . inOrder ( ) ; } public void testNewTreeSetFromIterableNonGeneric ( ) { Iterable < LegacyComparable > iterable = Arrays . asList ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) ; TreeSet < LegacyComparable > set = Sets . newTreeSet ( iterable ) ; assertThat ( set ) . containsExactly ( new LegacyComparable ( <str> ) , new LegacyComparable ( <str> ) ) . inOrder ( ) ; } public void testNewTreeSetEmptyWithComparator ( ) { TreeSet < Integer > set = Sets . newTreeSet ( SOME_COMPARATOR ) ; verifySortedSetContents ( set , EMPTY_COLLECTION , SOME_COMPARATOR ) ; } public void testNewIdentityHashSet ( ) { Set < Integer > set = Sets . newIdentityHashSet ( ) ; Integer value1 = new Integer ( <int> ) ; Integer value2 = new Integer ( <int> ) ; assertTrue ( set . add ( value1 ) ) ; assertFalse ( set . contains ( value2 ) ) ; assertTrue ( set . contains ( value1 ) ) ; assertTrue ( set . add ( value2 ) ) ; assertEquals ( <int> , set . size ( ) ) ; } @GwtIncompatible ( <str> ) public void testNewCOWASEmpty ( ) { CopyOnWriteArraySet < Integer > set = Sets . newCopyOnWriteArraySet ( ) ; verifySetContents ( set , EMPTY_COLLECTION ) ; } @GwtIncompatible ( <str> ) public void testNewCOWASFromIterable ( ) { CopyOnWriteArraySet < Integer > set = Sets . newCopyOnWriteArraySet ( SOME_ITERABLE ) ; verifySetContents ( set , SOME_COLLECTION ) ; } public void testComplementOfEnumSet ( ) { Set < SomeEnum > units = EnumSet . of ( SomeEnum . B , SomeEnum . D ) ; EnumSet < SomeEnum > otherUnits = Sets . complementOf ( units ) ; verifySetContents ( otherUnits , EnumSet . of ( SomeEnum . A , SomeEnum . C ) ) ; } public void testComplementOfEnumSetWithType ( ) { Set < SomeEnum > units = EnumSet . of ( SomeEnum . B , SomeEnum . D ) ; EnumSet < SomeEnum > otherUnits = Sets . complementOf ( units , SomeEnum . class ) ; verifySetContents ( otherUnits , EnumSet . of ( SomeEnum . A , SomeEnum . C ) ) ; } public void testComplementOfRegularSet ( ) { Set < SomeEnum > units = Sets . newHashSet ( SomeEnum . B , SomeEnum . D ) ; EnumSet < SomeEnum > otherUnits = Sets . complementOf ( units ) ; verifySetContents ( otherUnits , EnumSet . of ( SomeEnum . A , SomeEnum . C ) ) ; } public void testComplementOfRegularSetWithType ( ) { Set < SomeEnum > units = Sets . newHashSet ( SomeEnum . B , SomeEnum . D ) ; EnumSet < SomeEnum > otherUnits = Sets . complementOf ( units , SomeEnum . class ) ; verifySetContents ( otherUnits , EnumSet . of ( SomeEnum . A , SomeEnum . C ) ) ; } public void testComplementOfEmptySet ( ) { Set < SomeEnum > noUnits = Collections . emptySet ( ) ; EnumSet < SomeEnum > allUnits = Sets . complementOf ( noUnits , SomeEnum . class ) ; verifySetContents ( EnumSet . allOf ( SomeEnum . class ) , allUnits ) ; } public void testComplementOfFullSet ( ) { Set < SomeEnum > allUnits = Sets . newHashSet ( SomeEnum . values ( ) ) ; EnumSet < SomeEnum > noUnits = Sets . complementOf ( allUnits , SomeEnum . class ) ; verifySetContents ( noUnits , EnumSet . noneOf ( SomeEnum . class ) ) ; } public void testComplementOfEmptyEnumSetWithoutType ( ) { Set < SomeEnum > noUnits = EnumSet . noneOf ( SomeEnum . class ) ; EnumSet < SomeEnum > allUnits = Sets . complementOf ( noUnits ) ; verifySetContents ( allUnits , EnumSet . allOf ( SomeEnum . class ) ) ; } public void testComplementOfEmptySetWithoutTypeDoesntWork ( ) { Set < SomeEnum > set = Collections . emptySet ( ) ; try { Sets . complementOf ( set ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testNullPointerExceptions ( ) { new NullPointerTester ( ) . setDefault ( Enum . class , SomeEnum . A ) . setDefault ( Class . class , SomeEnum . class ) . testAllPublicStaticMethods ( Sets . class ) ; } public void testNewSetFromMap ( ) { Set < Integer > set = Sets . newSetFromMap ( new HashMap < Integer , Boolean > ( ) ) ; set . addAll ( SOME_COLLECTION ) ; verifySetContents ( set , SOME_COLLECTION ) ; } @GwtIncompatible ( <str> ) public void testNewSetFromMapSerialization ( ) { Set < Integer > set = Sets . newSetFromMap ( new LinkedHashMap < Integer , Boolean > ( ) ) ; set . addAll ( SOME_COLLECTION ) ; Set < Integer > copy = SerializableTester . reserializeAndAssert ( set ) ; assertThat ( copy ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testNewSetFromMapIllegal ( ) { Map < Integer , Boolean > map = new LinkedHashMap < Integer , Boolean > ( ) ; map . put ( <int> , true ) ; try { Sets . newSetFromMap ( map ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testCartesianProduct_zeroary ( ) { assertThat ( Sets . cartesianProduct ( ) ) . containsExactly ( list ( ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_unary ( ) { assertThat ( Sets . cartesianProduct ( set ( <int> , <int> ) ) ) . containsExactly ( list ( <int> ) , list ( <int> ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary0x0 ( ) { Set < Integer > mt = emptySet ( ) ; assertEmpty ( Sets . cartesianProduct ( mt , mt ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary0x1 ( ) { Set < Integer > mt = emptySet ( ) ; assertEmpty ( Sets . cartesianProduct ( mt , set ( <int> ) ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary1x0 ( ) { Set < Integer > mt = emptySet ( ) ; assertEmpty ( Sets . cartesianProduct ( set ( <int> ) , mt ) ) ; } private static void assertEmpty ( Set < ? extends List < ? > > set ) { assertTrue ( set . isEmpty ( ) ) ; assertEquals ( <int> , set . size ( ) ) ; assertFalse ( set . iterator ( ) . hasNext ( ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary1x1 ( ) { assertThat ( Sets . cartesianProduct ( set ( <int> ) , set ( <int> ) ) ) . contains ( list ( <int> , <int> ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary1x2 ( ) { assertThat ( Sets . cartesianProduct ( set ( <int> ) , set ( <int> , <int> ) ) ) . containsExactly ( list ( <int> , <int> ) , list ( <int> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary2x2 ( ) { assertThat ( Sets . cartesianProduct ( set ( <int> , <int> ) , set ( <int> , <int> ) ) ) . containsExactly ( list ( <int> , <int> ) , list ( <int> , <int> ) , list ( <int> , <int> ) , list ( <int> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_2x2x2 ( ) { assertThat ( Sets . cartesianProduct ( set ( <int> , <int> ) , set ( <int> , <int> ) , set ( <int> , <int> ) ) ) . containsExactly ( list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_contains ( ) { Set < List < Integer > > actual = Sets . cartesianProduct ( set ( <int> , <int> ) , set ( <int> , <int> ) ) ; assertTrue ( actual . contains ( list ( <int> , <int> ) ) ) ; assertTrue ( actual . contains ( list ( <int> , <int> ) ) ) ; assertTrue ( actual . contains ( list ( <int> , <int> ) ) ) ; assertTrue ( actual . contains ( list ( <int> , <int> ) ) ) ; assertFalse ( actual . contains ( list ( <int> , <int> ) ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_unrelatedTypes ( ) { Set < Integer > x = set ( <int> , <int> ) ; Set < String > y = set ( <str> , <str> ) ; List < Object > exp1 = list ( ( Object ) <int> , <str> ) ; List < Object > exp2 = list ( ( Object ) <int> , <str> ) ; List < Object > exp3 = list ( ( Object ) <int> , <str> ) ; List < Object > exp4 = list ( ( Object ) <int> , <str> ) ; assertThat ( Sets . < Object > cartesianProduct ( x , y ) ) . containsExactly ( exp1 , exp2 , exp3 , exp4 ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testCartesianProductTooBig ( ) { Set < Integer > set = ContiguousSet . create ( Range . closed ( <int> , <int> ) , DiscreteDomain . integers ( ) ) ; try { Sets . cartesianProduct ( set , set , set , set , set ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testCartesianProduct_hashCode ( ) { Set < List < Integer > > degenerate = Sets . cartesianProduct ( ) ; checkHashCode ( degenerate ) ; checkHashCode ( Sets . cartesianProduct ( set ( <int> , <int> ) ) ) ; int num = Integer . MAX_VALUE / <int> * <int> ; checkHashCode ( Sets . cartesianProduct ( set ( <int> , <int> , num ) ) ) ; Set < Integer > mt = emptySet ( ) ; checkHashCode ( Sets . cartesianProduct ( mt , mt ) ) ; checkHashCode ( Sets . cartesianProduct ( mt , set ( num ) ) ) ; checkHashCode ( Sets . cartesianProduct ( set ( num ) , mt ) ) ; checkHashCode ( Sets . cartesianProduct ( set ( num ) , set ( <int> ) ) ) ; checkHashCode ( Sets . cartesianProduct ( set ( <int> ) , set ( <int> , num ) ) ) ; checkHashCode ( Sets . cartesianProduct ( set ( <int> , num ) , set ( <int> , num - <int> ) ) ) ; checkHashCode ( Sets . cartesianProduct ( set ( <int> , num ) , set ( <int> , num - <int> ) , set ( <int> , num + <int> ) ) ) ; checkHashCode ( Sets . cartesianProduct ( set ( <int> , num , num + <int> ) , set ( <int> ) , set ( <int> , num + <int> ) , set ( <int> , <int> , <int> , <int> , <int> ) ) ) ; } public void testPowerSetEmpty ( ) { ImmutableSet < Integer > elements = ImmutableSet . of ( ) ; Set < Set < Integer > > powerSet = powerSet ( elements ) ; assertEquals ( <int> , powerSet . size ( ) ) ; assertEquals ( ImmutableSet . of ( ImmutableSet . of ( ) ) , powerSet ) ; assertEquals ( <int> , powerSet . hashCode ( ) ) ; } public void testPowerSetContents ( ) { ImmutableSet < Integer > elements = ImmutableSet . of ( <int> , <int> , <int> ) ; Set < Set < Integer > > powerSet = powerSet ( elements ) ; assertEquals ( <int> , powerSet . size ( ) ) ; assertEquals ( <int> * <int> + <int> * <int> + <int> * <int> , powerSet . hashCode ( ) ) ; Set < Set < Integer > > expected = newHashSet ( ) ; expected . add ( ImmutableSet . < Integer > of ( ) ) ; expected . add ( ImmutableSet . of ( <int> ) ) ; expected . add ( ImmutableSet . of ( <int> ) ) ; expected . add ( ImmutableSet . of ( <int> ) ) ; expected . add ( ImmutableSet . of ( <int> , <int> ) ) ; expected . add ( ImmutableSet . of ( <int> , <int> ) ) ; expected . add ( ImmutableSet . of ( <int> , <int> ) ) ; expected . add ( ImmutableSet . of ( <int> , <int> , <int> ) ) ; Set < Set < Integer > > almostPowerSet = newHashSet ( expected ) ; almostPowerSet . remove ( ImmutableSet . of ( <int> , <int> , <int> ) ) ; almostPowerSet . add ( ImmutableSet . of ( <int> , <int> , <int> ) ) ; new EqualsTester ( ) . addEqualityGroup ( expected , powerSet ) . addEqualityGroup ( ImmutableSet . of ( <int> , <int> , <int> ) ) . addEqualityGroup ( almostPowerSet ) . testEquals ( ) ; for ( Set < Integer > subset : expected ) { assertTrue ( powerSet . contains ( subset ) ) ; } assertFalse ( powerSet . contains ( ImmutableSet . of ( <int> , <int> , <int> ) ) ) ; assertFalse ( powerSet . contains ( singleton ( null ) ) ) ; assertFalse ( powerSet . contains ( null ) ) ; assertFalse ( powerSet . contains ( ( Object ) <str> ) ) ; } public void testPowerSetIteration_manual ( ) { ImmutableSet < Integer > elements = ImmutableSet . of ( <int> , <int> , <int> ) ; Set < Set < Integer > > powerSet = powerSet ( elements ) ; Iterator < Set < Integer > > i = powerSet . iterator ( ) ; assertEquals ( ImmutableSet . of ( ) , i . next ( ) ) ; assertEquals ( ImmutableSet . of ( <int> ) , i . next ( ) ) ; assertEquals ( ImmutableSet . of ( <int> ) , i . next ( ) ) ; assertEquals ( ImmutableSet . of ( <int> , <int> ) , i . next ( ) ) ; assertEquals ( ImmutableSet . of ( <int> ) , i . next ( ) ) ; assertEquals ( ImmutableSet . of ( <int> , <int> ) , i . next ( ) ) ; assertEquals ( ImmutableSet . of ( <int> , <int> ) , i . next ( ) ) ; assertEquals ( ImmutableSet . of ( <int> , <int> , <int> ) , i . next ( ) ) ; assertFalse ( i . hasNext ( ) ) ; try { i . next ( ) ; fail ( ) ; } catch ( NoSuchElementException expected ) { } } @GwtIncompatible ( <str> ) public void testPowerSetIteration_iteratorTester ( ) { ImmutableSet < Integer > elements = ImmutableSet . of ( <int> , <int> ) ; Set < Set < Integer > > expected = newLinkedHashSet ( ) ; expected . add ( ImmutableSet . < Integer > of ( ) ) ; expected . add ( ImmutableSet . of ( <int> ) ) ; expected . add ( ImmutableSet . of ( <int> ) ) ; expected . add ( ImmutableSet . of ( <int> , <int> ) ) ; final Set < Set < Integer > > powerSet = powerSet ( elements ) ; new IteratorTester < Set < Integer > > ( <int> , UNMODIFIABLE , expected , KNOWN_ORDER ) { @Override protected Iterator < Set < Integer > > newTargetIterator ( ) { return powerSet . iterator ( ) ; } } . test ( ) ; } public void testPowerSetIteration_iteratorTester_fast ( ) { ImmutableSet < Integer > elements = ImmutableSet . of ( <int> , <int> ) ; Set < Set < Integer > > expected = newLinkedHashSet ( ) ; expected . add ( ImmutableSet . < Integer > of ( ) ) ; expected . add ( ImmutableSet . of ( <int> ) ) ; expected . add ( ImmutableSet . of ( <int> ) ) ; expected . add ( ImmutableSet . of ( <int> , <int> ) ) ; final Set < Set < Integer > > powerSet = powerSet ( elements ) ; new IteratorTester < Set < Integer > > ( <int> , UNMODIFIABLE , expected , KNOWN_ORDER ) { @Override protected Iterator < Set < Integer > > newTargetIterator ( ) { return powerSet . iterator ( ) ; } } . test ( ) ; } public void testPowerSetSize ( ) { assertPowerSetSize ( <int> ) ; assertPowerSetSize ( <int> , <str> ) ; assertPowerSetSize ( <int> , <str> , <str> ) ; assertPowerSetSize ( <int> , <str> , <str> , <str> ) ; assertPowerSetSize ( <int> , <str> , <str> , <str> , <str> ) ; assertPowerSetSize ( <int> < < <int> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; } public void testPowerSetCreationErrors ( ) { try { powerSet ( newHashSet ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { powerSet ( singleton ( null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testPowerSetEqualsAndHashCode_verifyAgainstHashSet ( ) { ImmutableList < Integer > allElements = ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < allElements . size ( ) ; i + + ) { Set < Integer > elements = newHashSet ( allElements . subList ( <int> , i ) ) ; Set < Set < Integer > > powerSet1 = powerSet ( elements ) ; Set < Set < Integer > > powerSet2 = powerSet ( elements ) ; new EqualsTester ( ) . addEqualityGroup ( powerSet1 , powerSet2 , toHashSets ( powerSet1 ) ) . addEqualityGroup ( ImmutableSet . of ( ) ) . addEqualityGroup ( ImmutableSet . of ( <int> ) ) . addEqualityGroup ( <str> ) . testEquals ( ) ; assertEquals ( toHashSets ( powerSet1 ) . hashCode ( ) , powerSet1 . hashCode ( ) ) ; } } public void testPowerSetHashCode_inputHashCodeTimesTooFarValueIsZero ( ) { Set < Object > sumToEighthMaxIntElements = newHashSet ( objectWithHashCode ( <int> < < <int> ) , objectWithHashCode ( <int> ) ) ; assertPowerSetHashCode ( <int> < < <int> , sumToEighthMaxIntElements ) ; Set < Object > sumToQuarterMaxIntElements = newHashSet ( objectWithHashCode ( <int> < < <int> ) , objectWithHashCode ( <int> ) ) ; assertPowerSetHashCode ( <int> < < <int> , sumToQuarterMaxIntElements ) ; } public void testPowerSetShowOff ( ) { Set < Object > zero = ImmutableSet . of ( ) ; Set < Set < Object > > one = powerSet ( zero ) ; Set < Set < Set < Object > > > two = powerSet ( one ) ; Set < Set < Set < Set < Object > > > > four = powerSet ( two ) ; Set < Set < Set < Set < Set < Object > > > > > sixteen = powerSet ( four ) ; Set < Set < Set < Set < Set < Set < Object > > > > > > sixtyFiveThousandish = powerSet ( sixteen ) ; assertEquals ( <int> < < <int> , sixtyFiveThousandish . size ( ) ) ; assertTrue ( powerSet ( makeSetOfZeroToTwentyNine ( ) ) . contains ( makeSetOfZeroToTwentyNine ( ) ) ) ; assertFalse ( powerSet ( makeSetOfZeroToTwentyNine ( ) ) . contains ( ImmutableSet . of ( <int> ) ) ) ; } private static Set < Integer > makeSetOfZeroToTwentyNine ( ) { Set < Integer > zeroToTwentyNine = newHashSet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { zeroToTwentyNine . add ( i ) ; } return zeroToTwentyNine ; } private static < E > Set < Set < E > > toHashSets ( Set < Set < E > > powerSet ) { Set < Set < E > > result = newHashSet ( ) ; for ( Set < E > subset : powerSet ) { result . add ( new HashSet < E > ( subset ) ) ; } return result ; } private static Object objectWithHashCode ( final int hashCode ) { return new Object ( ) { @Override public int hashCode ( ) { return hashCode ; } } ; } private static void assertPowerSetHashCode ( int expected , Set < ? > elements ) { assertEquals ( expected , powerSet ( elements ) . hashCode ( ) ) ; } private static void assertPowerSetSize ( int i , Object . . . elements ) { assertEquals ( i , powerSet ( newHashSet ( elements ) ) . size ( ) ) ; } private static void checkHashCode ( Set < ? > set ) { assertEquals ( Sets . newHashSet ( set ) . hashCode ( ) , set . hashCode ( ) ) ; } private static < E > Set < E > set ( E . . . elements ) { return ImmutableSet . copyOf ( elements ) ; } private static < E > List < E > list ( E . . . elements ) { return ImmutableList . copyOf ( elements ) ; } private static < E > void verifyLinkedHashSetContents ( LinkedHashSet < E > set , Collection < E > contents ) { assertEquals ( <str> , new ArrayList < E > ( set ) , new ArrayList < E > ( contents ) ) ; verifySetContents ( set , contents ) ; } private static < E > void verifySortedSetContents ( SortedSet < E > set , Iterable < E > iterable , @Nullable Comparator < E > comparator ) { assertSame ( comparator , set . comparator ( ) ) ; verifySetContents ( set , iterable ) ; } private static < E > void verifySetContents ( Set < E > set , Iterable < E > contents ) { Set < E > expected = null ; if ( contents instanceof Set ) { expected = ( Set < E > ) contents ; } else { expected = new HashSet < E > ( ) ; for ( E element : contents ) { expected . add ( element ) ; } } assertEquals ( expected , set ) ; } static class Base implements Comparable < Base > , Serializable { private final String s ; public Base ( String s ) { this . s = s ; } @Override public int hashCode ( ) { return s . hashCode ( ) ; } @Override public boolean equals ( Object other ) { if ( other = = null ) { return false ; } else if ( other instanceof Base ) { return s . equals ( ( ( Base ) other ) . s ) ; } else { return false ; } } @Override public int compareTo ( Base o ) { return s . compareTo ( o . s ) ; } private static final long serialVersionUID = <int> ; } static class Derived extends Base { public Derived ( String s ) { super ( s ) ; } private static final long serialVersionUID = <int> ; } @GwtIncompatible ( <str> ) public void testUnmodifiableNavigableSet ( ) { TreeSet < Integer > mod = Sets . newTreeSet ( ) ; mod . add ( <int> ) ; mod . add ( <int> ) ; mod . add ( <int> ) ; NavigableSet < Integer > unmod = unmodifiableNavigableSet ( mod ) ; mod . add ( <int> ) ; assertTrue ( unmod . contains ( <int> ) ) ; assertTrue ( unmod . descendingSet ( ) . contains ( <int> ) ) ; ensureNotDirectlyModifiable ( unmod ) ; ensureNotDirectlyModifiable ( unmod . descendingSet ( ) ) ; ensureNotDirectlyModifiable ( unmod . headSet ( <int> ) ) ; ensureNotDirectlyModifiable ( unmod . headSet ( <int> , true ) ) ; ensureNotDirectlyModifiable ( unmod . tailSet ( <int> ) ) ; ensureNotDirectlyModifiable ( unmod . tailSet ( <int> , true ) ) ; ensureNotDirectlyModifiable ( unmod . subSet ( <int> , <int> ) ) ; ensureNotDirectlyModifiable ( unmod . subSet ( <int> , true , <int> , true ) ) ; NavigableSet < Integer > reverse = unmod . descendingSet ( ) ; try { reverse . add ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { reverse . addAll ( Collections . singleton ( <int> ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { reverse . remove ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } void ensureNotDirectlyModifiable ( SortedSet < Integer > unmod ) { try { unmod . add ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . remove ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . addAll ( Collections . singleton ( <int> ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { Iterator < Integer > iterator = unmod . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } @GwtIncompatible ( <str> ) void ensureNotDirectlyModifiable ( NavigableSet < Integer > unmod ) { try { unmod . add ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . remove ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . addAll ( Collections . singleton ( <int> ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . pollFirst ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { unmod . pollLast ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { Iterator < Integer > iterator = unmod . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { Iterator < Integer > iterator = unmod . descendingIterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } @GwtIncompatible ( <str> ) public void testSubSet_boundedRange ( ) { ImmutableSortedSet < Integer > set = ImmutableSortedSet . of ( <int> , <int> , <int> , <int> , <int> ) ; ImmutableSortedSet < Integer > empty = ImmutableSortedSet . of ( ) ; assertEquals ( set , Sets . subSet ( set , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> , <int> ) , Sets . subSet ( set , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( empty , Sets . subSet ( set , Range . closed ( <int> , <int> ) ) ) ; assertEquals ( set , Sets . subSet ( set , Range . open ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> ) , Sets . subSet ( set , Range . open ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> ) , Sets . subSet ( set , Range . open ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . open ( <int> , <int> ) ) ) ; assertEquals ( empty , Sets . subSet ( set , Range . open ( <int> , <int> ) ) ) ; assertEquals ( set , Sets . subSet ( set , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( empty , Sets . subSet ( set , Range . openClosed ( <int> , <int> ) ) ) ; assertEquals ( set , Sets . subSet ( set , Range . closedOpen ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> ) , Sets . subSet ( set , Range . closedOpen ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . closedOpen ( <int> , <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . closedOpen ( <int> , <int> ) ) ) ; assertEquals ( empty , Sets . subSet ( set , Range . closedOpen ( <int> , <int> ) ) ) ; } @GwtIncompatible ( <str> ) public void testSubSet_halfBoundedRange ( ) { ImmutableSortedSet < Integer > set = ImmutableSortedSet . of ( <int> , <int> , <int> , <int> , <int> ) ; ImmutableSortedSet < Integer > empty = ImmutableSortedSet . of ( ) ; assertEquals ( set , Sets . subSet ( set , Range . atLeast ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> , <int> , <int> ) , Sets . subSet ( set , Range . atLeast ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . atLeast ( <int> ) ) ) ; assertEquals ( empty , Sets . subSet ( set , Range . atLeast ( <int> ) ) ) ; assertEquals ( set , Sets . subSet ( set , Range . greaterThan ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> , <int> ) , Sets . subSet ( set , Range . greaterThan ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . greaterThan ( <int> ) ) ) ; assertEquals ( empty , Sets . subSet ( set , Range . greaterThan ( <int> ) ) ) ; assertEquals ( empty , Sets . subSet ( set , Range . lessThan ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> ) , Sets . subSet ( set , Range . lessThan ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> , <int> ) , Sets . subSet ( set , Range . lessThan ( <int> ) ) ) ; assertEquals ( set , Sets . subSet ( set , Range . lessThan ( <int> ) ) ) ; assertEquals ( empty , Sets . subSet ( set , Range . atMost ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . atMost ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> , <int> ) , Sets . subSet ( set , Range . atMost ( <int> ) ) ) ; assertEquals ( set , Sets . subSet ( set , Range . atMost ( <int> ) ) ) ; } @GwtIncompatible ( <str> ) public void testSubSet_unboundedRange ( ) { ImmutableSortedSet < Integer > set = ImmutableSortedSet . of ( <int> , <int> , <int> , <int> , <int> ) ; assertEquals ( set , Sets . subSet ( set , Range . < Integer > all ( ) ) ) ; } @GwtIncompatible ( <str> ) public void testSubSet_unnaturalOrdering ( ) { ImmutableSortedSet < Integer > set = ImmutableSortedSet . < Integer > reverseOrder ( ) . add ( <int> , <int> , <int> , <int> , <int> ) . build ( ) ; try { Sets . subSet ( set , Range . closed ( <int> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . atLeast ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> ) , Sets . subSet ( set , Range . atMost ( <int> ) ) ) ; assertEquals ( ImmutableSortedSet . of ( <int> , <int> , <int> , <int> , <int> ) , Sets . subSet ( set , Range . < Integer > all ( ) ) ) ; } } 
