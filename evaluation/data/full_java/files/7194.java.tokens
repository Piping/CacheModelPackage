package org . elasticsearch . search . aggregations . bucket . missing ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . util . Bits ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . LeafBucketCollectorBase ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSourceAggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class MissingAggregator extends SingleBucketAggregator { private final ValuesSource valuesSource ; public MissingAggregator ( String name , AggregatorFactories factories , ValuesSource valuesSource , AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , aggregationContext , parent , pipelineAggregators , metaData ) ; this . valuesSource = valuesSource ; } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , final LeafBucketCollector sub ) throws IOException { final Bits docsWithValue ; if ( valuesSource ! = null ) { docsWithValue = valuesSource . docsWithValue ( ctx ) ; } else { docsWithValue = new Bits . MatchNoBits ( ctx . reader ( ) . maxDoc ( ) ) ; } return new LeafBucketCollectorBase ( sub , docsWithValue ) { @Override public void collect ( int doc , long bucket ) throws IOException { if ( docsWithValue ! = null & & ! docsWithValue . get ( doc ) ) { collectBucket ( sub , doc , bucket ) ; } } } ; } @Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) throws IOException { return new InternalMissing ( name , bucketDocCount ( owningBucketOrdinal ) , bucketAggregations ( owningBucketOrdinal ) , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return new InternalMissing ( name , <int> , buildEmptySubAggregations ( ) , pipelineAggregators ( ) , metaData ( ) ) ; } public static class Factory extends ValuesSourceAggregatorFactory < ValuesSource > { public Factory ( String name , ValuesSourceConfig valueSourceConfig ) { super ( name , InternalMissing . TYPE . name ( ) , valueSourceConfig ) ; } @Override protected MissingAggregator createUnmapped ( AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new MissingAggregator ( name , factories , null , aggregationContext , parent , pipelineAggregators , metaData ) ; } @Override protected MissingAggregator doCreateInternal ( ValuesSource valuesSource , AggregationContext aggregationContext , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new MissingAggregator ( name , factories , valuesSource , aggregationContext , parent , pipelineAggregators , metaData ) ; } } } 
