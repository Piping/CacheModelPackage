package org . elasticsearch . search . aggregations . bucket . sampler ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import org . elasticsearch . search . aggregations . support . ValuesSourceParser ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; public class SamplerParser implements Aggregator . Parser { public static final int DEFAULT_SHARD_SAMPLE_SIZE = <int> ; public static final ParseField SHARD_SIZE_FIELD = new ParseField ( <str> ) ; public static final ParseField MAX_DOCS_PER_VALUE_FIELD = new ParseField ( <str> ) ; public static final ParseField EXECUTION_HINT_FIELD = new ParseField ( <str> ) ; public static final boolean DEFAULT_USE_GLOBAL_ORDINALS = false ; public static final int MAX_DOCS_PER_VALUE_DEFAULT = <int> ; @Override public String type ( ) { return InternalSampler . TYPE . name ( ) ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { XContentParser . Token token ; String currentFieldName = null ; String executionHint = null ; int shardSize = DEFAULT_SHARD_SAMPLE_SIZE ; int maxDocsPerValue = MAX_DOCS_PER_VALUE_DEFAULT ; ValuesSourceParser vsParser = null ; boolean diversityChoiceMade = false ; vsParser = ValuesSourceParser . any ( aggregationName , InternalSampler . TYPE , context ) . scriptable ( true ) . formattable ( false ) . build ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( vsParser . token ( currentFieldName , token , parser ) ) { continue ; } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , SHARD_SIZE_FIELD ) ) { shardSize = parser . intValue ( ) ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , MAX_DOCS_PER_VALUE_FIELD ) ) { diversityChoiceMade = true ; maxDocsPerValue = parser . intValue ( ) ; } else { throw new SearchParseException ( context , <str> + currentFieldName + <str> + aggregationName , parser . getTokenLocation ( ) ) ; } } else if ( ! vsParser . token ( currentFieldName , token , parser ) ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , EXECUTION_HINT_FIELD ) ) { executionHint = parser . text ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + currentFieldName + <str> + aggregationName , parser . getTokenLocation ( ) ) ; } } ValuesSourceConfig vsConfig = vsParser . config ( ) ; if ( vsConfig . valid ( ) ) { return new SamplerAggregator . DiversifiedFactory ( aggregationName , shardSize , executionHint , vsConfig , maxDocsPerValue ) ; } else { if ( diversityChoiceMade ) { throw new SearchParseException ( context , <str> + MAX_DOCS_PER_VALUE_FIELD . getPreferredName ( ) + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } return new SamplerAggregator . Factory ( aggregationName , shardSize ) ; } } } 
