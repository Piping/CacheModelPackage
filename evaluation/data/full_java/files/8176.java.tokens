package org . elasticsearch . index . mapper . geo ; import org . elasticsearch . common . geo . GeoDistance ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . unit . DistanceUnit ; import org . elasticsearch . common . unit . DistanceUnit . Distance ; import org . elasticsearch . test . ESTestCase ; import java . util . Arrays ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class GeoEncodingTests extends ESTestCase { public void test ( ) { for ( int i = <int> ; i < <int> ; + + i ) { final double lat = randomDouble ( ) * <int> - <int> ; final double lon = randomDouble ( ) * <int> - <int> ; final Distance precision = new Distance ( <int> + ( randomDouble ( ) * <int> ) , randomFrom ( Arrays . asList ( DistanceUnit . MILLIMETERS , DistanceUnit . METERS , DistanceUnit . KILOMETERS ) ) ) ; final GeoPointFieldMapperLegacy . Encoding encoding = GeoPointFieldMapperLegacy . Encoding . of ( precision ) ; assertThat ( encoding . precision ( ) . convert ( DistanceUnit . METERS ) . value , lessThanOrEqualTo ( precision . convert ( DistanceUnit . METERS ) . value ) ) ; final GeoPoint geoPoint = encoding . decode ( encoding . encodeCoordinate ( lat ) , encoding . encodeCoordinate ( lon ) , new GeoPoint ( ) ) ; final double error = GeoDistance . PLANE . calculate ( lat , lon , geoPoint . lat ( ) , geoPoint . lon ( ) , DistanceUnit . METERS ) ; assertThat ( error , lessThanOrEqualTo ( precision . convert ( DistanceUnit . METERS ) . value ) ) ; } } } 
