package com . badlogic . gdx . tools . texturepacker ; import com . badlogic . gdx . tools . texturepacker . ColorBleedEffect . Mask . MaskIterator ; import java . awt . image . BufferedImage ; import java . util . NoSuchElementException ; public class ColorBleedEffect { static int TO_PROCESS = <int> ; static int IN_PROCESS = <int> ; static int REALDATA = <int> ; static int [ ] [ ] offsets = { { - <int> , - <int> } , { <int> , - <int> } , { <int> , - <int> } , { - <int> , <int> } , { <int> , <int> } , { - <int> , <int> } , { <int> , <int> } , { <int> , <int> } } ; ARGBColor color = new ARGBColor ( ) ; public BufferedImage processImage ( BufferedImage image , int maxIterations ) { int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; BufferedImage processedImage = new BufferedImage ( width , height , BufferedImage . TYPE_INT_ARGB ) ; int [ ] rgb = image . getRGB ( <int> , <int> , width , height , null , <int> , width ) ; Mask mask = new Mask ( rgb ) ; int iterations = <int> ; int lastPending = - <int> ; while ( mask . pendingSize > <int> & & mask . pendingSize ! = lastPending & & iterations < maxIterations ) { lastPending = mask . pendingSize ; executeIteration ( rgb , mask , width , height ) ; iterations + + ; } processedImage . setRGB ( <int> , <int> , width , height , rgb , <int> , width ) ; return processedImage ; } private void executeIteration ( int [ ] rgb , Mask mask , int width , int height ) { MaskIterator iterator = mask . new MaskIterator ( ) ; while ( iterator . hasNext ( ) ) { int pixelIndex = iterator . next ( ) ; int x = pixelIndex % width ; int y = pixelIndex / width ; int r = <int> , g = <int> , b = <int> ; int count = <int> ; for ( int i = <int> , n = offsets . length ; i < n ; i + + ) { int [ ] offset = offsets [ i ] ; int column = x + offset [ <int> ] ; int row = y + offset [ <int> ] ; if ( column < <int> | | column > = width | | row < <int> | | row > = height ) continue ; int currentPixelIndex = getPixelIndex ( width , column , row ) ; if ( mask . getMask ( currentPixelIndex ) = = REALDATA ) { color . argb = rgb [ currentPixelIndex ] ; r + = color . red ( ) ; g + = color . green ( ) ; b + = color . blue ( ) ; count + + ; } } if ( count ! = <int> ) { color . setARGBA ( <int> , r / count , g / count , b / count ) ; rgb [ pixelIndex ] = color . argb ; iterator . markAsInProgress ( ) ; } } iterator . reset ( ) ; } private int getPixelIndex ( int width , int x , int y ) { return y * width + x ; } static class Mask { int [ ] data , pending , changing ; int pendingSize , changingSize ; Mask ( int [ ] rgb ) { data = new int [ rgb . length ] ; pending = new int [ rgb . length ] ; changing = new int [ rgb . length ] ; ARGBColor color = new ARGBColor ( ) ; for ( int i = <int> ; i < rgb . length ; i + + ) { color . argb = rgb [ i ] ; if ( color . alpha ( ) = = <int> ) { data [ i ] = TO_PROCESS ; pending [ pendingSize ] = i ; pendingSize + + ; } else data [ i ] = REALDATA ; } } int getMask ( int index ) { return data [ index ] ; } int removeIndex ( int index ) { if ( index > = pendingSize ) throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; int value = pending [ index ] ; pendingSize - - ; pending [ index ] = pending [ pendingSize ] ; return value ; } class MaskIterator { private int index ; boolean hasNext ( ) { return index < pendingSize ; } int next ( ) { if ( index > = pendingSize ) throw new NoSuchElementException ( String . valueOf ( index ) ) ; return pending [ index + + ] ; } void markAsInProgress ( ) { index - - ; changing [ changingSize ] = removeIndex ( index ) ; changingSize + + ; } void reset ( ) { index = <int> ; for ( int i = <int> ; i < changingSize ; i + + ) { int index = changing [ i ] ; data [ index ] = REALDATA ; } changingSize = <int> ; } } } static class ARGBColor { int argb = <hex> ; public int red ( ) { return ( argb > > <int> ) & <hex> ; } public int green ( ) { return ( argb > > <int> ) & <hex> ; } public int blue ( ) { return ( argb > > <int> ) & <hex> ; } public int alpha ( ) { return ( argb > > <int> ) & <hex> ; } public void setARGBA ( int a , int r , int g , int b ) { if ( a < <int> | | a > <int> | | r < <int> | | r > <int> | | g < <int> | | g > <int> | | b < <int> | | b > <int> ) throw new IllegalArgumentException ( <str> + r + <str> + g + <str> + b + <str> + a ) ; argb = ( ( a & <hex> ) < < <int> ) | ( ( r & <hex> ) < < <int> ) | ( ( g & <hex> ) < < <int> ) | ( ( b & <hex> ) < < <int> ) ; } } } 
