package org . gradle . nativeplatform . toolchain . internal ; import org . gradle . internal . operations . BuildOperationProcessor ; import org . gradle . language . base . internal . compile . CompileSpec ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . language . base . internal . compile . CompilerUtil ; import org . gradle . nativeplatform . internal . LinkerSpec ; import org . gradle . nativeplatform . internal . StaticLibraryArchiverSpec ; import org . gradle . nativeplatform . platform . internal . OperatingSystemInternal ; import org . gradle . nativeplatform . toolchain . internal . compilespec . * ; import org . gradle . util . TreeVisitor ; public abstract class AbstractPlatformToolProvider implements PlatformToolProvider { protected final OperatingSystemInternal targetOperatingSystem ; protected final BuildOperationProcessor buildOperationProcessor ; public AbstractPlatformToolProvider ( BuildOperationProcessor buildOperationProcessor , OperatingSystemInternal targetOperatingSystem ) { this . targetOperatingSystem = targetOperatingSystem ; this . buildOperationProcessor = buildOperationProcessor ; } public boolean isAvailable ( ) { return true ; } public void explain ( TreeVisitor < ? super String > visitor ) { } public String getExecutableName ( String executablePath ) { return targetOperatingSystem . getInternalOs ( ) . getExecutableName ( executablePath ) ; } public String getSharedLibraryName ( String libraryPath ) { return targetOperatingSystem . getInternalOs ( ) . getSharedLibraryName ( libraryPath ) ; } public String getSharedLibraryLinkFileName ( String libraryPath ) { return targetOperatingSystem . getInternalOs ( ) . getSharedLibraryName ( libraryPath ) ; } public String getStaticLibraryName ( String libraryPath ) { return targetOperatingSystem . getInternalOs ( ) . getStaticLibraryName ( libraryPath ) ; } @Override public < T > T get ( Class < T > toolType ) { throw new IllegalArgumentException ( String . format ( <str> , toolType . getSimpleName ( ) ) ) ; } public < T extends CompileSpec > org . gradle . language . base . internal . compile . Compiler < T > newCompiler ( Class < T > spec ) { if ( CppCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createCppCompiler ( ) ) ; } if ( CppPCHCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createCppPCHCompiler ( ) ) ; } if ( CCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createCCompiler ( ) ) ; } if ( CPCHCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createCPCHCompiler ( ) ) ; } if ( ObjectiveCppCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createObjectiveCppCompiler ( ) ) ; } if ( ObjectiveCppPCHCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createObjectiveCppPCHCompiler ( ) ) ; } if ( ObjectiveCCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createObjectiveCCompiler ( ) ) ; } if ( ObjectiveCPCHCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createObjectiveCPCHCompiler ( ) ) ; } if ( WindowsResourceCompileSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createWindowsResourceCompiler ( ) ) ; } if ( AssembleSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createAssembler ( ) ) ; } if ( LinkerSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createLinker ( ) ) ; } if ( StaticLibraryArchiverSpec . class . isAssignableFrom ( spec ) ) { return CompilerUtil . castCompiler ( createStaticLibraryArchiver ( ) ) ; } throw new IllegalArgumentException ( String . format ( <str> , spec . getClass ( ) . getSimpleName ( ) ) ) ; } protected final RuntimeException unavailableTool ( String message ) { return new RuntimeException ( message ) ; } protected Compiler < ? > createCppCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createCppPCHCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createCCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createCPCHCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createObjectiveCppCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createObjectiveCppPCHCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createObjectiveCCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createObjectiveCPCHCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createWindowsResourceCompiler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createAssembler ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createLinker ( ) { throw unavailableTool ( <str> ) ; } protected Compiler < ? > createStaticLibraryArchiver ( ) { throw unavailableTool ( <str> ) ; } public String getObjectFileExtension ( ) { return targetOperatingSystem . isWindows ( ) ? <str> : <str> ; } } 
