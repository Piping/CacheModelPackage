package org . gradle . model . internal . core ; import org . gradle . internal . BiAction ; import org . gradle . model . ModelMap ; import org . gradle . model . collection . internal . ChildNodeInitializerStrategyAccessors ; import org . gradle . model . collection . internal . ModelMapModelProjection ; import org . gradle . model . internal . registry . RuleContext ; import org . gradle . model . internal . type . ModelType ; import org . gradle . model . internal . type . ModelTypes ; public class ModelMaps { public static < T > MutableModelNode addModelMapNode ( MutableModelNode modelNode , Class < T > elementType , String name ) { final ModelType < T > elementModelType = ModelType . of ( elementType ) ; modelNode . addLink ( ModelRegistrations . of ( modelNode . getPath ( ) . child ( name ) ) . action ( ModelActionRole . Create , ModelReference . of ( NodeInitializerRegistry . class ) , new BiAction < MutableModelNode , NodeInitializerRegistry > ( ) { @Override public void execute ( MutableModelNode node , NodeInitializerRegistry nodeInitializerRegistry ) { ChildNodeInitializerStrategy < T > childFactory = NodeBackedModelMap . createUsingRegistry ( elementModelType , nodeInitializerRegistry ) ; node . setPrivateData ( ModelType . of ( ChildNodeInitializerStrategy . class ) , childFactory ) ; } } ) . descriptor ( modelNode . getDescriptor ( ) . append ( name ) ) . withProjection ( ModelMapModelProjection . unmanaged ( elementModelType , ChildNodeInitializerStrategyAccessors . fromPrivateData ( ) ) ) . build ( ) ) ; MutableModelNode mapNode = modelNode . getLink ( name ) ; assert mapNode ! = null ; return mapNode ; } public static < T > ModelMap < T > asMutableView ( MutableModelNode mapNode , Class < T > elementType , String ruleContext ) { final ModelType < T > elementModelType = ModelType . of ( elementType ) ; mapNode . ensureUsable ( ) ; return mapNode . asMutable ( ModelTypes . modelMap ( elementModelType ) , RuleContext . nest ( ruleContext ) ) . getInstance ( ) ; } } 
