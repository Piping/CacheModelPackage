package org . elasticsearch . cluster . routing . allocation . command ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . RerouteExplanation ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; public class MoveAllocationCommand implements AllocationCommand { public static final String NAME = <str> ; public static class Factory implements AllocationCommand . Factory < MoveAllocationCommand > { @Override public MoveAllocationCommand readFrom ( StreamInput in ) throws IOException { return new MoveAllocationCommand ( ShardId . readShardId ( in ) , in . readString ( ) , in . readString ( ) ) ; } @Override public void writeTo ( MoveAllocationCommand command , StreamOutput out ) throws IOException { command . shardId ( ) . writeTo ( out ) ; out . writeString ( command . fromNode ( ) ) ; out . writeString ( command . toNode ( ) ) ; } @Override public MoveAllocationCommand fromXContent ( XContentParser parser ) throws IOException { String index = null ; int shardId = - <int> ; String fromNode = null ; String toNode = null ; String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { index = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { shardId = parser . intValue ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { fromNode = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { toNode = parser . text ( ) ; } else { throw new ElasticsearchParseException ( <str> , NAME , currentFieldName ) ; } } else { throw new ElasticsearchParseException ( <str> , NAME , token ) ; } } if ( index = = null ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } if ( shardId = = - <int> ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } if ( fromNode = = null ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } if ( toNode = = null ) { throw new ElasticsearchParseException ( <str> , NAME ) ; } return new MoveAllocationCommand ( new ShardId ( index , shardId ) , fromNode , toNode ) ; } @Override public void toXContent ( MoveAllocationCommand command , XContentBuilder builder , ToXContent . Params params , String objectName ) throws IOException { if ( objectName = = null ) { builder . startObject ( ) ; } else { builder . startObject ( objectName ) ; } builder . field ( <str> , command . shardId ( ) . index ( ) . name ( ) ) ; builder . field ( <str> , command . shardId ( ) . id ( ) ) ; builder . field ( <str> , command . fromNode ( ) ) ; builder . field ( <str> , command . toNode ( ) ) ; builder . endObject ( ) ; } } private final ShardId shardId ; private final String fromNode ; private final String toNode ; public MoveAllocationCommand ( ShardId shardId , String fromNode , String toNode ) { this . shardId = shardId ; this . fromNode = fromNode ; this . toNode = toNode ; } @Override public String name ( ) { return NAME ; } public ShardId shardId ( ) { return this . shardId ; } public String fromNode ( ) { return this . fromNode ; } public String toNode ( ) { return this . toNode ; } @Override public RerouteExplanation execute ( RoutingAllocation allocation , boolean explain ) { DiscoveryNode fromDiscoNode = allocation . nodes ( ) . resolveNode ( fromNode ) ; DiscoveryNode toDiscoNode = allocation . nodes ( ) . resolveNode ( toNode ) ; Decision decision = null ; boolean found = false ; for ( ShardRouting shardRouting : allocation . routingNodes ( ) . node ( fromDiscoNode . id ( ) ) ) { if ( ! shardRouting . shardId ( ) . equals ( shardId ) ) { continue ; } found = true ; if ( ! shardRouting . started ( ) ) { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + shardId + <str> ) ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> + shardRouting . state ( ) + <str> ) ; } RoutingNode toRoutingNode = allocation . routingNodes ( ) . node ( toDiscoNode . id ( ) ) ; decision = allocation . deciders ( ) . canAllocate ( shardRouting , toRoutingNode , allocation ) ; if ( decision . type ( ) = = Decision . Type . NO ) { if ( explain ) { return new RerouteExplanation ( this , decision ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> + fromDiscoNode + <str> + toDiscoNode + <str> + decision ) ; } if ( decision . type ( ) = = Decision . Type . THROTTLE ) { } allocation . routingNodes ( ) . relocate ( shardRouting , toRoutingNode . nodeId ( ) , allocation . clusterInfo ( ) . getShardSize ( shardRouting , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ) ; } if ( ! found ) { if ( explain ) { return new RerouteExplanation ( this , allocation . decision ( Decision . NO , <str> , <str> + shardId + <str> ) ) ; } throw new IllegalArgumentException ( <str> + shardId + <str> + fromDiscoNode ) ; } return new RerouteExplanation ( this , decision ) ; } } 
