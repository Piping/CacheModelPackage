package org . elasticsearch . cloud . aws . blobstore ; import com . amazonaws . AmazonClientException ; import com . amazonaws . services . s3 . AmazonS3 ; import com . amazonaws . services . s3 . model . * ; import com . amazonaws . services . s3 . model . DeleteObjectsRequest . KeyVersion ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . blobstore . BlobContainer ; import org . elasticsearch . common . blobstore . BlobPath ; import org . elasticsearch . common . blobstore . BlobStore ; import org . elasticsearch . common . blobstore . BlobStoreException ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import java . util . ArrayList ; import java . util . Locale ; public class S3BlobStore extends AbstractComponent implements BlobStore { public static final ByteSizeValue MIN_BUFFER_SIZE = new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ; private final AmazonS3 client ; private final String bucket ; private final String region ; private final ByteSizeValue bufferSize ; private final boolean serverSideEncryption ; private final int numberOfRetries ; private final CannedAccessControlList cannedACL ; private final StorageClass storageClass ; public S3BlobStore ( Settings settings , AmazonS3 client , String bucket , @Nullable String region , boolean serverSideEncryption , ByteSizeValue bufferSize , int maxRetries , String cannedACL , String storageClass ) { super ( settings ) ; this . client = client ; this . bucket = bucket ; this . region = region ; this . serverSideEncryption = serverSideEncryption ; this . bufferSize = ( bufferSize ! = null ) ? bufferSize : MIN_BUFFER_SIZE ; if ( this . bufferSize . getBytes ( ) < MIN_BUFFER_SIZE . getBytes ( ) ) { throw new BlobStoreException ( <str> + MIN_BUFFER_SIZE + <str> ) ; } this . cannedACL = initCannedACL ( cannedACL ) ; this . numberOfRetries = maxRetries ; this . storageClass = initStorageClass ( storageClass ) ; int retry = <int> ; while ( retry < = maxRetries ) { try { if ( ! client . doesBucketExist ( bucket ) ) { CreateBucketRequest request = null ; if ( region ! = null ) { request = new CreateBucketRequest ( bucket , region ) ; } else { request = new CreateBucketRequest ( bucket ) ; } request . setCannedAcl ( this . cannedACL ) ; client . createBucket ( request ) ; } break ; } catch ( AmazonClientException e ) { if ( shouldRetry ( e ) & & retry < maxRetries ) { retry + + ; } else { logger . debug ( <str> ) ; throw e ; } } } } @Override public String toString ( ) { return ( region = = null ? <str> : region + <str> ) + bucket ; } public AmazonS3 client ( ) { return client ; } public String bucket ( ) { return bucket ; } public boolean serverSideEncryption ( ) { return serverSideEncryption ; } public int bufferSizeInBytes ( ) { return bufferSize . bytesAsInt ( ) ; } public int numberOfRetries ( ) { return numberOfRetries ; } @Override public BlobContainer blobContainer ( BlobPath path ) { return new S3BlobContainer ( path , this ) ; } @Override public void delete ( BlobPath path ) { ObjectListing prevListing = null ; DeleteObjectsRequest multiObjectDeleteRequest = null ; ArrayList < KeyVersion > keys = new ArrayList < KeyVersion > ( ) ; while ( true ) { ObjectListing list ; if ( prevListing ! = null ) { list = client . listNextBatchOfObjects ( prevListing ) ; } else { String keyPath = path . buildAsString ( <str> ) ; if ( ! keyPath . isEmpty ( ) ) { keyPath = keyPath + <str> ; } list = client . listObjects ( bucket , keyPath ) ; multiObjectDeleteRequest = new DeleteObjectsRequest ( list . getBucketName ( ) ) ; } for ( S3ObjectSummary summary : list . getObjectSummaries ( ) ) { keys . add ( new KeyVersion ( summary . getKey ( ) ) ) ; if ( keys . size ( ) > <int> ) { multiObjectDeleteRequest . setKeys ( keys ) ; client . deleteObjects ( multiObjectDeleteRequest ) ; multiObjectDeleteRequest = new DeleteObjectsRequest ( list . getBucketName ( ) ) ; keys . clear ( ) ; } } if ( list . isTruncated ( ) ) { prevListing = list ; } else { break ; } } if ( ! keys . isEmpty ( ) ) { multiObjectDeleteRequest . setKeys ( keys ) ; client . deleteObjects ( multiObjectDeleteRequest ) ; } } protected boolean shouldRetry ( AmazonClientException e ) { if ( e instanceof AmazonS3Exception ) { AmazonS3Exception s3e = ( AmazonS3Exception ) e ; if ( s3e . getStatusCode ( ) = = <int> & & <str> . equals ( s3e . getErrorCode ( ) ) ) { return true ; } } return e . isRetryable ( ) ; } @Override public void close ( ) { } public CannedAccessControlList getCannedACL ( ) { return cannedACL ; } public StorageClass getStorageClass ( ) { return storageClass ; } public static StorageClass initStorageClass ( String storageClass ) { if ( storageClass = = null | | storageClass . equals ( <str> ) ) { return StorageClass . Standard ; } try { StorageClass _storageClass = StorageClass . fromValue ( storageClass . toUpperCase ( Locale . ENGLISH ) ) ; if ( _storageClass . equals ( StorageClass . Glacier ) ) { throw new BlobStoreException ( <str> ) ; } return _storageClass ; } catch ( IllegalArgumentException illegalArgumentException ) { throw new BlobStoreException ( <str> + storageClass + <str> ) ; } } public static CannedAccessControlList initCannedACL ( String cannedACL ) { if ( cannedACL = = null | | cannedACL . equals ( <str> ) ) { return CannedAccessControlList . Private ; } for ( CannedAccessControlList cur : CannedAccessControlList . values ( ) ) { if ( cur . toString ( ) . equalsIgnoreCase ( cannedACL ) ) { return cur ; } } throw new BlobStoreException ( <str> + cannedACL + <str> ) ; } } 
