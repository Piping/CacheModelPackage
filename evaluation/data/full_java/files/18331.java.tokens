package com . badlogic . gdx . utils ; import java . util . Arrays ; import com . badlogic . gdx . math . MathUtils ; public class CharArray { public char [ ] items ; public int size ; public boolean ordered ; public CharArray ( ) { this ( true , <int> ) ; } public CharArray ( int capacity ) { this ( true , capacity ) ; } public CharArray ( boolean ordered , int capacity ) { this . ordered = ordered ; items = new char [ capacity ] ; } public CharArray ( CharArray array ) { this . ordered = array . ordered ; size = array . size ; items = new char [ size ] ; System . arraycopy ( array . items , <int> , items , <int> , size ) ; } public CharArray ( char [ ] array ) { this ( true , array , <int> , array . length ) ; } public CharArray ( boolean ordered , char [ ] array , int startIndex , int count ) { this ( ordered , count ) ; size = count ; System . arraycopy ( array , startIndex , items , <int> , count ) ; } public void add ( char value ) { char [ ] items = this . items ; if ( size = = items . length ) items = resize ( Math . max ( <int> , ( int ) ( size * <float> ) ) ) ; items [ size + + ] = value ; } public void addAll ( CharArray array ) { addAll ( array , <int> , array . size ) ; } public void addAll ( CharArray array , int offset , int length ) { if ( offset + length > array . size ) throw new IllegalArgumentException ( <str> + offset + <str> + length + <str> + array . size ) ; addAll ( array . items , offset , length ) ; } public void addAll ( char . . . array ) { addAll ( array , <int> , array . length ) ; } public void addAll ( char [ ] array , int offset , int length ) { char [ ] items = this . items ; int sizeNeeded = size + length ; if ( sizeNeeded > items . length ) items = resize ( Math . max ( <int> , ( int ) ( sizeNeeded * <float> ) ) ) ; System . arraycopy ( array , offset , items , size , length ) ; size + = length ; } public char get ( int index ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; return items [ index ] ; } public void set ( int index , char value ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; items [ index ] = value ; } public void incr ( int index , char value ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; items [ index ] + = value ; } public void mul ( int index , char value ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; items [ index ] * = value ; } public void insert ( int index , char value ) { if ( index > size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; char [ ] items = this . items ; if ( size = = items . length ) items = resize ( Math . max ( <int> , ( int ) ( size * <float> ) ) ) ; if ( ordered ) System . arraycopy ( items , index , items , index + <int> , size - index ) ; else items [ size ] = items [ index ] ; size + + ; items [ index ] = value ; } public void swap ( int first , int second ) { if ( first > = size ) throw new IndexOutOfBoundsException ( <str> + first + <str> + size ) ; if ( second > = size ) throw new IndexOutOfBoundsException ( <str> + second + <str> + size ) ; char [ ] items = this . items ; char firstValue = items [ first ] ; items [ first ] = items [ second ] ; items [ second ] = firstValue ; } public boolean contains ( char value ) { int i = size - <int> ; char [ ] items = this . items ; while ( i > = <int> ) if ( items [ i - - ] = = value ) return true ; return false ; } public int indexOf ( char value ) { char [ ] items = this . items ; for ( int i = <int> , n = size ; i < n ; i + + ) if ( items [ i ] = = value ) return i ; return - <int> ; } public int lastIndexOf ( char value ) { char [ ] items = this . items ; for ( int i = size - <int> ; i > = <int> ; i - - ) if ( items [ i ] = = value ) return i ; return - <int> ; } public boolean removeValue ( char value ) { char [ ] items = this . items ; for ( int i = <int> , n = size ; i < n ; i + + ) { if ( items [ i ] = = value ) { removeIndex ( i ) ; return true ; } } return false ; } public char removeIndex ( int index ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; char [ ] items = this . items ; char value = items [ index ] ; size - - ; if ( ordered ) System . arraycopy ( items , index + <int> , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; } public void removeRange ( int start , int end ) { if ( end > = size ) throw new IndexOutOfBoundsException ( <str> + end + <str> + size ) ; if ( start > end ) throw new IndexOutOfBoundsException ( <str> + start + <str> + end ) ; char [ ] items = this . items ; int count = end - start + <int> ; if ( ordered ) System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; else { int lastIndex = this . size - <int> ; for ( int i = <int> ; i < count ; i + + ) items [ start + i ] = items [ lastIndex - i ] ; } size - = count ; } public boolean removeAll ( CharArray array ) { int size = this . size ; int startSize = size ; char [ ] items = this . items ; for ( int i = <int> , n = array . size ; i < n ; i + + ) { char item = array . get ( i ) ; for ( int ii = <int> ; ii < size ; ii + + ) { if ( item = = items [ ii ] ) { removeIndex ( ii ) ; size - - ; break ; } } } return size ! = startSize ; } public char pop ( ) { return items [ - - size ] ; } public char peek ( ) { return items [ size - <int> ] ; } public char first ( ) { if ( size = = <int> ) throw new IllegalStateException ( <str> ) ; return items [ <int> ] ; } public void clear ( ) { size = <int> ; } public char [ ] shrink ( ) { if ( items . length ! = size ) resize ( size ) ; return items ; } public char [ ] ensureCapacity ( int additionalCapacity ) { int sizeNeeded = size + additionalCapacity ; if ( sizeNeeded > items . length ) resize ( Math . max ( <int> , sizeNeeded ) ) ; return items ; } protected char [ ] resize ( int newSize ) { char [ ] newItems = new char [ newSize ] ; char [ ] items = this . items ; System . arraycopy ( items , <int> , newItems , <int> , Math . min ( size , newItems . length ) ) ; this . items = newItems ; return newItems ; } public void sort ( ) { Arrays . sort ( items , <int> , size ) ; } public void reverse ( ) { char [ ] items = this . items ; for ( int i = <int> , lastIndex = size - <int> , n = size / <int> ; i < n ; i + + ) { int ii = lastIndex - i ; char temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } } public void shuffle ( ) { char [ ] items = this . items ; for ( int i = size - <int> ; i > = <int> ; i - - ) { int ii = MathUtils . random ( i ) ; char temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } } public void truncate ( int newSize ) { if ( size > newSize ) size = newSize ; } public char random ( ) { if ( size = = <int> ) return <int> ; return items [ MathUtils . random ( <int> , size - <int> ) ] ; } public char [ ] toArray ( ) { char [ ] array = new char [ size ] ; System . arraycopy ( items , <int> , array , <int> , size ) ; return array ; } public int hashCode ( ) { if ( ! ordered ) return super . hashCode ( ) ; char [ ] items = this . items ; int h = <int> ; for ( int i = <int> , n = size ; i < n ; i + + ) h = h * <int> + items [ i ] ; return h ; } public boolean equals ( Object object ) { if ( object = = this ) return true ; if ( ! ordered ) return false ; if ( ! ( object instanceof CharArray ) ) return false ; CharArray array = ( CharArray ) object ; if ( ! array . ordered ) return false ; int n = size ; if ( n ! = array . size ) return false ; char [ ] items1 = this . items ; char [ ] items2 = array . items ; for ( int i = <int> ; i < n ; i + + ) if ( items1 [ i ] ! = items2 [ i ] ) return false ; return true ; } public String toString ( ) { if ( size = = <int> ) return <str> ; char [ ] items = this . items ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( <str> ) ; buffer . append ( items [ <int> ] ) ; for ( int i = <int> ; i < size ; i + + ) { buffer . append ( <str> ) ; buffer . append ( items [ i ] ) ; } buffer . append ( <str> ) ; return buffer . toString ( ) ; } public String toString ( String separator ) { if ( size = = <int> ) return <str> ; char [ ] items = this . items ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( items [ <int> ] ) ; for ( int i = <int> ; i < size ; i + + ) { buffer . append ( separator ) ; buffer . append ( items [ i ] ) ; } return buffer . toString ( ) ; } static public CharArray with ( char . . . array ) { return new CharArray ( array ) ; } } 
