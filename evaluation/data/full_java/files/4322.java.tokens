package org . eclipse . debug . internal . ui . sourcelookup ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IDebugEventSetListener ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . ISourceLocator ; import org . eclipse . debug . core . model . IStackFrame ; import org . eclipse . debug . core . model . IThread ; import org . eclipse . debug . core . sourcelookup . AbstractSourceLookupDirector ; import org . eclipse . debug . core . sourcelookup . ISourceLookupDirector ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . DelegatingModelPresentation ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . internal . ui . InstructionPointerManager ; import org . eclipse . debug . internal . ui . views . DebugUIViewsMessages ; import org . eclipse . debug . internal . ui . views . launch . Decoration ; import org . eclipse . debug . internal . ui . views . launch . DecorationManager ; import org . eclipse . debug . internal . ui . views . launch . SourceNotFoundEditorInput ; import org . eclipse . debug . internal . ui . views . launch . StandardDecoration ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . IDebugEditorPresentation ; import org . eclipse . debug . ui . IDebugModelPresentation ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . IInstructionPointerPresentation ; import org . eclipse . debug . ui . ISourcePresentation ; import org . eclipse . debug . ui . sourcelookup . CommonSourceNotFoundEditorInput ; import org . eclipse . debug . ui . sourcelookup . ISourceLookupResult ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . source . Annotation ; import org . eclipse . jface . util . IPropertyChangeListener ; import org . eclipse . jface . util . PropertyChangeEvent ; import org . eclipse . swt . custom . BusyIndicator ; import org . eclipse . ui . IEditorInput ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IEditorReference ; import org . eclipse . ui . IPageListener ; import org . eclipse . ui . IPartListener2 ; import org . eclipse . ui . IReusableEditor ; import org . eclipse . ui . IWorkbenchPage ; import org . eclipse . ui . IWorkbenchPart ; import org . eclipse . ui . IWorkbenchPartReference ; import org . eclipse . ui . PartInitException ; import org . eclipse . ui . progress . UIJob ; import org . eclipse . ui . texteditor . IDocumentProvider ; import org . eclipse . ui . texteditor . ITextEditor ; public class SourceLookupFacility implements IPageListener , IPartListener2 , IPropertyChangeListener , IDebugEventSetListener { static class LRU extends HashMap < Object , SourceLookupResult > { private static final long serialVersionUID = <int> ; ArrayList < Object > fEntryStack = null ; int fSize ; LRU ( int size ) { fSize = size ; fEntryStack = new ArrayList < Object > ( ) ; } @Override public SourceLookupResult put ( Object key , SourceLookupResult value ) { shuffle ( key ) ; return super . put ( key , value ) ; } @Override public SourceLookupResult remove ( Object key ) { SourceLookupResult oldResult = super . remove ( key ) ; fEntryStack . remove ( oldResult ) ; return oldResult ; } void shuffle ( Object key ) { int index = fEntryStack . indexOf ( key ) ; if ( index < <int> ) { if ( fEntryStack . size ( ) > = fSize ) { remove ( fEntryStack . get ( fEntryStack . size ( ) - <int> ) ) ; } } else { fEntryStack . remove ( index ) ; } fEntryStack . add ( <int> , key ) ; } } private static SourceLookupFacility fgDefault ; private Map < IWorkbenchPage , IEditorPart > fEditorsByPage ; private static LRU fLookupResults = new LRU ( <int> ) ; private IInstructionPointerPresentation fPresentation = ( IInstructionPointerPresentation ) DebugUITools . newDebugModelPresentation ( ) ; private boolean fReuseEditor = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IDebugUIConstants . PREF_REUSE_EDITOR ) ; public static SourceLookupFacility getDefault ( ) { if ( fgDefault = = null ) { fgDefault = new SourceLookupFacility ( ) ; } return fgDefault ; } public static void shutdown ( ) { if ( fgDefault ! = null ) { fgDefault . dispose ( ) ; } } private SourceLookupFacility ( ) { fEditorsByPage = new HashMap < IWorkbenchPage , IEditorPart > ( ) ; DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . addPropertyChangeListener ( this ) ; DebugPlugin . getDefault ( ) . addDebugEventListener ( this ) ; } @Override public void handleDebugEvents ( DebugEvent [ ] events ) { IStackFrame frame = null ; for ( int i = <int> ; i < events . length ; i + + ) { final DebugEvent event = events [ i ] ; switch ( event . getKind ( ) ) { case DebugEvent . TERMINATE : case DebugEvent . RESUME : if ( ! event . isEvaluation ( ) ) { Job uijob = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { clearSourceSelection ( event . getSource ( ) ) ; return Status . OK_STATUS ; } } ; uijob . setSystem ( true ) ; uijob . schedule ( ) ; } break ; case DebugEvent . CHANGE : if ( event . getSource ( ) instanceof IStackFrame ) { if ( event . getDetail ( ) = = DebugEvent . CONTENT ) { frame = ( IStackFrame ) event . getSource ( ) ; fLookupResults . remove ( new ArtifactWithLocator ( frame , frame . getLaunch ( ) . getSourceLocator ( ) ) ) ; } } break ; default : break ; } } } private class ArtifactWithLocator { public final Object artifact ; public final ISourceLocator locator ; public ArtifactWithLocator ( Object artifact , ISourceLocator locator ) { this . artifact = artifact ; this . locator = locator ; } @Override public int hashCode ( ) { final int prime = <int> ; int result = <int> ; result = prime * result + getOuterType ( ) . hashCode ( ) ; result = prime * result + ( ( artifact = = null ) ? <int> : artifact . hashCode ( ) ) ; result = prime * result + ( ( locator = = null ) ? <int> : locator . hashCode ( ) ) ; return result ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null ) { return false ; } if ( getClass ( ) ! = obj . getClass ( ) ) { return false ; } ArtifactWithLocator other = ( ArtifactWithLocator ) obj ; if ( ! getOuterType ( ) . equals ( other . getOuterType ( ) ) ) { return false ; } if ( artifact = = null ) { if ( other . artifact ! = null ) { return false ; } } else if ( ! artifact . equals ( other . artifact ) ) { return false ; } if ( locator = = null ) { if ( other . locator ! = null ) { return false ; } } else if ( ! locator . equals ( other . locator ) ) { return false ; } return true ; } private SourceLookupFacility getOuterType ( ) { return SourceLookupFacility . this ; } } public SourceLookupResult lookup ( Object artifact , ISourceLocator locator , boolean force ) { SourceLookupResult result = null ; synchronized ( fLookupResults ) { ArtifactWithLocator key = new ArtifactWithLocator ( artifact , locator ) ; if ( ! force ) { result = fLookupResults . get ( key ) ; if ( result ! = null ) { return result ; } } result = new SourceLookupResult ( artifact , null , null , null ) ; IDebugElement debugElement = null ; if ( artifact instanceof IDebugElement ) { debugElement = ( IDebugElement ) artifact ; } ISourceLocator localLocator = locator ; if ( localLocator = = null ) { ILaunch launch = null ; if ( debugElement ! = null ) { launch = debugElement . getLaunch ( ) ; } if ( launch ! = null ) { localLocator = launch . getSourceLocator ( ) ; } } if ( localLocator ! = null ) { String editorId = null ; IEditorInput editorInput = null ; Object sourceElement = null ; if ( localLocator instanceof ISourceLookupDirector ) { ISourceLookupDirector director = ( ISourceLookupDirector ) localLocator ; sourceElement = director . getSourceElement ( artifact ) ; } else { if ( artifact instanceof IStackFrame ) { sourceElement = localLocator . getSourceElement ( ( IStackFrame ) artifact ) ; } } if ( sourceElement = = null ) { if ( localLocator instanceof AbstractSourceLookupDirector ) { editorInput = new CommonSourceNotFoundEditorInput ( artifact ) ; editorId = IDebugUIConstants . ID_COMMON_SOURCE_NOT_FOUND_EDITOR ; } else { if ( artifact instanceof IStackFrame ) { IStackFrame frame = ( IStackFrame ) artifact ; editorInput = new SourceNotFoundEditorInput ( frame ) ; editorId = IInternalDebugUIConstants . ID_SOURCE_NOT_FOUND_EDITOR ; } } } else { ISourcePresentation presentation = null ; if ( localLocator instanceof ISourcePresentation ) { presentation = ( ISourcePresentation ) localLocator ; } else { if ( debugElement ! = null ) { presentation = getPresentation ( debugElement . getModelIdentifier ( ) ) ; } } if ( presentation ! = null ) { editorInput = presentation . getEditorInput ( sourceElement ) ; } if ( editorInput ! = null & & presentation ! = null ) { editorId = presentation . getEditorId ( editorInput , sourceElement ) ; } } result . setEditorInput ( editorInput ) ; result . setEditorId ( editorId ) ; result . setSourceElement ( sourceElement ) ; fLookupResults . put ( key , result ) ; } } return result ; } protected IDebugModelPresentation getPresentation ( String id ) { return ( ( DelegatingModelPresentation ) DebugUIPlugin . getModelPresentation ( ) ) . getPresentation ( id ) ; } protected IDebugEditorPresentation getEditorPresentation ( ) { return ( DelegatingModelPresentation ) DebugUIPlugin . getModelPresentation ( ) ; } public void display ( ISourceLookupResult result , IWorkbenchPage page ) { IEditorPart editor = openEditor ( result , page ) ; if ( editor = = null ) { return ; } IStackFrame frame = null ; if ( result . getArtifact ( ) instanceof IStackFrame ) { frame = ( IStackFrame ) result . getArtifact ( ) ; } if ( frame ! = null ) { IDebugEditorPresentation editorPresentation = getEditorPresentation ( ) ; if ( editorPresentation . addAnnotations ( editor , frame ) ) { Decoration decoration = new StandardDecoration ( editorPresentation , editor , frame . getThread ( ) ) ; DecorationManager . addDecoration ( decoration ) ; } else { ITextEditor textEditor = null ; if ( editor instanceof ITextEditor ) { textEditor = ( ITextEditor ) editor ; } else { textEditor = editor . getAdapter ( ITextEditor . class ) ; } if ( textEditor ! = null ) { positionEditor ( textEditor , frame ) ; InstructionPointerManager . getDefault ( ) . removeAnnotations ( textEditor ) ; Annotation annotation = fPresentation . getInstructionPointerAnnotation ( textEditor , frame ) ; if ( annotation ! = null ) { InstructionPointerManager . getDefault ( ) . addAnnotation ( textEditor , frame , annotation ) ; } } } } } private IEditorPart openEditor ( ISourceLookupResult result , IWorkbenchPage page ) { IEditorPart editor = null ; IEditorInput input = result . getEditorInput ( ) ; String id = result . getEditorId ( ) ; if ( input = = null | | id = = null ) { return null ; } if ( fReuseEditor ) { IEditorReference [ ] references = page . findEditors ( input , id , IWorkbenchPage . MATCH_ID | IWorkbenchPage . MATCH_INPUT ) ; if ( references . length > <int> ) { IEditorPart refEditor = references [ <int> ] . getEditor ( false ) ; editor = refEditor ; page . bringToTop ( editor ) ; } if ( editor = = null ) { IEditorPart editorForPage = getEditor ( page ) ; if ( editorForPage = = null | | editorForPage . isDirty ( ) | | page . isEditorPinned ( editorForPage ) ) { editor = openEditor ( page , input , id ) ; editorForPage = editor ; } else if ( editorForPage instanceof IReusableEditor & & editorForPage . getSite ( ) . getId ( ) . equals ( id ) ) { page . reuseEditor ( ( IReusableEditor ) editorForPage , input ) ; editor = editorForPage ; if ( ! page . isPartVisible ( editor ) ) { page . bringToTop ( editor ) ; } } else { editor = openEditor ( page , input , id ) ; page . closeEditor ( editorForPage , false ) ; editorForPage = editor ; } setEditor ( page , editorForPage ) ; } } else { editor = openEditor ( page , input , id ) ; } return editor ; } private void positionEditor ( ITextEditor editor , IStackFrame frame ) { try { int charStart = frame . getCharStart ( ) ; if ( charStart > = <int> ) { editor . selectAndReveal ( charStart , <int> ) ; return ; } int lineNumber = frame . getLineNumber ( ) ; lineNumber - - ; IRegion region = getLineInformation ( editor , lineNumber ) ; if ( region ! = null ) { editor . selectAndReveal ( region . getOffset ( ) , <int> ) ; } } catch ( DebugException e ) { } } private IRegion getLineInformation ( ITextEditor editor , int lineNumber ) { IDocumentProvider provider = editor . getDocumentProvider ( ) ; IEditorInput input = editor . getEditorInput ( ) ; try { provider . connect ( input ) ; } catch ( CoreException e ) { return null ; } try { IDocument document = provider . getDocument ( input ) ; if ( document ! = null ) { return document . getLineInformation ( lineNumber ) ; } } catch ( BadLocationException e ) { } finally { provider . disconnect ( input ) ; } return null ; } private IEditorPart openEditor ( final IWorkbenchPage page , final IEditorInput input , final String id ) { final IEditorPart [ ] editor = new IEditorPart [ ] { null } ; Runnable r = new Runnable ( ) { @Override public void run ( ) { if ( ! page . getWorkbenchWindow ( ) . getWorkbench ( ) . isClosing ( ) ) { try { editor [ <int> ] = page . openEditor ( input , id , false , IWorkbenchPage . MATCH_ID | IWorkbenchPage . MATCH_INPUT ) ; } catch ( PartInitException e ) { DebugUIPlugin . errorDialog ( DebugUIPlugin . getShell ( ) , DebugUIViewsMessages . LaunchView_Error_1 , DebugUIViewsMessages . LaunchView_Exception_occurred_opening_editor_for_debugger__2 , e ) ; } } } } ; BusyIndicator . showWhile ( DebugUIPlugin . getStandardDisplay ( ) , r ) ; return editor [ <int> ] ; } @Override public void pageActivated ( IWorkbenchPage page ) { } @Override public void pageClosed ( IWorkbenchPage page ) { fEditorsByPage . remove ( page ) ; page . removePartListener ( this ) ; } @Override public void pageOpened ( IWorkbenchPage page ) { page . addPartListener ( this ) ; } @Override public void partActivated ( IWorkbenchPartReference partRef ) { } @Override public void partBroughtToTop ( IWorkbenchPartReference partRef ) { } @Override public void partClosed ( IWorkbenchPartReference partRef ) { IWorkbenchPage page = partRef . getPage ( ) ; IEditorPart editor = getEditor ( page ) ; IWorkbenchPart part = partRef . getPart ( false ) ; if ( part ! = null & & part . equals ( editor ) ) { fEditorsByPage . remove ( page ) ; } } @Override public void partDeactivated ( IWorkbenchPartReference partRef ) { } @Override public void partOpened ( IWorkbenchPartReference partRef ) { } @Override public void partHidden ( IWorkbenchPartReference partRef ) { } @Override public void partVisible ( IWorkbenchPartReference partRef ) { } @Override public void partInputChanged ( IWorkbenchPartReference partRef ) { } @Override public void propertyChange ( PropertyChangeEvent event ) { String property = event . getProperty ( ) ; if ( property . equals ( IDebugUIConstants . PREF_REUSE_EDITOR ) ) { fReuseEditor = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IDebugUIConstants . PREF_REUSE_EDITOR ) ; } } protected IEditorPart getEditor ( IWorkbenchPage page ) { return fEditorsByPage . get ( page ) ; } protected void setEditor ( IWorkbenchPage page , IEditorPart editorPart ) { if ( editorPart = = null ) { fEditorsByPage . remove ( page ) ; } else { fEditorsByPage . put ( page , editorPart ) ; } page . addPartListener ( this ) ; page . getWorkbenchWindow ( ) . addPageListener ( this ) ; } protected void dispose ( ) { DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . removePropertyChangeListener ( this ) ; DebugPlugin . getDefault ( ) . removeDebugEventListener ( this ) ; fEditorsByPage . clear ( ) ; fPresentation . dispose ( ) ; fLookupResults . clear ( ) ; } class SourceLookupJob extends Job { private IStackFrame fTarget ; private ISourceLocator fLocator ; private IWorkbenchPage fPage ; private boolean fForce = false ; public SourceLookupJob ( IStackFrame frame , ISourceLocator locator , IWorkbenchPage page , boolean force ) { super ( <str> ) ; setPriority ( Job . INTERACTIVE ) ; setSystem ( true ) ; fTarget = frame ; fLocator = locator ; fPage = page ; fForce = force ; } @Override protected IStatus run ( IProgressMonitor monitor ) { if ( ! monitor . isCanceled ( ) ) { if ( ! fTarget . isTerminated ( ) ) { ISourceLookupResult result = lookup ( fTarget , fLocator , fForce ) ; if ( ! monitor . isCanceled ( ) & & ! fTarget . isTerminated ( ) & & fPage ! = null ) { new SourceDisplayJob ( result , fPage ) . schedule ( ) ; } } } return Status . OK_STATUS ; } @Override public boolean belongsTo ( Object family ) { if ( family instanceof SourceLookupJob ) { SourceLookupJob slj = ( SourceLookupJob ) family ; return slj . fPage . equals ( fPage ) ; } return false ; } } class SourceDisplayJob extends UIJob { private ISourceLookupResult fResult ; private IWorkbenchPage fPage ; public SourceDisplayJob ( ISourceLookupResult result , IWorkbenchPage page ) { super ( <str> ) ; setSystem ( true ) ; setPriority ( Job . INTERACTIVE ) ; fResult = result ; fPage = page ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { if ( ! monitor . isCanceled ( ) & & fResult ! = null ) { display ( fResult , fPage ) ; if ( monitor . isCanceled ( ) ) { Object artifact = fResult . getArtifact ( ) ; if ( artifact instanceof IStackFrame ) { clearSourceSelection ( ( ( IStackFrame ) artifact ) . getThread ( ) ) ; } } } return Status . OK_STATUS ; } @Override public boolean belongsTo ( Object family ) { if ( family instanceof SourceDisplayJob ) { SourceDisplayJob sdj = ( SourceDisplayJob ) family ; return sdj . fPage . equals ( fPage ) ; } return false ; } } public synchronized void displaySource ( Object context , IWorkbenchPage page , boolean force ) { IStackFrame frame = ( IStackFrame ) context ; SourceLookupJob slj = new SourceLookupJob ( frame , frame . getLaunch ( ) . getSourceLocator ( ) , page , force ) ; Job . getJobManager ( ) . cancel ( slj ) ; slj . schedule ( ) ; } private void clearSourceSelection ( Object source ) { if ( source instanceof IThread ) { IThread thread = ( IThread ) source ; DecorationManager . removeDecorations ( thread ) ; InstructionPointerManager . getDefault ( ) . removeAnnotations ( thread ) ; } else if ( source instanceof IDebugTarget ) { IDebugTarget target = ( IDebugTarget ) source ; DecorationManager . removeDecorations ( target ) ; InstructionPointerManager . getDefault ( ) . removeAnnotations ( target ) ; } } } 
