package org . gradle . api . logging ; import org . gradle . logging . ConfigureLogging ; import org . gradle . logging . internal . LogEvent ; import org . gradle . logging . internal . OutputEventListener ; import org . gradle . util . JUnit4GroovyMockery ; import org . hamcrest . BaseMatcher ; import org . hamcrest . Description ; import org . hamcrest . Matcher ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . junit . runner . RunWith ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; @RunWith ( JMock . class ) public class LoggingTest { private final JUnit4Mockery context = new JUnit4GroovyMockery ( ) ; private final OutputEventListener outputEventListener = context . mock ( OutputEventListener . class ) ; private final ConfigureLogging logging = new ConfigureLogging ( outputEventListener ) ; @Before public void attachListener ( ) { logging . attachListener ( ) ; } @After public void resetLogging ( ) { logging . resetLogging ( ) ; } @Test public void routesLogMessagesViaSlf4j ( ) { Logger logger = Logging . getLogger ( LoggingTest . class ) ; expectLogMessage ( LogLevel . DEBUG , <str> ) ; logger . debug ( <str> ) ; expectLogMessage ( LogLevel . INFO , <str> ) ; logger . info ( <str> ) ; expectLogMessage ( LogLevel . WARN , <str> ) ; logger . warn ( <str> ) ; expectLogMessage ( LogLevel . LIFECYCLE , <str> ) ; logger . lifecycle ( <str> ) ; expectLogMessage ( LogLevel . ERROR , <str> ) ; logger . error ( <str> ) ; expectLogMessage ( LogLevel . QUIET , <str> ) ; logger . quiet ( <str> ) ; expectLogMessage ( LogLevel . LIFECYCLE , <str> ) ; logger . log ( LogLevel . LIFECYCLE , <str> ) ; } @Test public void ignoresTraceLevelLogging ( ) { Logger logger = Logging . getLogger ( LoggingTest . class ) ; context . checking ( new Expectations ( ) { { never ( outputEventListener ) ; } } ) ; logger . trace ( <str> ) ; } @Test public void delegatesLevelIsEnabledToSlf4j ( ) { logging . setLevel ( LogLevel . WARN ) ; Logger logger = Logging . getLogger ( LoggingTest . class ) ; assertTrue ( logger . isErrorEnabled ( ) ) ; assertTrue ( logger . isQuietEnabled ( ) ) ; assertTrue ( logger . isWarnEnabled ( ) ) ; assertFalse ( logger . isLifecycleEnabled ( ) ) ; assertFalse ( logger . isInfoEnabled ( ) ) ; assertFalse ( logger . isDebugEnabled ( ) ) ; assertFalse ( logger . isTraceEnabled ( ) ) ; assertTrue ( logger . isEnabled ( LogLevel . ERROR ) ) ; assertFalse ( logger . isEnabled ( LogLevel . INFO ) ) ; } private void expectLogMessage ( final LogLevel level , final String text ) { final Matcher < LogEvent > matcher = new BaseMatcher < LogEvent > ( ) { public void describeTo ( Description description ) { description . appendText ( <str> ) . appendValue ( level ) . appendText ( <str> ) . appendValue ( text ) ; } public boolean matches ( Object o ) { LogEvent event = ( LogEvent ) o ; return event . getLogLevel ( ) = = level & & event . getMessage ( ) . equals ( text ) ; } } ; context . checking ( new Expectations ( ) { { one ( outputEventListener ) . onOutput ( with ( matcher ) ) ; } } ) ; } } 
