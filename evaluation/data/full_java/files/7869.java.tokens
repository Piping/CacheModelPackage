package org . elasticsearch . cluster . routing . allocation ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . AllocationId ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . TestShardRouting ; import org . elasticsearch . test . ESAllocationTestCase ; import java . util . Arrays ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . nullValue ; public class StartedShardsRoutingTests extends ESAllocationTestCase { public void testStartedShardsMatching ( ) { AllocationService allocation = createAllocationService ( ) ; logger . info ( <str> ) ; final IndexMetaData indexMetaData = IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) . build ( ) ; ClusterState . Builder stateBuilder = ClusterState . builder ( ClusterName . DEFAULT ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . metaData ( MetaData . builder ( ) . put ( indexMetaData , false ) ) ; final ShardRouting initShard = TestShardRouting . newShardRouting ( <str> , <int> , <str> , randomBoolean ( ) , ShardRoutingState . INITIALIZING , <int> ) ; final ShardRouting startedShard = TestShardRouting . newShardRouting ( <str> , <int> , <str> , randomBoolean ( ) , ShardRoutingState . STARTED , <int> ) ; final ShardRouting relocatingShard = TestShardRouting . newShardRouting ( <str> , <int> , <str> , <str> , randomBoolean ( ) , ShardRoutingState . RELOCATING , <int> ) ; stateBuilder . routingTable ( RoutingTable . builder ( ) . add ( IndexRoutingTable . builder ( <str> ) . addIndexShard ( new IndexShardRoutingTable . Builder ( initShard . shardId ( ) ) . addShard ( initShard ) . build ( ) ) . addIndexShard ( new IndexShardRoutingTable . Builder ( startedShard . shardId ( ) ) . addShard ( startedShard ) . build ( ) ) . addIndexShard ( new IndexShardRoutingTable . Builder ( relocatingShard . shardId ( ) ) . addShard ( relocatingShard ) . build ( ) ) ) . build ( ) ) ; ClusterState state = stateBuilder . build ( ) ; logger . info ( <str> ) ; RoutingAllocation . Result result = allocation . applyStartedShards ( state , Arrays . asList ( TestShardRouting . newShardRouting ( initShard . index ( ) , initShard . id ( ) , initShard . currentNodeId ( ) , initShard . relocatingNodeId ( ) , initShard . primary ( ) , ShardRoutingState . INITIALIZING , initShard . allocationId ( ) , randomInt ( ) ) ) , false ) ; assertTrue ( <str> + initShard + <str> + result . routingTable ( ) . prettyPrint ( ) , result . changed ( ) ) ; assertTrue ( initShard + <str> + result . routingTable ( ) . prettyPrint ( ) , result . routingTable ( ) . index ( <str> ) . shard ( initShard . id ( ) ) . allShardsStarted ( ) ) ; logger . info ( <str> ) ; result = allocation . applyStartedShards ( state , Arrays . asList ( TestShardRouting . newShardRouting ( initShard . index ( ) , initShard . id ( ) , initShard . currentNodeId ( ) , initShard . relocatingNodeId ( ) , initShard . primary ( ) , ShardRoutingState . INITIALIZING , <int> ) ) , false ) ; assertFalse ( <str> + initShard + <str> + result . routingTable ( ) . prettyPrint ( ) , result . changed ( ) ) ; result = allocation . applyStartedShards ( state , Arrays . asList ( TestShardRouting . newShardRouting ( initShard . index ( ) , initShard . id ( ) , <str> , initShard . currentNodeId ( ) , initShard . primary ( ) , ShardRoutingState . INITIALIZING , AllocationId . newTargetRelocation ( AllocationId . newRelocation ( initShard . allocationId ( ) ) ) , <int> ) ) , false ) ; assertFalse ( <str> + initShard + <str> + result . routingTable ( ) . prettyPrint ( ) , result . changed ( ) ) ; logger . info ( <str> ) ; result = allocation . applyStartedShards ( state , Arrays . asList ( TestShardRouting . newShardRouting ( startedShard . index ( ) , startedShard . id ( ) , startedShard . currentNodeId ( ) , startedShard . relocatingNodeId ( ) , startedShard . primary ( ) , ShardRoutingState . INITIALIZING , startedShard . allocationId ( ) , <int> ) ) , false ) ; assertFalse ( <str> + result . routingTable ( ) . prettyPrint ( ) , result . changed ( ) ) ; logger . info ( <str> ) ; final AllocationId targetAllocationId = AllocationId . newTargetRelocation ( relocatingShard . allocationId ( ) ) ; result = allocation . applyStartedShards ( state , Arrays . asList ( TestShardRouting . newShardRouting ( relocatingShard . index ( ) , relocatingShard . id ( ) , relocatingShard . relocatingNodeId ( ) , relocatingShard . currentNodeId ( ) , relocatingShard . primary ( ) , ShardRoutingState . INITIALIZING , targetAllocationId , randomInt ( ) ) ) , false ) ; assertTrue ( <str> + relocatingShard + <str> + result . routingTable ( ) . prettyPrint ( ) , result . changed ( ) ) ; ShardRouting shardRouting = result . routingTable ( ) . index ( <str> ) . shard ( relocatingShard . id ( ) ) . getShards ( ) . get ( <int> ) ; assertThat ( shardRouting . state ( ) , equalTo ( ShardRoutingState . STARTED ) ) ; assertThat ( shardRouting . currentNodeId ( ) , equalTo ( <str> ) ) ; assertThat ( shardRouting . relocatingNodeId ( ) , nullValue ( ) ) ; logger . info ( <str> ) ; result = allocation . applyStartedShards ( state , Arrays . asList ( TestShardRouting . newShardRouting ( relocatingShard . index ( ) , relocatingShard . id ( ) , relocatingShard . relocatingNodeId ( ) , relocatingShard . currentNodeId ( ) , relocatingShard . primary ( ) , ShardRoutingState . INITIALIZING , relocatingShard . version ( ) ) ) ) ; assertFalse ( <str> + relocatingShard + <str> + result . routingTable ( ) . prettyPrint ( ) , result . changed ( ) ) ; result = allocation . applyStartedShards ( state , Arrays . asList ( TestShardRouting . newShardRouting ( relocatingShard . index ( ) , relocatingShard . id ( ) , relocatingShard . relocatingNodeId ( ) , relocatingShard . currentNodeId ( ) , relocatingShard . primary ( ) , ShardRoutingState . INITIALIZING , relocatingShard . allocationId ( ) , randomInt ( ) ) ) , false ) ; assertFalse ( <str> + relocatingShard + <str> + result . routingTable ( ) . prettyPrint ( ) , result . changed ( ) ) ; } } 
