package com . google . common . hash ; import static com . google . common . base . Charsets . UTF_8 ; import static java . util . Arrays . asList ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableTable ; import com . google . common . collect . Lists ; import com . google . common . collect . Table . Cell ; import com . google . common . primitives . Ints ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . NullPointerTester ; import com . google . common . util . concurrent . AtomicLongMap ; import junit . framework . TestCase ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . nio . ByteBuffer ; import java . util . Collections ; import java . util . List ; import java . util . Locale ; import java . util . Random ; public class HashingTest extends TestCase { public void testMd5 ( ) { HashTestUtils . checkAvalanche ( Hashing . md5 ( ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . md5 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . md5 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . md5 ( ) ) ; assertEquals ( <str> , Hashing . md5 ( ) . toString ( ) ) ; } public void testSha1 ( ) { HashTestUtils . checkAvalanche ( Hashing . sha1 ( ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . sha1 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . sha1 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . sha1 ( ) ) ; assertEquals ( <str> , Hashing . sha1 ( ) . toString ( ) ) ; } public void testSha256 ( ) { HashTestUtils . checkAvalanche ( Hashing . sha256 ( ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . sha256 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . sha256 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . sha256 ( ) ) ; assertEquals ( <str> , Hashing . sha256 ( ) . toString ( ) ) ; } public void testSha384 ( ) { HashTestUtils . checkAvalanche ( Hashing . sha384 ( ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . sha384 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . sha384 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . sha384 ( ) ) ; assertEquals ( <str> , Hashing . sha384 ( ) . toString ( ) ) ; } public void testSha512 ( ) { HashTestUtils . checkAvalanche ( Hashing . sha512 ( ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . sha512 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . sha512 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . sha512 ( ) ) ; assertEquals ( <str> , Hashing . sha512 ( ) . toString ( ) ) ; } public void testCrc32 ( ) { HashTestUtils . assertInvariants ( Hashing . crc32 ( ) ) ; assertEquals ( <str> , Hashing . crc32 ( ) . toString ( ) ) ; } public void testAdler32 ( ) { HashTestUtils . assertInvariants ( Hashing . adler32 ( ) ) ; assertEquals ( <str> , Hashing . adler32 ( ) . toString ( ) ) ; } public void testMurmur3_128 ( ) { HashTestUtils . check2BitAvalanche ( Hashing . murmur3_128 ( ) , <int> , <float> ) ; HashTestUtils . checkAvalanche ( Hashing . murmur3_128 ( ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . murmur3_128 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . murmur3_128 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . murmur3_128 ( ) ) ; assertEquals ( <str> , Hashing . murmur3_128 ( ) . toString ( ) ) ; } @AndroidIncompatible public void testMurmur3_32 ( ) { HashTestUtils . check2BitAvalanche ( Hashing . murmur3_32 ( ) , <int> , <float> ) ; HashTestUtils . checkAvalanche ( Hashing . murmur3_32 ( ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . murmur3_32 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . murmur3_32 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . murmur3_32 ( ) ) ; assertEquals ( <str> , Hashing . murmur3_32 ( ) . toString ( ) ) ; } @AndroidIncompatible public void testSipHash24 ( ) { HashTestUtils . check2BitAvalanche ( Hashing . sipHash24 ( ) , <int> , <float> ) ; HashTestUtils . checkAvalanche ( Hashing . sipHash24 ( ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . sipHash24 ( ) ) ; HashTestUtils . checkNoFunnels ( Hashing . sipHash24 ( ) ) ; HashTestUtils . assertInvariants ( Hashing . sipHash24 ( ) ) ; assertEquals ( <str> , Hashing . sipHash24 ( ) . toString ( ) ) ; } @AndroidIncompatible public void testGoodFastHash ( ) { for ( int i = <int> ; i < <int> ; i + = <int> ) { HashFunction hasher = Hashing . goodFastHash ( i ) ; assertTrue ( hasher . bits ( ) > = i ) ; HashTestUtils . assertInvariants ( hasher ) ; } } @AndroidIncompatible public void testGoodFastHash32 ( ) { HashTestUtils . check2BitAvalanche ( Hashing . goodFastHash ( <int> ) , <int> , <float> ) ; HashTestUtils . checkAvalanche ( Hashing . goodFastHash ( <int> ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . goodFastHash ( <int> ) ) ; HashTestUtils . checkNoFunnels ( Hashing . goodFastHash ( <int> ) ) ; HashTestUtils . assertInvariants ( Hashing . goodFastHash ( <int> ) ) ; } public void testGoodFastHash128 ( ) { HashTestUtils . check2BitAvalanche ( Hashing . goodFastHash ( <int> ) , <int> , <float> ) ; HashTestUtils . checkAvalanche ( Hashing . goodFastHash ( <int> ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . goodFastHash ( <int> ) ) ; HashTestUtils . checkNoFunnels ( Hashing . goodFastHash ( <int> ) ) ; HashTestUtils . assertInvariants ( Hashing . goodFastHash ( <int> ) ) ; } public void testGoodFastHash256 ( ) { HashTestUtils . check2BitAvalanche ( Hashing . goodFastHash ( <int> ) , <int> , <float> ) ; HashTestUtils . checkAvalanche ( Hashing . goodFastHash ( <int> ) , <int> , <float> ) ; HashTestUtils . checkNo2BitCharacteristics ( Hashing . goodFastHash ( <int> ) ) ; HashTestUtils . checkNoFunnels ( Hashing . goodFastHash ( <int> ) ) ; HashTestUtils . assertInvariants ( Hashing . goodFastHash ( <int> ) ) ; } public void testConsistentHash_correctness ( ) { long [ ] interestingValues = { - <int> , <int> , <int> , <int> , Long . MAX_VALUE , Long . MIN_VALUE } ; for ( long h : interestingValues ) { checkConsistentHashCorrectness ( h ) ; } Random r = new Random ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { checkConsistentHashCorrectness ( r . nextLong ( ) ) ; } } private void checkConsistentHashCorrectness ( long hashCode ) { int last = <int> ; for ( int shards = <int> ; shards < = <int> ; shards + + ) { int b = Hashing . consistentHash ( hashCode , shards ) ; if ( b ! = last ) { assertEquals ( shards - <int> , b ) ; last = b ; } } } public void testConsistentHash_probabilities ( ) { AtomicLongMap < Integer > map = AtomicLongMap . create ( ) ; Random r = new Random ( <int> ) ; for ( int i = <int> ; i < ITERS ; i + + ) { countRemaps ( r . nextLong ( ) , map ) ; } for ( int shard = <int> ; shard < = MAX_SHARDS ; shard + + ) { assertTrue ( map . get ( shard ) < = <float> * ITERS / shard + <int> ) ; } } private void countRemaps ( long h , AtomicLongMap < Integer > map ) { int last = <int> ; for ( int shards = <int> ; shards < = MAX_SHARDS ; shards + + ) { int chosen = Hashing . consistentHash ( h , shards ) ; if ( chosen ! = last ) { map . incrementAndGet ( shards ) ; last = chosen ; } } } private static final int ITERS = <int> ; private static final int MAX_SHARDS = <int> ; @SuppressWarnings ( <str> ) public void testConsistentHash_outOfRange ( ) { try { Hashing . consistentHash ( <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testConsistentHash_ofHashCode ( ) { checkSameResult ( HashCode . fromLong ( <int> ) , <int> ) ; checkSameResult ( HashCode . fromLong ( <hex> ) , <hex> ) ; checkSameResult ( HashCode . fromInt ( <hex> ) , <hex> ) ; } public void checkSameResult ( HashCode hashCode , long equivLong ) { assertEquals ( Hashing . consistentHash ( equivLong , <int> ) , Hashing . consistentHash ( hashCode , <int> ) ) ; } public void testConsistentHash_linearCongruentialGeneratorCompatibility ( ) { int [ ] golden100 = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; for ( int i = <int> ; i < golden100 . length ; i + + ) { assertEquals ( golden100 [ i ] , Hashing . consistentHash ( i , <int> ) ) ; } assertEquals ( <int> , Hashing . consistentHash ( <int> , <int> ) ) ; assertEquals ( <int> , Hashing . consistentHash ( <int> , <int> ) ) ; assertEquals ( <int> , Hashing . consistentHash ( <int> , <int> ) ) ; assertEquals ( <int> , Hashing . consistentHash ( <int> , <int> ) ) ; assertEquals ( <int> , Hashing . consistentHash ( <int> , <int> ) ) ; assertEquals ( <int> , Hashing . consistentHash ( <int> , <int> ) ) ; } private static final double MAX_PERCENT_SPREAD = <float> ; private static final long RANDOM_SEED = <int> ; @SuppressWarnings ( <str> ) public void testCombineOrdered_empty ( ) { try { Hashing . combineOrdered ( Collections . < HashCode > emptySet ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testCombineOrdered_differentBitLengths ( ) { try { Hashing . combineOrdered ( ImmutableList . of ( HashCode . fromInt ( <int> ) , HashCode . fromLong ( <int> ) ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCombineOrdered ( ) { HashCode hash31 = HashCode . fromInt ( <int> ) ; HashCode hash32 = HashCode . fromInt ( <int> ) ; assertEquals ( hash32 , Hashing . combineOrdered ( ImmutableList . of ( hash32 ) ) ) ; assertEquals ( HashCode . fromBytes ( new byte [ ] { ( byte ) <hex> , <int> , <int> , <int> } ) , Hashing . combineOrdered ( ImmutableList . of ( hash32 , hash32 ) ) ) ; assertEquals ( HashCode . fromBytes ( new byte [ ] { ( byte ) <hex> , <int> , <int> , <int> } ) , Hashing . combineOrdered ( ImmutableList . of ( hash32 , hash32 , hash32 ) ) ) ; assertFalse ( Hashing . combineOrdered ( ImmutableList . of ( hash31 , hash32 ) ) . equals ( Hashing . combineOrdered ( ImmutableList . of ( hash32 , hash31 ) ) ) ) ; } public void testCombineOrdered_randomHashCodes ( ) { Random random = new Random ( <int> ) ; List < HashCode > hashCodes = Lists . newArrayList ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { hashCodes . add ( HashCode . fromLong ( random . nextLong ( ) ) ) ; } HashCode hashCode1 = Hashing . combineOrdered ( hashCodes ) ; Collections . shuffle ( hashCodes , random ) ; HashCode hashCode2 = Hashing . combineOrdered ( hashCodes ) ; assertFalse ( hashCode1 . equals ( hashCode2 ) ) ; } @SuppressWarnings ( <str> ) public void testCombineUnordered_empty ( ) { try { Hashing . combineUnordered ( Collections . < HashCode > emptySet ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testCombineUnordered_differentBitLengths ( ) { try { Hashing . combineUnordered ( ImmutableList . of ( HashCode . fromInt ( <int> ) , HashCode . fromLong ( <int> ) ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCombineUnordered ( ) { HashCode hash31 = HashCode . fromInt ( <int> ) ; HashCode hash32 = HashCode . fromInt ( <int> ) ; assertEquals ( hash32 , Hashing . combineUnordered ( ImmutableList . of ( hash32 ) ) ) ; assertEquals ( HashCode . fromInt ( <int> ) , Hashing . combineUnordered ( ImmutableList . of ( hash32 , hash32 ) ) ) ; assertEquals ( HashCode . fromInt ( <int> ) , Hashing . combineUnordered ( ImmutableList . of ( hash32 , hash32 , hash32 ) ) ) ; assertEquals ( Hashing . combineUnordered ( ImmutableList . of ( hash31 , hash32 ) ) , Hashing . combineUnordered ( ImmutableList . of ( hash32 , hash31 ) ) ) ; } public void testCombineUnordered_randomHashCodes ( ) { Random random = new Random ( RANDOM_SEED ) ; List < HashCode > hashCodes = Lists . newArrayList ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { hashCodes . add ( HashCode . fromLong ( random . nextLong ( ) ) ) ; } HashCode hashCode1 = Hashing . combineUnordered ( hashCodes ) ; Collections . shuffle ( hashCodes ) ; HashCode hashCode2 = Hashing . combineUnordered ( hashCodes ) ; assertEquals ( hashCode1 , hashCode2 ) ; } public void testConcatenating_equals ( ) { new EqualsTester ( ) . addEqualityGroup ( Hashing . concatenating ( asList ( Hashing . md5 ( ) ) ) ) . addEqualityGroup ( Hashing . concatenating ( asList ( Hashing . murmur3_32 ( ) ) ) ) . addEqualityGroup ( Hashing . concatenating ( Hashing . md5 ( ) , Hashing . md5 ( ) ) , Hashing . concatenating ( asList ( Hashing . md5 ( ) , Hashing . md5 ( ) ) ) ) . addEqualityGroup ( Hashing . concatenating ( Hashing . murmur3_32 ( ) , Hashing . md5 ( ) ) , Hashing . concatenating ( asList ( Hashing . murmur3_32 ( ) , Hashing . md5 ( ) ) ) ) . addEqualityGroup ( Hashing . concatenating ( Hashing . md5 ( ) , Hashing . murmur3_32 ( ) ) , Hashing . concatenating ( asList ( Hashing . md5 ( ) , Hashing . murmur3_32 ( ) ) ) ) . testEquals ( ) ; } public void testConcatenatingIterable_bits ( ) { assertEquals ( Hashing . md5 ( ) . bits ( ) + Hashing . md5 ( ) . bits ( ) , Hashing . concatenating ( asList ( Hashing . md5 ( ) , Hashing . md5 ( ) ) ) . bits ( ) ) ; assertEquals ( Hashing . md5 ( ) . bits ( ) + Hashing . murmur3_32 ( ) . bits ( ) , Hashing . concatenating ( asList ( Hashing . md5 ( ) , Hashing . murmur3_32 ( ) ) ) . bits ( ) ) ; assertEquals ( Hashing . md5 ( ) . bits ( ) + Hashing . murmur3_32 ( ) . bits ( ) + Hashing . murmur3_128 ( ) . bits ( ) , Hashing . concatenating ( asList ( Hashing . md5 ( ) , Hashing . murmur3_32 ( ) , Hashing . murmur3_128 ( ) ) ) . bits ( ) ) ; } public void testConcatenatingVarArgs_bits ( ) { assertEquals ( Hashing . md5 ( ) . bits ( ) + Hashing . md5 ( ) . bits ( ) , Hashing . concatenating ( Hashing . md5 ( ) , Hashing . md5 ( ) ) . bits ( ) ) ; assertEquals ( Hashing . md5 ( ) . bits ( ) + Hashing . murmur3_32 ( ) . bits ( ) , Hashing . concatenating ( Hashing . md5 ( ) , Hashing . murmur3_32 ( ) ) . bits ( ) ) ; assertEquals ( Hashing . md5 ( ) . bits ( ) + Hashing . murmur3_32 ( ) . bits ( ) + Hashing . murmur3_128 ( ) . bits ( ) , Hashing . concatenating ( Hashing . md5 ( ) , Hashing . murmur3_32 ( ) , Hashing . murmur3_128 ( ) ) . bits ( ) ) ; } public void testConcatenatingHashFunction_makeHash ( ) { byte [ ] md5Hash = Hashing . md5 ( ) . hashLong ( <int> ) . asBytes ( ) ; byte [ ] murmur3Hash = Hashing . murmur3_32 ( ) . hashLong ( <int> ) . asBytes ( ) ; byte [ ] combined = new byte [ md5Hash . length + murmur3Hash . length ] ; ByteBuffer buffer = ByteBuffer . wrap ( combined ) ; buffer . put ( md5Hash ) ; buffer . put ( murmur3Hash ) ; HashCode expected = HashCode . fromBytes ( combined ) ; assertEquals ( expected , Hashing . concatenating ( Hashing . md5 ( ) , Hashing . murmur3_32 ( ) ) . hashLong ( <int> ) ) ; assertEquals ( expected , Hashing . concatenating ( asList ( Hashing . md5 ( ) , Hashing . murmur3_32 ( ) ) ) . hashLong ( <int> ) ) ; } public void testHashIntReverseBytesVsHashBytesIntsToByteArray ( ) { int input = <int> ; assertEquals ( Hashing . md5 ( ) . hashBytes ( Ints . toByteArray ( input ) ) , Hashing . md5 ( ) . hashInt ( Integer . reverseBytes ( input ) ) ) ; } public void testHashIntVsForLoop ( ) { int input = <int> ; HashCode expected = Hashing . md5 ( ) . hashInt ( input ) ; Hasher hasher = Hashing . md5 ( ) . newHasher ( ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) { hasher . putByte ( ( byte ) ( input > > i ) ) ; } HashCode actual = hasher . hash ( ) ; assertEquals ( expected , actual ) ; } private static final String EMPTY_STRING = <str> ; private static final String TQBFJOTLD = <str> ; private static final String TQBFJOTLDP = <str> ; private static final ImmutableTable < HashFunction , String , String > KNOWN_HASHES = ImmutableTable . < HashFunction , String , String > builder ( ) . put ( Hashing . adler32 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . adler32 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . adler32 ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . md5 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . md5 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . md5 ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . murmur3_128 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . murmur3_128 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . murmur3_128 ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . murmur3_32 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . murmur3_32 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . murmur3_32 ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . sha1 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . sha1 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . sha1 ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . sha256 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . sha256 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . sha256 ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . sha384 ( ) , EMPTY_STRING , <str> + <str> ) . put ( Hashing . sha384 ( ) , TQBFJOTLD , <str> + <str> ) . put ( Hashing . sha384 ( ) , TQBFJOTLDP , <str> + <str> ) . put ( Hashing . sha512 ( ) , EMPTY_STRING , <str> + <str> ) . put ( Hashing . sha512 ( ) , TQBFJOTLD , <str> + <str> ) . put ( Hashing . sha512 ( ) , TQBFJOTLDP , <str> + <str> ) . put ( Hashing . crc32 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . crc32 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . crc32 ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . sipHash24 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . sipHash24 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . sipHash24 ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . crc32c ( ) , EMPTY_STRING , <str> ) . put ( Hashing . crc32c ( ) , TQBFJOTLD , <str> ) . put ( Hashing . crc32c ( ) , TQBFJOTLDP , <str> ) . put ( Hashing . farmHashFingerprint64 ( ) , EMPTY_STRING , <str> ) . put ( Hashing . farmHashFingerprint64 ( ) , TQBFJOTLD , <str> ) . put ( Hashing . farmHashFingerprint64 ( ) , TQBFJOTLDP , <str> ) . build ( ) ; public void testAllHashFunctionsHaveKnownHashes ( ) throws Exception { for ( Method method : Hashing . class . getDeclaredMethods ( ) ) { if ( method . getReturnType ( ) . equals ( HashFunction . class ) & & Modifier . isPublic ( method . getModifiers ( ) ) & & method . getParameterTypes ( ) . length = = <int> ) { HashFunction hashFunction = ( HashFunction ) method . invoke ( Hashing . class ) ; assertTrue ( <str> + hashFunction , KNOWN_HASHES . row ( hashFunction ) . size ( ) > = <int> ) ; } } } public void testKnownUtf8Hashing ( ) { for ( Cell < HashFunction , String , String > cell : KNOWN_HASHES . cellSet ( ) ) { HashFunction func = cell . getRowKey ( ) ; String input = cell . getColumnKey ( ) ; String expected = cell . getValue ( ) ; assertEquals ( String . format ( Locale . ROOT , <str> , input ) , expected , func . hashString ( input , UTF_8 ) . toString ( ) ) ; } } public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) . setDefault ( byte [ ] . class , <str> . getBytes ( UTF_8 ) ) . setDefault ( HashCode . class , HashCode . fromLong ( <int> ) ) ; tester . testAllPublicStaticMethods ( Hashing . class ) ; } public void testSeedlessHashFunctionEquals ( ) throws Exception { assertSeedlessHashFunctionEquals ( Hashing . class ) ; } public void testSeededHashFunctionEquals ( ) throws Exception { assertSeededHashFunctionEquals ( Hashing . class ) ; } public void testGoodFastHashEquals ( ) throws Exception { HashFunction hashFunction1a = Hashing . goodFastHash ( <int> ) ; HashFunction hashFunction1b = Hashing . goodFastHash ( <int> ) ; HashFunction hashFunction2a = Hashing . goodFastHash ( <int> ) ; HashFunction hashFunction2b = Hashing . goodFastHash ( <int> ) ; HashFunction hashFunction3a = Hashing . goodFastHash ( <int> ) ; HashFunction hashFunction3b = Hashing . goodFastHash ( <int> ) ; HashFunction hashFunction4a = Hashing . goodFastHash ( <int> ) ; HashFunction hashFunction4b = Hashing . goodFastHash ( <int> ) ; new EqualsTester ( ) . addEqualityGroup ( hashFunction1a , hashFunction1b ) . addEqualityGroup ( hashFunction2a , hashFunction2b ) . addEqualityGroup ( hashFunction3a , hashFunction3b ) . addEqualityGroup ( hashFunction4a , hashFunction4b ) . testEquals ( ) ; assertEquals ( hashFunction1a . toString ( ) , hashFunction1b . toString ( ) ) ; assertEquals ( hashFunction2a . toString ( ) , hashFunction2b . toString ( ) ) ; assertEquals ( hashFunction3a . toString ( ) , hashFunction3b . toString ( ) ) ; assertEquals ( hashFunction4a . toString ( ) , hashFunction4b . toString ( ) ) ; } static void assertSeedlessHashFunctionEquals ( Class < ? > clazz ) throws Exception { for ( Method method : clazz . getDeclaredMethods ( ) ) { if ( method . getReturnType ( ) . equals ( HashFunction . class ) & & Modifier . isPublic ( method . getModifiers ( ) ) & & method . getParameterTypes ( ) . length = = <int> ) { HashFunction hashFunction1a = ( HashFunction ) method . invoke ( clazz ) ; HashFunction hashFunction1b = ( HashFunction ) method . invoke ( clazz ) ; new EqualsTester ( ) . addEqualityGroup ( hashFunction1a , hashFunction1b ) . testEquals ( ) ; assertSame ( hashFunction1a , hashFunction1b ) ; assertEquals ( hashFunction1a . toString ( ) , hashFunction1b . toString ( ) ) ; } } } static void assertSeededHashFunctionEquals ( Class < ? > clazz ) throws Exception { Random random = new Random ( RANDOM_SEED ) ; for ( Method method : clazz . getDeclaredMethods ( ) ) { if ( method . getReturnType ( ) . equals ( HashFunction . class ) & & Modifier . isPublic ( method . getModifiers ( ) ) & & method . getParameterTypes ( ) . length ! = <int> & & ! method . getName ( ) . equals ( <str> ) & & ! method . getName ( ) . equals ( <str> ) & & ! method . getName ( ) . startsWith ( <str> ) ) { Object [ ] params1 = new Object [ method . getParameterTypes ( ) . length ] ; Object [ ] params2 = new Object [ method . getParameterTypes ( ) . length ] ; for ( int i = <int> ; i < params1 . length ; i + + ) { if ( method . getParameterTypes ( ) [ i ] = = int . class ) { params1 [ i ] = random . nextInt ( ) ; params2 [ i ] = random . nextInt ( ) ; } else if ( method . getParameterTypes ( ) [ i ] = = long . class ) { params1 [ i ] = random . nextLong ( ) ; params2 [ i ] = random . nextLong ( ) ; } else { fail ( <str> + method . getParameterTypes ( ) [ i ] ) ; } } HashFunction hashFunction1a = ( HashFunction ) method . invoke ( clazz , params1 ) ; HashFunction hashFunction1b = ( HashFunction ) method . invoke ( clazz , params1 ) ; HashFunction hashFunction2 = ( HashFunction ) method . invoke ( clazz , params2 ) ; new EqualsTester ( ) . addEqualityGroup ( hashFunction1a , hashFunction1b ) . addEqualityGroup ( hashFunction2 ) . testEquals ( ) ; assertEquals ( hashFunction1a . toString ( ) , hashFunction1b . toString ( ) ) ; } } } } 
