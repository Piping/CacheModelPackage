package io . netty . buffer ; import io . netty . util . internal . SystemPropertyUtil ; import org . junit . Test ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; public class PooledByteBufAllocatorTest { private static final int [ ] ALLOCATION_SIZES = new int [ <int> * <int> ] ; static { for ( int i = <int> ; i < ALLOCATION_SIZES . length ; i + + ) { ALLOCATION_SIZES [ i ] = i ; } } @Test public void testConcurrentUsage ( ) throws Throwable { long runningTime = TimeUnit . MILLISECONDS . toNanos ( SystemPropertyUtil . getLong ( <str> , <int> ) ) ; ByteBufAllocator allocator = new PooledByteBufAllocator ( true , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; List < AllocationThread > threads = new ArrayList < AllocationThread > ( ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { AllocationThread thread = new AllocationThread ( allocator ) ; thread . start ( ) ; threads . add ( thread ) ; } long start = System . nanoTime ( ) ; while ( ! isExpired ( start , runningTime ) ) { checkForErrors ( threads ) ; Thread . sleep ( <int> ) ; } } finally { for ( AllocationThread t : threads ) { t . finish ( ) ; } } } private static boolean isExpired ( long start , long expireTime ) { return System . nanoTime ( ) - start > expireTime ; } private static void checkForErrors ( List < AllocationThread > threads ) throws Throwable { for ( AllocationThread t : threads ) { if ( t . isFinished ( ) ) { t . checkForError ( ) ; } } } private static final class AllocationThread extends Thread { private final CountDownLatch latch = new CountDownLatch ( <int> ) ; private final Queue < ByteBuf > buffers = new ArrayDeque < ByteBuf > ( <int> ) ; private final ByteBufAllocator allocator ; private volatile boolean finished ; private volatile Throwable error ; public AllocationThread ( ByteBufAllocator allocator ) { this . allocator = allocator ; } @Override public void run ( ) { try { int idx = <int> ; while ( ! finished ) { for ( int i = <int> ; i < <int> ; i + + ) { buffers . add ( allocator . directBuffer ( ALLOCATION_SIZES [ Math . abs ( idx + + % ALLOCATION_SIZES . length ) ] , Integer . MAX_VALUE ) ) ; } releaseBuffers ( ) ; } } catch ( Throwable cause ) { error = cause ; finished = true ; } finally { releaseBuffers ( ) ; } latch . countDown ( ) ; } private void releaseBuffers ( ) { for ( ; ; ) { ByteBuf buf = buffers . poll ( ) ; if ( buf = = null ) { break ; } buf . release ( ) ; } } public boolean isFinished ( ) { return finished ; } public void finish ( ) throws Throwable { try { finished = true ; latch . await ( ) ; checkForError ( ) ; } finally { releaseBuffers ( ) ; } } public void checkForError ( ) throws Throwable { if ( error ! = null ) { throw error ; } } } } 
