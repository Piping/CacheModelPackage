package org . apache . cassandra . io . compress ; import java . io . * ; import java . nio . ByteBuffer ; import java . nio . MappedByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . file . StandardOpenOption ; import java . util . Arrays ; import java . util . Collections ; import java . util . Random ; import com . google . common . io . Files ; import static org . junit . Assert . * ; import org . junit . Assert ; import org . junit . Test ; import org . apache . cassandra . io . util . RandomAccessReader ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . memory . BufferPool ; public class CompressorTest { ICompressor compressor ; ICompressor [ ] compressors = new ICompressor [ ] { LZ4Compressor . create ( Collections . < String , String > emptyMap ( ) ) , DeflateCompressor . create ( Collections . < String , String > emptyMap ( ) ) , SnappyCompressor . create ( Collections . < String , String > emptyMap ( ) ) } ; @Test public void testAllCompressors ( ) throws IOException { for ( ICompressor compressor : compressors ) { this . compressor = compressor ; testEmptyArray ( ) ; testLongArray ( ) ; testShortArray ( ) ; testMappedFile ( ) ; } } public void testArrayUncompress ( byte [ ] data , int off , int len ) throws IOException { final int inOffset = <int> ; ByteBuffer src = makeBB ( len + inOffset ) ; src . position ( inOffset ) ; src . put ( data , off , len ) ; src . flip ( ) . position ( inOffset ) ; final int outOffset = <int> ; final ByteBuffer compressed = makeBB ( outOffset + compressor . initialCompressedBufferLength ( len ) ) ; fillBBWithRandom ( compressed ) ; compressed . position ( outOffset ) ; compressor . compress ( src , compressed ) ; compressed . flip ( ) . position ( outOffset ) ; final int restoreOffset = <int> ; final byte [ ] restored = new byte [ restoreOffset + len ] ; new Random ( ) . nextBytes ( restored ) ; byte [ ] compressedBytes = new byte [ compressed . capacity ( ) ] ; ByteBufferUtil . arrayCopy ( compressed , outOffset , compressedBytes , outOffset , compressed . capacity ( ) - outOffset ) ; final int decompressedLength = compressor . uncompress ( compressedBytes , outOffset , compressed . remaining ( ) , restored , restoreOffset ) ; assertEquals ( decompressedLength , len ) ; assertArrayEquals ( Arrays . copyOfRange ( data , off , off + len ) , Arrays . copyOfRange ( restored , restoreOffset , restoreOffset + decompressedLength ) ) ; } public void testArrayUncompress ( byte [ ] data ) throws IOException { testArrayUncompress ( data , <int> , data . length ) ; } public void testEmptyArray ( ) throws IOException { testArrayUncompress ( new byte [ <int> ] ) ; } public void testShortArray ( ) throws UnsupportedEncodingException , IOException { testArrayUncompress ( <str> . getBytes ( <str> ) , <int> , <int> ) ; } public void testLongArray ( ) throws UnsupportedEncodingException , IOException { byte [ ] data = new byte [ <int> < < <int> ] ; testArrayUncompress ( data , <int> , <int> < < <int> ) ; new Random ( <int> ) . nextBytes ( data ) ; testArrayUncompress ( data , <int> , <int> < < <int> ) ; } public void testMappedFile ( ) throws IOException { byte [ ] data = new byte [ <int> < < <int> ] ; new Random ( ) . nextBytes ( data ) ; ByteBuffer src = makeBB ( data . length ) ; src . put ( data ) ; src . flip ( ) ; File temp = File . createTempFile ( <str> , <str> ) ; temp . deleteOnExit ( ) ; final int outOffset = <int> ; byte [ ] garbage = new byte [ outOffset + compressor . initialCompressedBufferLength ( data . length ) ] ; new Random ( ) . nextBytes ( garbage ) ; ByteBuffer dest = makeBB ( outOffset + compressor . initialCompressedBufferLength ( data . length ) ) ; dest . put ( garbage ) ; dest . clear ( ) ; dest . position ( outOffset ) ; compressor . compress ( src , dest ) ; int compressedLength = dest . position ( ) - outOffset ; FileChannel channel = FileChannel . open ( temp . toPath ( ) , StandardOpenOption . READ , StandardOpenOption . WRITE ) ; dest . clear ( ) ; channel . write ( dest ) ; MappedByteBuffer mappedData = Files . map ( temp ) ; ByteBuffer result = makeBB ( data . length + <int> ) ; mappedData . position ( outOffset ) . limit ( outOffset + compressedLength ) ; compressor . uncompress ( mappedData , result ) ; channel . close ( ) ; result . flip ( ) ; Assert . assertEquals ( data . length , result . limit ( ) ) ; for ( int i = <int> ; i < result . limit ( ) ; i + + ) { Assert . assertEquals ( <str> + i , data [ i ] , result . get ( ) ) ; } } @Test public void testLZ4ByteBuffers ( ) throws IOException { compressor = LZ4Compressor . create ( Collections . < String , String > emptyMap ( ) ) ; testByteBuffers ( ) ; } @Test public void testDeflateByteBuffers ( ) throws IOException { compressor = DeflateCompressor . create ( Collections . < String , String > emptyMap ( ) ) ; testByteBuffers ( ) ; } @Test public void testSnappyByteBuffers ( ) throws IOException { compressor = SnappyCompressor . create ( Collections . < String , String > emptyMap ( ) ) ; testByteBuffers ( ) ; } private void testByteBuffers ( ) throws IOException { assert compressor . supports ( BufferType . OFF_HEAP ) ; assert compressor . supports ( compressor . preferredBufferType ( ) ) ; for ( BufferType in : BufferType . values ( ) ) if ( compressor . supports ( in ) ) for ( BufferType comp : BufferType . values ( ) ) if ( compressor . supports ( comp ) ) for ( BufferType out : BufferType . values ( ) ) if ( compressor . supports ( out ) ) testByteBuffers ( in , comp , out ) ; } private void testByteBuffers ( BufferType typeIn , BufferType typeComp , BufferType typeOut ) throws IOException { try { int n = RandomAccessReader . DEFAULT_BUFFER_SIZE ; byte [ ] srcData = new byte [ n ] ; new Random ( ) . nextBytes ( srcData ) ; final int inOffset = <int> ; ByteBuffer src = typeIn . allocate ( inOffset + n + inOffset ) ; src . position ( inOffset ) ; src . put ( srcData , <int> , n ) ; src . flip ( ) . position ( inOffset ) ; int outOffset = <int> ; ByteBuffer compressed = typeComp . allocate ( outOffset + compressor . initialCompressedBufferLength ( srcData . length ) + outOffset ) ; byte [ ] garbage = new byte [ compressed . capacity ( ) ] ; new Random ( ) . nextBytes ( garbage ) ; compressed . put ( garbage ) ; compressed . position ( outOffset ) . limit ( compressed . capacity ( ) - outOffset ) ; compressor . compress ( src , compressed ) ; assertEquals ( inOffset + n , src . position ( ) ) ; assertEquals ( inOffset + n , src . limit ( ) ) ; assertEquals ( compressed . capacity ( ) - outOffset , compressed . limit ( ) ) ; compressed . flip ( ) . position ( outOffset ) ; int len = compressed . remaining ( ) ; ByteBuffer result = typeOut . allocate ( inOffset + n + inOffset ) ; result . position ( inOffset ) . limit ( result . capacity ( ) - inOffset ) ; compressor . uncompress ( compressed , result ) ; assertEquals ( outOffset + len , compressed . position ( ) ) ; assertEquals ( outOffset + len , compressed . limit ( ) ) ; assertEquals ( result . capacity ( ) - inOffset , result . limit ( ) ) ; int decompressed = result . position ( ) - inOffset ; assert decompressed = = n : <str> ; for ( int i = <int> ; i < n ; + + i ) assert srcData [ i ] = = result . get ( inOffset + i ) : <str> + i ; } catch ( Throwable e ) { throw new AssertionError ( <str> + compressor . getClass ( ) . getSimpleName ( ) + <str> + typeIn + <str> + typeComp + <str> + typeOut , e ) ; } } private ByteBuffer makeBB ( int size ) { return compressor . preferredBufferType ( ) . allocate ( size ) ; } private void fillBBWithRandom ( ByteBuffer dest ) { byte [ ] random = new byte [ dest . capacity ( ) ] ; new Random ( ) . nextBytes ( random ) ; dest . clear ( ) ; dest . put ( random ) ; } } 
