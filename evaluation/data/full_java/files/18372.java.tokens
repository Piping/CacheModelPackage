package com . badlogic . gdx . utils ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . OutputStreamWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . Date ; import com . badlogic . gdx . utils . ObjectMap . Entry ; public final class PropertiesUtils { private static final int NONE = <int> , SLASH = <int> , UNICODE = <int> , CONTINUE = <int> , KEY_DONE = <int> , IGNORE = <int> ; private static final String LINE_SEPARATOR = <str> ; private PropertiesUtils ( ) { } @SuppressWarnings ( <str> ) public static void load ( ObjectMap < String , String > properties , Reader reader ) throws IOException { if ( properties = = null ) throw new NullPointerException ( <str> ) ; if ( reader = = null ) throw new NullPointerException ( <str> ) ; int mode = NONE , unicode = <int> , count = <int> ; char nextChar , buf [ ] = new char [ <int> ] ; int offset = <int> , keyLength = - <int> , intVal ; boolean firstChar = true ; BufferedReader br = new BufferedReader ( reader ) ; while ( true ) { intVal = br . read ( ) ; if ( intVal = = - <int> ) { break ; } nextChar = ( char ) intVal ; if ( offset = = buf . length ) { char [ ] newBuf = new char [ buf . length * <int> ] ; System . arraycopy ( buf , <int> , newBuf , <int> , offset ) ; buf = newBuf ; } if ( mode = = UNICODE ) { int digit = Character . digit ( nextChar , <int> ) ; if ( digit > = <int> ) { unicode = ( unicode < < <int> ) + digit ; if ( + + count < <int> ) { continue ; } } else if ( count < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } mode = NONE ; buf [ offset + + ] = ( char ) unicode ; if ( nextChar ! = <str> ) { continue ; } } if ( mode = = SLASH ) { mode = NONE ; switch ( nextChar ) { case <str> : mode = CONTINUE ; continue ; case <str> : mode = IGNORE ; continue ; case <str> : nextChar = <str> ; break ; case <str> : nextChar = <str> ; break ; case <str> : nextChar = <str> ; break ; case <str> : nextChar = <str> ; break ; case <str> : nextChar = <str> ; break ; case <str> : mode = UNICODE ; unicode = count = <int> ; continue ; } } else { switch ( nextChar ) { case <str> : case <str> : if ( firstChar ) { while ( true ) { intVal = br . read ( ) ; if ( intVal = = - <int> ) { break ; } nextChar = ( char ) intVal ; if ( nextChar = = <str> | | nextChar = = <str> ) { break ; } } continue ; } break ; case <str> : if ( mode = = CONTINUE ) { mode = IGNORE ; continue ; } case <str> : mode = NONE ; firstChar = true ; if ( offset > <int> | | ( offset = = <int> & & keyLength = = <int> ) ) { if ( keyLength = = - <int> ) { keyLength = offset ; } String temp = new String ( buf , <int> , offset ) ; properties . put ( temp . substring ( <int> , keyLength ) , temp . substring ( keyLength ) ) ; } keyLength = - <int> ; offset = <int> ; continue ; case <str> : if ( mode = = KEY_DONE ) { keyLength = offset ; } mode = SLASH ; continue ; case <str> : case <str> : if ( keyLength = = - <int> ) { mode = NONE ; keyLength = offset ; continue ; } break ; } if ( Character . isSpace ( nextChar ) ) { if ( mode = = CONTINUE ) { mode = IGNORE ; } if ( offset = = <int> | | offset = = keyLength | | mode = = IGNORE ) { continue ; } if ( keyLength = = - <int> ) { mode = KEY_DONE ; continue ; } } if ( mode = = IGNORE | | mode = = CONTINUE ) { mode = NONE ; } } firstChar = false ; if ( mode = = KEY_DONE ) { keyLength = offset ; mode = NONE ; } buf [ offset + + ] = nextChar ; } if ( mode = = UNICODE & & count < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( keyLength = = - <int> & & offset > <int> ) { keyLength = offset ; } if ( keyLength > = <int> ) { String temp = new String ( buf , <int> , offset ) ; String key = temp . substring ( <int> , keyLength ) ; String value = temp . substring ( keyLength ) ; if ( mode = = SLASH ) { value + = <str> ; } properties . put ( key , value ) ; } } public static void store ( ObjectMap < String , String > properties , Writer writer , String comment ) throws IOException { storeImpl ( properties , writer , comment , false ) ; } private static void storeImpl ( ObjectMap < String , String > properties , Writer writer , String comment , boolean escapeUnicode ) throws IOException { if ( comment ! = null ) { writeComment ( writer , comment ) ; } writer . write ( <str> ) ; writer . write ( new Date ( ) . toString ( ) ) ; writer . write ( LINE_SEPARATOR ) ; StringBuilder sb = new StringBuilder ( <int> ) ; for ( Entry < String , String > entry : properties . entries ( ) ) { dumpString ( sb , entry . key , true , escapeUnicode ) ; sb . append ( <str> ) ; dumpString ( sb , entry . value , false , escapeUnicode ) ; writer . write ( LINE_SEPARATOR ) ; writer . write ( sb . toString ( ) ) ; sb . setLength ( <int> ) ; } writer . flush ( ) ; } private static void dumpString ( StringBuilder outBuffer , String string , boolean escapeSpace , boolean escapeUnicode ) { int len = string . length ( ) ; for ( int i = <int> ; i < len ; i + + ) { char ch = string . charAt ( i ) ; if ( ( ch > <int> ) & & ( ch < <int> ) ) { outBuffer . append ( ch = = <str> ? <str> : ch ) ; continue ; } switch ( ch ) { case <str> : if ( i = = <int> | | escapeSpace ) outBuffer . append ( <str> ) ; break ; case <str> : outBuffer . append ( <str> ) ; break ; case <str> : outBuffer . append ( <str> ) ; break ; case <str> : outBuffer . append ( <str> ) ; break ; case <str> : outBuffer . append ( <str> ) ; break ; case <str> : case <str> : case <str> : case <str> : outBuffer . append ( <str> ) . append ( ch ) ; break ; default : if ( ( ( ch < <hex> ) | | ( ch > <hex> ) ) & escapeUnicode ) { String hex = Integer . toHexString ( ch ) ; outBuffer . append ( <str> ) ; for ( int j = <int> ; j < <int> - hex . length ( ) ; j + + ) { outBuffer . append ( <str> ) ; } outBuffer . append ( hex ) ; } else { outBuffer . append ( ch ) ; } break ; } } } private static void writeComment ( Writer writer , String comment ) throws IOException { writer . write ( <str> ) ; int len = comment . length ( ) ; int curIndex = <int> ; int lastIndex = <int> ; while ( curIndex < len ) { char c = comment . charAt ( curIndex ) ; if ( c > <str> | | c = = <str> | | c = = <str> ) { if ( lastIndex ! = curIndex ) writer . write ( comment . substring ( lastIndex , curIndex ) ) ; if ( c > <str> ) { String hex = Integer . toHexString ( c ) ; writer . write ( <str> ) ; for ( int j = <int> ; j < <int> - hex . length ( ) ; j + + ) { writer . write ( <str> ) ; } writer . write ( hex ) ; } else { writer . write ( LINE_SEPARATOR ) ; if ( c = = <str> & & curIndex ! = len - <int> & & comment . charAt ( curIndex + <int> ) = = <str> ) { curIndex + + ; } if ( curIndex = = len - <int> | | ( comment . charAt ( curIndex + <int> ) ! = <str> & & comment . charAt ( curIndex + <int> ) ! = <str> ) ) writer . write ( <str> ) ; } lastIndex = curIndex + <int> ; } curIndex + + ; } if ( lastIndex ! = curIndex ) writer . write ( comment . substring ( lastIndex , curIndex ) ) ; writer . write ( LINE_SEPARATOR ) ; } } 
