package org . elasticsearch . index . search . geo ; import com . spatial4j . core . context . SpatialContext ; import com . spatial4j . core . distance . DistanceUtils ; import org . apache . lucene . spatial . prefix . tree . Cell ; import org . apache . lucene . spatial . prefix . tree . GeohashPrefixTree ; import org . apache . lucene . spatial . prefix . tree . QuadPrefixTree ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentParser . Token ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . hamcrest . Matchers . allOf ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . Matchers . not ; public class GeoUtilsTests extends ESTestCase { private static final char [ ] BASE_32 = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; private static final double MAX_ACCEPTABLE_ERROR = <float> ; public void testGeohashCellWidth ( ) { double equatorialDistance = <int> * Math . PI * <float> ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; } public void testGeohashCellHeight ( ) { double polarDistance = Math . PI * <float> ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . geoHashCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; } public void testGeohashCellSize ( ) { double equatorialDistance = <int> * Math . PI * <float> ; double polarDistance = Math . PI * <float> ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance , <int> ) + Math . pow ( equatorialDistance , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . geoHashCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; } public void testGeoHashLevelsForPrecision ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double precision = randomDouble ( ) * <int> ; int level = GeoUtils . geoHashLevelsForPrecision ( precision ) ; assertThat ( GeoUtils . geoHashCellSize ( level ) , lessThanOrEqualTo ( precision ) ) ; } } public void testGeoHashLevelsForPrecision_String ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double precision = randomDouble ( ) * <int> ; String precisionString = precision + <str> ; int level = GeoUtils . geoHashLevelsForPrecision ( precisionString ) ; assertThat ( GeoUtils . geoHashCellSize ( level ) , lessThanOrEqualTo ( precision ) ) ; } } public void testQuadTreeCellWidth ( ) { double equatorialDistance = <int> * Math . PI * <float> ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , equalTo ( equatorialDistance / <int> ) ) ; } public void testQuadTreeCellHeight ( ) { double polarDistance = Math . PI * <float> ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( <int> ) , equalTo ( polarDistance / <int> ) ) ; } public void testQuadTreeCellSize ( ) { double equatorialDistance = <int> * Math . PI * <float> ; double polarDistance = Math . PI * <float> ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance , <int> ) + Math . pow ( equatorialDistance , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; assertThat ( GeoUtils . quadTreeCellSize ( <int> ) , equalTo ( Math . sqrt ( Math . pow ( polarDistance / <int> , <int> ) + Math . pow ( equatorialDistance / <int> , <int> ) ) ) ) ; } public void testQuadTreeLevelsForPrecision ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double precision = randomDouble ( ) * <int> ; int level = GeoUtils . quadTreeLevelsForPrecision ( precision ) ; assertThat ( GeoUtils . quadTreeCellSize ( level ) , lessThanOrEqualTo ( precision ) ) ; } } public void testQuadTreeLevelsForPrecisionString ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double precision = randomDouble ( ) * <int> ; String precisionString = precision + <str> ; int level = GeoUtils . quadTreeLevelsForPrecision ( precisionString ) ; assertThat ( GeoUtils . quadTreeCellSize ( level ) , lessThanOrEqualTo ( precision ) ) ; } } public void testNormalizeLatInNormalRange ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double testValue = ( randomDouble ( ) * <float> ) - <float> ; assertThat ( GeoUtils . normalizeLat ( testValue ) , closeTo ( testValue , MAX_ACCEPTABLE_ERROR ) ) ; } } public void testNormalizeLatOutsideNormalRange ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double normalisedValue = ( randomDouble ( ) * <float> ) - <float> ; int shift = ( randomBoolean ( ) ? <int> : - <int> ) * randomIntBetween ( <int> , <int> ) ; double testValue = normalisedValue + ( <float> * shift ) ; double expectedValue = normalisedValue * ( shift % <int> = = <int> ? <int> : - <int> ) ; assertThat ( GeoUtils . normalizeLat ( testValue ) , closeTo ( expectedValue , MAX_ACCEPTABLE_ERROR ) ) ; } } public void testNormalizeLatHuge ( ) { assertThat ( GeoUtils . normalizeLat ( - <float> ) , equalTo ( GeoUtils . normalizeLat ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( - <float> ) , equalTo ( GeoUtils . normalizeLat ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( - <float> ) , equalTo ( GeoUtils . normalizeLat ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( - <float> ) , equalTo ( GeoUtils . normalizeLat ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( - <float> ) , equalTo ( GeoUtils . normalizeLat ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( + <float> ) , equalTo ( GeoUtils . normalizeLat ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( + <float> ) , equalTo ( GeoUtils . normalizeLat ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( + <float> ) , equalTo ( GeoUtils . normalizeLat ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( + <float> ) , equalTo ( GeoUtils . normalizeLat ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( + <float> ) , equalTo ( GeoUtils . normalizeLat ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( + <float> ) , equalTo ( GeoUtils . normalizeLat ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( + <float> ) , equalTo ( GeoUtils . normalizeLat ( + <float> ) ) ) ; } public void testNormalizeLatEdgeCases ( ) { assertThat ( GeoUtils . normalizeLat ( Double . POSITIVE_INFINITY ) , equalTo ( Double . NaN ) ) ; assertThat ( GeoUtils . normalizeLat ( Double . NEGATIVE_INFINITY ) , equalTo ( Double . NaN ) ) ; assertThat ( GeoUtils . normalizeLat ( Double . NaN ) , equalTo ( Double . NaN ) ) ; assertThat ( <float> , not ( equalTo ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLat ( - <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLat ( <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLat ( - <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLat ( <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLat ( - <float> ) , equalTo ( - <float> ) ) ; assertThat ( GeoUtils . normalizeLat ( <float> ) , equalTo ( <float> ) ) ; } public void testNormalizeLonInNormalRange ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double testValue = ( randomDouble ( ) * <float> ) - <float> ; assertThat ( GeoUtils . normalizeLon ( testValue ) , closeTo ( testValue , MAX_ACCEPTABLE_ERROR ) ) ; } } public void testNormalizeLonOutsideNormalRange ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double normalisedValue = ( randomDouble ( ) * <float> ) - <float> ; double testValue = normalisedValue + ( ( randomBoolean ( ) ? <int> : - <int> ) * <float> * randomIntBetween ( <int> , <int> ) ) ; assertThat ( GeoUtils . normalizeLon ( testValue ) , closeTo ( normalisedValue , MAX_ACCEPTABLE_ERROR ) ) ; } } public void testNormalizeLonHuge ( ) { assertThat ( GeoUtils . normalizeLon ( - <float> ) , equalTo ( GeoUtils . normalizeLon ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( - <float> ) , equalTo ( GeoUtils . normalizeLon ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( - <float> ) , equalTo ( GeoUtils . normalizeLon ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( - <float> ) , equalTo ( GeoUtils . normalizeLon ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( - <float> ) , equalTo ( GeoUtils . normalizeLon ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( + <float> ) , equalTo ( GeoUtils . normalizeLon ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( + <float> ) , equalTo ( GeoUtils . normalizeLon ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( + <float> ) , equalTo ( GeoUtils . normalizeLon ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( + <float> ) , equalTo ( GeoUtils . normalizeLon ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( + <float> ) , equalTo ( GeoUtils . normalizeLon ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( + <float> ) , equalTo ( GeoUtils . normalizeLon ( + <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( + <float> ) , equalTo ( GeoUtils . normalizeLon ( + <float> ) ) ) ; } public void testNormalizeLonEdgeCases ( ) { assertThat ( GeoUtils . normalizeLon ( Double . POSITIVE_INFINITY ) , equalTo ( Double . NaN ) ) ; assertThat ( GeoUtils . normalizeLon ( Double . NEGATIVE_INFINITY ) , equalTo ( Double . NaN ) ) ; assertThat ( GeoUtils . normalizeLon ( Double . NaN ) , equalTo ( Double . NaN ) ) ; assertThat ( <float> , not ( equalTo ( - <float> ) ) ) ; assertThat ( GeoUtils . normalizeLon ( - <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLon ( <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLon ( - <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLon ( <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLon ( - <float> ) , equalTo ( <float> ) ) ; assertThat ( GeoUtils . normalizeLon ( <float> ) , equalTo ( <float> ) ) ; } public void testNormalizePointInNormalRange ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double testLat = ( randomDouble ( ) * <float> ) - <float> ; double testLon = ( randomDouble ( ) * <float> ) - <float> ; GeoPoint testPoint = new GeoPoint ( testLat , testLon ) ; assertNormalizedPoint ( testPoint , testPoint ) ; } } public void testNormalizePointOutsideNormalRange ( ) { for ( int i = <int> ; i < <int> ; i + + ) { double normalisedLat = ( randomDouble ( ) * <float> ) - <float> ; double normalisedLon = ( randomDouble ( ) * <float> ) - <float> ; int shiftLat = ( randomBoolean ( ) ? <int> : - <int> ) * randomIntBetween ( <int> , <int> ) ; int shiftLon = ( randomBoolean ( ) ? <int> : - <int> ) * randomIntBetween ( <int> , <int> ) ; double testLat = normalisedLat + ( <float> * shiftLat ) ; double testLon = normalisedLon + ( <float> * shiftLon ) ; double expectedLat = normalisedLat * ( shiftLat % <int> = = <int> ? <int> : - <int> ) ; double expectedLon = normalisedLon + ( shiftLat % <int> = = <int> ? <int> : <int> ) ; if ( expectedLon > <float> ) { expectedLon - = <int> ; } GeoPoint testPoint = new GeoPoint ( testLat , testLon ) ; GeoPoint expectedPoint = new GeoPoint ( expectedLat , expectedLon ) ; assertNormalizedPoint ( testPoint , expectedPoint ) ; } } public void testNormalizePointOutsideNormalRange_withOptions ( ) { for ( int i = <int> ; i < <int> ; i + + ) { boolean normalize = randomBoolean ( ) ; double normalisedLat = ( randomDouble ( ) * <float> ) - <float> ; double normalisedLon = ( randomDouble ( ) * <float> ) - <float> ; int shift = randomIntBetween ( <int> , <int> ) ; double testLat = normalisedLat + ( <float> * shift ) ; double testLon = normalisedLon + ( <float> * shift ) ; double expectedLat ; double expectedLon ; if ( normalize ) { expectedLat = normalisedLat * ( shift % <int> = = <int> ? <int> : - <int> ) ; expectedLon = normalisedLon + ( ( shift % <int> = = <int> ) ? <int> : <int> ) ; if ( expectedLon > <float> ) { expectedLon - = <int> ; } } else { expectedLat = testLat ; expectedLon = testLon ; } GeoPoint testPoint = new GeoPoint ( testLat , testLon ) ; GeoPoint expectedPoint = new GeoPoint ( expectedLat , expectedLon ) ; GeoUtils . normalizePoint ( testPoint , normalize , normalize ) ; assertThat ( <str> , testPoint . lat ( ) , closeTo ( expectedPoint . lat ( ) , MAX_ACCEPTABLE_ERROR ) ) ; assertThat ( <str> , testPoint . lon ( ) , closeTo ( expectedPoint . lon ( ) , MAX_ACCEPTABLE_ERROR ) ) ; } } public void testNormalizePointHuge ( ) { assertNormalizedPoint ( new GeoPoint ( - <float> , - <float> ) , new GeoPoint ( - <float> , - <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( - <float> , - <float> ) , new GeoPoint ( - <float> , + <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( - <float> , - <float> ) , new GeoPoint ( - <float> , - <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( - <float> , - <float> ) , new GeoPoint ( - <float> , - <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( - <float> , - <float> ) , new GeoPoint ( - <float> , - <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( + <float> , + <float> ) , new GeoPoint ( + <float> , + <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( + <float> , + <float> ) , new GeoPoint ( + <float> , + <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( + <float> , + <float> ) , new GeoPoint ( + <float> , + <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( + <float> , + <float> ) , new GeoPoint ( + <float> , + <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( + <float> , + <float> ) , new GeoPoint ( + <float> , + <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( + <float> , + <float> ) , new GeoPoint ( + <float> , + <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( + <float> , + <float> ) , new GeoPoint ( + <float> , + <float> ) ) ; } public void testNormalizePointEdgeCases ( ) { assertNormalizedPoint ( new GeoPoint ( Double . POSITIVE_INFINITY , Double . POSITIVE_INFINITY ) , new GeoPoint ( Double . NaN , Double . NaN ) ) ; assertNormalizedPoint ( new GeoPoint ( Double . NEGATIVE_INFINITY , Double . NEGATIVE_INFINITY ) , new GeoPoint ( Double . NaN , Double . NaN ) ) ; assertNormalizedPoint ( new GeoPoint ( Double . NaN , Double . NaN ) , new GeoPoint ( Double . NaN , Double . NaN ) ) ; assertThat ( <float> , not ( equalTo ( - <float> ) ) ) ; assertNormalizedPoint ( new GeoPoint ( - <float> , - <float> ) , new GeoPoint ( <float> , <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( <float> , <float> ) , new GeoPoint ( <float> , <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( - <float> , - <float> ) , new GeoPoint ( <float> , <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( <float> , <float> ) , new GeoPoint ( <float> , <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( - <float> , - <float> ) , new GeoPoint ( - <float> , - <float> ) ) ; assertNormalizedPoint ( new GeoPoint ( <float> , <float> ) , new GeoPoint ( <float> , <float> ) ) ; } public void testParseGeoPoint ( ) throws IOException { for ( int i = <int> ; i < <int> ; i + + ) { double lat = randomDouble ( ) * <int> - <int> + randomIntBetween ( - <int> , <int> ) * <int> ; double lon = randomDouble ( ) * <int> - <int> + randomIntBetween ( - <int> , <int> ) * <int> ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , lat ) . field ( <str> , lon ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; GeoPoint point = GeoUtils . parseGeoPoint ( parser ) ; assertThat ( point , equalTo ( new GeoPoint ( lat , lon ) ) ) ; jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , String . valueOf ( lat ) ) . field ( <str> , String . valueOf ( lon ) ) . endObject ( ) . bytes ( ) ; parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; point = GeoUtils . parseGeoPoint ( parser ) ; assertThat ( point , equalTo ( new GeoPoint ( lat , lon ) ) ) ; jsonBytes = jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( lon ) . value ( lat ) . endArray ( ) . endObject ( ) . bytes ( ) ; parser = XContentHelper . createParser ( jsonBytes ) ; while ( parser . currentToken ( ) ! = Token . START_ARRAY ) { parser . nextToken ( ) ; } point = GeoUtils . parseGeoPoint ( parser ) ; assertThat ( point , equalTo ( new GeoPoint ( lat , lon ) ) ) ; jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , lat + <str> + lon ) . endObject ( ) . bytes ( ) ; parser = XContentHelper . createParser ( jsonBytes ) ; while ( parser . currentToken ( ) ! = Token . VALUE_STRING ) { parser . nextToken ( ) ; } point = GeoUtils . parseGeoPoint ( parser ) ; assertThat ( point , equalTo ( new GeoPoint ( lat , lon ) ) ) ; } } public void testParseGeoPointGeohash ( ) throws IOException { for ( int i = <int> ; i < <int> ; i + + ) { int geoHashLength = randomIntBetween ( <int> , GeoHashUtils . PRECISION ) ; StringBuilder geohashBuilder = new StringBuilder ( geoHashLength ) ; for ( int j = <int> ; j < geoHashLength ; j + + ) { geohashBuilder . append ( BASE_32 [ randomInt ( BASE_32 . length - <int> ) ] ) ; } BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , geohashBuilder . toString ( ) ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; GeoPoint point = GeoUtils . parseGeoPoint ( parser ) ; assertThat ( point . lat ( ) , allOf ( lessThanOrEqualTo ( <float> ) , greaterThanOrEqualTo ( - <float> ) ) ) ; assertThat ( point . lon ( ) , allOf ( lessThanOrEqualTo ( <float> ) , greaterThanOrEqualTo ( - <float> ) ) ) ; jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , geohashBuilder . toString ( ) ) . endObject ( ) . bytes ( ) ; parser = XContentHelper . createParser ( jsonBytes ) ; while ( parser . currentToken ( ) ! = Token . VALUE_STRING ) { parser . nextToken ( ) ; } point = GeoUtils . parseGeoPoint ( parser ) ; assertThat ( point . lat ( ) , allOf ( lessThanOrEqualTo ( <float> ) , greaterThanOrEqualTo ( - <float> ) ) ) ; assertThat ( point . lon ( ) , allOf ( lessThanOrEqualTo ( <float> ) , greaterThanOrEqualTo ( - <float> ) ) ) ; } } public void testParseGeoPointGeohashWrongType ( ) throws IOException { BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , <float> ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testParseGeoPointLatNoLon ( ) throws IOException { double lat = <float> ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , lat ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParseGeoPointLonNoLat ( ) throws IOException { double lon = <float> ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , lon ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParseGeoPointLonWrongType ( ) throws IOException { double lat = <float> ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , lat ) . field ( <str> , false ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParseGeoPointLatWrongType ( ) throws IOException { double lon = <float> ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , false ) . field ( <str> , lon ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParseGeoPointExtraField ( ) throws IOException { double lat = <float> ; double lon = <float> ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , lat ) . field ( <str> , lon ) . field ( <str> , true ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParseGeoPointLonLatGeoHash ( ) throws IOException { double lat = <float> ; double lon = <float> ; String geohash = <str> ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , lat ) . field ( <str> , lon ) . field ( <str> , geohash ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testParseGeoPointArrayTooManyValues ( ) throws IOException { double lat = <float> ; double lon = <float> ; double elev = <float> ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( lon ) . value ( lat ) . value ( elev ) . endArray ( ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; while ( parser . currentToken ( ) ! = Token . START_ARRAY ) { parser . nextToken ( ) ; } try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParseGeoPointArrayWrongType ( ) throws IOException { double lat = <float> ; boolean lon = false ; BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . startArray ( <str> ) . value ( lon ) . value ( lat ) . endArray ( ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; while ( parser . currentToken ( ) ! = Token . START_ARRAY ) { parser . nextToken ( ) ; } try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParseGeoPointInvalidType ( ) throws IOException { BytesReference jsonBytes = jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) . bytes ( ) ; XContentParser parser = XContentHelper . createParser ( jsonBytes ) ; while ( parser . currentToken ( ) ! = Token . VALUE_NUMBER ) { parser . nextToken ( ) ; } try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testPrefixTreeCellSizes ( ) { assertThat ( GeoUtils . EARTH_SEMI_MAJOR_AXIS , equalTo ( DistanceUtils . EARTH_EQUATORIAL_RADIUS_KM * <int> ) ) ; assertThat ( GeoUtils . quadTreeCellWidth ( <int> ) , lessThanOrEqualTo ( GeoUtils . EARTH_EQUATOR ) ) ; SpatialContext spatialContext = new SpatialContext ( true ) ; GeohashPrefixTree geohashPrefixTree = new GeohashPrefixTree ( spatialContext , GeohashPrefixTree . getMaxLevelsPossible ( ) / <int> ) ; Cell gNode = geohashPrefixTree . getWorldCell ( ) ; for ( int i = <int> ; i < geohashPrefixTree . getMaxLevels ( ) ; i + + ) { double width = GeoUtils . geoHashCellWidth ( i ) ; double height = GeoUtils . geoHashCellHeight ( i ) ; double size = GeoUtils . geoHashCellSize ( i ) ; double degrees = <float> * width / GeoUtils . EARTH_EQUATOR ; int level = GeoUtils . quadTreeLevelsForPrecision ( size ) ; assertThat ( GeoUtils . quadTreeCellWidth ( level ) , lessThanOrEqualTo ( width ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( level ) , lessThanOrEqualTo ( height ) ) ; assertThat ( GeoUtils . geoHashLevelsForPrecision ( size ) , equalTo ( geohashPrefixTree . getLevelForDistance ( degrees ) ) ) ; assertThat ( <str> + i , gNode . getShape ( ) . getBoundingBox ( ) . getWidth ( ) , equalTo ( <float> * width / GeoUtils . EARTH_EQUATOR ) ) ; assertThat ( <str> + i , gNode . getShape ( ) . getBoundingBox ( ) . getHeight ( ) , equalTo ( <float> * height / GeoUtils . EARTH_POLAR_DISTANCE ) ) ; gNode = gNode . getNextLevelCells ( null ) . next ( ) ; } QuadPrefixTree quadPrefixTree = new QuadPrefixTree ( spatialContext ) ; Cell qNode = quadPrefixTree . getWorldCell ( ) ; for ( int i = <int> ; i < quadPrefixTree . getMaxLevels ( ) ; i + + ) { double degrees = <float> / ( <int> < < i ) ; double width = GeoUtils . quadTreeCellWidth ( i ) ; double height = GeoUtils . quadTreeCellHeight ( i ) ; double size = GeoUtils . quadTreeCellSize ( i ) ; int level = GeoUtils . quadTreeLevelsForPrecision ( size ) ; assertThat ( GeoUtils . quadTreeCellWidth ( level ) , lessThanOrEqualTo ( width ) ) ; assertThat ( GeoUtils . quadTreeCellHeight ( level ) , lessThanOrEqualTo ( height ) ) ; assertThat ( GeoUtils . quadTreeLevelsForPrecision ( size ) , equalTo ( quadPrefixTree . getLevelForDistance ( degrees ) ) ) ; assertThat ( <str> + i , qNode . getShape ( ) . getBoundingBox ( ) . getWidth ( ) , equalTo ( <float> * width / GeoUtils . EARTH_EQUATOR ) ) ; assertThat ( <str> + i , qNode . getShape ( ) . getBoundingBox ( ) . getHeight ( ) , equalTo ( <float> * height / GeoUtils . EARTH_POLAR_DISTANCE ) ) ; qNode = qNode . getNextLevelCells ( null ) . next ( ) ; } } private static void assertNormalizedPoint ( GeoPoint input , GeoPoint expected ) { GeoUtils . normalizePoint ( input ) ; if ( Double . isNaN ( expected . lat ( ) ) ) { assertThat ( <str> , input . lat ( ) , equalTo ( expected . lat ( ) ) ) ; } else { assertThat ( <str> , input . lat ( ) , closeTo ( expected . lat ( ) , MAX_ACCEPTABLE_ERROR ) ) ; } if ( Double . isNaN ( expected . lon ( ) ) ) { assertThat ( <str> , input . lon ( ) , equalTo ( expected . lon ( ) ) ) ; } else { assertThat ( <str> , input . lon ( ) , closeTo ( expected . lon ( ) , MAX_ACCEPTABLE_ERROR ) ) ; } } } 
