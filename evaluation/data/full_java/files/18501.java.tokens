package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . InputAdapter ; import com . badlogic . gdx . InputMultiplexer ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . Interpolation ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . ui . List ; import com . badlogic . gdx . scenes . scene2d . ui . ScrollPane ; import com . badlogic . gdx . scenes . scene2d . ui . Skin ; import com . badlogic . gdx . scenes . scene2d . ui . Table ; import com . badlogic . gdx . scenes . scene2d . utils . ChangeListener ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . reflect . ClassReflection ; import com . badlogic . gdx . utils . reflect . Field ; import com . badlogic . gdx . utils . viewport . ScreenViewport ; public class InterpolationTest extends GdxTest { Stage stage ; private Skin skin ; private Table table ; List < String > list ; String interpolationNames [ ] , selectedInterpolation ; private ShapeRenderer renderer ; float graphSize = <int> , steps = graphSize / <int> , time = <int> , duration = <float> ; Vector2 startPosition = new Vector2 ( ) , targetPosition = new Vector2 ( ) , position = new Vector2 ( ) ; void resetPositions ( ) { startPosition . set ( stage . getWidth ( ) - stage . getWidth ( ) / <float> , stage . getHeight ( ) - stage . getHeight ( ) / <float> ) ; targetPosition . set ( startPosition . x , stage . getHeight ( ) / <float> ) ; } Vector2 getPosition ( float time ) { position . set ( targetPosition ) ; position . sub ( startPosition ) ; position . scl ( getInterpolation ( selectedInterpolation ) . apply ( time / duration ) ) ; position . add ( startPosition ) ; return position ; } private Interpolation getInterpolation ( String name ) { try { return ( Interpolation ) Interpolation . class . getField ( name ) . get ( null ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } @Override public void create ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; renderer = new ShapeRenderer ( ) ; skin = new Skin ( Gdx . files . internal ( <str> ) ) ; stage = new Stage ( new ScreenViewport ( ) ) ; resetPositions ( ) ; Field [ ] interpolationFields = ClassReflection . getFields ( Interpolation . class ) ; int interpolationMembers = <int> ; for ( int i = <int> ; i < interpolationFields . length ; i + + ) if ( Interpolation . class . isAssignableFrom ( interpolationFields [ i ] . getDeclaringClass ( ) ) ) interpolationMembers + + ; interpolationNames = new String [ interpolationMembers ] ; for ( int i = <int> ; i < interpolationFields . length ; i + + ) if ( Interpolation . class . isAssignableFrom ( interpolationFields [ i ] . getDeclaringClass ( ) ) ) interpolationNames [ i ] = interpolationFields [ i ] . getName ( ) ; selectedInterpolation = interpolationNames [ <int> ] ; list = new List ( skin ) ; list . setItems ( interpolationNames ) ; list . addListener ( new ChangeListener ( ) { public void changed ( ChangeEvent event , Actor actor ) { selectedInterpolation = list . getSelected ( ) ; time = <int> ; resetPositions ( ) ; } } ) ; ScrollPane scroll = new ScrollPane ( list , skin ) ; scroll . setFadeScrollBars ( false ) ; scroll . setScrollingDisabled ( true , false ) ; table = new Table ( ) ; table . setFillParent ( true ) ; table . add ( scroll ) . expandX ( ) . left ( ) . width ( <int> ) ; stage . addActor ( table ) ; Gdx . input . setInputProcessor ( new InputMultiplexer ( new InputAdapter ( ) { public boolean scrolled ( int amount ) { if ( ! Gdx . input . isKeyPressed ( Keys . CONTROL_LEFT ) ) return false ; duration - = amount / <int> f ; duration = MathUtils . clamp ( duration , <int> , Float . POSITIVE_INFINITY ) ; return true ; } } , stage , new InputAdapter ( ) { public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { if ( ! Float . isNaN ( time ) ) startPosition . set ( getPosition ( time ) ) ; targetPosition . set ( stage . screenToStageCoordinates ( targetPosition . set ( screenX , screenY ) ) ) ; time = <int> ; return true ; } } ) ) ; } public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; float bottomLeftX = Gdx . graphics . getWidth ( ) / <int> - graphSize / <int> , bottomLeftY = Gdx . graphics . getHeight ( ) / <int> - graphSize / <int> ; String text = String . valueOf ( duration ) ; if ( text . length ( ) > <int> ) text = text . substring ( <int> , text . lastIndexOf ( <str> ) + <int> ) ; text = <str> + text + <str> ; stage . getBatch ( ) . begin ( ) ; list . getStyle ( ) . font . draw ( stage . getBatch ( ) , text , bottomLeftX + graphSize / <int> , bottomLeftY + graphSize + list . getStyle ( ) . font . getLineHeight ( ) , <int> , Align . center , false ) ; stage . getBatch ( ) . end ( ) ; renderer . begin ( ShapeType . Line ) ; renderer . rect ( bottomLeftX , bottomLeftY , graphSize , graphSize ) ; float lastX = bottomLeftX , lastY = bottomLeftY ; for ( float step = <int> ; step < = steps ; step + + ) { Interpolation interpolation = getInterpolation ( selectedInterpolation ) ; float percent = step / steps ; float x = bottomLeftX + graphSize * percent , y = bottomLeftY + graphSize * interpolation . apply ( percent ) ; renderer . line ( lastX , lastY , x , y ) ; lastX = x ; lastY = y ; } time + = Gdx . graphics . getDeltaTime ( ) ; if ( time > duration ) { time = Float . NaN ; startPosition . set ( targetPosition ) ; } renderer . line ( bottomLeftX + graphSize * time / duration , bottomLeftY , bottomLeftX + graphSize * time / duration , bottomLeftY + graphSize ) ; renderer . setColor ( Color . GRAY ) ; renderer . line ( startPosition , targetPosition ) ; renderer . setColor ( Color . WHITE ) ; renderer . end ( ) ; renderer . begin ( ShapeType . Filled ) ; if ( ! Float . isNaN ( time ) ) getPosition ( time ) ; renderer . circle ( position . x , position . y , <int> ) ; renderer . end ( ) ; stage . act ( ) ; stage . draw ( ) ; } public void resize ( int width , int height ) { stage . getViewport ( ) . update ( width , height , true ) ; table . invalidateHierarchy ( ) ; renderer . setProjectionMatrix ( stage . getViewport ( ) . getCamera ( ) . combined ) ; } public void dispose ( ) { stage . dispose ( ) ; skin . dispose ( ) ; } } 
