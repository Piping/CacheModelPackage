package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtIncompatible ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; @Beta @GwtIncompatible ( <str> ) public abstract class ImmutableSortedMultiset < E > extends ImmutableSortedMultisetFauxverideShim < E > implements SortedMultiset < E > { @SuppressWarnings ( <str> ) public static < E > ImmutableSortedMultiset < E > of ( ) { return ( ImmutableSortedMultiset ) RegularImmutableSortedMultiset . NATURAL_EMPTY_MULTISET ; } public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > of ( E element ) { RegularImmutableSortedSet < E > elementSet = ( RegularImmutableSortedSet < E > ) ImmutableSortedSet . of ( element ) ; long [ ] cumulativeCounts = { <int> , <int> } ; return new RegularImmutableSortedMultiset < E > ( elementSet , cumulativeCounts , <int> , <int> ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > of ( E e1 , E e2 ) { return copyOf ( Ordering . natural ( ) , Arrays . asList ( e1 , e2 ) ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 ) { return copyOf ( Ordering . natural ( ) , Arrays . asList ( e1 , e2 , e3 ) ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 , E e4 ) { return copyOf ( Ordering . natural ( ) , Arrays . asList ( e1 , e2 , e3 , e4 ) ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return copyOf ( Ordering . natural ( ) , Arrays . asList ( e1 , e2 , e3 , e4 , e5 ) ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E . . . remaining ) { int size = remaining . length + <int> ; List < E > all = Lists . newArrayListWithCapacity ( size ) ; Collections . addAll ( all , e1 , e2 , e3 , e4 , e5 , e6 ) ; Collections . addAll ( all , remaining ) ; return copyOf ( Ordering . natural ( ) , all ) ; } public static < E extends Comparable < ? super E > > ImmutableSortedMultiset < E > copyOf ( E [ ] elements ) { return copyOf ( Ordering . natural ( ) , Arrays . asList ( elements ) ) ; } public static < E > ImmutableSortedMultiset < E > copyOf ( Iterable < ? extends E > elements ) { @SuppressWarnings ( <str> ) Ordering < E > naturalOrder = ( Ordering < E > ) Ordering . < Comparable > natural ( ) ; return copyOf ( naturalOrder , elements ) ; } public static < E > ImmutableSortedMultiset < E > copyOf ( Iterator < ? extends E > elements ) { @SuppressWarnings ( <str> ) Ordering < E > naturalOrder = ( Ordering < E > ) Ordering . < Comparable > natural ( ) ; return copyOf ( naturalOrder , elements ) ; } public static < E > ImmutableSortedMultiset < E > copyOf ( Comparator < ? super E > comparator , Iterator < ? extends E > elements ) { checkNotNull ( comparator ) ; return new Builder < E > ( comparator ) . addAll ( elements ) . build ( ) ; } public static < E > ImmutableSortedMultiset < E > copyOf ( Comparator < ? super E > comparator , Iterable < ? extends E > elements ) { if ( elements instanceof ImmutableSortedMultiset ) { @SuppressWarnings ( <str> ) ImmutableSortedMultiset < E > multiset = ( ImmutableSortedMultiset < E > ) elements ; if ( comparator . equals ( multiset . comparator ( ) ) ) { if ( multiset . isPartialView ( ) ) { return copyOfSortedEntries ( comparator , multiset . entrySet ( ) . asList ( ) ) ; } else { return multiset ; } } } elements = Lists . newArrayList ( elements ) ; TreeMultiset < E > sortedCopy = TreeMultiset . create ( checkNotNull ( comparator ) ) ; Iterables . addAll ( sortedCopy , elements ) ; return copyOfSortedEntries ( comparator , sortedCopy . entrySet ( ) ) ; } public static < E > ImmutableSortedMultiset < E > copyOfSorted ( SortedMultiset < E > sortedMultiset ) { return copyOfSortedEntries ( sortedMultiset . comparator ( ) , Lists . newArrayList ( sortedMultiset . entrySet ( ) ) ) ; } private static < E > ImmutableSortedMultiset < E > copyOfSortedEntries ( Comparator < ? super E > comparator , Collection < Entry < E > > entries ) { if ( entries . isEmpty ( ) ) { return emptyMultiset ( comparator ) ; } ImmutableList . Builder < E > elementsBuilder = new ImmutableList . Builder < E > ( entries . size ( ) ) ; long [ ] cumulativeCounts = new long [ entries . size ( ) + <int> ] ; int i = <int> ; for ( Entry < E > entry : entries ) { elementsBuilder . add ( entry . getElement ( ) ) ; cumulativeCounts [ i + <int> ] = cumulativeCounts [ i ] + entry . getCount ( ) ; i + + ; } return new RegularImmutableSortedMultiset < E > ( new RegularImmutableSortedSet < E > ( elementsBuilder . build ( ) , comparator ) , cumulativeCounts , <int> , entries . size ( ) ) ; } @SuppressWarnings ( <str> ) static < E > ImmutableSortedMultiset < E > emptyMultiset ( Comparator < ? super E > comparator ) { if ( Ordering . natural ( ) . equals ( comparator ) ) { return ( ImmutableSortedMultiset < E > ) RegularImmutableSortedMultiset . NATURAL_EMPTY_MULTISET ; } else { return new RegularImmutableSortedMultiset < E > ( comparator ) ; } } ImmutableSortedMultiset ( ) { } @Override public final Comparator < ? super E > comparator ( ) { return elementSet ( ) . comparator ( ) ; } @Override public abstract ImmutableSortedSet < E > elementSet ( ) ; transient ImmutableSortedMultiset < E > descendingMultiset ; @Override public ImmutableSortedMultiset < E > descendingMultiset ( ) { ImmutableSortedMultiset < E > result = descendingMultiset ; if ( result = = null ) { return descendingMultiset = this . isEmpty ( ) ? emptyMultiset ( Ordering . from ( comparator ( ) ) . reverse ( ) ) : new DescendingImmutableSortedMultiset < E > ( this ) ; } return result ; } @Deprecated @Override public final Entry < E > pollFirstEntry ( ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final Entry < E > pollLastEntry ( ) { throw new UnsupportedOperationException ( ) ; } @Override public abstract ImmutableSortedMultiset < E > headMultiset ( E upperBound , BoundType boundType ) ; @Override public ImmutableSortedMultiset < E > subMultiset ( E lowerBound , BoundType lowerBoundType , E upperBound , BoundType upperBoundType ) { checkArgument ( comparator ( ) . compare ( lowerBound , upperBound ) < = <int> , <str> , lowerBound , upperBound ) ; return tailMultiset ( lowerBound , lowerBoundType ) . headMultiset ( upperBound , upperBoundType ) ; } @Override public abstract ImmutableSortedMultiset < E > tailMultiset ( E lowerBound , BoundType boundType ) ; public static < E > Builder < E > orderedBy ( Comparator < E > comparator ) { return new Builder < E > ( comparator ) ; } public static < E extends Comparable < ? > > Builder < E > reverseOrder ( ) { return new Builder < E > ( Ordering . natural ( ) . reverse ( ) ) ; } public static < E extends Comparable < ? > > Builder < E > naturalOrder ( ) { return new Builder < E > ( Ordering . natural ( ) ) ; } public static class Builder < E > extends ImmutableMultiset . Builder < E > { public Builder ( Comparator < ? super E > comparator ) { super ( TreeMultiset . < E > create ( checkNotNull ( comparator ) ) ) ; } @Override public Builder < E > add ( E element ) { super . add ( element ) ; return this ; } @Override public Builder < E > addCopies ( E element , int occurrences ) { super . addCopies ( element , occurrences ) ; return this ; } @Override public Builder < E > setCount ( E element , int count ) { super . setCount ( element , count ) ; return this ; } @Override public Builder < E > add ( E . . . elements ) { super . add ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterable < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterator < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public ImmutableSortedMultiset < E > build ( ) { return copyOfSorted ( ( SortedMultiset < E > ) contents ) ; } } private static final class SerializedForm < E > implements Serializable { Comparator < ? super E > comparator ; E [ ] elements ; int [ ] counts ; @SuppressWarnings ( <str> ) SerializedForm ( SortedMultiset < E > multiset ) { this . comparator = multiset . comparator ( ) ; int n = multiset . entrySet ( ) . size ( ) ; elements = ( E [ ] ) new Object [ n ] ; counts = new int [ n ] ; int i = <int> ; for ( Entry < E > entry : multiset . entrySet ( ) ) { elements [ i ] = entry . getElement ( ) ; counts [ i ] = entry . getCount ( ) ; i + + ; } } Object readResolve ( ) { int n = elements . length ; Builder < E > builder = new Builder < E > ( comparator ) ; for ( int i = <int> ; i < n ; i + + ) { builder . addCopies ( elements [ i ] , counts [ i ] ) ; } return builder . build ( ) ; } } @Override Object writeReplace ( ) { return new SerializedForm < E > ( this ) ; } } 
