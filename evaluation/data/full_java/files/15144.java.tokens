package org . gradle . play . internal . javascript ; import com . google . common . collect . Lists ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . internal . file . RelativeFile ; import org . gradle . api . internal . tasks . SimpleWorkResult ; import org . gradle . api . tasks . WorkResult ; import org . gradle . internal . Factory ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . reflect . DirectInstantiator ; import org . gradle . internal . reflect . JavaMethod ; import org . gradle . internal . reflect . JavaReflectionUtil ; import org . gradle . internal . reflect . PropertyAccessor ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . plugins . javascript . base . SourceTransformationException ; import org . gradle . util . GFileUtils ; import java . io . File ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . io . Serializable ; import java . util . List ; public class GoogleClosureCompiler implements Compiler < JavaScriptCompileSpec > , Serializable { private static final Iterable < String > SHARED_PACKAGES = Lists . newArrayList ( <str> ) ; private static final String DEFAULT_GOOGLE_CLOSURE_VERSION = <str> ; private Class < ? > sourceFileClass ; private Class < ? > compilerOptionsClass ; private Class < Enum > compilationLevelClass ; private Class < Object > compilerClass ; public Iterable < String > getClassLoaderPackages ( ) { return SHARED_PACKAGES ; } public static Object getDependencyNotation ( ) { return String . format ( <str> , DEFAULT_GOOGLE_CLOSURE_VERSION ) ; } @Override public WorkResult execute ( JavaScriptCompileSpec spec ) { JavaScriptCompileDestinationCalculator destinationCalculator = new JavaScriptCompileDestinationCalculator ( spec . getDestinationDir ( ) ) ; List < String > allErrors = Lists . newArrayList ( ) ; for ( RelativeFile sourceFile : spec . getSources ( ) ) { allErrors . addAll ( compile ( sourceFile , spec , destinationCalculator ) ) ; } if ( allErrors . isEmpty ( ) ) { return new SimpleWorkResult ( true ) ; } else { throw new SourceTransformationException ( String . format ( <str> , StringUtils . join ( allErrors , <str> ) ) , null ) ; } } List < String > compile ( RelativeFile javascriptFile , JavaScriptCompileSpec spec , JavaScriptCompileDestinationCalculator destinationCalculator ) { List < String > errors = Lists . newArrayList ( ) ; loadCompilerClasses ( getClass ( ) . getClassLoader ( ) ) ; JavaMethod < ? , Object > fromCodeJavaMethod = JavaReflectionUtil . staticMethod ( sourceFileClass , Object . class , <str> , String . class , String . class ) ; Object extern = fromCodeJavaMethod . invokeStatic ( <str> , <str> ) ; JavaMethod < ? , Object > fromFileJavaMethod = JavaReflectionUtil . staticMethod ( sourceFileClass , Object . class , <str> , File . class ) ; Object sourceFile = fromFileJavaMethod . invokeStatic ( javascriptFile . getFile ( ) ) ; Factory < ? > compilerOptionsFactory = JavaReflectionUtil . factory ( DirectInstantiator . INSTANCE , compilerOptionsClass ) ; Object compilerOptions = compilerOptionsFactory . create ( ) ; @SuppressWarnings ( { <str> , <str> } ) Enum simpleLevel = Enum . valueOf ( compilationLevelClass , <str> ) ; @SuppressWarnings ( <str> ) JavaMethod < Enum , Void > setOptionsForCompilationLevelMethod = JavaReflectionUtil . method ( compilationLevelClass , Void . class , <str> , compilerOptionsClass ) ; setOptionsForCompilationLevelMethod . invoke ( simpleLevel , compilerOptions ) ; Factory < ? > compilerFactory = JavaReflectionUtil . factory ( DirectInstantiator . INSTANCE , compilerClass , getDummyPrintStream ( ) ) ; Object compiler = compilerFactory . create ( ) ; JavaMethod < Object , Object > compileMethod = JavaReflectionUtil . method ( compilerClass , Object . class , <str> , sourceFileClass , sourceFileClass , compilerOptionsClass ) ; Object result = compileMethod . invoke ( compiler , extern , sourceFile , compilerOptions ) ; PropertyAccessor < Object , Object [ ] > jsErrorsField = JavaReflectionUtil . readableField ( result , Object [ ] . class , <str> ) ; Object [ ] jsErrors = jsErrorsField . getValue ( result ) ; if ( jsErrors . length = = <int> ) { JavaMethod < Object , String > toSourceMethod = JavaReflectionUtil . method ( compilerClass , String . class , <str> ) ; String compiledSource = toSourceMethod . invoke ( compiler ) ; GFileUtils . writeFile ( compiledSource , destinationCalculator . transform ( javascriptFile ) ) ; } else { for ( Object error : jsErrors ) { errors . add ( error . toString ( ) ) ; } } return errors ; } private void loadCompilerClasses ( ClassLoader cl ) { try { if ( sourceFileClass = = null ) { sourceFileClass = cl . loadClass ( <str> ) ; } if ( compilerOptionsClass = = null ) { compilerOptionsClass = cl . loadClass ( <str> ) ; } if ( compilationLevelClass = = null ) { @SuppressWarnings ( <str> ) Class < Enum > clazz = ( Class < Enum > ) cl . loadClass ( <str> ) ; compilationLevelClass = clazz ; } if ( compilerClass = = null ) { @SuppressWarnings ( <str> ) Class < Object > clazz = ( Class < Object > ) cl . loadClass ( <str> ) ; compilerClass = clazz ; } } catch ( ClassNotFoundException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } private PrintStream getDummyPrintStream ( ) { OutputStream os = new OutputStream ( ) { @Override public void write ( int b ) throws IOException { } } ; return new PrintStream ( os ) ; } } 
