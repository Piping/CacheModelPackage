package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputAdapter ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . BitmapFontCache ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Align ; public class BitmapFontFlipTest extends GdxTest { private SpriteBatch spriteBatch ; private Texture texture ; private BitmapFont font ; private Sprite logoSprite ; private Color red = new Color ( <int> , <int> , <int> , <int> ) ; private BitmapFontCache cache1 , cache2 , cache3 , cache4 , cache5 ; private BitmapFontCache cacheScaled1 , cacheScaled2 , cacheScaled3 , cacheScaled4 , cacheScaled5 ; int renderMode ; @Override public void create ( ) { Gdx . input . setInputProcessor ( new InputAdapter ( ) { public boolean touchDown ( int x , int y , int pointer , int newParam ) { renderMode = ( renderMode + <int> ) % <int> ; return false ; } } ) ; spriteBatch = new SpriteBatch ( ) ; spriteBatch . setProjectionMatrix ( new Matrix4 ( ) . setToOrtho ( <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) , <int> , <int> , <int> ) ) ; texture = new Texture ( Gdx . files . internal ( <str> ) ) ; logoSprite = new Sprite ( texture ) ; logoSprite . flip ( false , true ) ; logoSprite . setPosition ( <int> , <int> - <int> ) ; logoSprite . setColor ( <int> , <int> , <int> , <float> ) ; font = new BitmapFont ( Gdx . files . internal ( <str> ) , Gdx . files . internal ( <str> ) , true ) ; cache1 = font . newFontCache ( ) ; cache2 = font . newFontCache ( ) ; cache3 = font . newFontCache ( ) ; cache4 = font . newFontCache ( ) ; cache5 = font . newFontCache ( ) ; createCaches ( <str> , cache1 , cache2 , cache3 , cache4 , cache5 ) ; font . getData ( ) . setScale ( <float> ) ; cacheScaled1 = font . newFontCache ( ) ; cacheScaled2 = font . newFontCache ( ) ; cacheScaled3 = font . newFontCache ( ) ; cacheScaled4 = font . newFontCache ( ) ; cacheScaled5 = font . newFontCache ( ) ; createCaches ( <str> , cacheScaled1 , cacheScaled2 , cacheScaled3 , cacheScaled4 , cacheScaled5 ) ; } private void createCaches ( String type , BitmapFontCache cache1 , BitmapFontCache cache2 , BitmapFontCache cache3 , BitmapFontCache cache4 , BitmapFontCache cache5 ) { cache1 . setText ( <str> + type + <str> , <int> , <int> - <int> ) ; String text = <str> ; cache2 . setColor ( Color . RED ) ; cache2 . setText ( text , <int> , <int> - <int> ) ; text = <str> ; cache3 . setColor ( Color . BLUE ) ; cache3 . setText ( text , <int> , <int> - <int> , <int> , Align . center , false ) ; text = <str> ; cache4 . setText ( text , <int> , <int> - <int> , <int> , text . length ( ) - <int> , <int> , Align . left , false ) ; text = <str> ; cache5 . setColor ( red ) ; cache5 . setText ( text , <int> , <int> - <int> , <int> , Align . center , false ) ; } @Override public void render ( ) { red . a = ( red . a + Gdx . graphics . getDeltaTime ( ) * <float> ) % <int> ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; spriteBatch . begin ( ) ; logoSprite . draw ( spriteBatch ) ; switch ( renderMode ) { case <int> : font . getData ( ) . setScale ( <int> ) ; renderNormal ( <str> ) ; break ; case <int> : font . getData ( ) . setScale ( <int> ) ; renderCached ( ) ; break ; case <int> : font . getData ( ) . setScale ( red . a + <float> ) ; renderNormal ( <str> ) ; break ; case <int> : font . getData ( ) . setScale ( <int> ) ; renderCachedScaled ( ) ; break ; } spriteBatch . end ( ) ; } private void renderNormal ( String type ) { String text = <str> ; font . setColor ( red ) ; font . draw ( spriteBatch , text , <int> , <int> - <int> , <int> , Align . center , false ) ; font . setColor ( Color . WHITE ) ; font . draw ( spriteBatch , <str> + type + <str> , <int> , <int> - <int> ) ; if ( red . a > <float> ) return ; text = <str> ; font . setColor ( Color . RED ) ; font . draw ( spriteBatch , text , <int> , <int> - <int> ) ; text = <str> ; font . setColor ( Color . BLUE ) ; font . draw ( spriteBatch , text , <int> , <int> - <int> , <int> , Align . right , false ) ; text = <str> ; font . setColor ( Color . WHITE ) ; font . draw ( spriteBatch , text , <int> , <int> - <int> , <int> , text . length ( ) - <int> , <int> , Align . left , false ) ; } private void renderCached ( ) { cache5 . setColors ( red ) ; cache5 . draw ( spriteBatch ) ; cache1 . draw ( spriteBatch ) ; if ( red . a > <float> ) return ; cache2 . draw ( spriteBatch ) ; cache3 . draw ( spriteBatch ) ; cache4 . draw ( spriteBatch ) ; } private void renderCachedScaled ( ) { cacheScaled5 . setColors ( red ) ; cacheScaled5 . draw ( spriteBatch ) ; cacheScaled1 . draw ( spriteBatch ) ; if ( red . a > <float> ) return ; cacheScaled2 . draw ( spriteBatch ) ; cacheScaled3 . draw ( spriteBatch ) ; cacheScaled4 . draw ( spriteBatch ) ; } @Override public void dispose ( ) { spriteBatch . dispose ( ) ; font . dispose ( ) ; texture . dispose ( ) ; } } 
