package org . apache . cassandra . io . sstable . format ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; import java . io . File ; import java . nio . ByteBuffer ; import com . google . common . util . concurrent . Runnables ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . db . rows . SliceableUnfilteredRowIterator ; import org . apache . cassandra . dht . ByteOrderedPartitioner ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . SSTableFormat ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . format . Version ; public class ClientModeSSTableTest { public static final String LEGACY_SSTABLE_PROP = <str> ; public static final String KSNAME = <str> ; public static final String CFNAME = <str> ; public static File LEGACY_SSTABLE_ROOT ; static CFMetaData metadata ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { Config . setClientMode ( true ) ; metadata = CFMetaData . Builder . createDense ( KSNAME , CFNAME , false , false ) . addPartitionKey ( <str> , BytesType . instance ) . addClusteringColumn ( <str> , BytesType . instance ) . addRegularColumn ( <str> , BytesType . instance ) . withPartitioner ( ByteOrderedPartitioner . instance ) . build ( ) ; String scp = System . getProperty ( LEGACY_SSTABLE_PROP ) ; assert scp ! = null ; LEGACY_SSTABLE_ROOT = new File ( scp ) . getAbsoluteFile ( ) ; assert LEGACY_SSTABLE_ROOT . isDirectory ( ) ; } protected Descriptor getDescriptor ( String ver ) { File directory = new File ( LEGACY_SSTABLE_ROOT + File . separator + ver + File . separator + KSNAME ) ; return new Descriptor ( ver , directory , KSNAME , CFNAME , <int> , SSTableFormat . Type . LEGACY ) ; } @Test public void testVersions ( ) throws Throwable { boolean notSkipped = false ; for ( File version : LEGACY_SSTABLE_ROOT . listFiles ( ) ) { if ( ! new File ( LEGACY_SSTABLE_ROOT + File . separator + version . getName ( ) + File . separator + KSNAME ) . isDirectory ( ) ) continue ; if ( Version . validate ( version . getName ( ) ) & & SSTableFormat . Type . LEGACY . info . getVersion ( version . getName ( ) ) . isCompatible ( ) ) { notSkipped = true ; testVersion ( version . getName ( ) ) ; } } assert notSkipped ; } public void testVersion ( String version ) throws Throwable { SSTableReader reader = null ; try { reader = SSTableReader . openNoValidation ( getDescriptor ( version ) , metadata ) ; ByteBuffer key = bytes ( Integer . toString ( <int> ) ) ; try ( SliceableUnfilteredRowIterator iter = reader . iterator ( metadata . decorateKey ( key ) , ColumnFilter . selection ( metadata . partitionColumns ( ) ) , false , false ) ) { assert iter . next ( ) . clustering ( ) . get ( <int> ) . equals ( key ) ; } } catch ( Throwable e ) { System . err . println ( <str> + version ) ; throw e ; } finally { if ( reader ! = null ) { int globalTidyCount = SSTableReader . GlobalTidy . lookup . size ( ) ; reader . selfRef ( ) . release ( ) ; assert reader . selfRef ( ) . globalCount ( ) = = <int> ; ScheduledExecutors . nonPeriodicTasks . submit ( Runnables . doNothing ( ) ) . get ( ) ; assert SSTableReader . GlobalTidy . lookup . size ( ) < globalTidyCount ; } } } } 
