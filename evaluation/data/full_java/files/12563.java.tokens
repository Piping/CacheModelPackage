package org . gradle . api . internal . artifacts . ivyservice . ivyresolve ; import org . gradle . internal . component . model . ComponentArtifactMetaData ; import org . gradle . internal . component . model . ComponentResolveMetaData ; import org . gradle . internal . component . model . ComponentUsage ; import org . gradle . api . internal . component . ArtifactType ; import org . gradle . internal . Transformers ; import org . gradle . internal . component . model . ModuleSource ; import org . gradle . internal . resolve . resolver . ArtifactResolver ; import org . gradle . internal . resolve . result . BuildableArtifactResolveResult ; import org . gradle . internal . resolve . result . BuildableArtifactSetResolveResult ; import java . util . LinkedHashMap ; import java . util . Map ; class RepositoryChainArtifactResolver implements ArtifactResolver { private final Map < String , ModuleComponentRepository > repositories = new LinkedHashMap < String , ModuleComponentRepository > ( ) ; void add ( ModuleComponentRepository repository ) { repositories . put ( repository . getId ( ) , repository ) ; } public void resolveModuleArtifacts ( ComponentResolveMetaData component , ArtifactType artifactType , BuildableArtifactSetResolveResult result ) { ModuleComponentRepository sourceRepository = findSourceRepository ( component . getSource ( ) ) ; ComponentResolveMetaData unpackedComponent = unpackSource ( component ) ; sourceRepository . getLocalAccess ( ) . resolveModuleArtifacts ( unpackedComponent , artifactType , result ) ; if ( ! result . hasResult ( ) ) { sourceRepository . getRemoteAccess ( ) . resolveModuleArtifacts ( unpackedComponent , artifactType , result ) ; } } public void resolveModuleArtifacts ( ComponentResolveMetaData component , ComponentUsage usage , BuildableArtifactSetResolveResult result ) { ModuleComponentRepository sourceRepository = findSourceRepository ( component . getSource ( ) ) ; ComponentResolveMetaData unpackedComponent = unpackSource ( component ) ; sourceRepository . getLocalAccess ( ) . resolveModuleArtifacts ( unpackedComponent , usage , result ) ; if ( ! result . hasResult ( ) ) { sourceRepository . getRemoteAccess ( ) . resolveModuleArtifacts ( unpackedComponent , usage , result ) ; } } public void resolveArtifact ( ComponentArtifactMetaData artifact , ModuleSource source , BuildableArtifactResolveResult result ) { ModuleComponentRepository sourceRepository = findSourceRepository ( source ) ; ModuleSource unpackedSource = unpackSource ( source ) ; sourceRepository . getLocalAccess ( ) . resolveArtifact ( artifact , unpackedSource , result ) ; if ( ! result . hasResult ( ) ) { sourceRepository . getRemoteAccess ( ) . resolveArtifact ( artifact , unpackedSource , result ) ; } } private ModuleComponentRepository findSourceRepository ( ModuleSource originalSource ) { ModuleComponentRepository moduleVersionRepository = repositories . get ( repositorySource ( originalSource ) . getRepositoryId ( ) ) ; if ( moduleVersionRepository = = null ) { throw new IllegalStateException ( <str> ) ; } return moduleVersionRepository ; } private RepositoryChainModuleSource repositorySource ( ModuleSource original ) { return Transformers . cast ( RepositoryChainModuleSource . class ) . transform ( original ) ; } private ModuleSource unpackSource ( ModuleSource original ) { return repositorySource ( original ) . getDelegate ( ) ; } private ComponentResolveMetaData unpackSource ( ComponentResolveMetaData component ) { return component . withSource ( repositorySource ( component . getSource ( ) ) . getDelegate ( ) ) ; } } 
