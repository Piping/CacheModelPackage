package org . elasticsearch . search . aggregations . pipeline ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . index . mapper . core . DateFieldMapper ; import org . elasticsearch . search . aggregations . bucket . histogram . DateHistogramInterval ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram . Bucket ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram ; import org . elasticsearch . search . aggregations . metrics . sum . Sum ; import org . elasticsearch . search . aggregations . pipeline . derivative . Derivative ; import org . elasticsearch . search . aggregations . support . AggregationPath ; import org . elasticsearch . test . ESIntegTestCase ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import org . joda . time . format . DateTimeFormat ; import org . junit . After ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . dateHistogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . sum ; import static org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilders . derivative ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . core . IsNull . notNullValue ; import static org . hamcrest . core . IsNull . nullValue ; @ESIntegTestCase.SuiteScopeTestCase public class DateDerivativeIT extends ESIntegTestCase { private DateTime date ( int month , int day ) { return new DateTime ( <int> , month , day , <int> , <int> , DateTimeZone . UTC ) ; } private DateTime date ( String date ) { return DateFieldMapper . Defaults . DATE_TIME_FORMATTER . parser ( ) . parseDateTime ( date ) ; } private static String format ( DateTime date , String pattern ) { return DateTimeFormat . forPattern ( pattern ) . print ( date ) ; } private IndexRequestBuilder indexDoc ( String idx , DateTime date , int value ) throws Exception { return client ( ) . prepareIndex ( idx , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , date ) . field ( <str> , value ) . startArray ( <str> ) . value ( date ) . value ( date . plusMonths ( <int> ) . plusDays ( <int> ) ) . endArray ( ) . endObject ( ) ) ; } private IndexRequestBuilder indexDoc ( int month , int day , int value ) throws Exception { return client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , value ) . field ( <str> , date ( month , day ) ) . startArray ( <str> ) . value ( date ( month , day ) ) . value ( date ( month + <int> , day + <int> ) ) . endArray ( ) . endObject ( ) ) ; } @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , i * <int> ) . endObject ( ) ) ) ; } builders . addAll ( Arrays . asList ( indexDoc ( <int> , <int> , <int> ) , indexDoc ( <int> , <int> , <int> ) , indexDoc ( <int> , <int> , <int> ) , indexDoc ( <int> , <int> , <int> ) , indexDoc ( <int> , <int> , <int> ) , indexDoc ( <int> , <int> , <int> ) ) ) ; indexRandom ( true , builders ) ; ensureSearchable ( ) ; } @After public void afterEachTest ( ) throws IOException { internalCluster ( ) . wipeIndices ( <str> ) ; } public void testSingleValuedField ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( dateHistogram ( <str> ) . field ( <str> ) . interval ( DateHistogramInterval . MONTH ) . minDocCount ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; DateTime key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; Histogram . Bucket bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; SimpleValue docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , nullValue ( ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( <float> ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( <float> ) ) ; } public void testSingleValuedFieldNormalised ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( dateHistogram ( <str> ) . field ( <str> ) . interval ( DateHistogramInterval . MONTH ) . minDocCount ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) . unit ( DateHistogramInterval . DAY ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; DateTime key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; Histogram . Bucket bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Derivative docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , nullValue ( ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , closeTo ( <float> , <float> ) ) ; assertThat ( docCountDeriv . normalizedValue ( ) , closeTo ( <float> / <int> d , <float> ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , closeTo ( <float> , <float> ) ) ; assertThat ( docCountDeriv . normalizedValue ( ) , closeTo ( <float> / <int> d , <float> ) ) ; } public void testSingleValuedFieldWithSubAggregation ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( dateHistogram ( <str> ) . field ( <str> ) . interval ( DateHistogramInterval . MONTH ) . minDocCount ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) . subAggregation ( sum ( <str> ) . field ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; Object [ ] propertiesKeys = ( Object [ ] ) histo . getProperty ( <str> ) ; Object [ ] propertiesDocCounts = ( Object [ ] ) histo . getProperty ( <str> ) ; Object [ ] propertiesCounts = ( Object [ ] ) histo . getProperty ( <str> ) ; DateTime key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; Histogram . Bucket bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; assertThat ( sum . getValue ( ) , equalTo ( <float> ) ) ; SimpleValue deriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , nullValue ( ) ) ; assertThat ( ( DateTime ) propertiesKeys [ <int> ] , equalTo ( key ) ) ; assertThat ( ( long ) propertiesDocCounts [ <int> ] , equalTo ( <int> ) ) ; assertThat ( ( double ) propertiesCounts [ <int> ] , equalTo ( <float> ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; assertThat ( sum . getValue ( ) , equalTo ( <float> ) ) ; deriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . value ( ) , equalTo ( <float> ) ) ; assertThat ( ( double ) bucket . getProperty ( <str> , AggregationPath . parse ( <str> ) . getPathElementsAsStringList ( ) ) , equalTo ( <float> ) ) ; assertThat ( ( DateTime ) propertiesKeys [ <int> ] , equalTo ( key ) ) ; assertThat ( ( long ) propertiesDocCounts [ <int> ] , equalTo ( <int> ) ) ; assertThat ( ( double ) propertiesCounts [ <int> ] , equalTo ( <float> ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; assertThat ( sum . getValue ( ) , equalTo ( <float> ) ) ; deriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . value ( ) , equalTo ( <float> ) ) ; assertThat ( ( double ) bucket . getProperty ( <str> , AggregationPath . parse ( <str> ) . getPathElementsAsStringList ( ) ) , equalTo ( <float> ) ) ; assertThat ( ( DateTime ) propertiesKeys [ <int> ] , equalTo ( key ) ) ; assertThat ( ( long ) propertiesDocCounts [ <int> ] , equalTo ( <int> ) ) ; assertThat ( ( double ) propertiesCounts [ <int> ] , equalTo ( <float> ) ) ; } public void testMultiValuedField ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( dateHistogram ( <str> ) . field ( <str> ) . interval ( DateHistogramInterval . MONTH ) . minDocCount ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; DateTime key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; Histogram . Bucket bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( true ) ) ; SimpleValue docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , nullValue ( ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( <float> ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( <float> ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( - <float> ) ) ; } public void testUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( dateHistogram ( <str> ) . field ( <str> ) . interval ( DateHistogramInterval . MONTH ) . minDocCount ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; assertThat ( deriv . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testPartiallyUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . addAggregation ( dateHistogram ( <str> ) . field ( <str> ) . interval ( DateHistogramInterval . MONTH ) . minDocCount ( <int> ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram deriv = response . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = deriv . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; DateTime key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; Histogram . Bucket bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( true ) ) ; SimpleValue docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , nullValue ( ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( <float> ) ) ; key = new DateTime ( <int> , <int> , <int> , <int> , <int> , DateTimeZone . UTC ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( DateTime ) bucket . getKey ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; docCountDeriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( docCountDeriv , notNullValue ( ) ) ; assertThat ( docCountDeriv . value ( ) , equalTo ( <float> ) ) ; } } 
