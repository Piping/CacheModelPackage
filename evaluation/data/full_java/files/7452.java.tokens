package org . elasticsearch . search . aggregations . support . format ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import java . io . IOException ; public class ValueFormatterStreams { public static ValueFormatter read ( StreamInput in ) throws IOException { byte id = in . readByte ( ) ; ValueFormatter formatter = null ; switch ( id ) { case ValueFormatter . Raw . ID : return ValueFormatter . RAW ; case ValueFormatter . IPv4Formatter . ID : return ValueFormatter . IPv4 ; case ValueFormatter . DateTime . ID : formatter = new ValueFormatter . DateTime ( ) ; break ; case ValueFormatter . Number . Pattern . ID : formatter = new ValueFormatter . Number . Pattern ( ) ; break ; case ValueFormatter . GeoHash . ID : formatter = ValueFormatter . GEOHASH ; break ; case ValueFormatter . BooleanFormatter . ID : formatter = ValueFormatter . BOOLEAN ; break ; default : throw new IllegalArgumentException ( <str> + id + <str> ) ; } formatter . readFrom ( in ) ; return formatter ; } public static ValueFormatter readOptional ( StreamInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { return null ; } return read ( in ) ; } public static void write ( ValueFormatter formatter , StreamOutput out ) throws IOException { out . writeByte ( formatter . id ( ) ) ; formatter . writeTo ( out ) ; } public static void writeOptional ( ValueFormatter formatter , StreamOutput out ) throws IOException { out . writeBoolean ( formatter ! = null ) ; if ( formatter ! = null ) { write ( formatter , out ) ; } } } 
