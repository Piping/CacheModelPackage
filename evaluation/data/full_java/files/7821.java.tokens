package org . elasticsearch . cluster . health ; import com . carrotsearch . randomizedtesting . RandomizedContext ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . index . shard . ShardId ; class RoutingTableGenerator { private static int node_id = <int> ; private ShardRouting genShardRouting ( String index , int shardId , boolean primary ) { ShardRoutingState state ; int stateRandomizer = RandomizedContext . current ( ) . getRandom ( ) . nextInt ( <int> ) ; if ( stateRandomizer > <int> ) { state = ShardRoutingState . STARTED ; } else if ( stateRandomizer > <int> ) { state = ShardRoutingState . RELOCATING ; } else { state = ShardRoutingState . INITIALIZING ; } switch ( state ) { case STARTED : return TestShardRouting . newShardRouting ( index , shardId , <str> + Integer . toString ( node_id + + ) , null , null , primary , ShardRoutingState . STARTED , <int> ) ; case INITIALIZING : return TestShardRouting . newShardRouting ( index , shardId , <str> + Integer . toString ( node_id + + ) , null , null , primary , ShardRoutingState . INITIALIZING , <int> ) ; case RELOCATING : return TestShardRouting . newShardRouting ( index , shardId , <str> + Integer . toString ( node_id + + ) , <str> + Integer . toString ( node_id + + ) , null , primary , ShardRoutingState . RELOCATING , <int> ) ; default : throw new ElasticsearchException ( <str> + state . name ( ) ) ; } } public IndexShardRoutingTable genShardRoutingTable ( String index , int shardId , int replicas , ShardCounter counter ) { IndexShardRoutingTable . Builder builder = new IndexShardRoutingTable . Builder ( new ShardId ( index , shardId ) ) ; ShardRouting shardRouting = genShardRouting ( index , shardId , true ) ; counter . update ( shardRouting ) ; builder . addShard ( shardRouting ) ; for ( ; replicas > <int> ; replicas - - ) { shardRouting = genShardRouting ( index , shardId , false ) ; counter . update ( shardRouting ) ; builder . addShard ( shardRouting ) ; } return builder . build ( ) ; } public IndexRoutingTable genIndexRoutingTable ( IndexMetaData indexMetaData , ShardCounter counter ) { IndexRoutingTable . Builder builder = IndexRoutingTable . builder ( indexMetaData . getIndex ( ) ) ; for ( int shard = <int> ; shard < indexMetaData . getNumberOfShards ( ) ; shard + + ) { builder . addIndexShard ( genShardRoutingTable ( indexMetaData . getIndex ( ) , shard , indexMetaData . getNumberOfReplicas ( ) , counter ) ) ; } return builder . build ( ) ; } static class ShardCounter { public int active ; public int relocating ; public int initializing ; public int unassigned ; public int primaryActive ; public int primaryInactive ; public ClusterHealthStatus status ( ) { if ( primaryInactive > <int> ) { return ClusterHealthStatus . RED ; } if ( unassigned > <int> | | initializing > <int> ) { return ClusterHealthStatus . YELLOW ; } return ClusterHealthStatus . GREEN ; } public void update ( ShardRouting shardRouting ) { if ( shardRouting . active ( ) ) { active + + ; if ( shardRouting . primary ( ) ) { primaryActive + + ; } if ( shardRouting . relocating ( ) ) { relocating + + ; } return ; } if ( shardRouting . primary ( ) ) { primaryInactive + + ; } if ( shardRouting . initializing ( ) ) { initializing + + ; } else { unassigned + + ; } } } } 
