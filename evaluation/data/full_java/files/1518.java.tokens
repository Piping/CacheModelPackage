package org . apache . cassandra . db . rows ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . function . Function ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . stream . Collectors ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterators ; import org . junit . Assert ; import org . junit . Test ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . Slice . Bound ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . db . marshal . Int32Type ; import org . apache . cassandra . db . rows . Unfiltered . Kind ; import org . apache . cassandra . utils . FBUtilities ; public class UnfilteredRowIteratorsMergeTest { static DecoratedKey partitionKey = Util . dk ( <str> ) ; static DeletionTime partitionLevelDeletion = DeletionTime . LIVE ; static CFMetaData metadata = CFMetaData . Builder . create ( <str> , <str> ) . addPartitionKey ( <str> , AsciiType . instance ) . addClusteringColumn ( <str> , Int32Type . instance ) . addRegularColumn ( <str> , Int32Type . instance ) . build ( ) ; static Comparator < Clusterable > comparator = new ClusteringComparator ( Int32Type . instance ) ; static int nowInSec = FBUtilities . nowInSeconds ( ) ; static final int RANGE = <int> ; static final int DEL_RANGE = <int> ; static final int ITERATORS = <int> ; static final int ITEMS = <int> ; boolean reversed ; public UnfilteredRowIteratorsMergeTest ( ) { } @Test public void testTombstoneMerge ( ) { testTombstoneMerge ( false , false ) ; } @Test public void testTombstoneMergeReversed ( ) { testTombstoneMerge ( true , false ) ; } @Test public void testTombstoneMergeIterative ( ) { testTombstoneMerge ( false , true ) ; } @Test public void testTombstoneMergeReversedIterative ( ) { testTombstoneMerge ( true , true ) ; } @Test public void testDuplicateRangeCase ( ) { testForInput ( <str> , <str> , <str> ) ; } @SuppressWarnings ( <str> ) public void testTombstoneMerge ( boolean reversed , boolean iterations ) { for ( int seed = <int> ; seed < = <int> ; + + seed ) { this . reversed = reversed ; if ( ITEMS < = <int> ) System . out . println ( <str> + seed ) ; Random r = new Random ( seed ) ; List < Function < Integer , Integer > > timeGenerators = ImmutableList . of ( x - > - <int> , x - > DEL_RANGE , x - > r . nextInt ( DEL_RANGE ) ) ; List < List < Unfiltered > > sources = new ArrayList < > ( ITERATORS ) ; if ( ITEMS < = <int> ) System . out . println ( <str> ) ; for ( int i = <int> ; i < ITERATORS ; + + i ) sources . add ( generateSource ( r , timeGenerators . get ( r . nextInt ( timeGenerators . size ( ) ) ) ) ) ; List < Unfiltered > merged = merge ( sources , iterations ) ; if ( ITEMS < = <int> ) System . out . println ( <str> ) ; if ( ITEMS < = <int> ) dumpList ( merged ) ; verifyEquivalent ( sources , merged ) ; verifyValid ( merged ) ; if ( reversed ) { Collections . reverse ( merged ) ; this . reversed = false ; verifyValid ( merged ) ; } } } private List < Unfiltered > merge ( List < List < Unfiltered > > sources , boolean iterations ) { List < UnfilteredRowIterator > us = sources . stream ( ) . map ( l - > new Source ( l . iterator ( ) ) ) . collect ( Collectors . toList ( ) ) ; List < Unfiltered > merged = new ArrayList < > ( ) ; Iterators . addAll ( merged , mergeIterators ( us , iterations ) ) ; return merged ; } public UnfilteredRowIterator mergeIterators ( List < UnfilteredRowIterator > us , boolean iterations ) { int now = FBUtilities . nowInSeconds ( ) ; if ( iterations ) { UnfilteredRowIterator mi = us . get ( <int> ) ; int i ; for ( i = <int> ; i + <int> < = ITERATORS ; i + = <int> ) mi = UnfilteredRowIterators . merge ( ImmutableList . of ( mi , us . get ( i ) , us . get ( i + <int> ) ) , now ) ; if ( i + <int> < = ITERATORS ) mi = UnfilteredRowIterators . merge ( ImmutableList . of ( mi , us . get ( i ) ) , now ) ; return mi ; } else { return UnfilteredRowIterators . merge ( us , now ) ; } } @SuppressWarnings ( <str> ) private List < Unfiltered > generateSource ( Random r , Function < Integer , Integer > timeGenerator ) { int [ ] positions = new int [ ITEMS + <int> ] ; for ( int i = <int> ; i < ITEMS ; + + i ) positions [ i ] = r . nextInt ( RANGE ) ; positions [ ITEMS ] = RANGE ; Arrays . sort ( positions ) ; List < Unfiltered > content = new ArrayList < > ( ITEMS ) ; int prev = - <int> ; for ( int i = <int> ; i < ITEMS ; + + i ) { int pos = positions [ i ] ; int sz = positions [ i + <int> ] - pos ; if ( sz = = <int> & & pos = = prev ) continue ; if ( r . nextBoolean ( ) | | pos = = prev ) { int span ; boolean includesStart ; boolean includesEnd ; if ( pos > prev ) { span = r . nextInt ( sz + <int> ) ; includesStart = span > <int> ? r . nextBoolean ( ) : true ; includesEnd = span > <int> ? r . nextBoolean ( ) : true ; } else { span = <int> + r . nextInt ( sz ) ; includesStart = false ; includesEnd = r . nextBoolean ( ) ; } int deltime = r . nextInt ( DEL_RANGE ) ; DeletionTime dt = new DeletionTime ( deltime , deltime ) ; content . add ( new RangeTombstoneBoundMarker ( boundFor ( pos , true , includesStart ) , dt ) ) ; content . add ( new RangeTombstoneBoundMarker ( boundFor ( pos + span , false , includesEnd ) , dt ) ) ; prev = pos + span - ( includesEnd ? <int> : <int> ) ; } else { content . add ( emptyRowAt ( pos , timeGenerator ) ) ; prev = pos ; } } attachBoundaries ( content ) ; if ( reversed ) { Collections . reverse ( content ) ; } verifyValid ( content ) ; if ( ITEMS < = <int> ) dumpList ( content ) ; return content ; } static void attachBoundaries ( List < Unfiltered > content ) { int di = <int> ; RangeTombstoneMarker prev = null ; for ( int si = <int> ; si < content . size ( ) ; + + si ) { Unfiltered currUnfiltered = content . get ( si ) ; RangeTombstoneMarker curr = currUnfiltered . kind ( ) = = Kind . RANGE_TOMBSTONE_MARKER ? ( RangeTombstoneMarker ) currUnfiltered : null ; if ( prev ! = null & & curr ! = null & & prev . isClose ( false ) & & curr . isOpen ( false ) & & prev . clustering ( ) . invert ( ) . equals ( curr . clustering ( ) ) ) { RangeTombstone . Bound b = prev . clustering ( ) ; b = b . withNewKind ( b . isInclusive ( ) ? RangeTombstone . Bound . Kind . INCL_END_EXCL_START_BOUNDARY : RangeTombstone . Bound . Kind . EXCL_END_INCL_START_BOUNDARY ) ; prev = new RangeTombstoneBoundaryMarker ( b , prev . closeDeletionTime ( false ) , curr . openDeletionTime ( false ) ) ; currUnfiltered = prev ; - - di ; } content . set ( di + + , currUnfiltered ) ; prev = curr ; } for ( int pos = content . size ( ) - <int> ; pos > = di ; - - pos ) content . remove ( pos ) ; } void verifyValid ( List < Unfiltered > list ) { int reversedAsMultiplier = reversed ? - <int> : <int> ; try { RangeTombstoneMarker prev = null ; Unfiltered prevUnfiltered = null ; for ( Unfiltered unfiltered : list ) { Assert . assertTrue ( <str> + str ( prevUnfiltered ) + <str> + str ( unfiltered ) , prevUnfiltered = = null | | comparator . compare ( prevUnfiltered , unfiltered ) * reversedAsMultiplier < <int> ) ; prevUnfiltered = unfiltered ; if ( unfiltered . kind ( ) = = Kind . RANGE_TOMBSTONE_MARKER ) { RangeTombstoneMarker curr = ( RangeTombstoneMarker ) unfiltered ; if ( prev ! = null ) { if ( curr . isClose ( reversed ) ) { Assert . assertTrue ( str ( unfiltered ) + <str> + str ( prev ) , prev . isOpen ( reversed ) ) ; Assert . assertEquals ( <str> + str ( prev ) + <str> + str ( unfiltered ) , prev . openDeletionTime ( reversed ) , curr . closeDeletionTime ( reversed ) ) ; } else Assert . assertFalse ( str ( curr ) + <str> + str ( prev ) , prev . isOpen ( reversed ) ) ; } prev = curr ; } } Assert . assertFalse ( <str> + str ( prev ) , prev ! = null & & prev . isOpen ( reversed ) ) ; } catch ( AssertionError e ) { System . out . println ( e ) ; dumpList ( list ) ; throw e ; } } void verifyEquivalent ( List < List < Unfiltered > > sources , List < Unfiltered > merged ) { try { for ( int i = <int> ; i < RANGE ; + + i ) { Clusterable c = clusteringFor ( i ) ; DeletionTime dt = DeletionTime . LIVE ; for ( List < Unfiltered > source : sources ) { dt = deletionFor ( c , source , dt ) ; } Assert . assertEquals ( <str> + str ( c ) , dt , deletionFor ( c , merged ) ) ; if ( dt = = DeletionTime . LIVE ) { Optional < Unfiltered > sourceOpt = sources . stream ( ) . map ( source - > rowFor ( c , source ) ) . filter ( x - > x ! = null ) . findAny ( ) ; Unfiltered mergedRow = rowFor ( c , merged ) ; Assert . assertEquals ( <str> + str ( c ) , str ( sourceOpt . orElse ( null ) ) , str ( mergedRow ) ) ; } } } catch ( AssertionError e ) { System . out . println ( e ) ; for ( List < Unfiltered > list : sources ) dumpList ( list ) ; System . out . println ( <str> ) ; dumpList ( merged ) ; throw e ; } } private Unfiltered rowFor ( Clusterable pointer , List < Unfiltered > list ) { int index = Collections . binarySearch ( list , pointer , reversed ? comparator . reversed ( ) : comparator ) ; return index > = <int> ? list . get ( index ) : null ; } DeletionTime deletionFor ( Clusterable pointer , List < Unfiltered > list ) { return deletionFor ( pointer , list , DeletionTime . LIVE ) ; } DeletionTime deletionFor ( Clusterable pointer , List < Unfiltered > list , DeletionTime def ) { if ( list . isEmpty ( ) ) return def ; int index = Collections . binarySearch ( list , pointer , reversed ? comparator . reversed ( ) : comparator ) ; if ( index < <int> ) index = - <int> - index ; else { Row row = ( Row ) list . get ( index ) ; if ( row . deletion ( ) . supersedes ( def ) ) def = row . deletion ( ) . time ( ) ; } if ( index > = list . size ( ) ) return def ; while ( - - index > = <int> ) { Unfiltered unfiltered = list . get ( index ) ; if ( unfiltered . kind ( ) = = Kind . ROW ) continue ; RangeTombstoneMarker lower = ( RangeTombstoneMarker ) unfiltered ; if ( ! lower . isOpen ( reversed ) ) return def ; return lower . openDeletionTime ( reversed ) . supersedes ( def ) ? lower . openDeletionTime ( reversed ) : def ; } return def ; } private static Bound boundFor ( int pos , boolean start , boolean inclusive ) { return Bound . create ( Bound . boundKind ( start , inclusive ) , new ByteBuffer [ ] { Int32Type . instance . decompose ( pos ) } ) ; } private static Clustering clusteringFor ( int i ) { return new Clustering ( Int32Type . instance . decompose ( i ) ) ; } static Row emptyRowAt ( int pos , Function < Integer , Integer > timeGenerator ) { final Clustering clustering = clusteringFor ( pos ) ; final LivenessInfo live = LivenessInfo . create ( metadata , timeGenerator . apply ( pos ) , nowInSec ) ; return BTreeRow . noCellLiveRow ( clustering , live ) ; } private void dumpList ( List < Unfiltered > list ) { for ( Unfiltered u : list ) System . out . print ( str ( u ) + <str> ) ; System . out . println ( ) ; } private String str ( Clusterable curr ) { if ( curr = = null ) return <str> ; String val = Int32Type . instance . getString ( curr . clustering ( ) . get ( <int> ) ) ; if ( curr instanceof RangeTombstoneMarker ) { RangeTombstoneMarker marker = ( RangeTombstoneMarker ) curr ; if ( marker . isClose ( reversed ) ) val = <str> + marker . closeDeletionTime ( reversed ) . markedForDeleteAt ( ) + <str> + ( marker . closeIsInclusive ( reversed ) ? <str> : <str> ) + val ; if ( marker . isOpen ( reversed ) ) val = val + ( marker . openIsInclusive ( reversed ) ? <str> : <str> ) + <str> + marker . openDeletionTime ( reversed ) . markedForDeleteAt ( ) + <str> ; } return val ; } class Source extends AbstractUnfilteredRowIterator implements UnfilteredRowIterator { Iterator < Unfiltered > content ; protected Source ( Iterator < Unfiltered > content ) { super ( UnfilteredRowIteratorsMergeTest . metadata , UnfilteredRowIteratorsMergeTest . partitionKey , UnfilteredRowIteratorsMergeTest . partitionLevelDeletion , UnfilteredRowIteratorsMergeTest . metadata . partitionColumns ( ) , null , reversed , EncodingStats . NO_STATS ) ; this . content = content ; } @Override protected Unfiltered computeNext ( ) { return content . hasNext ( ) ? content . next ( ) : endOfData ( ) ; } } public void testForInput ( String . . . inputs ) { List < List < Unfiltered > > sources = new ArrayList < > ( ) ; for ( String input : inputs ) { List < Unfiltered > source = parse ( input ) ; attachBoundaries ( source ) ; dumpList ( source ) ; verifyValid ( source ) ; sources . add ( source ) ; } List < Unfiltered > merged = merge ( sources , false ) ; System . out . println ( <str> ) ; dumpList ( merged ) ; verifyEquivalent ( sources , merged ) ; verifyValid ( merged ) ; System . out . println ( ) ; } List < Unfiltered > parse ( String input ) { String [ ] split = input . split ( <str> ) ; Pattern open = Pattern . compile ( <str> ) ; Pattern close = Pattern . compile ( <str> ) ; Pattern row = Pattern . compile ( <str> ) ; List < Unfiltered > out = new ArrayList < > ( split . length ) ; for ( String s : split ) { Matcher m = open . matcher ( s ) ; if ( m . matches ( ) ) { out . add ( openMarker ( Integer . parseInt ( m . group ( <int> ) ) , Integer . parseInt ( m . group ( <int> ) ) , m . group ( <int> ) ! = null ) ) ; continue ; } m = close . matcher ( s ) ; if ( m . matches ( ) ) { out . add ( closeMarker ( Integer . parseInt ( m . group ( <int> ) ) , Integer . parseInt ( m . group ( <int> ) ) , m . group ( <int> ) ! = null ) ) ; continue ; } m = row . matcher ( s ) ; if ( m . matches ( ) ) { int live = m . group ( <int> ) ! = null ? Integer . parseInt ( m . group ( <int> ) ) : DEL_RANGE ; out . add ( emptyRowAt ( Integer . parseInt ( m . group ( <int> ) ) , x - > live ) ) ; continue ; } Assert . fail ( <str> + s ) ; } return out ; } private RangeTombstoneMarker openMarker ( int pos , int delTime , boolean inclusive ) { return marker ( pos , delTime , true , inclusive ) ; } private RangeTombstoneMarker closeMarker ( int pos , int delTime , boolean inclusive ) { return marker ( pos , delTime , false , inclusive ) ; } private RangeTombstoneMarker marker ( int pos , int delTime , boolean isStart , boolean inclusive ) { return new RangeTombstoneBoundMarker ( Bound . create ( Bound . boundKind ( isStart , inclusive ) , new ByteBuffer [ ] { clusteringFor ( pos ) . get ( <int> ) } ) , new DeletionTime ( delTime , delTime ) ) ; } } 
