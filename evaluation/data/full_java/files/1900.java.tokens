package clojure . lang ; import java . util . * ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . Callable ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . CountDownLatch ; @SuppressWarnings ( { <str> } ) public class LockingTransaction { public static final int RETRY_LIMIT = <int> ; public static final int LOCK_WAIT_MSECS = <int> ; public static final long BARGE_WAIT_NANOS = <int> * <int> ; static final int RUNNING = <int> ; static final int COMMITTING = <int> ; static final int RETRY = <int> ; static final int KILLED = <int> ; static final int COMMITTED = <int> ; final static ThreadLocal < LockingTransaction > transaction = new ThreadLocal < LockingTransaction > ( ) ; static class RetryEx extends Error { } static class AbortException extends Exception { } public static class Info { final AtomicInteger status ; final long startPoint ; final CountDownLatch latch ; public Info ( int status , long startPoint ) { this . status = new AtomicInteger ( status ) ; this . startPoint = startPoint ; this . latch = new CountDownLatch ( <int> ) ; } public boolean running ( ) { int s = status . get ( ) ; return s = = RUNNING | | s = = COMMITTING ; } } static class CFn { final IFn fn ; final ISeq args ; public CFn ( IFn fn , ISeq args ) { this . fn = fn ; this . args = args ; } } final private static AtomicLong lastPoint = new AtomicLong ( ) ; void getReadPoint ( ) { readPoint = lastPoint . incrementAndGet ( ) ; } long getCommitPoint ( ) { return lastPoint . incrementAndGet ( ) ; } void stop ( int status ) { if ( info ! = null ) { synchronized ( info ) { info . status . set ( status ) ; info . latch . countDown ( ) ; } info = null ; vals . clear ( ) ; sets . clear ( ) ; commutes . clear ( ) ; } } Info info ; long readPoint ; long startPoint ; long startTime ; final RetryEx retryex = new RetryEx ( ) ; final ArrayList < Agent . Action > actions = new ArrayList < Agent . Action > ( ) ; final HashMap < Ref , Object > vals = new HashMap < Ref , Object > ( ) ; final HashSet < Ref > sets = new HashSet < Ref > ( ) ; final TreeMap < Ref , ArrayList < CFn > > commutes = new TreeMap < Ref , ArrayList < CFn > > ( ) ; final HashSet < Ref > ensures = new HashSet < Ref > ( ) ; void tryWriteLock ( Ref ref ) { try { if ( ! ref . lock . writeLock ( ) . tryLock ( LOCK_WAIT_MSECS , TimeUnit . MILLISECONDS ) ) throw retryex ; } catch ( InterruptedException e ) { throw retryex ; } } Object lock ( Ref ref ) { releaseIfEnsured ( ref ) ; boolean unlocked = true ; try { tryWriteLock ( ref ) ; unlocked = false ; if ( ref . tvals ! = null & & ref . tvals . point > readPoint ) throw retryex ; Info refinfo = ref . tinfo ; if ( refinfo ! = null & & refinfo ! = info & & refinfo . running ( ) ) { if ( ! barge ( refinfo ) ) { ref . lock . writeLock ( ) . unlock ( ) ; unlocked = true ; return blockAndBail ( refinfo ) ; } } ref . tinfo = info ; return ref . tvals = = null ? null : ref . tvals . val ; } finally { if ( ! unlocked ) ref . lock . writeLock ( ) . unlock ( ) ; } } private Object blockAndBail ( Info refinfo ) { stop ( RETRY ) ; try { refinfo . latch . await ( LOCK_WAIT_MSECS , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { } throw retryex ; } private void releaseIfEnsured ( Ref ref ) { if ( ensures . contains ( ref ) ) { ensures . remove ( ref ) ; ref . lock . readLock ( ) . unlock ( ) ; } } void abort ( ) throws AbortException { stop ( KILLED ) ; throw new AbortException ( ) ; } private boolean bargeTimeElapsed ( ) { return System . nanoTime ( ) - startTime > BARGE_WAIT_NANOS ; } private boolean barge ( Info refinfo ) { boolean barged = false ; if ( bargeTimeElapsed ( ) & & startPoint < refinfo . startPoint ) { barged = refinfo . status . compareAndSet ( RUNNING , KILLED ) ; if ( barged ) refinfo . latch . countDown ( ) ; } return barged ; } static LockingTransaction getEx ( ) { LockingTransaction t = transaction . get ( ) ; if ( t = = null | | t . info = = null ) throw new IllegalStateException ( <str> ) ; return t ; } static public boolean isRunning ( ) { return getRunning ( ) ! = null ; } static LockingTransaction getRunning ( ) { LockingTransaction t = transaction . get ( ) ; if ( t = = null | | t . info = = null ) return null ; return t ; } static public Object runInTransaction ( Callable fn ) throws Exception { LockingTransaction t = transaction . get ( ) ; Object ret ; if ( t = = null ) { transaction . set ( t = new LockingTransaction ( ) ) ; try { ret = t . run ( fn ) ; } finally { transaction . remove ( ) ; } } else { if ( t . info ! = null ) { ret = fn . call ( ) ; } else { ret = t . run ( fn ) ; } } return ret ; } static class Notify { final public Ref ref ; final public Object oldval ; final public Object newval ; Notify ( Ref ref , Object oldval , Object newval ) { this . ref = ref ; this . oldval = oldval ; this . newval = newval ; } } Object run ( Callable fn ) throws Exception { boolean done = false ; Object ret = null ; ArrayList < Ref > locked = new ArrayList < Ref > ( ) ; ArrayList < Notify > notify = new ArrayList < Notify > ( ) ; for ( int i = <int> ; ! done & & i < RETRY_LIMIT ; i + + ) { try { getReadPoint ( ) ; if ( i = = <int> ) { startPoint = readPoint ; startTime = System . nanoTime ( ) ; } info = new Info ( RUNNING , startPoint ) ; ret = fn . call ( ) ; if ( info . status . compareAndSet ( RUNNING , COMMITTING ) ) { for ( Map . Entry < Ref , ArrayList < CFn > > e : commutes . entrySet ( ) ) { Ref ref = e . getKey ( ) ; if ( sets . contains ( ref ) ) continue ; boolean wasEnsured = ensures . contains ( ref ) ; releaseIfEnsured ( ref ) ; tryWriteLock ( ref ) ; locked . add ( ref ) ; if ( wasEnsured & & ref . tvals ! = null & & ref . tvals . point > readPoint ) throw retryex ; Info refinfo = ref . tinfo ; if ( refinfo ! = null & & refinfo ! = info & & refinfo . running ( ) ) { if ( ! barge ( refinfo ) ) throw retryex ; } Object val = ref . tvals = = null ? null : ref . tvals . val ; vals . put ( ref , val ) ; for ( CFn f : e . getValue ( ) ) { vals . put ( ref , f . fn . applyTo ( RT . cons ( vals . get ( ref ) , f . args ) ) ) ; } } for ( Ref ref : sets ) { tryWriteLock ( ref ) ; locked . add ( ref ) ; } for ( Map . Entry < Ref , Object > e : vals . entrySet ( ) ) { Ref ref = e . getKey ( ) ; ref . validate ( ref . getValidator ( ) , e . getValue ( ) ) ; } long commitPoint = getCommitPoint ( ) ; for ( Map . Entry < Ref , Object > e : vals . entrySet ( ) ) { Ref ref = e . getKey ( ) ; Object oldval = ref . tvals = = null ? null : ref . tvals . val ; Object newval = e . getValue ( ) ; int hcount = ref . histCount ( ) ; if ( ref . tvals = = null ) { ref . tvals = new Ref . TVal ( newval , commitPoint ) ; } else if ( ( ref . faults . get ( ) > <int> & & hcount < ref . maxHistory ) | | hcount < ref . minHistory ) { ref . tvals = new Ref . TVal ( newval , commitPoint , ref . tvals ) ; ref . faults . set ( <int> ) ; } else { ref . tvals = ref . tvals . next ; ref . tvals . val = newval ; ref . tvals . point = commitPoint ; } if ( ref . getWatches ( ) . count ( ) > <int> ) notify . add ( new Notify ( ref , oldval , newval ) ) ; } done = true ; info . status . set ( COMMITTED ) ; } } catch ( RetryEx retry ) { } finally { for ( int k = locked . size ( ) - <int> ; k > = <int> ; - - k ) { locked . get ( k ) . lock . writeLock ( ) . unlock ( ) ; } locked . clear ( ) ; for ( Ref r : ensures ) { r . lock . readLock ( ) . unlock ( ) ; } ensures . clear ( ) ; stop ( done ? COMMITTED : RETRY ) ; try { if ( done ) { for ( Notify n : notify ) { n . ref . notifyWatches ( n . oldval , n . newval ) ; } for ( Agent . Action action : actions ) { Agent . dispatchAction ( action ) ; } } } finally { notify . clear ( ) ; actions . clear ( ) ; } } } if ( ! done ) throw Util . runtimeException ( <str> ) ; return ret ; } public void enqueue ( Agent . Action action ) { actions . add ( action ) ; } Object doGet ( Ref ref ) { if ( ! info . running ( ) ) throw retryex ; if ( vals . containsKey ( ref ) ) return vals . get ( ref ) ; try { ref . lock . readLock ( ) . lock ( ) ; if ( ref . tvals = = null ) throw new IllegalStateException ( ref . toString ( ) + <str> ) ; Ref . TVal ver = ref . tvals ; do { if ( ver . point < = readPoint ) return ver . val ; } while ( ( ver = ver . prior ) ! = ref . tvals ) ; } finally { ref . lock . readLock ( ) . unlock ( ) ; } ref . faults . incrementAndGet ( ) ; throw retryex ; } Object doSet ( Ref ref , Object val ) { if ( ! info . running ( ) ) throw retryex ; if ( commutes . containsKey ( ref ) ) throw new IllegalStateException ( <str> ) ; if ( ! sets . contains ( ref ) ) { sets . add ( ref ) ; lock ( ref ) ; } vals . put ( ref , val ) ; return val ; } void doEnsure ( Ref ref ) { if ( ! info . running ( ) ) throw retryex ; if ( ensures . contains ( ref ) ) return ; ref . lock . readLock ( ) . lock ( ) ; if ( ref . tvals ! = null & & ref . tvals . point > readPoint ) { ref . lock . readLock ( ) . unlock ( ) ; throw retryex ; } Info refinfo = ref . tinfo ; if ( refinfo ! = null & & refinfo . running ( ) ) { ref . lock . readLock ( ) . unlock ( ) ; if ( refinfo ! = info ) { blockAndBail ( refinfo ) ; } } else ensures . add ( ref ) ; } Object doCommute ( Ref ref , IFn fn , ISeq args ) { if ( ! info . running ( ) ) throw retryex ; if ( ! vals . containsKey ( ref ) ) { Object val = null ; try { ref . lock . readLock ( ) . lock ( ) ; val = ref . tvals = = null ? null : ref . tvals . val ; } finally { ref . lock . readLock ( ) . unlock ( ) ; } vals . put ( ref , val ) ; } ArrayList < CFn > fns = commutes . get ( ref ) ; if ( fns = = null ) commutes . put ( ref , fns = new ArrayList < CFn > ( ) ) ; fns . add ( new CFn ( fn , args ) ) ; Object ret = fn . applyTo ( RT . cons ( vals . get ( ref ) , args ) ) ; vals . put ( ref , ret ) ; return ret ; } } 
