package org . elasticsearch . search . suggest . phrase ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . search . suggest . Suggest ; import org . elasticsearch . search . suggest . Suggest . Suggestion ; import java . io . IOException ; public class PhraseSuggestion extends Suggest . Suggestion < PhraseSuggestion . Entry > { public static final int TYPE = <int> ; public PhraseSuggestion ( ) { } public PhraseSuggestion ( String name , int size ) { super ( name , size ) ; } @Override public int getType ( ) { return TYPE ; } @Override protected Entry newEntry ( ) { return new Entry ( ) ; } public static class Entry extends Suggestion . Entry < Suggestion . Entry . Option > { static class Fields { static final XContentBuilderString CUTOFF_SCORE = new XContentBuilderString ( <str> ) ; } protected double cutoffScore = Double . MIN_VALUE ; public Entry ( Text text , int offset , int length , double cutoffScore ) { super ( text , offset , length ) ; this . cutoffScore = cutoffScore ; } public Entry ( ) { } public double getCutoffScore ( ) { return cutoffScore ; } @Override protected void merge ( Suggestion . Entry < Suggestion . Entry . Option > other ) { super . merge ( other ) ; if ( ! ( other instanceof PhraseSuggestion . Entry ) ) { return ; } PhraseSuggestion . Entry otherSuggestionEntry = ( PhraseSuggestion . Entry ) other ; this . cutoffScore = Math . max ( this . cutoffScore , otherSuggestionEntry . cutoffScore ) ; } @Override public void addOption ( Suggestion . Entry . Option option ) { if ( option . getScore ( ) > this . cutoffScore ) { this . options . add ( option ) ; } } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; cutoffScore = in . readDouble ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeDouble ( cutoffScore ) ; } } } 
