package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . collect . Iterables . skip ; import static com . google . common . collect . Lists . newArrayList ; import static com . google . common . collect . Sets . newLinkedHashSet ; import static com . google . common . collect . testing . IteratorFeature . MODIFIABLE ; import static com . google . common . collect . testing . IteratorFeature . UNMODIFIABLE ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import static java . util . Collections . emptyList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . testing . IteratorTester ; import com . google . common . testing . ClassSanityTester ; import com . google . common . testing . NullPointerTester ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . Queue ; import java . util . RandomAccess ; import java . util . Set ; import java . util . SortedSet ; import java . util . TreeSet ; @GwtCompatible ( emulated = true ) public class IterablesTest extends TestCase { public void testSize0 ( ) { Iterable < String > iterable = Collections . emptySet ( ) ; assertEquals ( <int> , Iterables . size ( iterable ) ) ; } public void testSize1Collection ( ) { Iterable < String > iterable = Collections . singleton ( <str> ) ; assertEquals ( <int> , Iterables . size ( iterable ) ) ; } public void testSize2NonCollection ( ) { Iterable < Integer > iterable = new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return asList ( <int> , <int> ) . iterator ( ) ; } } ; assertEquals ( <int> , Iterables . size ( iterable ) ) ; } @SuppressWarnings ( <str> ) public void testSize_collection_doesntIterate ( ) { List < Integer > nums = asList ( <int> , <int> , <int> , <int> , <int> ) ; List < Integer > collection = new ArrayList < Integer > ( nums ) { @Override public Iterator < Integer > iterator ( ) { throw new AssertionFailedError ( <str> ) ; } } ; assertEquals ( <int> , Iterables . size ( collection ) ) ; } private static Iterable < String > iterable ( String . . . elements ) { final List < String > list = asList ( elements ) ; return new Iterable < String > ( ) { @Override public Iterator < String > iterator ( ) { return list . iterator ( ) ; } } ; } public void test_contains_null_set_yes ( ) { Iterable < String > set = Sets . newHashSet ( <str> , null , <str> ) ; assertTrue ( Iterables . contains ( set , null ) ) ; } public void test_contains_null_set_no ( ) { Iterable < String > set = Sets . newHashSet ( <str> , <str> ) ; assertFalse ( Iterables . contains ( set , null ) ) ; } public void test_contains_null_iterable_yes ( ) { Iterable < String > set = iterable ( <str> , null , <str> ) ; assertTrue ( Iterables . contains ( set , null ) ) ; } public void test_contains_null_iterable_no ( ) { Iterable < String > set = iterable ( <str> , <str> ) ; assertFalse ( Iterables . contains ( set , null ) ) ; } public void test_contains_nonnull_set_yes ( ) { Iterable < String > set = Sets . newHashSet ( <str> , null , <str> ) ; assertTrue ( Iterables . contains ( set , <str> ) ) ; } public void test_contains_nonnull_set_no ( ) { Iterable < String > set = Sets . newHashSet ( <str> , <str> ) ; assertFalse ( Iterables . contains ( set , <str> ) ) ; } public void test_contains_nonnull_iterable_yes ( ) { Iterable < String > set = iterable ( <str> , null , <str> ) ; assertTrue ( Iterables . contains ( set , <str> ) ) ; } public void test_contains_nonnull_iterable_no ( ) { Iterable < String > set = iterable ( <str> , <str> ) ; assertFalse ( Iterables . contains ( set , <str> ) ) ; } public void testGetOnlyElement_noDefault_valid ( ) { Iterable < String > iterable = Collections . singletonList ( <str> ) ; assertEquals ( <str> , Iterables . getOnlyElement ( iterable ) ) ; } public void testGetOnlyElement_noDefault_empty ( ) { Iterable < String > iterable = Collections . emptyList ( ) ; try { Iterables . getOnlyElement ( iterable ) ; fail ( ) ; } catch ( NoSuchElementException expected ) { } } public void testGetOnlyElement_noDefault_multiple ( ) { Iterable < String > iterable = asList ( <str> , <str> ) ; try { Iterables . getOnlyElement ( iterable ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testGetOnlyElement_withDefault_singleton ( ) { Iterable < String > iterable = Collections . singletonList ( <str> ) ; assertEquals ( <str> , Iterables . getOnlyElement ( iterable , <str> ) ) ; } public void testGetOnlyElement_withDefault_empty ( ) { Iterable < String > iterable = Collections . emptyList ( ) ; assertEquals ( <str> , Iterables . getOnlyElement ( iterable , <str> ) ) ; } public void testGetOnlyElement_withDefault_empty_null ( ) { Iterable < String > iterable = Collections . emptyList ( ) ; assertNull ( Iterables . getOnlyElement ( iterable , null ) ) ; } public void testGetOnlyElement_withDefault_multiple ( ) { Iterable < String > iterable = asList ( <str> , <str> ) ; try { Iterables . getOnlyElement ( iterable , <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testToArrayEmpty ( ) { Iterable < String > iterable = Collections . emptyList ( ) ; String [ ] array = Iterables . toArray ( iterable , String . class ) ; assertTrue ( Arrays . equals ( new String [ <int> ] , array ) ) ; } @GwtIncompatible ( <str> ) public void testToArraySingleton ( ) { Iterable < String > iterable = Collections . singletonList ( <str> ) ; String [ ] array = Iterables . toArray ( iterable , String . class ) ; assertTrue ( Arrays . equals ( new String [ ] { <str> } , array ) ) ; } @GwtIncompatible ( <str> ) public void testToArray ( ) { String [ ] sourceArray = new String [ ] { <str> , <str> , <str> } ; Iterable < String > iterable = asList ( sourceArray ) ; String [ ] newArray = Iterables . toArray ( iterable , String . class ) ; assertTrue ( Arrays . equals ( sourceArray , newArray ) ) ; } public void testAny ( ) { List < String > list = newArrayList ( ) ; Predicate < String > predicate = Predicates . equalTo ( <str> ) ; assertFalse ( Iterables . any ( list , predicate ) ) ; list . add ( <str> ) ; assertFalse ( Iterables . any ( list , predicate ) ) ; list . add ( <str> ) ; assertTrue ( Iterables . any ( list , predicate ) ) ; } public void testAll ( ) { List < String > list = newArrayList ( ) ; Predicate < String > predicate = Predicates . equalTo ( <str> ) ; assertTrue ( Iterables . all ( list , predicate ) ) ; list . add ( <str> ) ; assertTrue ( Iterables . all ( list , predicate ) ) ; list . add ( <str> ) ; assertFalse ( Iterables . all ( list , predicate ) ) ; } public void testFind ( ) { Iterable < String > list = newArrayList ( <str> , <str> ) ; assertEquals ( <str> , Iterables . find ( list , Predicates . equalTo ( <str> ) ) ) ; assertEquals ( <str> , Iterables . find ( list , Predicates . equalTo ( <str> ) ) ) ; try { Iterables . find ( list , Predicates . alwaysFalse ( ) ) ; fail ( ) ; } catch ( NoSuchElementException e ) { } assertEquals ( <str> , Iterables . find ( list , Predicates . alwaysTrue ( ) ) ) ; assertCanIterateAgain ( list ) ; } public void testFind_withDefault ( ) { Iterable < String > list = Lists . newArrayList ( <str> , <str> ) ; assertEquals ( <str> , Iterables . find ( list , Predicates . equalTo ( <str> ) , <str> ) ) ; assertEquals ( <str> , Iterables . find ( list , Predicates . equalTo ( <str> ) , <str> ) ) ; assertEquals ( <str> , Iterables . find ( list , Predicates . alwaysFalse ( ) , <str> ) ) ; assertNull ( Iterables . find ( list , Predicates . alwaysFalse ( ) , null ) ) ; assertEquals ( <str> , Iterables . find ( list , Predicates . alwaysTrue ( ) , <str> ) ) ; assertCanIterateAgain ( list ) ; } public void testTryFind ( ) { Iterable < String > list = newArrayList ( <str> , <str> ) ; assertThat ( Iterables . tryFind ( list , Predicates . equalTo ( <str> ) ) ) . hasValue ( <str> ) ; assertThat ( Iterables . tryFind ( list , Predicates . equalTo ( <str> ) ) ) . hasValue ( <str> ) ; assertThat ( Iterables . tryFind ( list , Predicates . alwaysTrue ( ) ) ) . hasValue ( <str> ) ; assertThat ( Iterables . tryFind ( list , Predicates . alwaysFalse ( ) ) ) . isAbsent ( ) ; assertCanIterateAgain ( list ) ; } private static class TypeA { } private interface TypeB { } private static class HasBoth extends TypeA implements TypeB { } @GwtIncompatible ( <str> ) public void testFilterByType ( ) throws Exception { HasBoth hasBoth = new HasBoth ( ) ; Iterable < TypeA > alist = Lists . newArrayList ( new TypeA ( ) , new TypeA ( ) , hasBoth , new TypeA ( ) ) ; Iterable < TypeB > blist = Iterables . filter ( alist , TypeB . class ) ; assertThat ( blist ) . containsExactly ( hasBoth ) . inOrder ( ) ; } public void testTransform ( ) { List < String > input = asList ( <str> , <str> , <str> ) ; Iterable < Integer > result = Iterables . transform ( input , new Function < String , Integer > ( ) { @Override public Integer apply ( String from ) { return Integer . valueOf ( from ) ; } } ) ; List < Integer > actual = newArrayList ( result ) ; List < Integer > expected = asList ( <int> , <int> , <int> ) ; assertEquals ( expected , actual ) ; assertCanIterateAgain ( result ) ; assertEquals ( <str> , result . toString ( ) ) ; } public void testPoorlyBehavedTransform ( ) { List < String > input = asList ( <str> , null , <str> ) ; Iterable < Integer > result = Iterables . transform ( input , new Function < String , Integer > ( ) { @Override public Integer apply ( String from ) { return Integer . valueOf ( from ) ; } } ) ; Iterator < Integer > resultIterator = result . iterator ( ) ; resultIterator . next ( ) ; try { resultIterator . next ( ) ; fail ( <str> ) ; } catch ( NumberFormatException nfe ) { } } public void testNullFriendlyTransform ( ) { List < Integer > input = asList ( <int> , <int> , null , <int> ) ; Iterable < String > result = Iterables . transform ( input , new Function < Integer , String > ( ) { @Override public String apply ( Integer from ) { return String . valueOf ( from ) ; } } ) ; List < String > actual = newArrayList ( result ) ; List < String > expected = asList ( <str> , <str> , <str> , <str> ) ; assertEquals ( expected , actual ) ; } public void testCycle ( ) { Iterable < String > cycle = Iterables . cycle ( <str> , <str> ) ; int howManyChecked = <int> ; for ( String string : cycle ) { String expected = ( howManyChecked % <int> = = <int> ) ? <str> : <str> ; assertEquals ( expected , string ) ; if ( howManyChecked + + = = <int> ) { break ; } } for ( String string : cycle ) { assertEquals ( <str> , string ) ; break ; } assertEquals ( <str> , cycle . toString ( ) ) ; } public void testConcatIterable ( ) { List < Integer > list1 = newArrayList ( <int> ) ; List < Integer > list2 = newArrayList ( <int> ) ; @SuppressWarnings ( <str> ) List < List < Integer > > input = newArrayList ( list1 , list2 ) ; Iterable < Integer > result = Iterables . concat ( input ) ; assertEquals ( asList ( <int> , <int> ) , newArrayList ( result ) ) ; list1 . add ( <int> ) ; List < Integer > list3 = newArrayList ( <int> ) ; input . add ( <int> , list3 ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> ) , newArrayList ( result ) ) ; assertEquals ( <str> , result . toString ( ) ) ; } public void testConcatVarargs ( ) { List < Integer > list1 = newArrayList ( <int> ) ; List < Integer > list2 = newArrayList ( <int> ) ; List < Integer > list3 = newArrayList ( <int> , <int> ) ; List < Integer > list4 = newArrayList ( <int> ) ; List < Integer > list5 = newArrayList ( <int> ) ; @SuppressWarnings ( <str> ) Iterable < Integer > result = Iterables . concat ( list1 , list2 , list3 , list4 , list5 ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> , <int> , <int> ) , newArrayList ( result ) ) ; assertEquals ( <str> , result . toString ( ) ) ; } public void testConcatNullPointerException ( ) { List < Integer > list1 = newArrayList ( <int> ) ; List < Integer > list2 = newArrayList ( <int> ) ; try { Iterables . concat ( list1 , null , list2 ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testConcatPeformingFiniteCycle ( ) { Iterable < Integer > iterable = asList ( <int> , <int> , <int> ) ; int n = <int> ; Iterable < Integer > repeated = Iterables . concat ( Collections . nCopies ( n , iterable ) ) ; assertThat ( repeated ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testPartition_badSize ( ) { Iterable < Integer > source = Collections . singleton ( <int> ) ; try { Iterables . partition ( source , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testPartition_empty ( ) { Iterable < Integer > source = Collections . emptySet ( ) ; Iterable < List < Integer > > partitions = Iterables . partition ( source , <int> ) ; assertTrue ( Iterables . isEmpty ( partitions ) ) ; } public void testPartition_singleton1 ( ) { Iterable < Integer > source = Collections . singleton ( <int> ) ; Iterable < List < Integer > > partitions = Iterables . partition ( source , <int> ) ; assertEquals ( <int> , Iterables . size ( partitions ) ) ; assertEquals ( Collections . singletonList ( <int> ) , partitions . iterator ( ) . next ( ) ) ; } public void testPartition_view ( ) { List < Integer > list = asList ( <int> , <int> ) ; Iterable < List < Integer > > partitions = Iterables . partition ( list , <int> ) ; list . set ( <int> , <int> ) ; Iterator < List < Integer > > iterator = partitions . iterator ( ) ; list . set ( <int> , <int> ) ; List < Integer > first = iterator . next ( ) ; list . set ( <int> , <int> ) ; assertEquals ( ImmutableList . of ( <int> , <int> ) , first ) ; } @GwtIncompatible ( <str> ) public void testPartitionRandomAccessInput ( ) { Iterable < Integer > source = asList ( <int> , <int> , <int> ) ; Iterable < List < Integer > > partitions = Iterables . partition ( source , <int> ) ; Iterator < List < Integer > > iterator = partitions . iterator ( ) ; assertTrue ( iterator . next ( ) instanceof RandomAccess ) ; assertTrue ( iterator . next ( ) instanceof RandomAccess ) ; } @GwtIncompatible ( <str> ) public void testPartitionNonRandomAccessInput ( ) { Iterable < Integer > source = Lists . newLinkedList ( asList ( <int> , <int> , <int> ) ) ; Iterable < List < Integer > > partitions = Iterables . partition ( source , <int> ) ; Iterator < List < Integer > > iterator = partitions . iterator ( ) ; assertTrue ( iterator . next ( ) instanceof RandomAccess ) ; assertTrue ( iterator . next ( ) instanceof RandomAccess ) ; } public void testPaddedPartition_basic ( ) { List < Integer > list = asList ( <int> , <int> , <int> , <int> , <int> ) ; Iterable < List < Integer > > partitions = Iterables . paddedPartition ( list , <int> ) ; assertEquals ( <int> , Iterables . size ( partitions ) ) ; assertEquals ( asList ( <int> , null ) , Iterables . getLast ( partitions ) ) ; } public void testPaddedPartitionRandomAccessInput ( ) { Iterable < Integer > source = asList ( <int> , <int> , <int> ) ; Iterable < List < Integer > > partitions = Iterables . paddedPartition ( source , <int> ) ; Iterator < List < Integer > > iterator = partitions . iterator ( ) ; assertTrue ( iterator . next ( ) instanceof RandomAccess ) ; assertTrue ( iterator . next ( ) instanceof RandomAccess ) ; } public void testPaddedPartitionNonRandomAccessInput ( ) { Iterable < Integer > source = Lists . newLinkedList ( asList ( <int> , <int> , <int> ) ) ; Iterable < List < Integer > > partitions = Iterables . paddedPartition ( source , <int> ) ; Iterator < List < Integer > > iterator = partitions . iterator ( ) ; assertTrue ( iterator . next ( ) instanceof RandomAccess ) ; assertTrue ( iterator . next ( ) instanceof RandomAccess ) ; } public void testAddAllToList ( ) { List < String > alreadyThere = newArrayList ( <str> , <str> ) ; List < String > freshlyAdded = newArrayList ( <str> , <str> ) ; boolean changed = Iterables . addAll ( alreadyThere , freshlyAdded ) ; assertThat ( alreadyThere ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertTrue ( changed ) ; } private static void assertCanIterateAgain ( Iterable < ? > iterable ) { for ( @SuppressWarnings ( <str> ) Object obj : iterable ) { } } @GwtIncompatible ( <str> ) public void testNullPointerExceptions ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( Iterables . class ) ; } public void testElementsEqual ( ) throws Exception { Iterable < ? > a ; Iterable < ? > b ; a = asList ( <int> , <int> , <int> , <int> , <int> , <int> ) ; b = asList ( <int> , <int> , <int> , <int> , <int> , <int> ) ; assertTrue ( Iterables . elementsEqual ( a , b ) ) ; a = asList ( <int> , <int> , <int> , <int> , <int> , <int> ) ; b = asList ( <int> , <int> , <int> , <int> , <int> , <int> ) ; assertFalse ( Iterables . elementsEqual ( a , b ) ) ; a = asList ( <int> , <int> , <int> , null , <int> , <int> ) ; b = asList ( <int> , <int> , <int> , <int> , <int> , <int> ) ; assertFalse ( Iterables . elementsEqual ( a , b ) ) ; assertFalse ( Iterables . elementsEqual ( b , a ) ) ; a = asList ( <int> , <int> , <int> , <int> , <int> ) ; b = asList ( <int> , <int> , <int> , <int> , <int> , <int> ) ; assertFalse ( Iterables . elementsEqual ( a , b ) ) ; assertFalse ( Iterables . elementsEqual ( b , a ) ) ; } public void testToString ( ) { List < String > list = Collections . emptyList ( ) ; assertEquals ( <str> , Iterables . toString ( list ) ) ; list = newArrayList ( <str> , <str> , <str> , <str> ) ; assertEquals ( <str> , Iterables . toString ( list ) ) ; } public void testLimit ( ) { Iterable < String > iterable = newArrayList ( <str> , <str> , <str> ) ; Iterable < String > limited = Iterables . limit ( iterable , <int> ) ; List < String > expected = ImmutableList . of ( <str> , <str> ) ; List < String > actual = newArrayList ( limited ) ; assertEquals ( expected , actual ) ; assertCanIterateAgain ( limited ) ; assertEquals ( <str> , limited . toString ( ) ) ; } public void testLimit_illegalArgument ( ) { List < String > list = newArrayList ( <str> , <str> , <str> ) ; try { Iterables . limit ( list , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testIsEmpty ( ) { Iterable < String > emptyList = Collections . emptyList ( ) ; assertTrue ( Iterables . isEmpty ( emptyList ) ) ; Iterable < String > singletonList = Collections . singletonList ( <str> ) ; assertFalse ( Iterables . isEmpty ( singletonList ) ) ; } public void testSkip_simple ( ) { Collection < String > set = ImmutableSet . of ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , newArrayList ( skip ( set , <int> ) ) ) ; assertEquals ( <str> , skip ( set , <int> ) . toString ( ) ) ; } public void testSkip_simpleList ( ) { Collection < String > list = newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , newArrayList ( skip ( list , <int> ) ) ) ; assertEquals ( <str> , skip ( list , <int> ) . toString ( ) ) ; } public void testSkip_pastEnd ( ) { Collection < String > set = ImmutableSet . of ( <str> , <str> ) ; assertEquals ( emptyList ( ) , newArrayList ( skip ( set , <int> ) ) ) ; } public void testSkip_pastEndList ( ) { Collection < String > list = newArrayList ( <str> , <str> ) ; assertEquals ( emptyList ( ) , newArrayList ( skip ( list , <int> ) ) ) ; } public void testSkip_skipNone ( ) { Collection < String > set = ImmutableSet . of ( <str> , <str> ) ; assertEquals ( newArrayList ( <str> , <str> ) , newArrayList ( skip ( set , <int> ) ) ) ; } public void testSkip_skipNoneList ( ) { Collection < String > list = newArrayList ( <str> , <str> ) ; assertEquals ( newArrayList ( <str> , <str> ) , newArrayList ( skip ( list , <int> ) ) ) ; } public void testSkip_removal ( ) { Collection < String > set = Sets . newHashSet ( <str> , <str> ) ; Iterator < String > iterator = skip ( set , <int> ) . iterator ( ) ; try { iterator . next ( ) ; } catch ( NoSuchElementException suppressed ) { } try { iterator . remove ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testSkip_allOfMutableList_modifiable ( ) { List < String > list = newArrayList ( <str> , <str> ) ; Iterator < String > iterator = skip ( list , <int> ) . iterator ( ) ; try { iterator . remove ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testSkip_allOfImmutableList_modifiable ( ) { List < String > list = ImmutableList . of ( <str> , <str> ) ; Iterator < String > iterator = skip ( list , <int> ) . iterator ( ) ; try { iterator . remove ( ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } @GwtIncompatible ( <str> ) public void testSkip_iterator ( ) { new IteratorTester < Integer > ( <int> , MODIFIABLE , newArrayList ( <int> , <int> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < Integer > newTargetIterator ( ) { return skip ( newLinkedHashSet ( asList ( <int> , <int> , <int> ) ) , <int> ) . iterator ( ) ; } } . test ( ) ; } @GwtIncompatible ( <str> ) public void testSkip_iteratorList ( ) { new IteratorTester < Integer > ( <int> , MODIFIABLE , newArrayList ( <int> , <int> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < Integer > newTargetIterator ( ) { return skip ( newArrayList ( <int> , <int> , <int> ) , <int> ) . iterator ( ) ; } } . test ( ) ; } public void testSkip_nonStructurallyModifiedList ( ) throws Exception { List < String > list = newArrayList ( <str> , <str> , <str> ) ; Iterable < String > tail = skip ( list , <int> ) ; Iterator < String > tailIterator = tail . iterator ( ) ; list . set ( <int> , <str> ) ; assertEquals ( <str> , tailIterator . next ( ) ) ; assertEquals ( <str> , tailIterator . next ( ) ) ; assertFalse ( tailIterator . hasNext ( ) ) ; } public void testSkip_structurallyModifiedSkipSome ( ) throws Exception { Collection < String > set = newLinkedHashSet ( asList ( <str> , <str> , <str> ) ) ; Iterable < String > tail = skip ( set , <int> ) ; set . remove ( <str> ) ; set . addAll ( newArrayList ( <str> , <str> , <str> ) ) ; assertThat ( tail ) . containsExactly ( <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testSkip_structurallyModifiedSkipSomeList ( ) throws Exception { List < String > list = newArrayList ( <str> , <str> , <str> ) ; Iterable < String > tail = skip ( list , <int> ) ; list . subList ( <int> , <int> ) . clear ( ) ; list . addAll ( <int> , newArrayList ( <str> , <str> , <str> ) ) ; assertThat ( tail ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } public void testSkip_structurallyModifiedSkipAll ( ) throws Exception { Collection < String > set = newLinkedHashSet ( asList ( <str> , <str> , <str> ) ) ; Iterable < String > tail = skip ( set , <int> ) ; set . remove ( <str> ) ; set . remove ( <str> ) ; assertFalse ( tail . iterator ( ) . hasNext ( ) ) ; } public void testSkip_structurallyModifiedSkipAllList ( ) throws Exception { List < String > list = newArrayList ( <str> , <str> , <str> ) ; Iterable < String > tail = skip ( list , <int> ) ; list . subList ( <int> , <int> ) . clear ( ) ; assertTrue ( Iterables . isEmpty ( tail ) ) ; } public void testSkip_illegalArgument ( ) { List < String > list = newArrayList ( <str> , <str> , <str> ) ; try { skip ( list , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } private void testGetOnAbc ( Iterable < String > iterable ) { try { Iterables . get ( iterable , - <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } assertEquals ( <str> , Iterables . get ( iterable , <int> ) ) ; assertEquals ( <str> , Iterables . get ( iterable , <int> ) ) ; assertEquals ( <str> , Iterables . get ( iterable , <int> ) ) ; try { Iterables . get ( iterable , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException nsee ) { } try { Iterables . get ( iterable , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException nsee ) { } } private void testGetOnEmpty ( Iterable < String > iterable ) { try { Iterables . get ( iterable , <int> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } public void testGet_list ( ) { testGetOnAbc ( newArrayList ( <str> , <str> , <str> ) ) ; } public void testGet_emptyList ( ) { testGetOnEmpty ( Collections . < String > emptyList ( ) ) ; } public void testGet_sortedSet ( ) { testGetOnAbc ( ImmutableSortedSet . of ( <str> , <str> , <str> ) ) ; } public void testGet_emptySortedSet ( ) { testGetOnEmpty ( ImmutableSortedSet . < String > of ( ) ) ; } public void testGet_iterable ( ) { testGetOnAbc ( ImmutableSet . of ( <str> , <str> , <str> ) ) ; } public void testGet_emptyIterable ( ) { testGetOnEmpty ( Sets . < String > newHashSet ( ) ) ; } public void testGet_withDefault_negativePosition ( ) { try { Iterables . get ( newArrayList ( <str> , <str> , <str> ) , - <int> , <str> ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } public void testGet_withDefault_simple ( ) { ArrayList < String > list = newArrayList ( <str> , <str> , <str> ) ; assertEquals ( <str> , Iterables . get ( list , <int> , <str> ) ) ; } public void testGet_withDefault_iterable ( ) { Set < String > set = ImmutableSet . of ( <str> , <str> , <str> ) ; assertEquals ( <str> , Iterables . get ( set , <int> , <str> ) ) ; } public void testGet_withDefault_last ( ) { ArrayList < String > list = newArrayList ( <str> , <str> , <str> ) ; assertEquals ( <str> , Iterables . get ( list , <int> , <str> ) ) ; } public void testGet_withDefault_lastPlusOne ( ) { ArrayList < String > list = newArrayList ( <str> , <str> , <str> ) ; assertEquals ( <str> , Iterables . get ( list , <int> , <str> ) ) ; } public void testGet_withDefault_doesntIterate ( ) { List < String > list = new DiesOnIteratorArrayList ( ) ; list . add ( <str> ) ; assertEquals ( <str> , Iterables . get ( list , <int> , <str> ) ) ; } public void testGetFirst_withDefault_singleton ( ) { Iterable < String > iterable = Collections . singletonList ( <str> ) ; assertEquals ( <str> , Iterables . getFirst ( iterable , <str> ) ) ; } public void testGetFirst_withDefault_empty ( ) { Iterable < String > iterable = Collections . emptyList ( ) ; assertEquals ( <str> , Iterables . getFirst ( iterable , <str> ) ) ; } public void testGetFirst_withDefault_empty_null ( ) { Iterable < String > iterable = Collections . emptyList ( ) ; assertNull ( Iterables . getFirst ( iterable , null ) ) ; } public void testGetFirst_withDefault_multiple ( ) { Iterable < String > iterable = asList ( <str> , <str> ) ; assertEquals ( <str> , Iterables . getFirst ( iterable , <str> ) ) ; } public void testGetLast_list ( ) { List < String > list = newArrayList ( <str> , <str> , <str> ) ; assertEquals ( <str> , Iterables . getLast ( list ) ) ; } public void testGetLast_emptyList ( ) { List < String > list = Collections . emptyList ( ) ; try { Iterables . getLast ( list ) ; fail ( ) ; } catch ( NoSuchElementException e ) { } } public void testGetLast_sortedSet ( ) { SortedSet < String > sortedSet = ImmutableSortedSet . of ( <str> , <str> , <str> ) ; assertEquals ( <str> , Iterables . getLast ( sortedSet ) ) ; } public void testGetLast_withDefault_singleton ( ) { Iterable < String > iterable = Collections . singletonList ( <str> ) ; assertEquals ( <str> , Iterables . getLast ( iterable , <str> ) ) ; } public void testGetLast_withDefault_empty ( ) { Iterable < String > iterable = Collections . emptyList ( ) ; assertEquals ( <str> , Iterables . getLast ( iterable , <str> ) ) ; } public void testGetLast_withDefault_empty_null ( ) { Iterable < String > iterable = Collections . emptyList ( ) ; assertNull ( Iterables . getLast ( iterable , null ) ) ; } public void testGetLast_withDefault_multiple ( ) { Iterable < String > iterable = asList ( <str> , <str> ) ; assertEquals ( <str> , Iterables . getLast ( iterable , <str> ) ) ; } private static class DiesOnIteratorArrayList extends ArrayList < String > { @Override public Iterator < String > iterator ( ) { throw new UnsupportedOperationException ( ) ; } } public void testGetLast_withDefault_not_empty_list ( ) { List < String > diesOnIteratorList = new DiesOnIteratorArrayList ( ) ; diesOnIteratorList . add ( <str> ) ; assertEquals ( <str> , Iterables . getLast ( diesOnIteratorList , <str> ) ) ; } private static final class DiesOnIteratorTreeSet extends TreeSet < String > { @Override public Iterator < String > iterator ( ) { throw new UnsupportedOperationException ( ) ; } } public void testGetLast_emptySortedSet ( ) { SortedSet < String > sortedSet = ImmutableSortedSet . of ( ) ; try { Iterables . getLast ( sortedSet ) ; fail ( ) ; } catch ( NoSuchElementException e ) { } } public void testGetLast_iterable ( ) { Set < String > set = ImmutableSet . of ( <str> , <str> , <str> ) ; assertEquals ( <str> , Iterables . getLast ( set ) ) ; } public void testGetLast_emptyIterable ( ) { Set < String > set = Sets . newHashSet ( ) ; try { Iterables . getLast ( set ) ; fail ( ) ; } catch ( NoSuchElementException e ) { } } public void testUnmodifiableIterable ( ) { List < String > list = newArrayList ( <str> , <str> , <str> ) ; Iterable < String > iterable = Iterables . unmodifiableIterable ( list ) ; Iterator < String > iterator = iterable . iterator ( ) ; iterator . next ( ) ; try { iterator . remove ( ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } assertEquals ( <str> , iterable . toString ( ) ) ; } @SuppressWarnings ( <str> ) public void testUnmodifiableIterableShortCircuit ( ) { List < String > list = newArrayList ( <str> , <str> , <str> ) ; Iterable < String > iterable = Iterables . unmodifiableIterable ( list ) ; Iterable < String > iterable2 = Iterables . unmodifiableIterable ( iterable ) ; assertSame ( iterable , iterable2 ) ; ImmutableList < String > immutableList = ImmutableList . of ( <str> , <str> , <str> ) ; assertSame ( immutableList , Iterables . unmodifiableIterable ( immutableList ) ) ; assertSame ( immutableList , Iterables . unmodifiableIterable ( ( List < String > ) immutableList ) ) ; } public void testFrequency_multiset ( ) { Multiset < String > multiset = ImmutableMultiset . of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( <int> , Iterables . frequency ( multiset , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( multiset , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( multiset , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( multiset , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( multiset , <float> ) ) ; assertEquals ( <int> , Iterables . frequency ( multiset , null ) ) ; } public void testFrequency_set ( ) { Set < String > set = Sets . newHashSet ( <str> , <str> , <str> ) ; assertEquals ( <int> , Iterables . frequency ( set , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( set , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( set , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( set , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( set , <float> ) ) ; assertEquals ( <int> , Iterables . frequency ( set , null ) ) ; } public void testFrequency_list ( ) { List < String > list = newArrayList ( <str> , <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( <int> , Iterables . frequency ( list , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( list , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( list , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( list , <str> ) ) ; assertEquals ( <int> , Iterables . frequency ( list , <float> ) ) ; assertEquals ( <int> , Iterables . frequency ( list , null ) ) ; } public void testRemoveAll_collection ( ) { List < String > list = newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( Iterables . removeAll ( list , newArrayList ( <str> , <str> , <str> ) ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; assertFalse ( Iterables . removeAll ( list , newArrayList ( <str> , <str> , <str> ) ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; } public void testRemoveAll_iterable ( ) { final List < String > list = newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; Iterable < String > iterable = new Iterable < String > ( ) { @Override public Iterator < String > iterator ( ) { return list . iterator ( ) ; } } ; assertTrue ( Iterables . removeAll ( iterable , newArrayList ( <str> , <str> , <str> ) ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; assertFalse ( Iterables . removeAll ( iterable , newArrayList ( <str> , <str> , <str> ) ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; } public void testRetainAll_collection ( ) { List < String > list = newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( Iterables . retainAll ( list , newArrayList ( <str> , <str> , <str> ) ) ) ; assertEquals ( newArrayList ( <str> , <str> ) , list ) ; assertFalse ( Iterables . retainAll ( list , newArrayList ( <str> , <str> , <str> ) ) ) ; assertEquals ( newArrayList ( <str> , <str> ) , list ) ; } public void testRetainAll_iterable ( ) { final List < String > list = newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; Iterable < String > iterable = new Iterable < String > ( ) { @Override public Iterator < String > iterator ( ) { return list . iterator ( ) ; } } ; assertTrue ( Iterables . retainAll ( iterable , newArrayList ( <str> , <str> , <str> ) ) ) ; assertEquals ( newArrayList ( <str> , <str> ) , list ) ; assertFalse ( Iterables . retainAll ( iterable , newArrayList ( <str> , <str> , <str> ) ) ) ; assertEquals ( newArrayList ( <str> , <str> ) , list ) ; } public void testRemoveIf_randomAccess ( ) { List < String > list = newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( Iterables . removeIf ( list , new Predicate < String > ( ) { @Override public boolean apply ( String s ) { return s . equals ( <str> ) | | s . equals ( <str> ) | | s . equals ( <str> ) ; } } ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; assertFalse ( Iterables . removeIf ( list , new Predicate < String > ( ) { @Override public boolean apply ( String s ) { return s . equals ( <str> ) | | s . equals ( <str> ) | | s . equals ( <str> ) ; } } ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; } public void testRemoveIf_randomAccess_notPermittingDuplicates ( ) { final List < String > delegate = newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; List < String > uniqueList = Constraints . constrainedList ( delegate , new Constraint < String > ( ) { @Override public String checkElement ( String element ) { checkArgument ( ! delegate . contains ( element ) , <str> ) ; return element ; } } ) ; assertTrue ( uniqueList instanceof RandomAccess ) ; assertTrue ( Iterables . removeIf ( uniqueList , new Predicate < String > ( ) { @Override public boolean apply ( String s ) { return s . equals ( <str> ) | | s . equals ( <str> ) | | s . equals ( <str> ) ; } } ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , uniqueList ) ; assertFalse ( Iterables . removeIf ( uniqueList , new Predicate < String > ( ) { @Override public boolean apply ( String s ) { return s . equals ( <str> ) | | s . equals ( <str> ) | | s . equals ( <str> ) ; } } ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , uniqueList ) ; } public void testRemoveIf_transformedList ( ) { List < String > list = newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; List < Integer > transformed = Lists . transform ( list , new Function < String , Integer > ( ) { @Override public Integer apply ( String s ) { return Integer . valueOf ( s ) ; } } ) ; assertTrue ( Iterables . removeIf ( transformed , new Predicate < Integer > ( ) { @Override public boolean apply ( Integer n ) { return ( n & <int> ) = = <int> ; } } ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; assertFalse ( Iterables . removeIf ( transformed , new Predicate < Integer > ( ) { @Override public boolean apply ( Integer n ) { return ( n & <int> ) = = <int> ; } } ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; } public void testRemoveIf_noRandomAccess ( ) { List < String > list = Lists . newLinkedList ( asList ( <str> , <str> , <str> , <str> , <str> ) ) ; assertTrue ( Iterables . removeIf ( list , new Predicate < String > ( ) { @Override public boolean apply ( String s ) { return s . equals ( <str> ) | | s . equals ( <str> ) | | s . equals ( <str> ) ; } } ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; assertFalse ( Iterables . removeIf ( list , new Predicate < String > ( ) { @Override public boolean apply ( String s ) { return s . equals ( <str> ) | | s . equals ( <str> ) | | s . equals ( <str> ) ; } } ) ) ; assertEquals ( newArrayList ( <str> , <str> , <str> ) , list ) ; } public void testIterableWithToString ( ) { assertEquals ( <str> , create ( ) . toString ( ) ) ; assertEquals ( <str> , create ( <str> ) . toString ( ) ) ; assertEquals ( <str> , create ( <str> , <str> , <str> ) . toString ( ) ) ; assertEquals ( <str> , create ( <str> , <str> , <str> ) . toString ( ) ) ; } public void testIterableWithToStringNull ( ) { assertEquals ( <str> , create ( ( String ) null ) . toString ( ) ) ; assertEquals ( <str> , create ( null , null ) . toString ( ) ) ; assertEquals ( <str> , create ( <str> , null , <str> ) . toString ( ) ) ; } private static Iterable < String > create ( String . . . strings ) { final List < String > list = asList ( strings ) ; return new FluentIterable < String > ( ) { @Override public Iterator < String > iterator ( ) { return list . iterator ( ) ; } } ; } public void testConsumingIterable ( ) { List < String > list = Lists . newArrayList ( asList ( <str> , <str> ) ) ; Iterable < String > consumingIterable = Iterables . consumingIterable ( list ) ; assertEquals ( <str> , consumingIterable . toString ( ) ) ; Iterator < String > consumingIterator = consumingIterable . iterator ( ) ; assertThat ( list ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertTrue ( consumingIterator . hasNext ( ) ) ; assertThat ( list ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertEquals ( <str> , consumingIterator . next ( ) ) ; assertThat ( list ) . contains ( <str> ) ; assertTrue ( consumingIterator . hasNext ( ) ) ; assertEquals ( <str> , consumingIterator . next ( ) ) ; assertThat ( list ) . isEmpty ( ) ; assertFalse ( consumingIterator . hasNext ( ) ) ; } @GwtIncompatible ( <str> ) public void testConsumingIterable_duelingIterators ( ) { List < String > list = Lists . newArrayList ( asList ( <str> , <str> ) ) ; Iterator < String > i1 = Iterables . consumingIterable ( list ) . iterator ( ) ; Iterator < String > i2 = Iterables . consumingIterable ( list ) . iterator ( ) ; i1 . next ( ) ; try { i2 . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException cme ) { } } public void testConsumingIterable_queue_iterator ( ) { final List < Integer > items = ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> ) ; new IteratorTester < Integer > ( <int> , UNMODIFIABLE , items , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < Integer > newTargetIterator ( ) { return Iterables . consumingIterable ( Lists . newLinkedList ( items ) ) . iterator ( ) ; } } . test ( ) ; } public void testConsumingIterable_queue_removesFromQueue ( ) { Queue < Integer > queue = Lists . newLinkedList ( asList ( <int> , <int> ) ) ; Iterator < Integer > consumingIterator = Iterables . consumingIterable ( queue ) . iterator ( ) ; assertEquals ( <int> , queue . peek ( ) . intValue ( ) ) ; assertEquals ( <int> , consumingIterator . next ( ) . intValue ( ) ) ; assertEquals ( <int> , queue . peek ( ) . intValue ( ) ) ; assertTrue ( consumingIterator . hasNext ( ) ) ; assertTrue ( queue . isEmpty ( ) ) ; } public void testConsumingIterable_noIteratorCall ( ) { Queue < Integer > queue = new UnIterableQueue < Integer > ( Lists . newLinkedList ( asList ( <int> , <int> ) ) ) ; Iterator < Integer > consumingIterator = Iterables . consumingIterable ( queue ) . iterator ( ) ; assertEquals ( <int> , consumingIterator . next ( ) . intValue ( ) ) ; } private static class UnIterableQueue < T > extends ForwardingQueue < T > { private Queue < T > queue ; UnIterableQueue ( Queue < T > queue ) { this . queue = queue ; } @Override public Iterator < T > iterator ( ) { throw new UnsupportedOperationException ( ) ; } @Override protected Queue < T > delegate ( ) { return queue ; } } public void testIndexOf_empty ( ) { List < String > list = new ArrayList < String > ( ) ; assertEquals ( - <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; } public void testIndexOf_oneElement ( ) { List < String > list = Lists . newArrayList ( <str> ) ; assertEquals ( <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; assertEquals ( - <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; } public void testIndexOf_twoElements ( ) { List < String > list = Lists . newArrayList ( <str> , <str> ) ; assertEquals ( <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; assertEquals ( <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; assertEquals ( - <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; } public void testIndexOf_withDuplicates ( ) { List < String > list = Lists . newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; assertEquals ( <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; assertEquals ( <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; assertEquals ( - <int> , Iterables . indexOf ( list , Predicates . equalTo ( <str> ) ) ) ; } private static final Predicate < CharSequence > STARTSWITH_A = new Predicate < CharSequence > ( ) { @Override public boolean apply ( CharSequence input ) { return ( input . length ( ) > <int> ) & & ( input . charAt ( <int> ) = = <str> ) ; } } ; public void testIndexOf_genericPredicate ( ) { List < CharSequence > sequences = Lists . newArrayList ( ) ; sequences . add ( <str> ) ; sequences . add ( new StringBuilder ( <str> ) ) ; sequences . add ( new StringBuffer ( <str> ) ) ; sequences . add ( new StringBuilder ( <str> ) ) ; sequences . add ( <str> ) ; assertEquals ( <int> , Iterables . indexOf ( sequences , STARTSWITH_A ) ) ; } public void testIndexOf_genericPredicate2 ( ) { List < String > sequences = Lists . newArrayList ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( <int> , Iterables . indexOf ( sequences , STARTSWITH_A ) ) ; } public void testMergeSorted_empty ( ) { Iterable < Iterable < Integer > > elements = ImmutableList . of ( ) ; Iterable < Integer > iterable = Iterables . mergeSorted ( elements , Ordering . natural ( ) ) ; Iterator < Integer > iterator = iterable . iterator ( ) ; assertFalse ( iterator . hasNext ( ) ) ; try { iterator . next ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException e ) { } } public void testMergeSorted_single_empty ( ) { Iterable < Integer > iterable0 = ImmutableList . of ( ) ; Iterable < Iterable < Integer > > iterables = ImmutableList . of ( iterable0 ) ; verifyMergeSorted ( iterables , ImmutableList . < Integer > of ( ) ) ; } public void testMergeSorted_single ( ) { Iterable < Integer > iterable0 = ImmutableList . of ( <int> , <int> , <int> ) ; Iterable < Iterable < Integer > > iterables = ImmutableList . of ( iterable0 ) ; verifyMergeSorted ( iterables , iterable0 ) ; } public void testMergeSorted_pyramid ( ) { List < Iterable < Integer > > iterables = Lists . newLinkedList ( ) ; List < Integer > allIntegers = Lists . newArrayList ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { List < Integer > list = Lists . newLinkedList ( ) ; for ( int j = <int> ; j < i ; j + + ) { list . add ( j ) ; allIntegers . add ( j ) ; } iterables . add ( Ordering . natural ( ) . sortedCopy ( list ) ) ; } verifyMergeSorted ( iterables , allIntegers ) ; } public void testMergeSorted_skipping_pyramid ( ) { List < Iterable < Integer > > iterables = Lists . newLinkedList ( ) ; List < Integer > allIntegers = Lists . newArrayList ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { List < Integer > list = Lists . newLinkedList ( ) ; for ( int j = <int> ; j < i ; j + + ) { list . add ( j * i ) ; allIntegers . add ( j * i ) ; } iterables . add ( Ordering . natural ( ) . sortedCopy ( list ) ) ; } verifyMergeSorted ( iterables , allIntegers ) ; } @GwtIncompatible ( <str> ) public void testIterables_nullCheck ( ) throws Exception { new ClassSanityTester ( ) . forAllPublicStaticMethods ( Iterables . class ) . thatReturn ( Iterable . class ) . testNulls ( ) ; } private static void verifyMergeSorted ( Iterable < Iterable < Integer > > iterables , Iterable < Integer > unsortedExpected ) { Iterable < Integer > expected = Ordering . natural ( ) . sortedCopy ( unsortedExpected ) ; Iterable < Integer > mergedIterator = Iterables . mergeSorted ( iterables , Ordering . natural ( ) ) ; assertEquals ( Lists . newLinkedList ( expected ) , Lists . newLinkedList ( mergedIterator ) ) ; } } 
