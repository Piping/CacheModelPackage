package org . apache . cassandra . db . compaction ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . TimeUnit ; import org . junit . BeforeClass ; import org . junit . Test ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . Pair ; import static org . apache . cassandra . db . compaction . DateTieredCompactionStrategy . getBuckets ; import static org . apache . cassandra . db . compaction . DateTieredCompactionStrategy . newestBucket ; import static org . apache . cassandra . db . compaction . DateTieredCompactionStrategy . filterOldSSTables ; import static org . apache . cassandra . db . compaction . DateTieredCompactionStrategy . validateOptions ; import static org . junit . Assert . * ; public class DateTieredCompactionStrategyTest extends SchemaLoader { public static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) ) ; } @Test public void testOptionsValidation ( ) throws ConfigurationException { Map < String , String > options = new HashMap < > ( ) ; options . put ( DateTieredCompactionStrategyOptions . BASE_TIME_KEY , <str> ) ; options . put ( DateTieredCompactionStrategyOptions . MAX_SSTABLE_AGE_KEY , <str> ) ; Map < String , String > unvalidated = validateOptions ( options ) ; assertTrue ( unvalidated . isEmpty ( ) ) ; try { options . put ( DateTieredCompactionStrategyOptions . BASE_TIME_KEY , <str> ) ; validateOptions ( options ) ; fail ( String . format ( <str> , DateTieredCompactionStrategyOptions . BASE_TIME_KEY ) ) ; } catch ( ConfigurationException e ) { } try { options . put ( DateTieredCompactionStrategyOptions . BASE_TIME_KEY , <str> ) ; validateOptions ( options ) ; fail ( String . format ( <str> , DateTieredCompactionStrategyOptions . BASE_TIME_KEY ) ) ; } catch ( ConfigurationException e ) { options . put ( DateTieredCompactionStrategyOptions . BASE_TIME_KEY , <str> ) ; } try { options . put ( DateTieredCompactionStrategyOptions . MAX_SSTABLE_AGE_KEY , <str> ) ; validateOptions ( options ) ; fail ( String . format ( <str> , DateTieredCompactionStrategyOptions . MAX_SSTABLE_AGE_KEY ) ) ; } catch ( ConfigurationException e ) { options . put ( DateTieredCompactionStrategyOptions . MAX_SSTABLE_AGE_KEY , <str> ) ; } try { options . put ( DateTieredCompactionStrategyOptions . MAX_WINDOW_SIZE_KEY , <str> ) ; validateOptions ( options ) ; fail ( String . format ( <str> , DateTieredCompactionStrategyOptions . MAX_WINDOW_SIZE_KEY ) ) ; } catch ( ConfigurationException e ) { options . put ( DateTieredCompactionStrategyOptions . MAX_WINDOW_SIZE_KEY , <str> ) ; } options . put ( <str> , <str> ) ; unvalidated = validateOptions ( options ) ; assertTrue ( unvalidated . containsKey ( <str> ) ) ; } @Test public void testTimeConversions ( ) { Map < String , String > options = new HashMap < > ( ) ; options . put ( DateTieredCompactionStrategyOptions . BASE_TIME_KEY , <str> ) ; options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP_RESOLUTION_KEY , <str> ) ; DateTieredCompactionStrategyOptions opts = new DateTieredCompactionStrategyOptions ( options ) ; assertEquals ( opts . maxSSTableAge , TimeUnit . SECONDS . convert ( <int> * <int> , TimeUnit . DAYS ) ) ; options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP_RESOLUTION_KEY , <str> ) ; opts = new DateTieredCompactionStrategyOptions ( options ) ; assertEquals ( opts . maxSSTableAge , TimeUnit . MILLISECONDS . convert ( <int> * <int> , TimeUnit . DAYS ) ) ; options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP_RESOLUTION_KEY , <str> ) ; options . put ( DateTieredCompactionStrategyOptions . MAX_SSTABLE_AGE_KEY , <str> ) ; opts = new DateTieredCompactionStrategyOptions ( options ) ; assertEquals ( opts . maxSSTableAge , TimeUnit . MICROSECONDS . convert ( <int> , TimeUnit . DAYS ) ) ; options . put ( DateTieredCompactionStrategyOptions . MAX_SSTABLE_AGE_KEY , <str> ) ; opts = new DateTieredCompactionStrategyOptions ( options ) ; assertEquals ( opts . maxSSTableAge , TimeUnit . MICROSECONDS . convert ( <int> , TimeUnit . DAYS ) / <int> ) ; options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP_RESOLUTION_KEY , <str> ) ; options . put ( DateTieredCompactionStrategyOptions . MAX_SSTABLE_AGE_KEY , <str> ) ; opts = new DateTieredCompactionStrategyOptions ( options ) ; assertEquals ( opts . maxSSTableAge , <int> ) ; } @Test public void testGetBuckets ( ) { List < Pair < String , Long > > pairs = Lists . newArrayList ( Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) ) ; List < List < String > > buckets = getBuckets ( pairs , <int> , <int> , <int> , Long . MAX_VALUE ) ; assertEquals ( <int> , buckets . size ( ) ) ; for ( List < String > bucket : buckets ) { assertEquals ( <int> , bucket . size ( ) ) ; assertEquals ( bucket . get ( <int> ) , bucket . get ( <int> ) ) ; } pairs = Lists . newArrayList ( Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) ) ; buckets = getBuckets ( pairs , <int> , <int> , <int> , Long . MAX_VALUE ) ; assertEquals ( <int> , buckets . size ( ) ) ; for ( List < String > bucket : buckets ) { assertEquals ( <int> , bucket . size ( ) ) ; assertEquals ( bucket . get ( <int> ) , bucket . get ( <int> ) ) ; } pairs = Lists . newArrayList ( Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) , Pair . create ( <str> , <int> ) ) ; buckets = getBuckets ( pairs , <int> , <int> , <int> , Long . MAX_VALUE ) ; assertEquals ( <int> , buckets . size ( ) ) ; for ( List < String > bucket : buckets ) { assertEquals ( <int> , bucket . size ( ) ) ; assertEquals ( bucket . get ( <int> ) , bucket . get ( <int> ) ) ; } } @Test public void testPrepBucket ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD1 ) ; cfs . disableAutoCompaction ( ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> ] ) ; int numSSTables = <int> ; for ( int r = <int> ; r < numSSTables ; r + + ) { DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; new RowUpdateBuilder ( cfs . metadata , r , key . getKey ( ) ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } cfs . forceBlockingFlush ( ) ; List < SSTableReader > sstrs = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; List < SSTableReader > newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( <int> , <int> ) ) , <int> , <int> , <int> , <int> , Long . MAX_VALUE , new SizeTieredCompactionStrategyOptions ( ) ) ; assertTrue ( <str> , newBucket . isEmpty ( ) ) ; newBucket = newestBucket ( Collections . singletonList ( sstrs . subList ( <int> , <int> ) ) , <int> , <int> , <int> , <int> , Long . MAX_VALUE , new SizeTieredCompactionStrategyOptions ( ) ) ; assertFalse ( <str> , newBucket . isEmpty ( ) ) ; assertEquals ( <str> , sstrs . get ( <int> ) . getMinTimestamp ( ) , sstrs . get ( <int> ) . getMaxTimestamp ( ) ) ; assertEquals ( <str> , sstrs . get ( <int> ) . getMinTimestamp ( ) , sstrs . get ( <int> ) . getMaxTimestamp ( ) ) ; assertEquals ( <str> , sstrs . get ( <int> ) . getMinTimestamp ( ) , sstrs . get ( <int> ) . getMaxTimestamp ( ) ) ; cfs . truncateBlocking ( ) ; } @Test public void testFilterOldSSTables ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD1 ) ; cfs . disableAutoCompaction ( ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> ] ) ; int numSSTables = <int> ; for ( int r = <int> ; r < numSSTables ; r + + ) { DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; new RowUpdateBuilder ( cfs . metadata , r , key . getKey ( ) ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } cfs . forceBlockingFlush ( ) ; Iterable < SSTableReader > filtered ; List < SSTableReader > sstrs = new ArrayList < > ( cfs . getLiveSSTables ( ) ) ; filtered = filterOldSSTables ( sstrs , <int> , <int> ) ; assertEquals ( <str> , sstrs . size ( ) , Iterables . size ( filtered ) ) ; filtered = filterOldSSTables ( sstrs , <int> , <int> ) ; assertEquals ( <str> , <int> , Iterables . size ( filtered ) ) ; filtered = filterOldSSTables ( sstrs , <int> , <int> ) ; assertEquals ( <str> , <int> , Iterables . size ( filtered ) ) ; filtered = filterOldSSTables ( sstrs , <int> , <int> ) ; assertEquals ( <str> , <int> , Iterables . size ( filtered ) ) ; cfs . truncateBlocking ( ) ; } @Test public void testDropExpiredSSTables ( ) throws InterruptedException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD1 ) ; cfs . disableAutoCompaction ( ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> ] ) ; DecoratedKey key = Util . dk ( String . valueOf ( <str> ) ) ; new RowUpdateBuilder ( cfs . metadata , System . currentTimeMillis ( ) , <int> , key . getKey ( ) ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; SSTableReader expiredSSTable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; Thread . sleep ( <int> ) ; key = Util . dk ( String . valueOf ( <str> ) ) ; new RowUpdateBuilder ( cfs . metadata , System . currentTimeMillis ( ) , key . getKey ( ) ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; assertEquals ( cfs . getLiveSSTables ( ) . size ( ) , <int> ) ; Map < String , String > options = new HashMap < > ( ) ; options . put ( DateTieredCompactionStrategyOptions . BASE_TIME_KEY , <str> ) ; options . put ( DateTieredCompactionStrategyOptions . TIMESTAMP_RESOLUTION_KEY , <str> ) ; options . put ( DateTieredCompactionStrategyOptions . MAX_SSTABLE_AGE_KEY , Double . toString ( ( <float> / ( <int> * <int> * <int> ) ) ) ) ; options . put ( DateTieredCompactionStrategyOptions . EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_KEY , <str> ) ; DateTieredCompactionStrategy dtcs = new DateTieredCompactionStrategy ( cfs , options ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) dtcs . addSSTable ( sstable ) ; dtcs . startup ( ) ; assertNull ( dtcs . getNextBackgroundTask ( ( int ) ( System . currentTimeMillis ( ) / <int> ) ) ) ; Thread . sleep ( <int> ) ; AbstractCompactionTask t = dtcs . getNextBackgroundTask ( ( int ) ( System . currentTimeMillis ( ) / <int> ) ) ; assertNotNull ( t ) ; assertEquals ( <int> , Iterables . size ( t . transaction . originals ( ) ) ) ; SSTableReader sstable = t . transaction . originals ( ) . iterator ( ) . next ( ) ; assertEquals ( sstable , expiredSSTable ) ; t . transaction . abort ( ) ; cfs . truncateBlocking ( ) ; } @Test public void testSTCSBigWindow ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD1 ) ; cfs . disableAutoCompaction ( ) ; ByteBuffer bigValue = ByteBuffer . wrap ( new byte [ <int> ] ) ; ByteBuffer value = ByteBuffer . wrap ( new byte [ <int> ] ) ; int numSSTables = <int> ; long timestamp = System . currentTimeMillis ( ) ; for ( int r = <int> ; r < numSSTables / <int> ; r + + ) { for ( int i = <int> ; i < <int> ; i + + ) { DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; new RowUpdateBuilder ( cfs . metadata , timestamp , key . getKey ( ) ) . clustering ( <str> ) . add ( <str> , bigValue ) . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; } for ( int r = <int> ; r < numSSTables / <int> ; r + + ) { DecoratedKey key = Util . dk ( String . valueOf ( r ) ) ; new RowUpdateBuilder ( cfs . metadata , timestamp , key . getKey ( ) ) . clustering ( <str> ) . add ( <str> , value ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } Map < String , String > options = new HashMap < > ( ) ; options . put ( SizeTieredCompactionStrategyOptions . MIN_SSTABLE_SIZE_KEY , <str> ) ; DateTieredCompactionStrategy dtcs = new DateTieredCompactionStrategy ( cfs , options ) ; for ( SSTableReader sstable : cfs . getSSTables ( SSTableSet . CANONICAL ) ) dtcs . addSSTable ( sstable ) ; AbstractCompactionTask task = dtcs . getNextBackgroundTask ( <int> ) ; assertEquals ( <int> , task . transaction . originals ( ) . size ( ) ) ; task . transaction . abort ( ) ; } } 
