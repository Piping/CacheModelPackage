package org . eclipse . debug . internal . ui . viewers . model ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IColumnPresentation ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IColumnPresentationFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelChangedListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelSelectionPolicy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStateUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IVirtualItemListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IVirtualItemValidator ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . PresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . VirtualItem ; import org . eclipse . debug . internal . ui . viewers . model . provisional . VirtualItem . Index ; import org . eclipse . debug . internal . ui . viewers . model . provisional . VirtualTree ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ITreeSelection ; import org . eclipse . jface . viewers . SelectionChangedEvent ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . jface . viewers . ViewerLabel ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IMemento ; @SuppressWarnings ( <str> ) public class InternalVirtualTreeModelViewer extends Viewer implements IVirtualItemListener , org . eclipse . debug . internal . ui . viewers . model . ITreeModelViewer , IInternalTreeModelViewer { private static final String VISIBLE_COLUMNS = <str> ; private static final String SHOW_COLUMNS = <str> ; private static final String SIZE = <str> ; private static final String COLUMN = <str> ; private static final String TREE_PATH_KEY = <str> ; private ViewerFilter [ ] fFilters = new ViewerFilter [ <int> ] ; private Display fDisplay ; private IPresentationContext fContext ; private Object fInput ; private VirtualTree fTree ; private Map < Object , List < VirtualItem > > fItemsMap = new HashMap < Object , List < VirtualItem > > ( ) ; private boolean fNotifyUnmap = true ; private TreeModelLabelProvider fLabelProvider ; private TreeModelContentProvider fContentProvider ; private boolean fPreservingSelecction ; private boolean fRestoreSelection ; private int fAutoExpandToLevel = <int> ; private IColumnPresentation fColumnPresentation = null ; private Map < String , String [ ] > fVisibleColumns = new HashMap < String , String [ ] > ( ) ; private Map < String , Boolean > fShowColumns = new HashMap < String , Boolean > ( ) ; private Runnable fValidateRunnable ; public InternalVirtualTreeModelViewer ( Display display , int style , IPresentationContext context , IVirtualItemValidator itemValidator ) { fDisplay = display ; fContext = context ; fTree = new VirtualTree ( style , itemValidator ) ; fTree . addItemListener ( this ) ; fContentProvider = new TreeModelContentProvider ( ) ; fLabelProvider = new TreeModelLabelProvider ( this ) ; if ( ( style & SWT . POP_UP ) ! = <int> ) { getContentProvider ( ) . setModelDeltaMask ( ~ ITreeModelContentProvider . CONTROL_MODEL_DELTA_FLAGS ) ; } } @Override public Object getInput ( ) { return fInput ; } @Override public Control getControl ( ) { return null ; } @Override public Display getDisplay ( ) { return fDisplay ; } @Override public void setInput ( Object input ) { Object oldInput = fInput ; getContentProvider ( ) . inputChanged ( this , oldInput , input ) ; fItemsMap . clear ( ) ; fTree . clearAll ( ) ; fInput = input ; mapElement ( fInput , getTree ( ) ) ; getContentProvider ( ) . postInputChanged ( this , oldInput , input ) ; fTree . setData ( fInput ) ; fTree . setSelection ( EMPTY_ITEMS_ARRAY ) ; inputChanged ( fInput , oldInput ) ; refresh ( ) ; } @Override public void replace ( Object parentElementOrTreePath , final int index , Object element ) { VirtualItem [ ] selectedItems = fTree . getSelection ( ) ; TreeSelection selection = ( TreeSelection ) getSelection ( ) ; VirtualItem [ ] itemsToDisassociate ; if ( parentElementOrTreePath instanceof TreePath ) { TreePath elementPath = ( ( TreePath ) parentElementOrTreePath ) . createChildPath ( element ) ; itemsToDisassociate = findItems ( elementPath ) ; } else { itemsToDisassociate = findItems ( element ) ; } VirtualItem [ ] parentItems = findItems ( parentElementOrTreePath ) ; for ( int i = <int> ; i < parentItems . length ; i + + ) { VirtualItem parentItem = parentItems [ i ] ; if ( index < parentItem . getItemCount ( ) ) { VirtualItem item = parentItem . getItem ( new Index ( index ) ) ; selection = adjustSelectionForReplace ( selectedItems , selection , item , element , parentItem . getData ( ) ) ; for ( int j = <int> ; j < itemsToDisassociate . length ; j + + ) { VirtualItem itemToDisassociate = itemsToDisassociate [ j ] ; if ( itemToDisassociate ! = item & & itemsToDisassociate [ j ] . getParent ( ) = = parentItem ) { disassociate ( itemToDisassociate ) ; itemToDisassociate . getParent ( ) . clear ( itemToDisassociate . getIndex ( ) ) ; } } associate ( element , item ) ; doUpdate ( item ) ; VirtualItem [ ] children = item . getItems ( ) ; for ( int j = <int> ; j < children . length ; j + + ) { children [ j ] . setNeedsDataUpdate ( ) ; } } } if ( ! fPreservingSelecction ) { internalSetSelection ( selection , false ) ; ISelection newSelection = getSelection ( ) ; if ( ! newSelection . equals ( selection ) ) { handleInvalidSelection ( selection , newSelection ) ; } } validate ( ) ; } public VirtualTree getTree ( ) { return fTree ; } @Override public void insert ( Object parentOrTreePath , Object element , int position ) { if ( parentOrTreePath instanceof TreePath ) { VirtualItem parentItem = findItem ( ( TreePath ) parentOrTreePath ) ; if ( parentItem ! = null ) { VirtualItem item = parentItem . addItem ( position ) ; item . setData ( element ) ; mapElement ( element , item ) ; doUpdate ( item ) ; } } else { } validate ( ) ; } @Override public void remove ( final Object parentOrTreePath , final int index ) { final List < TreePath > oldSelection = new LinkedList < TreePath > ( Arrays . asList ( ( ( TreeSelection ) getSelection ( ) ) . getPaths ( ) ) ) ; preservingSelection ( new Runnable ( ) { @Override public void run ( ) { TreePath removedPath = null ; VirtualItem [ ] parentItems = findItems ( parentOrTreePath ) ; for ( int i = <int> ; i < parentItems . length ; i + + ) { VirtualItem parentItem = parentItems [ i ] ; if ( parentItem . isDisposed ( ) ) { continue ; } if ( ! parentItem . getExpanded ( ) ) { parentItem . setNeedsCountUpdate ( ) ; parentItem . setItemCount ( - <int> ) ; virtualLazyUpdateHasChildren ( parentItem ) ; } if ( index < parentItem . getItemCount ( ) ) { VirtualItem item = parentItem . getItem ( new VirtualItem . Index ( index ) ) ; if ( item . getData ( ) ! = null ) { removedPath = getTreePathFromItem ( item ) ; disassociate ( item ) ; } parentItem . remove ( item . getIndex ( ) ) ; } } if ( removedPath ! = null ) { boolean removed = false ; for ( Iterator < TreePath > it = oldSelection . iterator ( ) ; it . hasNext ( ) ; ) { TreePath path = it . next ( ) ; if ( path . startsWith ( removedPath , null ) ) { it . remove ( ) ; removed = true ; } } if ( removed ) { setSelection ( new TreeSelection ( oldSelection . toArray ( new TreePath [ oldSelection . size ( ) ] ) ) , false ) ; } } } } ) ; } @Override public void remove ( Object elementOrPath ) { if ( elementOrPath . equals ( getInput ( ) ) | | TreePath . EMPTY . equals ( elementOrPath ) ) { setInput ( null ) ; return ; } VirtualItem [ ] items = findItems ( elementOrPath ) ; if ( items . length > <int> ) { for ( int j = <int> ; j < items . length ; j + + ) { disassociate ( items [ j ] ) ; items [ j ] . getParent ( ) . remove ( items [ j ] . getIndex ( ) ) ; } } } private TreeSelection adjustSelectionForReplace ( VirtualItem [ ] selectedItems , TreeSelection selection , VirtualItem item , Object element , Object parentElement ) { if ( item . getData ( ) ! = null | | selectedItems . length = = selection . size ( ) | | parentElement = = null ) { return selection ; } for ( int i = <int> ; i < selectedItems . length ; i + + ) { if ( item = = selectedItems [ i ] ) { TreePath [ ] originalPaths = selection . getPaths ( ) ; int length = originalPaths . length ; TreePath [ ] paths = new TreePath [ length + <int> ] ; System . arraycopy ( originalPaths , <int> , paths , <int> , length ) ; item . setData ( element ) ; paths [ length ] = getTreePathFromItem ( item ) ; item . setData ( null ) ; return new TreeSelection ( paths , selection . getElementComparer ( ) ) ; } } return selection ; } @Override public void reveal ( TreePath path , final int index ) { VirtualItem parentItem = findItem ( path ) ; if ( parentItem ! = null & & parentItem . getItemCount ( ) > = index ) { VirtualItem revealItem = parentItem . getItem ( new Index ( index ) ) ; getTree ( ) . showItem ( revealItem ) ; getTree ( ) . validate ( ) ; } } @Override public int findElementIndex ( TreePath parentPath , Object element ) { VirtualItem parentItem = findItem ( parentPath ) ; if ( parentItem ! = null ) { VirtualItem item = parentItem . findItem ( element ) ; if ( item ! = null ) { return item . getIndex ( ) . intValue ( ) ; } } return - <int> ; } @Override public boolean getElementChildrenRealized ( TreePath parentPath ) { VirtualItem parentItem = findItem ( parentPath ) ; if ( parentItem ! = null ) { return ! parentItem . childrenNeedDataUpdate ( ) ; } return true ; } private ITreeModelLabelProvider getLabelProvider ( ) { return fLabelProvider ; } private ITreeModelContentProvider getContentProvider ( ) { return fContentProvider ; } public static int ALL_LEVELS = - <int> ; @Override public void refresh ( ) { refresh ( fTree ) ; validate ( ) ; } @Override public void refresh ( Object element ) { VirtualItem [ ] items = findItems ( element ) ; for ( int i = <int> ; i < items . length ; i + + ) { refresh ( items [ i ] ) ; validate ( ) ; } } private void refresh ( VirtualItem item ) { getContentProvider ( ) . preserveState ( getTreePathFromItem ( item ) ) ; if ( ! item . needsDataUpdate ( ) ) { if ( item . getParent ( ) ! = null ) { item . setNeedsLabelUpdate ( ) ; virtualLazyUpdateHasChildren ( item ) ; } VirtualItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { items [ i ] . setNeedsDataUpdate ( ) ; } } refreshStruct ( item ) ; } private void refreshStruct ( VirtualItem item ) { boolean expanded = false ; if ( item . getParent ( ) = = null ) { virtualLazyUpdateChildCount ( item ) ; expanded = true ; } else { if ( item . getExpanded ( ) ) { virtualLazyUpdateData ( item ) ; expanded = true ; } } VirtualItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { if ( expanded ) { refreshStruct ( items [ i ] ) ; } else { item . clear ( new VirtualItem . Index ( i ) ) ; } } } private void validate ( ) { if ( fValidateRunnable = = null ) { fValidateRunnable = new Runnable ( ) { @Override public void run ( ) { if ( ! fTree . isDisposed ( ) ) { fValidateRunnable = null ; fTree . validate ( ) ; } } } ; getDisplay ( ) . asyncExec ( fValidateRunnable ) ; } } @Override protected void inputChanged ( Object input , Object oldInput ) { resetColumns ( input ) ; } @Override public int getAutoExpandLevel ( ) { return fAutoExpandToLevel ; } @Override public void setAutoExpandLevel ( int level ) { fAutoExpandToLevel = level ; } public VirtualItem findItem ( TreePath path ) { if ( path . getSegmentCount ( ) = = <int> ) { return fTree ; } List < VirtualItem > itemsList = fItemsMap . get ( path . getLastSegment ( ) ) ; if ( itemsList ! = null ) { for ( VirtualItem item : itemsList ) { if ( path . equals ( getTreePathFromItem ( item ) ) ) { return item ; } } } return null ; } static private final VirtualItem [ ] EMPTY_ITEMS_ARRAY = new VirtualItem [ <int> ] ; public VirtualItem [ ] findItems ( Object elementOrTreePath ) { Object element = elementOrTreePath ; if ( elementOrTreePath instanceof TreePath ) { TreePath path = ( TreePath ) elementOrTreePath ; if ( path . getSegmentCount ( ) = = <int> ) { return new VirtualItem [ ] { getTree ( ) } ; } element = path . getLastSegment ( ) ; } List < VirtualItem > itemsList = fItemsMap . get ( element ) ; if ( itemsList = = null ) { return EMPTY_ITEMS_ARRAY ; } else { return itemsList . toArray ( new VirtualItem [ itemsList . size ( ) ] ) ; } } @Override public void setElementData ( TreePath path , int numColumns , String [ ] labels , ImageDescriptor [ ] images , FontData [ ] fontDatas , RGB [ ] foregrounds , RGB [ ] backgrounds ) { VirtualItem item = findItem ( path ) ; if ( item ! = null ) { item . setData ( VirtualItem . LABEL_KEY , labels ) ; item . setData ( VirtualItem . IMAGE_KEY , images ) ; item . setData ( VirtualItem . FOREGROUND_KEY , foregrounds ) ; item . setData ( VirtualItem . BACKGROUND_KEY , backgrounds ) ; item . setData ( VirtualItem . FONT_KEY , fontDatas ) ; } } @Override public void setChildCount ( final Object elementOrTreePath , final int count ) { preservingSelection ( new Runnable ( ) { @Override public void run ( ) { VirtualItem [ ] items = findItems ( elementOrTreePath ) ; for ( int i = <int> ; i < items . length ; i + + ) { VirtualItem [ ] children = items [ i ] . getItems ( ) ; for ( int j = <int> ; j < children . length ; j + + ) { if ( children [ j ] . getData ( ) ! = null & & children [ j ] . getIndex ( ) . intValue ( ) > = count ) { disassociate ( children [ j ] ) ; } } items [ i ] . setItemCount ( count ) ; } } } ) ; validate ( ) ; } @Override public void setHasChildren ( final Object elementOrTreePath , final boolean hasChildren ) { preservingSelection ( new Runnable ( ) { @Override public void run ( ) { VirtualItem [ ] items = findItems ( elementOrTreePath ) ; for ( int i = <int> ; i < items . length ; i + + ) { VirtualItem item = items [ i ] ; if ( ! hasChildren ) { VirtualItem [ ] children = item . getItems ( ) ; for ( int j = <int> ; j < children . length ; j + + ) { if ( children [ j ] . getData ( ) ! = null ) { disassociate ( children [ j ] ) ; } } } item . setHasItems ( hasChildren ) ; if ( hasChildren ) { if ( ! item . getExpanded ( ) ) { item . setItemCount ( - <int> ) ; } else { virtualLazyUpdateChildCount ( item ) ; } } } } } ) ; } @Override public boolean getHasChildren ( Object elementOrTreePath ) { VirtualItem [ ] items = findItems ( elementOrTreePath ) ; if ( items . length > <int> ) { return items [ <int> ] . hasItems ( ) ; } return false ; } private void virtualLazyUpdateHasChildren ( VirtualItem item ) { TreePath treePath ; treePath = getTreePathFromItem ( item ) ; item . clearNeedsCountUpdate ( ) ; getContentProvider ( ) . updateHasChildren ( treePath ) ; } private void virtualLazyUpdateChildCount ( VirtualItem item ) { item . clearNeedsCountUpdate ( ) ; getContentProvider ( ) . updateChildCount ( getTreePathFromItem ( item ) , item . getItemCount ( ) ) ; } private void virtualLazyUpdateData ( VirtualItem item ) { item . clearNeedsDataUpdate ( ) ; getContentProvider ( ) . updateElement ( getTreePathFromItem ( item . getParent ( ) ) , item . getIndex ( ) . intValue ( ) ) ; } private void virtualLazyUpdateLabel ( VirtualItem item ) { item . clearNeedsLabelUpdate ( ) ; if ( ! getLabelProvider ( ) . update ( getTreePathFromItem ( item ) ) ) { if ( item . getData ( ) instanceof String ) { item . setData ( VirtualItem . LABEL_KEY , new String [ ] { ( String ) item . getData ( ) } ) ; } } } private TreePath getTreePathFromItem ( VirtualItem item ) { List < Object > segments = new LinkedList < Object > ( ) ; while ( item . getParent ( ) ! = null ) { segments . add ( <int> , item . getData ( ) ) ; item = item . getParent ( ) ; } return new TreePath ( segments . toArray ( ) ) ; } private void unmapElement ( Object element , VirtualItem item ) { if ( fNotifyUnmap ) { IContentProvider provider = getContentProvider ( ) ; if ( provider instanceof TreeModelContentProvider ) { ( ( TreeModelContentProvider ) provider ) . unmapPath ( ( TreePath ) item . getData ( TREE_PATH_KEY ) ) ; } } List < VirtualItem > itemsList = fItemsMap . get ( element ) ; if ( itemsList ! = null ) { itemsList . remove ( item ) ; if ( itemsList . isEmpty ( ) ) { fItemsMap . remove ( element ) ; } } } private void mapElement ( Object element , VirtualItem item ) { List < VirtualItem > itemsList = fItemsMap . remove ( element ) ; if ( itemsList = = null ) { itemsList = new ArrayList < VirtualItem > ( <int> ) ; } if ( ! itemsList . contains ( item ) ) { itemsList . add ( item ) ; } fItemsMap . put ( element , itemsList ) ; item . setData ( TREE_PATH_KEY , getTreePathFromItem ( item ) ) ; } @Override public void revealed ( VirtualItem item ) { if ( item . needsDataUpdate ( ) ) { virtualLazyUpdateData ( item ) ; } else if ( item . getData ( ) ! = null ) { if ( item . needsLabelUpdate ( ) ) { virtualLazyUpdateLabel ( item ) ; } if ( item . needsCountUpdate ( ) & & item . getExpanded ( ) ) { virtualLazyUpdateChildCount ( item ) ; } } } @Override public void disposed ( VirtualItem item ) { if ( ! fTree . isDisposed ( ) ) { Object data = item . getData ( ) ; if ( data ! = null ) { unmapElement ( data , item ) ; } } } private void associate ( Object element , VirtualItem item ) { Object data = item . getData ( ) ; if ( data ! = null & & data ! = element & & data . equals ( element ) ) { try { fNotifyUnmap = false ; doAssociate ( element , item ) ; } finally { fNotifyUnmap = true ; } } else { doAssociate ( element , item ) ; } } private void doAssociate ( Object element , VirtualItem item ) { Object data = item . getData ( ) ; if ( data ! = null & & data ! = element & & data . equals ( element ) ) { unmapElement ( data , item ) ; item . setData ( element ) ; mapElement ( element , item ) ; } else { if ( data ! = element ) { if ( data ! = null ) { unmapElement ( element , item ) ; disassociate ( item ) ; } item . setData ( element ) ; } mapElement ( element , item ) ; } } private void disassociate ( VirtualItem item ) { unmapElement ( item . getData ( ) , item ) ; item . setData ( null ) ; VirtualItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { if ( items [ i ] . getData ( ) ! = null ) { disassociate ( items [ i ] ) ; } } } @Override public void setSelection ( ISelection selection , boolean reveal ) { setSelection ( selection , reveal , false ) ; } @Override public void setSelection ( ISelection selection , boolean reveal , boolean force ) { trySelection ( selection , reveal , force ) ; } @Override public boolean trySelection ( ISelection selection , boolean reveal , boolean force ) { if ( ! force & & ! overrideSelection ( getSelection ( ) , selection ) ) { return false ; } if ( ! fPreservingSelecction ) { internalSetSelection ( selection , reveal ) ; fireSelectionChanged ( new SelectionChangedEvent ( this , selection ) ) ; } else { fRestoreSelection = false ; internalSetSelection ( selection , reveal ) ; } return true ; } private void internalSetSelection ( ISelection selection , boolean reveal ) { if ( selection instanceof ITreeSelection ) { TreePath [ ] paths = ( ( ITreeSelection ) selection ) . getPaths ( ) ; List < VirtualItem > newSelection = new ArrayList < VirtualItem > ( paths . length ) ; for ( int i = <int> ; i < paths . length ; + + i ) { VirtualItem item = findItem ( paths [ i ] ) ; if ( item ! = null ) { newSelection . add ( item ) ; } } fTree . setSelection ( newSelection . toArray ( new VirtualItem [ newSelection . size ( ) ] ) ) ; if ( reveal & & newSelection . size ( ) > <int> ) { for ( int i = ( newSelection . size ( ) - <int> ) ; i > = <int> ; i - - ) { fTree . showItem ( newSelection . get ( i ) ) ; } } } else { fTree . setSelection ( EMPTY_ITEMS_ARRAY ) ; } validate ( ) ; } @Override public void update ( Object element ) { VirtualItem [ ] items = findItems ( element ) ; for ( int i = <int> ; i < items . length ; i + + ) { doUpdate ( items [ i ] ) ; } } public void doUpdate ( VirtualItem item ) { item . setNeedsLabelUpdate ( ) ; validate ( ) ; } @Override public ISelection getSelection ( ) { if ( fTree . isDisposed ( ) ) { return TreeSelection . EMPTY ; } VirtualItem [ ] items = fTree . getSelection ( ) ; ArrayList < TreePath > list = new ArrayList < TreePath > ( items . length ) ; Map < VirtualItem , TreePath > map = new LinkedHashMap < VirtualItem , TreePath > ( items . length * <int> / <int> ) ; for ( int i = <int> ; i < items . length ; i + + ) { TreePath path = null ; if ( items [ i ] . getData ( ) ! = null ) { path = getTreePathFromItem ( items [ i ] ) ; list . add ( path ) ; } map . put ( items [ i ] , path ) ; } return new TreeSelection ( list . toArray ( new TreePath [ list . size ( ) ] ) ) ; } private void preservingSelection ( Runnable updateCode ) { ISelection oldSelection = null ; try { oldSelection = getSelection ( ) ; fPreservingSelecction = fRestoreSelection = true ; updateCode . run ( ) ; } finally { fPreservingSelecction = false ; if ( fRestoreSelection ) { internalSetSelection ( oldSelection , false ) ; } ISelection newSelection = getSelection ( ) ; if ( ! newSelection . equals ( oldSelection ) ) { handleInvalidSelection ( oldSelection , newSelection ) ; } } } @Override public void expandToLevel ( Object elementOrTreePath , int level ) { VirtualItem [ ] items = findItems ( elementOrTreePath ) ; if ( items . length > <int> ) { expandToLevel ( items [ <int> ] , level ) ; } validate ( ) ; } @Override public void setExpandedState ( Object elementOrTreePath , boolean expanded ) { VirtualItem [ ] items = findItems ( elementOrTreePath ) ; for ( int i = <int> ; i < items . length ; i + + ) { items [ i ] . setExpanded ( expanded ) ; } validate ( ) ; } @Override public boolean getExpandedState ( Object elementOrTreePath ) { VirtualItem [ ] items = findItems ( elementOrTreePath ) ; if ( items . length > <int> ) { return items [ <int> ] . getExpanded ( ) ; } return false ; } private void expandToLevel ( VirtualItem item , int level ) { if ( level = = ALL_LEVELS | | level > <int> ) { if ( ! item . hasItems ( ) ) { return ; } item . setExpanded ( true ) ; if ( item . getData ( ) = = null ) { virtualLazyUpdateData ( item ) ; return ; } if ( level = = ALL_LEVELS | | level > <int> ) { VirtualItem [ ] children = item . getItems ( ) ; int newLevel = ( level = = ALL_LEVELS ? ALL_LEVELS : level - <int> ) ; for ( int i = <int> ; i < children . length ; i + + ) { expandToLevel ( children [ i ] , newLevel ) ; } } } } private void handleInvalidSelection ( ISelection selection , ISelection newSelection ) { IModelSelectionPolicy selectionPolicy = ViewerAdapterService . getSelectionPolicy ( selection , getPresentationContext ( ) ) ; if ( selectionPolicy ! = null ) { while ( ! selection . equals ( newSelection ) ) { ISelection temp = newSelection ; selection = selectionPolicy . replaceInvalidSelection ( selection , newSelection ) ; if ( selection = = null ) { selection = TreeSelection . EMPTY ; } if ( ! temp . equals ( selection ) ) { internalSetSelection ( selection , false ) ; newSelection = getSelection ( ) ; } else { break ; } } } fireSelectionChanged ( new SelectionChangedEvent ( this , newSelection ) ) ; } @Override public boolean overrideSelection ( ISelection current , ISelection candidate ) { IModelSelectionPolicy selectionPolicy = ViewerAdapterService . getSelectionPolicy ( current , getPresentationContext ( ) ) ; if ( selectionPolicy = = null ) { return true ; } if ( selectionPolicy . contains ( candidate , getPresentationContext ( ) ) ) { return selectionPolicy . overrides ( current , candidate , getPresentationContext ( ) ) ; } return ! selectionPolicy . isSticky ( current , getPresentationContext ( ) ) ; } @Override public ViewerFilter [ ] getFilters ( ) { return fFilters ; } @Override public void addFilter ( ViewerFilter filter ) { ViewerFilter [ ] newFilters = new ViewerFilter [ fFilters . length + <int> ] ; System . arraycopy ( fFilters , <int> , newFilters , <int> , fFilters . length ) ; newFilters [ fFilters . length ] = filter ; fFilters = newFilters ; } @Override public void setFilters ( ViewerFilter . . . filters ) { fFilters = filters ; } public void dispose ( ) { if ( fColumnPresentation ! = null ) { fColumnPresentation . dispose ( ) ; } if ( fContentProvider ! = null ) { fContentProvider . dispose ( ) ; fContentProvider = null ; } if ( fLabelProvider ! = null ) { fLabelProvider . dispose ( ) ; fLabelProvider = null ; } fTree . removeItemListener ( this ) ; fTree . dispose ( ) ; } @Override public IPresentationContext getPresentationContext ( ) { return fContext ; } private void resetColumns ( Object input ) { if ( input ! = null ) { IColumnPresentationFactory factory = ViewerAdapterService . getColumnPresentationFactory ( input ) ; PresentationContext context = ( PresentationContext ) getPresentationContext ( ) ; String type = null ; if ( factory ! = null ) { type = factory . getColumnPresentationId ( context , input ) ; } if ( type ! = null & & factory ! = null ) { if ( fColumnPresentation ! = null ) { if ( ! fColumnPresentation . getId ( ) . equals ( type ) ) { fColumnPresentation . dispose ( ) ; fColumnPresentation = null ; } } if ( fColumnPresentation = = null ) { fColumnPresentation = factory . createColumnPresentation ( context , input ) ; if ( fColumnPresentation ! = null ) { fColumnPresentation . init ( context ) ; configureColumns ( ) ; } } } else { if ( fColumnPresentation ! = null ) { fColumnPresentation . dispose ( ) ; fColumnPresentation = null ; configureColumns ( ) ; } } } } protected void configureColumns ( ) { if ( fColumnPresentation ! = null ) { IColumnPresentation build = null ; if ( isShowColumns ( fColumnPresentation . getId ( ) ) ) { build = fColumnPresentation ; } buildColumns ( build ) ; } else { buildColumns ( null ) ; } } public void setShowColumns ( boolean show ) { if ( show ) { if ( ! isShowColumns ( ) ) { fShowColumns . remove ( fColumnPresentation . getId ( ) ) ; } } else { if ( isShowColumns ( ) ) { fShowColumns . put ( fColumnPresentation . getId ( ) , Boolean . FALSE ) ; } } refreshColumns ( ) ; } protected void refreshColumns ( ) { configureColumns ( ) ; refresh ( ) ; } public boolean isShowColumns ( ) { if ( fColumnPresentation ! = null ) { return isShowColumns ( fColumnPresentation . getId ( ) ) ; } return false ; } public boolean canToggleColumns ( ) { return fColumnPresentation ! = null & & fColumnPresentation . isOptional ( ) ; } protected boolean isShowColumns ( String columnPresentationId ) { Boolean bool = fShowColumns . get ( columnPresentationId ) ; if ( bool = = null ) { return true ; } return bool . booleanValue ( ) ; } protected void buildColumns ( IColumnPresentation presentation ) { PresentationContext presentationContext = ( PresentationContext ) getPresentationContext ( ) ; if ( presentation ! = null ) { presentationContext . setColumns ( getVisibleColumns ( ) ) ; } else { presentationContext . setColumns ( null ) ; } } @Override public String [ ] getVisibleColumns ( ) { if ( isShowColumns ( ) ) { IColumnPresentation presentation = getColumnPresentation ( ) ; if ( presentation ! = null ) { String [ ] columns = fVisibleColumns . get ( presentation . getId ( ) ) ; if ( columns = = null ) { return presentation . getInitialColumns ( ) ; } return columns ; } } return null ; } public void setVisibleColumns ( String [ ] ids ) { if ( ids ! = null & & ids . length = = <int> ) { ids = null ; } IColumnPresentation presentation = getColumnPresentation ( ) ; if ( presentation ! = null ) { fVisibleColumns . remove ( presentation . getId ( ) ) ; if ( ids ! = null ) { String [ ] columns = presentation . getInitialColumns ( ) ; if ( columns . length = = ids . length ) { for ( int i = <int> ; i < columns . length ; i + + ) { if ( ! ids [ i ] . equals ( columns [ i ] ) ) { fVisibleColumns . put ( presentation . getId ( ) , ids ) ; break ; } } } else { fVisibleColumns . put ( presentation . getId ( ) , ids ) ; } } PresentationContext presentationContext = ( PresentationContext ) getPresentationContext ( ) ; presentationContext . setColumns ( getVisibleColumns ( ) ) ; refreshColumns ( ) ; } } public IColumnPresentation getColumnPresentation ( ) { return fColumnPresentation ; } public void saveState ( IMemento memento ) { if ( ! fShowColumns . isEmpty ( ) ) { for ( Entry < String , Boolean > entry : fShowColumns . entrySet ( ) ) { IMemento sizes = memento . createChild ( SHOW_COLUMNS , entry . getKey ( ) ) ; sizes . putString ( SHOW_COLUMNS , entry . getValue ( ) . toString ( ) ) ; } } if ( ! fVisibleColumns . isEmpty ( ) ) { for ( Entry < String , String [ ] > entry : fVisibleColumns . entrySet ( ) ) { IMemento visible = memento . createChild ( VISIBLE_COLUMNS , entry . getKey ( ) ) ; String [ ] columns = entry . getValue ( ) ; visible . putInteger ( SIZE , columns . length ) ; for ( int i = <int> ; i < columns . length ; i + + ) { visible . putString ( COLUMN + Integer . toString ( i ) , columns [ i ] ) ; } } } IPresentationContext context = getPresentationContext ( ) ; if ( context instanceof PresentationContext ) { PresentationContext pc = ( PresentationContext ) context ; pc . saveProperites ( memento ) ; } } public void initState ( IMemento memento ) { IMemento [ ] mementos = memento . getChildren ( SHOW_COLUMNS ) ; for ( int i = <int> ; i < mementos . length ; i + + ) { IMemento child = mementos [ i ] ; String id = child . getID ( ) ; Boolean bool = Boolean . valueOf ( child . getString ( SHOW_COLUMNS ) ) ; if ( ! bool . booleanValue ( ) ) { fShowColumns . put ( id , bool ) ; } } mementos = memento . getChildren ( VISIBLE_COLUMNS ) ; for ( int i = <int> ; i < mementos . length ; i + + ) { IMemento child = mementos [ i ] ; String id = child . getID ( ) ; Integer integer = child . getInteger ( SIZE ) ; if ( integer ! = null ) { int length = integer . intValue ( ) ; String [ ] columns = new String [ length ] ; for ( int j = <int> ; j < length ; j + + ) { columns [ j ] = child . getString ( COLUMN + Integer . toString ( j ) ) ; } fVisibleColumns . put ( id , columns ) ; } } IPresentationContext context = getPresentationContext ( ) ; if ( context instanceof PresentationContext ) { PresentationContext pc = ( PresentationContext ) context ; pc . initProperties ( memento ) ; } } @Override public void addViewerUpdateListener ( IViewerUpdateListener listener ) { getContentProvider ( ) . addViewerUpdateListener ( listener ) ; } @Override public void removeViewerUpdateListener ( IViewerUpdateListener listener ) { ITreeModelContentProvider cp = getContentProvider ( ) ; if ( cp ! = null ) { cp . removeViewerUpdateListener ( listener ) ; } } @Override public void addModelChangedListener ( IModelChangedListener listener ) { getContentProvider ( ) . addModelChangedListener ( listener ) ; } @Override public void removeModelChangedListener ( IModelChangedListener listener ) { ITreeModelContentProvider cp = getContentProvider ( ) ; if ( cp ! = null ) { cp . removeModelChangedListener ( listener ) ; } } @Override public void addStateUpdateListener ( IStateUpdateListener listener ) { getContentProvider ( ) . addStateUpdateListener ( listener ) ; } @Override public void removeStateUpdateListener ( IStateUpdateListener listener ) { ITreeModelContentProvider cp = getContentProvider ( ) ; if ( cp ! = null ) { cp . removeStateUpdateListener ( listener ) ; } } @Override public void addLabelUpdateListener ( ILabelUpdateListener listener ) { getLabelProvider ( ) . addLabelUpdateListener ( listener ) ; } @Override public void removeLabelUpdateListener ( ILabelUpdateListener listener ) { getLabelProvider ( ) . removeLabelUpdateListener ( listener ) ; } @Override public void autoExpand ( TreePath elementPath ) { int level = getAutoExpandLevel ( ) ; if ( level > <int> | | level = = org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer . ALL_LEVELS ) { if ( level = = org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer . ALL_LEVELS | | level > elementPath . getSegmentCount ( ) ) { expandToLevel ( elementPath , <int> ) ; } } } @Override public int getChildCount ( TreePath path ) { int childCount = - <int> ; VirtualItem [ ] items = findItems ( path ) ; if ( items . length > <int> ) { childCount = items [ <int> ] . getItemCount ( ) ; if ( childCount = = - <int> ) { childCount = items [ <int> ] . hasItems ( ) ? <int> : <int> ; } } return childCount ; } @Override public Object getChildElement ( TreePath path , int index ) { VirtualItem [ ] items = findItems ( path ) ; if ( items . length > <int> ) { if ( index < items [ <int> ] . getItemCount ( ) ) { return items [ <int> ] . getItem ( new VirtualItem . Index ( index ) ) . getData ( ) ; } } return null ; } @Override public TreePath getTopElementPath ( ) { return null ; } @Override public boolean saveElementState ( TreePath path , ModelDelta delta , int flagsToSave ) { VirtualTree tree = getTree ( ) ; VirtualItem [ ] selection = tree . getSelection ( ) ; Set < VirtualItem > set = new HashSet < VirtualItem > ( ) ; for ( int i = <int> ; i < selection . length ; i + + ) { set . add ( selection [ i ] ) ; } VirtualItem [ ] items = null ; VirtualItem parent = findItem ( path ) ; if ( parent ! = null ) { delta . setChildCount ( ( ( TreeModelContentProvider ) getContentProvider ( ) ) . viewToModelCount ( path , parent . getItemCount ( ) ) ) ; if ( parent . getExpanded ( ) ) { if ( ( flagsToSave & IModelDelta . EXPAND ) ! = <int> ) { delta . setFlags ( delta . getFlags ( ) | IModelDelta . EXPAND ) ; } } else if ( ( flagsToSave & IModelDelta . COLLAPSE ) ! = <int> & & parent . hasItems ( ) ) { delta . setFlags ( delta . getFlags ( ) | IModelDelta . COLLAPSE ) ; } if ( set . contains ( parent ) & & ( flagsToSave & IModelDelta . SELECT ) ! = <int> ) { delta . setFlags ( delta . getFlags ( ) | IModelDelta . SELECT ) ; } items = parent . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { doSaveElementState ( path , delta , items [ i ] , set , flagsToSave ) ; } return true ; } else { return false ; } } private void doSaveElementState ( TreePath parentPath , ModelDelta delta , VirtualItem item , Collection < VirtualItem > set , int flagsToSave ) { Object element = item . getData ( ) ; if ( element ! = null ) { boolean expanded = item . getExpanded ( ) ; boolean selected = set . contains ( item ) ; int flags = IModelDelta . NO_CHANGE ; if ( expanded & & ( flagsToSave & IModelDelta . EXPAND ) ! = <int> ) { flags = flags | IModelDelta . EXPAND ; } if ( ! expanded & & ( flagsToSave & IModelDelta . COLLAPSE ) ! = <int> & & item . hasItems ( ) ) { flags = flags | IModelDelta . COLLAPSE ; } if ( selected & & ( flagsToSave & IModelDelta . SELECT ) ! = <int> ) { flags = flags | IModelDelta . SELECT ; } if ( expanded | | flags ! = IModelDelta . NO_CHANGE ) { int modelIndex = ( ( TreeModelContentProvider ) getContentProvider ( ) ) . viewToModelIndex ( parentPath , item . getIndex ( ) . intValue ( ) ) ; TreePath elementPath = parentPath . createChildPath ( element ) ; int numChildren = ( ( TreeModelContentProvider ) getContentProvider ( ) ) . viewToModelCount ( elementPath , item . getItemCount ( ) ) ; ModelDelta childDelta = delta . addNode ( element , modelIndex , flags , numChildren ) ; if ( expanded ) { VirtualItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { doSaveElementState ( elementPath , childDelta , items [ i ] , set , flagsToSave ) ; } } } } } @Override public void updateViewer ( IModelDelta delta ) { getContentProvider ( ) . updateModel ( delta , ITreeModelContentProvider . ALL_MODEL_DELTA_FLAGS ) ; } @Override public ViewerLabel getElementLabel ( TreePath path , String columnId ) { if ( path . getSegmentCount ( ) = = <int> ) { return null ; } int columnIdx = - <int> ; String [ ] visibleColumns = getVisibleColumns ( ) ; if ( columnId ! = null & & visibleColumns ! = null ) { int i = <int> ; for ( i = <int> ; i < visibleColumns . length ; i + + ) { if ( columnId . equals ( getVisibleColumns ( ) [ i ] ) ) { columnIdx = i ; break ; } } if ( i = = visibleColumns . length ) { return null ; } } else { columnIdx = <int> ; } VirtualItem item = findItem ( path ) ; if ( item ! = null ) { ViewerLabel label = new ViewerLabel ( getText ( item , columnIdx ) , getImage ( item , columnIdx ) ) ; label . setFont ( getFont ( item , columnIdx ) ) ; label . setBackground ( getBackground ( item , columnIdx ) ) ; label . setForeground ( getForeground ( item , columnIdx ) ) ; return label ; } return null ; } @Override public TreePath [ ] getElementPaths ( Object element ) { VirtualItem [ ] items = findItems ( element ) ; TreePath [ ] paths = new TreePath [ items . length ] ; for ( int i = <int> ; i < items . length ; i + + ) { paths [ i ] = getTreePathFromItem ( items [ i ] ) ; } return paths ; } public String getText ( VirtualItem item , int columnIdx ) { String [ ] texts = ( String [ ] ) item . getData ( VirtualItem . LABEL_KEY ) ; if ( texts ! = null & & texts . length > columnIdx ) { return texts [ columnIdx ] ; } return null ; } public Image getImage ( VirtualItem item , int columnIdx ) { ImageDescriptor [ ] imageDescriptors = ( ImageDescriptor [ ] ) item . getData ( VirtualItem . IMAGE_KEY ) ; if ( imageDescriptors ! = null & & imageDescriptors . length > columnIdx ) { return getLabelProvider ( ) . getImage ( imageDescriptors [ columnIdx ] ) ; } return null ; } public Font getFont ( VirtualItem item , int columnIdx ) { FontData [ ] fontDatas = ( FontData [ ] ) item . getData ( VirtualItem . FONT_KEY ) ; if ( fontDatas ! = null ) { return getLabelProvider ( ) . getFont ( fontDatas [ columnIdx ] ) ; } return null ; } public Color getForeground ( VirtualItem item , int columnIdx ) { RGB [ ] rgbs = ( RGB [ ] ) item . getData ( VirtualItem . FOREGROUND_KEY ) ; if ( rgbs ! = null ) { return getLabelProvider ( ) . getColor ( rgbs [ columnIdx ] ) ; } return null ; } public Color getBackground ( VirtualItem item , int columnIdx ) { RGB [ ] rgbs = ( RGB [ ] ) item . getData ( VirtualItem . BACKGROUND_KEY ) ; if ( rgbs ! = null ) { return getLabelProvider ( ) . getColor ( rgbs [ columnIdx ] ) ; } return null ; } @Override public void clearSelectionQuiet ( ) { getTree ( ) . setSelection ( EMPTY_ITEMS_ARRAY ) ; } @Override public boolean getElementChecked ( TreePath path ) { return false ; } @Override public boolean getElementGrayed ( TreePath path ) { return false ; } @Override public void setElementChecked ( TreePath path , boolean checked , boolean grayed ) { } @Override public String toString ( ) { return getTree ( ) . toString ( ) ; } } 
