package org . apache . cassandra . db . commitlog ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . Map ; import java . util . Properties ; import java . util . TimeZone ; import java . util . concurrent . * ; import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . CompressionParams ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . WrappedRunnable ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . google . common . base . Strings ; public class CommitLogArchiver { private static final Logger logger = LoggerFactory . getLogger ( CommitLogArchiver . class ) ; public static final SimpleDateFormat format = new SimpleDateFormat ( <str> ) ; private static final String DELIMITER = <str> ; static { format . setTimeZone ( TimeZone . getTimeZone ( <str> ) ) ; } public final Map < String , Future < ? > > archivePending = new ConcurrentHashMap < String , Future < ? > > ( ) ; private final ExecutorService executor ; final String archiveCommand ; final String restoreCommand ; final String restoreDirectories ; public long restorePointInTime ; public final TimeUnit precision ; public CommitLogArchiver ( String archiveCommand , String restoreCommand , String restoreDirectories , long restorePointInTime , TimeUnit precision ) { this . archiveCommand = archiveCommand ; this . restoreCommand = restoreCommand ; this . restoreDirectories = restoreDirectories ; this . restorePointInTime = restorePointInTime ; this . precision = precision ; executor = ! Strings . isNullOrEmpty ( archiveCommand ) ? new JMXEnabledThreadPoolExecutor ( <str> ) : null ; } public static CommitLogArchiver disabled ( ) { return new CommitLogArchiver ( null , null , null , Long . MAX_VALUE , TimeUnit . MICROSECONDS ) ; } public static CommitLogArchiver construct ( ) { Properties commitlog_commands = new Properties ( ) ; try ( InputStream stream = CommitLogArchiver . class . getClassLoader ( ) . getResourceAsStream ( <str> ) ) { if ( stream = = null ) { logger . trace ( <str> ) ; return disabled ( ) ; } else { commitlog_commands . load ( stream ) ; String archiveCommand = commitlog_commands . getProperty ( <str> ) ; String restoreCommand = commitlog_commands . getProperty ( <str> ) ; String restoreDirectories = commitlog_commands . getProperty ( <str> ) ; if ( restoreDirectories ! = null & & ! restoreDirectories . isEmpty ( ) ) { for ( String dir : restoreDirectories . split ( DELIMITER ) ) { File directory = new File ( dir ) ; if ( ! directory . exists ( ) ) { if ( ! directory . mkdir ( ) ) { throw new RuntimeException ( <str> + dir ) ; } } } } String targetTime = commitlog_commands . getProperty ( <str> ) ; TimeUnit precision = TimeUnit . valueOf ( commitlog_commands . getProperty ( <str> , <str> ) ) ; long restorePointInTime ; try { restorePointInTime = Strings . isNullOrEmpty ( targetTime ) ? Long . MAX_VALUE : format . parse ( targetTime ) . getTime ( ) ; } catch ( ParseException e ) { throw new RuntimeException ( <str> , e ) ; } return new CommitLogArchiver ( archiveCommand , restoreCommand , restoreDirectories , restorePointInTime , precision ) ; } } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } } public void maybeArchive ( final CommitLogSegment segment ) { if ( Strings . isNullOrEmpty ( archiveCommand ) ) return ; archivePending . put ( segment . getName ( ) , executor . submit ( new WrappedRunnable ( ) { protected void runMayThrow ( ) throws IOException { segment . waitForFinalSync ( ) ; String command = archiveCommand . replace ( <str> , segment . getName ( ) ) ; command = command . replace ( <str> , segment . getPath ( ) ) ; exec ( command ) ; } } ) ) ; } public void maybeArchive ( final String path , final String name ) { if ( Strings . isNullOrEmpty ( archiveCommand ) ) return ; archivePending . put ( name , executor . submit ( new WrappedRunnable ( ) { protected void runMayThrow ( ) throws IOException { String command = archiveCommand . replace ( <str> , name ) ; command = command . replace ( <str> , path ) ; exec ( command ) ; } } ) ) ; } public boolean maybeWaitForArchiving ( String name ) { Future < ? > f = archivePending . remove ( name ) ; if ( f = = null ) return true ; try { f . get ( ) ; } catch ( InterruptedException e ) { throw new AssertionError ( e ) ; } catch ( ExecutionException e ) { if ( e . getCause ( ) instanceof IOException ) { logger . error ( <str> , name ) ; return false ; } throw new RuntimeException ( e ) ; } return true ; } public void maybeRestoreArchive ( ) { if ( Strings . isNullOrEmpty ( restoreDirectories ) ) return ; for ( String dir : restoreDirectories . split ( DELIMITER ) ) { File [ ] files = new File ( dir ) . listFiles ( ) ; if ( files = = null ) { throw new RuntimeException ( <str> + dir ) ; } for ( File fromFile : files ) { CommitLogDescriptor fromHeader = CommitLogDescriptor . fromHeader ( fromFile ) ; CommitLogDescriptor fromName = CommitLogDescriptor . isValid ( fromFile . getName ( ) ) ? CommitLogDescriptor . fromFileName ( fromFile . getName ( ) ) : null ; CommitLogDescriptor descriptor ; if ( fromHeader = = null & & fromName = = null ) throw new IllegalStateException ( <str> + fromFile . getPath ( ) ) ; else if ( fromHeader ! = null & & fromName ! = null & & ! fromHeader . equalsIgnoringCompression ( fromName ) ) throw new IllegalStateException ( String . format ( <str> , fromHeader , fromName , fromFile . getPath ( ) ) ) ; else if ( fromName ! = null & & fromHeader = = null & & fromName . version > = CommitLogDescriptor . VERSION_21 ) throw new IllegalStateException ( <str> + fromFile . getPath ( ) ) ; else if ( fromHeader ! = null ) descriptor = fromHeader ; else descriptor = fromName ; if ( descriptor . version > CommitLogDescriptor . current_version ) throw new IllegalStateException ( <str> + descriptor . version ) ; if ( descriptor . compression ! = null ) { try { CompressionParams . createCompressor ( descriptor . compression ) ; } catch ( ConfigurationException e ) { throw new IllegalStateException ( <str> , e ) ; } } File toFile = new File ( DatabaseDescriptor . getCommitLogLocation ( ) , descriptor . fileName ( ) ) ; if ( toFile . exists ( ) ) { logger . trace ( <str> , fromFile . getPath ( ) , toFile . getPath ( ) ) ; continue ; } String command = restoreCommand . replace ( <str> , fromFile . getPath ( ) ) ; command = command . replace ( <str> , toFile . getPath ( ) ) ; try { exec ( command ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } } private void exec ( String command ) throws IOException { ProcessBuilder pb = new ProcessBuilder ( command . split ( <str> ) ) ; pb . redirectErrorStream ( true ) ; FBUtilities . exec ( pb ) ; } } 
