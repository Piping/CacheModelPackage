package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import java . util . ArrayList ; import java . util . Collections ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Random ; import java . util . Set ; import java . util . TreeSet ; public class SortedCopyBenchmark { @Param ( { <str> , <str> , <str> , <str> } ) int size ; @Param boolean mutable ; @Param InputOrder inputOrder ; enum InputOrder { SORTED { @Override void arrange ( List < Integer > list ) { Collections . sort ( list ) ; } } , ALMOST_SORTED { @Override void arrange ( List < Integer > list ) { Collections . sort ( list ) ; if ( list . size ( ) > <int> ) { int i = ( list . size ( ) - <int> ) / <int> ; Collections . swap ( list , i , i + <int> ) ; } } } , RANDOM { @Override void arrange ( List < Integer > list ) { } } ; abstract void arrange ( List < Integer > list ) ; } private ImmutableList < Integer > input ; @BeforeExperiment void setUp ( ) { checkArgument ( size > <int> , <str> ) ; Set < Integer > set = new LinkedHashSet < Integer > ( size ) ; Random random = new Random ( ) ; while ( set . size ( ) < size ) { set . add ( random . nextInt ( ) ) ; } List < Integer > list = new ArrayList < Integer > ( set ) ; inputOrder . arrange ( list ) ; input = ImmutableList . copyOf ( list ) ; } @Benchmark int collections ( int reps ) { int dummy = <int> ; if ( mutable ) { for ( int i = <int> ; i < reps ; i + + ) { List < Integer > copy = new ArrayList < Integer > ( input ) ; Collections . sort ( copy ) ; dummy + = copy . get ( <int> ) ; } } else { for ( int i = <int> ; i < reps ; i + + ) { List < Integer > copy = new ArrayList < Integer > ( input ) ; Collections . sort ( copy ) ; dummy + = ImmutableList . copyOf ( copy ) . get ( <int> ) ; } } return dummy ; } @Benchmark int ordering ( int reps ) { int dummy = <int> ; if ( mutable ) { for ( int i = <int> ; i < reps ; i + + ) { dummy + = ORDERING . sortedCopy ( input ) . get ( <int> ) ; } } else { for ( int i = <int> ; i < reps ; i + + ) { dummy + = ORDERING . immutableSortedCopy ( input ) . get ( <int> ) ; } } return dummy ; } @Benchmark int sortedSet ( int reps ) { int dummy = <int> ; if ( mutable ) { for ( int i = <int> ; i < reps ; i + + ) { dummy + = new TreeSet < Integer > ( input ) . first ( ) ; } } else { for ( int i = <int> ; i < reps ; i + + ) { dummy + = ImmutableSortedSet . copyOf ( input ) . first ( ) ; } } return dummy ; } private static final Ordering < Integer > ORDERING = Ordering . natural ( ) ; } 
