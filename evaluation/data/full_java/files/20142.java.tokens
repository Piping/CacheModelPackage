package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . Bootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelOption ; import io . netty . testsuite . util . TestUtils ; import io . netty . util . NetUtil ; import io . netty . util . concurrent . GlobalEventExecutor ; import io . netty . util . concurrent . Promise ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . junit . Test ; import java . io . IOException ; import java . net . ConnectException ; import java . net . InetSocketAddress ; import java . net . Socket ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; import static org . junit . Assume . * ; public class SocketConnectionAttemptTest extends AbstractClientSocketTest { private static final String BAD_HOST = SystemPropertyUtil . get ( <str> , <str> ) ; private static final int BAD_PORT = SystemPropertyUtil . getInt ( <str> , <int> ) ; static { InternalLogger logger = InternalLoggerFactory . getInstance ( SocketConnectionAttemptTest . class ) ; logger . debug ( <str> , BAD_HOST ) ; logger . debug ( <str> , BAD_PORT ) ; } @Test ( timeout = <int> ) public void testConnectTimeout ( ) throws Throwable { run ( ) ; } public void testConnectTimeout ( Bootstrap cb ) throws Throwable { cb . handler ( new TestHandler ( ) ) . option ( ChannelOption . CONNECT_TIMEOUT_MILLIS , <int> ) ; ChannelFuture future = cb . connect ( BAD_HOST , BAD_PORT ) ; try { assertThat ( future . await ( <int> ) , is ( true ) ) ; } finally { future . channel ( ) . close ( ) ; } } @Test ( timeout = <int> ) public void testConnectRefused ( ) throws Throwable { run ( ) ; } public void testConnectRefused ( Bootstrap cb ) throws Throwable { testConnectRefused0 ( cb , false ) ; } @Test ( timeout = <int> ) public void testConnectRefusedHalfClosure ( ) throws Throwable { run ( ) ; } public void testConnectRefusedHalfClosure ( Bootstrap cb ) throws Throwable { testConnectRefused0 ( cb , true ) ; } private static void testConnectRefused0 ( Bootstrap cb , boolean halfClosure ) throws Throwable { final Promise < Error > errorPromise = GlobalEventExecutor . INSTANCE . newPromise ( ) ; ChannelHandler handler = new ChannelInboundHandlerAdapter ( ) { @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { Channel channel = ctx . channel ( ) ; errorPromise . setFailure ( new AssertionError ( <str> ) ) ; } } ; cb . handler ( handler ) ; cb . option ( ChannelOption . ALLOW_HALF_CLOSURE , halfClosure ) ; ChannelFuture future = cb . connect ( NetUtil . LOCALHOST , TestUtils . getFreePort ( ) ) . awaitUninterruptibly ( ) ; assertThat ( future . cause ( ) , is ( instanceOf ( ConnectException . class ) ) ) ; assertThat ( errorPromise . cause ( ) , is ( nullValue ( ) ) ) ; } @Test public void testConnectCancellation ( ) throws Throwable { boolean badHostTimedOut = true ; Socket socket = new Socket ( ) ; try { socket . connect ( new InetSocketAddress ( BAD_HOST , BAD_PORT ) , <int> ) ; } catch ( ConnectException e ) { badHostTimedOut = false ; } catch ( Exception e ) { } finally { try { socket . close ( ) ; } catch ( IOException e ) { } } assumeThat ( <str> + BAD_HOST + <str> , badHostTimedOut , is ( true ) ) ; run ( ) ; } public void testConnectCancellation ( Bootstrap cb ) throws Throwable { cb . handler ( new TestHandler ( ) ) . option ( ChannelOption . CONNECT_TIMEOUT_MILLIS , <int> ) ; ChannelFuture future = cb . connect ( BAD_HOST , BAD_PORT ) ; try { if ( future . await ( <int> ) ) { if ( future . isSuccess ( ) ) { fail ( <str> + BAD_HOST + <str> ) ; } else { throw future . cause ( ) ; } } if ( future . cancel ( true ) ) { assertThat ( future . channel ( ) . closeFuture ( ) . await ( <int> ) , is ( true ) ) ; assertThat ( future . isCancelled ( ) , is ( true ) ) ; } else { } } finally { future . channel ( ) . close ( ) ; } } private static class TestHandler extends ChannelInboundHandlerAdapter { @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { InternalLoggerFactory . getInstance ( SocketConnectionAttemptTest . class ) . warn ( <str> , cause ) ; } } } 
