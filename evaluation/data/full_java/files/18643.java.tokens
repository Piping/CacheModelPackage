package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . physics . bullet . collision . Collision ; import com . badlogic . gdx . physics . bullet . collision . btBoxShape ; import com . badlogic . gdx . physics . bullet . dynamics . btDefaultVehicleRaycaster ; import com . badlogic . gdx . physics . bullet . dynamics . btDiscreteDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btRaycastVehicle ; import com . badlogic . gdx . physics . bullet . dynamics . btRigidBody ; import com . badlogic . gdx . physics . bullet . dynamics . btVehicleRaycaster ; import com . badlogic . gdx . physics . bullet . dynamics . btRaycastVehicle . btVehicleTuning ; import com . badlogic . gdx . physics . bullet . dynamics . btWheelInfo ; public class VehicleTest extends BaseBulletTest { public btVehicleRaycaster raycaster ; public btRaycastVehicle vehicle ; public btVehicleTuning tuning ; BulletEntity chassis ; BulletEntity wheels [ ] = new BulletEntity [ <int> ] ; boolean downPressed ; boolean upPressed ; boolean leftPressed ; boolean rightPressed ; Vector3 tmpV = new Vector3 ( ) ; @Override public void create ( ) { super . create ( ) ; instructions = <str> ; final Model chassisModel = objLoader . loadModel ( Gdx . files . internal ( <str> ) ) ; disposables . add ( chassisModel ) ; chassisModel . materials . get ( <int> ) . clear ( ) ; chassisModel . materials . get ( <int> ) . set ( ColorAttribute . createDiffuse ( Color . RED ) , ColorAttribute . createSpecular ( Color . WHITE ) ) ; final Model wheelModel = objLoader . loadModel ( Gdx . files . internal ( <str> ) ) ; disposables . add ( wheelModel ) ; wheelModel . materials . get ( <int> ) . clear ( ) ; wheelModel . materials . get ( <int> ) . set ( ColorAttribute . createDiffuse ( Color . BLACK ) , ColorAttribute . createSpecular ( Color . WHITE ) , FloatAttribute . createShininess ( <int> ) ) ; Texture checkboard = new Texture ( Gdx . files . internal ( <str> ) ) ; final Model largeGroundModel = modelBuilder . createBox ( <int> f , <float> , <int> f , new Material ( TextureAttribute . createDiffuse ( checkboard ) , ColorAttribute . createSpecular ( Color . WHITE ) , FloatAttribute . createShininess ( <int> f ) ) , Usage . Position | Usage . Normal | Usage . TextureCoordinates ) ; largeGroundModel . manageDisposable ( checkboard ) ; disposables . add ( largeGroundModel ) ; world . addConstructor ( <str> , new BulletConstructor ( largeGroundModel , <float> ) ) ; BoundingBox bounds = new BoundingBox ( ) ; Vector3 chassisHalfExtents = chassisModel . calculateBoundingBox ( bounds ) . getDimensions ( new Vector3 ( ) ) . scl ( <float> ) ; Vector3 wheelHalfExtents = wheelModel . calculateBoundingBox ( bounds ) . getDimensions ( new Vector3 ( ) ) . scl ( <float> ) ; world . addConstructor ( <str> , new BulletConstructor ( chassisModel , <float> , new btBoxShape ( chassisHalfExtents ) ) ) ; world . addConstructor ( <str> , new BulletConstructor ( wheelModel , <int> , null ) ) ; world . add ( <str> , <int> , - <float> , <float> ) ; chassis = world . add ( <str> , <int> , <float> , <int> ) ; wheels [ <int> ] = world . add ( <str> , <int> , <int> , <int> ) ; wheels [ <int> ] = world . add ( <str> , <int> , <int> , <int> ) ; wheels [ <int> ] = world . add ( <str> , <int> , <int> , <int> ) ; wheels [ <int> ] = world . add ( <str> , <int> , <int> , <int> ) ; raycaster = new btDefaultVehicleRaycaster ( ( btDynamicsWorld ) world . collisionWorld ) ; tuning = new btVehicleTuning ( ) ; vehicle = new btRaycastVehicle ( tuning , ( btRigidBody ) chassis . body , raycaster ) ; chassis . body . setActivationState ( Collision . DISABLE_DEACTIVATION ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addVehicle ( vehicle ) ; vehicle . setCoordinateSystem ( <int> , <int> , <int> ) ; btWheelInfo wheelInfo ; Vector3 point = new Vector3 ( ) ; Vector3 direction = new Vector3 ( <int> , - <int> , <int> ) ; Vector3 axis = new Vector3 ( - <int> , <int> , <int> ) ; wheelInfo = vehicle . addWheel ( point . set ( chassisHalfExtents ) . scl ( <float> , - <float> , <float> ) , direction , axis , wheelHalfExtents . z * <float> , wheelHalfExtents . z , tuning , true ) ; wheelInfo = vehicle . addWheel ( point . set ( chassisHalfExtents ) . scl ( - <float> , - <float> , <float> ) , direction , axis , wheelHalfExtents . z * <float> , wheelHalfExtents . z , tuning , true ) ; wheelInfo = vehicle . addWheel ( point . set ( chassisHalfExtents ) . scl ( <float> , - <float> , - <float> ) , direction , axis , wheelHalfExtents . z * <float> , wheelHalfExtents . z , tuning , false ) ; wheelInfo = vehicle . addWheel ( point . set ( chassisHalfExtents ) . scl ( - <float> , - <float> , - <float> ) , direction , axis , wheelHalfExtents . z * <float> , wheelHalfExtents . z , tuning , false ) ; } float maxForce = <int> f ; float currentForce = <float> ; float acceleration = <int> f ; float maxAngle = <int> f ; float currentAngle = <float> ; float steerSpeed = <int> f ; @Override public void update ( ) { final float delta = Gdx . graphics . getDeltaTime ( ) ; float angle = currentAngle ; if ( rightPressed ) { if ( angle > <float> ) angle = <float> ; angle = MathUtils . clamp ( angle - steerSpeed * delta , - maxAngle , <float> ) ; } else if ( leftPressed ) { if ( angle < <float> ) angle = <float> ; angle = MathUtils . clamp ( angle + steerSpeed * delta , <float> , maxAngle ) ; } else angle = <float> ; if ( angle ! = currentAngle ) { currentAngle = angle ; vehicle . setSteeringValue ( angle * MathUtils . degreesToRadians , <int> ) ; vehicle . setSteeringValue ( angle * MathUtils . degreesToRadians , <int> ) ; } float force = currentForce ; if ( upPressed ) { if ( force < <float> ) force = <float> ; force = MathUtils . clamp ( force + acceleration * delta , <float> , maxForce ) ; } else if ( downPressed ) { if ( force > <float> ) force = <float> ; force = MathUtils . clamp ( force - acceleration * delta , - maxForce , <float> ) ; } else force = <float> ; if ( force ! = currentForce ) { currentForce = force ; vehicle . applyEngineForce ( force , <int> ) ; vehicle . applyEngineForce ( force , <int> ) ; } super . update ( ) ; for ( int i = <int> ; i < wheels . length ; i + + ) { vehicle . updateWheelTransform ( i , true ) ; vehicle . getWheelInfo ( i ) . getWorldTransform ( ) . getOpenGLMatrix ( wheels [ i ] . transform . val ) ; } chassis . transform . getTranslation ( camera . position ) ; tmpV . set ( camera . position ) . sub ( <int> , <int> , <int> ) . y = <float> ; camera . position . add ( tmpV . nor ( ) . scl ( - <float> ) ) . y = <float> ; chassis . transform . getTranslation ( tmpV ) ; camera . lookAt ( tmpV ) ; camera . up . set ( Vector3 . Y ) ; camera . update ( ) ; } @Override public boolean tap ( float x , float y , int count , int button ) { shoot ( x , y ) ; return true ; } @Override public void dispose ( ) { super . dispose ( ) ; vehicle . dispose ( ) ; vehicle = null ; raycaster . dispose ( ) ; raycaster = null ; tuning . dispose ( ) ; tuning = null ; } @Override public boolean keyDown ( int keycode ) { switch ( keycode ) { case Keys . DOWN : downPressed = true ; break ; case Keys . UP : upPressed = true ; break ; case Keys . LEFT : leftPressed = true ; break ; case Keys . RIGHT : rightPressed = true ; break ; } return super . keyDown ( keycode ) ; } @Override public boolean keyUp ( int keycode ) { switch ( keycode ) { case Keys . DOWN : downPressed = false ; break ; case Keys . UP : upPressed = false ; break ; case Keys . LEFT : leftPressed = false ; break ; case Keys . RIGHT : rightPressed = false ; break ; case Keys . R : chassis . body . setWorldTransform ( chassis . transform . setToTranslation ( <int> , <int> , <int> ) ) ; chassis . body . setInterpolationWorldTransform ( chassis . transform ) ; ( ( btRigidBody ) ( chassis . body ) ) . setLinearVelocity ( Vector3 . Zero ) ; ( ( btRigidBody ) ( chassis . body ) ) . setAngularVelocity ( Vector3 . Zero ) ; chassis . body . activate ( ) ; break ; } return super . keyUp ( keycode ) ; } } 
