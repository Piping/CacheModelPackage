package org . elasticsearch . common . inject ; import org . elasticsearch . common . inject . internal . Annotations ; import org . elasticsearch . common . inject . internal . MoreTypes ; import org . elasticsearch . common . inject . internal . ToStringBuilder ; import java . lang . annotation . Annotation ; import java . lang . reflect . Type ; import java . util . Objects ; public class Key < T > { private final AnnotationStrategy annotationStrategy ; private final TypeLiteral < T > typeLiteral ; private final int hashCode ; @SuppressWarnings ( <str> ) protected Key ( Class < ? extends Annotation > annotationType ) { this . annotationStrategy = strategyFor ( annotationType ) ; this . typeLiteral = ( TypeLiteral < T > ) TypeLiteral . fromSuperclassTypeParameter ( getClass ( ) ) ; this . hashCode = computeHashCode ( ) ; } @SuppressWarnings ( <str> ) protected Key ( Annotation annotation ) { this . annotationStrategy = strategyFor ( annotation ) ; this . typeLiteral = ( TypeLiteral < T > ) TypeLiteral . fromSuperclassTypeParameter ( getClass ( ) ) ; this . hashCode = computeHashCode ( ) ; } @SuppressWarnings ( <str> ) protected Key ( ) { this . annotationStrategy = NullAnnotationStrategy . INSTANCE ; this . typeLiteral = ( TypeLiteral < T > ) TypeLiteral . fromSuperclassTypeParameter ( getClass ( ) ) ; this . hashCode = computeHashCode ( ) ; } @SuppressWarnings ( <str> ) private Key ( Type type , AnnotationStrategy annotationStrategy ) { this . annotationStrategy = annotationStrategy ; this . typeLiteral = MoreTypes . makeKeySafe ( ( TypeLiteral < T > ) TypeLiteral . get ( type ) ) ; this . hashCode = computeHashCode ( ) ; } private Key ( TypeLiteral < T > typeLiteral , AnnotationStrategy annotationStrategy ) { this . annotationStrategy = annotationStrategy ; this . typeLiteral = MoreTypes . makeKeySafe ( typeLiteral ) ; this . hashCode = computeHashCode ( ) ; } private int computeHashCode ( ) { return typeLiteral . hashCode ( ) * <int> + annotationStrategy . hashCode ( ) ; } public final TypeLiteral < T > getTypeLiteral ( ) { return typeLiteral ; } public final Class < ? extends Annotation > getAnnotationType ( ) { return annotationStrategy . getAnnotationType ( ) ; } public final Annotation getAnnotation ( ) { return annotationStrategy . getAnnotation ( ) ; } boolean hasAnnotationType ( ) { return annotationStrategy . getAnnotationType ( ) ! = null ; } String getAnnotationName ( ) { Annotation annotation = annotationStrategy . getAnnotation ( ) ; if ( annotation ! = null ) { return annotation . toString ( ) ; } return annotationStrategy . getAnnotationType ( ) . toString ( ) ; } Class < ? super T > getRawType ( ) { return typeLiteral . getRawType ( ) ; } Key < Provider < T > > providerKey ( ) { return ofType ( typeLiteral . providerType ( ) ) ; } @Override public final boolean equals ( Object o ) { if ( o = = this ) { return true ; } if ( ! ( o instanceof Key < ? > ) ) { return false ; } Key < ? > other = ( Key < ? > ) o ; return annotationStrategy . equals ( other . annotationStrategy ) & & typeLiteral . equals ( other . typeLiteral ) ; } @Override public final int hashCode ( ) { return this . hashCode ; } @Override public final String toString ( ) { return new ToStringBuilder ( Key . class ) . add ( <str> , typeLiteral ) . add ( <str> , annotationStrategy ) . toString ( ) ; } static < T > Key < T > get ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < > ( type , annotationStrategy ) ; } public static < T > Key < T > get ( Class < T > type ) { return new Key < > ( type , NullAnnotationStrategy . INSTANCE ) ; } public static < T > Key < T > get ( Class < T > type , Class < ? extends Annotation > annotationType ) { return new Key < > ( type , strategyFor ( annotationType ) ) ; } public static < T > Key < T > get ( Class < T > type , Annotation annotation ) { return new Key < > ( type , strategyFor ( annotation ) ) ; } public static Key < ? > get ( Type type ) { return new Key < Object > ( type , NullAnnotationStrategy . INSTANCE ) ; } public static Key < ? > get ( Type type , Class < ? extends Annotation > annotationType ) { return new Key < Object > ( type , strategyFor ( annotationType ) ) ; } public static Key < ? > get ( Type type , Annotation annotation ) { return new Key < Object > ( type , strategyFor ( annotation ) ) ; } public static < T > Key < T > get ( TypeLiteral < T > typeLiteral ) { return new Key < > ( typeLiteral , NullAnnotationStrategy . INSTANCE ) ; } public static < T > Key < T > get ( TypeLiteral < T > typeLiteral , Class < ? extends Annotation > annotationType ) { return new Key < > ( typeLiteral , strategyFor ( annotationType ) ) ; } public static < T > Key < T > get ( TypeLiteral < T > typeLiteral , Annotation annotation ) { return new Key < > ( typeLiteral , strategyFor ( annotation ) ) ; } < T > Key < T > ofType ( Class < T > type ) { return new Key < > ( type , annotationStrategy ) ; } Key < ? > ofType ( Type type ) { return new Key < Object > ( type , annotationStrategy ) ; } < T > Key < T > ofType ( TypeLiteral < T > type ) { return new Key < > ( type , annotationStrategy ) ; } boolean hasAttributes ( ) { return annotationStrategy . hasAttributes ( ) ; } Key < T > withoutAttributes ( ) { return new Key < > ( typeLiteral , annotationStrategy . withoutAttributes ( ) ) ; } interface AnnotationStrategy { Annotation getAnnotation ( ) ; Class < ? extends Annotation > getAnnotationType ( ) ; boolean hasAttributes ( ) ; AnnotationStrategy withoutAttributes ( ) ; } static boolean isMarker ( Class < ? extends Annotation > annotationType ) { return annotationType . getMethods ( ) . length = = <int> ; } static AnnotationStrategy strategyFor ( Annotation annotation ) { Objects . requireNonNull ( annotation , <str> ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( annotationType . getMethods ( ) . length = = <int> ) { return new AnnotationTypeStrategy ( annotationType , annotation ) ; } return new AnnotationInstanceStrategy ( annotation ) ; } static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { Objects . requireNonNull ( annotationType , <str> ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; } private static void ensureRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { if ( ! Annotations . isRetainedAtRuntime ( annotationType ) ) { throw new IllegalArgumentException ( annotationType . getName ( ) + <str> ) ; } } private static void ensureIsBindingAnnotation ( Class < ? extends Annotation > annotationType ) { if ( ! isBindingAnnotation ( annotationType ) ) { throw new IllegalArgumentException ( annotationType . getName ( ) + <str> ) ; } } static enum NullAnnotationStrategy implements AnnotationStrategy { INSTANCE ; @Override public boolean hasAttributes ( ) { return false ; } @Override public AnnotationStrategy withoutAttributes ( ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public Annotation getAnnotation ( ) { return null ; } @Override public Class < ? extends Annotation > getAnnotationType ( ) { return null ; } @Override public String toString ( ) { return <str> ; } } static class AnnotationInstanceStrategy implements AnnotationStrategy { final Annotation annotation ; AnnotationInstanceStrategy ( Annotation annotation ) { this . annotation = Objects . requireNonNull ( annotation , <str> ) ; } @Override public boolean hasAttributes ( ) { return true ; } @Override public AnnotationStrategy withoutAttributes ( ) { return new AnnotationTypeStrategy ( getAnnotationType ( ) , annotation ) ; } @Override public Annotation getAnnotation ( ) { return annotation ; } @Override public Class < ? extends Annotation > getAnnotationType ( ) { return annotation . annotationType ( ) ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof AnnotationInstanceStrategy ) ) { return false ; } AnnotationInstanceStrategy other = ( AnnotationInstanceStrategy ) o ; return annotation . equals ( other . annotation ) ; } @Override public int hashCode ( ) { return annotation . hashCode ( ) ; } @Override public String toString ( ) { return annotation . toString ( ) ; } } static class AnnotationTypeStrategy implements AnnotationStrategy { final Class < ? extends Annotation > annotationType ; final Annotation annotation ; AnnotationTypeStrategy ( Class < ? extends Annotation > annotationType , Annotation annotation ) { this . annotationType = Objects . requireNonNull ( annotationType , <str> ) ; this . annotation = annotation ; } @Override public boolean hasAttributes ( ) { return false ; } @Override public AnnotationStrategy withoutAttributes ( ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public Annotation getAnnotation ( ) { return annotation ; } @Override public Class < ? extends Annotation > getAnnotationType ( ) { return annotationType ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof AnnotationTypeStrategy ) ) { return false ; } AnnotationTypeStrategy other = ( AnnotationTypeStrategy ) o ; return annotationType . equals ( other . annotationType ) ; } @Override public int hashCode ( ) { return annotationType . hashCode ( ) ; } @Override public String toString ( ) { return <str> + annotationType . getName ( ) ; } } static boolean isBindingAnnotation ( Annotation annotation ) { return isBindingAnnotation ( annotation . annotationType ( ) ) ; } static boolean isBindingAnnotation ( Class < ? extends Annotation > annotationType ) { return annotationType . getAnnotation ( BindingAnnotation . class ) ! = null ; } } 
