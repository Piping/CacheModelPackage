package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . query . QueryShardException ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptModule ; import org . elasticsearch . script . ScriptService . ScriptType ; import org . elasticsearch . search . SearchModule ; import org . elasticsearch . search . aggregations . Aggregation ; import org . elasticsearch . search . aggregations . bucket . filter . FilterAggregationBuilder ; import org . elasticsearch . search . aggregations . bucket . filter . InternalFilter ; import org . elasticsearch . search . aggregations . bucket . script . NativeSignificanceScoreScriptNoParams ; import org . elasticsearch . search . aggregations . bucket . script . NativeSignificanceScoreScriptWithParams ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTerms ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTermsAggregatorFactory ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTermsBuilder ; import org . elasticsearch . search . aggregations . bucket . significant . heuristics . * ; import org . elasticsearch . search . aggregations . bucket . terms . StringTerms ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . TermsBuilder ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . search . aggregations . bucket . SharedSignificantTermsTestMethods ; import org . junit . Test ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . * ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . SUITE ) public class SignificantTermsSignificanceScoreIT extends ESIntegTestCase { static final String INDEX_NAME = <str> ; static final String DOC_TYPE = <str> ; static final String TEXT_FIELD = <str> ; static final String CLASS_FIELD = <str> ; @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( CustomSignificanceHeuristicPlugin . class ) ; } public String randomExecutionHint ( ) { return randomBoolean ( ) ? null : randomFrom ( SignificantTermsAggregatorFactory . ExecutionMode . values ( ) ) . toString ( ) ; } public void testPlugin ( ) throws Exception { String type = randomBoolean ( ) ? <str> : <str> ; String settings = <str> ; SharedSignificantTermsTestMethods . index01Docs ( type , settings , this ) ; SearchResponse response = client ( ) . prepareSearch ( INDEX_NAME ) . setTypes ( DOC_TYPE ) . addAggregation ( new TermsBuilder ( <str> ) . field ( CLASS_FIELD ) . subAggregation ( ( new SignificantTermsBuilder ( <str> ) ) . field ( TEXT_FIELD ) . significanceHeuristic ( new SimpleHeuristic . SimpleHeuristicBuilder ( ) ) . minDocCount ( <int> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; StringTerms classes = ( StringTerms ) response . getAggregations ( ) . get ( <str> ) ; assertThat ( classes . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( Terms . Bucket classBucket : classes . getBuckets ( ) ) { Map < String , Aggregation > aggs = classBucket . getAggregations ( ) . asMap ( ) ; assertTrue ( aggs . containsKey ( <str> ) ) ; SignificantTerms agg = ( SignificantTerms ) aggs . get ( <str> ) ; assertThat ( agg . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Iterator < SignificantTerms . Bucket > bucketIterator = agg . iterator ( ) ; SignificantTerms . Bucket sigBucket = bucketIterator . next ( ) ; String term = sigBucket . getKeyAsString ( ) ; String classTerm = classBucket . getKeyAsString ( ) ; assertTrue ( term . equals ( classTerm ) ) ; assertThat ( sigBucket . getSignificanceScore ( ) , closeTo ( <float> , <float> ) ) ; sigBucket = bucketIterator . next ( ) ; assertThat ( sigBucket . getSignificanceScore ( ) , closeTo ( <float> , <float> ) ) ; } response = client ( ) . prepareSearch ( INDEX_NAME ) . setTypes ( DOC_TYPE ) . addAggregation ( new TermsBuilder ( <str> ) . field ( CLASS_FIELD ) . subAggregation ( ( new SignificantTermsBuilder ( <str> ) ) . field ( TEXT_FIELD ) . significanceHeuristic ( new SimpleHeuristic . SimpleHeuristicBuilder ( ) ) . minDocCount ( <int> ) ) ) . execute ( ) . actionGet ( ) ; classes = ( StringTerms ) response . getAggregations ( ) . get ( <str> ) ; assertThat ( classes . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( Terms . Bucket classBucket : classes . getBuckets ( ) ) { Map < String , Aggregation > aggs = classBucket . getAggregations ( ) . asMap ( ) ; assertTrue ( aggs . containsKey ( <str> ) ) ; SignificantTerms agg = ( SignificantTerms ) aggs . get ( <str> ) ; assertThat ( agg . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Iterator < SignificantTerms . Bucket > bucketIterator = agg . iterator ( ) ; SignificantTerms . Bucket sigBucket = bucketIterator . next ( ) ; String term = sigBucket . getKeyAsString ( ) ; String classTerm = classBucket . getKeyAsString ( ) ; assertTrue ( term . equals ( classTerm ) ) ; assertThat ( sigBucket . getSignificanceScore ( ) , closeTo ( <float> , <float> ) ) ; sigBucket = bucketIterator . next ( ) ; assertThat ( sigBucket . getSignificanceScore ( ) , closeTo ( <float> , <float> ) ) ; } } public static class CustomSignificanceHeuristicPlugin extends Plugin { static { SignificanceHeuristicStreams . registerStream ( SimpleHeuristic . STREAM ) ; } @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( SearchModule significanceModule ) { significanceModule . registerHeuristicParser ( SimpleHeuristic . SimpleHeuristicParser . class ) ; } public void onModule ( ScriptModule module ) { module . registerScript ( NativeSignificanceScoreScriptNoParams . NATIVE_SIGNIFICANCE_SCORE_SCRIPT_NO_PARAMS , NativeSignificanceScoreScriptNoParams . Factory . class ) ; module . registerScript ( NativeSignificanceScoreScriptWithParams . NATIVE_SIGNIFICANCE_SCORE_SCRIPT_WITH_PARAMS , NativeSignificanceScoreScriptWithParams . Factory . class ) ; } } public static class SimpleHeuristic extends SignificanceHeuristic { protected static final String [ ] NAMES = { <str> } ; public static final SignificanceHeuristicStreams . Stream STREAM = new SignificanceHeuristicStreams . Stream ( ) { @Override public SignificanceHeuristic readResult ( StreamInput in ) throws IOException { return readFrom ( in ) ; } @Override public String getName ( ) { return NAMES [ <int> ] ; } } ; public static SignificanceHeuristic readFrom ( StreamInput in ) throws IOException { return new SimpleHeuristic ( ) ; } @Override public double getScore ( long subsetFreq , long subsetSize , long supersetFreq , long supersetSize ) { return subsetFreq / subsetSize > supersetFreq / supersetSize ? <float> : <float> ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( STREAM . getName ( ) ) ; } public static class SimpleHeuristicParser implements SignificanceHeuristicParser { @Override public SignificanceHeuristic parse ( XContentParser parser , ParseFieldMatcher parseFieldMatcher , SearchContext context ) throws IOException , QueryShardException { parser . nextToken ( ) ; return new SimpleHeuristic ( ) ; } @Override public String [ ] getNames ( ) { return NAMES ; } } public static class SimpleHeuristicBuilder implements SignificanceHeuristicBuilder { @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( STREAM . getName ( ) ) . endObject ( ) ; return builder ; } } } public void testXContentResponse ( ) throws Exception { String type = randomBoolean ( ) ? <str> : <str> ; String settings = <str> ; SharedSignificantTermsTestMethods . index01Docs ( type , settings , this ) ; SearchResponse response = client ( ) . prepareSearch ( INDEX_NAME ) . setTypes ( DOC_TYPE ) . addAggregation ( new TermsBuilder ( <str> ) . field ( CLASS_FIELD ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( TEXT_FIELD ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; StringTerms classes = ( StringTerms ) response . getAggregations ( ) . get ( <str> ) ; assertThat ( classes . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( Terms . Bucket classBucket : classes . getBuckets ( ) ) { Map < String , Aggregation > aggs = classBucket . getAggregations ( ) . asMap ( ) ; assertTrue ( aggs . containsKey ( <str> ) ) ; SignificantTerms agg = ( SignificantTerms ) aggs . get ( <str> ) ; assertThat ( agg . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; String term = agg . iterator ( ) . next ( ) . getKeyAsString ( ) ; String classTerm = classBucket . getKeyAsString ( ) ; assertTrue ( term . equals ( classTerm ) ) ; } XContentBuilder responseBuilder = XContentFactory . jsonBuilder ( ) ; classes . toXContent ( responseBuilder , null ) ; String result = null ; if ( type . equals ( <str> ) ) { result = <str> ; } else { result = <str> ; } assertThat ( responseBuilder . string ( ) , equalTo ( result ) ) ; } public void testDeletesIssue7951 ( ) throws Exception { String settings = <str> ; String mappings = <str> ; assertAcked ( prepareCreate ( INDEX_NAME ) . setSettings ( settings ) . addMapping ( <str> , mappings ) ) ; String [ ] cat1v1 = { <str> , <str> } ; String [ ] cat1v2 = { <str> , <str> } ; String [ ] cat2v1 = { <str> , <str> } ; String [ ] cat2v2 = { <str> , <str> } ; List < IndexRequestBuilder > indexRequestBuilderList = new ArrayList < > ( ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , cat1v1 , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , cat1v2 , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , cat2v1 , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , cat2v2 , CLASS_FIELD , <str> ) ) ; indexRandom ( true , false , indexRequestBuilderList ) ; String [ ] text = cat1v1 ; indexRequestBuilderList . clear ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { text = text = = cat1v2 ? cat1v1 : cat1v2 ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , text , CLASS_FIELD , <str> ) ) ; } indexRandom ( true , false , indexRequestBuilderList ) ; SearchResponse response1 = client ( ) . prepareSearch ( INDEX_NAME ) . setTypes ( DOC_TYPE ) . addAggregation ( new TermsBuilder ( <str> ) . field ( CLASS_FIELD ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( TEXT_FIELD ) . minDocCount ( <int> ) ) ) . execute ( ) . actionGet ( ) ; } public void testBackgroundVsSeparateSet ( ) throws Exception { String type = randomBoolean ( ) ? <str> : <str> ; String settings = <str> ; SharedSignificantTermsTestMethods . index01Docs ( type , settings , this ) ; testBackgroundVsSeparateSet ( new MutualInformation . MutualInformationBuilder ( true , true ) , new MutualInformation . MutualInformationBuilder ( true , false ) ) ; testBackgroundVsSeparateSet ( new ChiSquare . ChiSquareBuilder ( true , true ) , new ChiSquare . ChiSquareBuilder ( true , false ) ) ; testBackgroundVsSeparateSet ( new GND . GNDBuilder ( true ) , new GND . GNDBuilder ( false ) ) ; } public void testBackgroundVsSeparateSet ( SignificanceHeuristicBuilder significanceHeuristicExpectingSuperset , SignificanceHeuristicBuilder significanceHeuristicExpectingSeparateSets ) throws Exception { SearchResponse response1 = client ( ) . prepareSearch ( INDEX_NAME ) . setTypes ( DOC_TYPE ) . addAggregation ( new TermsBuilder ( <str> ) . field ( CLASS_FIELD ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( TEXT_FIELD ) . minDocCount ( <int> ) . significanceHeuristic ( significanceHeuristicExpectingSuperset ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response1 ) ; SearchResponse response2 = client ( ) . prepareSearch ( INDEX_NAME ) . setTypes ( DOC_TYPE ) . addAggregation ( ( new FilterAggregationBuilder ( <str> ) ) . filter ( QueryBuilders . termQuery ( CLASS_FIELD , <str> ) ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( TEXT_FIELD ) . minDocCount ( <int> ) . backgroundFilter ( QueryBuilders . termQuery ( CLASS_FIELD , <str> ) ) . significanceHeuristic ( significanceHeuristicExpectingSeparateSets ) ) ) . addAggregation ( ( new FilterAggregationBuilder ( <str> ) ) . filter ( QueryBuilders . termQuery ( CLASS_FIELD , <str> ) ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( TEXT_FIELD ) . minDocCount ( <int> ) . backgroundFilter ( QueryBuilders . termQuery ( CLASS_FIELD , <str> ) ) . significanceHeuristic ( significanceHeuristicExpectingSeparateSets ) ) ) . execute ( ) . actionGet ( ) ; SignificantTerms sigTerms0 = ( ( SignificantTerms ) ( ( ( StringTerms ) response1 . getAggregations ( ) . get ( <str> ) ) . getBucketByKey ( <str> ) . getAggregations ( ) . asMap ( ) . get ( <str> ) ) ) ; assertThat ( sigTerms0 . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; double score00Background = sigTerms0 . getBucketByKey ( <str> ) . getSignificanceScore ( ) ; double score01Background = sigTerms0 . getBucketByKey ( <str> ) . getSignificanceScore ( ) ; SignificantTerms sigTerms1 = ( ( SignificantTerms ) ( ( ( StringTerms ) response1 . getAggregations ( ) . get ( <str> ) ) . getBucketByKey ( <str> ) . getAggregations ( ) . asMap ( ) . get ( <str> ) ) ) ; double score10Background = sigTerms1 . getBucketByKey ( <str> ) . getSignificanceScore ( ) ; double score11Background = sigTerms1 . getBucketByKey ( <str> ) . getSignificanceScore ( ) ; double score00SeparateSets = ( ( SignificantTerms ) ( ( InternalFilter ) response2 . getAggregations ( ) . get ( <str> ) ) . getAggregations ( ) . getAsMap ( ) . get ( <str> ) ) . getBucketByKey ( <str> ) . getSignificanceScore ( ) ; double score01SeparateSets = ( ( SignificantTerms ) ( ( InternalFilter ) response2 . getAggregations ( ) . get ( <str> ) ) . getAggregations ( ) . getAsMap ( ) . get ( <str> ) ) . getBucketByKey ( <str> ) . getSignificanceScore ( ) ; double score10SeparateSets = ( ( SignificantTerms ) ( ( InternalFilter ) response2 . getAggregations ( ) . get ( <str> ) ) . getAggregations ( ) . getAsMap ( ) . get ( <str> ) ) . getBucketByKey ( <str> ) . getSignificanceScore ( ) ; double score11SeparateSets = ( ( SignificantTerms ) ( ( InternalFilter ) response2 . getAggregations ( ) . get ( <str> ) ) . getAggregations ( ) . getAsMap ( ) . get ( <str> ) ) . getBucketByKey ( <str> ) . getSignificanceScore ( ) ; assertThat ( score00Background , equalTo ( score00SeparateSets ) ) ; assertThat ( score01Background , equalTo ( score01SeparateSets ) ) ; assertThat ( score10Background , equalTo ( score10SeparateSets ) ) ; assertThat ( score11Background , equalTo ( score11SeparateSets ) ) ; } public void testScoresEqualForPositiveAndNegative ( ) throws Exception { indexEqualTestData ( ) ; testScoresEqualForPositiveAndNegative ( new MutualInformation . MutualInformationBuilder ( true , true ) ) ; testScoresEqualForPositiveAndNegative ( new ChiSquare . ChiSquareBuilder ( true , true ) ) ; } public void testScoresEqualForPositiveAndNegative ( SignificanceHeuristicBuilder heuristic ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( <str> ) . executionHint ( randomExecutionHint ( ) ) . significanceHeuristic ( heuristic ) . minDocCount ( <int> ) . shardSize ( <int> ) . size ( <int> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; StringTerms classes = ( StringTerms ) response . getAggregations ( ) . get ( <str> ) ; assertThat ( classes . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Iterator < Terms . Bucket > classBuckets = classes . getBuckets ( ) . iterator ( ) ; Collection < SignificantTerms . Bucket > classA = ( ( SignificantTerms ) classBuckets . next ( ) . getAggregations ( ) . get ( <str> ) ) . getBuckets ( ) ; Iterator < SignificantTerms . Bucket > classBBucketIterator = ( ( SignificantTerms ) classBuckets . next ( ) . getAggregations ( ) . get ( <str> ) ) . getBuckets ( ) . iterator ( ) ; assertThat ( classA . size ( ) , greaterThan ( <int> ) ) ; for ( SignificantTerms . Bucket classABucket : classA ) { SignificantTerms . Bucket classBBucket = classBBucketIterator . next ( ) ; assertThat ( classABucket . getKey ( ) , equalTo ( classBBucket . getKey ( ) ) ) ; assertThat ( classABucket . getSignificanceScore ( ) , closeTo ( classBBucket . getSignificanceScore ( ) , <float> ) ) ; } } private void indexEqualTestData ( ) throws ExecutionException , InterruptedException { assertAcked ( prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , <int> , SETTING_NUMBER_OF_REPLICAS , <int> ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; createIndex ( <str> ) ; ensureGreen ( ) ; String data [ ] = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < data . length ; i + + ) { String [ ] parts = data [ i ] . split ( <str> ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( <str> , parts [ <int> ] , <str> , parts [ <int> ] ) ) ; } indexRandom ( true , false , indexRequestBuilders ) ; } public void testScriptScore ( ) throws ExecutionException , InterruptedException , IOException { indexRandomFrequencies01 ( randomBoolean ( ) ? <str> : <str> ) ; ScriptHeuristic . ScriptHeuristicBuilder scriptHeuristicBuilder = getScriptSignificanceHeuristicBuilder ( ) ; ensureYellow ( ) ; SearchResponse response = client ( ) . prepareSearch ( INDEX_NAME ) . addAggregation ( new TermsBuilder ( <str> ) . field ( CLASS_FIELD ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( TEXT_FIELD ) . executionHint ( randomExecutionHint ( ) ) . significanceHeuristic ( scriptHeuristicBuilder ) . minDocCount ( <int> ) . shardSize ( <int> ) . size ( <int> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; for ( Terms . Bucket classBucket : ( ( Terms ) response . getAggregations ( ) . get ( <str> ) ) . getBuckets ( ) ) { for ( SignificantTerms . Bucket bucket : ( ( SignificantTerms ) classBucket . getAggregations ( ) . get ( <str> ) ) . getBuckets ( ) ) { assertThat ( bucket . getSignificanceScore ( ) , is ( ( double ) bucket . getSubsetDf ( ) + bucket . getSubsetSize ( ) + bucket . getSupersetDf ( ) + bucket . getSupersetSize ( ) ) ) ; } } } private ScriptHeuristic . ScriptHeuristicBuilder getScriptSignificanceHeuristicBuilder ( ) throws IOException { Script script = null ; if ( randomBoolean ( ) ) { Map < String , Object > params = null ; params = new HashMap < > ( ) ; params . put ( <str> , randomIntBetween ( <int> , <int> ) ) ; script = new Script ( <str> , ScriptType . INLINE , <str> , params ) ; } else { script = new Script ( <str> , ScriptType . INLINE , <str> , null ) ; } ScriptHeuristic . ScriptHeuristicBuilder builder = new ScriptHeuristic . ScriptHeuristicBuilder ( ) . setScript ( script ) ; return builder ; } private void indexRandomFrequencies01 ( String type ) throws ExecutionException , InterruptedException { String mappings = <str> + DOC_TYPE + <str> + TEXT_FIELD + <str> + type + <str> ; assertAcked ( prepareCreate ( INDEX_NAME ) . addMapping ( DOC_TYPE , mappings ) ) ; String [ ] gb = { <str> , <str> } ; List < IndexRequestBuilder > indexRequestBuilderList = new ArrayList < > ( ) ; for ( int i = <int> ; i < randomInt ( <int> ) ; i + + ) { int randNum = randomInt ( <int> ) ; String [ ] text = new String [ <int> ] ; if ( randNum = = <int> ) { text = gb ; } else { text [ <int> ] = gb [ randNum ] ; } indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE ) . setSource ( TEXT_FIELD , text , CLASS_FIELD , randomBoolean ( ) ? <str> : <str> ) ) ; } indexRandom ( true , indexRequestBuilderList ) ; } public void testReduceFromSeveralShards ( ) throws IOException , ExecutionException , InterruptedException { SharedSignificantTermsTestMethods . aggregateAndCheckFromSeveralShards ( this ) ; } } 
