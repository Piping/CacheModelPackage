package org . elasticsearch . cluster . block ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . rest . RestStatus ; import java . io . IOException ; import java . util . ArrayList ; import java . util . EnumSet ; import java . util . Locale ; public class ClusterBlock implements Streamable , ToXContent { private int id ; private String description ; private EnumSet < ClusterBlockLevel > levels ; private boolean retryable ; private boolean disableStatePersistence = false ; private RestStatus status ; ClusterBlock ( ) { } public ClusterBlock ( int id , String description , boolean retryable , boolean disableStatePersistence , RestStatus status , EnumSet < ClusterBlockLevel > levels ) { this . id = id ; this . description = description ; this . retryable = retryable ; this . disableStatePersistence = disableStatePersistence ; this . status = status ; this . levels = levels ; } public int id ( ) { return this . id ; } public String description ( ) { return this . description ; } public RestStatus status ( ) { return this . status ; } public EnumSet < ClusterBlockLevel > levels ( ) { return this . levels ; } public boolean contains ( ClusterBlockLevel level ) { for ( ClusterBlockLevel testLevel : levels ) { if ( testLevel = = level ) { return true ; } } return false ; } public boolean retryable ( ) { return this . retryable ; } public boolean disableStatePersistence ( ) { return this . disableStatePersistence ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Integer . toString ( id ) ) ; builder . field ( <str> , description ) ; builder . field ( <str> , retryable ) ; if ( disableStatePersistence ) { builder . field ( <str> , disableStatePersistence ) ; } builder . startArray ( <str> ) ; for ( ClusterBlockLevel level : levels ) { builder . value ( level . name ( ) . toLowerCase ( Locale . ROOT ) ) ; } builder . endArray ( ) ; builder . endObject ( ) ; return builder ; } public static ClusterBlock readClusterBlock ( StreamInput in ) throws IOException { ClusterBlock block = new ClusterBlock ( ) ; block . readFrom ( in ) ; return block ; } @Override public void readFrom ( StreamInput in ) throws IOException { id = in . readVInt ( ) ; description = in . readString ( ) ; final int len = in . readVInt ( ) ; ArrayList < ClusterBlockLevel > levels = new ArrayList < > ( ) ; for ( int i = <int> ; i < len ; i + + ) { levels . add ( ClusterBlockLevel . fromId ( in . readVInt ( ) ) ) ; } this . levels = EnumSet . copyOf ( levels ) ; retryable = in . readBoolean ( ) ; disableStatePersistence = in . readBoolean ( ) ; status = RestStatus . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( id ) ; out . writeString ( description ) ; out . writeVInt ( levels . size ( ) ) ; for ( ClusterBlockLevel level : levels ) { out . writeVInt ( level . id ( ) ) ; } out . writeBoolean ( retryable ) ; out . writeBoolean ( disableStatePersistence ) ; RestStatus . writeTo ( out , status ) ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( id ) . append ( <str> ) . append ( description ) . append ( <str> ) ; String delimiter = <str> ; for ( ClusterBlockLevel level : levels ) { sb . append ( delimiter ) . append ( level . name ( ) ) ; delimiter = <str> ; } return sb . toString ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; ClusterBlock that = ( ClusterBlock ) o ; if ( id ! = that . id ) return false ; return true ; } @Override public int hashCode ( ) { return id ; } } 
