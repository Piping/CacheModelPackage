package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . Collections2 . FilteredCollection ; import java . io . Serializable ; import java . util . AbstractSet ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . EnumSet ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Map ; import java . util . NavigableSet ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . SortedSet ; import java . util . TreeSet ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . CopyOnWriteArraySet ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public final class Sets { private Sets ( ) { } abstract static class ImprovedAbstractSet < E > extends AbstractSet < E > { @Override public boolean removeAll ( Collection < ? > c ) { return removeAllImpl ( this , c ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return super . retainAll ( checkNotNull ( c ) ) ; } } @GwtCompatible ( serializable = true ) public static < E extends Enum < E > > ImmutableSet < E > immutableEnumSet ( E anElement , E . . . otherElements ) { return ImmutableEnumSet . asImmutable ( EnumSet . of ( anElement , otherElements ) ) ; } @GwtCompatible ( serializable = true ) public static < E extends Enum < E > > ImmutableSet < E > immutableEnumSet ( Iterable < E > elements ) { if ( elements instanceof ImmutableEnumSet ) { return ( ImmutableEnumSet < E > ) elements ; } else if ( elements instanceof Collection ) { Collection < E > collection = ( Collection < E > ) elements ; if ( collection . isEmpty ( ) ) { return ImmutableSet . of ( ) ; } else { return ImmutableEnumSet . asImmutable ( EnumSet . copyOf ( collection ) ) ; } } else { Iterator < E > itr = elements . iterator ( ) ; if ( itr . hasNext ( ) ) { EnumSet < E > enumSet = EnumSet . of ( itr . next ( ) ) ; Iterators . addAll ( enumSet , itr ) ; return ImmutableEnumSet . asImmutable ( enumSet ) ; } else { return ImmutableSet . of ( ) ; } } } public static < E extends Enum < E > > EnumSet < E > newEnumSet ( Iterable < E > iterable , Class < E > elementType ) { EnumSet < E > set = EnumSet . noneOf ( elementType ) ; Iterables . addAll ( set , iterable ) ; return set ; } public static < E > HashSet < E > newHashSet ( ) { return new HashSet < E > ( ) ; } public static < E > HashSet < E > newHashSet ( E . . . elements ) { HashSet < E > set = newHashSetWithExpectedSize ( elements . length ) ; Collections . addAll ( set , elements ) ; return set ; } public static < E > HashSet < E > newHashSetWithExpectedSize ( int expectedSize ) { return new HashSet < E > ( Maps . capacity ( expectedSize ) ) ; } public static < E > HashSet < E > newHashSet ( Iterable < ? extends E > elements ) { return ( elements instanceof Collection ) ? new HashSet < E > ( Collections2 . cast ( elements ) ) : newHashSet ( elements . iterator ( ) ) ; } public static < E > HashSet < E > newHashSet ( Iterator < ? extends E > elements ) { HashSet < E > set = newHashSet ( ) ; Iterators . addAll ( set , elements ) ; return set ; } public static < E > Set < E > newConcurrentHashSet ( ) { return newSetFromMap ( new ConcurrentHashMap < E , Boolean > ( ) ) ; } public static < E > Set < E > newConcurrentHashSet ( Iterable < ? extends E > elements ) { Set < E > set = newConcurrentHashSet ( ) ; Iterables . addAll ( set , elements ) ; return set ; } public static < E > LinkedHashSet < E > newLinkedHashSet ( ) { return new LinkedHashSet < E > ( ) ; } public static < E > LinkedHashSet < E > newLinkedHashSetWithExpectedSize ( int expectedSize ) { return new LinkedHashSet < E > ( Maps . capacity ( expectedSize ) ) ; } public static < E > LinkedHashSet < E > newLinkedHashSet ( Iterable < ? extends E > elements ) { if ( elements instanceof Collection ) { return new LinkedHashSet < E > ( Collections2 . cast ( elements ) ) ; } LinkedHashSet < E > set = newLinkedHashSet ( ) ; Iterables . addAll ( set , elements ) ; return set ; } public static < E extends Comparable > TreeSet < E > newTreeSet ( ) { return new TreeSet < E > ( ) ; } public static < E extends Comparable > TreeSet < E > newTreeSet ( Iterable < ? extends E > elements ) { TreeSet < E > set = newTreeSet ( ) ; Iterables . addAll ( set , elements ) ; return set ; } public static < E > TreeSet < E > newTreeSet ( Comparator < ? super E > comparator ) { return new TreeSet < E > ( checkNotNull ( comparator ) ) ; } public static < E > Set < E > newIdentityHashSet ( ) { return Sets . newSetFromMap ( Maps . < E , Boolean > newIdentityHashMap ( ) ) ; } @GwtIncompatible ( <str> ) public static < E > CopyOnWriteArraySet < E > newCopyOnWriteArraySet ( ) { return new CopyOnWriteArraySet < E > ( ) ; } @GwtIncompatible ( <str> ) public static < E > CopyOnWriteArraySet < E > newCopyOnWriteArraySet ( Iterable < ? extends E > elements ) { Collection < ? extends E > elementsCollection = ( elements instanceof Collection ) ? Collections2 . cast ( elements ) : Lists . newArrayList ( elements ) ; return new CopyOnWriteArraySet < E > ( elementsCollection ) ; } public static < E extends Enum < E > > EnumSet < E > complementOf ( Collection < E > collection ) { if ( collection instanceof EnumSet ) { return EnumSet . complementOf ( ( EnumSet < E > ) collection ) ; } checkArgument ( ! collection . isEmpty ( ) , <str> ) ; Class < E > type = collection . iterator ( ) . next ( ) . getDeclaringClass ( ) ; return makeComplementByHand ( collection , type ) ; } public static < E extends Enum < E > > EnumSet < E > complementOf ( Collection < E > collection , Class < E > type ) { checkNotNull ( collection ) ; return ( collection instanceof EnumSet ) ? EnumSet . complementOf ( ( EnumSet < E > ) collection ) : makeComplementByHand ( collection , type ) ; } private static < E extends Enum < E > > EnumSet < E > makeComplementByHand ( Collection < E > collection , Class < E > type ) { EnumSet < E > result = EnumSet . allOf ( type ) ; result . removeAll ( collection ) ; return result ; } @Deprecated public static < E > Set < E > newSetFromMap ( Map < E , Boolean > map ) { return Platform . newSetFromMap ( map ) ; } public abstract static class SetView < E > extends AbstractSet < E > { private SetView ( ) { } public ImmutableSet < E > immutableCopy ( ) { return ImmutableSet . copyOf ( this ) ; } public < S extends Set < E > > S copyInto ( S set ) { set . addAll ( this ) ; return set ; } } public static < E > SetView < E > union ( final Set < ? extends E > set1 , final Set < ? extends E > set2 ) { checkNotNull ( set1 , <str> ) ; checkNotNull ( set2 , <str> ) ; final Set < ? extends E > set2minus1 = difference ( set2 , set1 ) ; return new SetView < E > ( ) { @Override public int size ( ) { return set1 . size ( ) + set2minus1 . size ( ) ; } @Override public boolean isEmpty ( ) { return set1 . isEmpty ( ) & & set2 . isEmpty ( ) ; } @Override public Iterator < E > iterator ( ) { return Iterators . unmodifiableIterator ( Iterators . concat ( set1 . iterator ( ) , set2minus1 . iterator ( ) ) ) ; } @Override public boolean contains ( Object object ) { return set1 . contains ( object ) | | set2 . contains ( object ) ; } @Override public < S extends Set < E > > S copyInto ( S set ) { set . addAll ( set1 ) ; set . addAll ( set2 ) ; return set ; } @Override public ImmutableSet < E > immutableCopy ( ) { return new ImmutableSet . Builder < E > ( ) . addAll ( set1 ) . addAll ( set2 ) . build ( ) ; } } ; } public static < E > SetView < E > intersection ( final Set < E > set1 , final Set < ? > set2 ) { checkNotNull ( set1 , <str> ) ; checkNotNull ( set2 , <str> ) ; final Predicate < Object > inSet2 = Predicates . in ( set2 ) ; return new SetView < E > ( ) { @Override public Iterator < E > iterator ( ) { return Iterators . filter ( set1 . iterator ( ) , inSet2 ) ; } @Override public int size ( ) { return Iterators . size ( iterator ( ) ) ; } @Override public boolean isEmpty ( ) { return ! iterator ( ) . hasNext ( ) ; } @Override public boolean contains ( Object object ) { return set1 . contains ( object ) & & set2 . contains ( object ) ; } @Override public boolean containsAll ( Collection < ? > collection ) { return set1 . containsAll ( collection ) & & set2 . containsAll ( collection ) ; } } ; } public static < E > SetView < E > difference ( final Set < E > set1 , final Set < ? > set2 ) { checkNotNull ( set1 , <str> ) ; checkNotNull ( set2 , <str> ) ; final Predicate < Object > notInSet2 = Predicates . not ( Predicates . in ( set2 ) ) ; return new SetView < E > ( ) { @Override public Iterator < E > iterator ( ) { return Iterators . filter ( set1 . iterator ( ) , notInSet2 ) ; } @Override public int size ( ) { return Iterators . size ( iterator ( ) ) ; } @Override public boolean isEmpty ( ) { return set2 . containsAll ( set1 ) ; } @Override public boolean contains ( Object element ) { return set1 . contains ( element ) & & ! set2 . contains ( element ) ; } } ; } public static < E > SetView < E > symmetricDifference ( final Set < ? extends E > set1 , final Set < ? extends E > set2 ) { checkNotNull ( set1 , <str> ) ; checkNotNull ( set2 , <str> ) ; return new SetView < E > ( ) { @Override public Iterator < E > iterator ( ) { final Iterator < ? extends E > itr1 = set1 . iterator ( ) ; final Iterator < ? extends E > itr2 = set2 . iterator ( ) ; return new AbstractIterator < E > ( ) { @Override public E computeNext ( ) { while ( itr1 . hasNext ( ) ) { E elem1 = itr1 . next ( ) ; if ( ! set2 . contains ( elem1 ) ) { return elem1 ; } } while ( itr2 . hasNext ( ) ) { E elem2 = itr2 . next ( ) ; if ( ! set1 . contains ( elem2 ) ) { return elem2 ; } } return endOfData ( ) ; } } ; } @Override public int size ( ) { return Iterators . size ( iterator ( ) ) ; } @Override public boolean isEmpty ( ) { return set1 . equals ( set2 ) ; } @Override public boolean contains ( Object element ) { return set1 . contains ( element ) ^ set2 . contains ( element ) ; } } ; } @CheckReturnValue public static < E > Set < E > filter ( Set < E > unfiltered , Predicate < ? super E > predicate ) { if ( unfiltered instanceof SortedSet ) { return filter ( ( SortedSet < E > ) unfiltered , predicate ) ; } if ( unfiltered instanceof FilteredSet ) { FilteredSet < E > filtered = ( FilteredSet < E > ) unfiltered ; Predicate < E > combinedPredicate = Predicates . < E > and ( filtered . predicate , predicate ) ; return new FilteredSet < E > ( ( Set < E > ) filtered . unfiltered , combinedPredicate ) ; } return new FilteredSet < E > ( checkNotNull ( unfiltered ) , checkNotNull ( predicate ) ) ; } private static class FilteredSet < E > extends FilteredCollection < E > implements Set < E > { FilteredSet ( Set < E > unfiltered , Predicate < ? super E > predicate ) { super ( unfiltered , predicate ) ; } @Override public boolean equals ( @Nullable Object object ) { return equalsImpl ( this , object ) ; } @Override public int hashCode ( ) { return hashCodeImpl ( this ) ; } } @CheckReturnValue public static < E > SortedSet < E > filter ( SortedSet < E > unfiltered , Predicate < ? super E > predicate ) { return Platform . setsFilterSortedSet ( unfiltered , predicate ) ; } static < E > SortedSet < E > filterSortedIgnoreNavigable ( SortedSet < E > unfiltered , Predicate < ? super E > predicate ) { if ( unfiltered instanceof FilteredSet ) { FilteredSet < E > filtered = ( FilteredSet < E > ) unfiltered ; Predicate < E > combinedPredicate = Predicates . < E > and ( filtered . predicate , predicate ) ; return new FilteredSortedSet < E > ( ( SortedSet < E > ) filtered . unfiltered , combinedPredicate ) ; } return new FilteredSortedSet < E > ( checkNotNull ( unfiltered ) , checkNotNull ( predicate ) ) ; } private static class FilteredSortedSet < E > extends FilteredSet < E > implements SortedSet < E > { FilteredSortedSet ( SortedSet < E > unfiltered , Predicate < ? super E > predicate ) { super ( unfiltered , predicate ) ; } @Override public Comparator < ? super E > comparator ( ) { return ( ( SortedSet < E > ) unfiltered ) . comparator ( ) ; } @Override public SortedSet < E > subSet ( E fromElement , E toElement ) { return new FilteredSortedSet < E > ( ( ( SortedSet < E > ) unfiltered ) . subSet ( fromElement , toElement ) , predicate ) ; } @Override public SortedSet < E > headSet ( E toElement ) { return new FilteredSortedSet < E > ( ( ( SortedSet < E > ) unfiltered ) . headSet ( toElement ) , predicate ) ; } @Override public SortedSet < E > tailSet ( E fromElement ) { return new FilteredSortedSet < E > ( ( ( SortedSet < E > ) unfiltered ) . tailSet ( fromElement ) , predicate ) ; } @Override public E first ( ) { return iterator ( ) . next ( ) ; } @Override public E last ( ) { SortedSet < E > sortedUnfiltered = ( SortedSet < E > ) unfiltered ; while ( true ) { E element = sortedUnfiltered . last ( ) ; if ( predicate . apply ( element ) ) { return element ; } sortedUnfiltered = sortedUnfiltered . headSet ( element ) ; } } } @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) @CheckReturnValue public static < E > NavigableSet < E > filter ( NavigableSet < E > unfiltered , Predicate < ? super E > predicate ) { if ( unfiltered instanceof FilteredSet ) { FilteredSet < E > filtered = ( FilteredSet < E > ) unfiltered ; Predicate < E > combinedPredicate = Predicates . < E > and ( filtered . predicate , predicate ) ; return new FilteredNavigableSet < E > ( ( NavigableSet < E > ) filtered . unfiltered , combinedPredicate ) ; } return new FilteredNavigableSet < E > ( checkNotNull ( unfiltered ) , checkNotNull ( predicate ) ) ; } @GwtIncompatible ( <str> ) private static class FilteredNavigableSet < E > extends FilteredSortedSet < E > implements NavigableSet < E > { FilteredNavigableSet ( NavigableSet < E > unfiltered , Predicate < ? super E > predicate ) { super ( unfiltered , predicate ) ; } NavigableSet < E > unfiltered ( ) { return ( NavigableSet < E > ) unfiltered ; } @Override @Nullable public E lower ( E e ) { return Iterators . getNext ( headSet ( e , false ) . descendingIterator ( ) , null ) ; } @Override @Nullable public E floor ( E e ) { return Iterators . getNext ( headSet ( e , true ) . descendingIterator ( ) , null ) ; } @Override public E ceiling ( E e ) { return Iterables . getFirst ( tailSet ( e , true ) , null ) ; } @Override public E higher ( E e ) { return Iterables . getFirst ( tailSet ( e , false ) , null ) ; } @Override public E pollFirst ( ) { return Iterables . removeFirstMatching ( unfiltered ( ) , predicate ) ; } @Override public E pollLast ( ) { return Iterables . removeFirstMatching ( unfiltered ( ) . descendingSet ( ) , predicate ) ; } @Override public NavigableSet < E > descendingSet ( ) { return Sets . filter ( unfiltered ( ) . descendingSet ( ) , predicate ) ; } @Override public Iterator < E > descendingIterator ( ) { return Iterators . filter ( unfiltered ( ) . descendingIterator ( ) , predicate ) ; } @Override public E last ( ) { return descendingIterator ( ) . next ( ) ; } @Override public NavigableSet < E > subSet ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) { return filter ( unfiltered ( ) . subSet ( fromElement , fromInclusive , toElement , toInclusive ) , predicate ) ; } @Override public NavigableSet < E > headSet ( E toElement , boolean inclusive ) { return filter ( unfiltered ( ) . headSet ( toElement , inclusive ) , predicate ) ; } @Override public NavigableSet < E > tailSet ( E fromElement , boolean inclusive ) { return filter ( unfiltered ( ) . tailSet ( fromElement , inclusive ) , predicate ) ; } } public static < B > Set < List < B > > cartesianProduct ( List < ? extends Set < ? extends B > > sets ) { return CartesianSet . create ( sets ) ; } public static < B > Set < List < B > > cartesianProduct ( Set < ? extends B > . . . sets ) { return cartesianProduct ( Arrays . asList ( sets ) ) ; } private static final class CartesianSet < E > extends ForwardingCollection < List < E > > implements Set < List < E > > { private transient final ImmutableList < ImmutableSet < E > > axes ; private transient final CartesianList < E > delegate ; static < E > Set < List < E > > create ( List < ? extends Set < ? extends E > > sets ) { ImmutableList . Builder < ImmutableSet < E > > axesBuilder = new ImmutableList . Builder < ImmutableSet < E > > ( sets . size ( ) ) ; for ( Set < ? extends E > set : sets ) { ImmutableSet < E > copy = ImmutableSet . copyOf ( set ) ; if ( copy . isEmpty ( ) ) { return ImmutableSet . of ( ) ; } axesBuilder . add ( copy ) ; } final ImmutableList < ImmutableSet < E > > axes = axesBuilder . build ( ) ; ImmutableList < List < E > > listAxes = new ImmutableList < List < E > > ( ) { @Override public int size ( ) { return axes . size ( ) ; } @Override public List < E > get ( int index ) { return axes . get ( index ) . asList ( ) ; } @Override boolean isPartialView ( ) { return true ; } } ; return new CartesianSet < E > ( axes , new CartesianList < E > ( listAxes ) ) ; } private CartesianSet ( ImmutableList < ImmutableSet < E > > axes , CartesianList < E > delegate ) { this . axes = axes ; this . delegate = delegate ; } @Override protected Collection < List < E > > delegate ( ) { return delegate ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof CartesianSet ) { CartesianSet < ? > that = ( CartesianSet < ? > ) object ; return this . axes . equals ( that . axes ) ; } return super . equals ( object ) ; } @Override public int hashCode ( ) { int adjust = size ( ) - <int> ; for ( int i = <int> ; i < axes . size ( ) ; i + + ) { adjust * = <int> ; adjust = ~ ~ adjust ; } int hash = <int> ; for ( Set < E > axis : axes ) { hash = <int> * hash + ( size ( ) / axis . size ( ) * axis . hashCode ( ) ) ; hash = ~ ~ hash ; } hash + = adjust ; return ~ ~ hash ; } } @GwtCompatible ( serializable = false ) public static < E > Set < Set < E > > powerSet ( Set < E > set ) { return new PowerSet < E > ( set ) ; } private static final class SubSet < E > extends AbstractSet < E > { private final ImmutableMap < E , Integer > inputSet ; private final int mask ; SubSet ( ImmutableMap < E , Integer > inputSet , int mask ) { this . inputSet = inputSet ; this . mask = mask ; } @Override public Iterator < E > iterator ( ) { return new UnmodifiableIterator < E > ( ) { final ImmutableList < E > elements = inputSet . keySet ( ) . asList ( ) ; int remainingSetBits = mask ; @Override public boolean hasNext ( ) { return remainingSetBits ! = <int> ; } @Override public E next ( ) { int index = Integer . numberOfTrailingZeros ( remainingSetBits ) ; if ( index = = <int> ) { throw new NoSuchElementException ( ) ; } remainingSetBits & = ~ ( <int> < < index ) ; return elements . get ( index ) ; } } ; } @Override public int size ( ) { return Integer . bitCount ( mask ) ; } @Override public boolean contains ( @Nullable Object o ) { Integer index = inputSet . get ( o ) ; return index ! = null & & ( mask & ( <int> < < index ) ) ! = <int> ; } } private static final class PowerSet < E > extends AbstractSet < Set < E > > { final ImmutableMap < E , Integer > inputSet ; PowerSet ( Set < E > input ) { this . inputSet = Maps . indexMap ( input ) ; checkArgument ( inputSet . size ( ) < = <int> , <str> , inputSet . size ( ) ) ; } @Override public int size ( ) { return <int> < < inputSet . size ( ) ; } @Override public boolean isEmpty ( ) { return false ; } @Override public Iterator < Set < E > > iterator ( ) { return new AbstractIndexedListIterator < Set < E > > ( size ( ) ) { @Override protected Set < E > get ( final int setBits ) { return new SubSet < E > ( inputSet , setBits ) ; } } ; } @Override public boolean contains ( @Nullable Object obj ) { if ( obj instanceof Set ) { Set < ? > set = ( Set < ? > ) obj ; return inputSet . keySet ( ) . containsAll ( set ) ; } return false ; } @Override public boolean equals ( @Nullable Object obj ) { if ( obj instanceof PowerSet ) { PowerSet < ? > that = ( PowerSet < ? > ) obj ; return inputSet . equals ( that . inputSet ) ; } return super . equals ( obj ) ; } @Override public int hashCode ( ) { return inputSet . keySet ( ) . hashCode ( ) < < ( inputSet . size ( ) - <int> ) ; } @Override public String toString ( ) { return <str> + inputSet + <str> ; } } static int hashCodeImpl ( Set < ? > s ) { int hashCode = <int> ; for ( Object o : s ) { hashCode + = o ! = null ? o . hashCode ( ) : <int> ; hashCode = ~ ~ hashCode ; } return hashCode ; } static boolean equalsImpl ( Set < ? > s , @Nullable Object object ) { if ( s = = object ) { return true ; } if ( object instanceof Set ) { Set < ? > o = ( Set < ? > ) object ; try { return s . size ( ) = = o . size ( ) & & s . containsAll ( o ) ; } catch ( NullPointerException ignored ) { return false ; } catch ( ClassCastException ignored ) { return false ; } } return false ; } @GwtIncompatible ( <str> ) public static < E > NavigableSet < E > unmodifiableNavigableSet ( NavigableSet < E > set ) { if ( set instanceof ImmutableSortedSet | | set instanceof UnmodifiableNavigableSet ) { return set ; } return new UnmodifiableNavigableSet < E > ( set ) ; } @GwtIncompatible ( <str> ) static final class UnmodifiableNavigableSet < E > extends ForwardingSortedSet < E > implements NavigableSet < E > , Serializable { private final NavigableSet < E > delegate ; UnmodifiableNavigableSet ( NavigableSet < E > delegate ) { this . delegate = checkNotNull ( delegate ) ; } @Override protected SortedSet < E > delegate ( ) { return Collections . unmodifiableSortedSet ( delegate ) ; } @Override public E lower ( E e ) { return delegate . lower ( e ) ; } @Override public E floor ( E e ) { return delegate . floor ( e ) ; } @Override public E ceiling ( E e ) { return delegate . ceiling ( e ) ; } @Override public E higher ( E e ) { return delegate . higher ( e ) ; } @Override public E pollFirst ( ) { throw new UnsupportedOperationException ( ) ; } @Override public E pollLast ( ) { throw new UnsupportedOperationException ( ) ; } private transient UnmodifiableNavigableSet < E > descendingSet ; @Override public NavigableSet < E > descendingSet ( ) { UnmodifiableNavigableSet < E > result = descendingSet ; if ( result = = null ) { result = descendingSet = new UnmodifiableNavigableSet < E > ( delegate . descendingSet ( ) ) ; result . descendingSet = this ; } return result ; } @Override public Iterator < E > descendingIterator ( ) { return Iterators . unmodifiableIterator ( delegate . descendingIterator ( ) ) ; } @Override public NavigableSet < E > subSet ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) { return unmodifiableNavigableSet ( delegate . subSet ( fromElement , fromInclusive , toElement , toInclusive ) ) ; } @Override public NavigableSet < E > headSet ( E toElement , boolean inclusive ) { return unmodifiableNavigableSet ( delegate . headSet ( toElement , inclusive ) ) ; } @Override public NavigableSet < E > tailSet ( E fromElement , boolean inclusive ) { return unmodifiableNavigableSet ( delegate . tailSet ( fromElement , inclusive ) ) ; } private static final long serialVersionUID = <int> ; } @GwtIncompatible ( <str> ) public static < E > NavigableSet < E > synchronizedNavigableSet ( NavigableSet < E > navigableSet ) { return Synchronized . navigableSet ( navigableSet ) ; } static boolean removeAllImpl ( Set < ? > set , Iterator < ? > iterator ) { boolean changed = false ; while ( iterator . hasNext ( ) ) { changed | = set . remove ( iterator . next ( ) ) ; } return changed ; } static boolean removeAllImpl ( Set < ? > set , Collection < ? > collection ) { checkNotNull ( collection ) ; if ( collection instanceof Multiset ) { collection = ( ( Multiset < ? > ) collection ) . elementSet ( ) ; } if ( collection instanceof Set & & collection . size ( ) > set . size ( ) ) { return Iterators . removeAll ( set . iterator ( ) , collection ) ; } else { return removeAllImpl ( set , collection . iterator ( ) ) ; } } @GwtIncompatible ( <str> ) static class DescendingSet < E > extends ForwardingNavigableSet < E > { private final NavigableSet < E > forward ; DescendingSet ( NavigableSet < E > forward ) { this . forward = forward ; } @Override protected NavigableSet < E > delegate ( ) { return forward ; } @Override public E lower ( E e ) { return forward . higher ( e ) ; } @Override public E floor ( E e ) { return forward . ceiling ( e ) ; } @Override public E ceiling ( E e ) { return forward . floor ( e ) ; } @Override public E higher ( E e ) { return forward . lower ( e ) ; } @Override public E pollFirst ( ) { return forward . pollLast ( ) ; } @Override public E pollLast ( ) { return forward . pollFirst ( ) ; } @Override public NavigableSet < E > descendingSet ( ) { return forward ; } @Override public Iterator < E > descendingIterator ( ) { return forward . iterator ( ) ; } @Override public NavigableSet < E > subSet ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) { return forward . subSet ( toElement , toInclusive , fromElement , fromInclusive ) . descendingSet ( ) ; } @Override public NavigableSet < E > headSet ( E toElement , boolean inclusive ) { return forward . tailSet ( toElement , inclusive ) . descendingSet ( ) ; } @Override public NavigableSet < E > tailSet ( E fromElement , boolean inclusive ) { return forward . headSet ( fromElement , inclusive ) . descendingSet ( ) ; } @SuppressWarnings ( <str> ) @Override public Comparator < ? super E > comparator ( ) { Comparator < ? super E > forwardComparator = forward . comparator ( ) ; if ( forwardComparator = = null ) { return ( Comparator ) Ordering . natural ( ) . reverse ( ) ; } else { return reverse ( forwardComparator ) ; } } private static < T > Ordering < T > reverse ( Comparator < T > forward ) { return Ordering . from ( forward ) . reverse ( ) ; } @Override public E first ( ) { return forward . last ( ) ; } @Override public SortedSet < E > headSet ( E toElement ) { return standardHeadSet ( toElement ) ; } @Override public E last ( ) { return forward . first ( ) ; } @Override public SortedSet < E > subSet ( E fromElement , E toElement ) { return standardSubSet ( fromElement , toElement ) ; } @Override public SortedSet < E > tailSet ( E fromElement ) { return standardTailSet ( fromElement ) ; } @Override public Iterator < E > iterator ( ) { return forward . descendingIterator ( ) ; } @Override public Object [ ] toArray ( ) { return standardToArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] array ) { return standardToArray ( array ) ; } @Override public String toString ( ) { return standardToString ( ) ; } } @Beta @GwtIncompatible ( <str> ) public static < K extends Comparable < ? super K > > NavigableSet < K > subSet ( NavigableSet < K > set , Range < K > range ) { if ( set . comparator ( ) ! = null & & set . comparator ( ) ! = Ordering . natural ( ) & & range . hasLowerBound ( ) & & range . hasUpperBound ( ) ) { checkArgument ( set . comparator ( ) . compare ( range . lowerEndpoint ( ) , range . upperEndpoint ( ) ) < = <int> , <str> ) ; } if ( range . hasLowerBound ( ) & & range . hasUpperBound ( ) ) { return set . subSet ( range . lowerEndpoint ( ) , range . lowerBoundType ( ) = = BoundType . CLOSED , range . upperEndpoint ( ) , range . upperBoundType ( ) = = BoundType . CLOSED ) ; } else if ( range . hasLowerBound ( ) ) { return set . tailSet ( range . lowerEndpoint ( ) , range . lowerBoundType ( ) = = BoundType . CLOSED ) ; } else if ( range . hasUpperBound ( ) ) { return set . headSet ( range . upperEndpoint ( ) , range . upperBoundType ( ) = = BoundType . CLOSED ) ; } return checkNotNull ( set ) ; } } 
