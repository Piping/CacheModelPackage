package com . google . common . collect ; import static com . google . common . collect . Iterators . peekingIterator ; import static com . google . common . collect . testing . IteratorFeature . MODIFIABLE ; import static com . google . common . collect . testing . IteratorFeature . UNMODIFIABLE ; import static java . util . Collections . emptyList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . IteratorTester ; import junit . framework . TestCase ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; @SuppressWarnings ( <str> ) @GwtCompatible ( emulated = true ) public class PeekingIteratorTest extends TestCase { private static class PeekingIteratorTester < T > extends IteratorTester < T > { private Iterable < T > master ; private List < T > targetList ; public PeekingIteratorTester ( Collection < T > master ) { super ( master . size ( ) + <int> , MODIFIABLE , master , IteratorTester . KnownOrder . KNOWN_ORDER ) ; this . master = master ; } @Override protected Iterator < T > newTargetIterator ( ) { targetList = Lists . newArrayList ( master ) ; Iterator < T > iterator = targetList . iterator ( ) ; return Iterators . peekingIterator ( iterator ) ; } @Override protected void verify ( List < T > elements ) { assertEquals ( elements , targetList ) ; } } private < T > void actsLikeIteratorHelper ( final List < T > list ) { new PeekingIteratorTester < T > ( list ) . test ( ) ; new IteratorTester < T > ( list . size ( ) * <int> + <int> , UNMODIFIABLE , list , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < T > newTargetIterator ( ) { Iterator < T > iterator = Collections . unmodifiableList ( list ) . iterator ( ) ; return Iterators . peekingIterator ( iterator ) ; } } . test ( ) ; } public void testPeekingIteratorBehavesLikeIteratorOnEmptyIterable ( ) { actsLikeIteratorHelper ( Collections . emptyList ( ) ) ; } public void testPeekingIteratorBehavesLikeIteratorOnSingletonIterable ( ) { actsLikeIteratorHelper ( Collections . singletonList ( new Object ( ) ) ) ; } @GwtIncompatible ( <str> ) public void testPeekingIteratorBehavesLikeIteratorOnThreeElementIterable ( ) { actsLikeIteratorHelper ( Lists . newArrayList ( <str> , <str> , <str> ) ) ; } @GwtIncompatible ( <str> ) public void testPeekingIteratorAcceptsNullElements ( ) { actsLikeIteratorHelper ( Lists . newArrayList ( null , <str> , null ) ) ; } public void testPeekOnEmptyList ( ) { List < ? > list = Collections . emptyList ( ) ; Iterator < ? > iterator = list . iterator ( ) ; PeekingIterator < ? > peekingIterator = Iterators . peekingIterator ( iterator ) ; try { peekingIterator . peek ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException e ) { } } public void testPeekDoesntChangeIteration ( ) { List < ? > list = Lists . newArrayList ( <str> , <str> , <str> ) ; Iterator < ? > iterator = list . iterator ( ) ; PeekingIterator < ? > peekingIterator = Iterators . peekingIterator ( iterator ) ; assertEquals ( <str> , <str> , peekingIterator . peek ( ) ) ; assertEquals ( <str> , <str> , peekingIterator . peek ( ) ) ; assertEquals ( <str> , <str> , peekingIterator . next ( ) ) ; assertEquals ( <str> , <str> , peekingIterator . peek ( ) ) ; assertEquals ( <str> , <str> , peekingIterator . peek ( ) ) ; assertEquals ( <str> , <str> , peekingIterator . next ( ) ) ; assertEquals ( <str> , <str> , peekingIterator . peek ( ) ) ; assertEquals ( <str> , <str> , peekingIterator . peek ( ) ) ; assertEquals ( <str> , <str> , peekingIterator . next ( ) ) ; try { peekingIterator . peek ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException e ) { } try { peekingIterator . peek ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException e ) { } try { peekingIterator . next ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException e ) { } } public void testCantRemoveAfterPeek ( ) { List < String > list = Lists . newArrayList ( <str> , <str> , <str> ) ; Iterator < String > iterator = list . iterator ( ) ; PeekingIterator < ? > peekingIterator = Iterators . peekingIterator ( iterator ) ; assertEquals ( <str> , peekingIterator . next ( ) ) ; assertEquals ( <str> , peekingIterator . peek ( ) ) ; try { peekingIterator . remove ( ) ; fail ( <str> ) ; } catch ( IllegalStateException e ) { } assertEquals ( <str> , <str> , peekingIterator . peek ( ) ) ; assertEquals ( <str> , peekingIterator . next ( ) ) ; peekingIterator . remove ( ) ; assertEquals ( <str> , <int> , list . size ( ) ) ; assertFalse ( <str> , list . contains ( <str> ) ) ; } static class ThrowsAtEndException extends RuntimeException { } static class ThrowsAtEndIterator < E > implements Iterator < E > { Iterator < E > iterator ; public ThrowsAtEndIterator ( Iterable < E > iterable ) { this . iterator = iterable . iterator ( ) ; } @Override public boolean hasNext ( ) { return true ; } @Override public E next ( ) { if ( ! iterator . hasNext ( ) ) { throw new ThrowsAtEndException ( ) ; } return iterator . next ( ) ; } @Override public void remove ( ) { iterator . remove ( ) ; } } public void testPeekingIteratorDoesntAdvancePrematurely ( ) throws Exception { List < Integer > list = emptyList ( ) ; Iterator < Integer > iterator = peekingIterator ( new ThrowsAtEndIterator < Integer > ( list ) ) ; assertNextThrows ( iterator ) ; list = Lists . newArrayList ( <int> , <int> ) ; iterator = peekingIterator ( new ThrowsAtEndIterator < Integer > ( list ) ) ; assertTrue ( iterator . hasNext ( ) ) ; iterator . next ( ) ; assertTrue ( iterator . hasNext ( ) ) ; iterator . next ( ) ; assertNextThrows ( iterator ) ; } private void assertNextThrows ( Iterator < ? > iterator ) { try { iterator . next ( ) ; fail ( ) ; } catch ( ThrowsAtEndException expected ) { } } } 
