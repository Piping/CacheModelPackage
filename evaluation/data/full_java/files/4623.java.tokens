package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IMemoryBlockExtension ; import org . eclipse . debug . core . model . MemoryByte ; import org . eclipse . debug . internal . ui . DebugUIMessages ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . views . memory . MemoryViewUtil ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . memory . AbstractTableRendering ; import org . eclipse . jface . viewers . ICellModifier ; import org . eclipse . swt . widgets . TableItem ; public class TableRenderingCellModifier implements ICellModifier { private boolean editActionInvoked = false ; private AbstractTableRendering fRendering ; public TableRenderingCellModifier ( AbstractTableRendering rendering ) { fRendering = rendering ; } @Override public boolean canModify ( Object element , String property ) { boolean canModify = true ; try { if ( ! ( element instanceof TableRenderingLine ) ) return false ; if ( ! editActionInvoked ) return false ; if ( fRendering = = null ) return false ; if ( fRendering . getMemoryBlock ( ) . supportsValueModification ( ) = = false ) { return false ; } TableRenderingLine line = ( TableRenderingLine ) element ; if ( TableRenderingLine . P_ADDRESS . equals ( property ) ) { return false ; } int addressableSize = getAddressableSize ( ) ; int offset = Integer . valueOf ( property , <int> ) . intValue ( ) * addressableSize ; int end = offset + fRendering . getBytesPerColumn ( ) ; for ( int i = offset ; i < end ; i + + ) { MemoryByte oneByte = line . getByte ( i ) ; if ( ! oneByte . isWritable ( ) ) { canModify = false ; } } return canModify ; } catch ( NumberFormatException e ) { canModify = false ; return canModify ; } } private int getAddressableSize ( ) { int addressableSize = fRendering . getAddressableSize ( ) ; if ( addressableSize < <int> ) addressableSize = <int> ; return addressableSize ; } @Override public Object getValue ( Object element , String property ) { if ( ! ( element instanceof TableRenderingLine ) ) return null ; TableRenderingLine line = ( TableRenderingLine ) element ; try { if ( TableRenderingLine . P_ADDRESS . equals ( property ) ) return line . getAddress ( ) ; int offset = Integer . valueOf ( property , <int> ) . intValue ( ) * getAddressableSize ( ) ; int end = offset + fRendering . getBytesPerColumn ( ) ; MemoryByte [ ] memory = line . getBytes ( offset , end ) ; if ( line . isAvailable ( offset , end ) ) { offset = Integer . valueOf ( property , <int> ) . intValue ( ) ; BigInteger address = new BigInteger ( ( ( TableRenderingLine ) element ) . getAddress ( ) , <int> ) ; address = address . add ( BigInteger . valueOf ( offset ) ) ; return fRendering . getString ( fRendering . getRenderingId ( ) , address , memory ) ; } return getPaddedString ( offset , end ) ; } catch ( NumberFormatException e ) { return <str> ; } } @Override public void modify ( Object element , String property , Object value ) { TableRenderingLine line = null ; if ( ! ( element instanceof TableRenderingLine ) ) { line = ( TableRenderingLine ) ( ( TableItem ) element ) . getData ( ) ; } else { line = ( TableRenderingLine ) element ; } if ( ! ( value instanceof String ) ) return ; try { IMemoryBlock memoryBlk = fRendering . getMemoryBlock ( ) ; int lineOffset = Integer . valueOf ( property , <int> ) . intValue ( ) ; BigInteger offset = getOffset ( memoryBlk , line . getAddress ( ) , lineOffset ) ; byte [ ] bytes = null ; String oldValue = ( String ) getValue ( line , property ) ; if ( ! oldValue . equals ( value ) ) { int offsetToLine = Integer . valueOf ( property , <int> ) . intValue ( ) * getAddressableSize ( ) ; int end = offsetToLine + fRendering . getBytesPerColumn ( ) ; MemoryByte [ ] oldArray = line . getBytes ( offsetToLine , end ) ; BigInteger address = new BigInteger ( line . getAddress ( ) , <int> ) ; address = address . add ( BigInteger . valueOf ( offsetToLine ) ) ; bytes = fRendering . getBytes ( fRendering . getRenderingId ( ) , address , oldArray , ( String ) value ) ; if ( bytes = = null ) return ; if ( bytes . length = = <int> ) return ; if ( bytes . length < = oldArray . length ) { boolean changed = false ; for ( int i = <int> ; i < bytes . length ; i + + ) { if ( bytes [ i ] ! = oldArray [ i ] . getValue ( ) ) { changed = true ; break ; } } if ( ! changed ) return ; } } else { return ; } if ( memoryBlk instanceof IMemoryBlockExtension ) ( ( IMemoryBlockExtension ) memoryBlk ) . setValue ( offset , bytes ) ; else memoryBlk . setValue ( offset . longValue ( ) , bytes ) ; } catch ( DebugException e ) { MemoryViewUtil . openError ( DebugUIMessages . MemoryViewCellModifier_failure_title , DebugUIMessages . MemoryViewCellModifier_failed , e ) ; } catch ( NumberFormatException e ) { MemoryViewUtil . openError ( DebugUIMessages . MemoryViewCellModifier_failure_title , DebugUIMessages . MemoryViewCellModifier_failed + <str> + DebugUIMessages . MemoryViewCellModifier_data_is_invalid , null ) ; } } private BigInteger getOffset ( IMemoryBlock memory , String lineAddress , int lineOffset ) throws DebugException { BigInteger lineAddr = new BigInteger ( lineAddress , <int> ) ; BigInteger memoryAddr ; if ( memory instanceof IMemoryBlockExtension ) { memoryAddr = ( ( IMemoryBlockExtension ) memory ) . getBigBaseAddress ( ) ; } else { memoryAddr = BigInteger . valueOf ( memory . getStartAddress ( ) ) ; } if ( memoryAddr = = null ) memoryAddr = new BigInteger ( <str> ) ; return lineAddr . subtract ( memoryAddr ) . add ( BigInteger . valueOf ( lineOffset ) ) ; } public void setEditActionInvoked ( boolean editActionInvoked ) { this . editActionInvoked = editActionInvoked ; } public String getPaddedString ( int start , int end ) { StringBuffer buf = new StringBuffer ( ) ; String paddedStr = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IDebugUIConstants . PREF_PADDED_STR ) ; for ( int i = start ; i < end ; i + + ) { buf . append ( paddedStr ) ; } return buf . toString ( ) ; } } 
