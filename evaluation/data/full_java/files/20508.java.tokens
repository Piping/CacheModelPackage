package io . netty . test . udt . util ; import com . google . caliper . ConfiguredBenchmark ; import com . google . caliper . Environment ; import com . google . caliper . EnvironmentGetter ; import com . google . caliper . Json ; import com . google . caliper . Result ; import com . google . caliper . Run ; import com . google . caliper . Runner ; import com . google . caliper . Scenario ; import com . google . caliper . ScenarioResult ; import com . google . caliper . SimpleBenchmark ; import com . yammer . metrics . core . TimerContext ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Date ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . TreeMap ; import java . util . TreeSet ; public final class CaliperRunner { private static final InternalLogger log = InternalLoggerFactory . getInstance ( CaliperRunner . class ) ; private CaliperRunner ( ) { } public static List < String > valueList ( final String valueText ) { return Arrays . asList ( valueText . split ( <str> ) ) ; } public static void execute ( final Class < ? extends CaliperBench > klaz ) throws Exception { execute ( <str> , klaz ) ; Run run = execute ( <str> , klaz ) ; publish ( newResult ( run ) ) ; } public static Run execute ( final String name , final Class < ? extends CaliperBench > klaz ) throws Exception { final CaliperBench booter = klaz . newInstance ( ) ; final List < Map < String , String > > varsSet = product ( booter ) ; final Run run = newRun ( klaz . getName ( ) ) ; int index = <int> ; for ( final Map < String , String > vars : varsSet ) { final int done = <int> * index + + / varsSet . size ( ) ; log . info ( <str> , name , done , vars ) ; final ConfiguredBenchmark runner = booter . createBenchmark ( vars ) ; final CaliperBench bench = ( CaliperBench ) runner . getBenchmark ( ) ; final CaliperMeasure measure = bench . measure ( ) ; measure . variables ( ) . putAll ( vars ) ; runner . run ( <int> ) ; runner . close ( ) ; measure . appendTo ( run ) ; } return run ; } public static String json ( final Result result ) { return Json . getGsonInstance ( ) . toJson ( result ) ; } public static String signature ( final Map < String , String > map ) { final StringBuilder text = new StringBuilder ( ) ; for ( final String item : map . values ( ) ) { text . append ( String . format ( <str> , item ) ) ; } return text . toString ( ) ; } public static List < Map < String , String > > product ( final SimpleBenchmark bench ) { final Set < Map < String , String > > collect = new HashSet < Map < String , String > > ( ) ; final Map < String , Set < String > > pending = new TreeMap < String , Set < String > > ( ) ; for ( final String name : new TreeSet < String > ( bench . parameterNames ( ) ) ) { pending . put ( name , bench . parameterValues ( name ) ) ; } final List < Map < String , String > > list = new ArrayList < Map < String , String > > ( product ( collect , pending ) ) ; final Comparator < Map < String , String > > comp = new Comparator < Map < String , String > > ( ) { @Override public int compare ( final Map < String , String > o1 , final Map < String , String > o2 ) { return signature ( o1 ) . compareTo ( signature ( o2 ) ) ; } } ; Collections . sort ( list , comp ) ; return list ; } public static Set < Map < String , String > > product ( final Set < Map < String , String > > collect , final Map < String , Set < String > > pending ) { if ( pending . isEmpty ( ) ) { return collect ; } final Set < Map < String , String > > extract = new HashSet < Map < String , String > > ( ) ; final String key = pending . keySet ( ) . iterator ( ) . next ( ) ; for ( final String value : pending . remove ( key ) ) { final Map < String , String > map = new TreeMap < String , String > ( ) ; map . put ( key , value ) ; extract . add ( map ) ; } if ( collect . isEmpty ( ) ) { collect . addAll ( extract ) ; return product ( collect , pending ) ; } else { final Set < Map < String , String > > inject = new HashSet < Map < String , String > > ( ) ; for ( final Map < String , String > mapExtr : extract ) { for ( final Map < String , String > mapColl : collect ) { final Map < String , String > mapProd = new TreeMap < String , String > ( ) ; mapProd . putAll ( mapExtr ) ; mapProd . putAll ( mapColl ) ; inject . add ( mapProd ) ; } } return product ( inject , pending ) ; } } public static void publish ( final Result result ) throws Exception { final Runner runner = new Runner ( ) ; final Method method = runner . getClass ( ) . getDeclaredMethod ( <str> , Result . class ) ; method . setAccessible ( true ) ; method . invoke ( runner , result ) ; } public static Run newRun ( final String benchmarkName ) { final Map < Scenario , ScenarioResult > measurements = new HashMap < Scenario , ScenarioResult > ( ) ; final Date executedTimestamp = new Date ( ) ; return new Run ( measurements , benchmarkName , executedTimestamp ) ; } public static Result newResult ( final Run run ) { final Environment env = new EnvironmentGetter ( ) . getEnvironmentSnapshot ( ) ; return new Result ( run , env ) ; } public static void main ( final String [ ] args ) throws Exception { final Run run = newRun ( <str> ) ; for ( int param = <int> ; param < <int> ; param + + ) { final CaliperMeasure measure = new CaliperMeasure ( ) ; measure . variables ( ) . put ( <str> , String . valueOf ( param ) ) ; for ( int step = <int> ; step < <int> ; step + + ) { measure . rate ( ) . mark ( <int> + step ) ; final TimerContext time = measure . time ( ) . time ( ) ; Thread . sleep ( <int> ) ; time . stop ( ) ; measure . size ( ) . value ( <int> + step ) ; measure . mark ( ) ; } measure . appendTo ( run ) ; } final Result result = newResult ( run ) ; publish ( result ) ; System . out . println ( json ( result ) ) ; } } 
