package org . elasticsearch . index . translog ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . Channels ; import org . elasticsearch . common . util . concurrent . ReleasableLock ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; import java . io . OutputStream ; import java . nio . ByteBuffer ; public final class BufferingTranslogWriter extends TranslogWriter { private byte [ ] buffer ; private int bufferCount ; private WrapperOutputStream bufferOs = new WrapperOutputStream ( ) ; private volatile long totalOffset ; public BufferingTranslogWriter ( ShardId shardId , long generation , ChannelReference channelReference , int bufferSize ) throws IOException { super ( shardId , generation , channelReference ) ; this . buffer = new byte [ bufferSize ] ; this . totalOffset = writtenOffset ; } @Override public Translog . Location add ( BytesReference data ) throws IOException { try ( ReleasableLock lock = writeLock . acquire ( ) ) { ensureOpen ( ) ; operationCounter + + ; final long offset = totalOffset ; if ( data . length ( ) > = buffer . length ) { flush ( ) ; data . writeTo ( channel ) ; writtenOffset + = data . length ( ) ; totalOffset + = data . length ( ) ; return new Translog . Location ( generation , offset , data . length ( ) ) ; } if ( data . length ( ) > buffer . length - bufferCount ) { flush ( ) ; } data . writeTo ( bufferOs ) ; totalOffset + = data . length ( ) ; return new Translog . Location ( generation , offset , data . length ( ) ) ; } } protected final void flush ( ) throws IOException { assert writeLock . isHeldByCurrentThread ( ) ; if ( bufferCount > <int> ) { Channels . writeToChannel ( buffer , <int> , bufferCount , channel ) ; writtenOffset + = bufferCount ; bufferCount = <int> ; } } @Override protected void readBytes ( ByteBuffer targetBuffer , long position ) throws IOException { try ( ReleasableLock lock = readLock . acquire ( ) ) { if ( position > = writtenOffset ) { assert targetBuffer . hasArray ( ) : <str> ; final int sourcePosition = ( int ) ( position - writtenOffset ) ; System . arraycopy ( buffer , sourcePosition , targetBuffer . array ( ) , targetBuffer . position ( ) , targetBuffer . limit ( ) ) ; targetBuffer . position ( targetBuffer . limit ( ) ) ; return ; } } Channels . readFromFileChannelWithEofException ( channel , position , targetBuffer ) ; } @Override public boolean syncNeeded ( ) { return totalOffset ! = lastSyncedOffset ; } @Override public void sync ( ) throws IOException { if ( ! syncNeeded ( ) ) { return ; } synchronized ( this ) { channelReference . incRef ( ) ; try { try ( ReleasableLock lock = writeLock . acquire ( ) ) { flush ( ) ; lastSyncedOffset = totalOffset ; } checkpoint ( lastSyncedOffset , operationCounter , channelReference ) ; } finally { channelReference . decRef ( ) ; } } } public void updateBufferSize ( int bufferSize ) { try ( ReleasableLock lock = writeLock . acquire ( ) ) { ensureOpen ( ) ; if ( this . buffer . length ! = bufferSize ) { flush ( ) ; this . buffer = new byte [ bufferSize ] ; } } catch ( IOException e ) { throw new TranslogException ( shardId , <str> , e ) ; } } class WrapperOutputStream extends OutputStream { @Override public void write ( int b ) throws IOException { buffer [ bufferCount + + ] = ( byte ) b ; } @Override public void write ( byte [ ] b , int off , int len ) throws IOException { System . arraycopy ( b , off , buffer , bufferCount , len ) ; bufferCount + = len ; } } @Override public long sizeInBytes ( ) { return totalOffset ; } } 
