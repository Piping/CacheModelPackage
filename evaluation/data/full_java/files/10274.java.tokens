package com . google . common . cache ; import static com . google . common . cache . TestingCacheLoaders . identityLoader ; import static com . google . common . cache . TestingRemovalListeners . countingRemovalListener ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import com . google . common . cache . TestingCacheLoaders . IdentityLoader ; import com . google . common . cache . TestingRemovalListeners . CountingRemovalListener ; import com . google . common . cache . TestingRemovalListeners . QueuingRemovalListener ; import com . google . common . collect . Iterators ; import com . google . common . testing . FakeTicker ; import com . google . common . util . concurrent . Callables ; import junit . framework . TestCase ; import java . util . List ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; @SuppressWarnings ( <str> ) public class CacheExpirationTest extends TestCase { private static final long EXPIRING_TIME = <int> ; private static final int VALUE_PREFIX = <int> ; private static final String KEY_PREFIX = <str> ; public void testExpiration_expireAfterWrite ( ) { FakeTicker ticker = new FakeTicker ( ) ; CountingRemovalListener < String , Integer > removalListener = countingRemovalListener ( ) ; WatchedCreatorLoader loader = new WatchedCreatorLoader ( ) ; LoadingCache < String , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( EXPIRING_TIME , MILLISECONDS ) . removalListener ( removalListener ) . ticker ( ticker ) . build ( loader ) ; checkExpiration ( cache , loader , ticker , removalListener ) ; } public void testExpiration_expireAfterAccess ( ) { FakeTicker ticker = new FakeTicker ( ) ; CountingRemovalListener < String , Integer > removalListener = countingRemovalListener ( ) ; WatchedCreatorLoader loader = new WatchedCreatorLoader ( ) ; LoadingCache < String , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( EXPIRING_TIME , MILLISECONDS ) . removalListener ( removalListener ) . ticker ( ticker ) . build ( loader ) ; checkExpiration ( cache , loader , ticker , removalListener ) ; } private void checkExpiration ( LoadingCache < String , Integer > cache , WatchedCreatorLoader loader , FakeTicker ticker , CountingRemovalListener < String , Integer > removalListener ) { for ( int i = <int> ; i < <int> ; i + + ) { assertEquals ( Integer . valueOf ( VALUE_PREFIX + i ) , cache . getUnchecked ( KEY_PREFIX + i ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { loader . reset ( ) ; assertEquals ( Integer . valueOf ( VALUE_PREFIX + i ) , cache . getUnchecked ( KEY_PREFIX + i ) ) ; assertFalse ( <str> + i , loader . wasCalled ( ) ) ; } CacheTesting . expireEntries ( ( LoadingCache < ? , ? > ) cache , EXPIRING_TIME , ticker ) ; assertEquals ( <str> , <int> , cache . size ( ) ) ; assertEquals ( <str> , <int> , removalListener . getCount ( ) ) ; CacheTesting . expireEntries ( ( LoadingCache < ? , ? > ) cache , EXPIRING_TIME , ticker ) ; assertEquals ( <str> , <int> , removalListener . getCount ( ) ) ; } public void testExpiringGet_expireAfterWrite ( ) { FakeTicker ticker = new FakeTicker ( ) ; CountingRemovalListener < String , Integer > removalListener = countingRemovalListener ( ) ; WatchedCreatorLoader loader = new WatchedCreatorLoader ( ) ; LoadingCache < String , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( EXPIRING_TIME , MILLISECONDS ) . removalListener ( removalListener ) . ticker ( ticker ) . build ( loader ) ; runExpirationTest ( cache , loader , ticker , removalListener ) ; } public void testExpiringGet_expireAfterAccess ( ) { FakeTicker ticker = new FakeTicker ( ) ; CountingRemovalListener < String , Integer > removalListener = countingRemovalListener ( ) ; WatchedCreatorLoader loader = new WatchedCreatorLoader ( ) ; LoadingCache < String , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( EXPIRING_TIME , MILLISECONDS ) . removalListener ( removalListener ) . ticker ( ticker ) . build ( loader ) ; runExpirationTest ( cache , loader , ticker , removalListener ) ; } private void runExpirationTest ( LoadingCache < String , Integer > cache , WatchedCreatorLoader loader , FakeTicker ticker , CountingRemovalListener < String , Integer > removalListener ) { for ( int i = <int> ; i < <int> ; i + + ) { assertEquals ( Integer . valueOf ( VALUE_PREFIX + i ) , cache . getUnchecked ( KEY_PREFIX + i ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { loader . reset ( ) ; assertEquals ( Integer . valueOf ( VALUE_PREFIX + i ) , cache . getUnchecked ( KEY_PREFIX + i ) ) ; assertFalse ( <str> + i , loader . wasCalled ( ) ) ; } ticker . advance ( EXPIRING_TIME * <int> , MILLISECONDS ) ; cache . getUnchecked ( KEY_PREFIX + <int> ) ; assertEquals ( <int> , Iterators . size ( cache . asMap ( ) . entrySet ( ) . iterator ( ) ) ) ; assertEquals ( <int> , Iterators . size ( cache . asMap ( ) . keySet ( ) . iterator ( ) ) ) ; assertEquals ( <int> , Iterators . size ( cache . asMap ( ) . values ( ) . iterator ( ) ) ) ; CacheTesting . expireEntries ( ( LoadingCache < ? , ? > ) cache , EXPIRING_TIME , ticker ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertFalse ( cache . asMap ( ) . containsKey ( KEY_PREFIX + i ) ) ; } assertEquals ( <int> , removalListener . getCount ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertFalse ( cache . asMap ( ) . containsKey ( KEY_PREFIX + i ) ) ; loader . reset ( ) ; assertEquals ( Integer . valueOf ( VALUE_PREFIX + i ) , cache . getUnchecked ( KEY_PREFIX + i ) ) ; assertTrue ( <str> + i , loader . wasCalled ( ) ) ; } CacheTesting . expireEntries ( ( LoadingCache < ? , ? > ) cache , EXPIRING_TIME , ticker ) ; assertEquals ( <str> , <int> , removalListener . getCount ( ) ) ; CacheTesting . expireEntries ( ( LoadingCache < ? , ? > ) cache , EXPIRING_TIME , ticker ) ; assertEquals ( <str> , <int> , removalListener . getCount ( ) ) ; } public void testRemovalListener_expireAfterWrite ( ) { FakeTicker ticker = new FakeTicker ( ) ; final AtomicInteger evictionCount = new AtomicInteger ( ) ; final AtomicInteger applyCount = new AtomicInteger ( ) ; final AtomicInteger totalSum = new AtomicInteger ( ) ; RemovalListener < Integer , AtomicInteger > removalListener = new RemovalListener < Integer , AtomicInteger > ( ) { @Override public void onRemoval ( RemovalNotification < Integer , AtomicInteger > notification ) { if ( notification . wasEvicted ( ) ) { evictionCount . incrementAndGet ( ) ; totalSum . addAndGet ( notification . getValue ( ) . get ( ) ) ; } } } ; CacheLoader < Integer , AtomicInteger > loader = new CacheLoader < Integer , AtomicInteger > ( ) { @Override public AtomicInteger load ( Integer key ) { applyCount . incrementAndGet ( ) ; return new AtomicInteger ( ) ; } } ; LoadingCache < Integer , AtomicInteger > cache = CacheBuilder . newBuilder ( ) . removalListener ( removalListener ) . expireAfterWrite ( <int> , MILLISECONDS ) . ticker ( ticker ) . build ( loader ) ; for ( int i = <int> ; i < <int> ; + + i ) { cache . getUnchecked ( <int> ) . incrementAndGet ( ) ; ticker . advance ( <int> , MILLISECONDS ) ; } assertEquals ( evictionCount . get ( ) + <int> , applyCount . get ( ) ) ; int remaining = cache . getUnchecked ( <int> ) . get ( ) ; assertEquals ( <int> , totalSum . get ( ) + remaining ) ; } public void testRemovalScheduler_expireAfterWrite ( ) { FakeTicker ticker = new FakeTicker ( ) ; CountingRemovalListener < String , Integer > removalListener = countingRemovalListener ( ) ; WatchedCreatorLoader loader = new WatchedCreatorLoader ( ) ; LoadingCache < String , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( EXPIRING_TIME , MILLISECONDS ) . removalListener ( removalListener ) . ticker ( ticker ) . build ( loader ) ; runRemovalScheduler ( cache , removalListener , loader , ticker , KEY_PREFIX , EXPIRING_TIME ) ; } public void testRemovalScheduler_expireAfterAccess ( ) { FakeTicker ticker = new FakeTicker ( ) ; CountingRemovalListener < String , Integer > removalListener = countingRemovalListener ( ) ; WatchedCreatorLoader loader = new WatchedCreatorLoader ( ) ; LoadingCache < String , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( EXPIRING_TIME , MILLISECONDS ) . removalListener ( removalListener ) . ticker ( ticker ) . build ( loader ) ; runRemovalScheduler ( cache , removalListener , loader , ticker , KEY_PREFIX , EXPIRING_TIME ) ; } public void testRemovalScheduler_expireAfterBoth ( ) { FakeTicker ticker = new FakeTicker ( ) ; CountingRemovalListener < String , Integer > removalListener = countingRemovalListener ( ) ; WatchedCreatorLoader loader = new WatchedCreatorLoader ( ) ; LoadingCache < String , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( EXPIRING_TIME , MILLISECONDS ) . expireAfterWrite ( EXPIRING_TIME , MILLISECONDS ) . removalListener ( removalListener ) . ticker ( ticker ) . build ( loader ) ; runRemovalScheduler ( cache , removalListener , loader , ticker , KEY_PREFIX , EXPIRING_TIME ) ; } public void testExpirationOrder_access ( ) { FakeTicker ticker = new FakeTicker ( ) ; IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . expireAfterAccess ( <int> , MILLISECONDS ) . ticker ( ticker ) . build ( loader ) ; for ( int i = <int> ; i < <int> ; i + + ) { cache . getUnchecked ( i ) ; ticker . advance ( <int> , MILLISECONDS ) ; } Set < Integer > keySet = cache . asMap ( ) . keySet ( ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> ) ; } public void testExpirationOrder_write ( ) throws ExecutionException { FakeTicker ticker = new FakeTicker ( ) ; IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . expireAfterWrite ( <int> , MILLISECONDS ) . ticker ( ticker ) . build ( loader ) ; for ( int i = <int> ; i < <int> ; i + + ) { cache . getUnchecked ( i ) ; ticker . advance ( <int> , MILLISECONDS ) ; } Set < Integer > keySet = cache . asMap ( ) . keySet ( ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; cache . get ( <int> , Callables . returning ( - <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; cache . asMap ( ) . put ( <int> , - <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; cache . asMap ( ) . replace ( <int> , - <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; } public void testExpirationOrder_writeAccess ( ) throws ExecutionException { FakeTicker ticker = new FakeTicker ( ) ; IdentityLoader < Integer > loader = identityLoader ( ) ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) . expireAfterWrite ( <int> , MILLISECONDS ) . expireAfterAccess ( <int> , MILLISECONDS ) . ticker ( ticker ) . build ( loader ) ; for ( int i = <int> ; i < <int> ; i + + ) { cache . getUnchecked ( i ) ; } ticker . advance ( <int> , MILLISECONDS ) ; for ( int i = <int> ; i < <int> ; i + + ) { cache . getUnchecked ( i ) ; } ticker . advance ( <int> , MILLISECONDS ) ; Set < Integer > keySet = cache . asMap ( ) . keySet ( ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; getAll ( cache , asList ( <int> , <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> , <int> ) ; cache . asMap ( ) . put ( <int> , - <int> ) ; getAll ( cache , asList ( <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> , <int> ) ; cache . asMap ( ) . replace ( <int> , - <int> ) ; cache . get ( <int> , Callables . returning ( - <int> ) ) ; CacheTesting . drainRecencyQueues ( cache ) ; ticker . advance ( <int> , MILLISECONDS ) ; assertThat ( keySet ) . containsExactly ( <int> , <int> ) ; } public void testExpiration_invalidateAll ( ) { FakeTicker ticker = new FakeTicker ( ) ; QueuingRemovalListener < Integer , Integer > listener = TestingRemovalListeners . queuingRemovalListener ( ) ; Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( <int> , TimeUnit . MINUTES ) . removalListener ( listener ) . ticker ( ticker ) . build ( ) ; cache . put ( <int> , <int> ) ; ticker . advance ( <int> , TimeUnit . MINUTES ) ; cache . invalidateAll ( ) ; assertThat ( listener . poll ( ) . getCause ( ) ) . isEqualTo ( RemovalCause . EXPIRED ) ; } private void runRemovalScheduler ( LoadingCache < String , Integer > cache , CountingRemovalListener < String , Integer > removalListener , WatchedCreatorLoader loader , FakeTicker ticker , String keyPrefix , long ttl ) { int shift1 = <int> + VALUE_PREFIX ; loader . setValuePrefix ( shift1 ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertEquals ( Integer . valueOf ( i + shift1 ) , cache . getUnchecked ( keyPrefix + i ) ) ; } assertEquals ( <int> , CacheTesting . expirationQueueSize ( cache ) ) ; assertEquals ( <int> , removalListener . getCount ( ) ) ; ticker . advance ( ttl * <int> / <int> , MILLISECONDS ) ; assertEquals ( <int> , CacheTesting . expirationQueueSize ( cache ) ) ; assertEquals ( <int> , removalListener . getCount ( ) ) ; int shift2 = shift1 + <int> ; loader . setValuePrefix ( shift2 ) ; for ( int i = <int> ; i < <int> ; i + + ) { cache . invalidate ( keyPrefix + i ) ; assertEquals ( <str> + keyPrefix + i , Integer . valueOf ( i + shift2 ) , cache . getUnchecked ( keyPrefix + i ) ) ; } assertEquals ( <int> , CacheTesting . expirationQueueSize ( cache ) ) ; assertEquals ( <int> , removalListener . getCount ( ) ) ; ticker . advance ( ttl * <int> / <int> , MILLISECONDS ) ; assertEquals ( <int> , CacheTesting . expirationQueueSize ( cache ) ) ; assertEquals ( <int> , removalListener . getCount ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { loader . reset ( ) ; assertEquals ( Integer . valueOf ( i + shift2 ) , cache . getUnchecked ( keyPrefix + i ) ) ; assertFalse ( <str> + i , loader . wasCalled ( ) ) ; } assertEquals ( <int> , removalListener . getCount ( ) ) ; } private static void getAll ( LoadingCache < Integer , Integer > cache , List < Integer > keys ) { for ( int i : keys ) { cache . getUnchecked ( i ) ; } } private static class WatchedCreatorLoader extends CacheLoader < String , Integer > { boolean wasCalled = false ; String keyPrefix = KEY_PREFIX ; int valuePrefix = VALUE_PREFIX ; public WatchedCreatorLoader ( ) { } public void reset ( ) { wasCalled = false ; } public boolean wasCalled ( ) { return wasCalled ; } public void setKeyPrefix ( String keyPrefix ) { this . keyPrefix = keyPrefix ; } public void setValuePrefix ( int valuePrefix ) { this . valuePrefix = valuePrefix ; } @Override public Integer load ( String key ) { wasCalled = true ; return valuePrefix + Integer . parseInt ( key . substring ( keyPrefix . length ( ) ) ) ; } } } 
