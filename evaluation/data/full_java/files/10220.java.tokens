package com . google . common . math ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import java . util . Random ; public class LessThanBenchmark { static final int SAMPLE_SIZE = <hex> ; static final int SAMPLE_MASK = <hex> ; @Param ( <str> ) int randomSeed ; int [ ] xInts ; int [ ] yInts ; long [ ] xLongs ; long [ ] yLongs ; int [ ] constant ; private static final long NONNEGATIVE_LONG_MASK = <hex> ; @BeforeExperiment void setUp ( ) { Random random = new Random ( randomSeed ) ; xInts = new int [ SAMPLE_SIZE ] ; yInts = new int [ SAMPLE_SIZE ] ; xLongs = new long [ SAMPLE_SIZE ] ; yLongs = new long [ SAMPLE_SIZE ] ; constant = new int [ SAMPLE_SIZE ] ; for ( int i = <int> ; i < SAMPLE_SIZE ; i + + ) { xInts [ i ] = random . nextInt ( Integer . MAX_VALUE ) ; yInts [ i ] = random . nextInt ( Integer . MAX_VALUE ) ; xLongs [ i ] = random . nextLong ( ) & NONNEGATIVE_LONG_MASK ; yLongs [ i ] = random . nextLong ( ) & NONNEGATIVE_LONG_MASK ; constant [ i ] = random . nextInt ( ) ; } } @Benchmark int branchFreeLtIntInlined ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & SAMPLE_MASK ; int x = xInts [ j ] ; int y = yInts [ j ] ; int z = constant [ j ] ; tmp + = z + ( ( x - y ) > > > ( Integer . SIZE - <int> ) ) ; } return tmp ; } @Benchmark int branchFreeLtInt ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & SAMPLE_MASK ; int x = xInts [ j ] ; int y = yInts [ j ] ; int z = constant [ j ] ; tmp + = z + IntMath . lessThanBranchFree ( x , y ) ; } return tmp ; } @Benchmark int ternaryLtIntAddOutsideTernary ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & SAMPLE_MASK ; int x = xInts [ j ] ; int y = yInts [ j ] ; int z = constant [ j ] ; tmp + = z + ( ( x < y ) ? <int> : <int> ) ; } return tmp ; } @Benchmark int ternaryLtIntAddInsideTernary ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & SAMPLE_MASK ; int x = xInts [ j ] ; int y = yInts [ j ] ; int z = constant [ j ] ; tmp + = ( x < y ) ? z + <int> : z ; } return tmp ; } @Benchmark int branchFreeLtLongInlined ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & SAMPLE_MASK ; long x = xLongs [ j ] ; long y = yLongs [ j ] ; int z = constant [ j ] ; tmp + = z + ( int ) ( ( x - y ) > > > ( Long . SIZE - <int> ) ) ; } return tmp ; } @Benchmark int branchFreeLtLong ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & SAMPLE_MASK ; long x = xLongs [ j ] ; long y = yLongs [ j ] ; int z = constant [ j ] ; tmp + = z + LongMath . lessThanBranchFree ( x , y ) ; } return tmp ; } @Benchmark int ternaryLtLongAddOutsideTernary ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & SAMPLE_MASK ; long x = xLongs [ j ] ; long y = yLongs [ j ] ; int z = constant [ j ] ; tmp + = z + ( ( x < y ) ? <int> : <int> ) ; } return tmp ; } @Benchmark int ternaryLtLongAddInsideTernary ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & SAMPLE_MASK ; long x = xLongs [ j ] ; long y = yLongs [ j ] ; int z = constant [ j ] ; tmp + = ( x < y ) ? z + <int> : z ; } return tmp ; } } 
