package org . gradle . gradleplugin . userinterface . swing . generic ; import org . gradle . foundation . ProjectView ; import org . gradle . foundation . TaskView ; import org . gradle . foundation . visitors . TaskTreePopulationVisitor ; import org . gradle . gradleplugin . foundation . GradlePluginLord ; import org . gradle . gradleplugin . foundation . filters . ProjectAndTaskFilter ; import javax . swing . * ; import javax . swing . tree . * ; import java . awt . * ; import java . awt . event . * ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Enumeration ; import java . util . List ; public class TaskTreeComponent { private GradlePluginLord gradlePluginLord ; private Interaction interaction ; private JTree tree ; private DefaultTreeModel model ; private TaskTreeBaseNode rootNode ; private boolean isPopulated ; private TaskTreeComponent . Renderer renderer ; public interface Interaction { void rightClick ( JTree tree , int x , int y ) ; void projectInvoked ( ProjectView project ) ; void taskInvoked ( TaskView task , boolean isCtrlKeyDown ) ; } public TaskTreeComponent ( GradlePluginLord gradlePluginLord , Interaction interaction ) { this . gradlePluginLord = gradlePluginLord ; this . interaction = interaction ; createTreePanel ( ) ; } private void createTreePanel ( ) { rootNode = new TaskTreeBaseNode ( ) ; model = new DefaultTreeModel ( rootNode ) ; tree = new JTree ( model ) ; tree . setRootVisible ( false ) ; tree . setShowsRootHandles ( true ) ; renderer = new Renderer ( ) ; tree . setCellRenderer ( renderer ) ; ToolTipManager . sharedInstance ( ) . registerComponent ( tree ) ; tree . setToggleClickCount ( <int> ) ; tree . addMouseListener ( new MyMouseListener ( ) ) ; tree . registerKeyboardAction ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { executeFirstSelectedNode ( false ) ; } } , KeyStroke . getKeyStroke ( KeyEvent . VK_ENTER , <int> ) , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; tree . registerKeyboardAction ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { executeFirstSelectedNode ( true ) ; } } , KeyStroke . getKeyStroke ( KeyEvent . VK_ENTER , KeyEvent . CTRL_MASK ) , JComponent . WHEN_IN_FOCUSED_WINDOW ) ; } public JTree getTree ( ) { return tree ; } public void setTreeCellRenderer ( TreeCellRenderer renderer ) { tree . setCellRenderer ( renderer ) ; } private class Renderer implements TreeCellRenderer { private JPanel panel ; private DefaultTreeCellRenderer nameRenderer ; private DefaultTreeCellRenderer descriptionRenderer ; private Color descriptionColor ; private boolean showDescription = true ; private Component seperator ; private Font normalFont ; private Font boldFont ; private Renderer ( ) { setupRendererUI ( ) ; setShowDescription ( true ) ; descriptionColor = Color . blue ; } private void setupRendererUI ( ) { panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; nameRenderer = new DefaultTreeCellRenderer ( ) ; descriptionRenderer = new DefaultTreeCellRenderer ( ) ; panel . add ( nameRenderer ) ; seperator = Box . createHorizontalStrut ( <int> ) ; panel . add ( seperator ) ; panel . add ( descriptionRenderer ) ; panel . setOpaque ( false ) ; setupFonts ( ) ; } private void setupFonts ( ) { normalFont = nameRenderer . getFont ( ) . deriveFont ( Font . PLAIN ) ; boldFont = normalFont . deriveFont ( Font . BOLD ) ; nameRenderer . setFont ( normalFont ) ; descriptionRenderer . setFont ( normalFont ) ; } public boolean showDescription ( ) { return showDescription ; } public void setShowDescription ( boolean showDescription ) { this . showDescription = showDescription ; seperator . setVisible ( showDescription ) ; descriptionRenderer . setVisible ( showDescription ) ; seperator . invalidate ( ) ; nameRenderer . invalidate ( ) ; descriptionRenderer . invalidate ( ) ; panel . invalidate ( ) ; Enumeration enumeration = rootNode . breadthFirstEnumeration ( ) ; while ( enumeration . hasMoreElements ( ) ) { TaskTreeBaseNode treeNode = ( TaskTreeBaseNode ) enumeration . nextElement ( ) ; model . nodeChanged ( treeNode ) ; } tree . repaint ( ) ; } public Component getTreeCellRendererComponent ( JTree tree , Object value , boolean isSelected , boolean expanded , boolean leaf , int row , boolean hasFocus ) { TaskTreeBaseNode node = ( TaskTreeBaseNode ) value ; String description = node . getDescription ( ) ; this . nameRenderer . getTreeCellRendererComponent ( tree , node . toString ( ) , isSelected , expanded , leaf , row , hasFocus ) ; this . descriptionRenderer . getTreeCellRendererComponent ( tree , description , isSelected , expanded , leaf , row , false ) ; panel . setToolTipText ( description ) ; nameRenderer . setIcon ( null ) ; this . descriptionRenderer . setIcon ( null ) ; if ( node . isBold ( ) ) { nameRenderer . setFont ( boldFont ) ; } else { nameRenderer . setFont ( normalFont ) ; } if ( ! isSelected ) { this . descriptionRenderer . setForeground ( descriptionColor ) ; } else { this . descriptionRenderer . setForeground ( nameRenderer . getForeground ( ) ) ; } nameRenderer . invalidate ( ) ; descriptionRenderer . invalidate ( ) ; seperator . invalidate ( ) ; panel . invalidate ( ) ; panel . validate ( ) ; return panel ; } } private class MyMouseListener extends MouseAdapter { public void mousePressed ( MouseEvent e ) { if ( e . getButton ( ) = = MouseEvent . BUTTON3 ) { Point point = e . getPoint ( ) ; int row = tree . getRowForLocation ( point . x , point . y ) ; if ( row ! = - <int> ) { if ( tree . isRowSelected ( row ) ) { return ; } if ( isAddToSelectionKey ( e ) ) { tree . addSelectionRow ( row ) ; } else { tree . setSelectionRow ( row ) ; } } } } private boolean isAddToSelectionKey ( MouseEvent e ) { return ( e . getModifiers ( ) & MouseEvent . CTRL_MASK ) ! = <int> ; } public void mouseClicked ( MouseEvent e ) { if ( e . getClickCount ( ) = = <int> ) { if ( e . getButton ( ) = = MouseEvent . BUTTON3 ) { Point point = e . getPoint ( ) ; interaction . rightClick ( tree , point . x , point . y ) ; } } else if ( e . getClickCount ( ) = = <int> ) { TaskTreeBaseNode node = getNodeAtPoint ( e . getPoint ( ) ) ; if ( node ! = null ) { boolean isCtrlKeyDown = ( e . getModifiers ( ) & MouseEvent . CTRL_MASK ) ! = <int> ; node . executeTask ( isCtrlKeyDown ) ; } } } } public void populate ( ProjectAndTaskFilter filter ) { TaskTreePopulationVisitor . visitProjectAndTasks ( gradlePluginLord . getProjects ( ) , new PopulateTreeVisitor ( ) , filter , rootNode ) ; model . reload ( ) ; SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { tree . expandRow ( <int> ) ; } } ) ; isPopulated = true ; } public boolean isPopulated ( ) { return isPopulated ; } private class PopulateTreeVisitor implements TaskTreePopulationVisitor . Visitor < TaskTreeBaseNode , TaskTreeNode > { public TaskTreeBaseNode visitProject ( ProjectView project , int indexOfProject , TaskTreeBaseNode parentProjectObject ) { ProjectTreeNode projectTreeNode = findProjectChild ( parentProjectObject , project . getName ( ) ) ; if ( projectTreeNode = = null ) { projectTreeNode = new ProjectTreeNode ( project ) ; } int actualIndex = parentProjectObject . getIndex ( projectTreeNode ) ; if ( actualIndex ! = indexOfProject ) { if ( actualIndex ! = - <int> ) { model . removeNodeFromParent ( projectTreeNode ) ; } insertChildNode ( parentProjectObject , projectTreeNode , indexOfProject ) ; } return projectTreeNode ; } private ProjectTreeNode findProjectChild ( TaskTreeBaseNode parentNode , String projectName ) { for ( int index = <int> ; index < parentNode . getChildCount ( ) ; index + + ) { TreeNode child = parentNode . getChildAt ( index ) ; if ( child instanceof ProjectTreeNode ) { if ( ( ( ProjectTreeNode ) child ) . getProject ( ) . getName ( ) . equals ( projectName ) ) { return ( ProjectTreeNode ) child ; } } } return null ; } public TaskTreeNode visitTask ( TaskView task , int indexOfTask , ProjectView tasksProject , TaskTreeBaseNode parentTreeNode ) { TaskTreeNode taskTreeNode = findTaskChild ( ( ProjectTreeNode ) parentTreeNode , task . getName ( ) ) ; if ( taskTreeNode = = null ) { taskTreeNode = new TaskTreeNode ( task ) ; } int actualIndex = parentTreeNode . getIndex ( taskTreeNode ) ; if ( actualIndex ! = indexOfTask ) { if ( actualIndex ! = - <int> ) { model . removeNodeFromParent ( taskTreeNode ) ; } insertChildNode ( parentTreeNode , taskTreeNode , indexOfTask ) ; } return taskTreeNode ; } private void insertChildNode ( DefaultMutableTreeNode parent , DefaultMutableTreeNode child , int index ) { if ( parent . getChildCount ( ) < index ) { parent . add ( child ) ; model . nodesWereInserted ( parent , new int [ ] { parent . getChildCount ( ) - <int> } ) ; } else { parent . insert ( child , index ) ; model . nodesWereInserted ( parent , new int [ ] { index } ) ; } } private TaskTreeNode findTaskChild ( ProjectTreeNode parentNode , String taskName ) { for ( int index = <int> ; index < parentNode . getChildCount ( ) ; index + + ) { TreeNode child = parentNode . getChildAt ( index ) ; if ( child instanceof TaskTreeNode ) { if ( ( ( TaskTreeNode ) child ) . getTask ( ) . getName ( ) . equals ( taskName ) ) { return ( TaskTreeNode ) child ; } } } return null ; } public void completedVisitingProject ( TaskTreeBaseNode parentProjectObject , List < TaskTreeBaseNode > projectObjects , List < TaskTreeNode > taskObjects ) { int index = <int> ; while ( index < parentProjectObject . getChildCount ( ) ) { TaskTreeBaseNode child = ( TaskTreeBaseNode ) parentProjectObject . getChildAt ( index ) ; if ( ! projectObjects . contains ( child ) & & ! taskObjects . contains ( child ) ) { model . removeNodeFromParent ( child ) ; } else { index + + ; } } } } private void expandNode ( TreeNode node ) { tree . expandPath ( new TreePath ( node ) ) ; } public class TaskTreeBaseNode extends DefaultMutableTreeNode { public void executeTask ( boolean isCtrlKeyDown ) { } public String toString ( ) { return <str> ; } public String getDescription ( ) { return null ; } public boolean isBold ( ) { return false ; } } public class ProjectTreeNode extends TaskTreeBaseNode { private ProjectView project ; private ProjectTreeNode ( ProjectView project ) { this . project = project ; } public String toString ( ) { return project . getName ( ) ; } @Override public void executeTask ( boolean isCtrlKeyDown ) { interaction . projectInvoked ( project ) ; } @Override public String getDescription ( ) { return project . getDescription ( ) ; } public ProjectView getProject ( ) { return project ; } } public class TaskTreeNode extends TaskTreeBaseNode { private TaskView task ; private TaskTreeNode ( TaskView task ) { this . task = task ; } public String toString ( ) { return task . getName ( ) ; } @Override public void executeTask ( boolean isCtrlKeyDown ) { interaction . taskInvoked ( task , isCtrlKeyDown ) ; } public TaskView getTask ( ) { return task ; } @Override public String getDescription ( ) { return task . getDescription ( ) ; } @Override public boolean isBold ( ) { return task . isDefault ( ) ; } } public TaskTreeBaseNode getNodeAtPoint ( Point point ) { int row = tree . getRowForLocation ( point . x , point . y ) ; if ( row = = - <int> ) { return null ; } TreePath path = tree . getPathForLocation ( point . x , point . y ) ; if ( path = = null ) { return null ; } return ( TaskTreeBaseNode ) path . getLastPathComponent ( ) ; } public TaskTreeBaseNode getFirstSelectedNode ( ) { TreePath path = tree . getSelectionPath ( ) ; if ( path = = null ) { return null ; } return ( TaskTreeBaseNode ) path . getLastPathComponent ( ) ; } public List < TaskTreeBaseNode > getSelectedNodes ( ) { TreePath [ ] treePaths = tree . getSelectionPaths ( ) ; if ( treePaths = = null ) { return Collections . emptyList ( ) ; } List < TaskTreeBaseNode > nodes = new ArrayList < TaskTreeBaseNode > ( ) ; for ( int index = <int> ; index < treePaths . length ; index + + ) { TreePath treePath = treePaths [ index ] ; nodes . add ( ( TaskTreeBaseNode ) treePath . getLastPathComponent ( ) ) ; } return nodes ; } public boolean hasProjectsSelected ( ) { TreePath [ ] treePaths = tree . getSelectionPaths ( ) ; if ( treePaths = = null ) { return false ; } for ( int index = <int> ; index < treePaths . length ; index + + ) { TreePath treePath = treePaths [ index ] ; Object o = treePath . getLastPathComponent ( ) ; if ( o instanceof ProjectTreeNode ) { return true ; } } return false ; } public boolean hasTasksSelected ( ) { TreePath [ ] treePaths = tree . getSelectionPaths ( ) ; if ( treePaths = = null ) { return false ; } for ( int index = <int> ; index < treePaths . length ; index + + ) { TreePath treePath = treePaths [ index ] ; Object o = treePath . getLastPathComponent ( ) ; if ( o instanceof TaskTreeNode ) { return true ; } } return false ; } public List < TaskView > getSelectedTasks ( ) { TreePath [ ] treePaths = tree . getSelectionPaths ( ) ; if ( treePaths = = null ) { return Collections . emptyList ( ) ; } List < TaskView > tasks = new ArrayList < TaskView > ( ) ; for ( int index = <int> ; index < treePaths . length ; index + + ) { TreePath treePath = treePaths [ index ] ; Object o = treePath . getLastPathComponent ( ) ; if ( o instanceof TaskTreeNode ) { tasks . add ( ( ( TaskTreeNode ) o ) . task ) ; } } return tasks ; } public class MultipleSelection { public List < ProjectView > projects = new ArrayList < ProjectView > ( ) ; public List < TaskView > tasks = new ArrayList < TaskView > ( ) ; } public MultipleSelection getSelectedProjectsAndTasks ( ) { MultipleSelection multipleSelection = new MultipleSelection ( ) ; TreePath [ ] treePaths = tree . getSelectionPaths ( ) ; if ( treePaths = = null ) { return multipleSelection ; } for ( int index = <int> ; index < treePaths . length ; index + + ) { TreePath treePath = treePaths [ index ] ; Object o = treePath . getLastPathComponent ( ) ; if ( o instanceof TaskTreeNode ) { multipleSelection . tasks . add ( ( ( TaskTreeNode ) o ) . getTask ( ) ) ; } else if ( o instanceof ProjectTreeNode ) { multipleSelection . projects . add ( ( ( ProjectTreeNode ) o ) . getProject ( ) ) ; } } return multipleSelection ; } public boolean showDescription ( ) { return renderer . showDescription ( ) ; } public void setShowDescription ( boolean showDescription ) { this . renderer . setShowDescription ( showDescription ) ; } private void executeFirstSelectedNode ( boolean isCtrlKeyDown ) { TaskTreeComponent . TaskTreeBaseNode node = getFirstSelectedNode ( ) ; if ( node ! = null ) { node . executeTask ( isCtrlKeyDown ) ; } } } 
