package org . apache . cassandra . service ; import org . apache . cassandra . concurrent . JMXEnabledThreadPoolExecutor ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . locator . AbstractReplicationStrategy ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; public class PendingRangeCalculatorService { public static final PendingRangeCalculatorService instance = new PendingRangeCalculatorService ( ) ; private static Logger logger = LoggerFactory . getLogger ( PendingRangeCalculatorService . class ) ; private final JMXEnabledThreadPoolExecutor executor = new JMXEnabledThreadPoolExecutor ( <int> , Integer . MAX_VALUE , TimeUnit . SECONDS , new LinkedBlockingQueue < Runnable > ( <int> ) , new NamedThreadFactory ( <str> ) , <str> ) ; private AtomicInteger updateJobs = new AtomicInteger ( <int> ) ; public PendingRangeCalculatorService ( ) { executor . setRejectedExecutionHandler ( new RejectedExecutionHandler ( ) { public void rejectedExecution ( Runnable r , ThreadPoolExecutor e ) { PendingRangeCalculatorService . instance . finishUpdate ( ) ; } } ) ; } private static class PendingRangeTask implements Runnable { public void run ( ) { long start = System . currentTimeMillis ( ) ; for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) { calculatePendingRanges ( Keyspace . open ( keyspaceName ) . getReplicationStrategy ( ) , keyspaceName ) ; } PendingRangeCalculatorService . instance . finishUpdate ( ) ; logger . debug ( <str> , Schema . instance . getNonSystemKeyspaces ( ) . size ( ) , System . currentTimeMillis ( ) - start ) ; } } private void finishUpdate ( ) { updateJobs . decrementAndGet ( ) ; } public void update ( ) { updateJobs . incrementAndGet ( ) ; executor . submit ( new PendingRangeTask ( ) ) ; } public void blockUntilFinished ( ) { while ( updateJobs . get ( ) > <int> ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } } public static void calculatePendingRanges ( AbstractReplicationStrategy strategy , String keyspaceName ) { StorageService . instance . getTokenMetadata ( ) . calculatePendingRanges ( strategy , keyspaceName ) ; } } 
