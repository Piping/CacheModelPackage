package org . elasticsearch . common . lucene . search . function ; import org . apache . lucene . search . Explanation ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import java . io . IOException ; import java . util . Locale ; public enum CombineFunction implements Writeable < CombineFunction > { MULTIPLY { @Override public float combine ( double queryScore , double funcScore , double maxBoost ) { return toFloat ( queryScore * Math . min ( funcScore , maxBoost ) ) ; } @Override public Explanation explain ( Explanation queryExpl , Explanation funcExpl , float maxBoost ) { Explanation boostExpl = Explanation . match ( maxBoost , <str> ) ; Explanation minExpl = Explanation . match ( Math . min ( funcExpl . getValue ( ) , maxBoost ) , <str> , funcExpl , boostExpl ) ; return Explanation . match ( queryExpl . getValue ( ) * minExpl . getValue ( ) , <str> , queryExpl , minExpl ) ; } } , REPLACE { @Override public float combine ( double queryScore , double funcScore , double maxBoost ) { return toFloat ( Math . min ( funcScore , maxBoost ) ) ; } @Override public Explanation explain ( Explanation queryExpl , Explanation funcExpl , float maxBoost ) { Explanation boostExpl = Explanation . match ( maxBoost , <str> ) ; return Explanation . match ( Math . min ( funcExpl . getValue ( ) , maxBoost ) , <str> , funcExpl , boostExpl ) ; } } , SUM { @Override public float combine ( double queryScore , double funcScore , double maxBoost ) { return toFloat ( queryScore + Math . min ( funcScore , maxBoost ) ) ; } @Override public Explanation explain ( Explanation queryExpl , Explanation funcExpl , float maxBoost ) { Explanation minExpl = Explanation . match ( Math . min ( funcExpl . getValue ( ) , maxBoost ) , <str> , funcExpl , Explanation . match ( maxBoost , <str> ) ) ; return Explanation . match ( Math . min ( funcExpl . getValue ( ) , maxBoost ) + queryExpl . getValue ( ) , <str> , queryExpl , minExpl ) ; } } , AVG { @Override public float combine ( double queryScore , double funcScore , double maxBoost ) { return toFloat ( ( Math . min ( funcScore , maxBoost ) + queryScore ) / <float> ) ; } @Override public Explanation explain ( Explanation queryExpl , Explanation funcExpl , float maxBoost ) { Explanation minExpl = Explanation . match ( Math . min ( funcExpl . getValue ( ) , maxBoost ) , <str> , funcExpl , Explanation . match ( maxBoost , <str> ) ) ; return Explanation . match ( toFloat ( ( Math . min ( funcExpl . getValue ( ) , maxBoost ) + queryExpl . getValue ( ) ) / <float> ) , <str> , queryExpl , minExpl ) ; } } , MIN { @Override public float combine ( double queryScore , double funcScore , double maxBoost ) { return toFloat ( Math . min ( queryScore , Math . min ( funcScore , maxBoost ) ) ) ; } @Override public Explanation explain ( Explanation queryExpl , Explanation funcExpl , float maxBoost ) { Explanation innerMinExpl = Explanation . match ( Math . min ( funcExpl . getValue ( ) , maxBoost ) , <str> , funcExpl , Explanation . match ( maxBoost , <str> ) ) ; return Explanation . match ( Math . min ( Math . min ( funcExpl . getValue ( ) , maxBoost ) , queryExpl . getValue ( ) ) , <str> , queryExpl , innerMinExpl ) ; } } , MAX { @Override public float combine ( double queryScore , double funcScore , double maxBoost ) { return toFloat ( Math . max ( queryScore , Math . min ( funcScore , maxBoost ) ) ) ; } @Override public Explanation explain ( Explanation queryExpl , Explanation funcExpl , float maxBoost ) { Explanation innerMinExpl = Explanation . match ( Math . min ( funcExpl . getValue ( ) , maxBoost ) , <str> , funcExpl , Explanation . match ( maxBoost , <str> ) ) ; return Explanation . match ( Math . max ( Math . min ( funcExpl . getValue ( ) , maxBoost ) , queryExpl . getValue ( ) ) , <str> , queryExpl , innerMinExpl ) ; } } ; public abstract float combine ( double queryScore , double funcScore , double maxBoost ) ; public static float toFloat ( double input ) { assert deviation ( input ) < = <float> : <str> + input + <str> + deviation ( input ) ; return ( float ) input ; } private static double deviation ( double input ) { float floatVersion = ( float ) input ; return Double . compare ( floatVersion , input ) = = <int> | | input = = <float> ? <int> : <float> - ( floatVersion ) / input ; } public abstract Explanation explain ( Explanation queryExpl , Explanation funcExpl , float maxBoost ) ; @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( this . ordinal ( ) ) ; } @Override public CombineFunction readFrom ( StreamInput in ) throws IOException { int ordinal = in . readVInt ( ) ; if ( ordinal < <int> | | ordinal > = values ( ) . length ) { throw new IOException ( <str> + ordinal + <str> ) ; } return values ( ) [ ordinal ] ; } public static CombineFunction readCombineFunctionFrom ( StreamInput in ) throws IOException { return CombineFunction . MULTIPLY . readFrom ( in ) ; } public static CombineFunction fromString ( String combineFunction ) { return valueOf ( combineFunction . toUpperCase ( Locale . ROOT ) ) ; } } 
