package com . google . common . hash ; import static com . google . common . base . Preconditions . checkArgument ; import com . google . common . math . LongMath ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import java . math . RoundingMode ; import java . util . Arrays ; enum BloomFilterStrategies implements BloomFilter . Strategy { MURMUR128_MITZ_32 ( ) { @Override public < T > boolean put ( T object , Funnel < ? super T > funnel , int numHashFunctions , BitArray bits ) { long bitSize = bits . bitSize ( ) ; long hash64 = Hashing . murmur3_128 ( ) . hashObject ( object , funnel ) . asLong ( ) ; int hash1 = ( int ) hash64 ; int hash2 = ( int ) ( hash64 > > > <int> ) ; boolean bitsChanged = false ; for ( int i = <int> ; i < = numHashFunctions ; i + + ) { int combinedHash = hash1 + ( i * hash2 ) ; if ( combinedHash < <int> ) { combinedHash = ~ combinedHash ; } bitsChanged | = bits . set ( combinedHash % bitSize ) ; } return bitsChanged ; } @Override public < T > boolean mightContain ( T object , Funnel < ? super T > funnel , int numHashFunctions , BitArray bits ) { long bitSize = bits . bitSize ( ) ; long hash64 = Hashing . murmur3_128 ( ) . hashObject ( object , funnel ) . asLong ( ) ; int hash1 = ( int ) hash64 ; int hash2 = ( int ) ( hash64 > > > <int> ) ; for ( int i = <int> ; i < = numHashFunctions ; i + + ) { int combinedHash = hash1 + ( i * hash2 ) ; if ( combinedHash < <int> ) { combinedHash = ~ combinedHash ; } if ( ! bits . get ( combinedHash % bitSize ) ) { return false ; } } return true ; } } , MURMUR128_MITZ_64 ( ) { @Override public < T > boolean put ( T object , Funnel < ? super T > funnel , int numHashFunctions , BitArray bits ) { long bitSize = bits . bitSize ( ) ; byte [ ] bytes = Hashing . murmur3_128 ( ) . hashObject ( object , funnel ) . getBytesInternal ( ) ; long hash1 = lowerEight ( bytes ) ; long hash2 = upperEight ( bytes ) ; boolean bitsChanged = false ; long combinedHash = hash1 ; for ( int i = <int> ; i < numHashFunctions ; i + + ) { bitsChanged | = bits . set ( ( combinedHash & Long . MAX_VALUE ) % bitSize ) ; combinedHash + = hash2 ; } return bitsChanged ; } @Override public < T > boolean mightContain ( T object , Funnel < ? super T > funnel , int numHashFunctions , BitArray bits ) { long bitSize = bits . bitSize ( ) ; byte [ ] bytes = Hashing . murmur3_128 ( ) . hashObject ( object , funnel ) . getBytesInternal ( ) ; long hash1 = lowerEight ( bytes ) ; long hash2 = upperEight ( bytes ) ; long combinedHash = hash1 ; for ( int i = <int> ; i < numHashFunctions ; i + + ) { if ( ! bits . get ( ( combinedHash & Long . MAX_VALUE ) % bitSize ) ) { return false ; } combinedHash + = hash2 ; } return true ; } private long lowerEight ( byte [ ] bytes ) { return Longs . fromBytes ( bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] ) ; } private long upperEight ( byte [ ] bytes ) { return Longs . fromBytes ( bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] ) ; } } ; static final class BitArray { final long [ ] data ; long bitCount ; BitArray ( long bits ) { this ( new long [ Ints . checkedCast ( LongMath . divide ( bits , <int> , RoundingMode . CEILING ) ) ] ) ; } BitArray ( long [ ] data ) { checkArgument ( data . length > <int> , <str> ) ; this . data = data ; long bitCount = <int> ; for ( long value : data ) { bitCount + = Long . bitCount ( value ) ; } this . bitCount = bitCount ; } boolean set ( long index ) { if ( ! get ( index ) ) { data [ ( int ) ( index > > > <int> ) ] | = ( <int> < < index ) ; bitCount + + ; return true ; } return false ; } boolean get ( long index ) { return ( data [ ( int ) ( index > > > <int> ) ] & ( <int> < < index ) ) ! = <int> ; } long bitSize ( ) { return ( long ) data . length * Long . SIZE ; } long bitCount ( ) { return bitCount ; } BitArray copy ( ) { return new BitArray ( data . clone ( ) ) ; } void putAll ( BitArray array ) { checkArgument ( data . length = = array . data . length , <str> , data . length , array . data . length ) ; bitCount = <int> ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] | = array . data [ i ] ; bitCount + = Long . bitCount ( data [ i ] ) ; } } @Override public boolean equals ( Object o ) { if ( o instanceof BitArray ) { BitArray bitArray = ( BitArray ) o ; return Arrays . equals ( data , bitArray . data ) ; } return false ; } @Override public int hashCode ( ) { return Arrays . hashCode ( data ) ; } } } 
