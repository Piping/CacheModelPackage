package org . elasticsearch . cluster . metadata ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . action . admin . indices . alias . Alias ; import org . elasticsearch . action . support . master . MasterNodeRequest ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateUpdateTask ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . ValidationException ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . indices . IndexTemplateAlreadyExistsException ; import org . elasticsearch . indices . IndexTemplateMissingException ; import org . elasticsearch . indices . InvalidIndexTemplateException ; import java . util . * ; public class MetaDataIndexTemplateService extends AbstractComponent { private final ClusterService clusterService ; private final AliasValidator aliasValidator ; private final MetaDataCreateIndexService metaDataCreateIndexService ; @Inject public MetaDataIndexTemplateService ( Settings settings , ClusterService clusterService , MetaDataCreateIndexService metaDataCreateIndexService , AliasValidator aliasValidator ) { super ( settings ) ; this . clusterService = clusterService ; this . aliasValidator = aliasValidator ; this . metaDataCreateIndexService = metaDataCreateIndexService ; } public void removeTemplates ( final RemoveRequest request , final RemoveListener listener ) { clusterService . submitStateUpdateTask ( <str> + request . name + <str> , new ClusterStateUpdateTask ( Priority . URGENT ) { @Override public TimeValue timeout ( ) { return request . masterTimeout ; } @Override public void onFailure ( String source , Throwable t ) { listener . onFailure ( t ) ; } @Override public ClusterState execute ( ClusterState currentState ) { Set < String > templateNames = new HashSet < > ( ) ; for ( ObjectCursor < String > cursor : currentState . metaData ( ) . templates ( ) . keys ( ) ) { String templateName = cursor . value ; if ( Regex . simpleMatch ( request . name , templateName ) ) { templateNames . add ( templateName ) ; } } if ( templateNames . isEmpty ( ) ) { if ( Regex . isMatchAllPattern ( request . name ) ) { return currentState ; } throw new IndexTemplateMissingException ( request . name ) ; } MetaData . Builder metaData = MetaData . builder ( currentState . metaData ( ) ) ; for ( String templateName : templateNames ) { metaData . removeTemplate ( templateName ) ; } return ClusterState . builder ( currentState ) . metaData ( metaData ) . build ( ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { listener . onResponse ( new RemoveResponse ( true ) ) ; } } ) ; } public void putTemplate ( final PutRequest request , final PutListener listener ) { Settings . Builder updatedSettingsBuilder = Settings . settingsBuilder ( ) ; updatedSettingsBuilder . put ( request . settings ) . normalizePrefix ( IndexMetaData . INDEX_SETTING_PREFIX ) ; request . settings ( updatedSettingsBuilder . build ( ) ) ; if ( request . name = = null ) { listener . onFailure ( new IllegalArgumentException ( <str> ) ) ; return ; } if ( request . template = = null ) { listener . onFailure ( new IllegalArgumentException ( <str> ) ) ; return ; } try { validate ( request ) ; } catch ( Throwable e ) { listener . onFailure ( e ) ; return ; } IndexTemplateMetaData . Builder templateBuilder ; try { templateBuilder = IndexTemplateMetaData . builder ( request . name ) ; templateBuilder . order ( request . order ) ; templateBuilder . template ( request . template ) ; templateBuilder . settings ( request . settings ) ; for ( Map . Entry < String , String > entry : request . mappings . entrySet ( ) ) { templateBuilder . putMapping ( entry . getKey ( ) , entry . getValue ( ) ) ; } for ( Alias alias : request . aliases ) { AliasMetaData aliasMetaData = AliasMetaData . builder ( alias . name ( ) ) . filter ( alias . filter ( ) ) . indexRouting ( alias . indexRouting ( ) ) . searchRouting ( alias . searchRouting ( ) ) . build ( ) ; templateBuilder . putAlias ( aliasMetaData ) ; } for ( Map . Entry < String , IndexMetaData . Custom > entry : request . customs . entrySet ( ) ) { templateBuilder . putCustom ( entry . getKey ( ) , entry . getValue ( ) ) ; } } catch ( Throwable e ) { listener . onFailure ( e ) ; return ; } final IndexTemplateMetaData template = templateBuilder . build ( ) ; clusterService . submitStateUpdateTask ( <str> + request . name + <str> + request . cause + <str> , new ClusterStateUpdateTask ( Priority . URGENT ) { @Override public TimeValue timeout ( ) { return request . masterTimeout ; } @Override public void onFailure ( String source , Throwable t ) { listener . onFailure ( t ) ; } @Override public ClusterState execute ( ClusterState currentState ) { if ( request . create & & currentState . metaData ( ) . templates ( ) . containsKey ( request . name ) ) { throw new IndexTemplateAlreadyExistsException ( request . name ) ; } MetaData . Builder builder = MetaData . builder ( currentState . metaData ( ) ) . put ( template ) ; return ClusterState . builder ( currentState ) . metaData ( builder ) . build ( ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { listener . onResponse ( new PutResponse ( true , template ) ) ; } } ) ; } private void validate ( PutRequest request ) { List < String > validationErrors = new ArrayList < > ( ) ; if ( request . name . contains ( <str> ) ) { validationErrors . add ( <str> ) ; } if ( request . name . contains ( <str> ) ) { validationErrors . add ( <str> ) ; } if ( request . name . contains ( <str> ) ) { validationErrors . add ( <str> ) ; } if ( request . name . startsWith ( <str> ) ) { validationErrors . add ( <str> ) ; } if ( ! request . name . toLowerCase ( Locale . ROOT ) . equals ( request . name ) ) { validationErrors . add ( <str> ) ; } if ( request . template . contains ( <str> ) ) { validationErrors . add ( <str> ) ; } if ( request . template . contains ( <str> ) ) { validationErrors . add ( <str> ) ; } if ( request . template . contains ( <str> ) ) { validationErrors . add ( <str> ) ; } if ( request . template . startsWith ( <str> ) ) { validationErrors . add ( <str> ) ; } if ( ! Strings . validFileNameExcludingAstrix ( request . template ) ) { validationErrors . add ( <str> + Strings . INVALID_FILENAME_CHARS ) ; } List < String > indexSettingsValidation = metaDataCreateIndexService . getIndexSettingsValidationErrors ( request . settings ) ; validationErrors . addAll ( indexSettingsValidation ) ; if ( ! validationErrors . isEmpty ( ) ) { ValidationException validationException = new ValidationException ( ) ; validationException . addValidationErrors ( validationErrors ) ; throw new InvalidIndexTemplateException ( request . name , validationException . getMessage ( ) ) ; } for ( Alias alias : request . aliases ) { aliasValidator . validateAliasStandalone ( alias ) ; if ( request . template . equals ( alias . name ( ) ) ) { throw new IllegalArgumentException ( <str> + alias . name ( ) + <str> + request . template + <str> ) ; } } } public static interface PutListener { void onResponse ( PutResponse response ) ; void onFailure ( Throwable t ) ; } public static class PutRequest { final String name ; final String cause ; boolean create ; int order ; String template ; Settings settings = Settings . Builder . EMPTY_SETTINGS ; Map < String , String > mappings = new HashMap < > ( ) ; List < Alias > aliases = new ArrayList < > ( ) ; Map < String , IndexMetaData . Custom > customs = new HashMap < > ( ) ; TimeValue masterTimeout = MasterNodeRequest . DEFAULT_MASTER_NODE_TIMEOUT ; public PutRequest ( String cause , String name ) { this . cause = cause ; this . name = name ; } public PutRequest order ( int order ) { this . order = order ; return this ; } public PutRequest template ( String template ) { this . template = template ; return this ; } public PutRequest create ( boolean create ) { this . create = create ; return this ; } public PutRequest settings ( Settings settings ) { this . settings = settings ; return this ; } public PutRequest mappings ( Map < String , String > mappings ) { this . mappings . putAll ( mappings ) ; return this ; } public PutRequest aliases ( Set < Alias > aliases ) { this . aliases . addAll ( aliases ) ; return this ; } public PutRequest customs ( Map < String , IndexMetaData . Custom > customs ) { this . customs . putAll ( customs ) ; return this ; } public PutRequest putMapping ( String mappingType , String mappingSource ) { mappings . put ( mappingType , mappingSource ) ; return this ; } public PutRequest masterTimeout ( TimeValue masterTimeout ) { this . masterTimeout = masterTimeout ; return this ; } } public static class PutResponse { private final boolean acknowledged ; private final IndexTemplateMetaData template ; public PutResponse ( boolean acknowledged , IndexTemplateMetaData template ) { this . acknowledged = acknowledged ; this . template = template ; } public boolean acknowledged ( ) { return acknowledged ; } public IndexTemplateMetaData template ( ) { return template ; } } public static class RemoveRequest { final String name ; TimeValue masterTimeout = MasterNodeRequest . DEFAULT_MASTER_NODE_TIMEOUT ; public RemoveRequest ( String name ) { this . name = name ; } public RemoveRequest masterTimeout ( TimeValue masterTimeout ) { this . masterTimeout = masterTimeout ; return this ; } } public static class RemoveResponse { private final boolean acknowledged ; public RemoveResponse ( boolean acknowledged ) { this . acknowledged = acknowledged ; } public boolean acknowledged ( ) { return acknowledged ; } } public static interface RemoveListener { void onResponse ( RemoveResponse response ) ; void onFailure ( Throwable t ) ; } } 
