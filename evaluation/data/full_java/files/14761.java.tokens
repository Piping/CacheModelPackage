package org . gradle . platform . base . internal . registry ; import com . google . common . collect . ImmutableList ; import org . gradle . internal . TriAction ; import org . gradle . language . base . plugins . ComponentModelBasePlugin ; import org . gradle . model . InvalidModelRuleDeclarationException ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . inspect . MethodRuleDefinition ; import org . gradle . model . internal . inspect . ValidationProblemCollector ; import org . gradle . model . internal . type . ModelType ; import org . gradle . platform . base . * ; import java . util . List ; import static org . gradle . model . internal . core . NodePredicate . allLinks ; public class ComponentBinariesModelRuleExtractor extends AbstractAnnotationDrivenComponentModelRuleExtractor < ComponentBinaries > { @Override public < R , S > ExtractedModelRule registration ( MethodRuleDefinition < R , S > ruleDefinition , ValidationProblemCollector problems ) { return createRegistration ( ruleDefinition ) ; } private < R , S extends BinarySpec , C extends ComponentSpec > ExtractedModelRule createRegistration ( MethodRuleDefinition < R , ? > ruleDefinition ) { try { RuleMethodDataCollector dataCollector = new RuleMethodDataCollector ( ) ; visitAndVerifyMethodSignature ( dataCollector , ruleDefinition ) ; Class < S > binaryType = dataCollector . getParameterType ( BinarySpec . class ) ; Class < C > componentType = dataCollector . getParameterType ( ComponentSpec . class ) ; ModelReference < ComponentSpecContainer > subject = ModelReference . of ( ModelPath . path ( <str> ) , ModelType . of ( ComponentSpecContainer . class ) ) ; ComponentBinariesRule < R , S , C > componentBinariesRule = new ComponentBinariesRule < R , S , C > ( subject , componentType , binaryType , ruleDefinition ) ; return new ExtractedModelAction ( ModelActionRole . Finalize , ImmutableList . of ( ComponentModelBasePlugin . class ) , componentBinariesRule ) ; } catch ( InvalidModelException e ) { throw invalidModelRule ( ruleDefinition , e ) ; } } private void visitAndVerifyMethodSignature ( RuleMethodDataCollector dataCollector , MethodRuleDefinition < ? , ? > ruleDefinition ) { assertIsVoidMethod ( ruleDefinition ) ; visitSubject ( dataCollector , ruleDefinition , BinarySpec . class ) ; visitDependency ( dataCollector , ruleDefinition , ModelType . of ( ComponentSpec . class ) ) ; } private class ComponentBinariesRule < R , S extends BinarySpec , C extends ComponentSpec > extends ModelMapBasedRule < R , S , ComponentSpec , ComponentSpecContainer > { private final Class < C > componentType ; private final Class < S > binaryType ; public ComponentBinariesRule ( ModelReference < ComponentSpecContainer > subject , final Class < C > componentType , final Class < S > binaryType , MethodRuleDefinition < R , ? > ruleDefinition ) { super ( subject , componentType , ruleDefinition ) ; this . componentType = componentType ; this . binaryType = binaryType ; } protected void execute ( final MutableModelNode modelNode , final ComponentSpecContainer componentSpecs , final List < ModelView < ? > > modelMapRuleInputs ) { modelNode . applyTo ( allLinks ( ) , ModelActionRole . Finalize , DirectNodeInputUsingModelAction . of ( ModelReference . of ( ModelType . of ( componentType ) ) , getDescriptor ( ) , getInputs ( ) , new TriAction < MutableModelNode , C , List < ModelView < ? > > > ( ) { @Override public void execute ( MutableModelNode componentModelNode , C component , final List < ModelView < ? > > componentRuleInputs ) { invoke ( componentRuleInputs , component . getBinaries ( ) . withType ( binaryType ) , component ) ; } } ) ) ; } } protected InvalidModelRuleDeclarationException invalidModelRule ( MethodRuleDefinition < ? , ? > ruleDefinition , InvalidModelException e ) { StringBuilder sb = new StringBuilder ( ) ; ruleDefinition . getDescriptor ( ) . describeTo ( sb ) ; sb . append ( <str> ) ; return new InvalidModelRuleDeclarationException ( sb . toString ( ) , e ) ; } } 
