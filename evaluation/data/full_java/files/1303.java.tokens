package org . apache . cassandra . concurrent ; import java . util . BitSet ; import java . util . TreeSet ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . locks . LockSupport ; import com . google . common . util . concurrent . Uninterruptibles ; import org . apache . commons . math3 . distribution . WeibullDistribution ; import org . junit . Test ; public class LongSharedExecutorPoolTest { private static final class WaitTask implements Runnable { final long nanos ; private WaitTask ( long nanos ) { this . nanos = nanos ; } public void run ( ) { LockSupport . parkNanos ( nanos ) ; } } private static final class Result implements Comparable < Result > { final Future < ? > future ; final long forecastedCompletion ; private Result ( Future < ? > future , long forecastedCompletion ) { this . future = future ; this . forecastedCompletion = forecastedCompletion ; } public int compareTo ( Result that ) { int c = Long . compare ( this . forecastedCompletion , that . forecastedCompletion ) ; if ( c ! = <int> ) return c ; c = Integer . compare ( this . hashCode ( ) , that . hashCode ( ) ) ; if ( c ! = <int> ) return c ; return Integer . compare ( this . future . hashCode ( ) , that . future . hashCode ( ) ) ; } } private static final class Batch implements Comparable < Batch > { final TreeSet < Result > results ; final long timeout ; final int executorIndex ; private Batch ( TreeSet < Result > results , long timeout , int executorIndex ) { this . results = results ; this . timeout = timeout ; this . executorIndex = executorIndex ; } public int compareTo ( Batch that ) { int c = Long . compare ( this . timeout , that . timeout ) ; if ( c ! = <int> ) return c ; c = Integer . compare ( this . results . size ( ) , that . results . size ( ) ) ; if ( c ! = <int> ) return c ; return Integer . compare ( this . hashCode ( ) , that . hashCode ( ) ) ; } } @Test public void testPromptnessOfExecution ( ) throws InterruptedException , ExecutionException { testPromptnessOfExecution ( TimeUnit . MINUTES . toNanos ( <int> ) , <float> ) ; } private void testPromptnessOfExecution ( long intervalNanos , float loadIncrement ) throws InterruptedException , ExecutionException { final int executorCount = <int> ; int threadCount = <int> ; int maxQueued = <int> ; final WeibullDistribution workTime = new WeibullDistribution ( <int> , <int> ) ; final long minWorkTime = TimeUnit . MICROSECONDS . toNanos ( <int> ) ; final long maxWorkTime = TimeUnit . MILLISECONDS . toNanos ( <int> ) ; final int [ ] threadCounts = new int [ executorCount ] ; final WeibullDistribution [ ] workCount = new WeibullDistribution [ executorCount ] ; final ExecutorService [ ] executors = new ExecutorService [ executorCount ] ; for ( int i = <int> ; i < executors . length ; i + + ) { executors [ i ] = SharedExecutorPool . SHARED . newExecutor ( threadCount , maxQueued , <str> + i , <str> + i ) ; threadCounts [ i ] = threadCount ; workCount [ i ] = new WeibullDistribution ( <int> , maxQueued ) ; threadCount * = <int> ; maxQueued * = <int> ; } long runs = <int> ; long events = <int> ; final TreeSet < Batch > pending = new TreeSet < > ( ) ; final BitSet executorsWithWork = new BitSet ( executorCount ) ; long until = <int> ; for ( float multiplier = <float> ; multiplier < <float> ; ) { if ( System . nanoTime ( ) > until ) { System . out . println ( String . format ( <str> , runs * <float> , events * <float> ) ) ; events = <int> ; until = System . nanoTime ( ) + intervalNanos ; multiplier + = loadIncrement ; System . out . println ( String . format ( <str> , TimeUnit . NANOSECONDS . toSeconds ( intervalNanos ) , multiplier ) ) ; } long timeout ; if ( pending . isEmpty ( ) ) timeout = <int> ; else if ( Math . random ( ) > <float> ) timeout = Long . MAX_VALUE ; else if ( pending . size ( ) = = executorCount ) timeout = pending . first ( ) . timeout ; else timeout = ( long ) ( Math . random ( ) * pending . last ( ) . timeout ) ; while ( ! pending . isEmpty ( ) & & timeout > System . nanoTime ( ) ) { Batch first = pending . first ( ) ; boolean complete = false ; try { for ( Result result : first . results . descendingSet ( ) ) result . future . get ( timeout - System . nanoTime ( ) , TimeUnit . NANOSECONDS ) ; complete = true ; } catch ( TimeoutException e ) { } if ( ! complete & & System . nanoTime ( ) > first . timeout ) { for ( Result result : first . results ) if ( ! result . future . isDone ( ) ) throw new AssertionError ( ) ; complete = true ; } if ( complete ) { pending . pollFirst ( ) ; executorsWithWork . clear ( first . executorIndex ) ; } } if ( timeout = = Long . MAX_VALUE ) Uninterruptibles . sleepUninterruptibly ( <int> , TimeUnit . MILLISECONDS ) ; int executorIndex = executorsWithWork . nextClearBit ( <int> ) ; if ( executorIndex > = executorCount ) continue ; executorsWithWork . set ( executorIndex ) ; ExecutorService executor = executors [ executorIndex ] ; TreeSet < Result > results = new TreeSet < > ( ) ; int count = ( int ) ( workCount [ executorIndex ] . sample ( ) * multiplier ) ; long targetTotalElapsed = <int> ; long start = System . nanoTime ( ) ; long baseTime ; if ( Math . random ( ) > <float> ) baseTime = <int> * ( long ) ( workTime . sample ( ) * multiplier ) ; else baseTime = <int> ; for ( int j = <int> ; j < count ; j + + ) { long time ; if ( baseTime = = <int> ) time = ( long ) ( workTime . sample ( ) * multiplier ) ; else time = ( long ) ( baseTime * Math . random ( ) ) ; if ( time < minWorkTime ) time = minWorkTime ; if ( time > maxWorkTime ) time = maxWorkTime ; targetTotalElapsed + = time ; Future < ? > future = executor . submit ( new WaitTask ( time ) ) ; results . add ( new Result ( future , System . nanoTime ( ) + time ) ) ; } long end = start + ( long ) Math . ceil ( targetTotalElapsed / ( double ) threadCounts [ executorIndex ] ) + TimeUnit . MILLISECONDS . toNanos ( <int> ) ; long now = System . nanoTime ( ) ; if ( runs + + > executorCount & & now > end ) throw new AssertionError ( ) ; events + = results . size ( ) ; pending . add ( new Batch ( results , end , executorIndex ) ) ; } } public static void main ( String [ ] args ) throws InterruptedException , ExecutionException { new LongSharedExecutorPoolTest ( ) . testPromptnessOfExecution ( TimeUnit . MINUTES . toNanos ( <int> ) , <float> ) ; } } 
