package org . elasticsearch . search . aggregations . pipeline . bucketmetrics . percentile ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregation . Type ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorFactory ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorStreams ; import org . elasticsearch . search . aggregations . pipeline . bucketmetrics . BucketMetricsPipelineAggregator ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import java . io . IOException ; import java . util . * ; import static org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; public class PercentilesBucketPipelineAggregator extends BucketMetricsPipelineAggregator { public final static Type TYPE = new Type ( <str> ) ; public final static PipelineAggregatorStreams . Stream STREAM = new PipelineAggregatorStreams . Stream ( ) { @Override public PercentilesBucketPipelineAggregator readResult ( StreamInput in ) throws IOException { PercentilesBucketPipelineAggregator result = new PercentilesBucketPipelineAggregator ( ) ; result . readFrom ( in ) ; return result ; } } ; public static void registerStreams ( ) { PipelineAggregatorStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; InternalPercentilesBucket . registerStreams ( ) ; } private double [ ] percents ; private List < Double > data ; private PercentilesBucketPipelineAggregator ( ) { } protected PercentilesBucketPipelineAggregator ( String name , double [ ] percents , String [ ] bucketsPaths , GapPolicy gapPolicy , ValueFormatter formatter , Map < String , Object > metaData ) { super ( name , bucketsPaths , gapPolicy , formatter , metaData ) ; this . percents = percents ; } @Override public Type type ( ) { return TYPE ; } @Override protected void preCollection ( ) { data = new ArrayList < > ( <int> ) ; } @Override protected void collectBucketValue ( String bucketKey , Double bucketValue ) { data . add ( bucketValue ) ; } @Override protected InternalAggregation buildAggregation ( List < PipelineAggregator > pipelineAggregators , Map < String , Object > metadata ) { Collections . sort ( data ) ; double [ ] percentiles = new double [ percents . length ] ; if ( data . size ( ) = = <int> ) { for ( int i = <int> ; i < percents . length ; i + + ) { percentiles [ i ] = Double . NaN ; } } else { for ( int i = <int> ; i < percents . length ; i + + ) { int index = ( int ) ( ( percents [ i ] / <float> ) * data . size ( ) ) ; percentiles [ i ] = data . get ( index ) ; } } return new InternalPercentilesBucket ( name ( ) , percents , percentiles , formatter , pipelineAggregators , metadata ) ; } @Override public void doReadFrom ( StreamInput in ) throws IOException { super . doReadFrom ( in ) ; percents = in . readDoubleArray ( ) ; } @Override public void doWriteTo ( StreamOutput out ) throws IOException { super . doWriteTo ( out ) ; out . writeDoubleArray ( percents ) ; } public static class Factory extends PipelineAggregatorFactory { private final ValueFormatter formatter ; private final GapPolicy gapPolicy ; private final double [ ] percents ; public Factory ( String name , String [ ] bucketsPaths , GapPolicy gapPolicy , ValueFormatter formatter , double [ ] percents ) { super ( name , TYPE . name ( ) , bucketsPaths ) ; this . gapPolicy = gapPolicy ; this . formatter = formatter ; this . percents = percents ; } @Override protected PipelineAggregator createInternal ( Map < String , Object > metaData ) throws IOException { return new PercentilesBucketPipelineAggregator ( name , percents , bucketsPaths , gapPolicy , formatter , metaData ) ; } @Override public void doValidate ( AggregatorFactory parent , AggregatorFactory [ ] aggFactories , List < PipelineAggregatorFactory > pipelineAggregatorFactories ) { if ( bucketsPaths . length ! = <int> ) { throw new IllegalStateException ( PipelineAggregator . Parser . BUCKETS_PATH . getPreferredName ( ) + <str> + name + <str> ) ; } for ( Double p : percents ) { if ( p = = null | | p < <float> | | p > <float> ) { throw new IllegalStateException ( PercentilesBucketParser . PERCENTS . getPreferredName ( ) + <str> ) ; } } } } } 
