package org . elasticsearch . common . util ; import com . carrotsearch . hppc . ObjectLongHashMap ; import com . carrotsearch . hppc . ObjectLongMap ; import com . carrotsearch . hppc . cursors . ObjectLongCursor ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; public class BytesRefHashTests extends ESSingleNodeTestCase { BytesRefHash hash ; private void newHash ( ) { if ( hash ! = null ) { hash . close ( ) ; } final float maxLoadFactor = <float> + randomFloat ( ) * <float> ; hash = new BytesRefHash ( randomIntBetween ( <int> , <int> ) , maxLoadFactor , BigArraysTests . randombigArrays ( ) ) ; } @Override public void setUp ( ) throws Exception { super . setUp ( ) ; newHash ( ) ; } public void testDuell ( ) { final int len = randomIntBetween ( <int> , <int> ) ; final BytesRef [ ] values = new BytesRef [ len ] ; for ( int i = <int> ; i < values . length ; + + i ) { values [ i ] = new BytesRef ( randomAsciiOfLength ( <int> ) ) ; } final ObjectLongMap < BytesRef > valueToId = new ObjectLongHashMap < > ( ) ; final BytesRef [ ] idToValue = new BytesRef [ values . length ] ; final int iters = randomInt ( <int> ) ; for ( int i = <int> ; i < iters ; + + i ) { final BytesRef value = randomFrom ( values ) ; if ( valueToId . containsKey ( value ) ) { assertEquals ( - <int> - valueToId . get ( value ) , hash . add ( value , value . hashCode ( ) ) ) ; } else { assertEquals ( valueToId . size ( ) , hash . add ( value , value . hashCode ( ) ) ) ; idToValue [ valueToId . size ( ) ] = value ; valueToId . put ( value , valueToId . size ( ) ) ; } } assertEquals ( valueToId . size ( ) , hash . size ( ) ) ; for ( Iterator < ObjectLongCursor < BytesRef > > iterator = valueToId . iterator ( ) ; iterator . hasNext ( ) ; ) { final ObjectLongCursor < BytesRef > next = iterator . next ( ) ; assertEquals ( next . value , hash . find ( next . key , next . key . hashCode ( ) ) ) ; } for ( long i = <int> ; i < hash . capacity ( ) ; + + i ) { final long id = hash . id ( i ) ; BytesRef spare = new BytesRef ( ) ; if ( id > = <int> ) { hash . get ( id , spare ) ; assertEquals ( idToValue [ ( int ) id ] , spare ) ; } } hash . close ( ) ; } public void testSize ( ) { BytesRefBuilder ref = new BytesRefBuilder ( ) ; int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < num ; j + + ) { final int mod = <int> + randomInt ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { String str ; do { str = TestUtil . randomRealisticUnicodeString ( getRandom ( ) , <int> ) ; } while ( str . length ( ) = = <int> ) ; ref . copyChars ( str ) ; long count = hash . size ( ) ; long key = hash . add ( ref . get ( ) ) ; if ( key < <int> ) assertEquals ( hash . size ( ) , count ) ; else assertEquals ( hash . size ( ) , count + <int> ) ; if ( i % mod = = <int> ) { newHash ( ) ; } } } hash . close ( ) ; } public void testGet ( ) { BytesRefBuilder ref = new BytesRefBuilder ( ) ; BytesRef scratch = new BytesRef ( ) ; int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < num ; j + + ) { Map < String , Long > strings = new HashMap < > ( ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { String str ; do { str = TestUtil . randomRealisticUnicodeString ( getRandom ( ) , <int> ) ; } while ( str . length ( ) = = <int> ) ; ref . copyChars ( str ) ; long count = hash . size ( ) ; long key = hash . add ( ref . get ( ) ) ; if ( key > = <int> ) { assertNull ( strings . put ( str , Long . valueOf ( key ) ) ) ; assertEquals ( uniqueCount , key ) ; uniqueCount + + ; assertEquals ( hash . size ( ) , count + <int> ) ; } else { assertTrue ( ( - key ) - <int> < count ) ; assertEquals ( hash . size ( ) , count ) ; } } for ( Entry < String , Long > entry : strings . entrySet ( ) ) { ref . copyChars ( entry . getKey ( ) ) ; assertEquals ( ref . get ( ) , hash . get ( entry . getValue ( ) . longValue ( ) , scratch ) ) ; } newHash ( ) ; } hash . close ( ) ; } public void testAdd ( ) { BytesRefBuilder ref = new BytesRefBuilder ( ) ; BytesRef scratch = new BytesRef ( ) ; int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < num ; j + + ) { Set < String > strings = new HashSet < > ( ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { String str ; do { str = TestUtil . randomRealisticUnicodeString ( getRandom ( ) , <int> ) ; } while ( str . length ( ) = = <int> ) ; ref . copyChars ( str ) ; long count = hash . size ( ) ; long key = hash . add ( ref . get ( ) ) ; if ( key > = <int> ) { assertTrue ( strings . add ( str ) ) ; assertEquals ( uniqueCount , key ) ; assertEquals ( hash . size ( ) , count + <int> ) ; uniqueCount + + ; } else { assertFalse ( strings . add ( str ) ) ; assertTrue ( ( - key ) - <int> < count ) ; assertEquals ( str , hash . get ( ( - key ) - <int> , scratch ) . utf8ToString ( ) ) ; assertEquals ( count , hash . size ( ) ) ; } } assertAllIn ( strings , hash ) ; newHash ( ) ; } hash . close ( ) ; } public void testFind ( ) throws Exception { BytesRefBuilder ref = new BytesRefBuilder ( ) ; BytesRef scratch = new BytesRef ( ) ; int num = scaledRandomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < num ; j + + ) { Set < String > strings = new HashSet < > ( ) ; int uniqueCount = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { String str ; do { str = TestUtil . randomRealisticUnicodeString ( getRandom ( ) , <int> ) ; } while ( str . length ( ) = = <int> ) ; ref . copyChars ( str ) ; long count = hash . size ( ) ; long key = hash . find ( ref . get ( ) ) ; if ( key > = <int> ) { assertFalse ( strings . add ( str ) ) ; assertTrue ( key < count ) ; assertEquals ( str , hash . get ( key , scratch ) . utf8ToString ( ) ) ; assertEquals ( count , hash . size ( ) ) ; } else { key = hash . add ( ref . get ( ) ) ; assertTrue ( strings . add ( str ) ) ; assertEquals ( uniqueCount , key ) ; assertEquals ( hash . size ( ) , count + <int> ) ; uniqueCount + + ; } } assertAllIn ( strings , hash ) ; newHash ( ) ; } hash . close ( ) ; } private void assertAllIn ( Set < String > strings , BytesRefHash hash ) { BytesRefBuilder ref = new BytesRefBuilder ( ) ; BytesRef scratch = new BytesRef ( ) ; long count = hash . size ( ) ; for ( String string : strings ) { ref . copyChars ( string ) ; long key = hash . add ( ref . get ( ) ) ; assertEquals ( string , hash . get ( ( - key ) - <int> , scratch ) . utf8ToString ( ) ) ; assertEquals ( count , hash . size ( ) ) ; assertTrue ( <str> + key + <str> + count + <str> + string , key < count ) ; } } } 
