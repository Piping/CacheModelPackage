package org . apache . cassandra . streaming . compress ; import java . io . EOFException ; import java . io . IOException ; import java . io . InputStream ; import java . util . Iterator ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ThreadLocalRandom ; import java . util . function . Supplier ; import java . util . zip . Checksum ; import com . google . common . collect . Iterators ; import com . google . common . primitives . Ints ; import org . apache . cassandra . io . compress . CompressionMetadata ; import org . apache . cassandra . utils . ChecksumType ; import org . apache . cassandra . utils . WrappedRunnable ; public class CompressedInputStream extends InputStream { private final CompressionInfo info ; private final BlockingQueue < byte [ ] > dataBuffer ; private final Supplier < Double > crcCheckChanceSupplier ; private final byte [ ] buffer ; protected long bufferOffset = <int> ; private long current = <int> ; protected int validBufferBytes = - <int> ; private final Checksum checksum ; private final byte [ ] checksumBytes = new byte [ <int> ] ; private static final byte [ ] POISON_PILL = new byte [ <int> ] ; private long totalCompressedBytesRead ; private Thread readerThread ; public CompressedInputStream ( InputStream source , CompressionInfo info , ChecksumType checksumType , Supplier < Double > crcCheckChanceSupplier ) { this . info = info ; this . checksum = checksumType . newInstance ( ) ; this . buffer = new byte [ info . parameters . chunkLength ( ) ] ; this . dataBuffer = new ArrayBlockingQueue < > ( Math . min ( info . chunks . length , <int> ) ) ; this . crcCheckChanceSupplier = crcCheckChanceSupplier ; readerThread = new Thread ( new Reader ( source , info , dataBuffer ) ) ; readerThread . start ( ) ; } public int read ( ) throws IOException { if ( current > = bufferOffset + buffer . length | | validBufferBytes = = - <int> ) { try { byte [ ] compressedWithCRC = dataBuffer . take ( ) ; if ( compressedWithCRC = = POISON_PILL ) throw new EOFException ( <str> ) ; decompress ( compressedWithCRC ) ; } catch ( InterruptedException e ) { throw new EOFException ( <str> ) ; } } assert current > = bufferOffset & & current < bufferOffset + validBufferBytes ; return ( ( int ) buffer [ ( int ) ( current + + - bufferOffset ) ] ) & <hex> ; } public void position ( long position ) { assert position > = current : <str> ; current = position ; } private void decompress ( byte [ ] compressed ) throws IOException { validBufferBytes = info . parameters . getSstableCompressor ( ) . uncompress ( compressed , <int> , compressed . length - checksumBytes . length , buffer , <int> ) ; totalCompressedBytesRead + = compressed . length ; if ( this . crcCheckChanceSupplier . get ( ) > ThreadLocalRandom . current ( ) . nextDouble ( ) ) { checksum . update ( compressed , <int> , compressed . length - checksumBytes . length ) ; System . arraycopy ( compressed , compressed . length - checksumBytes . length , checksumBytes , <int> , checksumBytes . length ) ; if ( Ints . fromByteArray ( checksumBytes ) ! = ( int ) checksum . getValue ( ) ) throw new IOException ( <str> ) ; checksum . reset ( ) ; } bufferOffset = current & ~ ( buffer . length - <int> ) ; } public long getTotalCompressedBytesRead ( ) { return totalCompressedBytesRead ; } class Reader extends WrappedRunnable { private final InputStream source ; private final Iterator < CompressionMetadata . Chunk > chunks ; private final BlockingQueue < byte [ ] > dataBuffer ; Reader ( InputStream source , CompressionInfo info , BlockingQueue < byte [ ] > dataBuffer ) { this . source = source ; this . chunks = Iterators . forArray ( info . chunks ) ; this . dataBuffer = dataBuffer ; } protected void runMayThrow ( ) throws Exception { byte [ ] compressedWithCRC ; while ( ! Thread . currentThread ( ) . isInterrupted ( ) & & chunks . hasNext ( ) ) { CompressionMetadata . Chunk chunk = chunks . next ( ) ; int readLength = chunk . length + <int> ; compressedWithCRC = new byte [ readLength ] ; int bufferRead = <int> ; while ( bufferRead < readLength ) { int r ; try { r = source . read ( compressedWithCRC , bufferRead , readLength - bufferRead ) ; if ( r < <int> ) { dataBuffer . put ( POISON_PILL ) ; return ; } } catch ( IOException e ) { dataBuffer . put ( POISON_PILL ) ; throw e ; } bufferRead + = r ; } dataBuffer . put ( compressedWithCRC ) ; } synchronized ( CompressedInputStream . this ) { readerThread = null ; } } } @Override public void close ( ) throws IOException { synchronized ( this ) { if ( readerThread ! = null ) { readerThread . interrupt ( ) ; readerThread = null ; } } } } 
