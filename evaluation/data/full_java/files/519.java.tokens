package org . apache . cassandra . db . transform ; import java . util . Iterator ; import java . util . NoSuchElementException ; import net . nicoulaj . compilecommand . annotations . DontInline ; import org . apache . cassandra . utils . CloseableIterator ; import static org . apache . cassandra . utils . Throwables . maybeFail ; import static org . apache . cassandra . utils . Throwables . merge ; abstract class BaseIterator < V , I extends CloseableIterator < ? extends V > , O extends V > extends Stack implements AutoCloseable , Iterator < O > { I input ; V next ; Stop stop ; static class Stop { boolean isSignalled ; } BaseIterator ( BaseIterator < ? extends V , ? extends I , ? > copyFrom ) { super ( copyFrom ) ; this . input = copyFrom . input ; this . next = copyFrom . next ; this . stop = copyFrom . stop ; } BaseIterator ( I input ) { this . input = input ; this . stop = new Stop ( ) ; } protected abstract Throwable runOnClose ( int length ) ; protected abstract V applyOne ( V value , Transformation transformation ) ; public final void close ( ) { Throwable fail = runOnClose ( length ) ; if ( next instanceof AutoCloseable ) { try { ( ( AutoCloseable ) next ) . close ( ) ; } catch ( Throwable t ) { fail = merge ( fail , t ) ; } } try { input . close ( ) ; } catch ( Throwable t ) { fail = merge ( fail , t ) ; } maybeFail ( fail ) ; } public final O next ( ) { if ( next = = null & & ! hasNext ( ) ) throw new NoSuchElementException ( ) ; O next = ( O ) this . next ; this . next = null ; return next ; } protected final boolean hasMoreContents ( ) { return moreContents . length > <int> & & tryGetMoreContents ( ) ; } @DontInline private boolean tryGetMoreContents ( ) { for ( int i = <int> ; i < moreContents . length ; i + + ) { MoreContentsHolder holder = moreContents [ i ] ; MoreContents provider = holder . moreContents ; I newContents = ( I ) provider . moreContents ( ) ; if ( newContents = = null ) continue ; input . close ( ) ; input = newContents ; Stack prefix = EMPTY ; if ( newContents instanceof BaseIterator ) { BaseIterator abstr = ( BaseIterator ) newContents ; prefix = abstr ; input = ( I ) abstr . input ; next = apply ( ( V ) abstr . next , holder . length ) ; } maybeFail ( runOnClose ( holder . length ) ) ; refill ( prefix , holder , i ) ; if ( next ! = null | | input . hasNext ( ) ) return true ; i = - <int> ; } return false ; } private V apply ( V next , int from ) { while ( next ! = null & from < length ) next = applyOne ( next , stack [ from + + ] ) ; return next ; } } 
