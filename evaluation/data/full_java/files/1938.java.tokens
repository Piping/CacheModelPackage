package clojure . lang ; import java . io . Serializable ; import java . io . ObjectStreamException ; public class Symbol extends AFn implements IObj , Comparable , Named , Serializable , IHashEq { final String ns ; final String name ; private int _hasheq ; final IPersistentMap _meta ; transient String _str ; public String toString ( ) { if ( _str = = null ) { if ( ns ! = null ) _str = ( ns + <str> + name ) ; else _str = name ; } return _str ; } public String getNamespace ( ) { return ns ; } public String getName ( ) { return name ; } static public Symbol create ( String ns , String name ) { return Symbol . intern ( ns , name ) ; } static public Symbol create ( String nsname ) { return Symbol . intern ( nsname ) ; } static public Symbol intern ( String ns , String name ) { return new Symbol ( ns , name ) ; } static public Symbol intern ( String nsname ) { int i = nsname . indexOf ( <str> ) ; if ( i = = - <int> | | nsname . equals ( <str> ) ) return new Symbol ( null , nsname ) ; else return new Symbol ( nsname . substring ( <int> , i ) , nsname . substring ( i + <int> ) ) ; } private Symbol ( String ns_interned , String name_interned ) { this . name = name_interned ; this . ns = ns_interned ; this . _meta = null ; } public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof Symbol ) ) return false ; Symbol symbol = ( Symbol ) o ; return Util . equals ( ns , symbol . ns ) & & name . equals ( symbol . name ) ; } public int hashCode ( ) { return Util . hashCombine ( name . hashCode ( ) , Util . hash ( ns ) ) ; } public int hasheq ( ) { if ( _hasheq = = <int> ) { _hasheq = Util . hashCombine ( Murmur3 . hashUnencodedChars ( name ) , Util . hash ( ns ) ) ; } return _hasheq ; } public IObj withMeta ( IPersistentMap meta ) { return new Symbol ( meta , ns , name ) ; } private Symbol ( IPersistentMap meta , String ns , String name ) { this . name = name ; this . ns = ns ; this . _meta = meta ; } public int compareTo ( Object o ) { Symbol s = ( Symbol ) o ; if ( this . equals ( o ) ) return <int> ; if ( this . ns = = null & & s . ns ! = null ) return - <int> ; if ( this . ns ! = null ) { if ( s . ns = = null ) return <int> ; int nsc = this . ns . compareTo ( s . ns ) ; if ( nsc ! = <int> ) return nsc ; } return this . name . compareTo ( s . name ) ; } private Object readResolve ( ) throws ObjectStreamException { return intern ( ns , name ) ; } public Object invoke ( Object obj ) { return RT . get ( obj , this ) ; } public Object invoke ( Object obj , Object notFound ) { return RT . get ( obj , this , notFound ) ; } public IPersistentMap meta ( ) { return _meta ; } } 
