package org . elasticsearch . search . aggregations . pipeline . bucketmetrics . stats . extended ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregation . Type ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorFactory ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorStreams ; import org . elasticsearch . search . aggregations . pipeline . bucketmetrics . BucketMetricsPipelineAggregator ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class ExtendedStatsBucketPipelineAggregator extends BucketMetricsPipelineAggregator { public final static Type TYPE = new Type ( <str> ) ; public final static PipelineAggregatorStreams . Stream STREAM = new PipelineAggregatorStreams . Stream ( ) { @Override public ExtendedStatsBucketPipelineAggregator readResult ( StreamInput in ) throws IOException { ExtendedStatsBucketPipelineAggregator result = new ExtendedStatsBucketPipelineAggregator ( ) ; result . readFrom ( in ) ; return result ; } } ; public static void registerStreams ( ) { PipelineAggregatorStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; InternalExtendedStatsBucket . registerStreams ( ) ; } private double sum = <int> ; private long count = <int> ; private double min = Double . POSITIVE_INFINITY ; private double max = Double . NEGATIVE_INFINITY ; private double sumOfSqrs = <int> ; private double sigma ; protected ExtendedStatsBucketPipelineAggregator ( String name , String [ ] bucketsPaths , double sigma , GapPolicy gapPolicy , ValueFormatter formatter , Map < String , Object > metaData ) { super ( name , bucketsPaths , gapPolicy , formatter , metaData ) ; this . sigma = sigma ; } ExtendedStatsBucketPipelineAggregator ( ) { } @Override public Type type ( ) { return TYPE ; } @Override protected void preCollection ( ) { sum = <int> ; count = <int> ; min = Double . POSITIVE_INFINITY ; max = Double . NEGATIVE_INFINITY ; sumOfSqrs = <int> ; } @Override protected void collectBucketValue ( String bucketKey , Double bucketValue ) { sum + = bucketValue ; min = Math . min ( min , bucketValue ) ; max = Math . max ( max , bucketValue ) ; count + = <int> ; sumOfSqrs + = bucketValue * bucketValue ; } @Override protected InternalAggregation buildAggregation ( List < PipelineAggregator > pipelineAggregators , Map < String , Object > metadata ) { return new InternalExtendedStatsBucket ( name ( ) , count , sum , min , max , sumOfSqrs , sigma , formatter , pipelineAggregators , metadata ) ; } public static class Factory extends PipelineAggregatorFactory { private final ValueFormatter formatter ; private final GapPolicy gapPolicy ; private final double sigma ; public Factory ( String name , String [ ] bucketsPaths , double sigma , GapPolicy gapPolicy , ValueFormatter formatter ) { super ( name , TYPE . name ( ) , bucketsPaths ) ; this . gapPolicy = gapPolicy ; this . formatter = formatter ; this . sigma = sigma ; } @Override protected PipelineAggregator createInternal ( Map < String , Object > metaData ) throws IOException { return new ExtendedStatsBucketPipelineAggregator ( name , bucketsPaths , sigma , gapPolicy , formatter , metaData ) ; } @Override public void doValidate ( AggregatorFactory parent , AggregatorFactory [ ] aggFactories , List < PipelineAggregatorFactory > pipelineAggregatorFactories ) { if ( bucketsPaths . length ! = <int> ) { throw new IllegalStateException ( Parser . BUCKETS_PATH . getPreferredName ( ) + <str> + name + <str> ) ; } if ( sigma < <float> ) { throw new IllegalStateException ( ExtendedStatsBucketParser . SIGMA . getPreferredName ( ) + <str> ) ; } } } } 
