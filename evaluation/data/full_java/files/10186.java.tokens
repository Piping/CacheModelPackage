package com . google . common . cache ; import com . google . caliper . AfterExperiment ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . common . primitives . Ints ; import java . util . Random ; import java . util . concurrent . atomic . AtomicLong ; public class LoadingCacheSingleThreadBenchmark { @Param ( { <str> , <str> } ) int maximumSize ; @Param ( <str> ) int distinctKeys ; @Param ( <str> ) int segments ; @Param ( <str> ) double concentration ; Random random = new Random ( ) ; LoadingCache < Integer , Integer > cache ; int max ; static AtomicLong requests = new AtomicLong ( <int> ) ; static AtomicLong misses = new AtomicLong ( <int> ) ; @BeforeExperiment void setUp ( ) { max = Ints . checkedCast ( ( long ) Math . pow ( distinctKeys , concentration ) ) ; cache = CacheBuilder . newBuilder ( ) . concurrencyLevel ( segments ) . maximumSize ( maximumSize ) . build ( new CacheLoader < Integer , Integer > ( ) { @Override public Integer load ( Integer from ) { return ( int ) misses . incrementAndGet ( ) ; } } ) ; while ( cache . getUnchecked ( nextRandomKey ( ) ) < maximumSize ) { } requests . set ( <int> ) ; misses . set ( <int> ) ; } @Benchmark int time ( int reps ) { int dummy = <int> ; for ( int i = <int> ; i < reps ; i + + ) { dummy + = cache . getUnchecked ( nextRandomKey ( ) ) ; } requests . addAndGet ( reps ) ; return dummy ; } private int nextRandomKey ( ) { int a = random . nextInt ( max ) ; return ( int ) Math . pow ( a , <float> / concentration ) ; } @AfterExperiment void tearDown ( ) { double req = requests . get ( ) ; double hit = req - misses . get ( ) ; System . out . println ( <str> + hit / req ) ; } } 
