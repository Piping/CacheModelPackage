package org . apache . cassandra . io . util ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . DataInput ; import java . io . DataInputStream ; import java . io . DataOutput ; import java . io . DataOutputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . nio . ByteBuffer ; import java . nio . channels . Channels ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . Random ; import java . util . concurrent . Callable ; import java . util . concurrent . ThreadLocalRandom ; import org . junit . Assert ; import org . junit . Test ; import org . apache . cassandra . io . compress . BufferType ; import org . apache . cassandra . utils . ByteBufferUtil ; public class DataOutputTest { @Test public void testWrappedDataOutputStreamPlus ( ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStreamPlus write = new WrappedDataOutputStreamPlus ( bos ) ; DataInput canon = testWrite ( write ) ; DataInput test = new DataInputStream ( new ByteArrayInputStream ( bos . toByteArray ( ) ) ) ; testRead ( test , canon ) ; } @Test public void testWrappedDataOutputChannelAndChannel ( ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStreamPlus write = new WrappedDataOutputStreamPlus ( bos ) ; DataInput canon = testWrite ( write ) ; DataInput test = new DataInputStream ( new ByteArrayInputStream ( bos . toByteArray ( ) ) ) ; testRead ( test , canon ) ; } @Test public void testBufferedDataOutputStreamPlusAndChannel ( ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStreamPlus write = new BufferedDataOutputStreamPlus ( Channels . newChannel ( bos ) ) ; DataInput canon = testWrite ( write ) ; write . close ( ) ; DataInput test = new DataInputStream ( new ByteArrayInputStream ( bos . toByteArray ( ) ) ) ; testRead ( test , canon ) ; } @Test public void testDataOutputBuffer ( ) throws IOException { DataOutputBuffer write = new DataOutputBuffer ( ) ; DataInput canon = testWrite ( write ) ; DataInput test = new DataInputStream ( new ByteArrayInputStream ( write . toByteArray ( ) ) ) ; testRead ( test , canon ) ; } @Test public void testDataOutputBufferZeroReallocate ( ) throws IOException { try ( DataOutputBufferSpy write = new DataOutputBufferSpy ( ) ) { for ( int ii = <int> ; ii < <int> ; ii + + ) { write . superReallocate ( <int> ) ; } } } @Test public void testDataOutputDirectByteBuffer ( ) throws IOException { ByteBuffer buf = wrap ( new byte [ <int> ] , true ) ; BufferedDataOutputStreamPlus write = new BufferedDataOutputStreamPlus ( null , buf . duplicate ( ) ) ; DataInput canon = testWrite ( write ) ; DataInput test = new DataInputStream ( new ByteArrayInputStream ( ByteBufferUtil . getArray ( buf ) ) ) ; testRead ( test , canon ) ; } @Test public void testDataOutputHeapByteBuffer ( ) throws IOException { ByteBuffer buf = wrap ( new byte [ <int> ] , false ) ; BufferedDataOutputStreamPlus write = new BufferedDataOutputStreamPlus ( null , buf . duplicate ( ) ) ; DataInput canon = testWrite ( write ) ; DataInput test = new DataInputStream ( new ByteArrayInputStream ( ByteBufferUtil . getArray ( buf ) ) ) ; testRead ( test , canon ) ; } private static class DataOutputBufferSpy extends DataOutputBuffer { Deque < Long > sizes = new ArrayDeque < > ( ) ; DataOutputBufferSpy ( ) { sizes . offer ( <int> ) ; } void publicFlush ( ) throws IOException { doFlush ( <int> ) ; } void superReallocate ( int count ) throws IOException { super . reallocate ( count ) ; } @Override protected void reallocate ( long count ) { if ( count < = <int> ) return ; Long lastSize = sizes . peekLast ( ) ; long newSize = calculateNewSize ( count ) ; sizes . offer ( newSize ) ; if ( newSize > DataOutputBuffer . MAX_ARRAY_SIZE ) throw new RuntimeException ( ) ; if ( newSize < <int> ) throw new AssertionError ( ) ; if ( lastSize ! = null & & newSize < = lastSize ) throw new AssertionError ( ) ; } @Override protected long capacity ( ) { return sizes . peekLast ( ) . intValue ( ) ; } } @Test public void testDataOutputBufferMaxSizeFake ( ) throws IOException { try ( DataOutputBufferSpy write = new DataOutputBufferSpy ( ) ) { boolean threw = false ; try { while ( true ) write . publicFlush ( ) ; } catch ( RuntimeException e ) { if ( e . getClass ( ) = = RuntimeException . class ) threw = true ; } Assert . assertTrue ( threw ) ; Assert . assertTrue ( write . sizes . peekLast ( ) > = DataOutputBuffer . MAX_ARRAY_SIZE ) ; } } @Test public void testDataOutputBufferMaxSize ( ) throws IOException { if ( Runtime . getRuntime ( ) . maxMemory ( ) < <int> ) return ; try ( DataOutputBuffer write = new DataOutputBuffer ( ) ) { for ( int ii = <int> ; ii < DataOutputBuffer . MAX_ARRAY_SIZE / <int> ; ii + + ) write . writeLong ( <int> ) ; write . write ( new byte [ <int> ] ) ; checkThrowsRuntimeException ( validateReallocationCallable ( write , DataOutputBuffer . MAX_ARRAY_SIZE + <int> ) ) ; checkThrowsRuntimeException ( new Callable < Object > ( ) { public Object call ( ) throws Exception { write . write ( <int> ) ; return null ; } } ) ; } } @Test public void testDataOutputBufferBigReallocation ( ) throws Exception { Assert . assertEquals ( DataOutputBuffer . MAX_ARRAY_SIZE , DataOutputBuffer . saturatedArraySizeCast ( DataOutputBuffer . MAX_ARRAY_SIZE + <int> ) ) ; Assert . assertEquals ( DataOutputBuffer . MAX_ARRAY_SIZE , DataOutputBuffer . saturatedArraySizeCast ( DataOutputBuffer . MAX_ARRAY_SIZE ) ) ; Assert . assertEquals ( DataOutputBuffer . MAX_ARRAY_SIZE - <int> , DataOutputBuffer . saturatedArraySizeCast ( DataOutputBuffer . MAX_ARRAY_SIZE - <int> ) ) ; Assert . assertEquals ( <int> , DataOutputBuffer . saturatedArraySizeCast ( <int> ) ) ; Assert . assertEquals ( <int> , DataOutputBuffer . saturatedArraySizeCast ( <int> ) ) ; checkThrowsIAE ( saturatedArraySizeCastCallable ( - <int> ) ) ; checkThrowsIAE ( checkedArraySizeCastCallable ( DataOutputBuffer . MAX_ARRAY_SIZE + <int> ) ) ; Assert . assertEquals ( DataOutputBuffer . MAX_ARRAY_SIZE , DataOutputBuffer . checkedArraySizeCast ( DataOutputBuffer . MAX_ARRAY_SIZE ) ) ; Assert . assertEquals ( DataOutputBuffer . MAX_ARRAY_SIZE - <int> , DataOutputBuffer . checkedArraySizeCast ( DataOutputBuffer . MAX_ARRAY_SIZE - <int> ) ) ; Assert . assertEquals ( <int> , DataOutputBuffer . checkedArraySizeCast ( <int> ) ) ; Assert . assertEquals ( <int> , DataOutputBuffer . checkedArraySizeCast ( <int> ) ) ; checkThrowsIAE ( checkedArraySizeCastCallable ( - <int> ) ) ; try ( DataOutputBuffer write = new DataOutputBuffer ( ) ) { Assert . assertEquals ( DataOutputBuffer . MAX_ARRAY_SIZE , write . validateReallocation ( DataOutputBuffer . MAX_ARRAY_SIZE + <int> ) ) ; Assert . assertEquals ( DataOutputBuffer . MAX_ARRAY_SIZE , write . validateReallocation ( DataOutputBuffer . MAX_ARRAY_SIZE ) ) ; Assert . assertEquals ( DataOutputBuffer . MAX_ARRAY_SIZE - <int> , write . validateReallocation ( DataOutputBuffer . MAX_ARRAY_SIZE - <int> ) ) ; checkThrowsRuntimeException ( validateReallocationCallable ( write , <int> ) ) ; checkThrowsRuntimeException ( validateReallocationCallable ( write , <int> ) ) ; checkThrowsIAE ( validateReallocationCallable ( write , - <int> ) ) ; } } Callable < Object > saturatedArraySizeCastCallable ( final long value ) { return new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { return DataOutputBuffer . saturatedArraySizeCast ( value ) ; } } ; } Callable < Object > checkedArraySizeCastCallable ( final long value ) { return new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { return DataOutputBuffer . checkedArraySizeCast ( value ) ; } } ; } Callable < Object > validateReallocationCallable ( final DataOutputBuffer write , final long value ) { return new Callable < Object > ( ) { @Override public Object call ( ) throws Exception { return write . validateReallocation ( value ) ; } } ; } private static void checkThrowsIAE ( Callable < Object > c ) { checkThrowsException ( c , IllegalArgumentException . class ) ; } private static void checkThrowsRuntimeException ( Callable < Object > c ) { checkThrowsException ( c , RuntimeException . class ) ; } private static void checkThrowsException ( Callable < Object > c , Class < ? > exceptionClass ) { boolean threw = false ; try { c . call ( ) ; } catch ( Throwable t ) { if ( t . getClass ( ) = = exceptionClass ) threw = true ; } Assert . assertTrue ( threw ) ; } @Test public void testSafeMemoryWriter ( ) throws IOException { try ( SafeMemoryWriter write = new SafeMemoryWriter ( <int> ) ) { DataInput canon = testWrite ( write ) ; byte [ ] bytes = new byte [ <int> ] ; write . currentBuffer ( ) . getBytes ( <int> , bytes , <int> , <int> ) ; DataInput test = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; testRead ( test , canon ) ; } } @Test public void testWrappedFileOutputStream ( ) throws IOException { File file = FileUtils . createTempFile ( <str> , <str> ) ; try { DataOutputStreamPlus write = new WrappedDataOutputStreamPlus ( new FileOutputStream ( file ) ) ; DataInput canon = testWrite ( write ) ; write . close ( ) ; DataInputStream test = new DataInputStream ( new FileInputStream ( file ) ) ; testRead ( test , canon ) ; test . close ( ) ; } finally { Assert . assertTrue ( file . delete ( ) ) ; } } @Test public void testFileOutputStream ( ) throws IOException { File file = FileUtils . createTempFile ( <str> , <str> ) ; try { DataOutputStreamPlus write = new BufferedDataOutputStreamPlus ( new FileOutputStream ( file ) ) ; DataInput canon = testWrite ( write ) ; write . close ( ) ; DataInputStream test = new DataInputStream ( new FileInputStream ( file ) ) ; testRead ( test , canon ) ; test . close ( ) ; } finally { Assert . assertTrue ( file . delete ( ) ) ; } } @Test public void testRandomAccessFile ( ) throws IOException { File file = FileUtils . createTempFile ( <str> , <str> ) ; try { @SuppressWarnings ( <str> ) final RandomAccessFile raf = new RandomAccessFile ( file , <str> ) ; DataOutputStreamPlus write = new BufferedDataOutputStreamPlus ( raf . getChannel ( ) ) ; DataInput canon = testWrite ( write ) ; write . close ( ) ; DataInputStream test = new DataInputStream ( new FileInputStream ( file ) ) ; testRead ( test , canon ) ; test . close ( ) ; } finally { Assert . assertTrue ( file . delete ( ) ) ; } } @Test public void testSequentialWriter ( ) throws IOException { File file = FileUtils . createTempFile ( <str> , <str> ) ; final SequentialWriter writer = new SequentialWriter ( file , <int> , BufferType . ON_HEAP ) ; DataOutputStreamPlus write = new WrappedDataOutputStreamPlus ( writer . finishOnClose ( ) ) ; DataInput canon = testWrite ( write ) ; write . flush ( ) ; write . close ( ) ; DataInputStream test = new DataInputStream ( new FileInputStream ( file ) ) ; testRead ( test , canon ) ; test . close ( ) ; Assert . assertTrue ( file . delete ( ) ) ; } private DataInput testWrite ( DataOutputPlus test ) throws IOException { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final DataOutput canon = new DataOutputStream ( bos ) ; Random rnd = ThreadLocalRandom . current ( ) ; int size = <int> ; byte [ ] bytes = new byte [ size ] ; rnd . nextBytes ( bytes ) ; ByteBufferUtil . writeWithLength ( bytes , test ) ; ByteBufferUtil . writeWithLength ( bytes , canon ) ; bytes = new byte [ size ] ; rnd . nextBytes ( bytes ) ; ByteBufferUtil . writeWithLength ( wrap ( bytes , false ) , test ) ; ByteBufferUtil . writeWithLength ( bytes , canon ) ; bytes = new byte [ size ] ; rnd . nextBytes ( bytes ) ; ByteBufferUtil . writeWithLength ( wrap ( bytes , true ) , test ) ; ByteBufferUtil . writeWithLength ( bytes , canon ) ; bytes = new byte [ size ] ; rnd . nextBytes ( bytes ) ; ByteBufferUtil . writeWithShortLength ( bytes , test ) ; ByteBufferUtil . writeWithShortLength ( bytes , canon ) ; bytes = new byte [ size ] ; rnd . nextBytes ( bytes ) ; ByteBufferUtil . writeWithShortLength ( wrap ( bytes , false ) , test ) ; ByteBufferUtil . writeWithShortLength ( bytes , canon ) ; bytes = new byte [ size ] ; rnd . nextBytes ( bytes ) ; ByteBufferUtil . writeWithShortLength ( wrap ( bytes , true ) , test ) ; ByteBufferUtil . writeWithShortLength ( bytes , canon ) ; { long v = rnd . nextLong ( ) ; test . writeLong ( v ) ; canon . writeLong ( v ) ; } { int v = rnd . nextInt ( ) ; test . writeInt ( v ) ; canon . writeInt ( v ) ; } { short v = ( short ) rnd . nextInt ( ) ; test . writeShort ( v ) ; canon . writeShort ( v ) ; } { byte v = ( byte ) rnd . nextInt ( ) ; test . write ( v ) ; canon . write ( v ) ; } { double v = rnd . nextDouble ( ) ; test . writeDouble ( v ) ; canon . writeDouble ( v ) ; } { float v = ( float ) rnd . nextDouble ( ) ; test . writeFloat ( v ) ; canon . writeFloat ( v ) ; } return new DataInputStream ( new ByteArrayInputStream ( bos . toByteArray ( ) ) ) ; } private void testRead ( DataInput test , DataInput canon ) throws IOException { Assert . assertEquals ( ByteBufferUtil . readWithLength ( canon ) , ByteBufferUtil . readWithLength ( test ) ) ; Assert . assertEquals ( ByteBufferUtil . readWithLength ( canon ) , ByteBufferUtil . readWithLength ( test ) ) ; Assert . assertEquals ( ByteBufferUtil . readWithLength ( canon ) , ByteBufferUtil . readWithLength ( test ) ) ; Assert . assertEquals ( ByteBufferUtil . readWithShortLength ( canon ) , ByteBufferUtil . readWithShortLength ( test ) ) ; Assert . assertEquals ( ByteBufferUtil . readWithShortLength ( canon ) , ByteBufferUtil . readWithShortLength ( test ) ) ; Assert . assertEquals ( ByteBufferUtil . readWithShortLength ( canon ) , ByteBufferUtil . readWithShortLength ( test ) ) ; assert test . readLong ( ) = = canon . readLong ( ) ; assert test . readInt ( ) = = canon . readInt ( ) ; assert test . readShort ( ) = = canon . readShort ( ) ; assert test . readByte ( ) = = canon . readByte ( ) ; assert test . readDouble ( ) = = canon . readDouble ( ) ; assert test . readFloat ( ) = = canon . readFloat ( ) ; try { test . readInt ( ) ; assert false ; } catch ( EOFException ignore ) { } } private static ByteBuffer wrap ( byte [ ] bytes , boolean direct ) { ByteBuffer buf = direct ? ByteBuffer . allocateDirect ( bytes . length + <int> ) : ByteBuffer . allocate ( bytes . length + <int> ) ; buf . position ( <int> ) ; buf . limit ( bytes . length + <int> ) ; buf . duplicate ( ) . put ( bytes ) ; return buf ; } } 
