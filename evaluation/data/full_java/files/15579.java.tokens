package org . gradle . api . internal . tasks . testing . logging ; import com . google . common . base . Strings ; import com . google . common . collect . Lists ; import org . gradle . api . Nullable ; import org . gradle . api . specs . AndSpec ; import org . gradle . api . specs . Spec ; import org . gradle . api . tasks . testing . TestDescriptor ; import org . gradle . api . tasks . testing . logging . TestLogging ; import org . gradle . api . tasks . testing . logging . TestStackTraceFilter ; import org . gradle . util . TextUtil ; import java . util . List ; public class FullExceptionFormatter implements TestExceptionFormatter { private static final String INDENT = <str> ; private final TestLogging testLogging ; public FullExceptionFormatter ( TestLogging testLogging ) { this . testLogging = testLogging ; } public String format ( TestDescriptor descriptor , List < Throwable > exceptions ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = <int> ; i < exceptions . size ( ) ; i + + ) { printException ( descriptor , exceptions . get ( i ) , null , <int> , builder ) ; if ( i < exceptions . size ( ) - <int> ) { builder . append ( <str> ) ; } } return builder . toString ( ) ; } private void printException ( TestDescriptor descriptor , Throwable exception , @Nullable List < StackTraceElement > parentTrace , int exceptionLevel , StringBuilder builder ) { String exceptionIndent = Strings . repeat ( INDENT , exceptionLevel + <int> ) ; String exceptionText = exceptionLevel = = <int> ? exception . toString ( ) : <str> + exception . toString ( ) ; String indentedText = TextUtil . indent ( exceptionText , exceptionIndent ) ; builder . append ( indentedText ) ; builder . append ( <str> ) ; String stackTraceIndent = exceptionIndent + INDENT ; List < StackTraceElement > stackTrace = null ; if ( testLogging . getShowStackTraces ( ) ) { stackTrace = filterStackTrace ( exception , descriptor ) ; int commonElements = countCommonElements ( stackTrace , parentTrace ) ; for ( int i = <int> ; i < stackTrace . size ( ) - commonElements ; i + + ) { builder . append ( stackTraceIndent ) ; builder . append ( <str> ) ; builder . append ( stackTrace . get ( i ) ) ; builder . append ( <str> ) ; } if ( commonElements ! = <int> ) { builder . append ( stackTraceIndent ) ; builder . append ( <str> ) ; builder . append ( commonElements ) ; builder . append ( <str> ) ; builder . append ( <str> ) ; } } if ( testLogging . getShowCauses ( ) & & exception . getCause ( ) ! = null ) { printException ( descriptor , exception . getCause ( ) , stackTrace , exceptionLevel + <int> , builder ) ; } } private List < StackTraceElement > filterStackTrace ( Throwable exception , TestDescriptor descriptor ) { Spec < StackTraceElement > filterSpec = createCompositeFilter ( descriptor ) ; StackTraceFilter filter = new StackTraceFilter ( filterSpec ) ; return filter . filter ( exception ) ; } private Spec < StackTraceElement > createCompositeFilter ( TestDescriptor descriptor ) { List < Spec < StackTraceElement > > filters = Lists . newArrayList ( ) ; for ( TestStackTraceFilter type : testLogging . getStackTraceFilters ( ) ) { filters . add ( createFilter ( descriptor , type ) ) ; } return new AndSpec < StackTraceElement > ( filters ) ; } private Spec < StackTraceElement > createFilter ( TestDescriptor descriptor , TestStackTraceFilter filterType ) { switch ( filterType ) { case ENTRY_POINT : return new ClassMethodNameStackTraceSpec ( descriptor . getClassName ( ) , descriptor . getName ( ) ) ; case TRUNCATE : return new TruncatedStackTraceSpec ( new ClassMethodNameStackTraceSpec ( descriptor . getClassName ( ) , null ) ) ; case GROOVY : return new GroovyStackTraceSpec ( ) ; default : throw new AssertionError ( ) ; } } private int countCommonElements ( List < StackTraceElement > stackTrace , @Nullable List < StackTraceElement > parentTrace ) { if ( parentTrace = = null ) { return <int> ; } int commonElements = <int> ; for ( int i = stackTrace . size ( ) - <int> , j = parentTrace . size ( ) - <int> ; i > = <int> & & j > = <int> & & stackTrace . get ( i ) . equals ( parentTrace . get ( j ) ) ; i - - , j - - ) { commonElements + + ; } return commonElements ; } } 
