package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . filter . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . CompositeType ; import org . apache . cassandra . dht . * ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; public class DataRange { public static final Serializer serializer = new Serializer ( ) ; protected final AbstractBounds < PartitionPosition > keyRange ; protected final ClusteringIndexFilter clusteringIndexFilter ; public DataRange ( AbstractBounds < PartitionPosition > range , ClusteringIndexFilter clusteringIndexFilter ) { this . keyRange = range ; this . clusteringIndexFilter = clusteringIndexFilter ; } public static DataRange allData ( IPartitioner partitioner ) { return forTokenRange ( new Range < Token > ( partitioner . getMinimumToken ( ) , partitioner . getMinimumToken ( ) ) ) ; } public static DataRange forTokenRange ( Range < Token > tokenRange ) { return forKeyRange ( Range . makeRowRange ( tokenRange ) ) ; } public static DataRange forKeyRange ( Range < PartitionPosition > keyRange ) { return new DataRange ( keyRange , new ClusteringIndexSliceFilter ( Slices . ALL , false ) ) ; } public static DataRange allData ( IPartitioner partitioner , ClusteringIndexFilter filter ) { return new DataRange ( Range . makeRowRange ( new Range < Token > ( partitioner . getMinimumToken ( ) , partitioner . getMinimumToken ( ) ) ) , filter ) ; } public AbstractBounds < PartitionPosition > keyRange ( ) { return keyRange ; } public PartitionPosition startKey ( ) { return keyRange . left ; } public PartitionPosition stopKey ( ) { return keyRange . right ; } public boolean isNamesQuery ( ) { return clusteringIndexFilter instanceof ClusteringIndexNamesFilter ; } public boolean isPaging ( ) { return false ; } public boolean isWrapAround ( ) { return keyRange instanceof Range & & ( ( Range < ? > ) keyRange ) . isWrapAround ( ) ; } public boolean contains ( PartitionPosition pos ) { return keyRange . contains ( pos ) ; } public boolean isUnrestricted ( ) { return startKey ( ) . isMinimum ( ) & & stopKey ( ) . isMinimum ( ) & & clusteringIndexFilter . selectsAllPartition ( ) ; } public ClusteringIndexFilter clusteringIndexFilter ( DecoratedKey key ) { return clusteringIndexFilter ; } public DataRange forPaging ( AbstractBounds < PartitionPosition > range , ClusteringComparator comparator , Clustering lastReturned , boolean inclusive ) { return new Paging ( range , clusteringIndexFilter , comparator , lastReturned , inclusive ) ; } public DataRange forSubRange ( AbstractBounds < PartitionPosition > range ) { return new DataRange ( range , clusteringIndexFilter ) ; } public String toString ( CFMetaData metadata ) { return String . format ( <str> , keyRange . getString ( metadata . getKeyValidator ( ) ) , clusteringIndexFilter . toString ( metadata ) ) ; } public String toCQLString ( CFMetaData metadata ) { if ( isUnrestricted ( ) ) return <str> ; StringBuilder sb = new StringBuilder ( ) ; boolean needAnd = false ; if ( ! startKey ( ) . isMinimum ( ) ) { appendClause ( startKey ( ) , sb , metadata , true , keyRange . isStartInclusive ( ) ) ; needAnd = true ; } if ( ! stopKey ( ) . isMinimum ( ) ) { if ( needAnd ) sb . append ( <str> ) ; appendClause ( stopKey ( ) , sb , metadata , false , keyRange . isEndInclusive ( ) ) ; needAnd = true ; } String filterString = clusteringIndexFilter . toCQLString ( metadata ) ; if ( ! filterString . isEmpty ( ) ) sb . append ( needAnd ? <str> : <str> ) . append ( filterString ) ; return sb . toString ( ) ; } private void appendClause ( PartitionPosition pos , StringBuilder sb , CFMetaData metadata , boolean isStart , boolean isInclusive ) { sb . append ( <str> ) ; sb . append ( ColumnDefinition . toCQLString ( metadata . partitionKeyColumns ( ) ) ) ; sb . append ( <str> ) . append ( getOperator ( isStart , isInclusive ) ) . append ( <str> ) ; if ( pos instanceof DecoratedKey ) { sb . append ( <str> ) ; appendKeyString ( sb , metadata . getKeyValidator ( ) , ( ( DecoratedKey ) pos ) . getKey ( ) ) ; sb . append ( <str> ) ; } else { sb . append ( ( ( Token . KeyBound ) pos ) . getToken ( ) ) ; } } private static String getOperator ( boolean isStart , boolean isInclusive ) { return isStart ? ( isInclusive ? <str> : <str> ) : ( isInclusive ? <str> : <str> ) ; } public static void appendKeyString ( StringBuilder sb , AbstractType < ? > type , ByteBuffer key ) { if ( type instanceof CompositeType ) { CompositeType ct = ( CompositeType ) type ; ByteBuffer [ ] values = ct . split ( key ) ; for ( int i = <int> ; i < ct . types . size ( ) ; i + + ) sb . append ( i = = <int> ? <str> : <str> ) . append ( ct . types . get ( i ) . getString ( values [ i ] ) ) ; } else { sb . append ( type . getString ( key ) ) ; } } public static class Paging extends DataRange { private final ClusteringComparator comparator ; private final Clustering lastReturned ; private final boolean inclusive ; private Paging ( AbstractBounds < PartitionPosition > range , ClusteringIndexFilter filter , ClusteringComparator comparator , Clustering lastReturned , boolean inclusive ) { super ( range , filter ) ; assert ! ( range instanceof Range ) | | ! ( ( Range < ? > ) range ) . isWrapAround ( ) | | range . right . isMinimum ( ) : range ; assert lastReturned ! = null ; this . comparator = comparator ; this . lastReturned = lastReturned ; this . inclusive = inclusive ; } @Override public ClusteringIndexFilter clusteringIndexFilter ( DecoratedKey key ) { return key . equals ( startKey ( ) ) ? clusteringIndexFilter . forPaging ( comparator , lastReturned , inclusive ) : clusteringIndexFilter ; } @Override public DataRange forSubRange ( AbstractBounds < PartitionPosition > range ) { return range . left . equals ( keyRange ( ) . left ) ? new Paging ( range , clusteringIndexFilter , comparator , lastReturned , inclusive ) : new DataRange ( range , clusteringIndexFilter ) ; } public Clustering getLastReturned ( ) { return lastReturned ; } @Override public boolean isPaging ( ) { return true ; } @Override public boolean isUnrestricted ( ) { return false ; } @Override public String toString ( CFMetaData metadata ) { return String . format ( <str> , keyRange . getString ( metadata . getKeyValidator ( ) ) , clusteringIndexFilter . toString ( metadata ) , lastReturned . toString ( metadata ) , inclusive ? <str> : <str> ) ; } } public static class Serializer { public void serialize ( DataRange range , DataOutputPlus out , int version , CFMetaData metadata ) throws IOException { AbstractBounds . rowPositionSerializer . serialize ( range . keyRange , out , version ) ; ClusteringIndexFilter . serializer . serialize ( range . clusteringIndexFilter , out , version ) ; boolean isPaging = range instanceof Paging ; out . writeBoolean ( isPaging ) ; if ( isPaging ) { Clustering . serializer . serialize ( ( ( Paging ) range ) . lastReturned , out , version , metadata . comparator . subtypes ( ) ) ; out . writeBoolean ( ( ( Paging ) range ) . inclusive ) ; } } public DataRange deserialize ( DataInputPlus in , int version , CFMetaData metadata ) throws IOException { AbstractBounds < PartitionPosition > range = AbstractBounds . rowPositionSerializer . deserialize ( in , metadata . partitioner , version ) ; ClusteringIndexFilter filter = ClusteringIndexFilter . serializer . deserialize ( in , version , metadata ) ; if ( in . readBoolean ( ) ) { ClusteringComparator comparator = metadata . comparator ; Clustering lastReturned = Clustering . serializer . deserialize ( in , version , comparator . subtypes ( ) ) ; boolean inclusive = in . readBoolean ( ) ; return new Paging ( range , filter , comparator , lastReturned , inclusive ) ; } else { return new DataRange ( range , filter ) ; } } public long serializedSize ( DataRange range , int version , CFMetaData metadata ) { long size = AbstractBounds . rowPositionSerializer . serializedSize ( range . keyRange , version ) + ClusteringIndexFilter . serializer . serializedSize ( range . clusteringIndexFilter , version ) + <int> ; if ( range instanceof Paging ) { size + = Clustering . serializer . serializedSize ( ( ( Paging ) range ) . lastReturned , version , metadata . comparator . subtypes ( ) ) ; size + = <int> ; } return size ; } } } 
