package org . elasticsearch . cluster . node ; import com . carrotsearch . hppc . ObjectHashSet ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . AbstractDiffable ; import org . elasticsearch . common . Booleans ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . transport . TransportAddress ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; public class DiscoveryNodes extends AbstractDiffable < DiscoveryNodes > implements Iterable < DiscoveryNode > { public static final DiscoveryNodes EMPTY_NODES = builder ( ) . build ( ) ; public static final DiscoveryNodes PROTO = EMPTY_NODES ; private final ImmutableOpenMap < String , DiscoveryNode > nodes ; private final ImmutableOpenMap < String , DiscoveryNode > dataNodes ; private final ImmutableOpenMap < String , DiscoveryNode > masterNodes ; private final String masterNodeId ; private final String localNodeId ; private final Version minNodeVersion ; private final Version minNonClientNodeVersion ; private DiscoveryNodes ( ImmutableOpenMap < String , DiscoveryNode > nodes , ImmutableOpenMap < String , DiscoveryNode > dataNodes , ImmutableOpenMap < String , DiscoveryNode > masterNodes , String masterNodeId , String localNodeId , Version minNodeVersion , Version minNonClientNodeVersion ) { this . nodes = nodes ; this . dataNodes = dataNodes ; this . masterNodes = masterNodes ; this . masterNodeId = masterNodeId ; this . localNodeId = localNodeId ; this . minNodeVersion = minNodeVersion ; this . minNonClientNodeVersion = minNonClientNodeVersion ; } @Override public Iterator < DiscoveryNode > iterator ( ) { return nodes . valuesIt ( ) ; } public boolean valid ( ) { return localNodeId ! = null ; } public boolean localNodeMaster ( ) { if ( localNodeId = = null ) { return false ; } return localNodeId . equals ( masterNodeId ) ; } public int size ( ) { return nodes . size ( ) ; } public int getSize ( ) { return size ( ) ; } public ImmutableOpenMap < String , DiscoveryNode > nodes ( ) { return this . nodes ; } public ImmutableOpenMap < String , DiscoveryNode > getNodes ( ) { return nodes ( ) ; } public ImmutableOpenMap < String , DiscoveryNode > dataNodes ( ) { return this . dataNodes ; } public ImmutableOpenMap < String , DiscoveryNode > getDataNodes ( ) { return dataNodes ( ) ; } public ImmutableOpenMap < String , DiscoveryNode > masterNodes ( ) { return this . masterNodes ; } public ImmutableOpenMap < String , DiscoveryNode > getMasterNodes ( ) { return masterNodes ( ) ; } public ImmutableOpenMap < String , DiscoveryNode > masterAndDataNodes ( ) { ImmutableOpenMap . Builder < String , DiscoveryNode > nodes = ImmutableOpenMap . builder ( dataNodes ) ; nodes . putAll ( masterNodes ) ; return nodes . build ( ) ; } public DiscoveryNode get ( String nodeId ) { return nodes . get ( nodeId ) ; } public boolean nodeExists ( String nodeId ) { return nodes . containsKey ( nodeId ) ; } public String masterNodeId ( ) { return this . masterNodeId ; } public String getMasterNodeId ( ) { return masterNodeId ( ) ; } public String localNodeId ( ) { return this . localNodeId ; } public String getLocalNodeId ( ) { return localNodeId ( ) ; } public DiscoveryNode localNode ( ) { return nodes . get ( localNodeId ) ; } public DiscoveryNode getLocalNode ( ) { return localNode ( ) ; } public DiscoveryNode masterNode ( ) { return nodes . get ( masterNodeId ) ; } public DiscoveryNode getMasterNode ( ) { return masterNode ( ) ; } public DiscoveryNode findByAddress ( TransportAddress address ) { for ( ObjectCursor < DiscoveryNode > cursor : nodes . values ( ) ) { DiscoveryNode node = cursor . value ; if ( node . address ( ) . equals ( address ) ) { return node ; } } return null ; } public boolean isAllNodes ( String . . . nodesIds ) { return nodesIds = = null | | nodesIds . length = = <int> | | ( nodesIds . length = = <int> & & nodesIds [ <int> ] . equals ( <str> ) ) ; } public Version smallestVersion ( ) { return minNodeVersion ; } public Version smallestNonClientNodeVersion ( ) { return minNonClientNodeVersion ; } public DiscoveryNode resolveNode ( String node ) { String [ ] resolvedNodeIds = resolveNodesIds ( node ) ; if ( resolvedNodeIds . length > <int> ) { throw new IllegalArgumentException ( <str> + node + <str> + resolvedNodeIds . length + <str> ) ; } if ( resolvedNodeIds . length = = <int> ) { throw new IllegalArgumentException ( <str> + node + <str> ) ; } return nodes . get ( resolvedNodeIds [ <int> ] ) ; } public String [ ] resolveNodesIds ( String . . . nodesIds ) { if ( isAllNodes ( nodesIds ) ) { int index = <int> ; nodesIds = new String [ nodes . size ( ) ] ; for ( DiscoveryNode node : this ) { nodesIds [ index + + ] = node . id ( ) ; } return nodesIds ; } else { ObjectHashSet < String > resolvedNodesIds = new ObjectHashSet < > ( nodesIds . length ) ; for ( String nodeId : nodesIds ) { if ( nodeId . equals ( <str> ) ) { String localNodeId = localNodeId ( ) ; if ( localNodeId ! = null ) { resolvedNodesIds . add ( localNodeId ) ; } } else if ( nodeId . equals ( <str> ) ) { String masterNodeId = masterNodeId ( ) ; if ( masterNodeId ! = null ) { resolvedNodesIds . add ( masterNodeId ) ; } } else if ( nodeExists ( nodeId ) ) { resolvedNodesIds . add ( nodeId ) ; } else { for ( DiscoveryNode node : this ) { if ( Regex . simpleMatch ( nodeId , node . name ( ) ) ) { resolvedNodesIds . add ( node . id ( ) ) ; } } for ( DiscoveryNode node : this ) { if ( Regex . simpleMatch ( nodeId , node . getHostAddress ( ) ) ) { resolvedNodesIds . add ( node . id ( ) ) ; } else if ( Regex . simpleMatch ( nodeId , node . getHostName ( ) ) ) { resolvedNodesIds . add ( node . id ( ) ) ; } } int index = nodeId . indexOf ( <str> ) ; if ( index ! = - <int> ) { String matchAttrName = nodeId . substring ( <int> , index ) ; String matchAttrValue = nodeId . substring ( index + <int> ) ; if ( <str> . equals ( matchAttrName ) ) { if ( Booleans . parseBoolean ( matchAttrValue , true ) ) { resolvedNodesIds . addAll ( dataNodes . keys ( ) ) ; } else { resolvedNodesIds . removeAll ( dataNodes . keys ( ) ) ; } } else if ( <str> . equals ( matchAttrName ) ) { if ( Booleans . parseBoolean ( matchAttrValue , true ) ) { resolvedNodesIds . addAll ( masterNodes . keys ( ) ) ; } else { resolvedNodesIds . removeAll ( masterNodes . keys ( ) ) ; } } else { for ( DiscoveryNode node : this ) { for ( ObjectObjectCursor < String , String > entry : node . attributes ( ) ) { String attrName = entry . key ; String attrValue = entry . value ; if ( Regex . simpleMatch ( matchAttrName , attrName ) & & Regex . simpleMatch ( matchAttrValue , attrValue ) ) { resolvedNodesIds . add ( node . id ( ) ) ; } } } } } } } return resolvedNodesIds . toArray ( String . class ) ; } } public DiscoveryNodes removeDeadMembers ( Set < String > newNodes , String masterNodeId ) { Builder builder = new Builder ( ) . masterNodeId ( masterNodeId ) . localNodeId ( localNodeId ) ; for ( DiscoveryNode node : this ) { if ( newNodes . contains ( node . id ( ) ) ) { builder . put ( node ) ; } } return builder . build ( ) ; } public DiscoveryNodes newNode ( DiscoveryNode node ) { return new Builder ( this ) . put ( node ) . build ( ) ; } public Delta delta ( DiscoveryNodes other ) { List < DiscoveryNode > removed = new ArrayList < > ( ) ; List < DiscoveryNode > added = new ArrayList < > ( ) ; for ( DiscoveryNode node : other ) { if ( ! this . nodeExists ( node . id ( ) ) ) { removed . add ( node ) ; } } for ( DiscoveryNode node : this ) { if ( ! other . nodeExists ( node . id ( ) ) ) { added . add ( node ) ; } } DiscoveryNode previousMasterNode = null ; DiscoveryNode newMasterNode = null ; if ( masterNodeId ! = null ) { if ( other . masterNodeId = = null | | ! other . masterNodeId . equals ( masterNodeId ) ) { previousMasterNode = other . masterNode ( ) ; newMasterNode = masterNode ( ) ; } } return new Delta ( previousMasterNode , newMasterNode , localNodeId , Collections . unmodifiableList ( removed ) , Collections . unmodifiableList ( added ) ) ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; for ( DiscoveryNode node : this ) { sb . append ( node ) . append ( <str> ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } public String prettyPrint ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; for ( DiscoveryNode node : this ) { sb . append ( <str> ) . append ( node ) ; if ( node = = localNode ( ) ) { sb . append ( <str> ) ; } if ( node = = masterNode ( ) ) { sb . append ( <str> ) ; } sb . append ( <str> ) ; } return sb . toString ( ) ; } public Delta emptyDelta ( ) { return new Delta ( null , null , localNodeId , DiscoveryNode . EMPTY_LIST , DiscoveryNode . EMPTY_LIST ) ; } public static class Delta { private final String localNodeId ; private final DiscoveryNode previousMasterNode ; private final DiscoveryNode newMasterNode ; private final List < DiscoveryNode > removed ; private final List < DiscoveryNode > added ; public Delta ( String localNodeId , List < DiscoveryNode > removed , List < DiscoveryNode > added ) { this ( null , null , localNodeId , removed , added ) ; } public Delta ( @Nullable DiscoveryNode previousMasterNode , @Nullable DiscoveryNode newMasterNode , String localNodeId , List < DiscoveryNode > removed , List < DiscoveryNode > added ) { this . previousMasterNode = previousMasterNode ; this . newMasterNode = newMasterNode ; this . localNodeId = localNodeId ; this . removed = removed ; this . added = added ; } public boolean hasChanges ( ) { return masterNodeChanged ( ) | | ! removed . isEmpty ( ) | | ! added . isEmpty ( ) ; } public boolean masterNodeChanged ( ) { return newMasterNode ! = null ; } public DiscoveryNode previousMasterNode ( ) { return previousMasterNode ; } public DiscoveryNode newMasterNode ( ) { return newMasterNode ; } public boolean removed ( ) { return ! removed . isEmpty ( ) ; } public List < DiscoveryNode > removedNodes ( ) { return removed ; } public boolean added ( ) { return ! added . isEmpty ( ) ; } public List < DiscoveryNode > addedNodes ( ) { return added ; } public String shortSummary ( ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! removed ( ) & & masterNodeChanged ( ) ) { if ( newMasterNode . id ( ) . equals ( localNodeId ) ) { sb . append ( <str> ) . append ( newMasterNode ( ) ) ; } else { sb . append ( <str> ) . append ( newMasterNode ( ) ) ; } } else { if ( masterNodeChanged ( ) ) { sb . append ( <str> ) . append ( newMasterNode ( ) ) ; if ( previousMasterNode ( ) ! = null ) { sb . append ( <str> ) . append ( previousMasterNode ( ) ) ; } sb . append ( <str> ) ; } if ( removed ( ) ) { if ( masterNodeChanged ( ) ) { sb . append ( <str> ) ; } sb . append ( <str> ) ; for ( DiscoveryNode node : removedNodes ( ) ) { sb . append ( node ) . append ( <str> ) ; } sb . append ( <str> ) ; } } if ( added ( ) ) { if ( ! ( addedNodes ( ) . size ( ) = = <int> & & addedNodes ( ) . get ( <int> ) . id ( ) . equals ( localNodeId ) ) ) { if ( removed ( ) | | masterNodeChanged ( ) ) { sb . append ( <str> ) ; } sb . append ( <str> ) ; for ( DiscoveryNode node : addedNodes ( ) ) { if ( ! node . id ( ) . equals ( localNodeId ) ) { sb . append ( node ) . append ( <str> ) ; } } sb . append ( <str> ) ; } } return sb . toString ( ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { if ( masterNodeId = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeString ( masterNodeId ) ; } out . writeVInt ( nodes . size ( ) ) ; for ( DiscoveryNode node : this ) { node . writeTo ( out ) ; } } public DiscoveryNodes readFrom ( StreamInput in , DiscoveryNode localNode ) throws IOException { Builder builder = new Builder ( ) ; if ( in . readBoolean ( ) ) { builder . masterNodeId ( in . readString ( ) ) ; } if ( localNode ! = null ) { builder . localNodeId ( localNode . id ( ) ) ; } int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { DiscoveryNode node = DiscoveryNode . readNode ( in ) ; if ( localNode ! = null & & node . id ( ) . equals ( localNode . id ( ) ) ) { node = localNode ; } builder . put ( node ) ; } return builder . build ( ) ; } @Override public DiscoveryNodes readFrom ( StreamInput in ) throws IOException { return readFrom ( in , localNode ( ) ) ; } public static Builder builder ( ) { return new Builder ( ) ; } public static Builder builder ( DiscoveryNodes nodes ) { return new Builder ( nodes ) ; } public static class Builder { private final ImmutableOpenMap . Builder < String , DiscoveryNode > nodes ; private String masterNodeId ; private String localNodeId ; public Builder ( ) { nodes = ImmutableOpenMap . builder ( ) ; } public Builder ( DiscoveryNodes nodes ) { this . masterNodeId = nodes . masterNodeId ( ) ; this . localNodeId = nodes . localNodeId ( ) ; this . nodes = ImmutableOpenMap . builder ( nodes . nodes ( ) ) ; } public Builder put ( DiscoveryNode node ) { nodes . put ( node . id ( ) , node ) ; return this ; } public Builder remove ( String nodeId ) { nodes . remove ( nodeId ) ; return this ; } public Builder masterNodeId ( String masterNodeId ) { this . masterNodeId = masterNodeId ; return this ; } public Builder localNodeId ( String localNodeId ) { this . localNodeId = localNodeId ; return this ; } public DiscoveryNodes build ( ) { ImmutableOpenMap . Builder < String , DiscoveryNode > dataNodesBuilder = ImmutableOpenMap . builder ( ) ; ImmutableOpenMap . Builder < String , DiscoveryNode > masterNodesBuilder = ImmutableOpenMap . builder ( ) ; Version minNodeVersion = Version . CURRENT ; Version minNonClientNodeVersion = Version . CURRENT ; for ( ObjectObjectCursor < String , DiscoveryNode > nodeEntry : nodes ) { if ( nodeEntry . value . dataNode ( ) ) { dataNodesBuilder . put ( nodeEntry . key , nodeEntry . value ) ; minNonClientNodeVersion = Version . smallest ( minNonClientNodeVersion , nodeEntry . value . version ( ) ) ; } if ( nodeEntry . value . masterNode ( ) ) { masterNodesBuilder . put ( nodeEntry . key , nodeEntry . value ) ; minNonClientNodeVersion = Version . smallest ( minNonClientNodeVersion , nodeEntry . value . version ( ) ) ; } minNodeVersion = Version . smallest ( minNodeVersion , nodeEntry . value . version ( ) ) ; } return new DiscoveryNodes ( nodes . build ( ) , dataNodesBuilder . build ( ) , masterNodesBuilder . build ( ) , masterNodeId , localNodeId , minNodeVersion , minNonClientNodeVersion ) ; } public static DiscoveryNodes readFrom ( StreamInput in , @Nullable DiscoveryNode localNode ) throws IOException { return PROTO . readFrom ( in , localNode ) ; } } } 
