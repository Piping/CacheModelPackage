package com . google . common . io ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . io . TestOption . AVAILABLE_ALWAYS_ZERO ; import static com . google . common . io . TestOption . CLOSE_THROWS ; import static com . google . common . io . TestOption . OPEN_THROWS ; import static com . google . common . io . TestOption . READ_THROWS ; import static com . google . common . io . TestOption . SKIP_THROWS ; import static com . google . common . io . TestOption . WRITE_THROWS ; import static org . junit . Assert . assertArrayEquals ; import com . google . common . base . Charsets ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . hash . Hashing ; import com . google . common . primitives . UnsignedBytes ; import com . google . common . testing . TestLogHandler ; import junit . framework . TestSuite ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Arrays ; import java . util . EnumSet ; public class ByteSourceTest extends IoTestCase { @AndroidIncompatible public static TestSuite suite ( ) { TestSuite suite = new TestSuite ( ) ; for ( boolean asCharSource : new boolean [ ] { false , true } ) { suite . addTest ( ByteSourceTester . tests ( <str> , SourceSinkFactories . byteArraySourceFactory ( ) , asCharSource ) ) ; suite . addTest ( ByteSourceTester . tests ( <str> , SourceSinkFactories . emptyByteSourceFactory ( ) , asCharSource ) ) ; } suite . addTestSuite ( ByteSourceTest . class ) ; return suite ; } private static final byte [ ] bytes = newPreFilledByteArray ( <int> ) ; private TestByteSource source ; @Override protected void setUp ( ) throws Exception { source = new TestByteSource ( bytes ) ; } public void testOpenBufferedStream ( ) throws IOException { InputStream in = source . openBufferedStream ( ) ; assertTrue ( source . wasStreamOpened ( ) ) ; assertFalse ( source . wasStreamClosed ( ) ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ByteStreams . copy ( in , out ) ; in . close ( ) ; out . close ( ) ; assertTrue ( source . wasStreamClosed ( ) ) ; assertArrayEquals ( bytes , out . toByteArray ( ) ) ; } public void testSize ( ) throws IOException { assertEquals ( bytes . length , source . size ( ) ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; assertEquals ( bytes . length , new TestByteSource ( bytes , SKIP_THROWS ) . size ( ) ) ; assertEquals ( bytes . length , new TestByteSource ( bytes , AVAILABLE_ALWAYS_ZERO ) . size ( ) ) ; } public void testCopyTo_outputStream ( ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; assertEquals ( bytes . length , source . copyTo ( out ) ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; assertArrayEquals ( bytes , out . toByteArray ( ) ) ; } public void testCopyTo_byteSink ( ) throws IOException { TestByteSink sink = new TestByteSink ( ) ; assertFalse ( sink . wasStreamOpened ( ) | | sink . wasStreamClosed ( ) ) ; assertEquals ( bytes . length , source . copyTo ( sink ) ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; assertTrue ( sink . wasStreamOpened ( ) & & sink . wasStreamClosed ( ) ) ; assertArrayEquals ( bytes , sink . getBytes ( ) ) ; } public void testRead_toArray ( ) throws IOException { assertArrayEquals ( bytes , source . read ( ) ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; } public void testRead_withProcessor ( ) throws IOException { final byte [ ] processedBytes = new byte [ bytes . length ] ; ByteProcessor < byte [ ] > processor = new ByteProcessor < byte [ ] > ( ) { int pos ; @Override public boolean processBytes ( byte [ ] buf , int off , int len ) throws IOException { System . arraycopy ( buf , off , processedBytes , pos , len ) ; pos + = len ; return true ; } @Override public byte [ ] getResult ( ) { return processedBytes ; } } ; source . read ( processor ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; assertArrayEquals ( bytes , processedBytes ) ; } public void testRead_withProcessor_stopsOnFalse ( ) throws IOException { ByteProcessor < Void > processor = new ByteProcessor < Void > ( ) { boolean firstCall = true ; @Override public boolean processBytes ( byte [ ] buf , int off , int len ) throws IOException { assertTrue ( <str> , firstCall ) ; firstCall = false ; return false ; } @Override public Void getResult ( ) { return null ; } } ; source . read ( processor ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; } public void testHash ( ) throws IOException { ByteSource byteSource = new TestByteSource ( <str> . getBytes ( Charsets . US_ASCII ) ) ; assertEquals ( <str> , byteSource . hash ( Hashing . md5 ( ) ) . toString ( ) ) ; } public void testContentEquals ( ) throws IOException { assertTrue ( source . contentEquals ( source ) ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; ByteSource equalSource = new TestByteSource ( bytes ) ; assertTrue ( source . contentEquals ( equalSource ) ) ; assertTrue ( new TestByteSource ( bytes ) . contentEquals ( source ) ) ; ByteSource fewerBytes = new TestByteSource ( newPreFilledByteArray ( bytes . length / <int> ) ) ; assertFalse ( source . contentEquals ( fewerBytes ) ) ; byte [ ] copy = bytes . clone ( ) ; copy [ <int> ] = <int> ; ByteSource oneByteOff = new TestByteSource ( copy ) ; assertFalse ( source . contentEquals ( oneByteOff ) ) ; } public void testSlice ( ) throws IOException { try { source . slice ( - <int> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { source . slice ( <int> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; assertCorrectSlice ( <int> , <int> , <int> , <int> ) ; } public void testSlice_appendingAfterSlicing ( ) throws IOException { AppendableByteSource source = new AppendableByteSource ( newPreFilledByteArray ( <int> ) ) ; ByteSource slice = source . slice ( <int> , <int> ) ; InputStream in = slice . openStream ( ) ; source . append ( newPreFilledByteArray ( <int> , <int> ) ) ; assertEquals ( - <int> , in . read ( ) ) ; } private static class AppendableByteSource extends ByteSource { private byte [ ] bytes ; public AppendableByteSource ( byte [ ] initialBytes ) { this . bytes = initialBytes . clone ( ) ; } @Override public InputStream openStream ( ) { return new In ( ) ; } public void append ( byte [ ] b ) { byte [ ] newBytes = Arrays . copyOf ( bytes , bytes . length + b . length ) ; System . arraycopy ( b , <int> , newBytes , bytes . length , b . length ) ; bytes = newBytes ; } private class In extends InputStream { private int pos ; @Override public int read ( ) throws IOException { byte [ ] b = new byte [ <int> ] ; return read ( b ) = = - <int> ? - <int> : UnsignedBytes . toInt ( b [ <int> ] ) ; } @Override public int read ( byte [ ] b , int off , int len ) { if ( pos > = bytes . length ) { return - <int> ; } int lenToRead = Math . min ( len , bytes . length - pos ) ; System . arraycopy ( bytes , pos , b , off , lenToRead ) ; pos + = lenToRead ; return lenToRead ; } } } private static void assertCorrectSlice ( int input , int offset , long length , int expectRead ) throws IOException { checkArgument ( expectRead = = ( int ) Math . max ( <int> , Math . min ( input , offset + length ) - offset ) ) ; byte [ ] expected = newPreFilledByteArray ( offset , expectRead ) ; ByteSource source = new TestByteSource ( newPreFilledByteArray ( input ) ) ; ByteSource slice = source . slice ( offset , length ) ; assertArrayEquals ( expected , slice . read ( ) ) ; } public void testCopyToStream_doesNotCloseThatStream ( ) throws IOException { TestOutputStream out = new TestOutputStream ( ByteStreams . nullOutputStream ( ) ) ; assertFalse ( out . closed ( ) ) ; source . copyTo ( out ) ; assertFalse ( out . closed ( ) ) ; } public void testClosesOnErrors_copyingToByteSinkThatThrows ( ) { for ( TestOption option : EnumSet . of ( OPEN_THROWS , WRITE_THROWS , CLOSE_THROWS ) ) { TestByteSource okSource = new TestByteSource ( bytes ) ; try { okSource . copyTo ( new TestByteSink ( option ) ) ; fail ( ) ; } catch ( IOException expected ) { } assertTrue ( <str> + option , ! okSource . wasStreamOpened ( ) | | okSource . wasStreamClosed ( ) ) ; } } public void testClosesOnErrors_whenReadThrows ( ) { TestByteSource failSource = new TestByteSource ( bytes , READ_THROWS ) ; try { failSource . copyTo ( new TestByteSink ( ) ) ; fail ( ) ; } catch ( IOException expected ) { } assertTrue ( failSource . wasStreamClosed ( ) ) ; } public void testClosesOnErrors_copyingToOutputStreamThatThrows ( ) { TestByteSource okSource = new TestByteSource ( bytes ) ; try { OutputStream out = new TestOutputStream ( ByteStreams . nullOutputStream ( ) , WRITE_THROWS ) ; okSource . copyTo ( out ) ; fail ( ) ; } catch ( IOException expected ) { } assertTrue ( okSource . wasStreamClosed ( ) ) ; } public void testConcat ( ) throws IOException { ByteSource b1 = ByteSource . wrap ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; ByteSource b2 = ByteSource . wrap ( new byte [ <int> ] ) ; ByteSource b3 = ByteSource . wrap ( new byte [ ] { <int> , <int> } ) ; byte [ ] expected = { <int> , <int> , <int> , <int> , <int> , <int> } ; assertArrayEquals ( expected , ByteSource . concat ( ImmutableList . of ( b1 , b2 , b3 ) ) . read ( ) ) ; assertArrayEquals ( expected , ByteSource . concat ( b1 , b2 , b3 ) . read ( ) ) ; assertArrayEquals ( expected , ByteSource . concat ( ImmutableList . of ( b1 , b2 , b3 ) . iterator ( ) ) . read ( ) ) ; assertEquals ( expected . length , ByteSource . concat ( b1 , b2 , b3 ) . size ( ) ) ; assertFalse ( ByteSource . concat ( b1 , b2 , b3 ) . isEmpty ( ) ) ; ByteSource emptyConcat = ByteSource . concat ( ByteSource . empty ( ) , ByteSource . empty ( ) ) ; assertTrue ( emptyConcat . isEmpty ( ) ) ; assertEquals ( <int> , emptyConcat . size ( ) ) ; } public void testConcat_infiniteIterable ( ) throws IOException { ByteSource source = ByteSource . wrap ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; Iterable < ByteSource > cycle = Iterables . cycle ( ImmutableList . of ( source ) ) ; ByteSource concatenated = ByteSource . concat ( cycle ) ; byte [ ] expected = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; assertArrayEquals ( expected , concatenated . slice ( <int> , <int> ) . read ( ) ) ; } private static final ByteSource BROKEN_CLOSE_SOURCE = new TestByteSource ( new byte [ <int> ] , CLOSE_THROWS ) ; private static final ByteSource BROKEN_OPEN_SOURCE = new TestByteSource ( new byte [ <int> ] , OPEN_THROWS ) ; private static final ByteSource BROKEN_READ_SOURCE = new TestByteSource ( new byte [ <int> ] , READ_THROWS ) ; private static final ByteSink BROKEN_CLOSE_SINK = new TestByteSink ( CLOSE_THROWS ) ; private static final ByteSink BROKEN_OPEN_SINK = new TestByteSink ( OPEN_THROWS ) ; private static final ByteSink BROKEN_WRITE_SINK = new TestByteSink ( WRITE_THROWS ) ; private static final ImmutableSet < ByteSource > BROKEN_SOURCES = ImmutableSet . of ( BROKEN_CLOSE_SOURCE , BROKEN_OPEN_SOURCE , BROKEN_READ_SOURCE ) ; private static final ImmutableSet < ByteSink > BROKEN_SINKS = ImmutableSet . of ( BROKEN_CLOSE_SINK , BROKEN_OPEN_SINK , BROKEN_WRITE_SINK ) ; public void testCopyExceptions ( ) { if ( ! Closer . SuppressingSuppressor . isAvailable ( ) ) { TestLogHandler logHandler = new TestLogHandler ( ) ; Closeables . logger . addHandler ( logHandler ) ; try { for ( ByteSource in : BROKEN_SOURCES ) { runFailureTest ( in , newNormalByteSink ( ) ) ; assertTrue ( logHandler . getStoredLogRecords ( ) . isEmpty ( ) ) ; runFailureTest ( in , BROKEN_CLOSE_SINK ) ; assertEquals ( ( in = = BROKEN_OPEN_SOURCE ) ? <int> : <int> , getAndResetRecords ( logHandler ) ) ; } for ( ByteSink out : BROKEN_SINKS ) { runFailureTest ( newNormalByteSource ( ) , out ) ; assertTrue ( logHandler . getStoredLogRecords ( ) . isEmpty ( ) ) ; runFailureTest ( BROKEN_CLOSE_SOURCE , out ) ; assertEquals ( <int> , getAndResetRecords ( logHandler ) ) ; } for ( ByteSource in : BROKEN_SOURCES ) { for ( ByteSink out : BROKEN_SINKS ) { runFailureTest ( in , out ) ; assertTrue ( getAndResetRecords ( logHandler ) < = <int> ) ; } } } finally { Closeables . logger . removeHandler ( logHandler ) ; } } else { for ( ByteSource in : BROKEN_SOURCES ) { int suppressed = runSuppressionFailureTest ( in , newNormalByteSink ( ) ) ; assertEquals ( <int> , suppressed ) ; suppressed = runSuppressionFailureTest ( in , BROKEN_CLOSE_SINK ) ; assertEquals ( ( in = = BROKEN_OPEN_SOURCE ) ? <int> : <int> , suppressed ) ; } for ( ByteSink out : BROKEN_SINKS ) { int suppressed = runSuppressionFailureTest ( newNormalByteSource ( ) , out ) ; assertEquals ( <int> , suppressed ) ; suppressed = runSuppressionFailureTest ( BROKEN_CLOSE_SOURCE , out ) ; assertEquals ( <int> , suppressed ) ; } for ( ByteSource in : BROKEN_SOURCES ) { for ( ByteSink out : BROKEN_SINKS ) { int suppressed = runSuppressionFailureTest ( in , out ) ; assertTrue ( suppressed < = <int> ) ; } } } } private static int getAndResetRecords ( TestLogHandler logHandler ) { int records = logHandler . getStoredLogRecords ( ) . size ( ) ; logHandler . clear ( ) ; return records ; } private static void runFailureTest ( ByteSource in , ByteSink out ) { try { in . copyTo ( out ) ; fail ( ) ; } catch ( IOException expected ) { } } private static int runSuppressionFailureTest ( ByteSource in , ByteSink out ) { try { in . copyTo ( out ) ; fail ( ) ; } catch ( IOException expected ) { return CloserTest . getSuppressed ( expected ) . length ; } throw new AssertionError ( ) ; } private static ByteSource newNormalByteSource ( ) { return ByteSource . wrap ( new byte [ <int> ] ) ; } private static ByteSink newNormalByteSink ( ) { return new ByteSink ( ) { @Override public OutputStream openStream ( ) { return new ByteArrayOutputStream ( ) ; } } ; } } 
