package org . elasticsearch . search . fetch . explain ; import org . apache . lucene . search . Explanation ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . fetch . FetchPhaseExecutionException ; import org . elasticsearch . search . fetch . FetchSubPhase ; import org . elasticsearch . search . internal . InternalSearchHit ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . rescore . RescoreSearchContext ; import java . io . IOException ; import java . util . Map ; import static java . util . Collections . singletonMap ; public class ExplainFetchSubPhase implements FetchSubPhase { @Override public Map < String , ? extends SearchParseElement > parseElements ( ) { return singletonMap ( <str> , new ExplainParseElement ( ) ) ; } @Override public boolean hitsExecutionNeeded ( SearchContext context ) { return false ; } @Override public void hitsExecute ( SearchContext context , InternalSearchHit [ ] hits ) { } @Override public boolean hitExecutionNeeded ( SearchContext context ) { return context . explain ( ) ; } @Override public void hitExecute ( SearchContext context , HitContext hitContext ) { try { final int topLevelDocId = hitContext . hit ( ) . docId ( ) ; Explanation explanation = context . searcher ( ) . explain ( context . query ( ) , topLevelDocId ) ; for ( RescoreSearchContext rescore : context . rescore ( ) ) { explanation = rescore . rescorer ( ) . explain ( topLevelDocId , context , rescore , explanation ) ; } hitContext . hit ( ) . explanation ( explanation ) ; } catch ( IOException e ) { throw new FetchPhaseExecutionException ( context , <str> + hitContext . hit ( ) . type ( ) + <str> + hitContext . hit ( ) . id ( ) + <str> , e ) ; } finally { context . clearReleasables ( SearchContext . Lifetime . COLLECTION ) ; } } } 
