package org . elasticsearch . common . lucene ; import org . apache . lucene . analysis . core . KeywordAnalyzer ; import org . apache . lucene . analysis . standard . StandardAnalyzer ; import org . apache . lucene . codecs . CodecUtil ; import org . apache . lucene . codecs . DocValuesFormat ; import org . apache . lucene . codecs . PostingsFormat ; import org . apache . lucene . index . * ; import org . apache . lucene . search . * ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . IOContext ; import org . apache . lucene . store . IndexInput ; import org . apache . lucene . store . Lock ; import org . apache . lucene . util . Bits ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . Counter ; import org . apache . lucene . util . Version ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . util . iterable . Iterables ; import org . elasticsearch . index . analysis . AnalyzerScope ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . fielddata . IndexFieldData ; import java . io . IOException ; import java . text . ParseException ; import java . util . * ; public class Lucene { public static final Version VERSION = Version . LATEST ; public static final Version ANALYZER_VERSION = VERSION ; public static final Version QUERYPARSER_VERSION = VERSION ; public static final String LATEST_DOC_VALUES_FORMAT = <str> ; public static final String LATEST_POSTINGS_FORMAT = <str> ; public static final String LATEST_CODEC = <str> ; static { Deprecated annotation = PostingsFormat . forName ( LATEST_POSTINGS_FORMAT ) . getClass ( ) . getAnnotation ( Deprecated . class ) ; assert annotation = = null : <str> + LATEST_POSTINGS_FORMAT + <str> ; annotation = DocValuesFormat . forName ( LATEST_DOC_VALUES_FORMAT ) . getClass ( ) . getAnnotation ( Deprecated . class ) ; assert annotation = = null : <str> + LATEST_DOC_VALUES_FORMAT + <str> ; } public static final NamedAnalyzer STANDARD_ANALYZER = new NamedAnalyzer ( <str> , AnalyzerScope . GLOBAL , new StandardAnalyzer ( ) ) ; public static final NamedAnalyzer KEYWORD_ANALYZER = new NamedAnalyzer ( <str> , AnalyzerScope . GLOBAL , new KeywordAnalyzer ( ) ) ; public static final ScoreDoc [ ] EMPTY_SCORE_DOCS = new ScoreDoc [ <int> ] ; public static final TopDocs EMPTY_TOP_DOCS = new TopDocs ( <int> , EMPTY_SCORE_DOCS , <float> ) ; @SuppressWarnings ( <str> ) public static Version parseVersion ( @Nullable String version , Version defaultVersion , ESLogger logger ) { if ( version = = null ) { return defaultVersion ; } try { return Version . parse ( version ) ; } catch ( ParseException e ) { logger . warn ( <str> , version , defaultVersion , e ) ; return defaultVersion ; } } public static SegmentInfos readSegmentInfos ( Directory directory ) throws IOException { return SegmentInfos . readLatestCommit ( directory ) ; } public static Iterable < String > files ( SegmentInfos infos ) throws IOException { final List < Collection < String > > list = new ArrayList < > ( ) ; list . add ( Collections . singleton ( infos . getSegmentsFileName ( ) ) ) ; for ( SegmentCommitInfo info : infos ) { list . add ( info . files ( ) ) ; } return Iterables . flatten ( list ) ; } public static int getNumDocs ( SegmentInfos info ) { int numDocs = <int> ; for ( SegmentCommitInfo si : info ) { numDocs + = si . info . maxDoc ( ) - si . getDelCount ( ) ; } return numDocs ; } public static SegmentInfos readSegmentInfos ( IndexCommit commit ) throws IOException { String filename = IndexFileNames . fileNameFromGeneration ( IndexFileNames . SEGMENTS , <str> , commit . getGeneration ( ) ) ; return SegmentInfos . readCommit ( commit . getDirectory ( ) , filename ) ; } private static SegmentInfos readSegmentInfos ( String segmentsFileName , Directory directory ) throws IOException { return SegmentInfos . readCommit ( directory , segmentsFileName ) ; } public static SegmentInfos pruneUnreferencedFiles ( String segmentsFileName , Directory directory ) throws IOException { final SegmentInfos si = readSegmentInfos ( segmentsFileName , directory ) ; try ( Lock writeLock = directory . obtainLock ( IndexWriter . WRITE_LOCK_NAME ) ) { int foundSegmentFiles = <int> ; for ( final String file : directory . listAll ( ) ) { if ( file . startsWith ( IndexFileNames . SEGMENTS ) | | file . equals ( IndexFileNames . OLD_SEGMENTS_GEN ) ) { foundSegmentFiles + + ; if ( file . equals ( si . getSegmentsFileName ( ) ) = = false ) { directory . deleteFile ( file ) ; } } } assert SegmentInfos . getLastCommitSegmentsFileName ( directory ) . equals ( segmentsFileName ) ; if ( foundSegmentFiles = = <int> ) { throw new IllegalStateException ( <str> ) ; } } final CommitPoint cp = new CommitPoint ( si , directory ) ; try ( IndexWriter writer = new IndexWriter ( directory , new IndexWriterConfig ( Lucene . STANDARD_ANALYZER ) . setIndexCommit ( cp ) . setCommitOnClose ( false ) . setMergePolicy ( NoMergePolicy . INSTANCE ) . setOpenMode ( IndexWriterConfig . OpenMode . APPEND ) ) ) { } return si ; } public static void cleanLuceneIndex ( Directory directory ) throws IOException { try ( Lock writeLock = directory . obtainLock ( IndexWriter . WRITE_LOCK_NAME ) ) { for ( final String file : directory . listAll ( ) ) { if ( file . startsWith ( IndexFileNames . SEGMENTS ) | | file . equals ( IndexFileNames . OLD_SEGMENTS_GEN ) ) { directory . deleteFile ( file ) ; } } } try ( IndexWriter writer = new IndexWriter ( directory , new IndexWriterConfig ( Lucene . STANDARD_ANALYZER ) . setMergePolicy ( NoMergePolicy . INSTANCE ) . setCommitOnClose ( false ) . setOpenMode ( IndexWriterConfig . OpenMode . CREATE ) ) ) { } } public static void checkSegmentInfoIntegrity ( final Directory directory ) throws IOException { new SegmentInfos . FindSegmentsFile ( directory ) { @Override protected Object doBody ( String segmentFileName ) throws IOException { try ( IndexInput input = directory . openInput ( segmentFileName , IOContext . READ ) ) { final int format = input . readInt ( ) ; final int actualFormat ; if ( format = = CodecUtil . CODEC_MAGIC ) { actualFormat = CodecUtil . checkHeaderNoMagic ( input , <str> , SegmentInfos . VERSION_40 , Integer . MAX_VALUE ) ; if ( actualFormat > = SegmentInfos . VERSION_48 ) { CodecUtil . checksumEntireFile ( input ) ; } } } return null ; } } . run ( ) ; } public final static EarlyTerminatingCollector wrapCountBasedEarlyTerminatingCollector ( final Collector delegate , int maxCountHits ) { return new EarlyTerminatingCollector ( delegate , maxCountHits ) ; } public final static TimeLimitingCollector wrapTimeLimitingCollector ( final Collector delegate , final Counter counter , long timeoutInMillis ) { return new TimeLimitingCollector ( delegate , counter , timeoutInMillis ) ; } public static boolean exists ( IndexSearcher searcher , Query query ) throws IOException { final Weight weight = searcher . createNormalizedWeight ( query , false ) ; for ( LeafReaderContext context : searcher . getIndexReader ( ) . leaves ( ) ) { final Scorer scorer = weight . scorer ( context ) ; if ( scorer = = null ) { continue ; } final Bits liveDocs = context . reader ( ) . getLiveDocs ( ) ; for ( int doc = scorer . nextDoc ( ) ; doc ! = DocIdSetIterator . NO_MORE_DOCS ; doc = scorer . nextDoc ( ) ) { if ( liveDocs = = null | | liveDocs . get ( doc ) ) { return true ; } } } return false ; } public static TopDocs readTopDocs ( StreamInput in ) throws IOException { if ( in . readBoolean ( ) ) { int totalHits = in . readVInt ( ) ; float maxScore = in . readFloat ( ) ; SortField [ ] fields = new SortField [ in . readVInt ( ) ] ; for ( int i = <int> ; i < fields . length ; i + + ) { String field = null ; if ( in . readBoolean ( ) ) { field = in . readString ( ) ; } SortField . Type sortType = readSortType ( in ) ; Object missingValue = readMissingValue ( in ) ; boolean reverse = in . readBoolean ( ) ; fields [ i ] = new SortField ( field , sortType , reverse ) ; if ( missingValue ! = null ) { fields [ i ] . setMissingValue ( missingValue ) ; } } FieldDoc [ ] fieldDocs = new FieldDoc [ in . readVInt ( ) ] ; for ( int i = <int> ; i < fieldDocs . length ; i + + ) { fieldDocs [ i ] = readFieldDoc ( in ) ; } return new TopFieldDocs ( totalHits , fieldDocs , fields , maxScore ) ; } else { int totalHits = in . readVInt ( ) ; float maxScore = in . readFloat ( ) ; ScoreDoc [ ] scoreDocs = new ScoreDoc [ in . readVInt ( ) ] ; for ( int i = <int> ; i < scoreDocs . length ; i + + ) { scoreDocs [ i ] = new ScoreDoc ( in . readVInt ( ) , in . readFloat ( ) ) ; } return new TopDocs ( totalHits , scoreDocs , maxScore ) ; } } public static FieldDoc readFieldDoc ( StreamInput in ) throws IOException { Comparable [ ] cFields = new Comparable [ in . readVInt ( ) ] ; for ( int j = <int> ; j < cFields . length ; j + + ) { byte type = in . readByte ( ) ; if ( type = = <int> ) { cFields [ j ] = null ; } else if ( type = = <int> ) { cFields [ j ] = in . readString ( ) ; } else if ( type = = <int> ) { cFields [ j ] = in . readInt ( ) ; } else if ( type = = <int> ) { cFields [ j ] = in . readLong ( ) ; } else if ( type = = <int> ) { cFields [ j ] = in . readFloat ( ) ; } else if ( type = = <int> ) { cFields [ j ] = in . readDouble ( ) ; } else if ( type = = <int> ) { cFields [ j ] = in . readByte ( ) ; } else if ( type = = <int> ) { cFields [ j ] = in . readShort ( ) ; } else if ( type = = <int> ) { cFields [ j ] = in . readBoolean ( ) ; } else if ( type = = <int> ) { cFields [ j ] = in . readBytesRef ( ) ; } else { throw new IOException ( <str> + type + <str> ) ; } } return new FieldDoc ( in . readVInt ( ) , in . readFloat ( ) , cFields ) ; } public static ScoreDoc readScoreDoc ( StreamInput in ) throws IOException { return new ScoreDoc ( in . readVInt ( ) , in . readFloat ( ) ) ; } public static void writeTopDocs ( StreamOutput out , TopDocs topDocs ) throws IOException { if ( topDocs instanceof TopFieldDocs ) { out . writeBoolean ( true ) ; TopFieldDocs topFieldDocs = ( TopFieldDocs ) topDocs ; out . writeVInt ( topDocs . totalHits ) ; out . writeFloat ( topDocs . getMaxScore ( ) ) ; out . writeVInt ( topFieldDocs . fields . length ) ; for ( SortField sortField : topFieldDocs . fields ) { if ( sortField . getField ( ) = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeString ( sortField . getField ( ) ) ; } if ( sortField . getComparatorSource ( ) ! = null ) { IndexFieldData . XFieldComparatorSource comparatorSource = ( IndexFieldData . XFieldComparatorSource ) sortField . getComparatorSource ( ) ; writeSortType ( out , comparatorSource . reducedType ( ) ) ; writeMissingValue ( out , comparatorSource . missingValue ( sortField . getReverse ( ) ) ) ; } else { writeSortType ( out , sortField . getType ( ) ) ; writeMissingValue ( out , sortField . missingValue ) ; } out . writeBoolean ( sortField . getReverse ( ) ) ; } out . writeVInt ( topDocs . scoreDocs . length ) ; for ( ScoreDoc doc : topFieldDocs . scoreDocs ) { writeFieldDoc ( out , ( FieldDoc ) doc ) ; } } else { out . writeBoolean ( false ) ; out . writeVInt ( topDocs . totalHits ) ; out . writeFloat ( topDocs . getMaxScore ( ) ) ; out . writeVInt ( topDocs . scoreDocs . length ) ; for ( ScoreDoc doc : topDocs . scoreDocs ) { writeScoreDoc ( out , doc ) ; } } } private static void writeMissingValue ( StreamOutput out , Object missingValue ) throws IOException { if ( missingValue = = SortField . STRING_FIRST ) { out . writeByte ( ( byte ) <int> ) ; } else if ( missingValue = = SortField . STRING_LAST ) { out . writeByte ( ( byte ) <int> ) ; } else { out . writeByte ( ( byte ) <int> ) ; out . writeGenericValue ( missingValue ) ; } } private static Object readMissingValue ( StreamInput in ) throws IOException { final byte id = in . readByte ( ) ; switch ( id ) { case <int> : return in . readGenericValue ( ) ; case <int> : return SortField . STRING_FIRST ; case <int> : return SortField . STRING_LAST ; default : throw new IOException ( <str> + id ) ; } } public static void writeFieldDoc ( StreamOutput out , FieldDoc fieldDoc ) throws IOException { out . writeVInt ( fieldDoc . fields . length ) ; for ( Object field : fieldDoc . fields ) { if ( field = = null ) { out . writeByte ( ( byte ) <int> ) ; } else { Class type = field . getClass ( ) ; if ( type = = String . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeString ( ( String ) field ) ; } else if ( type = = Integer . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeInt ( ( Integer ) field ) ; } else if ( type = = Long . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeLong ( ( Long ) field ) ; } else if ( type = = Float . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeFloat ( ( Float ) field ) ; } else if ( type = = Double . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeDouble ( ( Double ) field ) ; } else if ( type = = Byte . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeByte ( ( Byte ) field ) ; } else if ( type = = Short . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeShort ( ( Short ) field ) ; } else if ( type = = Boolean . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeBoolean ( ( Boolean ) field ) ; } else if ( type = = BytesRef . class ) { out . writeByte ( ( byte ) <int> ) ; out . writeBytesRef ( ( BytesRef ) field ) ; } else { throw new IOException ( <str> + type + <str> ) ; } } } out . writeVInt ( fieldDoc . doc ) ; out . writeFloat ( fieldDoc . score ) ; } public static void writeScoreDoc ( StreamOutput out , ScoreDoc scoreDoc ) throws IOException { if ( ! scoreDoc . getClass ( ) . equals ( ScoreDoc . class ) ) { throw new IllegalArgumentException ( <str> + scoreDoc . getClass ( ) ) ; } out . writeVInt ( scoreDoc . doc ) ; out . writeFloat ( scoreDoc . score ) ; } public static SortField . Type readSortType ( StreamInput in ) throws IOException { return SortField . Type . values ( ) [ in . readVInt ( ) ] ; } public static void writeSortType ( StreamOutput out , SortField . Type sortType ) throws IOException { out . writeVInt ( sortType . ordinal ( ) ) ; } public static Explanation readExplanation ( StreamInput in ) throws IOException { boolean match = in . readBoolean ( ) ; String description = in . readString ( ) ; final Explanation [ ] subExplanations = new Explanation [ in . readVInt ( ) ] ; for ( int i = <int> ; i < subExplanations . length ; + + i ) { subExplanations [ i ] = readExplanation ( in ) ; } if ( match ) { return Explanation . match ( in . readFloat ( ) , description , subExplanations ) ; } else { return Explanation . noMatch ( description , subExplanations ) ; } } public static void writeExplanation ( StreamOutput out , Explanation explanation ) throws IOException { out . writeBoolean ( explanation . isMatch ( ) ) ; out . writeString ( explanation . getDescription ( ) ) ; Explanation [ ] subExplanations = explanation . getDetails ( ) ; out . writeVInt ( subExplanations . length ) ; for ( Explanation subExp : subExplanations ) { writeExplanation ( out , subExp ) ; } if ( explanation . isMatch ( ) ) { out . writeFloat ( explanation . getValue ( ) ) ; } } public final static class EarlyTerminationException extends ElasticsearchException { public EarlyTerminationException ( String msg ) { super ( msg ) ; } public EarlyTerminationException ( StreamInput in ) throws IOException { super ( in ) ; } } public final static class EarlyTerminatingCollector extends SimpleCollector { private final int maxCountHits ; private final Collector delegate ; private int count = <int> ; private LeafCollector leafCollector ; EarlyTerminatingCollector ( final Collector delegate , int maxCountHits ) { this . maxCountHits = maxCountHits ; this . delegate = Objects . requireNonNull ( delegate ) ; } public int count ( ) { return count ; } public boolean exists ( ) { return count > <int> ; } @Override public void setScorer ( Scorer scorer ) throws IOException { leafCollector . setScorer ( scorer ) ; } @Override public void collect ( int doc ) throws IOException { leafCollector . collect ( doc ) ; if ( + + count > = maxCountHits ) { throw new EarlyTerminationException ( <str> ) ; } } @Override public void doSetNextReader ( LeafReaderContext atomicReaderContext ) throws IOException { leafCollector = delegate . getLeafCollector ( atomicReaderContext ) ; } @Override public boolean needsScores ( ) { return delegate . needsScores ( ) ; } } private Lucene ( ) { } public static final boolean indexExists ( final Directory directory ) throws IOException { return DirectoryReader . indexExists ( directory ) ; } public static final boolean waitForIndex ( final Directory directory , final long timeLimitMillis ) throws IOException { final long DELAY = <int> ; long waited = <int> ; try { while ( true ) { if ( waited > = timeLimitMillis ) { break ; } if ( indexExists ( directory ) ) { return true ; } Thread . sleep ( DELAY ) ; waited + = DELAY ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; return false ; } return indexExists ( directory ) ; } public static boolean isCorruptionException ( Throwable t ) { return ExceptionsHelper . unwrapCorruption ( t ) ! = null ; } public static Version parseVersionLenient ( String toParse , Version defaultValue ) { return LenientParser . parse ( toParse , defaultValue ) ; } @SuppressForbidden ( reason = <str> ) private static final class LenientParser { public static Version parse ( String toParse , Version defaultValue ) { if ( Strings . hasLength ( toParse ) ) { try { return Version . parseLeniently ( toParse ) ; } catch ( ParseException e ) { } } return defaultValue ; } } public static Scorer illegalScorer ( final String message ) { return new Scorer ( null ) { @Override public float score ( ) throws IOException { throw new IllegalStateException ( message ) ; } @Override public int freq ( ) throws IOException { throw new IllegalStateException ( message ) ; } @Override public int advance ( int arg0 ) throws IOException { throw new IllegalStateException ( message ) ; } @Override public long cost ( ) { throw new IllegalStateException ( message ) ; } @Override public int docID ( ) { throw new IllegalStateException ( message ) ; } @Override public int nextDoc ( ) throws IOException { throw new IllegalStateException ( message ) ; } } ; } private static final class CommitPoint extends IndexCommit { private String segmentsFileName ; private final Collection < String > files ; private final Directory dir ; private final long generation ; private final Map < String , String > userData ; private final int segmentCount ; private CommitPoint ( SegmentInfos infos , Directory dir ) throws IOException { segmentsFileName = infos . getSegmentsFileName ( ) ; this . dir = dir ; userData = infos . getUserData ( ) ; files = Collections . unmodifiableCollection ( infos . files ( dir , true ) ) ; generation = infos . getGeneration ( ) ; segmentCount = infos . size ( ) ; } @Override public String toString ( ) { return <str> + segmentsFileName + <str> ; } @Override public int getSegmentCount ( ) { return segmentCount ; } @Override public String getSegmentsFileName ( ) { return segmentsFileName ; } @Override public Collection < String > getFileNames ( ) { return files ; } @Override public Directory getDirectory ( ) { return dir ; } @Override public long getGeneration ( ) { return generation ; } @Override public boolean isDeleted ( ) { return false ; } @Override public Map < String , String > getUserData ( ) { return userData ; } @Override public void delete ( ) { throw new UnsupportedOperationException ( <str> ) ; } } public static Bits asSequentialAccessBits ( final int maxDoc , @Nullable Scorer scorer ) throws IOException { if ( scorer = = null ) { return new Bits . MatchNoBits ( maxDoc ) ; } final TwoPhaseIterator twoPhase = scorer . asTwoPhaseIterator ( ) ; final DocIdSetIterator iterator ; if ( twoPhase = = null ) { iterator = scorer ; } else { iterator = twoPhase . approximation ( ) ; } return new Bits ( ) { int previous = - <int> ; boolean previousMatched = false ; @Override public boolean get ( int index ) { if ( index < <int> | | index > = maxDoc ) { throw new IndexOutOfBoundsException ( index + <str> + <int> + <str> + maxDoc + <str> ) ; } if ( index < previous ) { throw new IllegalArgumentException ( <str> + <str> + index + <str> + previous + <str> ) ; } if ( index = = previous ) { return previousMatched ; } previous = index ; int doc = iterator . docID ( ) ; if ( doc < index ) { try { doc = iterator . advance ( index ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } if ( index = = doc ) { try { return previousMatched = twoPhase = = null | | twoPhase . matches ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } return previousMatched = false ; } @Override public int length ( ) { return maxDoc ; } } ; } } 
