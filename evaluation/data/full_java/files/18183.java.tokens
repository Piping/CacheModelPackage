package com . badlogic . gdx . math ; import com . badlogic . gdx . utils . BooleanArray ; import com . badlogic . gdx . utils . FloatArray ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . ShortArray ; public class DelaunayTriangulator { static private final float EPSILON = <float> ; static private final int INSIDE = <int> ; static private final int COMPLETE = <int> ; static private final int INCOMPLETE = <int> ; private final IntArray quicksortStack = new IntArray ( ) ; private float [ ] sortedPoints ; private final ShortArray triangles = new ShortArray ( false , <int> ) ; private final ShortArray originalIndices = new ShortArray ( false , <int> ) ; private final IntArray edges = new IntArray ( ) ; private final BooleanArray complete = new BooleanArray ( false , <int> ) ; private final float [ ] superTriangle = new float [ <int> ] ; private final Vector2 centroid = new Vector2 ( ) ; public ShortArray computeTriangles ( FloatArray points , boolean sorted ) { return computeTriangles ( points . items , <int> , points . size , sorted ) ; } public ShortArray computeTriangles ( float [ ] polygon , boolean sorted ) { return computeTriangles ( polygon , <int> , polygon . length , sorted ) ; } public ShortArray computeTriangles ( float [ ] points , int offset , int count , boolean sorted ) { ShortArray triangles = this . triangles ; triangles . clear ( ) ; if ( count < <int> ) return triangles ; triangles . ensureCapacity ( count ) ; if ( ! sorted ) { if ( sortedPoints = = null | | sortedPoints . length < count ) sortedPoints = new float [ count ] ; System . arraycopy ( points , offset , sortedPoints , <int> , count ) ; points = sortedPoints ; offset = <int> ; sort ( points , count ) ; } int end = offset + count ; float xmin = points [ <int> ] , ymin = points [ <int> ] ; float xmax = xmin , ymax = ymin ; for ( int i = offset + <int> ; i < end ; i + + ) { float value = points [ i ] ; if ( value < xmin ) xmin = value ; if ( value > xmax ) xmax = value ; i + + ; value = points [ i ] ; if ( value < ymin ) ymin = value ; if ( value > ymax ) ymax = value ; } float dx = xmax - xmin , dy = ymax - ymin ; float dmax = ( dx > dy ? dx : dy ) * <int> f ; float xmid = ( xmax + xmin ) / <float> , ymid = ( ymax + ymin ) / <float> ; float [ ] superTriangle = this . superTriangle ; superTriangle [ <int> ] = xmid - dmax ; superTriangle [ <int> ] = ymid - dmax ; superTriangle [ <int> ] = xmid ; superTriangle [ <int> ] = ymid + dmax ; superTriangle [ <int> ] = xmid + dmax ; superTriangle [ <int> ] = ymid - dmax ; IntArray edges = this . edges ; edges . ensureCapacity ( count / <int> ) ; BooleanArray complete = this . complete ; complete . clear ( ) ; complete . ensureCapacity ( count ) ; triangles . add ( end ) ; triangles . add ( end + <int> ) ; triangles . add ( end + <int> ) ; complete . add ( false ) ; for ( int pointIndex = offset ; pointIndex < end ; pointIndex + = <int> ) { float x = points [ pointIndex ] , y = points [ pointIndex + <int> ] ; short [ ] trianglesArray = triangles . items ; boolean [ ] completeArray = complete . items ; for ( int triangleIndex = triangles . size - <int> ; triangleIndex > = <int> ; triangleIndex - = <int> ) { int completeIndex = triangleIndex / <int> ; if ( completeArray [ completeIndex ] ) continue ; int p1 = trianglesArray [ triangleIndex - <int> ] ; int p2 = trianglesArray [ triangleIndex - <int> ] ; int p3 = trianglesArray [ triangleIndex ] ; float x1 , y1 , x2 , y2 , x3 , y3 ; if ( p1 > = end ) { int i = p1 - end ; x1 = superTriangle [ i ] ; y1 = superTriangle [ i + <int> ] ; } else { x1 = points [ p1 ] ; y1 = points [ p1 + <int> ] ; } if ( p2 > = end ) { int i = p2 - end ; x2 = superTriangle [ i ] ; y2 = superTriangle [ i + <int> ] ; } else { x2 = points [ p2 ] ; y2 = points [ p2 + <int> ] ; } if ( p3 > = end ) { int i = p3 - end ; x3 = superTriangle [ i ] ; y3 = superTriangle [ i + <int> ] ; } else { x3 = points [ p3 ] ; y3 = points [ p3 + <int> ] ; } switch ( circumCircle ( x , y , x1 , y1 , x2 , y2 , x3 , y3 ) ) { case COMPLETE : completeArray [ completeIndex ] = true ; break ; case INSIDE : edges . add ( p1 ) ; edges . add ( p2 ) ; edges . add ( p2 ) ; edges . add ( p3 ) ; edges . add ( p3 ) ; edges . add ( p1 ) ; triangles . removeIndex ( triangleIndex ) ; triangles . removeIndex ( triangleIndex - <int> ) ; triangles . removeIndex ( triangleIndex - <int> ) ; complete . removeIndex ( completeIndex ) ; break ; } } int [ ] edgesArray = edges . items ; for ( int i = <int> , n = edges . size ; i < n ; i + = <int> ) { int p1 = edgesArray [ i ] ; if ( p1 = = - <int> ) continue ; int p2 = edgesArray [ i + <int> ] ; boolean skip = false ; for ( int ii = i + <int> ; ii < n ; ii + = <int> ) { if ( p1 = = edgesArray [ ii + <int> ] & & p2 = = edgesArray [ ii ] ) { skip = true ; edgesArray [ ii ] = - <int> ; } } if ( skip ) continue ; triangles . add ( p1 ) ; triangles . add ( edgesArray [ i + <int> ] ) ; triangles . add ( pointIndex ) ; complete . add ( false ) ; } edges . clear ( ) ; } short [ ] trianglesArray = triangles . items ; for ( int i = triangles . size - <int> ; i > = <int> ; i - = <int> ) { if ( trianglesArray [ i ] > = end | | trianglesArray [ i - <int> ] > = end | | trianglesArray [ i - <int> ] > = end ) { triangles . removeIndex ( i ) ; triangles . removeIndex ( i - <int> ) ; triangles . removeIndex ( i - <int> ) ; } } if ( ! sorted ) { short [ ] originalIndicesArray = originalIndices . items ; for ( int i = <int> , n = triangles . size ; i < n ; i + + ) trianglesArray [ i ] = ( short ) ( originalIndicesArray [ trianglesArray [ i ] / <int> ] * <int> ) ; } if ( offset = = <int> ) { for ( int i = <int> , n = triangles . size ; i < n ; i + + ) trianglesArray [ i ] = ( short ) ( trianglesArray [ i ] / <int> ) ; } else { for ( int i = <int> , n = triangles . size ; i < n ; i + + ) trianglesArray [ i ] = ( short ) ( ( trianglesArray [ i ] - offset ) / <int> ) ; } return triangles ; } private int circumCircle ( float xp , float yp , float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { float xc , yc ; float y1y2 = Math . abs ( y1 - y2 ) ; float y2y3 = Math . abs ( y2 - y3 ) ; if ( y1y2 < EPSILON ) { if ( y2y3 < EPSILON ) return INCOMPLETE ; float m2 = - ( x3 - x2 ) / ( y3 - y2 ) ; float mx2 = ( x2 + x3 ) / <float> ; float my2 = ( y2 + y3 ) / <float> ; xc = ( x2 + x1 ) / <float> ; yc = m2 * ( xc - mx2 ) + my2 ; } else { float m1 = - ( x2 - x1 ) / ( y2 - y1 ) ; float mx1 = ( x1 + x2 ) / <float> ; float my1 = ( y1 + y2 ) / <float> ; if ( y2y3 < EPSILON ) { xc = ( x3 + x2 ) / <float> ; yc = m1 * ( xc - mx1 ) + my1 ; } else { float m2 = - ( x3 - x2 ) / ( y3 - y2 ) ; float mx2 = ( x2 + x3 ) / <float> ; float my2 = ( y2 + y3 ) / <float> ; xc = ( m1 * mx1 - m2 * mx2 + my2 - my1 ) / ( m1 - m2 ) ; yc = m1 * ( xc - mx1 ) + my1 ; } } float dx = x2 - xc ; float dy = y2 - yc ; float rsqr = dx * dx + dy * dy ; dx = xp - xc ; dx * = dx ; dy = yp - yc ; if ( dx + dy * dy - rsqr < = EPSILON ) return INSIDE ; return xp > xc & & dx > rsqr ? COMPLETE : INCOMPLETE ; } private void sort ( float [ ] values , int count ) { int pointCount = count / <int> ; originalIndices . clear ( ) ; originalIndices . ensureCapacity ( pointCount ) ; short [ ] originalIndicesArray = originalIndices . items ; for ( short i = <int> ; i < pointCount ; i + + ) originalIndicesArray [ i ] = i ; int lower = <int> ; int upper = count - <int> ; IntArray stack = quicksortStack ; stack . add ( lower ) ; stack . add ( upper - <int> ) ; while ( stack . size > <int> ) { upper = stack . pop ( ) ; lower = stack . pop ( ) ; if ( upper < = lower ) continue ; int i = quicksortPartition ( values , lower , upper , originalIndicesArray ) ; if ( i - lower > upper - i ) { stack . add ( lower ) ; stack . add ( i - <int> ) ; } stack . add ( i + <int> ) ; stack . add ( upper ) ; if ( upper - i > = i - lower ) { stack . add ( lower ) ; stack . add ( i - <int> ) ; } } } private int quicksortPartition ( final float [ ] values , int lower , int upper , short [ ] originalIndices ) { float value = values [ lower ] ; int up = upper ; int down = lower + <int> ; float tempValue ; short tempIndex ; while ( down < up ) { while ( down < up & & values [ down ] < = value ) down = down + <int> ; while ( values [ up ] > value ) up = up - <int> ; if ( down < up ) { tempValue = values [ down ] ; values [ down ] = values [ up ] ; values [ up ] = tempValue ; tempValue = values [ down + <int> ] ; values [ down + <int> ] = values [ up + <int> ] ; values [ up + <int> ] = tempValue ; tempIndex = originalIndices [ down / <int> ] ; originalIndices [ down / <int> ] = originalIndices [ up / <int> ] ; originalIndices [ up / <int> ] = tempIndex ; } } values [ lower ] = values [ up ] ; values [ up ] = value ; tempValue = values [ lower + <int> ] ; values [ lower + <int> ] = values [ up + <int> ] ; values [ up + <int> ] = tempValue ; tempIndex = originalIndices [ lower / <int> ] ; originalIndices [ lower / <int> ] = originalIndices [ up / <int> ] ; originalIndices [ up / <int> ] = tempIndex ; return up ; } public void trim ( ShortArray triangles , float [ ] points , float [ ] hull , int offset , int count ) { short [ ] trianglesArray = triangles . items ; for ( int i = triangles . size - <int> ; i > = <int> ; i - = <int> ) { int p1 = trianglesArray [ i - <int> ] * <int> ; int p2 = trianglesArray [ i - <int> ] * <int> ; int p3 = trianglesArray [ i ] * <int> ; GeometryUtils . triangleCentroid ( points [ p1 ] , points [ p1 + <int> ] , points [ p2 ] , points [ p2 + <int> ] , points [ p3 ] , points [ p3 + <int> ] , centroid ) ; if ( ! Intersector . isPointInPolygon ( hull , offset , count , centroid . x , centroid . y ) ) { triangles . removeIndex ( i ) ; triangles . removeIndex ( i - <int> ) ; triangles . removeIndex ( i - <int> ) ; } } } } 
