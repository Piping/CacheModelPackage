package org . elasticsearch . snapshots ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . elasticsearch . action . admin . cluster . snapshots . create . CreateSnapshotResponse ; import org . elasticsearch . action . admin . cluster . snapshots . restore . RestoreSnapshotResponse ; import org . elasticsearch . action . admin . cluster . snapshots . status . SnapshotIndexShardStatus ; import org . elasticsearch . action . admin . cluster . snapshots . status . SnapshotStatus ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . test . ESBackcompatTestCase ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . lessThan ; public class SnapshotBackwardsCompatibilityIT extends ESBackcompatTestCase { public void testSnapshotAndRestore ( ) throws ExecutionException , InterruptedException , IOException { logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) . toAbsolutePath ( ) ) . put ( <str> , randomBoolean ( ) ) . put ( <str> , randomIntBetween ( <int> , <int> ) , ByteSizeUnit . BYTES ) ) ) ; String [ ] indicesBefore = new String [ randomIntBetween ( <int> , <int> ) ] ; String [ ] indicesAfter = new String [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < indicesBefore . length ; i + + ) { indicesBefore [ i ] = <str> + i ; createIndex ( indicesBefore [ i ] ) ; } for ( int i = <int> ; i < indicesAfter . length ; i + + ) { indicesAfter [ i ] = <str> + i ; createIndex ( indicesAfter [ i ] ) ; } String [ ] indices = new String [ indicesBefore . length + indicesAfter . length ] ; System . arraycopy ( indicesBefore , <int> , indices , <int> , indicesBefore . length ) ; System . arraycopy ( indicesAfter , <int> , indices , indicesBefore . length , indicesAfter . length ) ; ensureYellow ( ) ; logger . info ( <str> ) ; IndexRequestBuilder [ ] buildersBefore = new IndexRequestBuilder [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < buildersBefore . length ; i + + ) { buildersBefore [ i ] = client ( ) . prepareIndex ( RandomPicks . randomFrom ( getRandom ( ) , indicesBefore ) , <str> , Integer . toString ( i ) ) . setSource ( <str> ) ; } IndexRequestBuilder [ ] buildersAfter = new IndexRequestBuilder [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < buildersAfter . length ; i + + ) { buildersAfter [ i ] = client ( ) . prepareIndex ( RandomPicks . randomFrom ( getRandom ( ) , indicesBefore ) , <str> , Integer . toString ( i ) ) . setSource ( <str> ) ; } indexRandom ( true , buildersBefore ) ; indexRandom ( true , buildersAfter ) ; assertThat ( client ( ) . prepareSearch ( indices ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( ( long ) ( buildersBefore . length + buildersAfter . length ) ) ) ; long [ ] counts = new long [ indices . length ] ; for ( int i = <int> ; i < indices . length ; i + + ) { counts [ i ] = client ( ) . prepareSearch ( indices [ i ] ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) ; } logger . info ( <str> ) ; CreateSnapshotResponse createSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> ) . get ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; logger . info ( <str> ) ; int howMany = randomIntBetween ( <int> , buildersBefore . length ) ; for ( int i = <int> ; i < howMany ; i + + ) { IndexRequestBuilder indexRequestBuilder = RandomPicks . randomFrom ( getRandom ( ) , buildersBefore ) ; IndexRequest request = indexRequestBuilder . request ( ) ; client ( ) . prepareDelete ( request . index ( ) , request . type ( ) , request . id ( ) ) . get ( ) ; } refresh ( ) ; final long numDocs = client ( ) . prepareSearch ( indices ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) ; assertThat ( client ( ) . prepareSearch ( indices ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , lessThan ( ( long ) ( buildersBefore . length + buildersAfter . length ) ) ) ; disableAllocation ( indices ) ; backwardsCluster ( ) . allowOnAllNodes ( indices ) ; logClusterState ( ) ; boolean upgraded ; do { logClusterState ( ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; upgraded = backwardsCluster ( ) . upgradeOneNode ( ) ; ensureYellow ( ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; } while ( upgraded ) ; enableAllocation ( indices ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . get ( ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . cluster ( ) . prepareVerifyRepository ( <str> ) . get ( ) ; logger . info ( <str> ) ; RestoreSnapshotResponse restoreSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; ensureYellow ( ) ; assertThat ( client ( ) . prepareSearch ( indices ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( ( long ) ( buildersBefore . length + buildersAfter . length ) ) ) ; for ( int i = <int> ; i < indices . length ; i + + ) { assertThat ( counts [ i ] , equalTo ( client ( ) . prepareSearch ( indices [ i ] ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) ) ) ; } logger . info ( <str> ) ; createSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> ) . get ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; logger . info ( <str> ) ; String index = RandomPicks . randomFrom ( getRandom ( ) , indices ) ; cluster ( ) . wipeIndices ( index ) ; logger . info ( <str> ) ; restoreSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( index ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; ensureYellow ( ) ; assertThat ( client ( ) . prepareSearch ( indices ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( ( long ) ( buildersBefore . length + buildersAfter . length ) ) ) ; for ( int i = <int> ; i < indices . length ; i + + ) { assertThat ( counts [ i ] , equalTo ( client ( ) . prepareSearch ( indices [ i ] ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) ) ) ; } } public void testSnapshotMoreThanOnce ( ) throws ExecutionException , InterruptedException , IOException { Client client = client ( ) ; final Path tempDir = randomRepoPath ( ) . toAbsolutePath ( ) ; logger . info ( <str> ) ; assertAcked ( client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , tempDir ) . put ( <str> , randomBoolean ( ) ) . put ( <str> , randomIntBetween ( <int> , <int> ) , ByteSizeUnit . BYTES ) ) ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) ; ensureYellow ( ) ; logger . info ( <str> ) ; final int numDocs = randomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < builders . length ; i + + ) { builders [ i ] = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> + i ) ; } indexRandom ( true , builders ) ; flushAndRefresh ( ) ; assertNoFailures ( client ( ) . admin ( ) . indices ( ) . prepareForceMerge ( <str> ) . setFlush ( true ) . setMaxNumSegments ( <int> ) . get ( ) ) ; CreateSnapshotResponse createSnapshotResponseFirst = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> ) . get ( ) ; assertThat ( createSnapshotResponseFirst . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponseFirst . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponseFirst . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; { SnapshotStatus snapshotStatus = client . admin ( ) . cluster ( ) . prepareSnapshotStatus ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) ; List < SnapshotIndexShardStatus > shards = snapshotStatus . getShards ( ) ; for ( SnapshotIndexShardStatus status : shards ) { assertThat ( status . getStats ( ) . getProcessedFiles ( ) , greaterThan ( <int> ) ) ; } } if ( frequently ( ) ) { logger . info ( <str> ) ; disableAllocation ( <str> ) ; backwardsCluster ( ) . allowOnAllNodes ( <str> ) ; logClusterState ( ) ; boolean upgraded ; do { logClusterState ( ) ; SearchResponse countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; upgraded = backwardsCluster ( ) . upgradeOneNode ( ) ; ensureYellow ( ) ; countResponse = client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) ; assertHitCount ( countResponse , numDocs ) ; } while ( upgraded ) ; enableAllocation ( <str> ) ; } if ( cluster ( ) . numDataNodes ( ) > <int> & & randomBoolean ( ) ) { logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) . get ( ) ; } logger . debug ( <str> + Files . exists ( tempDir . resolve ( <str> ) ) + <str> + Arrays . toString ( FileSystemUtils . files ( tempDir . resolve ( <str> ) ) ) ) ; CreateSnapshotResponse createSnapshotResponseSecond = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> ) . get ( ) ; assertThat ( createSnapshotResponseSecond . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponseSecond . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponseSecond . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; { SnapshotStatus snapshotStatus = client . admin ( ) . cluster ( ) . prepareSnapshotStatus ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) ; List < SnapshotIndexShardStatus > shards = snapshotStatus . getShards ( ) ; for ( SnapshotIndexShardStatus status : shards ) { assertThat ( status . getStats ( ) . getProcessedFiles ( ) , equalTo ( <int> ) ) ; } } client ( ) . prepareDelete ( <str> , <str> , <str> ) . get ( ) ; CreateSnapshotResponse createSnapshotResponseThird = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> ) . get ( ) ; assertThat ( createSnapshotResponseThird . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponseThird . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponseThird . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; { SnapshotStatus snapshotStatus = client . admin ( ) . cluster ( ) . prepareSnapshotStatus ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) ; List < SnapshotIndexShardStatus > shards = snapshotStatus . getShards ( ) ; for ( SnapshotIndexShardStatus status : shards ) { assertThat ( status . getStats ( ) . getProcessedFiles ( ) , equalTo ( <int> ) ) ; } } } } 
