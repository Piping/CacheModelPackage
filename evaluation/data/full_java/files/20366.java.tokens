package io . netty . channel . epoll ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . unix . DomainSocketAddress ; import io . netty . channel . unix . DomainSocketChannel ; import io . netty . channel . unix . FileDescriptor ; import io . netty . channel . unix . Socket ; import io . netty . util . internal . OneTimeTask ; import java . net . SocketAddress ; import static io . netty . channel . unix . Socket . newSocketDomain ; public final class EpollDomainSocketChannel extends AbstractEpollStreamChannel implements DomainSocketChannel { private final EpollDomainSocketChannelConfig config = new EpollDomainSocketChannelConfig ( this ) ; private volatile DomainSocketAddress local ; private volatile DomainSocketAddress remote ; public EpollDomainSocketChannel ( ) { super ( newSocketDomain ( ) , false ) ; } @Deprecated public EpollDomainSocketChannel ( Channel parent , FileDescriptor fd ) { super ( parent , new Socket ( fd . intValue ( ) ) ) ; } @Deprecated public EpollDomainSocketChannel ( FileDescriptor fd ) { super ( fd ) ; } public EpollDomainSocketChannel ( Channel parent , Socket fd ) { super ( parent , fd ) ; } public EpollDomainSocketChannel ( Socket fd , boolean active ) { super ( fd , active ) ; } @Override protected AbstractEpollUnsafe newUnsafe ( ) { return new EpollDomainUnsafe ( ) ; } @Override protected DomainSocketAddress localAddress0 ( ) { return local ; } @Override protected DomainSocketAddress remoteAddress0 ( ) { return remote ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { fd ( ) . bind ( localAddress ) ; local = ( DomainSocketAddress ) localAddress ; } @Override public EpollDomainSocketChannelConfig config ( ) { return config ; } @Override protected boolean doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { if ( super . doConnect ( remoteAddress , localAddress ) ) { local = ( DomainSocketAddress ) localAddress ; remote = ( DomainSocketAddress ) remoteAddress ; return true ; } return false ; } @Override public DomainSocketAddress remoteAddress ( ) { return ( DomainSocketAddress ) super . remoteAddress ( ) ; } @Override public DomainSocketAddress localAddress ( ) { return ( DomainSocketAddress ) super . localAddress ( ) ; } @Override protected boolean doWriteSingle ( ChannelOutboundBuffer in , int writeSpinCount ) throws Exception { Object msg = in . current ( ) ; if ( msg instanceof FileDescriptor & & Native . sendFd ( fd ( ) . intValue ( ) , ( ( FileDescriptor ) msg ) . intValue ( ) ) > <int> ) { in . remove ( ) ; return true ; } return super . doWriteSingle ( in , writeSpinCount ) ; } @Override protected Object filterOutboundMessage ( Object msg ) { if ( msg instanceof FileDescriptor ) { return msg ; } return super . filterOutboundMessage ( msg ) ; } private final class EpollDomainUnsafe extends EpollStreamUnsafe { @Override void epollInReady ( ) { switch ( config ( ) . getReadMode ( ) ) { case BYTES : super . epollInReady ( ) ; break ; case FILE_DESCRIPTORS : epollInReadFd ( ) ; break ; default : throw new Error ( ) ; } } private void epollInReadFd ( ) { if ( fd ( ) . isInputShutdown ( ) ) { return ; } boolean edgeTriggered = isFlagSet ( Native . EPOLLET ) ; final ChannelConfig config = config ( ) ; if ( ! readPending & & ! edgeTriggered & & ! config . isAutoRead ( ) ) { clearEpollIn0 ( ) ; return ; } final ChannelPipeline pipeline = pipeline ( ) ; final EpollRecvByteAllocatorHandle allocHandle = recvBufAllocHandle ( ) ; allocHandle . reset ( config ) ; try { do { int socketFd = Native . recvFd ( fd ( ) . intValue ( ) ) ; if ( socketFd = = <int> ) { break ; } if ( socketFd = = - <int> ) { close ( voidPromise ( ) ) ; return ; } readPending = false ; allocHandle . incMessagesRead ( <int> ) ; pipeline . fireChannelRead ( new FileDescriptor ( socketFd ) ) ; } while ( allocHandle . continueReading ( ) ) ; allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; } catch ( Throwable t ) { allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; pipeline . fireExceptionCaught ( t ) ; checkResetEpollIn ( edgeTriggered ) ; } finally { if ( ! readPending & & ! config . isAutoRead ( ) ) { clearEpollIn0 ( ) ; } } } } } 
