package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . Queue ; public abstract class TreeTraverser < T > { public abstract Iterable < T > children ( T root ) ; public final FluentIterable < T > preOrderTraversal ( final T root ) { checkNotNull ( root ) ; return new FluentIterable < T > ( ) { @Override public UnmodifiableIterator < T > iterator ( ) { return preOrderIterator ( root ) ; } } ; } UnmodifiableIterator < T > preOrderIterator ( T root ) { return new PreOrderIterator ( root ) ; } private final class PreOrderIterator extends UnmodifiableIterator < T > { private final LinkedList < Iterator < T > > stack ; PreOrderIterator ( T root ) { this . stack = Lists . newLinkedList ( ) ; stack . addLast ( Iterators . singletonIterator ( checkNotNull ( root ) ) ) ; } @Override public boolean hasNext ( ) { return ! stack . isEmpty ( ) ; } @Override public T next ( ) { Iterator < T > itr = stack . getLast ( ) ; T result = checkNotNull ( itr . next ( ) ) ; if ( ! itr . hasNext ( ) ) { stack . removeLast ( ) ; } Iterator < T > childItr = children ( result ) . iterator ( ) ; if ( childItr . hasNext ( ) ) { stack . addLast ( childItr ) ; } return result ; } } public final FluentIterable < T > postOrderTraversal ( final T root ) { checkNotNull ( root ) ; return new FluentIterable < T > ( ) { @Override public UnmodifiableIterator < T > iterator ( ) { return postOrderIterator ( root ) ; } } ; } UnmodifiableIterator < T > postOrderIterator ( T root ) { return new PostOrderIterator ( root ) ; } private static final class PostOrderNode < T > { final T root ; final Iterator < T > childIterator ; PostOrderNode ( T root , Iterator < T > childIterator ) { this . root = checkNotNull ( root ) ; this . childIterator = checkNotNull ( childIterator ) ; } } private final class PostOrderIterator extends AbstractIterator < T > { private final LinkedList < PostOrderNode < T > > stack ; PostOrderIterator ( T root ) { this . stack = Lists . newLinkedList ( ) ; stack . addLast ( expand ( root ) ) ; } @Override protected T computeNext ( ) { while ( ! stack . isEmpty ( ) ) { PostOrderNode < T > top = stack . getLast ( ) ; if ( top . childIterator . hasNext ( ) ) { T child = top . childIterator . next ( ) ; stack . addLast ( expand ( child ) ) ; } else { stack . removeLast ( ) ; return top . root ; } } return endOfData ( ) ; } private PostOrderNode < T > expand ( T t ) { return new PostOrderNode < T > ( t , children ( t ) . iterator ( ) ) ; } } public final FluentIterable < T > breadthFirstTraversal ( final T root ) { checkNotNull ( root ) ; return new FluentIterable < T > ( ) { @Override public UnmodifiableIterator < T > iterator ( ) { return new BreadthFirstIterator ( root ) ; } } ; } private final class BreadthFirstIterator extends UnmodifiableIterator < T > implements PeekingIterator < T > { private final Queue < T > queue ; BreadthFirstIterator ( T root ) { this . queue = Lists . newLinkedList ( ) ; queue . add ( checkNotNull ( root ) ) ; } @Override public boolean hasNext ( ) { return ! queue . isEmpty ( ) ; } @Override public T peek ( ) { return queue . element ( ) ; } @Override public T next ( ) { T result = queue . remove ( ) ; for ( T child : children ( result ) ) { queue . add ( checkNotNull ( child ) ) ; } return result ; } } } 
