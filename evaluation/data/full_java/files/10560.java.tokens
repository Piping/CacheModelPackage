package com . google . common . math ; import com . google . common . annotations . GwtCompatible ; import junit . framework . TestCase ; import java . math . BigInteger ; @GwtCompatible public class MathPreconditionsTest extends TestCase { public void testCheckPositive_zeroInt ( ) { try { MathPreconditions . checkPositive ( <str> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckPositive_maxInt ( ) { MathPreconditions . checkPositive ( <str> , Integer . MAX_VALUE ) ; } public void testCheckPositive_minInt ( ) { try { MathPreconditions . checkPositive ( <str> , Integer . MIN_VALUE ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckPositive_positiveInt ( ) { MathPreconditions . checkPositive ( <str> , <int> ) ; } public void testCheckPositive_negativeInt ( ) { try { MathPreconditions . checkPositive ( <str> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckPositive_zeroLong ( ) { try { MathPreconditions . checkPositive ( <str> , <int> L ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckPositive_maxLong ( ) { MathPreconditions . checkPositive ( <str> , Long . MAX_VALUE ) ; } public void testCheckPositive_minLong ( ) { try { MathPreconditions . checkPositive ( <str> , Long . MIN_VALUE ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckPositive_positiveLong ( ) { MathPreconditions . checkPositive ( <str> , <int> ) ; } public void testCheckPositive_negativeLong ( ) { try { MathPreconditions . checkPositive ( <str> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckPositive_zeroBigInteger ( ) { try { MathPreconditions . checkPositive ( <str> , BigInteger . ZERO ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckPositive_postiveBigInteger ( ) { MathPreconditions . checkPositive ( <str> , BigInteger . ONE ) ; } public void testCheckPositive_negativeBigInteger ( ) { try { MathPreconditions . checkPositive ( <str> , BigInteger . ZERO . negate ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_zeroInt ( ) { MathPreconditions . checkNonNegative ( <str> , <int> ) ; } public void testCheckNonNegative_maxInt ( ) { MathPreconditions . checkNonNegative ( <str> , Integer . MAX_VALUE ) ; } public void testCheckNonNegative_minInt ( ) { try { MathPreconditions . checkNonNegative ( <str> , Integer . MIN_VALUE ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_positiveInt ( ) { MathPreconditions . checkNonNegative ( <str> , <int> ) ; } public void testCheckNonNegative_negativeInt ( ) { try { MathPreconditions . checkNonNegative ( <str> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_zeroLong ( ) { MathPreconditions . checkNonNegative ( <str> , <int> L ) ; } public void testCheckNonNegative_maxLong ( ) { MathPreconditions . checkNonNegative ( <str> , Long . MAX_VALUE ) ; } public void testCheckNonNegative_minLong ( ) { try { MathPreconditions . checkNonNegative ( <str> , Long . MIN_VALUE ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_positiveLong ( ) { MathPreconditions . checkNonNegative ( <str> , <int> ) ; } public void testCheckNonNegative_negativeLong ( ) { try { MathPreconditions . checkNonNegative ( <str> , - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_zeroBigInteger ( ) { MathPreconditions . checkNonNegative ( <str> , BigInteger . ZERO ) ; } public void testCheckNonNegative_positiveBigInteger ( ) { MathPreconditions . checkNonNegative ( <str> , BigInteger . ONE ) ; } public void testCheckNonNegative_negativeBigInteger ( ) { try { MathPreconditions . checkNonNegative ( <str> , BigInteger . ONE . negate ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_zeroFloat ( ) { MathPreconditions . checkNonNegative ( <str> , <float> ) ; } public void testCheckNonNegative_maxFloat ( ) { MathPreconditions . checkNonNegative ( <str> , Float . MAX_VALUE ) ; } public void testCheckNonNegative_minFloat ( ) { MathPreconditions . checkNonNegative ( <str> , Float . MIN_VALUE ) ; } public void testCheckNonNegative_positiveFloat ( ) { MathPreconditions . checkNonNegative ( <str> , <float> ) ; } public void testCheckNonNegative_negativeFloat ( ) { try { MathPreconditions . checkNonNegative ( <str> , - <float> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_nanFloat ( ) { try { MathPreconditions . checkNonNegative ( <str> , Float . NaN ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_zeroDouble ( ) { MathPreconditions . checkNonNegative ( <str> , <float> ) ; } public void testCheckNonNegative_maxDouble ( ) { MathPreconditions . checkNonNegative ( <str> , Double . MAX_VALUE ) ; } public void testCheckNonNegative_minDouble ( ) { MathPreconditions . checkNonNegative ( <str> , Double . MIN_VALUE ) ; } public void testCheckNonNegative_positiveDouble ( ) { MathPreconditions . checkNonNegative ( <str> , <float> ) ; } public void testCheckNonNegative_negativeDouble ( ) { try { MathPreconditions . checkNonNegative ( <str> , - <float> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckNonNegative_nanDouble ( ) { try { MathPreconditions . checkNonNegative ( <str> , Double . NaN ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCheckRoundingUnnnecessary_success ( ) { MathPreconditions . checkRoundingUnnecessary ( true ) ; } public void testCheckRoundingUnnecessary_failure ( ) { try { MathPreconditions . checkRoundingUnnecessary ( false ) ; fail ( ) ; } catch ( ArithmeticException expected ) { } } public void testCheckInRange_success ( ) { MathPreconditions . checkInRange ( true ) ; } public void testCheckInRange_failure ( ) { try { MathPreconditions . checkInRange ( false ) ; fail ( ) ; } catch ( ArithmeticException expected ) { } } public void testCheckNoOverflow_success ( ) { MathPreconditions . checkNoOverflow ( true ) ; } public void testCheckNoOverflow_failure ( ) { try { MathPreconditions . checkNoOverflow ( false ) ; fail ( ) ; } catch ( ArithmeticException expected ) { } } } 
