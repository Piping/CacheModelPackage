package com . nostra13 . universalimageloader . cache . memory . impl ; import android . graphics . Bitmap ; import com . nostra13 . universalimageloader . cache . memory . MemoryCache ; import java . util . Collection ; import java . util . HashSet ; import java . util . LinkedHashMap ; import java . util . Map ; public class LruMemoryCache implements MemoryCache { private final LinkedHashMap < String , Bitmap > map ; private final int maxSize ; private int size ; public LruMemoryCache ( int maxSize ) { if ( maxSize < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maxSize = maxSize ; this . map = new LinkedHashMap < String , Bitmap > ( <int> , <float> , true ) ; } @Override public final Bitmap get ( String key ) { if ( key = = null ) { throw new NullPointerException ( <str> ) ; } synchronized ( this ) { return map . get ( key ) ; } } @Override public final boolean put ( String key , Bitmap value ) { if ( key = = null | | value = = null ) { throw new NullPointerException ( <str> ) ; } synchronized ( this ) { size + = sizeOf ( key , value ) ; Bitmap previous = map . put ( key , value ) ; if ( previous ! = null ) { size - = sizeOf ( key , previous ) ; } } trimToSize ( maxSize ) ; return true ; } private void trimToSize ( int maxSize ) { while ( true ) { String key ; Bitmap value ; synchronized ( this ) { if ( size < <int> | | ( map . isEmpty ( ) & & size ! = <int> ) ) { throw new IllegalStateException ( getClass ( ) . getName ( ) + <str> ) ; } if ( size < = maxSize | | map . isEmpty ( ) ) { break ; } Map . Entry < String , Bitmap > toEvict = map . entrySet ( ) . iterator ( ) . next ( ) ; if ( toEvict = = null ) { break ; } key = toEvict . getKey ( ) ; value = toEvict . getValue ( ) ; map . remove ( key ) ; size - = sizeOf ( key , value ) ; } } } @Override public final Bitmap remove ( String key ) { if ( key = = null ) { throw new NullPointerException ( <str> ) ; } synchronized ( this ) { Bitmap previous = map . remove ( key ) ; if ( previous ! = null ) { size - = sizeOf ( key , previous ) ; } return previous ; } } @Override public Collection < String > keys ( ) { synchronized ( this ) { return new HashSet < String > ( map . keySet ( ) ) ; } } @Override public void clear ( ) { trimToSize ( - <int> ) ; } private int sizeOf ( String key , Bitmap value ) { return value . getRowBytes ( ) * value . getHeight ( ) ; } @Override public synchronized final String toString ( ) { return String . format ( <str> , maxSize ) ; } } 
