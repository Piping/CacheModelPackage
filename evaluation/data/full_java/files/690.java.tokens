package org . apache . cassandra . io . sstable ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . util . * ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . collect . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . DebuggableScheduledThreadPoolExecutor ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . db . lifecycle . View ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . Pair ; import org . apache . cassandra . utils . WrappedRunnable ; public class IndexSummaryManager implements IndexSummaryManagerMBean { private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryManager . class ) ; public static final String MBEAN_NAME = <str> ; public static final IndexSummaryManager instance ; private int resizeIntervalInMinutes = <int> ; private long memoryPoolBytes ; private final DebuggableScheduledThreadPoolExecutor executor ; private ScheduledFuture future ; static { instance = new IndexSummaryManager ( ) ; MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . registerMBean ( instance , new ObjectName ( MBEAN_NAME ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } private IndexSummaryManager ( ) { executor = new DebuggableScheduledThreadPoolExecutor ( <int> , <str> , Thread . MIN_PRIORITY ) ; long indexSummarySizeInMB = DatabaseDescriptor . getIndexSummaryCapacityInMB ( ) ; int interval = DatabaseDescriptor . getIndexSummaryResizeIntervalInMinutes ( ) ; logger . info ( <str> , indexSummarySizeInMB , interval ) ; setMemoryPoolCapacityInMB ( DatabaseDescriptor . getIndexSummaryCapacityInMB ( ) ) ; setResizeIntervalInMinutes ( DatabaseDescriptor . getIndexSummaryResizeIntervalInMinutes ( ) ) ; } public int getResizeIntervalInMinutes ( ) { return resizeIntervalInMinutes ; } public void setResizeIntervalInMinutes ( int resizeIntervalInMinutes ) { int oldInterval = this . resizeIntervalInMinutes ; this . resizeIntervalInMinutes = resizeIntervalInMinutes ; long initialDelay ; if ( future ! = null ) { initialDelay = oldInterval < <int> ? resizeIntervalInMinutes : Math . max ( <int> , resizeIntervalInMinutes - ( oldInterval - future . getDelay ( TimeUnit . MINUTES ) ) ) ; future . cancel ( false ) ; } else { initialDelay = resizeIntervalInMinutes ; } if ( this . resizeIntervalInMinutes < <int> ) { future = null ; return ; } future = executor . scheduleWithFixedDelay ( new WrappedRunnable ( ) { protected void runMayThrow ( ) throws Exception { redistributeSummaries ( ) ; } } , initialDelay , resizeIntervalInMinutes , TimeUnit . MINUTES ) ; } @VisibleForTesting Long getTimeToNextResize ( TimeUnit timeUnit ) { if ( future = = null ) return null ; return future . getDelay ( timeUnit ) ; } public long getMemoryPoolCapacityInMB ( ) { return memoryPoolBytes / <int> / <int> ; } public Map < String , Integer > getIndexIntervals ( ) { List < SSTableReader > sstables = getAllSSTables ( ) ; Map < String , Integer > intervals = new HashMap < > ( sstables . size ( ) ) ; for ( SSTableReader sstable : sstables ) intervals . put ( sstable . getFilename ( ) , ( int ) Math . round ( sstable . getEffectiveIndexInterval ( ) ) ) ; return intervals ; } public double getAverageIndexInterval ( ) { List < SSTableReader > sstables = getAllSSTables ( ) ; double total = <float> ; for ( SSTableReader sstable : sstables ) total + = sstable . getEffectiveIndexInterval ( ) ; return total / sstables . size ( ) ; } public void setMemoryPoolCapacityInMB ( long memoryPoolCapacityInMB ) { this . memoryPoolBytes = memoryPoolCapacityInMB * <int> * <int> ; } public double getMemoryPoolSizeInMB ( ) { long total = <int> ; for ( SSTableReader sstable : getAllSSTables ( ) ) total + = sstable . getIndexSummaryOffHeapSize ( ) ; return total / <float> / <float> ; } private List < SSTableReader > getAllSSTables ( ) { List < SSTableReader > result = new ArrayList < > ( ) ; for ( Keyspace ks : Keyspace . all ( ) ) { for ( ColumnFamilyStore cfStore : ks . getColumnFamilyStores ( ) ) result . addAll ( cfStore . getLiveSSTables ( ) ) ; } return result ; } @SuppressWarnings ( <str> ) private Pair < List < SSTableReader > , Map < UUID , LifecycleTransaction > > getCompactingAndNonCompactingSSTables ( ) { List < SSTableReader > allCompacting = new ArrayList < > ( ) ; Map < UUID , LifecycleTransaction > allNonCompacting = new HashMap < > ( ) ; for ( Keyspace ks : Keyspace . all ( ) ) { for ( ColumnFamilyStore cfStore : ks . getColumnFamilyStores ( ) ) { Set < SSTableReader > nonCompacting , allSSTables ; LifecycleTransaction txn = null ; do { View view = cfStore . getTracker ( ) . getView ( ) ; allSSTables = ImmutableSet . copyOf ( view . sstables ( SSTableSet . CANONICAL ) ) ; nonCompacting = ImmutableSet . copyOf ( view . getUncompacting ( allSSTables ) ) ; } while ( null = = ( txn = cfStore . getTracker ( ) . tryModify ( nonCompacting , OperationType . UNKNOWN ) ) ) ; allNonCompacting . put ( cfStore . metadata . cfId , txn ) ; allCompacting . addAll ( Sets . difference ( allSSTables , nonCompacting ) ) ; } } return Pair . create ( allCompacting , allNonCompacting ) ; } public void redistributeSummaries ( ) throws IOException { Pair < List < SSTableReader > , Map < UUID , LifecycleTransaction > > compactingAndNonCompacting = getCompactingAndNonCompactingSSTables ( ) ; try { redistributeSummaries ( compactingAndNonCompacting . left , compactingAndNonCompacting . right , this . memoryPoolBytes ) ; } finally { for ( LifecycleTransaction modifier : compactingAndNonCompacting . right . values ( ) ) modifier . close ( ) ; } } @VisibleForTesting public static List < SSTableReader > redistributeSummaries ( List < SSTableReader > compacting , Map < UUID , LifecycleTransaction > transactions , long memoryPoolBytes ) throws IOException { return CompactionManager . instance . runIndexSummaryRedistribution ( new IndexSummaryRedistribution ( compacting , transactions , memoryPoolBytes ) ) ; } } 
