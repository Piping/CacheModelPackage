package org . elasticsearch . index . query ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . lucene . BytesRefs ; import org . elasticsearch . index . mapper . MappedFieldType ; import java . io . IOException ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . Matchers . is ; public class TermQueryBuilderTests extends AbstractTermQueryTestCase < TermQueryBuilder > { @Override protected TermQueryBuilder createQueryBuilder ( String fieldName , Object value ) { return new TermQueryBuilder ( fieldName , value ) ; } @Override protected void doAssertLuceneQuery ( TermQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { assertThat ( query , instanceOf ( TermQuery . class ) ) ; TermQuery termQuery = ( TermQuery ) query ; assertThat ( termQuery . getTerm ( ) . field ( ) , equalTo ( queryBuilder . fieldName ( ) ) ) ; MappedFieldType mapper = context . fieldMapper ( queryBuilder . fieldName ( ) ) ; if ( mapper ! = null ) { BytesRef bytesRef = mapper . indexedValueForSearch ( queryBuilder . value ( ) ) ; assertThat ( termQuery . getTerm ( ) . bytes ( ) , equalTo ( bytesRef ) ) ; } else { assertThat ( termQuery . getTerm ( ) . bytes ( ) , equalTo ( BytesRefs . toBytesRef ( queryBuilder . value ( ) ) ) ) ; } } public void testTermArray ( ) throws IOException { String queryAsString = <str> + <str> + <str> + <str> + <str> ; try { parseQuery ( queryAsString ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; TermQueryBuilder parsed = ( TermQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <str> , parsed . value ( ) ) ; } } 
