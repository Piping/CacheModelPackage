package org . gradle . api . internal . tasks . testing . junit . result ; import com . esotericsoftware . kryo . io . Input ; import com . esotericsoftware . kryo . io . Output ; import com . google . common . collect . ImmutableMap ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . tasks . testing . TestOutputEvent ; import org . gradle . internal . io . RandomAccessFileInputStream ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . serialize . kryo . KryoBackedDecoder ; import org . gradle . internal . serialize . kryo . KryoBackedEncoder ; import java . io . * ; import java . nio . charset . Charset ; import java . util . LinkedHashMap ; import java . util . Map ; public class TestOutputStore { private final File resultsDir ; private final Charset messageStorageCharset ; public TestOutputStore ( File resultsDir ) { this . resultsDir = resultsDir ; this . messageStorageCharset = Charset . forName ( <str> ) ; } File getOutputsFile ( ) { return new File ( resultsDir , <str> ) ; } File getIndexFile ( ) { return new File ( resultsDir , getOutputsFile ( ) . getName ( ) + <str> ) ; } private static class Region { long start ; long stop ; private Region ( ) { start = - <int> ; stop = - <int> ; } private Region ( long start , long stop ) { this . start = start ; this . stop = stop ; } } private static class TestCaseRegion { Region stdOutRegion = new Region ( ) ; Region stdErrRegion = new Region ( ) ; } public class Writer implements Closeable { private final KryoBackedEncoder output ; private final Map < Long , Map < Long , TestCaseRegion > > index = new LinkedHashMap < Long , Map < Long , TestCaseRegion > > ( ) ; public Writer ( ) { try { output = new KryoBackedEncoder ( new FileOutputStream ( getOutputsFile ( ) ) ) ; } catch ( FileNotFoundException e ) { throw new UncheckedIOException ( e ) ; } } public void close ( ) { output . close ( ) ; writeIndex ( ) ; } public void onOutput ( long classId , TestOutputEvent outputEvent ) { onOutput ( classId , <int> , outputEvent ) ; } public void onOutput ( long classId , long testId , TestOutputEvent outputEvent ) { boolean stdout = outputEvent . getDestination ( ) = = TestOutputEvent . Destination . StdOut ; mark ( classId , testId , stdout ) ; output . writeBoolean ( stdout ) ; output . writeSmallLong ( classId ) ; output . writeSmallLong ( testId ) ; byte [ ] bytes ; try { bytes = outputEvent . getMessage ( ) . getBytes ( messageStorageCharset . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } output . writeSmallInt ( bytes . length ) ; output . writeBytes ( bytes , <int> , bytes . length ) ; } private void mark ( long classId , long testId , boolean isStdout ) { if ( ! index . containsKey ( classId ) ) { index . put ( classId , new LinkedHashMap < Long , TestCaseRegion > ( ) ) ; } Map < Long , TestCaseRegion > testCaseRegions = index . get ( classId ) ; if ( ! testCaseRegions . containsKey ( testId ) ) { TestCaseRegion region = new TestCaseRegion ( ) ; testCaseRegions . put ( testId , region ) ; } TestCaseRegion region = testCaseRegions . get ( testId ) ; Region streamRegion = isStdout ? region . stdOutRegion : region . stdErrRegion ; int total = output . getWritePosition ( ) ; if ( streamRegion . start < <int> ) { streamRegion . start = total ; } streamRegion . stop = total ; } private void writeIndex ( ) { Output indexOutput ; try { indexOutput = new Output ( new FileOutputStream ( getIndexFile ( ) ) ) ; } catch ( FileNotFoundException e ) { throw new UncheckedIOException ( e ) ; } try { indexOutput . writeInt ( index . size ( ) , true ) ; for ( Map . Entry < Long , Map < Long , TestCaseRegion > > classEntry : index . entrySet ( ) ) { Long classId = classEntry . getKey ( ) ; Map < Long , TestCaseRegion > regions = classEntry . getValue ( ) ; indexOutput . writeLong ( classId , true ) ; indexOutput . writeInt ( regions . size ( ) , true ) ; for ( Map . Entry < Long , TestCaseRegion > testCaseEntry : regions . entrySet ( ) ) { long id = testCaseEntry . getKey ( ) ; TestCaseRegion region = testCaseEntry . getValue ( ) ; indexOutput . writeLong ( id , true ) ; indexOutput . writeLong ( region . stdOutRegion . start ) ; indexOutput . writeLong ( region . stdOutRegion . stop ) ; indexOutput . writeLong ( region . stdErrRegion . start ) ; indexOutput . writeLong ( region . stdErrRegion . stop ) ; } } } finally { indexOutput . close ( ) ; } } } public Writer writer ( ) { return new Writer ( ) ; } private static class Index { final ImmutableMap < Long , Index > children ; final Region stdOut ; final Region stdErr ; private Index ( Region stdOut , Region stdErr ) { this . children = ImmutableMap . of ( ) ; this . stdOut = stdOut ; this . stdErr = stdErr ; } private Index ( ImmutableMap < Long , Index > children , Region stdOut , Region stdErr ) { this . children = children ; this . stdOut = stdOut ; this . stdErr = stdErr ; } } private static class IndexBuilder { final Region stdOut = new Region ( ) ; final Region stdErr = new Region ( ) ; private final ImmutableMap . Builder < Long , Index > children = ImmutableMap . builder ( ) ; void add ( long key , Index index ) { if ( stdOut . start < <int> ) { stdOut . start = index . stdOut . start ; } if ( stdErr . start < <int> ) { stdErr . start = index . stdErr . start ; } if ( index . stdOut . stop > stdOut . stop ) { stdOut . stop = index . stdOut . stop ; } if ( index . stdErr . stop > stdErr . stop ) { stdErr . stop = index . stdErr . stop ; } children . put ( key , index ) ; } Index build ( ) { return new Index ( children . build ( ) , stdOut , stdErr ) ; } } public class Reader implements Closeable { private final Index index ; private final RandomAccessFile dataFile ; public Reader ( ) { File indexFile = getIndexFile ( ) ; File outputsFile = getOutputsFile ( ) ; if ( outputsFile . exists ( ) ) { if ( ! indexFile . exists ( ) ) { throw new IllegalStateException ( String . format ( <str> , outputsFile , indexFile ) ) ; } Input input ; try { input = new Input ( new FileInputStream ( indexFile ) ) ; } catch ( FileNotFoundException e ) { throw new UncheckedIOException ( e ) ; } IndexBuilder rootBuilder = null ; try { int numClasses = input . readInt ( true ) ; rootBuilder = new IndexBuilder ( ) ; for ( int classCounter = <int> ; classCounter < numClasses ; + + classCounter ) { long classId = input . readLong ( true ) ; IndexBuilder classBuilder = new IndexBuilder ( ) ; int numEntries = input . readInt ( true ) ; for ( int entryCounter = <int> ; entryCounter < numEntries ; + + entryCounter ) { long testId = input . readLong ( true ) ; Region stdOut = new Region ( input . readLong ( ) , input . readLong ( ) ) ; Region stdErr = new Region ( input . readLong ( ) , input . readLong ( ) ) ; classBuilder . add ( testId , new Index ( stdOut , stdErr ) ) ; } rootBuilder . add ( classId , classBuilder . build ( ) ) ; } } finally { input . close ( ) ; } index = rootBuilder . build ( ) ; try { dataFile = new RandomAccessFile ( getOutputsFile ( ) , <str> ) ; } catch ( FileNotFoundException e ) { throw new UncheckedIOException ( e ) ; } } else { if ( indexFile . exists ( ) ) { throw new IllegalStateException ( String . format ( <str> , outputsFile , indexFile ) ) ; } index = null ; dataFile = null ; } } public void close ( ) throws IOException { if ( dataFile ! = null ) { dataFile . close ( ) ; } } public boolean hasOutput ( long classId , TestOutputEvent . Destination destination ) { if ( dataFile = = null ) { return false ; } Index classIndex = index . children . get ( classId ) ; if ( classIndex = = null ) { return false ; } else { Region region = destination = = TestOutputEvent . Destination . StdOut ? classIndex . stdOut : classIndex . stdErr ; return region . start > = <int> ; } } public void writeAllOutput ( long classId , TestOutputEvent . Destination destination , java . io . Writer writer ) { doRead ( classId , <int> , true , destination , writer ) ; } public void writeNonTestOutput ( long classId , TestOutputEvent . Destination destination , java . io . Writer writer ) { doRead ( classId , <int> , false , destination , writer ) ; } public void writeTestOutput ( long classId , long testId , TestOutputEvent . Destination destination , java . io . Writer writer ) { doRead ( classId , testId , false , destination , writer ) ; } private void doRead ( long classId , long testId , boolean allClassOutput , TestOutputEvent . Destination destination , java . io . Writer writer ) { if ( dataFile = = null ) { return ; } Index targetIndex = index . children . get ( classId ) ; if ( targetIndex ! = null & & testId ! = <int> ) { targetIndex = targetIndex . children . get ( testId ) ; } if ( targetIndex = = null ) { return ; } boolean stdout = destination = = TestOutputEvent . Destination . StdOut ; Region region = stdout ? targetIndex . stdOut : targetIndex . stdErr ; if ( region . start < <int> ) { return ; } boolean ignoreClassLevel = ! allClassOutput & & testId ! = <int> ; boolean ignoreTestLevel = ! allClassOutput & & testId = = <int> ; try { dataFile . seek ( region . start ) ; long maxPos = region . stop - region . start ; KryoBackedDecoder decoder = new KryoBackedDecoder ( new RandomAccessFileInputStream ( dataFile ) ) ; while ( decoder . getReadPosition ( ) < = maxPos ) { boolean readStdout = decoder . readBoolean ( ) ; long readClassId = decoder . readSmallLong ( ) ; long readTestId = decoder . readSmallLong ( ) ; int readLength = decoder . readSmallInt ( ) ; boolean isClassLevel = readTestId = = <int> ; if ( stdout ! = readStdout | | classId ! = readClassId ) { decoder . skipBytes ( readLength ) ; continue ; } if ( ignoreClassLevel & & isClassLevel ) { decoder . skipBytes ( readLength ) ; continue ; } if ( ignoreTestLevel & & ! isClassLevel ) { decoder . skipBytes ( readLength ) ; continue ; } if ( testId = = <int> | | testId = = readTestId ) { byte [ ] stringBytes = new byte [ readLength ] ; decoder . readBytes ( stringBytes ) ; String message ; try { message = new String ( stringBytes , messageStorageCharset . name ( ) ) ; } catch ( UnsupportedEncodingException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } writer . write ( message ) ; } else { decoder . skipBytes ( readLength ) ; } } } catch ( IOException e1 ) { throw new UncheckedIOException ( e1 ) ; } } } public Reader reader ( ) { return new Reader ( ) ; } } 
