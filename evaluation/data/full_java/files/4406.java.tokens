package org . eclipse . debug . internal . ui . viewers . model ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . eclipse . debug . internal . core . commands . Request ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . AsynchronousSchedulingRuleFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementContentProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . swt . widgets . Display ; public abstract class ViewerUpdateMonitor extends Request implements IViewerUpdate { private TreeModelContentProvider fContentProvider ; private TreePath fElementPath ; private Object fElement ; private IElementContentProvider fElementContentProvider ; private boolean fDone = false ; private boolean fStarted = false ; private Object fViewerInput = null ; private boolean fIsDelegated = false ; private IPresentationContext fContext ; public ViewerUpdateMonitor ( TreeModelContentProvider contentProvider , Object viewerInput , TreePath elementPath , Object element , IElementContentProvider elementContentProvider , IPresentationContext context ) { fContext = context ; if ( viewerInput = = null ) { DebugUIPlugin . log ( new NullPointerException ( <str> ) ) ; } fViewerInput = viewerInput ; fElementContentProvider = elementContentProvider ; fContentProvider = contentProvider ; fElement = element ; fElementPath = elementPath ; } protected ISchedulingRule getUpdateSchedulingRule ( ) { return AsynchronousSchedulingRuleFactory . getDefault ( ) . newSerialPerObjectRule ( getContentProvider ( ) ) ; } protected TreeModelContentProvider getContentProvider ( ) { return fContentProvider ; } protected IElementContentProvider getElementContentProvider ( ) { return fElementContentProvider ; } @Override public final void done ( ) { synchronized ( this ) { if ( isDone ( ) ) { return ; } fDone = true ; } scheduleViewerUpdate ( ) ; } protected synchronized boolean isDone ( ) { return fDone ; } protected void scheduleViewerUpdate ( ) { getContentProvider ( ) . scheduleViewerUpdate ( this ) ; } protected abstract void performUpdate ( ) ; @Override public IPresentationContext getPresentationContext ( ) { return fContext ; } @Override public Object getElement ( ) { return fElement ; } @Override public TreePath getElementPath ( ) { return fElementPath ; } abstract boolean coalesce ( ViewerUpdateMonitor update ) ; abstract boolean containsUpdate ( TreePath path ) ; protected void start ( ) { synchronized ( this ) { if ( fStarted ) { return ; } fStarted = true ; } getContentProvider ( ) . updateStarted ( this ) ; if ( ! isCanceled ( ) ) { startRequest ( ) ; } else { done ( ) ; } } @Override public Object getViewerInput ( ) { return fViewerInput ; } abstract void startRequest ( ) ; abstract int getPriority ( ) ; abstract TreePath getSchedulingPath ( ) ; public void setDelegated ( boolean delegated ) { fIsDelegated = delegated ; } public boolean isDelegated ( ) { return fIsDelegated ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof ViewerUpdateMonitor ) { return doEquals ( ( ViewerUpdateMonitor ) obj ) ; } return false ; } @Override public int hashCode ( ) { return doHashCode ( ) ; } abstract protected boolean doEquals ( ViewerUpdateMonitor update ) ; abstract protected int doHashCode ( ) ; protected void execInDisplayThread ( Runnable runnable ) { ITreeModelViewer viewer = getContentProvider ( ) . getViewer ( ) ; if ( viewer ! = null & & ! isCanceled ( ) ) { Display display = viewer . getDisplay ( ) ; if ( Thread . currentThread ( ) = = display . getThread ( ) ) { runnable . run ( ) ; } else { display . asyncExec ( runnable ) ; } } } } 
