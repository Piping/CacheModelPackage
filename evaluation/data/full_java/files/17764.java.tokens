package com . badlogic . gdx . graphics . g2d . freetype ; import java . nio . ByteBuffer ; import java . nio . IntBuffer ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Blending ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . LongMap ; import com . badlogic . gdx . utils . SharedLibraryLoader ; public class FreeType { private static class Pointer { long address ; Pointer ( long address ) { this . address = address ; } } public static class Library extends Pointer implements Disposable { LongMap < ByteBuffer > fontData = new LongMap < ByteBuffer > ( ) ; Library ( long address ) { super ( address ) ; } @Override public void dispose ( ) { doneFreeType ( address ) ; for ( ByteBuffer buffer : fontData . values ( ) ) { BufferUtils . disposeUnsafeByteBuffer ( buffer ) ; } } private static native void doneFreeType ( long library ) ; public Face newFace ( FileHandle font , int faceIndex ) { byte [ ] data = font . readBytes ( ) ; return newMemoryFace ( data , data . length , faceIndex ) ; } public Face newMemoryFace ( byte [ ] data , int dataSize , int faceIndex ) { ByteBuffer buffer = BufferUtils . newUnsafeByteBuffer ( data . length ) ; BufferUtils . copy ( data , <int> , buffer , data . length ) ; return newMemoryFace ( buffer , faceIndex ) ; } public Face newMemoryFace ( ByteBuffer buffer , int faceIndex ) { long face = newMemoryFace ( address , buffer , buffer . remaining ( ) , faceIndex ) ; if ( face = = <int> ) { BufferUtils . disposeUnsafeByteBuffer ( buffer ) ; throw new GdxRuntimeException ( <str> ) ; } else { fontData . put ( face , buffer ) ; return new Face ( face , this ) ; } } private static native long newMemoryFace ( long library , ByteBuffer data , int dataSize , int faceIndex ) ; public Stroker createStroker ( ) { long stroker = strokerNew ( address ) ; if ( stroker = = <int> ) throw new GdxRuntimeException ( <str> ) ; return new Stroker ( stroker ) ; } private static native long strokerNew ( long library ) ; } public static class Face extends Pointer implements Disposable { Library library ; public Face ( long address , Library library ) { super ( address ) ; this . library = library ; } @Override public void dispose ( ) { doneFace ( address ) ; ByteBuffer buffer = library . fontData . get ( address ) ; if ( buffer ! = null ) { library . fontData . remove ( address ) ; BufferUtils . disposeUnsafeByteBuffer ( buffer ) ; } } private static native void doneFace ( long face ) ; public int getFaceFlags ( ) { return getFaceFlags ( address ) ; } private static native int getFaceFlags ( long face ) ; public int getStyleFlags ( ) { return getStyleFlags ( address ) ; } private static native int getStyleFlags ( long face ) ; public int getNumGlyphs ( ) { return getNumGlyphs ( address ) ; } private static native int getNumGlyphs ( long face ) ; public int getAscender ( ) { return getAscender ( address ) ; } private static native int getAscender ( long face ) ; public int getDescender ( ) { return getDescender ( address ) ; } private static native int getDescender ( long face ) ; public int getHeight ( ) { return getHeight ( address ) ; } private static native int getHeight ( long face ) ; public int getMaxAdvanceWidth ( ) { return getMaxAdvanceWidth ( address ) ; } private static native int getMaxAdvanceWidth ( long face ) ; public int getMaxAdvanceHeight ( ) { return getMaxAdvanceHeight ( address ) ; } private static native int getMaxAdvanceHeight ( long face ) ; public int getUnderlinePosition ( ) { return getUnderlinePosition ( address ) ; } private static native int getUnderlinePosition ( long face ) ; public int getUnderlineThickness ( ) { return getUnderlineThickness ( address ) ; } private static native int getUnderlineThickness ( long face ) ; public boolean selectSize ( int strikeIndex ) { return selectSize ( address , strikeIndex ) ; } private static native boolean selectSize ( long face , int strike_index ) ; public boolean setCharSize ( int charWidth , int charHeight , int horzResolution , int vertResolution ) { return setCharSize ( address , charWidth , charHeight , horzResolution , vertResolution ) ; } private static native boolean setCharSize ( long face , int charWidth , int charHeight , int horzResolution , int vertResolution ) ; public boolean setPixelSizes ( int pixelWidth , int pixelHeight ) { return setPixelSizes ( address , pixelWidth , pixelHeight ) ; } private static native boolean setPixelSizes ( long face , int pixelWidth , int pixelHeight ) ; public boolean loadGlyph ( int glyphIndex , int loadFlags ) { return loadGlyph ( address , glyphIndex , loadFlags ) ; } private static native boolean loadGlyph ( long face , int glyphIndex , int loadFlags ) ; public boolean loadChar ( int charCode , int loadFlags ) { return loadChar ( address , charCode , loadFlags ) ; } private static native boolean loadChar ( long face , int charCode , int loadFlags ) ; public GlyphSlot getGlyph ( ) { return new GlyphSlot ( getGlyph ( address ) ) ; } private static native long getGlyph ( long face ) ; public Size getSize ( ) { return new Size ( getSize ( address ) ) ; } private static native long getSize ( long face ) ; public boolean hasKerning ( ) { return hasKerning ( address ) ; } private static native boolean hasKerning ( long face ) ; public int getKerning ( int leftGlyph , int rightGlyph , int kernMode ) { return getKerning ( address , leftGlyph , rightGlyph , kernMode ) ; } private static native int getKerning ( long face , int leftGlyph , int rightGlyph , int kernMode ) ; public int getCharIndex ( int charCode ) { return getCharIndex ( address , charCode ) ; } private static native int getCharIndex ( long face , int charCode ) ; } public static class Size extends Pointer { Size ( long address ) { super ( address ) ; } public SizeMetrics getMetrics ( ) { return new SizeMetrics ( getMetrics ( address ) ) ; } private static native long getMetrics ( long address ) ; } public static class SizeMetrics extends Pointer { SizeMetrics ( long address ) { super ( address ) ; } public int getXppem ( ) { return getXppem ( address ) ; } private static native int getXppem ( long metrics ) ; public int getYppem ( ) { return getYppem ( address ) ; } private static native int getYppem ( long metrics ) ; public int getXScale ( ) { return getXscale ( address ) ; } private static native int getXscale ( long metrics ) ; public int getYscale ( ) { return getYscale ( address ) ; } private static native int getYscale ( long metrics ) ; public int getAscender ( ) { return getAscender ( address ) ; } private static native int getAscender ( long metrics ) ; public int getDescender ( ) { return getDescender ( address ) ; } private static native int getDescender ( long metrics ) ; public int getHeight ( ) { return getHeight ( address ) ; } private static native int getHeight ( long metrics ) ; public int getMaxAdvance ( ) { return getMaxAdvance ( address ) ; } private static native int getMaxAdvance ( long metrics ) ; } public static class GlyphSlot extends Pointer { GlyphSlot ( long address ) { super ( address ) ; } public GlyphMetrics getMetrics ( ) { return new GlyphMetrics ( getMetrics ( address ) ) ; } private static native long getMetrics ( long slot ) ; public int getLinearHoriAdvance ( ) { return getLinearHoriAdvance ( address ) ; } private static native int getLinearHoriAdvance ( long slot ) ; public int getLinearVertAdvance ( ) { return getLinearVertAdvance ( address ) ; } private static native int getLinearVertAdvance ( long slot ) ; public int getAdvanceX ( ) { return getAdvanceX ( address ) ; } private static native int getAdvanceX ( long slot ) ; public int getAdvanceY ( ) { return getAdvanceY ( address ) ; } private static native int getAdvanceY ( long slot ) ; public int getFormat ( ) { return getFormat ( address ) ; } private static native int getFormat ( long slot ) ; public Bitmap getBitmap ( ) { return new Bitmap ( getBitmap ( address ) ) ; } private static native long getBitmap ( long slot ) ; public int getBitmapLeft ( ) { return getBitmapLeft ( address ) ; } private static native int getBitmapLeft ( long slot ) ; public int getBitmapTop ( ) { return getBitmapTop ( address ) ; } private static native int getBitmapTop ( long slot ) ; public boolean renderGlyph ( int renderMode ) { return renderGlyph ( address , renderMode ) ; } private static native boolean renderGlyph ( long slot , int renderMode ) ; public Glyph getGlyph ( ) { long glyph = getGlyph ( address ) ; if ( glyph = = <int> ) throw new GdxRuntimeException ( <str> ) ; return new Glyph ( glyph ) ; } private static native long getGlyph ( long glyphSlot ) ; } public static class Glyph extends Pointer implements Disposable { private boolean rendered ; Glyph ( long address ) { super ( address ) ; } @Override public void dispose ( ) { done ( address ) ; } private static native void done ( long glyph ) ; public void strokeBorder ( Stroker stroker , boolean inside ) { address = strokeBorder ( address , stroker . address , inside ) ; } private static native long strokeBorder ( long glyph , long stroker , boolean inside ) ; public void toBitmap ( int renderMode ) { long bitmap = toBitmap ( address , renderMode ) ; if ( bitmap = = <int> ) throw new GdxRuntimeException ( <str> ) ; address = bitmap ; rendered = true ; } private static native long toBitmap ( long glyph , int renderMode ) ; public Bitmap getBitmap ( ) { if ( ! rendered ) { throw new GdxRuntimeException ( <str> ) ; } return new Bitmap ( getBitmap ( address ) ) ; } private static native long getBitmap ( long glyph ) ; public int getLeft ( ) { if ( ! rendered ) { throw new GdxRuntimeException ( <str> ) ; } return getLeft ( address ) ; } private static native int getLeft ( long glyph ) ; public int getTop ( ) { if ( ! rendered ) { throw new GdxRuntimeException ( <str> ) ; } return getTop ( address ) ; } private static native int getTop ( long glyph ) ; } public static class Bitmap extends Pointer { Bitmap ( long address ) { super ( address ) ; } public int getRows ( ) { return getRows ( address ) ; } private static native int getRows ( long bitmap ) ; public int getWidth ( ) { return getWidth ( address ) ; } private static native int getWidth ( long bitmap ) ; public int getPitch ( ) { return getPitch ( address ) ; } private static native int getPitch ( long bitmap ) ; public ByteBuffer getBuffer ( ) { if ( getRows ( ) = = <int> ) return BufferUtils . newByteBuffer ( <int> ) ; return getBuffer ( address ) ; } private static native ByteBuffer getBuffer ( long bitmap ) ; public Pixmap getPixmap ( Format format , Color color , float gamma ) { int width = getWidth ( ) , rows = getRows ( ) ; ByteBuffer src = getBuffer ( ) ; Pixmap pixmap ; int srcPitch = getPitch ( ) ; if ( color = = Color . WHITE & & srcPitch = = <int> & & gamma = = <int> ) { pixmap = new Pixmap ( width , rows , Format . Alpha ) ; BufferUtils . copy ( src , pixmap . getPixels ( ) , pixmap . getPixels ( ) . capacity ( ) ) ; } else { pixmap = new Pixmap ( width , rows , Format . RGBA8888 ) ; int srcRGBA = Color . rgba8888 ( color ) ; IntBuffer dst = pixmap . getPixels ( ) . asIntBuffer ( ) ; for ( int y = <int> ; y < rows ; y + + ) { int ySrcPitch = y * srcPitch ; int yWidth = y * width ; for ( int x = <int> ; x < width ; x + + ) { float alpha = ( src . get ( ySrcPitch + x ) & <hex> ) / <int> f ; alpha = ( float ) Math . pow ( alpha , gamma ) ; dst . put ( yWidth + x , ( srcRGBA & <hex> ) | ( int ) ( ( srcRGBA & <hex> ) * alpha ) ) ; } } } Pixmap converted = pixmap ; if ( format ! = pixmap . getFormat ( ) ) { converted = new Pixmap ( pixmap . getWidth ( ) , pixmap . getHeight ( ) , format ) ; Blending blending = Pixmap . getBlending ( ) ; Pixmap . setBlending ( Blending . None ) ; converted . drawPixmap ( pixmap , <int> , <int> ) ; Pixmap . setBlending ( blending ) ; pixmap . dispose ( ) ; } return converted ; } public int getNumGray ( ) { return getNumGray ( address ) ; } private static native int getNumGray ( long bitmap ) ; public int getPixelMode ( ) { return getPixelMode ( address ) ; } private static native int getPixelMode ( long bitmap ) ; } public static class GlyphMetrics extends Pointer { GlyphMetrics ( long address ) { super ( address ) ; } public int getWidth ( ) { return getWidth ( address ) ; } private static native int getWidth ( long metrics ) ; public int getHeight ( ) { return getHeight ( address ) ; } private static native int getHeight ( long metrics ) ; public int getHoriBearingX ( ) { return getHoriBearingX ( address ) ; } private static native int getHoriBearingX ( long metrics ) ; public int getHoriBearingY ( ) { return getHoriBearingY ( address ) ; } private static native int getHoriBearingY ( long metrics ) ; public int getHoriAdvance ( ) { return getHoriAdvance ( address ) ; } private static native int getHoriAdvance ( long metrics ) ; public int getVertBearingX ( ) { return getVertBearingX ( address ) ; } private static native int getVertBearingX ( long metrics ) ; public int getVertBearingY ( ) { return getVertBearingY ( address ) ; } private static native int getVertBearingY ( long metrics ) ; public int getVertAdvance ( ) { return getVertAdvance ( address ) ; } private static native int getVertAdvance ( long metrics ) ; } public static class Stroker extends Pointer implements Disposable { Stroker ( long address ) { super ( address ) ; } public void set ( int radius , int lineCap , int lineJoin , int miterLimit ) { set ( address , radius , lineCap , lineJoin , miterLimit ) ; } private static native void set ( long stroker , int radius , int lineCap , int lineJoin , int miterLimit ) ; @Override public void dispose ( ) { done ( address ) ; } private static native void done ( long stroker ) ; } public static int FT_PIXEL_MODE_NONE = <int> ; public static int FT_PIXEL_MODE_MONO = <int> ; public static int FT_PIXEL_MODE_GRAY = <int> ; public static int FT_PIXEL_MODE_GRAY2 = <int> ; public static int FT_PIXEL_MODE_GRAY4 = <int> ; public static int FT_PIXEL_MODE_LCD = <int> ; public static int FT_PIXEL_MODE_LCD_V = <int> ; private static int encode ( char a , char b , char c , char d ) { return ( a < < <int> ) | ( b < < <int> ) | ( c < < <int> ) | d ; } public static int FT_ENCODING_NONE = <int> ; public static int FT_ENCODING_MS_SYMBOL = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_UNICODE = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_SJIS = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_GB2312 = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_BIG5 = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_WANSUNG = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_JOHAB = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_ADOBE_STANDARD = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_ADOBE_EXPERT = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_ADOBE_CUSTOM = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_ADOBE_LATIN_1 = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_OLD_LATIN_2 = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_ENCODING_APPLE_ROMAN = encode ( <str> , <str> , <str> , <str> ) ; public static int FT_FACE_FLAG_SCALABLE = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_FIXED_SIZES = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_FIXED_WIDTH = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_SFNT = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_HORIZONTAL = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_VERTICAL = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_KERNING = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_FAST_GLYPHS = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_MULTIPLE_MASTERS = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_GLYPH_NAMES = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_EXTERNAL_STREAM = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_HINTER = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_CID_KEYED = ( <int> < < <int> ) ; public static int FT_FACE_FLAG_TRICKY = ( <int> < < <int> ) ; public static int FT_STYLE_FLAG_ITALIC = ( <int> < < <int> ) ; public static int FT_STYLE_FLAG_BOLD = ( <int> < < <int> ) ; public static int FT_LOAD_DEFAULT = <hex> ; public static int FT_LOAD_NO_SCALE = <hex> ; public static int FT_LOAD_NO_HINTING = <hex> ; public static int FT_LOAD_RENDER = <hex> ; public static int FT_LOAD_NO_BITMAP = <hex> ; public static int FT_LOAD_VERTICAL_LAYOUT = <hex> ; public static int FT_LOAD_FORCE_AUTOHINT = <hex> ; public static int FT_LOAD_CROP_BITMAP = <hex> ; public static int FT_LOAD_PEDANTIC = <hex> ; public static int FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH = <hex> ; public static int FT_LOAD_NO_RECURSE = <hex> ; public static int FT_LOAD_IGNORE_TRANSFORM = <hex> ; public static int FT_LOAD_MONOCHROME = <hex> ; public static int FT_LOAD_LINEAR_DESIGN = <hex> ; public static int FT_LOAD_NO_AUTOHINT = <hex> ; public static int FT_RENDER_MODE_NORMAL = <int> ; public static int FT_RENDER_MODE_LIGHT = <int> ; public static int FT_RENDER_MODE_MONO = <int> ; public static int FT_RENDER_MODE_LCD = <int> ; public static int FT_RENDER_MODE_LCD_V = <int> ; public static int FT_RENDER_MODE_MAX = <int> ; public static int FT_KERNING_DEFAULT = <int> ; public static int FT_KERNING_UNFITTED = <int> ; public static int FT_KERNING_UNSCALED = <int> ; public static int FT_STROKER_LINECAP_BUTT = <int> ; public static int FT_STROKER_LINECAP_ROUND = <int> ; public static int FT_STROKER_LINECAP_SQUARE = <int> ; public static int FT_STROKER_LINEJOIN_ROUND = <int> ; public static int FT_STROKER_LINEJOIN_BEVEL = <int> ; public static int FT_STROKER_LINEJOIN_MITER_VARIABLE = <int> ; public static int FT_STROKER_LINEJOIN_MITER = FT_STROKER_LINEJOIN_MITER_VARIABLE ; public static int FT_STROKER_LINEJOIN_MITER_FIXED = <int> ; public static Library initFreeType ( ) { new SharedLibraryLoader ( ) . load ( <str> ) ; long address = initFreeTypeJni ( ) ; if ( address = = <int> ) throw new GdxRuntimeException ( <str> ) ; else return new Library ( address ) ; } private static native long initFreeTypeJni ( ) ; public static int toInt ( int value ) { if ( value < <int> ) return ( int ) ( ( value - <int> ) > > <int> ) ; return ( int ) ( ( value + <int> ) > > <int> ) ; } } 
