package com . badlogic . gdx . utils ; import com . badlogic . gdx . Application ; import com . badlogic . gdx . Files ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . LifecycleListener ; public class Timer { static final Array < Timer > instances = new Array ( <int> ) ; static TimerThread thread ; static private final int CANCELLED = - <int> ; static private final int FOREVER = - <int> ; static Timer instance = new Timer ( ) ; static public Timer instance ( ) { if ( instance = = null ) { instance = new Timer ( ) ; } return instance ; } private final Array < Task > tasks = new Array ( false , <int> ) ; public Timer ( ) { start ( ) ; } public Task postTask ( Task task ) { return scheduleTask ( task , <int> , <int> , <int> ) ; } public Task scheduleTask ( Task task , float delaySeconds ) { return scheduleTask ( task , delaySeconds , <int> , <int> ) ; } public Task scheduleTask ( Task task , float delaySeconds , float intervalSeconds ) { return scheduleTask ( task , delaySeconds , intervalSeconds , FOREVER ) ; } public Task scheduleTask ( Task task , float delaySeconds , float intervalSeconds , int repeatCount ) { synchronized ( task ) { if ( task . repeatCount ! = CANCELLED ) throw new IllegalArgumentException ( <str> ) ; task . executeTimeMillis = System . nanoTime ( ) / <int> + ( long ) ( delaySeconds * <int> ) ; task . intervalMillis = ( long ) ( intervalSeconds * <int> ) ; task . repeatCount = repeatCount ; } synchronized ( this ) { tasks . add ( task ) ; } wake ( ) ; return task ; } public void stop ( ) { synchronized ( instances ) { instances . removeValue ( this , true ) ; } } public void start ( ) { synchronized ( instances ) { if ( instances . contains ( this , true ) ) return ; instances . add ( this ) ; if ( thread = = null ) thread = new TimerThread ( ) ; wake ( ) ; } } public void clear ( ) { synchronized ( this ) { for ( int i = <int> , n = tasks . size ; i < n ; i + + ) tasks . get ( i ) . cancel ( ) ; tasks . clear ( ) ; } } public boolean isEmpty ( ) { synchronized ( this ) { return tasks . size = = <int> ; } } long update ( long timeMillis , long waitMillis ) { synchronized ( this ) { for ( int i = <int> , n = tasks . size ; i < n ; i + + ) { Task task = tasks . get ( i ) ; synchronized ( task ) { if ( task . executeTimeMillis > timeMillis ) { waitMillis = Math . min ( waitMillis , task . executeTimeMillis - timeMillis ) ; continue ; } if ( task . repeatCount ! = CANCELLED ) { if ( task . repeatCount = = <int> ) task . repeatCount = CANCELLED ; task . app . postRunnable ( task ) ; } if ( task . repeatCount = = CANCELLED ) { tasks . removeIndex ( i ) ; i - - ; n - - ; } else { task . executeTimeMillis = timeMillis + task . intervalMillis ; waitMillis = Math . min ( waitMillis , task . intervalMillis ) ; if ( task . repeatCount > <int> ) task . repeatCount - - ; } } } } return waitMillis ; } public void delay ( long delayMillis ) { synchronized ( this ) { for ( int i = <int> , n = tasks . size ; i < n ; i + + ) { Task task = tasks . get ( i ) ; synchronized ( task ) { task . executeTimeMillis + = delayMillis ; } } } } static void wake ( ) { synchronized ( instances ) { instances . notifyAll ( ) ; } } static public Task post ( Task task ) { return instance ( ) . postTask ( task ) ; } static public Task schedule ( Task task , float delaySeconds ) { return instance ( ) . scheduleTask ( task , delaySeconds ) ; } static public Task schedule ( Task task , float delaySeconds , float intervalSeconds ) { return instance ( ) . scheduleTask ( task , delaySeconds , intervalSeconds ) ; } static public Task schedule ( Task task , float delaySeconds , float intervalSeconds , int repeatCount ) { return instance ( ) . scheduleTask ( task , delaySeconds , intervalSeconds , repeatCount ) ; } static abstract public class Task implements Runnable { long executeTimeMillis ; long intervalMillis ; int repeatCount = CANCELLED ; Application app = Gdx . app ; abstract public void run ( ) ; public synchronized void cancel ( ) { executeTimeMillis = <int> ; repeatCount = CANCELLED ; } public synchronized boolean isScheduled ( ) { return repeatCount ! = CANCELLED ; } public synchronized long getExecuteTimeMillis ( ) { return executeTimeMillis ; } } static class TimerThread implements Runnable , LifecycleListener { Files files ; private long pauseMillis ; public TimerThread ( ) { Gdx . app . addLifecycleListener ( this ) ; resume ( ) ; } public void run ( ) { while ( true ) { synchronized ( instances ) { if ( files ! = Gdx . files ) return ; long timeMillis = System . nanoTime ( ) / <int> ; long waitMillis = <int> ; for ( int i = <int> , n = instances . size ; i < n ; i + + ) { try { waitMillis = instances . get ( i ) . update ( timeMillis , waitMillis ) ; } catch ( Throwable ex ) { throw new GdxRuntimeException ( <str> + instances . get ( i ) . getClass ( ) . getName ( ) , ex ) ; } } if ( files ! = Gdx . files ) return ; try { if ( waitMillis > <int> ) instances . wait ( waitMillis ) ; } catch ( InterruptedException ignored ) { } } } } public void resume ( ) { long delayMillis = System . nanoTime ( ) / <int> - pauseMillis ; synchronized ( instances ) { for ( int i = <int> , n = instances . size ; i < n ; i + + ) { instances . get ( i ) . delay ( delayMillis ) ; } } files = Gdx . files ; Thread t = new Thread ( this , <str> ) ; t . setDaemon ( true ) ; t . start ( ) ; thread = this ; } public void pause ( ) { pauseMillis = System . nanoTime ( ) / <int> ; synchronized ( instances ) { files = null ; wake ( ) ; } thread = null ; } public void dispose ( ) { pause ( ) ; Gdx . app . removeLifecycleListener ( this ) ; instances . clear ( ) ; instance = null ; } } } 
