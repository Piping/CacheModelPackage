package org . gradle . launcher . daemon . registry ; import org . gradle . api . specs . Spec ; import org . gradle . api . specs . Specs ; import org . gradle . launcher . daemon . context . DaemonContext ; import org . gradle . messaging . remote . Address ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentHashMap ; public class EmbeddedDaemonRegistry implements DaemonRegistry { private final Map < Address , DaemonInfo > daemonInfos = new ConcurrentHashMap < Address , DaemonInfo > ( ) ; private final Spec < DaemonInfo > allSpec = new Spec < DaemonInfo > ( ) { public boolean isSatisfiedBy ( DaemonInfo entry ) { return true ; } } ; @SuppressWarnings ( <str> ) private final Spec < DaemonInfo > idleSpec = Specs . < DaemonInfo > and ( allSpec , new Spec < DaemonInfo > ( ) { public boolean isSatisfiedBy ( DaemonInfo daemonInfo ) { return daemonInfo . isIdle ( ) ; } } ) ; @SuppressWarnings ( <str> ) private final Spec < DaemonInfo > busySpec = Specs . < DaemonInfo > and ( allSpec , new Spec < DaemonInfo > ( ) { public boolean isSatisfiedBy ( DaemonInfo daemonInfo ) { return ! daemonInfo . isIdle ( ) ; } } ) ; public List < DaemonInfo > getAll ( ) { return daemonInfosOfEntriesMatching ( allSpec ) ; } public List < DaemonInfo > getIdle ( ) { return daemonInfosOfEntriesMatching ( idleSpec ) ; } public List < DaemonInfo > getBusy ( ) { return daemonInfosOfEntriesMatching ( busySpec ) ; } public void store ( Address address , DaemonContext daemonContext , String password , boolean idle ) { daemonInfos . put ( address , new DaemonInfo ( address , daemonContext , password , idle ) ) ; } public void remove ( Address address ) { daemonInfos . remove ( address ) ; } public void markBusy ( Address address ) { synchronized ( daemonInfos ) { daemonInfos . get ( address ) . setIdle ( false ) ; } } public void markIdle ( Address address ) { synchronized ( daemonInfos ) { daemonInfos . get ( address ) . setIdle ( true ) ; } } private List < DaemonInfo > daemonInfosOfEntriesMatching ( Spec < DaemonInfo > spec ) { List < DaemonInfo > matches = new ArrayList < DaemonInfo > ( ) ; for ( DaemonInfo daemonInfo : daemonInfos . values ( ) ) { if ( spec . isSatisfiedBy ( daemonInfo ) ) { matches . add ( daemonInfo ) ; } } return matches ; } } 
