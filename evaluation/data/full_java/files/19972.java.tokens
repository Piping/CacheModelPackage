package io . netty . handler . ssl ; import io . netty . util . internal . NativeLibraryLoader ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . apache . tomcat . jni . Library ; import org . apache . tomcat . jni . Pool ; import org . apache . tomcat . jni . SSL ; import org . apache . tomcat . jni . SSLContext ; import java . util . Collections ; import java . util . LinkedHashSet ; import java . util . Set ; public final class OpenSsl { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( OpenSsl . class ) ; private static final Throwable UNAVAILABILITY_CAUSE ; private static final Set < String > AVAILABLE_CIPHER_SUITES ; static { Throwable cause = null ; try { Class . forName ( <str> , false , OpenSsl . class . getClassLoader ( ) ) ; } catch ( ClassNotFoundException t ) { cause = t ; logger . debug ( <str> + OpenSslEngine . class . getSimpleName ( ) + <str> ) ; } if ( cause = = null ) { try { NativeLibraryLoader . load ( <str> , SSL . class . getClassLoader ( ) ) ; Library . initialize ( <str> ) ; SSL . initialize ( null ) ; } catch ( Throwable t ) { cause = t ; logger . debug ( <str> + OpenSslEngine . class . getSimpleName ( ) + <str> + <str> , t ) ; } } UNAVAILABILITY_CAUSE = cause ; if ( cause = = null ) { final Set < String > availableCipherSuites = new LinkedHashSet < String > ( <int> ) ; final long aprPool = Pool . create ( <int> ) ; try { final long sslCtx = SSLContext . make ( aprPool , SSL . SSL_PROTOCOL_ALL , SSL . SSL_MODE_SERVER ) ; try { SSLContext . setOptions ( sslCtx , SSL . SSL_OP_ALL ) ; SSLContext . setCipherSuite ( sslCtx , <str> ) ; final long ssl = SSL . newSSL ( sslCtx , true ) ; try { for ( String c : SSL . getCiphers ( ssl ) ) { if ( c = = null | | c . length ( ) = = <int> | | availableCipherSuites . contains ( c ) ) { continue ; } availableCipherSuites . add ( c ) ; } } finally { SSL . freeSSL ( ssl ) ; } } finally { SSLContext . free ( sslCtx ) ; } } catch ( Exception e ) { logger . warn ( <str> , e ) ; } finally { Pool . destroy ( aprPool ) ; } AVAILABLE_CIPHER_SUITES = Collections . unmodifiableSet ( availableCipherSuites ) ; } else { AVAILABLE_CIPHER_SUITES = Collections . emptySet ( ) ; } } public static boolean isAvailable ( ) { return UNAVAILABILITY_CAUSE = = null ; } public static boolean isAlpnSupported ( ) { return version ( ) > = <hex> ; } public static int version ( ) { if ( isAvailable ( ) ) { return SSL . version ( ) ; } return - <int> ; } public static String versionString ( ) { if ( isAvailable ( ) ) { return SSL . versionString ( ) ; } return null ; } public static void ensureAvailability ( ) { if ( UNAVAILABILITY_CAUSE ! = null ) { throw ( Error ) new UnsatisfiedLinkError ( <str> ) . initCause ( UNAVAILABILITY_CAUSE ) ; } } public static Throwable unavailabilityCause ( ) { return UNAVAILABILITY_CAUSE ; } public static Set < String > availableCipherSuites ( ) { return AVAILABLE_CIPHER_SUITES ; } public static boolean isCipherSuiteAvailable ( String cipherSuite ) { String converted = CipherSuiteConverter . toOpenSsl ( cipherSuite ) ; if ( converted ! = null ) { cipherSuite = converted ; } return AVAILABLE_CIPHER_SUITES . contains ( cipherSuite ) ; } static boolean isError ( long errorCode ) { return errorCode ! = SSL . SSL_ERROR_NONE ; } private OpenSsl ( ) { } } 
