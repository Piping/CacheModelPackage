package org . elasticsearch . common . lucene . search . function ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . * ; import org . apache . lucene . util . ToStringUtils ; import java . io . IOException ; import java . util . Objects ; import java . util . Set ; public class FunctionScoreQuery extends Query { public static final float DEFAULT_MAX_BOOST = Float . MAX_VALUE ; Query subQuery ; final ScoreFunction function ; final float maxBoost ; final CombineFunction combineFunction ; private Float minScore ; public FunctionScoreQuery ( Query subQuery , ScoreFunction function , Float minScore , CombineFunction combineFunction , float maxBoost ) { this . subQuery = subQuery ; this . function = function ; this . combineFunction = combineFunction ; this . minScore = minScore ; this . maxBoost = maxBoost ; } public FunctionScoreQuery ( Query subQuery , ScoreFunction function ) { this . subQuery = subQuery ; this . function = function ; this . combineFunction = function . getDefaultScoreCombiner ( ) ; this . maxBoost = DEFAULT_MAX_BOOST ; } public float getMaxBoost ( ) { return this . maxBoost ; } public Query getSubQuery ( ) { return subQuery ; } public ScoreFunction getFunction ( ) { return function ; } @Override public Query rewrite ( IndexReader reader ) throws IOException { Query rewritten = super . rewrite ( reader ) ; if ( rewritten ! = this ) { return rewritten ; } Query newQ = subQuery . rewrite ( reader ) ; if ( newQ = = subQuery ) { return this ; } FunctionScoreQuery bq = ( FunctionScoreQuery ) this . clone ( ) ; bq . subQuery = newQ ; return bq ; } @Override public Weight createWeight ( IndexSearcher searcher , boolean needsScores ) throws IOException { if ( needsScores = = false ) { return subQuery . createWeight ( searcher , needsScores ) ; } boolean subQueryNeedsScores = combineFunction ! = CombineFunction . REPLACE | | function = = null | | function . needsScores ( ) ; Weight subQueryWeight = subQuery . createWeight ( searcher , subQueryNeedsScores ) ; return new CustomBoostFactorWeight ( this , subQueryWeight , subQueryNeedsScores ) ; } class CustomBoostFactorWeight extends Weight { final Weight subQueryWeight ; final boolean needsScores ; public CustomBoostFactorWeight ( Query parent , Weight subQueryWeight , boolean needsScores ) throws IOException { super ( parent ) ; this . subQueryWeight = subQueryWeight ; this . needsScores = needsScores ; } @Override public void extractTerms ( Set < Term > terms ) { subQueryWeight . extractTerms ( terms ) ; } @Override public float getValueForNormalization ( ) throws IOException { return subQueryWeight . getValueForNormalization ( ) ; } @Override public void normalize ( float norm , float boost ) { subQueryWeight . normalize ( norm , boost ) ; } @Override public Scorer scorer ( LeafReaderContext context ) throws IOException { Scorer subQueryScorer = subQueryWeight . scorer ( context ) ; if ( subQueryScorer = = null ) { return null ; } LeafScoreFunction leafFunction = null ; if ( function ! = null ) { leafFunction = function . getLeafScoreFunction ( context ) ; } return new FunctionFactorScorer ( this , subQueryScorer , leafFunction , maxBoost , combineFunction , minScore , needsScores ) ; } @Override public Explanation explain ( LeafReaderContext context , int doc ) throws IOException { Explanation subQueryExpl = subQueryWeight . explain ( context , doc ) ; if ( ! subQueryExpl . isMatch ( ) ) { return subQueryExpl ; } if ( function ! = null ) { Explanation functionExplanation = function . getLeafScoreFunction ( context ) . explainScore ( doc , subQueryExpl ) ; return combineFunction . explain ( subQueryExpl , functionExplanation , maxBoost ) ; } else { return subQueryExpl ; } } } static class FunctionFactorScorer extends CustomBoostFactorScorer { private final LeafScoreFunction function ; private final boolean needsScores ; private FunctionFactorScorer ( CustomBoostFactorWeight w , Scorer scorer , LeafScoreFunction function , float maxBoost , CombineFunction scoreCombiner , Float minScore , boolean needsScores ) throws IOException { super ( w , scorer , maxBoost , scoreCombiner , minScore ) ; this . function = function ; this . needsScores = needsScores ; } @Override public float innerScore ( ) throws IOException { float score = needsScores ? scorer . score ( ) : <float> ; if ( function = = null ) { return score ; } else { return scoreCombiner . combine ( score , function . score ( scorer . docID ( ) , score ) , maxBoost ) ; } } } @Override public String toString ( String field ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( subQuery . toString ( field ) ) . append ( <str> ) . append ( function ) . append ( <str> ) ; sb . append ( ToStringUtils . boost ( getBoost ( ) ) ) ; return sb . toString ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( super . equals ( o ) = = false ) { return false ; } FunctionScoreQuery other = ( FunctionScoreQuery ) o ; return Objects . equals ( this . subQuery , other . subQuery ) & & Objects . equals ( this . function , other . function ) & & Objects . equals ( this . combineFunction , other . combineFunction ) & & Objects . equals ( this . minScore , other . minScore ) & & this . maxBoost = = other . maxBoost ; } @Override public int hashCode ( ) { return Objects . hash ( super . hashCode ( ) , subQuery . hashCode ( ) , function , combineFunction , minScore , maxBoost ) ; } } 
