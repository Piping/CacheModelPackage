package io . netty . handler . codec . http . multipart ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . handler . codec . http . HttpConstants ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . charset . Charset ; import static io . netty . buffer . Unpooled . * ; public abstract class AbstractMemoryHttpData extends AbstractHttpData { private ByteBuf byteBuf ; private int chunkPosition ; protected AbstractMemoryHttpData ( String name , Charset charset , long size ) { super ( name , charset , size ) ; } @Override public void setContent ( ByteBuf buffer ) throws IOException { if ( buffer = = null ) { throw new NullPointerException ( <str> ) ; } long localsize = buffer . readableBytes ( ) ; checkSize ( localsize ) ; if ( definedSize > <int> & & definedSize < localsize ) { throw new IOException ( <str> + localsize + <str> + definedSize ) ; } if ( byteBuf ! = null ) { byteBuf . release ( ) ; } byteBuf = buffer ; size = localsize ; setCompleted ( ) ; } @Override public void setContent ( InputStream inputStream ) throws IOException { if ( inputStream = = null ) { throw new NullPointerException ( <str> ) ; } ByteBuf buffer = buffer ( ) ; byte [ ] bytes = new byte [ <int> * <int> ] ; int read = inputStream . read ( bytes ) ; int written = <int> ; while ( read > <int> ) { buffer . writeBytes ( bytes , <int> , read ) ; written + = read ; checkSize ( written ) ; read = inputStream . read ( bytes ) ; } size = written ; if ( definedSize > <int> & & definedSize < size ) { throw new IOException ( <str> + size + <str> + definedSize ) ; } if ( byteBuf ! = null ) { byteBuf . release ( ) ; } byteBuf = buffer ; setCompleted ( ) ; } @Override public void addContent ( ByteBuf buffer , boolean last ) throws IOException { if ( buffer ! = null ) { long localsize = buffer . readableBytes ( ) ; checkSize ( size + localsize ) ; if ( definedSize > <int> & & definedSize < size + localsize ) { throw new IOException ( <str> + ( size + localsize ) + <str> + definedSize ) ; } size + = localsize ; if ( byteBuf = = null ) { byteBuf = buffer ; } else if ( byteBuf instanceof CompositeByteBuf ) { CompositeByteBuf cbb = ( CompositeByteBuf ) byteBuf ; cbb . addComponent ( buffer ) ; cbb . writerIndex ( cbb . writerIndex ( ) + buffer . readableBytes ( ) ) ; } else { CompositeByteBuf cbb = compositeBuffer ( Integer . MAX_VALUE ) ; cbb . addComponents ( byteBuf , buffer ) ; cbb . writerIndex ( byteBuf . readableBytes ( ) + buffer . readableBytes ( ) ) ; byteBuf = cbb ; } } if ( last ) { setCompleted ( ) ; } else { if ( buffer = = null ) { throw new NullPointerException ( <str> ) ; } } } @Override public void setContent ( File file ) throws IOException { if ( file = = null ) { throw new NullPointerException ( <str> ) ; } long newsize = file . length ( ) ; if ( newsize > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( <str> ) ; } checkSize ( newsize ) ; FileInputStream inputStream = new FileInputStream ( file ) ; FileChannel fileChannel = inputStream . getChannel ( ) ; byte [ ] array = new byte [ ( int ) newsize ] ; ByteBuffer byteBuffer = ByteBuffer . wrap ( array ) ; int read = <int> ; while ( read < newsize ) { read + = fileChannel . read ( byteBuffer ) ; } fileChannel . close ( ) ; inputStream . close ( ) ; byteBuffer . flip ( ) ; if ( byteBuf ! = null ) { byteBuf . release ( ) ; } byteBuf = wrappedBuffer ( Integer . MAX_VALUE , byteBuffer ) ; size = newsize ; setCompleted ( ) ; } @Override public void delete ( ) { if ( byteBuf ! = null ) { byteBuf . release ( ) ; byteBuf = null ; } } @Override public byte [ ] get ( ) { if ( byteBuf = = null ) { return EMPTY_BUFFER . array ( ) ; } byte [ ] array = new byte [ byteBuf . readableBytes ( ) ] ; byteBuf . getBytes ( byteBuf . readerIndex ( ) , array ) ; return array ; } @Override public String getString ( ) { return getString ( HttpConstants . DEFAULT_CHARSET ) ; } @Override public String getString ( Charset encoding ) { if ( byteBuf = = null ) { return <str> ; } if ( encoding = = null ) { encoding = HttpConstants . DEFAULT_CHARSET ; } return byteBuf . toString ( encoding ) ; } @Override public ByteBuf getByteBuf ( ) { return byteBuf ; } @Override public ByteBuf getChunk ( int length ) throws IOException { if ( byteBuf = = null | | length = = <int> | | byteBuf . readableBytes ( ) = = <int> ) { chunkPosition = <int> ; return EMPTY_BUFFER ; } int sizeLeft = byteBuf . readableBytes ( ) - chunkPosition ; if ( sizeLeft = = <int> ) { chunkPosition = <int> ; return EMPTY_BUFFER ; } int sliceLength = length ; if ( sizeLeft < length ) { sliceLength = sizeLeft ; } ByteBuf chunk = byteBuf . slice ( chunkPosition , sliceLength ) . retain ( ) ; chunkPosition + = sliceLength ; return chunk ; } @Override public boolean isInMemory ( ) { return true ; } @Override public boolean renameTo ( File dest ) throws IOException { if ( dest = = null ) { throw new NullPointerException ( <str> ) ; } if ( byteBuf = = null ) { if ( ! dest . createNewFile ( ) ) { throw new IOException ( <str> + dest ) ; } return true ; } int length = byteBuf . readableBytes ( ) ; FileOutputStream outputStream = new FileOutputStream ( dest ) ; FileChannel fileChannel = outputStream . getChannel ( ) ; int written = <int> ; if ( byteBuf . nioBufferCount ( ) = = <int> ) { ByteBuffer byteBuffer = byteBuf . nioBuffer ( ) ; while ( written < length ) { written + = fileChannel . write ( byteBuffer ) ; } } else { ByteBuffer [ ] byteBuffers = byteBuf . nioBuffers ( ) ; while ( written < length ) { written + = fileChannel . write ( byteBuffers ) ; } } fileChannel . force ( false ) ; fileChannel . close ( ) ; outputStream . close ( ) ; return written = = length ; } @Override public File getFile ( ) throws IOException { throw new IOException ( <str> ) ; } @Override public HttpData touch ( ) { return touch ( null ) ; } @Override public HttpData touch ( Object hint ) { if ( byteBuf ! = null ) { byteBuf . touch ( hint ) ; } return this ; } } 
