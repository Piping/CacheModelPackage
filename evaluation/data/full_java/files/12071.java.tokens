package org . gradle . internal . filewatch ; import org . gradle . api . Action ; import org . gradle . api . JavaVersion ; import org . gradle . internal . Cast ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . reflect . DirectInstantiator ; import java . util . concurrent . ExecutorService ; public class DefaultFileWatcherFactory implements FileWatcherFactory , Stoppable { private final ExecutorService executor ; private final JavaVersion javaVersion ; private final ClassLoader classLoader ; private FileWatcherFactory fileWatcherFactory ; public DefaultFileWatcherFactory ( ExecutorFactory executorFactory ) { this ( JavaVersion . current ( ) , DefaultFileWatcherFactory . class . getClassLoader ( ) , executorFactory ) ; } DefaultFileWatcherFactory ( JavaVersion javaVersion , ClassLoader classLoader , ExecutorFactory executorFactory ) { this . javaVersion = javaVersion ; this . classLoader = classLoader ; this . executor = executorFactory . create ( <str> ) ; } protected FileWatcherFactory createFileWatcherFactory ( ) { if ( javaVersion . isJava7Compatible ( ) ) { try { Class clazz = classLoader . loadClass ( <str> ) ; return Cast . uncheckedCast ( DirectInstantiator . instantiate ( clazz , executor ) ) ; } catch ( ClassNotFoundException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } else { throw new UnsupportedOperationException ( <str> ) ; } } @Override public void stop ( ) { executor . shutdown ( ) ; } @Override public FileWatcher watch ( Action < ? super Throwable > onError , FileWatcherListener listener ) { if ( fileWatcherFactory = = null ) { fileWatcherFactory = createFileWatcherFactory ( ) ; } return fileWatcherFactory . watch ( onError , listener ) ; } } 
