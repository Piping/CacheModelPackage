package org . gradle . api . internal ; import com . google . common . collect . ImmutableSet ; import groovy . lang . * ; import org . gradle . api . Transformer ; import org . gradle . api . plugins . Convention ; import org . gradle . api . plugins . ExtensionAware ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . reflect . JavaMethod ; import org . gradle . internal . reflect . JavaReflectionUtil ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . util . CollectionUtils ; import org . objectweb . asm . * ; import java . lang . annotation . Annotation ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . List ; import java . util . Set ; import static org . gradle . model . internal . asm . AsmClassGeneratorUtils . signature ; public class AsmBackedClassGenerator extends AbstractClassGenerator { private static final JavaMethod < ClassLoader , Class > DEFINE_CLASS_METHOD = JavaReflectionUtil . method ( ClassLoader . class , Class . class , <str> , String . class , byte [ ] . class , Integer . TYPE , Integer . TYPE ) ; @Override protected < T > ClassBuilder < T > start ( Class < T > type , ClassMetaData classMetaData ) { return new ClassBuilderImpl < T > ( type , classMetaData ) ; } private static class ClassBuilderImpl < T > implements ClassBuilder < T > { public static final Set < ? extends Class < ? > > PRIMITIVE_TYPES = ImmutableSet . of ( Byte . TYPE , Boolean . TYPE , Character . TYPE , Short . TYPE , Integer . TYPE , Long . TYPE , Float . TYPE , Double . TYPE ) ; private static final String DYNAMIC_OBJECT_HELPER_FIELD = <str> ; private static final String MAPPING_FIELD = <str> ; private static final String META_CLASS_FIELD = <str> ; private final ClassWriter visitor ; private final Class < T > type ; private final String typeName ; private final Type generatedType ; private final Type superclassType ; private final Type conventionAwareType = Type . getType ( IConventionAware . class ) ; private final Type dynamicObjectAwareType = Type . getType ( DynamicObjectAware . class ) ; private final Type extensionAwareType = Type . getType ( ExtensionAware . class ) ; private final Type hasConventionType = Type . getType ( HasConvention . class ) ; private final Type dynamicObjectType = Type . getType ( DynamicObject . class ) ; private final Type conventionMappingType = Type . getType ( ConventionMapping . class ) ; private final Type groovyObjectType = Type . getType ( GroovyObject . class ) ; private final Type conventionType = Type . getType ( Convention . class ) ; private final Type extensibleDynamicObjectHelperType = Type . getType ( MixInExtensibleDynamicObject . class ) ; private final Type nonExtensibleDynamicObjectHelperType = Type . getType ( BeanDynamicObject . class ) ; private final boolean conventionAware ; private final boolean extensible ; private final boolean providesOwnDynamicObject ; private ClassBuilderImpl ( Class < T > type , ClassMetaData classMetaData ) { this . type = type ; visitor = new ClassWriter ( ClassWriter . COMPUTE_MAXS ) ; typeName = type . getName ( ) + <str> ; generatedType = Type . getType ( <str> + typeName . replaceAll ( <str> , <str> ) + <str> ) ; superclassType = Type . getType ( type ) ; extensible = classMetaData . isExtensible ( ) ; conventionAware = classMetaData . isConventionAware ( ) ; providesOwnDynamicObject = classMetaData . providesDynamicObjectImplementation ( ) ; } public void startClass ( ) { List < String > interfaceTypes = new ArrayList < String > ( ) ; if ( conventionAware & & extensible ) { interfaceTypes . add ( conventionAwareType . getInternalName ( ) ) ; } if ( extensible ) { interfaceTypes . add ( extensionAwareType . getInternalName ( ) ) ; interfaceTypes . add ( hasConventionType . getInternalName ( ) ) ; } interfaceTypes . add ( dynamicObjectAwareType . getInternalName ( ) ) ; interfaceTypes . add ( groovyObjectType . getInternalName ( ) ) ; includeNotInheritedAnnotations ( ) ; visitor . visit ( Opcodes . V1_5 , Opcodes . ACC_PUBLIC , generatedType . getInternalName ( ) , null , superclassType . getInternalName ( ) , interfaceTypes . toArray ( new String [ interfaceTypes . size ( ) ] ) ) ; } public void addConstructor ( Constructor < ? > constructor ) throws Exception { List < Type > paramTypes = new ArrayList < Type > ( ) ; for ( Class < ? > paramType : constructor . getParameterTypes ( ) ) { paramTypes . add ( Type . getType ( paramType ) ) ; } String methodDescriptor = Type . getMethodDescriptor ( Type . VOID_TYPE , paramTypes . toArray ( new Type [ paramTypes . size ( ) ] ) ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , <str> , methodDescriptor , signature ( constructor ) , new String [ <int> ] ) ; for ( Annotation annotation : constructor . getDeclaredAnnotations ( ) ) { if ( annotation . annotationType ( ) . getAnnotation ( Inherited . class ) ! = null ) { continue ; } Retention retention = annotation . annotationType ( ) . getAnnotation ( Retention . class ) ; AnnotationVisitor annotationVisitor = methodVisitor . visitAnnotation ( Type . getType ( annotation . annotationType ( ) ) . getDescriptor ( ) , retention ! = null & & retention . value ( ) = = RetentionPolicy . RUNTIME ) ; annotationVisitor . visitEnd ( ) ; } methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; for ( int i = <int> ; i < constructor . getParameterTypes ( ) . length ; i + + ) { methodVisitor . visitVarInsn ( Type . getType ( constructor . getParameterTypes ( ) [ i ] ) . getOpcode ( Opcodes . ILOAD ) , i + <int> ) ; } methodVisitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , superclassType . getInternalName ( ) , <str> , methodDescriptor ) ; methodVisitor . visitInsn ( Opcodes . RETURN ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } public void mixInDynamicAware ( ) throws Exception { Type extensibleObjectFieldType = extensible ? extensibleDynamicObjectHelperType : nonExtensibleDynamicObjectHelperType ; final String fieldSignature = extensibleObjectFieldType . getDescriptor ( ) ; visitor . visitField ( Opcodes . ACC_PRIVATE , DYNAMIC_OBJECT_HELPER_FIELD , fieldSignature , null , null ) ; final Method getAsDynamicObject = DynamicObjectAware . class . getDeclaredMethod ( <str> ) ; if ( extensible ) { addGetter ( HasConvention . class . getDeclaredMethod ( <str> ) , new MethodCodeBody ( ) { public void add ( MethodVisitor visitor ) throws Exception { visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , Type . getMethodDescriptor ( getAsDynamicObject ) ) ; visitor . visitTypeInsn ( Opcodes . CHECKCAST , extensibleDynamicObjectHelperType . getInternalName ( ) ) ; String getterDescriptor = Type . getMethodDescriptor ( ExtensibleDynamicObject . class . getDeclaredMethod ( <str> ) ) ; visitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , extensibleDynamicObjectHelperType . getInternalName ( ) , <str> , getterDescriptor ) ; } } ) ; addGetter ( ExtensionAware . class . getDeclaredMethod ( <str> ) , new MethodCodeBody ( ) { public void add ( MethodVisitor visitor ) throws Exception { visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getterDescriptor = Type . getMethodDescriptor ( ExtensibleDynamicObject . class . getDeclaredMethod ( <str> ) ) ; visitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , getterDescriptor ) ; } } ) ; } addGetter ( getAsDynamicObject , new MethodCodeBody ( ) { public void add ( MethodVisitor visitor ) { visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , DYNAMIC_OBJECT_HELPER_FIELD , fieldSignature ) ; Label returnValue = new Label ( ) ; visitor . visitInsn ( Opcodes . DUP ) ; visitor . visitJumpInsn ( Opcodes . IFNONNULL , returnValue ) ; visitor . visitInsn ( Opcodes . POP ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; generateCreateDynamicObject ( visitor ) ; visitor . visitFieldInsn ( Opcodes . PUTFIELD , generatedType . getInternalName ( ) , DYNAMIC_OBJECT_HELPER_FIELD , fieldSignature ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , DYNAMIC_OBJECT_HELPER_FIELD , fieldSignature ) ; visitor . visitLabel ( returnValue ) ; } } ) ; } private void generateCreateDynamicObject ( MethodVisitor visitor ) { if ( extensible ) { String helperTypeConstructorDesc = Type . getMethodDescriptor ( Type . VOID_TYPE , Type . getType ( Object . class ) , dynamicObjectType ) ; visitor . visitTypeInsn ( Opcodes . NEW , extensibleDynamicObjectHelperType . getInternalName ( ) ) ; visitor . visitInsn ( Opcodes . DUP ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; if ( providesOwnDynamicObject ) { visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , Type . getType ( type ) . getInternalName ( ) , <str> , Type . getMethodDescriptor ( dynamicObjectType ) ) ; } else { visitor . visitInsn ( Opcodes . ACONST_NULL ) ; } visitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , extensibleDynamicObjectHelperType . getInternalName ( ) , <str> , helperTypeConstructorDesc ) ; } else { String helperTypeConstructorDesc = Type . getMethodDescriptor ( Type . VOID_TYPE , Type . getType ( Object . class ) ) ; visitor . visitTypeInsn ( Opcodes . NEW , nonExtensibleDynamicObjectHelperType . getInternalName ( ) ) ; visitor . visitInsn ( Opcodes . DUP ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , nonExtensibleDynamicObjectHelperType . getInternalName ( ) , <str> , helperTypeConstructorDesc ) ; } } public void mixInConventionAware ( ) throws Exception { if ( ! extensible ) { return ; } final String mappingFieldSignature = Type . getDescriptor ( ConventionMapping . class ) ; final String getConventionDesc = Type . getMethodDescriptor ( conventionType ) ; visitor . visitField ( Opcodes . ACC_PRIVATE , MAPPING_FIELD , mappingFieldSignature , null , null ) ; final MethodCodeBody initConventionAwareHelper = new MethodCodeBody ( ) { public void add ( MethodVisitor visitor ) throws Exception { Type helperType = Type . getType ( ConventionAwareHelper . class ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitTypeInsn ( Opcodes . NEW , helperType . getInternalName ( ) ) ; visitor . visitInsn ( Opcodes . DUP ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , getConventionDesc ) ; String constructorDesc = Type . getMethodDescriptor ( Type . VOID_TYPE , conventionAwareType , conventionType ) ; visitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , helperType . getInternalName ( ) , <str> , constructorDesc ) ; visitor . visitFieldInsn ( Opcodes . PUTFIELD , generatedType . getInternalName ( ) , MAPPING_FIELD , mappingFieldSignature ) ; } } ; addGetter ( IConventionAware . class . getDeclaredMethod ( <str> ) , new MethodCodeBody ( ) { public void add ( MethodVisitor visitor ) throws Exception { visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , MAPPING_FIELD , mappingFieldSignature ) ; visitor . visitInsn ( Opcodes . DUP ) ; Label returnValue = new Label ( ) ; visitor . visitJumpInsn ( Opcodes . IFNONNULL , returnValue ) ; visitor . visitInsn ( Opcodes . POP ) ; initConventionAwareHelper . add ( visitor ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , MAPPING_FIELD , mappingFieldSignature ) ; visitor . visitLabel ( returnValue ) ; } } ) ; } public void mixInGroovyObject ( ) throws Exception { final String metaClassFieldSignature = Type . getDescriptor ( MetaClass . class ) ; visitor . visitField ( Opcodes . ACC_PRIVATE , META_CLASS_FIELD , metaClassFieldSignature , null , null ) ; final MethodCodeBody initMetaClass = new MethodCodeBody ( ) { public void add ( MethodVisitor visitor ) throws Exception { visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getMetaClassRegistryDesc = Type . getMethodDescriptor ( GroovySystem . class . getDeclaredMethod ( <str> ) ) ; visitor . visitMethodInsn ( Opcodes . INVOKESTATIC , Type . getType ( GroovySystem . class ) . getInternalName ( ) , <str> , getMetaClassRegistryDesc ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getClassDesc = Type . getMethodDescriptor ( Object . class . getDeclaredMethod ( <str> ) ) ; visitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , Type . getType ( Object . class ) . getInternalName ( ) , <str> , getClassDesc ) ; String getMetaClassDesc = Type . getMethodDescriptor ( MetaClassRegistry . class . getDeclaredMethod ( <str> , Class . class ) ) ; visitor . visitMethodInsn ( Opcodes . INVOKEINTERFACE , Type . getType ( MetaClassRegistry . class ) . getInternalName ( ) , <str> , getMetaClassDesc ) ; visitor . visitFieldInsn ( Opcodes . PUTFIELD , generatedType . getInternalName ( ) , META_CLASS_FIELD , metaClassFieldSignature ) ; } } ; addGetter ( GroovyObject . class . getDeclaredMethod ( <str> ) , new MethodCodeBody ( ) { public void add ( MethodVisitor visitor ) throws Exception { visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , META_CLASS_FIELD , metaClassFieldSignature ) ; visitor . visitInsn ( Opcodes . DUP ) ; Label returnValue = new Label ( ) ; visitor . visitJumpInsn ( Opcodes . IFNONNULL , returnValue ) ; visitor . visitInsn ( Opcodes . POP ) ; initMetaClass . add ( visitor ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , META_CLASS_FIELD , metaClassFieldSignature ) ; visitor . visitLabel ( returnValue ) ; } } ) ; addSetter ( GroovyObject . class . getDeclaredMethod ( <str> , MetaClass . class ) , new MethodCodeBody ( ) { public void add ( MethodVisitor visitor ) throws Exception { visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; visitor . visitFieldInsn ( Opcodes . PUTFIELD , generatedType . getInternalName ( ) , META_CLASS_FIELD , metaClassFieldSignature ) ; } } ) ; } private void addSetter ( Method method , MethodCodeBody body ) throws Exception { String methodDescriptor = Type . getMethodDescriptor ( method ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , method . getName ( ) , methodDescriptor , null , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; body . add ( methodVisitor ) ; methodVisitor . visitInsn ( Opcodes . RETURN ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } private void addGetter ( Method method , MethodCodeBody body ) throws Exception { String methodDescriptor = Type . getMethodDescriptor ( method ) ; String methodName = method . getName ( ) ; addGetter ( methodName , methodDescriptor , body ) ; } private void addGetter ( String methodName , String methodDescriptor , MethodCodeBody body ) throws Exception { MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , methodName , methodDescriptor , null , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; body . add ( methodVisitor ) ; methodVisitor . visitInsn ( Opcodes . ARETURN ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } public void addDynamicMethods ( ) throws Exception { addGetter ( GroovyObject . class . getDeclaredMethod ( <str> , String . class ) , new MethodCodeBody ( ) { public void add ( MethodVisitor methodVisitor ) throws Exception { methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getAsDynamicObjectDesc = Type . getMethodDescriptor ( DynamicObjectAware . class . getDeclaredMethod ( <str> ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , getAsDynamicObjectDesc ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getPropertyDesc = Type . getMethodDescriptor ( DynamicObject . class . getDeclaredMethod ( <str> , String . class ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEINTERFACE , dynamicObjectType . getInternalName ( ) , <str> , getPropertyDesc ) ; } } ) ; String methodDescriptor = Type . getMethodDescriptor ( Type . getType ( Boolean . TYPE ) , Type . getType ( String . class ) ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , <str> , methodDescriptor , null , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getAsDynamicObjectDesc = Type . getMethodDescriptor ( DynamicObjectAware . class . getDeclaredMethod ( <str> ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , getAsDynamicObjectDesc ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getPropertyDesc = Type . getMethodDescriptor ( DynamicObject . class . getDeclaredMethod ( <str> , String . class ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEINTERFACE , dynamicObjectType . getInternalName ( ) , <str> , getPropertyDesc ) ; methodVisitor . visitInsn ( Opcodes . IRETURN ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; addSetter ( GroovyObject . class . getDeclaredMethod ( <str> , String . class , Object . class ) , new MethodCodeBody ( ) { public void add ( MethodVisitor methodVisitor ) throws Exception { methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getAsDynamicObjectDesc = Type . getMethodDescriptor ( DynamicObjectAware . class . getDeclaredMethod ( <str> ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , getAsDynamicObjectDesc ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String setPropertyDesc = Type . getMethodDescriptor ( DynamicObject . class . getDeclaredMethod ( <str> , String . class , Object . class ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEINTERFACE , dynamicObjectType . getInternalName ( ) , <str> , setPropertyDesc ) ; } } ) ; addGetter ( GroovyObject . class . getDeclaredMethod ( <str> , String . class , Object . class ) , new MethodCodeBody ( ) { public void add ( MethodVisitor methodVisitor ) throws Exception { String invokeMethodDesc = Type . getMethodDescriptor ( Type . getType ( Object . class ) , Type . getType ( String . class ) , Type . getType ( Object [ ] . class ) ) ; String objArrayDesc = Type . getType ( Object [ ] . class ) . getDescriptor ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; String getAsDynamicObjectDesc = Type . getMethodDescriptor ( DynamicObjectAware . class . getDeclaredMethod ( <str> ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , getAsDynamicObjectDesc ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitTypeInsn ( Opcodes . INSTANCEOF , objArrayDesc ) ; Label end = new Label ( ) ; Label notArray = new Label ( ) ; methodVisitor . visitJumpInsn ( Opcodes . IFEQ , notArray ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitTypeInsn ( Opcodes . CHECKCAST , objArrayDesc ) ; methodVisitor . visitJumpInsn ( Opcodes . GOTO , end ) ; methodVisitor . visitLabel ( notArray ) ; methodVisitor . visitInsn ( Opcodes . ICONST_1 ) ; methodVisitor . visitTypeInsn ( Opcodes . ANEWARRAY , Type . getType ( Object . class ) . getInternalName ( ) ) ; methodVisitor . visitInsn ( Opcodes . DUP ) ; methodVisitor . visitInsn ( Opcodes . ICONST_0 ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitInsn ( Opcodes . AASTORE ) ; methodVisitor . visitLabel ( end ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEINTERFACE , dynamicObjectType . getInternalName ( ) , <str> , invokeMethodDesc ) ; } } ) ; } public void addInjectorProperty ( PropertyMetaData property ) { String flagName = propFieldName ( property ) ; visitor . visitField ( Opcodes . ACC_PRIVATE , flagName , Type . getDescriptor ( property . getType ( ) ) , null , null ) ; } public void applyServiceInjectionToGetter ( PropertyMetaData property , Method getter ) throws Exception { Type serviceRegistryType = Type . getType ( ServiceRegistry . class ) ; Type classType = Type . getType ( Class . class ) ; Type methodType = Type . getType ( Method . class ) ; Type typeType = Type . getType ( java . lang . reflect . Type . class ) ; String getterName = getter . getName ( ) ; Type returnType = Type . getType ( getter . getReturnType ( ) ) ; String methodDescriptor = Type . getMethodDescriptor ( returnType ) ; Type serviceType = Type . getType ( property . getType ( ) ) ; String propFieldName = propFieldName ( property ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , getterName , methodDescriptor , signature ( getter ) , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , propFieldName , serviceType . getDescriptor ( ) ) ; Label alreadyLoaded = new Label ( ) ; methodVisitor . visitJumpInsn ( Opcodes . IFNONNULL , alreadyLoaded ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , Type . getMethodDescriptor ( serviceRegistryType ) ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , <str> , Type . getMethodDescriptor ( classType ) ) ; methodVisitor . visitLdcInsn ( getterName ) ; methodVisitor . visitInsn ( Opcodes . ICONST_0 ) ; methodVisitor . visitTypeInsn ( Opcodes . ANEWARRAY , classType . getInternalName ( ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , classType . getInternalName ( ) , <str> , Type . getMethodDescriptor ( methodType , Type . getType ( String . class ) , Type . getType ( Class [ ] . class ) ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , methodType . getInternalName ( ) , <str> , Type . getMethodDescriptor ( typeType ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEINTERFACE , serviceRegistryType . getInternalName ( ) , <str> , Type . getMethodDescriptor ( Type . getType ( Object . class ) , typeType ) ) ; methodVisitor . visitTypeInsn ( Opcodes . CHECKCAST , serviceType . getInternalName ( ) ) ; methodVisitor . visitFieldInsn ( Opcodes . PUTFIELD , generatedType . getInternalName ( ) , propFieldName , serviceType . getDescriptor ( ) ) ; methodVisitor . visitLabel ( alreadyLoaded ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , propFieldName , serviceType . getDescriptor ( ) ) ; methodVisitor . visitInsn ( returnType . getOpcode ( Opcodes . IRETURN ) ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } public void applyServiceInjectionToSetter ( PropertyMetaData property , Method setter ) throws Exception { String methodDescriptor = Type . getMethodDescriptor ( setter ) ; Type serviceType = Type . getType ( property . getType ( ) ) ; String propFieldName = propFieldName ( property ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , setter . getName ( ) , methodDescriptor , signature ( setter ) , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitFieldInsn ( Opcodes . PUTFIELD , generatedType . getInternalName ( ) , propFieldName , serviceType . getDescriptor ( ) ) ; methodVisitor . visitInsn ( Opcodes . RETURN ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } public void addConventionProperty ( PropertyMetaData property ) throws Exception { String flagName = propFieldName ( property ) ; visitor . visitField ( Opcodes . ACC_PRIVATE , flagName , Type . BOOLEAN_TYPE . getDescriptor ( ) , null , null ) ; } private String propFieldName ( PropertyMetaData property ) { return String . format ( <str> , property . getName ( ) ) ; } public void applyConventionMappingToGetter ( PropertyMetaData property , Method getter ) throws Exception { String flagName = propFieldName ( property ) ; String getterName = getter . getName ( ) ; Type returnType = Type . getType ( getter . getReturnType ( ) ) ; String methodDescriptor = Type . getMethodDescriptor ( returnType ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , getterName , methodDescriptor , null , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEINTERFACE , conventionAwareType . getInternalName ( ) , <str> , Type . getMethodDescriptor ( conventionMappingType ) ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , superclassType . getInternalName ( ) , getterName , methodDescriptor ) ; Type boxedType = null ; if ( getter . getReturnType ( ) . isPrimitive ( ) ) { boxedType = Type . getType ( JavaReflectionUtil . getWrapperTypeForPrimitiveType ( getter . getReturnType ( ) ) ) ; String valueOfMethodDescriptor = Type . getMethodDescriptor ( boxedType , returnType ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKESTATIC , boxedType . getInternalName ( ) , <str> , valueOfMethodDescriptor ) ; } methodVisitor . visitLdcInsn ( property . getName ( ) ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitFieldInsn ( Opcodes . GETFIELD , generatedType . getInternalName ( ) , flagName , Type . BOOLEAN_TYPE . getDescriptor ( ) ) ; String getConventionValueDesc = Type . getMethodDescriptor ( ConventionMapping . class . getMethod ( <str> , Object . class , String . class , Boolean . TYPE ) ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEINTERFACE , conventionMappingType . getInternalName ( ) , <str> , getConventionValueDesc ) ; if ( getter . getReturnType ( ) . isPrimitive ( ) ) { methodVisitor . visitTypeInsn ( Opcodes . CHECKCAST , boxedType . getInternalName ( ) ) ; String valueMethodDescriptor = Type . getMethodDescriptor ( returnType ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , boxedType . getInternalName ( ) , getter . getReturnType ( ) . getName ( ) + <str> , valueMethodDescriptor ) ; } else { methodVisitor . visitTypeInsn ( Opcodes . CHECKCAST , getter . getReturnType ( ) . isArray ( ) ? <str> + returnType . getElementType ( ) . getDescriptor ( ) : returnType . getInternalName ( ) ) ; } methodVisitor . visitInsn ( returnType . getOpcode ( Opcodes . IRETURN ) ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } public void applyConventionMappingToSetter ( PropertyMetaData property , Method setter ) throws Exception { Type paramType = Type . getType ( setter . getParameterTypes ( ) [ <int> ] ) ; Type returnType = Type . getType ( setter . getReturnType ( ) ) ; String setterDescriptor = Type . getMethodDescriptor ( returnType , paramType ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , setter . getName ( ) , setterDescriptor , null , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitVarInsn ( paramType . getOpcode ( Opcodes . ILOAD ) , <int> ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , superclassType . getInternalName ( ) , setter . getName ( ) , setterDescriptor ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitLdcInsn ( true ) ; methodVisitor . visitFieldInsn ( Opcodes . PUTFIELD , generatedType . getInternalName ( ) , propFieldName ( property ) , Type . BOOLEAN_TYPE . getDescriptor ( ) ) ; methodVisitor . visitInsn ( returnType . getOpcode ( Opcodes . IRETURN ) ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } public void addSetMethod ( PropertyMetaData property , Method setter ) throws Exception { Type paramType = Type . getType ( setter . getParameterTypes ( ) [ <int> ] ) ; Type returnType = Type . getType ( setter . getReturnType ( ) ) ; String setterDescriptor = Type . getMethodDescriptor ( returnType , paramType ) ; String setMethodDescriptor = Type . getMethodDescriptor ( Type . VOID_TYPE , paramType ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , property . getName ( ) , setMethodDescriptor , null , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitVarInsn ( paramType . getOpcode ( Opcodes . ILOAD ) , <int> ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , setter . getName ( ) , setterDescriptor ) ; methodVisitor . visitInsn ( Opcodes . RETURN ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } public void applyConventionMappingToSetMethod ( PropertyMetaData property , Method method ) throws Exception { Type paramType = Type . getType ( method . getParameterTypes ( ) [ <int> ] ) ; Type returnType = Type . getType ( method . getReturnType ( ) ) ; String methodDescriptor = Type . getMethodDescriptor ( returnType , paramType ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , method . getName ( ) , methodDescriptor , null , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitVarInsn ( paramType . getOpcode ( Opcodes . ILOAD ) , <int> ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , superclassType . getInternalName ( ) , method . getName ( ) , methodDescriptor ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; methodVisitor . visitLdcInsn ( true ) ; methodVisitor . visitFieldInsn ( Opcodes . PUTFIELD , generatedType . getInternalName ( ) , propFieldName ( property ) , Type . BOOLEAN_TYPE . getDescriptor ( ) ) ; methodVisitor . visitInsn ( returnType . getOpcode ( Opcodes . IRETURN ) ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } public void addActionMethod ( Method method ) throws Exception { Type actionImplType = Type . getType ( ClosureBackedAction . class ) ; Type closureType = Type . getType ( Closure . class ) ; Type returnType = Type . getType ( method . getReturnType ( ) ) ; Type [ ] originalParameterTypes = CollectionUtils . collectArray ( method . getParameterTypes ( ) , Type . class , new Transformer < Type , Class > ( ) { public Type transform ( Class clazz ) { return Type . getType ( clazz ) ; } } ) ; int numParams = originalParameterTypes . length ; Type [ ] closurisedParameterTypes = new Type [ numParams ] ; System . arraycopy ( originalParameterTypes , <int> , closurisedParameterTypes , <int> , numParams ) ; closurisedParameterTypes [ numParams - <int> ] = closureType ; String methodDescriptor = Type . getMethodDescriptor ( returnType , closurisedParameterTypes ) ; MethodVisitor methodVisitor = visitor . visitMethod ( Opcodes . ACC_PUBLIC , method . getName ( ) , methodDescriptor , null , new String [ <int> ] ) ; methodVisitor . visitCode ( ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , <int> ) ; for ( int stackVar = <int> ; stackVar < numParams ; + + stackVar ) { methodVisitor . visitVarInsn ( closurisedParameterTypes [ stackVar - <int> ] . getOpcode ( Opcodes . ILOAD ) , stackVar ) ; } methodVisitor . visitTypeInsn ( Opcodes . NEW , actionImplType . getInternalName ( ) ) ; methodVisitor . visitInsn ( Opcodes . DUP ) ; methodVisitor . visitVarInsn ( Opcodes . ALOAD , numParams ) ; String constuctorDescriptor = Type . getMethodDescriptor ( Type . VOID_TYPE , closureType ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKESPECIAL , actionImplType . getInternalName ( ) , <str> , constuctorDescriptor ) ; methodDescriptor = Type . getMethodDescriptor ( Type . getType ( method . getReturnType ( ) ) , originalParameterTypes ) ; methodVisitor . visitMethodInsn ( Opcodes . INVOKEVIRTUAL , generatedType . getInternalName ( ) , method . getName ( ) , methodDescriptor ) ; methodVisitor . visitInsn ( returnType . getOpcode ( Opcodes . IRETURN ) ) ; methodVisitor . visitMaxs ( <int> , <int> ) ; methodVisitor . visitEnd ( ) ; } private void includeNotInheritedAnnotations ( ) { for ( Annotation annotation : type . getDeclaredAnnotations ( ) ) { if ( annotation . annotationType ( ) . getAnnotation ( Inherited . class ) ! = null ) { continue ; } Retention retention = annotation . annotationType ( ) . getAnnotation ( Retention . class ) ; boolean visible = retention ! = null & & retention . value ( ) = = RetentionPolicy . RUNTIME ; AnnotationVisitor annotationVisitor = visitor . visitAnnotation ( Type . getType ( annotation . annotationType ( ) ) . getDescriptor ( ) , visible ) ; visitAnnotationValues ( annotation , annotationVisitor ) ; annotationVisitor . visitEnd ( ) ; } } private void visitAnnotationValues ( Annotation annotation , AnnotationVisitor annotationVisitor ) { for ( Method method : annotation . annotationType ( ) . getDeclaredMethods ( ) ) { String name = method . getName ( ) ; Class < ? > returnType = method . getReturnType ( ) ; if ( returnType . isEnum ( ) ) { annotationVisitor . visitEnum ( name , Type . getType ( returnType ) . getDescriptor ( ) , getAnnotationParameterValue ( annotation , method ) . toString ( ) ) ; } else if ( returnType . isArray ( ) & & ! PRIMITIVE_TYPES . contains ( returnType . getComponentType ( ) ) ) { AnnotationVisitor arrayVisitor = annotationVisitor . visitArray ( name ) ; Object [ ] elements = ( Object [ ] ) getAnnotationParameterValue ( annotation , method ) ; visitArrayElements ( arrayVisitor , returnType . getComponentType ( ) , elements ) ; arrayVisitor . visitEnd ( ) ; } else if ( returnType . equals ( Class . class ) ) { Class < ? > clazz = ( Class < ? > ) getAnnotationParameterValue ( annotation , method ) ; annotationVisitor . visit ( name , Type . getType ( clazz ) ) ; } else if ( returnType . isAnnotation ( ) ) { Annotation nestedAnnotation = ( Annotation ) getAnnotationParameterValue ( annotation , method ) ; AnnotationVisitor nestedAnnotationVisitor = annotationVisitor . visitAnnotation ( name , Type . getType ( returnType ) . getDescriptor ( ) ) ; visitAnnotationValues ( nestedAnnotation , nestedAnnotationVisitor ) ; nestedAnnotationVisitor . visitEnd ( ) ; } else { annotationVisitor . visit ( name , getAnnotationParameterValue ( annotation , method ) ) ; } } } private void visitArrayElements ( AnnotationVisitor arrayVisitor , Class arrayElementType , Object [ ] arrayElements ) { if ( arrayElementType . isEnum ( ) ) { String enumDescriptor = Type . getType ( arrayElementType ) . getDescriptor ( ) ; for ( Object value : arrayElements ) { arrayVisitor . visitEnum ( null , enumDescriptor , value . toString ( ) ) ; } } else if ( arrayElementType . equals ( Class . class ) ) { for ( Object value : arrayElements ) { Class < ? > clazz = ( Class < ? > ) value ; arrayVisitor . visit ( null , Type . getType ( clazz ) ) ; } } else if ( arrayElementType . isAnnotation ( ) ) { for ( Object annotation : arrayElements ) { AnnotationVisitor nestedAnnotationVisitor = arrayVisitor . visitAnnotation ( null , Type . getType ( arrayElementType ) . getDescriptor ( ) ) ; visitAnnotationValues ( ( Annotation ) annotation , nestedAnnotationVisitor ) ; nestedAnnotationVisitor . visitEnd ( ) ; } } else { for ( Object value : arrayElements ) { arrayVisitor . visit ( null , value ) ; } } } private Object getAnnotationParameterValue ( Annotation annotation , Method method ) { try { return method . invoke ( annotation ) ; } catch ( IllegalAccessException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } catch ( InvocationTargetException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public Class < ? extends T > generate ( ) { visitor . visitEnd ( ) ; byte [ ] bytecode = visitor . toByteArray ( ) ; return DEFINE_CLASS_METHOD . invoke ( type . getClassLoader ( ) , typeName , bytecode , <int> , bytecode . length ) ; } } private interface MethodCodeBody { void add ( MethodVisitor visitor ) throws Exception ; } public static class MixInExtensibleDynamicObject extends ExtensibleDynamicObject { public MixInExtensibleDynamicObject ( Object delegateObject , DynamicObject dynamicObject ) { super ( delegateObject , wrap ( delegateObject , dynamicObject ) , ThreadGlobalInstantiator . getOrCreate ( ) ) ; } private static AbstractDynamicObject wrap ( Object delegateObject , DynamicObject dynamicObject ) { if ( dynamicObject ! = null ) { return ( AbstractDynamicObject ) dynamicObject ; } return new BeanDynamicObject ( delegateObject ) ; } } } 
