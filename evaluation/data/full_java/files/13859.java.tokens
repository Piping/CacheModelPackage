package org . gradle . launcher . daemon . server ; import org . gradle . launcher . daemon . protocol . OutputMessage ; import org . gradle . messaging . remote . internal . Connection ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class SynchronizedDispatchConnection < T > implements Connection < T > { private static final Logger LOGGER = LoggerFactory . getLogger ( SynchronizedDispatchConnection . class ) ; private final Object lock = new Object ( ) ; private final Connection < T > delegate ; private boolean dispatching ; public SynchronizedDispatchConnection ( Connection < T > delegate ) { this . delegate = delegate ; } public void requestStop ( ) { LOGGER . debug ( <str> , Thread . currentThread ( ) . getId ( ) ) ; delegate . requestStop ( ) ; } public void dispatch ( final T message ) { if ( ! ( message instanceof OutputMessage ) ) { LOGGER . debug ( <str> , Thread . currentThread ( ) . getId ( ) , message . getClass ( ) ) ; } synchronized ( lock ) { if ( dispatching ) { throw new IllegalStateException ( <str> ) ; } dispatching = true ; try { delegate . dispatch ( message ) ; } finally { dispatching = false ; } } } public T receive ( ) { T result = delegate . receive ( ) ; LOGGER . debug ( <str> , Thread . currentThread ( ) . getId ( ) , result = = null ? <str> : result . getClass ( ) ) ; return result ; } public void stop ( ) { LOGGER . debug ( <str> , Thread . currentThread ( ) . getId ( ) ) ; delegate . stop ( ) ; } public String toString ( ) { return delegate . toString ( ) ; } } 
