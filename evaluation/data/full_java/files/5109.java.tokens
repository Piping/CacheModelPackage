package org . elasticsearch . action . admin . indices . exists . types ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . master . TransportMasterNodeReadAction ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; public class TransportTypesExistsAction extends TransportMasterNodeReadAction < TypesExistsRequest , TypesExistsResponse > { @Inject public TransportTypesExistsAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , TypesExistsAction . NAME , transportService , clusterService , threadPool , actionFilters , indexNameExpressionResolver , TypesExistsRequest : : new ) ; } @Override protected String executor ( ) { return ThreadPool . Names . SAME ; } @Override protected TypesExistsResponse newResponse ( ) { return new TypesExistsResponse ( ) ; } @Override protected ClusterBlockException checkBlock ( TypesExistsRequest request , ClusterState state ) { return state . blocks ( ) . indicesBlockedException ( ClusterBlockLevel . METADATA_READ , indexNameExpressionResolver . concreteIndices ( state , request ) ) ; } @Override protected void masterOperation ( final TypesExistsRequest request , final ClusterState state , final ActionListener < TypesExistsResponse > listener ) { String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( state , request . indicesOptions ( ) , request . indices ( ) ) ; if ( concreteIndices . length = = <int> ) { listener . onResponse ( new TypesExistsResponse ( false ) ) ; return ; } for ( String concreteIndex : concreteIndices ) { if ( ! state . metaData ( ) . hasConcreteIndex ( concreteIndex ) ) { listener . onResponse ( new TypesExistsResponse ( false ) ) ; return ; } ImmutableOpenMap < String , MappingMetaData > mappings = state . metaData ( ) . getIndices ( ) . get ( concreteIndex ) . getMappings ( ) ; if ( mappings . isEmpty ( ) ) { listener . onResponse ( new TypesExistsResponse ( false ) ) ; return ; } for ( String type : request . types ( ) ) { if ( ! mappings . containsKey ( type ) ) { listener . onResponse ( new TypesExistsResponse ( false ) ) ; return ; } } } listener . onResponse ( new TypesExistsResponse ( true ) ) ; } } 
