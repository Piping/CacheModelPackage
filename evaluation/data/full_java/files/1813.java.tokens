package clojure . asm . commons ; import java . io . ByteArrayOutputStream ; import java . io . DataOutput ; import java . io . DataOutputStream ; import java . io . IOException ; import java . security . MessageDigest ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import clojure . asm . ClassVisitor ; import clojure . asm . FieldVisitor ; import clojure . asm . MethodVisitor ; import clojure . asm . Opcodes ; public class SerialVersionUIDAdder extends ClassVisitor { private boolean computeSVUID ; private boolean hasSVUID ; private int access ; private String name ; private String [ ] interfaces ; private Collection < Item > svuidFields ; private boolean hasStaticInitializer ; private Collection < Item > svuidConstructors ; private Collection < Item > svuidMethods ; public SerialVersionUIDAdder ( final ClassVisitor cv ) { this ( Opcodes . ASM4 , cv ) ; } protected SerialVersionUIDAdder ( final int api , final ClassVisitor cv ) { super ( api , cv ) ; svuidFields = new ArrayList < Item > ( ) ; svuidConstructors = new ArrayList < Item > ( ) ; svuidMethods = new ArrayList < Item > ( ) ; } @Override public void visit ( final int version , final int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { computeSVUID = ( access & Opcodes . ACC_INTERFACE ) = = <int> ; if ( computeSVUID ) { this . name = name ; this . access = access ; this . interfaces = interfaces ; } super . visit ( version , access , name , signature , superName , interfaces ) ; } @Override public MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { if ( computeSVUID ) { if ( <str> . equals ( name ) ) { hasStaticInitializer = true ; } int mods = access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_PRIVATE | Opcodes . ACC_PROTECTED | Opcodes . ACC_STATIC | Opcodes . ACC_FINAL | Opcodes . ACC_SYNCHRONIZED | Opcodes . ACC_NATIVE | Opcodes . ACC_ABSTRACT | Opcodes . ACC_STRICT ) ; if ( ( access & Opcodes . ACC_PRIVATE ) = = <int> ) { if ( <str> . equals ( name ) ) { svuidConstructors . add ( new Item ( name , mods , desc ) ) ; } else if ( ! <str> . equals ( name ) ) { svuidMethods . add ( new Item ( name , mods , desc ) ) ; } } } return super . visitMethod ( access , name , desc , signature , exceptions ) ; } @Override public FieldVisitor visitField ( final int access , final String name , final String desc , final String signature , final Object value ) { if ( computeSVUID ) { if ( <str> . equals ( name ) ) { computeSVUID = false ; hasSVUID = true ; } if ( ( access & Opcodes . ACC_PRIVATE ) = = <int> | | ( access & ( Opcodes . ACC_STATIC | Opcodes . ACC_TRANSIENT ) ) = = <int> ) { int mods = access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_PRIVATE | Opcodes . ACC_PROTECTED | Opcodes . ACC_STATIC | Opcodes . ACC_FINAL | Opcodes . ACC_VOLATILE | Opcodes . ACC_TRANSIENT ) ; svuidFields . add ( new Item ( name , mods , desc ) ) ; } } return super . visitField ( access , name , desc , signature , value ) ; } @Override public void visitInnerClass ( final String aname , final String outerName , final String innerName , final int attr_access ) { if ( ( name ! = null ) & & name . equals ( aname ) ) { this . access = attr_access ; } super . visitInnerClass ( aname , outerName , innerName , attr_access ) ; } @Override public void visitEnd ( ) { if ( computeSVUID & & ! hasSVUID ) { try { addSVUID ( computeSVUID ( ) ) ; } catch ( Throwable e ) { throw new RuntimeException ( <str> + name , e ) ; } } super . visitEnd ( ) ; } public boolean hasSVUID ( ) { return hasSVUID ; } protected void addSVUID ( long svuid ) { FieldVisitor fv = super . visitField ( Opcodes . ACC_FINAL + Opcodes . ACC_STATIC , <str> , <str> , null , new Long ( svuid ) ) ; if ( fv ! = null ) { fv . visitEnd ( ) ; } } protected long computeSVUID ( ) throws IOException { ByteArrayOutputStream bos ; DataOutputStream dos = null ; long svuid = <int> ; try { bos = new ByteArrayOutputStream ( ) ; dos = new DataOutputStream ( bos ) ; dos . writeUTF ( name . replace ( <str> , <str> ) ) ; dos . writeInt ( access & ( Opcodes . ACC_PUBLIC | Opcodes . ACC_FINAL | Opcodes . ACC_INTERFACE | Opcodes . ACC_ABSTRACT ) ) ; Arrays . sort ( interfaces ) ; for ( int i = <int> ; i < interfaces . length ; i + + ) { dos . writeUTF ( interfaces [ i ] . replace ( <str> , <str> ) ) ; } writeItems ( svuidFields , dos , false ) ; if ( hasStaticInitializer ) { dos . writeUTF ( <str> ) ; dos . writeInt ( Opcodes . ACC_STATIC ) ; dos . writeUTF ( <str> ) ; } writeItems ( svuidConstructors , dos , true ) ; writeItems ( svuidMethods , dos , true ) ; dos . flush ( ) ; byte [ ] hashBytes = computeSHAdigest ( bos . toByteArray ( ) ) ; for ( int i = Math . min ( hashBytes . length , <int> ) - <int> ; i > = <int> ; i - - ) { svuid = ( svuid < < <int> ) | ( hashBytes [ i ] & <hex> ) ; } } finally { if ( dos ! = null ) { dos . close ( ) ; } } return svuid ; } protected byte [ ] computeSHAdigest ( final byte [ ] value ) { try { return MessageDigest . getInstance ( <str> ) . digest ( value ) ; } catch ( Exception e ) { throw new UnsupportedOperationException ( e . toString ( ) ) ; } } private static void writeItems ( final Collection < Item > itemCollection , final DataOutput dos , final boolean dotted ) throws IOException { int size = itemCollection . size ( ) ; Item [ ] items = itemCollection . toArray ( new Item [ size ] ) ; Arrays . sort ( items ) ; for ( int i = <int> ; i < size ; i + + ) { dos . writeUTF ( items [ i ] . name ) ; dos . writeInt ( items [ i ] . access ) ; dos . writeUTF ( dotted ? items [ i ] . desc . replace ( <str> , <str> ) : items [ i ] . desc ) ; } } private static class Item implements Comparable < Item > { final String name ; final int access ; final String desc ; Item ( final String name , final int access , final String desc ) { this . name = name ; this . access = access ; this . desc = desc ; } public int compareTo ( final Item other ) { int retVal = name . compareTo ( other . name ) ; if ( retVal = = <int> ) { retVal = desc . compareTo ( other . desc ) ; } return retVal ; } @Override public boolean equals ( final Object o ) { if ( o instanceof Item ) { return compareTo ( ( Item ) o ) = = <int> ; } return false ; } @Override public int hashCode ( ) { return ( name + desc ) . hashCode ( ) ; } } } 
