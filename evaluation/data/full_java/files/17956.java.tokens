package com . badlogic . gdx . graphics ; import java . util . Iterator ; import java . util . NoSuchElementException ; import com . badlogic . gdx . utils . GdxRuntimeException ; public final class VertexAttributes implements Iterable < VertexAttribute > , Comparable < VertexAttributes > { public static final class Usage { public static final int Position = <int> ; public static final int ColorUnpacked = <int> ; public static final int ColorPacked = <int> ; public static final int Normal = <int> ; public static final int TextureCoordinates = <int> ; public static final int Generic = <int> ; public static final int BoneWeight = <int> ; public static final int Tangent = <int> ; public static final int BiNormal = <int> ; } private final VertexAttribute [ ] attributes ; public final int vertexSize ; private long mask = - <int> ; private ReadonlyIterable < VertexAttribute > iterable ; public VertexAttributes ( VertexAttribute . . . attributes ) { if ( attributes . length = = <int> ) throw new IllegalArgumentException ( <str> ) ; VertexAttribute [ ] list = new VertexAttribute [ attributes . length ] ; for ( int i = <int> ; i < attributes . length ; i + + ) list [ i ] = attributes [ i ] ; this . attributes = list ; vertexSize = calculateOffsets ( ) ; } public int getOffset ( int usage , int defaultIfNotFound ) { VertexAttribute vertexAttribute = findByUsage ( usage ) ; if ( vertexAttribute = = null ) return defaultIfNotFound ; return vertexAttribute . offset / <int> ; } public int getOffset ( int usage ) { return getOffset ( usage , <int> ) ; } public VertexAttribute findByUsage ( int usage ) { int len = size ( ) ; for ( int i = <int> ; i < len ; i + + ) if ( get ( i ) . usage = = usage ) return get ( i ) ; return null ; } private int calculateOffsets ( ) { int count = <int> ; for ( int i = <int> ; i < attributes . length ; i + + ) { VertexAttribute attribute = attributes [ i ] ; attribute . offset = count ; if ( attribute . usage = = VertexAttributes . Usage . ColorPacked ) count + = <int> ; else count + = <int> * attribute . numComponents ; } return count ; } public int size ( ) { return attributes . length ; } public VertexAttribute get ( int index ) { return attributes [ index ] ; } public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( <str> ) ; for ( int i = <int> ; i < attributes . length ; i + + ) { builder . append ( <str> ) ; builder . append ( attributes [ i ] . alias ) ; builder . append ( <str> ) ; builder . append ( attributes [ i ] . usage ) ; builder . append ( <str> ) ; builder . append ( attributes [ i ] . numComponents ) ; builder . append ( <str> ) ; builder . append ( attributes [ i ] . offset ) ; builder . append ( <str> ) ; builder . append ( <str> ) ; } builder . append ( <str> ) ; return builder . toString ( ) ; } @Override public boolean equals ( final Object obj ) { if ( obj = = this ) return true ; if ( ! ( obj instanceof VertexAttributes ) ) return false ; VertexAttributes other = ( VertexAttributes ) obj ; if ( this . attributes . length ! = other . attributes . length ) return false ; for ( int i = <int> ; i < attributes . length ; i + + ) { if ( ! attributes [ i ] . equals ( other . attributes [ i ] ) ) return false ; } return true ; } @Override public int hashCode ( ) { long result = <int> * attributes . length ; for ( int i = <int> ; i < attributes . length ; i + + ) result = result * <int> + attributes [ i ] . hashCode ( ) ; return ( int ) ( result ^ ( result > > <int> ) ) ; } public long getMask ( ) { if ( mask = = - <int> ) { long result = <int> ; for ( int i = <int> ; i < attributes . length ; i + + ) { result | = attributes [ i ] . usage ; } mask = result ; } return mask ; } @Override public int compareTo ( VertexAttributes o ) { if ( attributes . length ! = o . attributes . length ) return attributes . length - o . attributes . length ; final long m1 = getMask ( ) ; final long m2 = o . getMask ( ) ; if ( m1 ! = m2 ) return m1 < m2 ? - <int> : <int> ; for ( int i = attributes . length - <int> ; i > = <int> ; - - i ) { final VertexAttribute va0 = attributes [ i ] ; final VertexAttribute va1 = o . attributes [ i ] ; if ( va0 . usage ! = va1 . usage ) return va0 . usage - va1 . usage ; if ( va0 . unit ! = va1 . unit ) return va0 . unit - va1 . unit ; if ( va0 . numComponents ! = va1 . numComponents ) return va0 . numComponents - va1 . numComponents ; if ( va0 . normalized ! = va1 . normalized ) return va0 . normalized ? <int> : - <int> ; if ( va0 . type ! = va1 . type ) return va0 . type - va1 . type ; } return <int> ; } @Override public Iterator < VertexAttribute > iterator ( ) { if ( iterable = = null ) iterable = new ReadonlyIterable < VertexAttribute > ( attributes ) ; return iterable . iterator ( ) ; } static private class ReadonlyIterator < T > implements Iterator < T > , Iterable < T > { private final T [ ] array ; int index ; boolean valid = true ; public ReadonlyIterator ( T [ ] array ) { this . array = array ; } @Override public boolean hasNext ( ) { if ( ! valid ) throw new GdxRuntimeException ( <str> ) ; return index < array . length ; } @Override public T next ( ) { if ( index > = array . length ) throw new NoSuchElementException ( String . valueOf ( index ) ) ; if ( ! valid ) throw new GdxRuntimeException ( <str> ) ; return array [ index + + ] ; } @Override public void remove ( ) { throw new GdxRuntimeException ( <str> ) ; } public void reset ( ) { index = <int> ; } @Override public Iterator < T > iterator ( ) { return this ; } } static private class ReadonlyIterable < T > implements Iterable < T > { private final T [ ] array ; private ReadonlyIterator iterator1 , iterator2 ; public ReadonlyIterable ( T [ ] array ) { this . array = array ; } @Override public Iterator < T > iterator ( ) { if ( iterator1 = = null ) { iterator1 = new ReadonlyIterator ( array ) ; iterator2 = new ReadonlyIterator ( array ) ; } if ( ! iterator1 . valid ) { iterator1 . index = <int> ; iterator1 . valid = true ; iterator2 . valid = false ; return iterator1 ; } iterator2 . index = <int> ; iterator2 . valid = true ; iterator1 . valid = false ; return iterator2 ; } } } 
