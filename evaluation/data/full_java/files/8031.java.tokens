package org . elasticsearch . discovery . zen . publish ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Randomness ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . discovery . zen . DiscoveryNodesProvider ; import org . elasticsearch . node . service . NodeService ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import org . elasticsearch . transport . local . LocalTransport ; import org . junit . After ; import org . junit . Before ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . Matchers . * ; @TestLogging ( <str> ) public class PublishClusterStateActionTests extends ESTestCase { protected ThreadPool threadPool ; protected Map < String , MockNode > nodes = new HashMap < > ( ) ; public static class MockNode implements PublishClusterStateAction . NewPendingClusterStateListener , DiscoveryNodesProvider { public final DiscoveryNode discoveryNode ; public final MockTransportService service ; public MockPublishAction action ; public final ClusterStateListener listener ; public volatile ClusterState clusterState ; private final ESLogger logger ; public MockNode ( DiscoveryNode discoveryNode , MockTransportService service , @Nullable ClusterStateListener listener , ESLogger logger ) { this . discoveryNode = discoveryNode ; this . service = service ; this . listener = listener ; this . logger = logger ; this . clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . nodes ( DiscoveryNodes . builder ( ) . put ( discoveryNode ) . localNodeId ( discoveryNode . id ( ) ) . build ( ) ) . build ( ) ; } public MockNode setAsMaster ( ) { this . clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . masterNodeId ( discoveryNode . id ( ) ) ) . build ( ) ; return this ; } public MockNode resetMasterId ( ) { this . clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . masterNodeId ( null ) ) . build ( ) ; return this ; } public void connectTo ( DiscoveryNode node ) { service . connectToNode ( node ) ; } @Override public void onNewClusterState ( String reason ) { ClusterState newClusterState = action . pendingStatesQueue ( ) . getNextClusterStateToProcess ( ) ; logger . debug ( <str> , discoveryNode . name ( ) , newClusterState . version ( ) , newClusterState . stateUUID ( ) ) ; if ( listener ! = null ) { ClusterChangedEvent event = new ClusterChangedEvent ( <str> , newClusterState , clusterState ) ; listener . clusterChanged ( event ) ; } if ( clusterState . nodes ( ) . masterNode ( ) = = null | | newClusterState . supersedes ( clusterState ) ) { clusterState = newClusterState ; } action . pendingStatesQueue ( ) . markAsProcessed ( newClusterState ) ; } @Override public DiscoveryNodes nodes ( ) { return clusterState . nodes ( ) ; } @Override public NodeService nodeService ( ) { assert false ; throw new UnsupportedOperationException ( <str> ) ; } } public MockNode createMockNode ( final String name ) throws Exception { return createMockNode ( name , Settings . EMPTY , Version . CURRENT ) ; } public MockNode createMockNode ( String name , Settings settings ) throws Exception { return createMockNode ( name , settings , Version . CURRENT ) ; } public MockNode createMockNode ( final String name , Settings settings , Version version ) throws Exception { return createMockNode ( name , settings , version , null ) ; } public MockNode createMockNode ( String name , Settings settings , Version version , @Nullable ClusterStateListener listener ) throws Exception { settings = Settings . builder ( ) . put ( <str> , name ) . put ( TransportService . SETTING_TRACE_LOG_INCLUDE , <str> , TransportService . SETTING_TRACE_LOG_EXCLUDE , <str> ) . put ( settings ) . build ( ) ; MockTransportService service = buildTransportService ( settings , version ) ; DiscoveryNode discoveryNode = new DiscoveryNode ( name , name , service . boundAddress ( ) . publishAddress ( ) , settings . getByPrefix ( <str> ) . getAsMap ( ) , version ) ; MockNode node = new MockNode ( discoveryNode , service , listener , logger ) ; node . action = buildPublishClusterStateAction ( settings , service , node , node ) ; final CountDownLatch latch = new CountDownLatch ( nodes . size ( ) * <int> + <int> ) ; TransportConnectionListener waitForConnection = new TransportConnectionListener ( ) { @Override public void onNodeConnected ( DiscoveryNode node ) { latch . countDown ( ) ; } @Override public void onNodeDisconnected ( DiscoveryNode node ) { fail ( <str> + node ) ; } } ; node . service . addConnectionListener ( waitForConnection ) ; for ( MockNode curNode : nodes . values ( ) ) { curNode . service . addConnectionListener ( waitForConnection ) ; curNode . connectTo ( node . discoveryNode ) ; node . connectTo ( curNode . discoveryNode ) ; } node . connectTo ( node . discoveryNode ) ; assertThat ( <str> , latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; for ( MockNode curNode : nodes . values ( ) ) { curNode . service . removeConnectionListener ( waitForConnection ) ; } node . service . removeConnectionListener ( waitForConnection ) ; if ( nodes . put ( name , node ) ! = null ) { fail ( <str> + name + <str> ) ; } return node ; } public MockTransportService service ( String name ) { MockNode node = nodes . get ( name ) ; if ( node ! = null ) { return node . service ; } return null ; } public PublishClusterStateAction action ( String name ) { MockNode node = nodes . get ( name ) ; if ( node ! = null ) { return node . action ; } return null ; } @Override @Before public void setUp ( ) throws Exception { super . setUp ( ) ; threadPool = new ThreadPool ( getClass ( ) . getName ( ) ) ; } @Override @After public void tearDown ( ) throws Exception { super . tearDown ( ) ; for ( MockNode curNode : nodes . values ( ) ) { curNode . action . close ( ) ; curNode . service . close ( ) ; } terminate ( threadPool ) ; } protected MockTransportService buildTransportService ( Settings settings , Version version ) { MockTransportService transportService = new MockTransportService ( settings , new LocalTransport ( settings , threadPool , version , new NamedWriteableRegistry ( ) ) , threadPool ) ; transportService . start ( ) ; return transportService ; } protected MockPublishAction buildPublishClusterStateAction ( Settings settings , MockTransportService transportService , DiscoveryNodesProvider nodesProvider , PublishClusterStateAction . NewPendingClusterStateListener listener ) { DiscoverySettings discoverySettings = new DiscoverySettings ( settings , new NodeSettingsService ( settings ) ) ; return new MockPublishAction ( settings , transportService , nodesProvider , listener , discoverySettings , ClusterName . DEFAULT ) ; } public void testSimpleClusterStatePublishing ( ) throws Exception { MockNode nodeA = createMockNode ( <str> , Settings . EMPTY , Version . CURRENT ) . setAsMaster ( ) ; MockNode nodeB = createMockNode ( <str> , Settings . EMPTY , Version . CURRENT ) ; ClusterState clusterState = nodeA . clusterState ; DiscoveryNodes discoveryNodes = DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( nodeB . discoveryNode ) . build ( ) ; ClusterState previousClusterState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . nodes ( discoveryNodes ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromFull ( nodeB . clusterState , clusterState ) ; previousClusterState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . blocks ( ClusterBlocks . builder ( ) . addGlobalBlock ( MetaData . CLUSTER_READ_ONLY_BLOCK ) ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromDiff ( nodeB . clusterState , clusterState ) ; assertThat ( nodeB . clusterState . blocks ( ) . global ( ) . size ( ) , equalTo ( <int> ) ) ; previousClusterState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . blocks ( ClusterBlocks . EMPTY_CLUSTER_BLOCK ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromDiff ( nodeB . clusterState , clusterState ) ; assertTrue ( nodeB . clusterState . wasReadFromDiff ( ) ) ; MockNode nodeC = createMockNode ( <str> , Settings . EMPTY , Version . CURRENT ) ; previousClusterState = clusterState ; discoveryNodes = DiscoveryNodes . builder ( discoveryNodes ) . put ( nodeC . discoveryNode ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( discoveryNodes ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromDiff ( nodeB . clusterState , clusterState ) ; assertSameStateFromFull ( nodeC . clusterState , clusterState ) ; previousClusterState = clusterState ; MetaData metaData = MetaData . builder ( clusterState . metaData ( ) ) . transientSettings ( Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . metaData ( metaData ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromDiff ( nodeB . clusterState , clusterState ) ; assertThat ( nodeB . clusterState . blocks ( ) . global ( ) . size ( ) , equalTo ( <int> ) ) ; assertSameStateFromDiff ( nodeC . clusterState , clusterState ) ; assertThat ( nodeC . clusterState . blocks ( ) . global ( ) . size ( ) , equalTo ( <int> ) ) ; previousClusterState = ClusterState . builder ( clusterState ) . incrementVersion ( ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromFull ( nodeB . clusterState , clusterState ) ; assertSameStateFromFull ( nodeC . clusterState , clusterState ) ; assertFalse ( nodeC . clusterState . wasReadFromDiff ( ) ) ; nodeA . resetMasterId ( ) ; nodeB . resetMasterId ( ) ; nodeC . resetMasterId ( ) ; discoveryNodes = DiscoveryNodes . builder ( discoveryNodes ) . put ( nodeA . discoveryNode ) . put ( nodeB . discoveryNode ) . put ( nodeC . discoveryNode ) . masterNodeId ( nodeB . discoveryNode . id ( ) ) . localNodeId ( nodeB . discoveryNode . id ( ) ) . build ( ) ; previousClusterState = ClusterState . builder ( new ClusterName ( <str> ) ) . nodes ( discoveryNodes ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( discoveryNodes ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeB . action , clusterState , previousClusterState ) ; assertSameStateFromFull ( nodeA . clusterState , clusterState ) ; assertSameStateFromFull ( nodeC . clusterState , clusterState ) ; } public void testUnexpectedDiffPublishing ( ) throws Exception { MockNode nodeA = createMockNode ( <str> , Settings . EMPTY , Version . CURRENT , new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { fail ( <str> ) ; } } ) . setAsMaster ( ) ; MockNode nodeB = createMockNode ( <str> , Settings . EMPTY , Version . CURRENT ) ; DiscoveryNodes discoveryNodes = DiscoveryNodes . builder ( nodeA . nodes ( ) ) . put ( nodeB . discoveryNode ) . build ( ) ; ClusterState previousClusterState = ClusterState . builder ( ClusterName . DEFAULT ) . nodes ( discoveryNodes ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( previousClusterState ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromFull ( nodeB . clusterState , clusterState ) ; previousClusterState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . blocks ( ClusterBlocks . builder ( ) . addGlobalBlock ( MetaData . CLUSTER_READ_ONLY_BLOCK ) ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromDiff ( nodeB . clusterState , clusterState ) ; } public void testDisablingDiffPublishing ( ) throws Exception { Settings noDiffPublishingSettings = Settings . builder ( ) . put ( DiscoverySettings . PUBLISH_DIFF_ENABLE , false ) . build ( ) ; MockNode nodeA = createMockNode ( <str> , noDiffPublishingSettings , Version . CURRENT , new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { fail ( <str> ) ; } } ) ; MockNode nodeB = createMockNode ( <str> , noDiffPublishingSettings , Version . CURRENT , new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { assertFalse ( event . state ( ) . wasReadFromDiff ( ) ) ; } } ) ; DiscoveryNodes discoveryNodes = DiscoveryNodes . builder ( ) . put ( nodeA . discoveryNode ) . localNodeId ( nodeA . discoveryNode . id ( ) ) . masterNodeId ( nodeA . discoveryNode . id ( ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . nodes ( discoveryNodes ) . build ( ) ; discoveryNodes = DiscoveryNodes . builder ( discoveryNodes ) . put ( nodeB . discoveryNode ) . build ( ) ; ClusterState previousClusterState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . nodes ( discoveryNodes ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; previousClusterState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . blocks ( ClusterBlocks . builder ( ) . addGlobalBlock ( MetaData . CLUSTER_READ_ONLY_BLOCK ) ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; } public void testSimultaneousClusterStatePublishing ( ) throws Exception { int numberOfNodes = randomIntBetween ( <int> , <int> ) ; int numberOfIterations = scaledRandomIntBetween ( <int> , <int> ) ; Settings settings = Settings . builder ( ) . put ( DiscoverySettings . PUBLISH_DIFF_ENABLE , randomBoolean ( ) ) . build ( ) ; MockNode master = createMockNode ( <str> , settings , Version . CURRENT , new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { assertProperMetaDataForVersion ( event . state ( ) . metaData ( ) , event . state ( ) . version ( ) ) ; } } ) . setAsMaster ( ) ; DiscoveryNodes . Builder discoveryNodesBuilder = DiscoveryNodes . builder ( master . nodes ( ) ) ; for ( int i = <int> ; i < numberOfNodes ; i + + ) { final String name = <str> + i ; final MockNode node = createMockNode ( name , settings , Version . CURRENT , new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { assertProperMetaDataForVersion ( event . state ( ) . metaData ( ) , event . state ( ) . version ( ) ) ; } } ) ; discoveryNodesBuilder . put ( node . discoveryNode ) ; } AssertingAckListener [ ] listeners = new AssertingAckListener [ numberOfIterations ] ; DiscoveryNodes discoveryNodes = discoveryNodesBuilder . build ( ) ; MetaData metaData = MetaData . EMPTY_META_DATA ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . build ( ) ; ClusterState previousState ; for ( int i = <int> ; i < numberOfIterations ; i + + ) { previousState = clusterState ; metaData = buildMetaDataForVersion ( metaData , i + <int> ) ; clusterState = ClusterState . builder ( clusterState ) . incrementVersion ( ) . metaData ( metaData ) . nodes ( discoveryNodes ) . build ( ) ; listeners [ i ] = publishState ( master . action , clusterState , previousState ) ; } for ( int i = <int> ; i < numberOfIterations ; i + + ) { listeners [ i ] . await ( <int> , TimeUnit . SECONDS ) ; } master . clusterState = clusterState ; for ( MockNode node : nodes . values ( ) ) { assertSameState ( node . clusterState , clusterState ) ; assertThat ( node . clusterState . nodes ( ) . localNode ( ) , equalTo ( node . discoveryNode ) ) ; } } public void testSerializationFailureDuringDiffPublishing ( ) throws Exception { MockNode nodeA = createMockNode ( <str> , Settings . EMPTY , Version . CURRENT , new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { fail ( <str> ) ; } } ) . setAsMaster ( ) ; MockNode nodeB = createMockNode ( <str> , Settings . EMPTY , Version . CURRENT ) ; DiscoveryNodes discoveryNodes = DiscoveryNodes . builder ( nodeA . nodes ( ) ) . put ( nodeB . discoveryNode ) . build ( ) ; ClusterState previousClusterState = ClusterState . builder ( ClusterName . DEFAULT ) . nodes ( discoveryNodes ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( previousClusterState ) . incrementVersion ( ) . build ( ) ; publishStateAndWait ( nodeA . action , clusterState , previousClusterState ) ; assertSameStateFromFull ( nodeB . clusterState , clusterState ) ; previousClusterState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . blocks ( ClusterBlocks . builder ( ) . addGlobalBlock ( MetaData . CLUSTER_READ_ONLY_BLOCK ) ) . incrementVersion ( ) . build ( ) ; ClusterState unserializableClusterState = new ClusterState ( clusterState . version ( ) , clusterState . stateUUID ( ) , clusterState ) { @Override public Diff < ClusterState > diff ( ClusterState previousState ) { return new Diff < ClusterState > ( ) { @Override public ClusterState apply ( ClusterState part ) { fail ( <str> ) ; return part ; } @Override public void writeTo ( StreamOutput out ) throws IOException { throw new IOException ( <str> ) ; } } ; } } ; try { publishStateAndWait ( nodeA . action , unserializableClusterState , previousClusterState ) ; fail ( <str> ) ; } catch ( Discovery . FailedToCommitClusterStateException e ) { assertThat ( e . getCause ( ) , notNullValue ( ) ) ; assertThat ( e . getCause ( ) . getMessage ( ) , containsString ( <str> ) ) ; } } public void testFailToPublishWithLessThanMinMasterNodes ( ) throws Exception { final int masterNodes = randomIntBetween ( <int> , <int> ) ; MockNode master = createMockNode ( <str> ) ; DiscoveryNodes . Builder discoveryNodesBuilder = DiscoveryNodes . builder ( ) . put ( master . discoveryNode ) ; for ( int i = <int> ; i < masterNodes ; i + + ) { discoveryNodesBuilder . put ( createMockNode ( <str> + i ) . discoveryNode ) ; } final int dataNodes = randomIntBetween ( <int> , <int> ) ; final Settings dataSettings = Settings . builder ( ) . put ( <str> , false ) . build ( ) ; for ( int i = <int> ; i < dataNodes ; i + + ) { discoveryNodesBuilder . put ( createMockNode ( <str> + i , dataSettings ) . discoveryNode ) ; } discoveryNodesBuilder . localNodeId ( master . discoveryNode . id ( ) ) . masterNodeId ( master . discoveryNode . id ( ) ) ; DiscoveryNodes discoveryNodes = discoveryNodesBuilder . build ( ) ; MetaData metaData = MetaData . EMPTY_META_DATA ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . nodes ( discoveryNodes ) . build ( ) ; ClusterState previousState = master . clusterState ; try { publishState ( master . action , clusterState , previousState , masterNodes + randomIntBetween ( <int> , <int> ) ) ; fail ( <str> ) ; } catch ( Discovery . FailedToCommitClusterStateException expected ) { logger . debug ( <str> , expected ) ; } } public void testPublishingWithSendingErrors ( ) throws Exception { int goodNodes = randomIntBetween ( <int> , <int> ) ; int errorNodes = randomIntBetween ( <int> , <int> ) ; int timeOutNodes = randomBoolean ( ) ? <int> : randomIntBetween ( <int> , <int> ) ; final int numberOfMasterNodes = goodNodes + errorNodes + timeOutNodes + <int> ; final boolean expectingToCommit = randomBoolean ( ) ; Settings . Builder settings = Settings . builder ( ) ; settings . put ( DiscoverySettings . COMMIT_TIMEOUT , expectingToCommit = = false & & timeOutNodes > <int> ? <str> : <str> ) . put ( DiscoverySettings . PUBLISH_TIMEOUT , <str> ) ; MockNode master = createMockNode ( <str> , settings . build ( ) ) ; int [ ] nodeTypes = new int [ goodNodes + errorNodes + timeOutNodes ] ; for ( int i = <int> ; i < goodNodes ; i + + ) { nodeTypes [ i ] = <int> ; } for ( int i = goodNodes ; i < goodNodes + errorNodes ; i + + ) { nodeTypes [ i ] = <int> ; } for ( int i = goodNodes + errorNodes ; i < nodeTypes . length ; i + + ) { nodeTypes [ i ] = <int> ; } Collections . shuffle ( Arrays . asList ( nodeTypes ) , random ( ) ) ; DiscoveryNodes . Builder discoveryNodesBuilder = DiscoveryNodes . builder ( ) . put ( master . discoveryNode ) ; for ( int i = <int> ; i < nodeTypes . length ; i + + ) { final MockNode mockNode = createMockNode ( <str> + i ) ; discoveryNodesBuilder . put ( mockNode . discoveryNode ) ; switch ( nodeTypes [ i ] ) { case <int> : mockNode . action . errorOnSend . set ( true ) ; break ; case <int> : mockNode . action . timeoutOnSend . set ( true ) ; break ; } } final int dataNodes = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < dataNodes ; i + + ) { final MockNode mockNode = createMockNode ( <str> + i , Settings . builder ( ) . put ( <str> , false ) . build ( ) ) ; discoveryNodesBuilder . put ( mockNode . discoveryNode ) ; if ( randomBoolean ( ) ) { mockNode . action . errorOnCommit . set ( randomBoolean ( ) ) ; mockNode . action . errorOnSend . set ( randomBoolean ( ) ) ; mockNode . action . timeoutOnCommit . set ( randomBoolean ( ) ) ; mockNode . action . timeoutOnSend . set ( randomBoolean ( ) ) ; } } final int minMasterNodes ; final String expectedBehavior ; if ( expectingToCommit ) { minMasterNodes = randomIntBetween ( <int> , goodNodes + <int> ) ; expectedBehavior = <str> ; } else { minMasterNodes = randomIntBetween ( goodNodes + <int> , numberOfMasterNodes ) ; expectedBehavior = timeOutNodes > <int> ? <str> : <str> ; } logger . info ( <str> , expectedBehavior , goodNodes + <int> , errorNodes , timeOutNodes , minMasterNodes ) ; discoveryNodesBuilder . localNodeId ( master . discoveryNode . id ( ) ) . masterNodeId ( master . discoveryNode . id ( ) ) ; DiscoveryNodes discoveryNodes = discoveryNodesBuilder . build ( ) ; MetaData metaData = MetaData . EMPTY_META_DATA ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . nodes ( discoveryNodes ) . build ( ) ; ClusterState previousState = master . clusterState ; try { publishState ( master . action , clusterState , previousState , minMasterNodes ) ; if ( expectingToCommit = = false ) { fail ( <str> ) ; } } catch ( Discovery . FailedToCommitClusterStateException exception ) { logger . debug ( <str> , exception ) ; if ( expectingToCommit ) { throw exception ; } assertThat ( exception . getMessage ( ) , containsString ( timeOutNodes > <int> ? <str> : <str> ) ) ; } } public void testIncomingClusterStateValidation ( ) throws Exception { MockNode node = createMockNode ( <str> ) ; logger . info ( <str> ) ; ClusterState state = ClusterState . builder ( node . clusterState ) . nodes ( DiscoveryNodes . builder ( node . nodes ( ) ) . masterNodeId ( randomAsciiOfLength ( <int> ) ) ) . incrementVersion ( ) . build ( ) ; node . action . validateIncomingState ( state , null ) ; node . clusterState = ClusterState . builder ( node . clusterState ) . nodes ( DiscoveryNodes . builder ( node . nodes ( ) ) . masterNodeId ( <str> ) ) . build ( ) ; logger . info ( <str> ) ; try { node . action . validateIncomingState ( state , node . clusterState ) ; fail ( <str> ) ; } catch ( IllegalStateException OK ) { } logger . info ( <str> ) ; node . action . validateIncomingState ( ClusterState . builder ( node . clusterState ) . nodes ( DiscoveryNodes . builder ( node . nodes ( ) ) . masterNodeId ( <str> ) ) . build ( ) , node . clusterState ) ; logger . info ( <str> ) ; try { node . action . validateIncomingState ( ClusterState . builder ( new ClusterName ( randomAsciiOfLength ( <int> ) ) ) . nodes ( node . nodes ( ) ) . build ( ) , node . clusterState ) ; fail ( <str> ) ; } catch ( IllegalStateException OK ) { } logger . info ( <str> ) ; try { state = ClusterState . builder ( node . clusterState ) . nodes ( DiscoveryNodes . builder ( node . nodes ( ) ) . localNodeId ( <str> ) . build ( ) ) . incrementVersion ( ) . build ( ) ; node . action . validateIncomingState ( state , node . clusterState ) ; fail ( <str> ) ; } catch ( IllegalStateException OK ) { } try { MockNode otherNode = createMockNode ( <str> ) ; state = ClusterState . builder ( node . clusterState ) . nodes ( DiscoveryNodes . builder ( node . nodes ( ) ) . put ( otherNode . discoveryNode ) . localNodeId ( otherNode . discoveryNode . id ( ) ) . build ( ) ) . incrementVersion ( ) . build ( ) ; node . action . validateIncomingState ( state , node . clusterState ) ; fail ( <str> ) ; } catch ( IllegalStateException OK ) { } logger . info ( <str> ) ; state = node . clusterState ; node . clusterState = ClusterState . builder ( node . clusterState ) . incrementVersion ( ) . build ( ) ; node . action . validateIncomingState ( state , node . clusterState ) ; ClusterState previousState = ClusterState . builder ( node . clusterState ) . incrementVersion ( ) . build ( ) ; state = ClusterState . builder ( node . clusterState ) . nodes ( DiscoveryNodes . builder ( node . clusterState . nodes ( ) ) . masterNodeId ( <str> ) . build ( ) ) . build ( ) ; node . resetMasterId ( ) ; node . action . validateIncomingState ( state , previousState ) ; } public void testInterleavedPublishCommit ( ) throws Throwable { MockNode node = createMockNode ( <str> ) . setAsMaster ( ) ; final CapturingTransportChannel channel = new CapturingTransportChannel ( ) ; List < ClusterState > states = new ArrayList < > ( ) ; final int numOfStates = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < = numOfStates ; i + + ) { states . add ( ClusterState . builder ( node . clusterState ) . version ( i ) . stateUUID ( ClusterState . UNKNOWN_UUID ) . build ( ) ) ; } final ClusterState finalState = states . get ( numOfStates - <int> ) ; Collections . shuffle ( states , random ( ) ) ; logger . info ( <str> ) ; for ( ClusterState state : states ) { node . action . handleIncomingClusterStateRequest ( new BytesTransportRequest ( PublishClusterStateAction . serializeFullClusterState ( state , Version . CURRENT ) , Version . CURRENT ) , channel ) ; assertThat ( channel . response . get ( ) , equalTo ( ( TransportResponse ) TransportResponse . Empty . INSTANCE ) ) ; assertThat ( channel . error . get ( ) , nullValue ( ) ) ; channel . clear ( ) ; } logger . info ( <str> ) ; Randomness . shuffle ( states ) ; for ( ClusterState state : states ) { node . action . handleCommitRequest ( new PublishClusterStateAction . CommitClusterStateRequest ( state . stateUUID ( ) ) , channel ) ; assertThat ( channel . response . get ( ) , equalTo ( ( TransportResponse ) TransportResponse . Empty . INSTANCE ) ) ; if ( channel . error . get ( ) ! = null ) { throw channel . error . get ( ) ; } } channel . clear ( ) ; assertSameState ( node . clusterState , finalState ) ; } public void testTimeoutOrCommit ( ) throws Exception { Settings settings = Settings . builder ( ) . put ( DiscoverySettings . COMMIT_TIMEOUT , <str> ) . build ( ) ; MockNode master = createMockNode ( <str> , settings ) ; MockNode node = createMockNode ( <str> , settings ) ; ClusterState state = ClusterState . builder ( master . clusterState ) . nodes ( DiscoveryNodes . builder ( master . clusterState . nodes ( ) ) . put ( node . discoveryNode ) . masterNodeId ( master . discoveryNode . id ( ) ) ) . build ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { state = ClusterState . builder ( state ) . incrementVersion ( ) . build ( ) ; logger . debug ( <str> , state . version ( ) , state . stateUUID ( ) ) ; boolean success ; try { publishState ( master . action , state , master . clusterState , <int> ) . await ( <int> , TimeUnit . HOURS ) ; success = true ; } catch ( Discovery . FailedToCommitClusterStateException OK ) { success = false ; } logger . debug ( <str> , success ? <str> : <str> ) ; if ( success ) { assertSameState ( node . clusterState , state ) ; } else { assertThat ( node . clusterState . stateUUID ( ) , not ( equalTo ( state . stateUUID ( ) ) ) ) ; } } } private MetaData buildMetaDataForVersion ( MetaData metaData , long version ) { ImmutableOpenMap . Builder < String , IndexMetaData > indices = ImmutableOpenMap . builder ( metaData . indices ( ) ) ; indices . put ( <str> + version , IndexMetaData . builder ( <str> + version ) . settings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) ) . numberOfShards ( ( int ) version ) . numberOfReplicas ( <int> ) . build ( ) ) ; return MetaData . builder ( metaData ) . transientSettings ( Settings . builder ( ) . put ( <str> , version ) . build ( ) ) . indices ( indices . build ( ) ) . build ( ) ; } private void assertProperMetaDataForVersion ( MetaData metaData , long version ) { for ( long i = <int> ; i < = version ; i + + ) { assertThat ( metaData . index ( <str> + i ) , notNullValue ( ) ) ; assertThat ( metaData . index ( <str> + i ) . getNumberOfShards ( ) , equalTo ( ( int ) i ) ) ; } assertThat ( metaData . index ( <str> + ( version + <int> ) ) , nullValue ( ) ) ; assertThat ( metaData . transientSettings ( ) . get ( <str> ) , equalTo ( Long . toString ( version ) ) ) ; } public void publishStateAndWait ( PublishClusterStateAction action , ClusterState state , ClusterState previousState ) throws InterruptedException { publishState ( action , state , previousState ) . await ( <int> , TimeUnit . SECONDS ) ; } public AssertingAckListener publishState ( PublishClusterStateAction action , ClusterState state , ClusterState previousState ) throws InterruptedException { final int minimumMasterNodes = randomIntBetween ( - <int> , state . nodes ( ) . getMasterNodes ( ) . size ( ) ) ; return publishState ( action , state , previousState , minimumMasterNodes ) ; } public AssertingAckListener publishState ( PublishClusterStateAction action , ClusterState state , ClusterState previousState , int minMasterNodes ) throws InterruptedException { AssertingAckListener assertingAckListener = new AssertingAckListener ( state . nodes ( ) . getSize ( ) - <int> ) ; ClusterChangedEvent changedEvent = new ClusterChangedEvent ( <str> , state , previousState ) ; action . publish ( changedEvent , minMasterNodes , assertingAckListener ) ; return assertingAckListener ; } public static class AssertingAckListener implements Discovery . AckListener { private final List < Tuple < DiscoveryNode , Throwable > > errors = new CopyOnWriteArrayList < > ( ) ; private final AtomicBoolean timeoutOccurred = new AtomicBoolean ( ) ; private final CountDownLatch countDown ; public AssertingAckListener ( int nodeCount ) { countDown = new CountDownLatch ( nodeCount ) ; } @Override public void onNodeAck ( DiscoveryNode node , @Nullable Throwable t ) { if ( t ! = null ) { errors . add ( new Tuple < > ( node , t ) ) ; } countDown . countDown ( ) ; } @Override public void onTimeout ( ) { timeoutOccurred . set ( true ) ; long currentCount = countDown . getCount ( ) ; for ( long i = <int> ; i < currentCount ; i + + ) { countDown . countDown ( ) ; } } public void await ( long timeout , TimeUnit unit ) throws InterruptedException { assertThat ( awaitErrors ( timeout , unit ) , emptyIterable ( ) ) ; } public List < Tuple < DiscoveryNode , Throwable > > awaitErrors ( long timeout , TimeUnit unit ) throws InterruptedException { countDown . await ( timeout , unit ) ; assertFalse ( timeoutOccurred . get ( ) ) ; return errors ; } } void assertSameState ( ClusterState actual , ClusterState expected ) { assertThat ( actual , notNullValue ( ) ) ; final String reason = <str> + actual . prettyPrint ( ) + <str> + expected . prettyPrint ( ) ; assertThat ( <str> + reason , actual . stateUUID ( ) , equalTo ( expected . stateUUID ( ) ) ) ; assertThat ( <str> + reason , actual . version ( ) , equalTo ( expected . version ( ) ) ) ; } void assertSameStateFromDiff ( ClusterState actual , ClusterState expected ) { assertSameState ( actual , expected ) ; assertTrue ( actual . wasReadFromDiff ( ) ) ; } void assertSameStateFromFull ( ClusterState actual , ClusterState expected ) { assertSameState ( actual , expected ) ; assertFalse ( actual . wasReadFromDiff ( ) ) ; } static class MockPublishAction extends PublishClusterStateAction { AtomicBoolean timeoutOnSend = new AtomicBoolean ( ) ; AtomicBoolean errorOnSend = new AtomicBoolean ( ) ; AtomicBoolean timeoutOnCommit = new AtomicBoolean ( ) ; AtomicBoolean errorOnCommit = new AtomicBoolean ( ) ; public MockPublishAction ( Settings settings , TransportService transportService , DiscoveryNodesProvider nodesProvider , NewPendingClusterStateListener listener , DiscoverySettings discoverySettings , ClusterName clusterName ) { super ( settings , transportService , nodesProvider , listener , discoverySettings , clusterName ) ; } @Override protected void handleIncomingClusterStateRequest ( BytesTransportRequest request , TransportChannel channel ) throws IOException { if ( errorOnSend . get ( ) ) { throw new ElasticsearchException ( <str> ) ; } if ( timeoutOnSend . get ( ) ) { return ; } super . handleIncomingClusterStateRequest ( request , channel ) ; } @Override protected void handleCommitRequest ( PublishClusterStateAction . CommitClusterStateRequest request , TransportChannel channel ) { if ( errorOnCommit . get ( ) ) { throw new ElasticsearchException ( <str> ) ; } if ( timeoutOnCommit . get ( ) ) { return ; } super . handleCommitRequest ( request , channel ) ; } } static class CapturingTransportChannel implements TransportChannel { AtomicReference < TransportResponse > response = new AtomicReference < > ( ) ; AtomicReference < Throwable > error = new AtomicReference < > ( ) ; public void clear ( ) { response . set ( null ) ; error . set ( null ) ; } @Override public String action ( ) { return <str> ; } @Override public String getProfileName ( ) { return <str> ; } @Override public void sendResponse ( TransportResponse response ) throws IOException { this . response . set ( response ) ; assertThat ( error . get ( ) , nullValue ( ) ) ; } @Override public void sendResponse ( TransportResponse response , TransportResponseOptions options ) throws IOException { this . response . set ( response ) ; assertThat ( error . get ( ) , nullValue ( ) ) ; } @Override public void sendResponse ( Throwable error ) throws IOException { this . error . set ( error ) ; assertThat ( response . get ( ) , nullValue ( ) ) ; } } } 
