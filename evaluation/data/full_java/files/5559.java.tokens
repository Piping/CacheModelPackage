package org . elasticsearch . cluster . metadata ; import org . elasticsearch . action . admin . indices . alias . Alias ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . indices . InvalidAliasNameException ; import java . io . IOException ; public class AliasValidator extends AbstractComponent { @Inject public AliasValidator ( Settings settings ) { super ( settings ) ; } public void validateAliasAction ( AliasAction aliasAction , MetaData metaData ) { validateAlias ( aliasAction . alias ( ) , aliasAction . index ( ) , aliasAction . indexRouting ( ) , metaData ) ; } public void validateAlias ( Alias alias , String index , MetaData metaData ) { validateAlias ( alias . name ( ) , index , alias . indexRouting ( ) , metaData ) ; } public void validateAliasMetaData ( AliasMetaData aliasMetaData , String index , MetaData metaData ) { validateAlias ( aliasMetaData . alias ( ) , index , aliasMetaData . indexRouting ( ) , metaData ) ; } public void validateAliasStandalone ( Alias alias ) { validateAliasStandalone ( alias . name ( ) , alias . indexRouting ( ) ) ; if ( Strings . hasLength ( alias . filter ( ) ) ) { try ( XContentParser parser = XContentFactory . xContent ( alias . filter ( ) ) . createParser ( alias . filter ( ) ) ) { parser . map ( ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( <str> + alias . name ( ) + <str> , e ) ; } } } private void validateAlias ( String alias , String index , String indexRouting , MetaData metaData ) { validateAliasStandalone ( alias , indexRouting ) ; if ( ! Strings . hasText ( index ) ) { throw new IllegalArgumentException ( <str> ) ; } assert metaData ! = null ; if ( metaData . hasIndex ( alias ) ) { throw new InvalidAliasNameException ( new Index ( index ) , alias , <str> ) ; } } private void validateAliasStandalone ( String alias , String indexRouting ) { if ( ! Strings . hasText ( alias ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( indexRouting ! = null & & indexRouting . indexOf ( <str> ) ! = - <int> ) { throw new IllegalArgumentException ( <str> + alias + <str> ) ; } } public void validateAliasFilter ( String alias , String filter , QueryShardContext queryShardContext ) { assert queryShardContext ! = null ; try { XContentParser parser = XContentFactory . xContent ( filter ) . createParser ( filter ) ; validateAliasFilter ( parser , queryShardContext ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( <str> + alias + <str> , e ) ; } } public void validateAliasFilter ( String alias , byte [ ] filter , QueryShardContext queryShardContext ) { assert queryShardContext ! = null ; try { XContentParser parser = XContentFactory . xContent ( filter ) . createParser ( filter ) ; validateAliasFilter ( parser , queryShardContext ) ; } catch ( Throwable e ) { throw new IllegalArgumentException ( <str> + alias + <str> , e ) ; } } private void validateAliasFilter ( XContentParser parser , QueryShardContext queryShardContext ) throws IOException { try { queryShardContext . reset ( parser ) ; queryShardContext . parseContext ( ) . parseInnerQueryBuilder ( ) . toFilter ( queryShardContext ) ; } finally { queryShardContext . reset ( null ) ; parser . close ( ) ; } } } 
