package org . elasticsearch . action . admin . cluster . repositories ; import org . elasticsearch . action . admin . cluster . repositories . get . GetRepositoriesResponse ; import org . elasticsearch . action . admin . cluster . repositories . verify . VerifyRepositoryResponse ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertBlocked ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . hasSize ; @ClusterScope ( scope = ESIntegTestCase . Scope . TEST ) public class RepositoryBlocksIT extends ESIntegTestCase { public void testPutRepositoryWithBlocks ( ) { logger . info ( <str> ) ; try { setClusterReadOnly ( true ) ; assertBlocked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setVerify ( false ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) , MetaData . CLUSTER_READ_ONLY_BLOCK ) ; } finally { setClusterReadOnly ( false ) ; } logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setVerify ( false ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) ) ; } public void testVerifyRepositoryWithBlocks ( ) { assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setVerify ( false ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) ) ; try { setClusterReadOnly ( true ) ; VerifyRepositoryResponse response = client ( ) . admin ( ) . cluster ( ) . prepareVerifyRepository ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( response . getNodes ( ) . length , equalTo ( cluster ( ) . numDataAndMasterNodes ( ) ) ) ; } finally { setClusterReadOnly ( false ) ; } } public void testDeleteRepositoryWithBlocks ( ) { assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setVerify ( false ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) ) ; logger . info ( <str> ) ; try { setClusterReadOnly ( true ) ; assertBlocked ( client ( ) . admin ( ) . cluster ( ) . prepareDeleteRepository ( <str> ) , MetaData . CLUSTER_READ_ONLY_BLOCK ) ; } finally { setClusterReadOnly ( false ) ; } logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareDeleteRepository ( <str> ) ) ; } public void testGetRepositoryWithBlocks ( ) { assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setVerify ( false ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) ) ; try { setClusterReadOnly ( true ) ; GetRepositoriesResponse response = client ( ) . admin ( ) . cluster ( ) . prepareGetRepositories ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( response . repositories ( ) , hasSize ( <int> ) ) ; } finally { setClusterReadOnly ( false ) ; } } } 
