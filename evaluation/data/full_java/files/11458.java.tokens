package org . gradle . api . internal . file ; import groovy . lang . Closure ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . PathValidation ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . file . FileCollection ; import org . gradle . api . file . FileTree ; import org . gradle . api . internal . file . collections . DefaultConfigurableFileCollection ; import org . gradle . api . resources . internal . ReadableResourceInternal ; import org . gradle . internal . Cast ; import org . gradle . internal . Factory ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . nativeintegration . filesystem . FileSystem ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . internal . typeconversion . NotationParser ; import org . gradle . internal . typeconversion . UnsupportedNotationException ; import org . gradle . util . CollectionUtils ; import java . io . File ; import java . io . IOException ; import java . net . URI ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . Callable ; import java . util . regex . Pattern ; public abstract class AbstractFileResolver implements FileResolver { private static final Pattern FILE_SEPARATOR_PATTERN = Pattern . compile ( <str> + Pattern . quote ( File . separator ) + <str> ) ; private final FileSystem fileSystem ; private final NotationParser < Object , Object > fileNotationParser ; protected AbstractFileResolver ( FileSystem fileSystem ) { this . fileSystem = fileSystem ; this . fileNotationParser = FileOrUriNotationConverter . parser ( fileSystem ) ; } public FileSystem getFileSystem ( ) { return fileSystem ; } public FileResolver withBaseDir ( Object path ) { return new BaseDirFileResolver ( fileSystem , resolve ( path ) ) ; } public File resolve ( Object path ) { return resolve ( path , PathValidation . NONE ) ; } public NotationParser < Object , File > asNotationParser ( ) { return new NotationParser < Object , File > ( ) { public File parseNotation ( Object notation ) throws UnsupportedNotationException { return resolve ( notation , PathValidation . NONE ) ; } @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) ; } } ; } public File resolve ( Object path , PathValidation validation ) { File file = doResolve ( path ) ; file = normalise ( file ) ; validate ( file , validation ) ; return file ; } private File normalise ( File file ) { try { assert file . isAbsolute ( ) : String . format ( <str> , file ) ; if ( OperatingSystem . current ( ) . isWindows ( ) ) { return file . getCanonicalFile ( ) ; } String [ ] segments = FILE_SEPARATOR_PATTERN . split ( file . getPath ( ) ) ; List < String > path = new ArrayList < String > ( segments . length ) ; for ( String segment : segments ) { if ( segment . equals ( <str> ) ) { if ( ! path . isEmpty ( ) ) { path . remove ( path . size ( ) - <int> ) ; } } else if ( ! segment . equals ( <str> ) & & segment . length ( ) > <int> ) { path . add ( segment ) ; } } String resolvedPath = CollectionUtils . join ( File . separator , path ) ; boolean needLeadingSeparator = File . listRoots ( ) [ <int> ] . getPath ( ) . startsWith ( File . separator ) ; if ( needLeadingSeparator ) { resolvedPath = File . separator + resolvedPath ; } File candidate = new File ( resolvedPath ) ; if ( fileSystem . isCaseSensitive ( ) ) { return candidate ; } File canonical = candidate . getCanonicalFile ( ) ; if ( candidate . getPath ( ) . equalsIgnoreCase ( canonical . getPath ( ) ) ) { return canonical ; } File current = File . listRoots ( ) [ <int> ] ; for ( int pos = <int> ; pos < path . size ( ) ; pos + + ) { File child = findChild ( current , path . get ( pos ) ) ; if ( child = = null ) { current = new File ( current , CollectionUtils . join ( File . separator , path . subList ( pos , path . size ( ) ) ) ) ; break ; } current = child ; } return current ; } catch ( IOException e ) { throw new UncheckedIOException ( String . format ( <str> , file ) , e ) ; } } private File findChild ( File current , String segment ) throws IOException { String [ ] children = current . list ( ) ; if ( children = = null ) { return null ; } for ( String child : children ) { if ( child . equalsIgnoreCase ( segment ) ) { return new File ( current , child ) ; } } return new File ( current , segment ) ; } public Factory < File > resolveLater ( final Object path ) { return new Factory < File > ( ) { public File create ( ) { return resolve ( path ) ; } } ; } public URI resolveUri ( Object path ) { return convertObjectToURI ( path ) ; } protected abstract File doResolve ( Object path ) ; protected URI convertObjectToURI ( Object path ) { Object object = unpack ( path ) ; Object converted = fileNotationParser . parseNotation ( object ) ; if ( converted instanceof File ) { return resolve ( converted ) . toURI ( ) ; } return ( URI ) converted ; } protected File convertObjectToFile ( Object path ) { Object object = unpack ( path ) ; if ( object = = null ) { return null ; } Object converted = fileNotationParser . parseNotation ( object ) ; if ( converted instanceof File ) { return ( File ) converted ; } throw new InvalidUserDataException ( String . format ( <str> , converted ) ) ; } private Object unpack ( Object path ) { Object current = path ; while ( current ! = null ) { if ( current instanceof Closure ) { current = ( ( Closure ) current ) . call ( ) ; } else if ( current instanceof Callable ) { try { current = ( ( Callable ) current ) . call ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } else if ( current instanceof Factory ) { return ( ( Factory ) current ) . create ( ) ; } else { return current ; } } return null ; } protected void validate ( File file , PathValidation validation ) { switch ( validation ) { case NONE : break ; case EXISTS : if ( ! file . exists ( ) ) { throw new InvalidUserDataException ( String . format ( <str> , file ) ) ; } break ; case FILE : if ( ! file . exists ( ) ) { throw new InvalidUserDataException ( String . format ( <str> , file ) ) ; } if ( ! file . isFile ( ) ) { throw new InvalidUserDataException ( String . format ( <str> , file ) ) ; } break ; case DIRECTORY : if ( ! file . exists ( ) ) { throw new InvalidUserDataException ( String . format ( <str> , file ) ) ; } if ( ! file . isDirectory ( ) ) { throw new InvalidUserDataException ( String . format ( <str> , file ) ) ; } break ; } } public FileCollectionInternal resolveFiles ( Object . . . paths ) { if ( paths . length = = <int> & & paths [ <int> ] instanceof FileCollection ) { return Cast . cast ( FileCollectionInternal . class , paths [ <int> ] ) ; } return new DefaultConfigurableFileCollection ( this , null , paths ) ; } public FileTreeInternal resolveFilesAsTree ( Object . . . paths ) { return Cast . cast ( FileTreeInternal . class , resolveFiles ( paths ) . getAsFileTree ( ) ) ; } public FileTreeInternal compositeFileTree ( List < ? extends FileTree > fileTrees ) { return new DefaultCompositeFileTree ( CollectionUtils . checkedCast ( FileTreeInternal . class , fileTrees ) ) ; } public ReadableResourceInternal resolveResource ( Object path ) { if ( path instanceof ReadableResourceInternal ) { return ( ReadableResourceInternal ) path ; } return new FileResource ( resolve ( path ) ) ; } } 
