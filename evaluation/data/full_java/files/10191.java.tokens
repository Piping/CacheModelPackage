package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . collect . CollectPreconditions . checkNonnegative ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . primitives . Ints ; import com . google . common . util . concurrent . ThreadFactoryBuilder ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Random ; import java . util . Set ; import java . util . concurrent . Callable ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import javax . annotation . Nullable ; public class ConcurrentHashMultisetBenchmark { @Param ( { <str> , <str> , <str> , <str> } ) int threads ; @Param ( { <str> , <str> , <str> } ) int size ; @Param MultisetSupplier implSupplier ; private Multiset < Integer > multiset ; private ImmutableList < Integer > keys ; private ExecutorService threadPool ; @BeforeExperiment void setUp ( ) throws Exception { multiset = implSupplier . get ( ) ; ImmutableList . Builder < Integer > builder = ImmutableList . builder ( ) ; for ( int i = <int> ; i < size ; i + + ) { builder . add ( i ) ; } keys = builder . build ( ) ; threadPool = Executors . newFixedThreadPool ( threads , new ThreadFactoryBuilder ( ) . setDaemon ( true ) . build ( ) ) ; } @Benchmark long add ( final int reps ) throws ExecutionException , InterruptedException { return doMultithreadedLoop ( new Callable < Long > ( ) { @Override public Long call ( ) { return runAddSingleThread ( reps ) ; } } ) ; } @Benchmark long addRemove ( final int reps ) throws ExecutionException , InterruptedException { return doMultithreadedLoop ( new Callable < Long > ( ) { @Override public Long call ( ) { return runAddRemoveSingleThread ( reps ) ; } } ) ; } private long doMultithreadedLoop ( Callable < Long > task ) throws InterruptedException , ExecutionException { List < Future < Long > > futures = Lists . newArrayListWithCapacity ( threads ) ; for ( int i = <int> ; i < threads ; i + + ) { futures . add ( threadPool . submit ( task ) ) ; } long total = <int> ; for ( Future < Long > future : futures ) { total + = future . get ( ) ; } return total ; } private long runAddSingleThread ( int reps ) { Random random = new Random ( ) ; int nKeys = keys . size ( ) ; long blah = <int> ; for ( int i = <int> ; i < reps ; i + + ) { Integer key = keys . get ( random . nextInt ( nKeys ) ) ; int delta = random . nextInt ( <int> ) ; blah + = delta ; multiset . add ( key , delta ) ; } return blah ; } private long runAddRemoveSingleThread ( int reps ) { Random random = new Random ( ) ; int nKeys = keys . size ( ) ; long blah = <int> ; for ( int i = <int> ; i < reps ; i + + ) { Integer key = keys . get ( random . nextInt ( nKeys ) ) ; int delta = random . nextInt ( <int> ) - <int> ; blah + = delta ; if ( delta > = <int> ) { multiset . add ( key , delta ) ; } else { multiset . remove ( key , - delta ) ; } } return blah ; } private enum MultisetSupplier { CONCURRENT_HASH_MULTISET ( ) { @Override Multiset < Integer > get ( ) { return ConcurrentHashMultiset . create ( ) ; } } , BOXED_ATOMIC_REPLACE ( ) { @Override Multiset < Integer > get ( ) { return OldConcurrentHashMultiset . create ( ) ; } } , SYNCHRONIZED_MULTISET ( ) { @Override Multiset < Integer > get ( ) { return Synchronized . multiset ( HashMultiset . < Integer > create ( ) , null ) ; } } , ; abstract Multiset < Integer > get ( ) ; } private static final class OldConcurrentHashMultiset < E > extends AbstractMultiset < E > { private final transient ConcurrentMap < E , Integer > countMap ; public static < E > OldConcurrentHashMultiset < E > create ( ) { return new OldConcurrentHashMultiset < E > ( new ConcurrentHashMap < E , Integer > ( ) ) ; } @VisibleForTesting OldConcurrentHashMultiset ( ConcurrentMap < E , Integer > countMap ) { checkArgument ( countMap . isEmpty ( ) ) ; this . countMap = countMap ; } @Override public int count ( @Nullable Object element ) { try { return unbox ( countMap . get ( element ) ) ; } catch ( NullPointerException e ) { return <int> ; } catch ( ClassCastException e ) { return <int> ; } } @Override public int size ( ) { long sum = <int> L ; for ( Integer value : countMap . values ( ) ) { sum + = value ; } return Ints . saturatedCast ( sum ) ; } @Override public Object [ ] toArray ( ) { return snapshot ( ) . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] array ) { return snapshot ( ) . toArray ( array ) ; } private List < E > snapshot ( ) { List < E > list = Lists . newArrayListWithExpectedSize ( size ( ) ) ; for ( Multiset . Entry < E > entry : entrySet ( ) ) { E element = entry . getElement ( ) ; for ( int i = entry . getCount ( ) ; i > <int> ; i - - ) { list . add ( element ) ; } } return list ; } @Override public int add ( E element , int occurrences ) { if ( occurrences = = <int> ) { return count ( element ) ; } checkArgument ( occurrences > <int> , <str> , occurrences ) ; while ( true ) { int current = count ( element ) ; if ( current = = <int> ) { if ( countMap . putIfAbsent ( element , occurrences ) = = null ) { return <int> ; } } else { checkArgument ( occurrences < = Integer . MAX_VALUE - current , <str> , occurrences , current ) ; int next = current + occurrences ; if ( countMap . replace ( element , current , next ) ) { return current ; } } } } @Override public int remove ( @Nullable Object element , int occurrences ) { if ( occurrences = = <int> ) { return count ( element ) ; } checkArgument ( occurrences > <int> , <str> , occurrences ) ; while ( true ) { int current = count ( element ) ; if ( current = = <int> ) { return <int> ; } if ( occurrences > = current ) { if ( countMap . remove ( element , current ) ) { return current ; } } else { @SuppressWarnings ( <str> ) E casted = ( E ) element ; if ( countMap . replace ( casted , current , current - occurrences ) ) { return current ; } } } } private int removeAllOccurrences ( @Nullable Object element ) { try { return unbox ( countMap . remove ( element ) ) ; } catch ( NullPointerException e ) { return <int> ; } catch ( ClassCastException e ) { return <int> ; } } public boolean removeExactly ( @Nullable Object element , int occurrences ) { if ( occurrences = = <int> ) { return true ; } checkArgument ( occurrences > <int> , <str> , occurrences ) ; while ( true ) { int current = count ( element ) ; if ( occurrences > current ) { return false ; } if ( occurrences = = current ) { if ( countMap . remove ( element , occurrences ) ) { return true ; } } else { @SuppressWarnings ( <str> ) E casted = ( E ) element ; if ( countMap . replace ( casted , current , current - occurrences ) ) { return true ; } } } } @Override public int setCount ( E element , int count ) { checkNonnegative ( count , <str> ) ; return ( count = = <int> ) ? removeAllOccurrences ( element ) : unbox ( countMap . put ( element , count ) ) ; } @Override public boolean setCount ( E element , int oldCount , int newCount ) { checkNonnegative ( oldCount , <str> ) ; checkNonnegative ( newCount , <str> ) ; if ( newCount = = <int> ) { if ( oldCount = = <int> ) { return ! countMap . containsKey ( element ) ; } else { return countMap . remove ( element , oldCount ) ; } } if ( oldCount = = <int> ) { return countMap . putIfAbsent ( element , newCount ) = = null ; } return countMap . replace ( element , oldCount , newCount ) ; } @Override Set < E > createElementSet ( ) { final Set < E > delegate = countMap . keySet ( ) ; return new ForwardingSet < E > ( ) { @Override protected Set < E > delegate ( ) { return delegate ; } @Override public boolean remove ( Object object ) { try { return delegate . remove ( object ) ; } catch ( NullPointerException e ) { return false ; } catch ( ClassCastException e ) { return false ; } } } ; } private transient EntrySet entrySet ; @Override public Set < Multiset . Entry < E > > entrySet ( ) { EntrySet result = entrySet ; if ( result = = null ) { entrySet = result = new EntrySet ( ) ; } return result ; } @Override int distinctElements ( ) { return countMap . size ( ) ; } @Override public boolean isEmpty ( ) { return countMap . isEmpty ( ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < Map . Entry < E , Integer > > backingIterator = countMap . entrySet ( ) . iterator ( ) ; return new Iterator < Entry < E > > ( ) { @Override public boolean hasNext ( ) { return backingIterator . hasNext ( ) ; } @Override public Multiset . Entry < E > next ( ) { Map . Entry < E , Integer > backingEntry = backingIterator . next ( ) ; return Multisets . immutableEntry ( backingEntry . getKey ( ) , backingEntry . getValue ( ) ) ; } @Override public void remove ( ) { backingIterator . remove ( ) ; } } ; } @Override public void clear ( ) { countMap . clear ( ) ; } private class EntrySet extends AbstractMultiset < E > . EntrySet { @Override Multiset < E > multiset ( ) { return OldConcurrentHashMultiset . this ; } @Override public Object [ ] toArray ( ) { return snapshot ( ) . toArray ( ) ; } @Override public < T > T [ ] toArray ( T [ ] array ) { return snapshot ( ) . toArray ( array ) ; } private List < Multiset . Entry < E > > snapshot ( ) { List < Multiset . Entry < E > > list = Lists . newArrayListWithExpectedSize ( size ( ) ) ; Iterators . addAll ( list , iterator ( ) ) ; return list ; } @Override public boolean remove ( Object object ) { if ( object instanceof Multiset . Entry ) { Multiset . Entry < ? > entry = ( Multiset . Entry < ? > ) object ; Object element = entry . getElement ( ) ; int entryCount = entry . getCount ( ) ; return countMap . remove ( element , entryCount ) ; } return false ; } @Override public int hashCode ( ) { return countMap . hashCode ( ) ; } } private static int unbox ( @Nullable Integer i ) { return ( i = = null ) ? <int> : i ; } } } 
