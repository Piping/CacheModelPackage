package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . collect . CollectPreconditions . checkNonnegative ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . MoreObjects ; import com . google . common . primitives . Ints ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . Comparator ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . NoSuchElementException ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) public final class TreeMultiset < E > extends AbstractSortedMultiset < E > implements Serializable { public static < E extends Comparable > TreeMultiset < E > create ( ) { return new TreeMultiset < E > ( Ordering . natural ( ) ) ; } @SuppressWarnings ( <str> ) public static < E > TreeMultiset < E > create ( @Nullable Comparator < ? super E > comparator ) { return ( comparator = = null ) ? new TreeMultiset < E > ( ( Comparator ) Ordering . natural ( ) ) : new TreeMultiset < E > ( comparator ) ; } public static < E extends Comparable > TreeMultiset < E > create ( Iterable < ? extends E > elements ) { TreeMultiset < E > multiset = create ( ) ; Iterables . addAll ( multiset , elements ) ; return multiset ; } private final transient Reference < AvlNode < E > > rootReference ; private final transient GeneralRange < E > range ; private final transient AvlNode < E > header ; TreeMultiset ( Reference < AvlNode < E > > rootReference , GeneralRange < E > range , AvlNode < E > endLink ) { super ( range . comparator ( ) ) ; this . rootReference = rootReference ; this . range = range ; this . header = endLink ; } TreeMultiset ( Comparator < ? super E > comparator ) { super ( comparator ) ; this . range = GeneralRange . all ( comparator ) ; this . header = new AvlNode < E > ( null , <int> ) ; successor ( header , header ) ; this . rootReference = new Reference < AvlNode < E > > ( ) ; } private enum Aggregate { SIZE { @Override int nodeAggregate ( AvlNode < ? > node ) { return node . elemCount ; } @Override long treeAggregate ( @Nullable AvlNode < ? > root ) { return ( root = = null ) ? <int> : root . totalCount ; } } , DISTINCT { @Override int nodeAggregate ( AvlNode < ? > node ) { return <int> ; } @Override long treeAggregate ( @Nullable AvlNode < ? > root ) { return ( root = = null ) ? <int> : root . distinctElements ; } } ; abstract int nodeAggregate ( AvlNode < ? > node ) ; abstract long treeAggregate ( @Nullable AvlNode < ? > root ) ; } private long aggregateForEntries ( Aggregate aggr ) { AvlNode < E > root = rootReference . get ( ) ; long total = aggr . treeAggregate ( root ) ; if ( range . hasLowerBound ( ) ) { total - = aggregateBelowRange ( aggr , root ) ; } if ( range . hasUpperBound ( ) ) { total - = aggregateAboveRange ( aggr , root ) ; } return total ; } private long aggregateBelowRange ( Aggregate aggr , @Nullable AvlNode < E > node ) { if ( node = = null ) { return <int> ; } int cmp = comparator ( ) . compare ( range . getLowerEndpoint ( ) , node . elem ) ; if ( cmp < <int> ) { return aggregateBelowRange ( aggr , node . left ) ; } else if ( cmp = = <int> ) { switch ( range . getLowerBoundType ( ) ) { case OPEN : return aggr . nodeAggregate ( node ) + aggr . treeAggregate ( node . left ) ; case CLOSED : return aggr . treeAggregate ( node . left ) ; default : throw new AssertionError ( ) ; } } else { return aggr . treeAggregate ( node . left ) + aggr . nodeAggregate ( node ) + aggregateBelowRange ( aggr , node . right ) ; } } private long aggregateAboveRange ( Aggregate aggr , @Nullable AvlNode < E > node ) { if ( node = = null ) { return <int> ; } int cmp = comparator ( ) . compare ( range . getUpperEndpoint ( ) , node . elem ) ; if ( cmp > <int> ) { return aggregateAboveRange ( aggr , node . right ) ; } else if ( cmp = = <int> ) { switch ( range . getUpperBoundType ( ) ) { case OPEN : return aggr . nodeAggregate ( node ) + aggr . treeAggregate ( node . right ) ; case CLOSED : return aggr . treeAggregate ( node . right ) ; default : throw new AssertionError ( ) ; } } else { return aggr . treeAggregate ( node . right ) + aggr . nodeAggregate ( node ) + aggregateAboveRange ( aggr , node . left ) ; } } @Override public int size ( ) { return Ints . saturatedCast ( aggregateForEntries ( Aggregate . SIZE ) ) ; } @Override int distinctElements ( ) { return Ints . saturatedCast ( aggregateForEntries ( Aggregate . DISTINCT ) ) ; } @Override public int count ( @Nullable Object element ) { try { @SuppressWarnings ( <str> ) E e = ( E ) element ; AvlNode < E > root = rootReference . get ( ) ; if ( ! range . contains ( e ) | | root = = null ) { return <int> ; } return root . count ( comparator ( ) , e ) ; } catch ( ClassCastException e ) { return <int> ; } catch ( NullPointerException e ) { return <int> ; } } @Override public int add ( @Nullable E element , int occurrences ) { checkNonnegative ( occurrences , <str> ) ; if ( occurrences = = <int> ) { return count ( element ) ; } checkArgument ( range . contains ( element ) ) ; AvlNode < E > root = rootReference . get ( ) ; if ( root = = null ) { comparator ( ) . compare ( element , element ) ; AvlNode < E > newRoot = new AvlNode < E > ( element , occurrences ) ; successor ( header , newRoot , header ) ; rootReference . checkAndSet ( root , newRoot ) ; return <int> ; } int [ ] result = new int [ <int> ] ; AvlNode < E > newRoot = root . add ( comparator ( ) , element , occurrences , result ) ; rootReference . checkAndSet ( root , newRoot ) ; return result [ <int> ] ; } @Override public int remove ( @Nullable Object element , int occurrences ) { checkNonnegative ( occurrences , <str> ) ; if ( occurrences = = <int> ) { return count ( element ) ; } AvlNode < E > root = rootReference . get ( ) ; int [ ] result = new int [ <int> ] ; AvlNode < E > newRoot ; try { @SuppressWarnings ( <str> ) E e = ( E ) element ; if ( ! range . contains ( e ) | | root = = null ) { return <int> ; } newRoot = root . remove ( comparator ( ) , e , occurrences , result ) ; } catch ( ClassCastException e ) { return <int> ; } catch ( NullPointerException e ) { return <int> ; } rootReference . checkAndSet ( root , newRoot ) ; return result [ <int> ] ; } @Override public int setCount ( @Nullable E element , int count ) { checkNonnegative ( count , <str> ) ; if ( ! range . contains ( element ) ) { checkArgument ( count = = <int> ) ; return <int> ; } AvlNode < E > root = rootReference . get ( ) ; if ( root = = null ) { if ( count > <int> ) { add ( element , count ) ; } return <int> ; } int [ ] result = new int [ <int> ] ; AvlNode < E > newRoot = root . setCount ( comparator ( ) , element , count , result ) ; rootReference . checkAndSet ( root , newRoot ) ; return result [ <int> ] ; } @Override public boolean setCount ( @Nullable E element , int oldCount , int newCount ) { checkNonnegative ( newCount , <str> ) ; checkNonnegative ( oldCount , <str> ) ; checkArgument ( range . contains ( element ) ) ; AvlNode < E > root = rootReference . get ( ) ; if ( root = = null ) { if ( oldCount = = <int> ) { if ( newCount > <int> ) { add ( element , newCount ) ; } return true ; } else { return false ; } } int [ ] result = new int [ <int> ] ; AvlNode < E > newRoot = root . setCount ( comparator ( ) , element , oldCount , newCount , result ) ; rootReference . checkAndSet ( root , newRoot ) ; return result [ <int> ] = = oldCount ; } private Entry < E > wrapEntry ( final AvlNode < E > baseEntry ) { return new Multisets . AbstractEntry < E > ( ) { @Override public E getElement ( ) { return baseEntry . getElement ( ) ; } @Override public int getCount ( ) { int result = baseEntry . getCount ( ) ; if ( result = = <int> ) { return count ( getElement ( ) ) ; } else { return result ; } } } ; } @Nullable private AvlNode < E > firstNode ( ) { AvlNode < E > root = rootReference . get ( ) ; if ( root = = null ) { return null ; } AvlNode < E > node ; if ( range . hasLowerBound ( ) ) { E endpoint = range . getLowerEndpoint ( ) ; node = rootReference . get ( ) . ceiling ( comparator ( ) , endpoint ) ; if ( node = = null ) { return null ; } if ( range . getLowerBoundType ( ) = = BoundType . OPEN & & comparator ( ) . compare ( endpoint , node . getElement ( ) ) = = <int> ) { node = node . succ ; } } else { node = header . succ ; } return ( node = = header | | ! range . contains ( node . getElement ( ) ) ) ? null : node ; } @Nullable private AvlNode < E > lastNode ( ) { AvlNode < E > root = rootReference . get ( ) ; if ( root = = null ) { return null ; } AvlNode < E > node ; if ( range . hasUpperBound ( ) ) { E endpoint = range . getUpperEndpoint ( ) ; node = rootReference . get ( ) . floor ( comparator ( ) , endpoint ) ; if ( node = = null ) { return null ; } if ( range . getUpperBoundType ( ) = = BoundType . OPEN & & comparator ( ) . compare ( endpoint , node . getElement ( ) ) = = <int> ) { node = node . pred ; } } else { node = header . pred ; } return ( node = = header | | ! range . contains ( node . getElement ( ) ) ) ? null : node ; } @Override Iterator < Entry < E > > entryIterator ( ) { return new Iterator < Entry < E > > ( ) { AvlNode < E > current = firstNode ( ) ; Entry < E > prevEntry ; @Override public boolean hasNext ( ) { if ( current = = null ) { return false ; } else if ( range . tooHigh ( current . getElement ( ) ) ) { current = null ; return false ; } else { return true ; } } @Override public Entry < E > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } Entry < E > result = wrapEntry ( current ) ; prevEntry = result ; if ( current . succ = = header ) { current = null ; } else { current = current . succ ; } return result ; } @Override public void remove ( ) { checkRemove ( prevEntry ! = null ) ; setCount ( prevEntry . getElement ( ) , <int> ) ; prevEntry = null ; } } ; } @Override Iterator < Entry < E > > descendingEntryIterator ( ) { return new Iterator < Entry < E > > ( ) { AvlNode < E > current = lastNode ( ) ; Entry < E > prevEntry = null ; @Override public boolean hasNext ( ) { if ( current = = null ) { return false ; } else if ( range . tooLow ( current . getElement ( ) ) ) { current = null ; return false ; } else { return true ; } } @Override public Entry < E > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } Entry < E > result = wrapEntry ( current ) ; prevEntry = result ; if ( current . pred = = header ) { current = null ; } else { current = current . pred ; } return result ; } @Override public void remove ( ) { checkRemove ( prevEntry ! = null ) ; setCount ( prevEntry . getElement ( ) , <int> ) ; prevEntry = null ; } } ; } @Override public SortedMultiset < E > headMultiset ( @Nullable E upperBound , BoundType boundType ) { return new TreeMultiset < E > ( rootReference , range . intersect ( GeneralRange . upTo ( comparator ( ) , upperBound , boundType ) ) , header ) ; } @Override public SortedMultiset < E > tailMultiset ( @Nullable E lowerBound , BoundType boundType ) { return new TreeMultiset < E > ( rootReference , range . intersect ( GeneralRange . downTo ( comparator ( ) , lowerBound , boundType ) ) , header ) ; } static int distinctElements ( @Nullable AvlNode < ? > node ) { return ( node = = null ) ? <int> : node . distinctElements ; } private static final class Reference < T > { @Nullable private T value ; @Nullable public T get ( ) { return value ; } public void checkAndSet ( @Nullable T expected , T newValue ) { if ( value ! = expected ) { throw new ConcurrentModificationException ( ) ; } value = newValue ; } } private static final class AvlNode < E > extends Multisets . AbstractEntry < E > { @Nullable private final E elem ; private int elemCount ; private int distinctElements ; private long totalCount ; private int height ; private AvlNode < E > left ; private AvlNode < E > right ; private AvlNode < E > pred ; private AvlNode < E > succ ; AvlNode ( @Nullable E elem , int elemCount ) { checkArgument ( elemCount > <int> ) ; this . elem = elem ; this . elemCount = elemCount ; this . totalCount = elemCount ; this . distinctElements = <int> ; this . height = <int> ; this . left = null ; this . right = null ; } public int count ( Comparator < ? super E > comparator , E e ) { int cmp = comparator . compare ( e , elem ) ; if ( cmp < <int> ) { return ( left = = null ) ? <int> : left . count ( comparator , e ) ; } else if ( cmp > <int> ) { return ( right = = null ) ? <int> : right . count ( comparator , e ) ; } else { return elemCount ; } } private AvlNode < E > addRightChild ( E e , int count ) { right = new AvlNode < E > ( e , count ) ; successor ( this , right , succ ) ; height = Math . max ( <int> , height ) ; distinctElements + + ; totalCount + = count ; return this ; } private AvlNode < E > addLeftChild ( E e , int count ) { left = new AvlNode < E > ( e , count ) ; successor ( pred , left , this ) ; height = Math . max ( <int> , height ) ; distinctElements + + ; totalCount + = count ; return this ; } AvlNode < E > add ( Comparator < ? super E > comparator , @Nullable E e , int count , int [ ] result ) { int cmp = comparator . compare ( e , elem ) ; if ( cmp < <int> ) { AvlNode < E > initLeft = left ; if ( initLeft = = null ) { result [ <int> ] = <int> ; return addLeftChild ( e , count ) ; } int initHeight = initLeft . height ; left = initLeft . add ( comparator , e , count , result ) ; if ( result [ <int> ] = = <int> ) { distinctElements + + ; } this . totalCount + = count ; return ( left . height = = initHeight ) ? this : rebalance ( ) ; } else if ( cmp > <int> ) { AvlNode < E > initRight = right ; if ( initRight = = null ) { result [ <int> ] = <int> ; return addRightChild ( e , count ) ; } int initHeight = initRight . height ; right = initRight . add ( comparator , e , count , result ) ; if ( result [ <int> ] = = <int> ) { distinctElements + + ; } this . totalCount + = count ; return ( right . height = = initHeight ) ? this : rebalance ( ) ; } result [ <int> ] = elemCount ; long resultCount = ( long ) elemCount + count ; checkArgument ( resultCount < = Integer . MAX_VALUE ) ; this . elemCount + = count ; this . totalCount + = count ; return this ; } AvlNode < E > remove ( Comparator < ? super E > comparator , @Nullable E e , int count , int [ ] result ) { int cmp = comparator . compare ( e , elem ) ; if ( cmp < <int> ) { AvlNode < E > initLeft = left ; if ( initLeft = = null ) { result [ <int> ] = <int> ; return this ; } left = initLeft . remove ( comparator , e , count , result ) ; if ( result [ <int> ] > <int> ) { if ( count > = result [ <int> ] ) { this . distinctElements - - ; this . totalCount - = result [ <int> ] ; } else { this . totalCount - = count ; } } return ( result [ <int> ] = = <int> ) ? this : rebalance ( ) ; } else if ( cmp > <int> ) { AvlNode < E > initRight = right ; if ( initRight = = null ) { result [ <int> ] = <int> ; return this ; } right = initRight . remove ( comparator , e , count , result ) ; if ( result [ <int> ] > <int> ) { if ( count > = result [ <int> ] ) { this . distinctElements - - ; this . totalCount - = result [ <int> ] ; } else { this . totalCount - = count ; } } return rebalance ( ) ; } result [ <int> ] = elemCount ; if ( count > = elemCount ) { return deleteMe ( ) ; } else { this . elemCount - = count ; this . totalCount - = count ; return this ; } } AvlNode < E > setCount ( Comparator < ? super E > comparator , @Nullable E e , int count , int [ ] result ) { int cmp = comparator . compare ( e , elem ) ; if ( cmp < <int> ) { AvlNode < E > initLeft = left ; if ( initLeft = = null ) { result [ <int> ] = <int> ; return ( count > <int> ) ? addLeftChild ( e , count ) : this ; } left = initLeft . setCount ( comparator , e , count , result ) ; if ( count = = <int> & & result [ <int> ] ! = <int> ) { this . distinctElements - - ; } else if ( count > <int> & & result [ <int> ] = = <int> ) { this . distinctElements + + ; } this . totalCount + = count - result [ <int> ] ; return rebalance ( ) ; } else if ( cmp > <int> ) { AvlNode < E > initRight = right ; if ( initRight = = null ) { result [ <int> ] = <int> ; return ( count > <int> ) ? addRightChild ( e , count ) : this ; } right = initRight . setCount ( comparator , e , count , result ) ; if ( count = = <int> & & result [ <int> ] ! = <int> ) { this . distinctElements - - ; } else if ( count > <int> & & result [ <int> ] = = <int> ) { this . distinctElements + + ; } this . totalCount + = count - result [ <int> ] ; return rebalance ( ) ; } result [ <int> ] = elemCount ; if ( count = = <int> ) { return deleteMe ( ) ; } this . totalCount + = count - elemCount ; this . elemCount = count ; return this ; } AvlNode < E > setCount ( Comparator < ? super E > comparator , @Nullable E e , int expectedCount , int newCount , int [ ] result ) { int cmp = comparator . compare ( e , elem ) ; if ( cmp < <int> ) { AvlNode < E > initLeft = left ; if ( initLeft = = null ) { result [ <int> ] = <int> ; if ( expectedCount = = <int> & & newCount > <int> ) { return addLeftChild ( e , newCount ) ; } return this ; } left = initLeft . setCount ( comparator , e , expectedCount , newCount , result ) ; if ( result [ <int> ] = = expectedCount ) { if ( newCount = = <int> & & result [ <int> ] ! = <int> ) { this . distinctElements - - ; } else if ( newCount > <int> & & result [ <int> ] = = <int> ) { this . distinctElements + + ; } this . totalCount + = newCount - result [ <int> ] ; } return rebalance ( ) ; } else if ( cmp > <int> ) { AvlNode < E > initRight = right ; if ( initRight = = null ) { result [ <int> ] = <int> ; if ( expectedCount = = <int> & & newCount > <int> ) { return addRightChild ( e , newCount ) ; } return this ; } right = initRight . setCount ( comparator , e , expectedCount , newCount , result ) ; if ( result [ <int> ] = = expectedCount ) { if ( newCount = = <int> & & result [ <int> ] ! = <int> ) { this . distinctElements - - ; } else if ( newCount > <int> & & result [ <int> ] = = <int> ) { this . distinctElements + + ; } this . totalCount + = newCount - result [ <int> ] ; } return rebalance ( ) ; } result [ <int> ] = elemCount ; if ( expectedCount = = elemCount ) { if ( newCount = = <int> ) { return deleteMe ( ) ; } this . totalCount + = newCount - elemCount ; this . elemCount = newCount ; } return this ; } private AvlNode < E > deleteMe ( ) { int oldElemCount = this . elemCount ; this . elemCount = <int> ; successor ( pred , succ ) ; if ( left = = null ) { return right ; } else if ( right = = null ) { return left ; } else if ( left . height > = right . height ) { AvlNode < E > newTop = pred ; newTop . left = left . removeMax ( newTop ) ; newTop . right = right ; newTop . distinctElements = distinctElements - <int> ; newTop . totalCount = totalCount - oldElemCount ; return newTop . rebalance ( ) ; } else { AvlNode < E > newTop = succ ; newTop . right = right . removeMin ( newTop ) ; newTop . left = left ; newTop . distinctElements = distinctElements - <int> ; newTop . totalCount = totalCount - oldElemCount ; return newTop . rebalance ( ) ; } } private AvlNode < E > removeMin ( AvlNode < E > node ) { if ( left = = null ) { return right ; } else { left = left . removeMin ( node ) ; distinctElements - - ; totalCount - = node . elemCount ; return rebalance ( ) ; } } private AvlNode < E > removeMax ( AvlNode < E > node ) { if ( right = = null ) { return left ; } else { right = right . removeMax ( node ) ; distinctElements - - ; totalCount - = node . elemCount ; return rebalance ( ) ; } } private void recomputeMultiset ( ) { this . distinctElements = <int> + TreeMultiset . distinctElements ( left ) + TreeMultiset . distinctElements ( right ) ; this . totalCount = elemCount + totalCount ( left ) + totalCount ( right ) ; } private void recomputeHeight ( ) { this . height = <int> + Math . max ( height ( left ) , height ( right ) ) ; } private void recompute ( ) { recomputeMultiset ( ) ; recomputeHeight ( ) ; } private AvlNode < E > rebalance ( ) { switch ( balanceFactor ( ) ) { case - <int> : if ( right . balanceFactor ( ) > <int> ) { right = right . rotateRight ( ) ; } return rotateLeft ( ) ; case <int> : if ( left . balanceFactor ( ) < <int> ) { left = left . rotateLeft ( ) ; } return rotateRight ( ) ; default : recomputeHeight ( ) ; return this ; } } private int balanceFactor ( ) { return height ( left ) - height ( right ) ; } private AvlNode < E > rotateLeft ( ) { checkState ( right ! = null ) ; AvlNode < E > newTop = right ; this . right = newTop . left ; newTop . left = this ; newTop . totalCount = this . totalCount ; newTop . distinctElements = this . distinctElements ; this . recompute ( ) ; newTop . recomputeHeight ( ) ; return newTop ; } private AvlNode < E > rotateRight ( ) { checkState ( left ! = null ) ; AvlNode < E > newTop = left ; this . left = newTop . right ; newTop . right = this ; newTop . totalCount = this . totalCount ; newTop . distinctElements = this . distinctElements ; this . recompute ( ) ; newTop . recomputeHeight ( ) ; return newTop ; } private static long totalCount ( @Nullable AvlNode < ? > node ) { return ( node = = null ) ? <int> : node . totalCount ; } private static int height ( @Nullable AvlNode < ? > node ) { return ( node = = null ) ? <int> : node . height ; } @Nullable private AvlNode < E > ceiling ( Comparator < ? super E > comparator , E e ) { int cmp = comparator . compare ( e , elem ) ; if ( cmp < <int> ) { return ( left = = null ) ? this : MoreObjects . firstNonNull ( left . ceiling ( comparator , e ) , this ) ; } else if ( cmp = = <int> ) { return this ; } else { return ( right = = null ) ? null : right . ceiling ( comparator , e ) ; } } @Nullable private AvlNode < E > floor ( Comparator < ? super E > comparator , E e ) { int cmp = comparator . compare ( e , elem ) ; if ( cmp > <int> ) { return ( right = = null ) ? this : MoreObjects . firstNonNull ( right . floor ( comparator , e ) , this ) ; } else if ( cmp = = <int> ) { return this ; } else { return ( left = = null ) ? null : left . floor ( comparator , e ) ; } } @Override public E getElement ( ) { return elem ; } @Override public int getCount ( ) { return elemCount ; } @Override public String toString ( ) { return Multisets . immutableEntry ( getElement ( ) , getCount ( ) ) . toString ( ) ; } } private static < T > void successor ( AvlNode < T > a , AvlNode < T > b ) { a . succ = b ; b . pred = a ; } private static < T > void successor ( AvlNode < T > a , AvlNode < T > b , AvlNode < T > c ) { successor ( a , b ) ; successor ( b , c ) ; } @GwtIncompatible ( <str> ) private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; stream . writeObject ( elementSet ( ) . comparator ( ) ) ; Serialization . writeMultiset ( this , stream ) ; } @GwtIncompatible ( <str> ) private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException { stream . defaultReadObject ( ) ; @SuppressWarnings ( <str> ) Comparator < ? super E > comparator = ( Comparator < ? super E > ) stream . readObject ( ) ; Serialization . getFieldSetter ( AbstractSortedMultiset . class , <str> ) . set ( this , comparator ) ; Serialization . getFieldSetter ( TreeMultiset . class , <str> ) . set ( this , GeneralRange . all ( comparator ) ) ; Serialization . getFieldSetter ( TreeMultiset . class , <str> ) . set ( this , new Reference < AvlNode < E > > ( ) ) ; AvlNode < E > header = new AvlNode < E > ( null , <int> ) ; Serialization . getFieldSetter ( TreeMultiset . class , <str> ) . set ( this , header ) ; successor ( header , header ) ; Serialization . populateMultiset ( this , stream ) ; } @GwtIncompatible ( <str> ) private static final long serialVersionUID = <int> ; } 
