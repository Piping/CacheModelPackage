package com . google . common . hash ; import com . google . common . base . Preconditions ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . nio . charset . Charset ; abstract class AbstractNonStreamingHashFunction implements HashFunction { @Override public Hasher newHasher ( ) { return new BufferingHasher ( <int> ) ; } @Override public Hasher newHasher ( int expectedInputSize ) { Preconditions . checkArgument ( expectedInputSize > = <int> ) ; return new BufferingHasher ( expectedInputSize ) ; } @Override public < T > HashCode hashObject ( T instance , Funnel < ? super T > funnel ) { return newHasher ( ) . putObject ( instance , funnel ) . hash ( ) ; } @Override public HashCode hashUnencodedChars ( CharSequence input ) { int len = input . length ( ) ; Hasher hasher = newHasher ( len * <int> ) ; for ( int i = <int> ; i < len ; i + + ) { hasher . putChar ( input . charAt ( i ) ) ; } return hasher . hash ( ) ; } @Override public HashCode hashString ( CharSequence input , Charset charset ) { return hashBytes ( input . toString ( ) . getBytes ( charset ) ) ; } @Override public HashCode hashInt ( int input ) { return newHasher ( <int> ) . putInt ( input ) . hash ( ) ; } @Override public HashCode hashLong ( long input ) { return newHasher ( <int> ) . putLong ( input ) . hash ( ) ; } @Override public HashCode hashBytes ( byte [ ] input ) { return hashBytes ( input , <int> , input . length ) ; } private final class BufferingHasher extends AbstractHasher { final ExposedByteArrayOutputStream stream ; static final int BOTTOM_BYTE = <hex> ; BufferingHasher ( int expectedInputSize ) { this . stream = new ExposedByteArrayOutputStream ( expectedInputSize ) ; } @Override public Hasher putByte ( byte b ) { stream . write ( b ) ; return this ; } @Override public Hasher putBytes ( byte [ ] bytes ) { try { stream . write ( bytes ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return this ; } @Override public Hasher putBytes ( byte [ ] bytes , int off , int len ) { stream . write ( bytes , off , len ) ; return this ; } @Override public Hasher putShort ( short s ) { stream . write ( s & BOTTOM_BYTE ) ; stream . write ( ( s > > > <int> ) & BOTTOM_BYTE ) ; return this ; } @Override public Hasher putInt ( int i ) { stream . write ( i & BOTTOM_BYTE ) ; stream . write ( ( i > > > <int> ) & BOTTOM_BYTE ) ; stream . write ( ( i > > > <int> ) & BOTTOM_BYTE ) ; stream . write ( ( i > > > <int> ) & BOTTOM_BYTE ) ; return this ; } @Override public Hasher putLong ( long l ) { for ( int i = <int> ; i < <int> ; i + = <int> ) { stream . write ( ( byte ) ( ( l > > > i ) & BOTTOM_BYTE ) ) ; } return this ; } @Override public Hasher putChar ( char c ) { stream . write ( c & BOTTOM_BYTE ) ; stream . write ( ( c > > > <int> ) & BOTTOM_BYTE ) ; return this ; } @Override public < T > Hasher putObject ( T instance , Funnel < ? super T > funnel ) { funnel . funnel ( instance , this ) ; return this ; } @Override public HashCode hash ( ) { return hashBytes ( stream . byteArray ( ) , <int> , stream . length ( ) ) ; } } private static final class ExposedByteArrayOutputStream extends ByteArrayOutputStream { ExposedByteArrayOutputStream ( int expectedInputSize ) { super ( expectedInputSize ) ; } byte [ ] byteArray ( ) { return buf ; } int length ( ) { return count ; } } } 
