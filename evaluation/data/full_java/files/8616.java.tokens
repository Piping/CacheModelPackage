package org . elasticsearch . messy . tests ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . lucene . search . function . CombineFunction ; import org . elasticsearch . common . lucene . search . function . FiltersFunctionScoreQuery ; import org . elasticsearch . index . query . MatchAllQueryBuilder ; import org . elasticsearch . index . query . functionscore . FunctionScoreQueryBuilder ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . groovy . GroovyPlugin ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . client . Requests . searchRequest ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . functionScoreQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . index . query . functionscore . ScoreFunctionBuilders . scriptFunction ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . search . builder . SearchSourceBuilder . searchSource ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class FunctionScoreTests extends ESIntegTestCase { static final String TYPE = <str> ; static final String INDEX = <str> ; @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return Collections . singleton ( GroovyPlugin . class ) ; } public void testScriptScoresNested ( ) throws IOException { createIndex ( INDEX ) ; ensureYellow ( ) ; index ( INDEX , TYPE , <str> , jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) ; refresh ( ) ; SearchResponse response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( functionScoreQuery ( functionScoreQuery ( scriptFunction ( new Script ( <str> ) ) ) , scriptFunction ( new Script ( <str> ) ) ) , scriptFunction ( new Script ( <str> ) ) ) ) ) ) . actionGet ( ) ; assertSearchResponse ( response ) ; assertThat ( response . getHits ( ) . getAt ( <int> ) . score ( ) , equalTo ( <float> ) ) ; } public void testScriptScoresWithAgg ( ) throws IOException { createIndex ( INDEX ) ; ensureYellow ( ) ; index ( INDEX , TYPE , <str> , jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) ; refresh ( ) ; SearchResponse response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( scriptFunction ( new Script ( <str> ) ) ) ) . aggregation ( terms ( <str> ) . script ( new Script ( <str> ) ) ) ) ) . actionGet ( ) ; assertSearchResponse ( response ) ; assertThat ( response . getHits ( ) . getAt ( <int> ) . score ( ) , equalTo ( <float> ) ) ; assertThat ( ( ( Terms ) response . getAggregations ( ) . asMap ( ) . get ( <str> ) ) . getBuckets ( ) . get ( <int> ) . getKeyAsString ( ) , equalTo ( <str> ) ) ; assertThat ( ( ( Terms ) response . getAggregations ( ) . asMap ( ) . get ( <str> ) ) . getBuckets ( ) . get ( <int> ) . getDocCount ( ) , is ( <int> ) ) ; } public void testMinScoreFunctionScoreBasic ( ) throws IOException { index ( INDEX , TYPE , jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) ; refresh ( ) ; ensureYellow ( ) ; float score = randomFloat ( ) ; float minScore = randomFloat ( ) ; SearchResponse searchResponse = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( scriptFunction ( new Script ( Float . toString ( score ) ) ) ) . setMinScore ( minScore ) ) ) ) . actionGet ( ) ; if ( score < minScore ) { assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , is ( <int> l ) ) ; } else { assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , is ( <int> ) ) ; } searchResponse = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( new MatchAllQueryBuilder ( ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( new Script ( Float . toString ( score ) ) ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( new Script ( Float . toString ( score ) ) ) ) } ) . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . AVG ) . setMinScore ( minScore ) ) ) ) . actionGet ( ) ; if ( score < minScore ) { assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , is ( <int> l ) ) ; } else { assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , is ( <int> ) ) ; } } public void testMinScoreFunctionScoreManyDocsAndRandomMinScore ( ) throws IOException , ExecutionException , InterruptedException { List < IndexRequestBuilder > docs = new ArrayList < > ( ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; int scoreOffset = randomIntBetween ( - <int> * numDocs , <int> * numDocs ) ; int minScore = randomIntBetween ( - <int> * numDocs , <int> * numDocs ) ; for ( int i = <int> ; i < numDocs ; i + + ) { docs . add ( client ( ) . prepareIndex ( INDEX , TYPE , Integer . toString ( i ) ) . setSource ( <str> , i + scoreOffset ) ) ; } indexRandom ( true , docs ) ; ensureYellow ( ) ; Script script = new Script ( <str> ) ; int numMatchingDocs = numDocs + scoreOffset - minScore ; if ( numMatchingDocs < <int> ) { numMatchingDocs = <int> ; } if ( numMatchingDocs > numDocs ) { numMatchingDocs = numDocs ; } SearchResponse searchResponse = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( scriptFunction ( script ) ) . setMinScore ( minScore ) ) . size ( numDocs ) ) ) . actionGet ( ) ; assertMinScoreSearchResponses ( numDocs , searchResponse , numMatchingDocs ) ; searchResponse = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( new MatchAllQueryBuilder ( ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( script ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( scriptFunction ( script ) ) } ) . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . AVG ) . setMinScore ( minScore ) ) . size ( numDocs ) ) ) . actionGet ( ) ; assertMinScoreSearchResponses ( numDocs , searchResponse , numMatchingDocs ) ; } protected void assertMinScoreSearchResponses ( int numDocs , SearchResponse searchResponse , int numMatchingDocs ) { assertSearchResponse ( searchResponse ) ; assertThat ( ( int ) searchResponse . getHits ( ) . totalHits ( ) , is ( numMatchingDocs ) ) ; int pos = <int> ; for ( int hitId = numDocs - <int> ; ( numDocs - hitId ) < searchResponse . getHits ( ) . totalHits ( ) ; hitId - - ) { assertThat ( searchResponse . getHits ( ) . getAt ( pos ) . getId ( ) , equalTo ( Integer . toString ( hitId ) ) ) ; pos + + ; } } public void testWithEmptyFunctions ( ) throws IOException , ExecutionException , InterruptedException { assertAcked ( prepareCreate ( <str> ) ) ; ensureYellow ( ) ; index ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) ; refresh ( ) ; float termQueryScore = <float> ; for ( CombineFunction combineFunction : CombineFunction . values ( ) ) { testMinScoreApplied ( combineFunction , termQueryScore ) ; } } protected void testMinScoreApplied ( CombineFunction boostMode , float expectedScore ) throws InterruptedException , ExecutionException { SearchResponse response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . explain ( true ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) ) . boostMode ( boostMode ) . setMinScore ( <float> ) ) ) ) . get ( ) ; assertSearchResponse ( response ) ; assertThat ( response . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( response . getHits ( ) . getAt ( <int> ) . getScore ( ) , equalTo ( expectedScore ) ) ; response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . explain ( true ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) ) . boostMode ( boostMode ) . setMinScore ( <float> ) ) ) ) . get ( ) ; assertSearchResponse ( response ) ; assertThat ( response . getHits ( ) . totalHits ( ) , equalTo ( <int> l ) ) ; } } 
