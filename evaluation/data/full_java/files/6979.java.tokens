package org . elasticsearch . rest . action . admin . indices . alias ; import org . elasticsearch . action . admin . indices . alias . IndicesAliasesRequest ; import org . elasticsearch . action . admin . indices . alias . IndicesAliasesRequest . AliasActions ; import org . elasticsearch . action . admin . indices . alias . IndicesAliasesResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . metadata . AliasAction ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . AcknowledgedRestListener ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . rest . RestRequest . Method . POST ; public class RestIndicesAliasesAction extends BaseRestHandler { @Inject public RestIndicesAliasesAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( POST , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) throws Exception { IndicesAliasesRequest indicesAliasesRequest = new IndicesAliasesRequest ( ) ; indicesAliasesRequest . masterNodeTimeout ( request . paramAsTime ( <str> , indicesAliasesRequest . masterNodeTimeout ( ) ) ) ; try ( XContentParser parser = XContentFactory . xContent ( request . content ( ) ) . createParser ( request . content ( ) ) ) { indicesAliasesRequest . timeout ( request . paramAsTime ( <str> , indicesAliasesRequest . timeout ( ) ) ) ; XContentParser . Token token = parser . nextToken ( ) ; if ( token = = null ) { throw new IllegalArgumentException ( <str> ) ; } while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . START_ARRAY ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String action = parser . currentName ( ) ; AliasAction . Type type ; if ( <str> . equals ( action ) ) { type = AliasAction . Type . ADD ; } else if ( <str> . equals ( action ) ) { type = AliasAction . Type . REMOVE ; } else { throw new IllegalArgumentException ( <str> + action + <str> ) ; } String [ ] indices = null ; String [ ] aliases = null ; Map < String , Object > filter = null ; String routing = null ; boolean routingSet = false ; String indexRouting = null ; boolean indexRoutingSet = false ; String searchRouting = null ; boolean searchRoutingSet = false ; String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { indices = new String [ ] { parser . text ( ) } ; } else if ( <str> . equals ( currentFieldName ) ) { aliases = new String [ ] { parser . text ( ) } ; } else if ( <str> . equals ( currentFieldName ) ) { routing = parser . textOrNull ( ) ; routingSet = true ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { indexRouting = parser . textOrNull ( ) ; indexRoutingSet = true ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { searchRouting = parser . textOrNull ( ) ; searchRoutingSet = true ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( <str> . equals ( currentFieldName ) ) { List < String > indexNames = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { String index = parser . text ( ) ; indexNames . add ( index ) ; } indices = indexNames . toArray ( new String [ indexNames . size ( ) ] ) ; } if ( <str> . equals ( currentFieldName ) ) { List < String > aliasNames = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { String alias = parser . text ( ) ; aliasNames . add ( alias ) ; } aliases = aliasNames . toArray ( new String [ aliasNames . size ( ) ] ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( currentFieldName ) ) { filter = parser . mapOrdered ( ) ; } } } if ( type = = AliasAction . Type . ADD ) { AliasActions aliasActions = new AliasActions ( type , indices , aliases ) ; if ( routingSet ) { aliasActions . routing ( routing ) ; } if ( indexRoutingSet ) { aliasActions . indexRouting ( indexRouting ) ; } if ( searchRoutingSet ) { aliasActions . searchRouting ( searchRouting ) ; } indicesAliasesRequest . addAliasAction ( aliasActions ) ; } else if ( type = = AliasAction . Type . REMOVE ) { indicesAliasesRequest . removeAlias ( indices , aliases ) ; } } } } } } client . admin ( ) . indices ( ) . aliases ( indicesAliasesRequest , new AcknowledgedRestListener < IndicesAliasesResponse > ( channel ) ) ; } } 
