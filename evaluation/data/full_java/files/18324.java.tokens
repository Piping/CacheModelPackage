package com . badlogic . gdx . utils ; public class Base64Coder { public static class CharMap { protected final char [ ] encodingMap = new char [ <int> ] ; protected final byte [ ] decodingMap = new byte [ <int> ] ; public CharMap ( char char63 , char char64 ) { int i = <int> ; for ( char c = <str> ; c < = <str> ; c + + ) { encodingMap [ i + + ] = c ; } for ( char c = <str> ; c < = <str> ; c + + ) { encodingMap [ i + + ] = c ; } for ( char c = <str> ; c < = <str> ; c + + ) { encodingMap [ i + + ] = c ; } encodingMap [ i + + ] = char63 ; encodingMap [ i + + ] = char64 ; for ( i = <int> ; i < decodingMap . length ; i + + ) { decodingMap [ i ] = - <int> ; } for ( i = <int> ; i < <int> ; i + + ) { decodingMap [ encodingMap [ i ] ] = ( byte ) i ; } } public byte [ ] getDecodingMap ( ) { return decodingMap ; } public char [ ] getEncodingMap ( ) { return encodingMap ; } } private static final String systemLineSeparator = <str> ; public static final CharMap regularMap = new CharMap ( <str> , <str> ) , urlsafeMap = new CharMap ( <str> , <str> ) ; public static String encodeString ( String s ) { return encodeString ( s , false ) ; } public static String encodeString ( String s , boolean useUrlsafeEncoding ) { return new String ( encode ( s . getBytes ( ) , useUrlsafeEncoding ? urlsafeMap . encodingMap : regularMap . encodingMap ) ) ; } public static String encodeLines ( byte [ ] in ) { return encodeLines ( in , <int> , in . length , <int> , systemLineSeparator , regularMap . encodingMap ) ; } public static String encodeLines ( byte [ ] in , int iOff , int iLen , int lineLen , String lineSeparator , CharMap charMap ) { return encodeLines ( in , iOff , iLen , lineLen , lineSeparator , charMap . encodingMap ) ; } public static String encodeLines ( byte [ ] in , int iOff , int iLen , int lineLen , String lineSeparator , char [ ] charMap ) { int blockLen = ( lineLen * <int> ) / <int> ; if ( blockLen < = <int> ) { throw new IllegalArgumentException ( ) ; } int lines = ( iLen + blockLen - <int> ) / blockLen ; int bufLen = ( ( iLen + <int> ) / <int> ) * <int> + lines * lineSeparator . length ( ) ; StringBuilder buf = new StringBuilder ( bufLen ) ; int ip = <int> ; while ( ip < iLen ) { int l = Math . min ( iLen - ip , blockLen ) ; buf . append ( encode ( in , iOff + ip , l , charMap ) ) ; buf . append ( lineSeparator ) ; ip + = l ; } return buf . toString ( ) ; } public static char [ ] encode ( byte [ ] in ) { return encode ( in , regularMap . encodingMap ) ; } public static char [ ] encode ( byte [ ] in , CharMap charMap ) { return encode ( in , <int> , in . length , charMap ) ; } public static char [ ] encode ( byte [ ] in , char [ ] charMap ) { return encode ( in , <int> , in . length , charMap ) ; } public static char [ ] encode ( byte [ ] in , int iLen ) { return encode ( in , <int> , iLen , regularMap . encodingMap ) ; } public static char [ ] encode ( byte [ ] in , int iOff , int iLen , CharMap charMap ) { return encode ( in , iOff , iLen , charMap . encodingMap ) ; } public static char [ ] encode ( byte [ ] in , int iOff , int iLen , char [ ] charMap ) { int oDataLen = ( iLen * <int> + <int> ) / <int> ; int oLen = ( ( iLen + <int> ) / <int> ) * <int> ; char [ ] out = new char [ oLen ] ; int ip = iOff ; int iEnd = iOff + iLen ; int op = <int> ; while ( ip < iEnd ) { int i0 = in [ ip + + ] & <hex> ; int i1 = ip < iEnd ? in [ ip + + ] & <hex> : <int> ; int i2 = ip < iEnd ? in [ ip + + ] & <hex> : <int> ; int o0 = i0 > > > <int> ; int o1 = ( ( i0 & <int> ) < < <int> ) | ( i1 > > > <int> ) ; int o2 = ( ( i1 & <hex> ) < < <int> ) | ( i2 > > > <int> ) ; int o3 = i2 & <hex> ; out [ op + + ] = charMap [ o0 ] ; out [ op + + ] = charMap [ o1 ] ; out [ op ] = op < oDataLen ? charMap [ o2 ] : <str> ; op + + ; out [ op ] = op < oDataLen ? charMap [ o3 ] : <str> ; op + + ; } return out ; } public static String decodeString ( String s ) { return decodeString ( s , false ) ; } public static String decodeString ( String s , boolean useUrlSafeEncoding ) { return new String ( decode ( s . toCharArray ( ) , useUrlSafeEncoding ? urlsafeMap . decodingMap : regularMap . decodingMap ) ) ; } public static byte [ ] decodeLines ( String s ) { return decodeLines ( s , regularMap . decodingMap ) ; } public static byte [ ] decodeLines ( String s , CharMap inverseCharMap ) { return decodeLines ( s , inverseCharMap . decodingMap ) ; } public static byte [ ] decodeLines ( String s , byte [ ] inverseCharMap ) { char [ ] buf = new char [ s . length ( ) ] ; int p = <int> ; for ( int ip = <int> ; ip < s . length ( ) ; ip + + ) { char c = s . charAt ( ip ) ; if ( c ! = <str> & & c ! = <str> & & c ! = <str> & & c ! = <str> ) { buf [ p + + ] = c ; } } return decode ( buf , <int> , p , inverseCharMap ) ; } public static byte [ ] decode ( String s ) { return decode ( s . toCharArray ( ) ) ; } public static byte [ ] decode ( String s , CharMap inverseCharMap ) { return decode ( s . toCharArray ( ) , inverseCharMap ) ; } public static byte [ ] decode ( char [ ] in , byte [ ] inverseCharMap ) { return decode ( in , <int> , in . length , inverseCharMap ) ; } public static byte [ ] decode ( char [ ] in , CharMap inverseCharMap ) { return decode ( in , <int> , in . length , inverseCharMap ) ; } public static byte [ ] decode ( char [ ] in ) { return decode ( in , <int> , in . length , regularMap . decodingMap ) ; } public static byte [ ] decode ( char [ ] in , int iOff , int iLen , CharMap inverseCharMap ) { return decode ( in , iOff , iLen , inverseCharMap . decodingMap ) ; } public static byte [ ] decode ( char [ ] in , int iOff , int iLen , byte [ ] inverseCharMap ) { if ( iLen % <int> ! = <int> ) { throw new IllegalArgumentException ( <str> ) ; } while ( iLen > <int> & & in [ iOff + iLen - <int> ] = = <str> ) { iLen - - ; } int oLen = ( iLen * <int> ) / <int> ; byte [ ] out = new byte [ oLen ] ; int ip = iOff ; int iEnd = iOff + iLen ; int op = <int> ; while ( ip < iEnd ) { int i0 = in [ ip + + ] ; int i1 = in [ ip + + ] ; int i2 = ip < iEnd ? in [ ip + + ] : <str> ; int i3 = ip < iEnd ? in [ ip + + ] : <str> ; if ( i0 > <int> | | i1 > <int> | | i2 > <int> | | i3 > <int> ) { throw new IllegalArgumentException ( <str> ) ; } int b0 = inverseCharMap [ i0 ] ; int b1 = inverseCharMap [ i1 ] ; int b2 = inverseCharMap [ i2 ] ; int b3 = inverseCharMap [ i3 ] ; if ( b0 < <int> | | b1 < <int> | | b2 < <int> | | b3 < <int> ) { throw new IllegalArgumentException ( <str> ) ; } int o0 = ( b0 < < <int> ) | ( b1 > > > <int> ) ; int o1 = ( ( b1 & <hex> ) < < <int> ) | ( b2 > > > <int> ) ; int o2 = ( ( b2 & <int> ) < < <int> ) | b3 ; out [ op + + ] = ( byte ) o0 ; if ( op < oLen ) { out [ op + + ] = ( byte ) o1 ; } if ( op < oLen ) { out [ op + + ] = ( byte ) o2 ; } } return out ; } private Base64Coder ( ) { } } 
