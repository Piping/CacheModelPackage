package io . netty . channel . epoll ; import static io . netty . channel . unix . NativeInetAddress . ipv4MappedIpv6Address ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . socket . DatagramPacket ; import io . netty . util . concurrent . FastThreadLocal ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . InetSocketAddress ; final class NativeDatagramPacketArray implements ChannelOutboundBuffer . MessageProcessor { private static final FastThreadLocal < NativeDatagramPacketArray > ARRAY = new FastThreadLocal < NativeDatagramPacketArray > ( ) { @Override protected NativeDatagramPacketArray initialValue ( ) throws Exception { return new NativeDatagramPacketArray ( ) ; } @Override protected void onRemoval ( NativeDatagramPacketArray value ) throws Exception { NativeDatagramPacket [ ] array = value . packets ; for ( int i = <int> ; i < array . length ; i + + ) { array [ i ] . release ( ) ; } } } ; private final NativeDatagramPacket [ ] packets = new NativeDatagramPacket [ Native . UIO_MAX_IOV ] ; private int count ; private NativeDatagramPacketArray ( ) { for ( int i = <int> ; i < packets . length ; i + + ) { packets [ i ] = new NativeDatagramPacket ( ) ; } } boolean add ( DatagramPacket packet ) { if ( count = = packets . length ) { return false ; } ByteBuf content = packet . content ( ) ; int len = content . readableBytes ( ) ; if ( len = = <int> ) { return true ; } NativeDatagramPacket p = packets [ count ] ; InetSocketAddress recipient = packet . recipient ( ) ; if ( ! p . init ( content , recipient ) ) { return false ; } count + + ; return true ; } @Override public boolean processMessage ( Object msg ) throws Exception { return msg instanceof DatagramPacket & & add ( ( DatagramPacket ) msg ) ; } int count ( ) { return count ; } NativeDatagramPacket [ ] packets ( ) { return packets ; } static NativeDatagramPacketArray getInstance ( ChannelOutboundBuffer buffer ) throws Exception { NativeDatagramPacketArray array = ARRAY . get ( ) ; array . count = <int> ; buffer . forEachFlushedMessage ( array ) ; return array ; } @SuppressWarnings ( <str> ) static final class NativeDatagramPacket { private final IovArray array = new IovArray ( ) ; private long memoryAddress ; private int count ; private byte [ ] addr ; private int scopeId ; private int port ; private void release ( ) { array . release ( ) ; } private boolean init ( ByteBuf buf , InetSocketAddress recipient ) { array . clear ( ) ; if ( ! array . add ( buf ) ) { return false ; } memoryAddress = array . memoryAddress ( <int> ) ; count = array . count ( ) ; InetAddress address = recipient . getAddress ( ) ; if ( address instanceof Inet6Address ) { addr = address . getAddress ( ) ; scopeId = ( ( Inet6Address ) address ) . getScopeId ( ) ; } else { addr = ipv4MappedIpv6Address ( address . getAddress ( ) ) ; scopeId = <int> ; } port = recipient . getPort ( ) ; return true ; } } } 
