package io . netty . handler . stream ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . FileRegion ; import java . io . File ; import java . io . FileInputStream ; import java . io . IOException ; import java . nio . channels . FileChannel ; public class ChunkedNioFile implements ChunkedInput < ByteBuf > { private final FileChannel in ; private final long startOffset ; private final long endOffset ; private final int chunkSize ; private long offset ; public ChunkedNioFile ( File in ) throws IOException { this ( new FileInputStream ( in ) . getChannel ( ) ) ; } public ChunkedNioFile ( File in , int chunkSize ) throws IOException { this ( new FileInputStream ( in ) . getChannel ( ) , chunkSize ) ; } public ChunkedNioFile ( FileChannel in ) throws IOException { this ( in , ChunkedStream . DEFAULT_CHUNK_SIZE ) ; } public ChunkedNioFile ( FileChannel in , int chunkSize ) throws IOException { this ( in , <int> , in . size ( ) , chunkSize ) ; } public ChunkedNioFile ( FileChannel in , long offset , long length , int chunkSize ) throws IOException { if ( in = = null ) { throw new NullPointerException ( <str> ) ; } if ( offset < <int> ) { throw new IllegalArgumentException ( <str> + offset + <str> ) ; } if ( length < <int> ) { throw new IllegalArgumentException ( <str> + length + <str> ) ; } if ( chunkSize < = <int> ) { throw new IllegalArgumentException ( <str> + chunkSize + <str> ) ; } if ( offset ! = <int> ) { in . position ( offset ) ; } this . in = in ; this . chunkSize = chunkSize ; this . offset = startOffset = offset ; endOffset = offset + length ; } public long startOffset ( ) { return startOffset ; } public long endOffset ( ) { return endOffset ; } public long currentOffset ( ) { return offset ; } @Override public boolean isEndOfInput ( ) throws Exception { return ! ( offset < endOffset & & in . isOpen ( ) ) ; } @Override public void close ( ) throws Exception { in . close ( ) ; } @Override public ByteBuf readChunk ( ChannelHandlerContext ctx ) throws Exception { long offset = this . offset ; if ( offset > = endOffset ) { return null ; } int chunkSize = ( int ) Math . min ( this . chunkSize , endOffset - offset ) ; ByteBuf buffer = ctx . alloc ( ) . buffer ( chunkSize ) ; boolean release = true ; try { int readBytes = <int> ; for ( ; ; ) { int localReadBytes = buffer . writeBytes ( in , chunkSize - readBytes ) ; if ( localReadBytes < <int> ) { break ; } readBytes + = localReadBytes ; if ( readBytes = = chunkSize ) { break ; } } this . offset + = readBytes ; release = false ; return buffer ; } finally { if ( release ) { buffer . release ( ) ; } } } @Override public long length ( ) { return endOffset - startOffset ; } @Override public long progress ( ) { return offset - startOffset ; } } 
