package org . elasticsearch . indices . store ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . EsRejectedExecutionException ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . IndexShardState ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . Closeable ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . EnumSet ; import java . util . List ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; public class IndicesStore extends AbstractComponent implements ClusterStateListener , Closeable { public static final String INDICES_STORE_DELETE_SHARD_TIMEOUT = <str> ; public static final String ACTION_SHARD_EXISTS = <str> ; private static final EnumSet < IndexShardState > ACTIVE_STATES = EnumSet . of ( IndexShardState . STARTED , IndexShardState . RELOCATED ) ; private final IndicesService indicesService ; private final ClusterService clusterService ; private final TransportService transportService ; private TimeValue deleteShardTimeout ; @Inject public IndicesStore ( Settings settings , IndicesService indicesService , ClusterService clusterService , TransportService transportService ) { super ( settings ) ; this . indicesService = indicesService ; this . clusterService = clusterService ; this . transportService = transportService ; transportService . registerRequestHandler ( ACTION_SHARD_EXISTS , ShardActiveRequest : : new , ThreadPool . Names . SAME , new ShardActiveRequestHandler ( ) ) ; this . deleteShardTimeout = settings . getAsTime ( INDICES_STORE_DELETE_SHARD_TIMEOUT , new TimeValue ( <int> , TimeUnit . SECONDS ) ) ; clusterService . addLast ( this ) ; } IndicesStore ( ) { super ( Settings . EMPTY ) ; indicesService = null ; this . clusterService = null ; this . transportService = null ; } @Override public void close ( ) { clusterService . remove ( this ) ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { if ( ! event . routingTableChanged ( ) ) { return ; } if ( event . state ( ) . blocks ( ) . disableStatePersistence ( ) ) { return ; } for ( IndexRoutingTable indexRoutingTable : event . state ( ) . routingTable ( ) ) { IndexSettings indexSettings = new IndexSettings ( event . state ( ) . getMetaData ( ) . index ( indexRoutingTable . index ( ) ) , settings , Collections . emptyList ( ) ) ; for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { if ( shardCanBeDeleted ( event . state ( ) , indexShardRoutingTable ) ) { ShardId shardId = indexShardRoutingTable . shardId ( ) ; if ( indicesService . canDeleteShardContent ( shardId , indexSettings ) ) { deleteShardIfExistElseWhere ( event . state ( ) , indexShardRoutingTable ) ; } } } } } boolean shardCanBeDeleted ( ClusterState state , IndexShardRoutingTable indexShardRoutingTable ) { if ( indexShardRoutingTable . size ( ) = = <int> ) { return false ; } for ( ShardRouting shardRouting : indexShardRoutingTable ) { if ( ! shardRouting . started ( ) ) { return false ; } DiscoveryNode node = state . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) ; if ( node = = null ) { return false ; } if ( shardRouting . relocatingNodeId ( ) ! = null ) { node = state . nodes ( ) . get ( shardRouting . relocatingNodeId ( ) ) ; if ( node = = null ) { return false ; } } String localNodeId = state . getNodes ( ) . localNode ( ) . id ( ) ; if ( localNodeId . equals ( shardRouting . currentNodeId ( ) ) | | localNodeId . equals ( shardRouting . relocatingNodeId ( ) ) ) { return false ; } } return true ; } private void deleteShardIfExistElseWhere ( ClusterState state , IndexShardRoutingTable indexShardRoutingTable ) { List < Tuple < DiscoveryNode , ShardActiveRequest > > requests = new ArrayList < > ( indexShardRoutingTable . size ( ) ) ; String indexUUID = state . getMetaData ( ) . index ( indexShardRoutingTable . shardId ( ) . getIndex ( ) ) . getIndexUUID ( ) ; ClusterName clusterName = state . getClusterName ( ) ; for ( ShardRouting shardRouting : indexShardRoutingTable ) { DiscoveryNode currentNode = state . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) ; assert currentNode ! = null ; requests . add ( new Tuple < > ( currentNode , new ShardActiveRequest ( clusterName , indexUUID , shardRouting . shardId ( ) , deleteShardTimeout ) ) ) ; if ( shardRouting . relocatingNodeId ( ) ! = null ) { DiscoveryNode relocatingNode = state . nodes ( ) . get ( shardRouting . relocatingNodeId ( ) ) ; assert relocatingNode ! = null ; requests . add ( new Tuple < > ( relocatingNode , new ShardActiveRequest ( clusterName , indexUUID , shardRouting . shardId ( ) , deleteShardTimeout ) ) ) ; } } ShardActiveResponseHandler responseHandler = new ShardActiveResponseHandler ( indexShardRoutingTable . shardId ( ) , state , requests . size ( ) ) ; for ( Tuple < DiscoveryNode , ShardActiveRequest > request : requests ) { logger . trace ( <str> , request . v2 ( ) . shardId , request . v1 ( ) ) ; transportService . sendRequest ( request . v1 ( ) , ACTION_SHARD_EXISTS , request . v2 ( ) , responseHandler ) ; } } private class ShardActiveResponseHandler implements TransportResponseHandler < ShardActiveResponse > { private final ShardId shardId ; private final int expectedActiveCopies ; private final ClusterState clusterState ; private final AtomicInteger awaitingResponses ; private final AtomicInteger activeCopies ; public ShardActiveResponseHandler ( ShardId shardId , ClusterState clusterState , int expectedActiveCopies ) { this . shardId = shardId ; this . expectedActiveCopies = expectedActiveCopies ; this . clusterState = clusterState ; this . awaitingResponses = new AtomicInteger ( expectedActiveCopies ) ; this . activeCopies = new AtomicInteger ( ) ; } @Override public ShardActiveResponse newInstance ( ) { return new ShardActiveResponse ( ) ; } @Override public void handleResponse ( ShardActiveResponse response ) { logger . trace ( <str> , shardId , response . shardActive ? <str> : <str> , response . node ) ; if ( response . shardActive ) { activeCopies . incrementAndGet ( ) ; } if ( awaitingResponses . decrementAndGet ( ) = = <int> ) { allNodesResponded ( ) ; } } @Override public void handleException ( TransportException exp ) { logger . debug ( <str> , exp , shardId ) ; if ( awaitingResponses . decrementAndGet ( ) = = <int> ) { allNodesResponded ( ) ; } } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } private void allNodesResponded ( ) { if ( activeCopies . get ( ) ! = expectedActiveCopies ) { logger . trace ( <str> , shardId , expectedActiveCopies , activeCopies . get ( ) ) ; return ; } ClusterState latestClusterState = clusterService . state ( ) ; if ( clusterState . getVersion ( ) ! = latestClusterState . getVersion ( ) ) { logger . trace ( <str> , shardId , latestClusterState . getVersion ( ) , clusterState . getVersion ( ) ) ; return ; } clusterService . submitStateUpdateTask ( <str> + shardId + <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) throws Exception { if ( clusterState . getVersion ( ) ! = currentState . getVersion ( ) ) { logger . trace ( <str> , shardId , currentState . getVersion ( ) , clusterState . getVersion ( ) ) ; return currentState ; } try { indicesService . deleteShardStore ( <str> , shardId , currentState ) ; } catch ( Throwable ex ) { logger . debug ( <str> , ex , shardId ) ; } return currentState ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , shardId ) ; } } ) ; } } private class ShardActiveRequestHandler implements TransportRequestHandler < ShardActiveRequest > { @Override public void messageReceived ( final ShardActiveRequest request , final TransportChannel channel ) throws Exception { IndexShard indexShard = getShard ( request ) ; if ( indexShard = = null ) { channel . sendResponse ( new ShardActiveResponse ( false , clusterService . localNode ( ) ) ) ; } else { ClusterStateObserver observer = new ClusterStateObserver ( clusterService , request . timeout , logger ) ; boolean shardActive = shardActive ( indexShard ) ; if ( shardActive ) { channel . sendResponse ( new ShardActiveResponse ( true , clusterService . localNode ( ) ) ) ; } else { observer . waitForNextChange ( new ClusterStateObserver . Listener ( ) { @Override public void onNewClusterState ( ClusterState state ) { sendResult ( shardActive ( getShard ( request ) ) ) ; } @Override public void onClusterServiceClose ( ) { sendResult ( false ) ; } @Override public void onTimeout ( TimeValue timeout ) { sendResult ( shardActive ( getShard ( request ) ) ) ; } public void sendResult ( boolean shardActive ) { try { channel . sendResponse ( new ShardActiveResponse ( shardActive , clusterService . localNode ( ) ) ) ; } catch ( IOException e ) { logger . error ( <str> , e , request . shardId ) ; } catch ( EsRejectedExecutionException e ) { logger . error ( <str> , e , request . shardId ) ; } } } , new ClusterStateObserver . ValidationPredicate ( ) { @Override protected boolean validate ( ClusterState newState ) { IndexShard indexShard = getShard ( request ) ; return indexShard = = null | | shardActive ( indexShard ) ; } } ) ; } } } private boolean shardActive ( IndexShard indexShard ) { if ( indexShard ! = null ) { return ACTIVE_STATES . contains ( indexShard . state ( ) ) ; } return false ; } private IndexShard getShard ( ShardActiveRequest request ) { ClusterName thisClusterName = clusterService . state ( ) . getClusterName ( ) ; if ( ! thisClusterName . equals ( request . clusterName ) ) { logger . trace ( <str> , request . clusterName , thisClusterName ) ; return null ; } ShardId shardId = request . shardId ; IndexService indexService = indicesService . indexService ( shardId . index ( ) . getName ( ) ) ; if ( indexService ! = null & & indexService . indexUUID ( ) . equals ( request . indexUUID ) ) { return indexService . getShardOrNull ( shardId . id ( ) ) ; } return null ; } } private static class ShardActiveRequest extends TransportRequest { protected TimeValue timeout = null ; private ClusterName clusterName ; private String indexUUID ; private ShardId shardId ; public ShardActiveRequest ( ) { } ShardActiveRequest ( ClusterName clusterName , String indexUUID , ShardId shardId , TimeValue timeout ) { this . shardId = shardId ; this . indexUUID = indexUUID ; this . clusterName = clusterName ; this . timeout = timeout ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; clusterName = ClusterName . readClusterName ( in ) ; indexUUID = in . readString ( ) ; shardId = ShardId . readShardId ( in ) ; timeout = new TimeValue ( in . readLong ( ) , TimeUnit . MILLISECONDS ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; clusterName . writeTo ( out ) ; out . writeString ( indexUUID ) ; shardId . writeTo ( out ) ; out . writeLong ( timeout . millis ( ) ) ; } } private static class ShardActiveResponse extends TransportResponse { private boolean shardActive ; private DiscoveryNode node ; ShardActiveResponse ( ) { } ShardActiveResponse ( boolean shardActive , DiscoveryNode node ) { this . shardActive = shardActive ; this . node = node ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; shardActive = in . readBoolean ( ) ; node = DiscoveryNode . readNode ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeBoolean ( shardActive ) ; node . writeTo ( out ) ; } } } 
