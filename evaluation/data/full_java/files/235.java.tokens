package org . apache . cassandra . cql3 . statements ; import org . apache . cassandra . auth . Permission ; import org . apache . cassandra . auth . RoleResource ; import org . apache . cassandra . cql3 . CQLStatement ; import org . apache . cassandra . cql3 . QueryOptions ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . exceptions . UnauthorizedException ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . transport . messages . ResultMessage ; public abstract class AuthenticationStatement extends ParsedStatement implements CQLStatement { @Override public Prepared prepare ( ) { return new Prepared ( this ) ; } public int getBoundTerms ( ) { return <int> ; } public ResultMessage execute ( QueryState state , QueryOptions options ) throws RequestExecutionException , RequestValidationException { return execute ( state . getClientState ( ) ) ; } public abstract ResultMessage execute ( ClientState state ) throws RequestExecutionException , RequestValidationException ; public ResultMessage executeInternal ( QueryState state , QueryOptions options ) { throw new UnsupportedOperationException ( ) ; } public void checkPermission ( ClientState state , Permission required , RoleResource resource ) throws UnauthorizedException { try { state . ensureHasPermission ( required , resource ) ; } catch ( UnauthorizedException e ) { throw new UnauthorizedException ( String . format ( <str> + <str> , state . getUser ( ) . getName ( ) ) ) ; } } } 
