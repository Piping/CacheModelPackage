package org . elasticsearch . bootstrap ; import com . carrotsearch . randomizedtesting . RandomizedRunner ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . TestSecurityManager ; import org . elasticsearch . SecureSM ; import org . elasticsearch . bootstrap . Bootstrap ; import org . elasticsearch . bootstrap . ESPolicy ; import org . elasticsearch . bootstrap . Security ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . plugins . PluginInfo ; import org . junit . Assert ; import java . io . FilePermission ; import java . io . InputStream ; import java . net . SocketPermission ; import java . net . URL ; import java . nio . file . Path ; import java . security . Permission ; import java . security . Permissions ; import java . security . Policy ; import java . security . ProtectionDomain ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Objects ; import java . util . Properties ; import java . util . Set ; import static com . carrotsearch . randomizedtesting . RandomizedTest . systemPropertyAsBoolean ; public class BootstrapForTesting { static { Path javaTmpDir = PathUtils . get ( Objects . requireNonNull ( System . getProperty ( <str> ) , <str> ) ) ; try { Security . ensureDirectoryExists ( javaTmpDir ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } Bootstrap . initializeNatives ( javaTmpDir , true , true , true ) ; Bootstrap . initializeProbes ( ) ; BootstrapInfo . getSystemProperties ( ) ; try { JarHell . checkJarHell ( ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } if ( systemPropertyAsBoolean ( <str> , true ) ) { try { Permissions perms = new Permissions ( ) ; Security . addClasspathPermissions ( perms ) ; for ( URL url : JarHell . parseClassPath ( ) ) { Path path = PathUtils . get ( url . toURI ( ) ) ; String filename = path . getFileName ( ) . toString ( ) ; if ( filename . contains ( <str> ) & & filename . endsWith ( <str> ) ) { perms . add ( new FilePermission ( path . getParent ( ) . toString ( ) , <str> ) ) ; perms . add ( new FilePermission ( path . getParent ( ) . resolve ( <str> ) . toString ( ) , <str> ) ) ; } } Security . addPath ( perms , <str> , javaTmpDir , <str> ) ; if ( Strings . hasLength ( System . getProperty ( <str> ) ) ) { perms . add ( new FilePermission ( System . getProperty ( <str> ) , <str> ) ) ; } if ( Boolean . getBoolean ( <str> ) ) { Path coverageDir = PathUtils . get ( System . getProperty ( <str> ) ) ; perms . add ( new FilePermission ( coverageDir . resolve ( <str> ) . toString ( ) , <str> ) ) ; perms . add ( new FilePermission ( coverageDir . resolve ( <str> ) . toString ( ) , <str> ) ) ; } if ( System . getProperty ( <str> ) = = null ) { perms . add ( new RuntimePermission ( <str> ) ) ; } perms . add ( new SocketPermission ( <str> , <str> ) ) ; perms . add ( new SocketPermission ( <str> , <str> ) ) ; final Policy testFramework = Security . readPolicy ( Bootstrap . class . getResource ( <str> ) , JarHell . parseClassPath ( ) ) ; final Policy esPolicy = new ESPolicy ( perms , getPluginPermissions ( ) , true ) ; Policy . setPolicy ( new Policy ( ) { @Override public boolean implies ( ProtectionDomain domain , Permission permission ) { return esPolicy . implies ( domain , permission ) | | testFramework . implies ( domain , permission ) ; } } ) ; System . setSecurityManager ( new SecureSM ( true ) ) ; Security . selfTest ( ) ; for ( URL url : Collections . list ( BootstrapForTesting . class . getClassLoader ( ) . getResources ( PluginInfo . ES_PLUGIN_PROPERTIES ) ) ) { Properties properties = new Properties ( ) ; try ( InputStream stream = url . openStream ( ) ) { properties . load ( stream ) ; } if ( Boolean . parseBoolean ( properties . getProperty ( <str> ) ) ) { String clazz = properties . getProperty ( <str> ) ; if ( clazz ! = null ) { Class . forName ( clazz ) ; } } } } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } } } @SuppressForbidden ( reason = <str> ) static Map < String , Policy > getPluginPermissions ( ) throws Exception { List < URL > pluginPolicies = Collections . list ( BootstrapForTesting . class . getClassLoader ( ) . getResources ( PluginInfo . ES_PLUGIN_POLICY ) ) ; if ( pluginPolicies . isEmpty ( ) ) { return Collections . emptyMap ( ) ; } Set < URL > codebases = new HashSet < > ( Arrays . asList ( parseClassPathWithSymlinks ( ) ) ) ; Set < URL > excluded = new HashSet < > ( Arrays . asList ( Bootstrap . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) , BootstrapForTesting . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) , LuceneTestCase . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) , RandomizedRunner . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) , Assert . class . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) ) ) ; codebases . removeAll ( excluded ) ; final List < Policy > policies = new ArrayList < > ( ) ; for ( URL policyFile : pluginPolicies ) { policies . add ( Security . readPolicy ( policyFile , codebases . toArray ( new URL [ codebases . size ( ) ] ) ) ) ; } Map < String , Policy > map = new HashMap < > ( ) ; for ( URL url : codebases ) { map . put ( url . getFile ( ) , new Policy ( ) { @Override public boolean implies ( ProtectionDomain domain , Permission permission ) { for ( Policy p : policies ) { if ( p . implies ( domain , permission ) ) { return true ; } } return false ; } } ) ; } return Collections . unmodifiableMap ( map ) ; } @SuppressForbidden ( reason = <str> ) static URL [ ] parseClassPathWithSymlinks ( ) throws Exception { URL raw [ ] = JarHell . parseClassPath ( ) ; for ( int i = <int> ; i < raw . length ; i + + ) { raw [ i ] = PathUtils . get ( raw [ i ] . toURI ( ) ) . toRealPath ( ) . toUri ( ) . toURL ( ) ; } return raw ; } public static void ensureInitialized ( ) { } } 
