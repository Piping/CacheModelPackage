package org . junit . tests . experimental . theories . runner ; import static org . hamcrest . CoreMatchers . allOf ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; import static org . junit . experimental . results . PrintableResult . testResult ; import static org . junit . experimental . results . ResultMatchers . failureCountIs ; import static org . junit . experimental . results . ResultMatchers . hasFailureContaining ; import static org . junit . experimental . results . ResultMatchers . hasSingleFailureContaining ; import org . hamcrest . CoreMatchers ; import org . junit . Test ; import org . junit . experimental . results . PrintableResult ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . DataPoints ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . runner . RunWith ; import org . junit . runners . model . TestClass ; public class UnsuccessfulWithDataPointFields { @RunWith ( Theories . class ) public static class HasAFailingTheory { @DataPoint public static int ONE = <int> ; @Theory public void everythingIsZero ( int x ) { assertThat ( x , is ( <int> ) ) ; } } @Test public void theoryClassMethodsShowUp ( ) throws Exception { assertThat ( new Theories ( HasAFailingTheory . class ) . getDescription ( ) . getChildren ( ) . size ( ) , is ( <int> ) ) ; } @Test public void theoryAnnotationsAreRetained ( ) throws Exception { assertThat ( new TestClass ( HasAFailingTheory . class ) . getAnnotatedMethods ( Theory . class ) . size ( ) , is ( <int> ) ) ; } @Test public void canRunTheories ( ) throws Exception { assertThat ( testResult ( HasAFailingTheory . class ) , hasSingleFailureContaining ( <str> ) ) ; } @RunWith ( Theories . class ) public static class DoesntUseParams { @DataPoint public static int ONE = <int> ; @Theory public void everythingIsZero ( int x , int y ) { assertThat ( <int> , is ( <int> ) ) ; } } @Test public void reportBadParams ( ) throws Exception { assertThat ( testResult ( DoesntUseParams . class ) , hasSingleFailureContaining ( <str> ) ) ; } @RunWith ( Theories . class ) public static class NullsOK { @DataPoint public static String NULL = null ; @DataPoint public static String A = <str> ; @Theory public void everythingIsA ( String a ) { assertThat ( a , is ( <str> ) ) ; } } @Test public void nullsUsedUnlessProhibited ( ) throws Exception { assertThat ( testResult ( NullsOK . class ) , hasSingleFailureContaining ( <str> ) ) ; } @RunWith ( Theories . class ) public static class TheoriesMustBePublic { @DataPoint public static int THREE = <int> ; @Theory void numbers ( int x ) { } } @Test public void theoriesMustBePublic ( ) { assertThat ( testResult ( TheoriesMustBePublic . class ) , hasSingleFailureContaining ( <str> ) ) ; } @RunWith ( Theories . class ) public static class DataPointFieldsMustBeStatic { @DataPoint public int THREE = <int> ; @DataPoints public int [ ] FOURS = new int [ ] { <int> } ; @Theory public void numbers ( int x ) { } } @Test public void dataPointFieldsMustBeStatic ( ) { assertThat ( testResult ( DataPointFieldsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( failureCountIs ( <int> ) ) . and ( hasFailureContaining ( <str> ) ) . and ( hasFailureContaining ( <str> ) ) ) ; } @RunWith ( Theories . class ) public static class DataPointMethodsMustBeStatic { @DataPoint public int singleDataPointMethod ( ) { return <int> ; } @DataPoints public int [ ] dataPointArrayMethod ( ) { return new int [ ] { <int> , <int> , <int> } ; } @Theory public void numbers ( int x ) { } } @Test public void dataPointMethodsMustBeStatic ( ) { assertThat ( testResult ( DataPointMethodsMustBeStatic . class ) , CoreMatchers . < PrintableResult > both ( failureCountIs ( <int> ) ) . and ( hasFailureContaining ( <str> ) ) . and ( hasFailureContaining ( <str> ) ) ) ; } @RunWith ( Theories . class ) public static class DataPointFieldsMustBePublic { @DataPoint static int THREE = <int> ; @DataPoints static int [ ] THREES = new int [ ] { <int> } ; @DataPoint protected static int FOUR = <int> ; @DataPoints protected static int [ ] FOURS = new int [ ] { <int> } ; @DataPoint private static int FIVE = <int> ; @DataPoints private static int [ ] FIVES = new int [ ] { <int> } ; @Theory public void numbers ( int x ) { } } @Test public void dataPointFieldsMustBePublic ( ) { PrintableResult result = testResult ( DataPointFieldsMustBePublic . class ) ; assertEquals ( <int> , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) ) ) ; } @RunWith ( Theories . class ) public static class DataPointMethodsMustBePublic { @DataPoint static int three ( ) { return <int> ; } @DataPoints static int [ ] threes ( ) { return new int [ ] { <int> } ; } @DataPoint protected static int four ( ) { return <int> ; } @DataPoints protected static int [ ] fours ( ) { return new int [ ] { <int> } ; } @DataPoint private static int five ( ) { return <int> ; } @DataPoints private static int [ ] fives ( ) { return new int [ ] { <int> } ; } @Theory public void numbers ( int x ) { } } @Test public void dataPointMethodsMustBePublic ( ) { PrintableResult result = testResult ( DataPointMethodsMustBePublic . class ) ; assertEquals ( <int> , result . failureCount ( ) ) ; assertThat ( result , allOf ( hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) , hasFailureContaining ( <str> ) ) ) ; } } 
