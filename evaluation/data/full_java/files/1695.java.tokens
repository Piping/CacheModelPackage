package org . apache . cassandra . stress . generate ; import java . nio . ByteBuffer ; import java . util . ArrayDeque ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Deque ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . Queue ; import java . util . Set ; import java . util . UUID ; import java . util . concurrent . ThreadLocalRandom ; import com . google . common . collect . Iterables ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . stress . generate . values . Generator ; import org . apache . cassandra . utils . Pair ; public abstract class PartitionIterator implements Iterator < Row > { abstract boolean reset ( double useChance , double rowPopulationRatio , int targetCount , boolean isWrite , PartitionGenerator . Order order ) ; public abstract Pair < Row , Row > resetToBounds ( Seed seed , int clusteringComponentDepth ) ; PartitionGenerator . Order order ; long idseed ; Seed seed ; final PartitionGenerator generator ; final SeedManager seedManager ; final Object [ ] partitionKey ; final Row row ; public static PartitionIterator get ( PartitionGenerator generator , SeedManager seedManager ) { if ( generator . clusteringComponents . size ( ) > <int> ) return new MultiRowIterator ( generator , seedManager ) ; else return new SingleRowIterator ( generator , seedManager ) ; } private PartitionIterator ( PartitionGenerator generator , SeedManager seedManager ) { this . generator = generator ; this . seedManager = seedManager ; this . partitionKey = new Object [ generator . partitionKey . size ( ) ] ; this . row = new Row ( partitionKey , new Object [ generator . clusteringComponents . size ( ) + generator . valueComponents . size ( ) ] ) ; } void setSeed ( Seed seed ) { long idseed = <int> ; for ( int i = <int> ; i < partitionKey . length ; i + + ) { Generator generator = this . generator . partitionKey . get ( i ) ; generator . setSeed ( seed . seed ) ; Object key = generator . generate ( ) ; partitionKey [ i ] = key ; idseed = seed ( key , generator . type , idseed ) ; } this . seed = seed ; this . idseed = idseed ; } public boolean reset ( Seed seed , double useChance , double rowPopulationRatio , boolean isWrite ) { setSeed ( seed ) ; this . order = generator . order ; return reset ( useChance , rowPopulationRatio , <int> , isWrite , PartitionIterator . this . order ) ; } public boolean reset ( Seed seed , int targetCount , double rowPopulationRatio , boolean isWrite ) { setSeed ( seed ) ; this . order = generator . order ; return reset ( Double . NaN , rowPopulationRatio , targetCount , isWrite , PartitionIterator . this . order ) ; } static class SingleRowIterator extends PartitionIterator { boolean done ; boolean isWrite ; double rowPopulationRatio ; final double totalValueColumns ; private SingleRowIterator ( PartitionGenerator generator , SeedManager seedManager ) { super ( generator , seedManager ) ; this . totalValueColumns = generator . valueComponents . size ( ) ; } public Pair < Row , Row > resetToBounds ( Seed seed , int clusteringComponentDepth ) { assert clusteringComponentDepth = = <int> ; setSeed ( seed ) ; reset ( <float> , <float> , <int> , false , PartitionGenerator . Order . SORTED ) ; return Pair . create ( new Row ( partitionKey ) , new Row ( partitionKey ) ) ; } boolean reset ( double useChance , double rowPopulationRatio , int targetCount , boolean isWrite , PartitionGenerator . Order order ) { done = false ; this . isWrite = isWrite ; this . rowPopulationRatio = rowPopulationRatio ; return true ; } public boolean hasNext ( ) { return ! done ; } public Row next ( ) { if ( done ) throw new NoSuchElementException ( ) ; double valueColumn = <float> ; for ( int i = <int> ; i < row . row . length ; i + + ) { if ( generator . permitNulls ( i ) & & ( + + valueColumn / totalValueColumns ) > rowPopulationRatio ) { row . row [ i ] = null ; } else { Generator gen = generator . valueComponents . get ( i ) ; gen . setSeed ( idseed ) ; row . row [ i ] = gen . generate ( ) ; } } done = true ; if ( isWrite ) { seedManager . markFirstWrite ( seed , true ) ; seedManager . markLastWrite ( seed , true ) ; } return row ; } } static class MultiRowIterator extends PartitionIterator { final long [ ] clusteringSeeds = new long [ generator . clusteringComponents . size ( ) ] ; final Deque < Object > [ ] clusteringComponents = new ArrayDeque [ generator . clusteringComponents . size ( ) ] ; double useChance ; double rowPopulationRatio ; final double totalValueColumns ; final double [ ] chancemodifier = new double [ generator . clusteringComponents . size ( ) ] ; final double [ ] rollmodifier = new double [ generator . clusteringComponents . size ( ) ] ; final int [ ] currentRow = new int [ generator . clusteringComponents . size ( ) ] ; final int [ ] lastRow = new int [ currentRow . length ] ; boolean hasNext , isFirstWrite , isWrite ; final Set < Object > unique = new HashSet < > ( ) ; final List < Object > tosort = new ArrayList < > ( ) ; MultiRowIterator ( PartitionGenerator generator , SeedManager seedManager ) { super ( generator , seedManager ) ; for ( int i = <int> ; i < clusteringComponents . length ; i + + ) clusteringComponents [ i ] = new ArrayDeque < > ( ) ; rollmodifier [ <int> ] = <float> ; chancemodifier [ <int> ] = generator . clusteringDescendantAverages [ <int> ] ; this . totalValueColumns = generator . valueComponents . size ( ) ; } boolean reset ( double useChance , double rowPopulationRatio , int targetCount , boolean isWrite , PartitionGenerator . Order order ) { this . isWrite = isWrite ; this . rowPopulationRatio = rowPopulationRatio ; this . order = order ; generator . clusteringComponents . get ( <int> ) . setSeed ( idseed ) ; int firstComponentCount = ( int ) generator . clusteringComponents . get ( <int> ) . clusteringDistribution . next ( ) ; int expectedRowCount ; int position = seed . position ( ) ; if ( isWrite ) expectedRowCount = firstComponentCount * generator . clusteringDescendantAverages [ <int> ] ; else if ( position ! = <int> ) expectedRowCount = setLastRow ( position - <int> ) ; else expectedRowCount = setNoLastRow ( firstComponentCount ) ; if ( Double . isNaN ( useChance ) ) useChance = Math . max ( <float> , Math . min ( <float> , targetCount / ( double ) expectedRowCount ) ) ; setUseChance ( useChance ) ; while ( true ) { for ( Queue < ? > q : clusteringComponents ) q . clear ( ) ; fill ( <int> ) ; if ( ! isWrite ) { if ( seek ( <int> ) ! = State . SUCCESS ) throw new IllegalStateException ( ) ; return true ; } int count = seed . visits = = <int> ? <int> + ( int ) generator . maxRowCount : Math . max ( <int> , expectedRowCount / seed . visits ) ; position = seed . moveForwards ( count ) ; isFirstWrite = position = = <int> ; setLastRow ( position + count - <int> ) ; switch ( seek ( position ) ) { case END_OF_PARTITION : return false ; case SUCCESS : return true ; } } } void setUseChance ( double useChance ) { if ( this . useChance < <float> ) { Arrays . fill ( rollmodifier , <float> ) ; Arrays . fill ( chancemodifier , <float> ) ; } this . useChance = useChance ; } public Pair < Row , Row > resetToBounds ( Seed seed , int clusteringComponentDepth ) { setSeed ( seed ) ; setUseChance ( <float> ) ; if ( clusteringComponentDepth = = <int> ) { reset ( <float> , <float> , - <int> , false , PartitionGenerator . Order . SORTED ) ; return Pair . create ( new Row ( partitionKey ) , new Row ( partitionKey ) ) ; } this . order = PartitionGenerator . Order . SORTED ; assert clusteringComponentDepth < = clusteringComponents . length ; for ( Queue < ? > q : clusteringComponents ) q . clear ( ) ; fill ( <int> ) ; Pair < int [ ] , Object [ ] > bound1 = randomBound ( clusteringComponentDepth ) ; Pair < int [ ] , Object [ ] > bound2 = randomBound ( clusteringComponentDepth ) ; if ( compare ( bound1 . left , bound2 . left ) > <int> ) { Pair < int [ ] , Object [ ] > tmp = bound1 ; bound1 = bound2 ; bound2 = tmp ; } Arrays . fill ( lastRow , <int> ) ; System . arraycopy ( bound2 . left , <int> , lastRow , <int> , bound2 . left . length ) ; Arrays . fill ( currentRow , <int> ) ; System . arraycopy ( bound1 . left , <int> , currentRow , <int> , bound1 . left . length ) ; seekToCurrentRow ( ) ; return Pair . create ( new Row ( partitionKey , bound1 . right ) , new Row ( partitionKey , bound2 . right ) ) ; } private int setNoLastRow ( int firstComponentCount ) { Arrays . fill ( lastRow , Integer . MAX_VALUE ) ; return firstComponentCount * generator . clusteringDescendantAverages [ <int> ] ; } private int setLastRow ( int position ) { if ( position < <int> ) throw new IllegalStateException ( ) ; decompose ( position , lastRow ) ; int expectedRowCount = <int> ; for ( int i = <int> ; i < lastRow . length ; i + + ) { int l = lastRow [ i ] ; expectedRowCount + = l * generator . clusteringDescendantAverages [ i ] ; } return expectedRowCount + <int> ; } private int compareToLastRow ( int depth ) { int prev = <int> ; for ( int i = <int> ; i < = depth ; i + + ) { int p = currentRow [ i ] , l = lastRow [ i ] , r = clusteringComponents [ i ] . size ( ) ; if ( prev < <int> ) { if ( r > <int> ) return - <int> ; } else if ( p > l ) { return <int> ; } else if ( p = = l ) { } else if ( r = = <int> ) { prev = p - l ; } else { return - <int> ; } } return <int> ; } private void decompose ( int scalar , int [ ] decomposed ) { for ( int i = <int> ; i < decomposed . length ; i + + ) { int avg = generator . clusteringDescendantAverages [ i ] ; decomposed [ i ] = scalar / avg ; scalar % = avg ; } for ( int i = lastRow . length - <int> ; i > <int> ; i - - ) { int avg = generator . clusteringComponentAverages [ i ] ; if ( decomposed [ i ] > = avg ) { decomposed [ i - <int> ] + = decomposed [ i ] / avg ; decomposed [ i ] % = avg ; } } } private static int compare ( int [ ] l , int [ ] r ) { for ( int i = <int> ; i < l . length ; i + + ) if ( l [ i ] ! = r [ i ] ) return Integer . compare ( l [ i ] , r [ i ] ) ; return <int> ; } static enum State { END_OF_PARTITION , AFTER_LIMIT , SUCCESS ; } private State seek ( int scalar ) { if ( scalar = = <int> ) { this . currentRow [ <int> ] = - <int> ; clusteringComponents [ <int> ] . addFirst ( this ) ; return setHasNext ( advance ( <int> , true ) ) ; } decompose ( scalar , this . currentRow ) ; return seekToCurrentRow ( ) ; } private State seekToCurrentRow ( ) { int [ ] position = this . currentRow ; for ( int i = <int> ; i < position . length ; i + + ) { if ( i ! = <int> ) fill ( i ) ; for ( int c = position [ i ] ; c > <int> ; c - - ) clusteringComponents [ i ] . poll ( ) ; if ( clusteringComponents [ i ] . isEmpty ( ) ) { int j = i ; while ( true ) { if ( - - j < <int> ) return setHasNext ( false ) ; clusteringComponents [ j ] . poll ( ) ; if ( ! clusteringComponents [ j ] . isEmpty ( ) ) break ; } position [ j ] + + ; Arrays . fill ( position , j + <int> , position . length , <int> ) ; while ( j < i ) fill ( + + j ) ; } row . row [ i ] = clusteringComponents [ i ] . peek ( ) ; } if ( compareToLastRow ( currentRow . length - <int> ) > <int> ) return setHasNext ( false ) ; position [ position . length - <int> ] - - ; clusteringComponents [ position . length - <int> ] . addFirst ( this ) ; return setHasNext ( advance ( position . length - <int> , true ) ) ; } Row advance ( ) { int depth = clusteringComponents . length - <int> ; long parentSeed = clusteringSeeds [ depth ] ; long rowSeed = seed ( clusteringComponents [ depth ] . peek ( ) , generator . clusteringComponents . get ( depth ) . type , parentSeed ) ; Row result = row . copy ( ) ; double valueColumn = <float> ; for ( int i = clusteringSeeds . length ; i < row . row . length ; i + + ) { Generator gen = generator . valueComponents . get ( i - clusteringSeeds . length ) ; if ( + + valueColumn / totalValueColumns > rowPopulationRatio ) { result . row [ i ] = null ; } else { gen . setSeed ( rowSeed ) ; result . row [ i ] = gen . generate ( ) ; } } setHasNext ( advance ( depth , false ) ) ; return result ; } private boolean advance ( int depth , boolean first ) { ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; clusteringComponents [ depth ] . poll ( ) ; currentRow [ depth ] + + ; while ( true ) { if ( clusteringComponents [ depth ] . isEmpty ( ) ) { if ( depth = = <int> ) return false ; depth - - ; clusteringComponents [ depth ] . poll ( ) ; if ( + + currentRow [ depth ] > lastRow [ depth ] ) return false ; continue ; } int compareToLastRow = compareToLastRow ( depth ) ; if ( compareToLastRow > <int> ) { assert ! first ; return false ; } boolean forceReturnOne = first & & compareToLastRow = = <int> ; double thischance = useChance * chancemodifier [ depth ] ; if ( forceReturnOne | | thischance > <float> | | thischance > = random . nextDouble ( ) ) { row . row [ depth ] = clusteringComponents [ depth ] . peek ( ) ; depth + + ; if ( depth = = clusteringComponents . length ) return true ; if ( useChance < <float> ) { rollmodifier [ depth ] = rollmodifier [ depth - <int> ] / Math . min ( <float> , thischance ) ; chancemodifier [ depth ] = generator . clusteringDescendantAverages [ depth ] * rollmodifier [ depth ] ; } currentRow [ depth ] = <int> ; fill ( depth ) ; continue ; } if ( compareToLastRow > = <int> ) return false ; clusteringComponents [ depth ] . poll ( ) ; currentRow [ depth ] + + ; } } private Pair < int [ ] , Object [ ] > randomBound ( int clusteringComponentDepth ) { ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; int [ ] position = new int [ clusteringComponentDepth ] ; Object [ ] bound = new Object [ clusteringComponentDepth ] ; position [ <int> ] = rnd . nextInt ( clusteringComponents [ <int> ] . size ( ) ) ; bound [ <int> ] = Iterables . get ( clusteringComponents [ <int> ] , position [ <int> ] ) ; for ( int d = <int> ; d < clusteringComponentDepth ; d + + ) { fill ( d ) ; position [ d ] = rnd . nextInt ( clusteringComponents [ d ] . size ( ) ) ; bound [ d ] = Iterables . get ( clusteringComponents [ d ] , position [ d ] ) ; } for ( int d = <int> ; d < clusteringComponentDepth ; d + + ) clusteringComponents [ d ] . clear ( ) ; return Pair . create ( position , bound ) ; } void fill ( int depth ) { long seed = depth = = <int> ? idseed : clusteringSeeds [ depth - <int> ] ; Generator gen = generator . clusteringComponents . get ( depth ) ; gen . setSeed ( seed ) ; fill ( clusteringComponents [ depth ] , ( int ) gen . clusteringDistribution . next ( ) , gen ) ; clusteringSeeds [ depth ] = seed ( clusteringComponents [ depth ] . peek ( ) , generator . clusteringComponents . get ( depth ) . type , seed ) ; } void fill ( Queue < Object > queue , int count , Generator generator ) { if ( count = = <int> ) { queue . add ( generator . generate ( ) ) ; return ; } switch ( order ) { case SORTED : if ( Comparable . class . isAssignableFrom ( generator . clazz ) ) { tosort . clear ( ) ; for ( int i = <int> ; i < count ; i + + ) tosort . add ( generator . generate ( ) ) ; Collections . sort ( ( List < Comparable > ) ( List < ? > ) tosort ) ; for ( int i = <int> ; i < count ; i + + ) if ( i = = <int> | | ( ( Comparable ) tosort . get ( i - <int> ) ) . compareTo ( tosort . get ( i ) ) < <int> ) queue . add ( tosort . get ( i ) ) ; break ; } case ARBITRARY : unique . clear ( ) ; for ( int i = <int> ; i < count ; i + + ) { Object next = generator . generate ( ) ; if ( unique . add ( next ) ) queue . add ( next ) ; } break ; case SHUFFLED : unique . clear ( ) ; tosort . clear ( ) ; ThreadLocalRandom rand = ThreadLocalRandom . current ( ) ; for ( int i = <int> ; i < count ; i + + ) { Object next = generator . generate ( ) ; if ( unique . add ( next ) ) tosort . add ( next ) ; } for ( int i = <int> ; i < tosort . size ( ) ; i + + ) { int index = rand . nextInt ( i , tosort . size ( ) ) ; Object obj = tosort . get ( index ) ; tosort . set ( index , tosort . get ( i ) ) ; queue . add ( obj ) ; } break ; default : throw new IllegalStateException ( ) ; } } public boolean hasNext ( ) { return hasNext ; } public Row next ( ) { if ( ! hasNext ( ) ) throw new NoSuchElementException ( ) ; return advance ( ) ; } public boolean finishedPartition ( ) { return clusteringComponents [ <int> ] . isEmpty ( ) ; } private State setHasNext ( boolean hasNext ) { this . hasNext = hasNext ; if ( ! hasNext ) { boolean isLast = finishedPartition ( ) ; if ( isWrite ) { boolean isFirst = isFirstWrite ; if ( isFirst ) seedManager . markFirstWrite ( seed , isLast ) ; if ( isLast ) seedManager . markLastWrite ( seed , isFirst ) ; } return isLast ? State . END_OF_PARTITION : State . AFTER_LIMIT ; } return State . SUCCESS ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } static long seed ( Object object , AbstractType type , long seed ) { if ( object instanceof ByteBuffer ) { ByteBuffer buf = ( ByteBuffer ) object ; for ( int i = buf . position ( ) ; i < buf . limit ( ) ; i + + ) seed = ( <int> * seed ) + buf . get ( i ) ; return seed ; } else if ( object instanceof String ) { String str = ( String ) object ; for ( int i = <int> ; i < str . length ( ) ; i + + ) seed = ( <int> * seed ) + str . charAt ( i ) ; return seed ; } else if ( object instanceof Number ) { return ( seed * <int> ) + ( ( Number ) object ) . longValue ( ) ; } else if ( object instanceof UUID ) { return seed * <int> + ( ( ( UUID ) object ) . getLeastSignificantBits ( ) ^ ( ( UUID ) object ) . getMostSignificantBits ( ) ) ; } else { return seed ( type . decompose ( object ) , BytesType . instance , seed ) ; } } public Object getPartitionKey ( int i ) { return partitionKey [ i ] ; } public String getKeyAsString ( ) { StringBuilder sb = new StringBuilder ( ) ; int i = <int> ; for ( Object key : partitionKey ) { if ( i > <int> ) sb . append ( <str> ) ; AbstractType type = generator . partitionKey . get ( i + + ) . type ; sb . append ( type . getString ( type . decompose ( key ) ) ) ; } return sb . toString ( ) ; } public ByteBuffer getToken ( ) { return generator . partitionKey . get ( <int> ) . type . decompose ( partitionKey [ <int> ] ) ; } } 
