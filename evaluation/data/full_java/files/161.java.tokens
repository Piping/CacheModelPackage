package org . apache . cassandra . cql3 ; import java . util . Collections ; import java . util . ArrayList ; import java . util . List ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . Term . Raw ; import org . apache . cassandra . cql3 . restrictions . Restriction ; import org . apache . cassandra . cql3 . restrictions . SingleColumnRestriction ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . db . marshal . CollectionType ; import org . apache . cassandra . db . marshal . ListType ; import org . apache . cassandra . db . marshal . MapType ; import org . apache . cassandra . exceptions . InvalidRequestException ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; public final class SingleColumnRelation extends Relation { private final ColumnIdentifier . Raw entity ; private final Term . Raw mapKey ; private final Term . Raw value ; private final List < Term . Raw > inValues ; private SingleColumnRelation ( ColumnIdentifier . Raw entity , Term . Raw mapKey , Operator type , Term . Raw value , List < Term . Raw > inValues ) { this . entity = entity ; this . mapKey = mapKey ; this . relationType = type ; this . value = value ; this . inValues = inValues ; if ( type = = Operator . IS_NOT ) assert value = = Constants . NULL_LITERAL ; } public SingleColumnRelation ( ColumnIdentifier . Raw entity , Term . Raw mapKey , Operator type , Term . Raw value ) { this ( entity , mapKey , type , value , null ) ; } public SingleColumnRelation ( ColumnIdentifier . Raw entity , Operator type , Term . Raw value ) { this ( entity , null , type , value ) ; } public Term . Raw getValue ( ) { return value ; } public List < ? extends Term . Raw > getInValues ( ) { return inValues ; } public static SingleColumnRelation createInRelation ( ColumnIdentifier . Raw entity , List < Term . Raw > inValues ) { return new SingleColumnRelation ( entity , null , Operator . IN , null , inValues ) ; } public ColumnIdentifier . Raw getEntity ( ) { return entity ; } public Term . Raw getMapKey ( ) { return mapKey ; } @Override protected Term toTerm ( List < ? extends ColumnSpecification > receivers , Raw raw , String keyspace , VariableSpecifications boundNames ) throws InvalidRequestException { assert receivers . size ( ) = = <int> ; Term term = raw . prepare ( keyspace , receivers . get ( <int> ) ) ; term . collectMarkerSpecification ( boundNames ) ; return term ; } public SingleColumnRelation withNonStrictOperator ( ) { switch ( relationType ) { case GT : return new SingleColumnRelation ( entity , Operator . GTE , value ) ; case LT : return new SingleColumnRelation ( entity , Operator . LTE , value ) ; default : return this ; } } public Relation renameIdentifier ( ColumnIdentifier . Raw from , ColumnIdentifier . Raw to ) { return entity . equals ( from ) ? new SingleColumnRelation ( to , mapKey , operator ( ) , value , inValues ) : this ; } @Override public String toString ( ) { String entityAsString = entity . toString ( ) ; if ( mapKey ! = null ) entityAsString = String . format ( <str> , entityAsString , mapKey ) ; if ( isIN ( ) ) return String . format ( <str> , entityAsString , inValues ) ; return String . format ( <str> , entityAsString , relationType , value ) ; } @Override protected Restriction newEQRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; if ( mapKey = = null ) { Term term = toTerm ( toReceivers ( columnDef , cfm . isDense ( ) ) , value , cfm . ksName , boundNames ) ; return new SingleColumnRestriction . EQRestriction ( columnDef , term ) ; } List < ? extends ColumnSpecification > receivers = toReceivers ( columnDef , cfm . isDense ( ) ) ; Term entryKey = toTerm ( Collections . singletonList ( receivers . get ( <int> ) ) , mapKey , cfm . ksName , boundNames ) ; Term entryValue = toTerm ( Collections . singletonList ( receivers . get ( <int> ) ) , value , cfm . ksName , boundNames ) ; return new SingleColumnRestriction . ContainsRestriction ( columnDef , entryKey , entryValue ) ; } @Override protected Restriction newINRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; List < ? extends ColumnSpecification > receivers = toReceivers ( columnDef , cfm . isDense ( ) ) ; List < Term > terms = toTerms ( receivers , inValues , cfm . ksName , boundNames ) ; if ( terms = = null ) { Term term = toTerm ( receivers , value , cfm . ksName , boundNames ) ; return new SingleColumnRestriction . InRestrictionWithMarker ( columnDef , ( Lists . Marker ) term ) ; } return new SingleColumnRestriction . InRestrictionWithValues ( columnDef , terms ) ; } @Override protected Restriction newSliceRestriction ( CFMetaData cfm , VariableSpecifications boundNames , Bound bound , boolean inclusive ) throws InvalidRequestException { ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; Term term = toTerm ( toReceivers ( columnDef , cfm . isDense ( ) ) , value , cfm . ksName , boundNames ) ; return new SingleColumnRestriction . SliceRestriction ( columnDef , bound , inclusive , term ) ; } @Override protected Restriction newContainsRestriction ( CFMetaData cfm , VariableSpecifications boundNames , boolean isKey ) throws InvalidRequestException { ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; Term term = toTerm ( toReceivers ( columnDef , cfm . isDense ( ) ) , value , cfm . ksName , boundNames ) ; return new SingleColumnRestriction . ContainsRestriction ( columnDef , term , isKey ) ; } @Override protected Restriction newIsNotRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { ColumnDefinition columnDef = toColumnDefinition ( cfm , entity ) ; assert value = = Constants . NULL_LITERAL : <str> + this . toString ( ) ; return new SingleColumnRestriction . IsNotNullRestriction ( columnDef ) ; } private List < ? extends ColumnSpecification > toReceivers ( ColumnDefinition columnDef , boolean isDense ) throws InvalidRequestException { ColumnSpecification receiver = columnDef ; checkFalse ( ! columnDef . isPrimaryKeyColumn ( ) & & isDense , <str> , columnDef . name ) ; if ( isIN ( ) ) { checkFalse ( ! columnDef . isPrimaryKeyColumn ( ) & & ! canHaveOnlyOneValue ( ) , <str> , columnDef . name ) ; } else if ( isSlice ( ) ) { checkFalse ( columnDef . isPartitionKey ( ) , <str> ) ; } checkFalse ( isContainsKey ( ) & & ! ( receiver . type instanceof MapType ) , <str> , receiver . name ) ; checkFalse ( isContains ( ) & & ! ( receiver . type . isCollection ( ) ) , <str> , receiver . name ) ; if ( mapKey ! = null ) { checkFalse ( receiver . type instanceof ListType , <str> , receiver . name ) ; checkTrue ( receiver . type instanceof MapType , <str> , receiver . name ) ; checkTrue ( receiver . type . isMultiCell ( ) , <str> , receiver . name ) ; checkTrue ( isEQ ( ) , <str> ) ; } if ( receiver . type . isCollection ( ) ) { checkFalse ( receiver . type . isMultiCell ( ) & & ! isLegalRelationForNonFrozenCollection ( ) , <str> , receiver . name , receiver . type . asCQL3Type ( ) , operator ( ) ) ; if ( isContainsKey ( ) | | isContains ( ) ) { receiver = makeCollectionReceiver ( receiver , isContainsKey ( ) ) ; } else if ( receiver . type . isMultiCell ( ) & & mapKey ! = null & & isEQ ( ) ) { List < ColumnSpecification > receivers = new ArrayList < > ( <int> ) ; receivers . add ( makeCollectionReceiver ( receiver , true ) ) ; receivers . add ( makeCollectionReceiver ( receiver , false ) ) ; return receivers ; } } return Collections . singletonList ( receiver ) ; } private static ColumnSpecification makeCollectionReceiver ( ColumnSpecification receiver , boolean forKey ) { return ( ( CollectionType < ? > ) receiver . type ) . makeCollectionReceiver ( receiver , forKey ) ; } private boolean isLegalRelationForNonFrozenCollection ( ) { return isContainsKey ( ) | | isContains ( ) | | isMapEntryEquality ( ) ; } private boolean isMapEntryEquality ( ) { return mapKey ! = null & & isEQ ( ) ; } private boolean canHaveOnlyOneValue ( ) { return isEQ ( ) | | ( isIN ( ) & & inValues ! = null & & inValues . size ( ) = = <int> ) ; } } 
