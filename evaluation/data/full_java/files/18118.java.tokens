package com . badlogic . gdx . graphics . glutils ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . utils . Array ; public class ImmediateModeRenderer20 implements ImmediateModeRenderer { private int primitiveType ; private int vertexIdx ; private int numSetTexCoords ; private final int maxVertices ; private int numVertices ; private final Mesh mesh ; private ShaderProgram shader ; private boolean ownsShader ; private final int numTexCoords ; private final int vertexSize ; private final int normalOffset ; private final int colorOffset ; private final int texCoordOffset ; private final Matrix4 projModelView = new Matrix4 ( ) ; private final float [ ] vertices ; private final String [ ] shaderUniformNames ; public ImmediateModeRenderer20 ( boolean hasNormals , boolean hasColors , int numTexCoords ) { this ( <int> , hasNormals , hasColors , numTexCoords , createDefaultShader ( hasNormals , hasColors , numTexCoords ) ) ; ownsShader = true ; } public ImmediateModeRenderer20 ( int maxVertices , boolean hasNormals , boolean hasColors , int numTexCoords ) { this ( maxVertices , hasNormals , hasColors , numTexCoords , createDefaultShader ( hasNormals , hasColors , numTexCoords ) ) ; ownsShader = true ; } public ImmediateModeRenderer20 ( int maxVertices , boolean hasNormals , boolean hasColors , int numTexCoords , ShaderProgram shader ) { this . maxVertices = maxVertices ; this . numTexCoords = numTexCoords ; this . shader = shader ; VertexAttribute [ ] attribs = buildVertexAttributes ( hasNormals , hasColors , numTexCoords ) ; mesh = new Mesh ( false , maxVertices , <int> , attribs ) ; vertices = new float [ maxVertices * ( mesh . getVertexAttributes ( ) . vertexSize / <int> ) ] ; vertexSize = mesh . getVertexAttributes ( ) . vertexSize / <int> ; normalOffset = mesh . getVertexAttribute ( Usage . Normal ) ! = null ? mesh . getVertexAttribute ( Usage . Normal ) . offset / <int> : <int> ; colorOffset = mesh . getVertexAttribute ( Usage . ColorPacked ) ! = null ? mesh . getVertexAttribute ( Usage . ColorPacked ) . offset / <int> : <int> ; texCoordOffset = mesh . getVertexAttribute ( Usage . TextureCoordinates ) ! = null ? mesh . getVertexAttribute ( Usage . TextureCoordinates ) . offset / <int> : <int> ; shaderUniformNames = new String [ numTexCoords ] ; for ( int i = <int> ; i < numTexCoords ; i + + ) { shaderUniformNames [ i ] = <str> + i ; } } private VertexAttribute [ ] buildVertexAttributes ( boolean hasNormals , boolean hasColor , int numTexCoords ) { Array < VertexAttribute > attribs = new Array < VertexAttribute > ( ) ; attribs . add ( new VertexAttribute ( Usage . Position , <int> , ShaderProgram . POSITION_ATTRIBUTE ) ) ; if ( hasNormals ) attribs . add ( new VertexAttribute ( Usage . Normal , <int> , ShaderProgram . NORMAL_ATTRIBUTE ) ) ; if ( hasColor ) attribs . add ( new VertexAttribute ( Usage . ColorPacked , <int> , ShaderProgram . COLOR_ATTRIBUTE ) ) ; for ( int i = <int> ; i < numTexCoords ; i + + ) { attribs . add ( new VertexAttribute ( Usage . TextureCoordinates , <int> , ShaderProgram . TEXCOORD_ATTRIBUTE + i ) ) ; } VertexAttribute [ ] array = new VertexAttribute [ attribs . size ] ; for ( int i = <int> ; i < attribs . size ; i + + ) array [ i ] = attribs . get ( i ) ; return array ; } public void setShader ( ShaderProgram shader ) { if ( ownsShader ) this . shader . dispose ( ) ; this . shader = shader ; ownsShader = false ; } public void begin ( Matrix4 projModelView , int primitiveType ) { this . projModelView . set ( projModelView ) ; this . primitiveType = primitiveType ; } public void color ( Color color ) { vertices [ vertexIdx + colorOffset ] = color . toFloatBits ( ) ; } public void color ( float r , float g , float b , float a ) { vertices [ vertexIdx + colorOffset ] = Color . toFloatBits ( r , g , b , a ) ; } public void color ( float colorBits ) { vertices [ vertexIdx + colorOffset ] = colorBits ; } public void texCoord ( float u , float v ) { final int idx = vertexIdx + texCoordOffset ; vertices [ idx + numSetTexCoords ] = u ; vertices [ idx + numSetTexCoords + <int> ] = v ; numSetTexCoords + = <int> ; } public void normal ( float x , float y , float z ) { final int idx = vertexIdx + normalOffset ; vertices [ idx ] = x ; vertices [ idx + <int> ] = y ; vertices [ idx + <int> ] = z ; } public void vertex ( float x , float y , float z ) { final int idx = vertexIdx ; vertices [ idx ] = x ; vertices [ idx + <int> ] = y ; vertices [ idx + <int> ] = z ; numSetTexCoords = <int> ; vertexIdx + = vertexSize ; numVertices + + ; } public void flush ( ) { if ( numVertices = = <int> ) return ; shader . begin ( ) ; shader . setUniformMatrix ( <str> , projModelView ) ; for ( int i = <int> ; i < numTexCoords ; i + + ) shader . setUniformi ( shaderUniformNames [ i ] , i ) ; mesh . setVertices ( vertices , <int> , vertexIdx ) ; mesh . render ( shader , primitiveType ) ; shader . end ( ) ; numSetTexCoords = <int> ; vertexIdx = <int> ; numVertices = <int> ; } public void end ( ) { flush ( ) ; } public int getNumVertices ( ) { return numVertices ; } @Override public int getMaxVertices ( ) { return maxVertices ; } public void dispose ( ) { if ( ownsShader & & shader ! = null ) shader . dispose ( ) ; mesh . dispose ( ) ; } static private String createVertexShader ( boolean hasNormals , boolean hasColors , int numTexCoords ) { String shader = <str> + ShaderProgram . POSITION_ATTRIBUTE + <str> + ( hasNormals ? <str> + ShaderProgram . NORMAL_ATTRIBUTE + <str> : <str> ) + ( hasColors ? <str> + ShaderProgram . COLOR_ATTRIBUTE + <str> : <str> ) ; for ( int i = <int> ; i < numTexCoords ; i + + ) { shader + = <str> + ShaderProgram . TEXCOORD_ATTRIBUTE + i + <str> ; } shader + = <str> ; shader + = ( hasColors ? <str> : <str> ) ; for ( int i = <int> ; i < numTexCoords ; i + + ) { shader + = <str> + i + <str> ; } shader + = <str> + <str> + ShaderProgram . POSITION_ATTRIBUTE + <str> + ( hasColors ? <str> + ShaderProgram . COLOR_ATTRIBUTE + <str> : <str> ) ; for ( int i = <int> ; i < numTexCoords ; i + + ) { shader + = <str> + i + <str> + ShaderProgram . TEXCOORD_ATTRIBUTE + i + <str> ; } shader + = <str> ; shader + = <str> ; return shader ; } static private String createFragmentShader ( boolean hasNormals , boolean hasColors , int numTexCoords ) { String shader = <str> + <str> + <str> ; if ( hasColors ) shader + = <str> ; for ( int i = <int> ; i < numTexCoords ; i + + ) { shader + = <str> + i + <str> ; shader + = <str> + i + <str> ; } shader + = <str> + <str> + ( hasColors ? <str> : <str> ) ; if ( numTexCoords > <int> ) shader + = <str> ; for ( int i = <int> ; i < numTexCoords ; i + + ) { if ( i = = numTexCoords - <int> ) { shader + = <str> + i + <str> + i + <str> ; } else { shader + = <str> + i + <str> + i + <str> ; } } shader + = <str> ; return shader ; } static public ShaderProgram createDefaultShader ( boolean hasNormals , boolean hasColors , int numTexCoords ) { String vertexShader = createVertexShader ( hasNormals , hasColors , numTexCoords ) ; String fragmentShader = createFragmentShader ( hasNormals , hasColors , numTexCoords ) ; ShaderProgram program = new ShaderProgram ( vertexShader , fragmentShader ) ; return program ; } } 
