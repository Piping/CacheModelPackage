package org . gradle . foundation ; import org . gradle . api . Project ; import org . gradle . api . Task ; import org . gradle . api . internal . project . DefaultProjectTaskLister ; import org . gradle . api . internal . project . ProjectInternal ; import org . gradle . api . internal . project . ProjectTaskLister ; import org . gradle . api . internal . tasks . TaskContainerInternal ; import org . gradle . foundation . ipc . gradle . ExecuteGradleCommandServerProtocol ; import org . gradle . gradleplugin . foundation . DOM4JSerializer ; import org . gradle . gradleplugin . foundation . GradlePluginLord ; import org . gradle . gradleplugin . foundation . request . ExecutionRequest ; import org . gradle . gradleplugin . foundation . request . RefreshTaskListRequest ; import org . gradle . gradleplugin . foundation . request . Request ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . internal . service . ServiceRegistryBuilder ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Assert ; import javax . swing . filechooser . FileFilter ; import java . io . File ; import java . util . * ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicReference ; public class TestUtility { private static long uniqueNameCounter = <int> ; public static Project createMockProject ( JUnit4Mockery context , final String name , final String buildFilePath , final int depth , Project [ ] subProjectArray , Task [ ] tasks , String [ ] defaultTasks ) { final ProjectInternal project = context . mock ( ProjectInternal . class , <str> + name + <str> + uniqueNameCounter + + ) ; final ServiceRegistry services = ServiceRegistryBuilder . builder ( ) . provider ( new Object ( ) { ProjectTaskLister createTaskLister ( ) { return new DefaultProjectTaskLister ( ) ; } } ) . build ( ) ; context . checking ( new Expectations ( ) { { allowing ( project ) . getName ( ) ; will ( returnValue ( name ) ) ; allowing ( project ) . getDescription ( ) ; will ( returnValue ( null ) ) ; allowing ( project ) . getBuildFile ( ) ; will ( returnValue ( new File ( buildFilePath ) ) ) ; allowing ( project ) . getDepth ( ) ; will ( returnValue ( depth ) ) ; allowing ( project ) . getServices ( ) ; will ( returnValue ( services ) ) ; } } ) ; attachSubProjects ( context , project , subProjectArray ) ; attachTasks ( context , project , tasks ) ; assignDefaultTasks ( context , project , defaultTasks ) ; return project ; } public static void attachSubProjects ( JUnit4Mockery context , final Project parentProject , Project . . . subProjectArray ) { final Map < String , Project > childProjects = new LinkedHashMap < String , Project > ( ) ; if ( subProjectArray ! = null ) { for ( final Project subProject : subProjectArray ) { childProjects . put ( String . valueOf ( childProjects . size ( ) ) , subProject ) ; context . checking ( new Expectations ( ) { { allowing ( subProject ) . getParent ( ) ; will ( returnValue ( parentProject ) ) ; } } ) ; } } context . checking ( new Expectations ( ) { { allowing ( parentProject ) . getChildProjects ( ) ; will ( returnValue ( childProjects ) ) ; } } ) ; } public static Task createTask ( JUnit4Mockery context , final String name , final String description ) { final Task task = context . mock ( Task . class , <str> + name + <str> + uniqueNameCounter + + ) ; context . checking ( new Expectations ( ) { { allowing ( task ) . getName ( ) ; will ( returnValue ( name ) ) ; allowing ( task ) . getDescription ( ) ; will ( returnValue ( description ) ) ; } } ) ; return task ; } public static void attachTasks ( JUnit4Mockery context , final Project parentProject , Task . . . taskArray ) { final TaskContainerInternal taskContainer = context . mock ( TaskContainerInternal . class , <str> + parentProject . getName ( ) + <str> + uniqueNameCounter + + ) ; context . checking ( new Expectations ( ) { { allowing ( parentProject ) . getTasks ( ) ; will ( returnValue ( taskContainer ) ) ; allowing ( taskContainer ) . realize ( ) ; } } ) ; final Set < Task > set = new LinkedHashSet < Task > ( ) ; if ( taskArray ! = null & & taskArray . length ! = <int> ) { set . addAll ( Arrays . asList ( taskArray ) ) ; for ( int index = <int> ; index < taskArray . length ; index + + ) { final Task task = taskArray [ index ] ; context . checking ( new Expectations ( ) { { allowing ( task ) . getProject ( ) ; will ( returnValue ( parentProject ) ) ; } } ) ; } } context . checking ( new Expectations ( ) { { allowing ( taskContainer ) . iterator ( ) ; will ( returnIterator ( set ) ) ; } } ) ; } private static void assignDefaultTasks ( JUnit4Mockery context , final Project project , final String . . . defaultTasksArray ) { final List < String > defaultTaskList = new ArrayList < String > ( ) ; if ( defaultTasksArray ! = null & & defaultTasksArray . length ! = <int> ) { defaultTaskList . addAll ( Arrays . asList ( defaultTasksArray ) ) ; } context . checking ( new Expectations ( ) { { allowing ( project ) . getDefaultTasks ( ) ; will ( returnValue ( defaultTaskList ) ) ; } } ) ; } public static < T > void assertListContents ( List < T > actualObjects , T . . . expectedObjectsArray ) { assertListContents ( actualObjects , Arrays . asList ( expectedObjectsArray ) ) ; } public static < T > void assertListContents ( List < T > actualObjects , List < T > expectedObjects ) { assertUnorderedListContents ( actualObjects , expectedObjects ) ; } public static < T > void assertUnorderedListContents ( List < T > actualObjecs , List < T > expectedObjects ) { List < T > expectedObjecsList = new ArrayList < T > ( expectedObjects ) ; while ( ! expectedObjecsList . isEmpty ( ) ) { T expectedObject = expectedObjecsList . remove ( <int> ) ; if ( ! actualObjecs . contains ( expectedObject ) ) { throw new AssertionError ( <str> + expectedObject + <str> + dumpList ( expectedObjects ) + <str> + dumpList ( actualObjecs ) ) ; } } if ( actualObjecs . size ( ) ! = expectedObjects . size ( ) ) { throw new AssertionError ( <str> + expectedObjects . size ( ) + <str> + actualObjecs . size ( ) + <str> + dumpList ( expectedObjects ) + <str> + dumpList ( actualObjecs ) ) ; } } public static String dumpList ( List list ) { if ( list = = null ) { return <str> ; } if ( list . isEmpty ( ) ) { return <str> ; } StringBuilder builder = new StringBuilder ( ) ; Iterator iterator = list . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object object = iterator . next ( ) ; if ( object = = null ) { builder . append ( <str> ) ; } else { builder . append ( object . toString ( ) ) . append ( <str> ) ; } } return builder . toString ( ) ; } public static class TestExportInteraction implements DOM4JSerializer . ExportInteraction { private File file ; private boolean confirmOverwrite ; private int promptCount ; public TestExportInteraction ( File file , boolean confirmOverwrite ) { this . file = file ; this . confirmOverwrite = confirmOverwrite ; } public File promptForFile ( FileFilter fileFilters ) { if ( promptCount = = <int> ) { throw new AssertionError ( <str> ) ; } promptCount + + ; return file ; } public boolean confirmOverwritingExistingFile ( File file ) { return confirmOverwrite ; } public void reportError ( String error ) { throw new AssertionError ( <str> + error ) ; } } public static class TestImportInteraction implements DOM4JSerializer . ImportInteraction { private File file ; private int promptCount ; public TestImportInteraction ( File file ) { this . file = file ; } public File promptForFile ( FileFilter fileFilters ) { if ( promptCount = = <int> ) { throw new AssertionError ( <str> ) ; } promptCount + + ; return file ; } public void reportError ( String error ) { throw new AssertionError ( <str> + error ) ; } } public static void refreshProjectsBlocking ( GradlePluginLord gradlePluginLord , int maximumWaitValue , TimeUnit maximumWaitUnits ) { refreshProjectsBlocking ( gradlePluginLord , new ExecuteGradleCommandServerProtocol . ExecutionInteraction ( ) { public void reportExecutionStarted ( ) { } public void reportNumberOfTasksToExecute ( int size ) { } public void reportExecutionFinished ( boolean wasSuccessful , String message , Throwable throwable ) { } public void reportTaskStarted ( String message , float percentComplete ) { } public void reportTaskComplete ( String message , float percentComplete ) { } public void reportLiveOutput ( String message ) { } } , maximumWaitValue , maximumWaitUnits ) ; } private static void refreshProjectsBlocking ( GradlePluginLord gradlePluginLord , final ExecuteGradleCommandServerProtocol . ExecutionInteraction executionInteraction , int maximumWaitValue , TimeUnit maximumWaitUnits ) { final CountDownLatch complete = new CountDownLatch ( <int> ) ; final AtomicReference < String > errorOutput = new AtomicReference < String > ( ) ; GradlePluginLord . RequestObserver observer = new GradlePluginLord . RequestObserver ( ) { public void executionRequestAdded ( ExecutionRequest request ) { } public void refreshRequestAdded ( RefreshTaskListRequest request ) { request . setExecutionInteraction ( executionInteraction ) ; } public void aboutToExecuteRequest ( Request request ) { } public void requestExecutionComplete ( Request request , int result , String output ) { if ( result ! = <int> ) { errorOutput . set ( output ) ; } complete . countDown ( ) ; } } ; gradlePluginLord . addRequestObserver ( observer , false ) ; Request request = gradlePluginLord . addRefreshRequestToQueue ( ) ; Assert . assertNotNull ( request ) ; boolean completed ; try { completed = complete . await ( maximumWaitValue , maximumWaitUnits ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } gradlePluginLord . removeRequestObserver ( observer ) ; if ( ! completed ) { request . cancel ( ) ; throw new AssertionError ( <str> + maximumWaitValue + <str> + maximumWaitUnits + <str> ) ; } if ( errorOutput . get ( ) ! = null ) { throw new AssertionError ( String . format ( <str> , errorOutput . get ( ) ) ) ; } } public static void executeBlocking ( GradlePluginLord gradlePluginLord , String fullCommandLine , String displayName , final ExecuteGradleCommandServerProtocol . ExecutionInteraction executionInteraction , int maximumWaitSeconds ) { final CountDownLatch complete = new CountDownLatch ( <int> ) ; GradlePluginLord . RequestObserver observer = new GradlePluginLord . RequestObserver ( ) { public void executionRequestAdded ( ExecutionRequest request ) { request . setExecutionInteraction ( executionInteraction ) ; } public void refreshRequestAdded ( RefreshTaskListRequest request ) { } public void aboutToExecuteRequest ( Request request ) { } public void requestExecutionComplete ( Request request , int result , String output ) { complete . countDown ( ) ; } } ; gradlePluginLord . addRequestObserver ( observer , false ) ; Request request = gradlePluginLord . addExecutionRequestToQueue ( fullCommandLine , displayName ) ; Assert . assertNotNull ( request ) ; boolean timeout ; try { timeout = ! complete . await ( maximumWaitSeconds , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } gradlePluginLord . removeRequestObserver ( observer ) ; if ( timeout ) { request . cancel ( ) ; throw new AssertionError ( <str> + maximumWaitSeconds + <str> ) ; } } } 
