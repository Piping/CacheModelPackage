package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; public class SameShardAllocationDecider extends AllocationDecider { public static final String NAME = <str> ; public static final String SAME_HOST_SETTING = <str> ; private final boolean sameHost ; @Inject public SameShardAllocationDecider ( Settings settings ) { super ( settings ) ; this . sameHost = settings . getAsBoolean ( SAME_HOST_SETTING , false ) ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { Iterable < ShardRouting > assignedShards = allocation . routingNodes ( ) . assignedShards ( shardRouting ) ; for ( ShardRouting assignedShard : assignedShards ) { if ( node . nodeId ( ) . equals ( assignedShard . currentNodeId ( ) ) ) { return allocation . decision ( Decision . NO , NAME , <str> , node . nodeId ( ) ) ; } } if ( sameHost ) { if ( node . node ( ) ! = null ) { for ( RoutingNode checkNode : allocation . routingNodes ( ) ) { if ( checkNode . node ( ) = = null ) { continue ; } boolean checkNodeOnSameHost = false ; if ( Strings . hasLength ( checkNode . node ( ) . getHostAddress ( ) ) & & Strings . hasLength ( node . node ( ) . getHostAddress ( ) ) ) { if ( checkNode . node ( ) . getHostAddress ( ) . equals ( node . node ( ) . getHostAddress ( ) ) ) { checkNodeOnSameHost = true ; } } else if ( Strings . hasLength ( checkNode . node ( ) . getHostName ( ) ) & & Strings . hasLength ( node . node ( ) . getHostName ( ) ) ) { if ( checkNode . node ( ) . getHostName ( ) . equals ( node . node ( ) . getHostName ( ) ) ) { checkNodeOnSameHost = true ; } } if ( checkNodeOnSameHost ) { for ( ShardRouting assignedShard : assignedShards ) { if ( checkNode . nodeId ( ) . equals ( assignedShard . currentNodeId ( ) ) ) { return allocation . decision ( Decision . NO , NAME , <str> , node . nodeId ( ) ) ; } } } } } } return allocation . decision ( Decision . YES , NAME , <str> ) ; } } 
