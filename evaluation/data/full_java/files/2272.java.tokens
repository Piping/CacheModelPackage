package org . nd4j . linalg . util ; import org . apache . commons . math3 . complex . Complex ; import org . apache . commons . math3 . util . FastMath ; import org . nd4j . linalg . api . complex . IComplexDouble ; import org . nd4j . linalg . api . complex . IComplexFloat ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . factory . Nd4j ; public class ComplexUtil { private ComplexUtil ( ) { } public static IComplexNumber [ ] [ ] complexNumbersFor ( float [ ] [ ] realComponents ) { IComplexNumber [ ] [ ] ret = new IComplexNumber [ realComponents . length ] [ realComponents [ <int> ] . length ] ; for ( int i = <int> ; i < realComponents . length ; i + + ) for ( int j = <int> ; j < realComponents [ i ] . length ; j + + ) ret [ i ] [ j ] = Nd4j . createComplexNumber ( realComponents [ i ] [ j ] , <int> ) ; return ret ; } public static IComplexNumber [ ] [ ] complexNumbersFor ( double [ ] [ ] realComponents ) { IComplexNumber [ ] [ ] ret = new IComplexNumber [ realComponents . length ] [ realComponents [ <int> ] . length ] ; for ( int i = <int> ; i < realComponents . length ; i + + ) for ( int j = <int> ; j < realComponents [ i ] . length ; j + + ) ret [ i ] [ j ] = Nd4j . createComplexNumber ( realComponents [ i ] [ j ] , <int> ) ; return ret ; } public static IComplexNumber [ ] complexNumbersFor ( float [ ] realComponents ) { IComplexNumber [ ] ret = new IComplexNumber [ realComponents . length ] ; for ( int i = <int> ; i < realComponents . length ; i + + ) ret [ i ] = Nd4j . createComplexNumber ( realComponents [ i ] , <int> ) ; return ret ; } public static IComplexNumber [ ] complexNumbersFor ( double [ ] realComponents ) { IComplexNumber [ ] ret = new IComplexNumber [ realComponents . length ] ; for ( int i = <int> ; i < realComponents . length ; i + + ) ret [ i ] = Nd4j . createComplexNumber ( realComponents [ i ] , <int> ) ; return ret ; } public static IComplexNumber atan ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . atan ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber acos ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . acos ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber asin ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . asin ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber sin ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . sin ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber ceil ( IComplexNumber num ) { Complex c = new Complex ( FastMath . ceil ( num . realComponent ( ) . doubleValue ( ) ) , FastMath . ceil ( num . imaginaryComponent ( ) . doubleValue ( ) ) ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber floor ( IComplexNumber num ) { Complex c = new Complex ( FastMath . floor ( num . realComponent ( ) . doubleValue ( ) ) , FastMath . floor ( num . imaginaryComponent ( ) . doubleValue ( ) ) ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber neg ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . negate ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber log ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . log ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber sqrt ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . sqrt ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber abs ( IComplexNumber num ) { double c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . abs ( ) ; return Nd4j . createDouble ( c , <int> ) ; } public static IComplexNumber round ( IComplexNumber num ) { return Nd4j . createDouble ( Math . round ( num . realComponent ( ) . doubleValue ( ) ) , Math . round ( num . imaginaryComponent ( ) . doubleValue ( ) ) ) ; } public static IComplexNumber pow ( IComplexNumber num , IComplexNumber power ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . pow ( new Complex ( power . realComponent ( ) . doubleValue ( ) , power . imaginaryComponent ( ) . doubleValue ( ) ) ) ; if ( c . isNaN ( ) ) c = new Complex ( Nd4j . EPS_THRESHOLD , <float> ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber pow ( IComplexNumber num , double power ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . pow ( power ) ; if ( c . isNaN ( ) ) c = new Complex ( Nd4j . EPS_THRESHOLD , <float> ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber cos ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . cos ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber hardTanh ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . tanh ( ) ; if ( c . getReal ( ) < - <float> ) c = new Complex ( - <float> , c . getImaginary ( ) ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber tanh ( IComplexNumber num ) { Complex c = new Complex ( num . realComponent ( ) . doubleValue ( ) , num . imaginaryComponent ( ) . doubleValue ( ) ) . tanh ( ) ; return Nd4j . createDouble ( c . getReal ( ) , c . getImaginary ( ) ) ; } public static IComplexNumber exp ( IComplexNumber d ) { if ( d instanceof IComplexFloat ) return exp ( ( IComplexFloat ) d ) ; return exp ( ( IComplexDouble ) d ) ; } public static IComplexDouble exp ( IComplexDouble d ) { return Nd4j . createDouble ( FastMath . exp ( d . realComponent ( ) ) * FastMath . cos ( d . imaginaryComponent ( ) ) , FastMath . exp ( d . realComponent ( ) ) * FastMath . sin ( d . imaginaryComponent ( ) ) ) ; } public static IComplexFloat exp ( IComplexFloat d ) { return Nd4j . createFloat ( ( float ) FastMath . exp ( d . realComponent ( ) ) * ( float ) FastMath . cos ( d . imaginaryComponent ( ) ) , ( float ) FastMath . exp ( d . realComponent ( ) ) * ( float ) FastMath . sin ( d . imaginaryComponent ( ) ) ) ; } } 
