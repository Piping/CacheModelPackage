package org . elasticsearch . search . scroll ; import com . carrotsearch . hppc . IntHashSet ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . SearchHits ; import org . elasticsearch . search . sort . SortBuilder ; import org . elasticsearch . search . sort . SortBuilders ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . Arrays ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . equalTo ; public class DuelScrollIT extends ESIntegTestCase { public void testDuelQueryThenFetch ( ) throws Exception { TestContext context = create ( SearchType . DFS_QUERY_THEN_FETCH , SearchType . QUERY_THEN_FETCH ) ; SearchResponse control = client ( ) . prepareSearch ( <str> ) . setSearchType ( context . searchType ) . addSort ( context . sort ) . setSize ( context . numDocs ) . get ( ) ; assertNoFailures ( control ) ; SearchHits sh = control . getHits ( ) ; assertThat ( sh . totalHits ( ) , equalTo ( ( long ) context . numDocs ) ) ; assertThat ( sh . getHits ( ) . length , equalTo ( context . numDocs ) ) ; SearchResponse searchScrollResponse = client ( ) . prepareSearch ( <str> ) . setSearchType ( context . searchType ) . addSort ( context . sort ) . setSize ( context . scrollRequestSize ) . setScroll ( <str> ) . get ( ) ; assertNoFailures ( searchScrollResponse ) ; assertThat ( searchScrollResponse . getHits ( ) . getTotalHits ( ) , equalTo ( ( long ) context . numDocs ) ) ; assertThat ( searchScrollResponse . getHits ( ) . hits ( ) . length , equalTo ( context . scrollRequestSize ) ) ; int counter = <int> ; for ( SearchHit hit : searchScrollResponse . getHits ( ) ) { assertThat ( hit . sortValues ( ) [ <int> ] , equalTo ( sh . getAt ( counter + + ) . sortValues ( ) [ <int> ] ) ) ; } int iter = <int> ; String scrollId = searchScrollResponse . getScrollId ( ) ; while ( true ) { searchScrollResponse = client ( ) . prepareSearchScroll ( scrollId ) . setScroll ( <str> ) . get ( ) ; assertNoFailures ( searchScrollResponse ) ; assertThat ( searchScrollResponse . getHits ( ) . getTotalHits ( ) , equalTo ( ( long ) context . numDocs ) ) ; if ( searchScrollResponse . getHits ( ) . hits ( ) . length = = <int> ) { break ; } int expectedLength ; int scrollSlice = + + iter * context . scrollRequestSize ; if ( scrollSlice < = context . numDocs ) { expectedLength = context . scrollRequestSize ; } else { expectedLength = context . scrollRequestSize - ( scrollSlice - context . numDocs ) ; } assertThat ( searchScrollResponse . getHits ( ) . hits ( ) . length , equalTo ( expectedLength ) ) ; for ( SearchHit hit : searchScrollResponse . getHits ( ) ) { assertThat ( hit . sortValues ( ) [ <int> ] , equalTo ( sh . getAt ( counter + + ) . sortValues ( ) [ <int> ] ) ) ; } scrollId = searchScrollResponse . getScrollId ( ) ; } assertThat ( counter , equalTo ( context . numDocs ) ) ; clearScroll ( scrollId ) ; } public void testDuelQueryAndFetch ( ) throws Exception { TestContext context = create ( SearchType . DFS_QUERY_AND_FETCH , SearchType . QUERY_AND_FETCH ) ; SearchResponse searchScrollResponse = client ( ) . prepareSearch ( <str> ) . setSearchType ( context . searchType ) . addSort ( context . sort ) . setSize ( context . scrollRequestSize ) . setScroll ( <str> ) . get ( ) ; assertNoFailures ( searchScrollResponse ) ; assertThat ( searchScrollResponse . getHits ( ) . getTotalHits ( ) , equalTo ( ( long ) context . numDocs ) ) ; int counter = searchScrollResponse . getHits ( ) . hits ( ) . length ; String scrollId = searchScrollResponse . getScrollId ( ) ; while ( true ) { searchScrollResponse = client ( ) . prepareSearchScroll ( scrollId ) . setScroll ( <str> ) . get ( ) ; assertNoFailures ( searchScrollResponse ) ; assertThat ( searchScrollResponse . getHits ( ) . getTotalHits ( ) , equalTo ( ( long ) context . numDocs ) ) ; if ( searchScrollResponse . getHits ( ) . hits ( ) . length = = <int> ) { break ; } counter + = searchScrollResponse . getHits ( ) . hits ( ) . length ; scrollId = searchScrollResponse . getScrollId ( ) ; } assertThat ( counter , equalTo ( context . numDocs ) ) ; clearScroll ( scrollId ) ; } private TestContext create ( SearchType . . . searchTypes ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; int numDocs = <int> + randomInt ( <int> ) ; int scrollRequestSize = randomIntBetween ( <int> , rarely ( ) ? numDocs : numDocs / <int> ) ; boolean unevenRouting = randomBoolean ( ) ; int numMissingDocs = scaledRandomIntBetween ( <int> , numDocs / <int> ) ; IntHashSet missingDocs = new IntHashSet ( numMissingDocs ) ; for ( int i = <int> ; i < numMissingDocs ; i + + ) { while ( ! missingDocs . add ( randomInt ( numDocs ) ) ) { } } for ( int i = <int> ; i < = numDocs ; i + + ) { IndexRequestBuilder indexRequestBuilder = client ( ) . prepareIndex ( <str> , <str> , String . valueOf ( i ) ) ; if ( missingDocs . contains ( i ) ) { indexRequestBuilder . setSource ( <str> , <str> ) ; } else { indexRequestBuilder . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , i ) . field ( <str> , String . valueOf ( i ) ) . startObject ( <str> ) . field ( <str> , i ) . field ( <str> , String . valueOf ( i ) ) . endObject ( ) . endObject ( ) ) ; } if ( unevenRouting & & randomInt ( <int> ) < = <int> ) { indexRequestBuilder . setRouting ( <str> ) ; } indexRandom ( false , indexRequestBuilder ) ; } refresh ( ) ; final SortBuilder sort ; if ( randomBoolean ( ) ) { if ( randomBoolean ( ) ) { sort = SortBuilders . fieldSort ( <str> ) . missing ( <int> ) ; } else { sort = SortBuilders . fieldSort ( <str> ) . missing ( <str> ) ; } } else { if ( randomBoolean ( ) ) { sort = SortBuilders . fieldSort ( <str> ) . missing ( <int> ) ; } else { sort = SortBuilders . fieldSort ( <str> ) . missing ( <str> ) ; } } sort . order ( randomBoolean ( ) ? SortOrder . ASC : SortOrder . DESC ) ; SearchType searchType = RandomPicks . randomFrom ( getRandom ( ) , Arrays . asList ( searchTypes ) ) ; logger . info ( <str> , numDocs , scrollRequestSize , sort , searchType ) ; return new TestContext ( numDocs , scrollRequestSize , sort , searchType ) ; } class TestContext { final int numDocs ; final int scrollRequestSize ; final SortBuilder sort ; final SearchType searchType ; TestContext ( int numDocs , int scrollRequestSize , SortBuilder sort , SearchType searchType ) { this . numDocs = numDocs ; this . scrollRequestSize = scrollRequestSize ; this . sort = sort ; this . searchType = searchType ; } } private int createIndex ( boolean singleShard ) throws Exception { Settings . Builder settings = Settings . builder ( ) ; if ( singleShard ) { settings . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) ; } settings . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( settings . build ( ) ) . get ( ) ) ; final int numDocs = randomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs ; + + i ) { builders [ i ] = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , random ( ) . nextBoolean ( ) ) ; } indexRandom ( true , builders ) ; return numDocs ; } private void testDuelIndexOrder ( SearchType searchType , boolean trackScores , int numDocs ) throws Exception { final int size = scaledRandomIntBetween ( <int> , numDocs + <int> ) ; final SearchResponse control = client ( ) . prepareSearch ( <str> ) . setSearchType ( searchType ) . setSize ( numDocs ) . setQuery ( QueryBuilders . matchQuery ( <str> , <str> ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setTrackScores ( trackScores ) . get ( ) ; assertNoFailures ( control ) ; SearchResponse scroll = client ( ) . prepareSearch ( <str> ) . setSearchType ( searchType ) . setSize ( size ) . setQuery ( QueryBuilders . matchQuery ( <str> , <str> ) ) . addSort ( SortBuilders . fieldSort ( <str> ) ) . setTrackScores ( trackScores ) . setScroll ( <str> ) . get ( ) ; int scrollDocs = <int> ; try { while ( true ) { assertNoFailures ( scroll ) ; assertEquals ( control . getHits ( ) . getTotalHits ( ) , scroll . getHits ( ) . getTotalHits ( ) ) ; assertEquals ( control . getHits ( ) . getMaxScore ( ) , scroll . getHits ( ) . getMaxScore ( ) , <float> ) ; if ( scroll . getHits ( ) . hits ( ) . length = = <int> ) { break ; } for ( int i = <int> ; i < scroll . getHits ( ) . hits ( ) . length ; + + i ) { SearchHit controlHit = control . getHits ( ) . getAt ( scrollDocs + i ) ; SearchHit scrollHit = scroll . getHits ( ) . getAt ( i ) ; assertEquals ( controlHit . getId ( ) , scrollHit . getId ( ) ) ; } scrollDocs + = scroll . getHits ( ) . hits ( ) . length ; scroll = client ( ) . prepareSearchScroll ( scroll . getScrollId ( ) ) . setScroll ( <str> ) . get ( ) ; } assertEquals ( control . getHits ( ) . getTotalHits ( ) , scrollDocs ) ; } catch ( AssertionError e ) { logger . info ( <str> + control ) ; logger . info ( <str> + size + <str> + scrollDocs + <str> + scroll ) ; throw e ; } finally { clearScroll ( scroll . getScrollId ( ) ) ; } } public void testDuelIndexOrderQueryAndFetch ( ) throws Exception { final SearchType searchType = RandomPicks . randomFrom ( random ( ) , Arrays . asList ( SearchType . QUERY_AND_FETCH , SearchType . DFS_QUERY_AND_FETCH ) ) ; final int numDocs = createIndex ( true ) ; testDuelIndexOrder ( searchType , false , numDocs ) ; testDuelIndexOrder ( searchType , true , numDocs ) ; } public void testDuelIndexOrderQueryThenFetch ( ) throws Exception { final SearchType searchType = RandomPicks . randomFrom ( random ( ) , Arrays . asList ( SearchType . QUERY_THEN_FETCH , SearchType . DFS_QUERY_THEN_FETCH ) ) ; final int numDocs = createIndex ( false ) ; testDuelIndexOrder ( searchType , false , numDocs ) ; testDuelIndexOrder ( searchType , true , numDocs ) ; } } 
