package org . gradle . performance . measure ; import org . gradle . api . Nullable ; import java . math . BigDecimal ; import java . math . RoundingMode ; import java . text . DecimalFormat ; import java . text . DecimalFormatSymbols ; import java . util . List ; import java . util . Locale ; public class Amount < Q > implements Comparable < Amount < Q > > { private final BigDecimal value ; private final Units < Q > units ; private final BigDecimal normalised ; private Amount ( BigDecimal value , Units < Q > units ) { this . value = value ; this . units = units ; normalised = units . scaleTo ( value , units . getBaseUnits ( ) ) ; } public static < Q > Amount < Q > valueOf ( long value , Units < Q > units ) { return valueOf ( BigDecimal . valueOf ( value ) , units ) ; } @Nullable public static < Q > Amount < Q > valueOf ( @Nullable BigDecimal value , Units < Q > units ) { if ( value = = null ) { return null ; } return new Amount < Q > ( value , units ) ; } @Override public String toString ( ) { return String . format ( <str> , value , units . format ( value ) ) ; } public Units < Q > getUnits ( ) { return units ; } public BigDecimal getValue ( ) { return value ; } public String format ( ) { List < Units < Q > > allUnits = units . getUnitsForQuantity ( ) ; BigDecimal base = normalised . abs ( ) ; for ( int i = allUnits . size ( ) - <int> ; i > = <int> ; i - - ) { Units < Q > candidate = allUnits . get ( i ) ; if ( base . compareTo ( candidate . getFactor ( ) ) > = <int> ) { BigDecimal scaled = units . scaleTo ( value , candidate ) ; return String . format ( <str> , new DecimalFormat ( <str> , new DecimalFormatSymbols ( Locale . US ) ) . format ( scaled ) , candidate . format ( scaled ) ) ; } } return String . format ( <str> , new DecimalFormat ( <str> , new DecimalFormatSymbols ( Locale . US ) ) . format ( value ) , units . format ( value ) ) ; } public Amount < Q > toUnits ( Units < Q > units ) { if ( units . equals ( this . units ) ) { return this ; } return new Amount < Q > ( this . units . scaleTo ( value , units ) , units ) ; } @Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null | | obj . getClass ( ) ! = getClass ( ) ) { return false ; } @SuppressWarnings ( <str> ) Amount < Q > other = ( Amount ) obj ; return compareTo ( other ) = = <int> ; } @Override public int hashCode ( ) { return normalised . hashCode ( ) ; } public int compareTo ( Amount < Q > o ) { if ( o . units . getType ( ) ! = units . getType ( ) ) { throw new IllegalArgumentException ( String . format ( <str> , o . units ) ) ; } return normalised . compareTo ( o . normalised ) ; } public Amount < Q > plus ( Amount < Q > other ) { if ( other . value . equals ( BigDecimal . ZERO ) ) { return this ; } if ( value . equals ( BigDecimal . ZERO ) ) { return other ; } int diff = units . compareTo ( other . units ) ; if ( diff = = <int> ) { return new Amount < Q > ( value . add ( other . value ) , units ) ; } if ( diff < <int> ) { return new Amount < Q > ( value . add ( other . units . scaleTo ( other . value , units ) ) , units ) ; } return new Amount < Q > ( units . scaleTo ( value , other . units ) . add ( other . value ) , other . units ) ; } public Amount < Q > minus ( Amount < Q > other ) { if ( other . value . equals ( BigDecimal . ZERO ) ) { return this ; } int diff = units . compareTo ( other . units ) ; if ( diff = = <int> ) { return new Amount < Q > ( value . subtract ( other . value ) , units ) ; } if ( diff < <int> ) { return new Amount < Q > ( value . subtract ( other . units . scaleTo ( other . value , units ) ) , units ) ; } return new Amount < Q > ( units . scaleTo ( value , other . units ) . subtract ( other . value ) , other . units ) ; } public Amount < Q > div ( long other ) { return new Amount < Q > ( value . divide ( BigDecimal . valueOf ( other ) , <int> , RoundingMode . HALF_UP ) , units ) ; } public BigDecimal div ( Amount < Q > other ) { return normalised . divide ( other . normalised , <int> , RoundingMode . HALF_UP ) ; } public Amount < Q > abs ( ) { if ( value . compareTo ( BigDecimal . ZERO ) > = <int> ) { return this ; } return new Amount < Q > ( value . abs ( ) , units ) ; } } 
