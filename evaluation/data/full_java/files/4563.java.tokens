package org . eclipse . debug . internal . ui . views . memory ; import java . math . BigInteger ; import java . util . ArrayList ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IMemoryBlockManager ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IMemoryBlockExtension ; import org . eclipse . debug . core . model . IMemoryBlockRetrieval ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . swt . SWT ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . progress . UIJob ; public class MemoryViewUtil { public static final int [ ] ignoreKeyEvents = { SWT . ARROW_UP , SWT . ARROW_DOWN , SWT . ARROW_LEFT , SWT . ARROW_RIGHT , SWT . PAGE_UP , SWT . PAGE_DOWN , SWT . HOME , SWT . END , SWT . INSERT , SWT . F1 , SWT . F2 , SWT . F3 , SWT . F4 , SWT . F5 , SWT . F6 , SWT . F7 , SWT . F8 , SWT . F9 , SWT . F10 , SWT . F11 , SWT . F12 , SWT . F13 , SWT . F14 , SWT . F15 , SWT . HELP , SWT . CAPS_LOCK , SWT . NUM_LOCK , SWT . SCROLL_LOCK , SWT . PAUSE , SWT . BREAK , SWT . PRINT_SCREEN , SWT . ESC , SWT . CTRL , SWT . ALT , SWT . SHIFT } ; public static ArrayList < String > MEMORY_BLOCKS_HISTORY = new ArrayList < String > ( ) ; static public boolean isValidSelection ( ISelection selection ) { if ( ! ( selection instanceof IStructuredSelection ) ) return false ; if ( selection . isEmpty ( ) | | ( ( IStructuredSelection ) selection ) . size ( ) > <int> ) { return false ; } Object elem = ( ( IStructuredSelection ) selection ) . getFirstElement ( ) ; return isValidContext ( elem ) ; } public static boolean isValidContext ( Object elem ) { if ( ! ( elem instanceof IAdaptable ) ) return false ; IMemoryBlockRetrieval memRetrieval = ( ( IAdaptable ) elem ) . getAdapter ( IMemoryBlockRetrieval . class ) ; IDebugTarget debugTarget = null ; if ( elem instanceof IDebugElement ) { debugTarget = ( ( IDebugElement ) elem ) . getDebugTarget ( ) ; } else { debugTarget = ( ( IAdaptable ) elem ) . getAdapter ( IDebugTarget . class ) ; } if ( memRetrieval = = null ) { memRetrieval = debugTarget ; } if ( debugTarget ! = null & & ( debugTarget . isTerminated ( ) | | debugTarget . isDisconnected ( ) ) ) return false ; if ( memRetrieval ! = null & & memRetrieval . supportsStorageRetrieval ( ) ) { return true ; } return false ; } static public void openError ( final String title , final String message , final Exception e ) { UIJob uiJob = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { String detail = IInternalDebugCoreConstants . EMPTY_STRING ; if ( e ! = null ) detail = e . getMessage ( ) ; Shell shell = DebugUIPlugin . getDefault ( ) . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getShell ( ) ; MessageDialog . openError ( shell , title , message + <str> + detail ) ; return Status . OK_STATUS ; } } ; uiJob . setSystem ( true ) ; uiJob . schedule ( ) ; } static IMemoryBlockManager getMemoryBlockManager ( ) { return DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) ; } static public boolean isLinuxGTK ( ) { String ws = Platform . getWS ( ) ; return ws . equals ( Platform . WS_GTK ) ; } public static boolean isValidEditEvent ( int event ) { for ( int i = <int> ; i < MemoryViewUtil . ignoreKeyEvents . length ; i + + ) { if ( event = = MemoryViewUtil . ignoreKeyEvents [ i ] ) return false ; } return true ; } public static BigInteger alignToBoundary ( BigInteger integer , int numberOfUnitsPerLine ) { BigInteger [ ] result = integer . divideAndRemainder ( BigInteger . valueOf ( numberOfUnitsPerLine ) ) ; integer = integer . subtract ( result [ <int> ] ) ; return integer ; } public static void addHistory ( String expression ) { if ( ! MEMORY_BLOCKS_HISTORY . contains ( expression ) ) MEMORY_BLOCKS_HISTORY . add ( <int> , expression ) ; if ( MEMORY_BLOCKS_HISTORY . size ( ) > <int> ) MEMORY_BLOCKS_HISTORY . remove ( MEMORY_BLOCKS_HISTORY . size ( ) - <int> ) ; } public static String [ ] getHistory ( ) { return MEMORY_BLOCKS_HISTORY . toArray ( new String [ MEMORY_BLOCKS_HISTORY . size ( ) ] ) ; } public static IMemoryBlockRetrieval getMemoryBlockRetrieval ( Object object ) { IMemoryBlockRetrieval retrieval = null ; if ( object instanceof IMemoryBlockExtension ) return ( ( IMemoryBlockExtension ) object ) . getMemoryBlockRetrieval ( ) ; if ( object instanceof IAdaptable ) { IAdaptable adaptable = ( IAdaptable ) object ; retrieval = adaptable . getAdapter ( IMemoryBlockRetrieval . class ) ; } if ( retrieval = = null & & object instanceof IMemoryBlockRetrieval ) { retrieval = ( IMemoryBlockRetrieval ) object ; } if ( retrieval = = null & & object instanceof IDebugElement ) { IDebugElement de = ( IDebugElement ) object ; retrieval = de . getDebugTarget ( ) ; } return retrieval ; } public static Integer getHashCode ( Object o ) { return Integer . valueOf ( o . hashCode ( ) ) ; } } 
