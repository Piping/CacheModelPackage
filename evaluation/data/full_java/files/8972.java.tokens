package org . elasticsearch . test ; import com . carrotsearch . hppc . ObjectArrayList ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . admin . indices . template . get . GetIndexTemplatesResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexTemplateMetaData ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . indices . IndexTemplateMissingException ; import org . elasticsearch . repositories . RepositoryMissingException ; import java . io . Closeable ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . util . Random ; import java . util . Set ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . * ; public abstract class TestCluster implements Iterable < Client > , Closeable { protected final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; private final long seed ; protected Random random ; protected double transportClientRatio = <float> ; public TestCluster ( long seed ) { this . seed = seed ; } public long seed ( ) { return seed ; } public void beforeTest ( Random random , double transportClientRatio ) throws IOException , InterruptedException { assert transportClientRatio > = <float> & & transportClientRatio < = <float> ; logger . debug ( <str> , transportClientRatio ) ; this . transportClientRatio = transportClientRatio ; this . random = new Random ( random . nextLong ( ) ) ; } public void wipe ( Set < String > excludeTemplates ) { wipeIndices ( <str> ) ; wipeAllTemplates ( excludeTemplates ) ; wipeRepositories ( ) ; } public void beforeIndexDeletion ( ) { } public void assertAfterTest ( ) throws IOException { ensureEstimatedStats ( ) ; } public abstract void afterTest ( ) throws IOException ; public abstract Client client ( ) ; public abstract int size ( ) ; public abstract int numDataNodes ( ) ; public abstract int numDataAndMasterNodes ( ) ; public abstract InetSocketAddress [ ] httpAddresses ( ) ; @Override public abstract void close ( ) throws IOException ; public void wipeIndices ( String . . . indices ) { assert indices ! = null & & indices . length > <int> ; if ( size ( ) > <int> ) { try { assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( indices ) ) ; } catch ( IndexNotFoundException e ) { } catch ( IllegalArgumentException e ) { if ( <str> . equals ( indices [ <int> ] ) ) { ClusterStateResponse clusterStateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) ; ObjectArrayList < String > concreteIndices = new ObjectArrayList < > ( ) ; for ( IndexMetaData indexMetaData : clusterStateResponse . getState ( ) . metaData ( ) ) { concreteIndices . add ( indexMetaData . getIndex ( ) ) ; } if ( ! concreteIndices . isEmpty ( ) ) { assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( concreteIndices . toArray ( String . class ) ) ) ; } } } } } public void wipeAllTemplates ( Set < String > exclude ) { if ( size ( ) > <int> ) { GetIndexTemplatesResponse response = client ( ) . admin ( ) . indices ( ) . prepareGetTemplates ( ) . get ( ) ; for ( IndexTemplateMetaData indexTemplate : response . getIndexTemplates ( ) ) { if ( exclude . contains ( indexTemplate . getName ( ) ) ) { continue ; } try { client ( ) . admin ( ) . indices ( ) . prepareDeleteTemplate ( indexTemplate . getName ( ) ) . execute ( ) . actionGet ( ) ; } catch ( IndexTemplateMissingException e ) { } } } } public void wipeTemplates ( String . . . templates ) { if ( size ( ) > <int> ) { if ( templates . length = = <int> ) { templates = new String [ ] { <str> } ; } for ( String template : templates ) { try { client ( ) . admin ( ) . indices ( ) . prepareDeleteTemplate ( template ) . execute ( ) . actionGet ( ) ; } catch ( IndexTemplateMissingException e ) { } } } } public void wipeRepositories ( String . . . repositories ) { if ( size ( ) > <int> ) { if ( repositories . length = = <int> ) { repositories = new String [ ] { <str> } ; } for ( String repository : repositories ) { try { client ( ) . admin ( ) . cluster ( ) . prepareDeleteRepository ( repository ) . execute ( ) . actionGet ( ) ; } catch ( RepositoryMissingException ex ) { } } } } public abstract void ensureEstimatedStats ( ) ; public abstract String getClusterName ( ) ; } 
