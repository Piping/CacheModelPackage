package org . elasticsearch . rest . action . admin . cluster . state ; import org . elasticsearch . action . admin . cluster . state . ClusterStateRequest ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . Requests ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import java . util . EnumSet ; public class RestClusterStateAction extends BaseRestHandler { private final SettingsFilter settingsFilter ; @Inject public RestClusterStateAction ( Settings settings , RestController controller , Client client , SettingsFilter settingsFilter ) { super ( settings , controller , client ) ; controller . registerHandler ( RestRequest . Method . GET , <str> , this ) ; controller . registerHandler ( RestRequest . Method . GET , <str> , this ) ; controller . registerHandler ( RestRequest . Method . GET , <str> , this ) ; this . settingsFilter = settingsFilter ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final ClusterStateRequest clusterStateRequest = Requests . clusterStateRequest ( ) ; clusterStateRequest . indicesOptions ( IndicesOptions . fromRequest ( request , clusterStateRequest . indicesOptions ( ) ) ) ; clusterStateRequest . local ( request . paramAsBoolean ( <str> , clusterStateRequest . local ( ) ) ) ; clusterStateRequest . masterNodeTimeout ( request . paramAsTime ( <str> , clusterStateRequest . masterNodeTimeout ( ) ) ) ; final String [ ] indices = Strings . splitStringByCommaToArray ( request . param ( <str> , <str> ) ) ; boolean isAllIndicesOnly = indices . length = = <int> & & <str> . equals ( indices [ <int> ] ) ; if ( ! isAllIndicesOnly ) { clusterStateRequest . indices ( indices ) ; } if ( request . hasParam ( <str> ) ) { EnumSet < ClusterState . Metric > metrics = ClusterState . Metric . parseString ( request . param ( <str> ) , true ) ; clusterStateRequest . nodes ( metrics . contains ( ClusterState . Metric . NODES ) | | metrics . contains ( ClusterState . Metric . MASTER_NODE ) ) ; clusterStateRequest . routingTable ( metrics . contains ( ClusterState . Metric . ROUTING_TABLE ) | | metrics . contains ( ClusterState . Metric . ROUTING_NODES ) ) ; clusterStateRequest . metaData ( metrics . contains ( ClusterState . Metric . METADATA ) ) ; clusterStateRequest . blocks ( metrics . contains ( ClusterState . Metric . BLOCKS ) ) ; clusterStateRequest . customs ( metrics . contains ( ClusterState . Metric . CUSTOMS ) ) ; } settingsFilter . addFilterSettingParams ( request ) ; client . admin ( ) . cluster ( ) . state ( clusterStateRequest , new RestBuilderListener < ClusterStateResponse > ( channel ) { @Override public RestResponse buildResponse ( ClusterStateResponse response , XContentBuilder builder ) throws Exception { builder . startObject ( ) ; builder . field ( Fields . CLUSTER_NAME , response . getClusterName ( ) . value ( ) ) ; response . getState ( ) . toXContent ( builder , request ) ; builder . endObject ( ) ; return new BytesRestResponse ( RestStatus . OK , builder ) ; } } ) ; } static final class Fields { static final XContentBuilderString CLUSTER_NAME = new XContentBuilderString ( <str> ) ; } } 
