package org . gradle . integtests . fixtures . executer ; import org . apache . commons . io . output . CloseShieldOutputStream ; import org . apache . commons . io . output . TeeOutputStream ; import org . gradle . api . Action ; import org . gradle . api . UncheckedIOException ; import org . gradle . internal . Factory ; import org . gradle . internal . UncheckedException ; import org . gradle . process . ExecResult ; import org . gradle . process . internal . AbstractExecHandleBuilder ; import org . gradle . process . internal . ExecHandle ; import org . gradle . process . internal . ExecHandleState ; import org . gradle . util . TextUtil ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . PipedOutputStream ; import java . io . UnsupportedEncodingException ; class ForkingGradleHandle extends OutputScrapingGradleHandle { final private Factory < ? extends AbstractExecHandleBuilder > execHandleFactory ; final private ByteArrayOutputStream standardOutput = new ByteArrayOutputStream ( ) ; final private ByteArrayOutputStream errorOutput = new ByteArrayOutputStream ( ) ; private final Action < ExecutionResult > resultAssertion ; private final PipedOutputStream stdinPipe ; private final boolean isDaemon ; private ExecHandle execHandle ; private final String outputEncoding ; public ForkingGradleHandle ( PipedOutputStream stdinPipe , boolean isDaemon , Action < ExecutionResult > resultAssertion , String outputEncoding , Factory < ? extends AbstractExecHandleBuilder > execHandleFactory ) { this . resultAssertion = resultAssertion ; this . execHandleFactory = execHandleFactory ; this . outputEncoding = outputEncoding ; this . isDaemon = isDaemon ; this . stdinPipe = stdinPipe ; } @Override public PipedOutputStream getStdinPipe ( ) { return stdinPipe ; } public String getStandardOutput ( ) { try { return standardOutput . toString ( outputEncoding ) ; } catch ( UnsupportedEncodingException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public String getErrorOutput ( ) { try { return errorOutput . toString ( outputEncoding ) ; } catch ( UnsupportedEncodingException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public GradleHandle start ( ) { if ( execHandle ! = null ) { throw new IllegalStateException ( <str> ) ; } AbstractExecHandleBuilder execBuilder = execHandleFactory . create ( ) ; execBuilder . setStandardOutput ( new CloseShieldOutputStream ( new TeeOutputStream ( System . out , standardOutput ) ) ) ; execBuilder . setErrorOutput ( new CloseShieldOutputStream ( new TeeOutputStream ( System . err , errorOutput ) ) ) ; execHandle = execBuilder . build ( ) ; execHandle . start ( ) ; return this ; } @Override public GradleHandle cancel ( ) { if ( stdinPipe = = null ) { throw new UnsupportedOperationException ( <str> ) ; } try { stdinPipe . close ( ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } return this ; } @Override public GradleHandle cancelWithEOT ( ) { if ( stdinPipe = = null ) { throw new UnsupportedOperationException ( <str> ) ; } try { stdinPipe . write ( <int> ) ; if ( isDaemon ) { stdinPipe . write ( TextUtil . toPlatformLineSeparators ( <str> ) . getBytes ( ) ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } return this ; } public GradleHandle abort ( ) { getExecHandle ( ) . abort ( ) ; return this ; } public boolean isRunning ( ) { return execHandle ! = null & & execHandle . getState ( ) = = ExecHandleState . STARTED ; } protected ExecHandle getExecHandle ( ) { if ( execHandle = = null ) { throw new IllegalStateException ( <str> ) ; } return execHandle ; } public ExecutionResult waitForFinish ( ) { return waitForStop ( false ) ; } public ExecutionFailure waitForFailure ( ) { return ( ExecutionFailure ) waitForStop ( true ) ; } @Override public void waitForExit ( ) { getExecHandle ( ) . waitForFinish ( ) . rethrowFailure ( ) ; } protected ExecutionResult waitForStop ( boolean expectFailure ) { ExecHandle execHandle = getExecHandle ( ) ; ExecResult execResult = execHandle . waitForFinish ( ) ; execResult . rethrowFailure ( ) ; String output = getStandardOutput ( ) ; String error = getErrorOutput ( ) ; boolean didFail = execResult . getExitValue ( ) ! = <int> ; if ( didFail ! = expectFailure ) { String message = String . format ( <str> , expectFailure ? <str> : <str> , execHandle . getDirectory ( ) , execHandle . getCommand ( ) , execHandle . getArguments ( ) , output , error ) ; throw new UnexpectedBuildFailure ( message ) ; } ExecutionResult executionResult = expectFailure ? toExecutionFailure ( output , error ) : toExecutionResult ( output , error ) ; resultAssertion . execute ( executionResult ) ; return executionResult ; } } 
