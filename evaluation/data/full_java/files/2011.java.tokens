package org . nd4j . linalg . api . ops . executioner ; import lombok . AllArgsConstructor ; import lombok . Data ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . util . ArrayUtil ; import java . util . Arrays ; public class OpExecutionerUtil { public static boolean canDoOpDirectly ( INDArray x ) { if ( x . isVector ( ) ) return true ; int l1 = x . length ( ) ; int dl1 = x . data ( ) . length ( ) ; if ( l1 = = dl1 ) return true ; int [ ] shape1 = x . shape ( ) ; int [ ] stridesAsInit = ( x . ordering ( ) = = <str> ? ArrayUtil . calcStrides ( shape1 ) : ArrayUtil . calcStridesFortran ( shape1 ) ) ; boolean stridesSameAsInit = Arrays . equals ( x . stride ( ) , stridesAsInit ) ; return stridesSameAsInit ; } public static boolean canDoOpDirectly ( INDArray x , INDArray y ) { if ( x . isVector ( ) ) return true ; if ( x . ordering ( ) ! = y . ordering ( ) ) return false ; int l1 = x . length ( ) ; int dl1 = x . data ( ) . length ( ) ; int l2 = y . length ( ) ; int dl2 = y . data ( ) . length ( ) ; int [ ] strides1 = x . stride ( ) ; int [ ] strides2 = y . stride ( ) ; boolean equalStrides = Arrays . equals ( strides1 , strides2 ) ; if ( l1 = = dl1 & & l2 = = dl2 & & equalStrides ) return true ; if ( equalStrides ) { int [ ] shape1 = x . shape ( ) ; int [ ] stridesAsInit = ( x . ordering ( ) = = <str> ? ArrayUtil . calcStrides ( shape1 ) : ArrayUtil . calcStridesFortran ( shape1 ) ) ; boolean stridesSameAsInit = Arrays . equals ( strides1 , stridesAsInit ) ; return stridesSameAsInit ; } return false ; } public static boolean canDoOpDirectly ( INDArray x , INDArray y , INDArray z ) { if ( x . isVector ( ) ) return true ; if ( x . ordering ( ) ! = y . ordering ( ) | | x . ordering ( ) ! = z . ordering ( ) ) return false ; int l1 = x . length ( ) ; int dl1 = x . data ( ) . length ( ) ; int l2 = y . length ( ) ; int dl2 = y . data ( ) . length ( ) ; int l3 = z . length ( ) ; int dl3 = z . data ( ) . length ( ) ; int [ ] strides1 = x . stride ( ) ; int [ ] strides2 = y . stride ( ) ; int [ ] strides3 = z . stride ( ) ; boolean equalStrides = Arrays . equals ( strides1 , strides2 ) & & Arrays . equals ( strides1 , strides3 ) ; if ( l1 = = dl1 & & l2 = = dl2 & & l3 = = dl3 & & equalStrides ) return true ; if ( equalStrides ) { int [ ] shape1 = x . shape ( ) ; int [ ] stridesAsInit = ( x . ordering ( ) = = <str> ? ArrayUtil . calcStrides ( shape1 ) : ArrayUtil . calcStridesFortran ( shape1 ) ) ; boolean stridesSameAsInit = Arrays . equals ( strides1 , stridesAsInit ) ; return stridesSameAsInit ; } return false ; } public static int chooseElementWiseTensorDimension ( INDArray x ) { if ( x . isVector ( ) ) return ArrayUtil . argMax ( x . shape ( ) ) ; int opAlongDimensionMinStride = ArrayUtil . argMin ( x . stride ( ) ) ; int opAlongDimensionMaxLength = ArrayUtil . argMax ( x . shape ( ) ) ; if ( x . isVector ( ) | | x . size ( opAlongDimensionMinStride ) = = <int> ) return opAlongDimensionMaxLength ; int nOpsAlongMinStride = ArrayUtil . prod ( ArrayUtil . removeIndex ( x . shape ( ) , opAlongDimensionMinStride ) ) ; int nOpsAlongMaxLength = ArrayUtil . prod ( ArrayUtil . removeIndex ( x . shape ( ) , opAlongDimensionMaxLength ) ) ; if ( nOpsAlongMinStride < = <int> * nOpsAlongMaxLength ) return opAlongDimensionMinStride ; else return opAlongDimensionMaxLength ; } public static int chooseElementWiseTensorDimension ( INDArray x , INDArray y ) { if ( x . isVector ( ) ) return ArrayUtil . argMax ( x . shape ( ) ) ; int opAlongDimensionMinStride = ArrayUtil . argMinOfMax ( x . stride ( ) , y . stride ( ) ) ; int opAlongDimensionMaxLength = ArrayUtil . argMax ( x . shape ( ) ) ; if ( opAlongDimensionMinStride = = opAlongDimensionMaxLength | | x . size ( opAlongDimensionMinStride ) = = <int> ) return opAlongDimensionMaxLength ; int nOpsAlongMinStride = ArrayUtil . prod ( ArrayUtil . removeIndex ( x . shape ( ) , opAlongDimensionMinStride ) ) ; int nOpsAlongMaxLength = ArrayUtil . prod ( ArrayUtil . removeIndex ( x . shape ( ) , opAlongDimensionMaxLength ) ) ; if ( nOpsAlongMinStride < = <int> * nOpsAlongMaxLength ) return opAlongDimensionMinStride ; else return opAlongDimensionMaxLength ; } public static int chooseElementWiseTensorDimension ( INDArray x , INDArray y , INDArray z ) { if ( x . isVector ( ) ) return ArrayUtil . argMax ( x . shape ( ) ) ; int opAlongDimensionMinStride = ArrayUtil . argMinOfMax ( x . stride ( ) , y . stride ( ) , z . stride ( ) ) ; int opAlongDimensionMaxLength = ArrayUtil . argMax ( x . shape ( ) ) ; if ( opAlongDimensionMinStride = = opAlongDimensionMaxLength | | x . size ( opAlongDimensionMinStride ) = = <int> ) return opAlongDimensionMaxLength ; int nOpsAlongMinStride = ArrayUtil . prod ( ArrayUtil . removeIndex ( x . shape ( ) , opAlongDimensionMinStride ) ) ; int nOpsAlongMaxLength = ArrayUtil . prod ( ArrayUtil . removeIndex ( x . shape ( ) , opAlongDimensionMaxLength ) ) ; if ( nOpsAlongMinStride < = <int> * nOpsAlongMaxLength ) return opAlongDimensionMinStride ; else return opAlongDimensionMaxLength ; } public static Tensor1DStats get1DTensorStats ( INDArray array , int . . . dimension ) { int tensorLength = array . size ( dimension [ <int> ] ) ; int numTensors = array . tensorssAlongDimension ( dimension ) ; int firstTensorOffset = array . offset ( ) ; int tensorStartSeparation ; int elementWiseStride ; if ( numTensors = = <int> ) { tensorStartSeparation = - <int> ; elementWiseStride = array . elementWiseStride ( ) ; } else { INDArray secondTensor = array . tensorAlongDimension ( <int> , dimension ) ; tensorStartSeparation = secondTensor . offset ( ) - firstTensorOffset ; elementWiseStride = secondTensor . elementWiseStride ( ) ; } return new Tensor1DStats ( firstTensorOffset , tensorStartSeparation , numTensors , tensorLength , elementWiseStride ) ; } @AllArgsConstructor @Data public static class Tensor1DStats { public final int firstTensorOffset ; public final int tensorStartSeparation ; public final int numTensors ; public final int tensorLength ; public final int elementWiseStride ; } } 
