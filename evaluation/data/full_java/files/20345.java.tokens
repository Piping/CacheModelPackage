package io . netty . channel . group ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . netty . util . concurrent . GlobalEventExecutor ; import org . junit . Test ; public class DefaultChannnelGroupTest { @Test public void testNotThrowBlockingOperationException ( ) throws Exception { EventLoopGroup bossGroup = new NioEventLoopGroup ( ) ; EventLoopGroup workerGroup = new NioEventLoopGroup ( ) ; final ChannelGroup allChannels = new DefaultChannelGroup ( GlobalEventExecutor . INSTANCE ) ; ServerBootstrap b = new ServerBootstrap ( ) ; b . group ( bossGroup , workerGroup ) ; b . childHandler ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelActive ( ChannelHandlerContext ctx ) { allChannels . add ( ctx . channel ( ) ) ; } } ) ; b . channel ( NioServerSocketChannel . class ) ; ChannelFuture f = b . bind ( <int> ) . syncUninterruptibly ( ) ; if ( f . isSuccess ( ) ) { allChannels . add ( f . channel ( ) ) ; allChannels . close ( ) . awaitUninterruptibly ( ) ; } bossGroup . shutdownGracefully ( ) ; workerGroup . shutdownGracefully ( ) ; bossGroup . terminationFuture ( ) . sync ( ) ; workerGroup . terminationFuture ( ) . sync ( ) ; } } 
