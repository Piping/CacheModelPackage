package org . elasticsearch . common . rounding ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESTestCase ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import org . joda . time . format . ISODateTimeFormat ; import java . util . concurrent . TimeUnit ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class TimeZoneRoundingTests extends ESTestCase { final static DateTimeZone JERUSALEM_TIMEZONE = DateTimeZone . forID ( <str> ) ; public void testUTCTimeUnitRounding ( ) { Rounding tzRounding = TimeZoneRounding . builder ( DateTimeUnit . MONTH_OF_YEAR ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . WEEK_OF_WEEKYEAR ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . WEEK_OF_WEEKYEAR ) . offset ( - TimeValue . timeValueHours ( <int> ) . millis ( ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; } public void testUTCIntervalRounding ( ) { Rounding tzRounding = TimeZoneRounding . builder ( TimeValue . timeValueHours ( <int> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; long roundKey = tzRounding . roundKey ( utc ( <str> ) ) ; assertThat ( roundKey , equalTo ( tzRounding . roundKey ( utc ( <str> ) ) ) ) ; assertThat ( tzRounding . valueForKey ( roundKey ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; tzRounding = TimeZoneRounding . builder ( TimeValue . timeValueHours ( <int> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; } public void testTimeIntervalTimeZoneRounding ( ) { Rounding tzRounding = TimeZoneRounding . builder ( TimeValue . timeValueHours ( <int> ) ) . timeZone ( DateTimeZone . forOffsetHours ( - <int> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; long roundKey = tzRounding . roundKey ( utc ( <str> ) ) ; assertThat ( roundKey , equalTo ( tzRounding . roundKey ( utc ( <str> ) ) ) ) ; assertThat ( tzRounding . valueForKey ( roundKey ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; } public void testDayIntervalTimeZoneRounding ( ) { Rounding tzRounding = TimeZoneRounding . builder ( TimeValue . timeValueHours ( <int> ) ) . timeZone ( DateTimeZone . forOffsetHours ( - <int> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; long roundKey = tzRounding . roundKey ( utc ( <str> ) ) ; assertThat ( roundKey , equalTo ( tzRounding . roundKey ( utc ( <str> ) ) ) ) ; assertThat ( tzRounding . valueForKey ( roundKey ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; } public void testDayTimeZoneRounding ( ) { int timezoneOffset = - <int> ; Rounding tzRounding = TimeZoneRounding . builder ( DateTimeUnit . DAY_OF_MONTH ) . timeZone ( DateTimeZone . forOffsetHours ( timezoneOffset ) ) . build ( ) ; assertThat ( tzRounding . round ( <int> ) , equalTo ( <int> l - TimeValue . timeValueHours ( <int> + timezoneOffset ) . millis ( ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( <int> l - TimeValue . timeValueHours ( <int> + timezoneOffset ) . millis ( ) ) , equalTo ( <int> l - TimeValue . timeValueHours ( timezoneOffset ) . millis ( ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . DAY_OF_MONTH ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( toUTCDateString ( tzRounding . nextRoundingValue ( utc ( <str> ) ) ) , equalTo ( toUTCDateString ( utc ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . MONTH_OF_YEAR ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( toUTCDateString ( tzRounding . nextRoundingValue ( utc ( <str> ) ) ) , equalTo ( toUTCDateString ( utc ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . DAY_OF_MONTH ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; long roundKey = tzRounding . roundKey ( utc ( <str> ) ) ; assertThat ( roundKey , equalTo ( tzRounding . roundKey ( utc ( <str> ) ) ) ) ; assertThat ( tzRounding . valueForKey ( roundKey ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . DAY_OF_MONTH ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; roundKey = tzRounding . roundKey ( utc ( <str> ) ) ; assertThat ( roundKey , equalTo ( tzRounding . roundKey ( utc ( <str> ) ) ) ) ; assertThat ( tzRounding . valueForKey ( roundKey ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; } public void testTimeTimeZoneRounding ( ) { Rounding tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forOffsetHours ( - <int> ) ) . build ( ) ; assertThat ( tzRounding . round ( <int> ) , equalTo ( <int> l ) ) ; assertThat ( tzRounding . nextRoundingValue ( <int> l ) , equalTo ( TimeValue . timeValueHours ( <int> ) . getMillis ( ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forOffsetHours ( - <int> ) ) . build ( ) ; assertThat ( tzRounding . round ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; assertThat ( tzRounding . nextRoundingValue ( utc ( <str> ) ) , equalTo ( utc ( <str> ) ) ) ; } public void testTimeUnitRoundingDST ( ) { Rounding tzRounding ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( DateTimeZone . forID ( <str> ) ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) , equalTo ( time ( <str> , DateTimeZone . forID ( <str> ) ) ) ) ; } public void testTimeZoneRoundingRandom ( ) { for ( int i = <int> ; i < <int> ; + + i ) { DateTimeUnit timeUnit = randomTimeUnit ( ) ; TimeZoneRounding rounding ; int timezoneOffset = randomIntBetween ( - <int> , <int> ) ; rounding = new TimeZoneRounding . TimeUnitRounding ( timeUnit , DateTimeZone . forOffsetHours ( timezoneOffset ) ) ; long date = Math . abs ( randomLong ( ) % ( ( long ) <int> e11 ) ) ; final long roundedDate = rounding . round ( date ) ; final long nextRoundingValue = rounding . nextRoundingValue ( roundedDate ) ; assertThat ( <str> , roundedDate , equalTo ( rounding . round ( roundedDate ) ) ) ; assertThat ( <str> , roundedDate , lessThanOrEqualTo ( date ) ) ; assertThat ( <str> , nextRoundingValue , greaterThan ( roundedDate ) ) ; assertThat ( <str> , nextRoundingValue , equalTo ( rounding . round ( nextRoundingValue ) ) ) ; } } public void testIntervalRoundingRandom ( ) { for ( int i = <int> ; i < <int> ; + + i ) { long interval = Math . abs ( randomLong ( ) % ( TimeUnit . DAYS . toMillis ( <int> ) ) ) ; TimeZoneRounding rounding ; int timezoneOffset = randomIntBetween ( - <int> , <int> ) ; rounding = new TimeZoneRounding . TimeIntervalRounding ( interval , DateTimeZone . forOffsetHours ( timezoneOffset ) ) ; long date = Math . abs ( randomLong ( ) % ( ( long ) <int> e11 ) ) ; final long roundedDate = rounding . round ( date ) ; final long nextRoundingValue = rounding . nextRoundingValue ( roundedDate ) ; assertThat ( <str> , roundedDate , equalTo ( rounding . round ( roundedDate ) ) ) ; assertThat ( <str> , roundedDate , lessThanOrEqualTo ( date ) ) ; assertThat ( <str> , nextRoundingValue , greaterThan ( roundedDate ) ) ; assertThat ( <str> , nextRoundingValue - roundedDate , equalTo ( interval ) ) ; assertThat ( <str> , nextRoundingValue , equalTo ( rounding . round ( nextRoundingValue ) ) ) ; } } public void testAmbiguousHoursAfterDSTSwitch ( ) { Rounding tzRounding ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . HOUR_OF_DAY ) . timeZone ( JERUSALEM_TIMEZONE ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . UTC ) ) , equalTo ( time ( <str> , DateTimeZone . UTC ) ) ) ; assertThat ( tzRounding . round ( time ( <str> , DateTimeZone . UTC ) ) , equalTo ( time ( <str> , DateTimeZone . UTC ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . DAY_OF_MONTH ) . timeZone ( JERUSALEM_TIMEZONE ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) , equalTo ( time ( <str> , JERUSALEM_TIMEZONE ) ) ) ; assertThat ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) , equalTo ( time ( <str> , JERUSALEM_TIMEZONE ) ) ) ; assertThat ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) , equalTo ( time ( <str> , JERUSALEM_TIMEZONE ) ) ) ; assertThat ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) , equalTo ( time ( <str> , JERUSALEM_TIMEZONE ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . MONTH_OF_YEAR ) . timeZone ( JERUSALEM_TIMEZONE ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) , equalTo ( time ( <str> , JERUSALEM_TIMEZONE ) ) ) ; assertThat ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) , equalTo ( time ( <str> , JERUSALEM_TIMEZONE ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . YEAR_OF_CENTURY ) . timeZone ( JERUSALEM_TIMEZONE ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) , equalTo ( time ( <str> , JERUSALEM_TIMEZONE ) ) ) ; tzRounding = TimeZoneRounding . builder ( DateTimeUnit . YEAR_OF_CENTURY ) . timeZone ( JERUSALEM_TIMEZONE ) . build ( ) ; assertThat ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) , equalTo ( tzRounding . round ( time ( <str> , JERUSALEM_TIMEZONE ) ) ) ) ; } public void testLenientConversionDST ( ) { DateTimeZone tz = DateTimeZone . forID ( <str> ) ; long start = time ( <str> , tz ) ; long end = time ( <str> , tz ) ; Rounding tzRounding = new TimeZoneRounding . TimeUnitRounding ( DateTimeUnit . MINUTES_OF_HOUR , tz ) ; Rounding dayTzRounding = new TimeZoneRounding . TimeIntervalRounding ( <int> , tz ) ; for ( long time = start ; time < end ; time = time + <int> ) { assertThat ( tzRounding . nextRoundingValue ( time ) , greaterThan ( time ) ) ; assertThat ( dayTzRounding . nextRoundingValue ( time ) , greaterThan ( time ) ) ; } } private DateTimeUnit randomTimeUnit ( ) { byte id = ( byte ) randomIntBetween ( <int> , <int> ) ; return DateTimeUnit . resolve ( id ) ; } private String toUTCDateString ( long time ) { return new DateTime ( time , DateTimeZone . UTC ) . toString ( ) ; } private long utc ( String time ) { return time ( time , DateTimeZone . UTC ) ; } private long time ( String time , DateTimeZone zone ) { return ISODateTimeFormat . dateOptionalTimeParser ( ) . withZone ( zone ) . parseMillis ( time ) ; } } 
