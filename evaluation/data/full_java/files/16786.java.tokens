package com . badlogic . gdx . backends . lwjgl ; import java . awt . Canvas ; import java . awt . Toolkit ; import java . nio . ByteBuffer ; import org . lwjgl . LWJGLException ; import org . lwjgl . opengl . ContextAttribs ; import org . lwjgl . opengl . Display ; import org . lwjgl . opengl . GL11 ; import org . lwjgl . opengl . PixelFormat ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Graphics ; import com . badlogic . gdx . graphics . Cursor ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . GL30 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class LwjglGraphics implements Graphics { static int major , minor , release ; static Array < String > extensions ; GL20 gl20 ; GL30 gl30 ; long frameId = - <int> ; float deltaTime = <int> ; long frameStart = <int> ; int frames = <int> ; int fps ; long lastTime = System . nanoTime ( ) ; Canvas canvas ; boolean vsync = false ; boolean resize = false ; LwjglApplicationConfiguration config ; BufferFormat bufferFormat = new BufferFormat ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; volatile boolean isContinuous = true ; volatile boolean requestRendering = false ; boolean softwareMode ; boolean usingGL30 ; LwjglGraphics ( LwjglApplicationConfiguration config ) { this . config = config ; } LwjglGraphics ( Canvas canvas ) { this . config = new LwjglApplicationConfiguration ( ) ; config . width = canvas . getWidth ( ) ; config . height = canvas . getHeight ( ) ; this . canvas = canvas ; } LwjglGraphics ( Canvas canvas , LwjglApplicationConfiguration config ) { this . config = config ; this . canvas = canvas ; } public GL20 getGL20 ( ) { return gl20 ; } public int getHeight ( ) { if ( canvas ! = null ) return Math . max ( <int> , canvas . getHeight ( ) ) ; else return ( int ) ( Display . getHeight ( ) * Display . getPixelScaleFactor ( ) ) ; } public int getWidth ( ) { if ( canvas ! = null ) return Math . max ( <int> , canvas . getWidth ( ) ) ; else return ( int ) ( Display . getWidth ( ) * Display . getPixelScaleFactor ( ) ) ; } public boolean isGL20Available ( ) { return gl20 ! = null ; } public long getFrameId ( ) { return frameId ; } public float getDeltaTime ( ) { return deltaTime ; } public float getRawDeltaTime ( ) { return deltaTime ; } public GraphicsType getType ( ) { return GraphicsType . LWJGL ; } public int getFramesPerSecond ( ) { return fps ; } void updateTime ( ) { long time = System . nanoTime ( ) ; deltaTime = ( time - lastTime ) / <float> ; lastTime = time ; if ( time - frameStart > = <int> ) { fps = frames ; frames = <int> ; frameStart = time ; } frames + + ; } void setupDisplay ( ) throws LWJGLException { if ( config . useHDPI ) { System . setProperty ( <str> , <str> ) ; } if ( canvas ! = null ) { Display . setParent ( canvas ) ; } else { boolean displayCreated = setDisplayMode ( config . width , config . height , config . fullscreen ) ; if ( ! displayCreated ) { if ( config . setDisplayModeCallback ! = null ) { config = config . setDisplayModeCallback . onFailure ( config ) ; if ( config ! = null ) { displayCreated = setDisplayMode ( config . width , config . height , config . fullscreen ) ; } } if ( ! displayCreated ) { throw new GdxRuntimeException ( <str> + config . width + <str> + config . height + <str> + config . fullscreen ) ; } } if ( config . iconPaths . size > <int> ) { ByteBuffer [ ] icons = new ByteBuffer [ config . iconPaths . size ] ; for ( int i = <int> , n = config . iconPaths . size ; i < n ; i + + ) { Pixmap pixmap = new Pixmap ( Gdx . files . getFileHandle ( config . iconPaths . get ( i ) , config . iconFileTypes . get ( i ) ) ) ; if ( pixmap . getFormat ( ) ! = Format . RGBA8888 ) { Pixmap rgba = new Pixmap ( pixmap . getWidth ( ) , pixmap . getHeight ( ) , Format . RGBA8888 ) ; rgba . drawPixmap ( pixmap , <int> , <int> ) ; pixmap = rgba ; } icons [ i ] = ByteBuffer . allocateDirect ( pixmap . getPixels ( ) . limit ( ) ) ; icons [ i ] . put ( pixmap . getPixels ( ) ) . flip ( ) ; pixmap . dispose ( ) ; } Display . setIcon ( icons ) ; } } Display . setTitle ( config . title ) ; Display . setResizable ( config . resizable ) ; Display . setInitialBackground ( config . initialBackgroundColor . r , config . initialBackgroundColor . g , config . initialBackgroundColor . b ) ; Display . setLocation ( config . x , config . y ) ; createDisplayPixelFormat ( config . useGL30 , config . gles30ContextMajorVersion , config . gles30ContextMinorVersion ) ; initiateGL ( ) ; } void initiateGL ( ) { extractVersion ( ) ; extractExtensions ( ) ; initiateGLInstances ( ) ; } private static void extractVersion ( ) { String version = org . lwjgl . opengl . GL11 . glGetString ( GL11 . GL_VERSION ) ; try { String [ ] v = version . split ( <str> , <int> ) [ <int> ] . split ( <str> , <int> ) ; major = Integer . parseInt ( v [ <int> ] ) ; minor = Integer . parseInt ( v [ <int> ] ) ; release = v . length > <int> ? Integer . parseInt ( v [ <int> ] ) : <int> ; } catch ( Throwable t ) { throw new GdxRuntimeException ( <str> + version , t ) ; } } private static void extractExtensions ( ) { extensions = new Array < String > ( ) ; if ( isOpenGLOrHigher ( <int> , <int> ) ) { int numExtensions = GL11 . glGetInteger ( GL30 . GL_NUM_EXTENSIONS ) ; for ( int i = <int> ; i < numExtensions ; + + i ) extensions . add ( org . lwjgl . opengl . GL30 . glGetStringi ( GL20 . GL_EXTENSIONS , i ) ) ; } else { extensions . addAll ( org . lwjgl . opengl . GL11 . glGetString ( GL20 . GL_EXTENSIONS ) . split ( <str> ) ) ; } } private static boolean isOpenGLOrHigher ( int major , int minor ) { return LwjglGraphics . major > major | | ( LwjglGraphics . major = = major & & LwjglGraphics . minor > = minor ) ; } private static boolean fullCompatibleWithGLES3 ( ) { return isOpenGLOrHigher ( <int> , <int> ) ; } private static boolean fullCompatibleWithGLES2 ( ) { return isOpenGLOrHigher ( <int> , <int> ) | | extensions . contains ( <str> , false ) ; } private static boolean supportsFBO ( ) { return isOpenGLOrHigher ( <int> , <int> ) | | extensions . contains ( <str> , false ) | | extensions . contains ( <str> , false ) ; } private void createDisplayPixelFormat ( boolean useGL30 , int gles30ContextMajor , int gles30ContextMinor ) { try { if ( useGL30 ) { ContextAttribs context = new ContextAttribs ( gles30ContextMajor , gles30ContextMinor ) . withForwardCompatible ( false ) . withProfileCore ( true ) ; try { Display . create ( new PixelFormat ( config . r + config . g + config . b , config . a , config . depth , config . stencil , config . samples ) , context ) ; } catch ( Exception e ) { System . out . println ( <str> + gles30ContextMajor + <str> + gles30ContextMinor + <str> ) ; createDisplayPixelFormat ( false , gles30ContextMajor , gles30ContextMinor ) ; return ; } System . out . println ( <str> + gles30ContextMajor + <str> + gles30ContextMinor + <str> ) ; usingGL30 = true ; } else { Display . create ( new PixelFormat ( config . r + config . g + config . b , config . a , config . depth , config . stencil , config . samples ) ) ; usingGL30 = false ; } bufferFormat = new BufferFormat ( config . r , config . g , config . b , config . a , config . depth , config . stencil , config . samples , false ) ; } catch ( Exception ex ) { Display . destroy ( ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException ignored ) { } try { Display . create ( new PixelFormat ( <int> , <int> , <int> ) ) ; if ( getDesktopDisplayMode ( ) . bitsPerPixel = = <int> ) { bufferFormat = new BufferFormat ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; } if ( getDesktopDisplayMode ( ) . bitsPerPixel = = <int> ) { bufferFormat = new BufferFormat ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; } if ( getDesktopDisplayMode ( ) . bitsPerPixel = = <int> ) { bufferFormat = new BufferFormat ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; } } catch ( Exception ex2 ) { Display . destroy ( ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException ignored ) { } try { Display . create ( new PixelFormat ( ) ) ; } catch ( Exception ex3 ) { if ( ! softwareMode & & config . allowSoftwareMode ) { softwareMode = true ; System . setProperty ( <str> , <str> ) ; createDisplayPixelFormat ( useGL30 , gles30ContextMajor , gles30ContextMinor ) ; return ; } String glInfo = glInfo ( ) ; throw new GdxRuntimeException ( <str> + ( glInfo . isEmpty ( ) ? <str> : ( <str> + glInfo ( ) ) ) , ex3 ) ; } if ( getDesktopDisplayMode ( ) . bitsPerPixel = = <int> ) { bufferFormat = new BufferFormat ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; } if ( getDesktopDisplayMode ( ) . bitsPerPixel = = <int> ) { bufferFormat = new BufferFormat ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; } if ( getDesktopDisplayMode ( ) . bitsPerPixel = = <int> ) { bufferFormat = new BufferFormat ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; } } } } public void initiateGLInstances ( ) { if ( usingGL30 ) { gl30 = new LwjglGL30 ( ) ; gl20 = gl30 ; } else { gl20 = new LwjglGL20 ( ) ; } if ( ! isOpenGLOrHigher ( <int> , <int> ) ) throw new GdxRuntimeException ( <str> + GL11 . glGetString ( GL11 . GL_VERSION ) + <str> + glInfo ( ) ) ; if ( ! supportsFBO ( ) ) { throw new GdxRuntimeException ( <str> + GL11 . glGetString ( GL11 . GL_VERSION ) + <str> + glInfo ( ) ) ; } Gdx . gl = gl20 ; Gdx . gl20 = gl20 ; Gdx . gl30 = gl30 ; } private String glInfo ( ) { try { return GL11 . glGetString ( GL11 . GL_VENDOR ) + <str> + GL11 . glGetString ( GL11 . GL_RENDERER ) + <str> + GL11 . glGetString ( GL11 . GL_VERSION ) ; } catch ( Throwable ignored ) { } return <str> ; } @Override public float getPpiX ( ) { return Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) ; } @Override public float getPpiY ( ) { return Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) ; } @Override public float getPpcX ( ) { return ( Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) / <float> ) ; } @Override public float getPpcY ( ) { return ( Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) / <float> ) ; } @Override public float getDensity ( ) { if ( config . overrideDensity ! = - <int> ) return config . overrideDensity / <int> f ; return ( Toolkit . getDefaultToolkit ( ) . getScreenResolution ( ) / <int> f ) ; } @Override public boolean supportsDisplayModeChange ( ) { return true ; } private class LwjglDisplayMode extends DisplayMode { org . lwjgl . opengl . DisplayMode mode ; public LwjglDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel , org . lwjgl . opengl . DisplayMode mode ) { super ( width , height , refreshRate , bitsPerPixel ) ; this . mode = mode ; } } @Override public boolean setDisplayMode ( DisplayMode displayMode ) { org . lwjgl . opengl . DisplayMode mode = ( ( LwjglDisplayMode ) displayMode ) . mode ; try { if ( ! mode . isFullscreenCapable ( ) ) { Display . setDisplayMode ( mode ) ; } else { Display . setDisplayModeAndFullscreen ( mode ) ; } float scaleFactor = Display . getPixelScaleFactor ( ) ; config . width = ( int ) ( mode . getWidth ( ) * scaleFactor ) ; config . height = ( int ) ( mode . getHeight ( ) * scaleFactor ) ; if ( Gdx . gl ! = null ) Gdx . gl . glViewport ( <int> , <int> , config . width , config . height ) ; resize = true ; return true ; } catch ( LWJGLException e ) { return false ; } } @Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { if ( getWidth ( ) = = width & & getHeight ( ) = = height & & Display . isFullscreen ( ) = = fullscreen ) { return true ; } try { org . lwjgl . opengl . DisplayMode targetDisplayMode = null ; if ( fullscreen ) { org . lwjgl . opengl . DisplayMode [ ] modes = Display . getAvailableDisplayModes ( ) ; int freq = <int> ; for ( int i = <int> ; i < modes . length ; i + + ) { org . lwjgl . opengl . DisplayMode current = modes [ i ] ; if ( ( current . getWidth ( ) = = width ) & & ( current . getHeight ( ) = = height ) ) { if ( ( targetDisplayMode = = null ) | | ( current . getFrequency ( ) > = freq ) ) { if ( ( targetDisplayMode = = null ) | | ( current . getBitsPerPixel ( ) > targetDisplayMode . getBitsPerPixel ( ) ) ) { targetDisplayMode = current ; freq = targetDisplayMode . getFrequency ( ) ; } } if ( ( current . getBitsPerPixel ( ) = = Display . getDesktopDisplayMode ( ) . getBitsPerPixel ( ) ) & & ( current . getFrequency ( ) = = Display . getDesktopDisplayMode ( ) . getFrequency ( ) ) ) { targetDisplayMode = current ; break ; } } } } else { targetDisplayMode = new org . lwjgl . opengl . DisplayMode ( width , height ) ; } if ( targetDisplayMode = = null ) { return false ; } boolean resizable = ! fullscreen & & config . resizable ; Display . setDisplayMode ( targetDisplayMode ) ; Display . setFullscreen ( fullscreen ) ; if ( resizable = = Display . isResizable ( ) ) { Display . setResizable ( ! resizable ) ; } Display . setResizable ( resizable ) ; float scaleFactor = Display . getPixelScaleFactor ( ) ; config . width = ( int ) ( targetDisplayMode . getWidth ( ) * scaleFactor ) ; config . height = ( int ) ( targetDisplayMode . getHeight ( ) * scaleFactor ) ; if ( Gdx . gl ! = null ) Gdx . gl . glViewport ( <int> , <int> , config . width , config . height ) ; resize = true ; return true ; } catch ( LWJGLException e ) { return false ; } } @Override public DisplayMode [ ] getDisplayModes ( ) { try { org . lwjgl . opengl . DisplayMode [ ] availableDisplayModes = Display . getAvailableDisplayModes ( ) ; DisplayMode [ ] modes = new DisplayMode [ availableDisplayModes . length ] ; int idx = <int> ; for ( org . lwjgl . opengl . DisplayMode mode : availableDisplayModes ) { if ( mode . isFullscreenCapable ( ) ) { modes [ idx + + ] = new LwjglDisplayMode ( mode . getWidth ( ) , mode . getHeight ( ) , mode . getFrequency ( ) , mode . getBitsPerPixel ( ) , mode ) ; } } return modes ; } catch ( LWJGLException e ) { throw new GdxRuntimeException ( <str> , e ) ; } } @Override public DisplayMode getDesktopDisplayMode ( ) { org . lwjgl . opengl . DisplayMode mode = Display . getDesktopDisplayMode ( ) ; return new LwjglDisplayMode ( mode . getWidth ( ) , mode . getHeight ( ) , mode . getFrequency ( ) , mode . getBitsPerPixel ( ) , mode ) ; } @Override public void setTitle ( String title ) { Display . setTitle ( title ) ; } @Override public BufferFormat getBufferFormat ( ) { return bufferFormat ; } @Override public void setVSync ( boolean vsync ) { this . vsync = vsync ; Display . setVSyncEnabled ( vsync ) ; } @Override public boolean supportsExtension ( String extension ) { return extensions . contains ( extension , false ) ; } @Override public void setContinuousRendering ( boolean isContinuous ) { this . isContinuous = isContinuous ; } @Override public boolean isContinuousRendering ( ) { return isContinuous ; } @Override public void requestRendering ( ) { synchronized ( this ) { requestRendering = true ; } } public boolean shouldRender ( ) { synchronized ( this ) { boolean rq = requestRendering ; requestRendering = false ; return rq | | isContinuous | | Display . isDirty ( ) ; } } @Override public boolean isFullscreen ( ) { return Display . isFullscreen ( ) ; } public boolean isSoftwareMode ( ) { return softwareMode ; } @Override public boolean isGL30Available ( ) { return gl30 ! = null ; } @Override public GL30 getGL30 ( ) { return gl30 ; } public interface SetDisplayModeCallback { public LwjglApplicationConfiguration onFailure ( LwjglApplicationConfiguration initialConfig ) ; } @Override public com . badlogic . gdx . graphics . Cursor newCursor ( Pixmap pixmap , int xHotspot , int yHotspot ) { return new LwjglCursor ( pixmap , xHotspot , yHotspot ) ; } @Override public void setCursor ( com . badlogic . gdx . graphics . Cursor cursor ) { if ( cursor = = null ) { LwjglCursor . resetCursor ( ) ; } else { cursor . setSystemCursor ( ) ; } } } 
