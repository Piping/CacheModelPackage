package org . apache . cassandra . db . columniterator ; import java . io . IOException ; import java . util . NoSuchElementException ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . util . FileDataInput ; public class SSTableIterator extends AbstractSSTableIterator { public SSTableIterator ( SSTableReader sstable , DecoratedKey key , ColumnFilter columns , boolean isForThrift ) { this ( sstable , null , key , sstable . getPosition ( key , SSTableReader . Operator . EQ ) , columns , isForThrift ) ; } public SSTableIterator ( SSTableReader sstable , FileDataInput file , DecoratedKey key , RowIndexEntry indexEntry , ColumnFilter columns , boolean isForThrift ) { super ( sstable , file , key , indexEntry , columns , isForThrift ) ; } protected Reader createReader ( RowIndexEntry indexEntry , FileDataInput file , boolean isAtPartitionStart , boolean shouldCloseFile ) { return indexEntry . isIndexed ( ) ? new ForwardIndexedReader ( indexEntry , file , isAtPartitionStart , shouldCloseFile ) : new ForwardReader ( file , isAtPartitionStart , shouldCloseFile ) ; } public boolean isReverseOrder ( ) { return false ; } private class ForwardReader extends Reader { protected Slice . Bound start ; protected Slice . Bound end = Slice . Bound . TOP ; protected Unfiltered next ; protected boolean sliceDone ; private ForwardReader ( FileDataInput file , boolean isAtPartitionStart , boolean shouldCloseFile ) { super ( file , isAtPartitionStart , shouldCloseFile ) ; } protected void init ( ) throws IOException { throw new IllegalStateException ( ) ; } public void setForSlice ( Slice slice ) throws IOException { start = slice . start ( ) = = Slice . Bound . BOTTOM ? null : slice . start ( ) ; end = slice . end ( ) ; sliceDone = false ; next = null ; } private Unfiltered handlePreSliceData ( ) throws IOException { while ( deserializer . hasNext ( ) & & deserializer . compareNextTo ( start ) < = <int> ) { if ( deserializer . nextIsRow ( ) ) deserializer . skipNext ( ) ; else updateOpenMarker ( ( RangeTombstoneMarker ) deserializer . readNext ( ) ) ; } Slice . Bound sliceStart = start ; start = null ; if ( openMarker ! = null ) return new RangeTombstoneBoundMarker ( sliceStart , openMarker ) ; return null ; } protected Unfiltered computeNext ( ) throws IOException { if ( ! deserializer . hasNext ( ) | | deserializer . compareNextTo ( end ) > <int> ) return null ; Unfiltered next = deserializer . readNext ( ) ; if ( next . kind ( ) = = Unfiltered . Kind . RANGE_TOMBSTONE_MARKER ) updateOpenMarker ( ( RangeTombstoneMarker ) next ) ; return next ; } protected boolean hasNextInternal ( ) throws IOException { if ( next ! = null ) return true ; if ( sliceDone ) return false ; assert deserializer ! = null ; if ( start ! = null ) { Unfiltered unfiltered = handlePreSliceData ( ) ; if ( unfiltered ! = null ) { next = unfiltered ; return true ; } } next = computeNext ( ) ; if ( next ! = null ) return true ; if ( openMarker ! = null ) { next = new RangeTombstoneBoundMarker ( end , getAndClearOpenMarker ( ) ) ; return true ; } sliceDone = true ; return false ; } protected Unfiltered nextInternal ( ) throws IOException { if ( ! hasNextInternal ( ) ) throw new NoSuchElementException ( ) ; Unfiltered toReturn = next ; next = null ; return toReturn ; } } private class ForwardIndexedReader extends ForwardReader { private final IndexState indexState ; private int lastBlockIdx ; private ForwardIndexedReader ( RowIndexEntry indexEntry , FileDataInput file , boolean isAtPartitionStart , boolean shouldCloseFile ) { super ( file , isAtPartitionStart , shouldCloseFile ) ; this . indexState = new IndexState ( this , sstable . metadata . comparator , indexEntry , false ) ; this . lastBlockIdx = indexState . blocksCount ( ) ; } @Override protected void init ( ) throws IOException { indexState . setToBlock ( <int> ) ; } @Override public void setForSlice ( Slice slice ) throws IOException { super . setForSlice ( slice ) ; isInit = true ; if ( indexState . isDone ( ) ) { sliceDone = true ; return ; } int startIdx = indexState . findBlockIndex ( slice . start ( ) , indexState . currentBlockIdx ( ) ) ; if ( startIdx > = indexState . blocksCount ( ) ) { sliceDone = true ; return ; } lastBlockIdx = indexState . findBlockIndex ( slice . end ( ) , startIdx ) ; if ( lastBlockIdx < <int> ) { assert startIdx < <int> ; sliceDone = true ; return ; } if ( startIdx < <int> ) startIdx = <int> ; if ( startIdx ! = indexState . currentBlockIdx ( ) ) indexState . setToBlock ( startIdx ) ; if ( indexState . currentBlockIdx ( ) = = lastBlockIdx & & metadata ( ) . comparator . compare ( slice . end ( ) , indexState . currentIndex ( ) . firstName ) < <int> & & openMarker = = null & & sstable . descriptor . version . storeRows ( ) ) { sliceDone = true ; } } @Override protected Unfiltered computeNext ( ) throws IOException { indexState . updateBlock ( ) ; if ( indexState . isDone ( ) | | indexState . currentBlockIdx ( ) > lastBlockIdx | | ! deserializer . hasNext ( ) | | ( indexState . currentBlockIdx ( ) = = lastBlockIdx & & deserializer . compareNextTo ( end ) > <int> ) ) return null ; Unfiltered next = deserializer . readNext ( ) ; if ( next . kind ( ) = = Unfiltered . Kind . RANGE_TOMBSTONE_MARKER ) updateOpenMarker ( ( RangeTombstoneMarker ) next ) ; return next ; } } } 
