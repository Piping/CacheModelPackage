package org . eclipse . debug . internal . ui . views . memory ; import java . util . ArrayList ; import java . util . Iterator ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . internal . ui . preferences . IDebugPreferenceConstants ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . memory . IMemoryRendering ; import org . eclipse . debug . ui . memory . IMemoryRenderingContainer ; import org . eclipse . jface . action . IAction ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . ui . IViewActionDelegate ; import org . eclipse . ui . IViewPart ; public class ResetMemoryBlockAction implements IViewActionDelegate { private IViewPart fView ; private ArrayList < Object > fSelectedMB = new ArrayList < Object > ( ) ; @Override public void init ( IViewPart view ) { fView = view ; } @Override public void run ( IAction action ) { if ( fSelectedMB . isEmpty ( ) ) { return ; } boolean resetVisible = false ; String resetPref = DebugUITools . getPreferenceStore ( ) . getString ( IDebugPreferenceConstants . PREF_RESET_MEMORY_BLOCK ) ; if ( resetPref . equals ( IDebugPreferenceConstants . RESET_VISIBLE ) ) { resetVisible = true ; } Iterator < Object > iter = fSelectedMB . iterator ( ) ; while ( iter . hasNext ( ) ) { IMemoryBlock mb = ( IMemoryBlock ) iter . next ( ) ; if ( fView instanceof MemoryView ) { MemoryView memView = ( MemoryView ) fView ; IMemoryRenderingContainer [ ] containers = memView . getMemoryRenderingContainers ( ) ; for ( int i = <int> ; i < containers . length ; i + + ) { if ( containers [ i ] instanceof RenderingViewPane ) { ( ( RenderingViewPane ) containers [ i ] ) . resetRenderings ( mb , resetVisible ) ; } } } } } @Override public void selectionChanged ( IAction action , ISelection selection ) { action . setEnabled ( ! selection . isEmpty ( ) ) ; if ( selection instanceof IStructuredSelection ) { IStructuredSelection strucSel = ( IStructuredSelection ) selection ; Object [ ] objs = strucSel . toArray ( ) ; fSelectedMB . clear ( ) ; for ( int i = <int> ; i < objs . length ; i + + ) { if ( objs [ i ] instanceof IMemoryBlock ) fSelectedMB . add ( objs [ i ] ) ; if ( objs [ i ] instanceof IMemoryRendering ) fSelectedMB . add ( ( ( IMemoryRendering ) objs [ i ] ) . getMemoryBlock ( ) ) ; } } } } 
