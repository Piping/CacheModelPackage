package org . elasticsearch . index . percolator ; import org . apache . lucene . index . LeafReader ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Scorer ; import org . apache . lucene . search . SimpleCollector ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . index . fielddata . IndexFieldData ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . fielddata . SortedBinaryDocValues ; import org . elasticsearch . index . fieldvisitor . FieldsVisitor ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . Uid ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; final class QueriesLoaderCollector extends SimpleCollector { private final Map < BytesRef , Query > queries = new HashMap < > ( ) ; private final FieldsVisitor fieldsVisitor = new FieldsVisitor ( true ) ; private final PercolatorQueriesRegistry percolator ; private final IndexFieldData < ? > uidFieldData ; private final ESLogger logger ; private SortedBinaryDocValues uidValues ; private LeafReader reader ; QueriesLoaderCollector ( PercolatorQueriesRegistry percolator , ESLogger logger , MapperService mapperService , IndexFieldDataService indexFieldDataService ) { this . percolator = percolator ; this . logger = logger ; final MappedFieldType uidMapper = mapperService . smartNameFieldType ( UidFieldMapper . NAME ) ; this . uidFieldData = indexFieldDataService . getForField ( uidMapper ) ; } public Map < BytesRef , Query > queries ( ) { return this . queries ; } @Override public void collect ( int doc ) throws IOException { uidValues . setDocument ( doc ) ; if ( uidValues . count ( ) > <int> ) { assert uidValues . count ( ) = = <int> ; final BytesRef uid = uidValues . valueAt ( <int> ) ; final BytesRef id = Uid . splitUidIntoTypeAndId ( uid ) [ <int> ] ; fieldsVisitor . reset ( ) ; reader . document ( doc , fieldsVisitor ) ; try { final Query parseQuery = percolator . parsePercolatorDocument ( null , fieldsVisitor . source ( ) ) ; if ( parseQuery ! = null ) { queries . put ( BytesRef . deepCopyOf ( id ) , parseQuery ) ; } else { logger . warn ( <str> , id ) ; } } catch ( Exception e ) { logger . warn ( <str> , e , id . utf8ToString ( ) ) ; } } } @Override protected void doSetNextReader ( LeafReaderContext context ) throws IOException { reader = context . reader ( ) ; uidValues = uidFieldData . load ( context ) . getBytesValues ( ) ; } @Override public void setScorer ( Scorer scorer ) throws IOException { } @Override public boolean needsScores ( ) { return false ; } } 
