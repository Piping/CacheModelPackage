package org . gradle . messaging . dispatch ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . AsyncStoppable ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . Executor ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class AsyncReceive < T > implements AsyncStoppable { private enum State { Init , Stopping , Stopped } private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private final Executor executor ; private final List < Dispatch < ? super T > > dispatches = new ArrayList < Dispatch < ? super T > > ( ) ; private final Runnable onReceiversExhausted ; private int receivers ; private State state = State . Init ; public AsyncReceive ( Executor executor ) { this ( executor , ( Runnable ) null ) ; } public AsyncReceive ( Executor executor , Runnable onReceiversExhausted ) { this . executor = executor ; this . onReceiversExhausted = onReceiversExhausted ; } public AsyncReceive ( Executor executor , final Dispatch < ? super T > dispatch ) { this ( executor , dispatch , null ) ; } public AsyncReceive ( Executor executor , final Dispatch < ? super T > dispatch , Runnable onReceiversExhausted ) { this ( executor , onReceiversExhausted ) ; dispatchTo ( dispatch ) ; } public void dispatchTo ( final Dispatch < ? super T > dispatch ) { lock . lock ( ) ; try { dispatches . add ( dispatch ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } public void receiveFrom ( final Receive < ? extends T > receive ) { onReceiveThreadStart ( ) ; executor . execute ( new Runnable ( ) { public void run ( ) { try { receiveMessages ( receive ) ; } finally { onReceiveThreadExit ( ) ; } } } ) ; } private void onReceiveThreadStart ( ) { lock . lock ( ) ; try { if ( state ! = State . Init ) { throw new IllegalStateException ( <str> ) ; } receivers + + ; } finally { lock . unlock ( ) ; } } private void onReceiveThreadExit ( ) { lock . lock ( ) ; try { receivers - - ; if ( receivers = = <int> & & onReceiversExhausted ! = null ) { onReceiversExhausted . run ( ) ; } condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } private void receiveMessages ( Receive < ? extends T > receive ) { while ( true ) { Dispatch < ? super T > dispatch ; lock . lock ( ) ; try { while ( dispatches . isEmpty ( ) & & state = = State . Init ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } if ( state ! = State . Init ) { return ; } dispatch = dispatches . remove ( <int> ) ; } finally { lock . unlock ( ) ; } try { T message = receive . receive ( ) ; if ( message = = null ) { return ; } dispatch . dispatch ( message ) ; } finally { lock . lock ( ) ; try { dispatches . add ( dispatch ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } } } private void setState ( State state ) { this . state = state ; condition . signalAll ( ) ; } public void requestStop ( ) { lock . lock ( ) ; try { doRequestStop ( ) ; } finally { lock . unlock ( ) ; } } private void doRequestStop ( ) { if ( receivers > <int> ) { setState ( State . Stopping ) ; } else { setState ( State . Stopped ) ; } } public void stop ( ) { lock . lock ( ) ; try { doRequestStop ( ) ; while ( receivers > <int> ) { condition . await ( ) ; } setState ( State . Stopped ) ; } catch ( InterruptedException e ) { throw new UncheckedException ( e ) ; } finally { lock . unlock ( ) ; } } } 
