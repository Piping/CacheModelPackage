package org . eclipse . ui . console ; import java . util . HashMap ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . BadPositionCategoryException ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . Position ; import org . eclipse . jface . text . Region ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . ui . internal . console . ConsoleDocument ; import org . eclipse . ui . internal . console . ConsoleHyperlinkPosition ; import org . eclipse . ui . internal . console . ConsolePatternMatcher ; import org . eclipse . ui . part . IPageBookViewPage ; public abstract class TextConsole extends AbstractConsole { private int fConsoleWidth ; private int fTabWidth ; private Font fFont ; private Color fBackground ; private ConsolePatternMatcher fPatternMatcher ; private ConsoleDocument fDocument ; private boolean fPartitionerFinished = false ; private boolean fMatcherFinished = false ; private boolean fCompleteFired = false ; private HashMap < String , Object > fAttributes = new HashMap < String , Object > ( ) ; private IConsoleManager fConsoleManager = ConsolePlugin . getDefault ( ) . getConsoleManager ( ) ; @Override protected void dispose ( ) { super . dispose ( ) ; fFont = null ; synchronized ( fAttributes ) { fAttributes . clear ( ) ; } } public TextConsole ( String name , String consoleType , ImageDescriptor imageDescriptor , boolean autoLifecycle ) { super ( name , consoleType , imageDescriptor , autoLifecycle ) ; fDocument = new ConsoleDocument ( ) ; fDocument . addPositionCategory ( ConsoleHyperlinkPosition . HYPER_LINK_CATEGORY ) ; fPatternMatcher = new ConsolePatternMatcher ( this ) ; fDocument . addDocumentListener ( fPatternMatcher ) ; fTabWidth = IConsoleConstants . DEFAULT_TAB_SIZE ; } @Override public IPageBookViewPage createPage ( IConsoleView view ) { return new TextConsolePage ( this , view ) ; } public IDocument getDocument ( ) { return fDocument ; } public int getConsoleWidth ( ) { return fConsoleWidth ; } public void setConsoleWidth ( int width ) { if ( fConsoleWidth ! = width ) { int old = fConsoleWidth ; fConsoleWidth = width ; firePropertyChange ( this , IConsoleConstants . P_CONSOLE_WIDTH , Integer . valueOf ( old ) , Integer . valueOf ( fConsoleWidth ) ) ; } } public void setTabWidth ( final int newTabWidth ) { if ( fTabWidth ! = newTabWidth ) { final int oldTabWidth = fTabWidth ; fTabWidth = newTabWidth ; ConsolePlugin . getStandardDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { firePropertyChange ( TextConsole . this , IConsoleConstants . P_TAB_SIZE , Integer . valueOf ( oldTabWidth ) , Integer . valueOf ( fTabWidth ) ) ; } } ) ; } } public int getTabWidth ( ) { return fTabWidth ; } public Font getFont ( ) { if ( fFont = = null ) { fFont = getDefaultFont ( ) ; } return fFont ; } private Font getDefaultFont ( ) { return JFaceResources . getFont ( JFaceResources . TEXT_FONT ) ; } public void setFont ( Font newFont ) { getFont ( ) ; Font font = newFont ; if ( font = = null ) { font = getDefaultFont ( ) ; } if ( ! fFont . equals ( font ) ) { Font old = fFont ; fFont = font ; firePropertyChange ( this , IConsoleConstants . P_FONT , old , fFont ) ; } } @Deprecated public void setBackgrond ( Color background ) { setBackground ( background ) ; } public void setBackground ( Color background ) { if ( fBackground = = null ) { if ( background = = null ) { return ; } } else if ( fBackground . equals ( background ) ) { return ; } Color old = fBackground ; fBackground = background ; firePropertyChange ( this , IConsoleConstants . P_BACKGROUND_COLOR , old , fBackground ) ; } public Color getBackground ( ) { return fBackground ; } public void clearConsole ( ) { IDocument document = getDocument ( ) ; if ( document ! = null ) { document . set ( <str> ) ; } } protected abstract IConsoleDocumentPartitioner getPartitioner ( ) ; public IHyperlink [ ] getHyperlinks ( ) { try { Position [ ] positions = getDocument ( ) . getPositions ( ConsoleHyperlinkPosition . HYPER_LINK_CATEGORY ) ; IHyperlink [ ] hyperlinks = new IHyperlink [ positions . length ] ; for ( int i = <int> ; i < positions . length ; i + + ) { ConsoleHyperlinkPosition position = ( ConsoleHyperlinkPosition ) positions [ i ] ; hyperlinks [ i ] = position . getHyperLink ( ) ; } return hyperlinks ; } catch ( BadPositionCategoryException e ) { return new IHyperlink [ <int> ] ; } } public IHyperlink getHyperlink ( int offset ) { try { IDocument document = getDocument ( ) ; if ( document ! = null ) { Position [ ] positions = document . getPositions ( ConsoleHyperlinkPosition . HYPER_LINK_CATEGORY ) ; Position position = findPosition ( offset , positions ) ; if ( position instanceof ConsoleHyperlinkPosition ) { return ( ( ConsoleHyperlinkPosition ) position ) . getHyperLink ( ) ; } } } catch ( BadPositionCategoryException e ) { } return null ; } private Position findPosition ( int offset , Position [ ] positions ) { if ( positions . length = = <int> ) { return null ; } int left = <int> ; int right = positions . length - <int> ; int mid = <int> ; Position position = null ; while ( left < right ) { mid = ( left + right ) / <int> ; position = positions [ mid ] ; if ( offset < position . getOffset ( ) ) { if ( left = = mid ) { right = left ; } else { right = mid - <int> ; } } else if ( offset > ( position . getOffset ( ) + position . getLength ( ) - <int> ) ) { if ( right = = mid ) { left = right ; } else { left = mid + <int> ; } } else { left = right = mid ; } } position = positions [ left ] ; if ( offset > = position . getOffset ( ) & & ( offset < ( position . getOffset ( ) + position . getLength ( ) ) ) ) { return position ; } return null ; } public void addPatternMatchListener ( IPatternMatchListener listener ) { fPatternMatcher . addPatternMatchListener ( listener ) ; } public void removePatternMatchListener ( IPatternMatchListener listener ) { fPatternMatcher . removePatternMatchListener ( listener ) ; } private class MatcherSchedulingRule implements ISchedulingRule { @Override public boolean contains ( ISchedulingRule rule ) { return rule = = this ; } @Override public boolean isConflicting ( ISchedulingRule rule ) { if ( contains ( rule ) ) { return true ; } if ( rule ! = this & & rule instanceof MatcherSchedulingRule ) { return ( ( ( MatcherSchedulingRule ) rule ) . getConsole ( ) = = TextConsole . this ) ; } return false ; } public TextConsole getConsole ( ) { return TextConsole . this ; } } public ISchedulingRule getSchedulingRule ( ) { return new MatcherSchedulingRule ( ) ; } public void partitionerFinished ( ) { fPatternMatcher . forceFinalMatching ( ) ; fPartitionerFinished = true ; checkFinished ( ) ; } public void matcherFinished ( ) { fMatcherFinished = true ; fDocument . removeDocumentListener ( fPatternMatcher ) ; checkFinished ( ) ; } private synchronized void checkFinished ( ) { if ( ! fCompleteFired & & fPartitionerFinished & & fMatcherFinished ) { fCompleteFired = true ; firePropertyChange ( this , IConsoleConstants . P_CONSOLE_OUTPUT_COMPLETE , null , null ) ; } } public void addHyperlink ( IHyperlink hyperlink , int offset , int length ) throws BadLocationException { IDocument document = getDocument ( ) ; ConsoleHyperlinkPosition hyperlinkPosition = new ConsoleHyperlinkPosition ( hyperlink , offset , length ) ; try { document . addPosition ( ConsoleHyperlinkPosition . HYPER_LINK_CATEGORY , hyperlinkPosition ) ; fConsoleManager . refresh ( this ) ; } catch ( BadPositionCategoryException e ) { ConsolePlugin . log ( e ) ; } } public IRegion getRegion ( IHyperlink link ) { try { IDocument doc = getDocument ( ) ; if ( doc ! = null ) { Position [ ] positions = doc . getPositions ( ConsoleHyperlinkPosition . HYPER_LINK_CATEGORY ) ; for ( int i = <int> ; i < positions . length ; i + + ) { ConsoleHyperlinkPosition position = ( ConsoleHyperlinkPosition ) positions [ i ] ; if ( position . getHyperLink ( ) . equals ( link ) ) { return new Region ( position . getOffset ( ) , position . getLength ( ) ) ; } } } } catch ( BadPositionCategoryException e ) { } return null ; } public Object getAttribute ( String key ) { synchronized ( fAttributes ) { return fAttributes . get ( key ) ; } } public void setAttribute ( String key , Object value ) { synchronized ( fAttributes ) { fAttributes . put ( key , value ) ; } } } 
