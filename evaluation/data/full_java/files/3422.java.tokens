package org . nd4j . linalg ; import org . apache . commons . math3 . linear . BlockRealMatrix ; import org . apache . commons . math3 . linear . RealMatrix ; import org . apache . commons . math3 . util . Pair ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . checkutil . CheckUtil ; import org . nd4j . linalg . checkutil . NDArrayCreationUtil ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . List ; import java . util . Random ; import static org . junit . Assert . assertArrayEquals ; public class Nd4jTestsComparisonFortran extends BaseNd4jTest { private static Logger log = LoggerFactory . getLogger ( Nd4jTestsComparisonFortran . class ) ; public static final int SEED = <int> ; public Nd4jTestsComparisonFortran ( ) { } public Nd4jTestsComparisonFortran ( String name ) { super ( name ) ; } public Nd4jTestsComparisonFortran ( Nd4jBackend backend ) { super ( backend ) ; } public Nd4jTestsComparisonFortran ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } @Before public void before ( ) { super . before ( ) ; Nd4j . factory ( ) . setDType ( DataBuffer . Type . DOUBLE ) ; Nd4j . dtype = DataBuffer . Type . DOUBLE ; Nd4j . getRandom ( ) . setSeed ( SEED ) ; } @After public void after ( ) { super . after ( ) ; Nd4j . factory ( ) . setDType ( DataBuffer . Type . DOUBLE ) ; Nd4j . dtype = DataBuffer . Type . DOUBLE ; } @Override public char ordering ( ) { return <str> ; } @Test public void testMmulWithOpsCommonsMath ( ) { List < Pair < INDArray , String > > first = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; List < Pair < INDArray , String > > second = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; for ( int i = <int> ; i < first . size ( ) ; i + + ) { for ( int j = <int> ; j < second . size ( ) ; j + + ) { Pair < INDArray , String > p1 = first . get ( i ) ; Pair < INDArray , String > p2 = second . get ( j ) ; String errorMsg = getTestWithOpsErrorMsg ( i , j , <str> , p1 , p2 ) ; assertTrue ( errorMsg , CheckUtil . checkMmul ( p1 . getFirst ( ) , p2 . getFirst ( ) , <float> , <float> ) ) ; } } } @Test public void testGemmWithOpsCommonsMath ( ) { List < Pair < INDArray , String > > first = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; List < Pair < INDArray , String > > firstT = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; List < Pair < INDArray , String > > second = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; List < Pair < INDArray , String > > secondT = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; double [ ] alpha = { <float> , - <float> , <float> } ; double [ ] beta = { <float> , - <float> , <float> } ; INDArray cOrig = Nd4j . create ( new int [ ] { <int> , <int> } ) ; Random r = new Random ( <int> ) ; for ( int i = <int> ; i < cOrig . size ( <int> ) ; i + + ) { for ( int j = <int> ; j < cOrig . size ( <int> ) ; j + + ) { cOrig . putScalar ( new int [ ] { i , j } , r . nextDouble ( ) ) ; } } for ( int i = <int> ; i < first . size ( ) ; i + + ) { for ( int j = <int> ; j < second . size ( ) ; j + + ) { for ( int k = <int> ; k < alpha . length ; k + + ) { for ( int m = <int> ; m < beta . length ; m + + ) { INDArray cff = Nd4j . create ( cOrig . shape ( ) , <str> ) ; cff . assign ( cOrig ) ; INDArray cft = Nd4j . create ( cOrig . shape ( ) , <str> ) ; cft . assign ( cOrig ) ; INDArray ctf = Nd4j . create ( cOrig . shape ( ) , <str> ) ; ctf . assign ( cOrig ) ; INDArray ctt = Nd4j . create ( cOrig . shape ( ) , <str> ) ; ctt . assign ( cOrig ) ; double a = alpha [ k ] ; double b = beta [ k ] ; Pair < INDArray , String > p1 = first . get ( i ) ; Pair < INDArray , String > p1T = firstT . get ( i ) ; Pair < INDArray , String > p2 = second . get ( j ) ; Pair < INDArray , String > p2T = secondT . get ( j ) ; String errorMsgff = getGemmErrorMsg ( i , j , false , false , a , b , p1 , p2 ) ; String errorMsgft = getGemmErrorMsg ( i , j , false , true , a , b , p1 , p2T ) ; String errorMsgtf = getGemmErrorMsg ( i , j , true , false , a , b , p1T , p2 ) ; String errorMsgtt = getGemmErrorMsg ( i , j , true , true , a , b , p1T , p2T ) ; assertTrue ( errorMsgff , CheckUtil . checkGemm ( p1 . getFirst ( ) , p2 . getFirst ( ) , cff , false , false , a , b , <float> , <float> ) ) ; assertTrue ( errorMsgft , CheckUtil . checkGemm ( p1 . getFirst ( ) , p2T . getFirst ( ) , cft , false , true , a , b , <float> , <float> ) ) ; assertTrue ( errorMsgtf , CheckUtil . checkGemm ( p1T . getFirst ( ) , p2 . getFirst ( ) , ctf , true , false , a , b , <float> , <float> ) ) ; assertTrue ( errorMsgtt , CheckUtil . checkGemm ( p1T . getFirst ( ) , p2T . getFirst ( ) , ctt , true , true , a , b , <float> , <float> ) ) ; } } } } } @Test public void testGemvApacheCommons ( ) { int [ ] rowsArr = new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> } ; int [ ] colsArr = new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> } ; for ( int x = <int> ; x < rowsArr . length ; x + + ) { int rows = rowsArr [ x ] ; int cols = colsArr [ x ] ; List < Pair < INDArray , String > > matrices = NDArrayCreationUtil . getAllTestMatricesWithShape ( rows , cols , <int> ) ; List < Pair < INDArray , String > > vectors = NDArrayCreationUtil . getAllTestMatricesWithShape ( cols , <int> , <int> ) ; for ( int i = <int> ; i < matrices . size ( ) ; i + + ) { for ( int j = <int> ; j < vectors . size ( ) ; j + + ) { Pair < INDArray , String > p1 = matrices . get ( i ) ; Pair < INDArray , String > p2 = vectors . get ( j ) ; String errorMsg = getTestWithOpsErrorMsg ( i , j , <str> , p1 , p2 ) ; INDArray m = p1 . getFirst ( ) ; INDArray v = p2 . getFirst ( ) ; RealMatrix rm = new BlockRealMatrix ( m . rows ( ) , m . columns ( ) ) ; for ( int r = <int> ; r < m . rows ( ) ; r + + ) { for ( int c = <int> ; c < m . columns ( ) ; c + + ) { double d = m . getDouble ( r , c ) ; rm . setEntry ( r , c , d ) ; } } RealMatrix rv = new BlockRealMatrix ( cols , <int> ) ; for ( int r = <int> ; r < v . rows ( ) ; r + + ) { double d = v . getDouble ( r , <int> ) ; rv . setEntry ( r , <int> , d ) ; } INDArray gemv = m . mmul ( v ) ; RealMatrix gemv2 = rm . multiply ( rv ) ; assertArrayEquals ( new int [ ] { rows , <int> } , gemv . shape ( ) ) ; assertArrayEquals ( new int [ ] { rows , <int> } , new int [ ] { gemv2 . getRowDimension ( ) , gemv2 . getColumnDimension ( ) } ) ; for ( int r = <int> ; r < rows ; r + + ) { double exp = gemv2 . getEntry ( r , <int> ) ; double act = gemv . getDouble ( r , <int> ) ; assertEquals ( errorMsg , exp , act , <float> ) ; } } } } } @Test public void testAddSubtractWithOpsCommonsMath ( ) { List < Pair < INDArray , String > > first = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; List < Pair < INDArray , String > > second = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; for ( int i = <int> ; i < first . size ( ) ; i + + ) { for ( int j = <int> ; j < second . size ( ) ; j + + ) { Pair < INDArray , String > p1 = first . get ( i ) ; Pair < INDArray , String > p2 = second . get ( j ) ; String errorMsg1 = getTestWithOpsErrorMsg ( i , j , <str> , p1 , p2 ) ; String errorMsg2 = getTestWithOpsErrorMsg ( i , j , <str> , p1 , p2 ) ; boolean addFail = CheckUtil . checkAdd ( p1 . getFirst ( ) , p2 . getFirst ( ) , <float> , <float> ) ; assertTrue ( errorMsg1 , addFail ) ; boolean subFail = CheckUtil . checkSubtract ( p1 . getFirst ( ) , p2 . getFirst ( ) , <float> , <float> ) ; assertTrue ( errorMsg2 , subFail ) ; } } } @Test public void testMulDivOnCheckUtilMatrices ( ) { List < Pair < INDArray , String > > first = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; List < Pair < INDArray , String > > second = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , SEED ) ; for ( int i = <int> ; i < first . size ( ) ; i + + ) { for ( int j = <int> ; j < second . size ( ) ; j + + ) { Pair < INDArray , String > p1 = first . get ( i ) ; Pair < INDArray , String > p2 = second . get ( j ) ; String errorMsg1 = getTestWithOpsErrorMsg ( i , j , <str> , p1 , p2 ) ; String errorMsg2 = getTestWithOpsErrorMsg ( i , j , <str> , p1 , p2 ) ; assertTrue ( errorMsg1 , CheckUtil . checkMulManually ( p1 . getFirst ( ) , p2 . getFirst ( ) , <float> , <float> ) ) ; assertTrue ( errorMsg2 , CheckUtil . checkDivManually ( p1 . getFirst ( ) , p2 . getFirst ( ) , <float> , <float> ) ) ; } } } private static String getTestWithOpsErrorMsg ( int i , int j , String op , Pair < INDArray , String > first , Pair < INDArray , String > second ) { return i + <str> + j + <str> + first . getSecond ( ) + <str> + op + <str> + second . getSecond ( ) + <str> ; } private static String getGemmErrorMsg ( int i , int j , boolean transposeA , boolean transposeB , double alpha , double beta , Pair < INDArray , String > first , Pair < INDArray , String > second ) { return i + <str> + j + <str> + transposeA + <str> + transposeB + <str> + alpha + <str> + beta + <str> + first . getSecond ( ) + <str> + second . getSecond ( ) ; } } 
