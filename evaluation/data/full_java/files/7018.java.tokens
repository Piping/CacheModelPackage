package org . elasticsearch . rest . action . bulk ; import org . elasticsearch . action . WriteConsistencyLevel ; import org . elasticsearch . action . bulk . BulkItemResponse ; import org . elasticsearch . action . bulk . BulkRequest ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . action . bulk . BulkShardRequest ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . Requests ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import static org . elasticsearch . rest . RestRequest . Method . POST ; import static org . elasticsearch . rest . RestRequest . Method . PUT ; import static org . elasticsearch . rest . RestStatus . OK ; public class RestBulkAction extends BaseRestHandler { private final boolean allowExplicitIndex ; @Inject public RestBulkAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( PUT , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( PUT , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( PUT , <str> , this ) ; this . allowExplicitIndex = settings . getAsBoolean ( <str> , true ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) throws Exception { BulkRequest bulkRequest = Requests . bulkRequest ( ) ; String defaultIndex = request . param ( <str> ) ; String defaultType = request . param ( <str> ) ; String defaultRouting = request . param ( <str> ) ; String fieldsParam = request . param ( <str> ) ; String [ ] defaultFields = fieldsParam ! = null ? Strings . commaDelimitedListToStringArray ( fieldsParam ) : null ; String consistencyLevel = request . param ( <str> ) ; if ( consistencyLevel ! = null ) { bulkRequest . consistencyLevel ( WriteConsistencyLevel . fromString ( consistencyLevel ) ) ; } bulkRequest . timeout ( request . paramAsTime ( <str> , BulkShardRequest . DEFAULT_TIMEOUT ) ) ; bulkRequest . refresh ( request . paramAsBoolean ( <str> , bulkRequest . refresh ( ) ) ) ; bulkRequest . add ( request . content ( ) , defaultIndex , defaultType , defaultRouting , defaultFields , null , allowExplicitIndex ) ; client . bulk ( bulkRequest , new RestBuilderListener < BulkResponse > ( channel ) { @Override public RestResponse buildResponse ( BulkResponse response , XContentBuilder builder ) throws Exception { builder . startObject ( ) ; builder . field ( Fields . TOOK , response . getTookInMillis ( ) ) ; builder . field ( Fields . ERRORS , response . hasFailures ( ) ) ; builder . startArray ( Fields . ITEMS ) ; for ( BulkItemResponse itemResponse : response ) { builder . startObject ( ) ; itemResponse . toXContent ( builder , request ) ; builder . endObject ( ) ; } builder . endArray ( ) ; builder . endObject ( ) ; return new BytesRestResponse ( OK , builder ) ; } } ) ; } static final class Fields { static final XContentBuilderString ITEMS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString ERRORS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOOK = new XContentBuilderString ( <str> ) ; } } 
