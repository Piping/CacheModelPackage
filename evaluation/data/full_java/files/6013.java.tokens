package org . elasticsearch . common . metrics ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import java . util . concurrent . atomic . LongAdder ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; public class MeterMetric implements Metric { private static final long INTERVAL = <int> ; private final EWMA m1Rate = EWMA . oneMinuteEWMA ( ) ; private final EWMA m5Rate = EWMA . fiveMinuteEWMA ( ) ; private final EWMA m15Rate = EWMA . fifteenMinuteEWMA ( ) ; private final LongAdder count = new LongAdder ( ) ; private final long startTime = System . nanoTime ( ) ; private final TimeUnit rateUnit ; private final ScheduledFuture < ? > future ; public MeterMetric ( ScheduledExecutorService tickThread , TimeUnit rateUnit ) { this . rateUnit = rateUnit ; this . future = tickThread . scheduleAtFixedRate ( new Runnable ( ) { @Override public void run ( ) { tick ( ) ; } } , INTERVAL , INTERVAL , TimeUnit . SECONDS ) ; } public TimeUnit rateUnit ( ) { return rateUnit ; } void tick ( ) { m1Rate . tick ( ) ; m5Rate . tick ( ) ; m15Rate . tick ( ) ; } public void mark ( ) { mark ( <int> ) ; } public void mark ( long n ) { count . add ( n ) ; m1Rate . update ( n ) ; m5Rate . update ( n ) ; m15Rate . update ( n ) ; } public long count ( ) { return count . sum ( ) ; } public double fifteenMinuteRate ( ) { return m15Rate . rate ( rateUnit ) ; } public double fiveMinuteRate ( ) { return m5Rate . rate ( rateUnit ) ; } public double meanRate ( ) { long count = count ( ) ; if ( count = = <int> ) { return <float> ; } else { final long elapsed = ( System . nanoTime ( ) - startTime ) ; return convertNsRate ( count / ( double ) elapsed ) ; } } public double oneMinuteRate ( ) { return m1Rate . rate ( rateUnit ) ; } private double convertNsRate ( double ratePerNs ) { return ratePerNs * ( double ) rateUnit . toNanos ( <int> ) ; } public void stop ( ) { FutureUtils . cancel ( future ) ; } } 
