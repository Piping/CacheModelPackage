package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . utils . MeshPartBuilder ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . physics . bullet . collision . btBroadphasePairArray ; import com . badlogic . gdx . physics . bullet . collision . btCollisionDispatcher ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObject ; import com . badlogic . gdx . physics . bullet . collision . btCollisionShape ; import com . badlogic . gdx . physics . bullet . collision . btCollisionWorld ; import com . badlogic . gdx . physics . bullet . collision . btCompoundShape ; import com . badlogic . gdx . physics . bullet . collision . btConvexHullShape ; import com . badlogic . gdx . physics . bullet . collision . btDbvtBroadphase ; import com . badlogic . gdx . physics . bullet . collision . btDefaultCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . collision . btPairCachingGhostObject ; import com . badlogic . gdx . physics . bullet . collision . btPersistentManifoldArray ; import com . badlogic . gdx . utils . Array ; public class FrustumCullingTest extends BaseBulletTest { final static int CULL_FRUSTUM = <int> ; final static int FRUSTUM_CAM = <int> ; final static boolean USE_BULLET_FRUSTUM_CULLING = true ; int state = <int> ; final static int BOXCOUNT = <int> ; final static float BOX_X_MIN = - <int> ; final static float BOX_Y_MIN = - <int> ; final static float BOX_Z_MIN = - <int> ; final static float BOX_X_MAX = <int> ; final static float BOX_Y_MAX = <int> ; final static float BOX_Z_MAX = <int> ; final static float SPEED_X = <int> f / <float> ; final static float SPEED_Y = <int> f / <int> f ; final static float SPEED_Z = <int> f / <int> f ; final static Vector3 tmpV = new Vector3 ( ) ; final static Matrix4 tmpM = new Matrix4 ( ) ; final static int ptrs [ ] = new int [ <int> ] ; final static Array < btCollisionObject > visibleObjects = new Array < btCollisionObject > ( ) ; public static btPairCachingGhostObject createFrustumObject ( final Vector3 . . . points ) { final btPairCachingGhostObject result = new TestPairCachingGhostObject ( ) ; final boolean USE_COMPOUND = true ; if ( USE_COMPOUND ) { final Vector3 centerNear = new Vector3 ( points [ <int> ] ) . sub ( points [ <int> ] ) . scl ( <float> ) . add ( points [ <int> ] ) ; final Vector3 centerFar = new Vector3 ( points [ <int> ] ) . sub ( points [ <int> ] ) . scl ( <float> ) . add ( points [ <int> ] ) ; final Vector3 center = new Vector3 ( centerFar ) . sub ( centerNear ) . scl ( <float> ) . add ( centerNear ) ; final btConvexHullShape hullShape = new btConvexHullShape ( ) ; for ( int i = <int> ; i < points . length ; i + + ) hullShape . addPoint ( tmpV . set ( points [ i ] ) . sub ( center ) ) ; final btCompoundShape shape = new btCompoundShape ( ) ; shape . addChildShape ( tmpM . setToTranslation ( center ) , hullShape ) ; result . setCollisionShape ( shape ) ; } else { final btConvexHullShape shape = new btConvexHullShape ( ) ; for ( int i = <int> ; i < points . length ; i + + ) shape . addPoint ( points [ i ] ) ; result . setCollisionShape ( shape ) ; } result . setCollisionFlags ( btCollisionObject . CollisionFlags . CF_NO_CONTACT_RESPONSE ) ; return result ; } public static Array < BulletEntity > getEntitiesCollidingWithObject ( final BulletWorld world , final btCollisionObject object , final Array < BulletEntity > out , final btPersistentManifoldArray tmpArr ) { btBroadphasePairArray arr = world . broadphase . getOverlappingPairCache ( ) . getOverlappingPairArray ( ) ; final int n = arr . getCollisionObjectsValue ( ptrs , object ) ; out . clear ( ) ; for ( int i = <int> ; i < n ; i + + ) out . add ( world . entities . get ( ptrs [ i ] ) ) ; return out ; } public static Model createFrustumModel ( final Vector3 . . . p ) { ModelBuilder builder = new ModelBuilder ( ) ; builder . begin ( ) ; MeshPartBuilder mpb = builder . part ( <str> , GL20 . GL_LINES , Usage . Position | Usage . Normal , new Material ( new ColorAttribute ( ColorAttribute . Diffuse , Color . WHITE ) ) ) ; mpb . vertex ( p [ <int> ] . x , p [ <int> ] . y , p [ <int> ] . z , <int> , <int> , <int> , p [ <int> ] . x , p [ <int> ] . y , p [ <int> ] . z , <int> , <int> , <int> , p [ <int> ] . x , p [ <int> ] . y , p [ <int> ] . z , <int> , <int> , <int> , p [ <int> ] . x , p [ <int> ] . y , p [ <int> ] . z , <int> , <int> , <int> , p [ <int> ] . x , p [ <int> ] . y , p [ <int> ] . z , <int> , <int> , - <int> , p [ <int> ] . x , p [ <int> ] . y , p [ <int> ] . z , <int> , <int> , - <int> , p [ <int> ] . x , p [ <int> ] . y , p [ <int> ] . z , <int> , <int> , - <int> , p [ <int> ] . x , p [ <int> ] . y , p [ <int> ] . z , <int> , <int> , - <int> ) ; mpb . index ( ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> ) ; mpb . index ( ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> ) ; mpb . index ( ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> , ( short ) <int> ) ; return builder . end ( ) ; } private float angleX , angleY , angleZ ; private btPairCachingGhostObject frustumObject ; private BulletEntity frustumEntity ; private final Array < BulletEntity > visibleEntities = new Array < BulletEntity > ( ) ; private btPersistentManifoldArray tempManifoldArr ; private PerspectiveCamera frustumCam ; private PerspectiveCamera overviewCam ; @Override public void create ( ) { super . create ( ) ; instructions = <str> ; tempManifoldArr = new btPersistentManifoldArray ( ) ; world . addConstructor ( <str> , new BulletConstructor ( world . getConstructor ( <str> ) . model ) ) ; final float dX = BOX_X_MAX - BOX_X_MIN ; final float dY = BOX_Y_MAX - BOX_Y_MIN ; final float dZ = BOX_Z_MAX - BOX_Z_MIN ; for ( int i = <int> ; i < BOXCOUNT ; i + + ) world . add ( <str> , BOX_X_MIN + dX * ( float ) Math . random ( ) , BOX_Y_MIN + dY * ( float ) Math . random ( ) , BOX_Z_MIN + dZ * ( float ) Math . random ( ) ) . setColor ( Color . GRAY ) ; frustumCam = new PerspectiveCamera ( camera . fieldOfView , camera . viewportWidth , camera . viewportHeight ) ; frustumCam . far = Vector3 . len ( BOX_X_MAX , BOX_Y_MAX , BOX_Z_MAX ) ; frustumCam . update ( ) ; overviewCam = camera ; overviewCam . position . set ( BOX_X_MAX , BOX_Y_MAX , BOX_Z_MAX ) ; overviewCam . lookAt ( Vector3 . Zero ) ; overviewCam . far = <int> f ; overviewCam . update ( ) ; final Model frustumModel = createFrustumModel ( frustumCam . frustum . planePoints ) ; disposables . add ( frustumModel ) ; frustumObject = createFrustumObject ( frustumCam . frustum . planePoints ) ; world . add ( frustumEntity = new BulletEntity ( frustumModel , frustumObject , <int> , <int> , <int> ) ) ; frustumEntity . setColor ( Color . BLUE ) ; } @Override public BulletWorld createWorld ( ) { btDbvtBroadphase broadphase = new btDbvtBroadphase ( ) ; btDefaultCollisionConfiguration collisionConfig = new btDefaultCollisionConfiguration ( ) ; btCollisionDispatcher dispatcher = new btCollisionDispatcher ( collisionConfig ) ; btCollisionWorld collisionWorld = new btCollisionWorld ( dispatcher , broadphase , collisionConfig ) ; return new BulletWorld ( collisionConfig , dispatcher , broadphase , null , collisionWorld ) ; } @Override public void update ( ) { super . update ( ) ; if ( USE_BULLET_FRUSTUM_CULLING ) { if ( world . performanceCounter ! = null ) world . performanceCounter . start ( ) ; world . collisionWorld . performDiscreteCollisionDetection ( ) ; if ( world . performanceCounter ! = null ) world . performanceCounter . stop ( ) ; } } @Override public void render ( ) { final float dt = Gdx . graphics . getDeltaTime ( ) ; frustumEntity . transform . idt ( ) ; frustumEntity . transform . rotate ( Vector3 . X , angleX = ( angleX + dt * SPEED_X ) % <int> ) ; frustumEntity . transform . rotate ( Vector3 . Y , angleY = ( angleY + dt * SPEED_Y ) % <int> ) ; frustumEntity . transform . rotate ( Vector3 . Z , angleZ = ( angleZ + dt * SPEED_Z ) % <int> ) ; frustumEntity . body . setWorldTransform ( frustumEntity . transform ) ; frustumCam . direction . set ( <int> , <int> , - <int> ) ; frustumCam . up . set ( <int> , <int> , <int> ) ; frustumCam . position . set ( <int> , <int> , <int> ) ; frustumCam . rotate ( frustumEntity . transform ) ; frustumCam . update ( ) ; super . render ( ) ; performance . append ( <str> ) . append ( visibleEntities . size ) ; } @Override protected void renderWorld ( ) { if ( world . performanceCounter ! = null ) world . performanceCounter . start ( ) ; if ( USE_BULLET_FRUSTUM_CULLING ) getEntitiesCollidingWithObject ( world , frustumObject , visibleEntities , tempManifoldArr ) ; else { visibleEntities . clear ( ) ; for ( int i = <int> ; i < world . entities . size ; i + + ) { final BulletEntity e = world . entities . get ( i ) ; if ( e = = frustumEntity ) continue ; e . modelInstance . transform . getTranslation ( tmpV ) ; if ( frustumCam . frustum . sphereInFrustum ( tmpV , <int> ) ) visibleEntities . add ( e ) ; } } if ( world . performanceCounter ! = null ) world . performanceCounter . stop ( ) ; for ( int i = <int> ; i < visibleEntities . size ; i + + ) visibleEntities . get ( i ) . setColor ( Color . RED ) ; modelBatch . begin ( camera ) ; if ( ( state & CULL_FRUSTUM ) = = CULL_FRUSTUM ) { world . render ( modelBatch , environment , visibleEntities ) ; world . render ( modelBatch , environment , frustumEntity ) ; } else world . render ( modelBatch , environment ) ; modelBatch . end ( ) ; for ( int i = <int> ; i < visibleEntities . size ; i + + ) visibleEntities . get ( i ) . setColor ( Color . GRAY ) ; } @Override protected void beginRender ( boolean lighting ) { super . beginRender ( false ) ; } @Override public void dispose ( ) { frustumObject = null ; super . dispose ( ) ; if ( tempManifoldArr ! = null ) tempManifoldArr . dispose ( ) ; tempManifoldArr = null ; } @Override public boolean tap ( float x , float y , int count , int button ) { state = ( state + <int> ) % <int> ; if ( ( state & FRUSTUM_CAM ) = = FRUSTUM_CAM ) camera = frustumCam ; else camera = overviewCam ; return true ; } public static class TestPairCachingGhostObject extends btPairCachingGhostObject { public btCollisionShape shape ; @Override public void setCollisionShape ( btCollisionShape collisionShape ) { shape = collisionShape ; super . setCollisionShape ( collisionShape ) ; } @Override public void dispose ( ) { super . dispose ( ) ; if ( shape ! = null ) shape . dispose ( ) ; shape = null ; } } } 
