package com . badlogic . gdx . math ; public final class GeometryUtils { static private final Vector2 tmp1 = new Vector2 ( ) , tmp2 = new Vector2 ( ) , tmp3 = new Vector2 ( ) ; static public Vector2 toBarycoord ( Vector2 p , Vector2 a , Vector2 b , Vector2 c , Vector2 barycentricOut ) { Vector2 v0 = tmp1 . set ( b ) . sub ( a ) ; Vector2 v1 = tmp2 . set ( c ) . sub ( a ) ; Vector2 v2 = tmp3 . set ( p ) . sub ( a ) ; float d00 = v0 . dot ( v0 ) ; float d01 = v0 . dot ( v1 ) ; float d11 = v1 . dot ( v1 ) ; float d20 = v2 . dot ( v0 ) ; float d21 = v2 . dot ( v1 ) ; float denom = d00 * d11 - d01 * d01 ; barycentricOut . x = ( d11 * d20 - d01 * d21 ) / denom ; barycentricOut . y = ( d00 * d21 - d01 * d20 ) / denom ; return barycentricOut ; } static public boolean barycoordInsideTriangle ( Vector2 barycentric ) { return barycentric . x > = <int> & & barycentric . y > = <int> & & barycentric . x + barycentric . y < = <int> ; } static public Vector2 fromBarycoord ( Vector2 barycentric , Vector2 a , Vector2 b , Vector2 c , Vector2 interpolatedOut ) { float u = <int> - barycentric . x - barycentric . y ; interpolatedOut . x = u * a . x + barycentric . x * b . x + barycentric . y * c . x ; interpolatedOut . y = u * a . y + barycentric . x * b . y + barycentric . y * c . y ; return interpolatedOut ; } static public float fromBarycoord ( Vector2 barycentric , float a , float b , float c ) { float u = <int> - barycentric . x - barycentric . y ; return u * a + barycentric . x * b + barycentric . y * c ; } static public float lowestPositiveRoot ( float a , float b , float c ) { float det = b * b - <int> * a * c ; if ( det < <int> ) return Float . NaN ; float sqrtD = ( float ) Math . sqrt ( det ) ; float invA = <int> / ( <int> * a ) ; float r1 = ( - b - sqrtD ) * invA ; float r2 = ( - b + sqrtD ) * invA ; if ( r1 > r2 ) { float tmp = r2 ; r2 = r1 ; r1 = tmp ; } if ( r1 > <int> ) return r1 ; if ( r2 > <int> ) return r2 ; return Float . NaN ; } static public boolean colinear ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { float dx21 = x2 - x1 , dy21 = y2 - y1 ; float dx32 = x3 - x2 , dy32 = y3 - y2 ; float det = dx32 * dy21 - dx21 * dy32 ; return Math . abs ( det ) < MathUtils . FLOAT_ROUNDING_ERROR ; } static public Vector2 triangleCentroid ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , Vector2 centroid ) { centroid . x = ( x1 + x2 + x3 ) / <int> ; centroid . y = ( y1 + y2 + y3 ) / <int> ; return centroid ; } static public Vector2 triangleCircumcenter ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , Vector2 circumcenter ) { float dx21 = x2 - x1 , dy21 = y2 - y1 ; float dx32 = x3 - x2 , dy32 = y3 - y2 ; float dx13 = x1 - x3 , dy13 = y1 - y3 ; float det = dx32 * dy21 - dx21 * dy32 ; if ( Math . abs ( det ) < MathUtils . FLOAT_ROUNDING_ERROR ) throw new IllegalArgumentException ( <str> ) ; det * = <int> ; float sqr1 = x1 * x1 + y1 * y1 , sqr2 = x2 * x2 + y2 * y2 , sqr3 = x3 * x3 + y3 * y3 ; circumcenter . set ( ( sqr1 * dy32 + sqr2 * dy13 + sqr3 * dy21 ) / det , - ( sqr1 * dx32 + sqr2 * dx13 + sqr3 * dx21 ) / det ) ; return circumcenter ; } static public float triangleArea ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) { return Math . abs ( ( x1 - x3 ) * ( y2 - y1 ) - ( x1 - x2 ) * ( y3 - y1 ) ) * <float> ; } static public Vector2 quadrilateralCentroid ( float x1 , float y1 , float x2 , float y2 , float x3 , float y3 , float x4 , float y4 , Vector2 centroid ) { float avgX1 = ( x1 + x2 + x3 ) / <int> ; float avgY1 = ( y1 + y2 + y3 ) / <int> ; float avgX2 = ( x1 + x4 + x3 ) / <int> ; float avgY2 = ( y1 + y4 + y3 ) / <int> ; centroid . x = avgX1 - ( avgX1 - avgX2 ) / <int> ; centroid . y = avgY1 - ( avgY1 - avgY2 ) / <int> ; return centroid ; } static public Vector2 polygonCentroid ( float [ ] polygon , int offset , int count , Vector2 centroid ) { if ( count < <int> ) throw new IllegalArgumentException ( <str> ) ; float x = <int> , y = <int> ; float signedArea = <int> ; int i = offset ; for ( int n = offset + count - <int> ; i < n ; i + = <int> ) { float x0 = polygon [ i ] ; float y0 = polygon [ i + <int> ] ; float x1 = polygon [ i + <int> ] ; float y1 = polygon [ i + <int> ] ; float a = x0 * y1 - x1 * y0 ; signedArea + = a ; x + = ( x0 + x1 ) * a ; y + = ( y0 + y1 ) * a ; } float x0 = polygon [ i ] ; float y0 = polygon [ i + <int> ] ; float x1 = polygon [ offset ] ; float y1 = polygon [ offset + <int> ] ; float a = x0 * y1 - x1 * y0 ; signedArea + = a ; x + = ( x0 + x1 ) * a ; y + = ( y0 + y1 ) * a ; if ( signedArea = = <int> ) { centroid . x = <int> ; centroid . y = <int> ; } else { signedArea * = <float> ; centroid . x = x / ( <int> * signedArea ) ; centroid . y = y / ( <int> * signedArea ) ; } return centroid ; } static public float polygonArea ( float [ ] polygon , int offset , int count ) { float area = <int> ; for ( int i = offset , n = offset + count ; i < n ; i + = <int> ) { int x1 = i ; int y1 = i + <int> ; int x2 = ( i + <int> ) % n ; if ( x2 < offset ) x2 + = offset ; int y2 = ( i + <int> ) % n ; if ( y2 < offset ) y2 + = offset ; area + = polygon [ x1 ] * polygon [ y2 ] ; area - = polygon [ x2 ] * polygon [ y1 ] ; } area * = <float> ; return area ; } static public void ensureCCW ( float [ ] polygon ) { if ( ! areVerticesClockwise ( polygon , <int> , polygon . length ) ) return ; int lastX = polygon . length - <int> ; for ( int i = <int> , n = polygon . length / <int> ; i < n ; i + = <int> ) { int other = lastX - i ; float x = polygon [ i ] ; float y = polygon [ i + <int> ] ; polygon [ i ] = polygon [ other ] ; polygon [ i + <int> ] = polygon [ other + <int> ] ; polygon [ other ] = x ; polygon [ other + <int> ] = y ; } } static private boolean areVerticesClockwise ( float [ ] polygon , int offset , int count ) { if ( count < = <int> ) return false ; float area = <int> , p1x , p1y , p2x , p2y ; for ( int i = offset , n = offset + count - <int> ; i < n ; i + = <int> ) { p1x = polygon [ i ] ; p1y = polygon [ i + <int> ] ; p2x = polygon [ i + <int> ] ; p2y = polygon [ i + <int> ] ; area + = p1x * p2y - p2x * p1y ; } p1x = polygon [ count - <int> ] ; p1y = polygon [ count - <int> ] ; p2x = polygon [ <int> ] ; p2y = polygon [ <int> ] ; return area + p1x * p2y - p2x * p1y < <int> ; } } 
