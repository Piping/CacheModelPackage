package org . nd4j . linalg ; import org . junit . After ; import org . junit . Before ; import org . junit . Ignore ; import org . junit . Test ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexDouble ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . impl . transforms . VectorFFT ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . nd4j . linalg . indexing . NDArrayIndex ; import org . nd4j . linalg . ops . transforms . Transforms ; import org . nd4j . linalg . util . ArrayUtil ; import org . nd4j . linalg . util . ComplexUtil ; import org . nd4j . linalg . api . shape . Shape ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; @Ignore public class ComplexNDArrayTestsC extends BaseComplexNDArrayTests { private static Logger log = LoggerFactory . getLogger ( ComplexNDArrayTestsC . class ) ; public ComplexNDArrayTestsC ( ) { } public ComplexNDArrayTestsC ( String name ) { super ( name ) ; } public ComplexNDArrayTestsC ( Nd4jBackend backend ) { super ( backend ) ; } public ComplexNDArrayTestsC ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } @Before public void before ( ) { super . before ( ) ; } @After public void after ( ) { super . after ( ) ; } @Test public void testConstruction ( ) { IComplexNDArray arr2 = Nd4j . createComplex ( new int [ ] { <int> , <int> } ) ; assertEquals ( <int> , arr2 . rows ( ) ) ; assertEquals ( arr2 . rows ( ) , arr2 . rows ( ) ) ; assertEquals ( <int> , arr2 . columns ( ) ) ; assertEquals ( arr2 . columns ( ) , arr2 . columns ( ) ) ; assertTrue ( arr2 . isMatrix ( ) ) ; IComplexNDArray arr = Nd4j . createComplex ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( <int> , arr . length ( ) ) ; assertEquals ( <int> , arr . data ( ) . length ( ) ) ; IComplexNumber n1 = ( IComplexNumber ) arr . getScalar ( <int> ) . element ( ) ; assertEquals ( <int> , n1 . realComponent ( ) . doubleValue ( ) , <float> ) ; IComplexDouble [ ] two = new IComplexDouble [ <int> ] ; two [ <int> ] = Nd4j . createDouble ( <int> , <int> ) ; two [ <int> ] = Nd4j . createDouble ( <int> , <int> ) ; double [ ] testArr = { <int> , <int> , <int> , <int> } ; IComplexNDArray assertComplexDouble = Nd4j . createComplex ( testArr , new int [ ] { <int> , <int> } ) ; IComplexNDArray testComplexDouble = Nd4j . createComplex ( two , new int [ ] { <int> , <int> } ) ; assertEquals ( assertComplexDouble , testComplexDouble ) ; } @Test public void testSort ( ) { IComplexNDArray matrix = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray sorted = Nd4j . sort ( matrix . dup ( ) , <int> , true ) ; assertEquals ( matrix , sorted ) ; IComplexNDArray reversed = Nd4j . createComplex ( new float [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; IComplexNDArray sortedReversed = Nd4j . sort ( matrix , <int> , false ) ; assertEquals ( reversed , sortedReversed ) ; } @Test public void testSortWithIndicesDescending ( ) { IComplexNDArray toSort = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray [ ] sorted = Nd4j . sortWithIndices ( toSort . dup ( ) , <int> , false ) ; INDArray sorted2 = Nd4j . sort ( toSort . dup ( ) , <int> , false ) ; assertEquals ( sorted [ <int> ] , sorted2 ) ; INDArray shouldIndex = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( shouldIndex , sorted [ <int> ] ) ; } @Test public void testSortWithIndices ( ) { IComplexNDArray toSort = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray [ ] sorted = Nd4j . sortWithIndices ( toSort . dup ( ) , <int> , true ) ; INDArray sorted2 = Nd4j . sort ( toSort . dup ( ) , <int> , true ) ; assertEquals ( sorted [ <int> ] , sorted2 ) ; INDArray shouldIndex = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( shouldIndex , sorted [ <int> ] ) ; } @Test public void testAssignOffset ( ) { IComplexNDArray arr = Nd4j . complexOnes ( <int> , <int> ) ; IComplexNDArray row = arr . slice ( <int> ) ; row . assign ( <int> ) ; assertEquals ( Nd4j . complexOnes ( <int> ) , row ) ; } @Test public void testDimShuffle ( ) { IComplexNDArray n = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray twoOneTwo = n . dimShuffle ( new Object [ ] { <int> , <str> , <int> } , new int [ ] { <int> , <int> } , new boolean [ ] { false , false } ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> , <int> } , twoOneTwo . shape ( ) ) ) ; IComplexNDArray reverse = n . dimShuffle ( new Object [ ] { <int> , <str> , <int> } , new int [ ] { <int> , <int> } , new boolean [ ] { false , false } ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> , <int> } , reverse . shape ( ) ) ) ; } @Test public void testPutComplex ( ) { INDArray fourTwoTwo = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray test = Nd4j . createComplex ( <int> , <int> , <int> ) ; for ( int i = <int> ; i < test . vectorsAlongDimension ( <int> ) ; i + + ) { INDArray vector = fourTwoTwo . vectorAlongDimension ( i , <int> ) ; IComplexNDArray complexVector = test . vectorAlongDimension ( i , <int> ) ; for ( int j = <int> ; j < complexVector . length ( ) ; j + + ) { complexVector . putReal ( j , vector . getFloat ( j ) ) ; } } for ( int i = <int> ; i < test . vectorsAlongDimension ( <int> ) ; i + + ) { INDArray vector = fourTwoTwo . vectorAlongDimension ( i , <int> ) ; IComplexNDArray complexVector = test . vectorAlongDimension ( i , <int> ) ; assertEquals ( vector , complexVector . real ( ) ) ; } } @Test public void testColumnWithReshape ( ) { IComplexNDArray ones = Nd4j . complexOnes ( <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray column = Nd4j . createComplex ( new float [ ] { <int> , <int> , <int> , <int> } ) ; ones . putColumn ( <int> , column ) ; assertEquals ( column , ones . getColumn ( <int> ) ) ; } @Test public void testPutSlice ( ) { } @Test public void testSum ( ) { IComplexNDArray n = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ) ; assertEquals ( Nd4j . createDouble ( <int> , <int> ) , n . sumComplex ( ) ) ; } @Test public void testCreateComplexFromReal ( ) { INDArray n = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; IComplexNDArray nComplex = Nd4j . createComplex ( n ) ; for ( int i = <int> ; i < n . vectorsAlongDimension ( <int> ) ; i + + ) { INDArray vec = n . vectorAlongDimension ( i , <int> ) ; IComplexNDArray vecComplex = nComplex . vectorAlongDimension ( i , <int> ) ; assertEquals ( vec . length ( ) , vecComplex . length ( ) ) ; for ( int j = <int> ; j < vec . length ( ) ; j + + ) { IComplexNumber currComplex = vecComplex . getComplex ( j ) ; double curr = vec . getFloat ( j ) ; assertEquals ( curr , currComplex . realComponent ( ) . doubleValue ( ) , <float> ) ; } assertEquals ( vec , vecComplex . getReal ( ) ) ; } } @Test public void testVectorOffsetRavel ( ) { IComplexNDArray arr = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; for ( int i = <int> ; i < arr . slices ( ) ; i + + ) { assertEquals ( arr . slice ( i ) , arr . slice ( i ) . ravel ( ) ) ; } } @Test public void testSliceVsVectorAlongDimension ( ) { IComplexNDArray arr = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; assertEquals ( arr . slices ( ) , arr . vectorsAlongDimension ( <int> ) ) ; for ( int i = <int> ; i < arr . slices ( ) ; i + + ) { assertEquals ( arr . vectorAlongDimension ( i , <int> ) , arr . slice ( i ) ) ; assertEquals ( arr . vectorAlongDimension ( i , <int> ) . ravel ( ) , arr . slice ( i ) . ravel ( ) ) ; } } @Test public void testVectorAlongDimension ( ) { INDArray n = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray nComplex = Nd4j . createComplex ( Nd4j . linspace ( <int> , <int> , <int> ) ) . reshape ( <int> , <int> ) ; assertEquals ( n . vectorsAlongDimension ( <int> ) , nComplex . vectorsAlongDimension ( <int> ) ) ; for ( int i = <int> ; i < n . vectorsAlongDimension ( <int> ) ; i + + ) { INDArray vec = n . vectorAlongDimension ( i , <int> ) ; IComplexNDArray vecComplex = nComplex . vectorAlongDimension ( i , <int> ) ; assertEquals ( vec . length ( ) , vecComplex . length ( ) ) ; for ( int j = <int> ; j < vec . length ( ) ; j + + ) { IComplexNumber currComplex = vecComplex . getComplex ( j ) ; double curr = vec . getFloat ( j ) ; assertEquals ( curr , currComplex . realComponent ( ) . doubleValue ( ) , <float> ) ; } assertEquals ( vec , vecComplex . getReal ( ) ) ; } } @Test public void testVectorGet ( ) { IComplexNDArray arr = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ) ; for ( int i = <int> ; i < arr . length ( ) ; i + + ) { IComplexNumber curr = arr . getComplex ( i ) ; assertEquals ( Nd4j . createDouble ( i + <int> , <int> ) , curr ) ; } IComplexNDArray matrix = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray row = matrix . getRow ( <int> ) ; IComplexNDArray column = matrix . getColumn ( <int> ) ; IComplexNDArray validate = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNumber d = row . getComplex ( <int> ) ; assertEquals ( Nd4j . createDouble ( <int> , <int> ) , d ) ; assertEquals ( row , validate ) ; IComplexNumber d2 = column . getComplex ( <int> ) ; assertEquals ( Nd4j . createDouble ( <int> , <int> ) , d2 ) ; } @Test public void testTensorStrides ( ) { INDArray arr = Nd4j . createComplex ( <int> , <int> , <int> , <int> ) ; int [ ] assertion = ArrayUtil . of ( <int> , <int> , <int> , <int> ) ; int [ ] arrShape = arr . stride ( ) ; assertTrue ( Arrays . equals ( assertion , arrShape ) ) ; Nd4j . factory ( ) . setOrder ( <str> ) ; arr = Nd4j . createComplex ( <int> , <int> , <int> , <int> ) ; assertion = ArrayUtil . of ( <int> , <int> , <int> , <int> ) ; arrShape = arr . stride ( ) ; assertTrue ( Arrays . equals ( assertion , arrShape ) ) ; } @Test public void testLinearView ( ) { IComplexNDArray n = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray row = n . getRow ( <int> ) ; IComplexNDArray linear = row . linearView ( ) ; assertEquals ( row , linear ) ; IComplexNDArray large = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray largeLinear = large . linearView ( ) ; for ( int i = <int> ; i < largeLinear . length ( ) ; i + + ) assertEquals ( i + <int> , largeLinear . getReal ( i ) , <float> ) ; IComplexNDArray largeTensor = large . reshape ( <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < largeLinear . length ( ) ; i + + ) assertEquals ( i + <int> , largeTensor . getReal ( i ) , <float> ) ; } @Test public void testSwapAxes ( ) { IComplexNDArray n = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray swapped = n . swapAxes ( <int> , <int> ) ; assertEquals ( n . transpose ( ) , swapped ) ; assertEquals ( swapped . getScalar ( <int> ) , n . getScalar ( <int> ) ) ; assertEquals ( swapped . getScalar ( <int> ) , n . getScalar ( <int> ) ) ; assertEquals ( swapped . getScalar ( <int> ) , n . getScalar ( <int> ) ) ; IComplexNDArray n2 = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ) ; IComplexNDArray assertion = n2 . permute ( new int [ ] { <int> , <int> , <int> } ) ; IComplexNDArray validate = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> , <int> } ) ) ; assertEquals ( validate , assertion ) ; IComplexNDArray v1 = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray swap = v1 . swapAxes ( <int> , <int> ) ; IComplexNDArray transposed = v1 . transpose ( ) ; assertEquals ( swap , transposed ) ; transposed . put ( <int> , Nd4j . scalar ( <int> ) ) ; swap . put ( <int> , Nd4j . scalar ( <int> ) ) ; assertEquals ( transposed , swap ) ; assertEquals ( transposed . getScalar ( <int> ) . element ( ) , swap . getScalar ( <int> ) . element ( ) ) ; IComplexNDArray row = n2 . slice ( <int> ) . getRow ( <int> ) ; row . put ( <int> , Nd4j . scalar ( <int> ) ) ; IComplexNumber n3 = ( IComplexNumber ) row . getScalar ( <int> ) . element ( ) ; assertEquals ( <int> , n3 . realComponent ( ) . doubleValue ( ) , <float> ) ; } @Test public void testSliceOffset ( ) { IComplexNDArray test = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray testSlice0 = Nd4j . complexLinSpace ( <int> , <int> , <int> ) ; IComplexNDArray testSlice1 = Nd4j . complexLinSpace ( <int> , <int> , <int> ) ; assertEquals ( testSlice0 , test . slice ( <int> ) ) ; assertEquals ( testSlice1 , test . slice ( <int> ) ) ; IComplexNDArray sliceOfSlice0 = test . slice ( <int> ) . slice ( <int> ) ; assertEquals ( sliceOfSlice0 . getComplex ( <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) ) ; assertEquals ( test . slice ( <int> ) . slice ( <int> ) . getComplex ( <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) ) ; assertEquals ( test . slice ( <int> ) . getComplex ( <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) ) ; } @Test public void testSlice ( ) { IComplexNDArray slices = Nd4j . createComplex ( <int> , <int> ) ; slices . put ( <int> , <int> , <int> ) ; slices . put ( <int> , <int> , <int> ) ; slices . put ( <int> , <int> , <int> ) ; slices . put ( <int> , <int> , <int> ) ; IComplexNDArray assertion = Nd4j . createComplex ( new IComplexNumber [ ] { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) , } ) ; assertEquals ( assertion , slices . slice ( <int> ) ) ; INDArray arr = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; IComplexNDArray arr2 = Nd4j . createComplex ( arr ) ; assertEquals ( arr , arr2 . getReal ( ) ) ; INDArray firstSlice = arr . slice ( <int> ) ; INDArray firstSliceTest = arr2 . slice ( <int> ) . getReal ( ) ; assertEquals ( firstSlice , firstSliceTest ) ; INDArray secondSlice = arr . slice ( <int> ) ; INDArray secondSliceTest = arr2 . slice ( <int> ) . getReal ( ) ; assertEquals ( secondSlice , secondSliceTest ) ; INDArray slice0 = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray slice2 = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; IComplexNDArray testSliceComplex = arr2 . slice ( <int> ) ; IComplexNDArray testSliceComplex2 = arr2 . slice ( <int> ) ; INDArray testSlice0 = testSliceComplex . getReal ( ) ; INDArray testSlice1 = testSliceComplex2 . getReal ( ) ; assertEquals ( slice0 , testSlice0 ) ; assertEquals ( slice2 , testSlice1 ) ; INDArray n2 = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; INDArray swapped = n2 . swapAxes ( n2 . shape ( ) . length - <int> , <int> ) ; INDArray firstSlice2 = swapped . slice ( <int> ) . slice ( <int> ) ; IComplexNDArray testSlice = Nd4j . createComplex ( firstSlice2 ) ; IComplexNDArray testNoOffset = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( testSlice , testNoOffset ) ; } @Test public void testSliceConstructor ( ) { List < IComplexNDArray > testList = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) testList . add ( Nd4j . complexScalar ( i + <int> ) ) ; IComplexNDArray test = Nd4j . createComplex ( testList , new int [ ] { <int> , testList . size ( ) } ) ; IComplexNDArray expected = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; assertEquals ( expected , test ) ; } @Test public void testVectorInit ( ) { DataBuffer data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; IComplexNDArray arr = Nd4j . createComplex ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( true , arr . isRowVector ( ) ) ; IComplexNDArray arr2 = Nd4j . createComplex ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( true , arr2 . isRowVector ( ) ) ; IComplexNDArray columnVector = Nd4j . createComplex ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( true , columnVector . isColumnVector ( ) ) ; } @Test public void testMmulOffset ( ) { IComplexNDArray three = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray test = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ) ; IComplexNDArray sliceRow = test . slice ( <int> ) . getRow ( <int> ) ; assertEquals ( getFailureMessage ( ) , three , sliceRow ) ; IComplexNDArray twoSix = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray threeTwoSix = three . mmul ( twoSix ) ; IComplexNDArray sliceRowTwoSix = sliceRow . mmul ( twoSix ) ; verifyElements ( three , sliceRow ) ; assertEquals ( getFailureMessage ( ) , threeTwoSix , sliceRowTwoSix ) ; } @Test public void testIterateOverAllRows ( ) { Nd4j . EPS_THRESHOLD = <float> ; IComplexNDArray ones = Nd4j . complexOnes ( <int> , <int> ) ; VectorFFT fft = new VectorFFT ( ones ) ; IComplexNDArray assertion = Nd4j . createComplex ( <int> , <int> ) ; for ( int i = <int> ; i < assertion . rows ( ) ; i + + ) assertion . getRow ( i ) . putScalar ( <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; Nd4j . getExecutioner ( ) . iterateOverAllRows ( fft ) ; assertEquals ( getFailureMessage ( ) , assertion , ones ) ; } @Test public void testRowVectorGemm ( ) { IComplexNDArray linspace = Nd4j . complexLinSpace ( <int> , <int> , <int> ) ; IComplexNDArray other = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray result = linspace . mmul ( other ) ; IComplexNDArray assertion = Nd4j . createComplex ( ComplexUtil . complexNumbersFor ( new double [ ] { <int> , <int> , <int> , <int> } ) ) ; assertEquals ( assertion , result ) ; } @Test public void testRealConversion ( ) { IComplexNDArray arr = Nd4j . createComplex ( <int> , <int> ) ; INDArray arr1 = Nd4j . create ( <int> , <int> ) ; assertEquals ( arr , Nd4j . createComplex ( arr1 ) ) ; IComplexNDArray arr3 = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; assertEquals ( arr3 , Nd4j . createComplex ( linspace ) ) ; } @Test public void testTranspose ( ) { IComplexNDArray ndArray = Nd4j . createComplex ( new double [ ] { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , new int [ ] { <int> , <int> } ) ; IComplexNDArray transposed2 = ndArray . transpose ( ) ; assertEquals ( <int> , transposed2 . columns ( ) ) ; } @Test public void testConjugate ( ) { IComplexNDArray negative = Nd4j . createComplex ( new double [ ] { <int> , - <int> , <int> , - <int> } , new int [ ] { <int> , <int> } ) ; IComplexNDArray positive = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( negative , positive . conj ( ) ) ; } @Test public void testGetRow ( ) { IComplexNDArray arr = Nd4j . createComplex ( new int [ ] { <int> , <int> } ) ; IComplexNDArray row = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; arr . putRow ( <int> , row ) ; IComplexNDArray firstRow = arr . getRow ( <int> ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> , <int> } , firstRow . shape ( ) ) ) ; IComplexNDArray testRow = arr . getRow ( <int> ) ; assertEquals ( row , testRow ) ; IComplexNDArray row1 = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; arr . putRow ( <int> , row1 ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> } , arr . getRow ( <int> ) . shape ( ) ) ) ; IComplexNDArray testRow1 = arr . getRow ( <int> ) ; assertEquals ( row1 , testRow1 ) ; INDArray fourTwoTwo = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray multiRow = Nd4j . createComplex ( fourTwoTwo ) ; IComplexNDArray test = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray multiRowSlice = multiRow . slice ( <int> ) ; IComplexNDArray testMultiRow = multiRowSlice . getRow ( <int> ) ; assertEquals ( test , testMultiRow ) ; } @Test public void testMultiDimensionalCreation ( ) { INDArray fourTwoTwo = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; IComplexNDArray multiRow = Nd4j . createComplex ( fourTwoTwo ) ; multiRow . toString ( ) ; assertEquals ( fourTwoTwo , multiRow . getReal ( ) ) ; } @Test public void testGetComplex ( ) { IComplexNDArray arr = Nd4j . createComplex ( Nd4j . create ( Nd4j . createBuffer ( new double [ ] { <int> , <int> , <int> , <int> , <int> } ) ) ) ; IComplexNumber num = arr . getComplex ( <int> ) ; assertEquals ( Nd4j . createDouble ( <int> , <int> ) , num ) ; IComplexNDArray matrix = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray slice = matrix . slice ( <int> ) ; IComplexNDArray assertion = Nd4j . complexLinSpace ( <int> , <int> , <int> ) ; assertEquals ( assertion , slice ) ; IComplexNDArray assert2 = Nd4j . complexLinSpace ( <int> , <int> , <int> ) ; assertEquals ( assert2 , matrix . slice ( <int> ) ) ; } @Test public void testGetColumn ( ) { IComplexNDArray arr = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray column2 = arr . getColumn ( <int> ) ; IComplexNDArray result = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; assertEquals ( result , column2 ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> , <int> } , column2 . shape ( ) ) ) ; IComplexNDArray column = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; arr . putColumn ( <int> , column ) ; IComplexNDArray firstColumn = arr . getColumn ( <int> ) ; assertEquals ( column , firstColumn ) ; IComplexNDArray column1 = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; arr . putColumn ( <int> , column1 ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> , <int> } , arr . getColumn ( <int> ) . shape ( ) ) ) ; IComplexNDArray testC = arr . getColumn ( <int> ) ; assertEquals ( column1 , testC ) ; IComplexNDArray multiSlice = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ) ; IComplexNDArray testColumn = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray sliceColumn = multiSlice . slice ( <int> ) . getColumn ( <int> ) ; assertEquals ( sliceColumn , testColumn ) ; IComplexNDArray testColumn2 = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray testSlice2 = multiSlice . slice ( <int> ) ; IComplexNDArray testSlice2ColumnZero = testSlice2 . getColumn ( <int> ) ; assertEquals ( testColumn2 , testSlice2ColumnZero ) ; IComplexNDArray testColumn3 = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray testSlice3 = multiSlice . slice ( <int> ) . getColumn ( <int> ) ; assertEquals ( testColumn3 , testSlice3 ) ; } @Test public void testGetIndexing ( ) { Nd4j . MAX_SLICES_TO_PRINT = Integer . MAX_VALUE ; Nd4j . MAX_ELEMENTS_PER_SLICE = Integer . MAX_VALUE ; IComplexNDArray tenByTen = Nd4j . complexLinSpace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; IComplexNDArray thirtyToSixty = ( IComplexNDArray ) Transforms . round ( Nd4j . complexLinSpace ( <int> , <int> , <int> ) ) . reshape ( <int> , <int> ) ; IComplexNDArray test = tenByTen . get ( NDArrayIndex . interval ( <int> , <int> ) , NDArrayIndex . interval ( <int> , tenByTen . columns ( ) ) ) ; assertEquals ( thirtyToSixty , test ) ; } @Test public void testPutAndGet ( ) { IComplexNDArray multiRow = Nd4j . createComplex ( <int> , <int> ) ; multiRow . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; multiRow . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; multiRow . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; multiRow . putScalar ( <int> , <int> , Nd4j . createComplexNumber ( <int> , <int> ) ) ; assertEquals ( Nd4j . createComplexNumber ( <int> , <int> ) , multiRow . getComplex ( <int> , <int> ) ) ; assertEquals ( Nd4j . createComplexNumber ( <int> , <int> ) , multiRow . getComplex ( <int> , <int> ) ) ; assertEquals ( Nd4j . createComplexNumber ( <int> , <int> ) , multiRow . getComplex ( <int> , <int> ) ) ; assertEquals ( Nd4j . createComplexNumber ( <int> , <int> ) , multiRow . getComplex ( <int> , <int> ) ) ; IComplexNDArray arr = Nd4j . createComplex ( Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ) ; assertEquals ( <int> , arr . length ( ) ) ; assertEquals ( <int> , arr . data ( ) . length ( ) ) ; arr . put ( <int> , <int> , Nd4j . scalar ( <float> ) ) ; IComplexNumber n1 = arr . getComplex ( <int> , <int> ) ; IComplexNumber n2 = arr . getComplex ( <int> , <int> ) ; assertEquals ( <float> , n1 . realComponent ( ) . doubleValue ( ) , <float> ) ; assertEquals ( <float> , n2 . imaginaryComponent ( ) . doubleValue ( ) , <float> ) ; } @Test public void testGetReal ( ) { DataBuffer data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; int [ ] shape = new int [ ] { <int> , <int> } ; IComplexNDArray arr = Nd4j . createComplex ( shape ) ; for ( int i = <int> ; i < arr . length ( ) ; i + + ) arr . put ( i , Nd4j . scalar ( data . getFloat ( i ) ) ) ; INDArray arr2 = Nd4j . create ( data , shape ) ; assertEquals ( arr2 , arr . getReal ( ) ) ; INDArray ones = Nd4j . ones ( <int> ) ; IComplexNDArray n2 = Nd4j . complexOnes ( <int> ) ; assertEquals ( ones , n2 . getReal ( ) ) ; } @Test public void testBroadcast ( ) { IComplexNDArray arr = Nd4j . complexLinSpace ( <int> , <int> , <int> ) ; IComplexNDArray arrs = arr . broadcast ( new int [ ] { <int> , <int> } ) ; IComplexNDArray arrs3 = Nd4j . createComplex ( <int> , <int> ) ; assertTrue ( Arrays . equals ( arrs . shape ( ) , arrs3 . shape ( ) ) ) ; for ( int i = <int> ; i < arrs . slices ( ) ; i + + ) arrs3 . putSlice ( i , arr ) ; assertEquals ( arrs3 , arrs ) ; } @Test public void testBasicOperations ( ) { IComplexNDArray arr = Nd4j . createComplex ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; IComplexNumber scalar = arr . sumComplex ( ) ; double sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; arr . addi ( <int> ) ; scalar = arr . sumComplex ( ) ; sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; arr . subi ( Nd4j . createDouble ( <int> , <int> ) ) ; scalar = arr . sumComplex ( ) . asDouble ( ) ; sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; } @Test public void testComplexCalculation ( ) { IComplexNDArray arr = Nd4j . createComplex ( new IComplexNumber [ ] [ ] { { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } , { Nd4j . createComplexNumber ( <int> , <int> ) , Nd4j . createComplexNumber ( <int> , <int> ) } } ) ; IComplexNumber scalar = arr . sumComplex ( ) ; double sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; double sumImag = scalar . imaginaryComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sumImag , <float> ) ; IComplexNDArray res = arr . add ( Nd4j . createComplexNumber ( <int> , <int> ) ) ; scalar = res . sumComplex ( ) ; sum = scalar . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; sumImag = scalar . imaginaryComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sumImag , <float> ) ; sum = arr . sumComplex ( ) . realComponent ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; } @Test public void testElementWiseOps ( ) { IComplexNDArray n1 = Nd4j . complexScalar ( <int> ) ; IComplexNDArray n2 = Nd4j . complexScalar ( <int> ) ; assertEquals ( Nd4j . complexScalar ( <int> ) , n1 . add ( n2 ) ) ; assertFalse ( n1 . add ( n2 ) . equals ( n1 ) ) ; IComplexNDArray n3 = Nd4j . complexScalar ( <int> ) ; IComplexNDArray n4 = Nd4j . complexScalar ( <int> ) ; IComplexNDArray subbed = n4 . sub ( n3 ) ; IComplexNDArray mulled = n4 . mul ( n3 ) ; IComplexNDArray div = n4 . div ( n3 ) ; assertFalse ( subbed . equals ( n4 ) ) ; assertFalse ( mulled . equals ( n4 ) ) ; assertEquals ( Nd4j . complexScalar ( <int> ) , subbed ) ; assertEquals ( Nd4j . complexScalar ( <int> ) , mulled ) ; assertEquals ( Nd4j . complexScalar ( <float> ) , div ) ; IComplexNDArray multiDimensionElementWise = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ) ; IComplexNumber sum2 = multiDimensionElementWise . sumComplex ( ) ; assertEquals ( sum2 , Nd4j . createDouble ( <int> , <int> ) ) ; IComplexNDArray added = multiDimensionElementWise . add ( Nd4j . complexScalar ( <int> ) ) ; IComplexNumber sum3 = added . sumComplex ( ) ; assertEquals ( sum3 , Nd4j . createDouble ( <int> , <int> ) ) ; } @Test public void testFlatten ( ) { IComplexNDArray arr = Nd4j . createComplex ( Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ) ; IComplexNDArray flattened = arr . ravel ( ) ; assertEquals ( arr . length ( ) , flattened . length ( ) ) ; assertTrue ( Shape . shapeEquals ( new int [ ] { <int> , <int> } , flattened . shape ( ) ) ) ; for ( int i = <int> ; i < arr . length ( ) ; i + + ) { IComplexNumber get = ( IComplexNumber ) flattened . getScalar ( i ) . element ( ) ; assertEquals ( i + <int> , get . realComponent ( ) . doubleValue ( ) , <float> ) ; } } @Test public void testMatrixGet ( ) { IComplexNDArray arr = Nd4j . createComplex ( ( Nd4j . linspace ( <int> , <int> , <int> ) ) ) . reshape ( <int> , <int> ) ; IComplexNumber n1 = arr . getComplex ( <int> , <int> ) ; IComplexNumber n2 = arr . getComplex ( <int> , <int> ) ; IComplexNumber n3 = arr . getComplex ( <int> , <int> ) ; IComplexNumber n4 = arr . getComplex ( <int> , <int> ) ; assertEquals ( <int> , n1 . realComponent ( ) . doubleValue ( ) , <float> ) ; assertEquals ( <int> , n2 . realComponent ( ) . doubleValue ( ) , <float> ) ; assertEquals ( <int> , n3 . realComponent ( ) . doubleValue ( ) , <float> ) ; assertEquals ( <int> , n4 . realComponent ( ) . doubleValue ( ) , <float> ) ; } @Override public char ordering ( ) { return <str> ; } } 
