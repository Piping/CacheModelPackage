package org . elasticsearch . action . admin . cluster . health ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . health . ClusterStateHealth ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matchers ; import java . io . IOException ; import static org . hamcrest . CoreMatchers . allOf ; import static org . hamcrest . Matchers . * ; public class ClusterHealthResponsesTests extends ESTestCase { public void testIsTimeout ( ) throws IOException { ClusterHealthResponse res = new ClusterHealthResponse ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { res . setTimedOut ( randomBoolean ( ) ) ; if ( res . isTimedOut ( ) ) { assertEquals ( RestStatus . REQUEST_TIMEOUT , res . status ( ) ) ; } else { assertEquals ( RestStatus . OK , res . status ( ) ) ; } } } public void testClusterHealth ( ) throws IOException { ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . build ( ) ; int pendingTasks = randomIntBetween ( <int> , <int> ) ; int inFlight = randomIntBetween ( <int> , <int> ) ; int delayedUnassigned = randomIntBetween ( <int> , <int> ) ; TimeValue pendingTaskInQueueTime = TimeValue . timeValueMillis ( randomIntBetween ( <int> , <int> ) ) ; ClusterHealthResponse clusterHealth = new ClusterHealthResponse ( <str> , new String [ ] { MetaData . ALL } , clusterState , pendingTasks , inFlight , delayedUnassigned , pendingTaskInQueueTime ) ; clusterHealth = maybeSerialize ( clusterHealth ) ; assertClusterHealth ( clusterHealth ) ; assertThat ( clusterHealth . getNumberOfPendingTasks ( ) , Matchers . equalTo ( pendingTasks ) ) ; assertThat ( clusterHealth . getNumberOfInFlightFetch ( ) , Matchers . equalTo ( inFlight ) ) ; assertThat ( clusterHealth . getDelayedUnassignedShards ( ) , Matchers . equalTo ( delayedUnassigned ) ) ; assertThat ( clusterHealth . getTaskMaxWaitingTime ( ) . millis ( ) , is ( pendingTaskInQueueTime . millis ( ) ) ) ; assertThat ( clusterHealth . getActiveShardsPercent ( ) , is ( allOf ( greaterThanOrEqualTo ( <float> ) , lessThanOrEqualTo ( <float> ) ) ) ) ; } private void assertClusterHealth ( ClusterHealthResponse clusterHealth ) { ClusterStateHealth clusterStateHealth = clusterHealth . getClusterStateHealth ( ) ; assertThat ( clusterHealth . getValidationFailures ( ) , Matchers . equalTo ( clusterStateHealth . getValidationFailures ( ) ) ) ; assertThat ( clusterHealth . getActiveShards ( ) , Matchers . equalTo ( clusterStateHealth . getActiveShards ( ) ) ) ; assertThat ( clusterHealth . getRelocatingShards ( ) , Matchers . equalTo ( clusterStateHealth . getRelocatingShards ( ) ) ) ; assertThat ( clusterHealth . getActivePrimaryShards ( ) , Matchers . equalTo ( clusterStateHealth . getActivePrimaryShards ( ) ) ) ; assertThat ( clusterHealth . getInitializingShards ( ) , Matchers . equalTo ( clusterStateHealth . getInitializingShards ( ) ) ) ; assertThat ( clusterHealth . getUnassignedShards ( ) , Matchers . equalTo ( clusterStateHealth . getUnassignedShards ( ) ) ) ; assertThat ( clusterHealth . getNumberOfNodes ( ) , Matchers . equalTo ( clusterStateHealth . getNumberOfNodes ( ) ) ) ; assertThat ( clusterHealth . getNumberOfDataNodes ( ) , Matchers . equalTo ( clusterStateHealth . getNumberOfDataNodes ( ) ) ) ; } ClusterHealthResponse maybeSerialize ( ClusterHealthResponse clusterHealth ) throws IOException { if ( randomBoolean ( ) ) { BytesStreamOutput out = new BytesStreamOutput ( ) ; clusterHealth . writeTo ( out ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ; clusterHealth = ClusterHealthResponse . readResponseFrom ( in ) ; } return clusterHealth ; } } 
