package org . elasticsearch . index . fielddata . plain ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . DocValues ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . fielddata . IndexFieldData ; import org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource . Nested ; import org . elasticsearch . index . fielddata . IndexFieldDataCache ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MappedFieldType . Names ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import org . elasticsearch . search . MultiValueMode ; import java . io . IOException ; public class BytesBinaryDVIndexFieldData extends DocValuesIndexFieldData implements IndexFieldData < BytesBinaryDVAtomicFieldData > { public BytesBinaryDVIndexFieldData ( Index index , Names fieldNames , FieldDataType fieldDataType ) { super ( index , fieldNames , fieldDataType ) ; } @Override public final XFieldComparatorSource comparatorSource ( @Nullable Object missingValue , MultiValueMode sortMode , Nested nested ) { throw new IllegalArgumentException ( <str> ) ; } @Override public BytesBinaryDVAtomicFieldData load ( LeafReaderContext context ) { try { return new BytesBinaryDVAtomicFieldData ( DocValues . getBinary ( context . reader ( ) , fieldNames . indexName ( ) ) ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } @Override public BytesBinaryDVAtomicFieldData loadDirect ( LeafReaderContext context ) throws Exception { return load ( context ) ; } public static class Builder implements IndexFieldData . Builder { @Override public IndexFieldData < ? > build ( IndexSettings indexSettings , MappedFieldType fieldType , IndexFieldDataCache cache , CircuitBreakerService breakerService , MapperService mapperService ) { final Names fieldNames = fieldType . names ( ) ; return new BytesBinaryDVIndexFieldData ( indexSettings . getIndex ( ) , fieldNames , fieldType . fieldDataType ( ) ) ; } } } 
