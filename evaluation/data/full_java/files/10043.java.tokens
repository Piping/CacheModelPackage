package com . google . common . collect . testing . testers ; import static com . google . common . collect . testing . features . CollectionFeature . ALLOWS_NULL_VALUES ; import static com . google . common . collect . testing . features . CollectionFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION ; import static com . google . common . collect . testing . features . CollectionFeature . RESTRICTS_ELEMENTS ; import static com . google . common . collect . testing . features . CollectionFeature . SUPPORTS_ADD ; import static com . google . common . collect . testing . features . CollectionSize . ZERO ; import static java . util . Collections . singletonList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . AbstractCollectionTester ; import com . google . common . collect . testing . Helpers ; import com . google . common . collect . testing . MinimalCollection ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import java . lang . reflect . Method ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . List ; @SuppressWarnings ( <str> ) @GwtCompatible ( emulated = true ) public class CollectionAddAllTester < E > extends AbstractCollectionTester < E > { @CollectionFeature.Require ( SUPPORTS_ADD ) public void testAddAll_supportedNothing ( ) { assertFalse ( <str> , collection . addAll ( emptyCollection ( ) ) ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( absent = SUPPORTS_ADD ) public void testAddAll_unsupportedNothing ( ) { try { assertFalse ( <str> , collection . addAll ( emptyCollection ( ) ) ) ; } catch ( UnsupportedOperationException tolerated ) { } expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_ADD ) public void testAddAll_supportedNonePresent ( ) { assertTrue ( <str> , collection . addAll ( createDisjointCollection ( ) ) ) ; expectAdded ( e3 ( ) , e4 ( ) ) ; } @CollectionFeature.Require ( absent = SUPPORTS_ADD ) public void testAddAll_unsupportedNonePresent ( ) { try { collection . addAll ( createDisjointCollection ( ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } expectUnchanged ( ) ; expectMissing ( e3 ( ) , e4 ( ) ) ; } @CollectionFeature.Require ( SUPPORTS_ADD ) @CollectionSize.Require ( absent = ZERO ) public void testAddAll_supportedSomePresent ( ) { assertTrue ( <str> , collection . addAll ( MinimalCollection . of ( e3 ( ) , e0 ( ) ) ) ) ; assertTrue ( <str> + e3 ( ) , collection . contains ( e3 ( ) ) ) ; assertTrue ( <str> + e0 ( ) , collection . contains ( e0 ( ) ) ) ; } @CollectionFeature.Require ( absent = SUPPORTS_ADD ) @CollectionSize.Require ( absent = ZERO ) public void testAddAll_unsupportedSomePresent ( ) { try { collection . addAll ( MinimalCollection . of ( e3 ( ) , e0 ( ) ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } expectUnchanged ( ) ; } @CollectionFeature.Require ( { SUPPORTS_ADD , FAILS_FAST_ON_CONCURRENT_MODIFICATION } ) @CollectionSize.Require ( absent = ZERO ) public void testAddAllConcurrentWithIteration ( ) { try { Iterator < E > iterator = collection . iterator ( ) ; assertTrue ( collection . addAll ( MinimalCollection . of ( e3 ( ) , e0 ( ) ) ) ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @CollectionFeature.Require ( absent = SUPPORTS_ADD ) @CollectionSize.Require ( absent = ZERO ) public void testAddAll_unsupportedAllPresent ( ) { try { assertFalse ( <str> , collection . addAll ( MinimalCollection . of ( e0 ( ) ) ) ) ; } catch ( UnsupportedOperationException tolerated ) { } expectUnchanged ( ) ; } @CollectionFeature.Require ( value = { SUPPORTS_ADD , ALLOWS_NULL_VALUES } , absent = RESTRICTS_ELEMENTS ) public void testAddAll_nullSupported ( ) { List < E > containsNull = singletonList ( null ) ; assertTrue ( <str> , collection . addAll ( containsNull ) ) ; expectAdded ( ( E ) null ) ; } @CollectionFeature.Require ( value = SUPPORTS_ADD , absent = ALLOWS_NULL_VALUES ) public void testAddAll_nullUnsupported ( ) { List < E > containsNull = singletonList ( null ) ; try { collection . addAll ( containsNull ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } expectUnchanged ( ) ; expectNullMissingWhenNullUnsupported ( <str> ) ; } @CollectionFeature.Require ( SUPPORTS_ADD ) public void testAddAll_nullCollectionReference ( ) { try { collection . addAll ( null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } @GwtIncompatible ( <str> ) public static Method getAddAllNullUnsupportedMethod ( ) { return Helpers . getMethod ( CollectionAddAllTester . class , <str> ) ; } @GwtIncompatible ( <str> ) public static Method getAddAllUnsupportedNonePresentMethod ( ) { return Helpers . getMethod ( CollectionAddAllTester . class , <str> ) ; } @GwtIncompatible ( <str> ) public static Method getAddAllUnsupportedSomePresentMethod ( ) { return Helpers . getMethod ( CollectionAddAllTester . class , <str> ) ; } } 
