package org . gradle . launcher . daemon . server ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . launcher . daemon . context . DaemonContext ; import org . gradle . launcher . daemon . logging . DaemonMessages ; import org . gradle . launcher . daemon . registry . DaemonRegistry ; import org . gradle . launcher . daemon . server . exec . DaemonCommandExecuter ; import org . gradle . messaging . remote . Address ; import java . util . Date ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class Daemon implements Stoppable { private static final Logger LOGGER = Logging . getLogger ( Daemon . class ) ; private final DaemonServerConnector connector ; private final DaemonRegistry daemonRegistry ; private final DaemonContext daemonContext ; private final DaemonCommandExecuter commandExecuter ; private final ExecutorFactory executorFactory ; private final String password ; private DaemonStateCoordinator stateCoordinator ; private final Lock lifecyleLock = new ReentrantLock ( ) ; private Address connectorAddress ; private DomainRegistryUpdater registryUpdater ; private DefaultIncomingConnectionHandler connectionHandler ; public Daemon ( DaemonServerConnector connector , DaemonRegistry daemonRegistry , DaemonContext daemonContext , String password , DaemonCommandExecuter commandExecuter , ExecutorFactory executorFactory ) { this . connector = connector ; this . daemonRegistry = daemonRegistry ; this . daemonContext = daemonContext ; this . password = password ; this . commandExecuter = commandExecuter ; this . executorFactory = executorFactory ; } public String getUid ( ) { return daemonContext . getUid ( ) ; } public Address getAddress ( ) { return connectorAddress ; } public void start ( ) { LOGGER . info ( <str> , daemonContext ) ; lifecyleLock . lock ( ) ; try { if ( stateCoordinator ! = null ) { throw new IllegalStateException ( <str> ) ; } registryUpdater = new DomainRegistryUpdater ( daemonRegistry , daemonContext , password ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { public void run ( ) { try { daemonRegistry . remove ( connectorAddress ) ; } catch ( Exception e ) { LOGGER . debug ( <str> , e ) ; } } } ) ; Runnable onStartCommand = new Runnable ( ) { public void run ( ) { registryUpdater . onStartActivity ( ) ; } } ; Runnable onFinishCommand = new Runnable ( ) { public void run ( ) { registryUpdater . onCompleteActivity ( ) ; } } ; stateCoordinator = new DaemonStateCoordinator ( executorFactory , onStartCommand , onFinishCommand ) ; connectionHandler = new DefaultIncomingConnectionHandler ( commandExecuter , daemonContext , stateCoordinator , executorFactory ) ; connectorAddress = connector . start ( connectionHandler ) ; LOGGER . debug ( <str> , new Date ( ) , connectorAddress ) ; registryUpdater . onStart ( connectorAddress ) ; } finally { lifecyleLock . unlock ( ) ; } LOGGER . lifecycle ( DaemonMessages . PROCESS_STARTED ) ; } public void stop ( ) { LOGGER . debug ( <str> ) ; lifecyleLock . lock ( ) ; try { if ( stateCoordinator = = null ) { throw new IllegalStateException ( <str> ) ; } LOGGER . info ( DaemonMessages . REMOVING_PRESENCE_DUE_TO_STOP ) ; CompositeStoppable . stoppable ( stateCoordinator , registryUpdater , connector , connectionHandler ) . stop ( ) ; } finally { lifecyleLock . unlock ( ) ; } } public void requestStopOnIdleTimeout ( int idleTimeout , TimeUnit idleTimeoutUnits ) { LOGGER . debug ( <str> , idleTimeout , idleTimeoutUnits ) ; DaemonStateCoordinator stateCoordinator ; lifecyleLock . lock ( ) ; try { if ( this . stateCoordinator = = null ) { throw new IllegalStateException ( <str> ) ; } stateCoordinator = this . stateCoordinator ; } finally { lifecyleLock . unlock ( ) ; } stateCoordinator . stopOnIdleTimeout ( idleTimeout , idleTimeoutUnits ) ; } } 
