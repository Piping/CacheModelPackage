package org . apache . cassandra . utils ; class BloomCalculations { private static final int minBuckets = <int> ; private static final int minK = <int> ; private static final int EXCESS = <int> ; static final double [ ] [ ] probs = new double [ ] [ ] { { <float> } , { <float> , <float> } , { <float> , <float> , <float> } , { <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } } ; private static final int [ ] optKPerBuckets = new int [ probs . length ] ; static { for ( int i = <int> ; i < probs . length ; i + + ) { double min = Double . MAX_VALUE ; double [ ] prob = probs [ i ] ; for ( int j = <int> ; j < prob . length ; j + + ) { if ( prob [ j ] < min ) { min = prob [ j ] ; optKPerBuckets [ i ] = Math . max ( minK , j ) ; } } } } public static BloomSpecification computeBloomSpec ( int bucketsPerElement ) { assert bucketsPerElement > = <int> ; assert bucketsPerElement < = probs . length - <int> ; return new BloomSpecification ( optKPerBuckets [ bucketsPerElement ] , bucketsPerElement ) ; } public static class BloomSpecification { final int K ; final int bucketsPerElement ; public BloomSpecification ( int k , int bucketsPerElement ) { K = k ; this . bucketsPerElement = bucketsPerElement ; } public String toString ( ) { return String . format ( <str> , K , bucketsPerElement ) ; } } public static BloomSpecification computeBloomSpec ( int maxBucketsPerElement , double maxFalsePosProb ) { assert maxBucketsPerElement > = <int> ; assert maxBucketsPerElement < = probs . length - <int> ; int maxK = probs [ maxBucketsPerElement ] . length - <int> ; if ( maxFalsePosProb > = probs [ minBuckets ] [ minK ] ) { return new BloomSpecification ( <int> , optKPerBuckets [ <int> ] ) ; } if ( maxFalsePosProb < probs [ maxBucketsPerElement ] [ maxK ] ) { throw new UnsupportedOperationException ( String . format ( <str> , maxFalsePosProb , maxBucketsPerElement ) ) ; } int bucketsPerElement = <int> ; int K = optKPerBuckets [ <int> ] ; while ( probs [ bucketsPerElement ] [ K ] > maxFalsePosProb ) { bucketsPerElement + + ; K = optKPerBuckets [ bucketsPerElement ] ; } while ( probs [ bucketsPerElement ] [ K - <int> ] < = maxFalsePosProb ) { K - - ; } return new BloomSpecification ( K , bucketsPerElement ) ; } public static int maxBucketsPerElement ( long numElements ) { numElements = Math . max ( <int> , numElements ) ; double v = ( Long . MAX_VALUE - EXCESS ) / ( double ) numElements ; if ( v < <float> ) { throw new UnsupportedOperationException ( <str> + numElements + <str> ) ; } return Math . min ( BloomCalculations . probs . length - <int> , ( int ) v ) ; } } 
