package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufInputStream ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . CharsetUtil ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . ThreadLocalRandom ; import org . junit . Test ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . util . zip . DeflaterOutputStream ; import java . util . zip . GZIPInputStream ; import java . util . zip . GZIPOutputStream ; import static org . junit . Assert . * ; public abstract class ZlibTest { private static final byte [ ] BYTES_SMALL = new byte [ <int> ] ; private static final byte [ ] BYTES_LARGE = new byte [ <int> * <int> ] ; private static final byte [ ] BYTES_LARGE2 = ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) . getBytes ( CharsetUtil . UTF_8 ) ; static { ThreadLocalRandom rand = ThreadLocalRandom . current ( ) ; rand . nextBytes ( BYTES_SMALL ) ; rand . nextBytes ( BYTES_LARGE ) ; } protected abstract ZlibEncoder createEncoder ( ZlibWrapper wrapper ) ; protected abstract ZlibDecoder createDecoder ( ZlibWrapper wrapper ) ; @Test public void testGZIP2 ( ) throws Exception { byte [ ] bytes = <str> . getBytes ( CharsetUtil . UTF_8 ) ; ByteBuf data = Unpooled . wrappedBuffer ( bytes ) ; ByteBuf deflatedData = Unpooled . wrappedBuffer ( gzip ( bytes ) ) ; EmbeddedChannel chDecoderGZip = new EmbeddedChannel ( createDecoder ( ZlibWrapper . GZIP ) ) ; try { chDecoderGZip . writeInbound ( deflatedData ) ; assertTrue ( chDecoderGZip . finish ( ) ) ; ByteBuf buf = chDecoderGZip . readInbound ( ) ; assertEquals ( buf , data ) ; assertNull ( chDecoderGZip . readInbound ( ) ) ; data . release ( ) ; buf . release ( ) ; } finally { dispose ( chDecoderGZip ) ; } } private void testCompress0 ( ZlibWrapper encoderWrapper , ZlibWrapper decoderWrapper , ByteBuf data ) throws Exception { EmbeddedChannel chEncoder = new EmbeddedChannel ( createEncoder ( encoderWrapper ) ) ; EmbeddedChannel chDecoderZlib = new EmbeddedChannel ( createDecoder ( decoderWrapper ) ) ; try { chEncoder . writeOutbound ( data . retain ( ) ) ; chEncoder . flush ( ) ; data . resetReaderIndex ( ) ; for ( ; ; ) { ByteBuf deflatedData = chEncoder . readOutbound ( ) ; if ( deflatedData = = null ) { break ; } chDecoderZlib . writeInbound ( deflatedData ) ; } byte [ ] decompressed = new byte [ data . readableBytes ( ) ] ; int offset = <int> ; for ( ; ; ) { ByteBuf buf = chDecoderZlib . readInbound ( ) ; if ( buf = = null ) { break ; } int length = buf . readableBytes ( ) ; buf . readBytes ( decompressed , offset , length ) ; offset + = length ; buf . release ( ) ; if ( offset = = decompressed . length ) { break ; } } assertEquals ( data , Unpooled . wrappedBuffer ( decompressed ) ) ; assertNull ( chDecoderZlib . readInbound ( ) ) ; assertTrue ( chEncoder . finish ( ) ) ; for ( ; ; ) { Object msg = chEncoder . readOutbound ( ) ; if ( msg = = null ) { break ; } ReferenceCountUtil . release ( msg ) ; } assertFalse ( chDecoderZlib . finish ( ) ) ; data . release ( ) ; } finally { dispose ( chEncoder ) ; dispose ( chDecoderZlib ) ; } } private void testCompressNone ( ZlibWrapper encoderWrapper , ZlibWrapper decoderWrapper ) throws Exception { EmbeddedChannel chEncoder = new EmbeddedChannel ( createEncoder ( encoderWrapper ) ) ; EmbeddedChannel chDecoderZlib = new EmbeddedChannel ( createDecoder ( decoderWrapper ) ) ; try { assertTrue ( chEncoder . finish ( ) ) ; for ( ; ; ) { ByteBuf deflatedData = chEncoder . readOutbound ( ) ; if ( deflatedData = = null ) { break ; } chDecoderZlib . writeInbound ( deflatedData ) ; } boolean decoded = false ; for ( ; ; ) { ByteBuf buf = chDecoderZlib . readInbound ( ) ; if ( buf = = null ) { break ; } buf . release ( ) ; decoded = true ; } assertFalse ( <str> , decoded ) ; assertFalse ( chDecoderZlib . finish ( ) ) ; } finally { dispose ( chEncoder ) ; dispose ( chDecoderZlib ) ; } } private static void dispose ( EmbeddedChannel ch ) { if ( ch . finish ( ) ) { for ( ; ; ) { Object msg = ch . readInbound ( ) ; if ( msg = = null ) { break ; } ReferenceCountUtil . release ( msg ) ; } for ( ; ; ) { Object msg = ch . readOutbound ( ) ; if ( msg = = null ) { break ; } ReferenceCountUtil . release ( msg ) ; } } } private void testDecompressOnly ( ZlibWrapper decoderWrapper , byte [ ] compressed , byte [ ] data ) throws Exception { EmbeddedChannel chDecoder = new EmbeddedChannel ( createDecoder ( decoderWrapper ) ) ; chDecoder . writeInbound ( Unpooled . wrappedBuffer ( compressed ) ) ; assertTrue ( chDecoder . finish ( ) ) ; ByteBuf decoded = Unpooled . buffer ( data . length ) ; for ( ; ; ) { ByteBuf buf = chDecoder . readInbound ( ) ; if ( buf = = null ) { break ; } decoded . writeBytes ( buf ) ; buf . release ( ) ; } assertEquals ( Unpooled . wrappedBuffer ( data ) , decoded ) ; decoded . release ( ) ; } private void testCompressSmall ( ZlibWrapper encoderWrapper , ZlibWrapper decoderWrapper ) throws Exception { testCompress0 ( encoderWrapper , decoderWrapper , Unpooled . wrappedBuffer ( BYTES_SMALL ) ) ; testCompress0 ( encoderWrapper , decoderWrapper , Unpooled . directBuffer ( BYTES_SMALL . length ) . writeBytes ( BYTES_SMALL ) ) ; } private void testCompressLarge ( ZlibWrapper encoderWrapper , ZlibWrapper decoderWrapper ) throws Exception { testCompress0 ( encoderWrapper , decoderWrapper , Unpooled . wrappedBuffer ( BYTES_LARGE ) ) ; testCompress0 ( encoderWrapper , decoderWrapper , Unpooled . directBuffer ( BYTES_LARGE . length ) . writeBytes ( BYTES_LARGE ) ) ; } @Test public void testZLIB ( ) throws Exception { testCompressNone ( ZlibWrapper . ZLIB , ZlibWrapper . ZLIB ) ; testCompressSmall ( ZlibWrapper . ZLIB , ZlibWrapper . ZLIB ) ; testCompressLarge ( ZlibWrapper . ZLIB , ZlibWrapper . ZLIB ) ; testDecompressOnly ( ZlibWrapper . ZLIB , deflate ( BYTES_LARGE2 ) , BYTES_LARGE2 ) ; } @Test public void testNONE ( ) throws Exception { testCompressNone ( ZlibWrapper . NONE , ZlibWrapper . NONE ) ; testCompressSmall ( ZlibWrapper . NONE , ZlibWrapper . NONE ) ; testCompressLarge ( ZlibWrapper . NONE , ZlibWrapper . NONE ) ; } @Test public void testGZIP ( ) throws Exception { testCompressNone ( ZlibWrapper . GZIP , ZlibWrapper . GZIP ) ; testCompressSmall ( ZlibWrapper . GZIP , ZlibWrapper . GZIP ) ; testCompressLarge ( ZlibWrapper . GZIP , ZlibWrapper . GZIP ) ; testDecompressOnly ( ZlibWrapper . GZIP , gzip ( BYTES_LARGE2 ) , BYTES_LARGE2 ) ; } @Test public void testGZIPCompressOnly ( ) throws Exception { testGZIPCompressOnly0 ( null ) ; testGZIPCompressOnly0 ( EmptyArrays . EMPTY_BYTES ) ; testGZIPCompressOnly0 ( BYTES_SMALL ) ; testGZIPCompressOnly0 ( BYTES_LARGE ) ; } private void testGZIPCompressOnly0 ( byte [ ] data ) throws IOException { EmbeddedChannel chEncoder = new EmbeddedChannel ( createEncoder ( ZlibWrapper . GZIP ) ) ; if ( data ! = null ) { chEncoder . writeOutbound ( Unpooled . wrappedBuffer ( data ) ) ; } assertTrue ( chEncoder . finish ( ) ) ; ByteBuf encoded = Unpooled . buffer ( ) ; for ( ; ; ) { ByteBuf buf = chEncoder . readOutbound ( ) ; if ( buf = = null ) { break ; } encoded . writeBytes ( buf ) ; buf . release ( ) ; } ByteBuf decoded = Unpooled . buffer ( ) ; GZIPInputStream stream = new GZIPInputStream ( new ByteBufInputStream ( encoded ) ) ; byte [ ] buf = new byte [ <int> ] ; for ( ; ; ) { int readBytes = stream . read ( buf ) ; if ( readBytes < <int> ) { break ; } decoded . writeBytes ( buf , <int> , readBytes ) ; } stream . close ( ) ; if ( data ! = null ) { assertEquals ( Unpooled . wrappedBuffer ( data ) , decoded ) ; } else { assertFalse ( decoded . isReadable ( ) ) ; } encoded . release ( ) ; decoded . release ( ) ; } @Test public void testZLIB_OR_NONE ( ) throws Exception { testCompressNone ( ZlibWrapper . NONE , ZlibWrapper . ZLIB_OR_NONE ) ; testCompressSmall ( ZlibWrapper . NONE , ZlibWrapper . ZLIB_OR_NONE ) ; testCompressLarge ( ZlibWrapper . NONE , ZlibWrapper . ZLIB_OR_NONE ) ; } @Test public void testZLIB_OR_NONE2 ( ) throws Exception { testCompressNone ( ZlibWrapper . ZLIB , ZlibWrapper . ZLIB_OR_NONE ) ; testCompressSmall ( ZlibWrapper . ZLIB , ZlibWrapper . ZLIB_OR_NONE ) ; testCompressLarge ( ZlibWrapper . ZLIB , ZlibWrapper . ZLIB_OR_NONE ) ; } @Test public void testZLIB_OR_NONE3 ( ) throws Exception { testCompressNone ( ZlibWrapper . GZIP , ZlibWrapper . ZLIB_OR_NONE ) ; testCompressSmall ( ZlibWrapper . GZIP , ZlibWrapper . ZLIB_OR_NONE ) ; testCompressLarge ( ZlibWrapper . GZIP , ZlibWrapper . ZLIB_OR_NONE ) ; } private static byte [ ] gzip ( byte [ ] bytes ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; GZIPOutputStream stream = new GZIPOutputStream ( out ) ; stream . write ( bytes ) ; stream . close ( ) ; return out . toByteArray ( ) ; } private static byte [ ] deflate ( byte [ ] bytes ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStream stream = new DeflaterOutputStream ( out ) ; stream . write ( bytes ) ; stream . close ( ) ; return out . toByteArray ( ) ; } } 
