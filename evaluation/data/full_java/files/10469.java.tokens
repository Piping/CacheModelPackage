package com . google . common . graph ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . graph . Graphs . MULTIGRAPH ; import static com . google . common . graph . Graphs . addEdge ; import static com . google . common . graph . Graphs . config ; import static com . google . common . graph . Graphs . copyOf ; import static com . google . common . graph . Graphs . mergeEdgesFrom ; import static com . google . common . graph . Graphs . mergeNodesFrom ; import static com . google . common . graph . Graphs . noSelfLoopPredicate ; import static com . google . common . truth . Truth . assertThat ; import static org . junit . Assert . fail ; import com . google . common . base . Predicate ; import com . google . common . collect . ImmutableSet ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . junit . runners . JUnit4 ; @RunWith ( JUnit4 . class ) public class GraphsTest { private static final Integer N1 = <int> ; private static final Integer N2 = <int> ; private static final Integer N3 = <int> ; private static final Integer N4 = <int> ; private static final String E11 = <str> ; private static final String E11_A = <str> ; private static final String E12 = <str> ; private static final String E12_A = <str> ; private static final String E21 = <str> ; private static final String E22 = <str> ; private static final String E44 = <str> ; private static final int NODE_COUNT = <int> ; private static final int EDGE_COUNT = <int> ; private static final String ERROR_PARALLEL_EDGE = <str> ; private static final String ERROR_NEGATIVE_NODE_COUNT = <str> ; private static final String ERROR_NEGATIVE_EDGE_COUNT = <str> ; private static final String ERROR_ADDED_PARALLEL_EDGE = <str> ; private static final String ERROR_ADDED_SELF_LOOP = <str> ; static final String ERROR_SELF_LOOP = <str> ; @Test public void createDirected ( ) { DirectedGraph < Integer , String > directedGraph = Graphs . createDirected ( ) ; assertThat ( directedGraph . nodes ( ) ) . isEmpty ( ) ; assertThat ( directedGraph . edges ( ) ) . isEmpty ( ) ; assertThat ( directedGraph . addEdge ( E12 , N1 , N2 ) ) . isTrue ( ) ; assertThat ( directedGraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; assertThat ( directedGraph . edgesConnecting ( N2 , N1 ) ) . isEmpty ( ) ; try { directedGraph . addEdge ( E12_A , N1 , N2 ) ; fail ( ERROR_ADDED_PARALLEL_EDGE ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_PARALLEL_EDGE ) ; } assertThat ( directedGraph . addEdge ( E11 , N1 , N1 ) ) . isTrue ( ) ; } @Test public void createUndirected ( ) { UndirectedGraph < Integer , String > undirectedGraph = Graphs . createUndirected ( ) ; assertThat ( undirectedGraph . nodes ( ) ) . isEmpty ( ) ; assertThat ( undirectedGraph . edges ( ) ) . isEmpty ( ) ; assertThat ( undirectedGraph . addEdge ( E12 , N1 , N2 ) ) . isTrue ( ) ; assertThat ( undirectedGraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; assertThat ( undirectedGraph . edgesConnecting ( N2 , N1 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; try { undirectedGraph . addEdge ( E12_A , N1 , N2 ) ; fail ( ERROR_ADDED_PARALLEL_EDGE ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_PARALLEL_EDGE ) ; } try { undirectedGraph . addEdge ( E21 , N2 , N1 ) ; fail ( ERROR_ADDED_PARALLEL_EDGE ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_PARALLEL_EDGE ) ; } assertThat ( undirectedGraph . addEdge ( E11 , N1 , N1 ) ) . isTrue ( ) ; } @Test public void createDirected_multigraph ( ) { DirectedGraph < Integer , String > directedMultigraph = Graphs . createDirected ( config ( ) . multigraph ( ) ) ; assertThat ( directedMultigraph . addEdge ( E12 , N1 , N2 ) ) . isTrue ( ) ; assertThat ( directedMultigraph . addEdge ( E12_A , N1 , N2 ) ) . isTrue ( ) ; assertThat ( directedMultigraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 , E12_A ) ) ; assertThat ( directedMultigraph . edgesConnecting ( N2 , N1 ) ) . isEmpty ( ) ; } @Test public void createUndirected_multigraph ( ) { UndirectedGraph < Integer , String > undirectedMultigraph = Graphs . createUndirected ( Graphs . MULTIGRAPH ) ; assertThat ( undirectedMultigraph . addEdge ( E12 , N1 , N2 ) ) . isTrue ( ) ; assertThat ( undirectedMultigraph . addEdge ( E12_A , N1 , N2 ) ) . isTrue ( ) ; assertThat ( undirectedMultigraph . addEdge ( E21 , N2 , N1 ) ) . isTrue ( ) ; assertThat ( undirectedMultigraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 , E12_A , E21 ) ) ; } @Test public void createDirected_expectedNodeCount ( ) { DirectedGraph < Integer , String > directedGraph = Graphs . createDirected ( config ( ) . expectedNodeCount ( NODE_COUNT ) ) ; assertThat ( directedGraph . addEdge ( E12 , N1 , N2 ) ) . isTrue ( ) ; assertThat ( directedGraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; assertThat ( directedGraph . edgesConnecting ( N2 , N1 ) ) . isEmpty ( ) ; } @Test public void createUndirected_expectedNodeCount ( ) { UndirectedGraph < Integer , String > undirectedGraph = Graphs . createUndirected ( config ( ) . expectedNodeCount ( NODE_COUNT ) ) ; assertThat ( undirectedGraph . addEdge ( E12 , N1 , N2 ) ) . isTrue ( ) ; assertThat ( undirectedGraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; assertThat ( undirectedGraph . edgesConnecting ( N2 , N1 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; } @Test @SuppressWarnings ( <str> ) public void config_expectedNodeCount_negative ( ) { try { config ( ) . expectedNodeCount ( - <int> ) ; fail ( ERROR_NEGATIVE_NODE_COUNT ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_NEGATIVE_NODE_COUNT ) ; } } @Test public void config_expectedNodeCount_overridden ( ) { GraphConfig oldConfig = config ( ) . expectedNodeCount ( NODE_COUNT ) ; assertThat ( oldConfig . getExpectedNodeCount ( ) . get ( ) ) . isEqualTo ( NODE_COUNT ) ; GraphConfig newConfig = oldConfig . expectedNodeCount ( NODE_COUNT + <int> ) ; assertThat ( oldConfig . getExpectedNodeCount ( ) . get ( ) ) . isEqualTo ( NODE_COUNT ) ; assertThat ( newConfig . getExpectedNodeCount ( ) . get ( ) ) . isEqualTo ( NODE_COUNT + <int> ) ; } @Test public void createDirected_expectedEdgeCount ( ) { DirectedGraph < Integer , String > directedGraph = Graphs . createDirected ( config ( ) . expectedEdgeCount ( EDGE_COUNT ) ) ; assertThat ( directedGraph . addEdge ( E12 , N1 , N2 ) ) . isTrue ( ) ; assertThat ( directedGraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; assertThat ( directedGraph . edgesConnecting ( N2 , N1 ) ) . isEmpty ( ) ; } @Test public void createUndirected_expectedEdgeCount ( ) { UndirectedGraph < Integer , String > undirectedGraph = Graphs . createUndirected ( config ( ) . expectedEdgeCount ( EDGE_COUNT ) ) ; assertThat ( undirectedGraph . addEdge ( E12 , N1 , N2 ) ) . isTrue ( ) ; assertThat ( undirectedGraph . edgesConnecting ( N1 , N2 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; assertThat ( undirectedGraph . edgesConnecting ( N2 , N1 ) ) . isEqualTo ( ImmutableSet . of ( E12 ) ) ; } @Test @SuppressWarnings ( <str> ) public void config_expectedEdgeCount_negative ( ) { try { config ( ) . expectedEdgeCount ( - <int> ) ; fail ( ERROR_NEGATIVE_EDGE_COUNT ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_NEGATIVE_EDGE_COUNT ) ; } } @Test public void config_expectedEdgeCount_overridden ( ) { GraphConfig oldConfig = config ( ) . expectedEdgeCount ( EDGE_COUNT ) ; assertThat ( oldConfig . getExpectedEdgeCount ( ) . get ( ) ) . isEqualTo ( EDGE_COUNT ) ; GraphConfig newConfig = oldConfig . expectedEdgeCount ( EDGE_COUNT + <int> ) ; assertThat ( oldConfig . getExpectedEdgeCount ( ) . get ( ) ) . isEqualTo ( EDGE_COUNT ) ; assertThat ( newConfig . getExpectedEdgeCount ( ) . get ( ) ) . isEqualTo ( EDGE_COUNT + <int> ) ; } @Test public void createDirected_noSelfLoops ( ) { DirectedGraph < Integer , String > directedGraph = Graphs . createDirected ( config ( ) . noSelfLoops ( ) ) ; try { directedGraph . addEdge ( E11 , N1 , N1 ) ; fail ( ERROR_ADDED_SELF_LOOP ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_SELF_LOOP ) ; } } @Test public void createUndirected_noSelfLoops ( ) { UndirectedGraph < Integer , String > undirectedGraph = Graphs . createUndirected ( config ( ) . noSelfLoops ( ) ) ; try { undirectedGraph . addEdge ( E11 , N1 , N1 ) ; fail ( ERROR_ADDED_SELF_LOOP ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_SELF_LOOP ) ; } } @Test @SuppressWarnings ( <str> ) public void config_immutability ( ) { config ( ) . multigraph ( ) ; assertThat ( config ( ) . isMultigraph ( ) ) . isFalse ( ) ; config ( ) . expectedNodeCount ( NODE_COUNT ) ; assertThat ( config ( ) . getExpectedNodeCount ( ) ) . isAbsent ( ) ; config ( ) . expectedEdgeCount ( EDGE_COUNT ) ; assertThat ( config ( ) . getExpectedEdgeCount ( ) ) . isAbsent ( ) ; config ( ) . noSelfLoops ( ) ; assertThat ( config ( ) . isSelfLoopsAllowed ( ) ) . isTrue ( ) ; } @Test public void addEdge_nullGraph ( ) { try { addEdge ( null , E11 , ImmutableSet . of ( N1 ) ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } @Test public void addEdge_nullNodes ( ) { try { addEdge ( Graphs . createDirected ( ) , E11 , null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } @Test public void addEdge_tooManyNodes ( ) { try { addEdge ( Graphs . < Integer , String > createDirected ( ) , E11 , ImmutableSet . < Integer > of ( N1 , N2 , N3 ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @Test public void addEdge_notEnoughNodes ( ) { try { addEdge ( Graphs . createDirected ( ) , E11 , ImmutableSet . of ( ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } @Test public void addEdge_selfLoop ( ) { DirectedGraph < Integer , String > directedGraph = Graphs . createDirected ( ) ; assertThat ( addEdge ( directedGraph , E11 , ImmutableSet . of ( N1 ) ) ) . isTrue ( ) ; assertThat ( directedGraph . edges ( ) ) . containsExactly ( E11 ) ; assertThat ( directedGraph . nodes ( ) ) . containsExactly ( N1 ) ; assertThat ( directedGraph . incidentNodes ( E11 ) ) . containsExactly ( N1 ) ; } @Test public void addEdge_basic ( ) { DirectedGraph < Integer , String > directedGraph = Graphs . createDirected ( ) ; assertThat ( addEdge ( directedGraph , E12 , ImmutableSet . of ( N1 , N2 ) ) ) . isTrue ( ) ; assertThat ( directedGraph . edges ( ) ) . containsExactly ( E12 ) ; assertThat ( directedGraph . nodes ( ) ) . containsExactly ( N1 , N2 ) . inOrder ( ) ; assertThat ( directedGraph . incidentNodes ( E12 ) ) . containsExactly ( N1 , N2 ) . inOrder ( ) ; } @Test @SuppressWarnings ( <str> ) public void copyOf_nullArgument ( ) { try { copyOf ( ( DirectedGraph ) null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } try { copyOf ( ( UndirectedGraph ) null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } @Test public void copyOf_directedGraph ( ) { DirectedGraph < Integer , String > directedGraph = buildDirectedTestGraph ( ) ; DirectedGraph < Integer , String > copy = copyOf ( directedGraph ) ; assertThat ( copy ) . isEqualTo ( directedGraph ) ; } @Test public void copyOf_undirectedGraph ( ) { UndirectedGraph < Integer , String > undirectedGraph = buildUndirectedTestGraph ( ) ; UndirectedGraph < Integer , String > copy = copyOf ( undirectedGraph ) ; assertThat ( copy ) . isEqualTo ( undirectedGraph ) ; } @Test public void copyOf_filtered_undirected ( ) { UndirectedGraph < Integer , String > undirectedGraph = buildUndirectedTestGraph ( ) ; undirectedGraph . addNode ( N3 ) ; Predicate < Integer > nodePredicate = connectedNodePredicate ( undirectedGraph ) ; Predicate < String > edgePredicate = noSelfLoopPredicate ( undirectedGraph ) ; UndirectedGraph < Integer , String > filteredCopy = copyOf ( undirectedGraph , nodePredicate , edgePredicate ) ; UndirectedGraph < Integer , String > expectedGraph = Graphs . createUndirected ( MULTIGRAPH ) ; expectedGraph . addEdge ( E12 , N1 , N2 ) ; expectedGraph . addEdge ( E12_A , N1 , N2 ) ; expectedGraph . addEdge ( E21 , N2 , N1 ) ; assertThat ( filteredCopy ) . isEqualTo ( expectedGraph ) ; } @Test public void copyOf_filtered_directed ( ) { DirectedGraph < Integer , String > directedGraph = buildDirectedTestGraph ( ) ; directedGraph . addNode ( N3 ) ; Predicate < Integer > nodePredicate = connectedNodePredicate ( directedGraph ) ; Predicate < String > edgePredicate = noSelfLoopPredicate ( directedGraph ) ; DirectedGraph < Integer , String > filteredCopy = copyOf ( directedGraph , nodePredicate , edgePredicate ) ; DirectedGraph < Integer , String > expectedGraph = Graphs . createDirected ( MULTIGRAPH ) ; expectedGraph . addEdge ( E12 , N1 , N2 ) ; expectedGraph . addEdge ( E12_A , N1 , N2 ) ; expectedGraph . addEdge ( E21 , N2 , N1 ) ; assertThat ( filteredCopy ) . isEqualTo ( expectedGraph ) ; } @Test public void mergeNodesFrom_directed ( ) { DirectedGraph < Integer , String > directedGraph = buildDirectedTestGraph ( ) ; directedGraph . addNode ( N3 ) ; DirectedGraph < Integer , String > actualGraph = Graphs . createDirected ( ) ; actualGraph . addNode ( N4 ) ; actualGraph . addNode ( N2 ) ; mergeNodesFrom ( directedGraph , actualGraph ) ; DirectedGraph < Integer , String > expectedGraph = Graphs . createDirected ( ) ; expectedGraph . addNode ( N1 ) ; expectedGraph . addNode ( N2 ) ; expectedGraph . addNode ( N3 ) ; expectedGraph . addNode ( N4 ) ; assertThat ( actualGraph ) . isEqualTo ( expectedGraph ) ; } @Test public void mergeNodesFrom_filtered_directed ( ) { DirectedGraph < Integer , String > directedGraph = buildDirectedTestGraph ( ) ; directedGraph . addNode ( N3 ) ; Predicate < Integer > nodePredicate = connectedNodePredicate ( directedGraph ) ; DirectedGraph < Integer , String > actualGraph = Graphs . createDirected ( ) ; actualGraph . addNode ( N4 ) ; actualGraph . addNode ( N2 ) ; mergeNodesFrom ( directedGraph , actualGraph , nodePredicate ) ; DirectedGraph < Integer , String > expectedGraph = Graphs . createDirected ( ) ; expectedGraph . addNode ( N1 ) ; expectedGraph . addNode ( N2 ) ; expectedGraph . addNode ( N4 ) ; assertThat ( actualGraph ) . isEqualTo ( expectedGraph ) ; } @Test public void mergeEdgesFrom_directed ( ) { DirectedGraph < Integer , String > directedGraph = buildDirectedTestGraph ( ) ; DirectedGraph < Integer , String > actualGraph = Graphs . createDirected ( MULTIGRAPH ) ; actualGraph . addEdge ( E11 , N1 , N1 ) ; actualGraph . addEdge ( E22 , N2 , N2 ) ; mergeEdgesFrom ( directedGraph , actualGraph ) ; DirectedGraph < Integer , String > expectedGraph = buildDirectedTestGraph ( ) ; expectedGraph . addEdge ( E22 , N2 , N2 ) ; assertThat ( actualGraph ) . isEqualTo ( expectedGraph ) ; } @Test public void mergeEdgesFrom_filtered_directed ( ) { DirectedGraph < Integer , String > directedGraph = buildDirectedTestGraph ( ) ; directedGraph . addNode ( N3 ) ; Predicate < String > edgePredicate = noSelfLoopPredicate ( directedGraph ) ; DirectedGraph < Integer , String > actualGraph = Graphs . createDirected ( MULTIGRAPH ) ; actualGraph . addEdge ( E11 , N1 , N1 ) ; actualGraph . addEdge ( E22 , N2 , N2 ) ; actualGraph . addEdge ( E44 , N4 , N4 ) ; actualGraph . addEdge ( E12 , N1 , N2 ) ; mergeEdgesFrom ( directedGraph , actualGraph , edgePredicate ) ; DirectedGraph < Integer , String > expectedGraph = Graphs . createDirected ( MULTIGRAPH ) ; expectedGraph . addEdge ( E11 , N1 , N1 ) ; expectedGraph . addEdge ( E22 , N2 , N2 ) ; expectedGraph . addEdge ( E44 , N4 , N4 ) ; expectedGraph . addEdge ( E12 , N1 , N2 ) ; expectedGraph . addEdge ( E12_A , N1 , N2 ) ; expectedGraph . addEdge ( E21 , N2 , N1 ) ; assertThat ( actualGraph ) . isEqualTo ( expectedGraph ) ; } @Test public void mergeNodesFrom_undirected ( ) { UndirectedGraph < Integer , String > undirectedGraph = buildUndirectedTestGraph ( ) ; undirectedGraph . addNode ( N3 ) ; UndirectedGraph < Integer , String > actualGraph = Graphs . createUndirected ( ) ; actualGraph . addNode ( N4 ) ; actualGraph . addNode ( N2 ) ; mergeNodesFrom ( undirectedGraph , actualGraph ) ; UndirectedGraph < Integer , String > expectedGraph = Graphs . createUndirected ( ) ; expectedGraph . addNode ( N1 ) ; expectedGraph . addNode ( N2 ) ; expectedGraph . addNode ( N3 ) ; expectedGraph . addNode ( N4 ) ; assertThat ( actualGraph ) . isEqualTo ( expectedGraph ) ; } @Test public void mergeNodesFrom_filtered_undirected ( ) { UndirectedGraph < Integer , String > undirectedGraph = buildUndirectedTestGraph ( ) ; undirectedGraph . addNode ( N3 ) ; Predicate < Integer > nodePredicate = connectedNodePredicate ( undirectedGraph ) ; UndirectedGraph < Integer , String > actualGraph = Graphs . createUndirected ( ) ; actualGraph . addNode ( N4 ) ; actualGraph . addNode ( N2 ) ; mergeNodesFrom ( undirectedGraph , actualGraph , nodePredicate ) ; UndirectedGraph < Integer , String > expectedGraph = Graphs . createUndirected ( ) ; expectedGraph . addNode ( N1 ) ; expectedGraph . addNode ( N2 ) ; expectedGraph . addNode ( N4 ) ; assertThat ( actualGraph ) . isEqualTo ( expectedGraph ) ; } @Test public void mergeEdgesFrom_undirected ( ) { UndirectedGraph < Integer , String > undirectedGraph = buildUndirectedTestGraph ( ) ; UndirectedGraph < Integer , String > actualGraph = Graphs . createUndirected ( MULTIGRAPH ) ; actualGraph . addEdge ( E11 , N1 , N1 ) ; actualGraph . addEdge ( E22 , N2 , N2 ) ; mergeEdgesFrom ( undirectedGraph , actualGraph ) ; UndirectedGraph < Integer , String > expectedGraph = buildUndirectedTestGraph ( ) ; expectedGraph . addEdge ( E22 , N2 , N2 ) ; assertThat ( actualGraph ) . isEqualTo ( expectedGraph ) ; } @Test public void mergeEdgesFrom_filtered_undirected ( ) { UndirectedGraph < Integer , String > undirectedGraph = buildUndirectedTestGraph ( ) ; undirectedGraph . addNode ( N3 ) ; Predicate < String > edgePredicate = noSelfLoopPredicate ( undirectedGraph ) ; UndirectedGraph < Integer , String > actualGraph = Graphs . createUndirected ( MULTIGRAPH ) ; actualGraph . addEdge ( E11 , N1 , N1 ) ; actualGraph . addEdge ( E22 , N2 , N2 ) ; actualGraph . addEdge ( E44 , N4 , N4 ) ; actualGraph . addEdge ( E12 , N1 , N2 ) ; mergeEdgesFrom ( undirectedGraph , actualGraph , edgePredicate ) ; UndirectedGraph < Integer , String > expectedGraph = Graphs . createUndirected ( MULTIGRAPH ) ; expectedGraph . addEdge ( E11 , N1 , N1 ) ; expectedGraph . addEdge ( E22 , N2 , N2 ) ; expectedGraph . addEdge ( E44 , N4 , N4 ) ; expectedGraph . addEdge ( E12 , N1 , N2 ) ; expectedGraph . addEdge ( E12_A , N1 , N2 ) ; expectedGraph . addEdge ( E21 , N2 , N1 ) ; assertThat ( actualGraph ) . isEqualTo ( expectedGraph ) ; } private static DirectedGraph < Integer , String > buildDirectedTestGraph ( ) { DirectedGraph < Integer , String > directedGraph = Graphs . createDirected ( MULTIGRAPH ) ; directedGraph . addEdge ( E11 , N1 , N1 ) ; directedGraph . addEdge ( E12 , N1 , N2 ) ; directedGraph . addEdge ( E11_A , N1 , N1 ) ; directedGraph . addEdge ( E12_A , N1 , N2 ) ; directedGraph . addEdge ( E21 , N2 , N1 ) ; return directedGraph ; } private static UndirectedGraph < Integer , String > buildUndirectedTestGraph ( ) { UndirectedGraph < Integer , String > undirectedGraph = Graphs . createUndirected ( MULTIGRAPH ) ; undirectedGraph . addEdge ( E11 , N1 , N1 ) ; undirectedGraph . addEdge ( E12 , N1 , N2 ) ; undirectedGraph . addEdge ( E11_A , N1 , N1 ) ; undirectedGraph . addEdge ( E12_A , N1 , N2 ) ; undirectedGraph . addEdge ( E21 , N2 , N1 ) ; return undirectedGraph ; } private static < N > Predicate < N > connectedNodePredicate ( final Graph < N , ? > graph ) { checkNotNull ( graph , <str> ) ; return new Predicate < N > ( ) { @Override public boolean apply ( N node ) { return graph . degree ( node ) > <int> ; } } ; } } 
