package org . gradle . internal . classloader ; import org . gradle . internal . Transformers ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . internal . service . ServiceLocator ; import org . gradle . util . CollectionUtils ; import javax . xml . datatype . DatatypeFactory ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . SAXParserFactory ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URL ; import java . util . Collection ; import java . util . List ; public class DefaultClassLoaderFactory implements ClassLoaderFactory { @Override public ClassLoader getIsolatedSystemClassLoader ( ) { return getSystemClassLoader ( ) . getParent ( ) ; } public ClassLoader createIsolatedClassLoader ( Iterable < URI > uris ) { return doCreateIsolatedClassLoader ( CollectionUtils . collect ( uris , Transformers . toURL ( ) ) ) ; } public ClassLoader createIsolatedClassLoader ( ClassPath classPath ) { return doCreateIsolatedClassLoader ( classPath . getAsURLs ( ) ) ; } private ClassLoader doCreateIsolatedClassLoader ( Collection < URL > classpath ) { if ( needJaxpImpl ( ) ) { try { classpath . add ( ClasspathUtil . getClasspathForResource ( getSystemClassLoader ( ) , <str> ) . toURI ( ) . toURL ( ) ) ; } catch ( MalformedURLException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } return new MutableURLClassLoader ( getIsolatedSystemClassLoader ( ) , classpath ) ; } public FilteringClassLoader createFilteringClassLoader ( ClassLoader parent ) { FilteringClassLoader classLoader = new FilteringClassLoader ( parent ) ; if ( needJaxpImpl ( ) ) { ServiceLocator locator = new ServiceLocator ( getSystemClassLoader ( ) ) ; makeServiceVisible ( locator , classLoader , SAXParserFactory . class ) ; makeServiceVisible ( locator , classLoader , DocumentBuilderFactory . class ) ; makeServiceVisible ( locator , classLoader , DatatypeFactory . class ) ; } return classLoader ; } public ClassLoader createClassLoader ( ClassLoaderSpec spec , List < ? extends ClassLoader > parents ) { if ( spec instanceof MultiParentClassLoader . Spec ) { return new MultiParentClassLoader ( parents ) ; } if ( parents . size ( ) ! = <int> ) { throw new IllegalArgumentException ( <str> ) ; } ClassLoader parent = parents . get ( <int> ) ; if ( spec instanceof MutableURLClassLoader . Spec ) { MutableURLClassLoader . Spec clSpec = ( MutableURLClassLoader . Spec ) spec ; return new MutableURLClassLoader ( parent , clSpec ) ; } if ( spec instanceof CachingClassLoader . Spec ) { return new CachingClassLoader ( parent ) ; } if ( spec instanceof FilteringClassLoader . Spec ) { FilteringClassLoader . Spec clSpec = ( FilteringClassLoader . Spec ) spec ; return new FilteringClassLoader ( parent , clSpec ) ; } throw new IllegalArgumentException ( String . format ( <str> , spec ) ) ; } @Override public FilteringClassLoader createSystemFilteringClassLoader ( ) { return createFilteringClassLoader ( getSystemClassLoader ( ) ) ; } private void makeServiceVisible ( ServiceLocator locator , FilteringClassLoader classLoader , Class < ? > serviceType ) { classLoader . allowClass ( locator . getFactory ( serviceType ) . getImplementationClass ( ) ) ; classLoader . allowResource ( <str> + serviceType . getName ( ) ) ; } private boolean needJaxpImpl ( ) { return ClassLoader . getSystemResource ( <str> ) ! = null ; } private ClassLoader getSystemClassLoader ( ) { return ClassLoader . getSystemClassLoader ( ) ; } } 
