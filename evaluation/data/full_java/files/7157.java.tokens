package org . elasticsearch . search . aggregations . bucket . children ; import org . apache . lucene . search . Query ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . fielddata . plain . ParentChildIndexFieldData ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . internal . ParentFieldMapper ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . support . FieldContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; public class ChildrenParser implements Aggregator . Parser { @Override public String type ( ) { return InternalChildren . TYPE . name ( ) ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { String childType = null ; XContentParser . Token token ; String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { if ( <str> . equals ( currentFieldName ) ) { childType = parser . text ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } if ( childType = = null ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } ValuesSourceConfig < ValuesSource . Bytes . WithOrdinals . ParentChild > config = new ValuesSourceConfig < > ( ValuesSource . Bytes . WithOrdinals . ParentChild . class ) ; DocumentMapper childDocMapper = context . mapperService ( ) . documentMapper ( childType ) ; String parentType = null ; Query parentFilter = null ; Query childFilter = null ; if ( childDocMapper ! = null ) { ParentFieldMapper parentFieldMapper = childDocMapper . parentFieldMapper ( ) ; if ( ! parentFieldMapper . active ( ) ) { throw new SearchParseException ( context , <str> , parser . getTokenLocation ( ) ) ; } parentType = parentFieldMapper . type ( ) ; DocumentMapper parentDocMapper = context . mapperService ( ) . documentMapper ( parentType ) ; if ( parentDocMapper ! = null ) { parentFilter = parentDocMapper . typeFilter ( ) ; childFilter = childDocMapper . typeFilter ( ) ; ParentChildIndexFieldData parentChildIndexFieldData = context . fieldData ( ) . getForField ( parentFieldMapper . fieldType ( ) ) ; config . fieldContext ( new FieldContext ( parentFieldMapper . fieldType ( ) . names ( ) . indexName ( ) , parentChildIndexFieldData , parentFieldMapper . fieldType ( ) ) ) ; } else { config . unmapped ( true ) ; } } else { config . unmapped ( true ) ; } return new ParentToChildrenAggregator . Factory ( aggregationName , config , parentType , parentFilter , childFilter ) ; } } 
