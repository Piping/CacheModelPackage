package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . google . SetMultimapTestSuiteBuilder ; import com . google . common . collect . testing . google . TestStringSetMultimapGenerator ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Collection ; import java . util . Map ; import java . util . Map . Entry ; import java . util . RandomAccess ; import java . util . Set ; import javax . annotation . Nullable ; public class SynchronizedMultimapTest extends TestCase { public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( SynchronizedMultimapTest . class ) ; suite . addTest ( SetMultimapTestSuiteBuilder . using ( new TestStringSetMultimapGenerator ( ) { @Override protected SetMultimap < String , String > create ( Entry < String , String > [ ] entries ) { TestMultimap < String , String > inner = new TestMultimap < String , String > ( ) ; SetMultimap < String , String > outer = Synchronized . setMultimap ( inner , inner . mutex ) ; for ( Entry < String , String > entry : entries ) { outer . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return outer ; } } ) . named ( <str> ) . withFeatures ( MapFeature . GENERAL_PURPOSE , CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . SUPPORTS_ITERATOR_REMOVE , MapFeature . ALLOWS_NULL_KEYS , MapFeature . ALLOWS_NULL_VALUES , MapFeature . ALLOWS_ANY_NULL_QUERIES ) . createTestSuite ( ) ) ; return suite ; } private static final class TestMultimap < K , V > extends ForwardingSetMultimap < K , V > implements Serializable { final SetMultimap < K , V > delegate = HashMultimap . create ( ) ; public final Object mutex = new Integer ( <int> ) ; @Override protected SetMultimap < K , V > delegate ( ) { return delegate ; } @Override public String toString ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . toString ( ) ; } @Override public boolean equals ( @Nullable Object o ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . equals ( o ) ; } @Override public int hashCode ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . hashCode ( ) ; } @Override public int size ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . size ( ) ; } @Override public boolean isEmpty ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . isEmpty ( ) ; } @Override public boolean containsKey ( @Nullable Object key ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . containsKey ( key ) ; } @Override public boolean containsValue ( @Nullable Object value ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . containsValue ( value ) ; } @Override public boolean containsEntry ( @Nullable Object key , @Nullable Object value ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . containsEntry ( key , value ) ; } @Override public Set < V > get ( @Nullable K key ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . get ( key ) ; } @Override public boolean put ( K key , V value ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . put ( key , value ) ; } @Override public boolean putAll ( @Nullable K key , Iterable < ? extends V > values ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . putAll ( key , values ) ; } @Override public boolean putAll ( Multimap < ? extends K , ? extends V > map ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . putAll ( map ) ; } @Override public Set < V > replaceValues ( @Nullable K key , Iterable < ? extends V > values ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . replaceValues ( key , values ) ; } @Override public boolean remove ( @Nullable Object key , @Nullable Object value ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . remove ( key , value ) ; } @Override public Set < V > removeAll ( @Nullable Object key ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . removeAll ( key ) ; } @Override public void clear ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; super . clear ( ) ; } @Override public Set < K > keySet ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . keySet ( ) ; } @Override public Multiset < K > keys ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . keys ( ) ; } @Override public Collection < V > values ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . values ( ) ; } @Override public Set < Map . Entry < K , V > > entries ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . entries ( ) ; } @Override public Map < K , Collection < V > > asMap ( ) { assertTrue ( Thread . holdsLock ( mutex ) ) ; return super . asMap ( ) ; } private static final long serialVersionUID = <int> ; } public void testSynchronizedListMultimap ( ) { ListMultimap < String , Integer > multimap = Multimaps . synchronizedListMultimap ( ArrayListMultimap . < String , Integer > create ( ) ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , - <int> , <int> , <int> , <int> ) ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , <int> , <int> , <int> ) ) ; assertThat ( multimap . removeAll ( <str> ) ) . containsExactly ( <int> , - <int> , <int> , <int> , <int> ) . inOrder ( ) ; assertFalse ( multimap . containsKey ( <str> ) ) ; assertThat ( multimap . replaceValues ( <str> , Arrays . asList ( <int> , <int> ) ) ) . containsExactly ( <int> , <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testSynchronizedSortedSetMultimap ( ) { SortedSetMultimap < String , Integer > multimap = Multimaps . synchronizedSortedSetMultimap ( TreeMultimap . < String , Integer > create ( ) ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , - <int> , <int> , <int> , <int> ) ) ; multimap . putAll ( <str> , Arrays . asList ( <int> , <int> , <int> , <int> ) ) ; assertThat ( multimap . removeAll ( <str> ) ) . containsExactly ( - <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; assertFalse ( multimap . containsKey ( <str> ) ) ; assertThat ( multimap . replaceValues ( <str> , Arrays . asList ( <int> , <int> ) ) ) . containsExactly ( <int> , <int> , <int> ) . inOrder ( ) ; assertThat ( multimap . get ( <str> ) ) . containsExactly ( <int> , <int> ) . inOrder ( ) ; } public void testSynchronizedArrayListMultimapRandomAccess ( ) { ListMultimap < String , Integer > delegate = ArrayListMultimap . create ( ) ; delegate . put ( <str> , <int> ) ; delegate . put ( <str> , <int> ) ; ListMultimap < String , Integer > multimap = Multimaps . synchronizedListMultimap ( delegate ) ; assertTrue ( multimap . get ( <str> ) instanceof RandomAccess ) ; assertTrue ( multimap . get ( <str> ) instanceof RandomAccess ) ; } public void testSynchronizedLinkedListMultimapRandomAccess ( ) { ListMultimap < String , Integer > delegate = LinkedListMultimap . create ( ) ; delegate . put ( <str> , <int> ) ; delegate . put ( <str> , <int> ) ; ListMultimap < String , Integer > multimap = Multimaps . synchronizedListMultimap ( delegate ) ; assertThat ( multimap . get ( <str> ) ) . isNotInstanceOf ( RandomAccess . class ) ; assertThat ( multimap . get ( <str> ) ) . isNotInstanceOf ( RandomAccess . class ) ; } } 
