package com . badlogic . gdx . utils ; import java . util . Arrays ; public class Bits { long [ ] bits = { <int> } ; public Bits ( ) { } public Bits ( int nbits ) { checkCapacity ( nbits > > > <int> ) ; } public boolean get ( int index ) { final int word = index > > > <int> ; if ( word > = bits . length ) return false ; return ( bits [ word ] & ( <int> < < ( index & <hex> ) ) ) ! = <int> L ; } public boolean getAndClear ( int index ) { final int word = index > > > <int> ; if ( word > = bits . length ) return false ; long oldBits = bits [ word ] ; bits [ word ] & = ~ ( <int> < < ( index & <hex> ) ) ; return bits [ word ] ! = oldBits ; } public boolean getAndSet ( int index ) { final int word = index > > > <int> ; checkCapacity ( word ) ; long oldBits = bits [ word ] ; bits [ word ] | = <int> < < ( index & <hex> ) ; return bits [ word ] = = oldBits ; } public void set ( int index ) { final int word = index > > > <int> ; checkCapacity ( word ) ; bits [ word ] | = <int> < < ( index & <hex> ) ; } public void flip ( int index ) { final int word = index > > > <int> ; checkCapacity ( word ) ; bits [ word ] ^ = <int> < < ( index & <hex> ) ; } private void checkCapacity ( int len ) { if ( len > = bits . length ) { long [ ] newBits = new long [ len + <int> ] ; System . arraycopy ( bits , <int> , newBits , <int> , bits . length ) ; bits = newBits ; } } public void clear ( int index ) { final int word = index > > > <int> ; if ( word > = bits . length ) return ; bits [ word ] & = ~ ( <int> < < ( index & <hex> ) ) ; } public void clear ( ) { long [ ] bits = this . bits ; int length = bits . length ; for ( int i = <int> ; i < length ; i + + ) { bits [ i ] = <int> L ; } } public int numBits ( ) { return bits . length < < <int> ; } public int length ( ) { long [ ] bits = this . bits ; for ( int word = bits . length - <int> ; word > = <int> ; - - word ) { long bitsAtWord = bits [ word ] ; if ( bitsAtWord ! = <int> ) { for ( int bit = <int> ; bit > = <int> ; - - bit ) { if ( ( bitsAtWord & ( <int> < < ( bit & <hex> ) ) ) ! = <int> L ) { return ( word < < <int> ) + bit + <int> ; } } } } return <int> ; } public boolean isEmpty ( ) { long [ ] bits = this . bits ; int length = bits . length ; for ( int i = <int> ; i < length ; i + + ) { if ( bits [ i ] ! = <int> L ) { return false ; } } return true ; } public int nextSetBit ( int fromIndex ) { long [ ] bits = this . bits ; int word = fromIndex > > > <int> ; int bitsLength = bits . length ; if ( word > = bitsLength ) return - <int> ; long bitsAtWord = bits [ word ] ; if ( bitsAtWord ! = <int> ) { for ( int i = fromIndex & <hex> ; i < <int> ; i + + ) { if ( ( bitsAtWord & ( <int> < < ( i & <hex> ) ) ) ! = <int> L ) { return ( word < < <int> ) + i ; } } } for ( word + + ; word < bitsLength ; word + + ) { if ( word ! = <int> ) { bitsAtWord = bits [ word ] ; if ( bitsAtWord ! = <int> ) { for ( int i = <int> ; i < <int> ; i + + ) { if ( ( bitsAtWord & ( <int> < < ( i & <hex> ) ) ) ! = <int> L ) { return ( word < < <int> ) + i ; } } } } } return - <int> ; } public int nextClearBit ( int fromIndex ) { long [ ] bits = this . bits ; int word = fromIndex > > > <int> ; int bitsLength = bits . length ; if ( word > = bitsLength ) return bits . length < < <int> ; long bitsAtWord = bits [ word ] ; for ( int i = fromIndex & <hex> ; i < <int> ; i + + ) { if ( ( bitsAtWord & ( <int> < < ( i & <hex> ) ) ) = = <int> L ) { return ( word < < <int> ) + i ; } } for ( word + + ; word < bitsLength ; word + + ) { if ( word = = <int> ) { return word < < <int> ; } bitsAtWord = bits [ word ] ; for ( int i = <int> ; i < <int> ; i + + ) { if ( ( bitsAtWord & ( <int> < < ( i & <hex> ) ) ) = = <int> L ) { return ( word < < <int> ) + i ; } } } return bits . length < < <int> ; } public void and ( Bits other ) { int commonWords = Math . min ( bits . length , other . bits . length ) ; for ( int i = <int> ; commonWords > i ; i + + ) { bits [ i ] & = other . bits [ i ] ; } if ( bits . length > commonWords ) { for ( int i = commonWords , s = bits . length ; s > i ; i + + ) { bits [ i ] = <int> L ; } } } public void andNot ( Bits other ) { for ( int i = <int> , j = bits . length , k = other . bits . length ; i < j & & i < k ; i + + ) { bits [ i ] & = ~ other . bits [ i ] ; } } public void or ( Bits other ) { int commonWords = Math . min ( bits . length , other . bits . length ) ; for ( int i = <int> ; commonWords > i ; i + + ) { bits [ i ] | = other . bits [ i ] ; } if ( commonWords < other . bits . length ) { checkCapacity ( other . bits . length ) ; for ( int i = commonWords , s = other . bits . length ; s > i ; i + + ) { bits [ i ] = other . bits [ i ] ; } } } public void xor ( Bits other ) { int commonWords = Math . min ( bits . length , other . bits . length ) ; for ( int i = <int> ; commonWords > i ; i + + ) { bits [ i ] ^ = other . bits [ i ] ; } if ( commonWords < other . bits . length ) { checkCapacity ( other . bits . length ) ; for ( int i = commonWords , s = other . bits . length ; s > i ; i + + ) { bits [ i ] = other . bits [ i ] ; } } } public boolean intersects ( Bits other ) { long [ ] bits = this . bits ; long [ ] otherBits = other . bits ; for ( int i = Math . min ( bits . length , otherBits . length ) - <int> ; i > = <int> ; i - - ) { if ( ( bits [ i ] & otherBits [ i ] ) ! = <int> ) { return true ; } } return false ; } public boolean containsAll ( Bits other ) { long [ ] bits = this . bits ; long [ ] otherBits = other . bits ; int otherBitsLength = otherBits . length ; int bitsLength = bits . length ; for ( int i = bitsLength ; i < otherBitsLength ; i + + ) { if ( otherBits [ i ] ! = <int> ) { return false ; } } for ( int i = Math . min ( bitsLength , otherBitsLength ) - <int> ; i > = <int> ; i - - ) { if ( ( bits [ i ] & otherBits [ i ] ) ! = otherBits [ i ] ) { return false ; } } return true ; } @Override public int hashCode ( ) { final int word = length ( ) > > > <int> ; int hash = <int> ; for ( int i = <int> ; word > = i ; i + + ) { hash = <int> * hash + ( int ) ( bits [ i ] ^ ( bits [ i ] > > > <int> ) ) ; } return hash ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null ) return false ; if ( getClass ( ) ! = obj . getClass ( ) ) return false ; Bits other = ( Bits ) obj ; long [ ] otherBits = other . bits ; int commonWords = Math . min ( bits . length , otherBits . length ) ; for ( int i = <int> ; commonWords > i ; i + + ) { if ( bits [ i ] ! = otherBits [ i ] ) return false ; } if ( bits . length = = otherBits . length ) return true ; return length ( ) = = other . length ( ) ; } } 
