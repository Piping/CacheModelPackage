package org . elasticsearch . action . termvectors ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . * ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . Iterators ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . * ; public class MultiTermVectorsRequest extends ActionRequest < MultiTermVectorsRequest > implements Iterable < TermVectorsRequest > , CompositeIndicesRequest , RealtimeRequest { String preference ; List < TermVectorsRequest > requests = new ArrayList < > ( ) ; final Set < String > ids = new HashSet < > ( ) ; public MultiTermVectorsRequest add ( TermVectorsRequest termVectorsRequest ) { requests . add ( termVectorsRequest ) ; return this ; } public MultiTermVectorsRequest add ( String index , @Nullable String type , String id ) { requests . add ( new TermVectorsRequest ( index , type , id ) ) ; return this ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( requests . isEmpty ( ) ) { validationException = ValidateActions . addValidationError ( <str> , validationException ) ; } else { for ( int i = <int> ; i < requests . size ( ) ; i + + ) { TermVectorsRequest termVectorsRequest = requests . get ( i ) ; ActionRequestValidationException validationExceptionForDoc = termVectorsRequest . validate ( ) ; if ( validationExceptionForDoc ! = null ) { validationException = ValidateActions . addValidationError ( <str> + i , validationExceptionForDoc ) ; } } } return validationException ; } @Override public List < ? extends IndicesRequest > subRequests ( ) { return requests ; } @Override public Iterator < TermVectorsRequest > iterator ( ) { return Collections . unmodifiableCollection ( requests ) . iterator ( ) ; } public boolean isEmpty ( ) { return requests . isEmpty ( ) & & ids . isEmpty ( ) ; } public List < TermVectorsRequest > getRequests ( ) { return requests ; } public void add ( TermVectorsRequest template , BytesReference data ) throws Exception { XContentParser . Token token ; String currentFieldName = null ; if ( data . length ( ) > <int> ) { try ( XContentParser parser = XContentFactory . xContent ( data ) . createParser ( data ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( <str> . equals ( currentFieldName ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token ! = XContentParser . Token . START_OBJECT ) { throw new IllegalArgumentException ( <str> ) ; } TermVectorsRequest termVectorsRequest = new TermVectorsRequest ( template ) ; TermVectorsRequest . parseRequest ( termVectorsRequest , parser ) ; add ( termVectorsRequest ) ; } } else if ( <str> . equals ( currentFieldName ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( ! token . isValue ( ) ) { throw new IllegalArgumentException ( <str> ) ; } ids . add ( parser . text ( ) ) ; } } else { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } } else if ( token = = XContentParser . Token . START_OBJECT & & currentFieldName ! = null ) { if ( <str> . equals ( currentFieldName ) ) { TermVectorsRequest . parseRequest ( template , parser ) ; } else { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } } else if ( currentFieldName ! = null ) { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } } } } for ( String id : ids ) { TermVectorsRequest curRequest = new TermVectorsRequest ( template ) ; curRequest . id ( id ) ; requests . add ( curRequest ) ; } } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; preference = in . readOptionalString ( ) ; int size = in . readVInt ( ) ; requests = new ArrayList < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { requests . add ( TermVectorsRequest . readTermVectorsRequest ( in ) ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeOptionalString ( preference ) ; out . writeVInt ( requests . size ( ) ) ; for ( TermVectorsRequest termVectorsRequest : requests ) { termVectorsRequest . writeTo ( out ) ; } } public void ids ( String [ ] ids ) { for ( String id : ids ) { this . ids . add ( id . replaceAll ( <str> , <str> ) ) ; } } public int size ( ) { return requests . size ( ) ; } @Override public MultiTermVectorsRequest realtime ( Boolean realtime ) { for ( TermVectorsRequest request : requests ) { request . realtime ( realtime ) ; } return this ; } } 
