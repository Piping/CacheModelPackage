package io . netty . handler . codec . http2 . hpack ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; final class HuffmanDecoder { private static final IOException EOS_DECODED = new IOException ( <str> ) ; private static final IOException INVALID_PADDING = new IOException ( <str> ) ; private final Node root ; HuffmanDecoder ( int [ ] codes , byte [ ] lengths ) { if ( codes . length ! = <int> | | codes . length ! = lengths . length ) { throw new IllegalArgumentException ( <str> ) ; } root = buildTree ( codes , lengths ) ; } public byte [ ] decode ( byte [ ] buf ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; Node node = root ; int current = <int> ; int bits = <int> ; for ( int i = <int> ; i < buf . length ; i + + ) { int b = buf [ i ] & <hex> ; current = ( current < < <int> ) | b ; bits + = <int> ; while ( bits > = <int> ) { int c = ( current > > > ( bits - <int> ) ) & <hex> ; node = node . children [ c ] ; bits - = node . bits ; if ( node . isTerminal ( ) ) { if ( node . symbol = = HpackUtil . HUFFMAN_EOS ) { throw EOS_DECODED ; } baos . write ( node . symbol ) ; node = root ; } } } while ( bits > <int> ) { int c = ( current < < ( <int> - bits ) ) & <hex> ; node = node . children [ c ] ; if ( node . isTerminal ( ) & & node . bits < = bits ) { bits - = node . bits ; baos . write ( node . symbol ) ; node = root ; } else { break ; } } int mask = ( <int> < < bits ) - <int> ; if ( ( current & mask ) ! = mask ) { throw INVALID_PADDING ; } return baos . toByteArray ( ) ; } private static final class Node { private final int symbol ; private final int bits ; private final Node [ ] children ; private Node ( ) { symbol = <int> ; bits = <int> ; children = new Node [ <int> ] ; } private Node ( int symbol , int bits ) { assert bits > <int> & & bits < = <int> ; this . symbol = symbol ; this . bits = bits ; children = null ; } private boolean isTerminal ( ) { return children = = null ; } } private static Node buildTree ( int [ ] codes , byte [ ] lengths ) { Node root = new Node ( ) ; for ( int i = <int> ; i < codes . length ; i + + ) { insert ( root , i , codes [ i ] , lengths [ i ] ) ; } return root ; } private static void insert ( Node root , int symbol , int code , byte length ) { Node current = root ; while ( length > <int> ) { if ( current . isTerminal ( ) ) { throw new IllegalStateException ( <str> ) ; } length - = <int> ; int i = ( code > > > length ) & <hex> ; if ( current . children [ i ] = = null ) { current . children [ i ] = new Node ( ) ; } current = current . children [ i ] ; } Node terminal = new Node ( symbol , length ) ; int shift = <int> - length ; int start = ( code < < shift ) & <hex> ; int end = <int> < < shift ; for ( int i = start ; i < start + end ; i + + ) { current . children [ i ] = terminal ; } } } 
