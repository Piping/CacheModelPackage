package com . badlogic . gdx . math ; import com . badlogic . gdx . utils . FloatArray ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . ShortArray ; public class EarClippingTriangulator { static private final int CONCAVE = - <int> ; static private final int TANGENTIAL = <int> ; static private final int CONVEX = <int> ; private final ShortArray indicesArray = new ShortArray ( ) ; private short [ ] indices ; private float [ ] vertices ; private int vertexCount ; private final IntArray vertexTypes = new IntArray ( ) ; private final ShortArray triangles = new ShortArray ( ) ; public ShortArray computeTriangles ( FloatArray vertices ) { return computeTriangles ( vertices . items , <int> , vertices . size ) ; } public ShortArray computeTriangles ( float [ ] vertices ) { return computeTriangles ( vertices , <int> , vertices . length ) ; } public ShortArray computeTriangles ( float [ ] vertices , int offset , int count ) { this . vertices = vertices ; int vertexCount = this . vertexCount = count / <int> ; int vertexOffset = offset / <int> ; ShortArray indicesArray = this . indicesArray ; indicesArray . clear ( ) ; indicesArray . ensureCapacity ( vertexCount ) ; indicesArray . size = vertexCount ; short [ ] indices = this . indices = indicesArray . items ; if ( areVerticesClockwise ( vertices , offset , count ) ) { for ( short i = <int> ; i < vertexCount ; i + + ) indices [ i ] = ( short ) ( vertexOffset + i ) ; } else { for ( int i = <int> , n = vertexCount - <int> ; i < vertexCount ; i + + ) indices [ i ] = ( short ) ( vertexOffset + n - i ) ; } IntArray vertexTypes = this . vertexTypes ; vertexTypes . clear ( ) ; vertexTypes . ensureCapacity ( vertexCount ) ; for ( int i = <int> , n = vertexCount ; i < n ; + + i ) vertexTypes . add ( classifyVertex ( i ) ) ; ShortArray triangles = this . triangles ; triangles . clear ( ) ; triangles . ensureCapacity ( Math . max ( <int> , vertexCount - <int> ) * <int> ) ; triangulate ( ) ; return triangles ; } private void triangulate ( ) { int [ ] vertexTypes = this . vertexTypes . items ; while ( vertexCount > <int> ) { int earTipIndex = findEarTip ( ) ; cutEarTip ( earTipIndex ) ; int previousIndex = previousIndex ( earTipIndex ) ; int nextIndex = earTipIndex = = vertexCount ? <int> : earTipIndex ; vertexTypes [ previousIndex ] = classifyVertex ( previousIndex ) ; vertexTypes [ nextIndex ] = classifyVertex ( nextIndex ) ; } if ( vertexCount = = <int> ) { ShortArray triangles = this . triangles ; short [ ] indices = this . indices ; triangles . add ( indices [ <int> ] ) ; triangles . add ( indices [ <int> ] ) ; triangles . add ( indices [ <int> ] ) ; } } private int classifyVertex ( int index ) { short [ ] indices = this . indices ; int previous = indices [ previousIndex ( index ) ] * <int> ; int current = indices [ index ] * <int> ; int next = indices [ nextIndex ( index ) ] * <int> ; float [ ] vertices = this . vertices ; return computeSpannedAreaSign ( vertices [ previous ] , vertices [ previous + <int> ] , vertices [ current ] , vertices [ current + <int> ] , vertices [ next ] , vertices [ next + <int> ] ) ; } private int findEarTip ( ) { int vertexCount = this . vertexCount ; for ( int i = <int> ; i < vertexCount ; i + + ) if ( isEarTip ( i ) ) return i ; int [ ] vertexTypes = this . vertexTypes . items ; for ( int i = <int> ; i < vertexCount ; i + + ) if ( vertexTypes [ i ] ! = CONCAVE ) return i ; return <int> ; } private boolean isEarTip ( int earTipIndex ) { int [ ] vertexTypes = this . vertexTypes . items ; if ( vertexTypes [ earTipIndex ] = = CONCAVE ) return false ; int previousIndex = previousIndex ( earTipIndex ) ; int nextIndex = nextIndex ( earTipIndex ) ; short [ ] indices = this . indices ; int p1 = indices [ previousIndex ] * <int> ; int p2 = indices [ earTipIndex ] * <int> ; int p3 = indices [ nextIndex ] * <int> ; float [ ] vertices = this . vertices ; float p1x = vertices [ p1 ] , p1y = vertices [ p1 + <int> ] ; float p2x = vertices [ p2 ] , p2y = vertices [ p2 + <int> ] ; float p3x = vertices [ p3 ] , p3y = vertices [ p3 + <int> ] ; for ( int i = nextIndex ( nextIndex ) ; i ! = previousIndex ; i = nextIndex ( i ) ) { if ( vertexTypes [ i ] ! = CONVEX ) { int v = indices [ i ] * <int> ; float vx = vertices [ v ] ; float vy = vertices [ v + <int> ] ; if ( computeSpannedAreaSign ( p3x , p3y , p1x , p1y , vx , vy ) > = <int> ) { if ( computeSpannedAreaSign ( p1x , p1y , p2x , p2y , vx , vy ) > = <int> ) { if ( computeSpannedAreaSign ( p2x , p2y , p3x , p3y , vx , vy ) > = <int> ) return false ; } } } } return true ; } private void cutEarTip ( int earTipIndex ) { short [ ] indices = this . indices ; ShortArray triangles = this . triangles ; triangles . add ( indices [ previousIndex ( earTipIndex ) ] ) ; triangles . add ( indices [ earTipIndex ] ) ; triangles . add ( indices [ nextIndex ( earTipIndex ) ] ) ; indicesArray . removeIndex ( earTipIndex ) ; vertexTypes . removeIndex ( earTipIndex ) ; vertexCount - - ; } private int previousIndex ( int index ) { return ( index = = <int> ? vertexCount : index ) - <int> ; } private int nextIndex ( int index ) { return ( index + <int> ) % vertexCount ; } static private boolean areVerticesClockwise ( float [ ] vertices , int offset , int count ) { if ( count < = <int> ) return false ; float area = <int> , p1x , p1y , p2x , p2y ; for ( int i = offset , n = offset + count - <int> ; i < n ; i + = <int> ) { p1x = vertices [ i ] ; p1y = vertices [ i + <int> ] ; p2x = vertices [ i + <int> ] ; p2y = vertices [ i + <int> ] ; area + = p1x * p2y - p2x * p1y ; } p1x = vertices [ offset + count - <int> ] ; p1y = vertices [ offset + count - <int> ] ; p2x = vertices [ offset ] ; p2y = vertices [ offset + <int> ] ; return area + p1x * p2y - p2x * p1y < <int> ; } static private int computeSpannedAreaSign ( float p1x , float p1y , float p2x , float p2y , float p3x , float p3y ) { float area = p1x * ( p3y - p2y ) ; area + = p2x * ( p1y - p3y ) ; area + = p3x * ( p2y - p1y ) ; return ( int ) Math . signum ( area ) ; } } 
