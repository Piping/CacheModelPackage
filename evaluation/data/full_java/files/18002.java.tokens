package com . badlogic . gdx . graphics . g3d . decals ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . NumberUtils ; public class Decal { private static final int VERTEX_SIZE = <int> + <int> + <int> ; public static final int SIZE = <int> * VERTEX_SIZE ; private static Vector3 tmp = new Vector3 ( ) ; private static Vector3 tmp2 = new Vector3 ( ) ; public int value ; protected float [ ] vertices = new float [ SIZE ] ; protected Vector3 position = new Vector3 ( ) ; protected Quaternion rotation = new Quaternion ( ) ; protected Vector2 scale = new Vector2 ( <int> , <int> ) ; protected Color color = new Color ( ) ; public Vector2 transformationOffset = null ; protected Vector2 dimensions = new Vector2 ( ) ; protected DecalMaterial material ; protected boolean updated = false ; public Decal ( ) { this . material = new DecalMaterial ( ) ; } public Decal ( DecalMaterial material ) { this . material = material ; } public void setColor ( float r , float g , float b , float a ) { color . set ( r , g , b , a ) ; int intBits = ( ( int ) ( <int> * a ) < < <int> ) | ( ( int ) ( <int> * b ) < < <int> ) | ( ( int ) ( <int> * g ) < < <int> ) | ( ( int ) ( <int> * r ) ) ; float color = NumberUtils . intToFloatColor ( intBits ) ; vertices [ C1 ] = color ; vertices [ C2 ] = color ; vertices [ C3 ] = color ; vertices [ C4 ] = color ; } public void setColor ( Color tint ) { color . set ( tint ) ; float color = tint . toFloatBits ( ) ; vertices [ C1 ] = color ; vertices [ C2 ] = color ; vertices [ C3 ] = color ; vertices [ C4 ] = color ; } public void setColor ( float color ) { this . color . set ( NumberUtils . floatToIntColor ( color ) ) ; vertices [ C1 ] = color ; vertices [ C2 ] = color ; vertices [ C3 ] = color ; vertices [ C4 ] = color ; } public void setRotationX ( float angle ) { rotation . set ( Vector3 . X , angle ) ; updated = false ; } public void setRotationY ( float angle ) { rotation . set ( Vector3 . Y , angle ) ; updated = false ; } public void setRotationZ ( float angle ) { rotation . set ( Vector3 . Z , angle ) ; updated = false ; } public void rotateX ( float angle ) { rotator . set ( Vector3 . X , angle ) ; rotation . mul ( rotator ) ; updated = false ; } public void rotateY ( float angle ) { rotator . set ( Vector3 . Y , angle ) ; rotation . mul ( rotator ) ; updated = false ; } public void rotateZ ( float angle ) { rotator . set ( Vector3 . Z , angle ) ; rotation . mul ( rotator ) ; updated = false ; } public void setRotation ( float yaw , float pitch , float roll ) { rotation . setEulerAngles ( yaw , pitch , roll ) ; updated = false ; } public void setRotation ( Vector3 dir , Vector3 up ) { tmp . set ( up ) . crs ( dir ) . nor ( ) ; tmp2 . set ( dir ) . crs ( tmp ) . nor ( ) ; rotation . setFromAxes ( tmp . x , tmp2 . x , dir . x , tmp . y , tmp2 . y , dir . y , tmp . z , tmp2 . z , dir . z ) ; updated = false ; } public void setRotation ( Quaternion q ) { rotation . set ( q ) ; updated = false ; } public Quaternion getRotation ( ) { return rotation ; } public void translateX ( float units ) { this . position . x + = units ; updated = false ; } public void setX ( float x ) { this . position . x = x ; updated = false ; } public float getX ( ) { return this . position . x ; } public void translateY ( float units ) { this . position . y + = units ; updated = false ; } public void setY ( float y ) { this . position . y = y ; updated = false ; } public float getY ( ) { return this . position . y ; } public void translateZ ( float units ) { this . position . z + = units ; updated = false ; } public void setZ ( float z ) { this . position . z = z ; updated = false ; } public float getZ ( ) { return this . position . z ; } public void translate ( float x , float y , float z ) { this . position . add ( x , y , z ) ; updated = false ; } public void translate ( Vector3 trans ) { this . position . add ( trans ) ; updated = false ; } public void setPosition ( float x , float y , float z ) { this . position . set ( x , y , z ) ; updated = false ; } public void setPosition ( Vector3 pos ) { this . position . set ( pos ) ; updated = false ; } public Color getColor ( ) { return color ; } public Vector3 getPosition ( ) { return position ; } public void setScaleX ( float scale ) { this . scale . x = scale ; updated = false ; } public float getScaleX ( ) { return this . scale . x ; } public void setScaleY ( float scale ) { this . scale . y = scale ; updated = false ; } public float getScaleY ( ) { return this . scale . y ; } public void setScale ( float scaleX , float scaleY ) { this . scale . set ( scaleX , scaleY ) ; updated = false ; } public void setScale ( float scale ) { this . scale . set ( scale , scale ) ; updated = false ; } public void setWidth ( float width ) { this . dimensions . x = width ; updated = false ; } public float getWidth ( ) { return this . dimensions . x ; } public void setHeight ( float height ) { this . dimensions . y = height ; updated = false ; } public float getHeight ( ) { return dimensions . y ; } public void setDimensions ( float width , float height ) { dimensions . set ( width , height ) ; updated = false ; } public float [ ] getVertices ( ) { return vertices ; } protected void update ( ) { if ( ! updated ) { resetVertices ( ) ; transformVertices ( ) ; } } protected void transformVertices ( ) { float x , y , z , w ; float tx , ty ; if ( transformationOffset ! = null ) { tx = - transformationOffset . x ; ty = - transformationOffset . y ; } else { tx = ty = <int> ; } x = ( vertices [ X1 ] + tx ) * scale . x ; y = ( vertices [ Y1 ] + ty ) * scale . y ; z = vertices [ Z1 ] ; vertices [ X1 ] = rotation . w * x + rotation . y * z - rotation . z * y ; vertices [ Y1 ] = rotation . w * y + rotation . z * x - rotation . x * z ; vertices [ Z1 ] = rotation . w * z + rotation . x * y - rotation . y * x ; w = - rotation . x * x - rotation . y * y - rotation . z * z ; rotation . conjugate ( ) ; x = vertices [ X1 ] ; y = vertices [ Y1 ] ; z = vertices [ Z1 ] ; vertices [ X1 ] = w * rotation . x + x * rotation . w + y * rotation . z - z * rotation . y ; vertices [ Y1 ] = w * rotation . y + y * rotation . w + z * rotation . x - x * rotation . z ; vertices [ Z1 ] = w * rotation . z + z * rotation . w + x * rotation . y - y * rotation . x ; rotation . conjugate ( ) ; vertices [ X1 ] + = position . x - tx ; vertices [ Y1 ] + = position . y - ty ; vertices [ Z1 ] + = position . z ; x = ( vertices [ X2 ] + tx ) * scale . x ; y = ( vertices [ Y2 ] + ty ) * scale . y ; z = vertices [ Z2 ] ; vertices [ X2 ] = rotation . w * x + rotation . y * z - rotation . z * y ; vertices [ Y2 ] = rotation . w * y + rotation . z * x - rotation . x * z ; vertices [ Z2 ] = rotation . w * z + rotation . x * y - rotation . y * x ; w = - rotation . x * x - rotation . y * y - rotation . z * z ; rotation . conjugate ( ) ; x = vertices [ X2 ] ; y = vertices [ Y2 ] ; z = vertices [ Z2 ] ; vertices [ X2 ] = w * rotation . x + x * rotation . w + y * rotation . z - z * rotation . y ; vertices [ Y2 ] = w * rotation . y + y * rotation . w + z * rotation . x - x * rotation . z ; vertices [ Z2 ] = w * rotation . z + z * rotation . w + x * rotation . y - y * rotation . x ; rotation . conjugate ( ) ; vertices [ X2 ] + = position . x - tx ; vertices [ Y2 ] + = position . y - ty ; vertices [ Z2 ] + = position . z ; x = ( vertices [ X3 ] + tx ) * scale . x ; y = ( vertices [ Y3 ] + ty ) * scale . y ; z = vertices [ Z3 ] ; vertices [ X3 ] = rotation . w * x + rotation . y * z - rotation . z * y ; vertices [ Y3 ] = rotation . w * y + rotation . z * x - rotation . x * z ; vertices [ Z3 ] = rotation . w * z + rotation . x * y - rotation . y * x ; w = - rotation . x * x - rotation . y * y - rotation . z * z ; rotation . conjugate ( ) ; x = vertices [ X3 ] ; y = vertices [ Y3 ] ; z = vertices [ Z3 ] ; vertices [ X3 ] = w * rotation . x + x * rotation . w + y * rotation . z - z * rotation . y ; vertices [ Y3 ] = w * rotation . y + y * rotation . w + z * rotation . x - x * rotation . z ; vertices [ Z3 ] = w * rotation . z + z * rotation . w + x * rotation . y - y * rotation . x ; rotation . conjugate ( ) ; vertices [ X3 ] + = position . x - tx ; vertices [ Y3 ] + = position . y - ty ; vertices [ Z3 ] + = position . z ; x = ( vertices [ X4 ] + tx ) * scale . x ; y = ( vertices [ Y4 ] + ty ) * scale . y ; z = vertices [ Z4 ] ; vertices [ X4 ] = rotation . w * x + rotation . y * z - rotation . z * y ; vertices [ Y4 ] = rotation . w * y + rotation . z * x - rotation . x * z ; vertices [ Z4 ] = rotation . w * z + rotation . x * y - rotation . y * x ; w = - rotation . x * x - rotation . y * y - rotation . z * z ; rotation . conjugate ( ) ; x = vertices [ X4 ] ; y = vertices [ Y4 ] ; z = vertices [ Z4 ] ; vertices [ X4 ] = w * rotation . x + x * rotation . w + y * rotation . z - z * rotation . y ; vertices [ Y4 ] = w * rotation . y + y * rotation . w + z * rotation . x - x * rotation . z ; vertices [ Z4 ] = w * rotation . z + z * rotation . w + x * rotation . y - y * rotation . x ; rotation . conjugate ( ) ; vertices [ X4 ] + = position . x - tx ; vertices [ Y4 ] + = position . y - ty ; vertices [ Z4 ] + = position . z ; updated = true ; } protected void resetVertices ( ) { float left = - dimensions . x / <float> ; float right = left + dimensions . x ; float top = dimensions . y / <float> ; float bottom = top - dimensions . y ; vertices [ X1 ] = left ; vertices [ Y1 ] = top ; vertices [ Z1 ] = <int> ; vertices [ X2 ] = right ; vertices [ Y2 ] = top ; vertices [ Z2 ] = <int> ; vertices [ X3 ] = left ; vertices [ Y3 ] = bottom ; vertices [ Z3 ] = <int> ; vertices [ X4 ] = right ; vertices [ Y4 ] = bottom ; vertices [ Z4 ] = <int> ; updated = false ; } protected void updateUVs ( ) { TextureRegion tr = material . textureRegion ; vertices [ U1 ] = tr . getU ( ) ; vertices [ V1 ] = tr . getV ( ) ; vertices [ U2 ] = tr . getU2 ( ) ; vertices [ V2 ] = tr . getV ( ) ; vertices [ U3 ] = tr . getU ( ) ; vertices [ V3 ] = tr . getV2 ( ) ; vertices [ U4 ] = tr . getU2 ( ) ; vertices [ V4 ] = tr . getV2 ( ) ; } public void setTextureRegion ( TextureRegion textureRegion ) { this . material . textureRegion = textureRegion ; updateUVs ( ) ; } public TextureRegion getTextureRegion ( ) { return this . material . textureRegion ; } public void setBlending ( int srcBlendFactor , int dstBlendFactor ) { material . srcBlendFactor = srcBlendFactor ; material . dstBlendFactor = dstBlendFactor ; } public DecalMaterial getMaterial ( ) { return material ; } public void setMaterial ( DecalMaterial material ) { this . material = material ; } final static Vector3 dir = new Vector3 ( ) ; public void lookAt ( Vector3 position , Vector3 up ) { dir . set ( position ) . sub ( this . position ) . nor ( ) ; setRotation ( dir , up ) ; } public static final int X1 = <int> ; public static final int Y1 = <int> ; public static final int Z1 = <int> ; public static final int C1 = <int> ; public static final int U1 = <int> ; public static final int V1 = <int> ; public static final int X2 = <int> ; public static final int Y2 = <int> ; public static final int Z2 = <int> ; public static final int C2 = <int> ; public static final int U2 = <int> ; public static final int V2 = <int> ; public static final int X3 = <int> ; public static final int Y3 = <int> ; public static final int Z3 = <int> ; public static final int C3 = <int> ; public static final int U3 = <int> ; public static final int V3 = <int> ; public static final int X4 = <int> ; public static final int Y4 = <int> ; public static final int Z4 = <int> ; public static final int C4 = <int> ; public static final int U4 = <int> ; public static final int V4 = <int> ; protected static Quaternion rotator = new Quaternion ( <int> , <int> , <int> , <int> ) ; public static Decal newDecal ( TextureRegion textureRegion ) { return newDecal ( textureRegion . getRegionWidth ( ) , textureRegion . getRegionHeight ( ) , textureRegion , DecalMaterial . NO_BLEND , DecalMaterial . NO_BLEND ) ; } public static Decal newDecal ( TextureRegion textureRegion , boolean hasTransparency ) { return newDecal ( textureRegion . getRegionWidth ( ) , textureRegion . getRegionHeight ( ) , textureRegion , hasTransparency ? GL20 . GL_SRC_ALPHA : DecalMaterial . NO_BLEND , hasTransparency ? GL20 . GL_ONE_MINUS_SRC_ALPHA : DecalMaterial . NO_BLEND ) ; } public static Decal newDecal ( float width , float height , TextureRegion textureRegion ) { return newDecal ( width , height , textureRegion , DecalMaterial . NO_BLEND , DecalMaterial . NO_BLEND ) ; } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , boolean hasTransparency ) { return newDecal ( width , height , textureRegion , hasTransparency ? GL20 . GL_SRC_ALPHA : DecalMaterial . NO_BLEND , hasTransparency ? GL20 . GL_ONE_MINUS_SRC_ALPHA : DecalMaterial . NO_BLEND ) ; } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , int srcBlendFactor , int dstBlendFactor ) { Decal decal = new Decal ( ) ; decal . setTextureRegion ( textureRegion ) ; decal . setBlending ( srcBlendFactor , dstBlendFactor ) ; decal . dimensions . x = width ; decal . dimensions . y = height ; decal . setColor ( <int> , <int> , <int> , <int> ) ; return decal ; } public static Decal newDecal ( float width , float height , TextureRegion textureRegion , int srcBlendFactor , int dstBlendFactor , DecalMaterial material ) { Decal decal = new Decal ( material ) ; decal . setTextureRegion ( textureRegion ) ; decal . setBlending ( srcBlendFactor , dstBlendFactor ) ; decal . dimensions . x = width ; decal . dimensions . y = height ; decal . setColor ( <int> , <int> , <int> , <int> ) ; return decal ; } } 
