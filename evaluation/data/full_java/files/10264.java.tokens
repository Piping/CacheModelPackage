package com . google . common . base ; import static com . google . common . truth . Truth . assertThat ; import static java . lang . Character . MAX_CODE_POINT ; import static java . lang . Character . MAX_HIGH_SURROGATE ; import static java . lang . Character . MAX_LOW_SURROGATE ; import static java . lang . Character . MIN_HIGH_SURROGATE ; import static java . lang . Character . MIN_LOW_SURROGATE ; import static java . lang . Character . MIN_SUPPLEMENTARY_CODE_POINT ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . ImmutableList ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Random ; @GwtCompatible ( emulated = true ) public class Utf8Test extends TestCase { private static final ImmutableList < String > ILL_FORMED_STRINGS ; static { ImmutableList . Builder < String > builder = ImmutableList . builder ( ) ; char [ ] surrogates = { MAX_LOW_SURROGATE , MAX_HIGH_SURROGATE , MIN_LOW_SURROGATE , MIN_HIGH_SURROGATE , } ; for ( char surrogate : surrogates ) { builder . add ( newString ( surrogate ) ) ; builder . add ( newString ( surrogate , <str> ) ) ; builder . add ( newString ( <str> , surrogate ) ) ; builder . add ( newString ( surrogate , surrogate ) ) ; } builder . add ( newString ( MIN_LOW_SURROGATE , MAX_HIGH_SURROGATE ) ) ; ILL_FORMED_STRINGS = builder . build ( ) ; } public void testEncodedLength_validStrings ( ) { assertEquals ( <int> , Utf8 . encodedLength ( <str> ) ) ; assertEquals ( <int> , Utf8 . encodedLength ( <str> ) ) ; assertEquals ( <int> , Utf8 . encodedLength ( <str> ) ) ; assertEquals ( <int> , Utf8 . encodedLength ( <str> + <str> + <str> + <str> + <str> + <str> ) ) ; assertEquals ( <int> , Utf8 . encodedLength ( newString ( MIN_HIGH_SURROGATE , MIN_LOW_SURROGATE ) ) ) ; } public void testEncodedLength_validStrings2 ( ) { HashMap < Integer , Integer > utf8Lengths = new HashMap < Integer , Integer > ( ) ; utf8Lengths . put ( <hex> , <int> ) ; utf8Lengths . put ( <hex> , <int> ) ; utf8Lengths . put ( <hex> , <int> ) ; utf8Lengths . put ( <hex> , <int> ) ; utf8Lengths . put ( <hex> , <int> ) ; utf8Lengths . put ( MIN_SUPPLEMENTARY_CODE_POINT - <int> , <int> ) ; utf8Lengths . put ( MIN_SUPPLEMENTARY_CODE_POINT , <int> ) ; utf8Lengths . put ( MAX_CODE_POINT , <int> ) ; Integer [ ] codePoints = utf8Lengths . keySet ( ) . toArray ( new Integer [ ] { } ) ; StringBuilder sb = new StringBuilder ( ) ; Random rnd = new Random ( ) ; for ( int trial = <int> ; trial < <int> ; trial + + ) { sb . setLength ( <int> ) ; int utf8Length = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { Integer randomCodePoint = codePoints [ rnd . nextInt ( codePoints . length ) ] ; sb . appendCodePoint ( randomCodePoint ) ; utf8Length + = utf8Lengths . get ( randomCodePoint ) ; if ( utf8Length ! = Utf8 . encodedLength ( sb ) ) { StringBuilder repro = new StringBuilder ( ) ; for ( int j = <int> ; j < sb . length ( ) ; j + + ) { repro . append ( <str> + ( int ) sb . charAt ( j ) ) ; } assertEquals ( repro . toString ( ) , utf8Length , Utf8 . encodedLength ( sb ) ) ; } } } } public void testEncodedLength_invalidStrings ( ) { testEncodedLengthFails ( newString ( MIN_HIGH_SURROGATE ) , <int> ) ; testEncodedLengthFails ( <str> + newString ( MIN_HIGH_SURROGATE ) , <int> ) ; testEncodedLengthFails ( newString ( MIN_LOW_SURROGATE ) , <int> ) ; testEncodedLengthFails ( <str> + newString ( MIN_LOW_SURROGATE ) , <int> ) ; testEncodedLengthFails ( newString ( MIN_HIGH_SURROGATE , MIN_HIGH_SURROGATE ) , <int> ) ; } @SuppressWarnings ( <str> ) private static void testEncodedLengthFails ( String invalidString , int invalidCodePointIndex ) { try { Utf8 . encodedLength ( invalidString ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertThat ( expected ) . hasMessage ( <str> + invalidCodePointIndex ) ; } } private static final long ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS = <hex> - <hex> + <int> ; private static final long EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT = ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS ; private static final long TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS = <hex> - <hex> + <int> ; private static final long EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT = ( long ) Math . pow ( EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT , <int> ) + TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS ; private static final long THREE_BYTE_SURROGATES = <int> * <int> ; private static final long THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS = <hex> - <hex> + <int> - THREE_BYTE_SURROGATES ; private static final long EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT = ( long ) Math . pow ( EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT , <int> ) + <int> * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS + THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS ; private static final long FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS = <hex> - <hex> + <int> ; private static final long EXPECTED_FOUR_BYTE_ROUNDTRIPPABLE_COUNT = ( long ) Math . pow ( EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT , <int> ) + <int> * THREE_BYTE_ROUNDTRIPPABLE_CHARACTERS * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS + TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS + <int> * TWO_BYTE_ROUNDTRIPPABLE_CHARACTERS * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS * ONE_BYTE_ROUNDTRIPPABLE_CHARACTERS + FOUR_BYTE_ROUNDTRIPPABLE_CHARACTERS ; @GwtIncompatible ( <str> ) public void testIsWellFormed_1Byte ( ) { testBytes ( <int> , EXPECTED_ONE_BYTE_ROUNDTRIPPABLE_COUNT ) ; } @GwtIncompatible ( <str> ) public void testIsWellFormed_2Bytes ( ) { testBytes ( <int> , EXPECTED_TWO_BYTE_ROUNDTRIPPABLE_COUNT ) ; } @GwtIncompatible ( <str> ) public void testIsWellFormed_3Bytes ( ) { testBytes ( <int> , EXPECTED_THREE_BYTE_ROUNDTRIPPABLE_COUNT ) ; } public void testIsWellFormed_4BytesSamples ( ) { assertWellFormed ( <hex> , <hex> , <hex> , <hex> ) ; assertNotWellFormed ( <hex> , <hex> , <hex> , <hex> ) ; assertNotWellFormed ( <hex> , <hex> , <hex> , <hex> ) ; assertNotWellFormed ( <hex> , <hex> , <hex> , <hex> ) ; assertNotWellFormed ( <hex> , <hex> , <hex> , <hex> ) ; } public void testSomeSequences ( ) { assertWellFormed ( ) ; assertWellFormed ( <hex> , <hex> , <hex> , <hex> , <hex> ) ; assertWellFormed ( <hex> , <hex> , <hex> , <hex> ) ; assertWellFormed ( <hex> , <hex> , <hex> , <hex> , <hex> , <hex> ) ; assertWellFormed ( <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> ) ; assertWellFormed ( <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> ) ; assertNotWellFormed ( - <int> , <int> , - <int> , <int> ) ; } public void testShardsHaveExpectedRoundTrippables ( ) { long actual = <int> ; for ( long expected : generateFourByteShardsExpectedRunnables ( ) ) { actual + = expected ; } assertEquals ( EXPECTED_FOUR_BYTE_ROUNDTRIPPABLE_COUNT , actual ) ; } private static String newString ( char . . . chars ) { return new String ( chars ) ; } private static byte [ ] toByteArray ( int . . . bytes ) { byte [ ] realBytes = new byte [ bytes . length ] ; for ( int i = <int> ; i < bytes . length ; i + + ) { realBytes [ i ] = ( byte ) bytes [ i ] ; } return realBytes ; } private static void assertWellFormed ( int . . . bytes ) { assertTrue ( Utf8 . isWellFormed ( toByteArray ( bytes ) ) ) ; } private static void assertNotWellFormed ( int . . . bytes ) { assertFalse ( Utf8 . isWellFormed ( toByteArray ( bytes ) ) ) ; } private static long [ ] generateFourByteShardsExpectedRunnables ( ) { long [ ] expected = new long [ <int> ] ; for ( int i = <int> ; i < = <int> ; i + + ) { expected [ i ] = <int> ; } for ( int i = <int> ; i < = <int> ; i + + ) { expected [ i ] = <int> ; } for ( int i = <int> ; i < = <int> ; i + + ) { expected [ i ] = <int> ; } expected [ <int> ] = <int> ; expected [ <int> ] = <int> ; expected [ <int> ] = <int> ; expected [ <int> ] = <int> ; expected [ <int> ] = <int> ; expected [ <int> ] = <int> ; return expected ; } @GwtIncompatible ( <str> ) private static void testBytes ( int numBytes , long expectedCount ) { testBytes ( numBytes , expectedCount , <int> , - <int> ) ; } @GwtIncompatible ( <str> ) private static void testBytes ( int numBytes , long expectedCount , long start , long lim ) { byte [ ] bytes = new byte [ numBytes ] ; if ( lim = = - <int> ) { lim = <int> < < ( numBytes * <int> ) ; } long countRoundTripped = <int> ; for ( long byteChar = start ; byteChar < lim ; byteChar + + ) { long tmpByteChar = byteChar ; for ( int i = <int> ; i < numBytes ; i + + ) { bytes [ bytes . length - i - <int> ] = ( byte ) tmpByteChar ; tmpByteChar = tmpByteChar > > <int> ; } boolean isRoundTrippable = Utf8 . isWellFormed ( bytes ) ; assertEquals ( isRoundTrippable , Utf8 . isWellFormed ( bytes , <int> , numBytes ) ) ; String s = new String ( bytes , Charsets . UTF_8 ) ; byte [ ] bytesReencoded = s . getBytes ( Charsets . UTF_8 ) ; boolean bytesEqual = Arrays . equals ( bytes , bytesReencoded ) ; if ( bytesEqual ! = isRoundTrippable ) { fail ( ) ; } if ( isRoundTrippable ) { countRoundTripped + + ; } } assertEquals ( expectedCount , countRoundTripped ) ; } } 
