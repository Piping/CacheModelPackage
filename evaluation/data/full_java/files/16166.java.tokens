package org . gradle . tooling . internal . provider . runner ; import org . gradle . api . Project ; import org . gradle . api . Task ; import org . gradle . api . Transformer ; import org . gradle . api . internal . GradleInternal ; import org . gradle . api . specs . Specs ; import org . gradle . api . tasks . testing . Test ; import org . gradle . api . tasks . testing . TestExecutionException ; import org . gradle . api . tasks . testing . TestFilter ; import org . gradle . execution . BuildConfigurationAction ; import org . gradle . execution . BuildExecutionContext ; import org . gradle . tooling . internal . protocol . events . InternalTestDescriptor ; import org . gradle . tooling . internal . protocol . test . InternalJvmTestRequest ; import org . gradle . tooling . internal . provider . TestExecutionRequestAction ; import org . gradle . tooling . internal . provider . events . DefaultTestDescriptor ; import java . util . * ; class TestExecutionBuildConfigurationAction implements BuildConfigurationAction { private final GradleInternal gradle ; private final TestExecutionRequestAction testExecutionRequest ; public TestExecutionBuildConfigurationAction ( TestExecutionRequestAction testExecutionRequest , GradleInternal gradle ) { this . testExecutionRequest = testExecutionRequest ; this . gradle = gradle ; } @Override public void configure ( BuildExecutionContext context ) { final Set < Test > allTestTasksToRun = new LinkedHashSet < Test > ( ) ; final GradleInternal gradleInternal = context . getGradle ( ) ; allTestTasksToRun . addAll ( configureBuildForTestDescriptors ( gradleInternal , testExecutionRequest ) ) ; allTestTasksToRun . addAll ( configureBuildForInternalJvmTestRequest ( gradleInternal , testExecutionRequest ) ) ; configureTestTasks ( allTestTasksToRun ) ; gradle . getTaskGraph ( ) . addTasks ( allTestTasksToRun ) ; } private void configureTestTasks ( Set < Test > allTestTasksToRun ) { for ( Test task : allTestTasksToRun ) { task . setIgnoreFailures ( true ) ; task . getFilter ( ) . setFailOnNoMatchingTests ( false ) ; task . getOutputs ( ) . upToDateWhen ( Specs . SATISFIES_NONE ) ; } } private List < Test > configureBuildForTestDescriptors ( GradleInternal gradle , TestExecutionRequestAction testExecutionRequest ) { final Collection < InternalTestDescriptor > testDescriptors = testExecutionRequest . getTestExecutionDescriptors ( ) ; final List < String > testTaskPaths = org . gradle . util . CollectionUtils . collect ( testDescriptors , new Transformer < String , InternalTestDescriptor > ( ) { @Override public String transform ( InternalTestDescriptor testDescriptor ) { return ( ( DefaultTestDescriptor ) testDescriptor ) . getTaskPath ( ) ; } } ) ; List < Test > testTasksToRun = new ArrayList < Test > ( ) ; for ( final String testTaskPath : testTaskPaths ) { final Task task = gradle . getRootProject ( ) . getTasks ( ) . findByPath ( testTaskPath ) ; if ( task = = null ) { throw new TestExecutionException ( String . format ( <str> , testTaskPath ) ) ; } else if ( ! ( task instanceof Test ) ) { throw new TestExecutionException ( String . format ( <str> , testTaskPath , task . getClass ( ) . getName ( ) ) ) ; } else { Test testTask = ( Test ) task ; for ( InternalTestDescriptor testDescriptor : testDescriptors ) { DefaultTestDescriptor defaultTestDescriptor = ( DefaultTestDescriptor ) testDescriptor ; if ( defaultTestDescriptor . getTaskPath ( ) . equals ( testTaskPath ) ) { String className = defaultTestDescriptor . getClassName ( ) ; String methodName = defaultTestDescriptor . getMethodName ( ) ; if ( className = = null & & methodName = = null ) { testTask . getFilter ( ) . includeTestsMatching ( <str> ) ; } else { testTask . getFilter ( ) . includeTest ( className , methodName ) ; } } } testTasksToRun . add ( testTask ) ; } } return testTasksToRun ; } private List < Test > configureBuildForInternalJvmTestRequest ( GradleInternal gradle , TestExecutionRequestAction testExecutionRequest ) { final Collection < InternalJvmTestRequest > internalJvmTestRequests = testExecutionRequest . getInternalJvmTestRequests ( ) ; if ( internalJvmTestRequests . isEmpty ( ) ) { return Collections . emptyList ( ) ; } List < Test > tasksToExecute = new ArrayList < Test > ( ) ; final Set < Project > allprojects = gradle . getRootProject ( ) . getAllprojects ( ) ; for ( Project project : allprojects ) { final Collection < Test > testTasks = project . getTasks ( ) . withType ( Test . class ) ; for ( Test testTask : testTasks ) { for ( InternalJvmTestRequest jvmTestRequest : internalJvmTestRequests ) { final TestFilter filter = testTask . getFilter ( ) ; filter . includeTest ( jvmTestRequest . getClassName ( ) , jvmTestRequest . getMethodName ( ) ) ; } } tasksToExecute . addAll ( testTasks ) ; } return tasksToExecute ; } } 
