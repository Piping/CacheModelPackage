package org . elasticsearch . search . suggest . phrase ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Terms ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . HasContextAndHeaders ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentParser . Token ; import org . elasticsearch . index . analysis . ShingleTokenFilterFactory ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . ScriptContext ; import org . elasticsearch . script . Template ; import org . elasticsearch . search . suggest . SuggestContextParser ; import org . elasticsearch . search . suggest . SuggestUtils ; import org . elasticsearch . search . suggest . SuggestionSearchContext ; import org . elasticsearch . search . suggest . phrase . PhraseSuggestionContext . DirectCandidateGenerator ; import java . io . IOException ; public final class PhraseSuggestParser implements SuggestContextParser { private PhraseSuggester suggester ; public PhraseSuggestParser ( PhraseSuggester suggester ) { this . suggester = suggester ; } @Override public SuggestionSearchContext . SuggestionContext parse ( XContentParser parser , MapperService mapperService , IndexFieldDataService fieldDataService , HasContextAndHeaders headersContext ) throws IOException { PhraseSuggestionContext suggestion = new PhraseSuggestionContext ( suggester ) ; ParseFieldMatcher parseFieldMatcher = mapperService . getIndexSettings ( ) . getParseFieldMatcher ( ) ; XContentParser . Token token ; String fieldName = null ; boolean gramSizeSet = false ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( ! SuggestUtils . parseSuggestContext ( parser , mapperService , fieldName , suggestion , parseFieldMatcher ) ) { if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { suggestion . setRealWordErrorLikelihood ( parser . floatValue ( ) ) ; if ( suggestion . realworldErrorLikelyhood ( ) < = <float> ) { throw new IllegalArgumentException ( <str> ) ; } } else if ( <str> . equals ( fieldName ) ) { suggestion . setConfidence ( parser . floatValue ( ) ) ; if ( suggestion . confidence ( ) < <float> ) { throw new IllegalArgumentException ( <str> ) ; } } else if ( <str> . equals ( fieldName ) ) { suggestion . setSeparator ( new BytesRef ( parser . text ( ) ) ) ; } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { suggestion . setMaxErrors ( parser . floatValue ( ) ) ; if ( suggestion . maxErrors ( ) < = <float> ) { throw new IllegalArgumentException ( <str> ) ; } } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { suggestion . setGramSize ( parser . intValue ( ) ) ; if ( suggestion . gramSize ( ) < <int> ) { throw new IllegalArgumentException ( <str> ) ; } gramSizeSet = true ; } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { suggestion . setRequireUnigram ( parser . booleanValue ( ) ) ; } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { int tokenLimit = parser . intValue ( ) ; if ( tokenLimit < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } suggestion . setTokenLimit ( tokenLimit ) ; } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } } else if ( token = = Token . START_ARRAY ) { if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { while ( ( token = parser . nextToken ( ) ) = = Token . START_OBJECT ) { PhraseSuggestionContext . DirectCandidateGenerator generator = new PhraseSuggestionContext . DirectCandidateGenerator ( ) ; while ( ( token = parser . nextToken ( ) ) ! = Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } if ( token . isValue ( ) ) { parseCandidateGenerator ( parser , mapperService , fieldName , generator , parseFieldMatcher ) ; } } verifyGenerator ( generator ) ; suggestion . addGenerator ( generator ) ; } } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } else if ( token = = Token . START_OBJECT ) { if ( <str> . equals ( fieldName ) ) { parseSmoothingModel ( parser , suggestion , fieldName ) ; } else if ( <str> . equals ( fieldName ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { suggestion . setPreTag ( parser . utf8Bytes ( ) ) ; } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { suggestion . setPostTag ( parser . utf8Bytes ( ) ) ; } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } } } else if ( <str> . equals ( fieldName ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( <str> . equals ( fieldName ) ) { if ( suggestion . getCollateQueryScript ( ) ! = null ) { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } Template template = Template . parse ( parser , parseFieldMatcher ) ; CompiledScript compiledScript = suggester . scriptService ( ) . compile ( template , ScriptContext . Standard . SEARCH , headersContext ) ; suggestion . setCollateQueryScript ( compiledScript ) ; } else if ( <str> . equals ( fieldName ) ) { suggestion . setCollateScriptParams ( parser . map ( ) ) ; } else if ( <str> . equals ( fieldName ) ) { if ( parser . isBooleanValue ( ) ) { suggestion . setCollatePrune ( parser . booleanValue ( ) ) ; } else { throw new IllegalArgumentException ( <str> ) ; } } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } if ( suggestion . getField ( ) = = null ) { throw new IllegalArgumentException ( <str> ) ; } MappedFieldType fieldType = mapperService . smartNameFieldType ( suggestion . getField ( ) ) ; if ( fieldType = = null ) { throw new IllegalArgumentException ( <str> + suggestion . getField ( ) + <str> ) ; } else if ( suggestion . getAnalyzer ( ) = = null ) { if ( fieldType . searchAnalyzer ( ) = = null ) { suggestion . setAnalyzer ( mapperService . searchAnalyzer ( ) ) ; } else { suggestion . setAnalyzer ( fieldType . searchAnalyzer ( ) ) ; } } if ( suggestion . model ( ) = = null ) { suggestion . setModel ( StupidBackoffScorer . FACTORY ) ; } if ( ! gramSizeSet | | suggestion . generators ( ) . isEmpty ( ) ) { final ShingleTokenFilterFactory . Factory shingleFilterFactory = SuggestUtils . getShingleFilterFactory ( suggestion . getAnalyzer ( ) ) ; if ( ! gramSizeSet ) { if ( shingleFilterFactory ! = null ) { suggestion . setGramSize ( shingleFilterFactory . getMaxShingleSize ( ) ) ; if ( suggestion . getAnalyzer ( ) = = null & & shingleFilterFactory . getMinShingleSize ( ) > <int> & & ! shingleFilterFactory . getOutputUnigrams ( ) ) { throw new IllegalArgumentException ( <str> + suggestion . getField ( ) + <str> ) ; } } } if ( suggestion . generators ( ) . isEmpty ( ) ) { if ( shingleFilterFactory ! = null & & shingleFilterFactory . getMinShingleSize ( ) > <int> & & ! shingleFilterFactory . getOutputUnigrams ( ) & & suggestion . getRequireUnigram ( ) ) { throw new IllegalArgumentException ( <str> + suggestion . getField ( ) + <str> ) ; } DirectCandidateGenerator generator = new DirectCandidateGenerator ( ) ; generator . setField ( suggestion . getField ( ) ) ; suggestion . addGenerator ( generator ) ; } } return suggestion ; } public void parseSmoothingModel ( XContentParser parser , PhraseSuggestionContext suggestion , String fieldName ) throws IOException { XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; if ( <str> . equals ( fieldName ) ) { ensureNoSmoothing ( suggestion ) ; final double [ ] lambdas = new double [ <int> ] ; while ( ( token = parser . nextToken ( ) ) ! = Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } if ( token . isValue ( ) ) { if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { lambdas [ <int> ] = parser . doubleValue ( ) ; if ( lambdas [ <int> ] < <int> ) { throw new IllegalArgumentException ( <str> ) ; } } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { lambdas [ <int> ] = parser . doubleValue ( ) ; if ( lambdas [ <int> ] < <int> ) { throw new IllegalArgumentException ( <str> ) ; } } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { lambdas [ <int> ] = parser . doubleValue ( ) ; if ( lambdas [ <int> ] < <int> ) { throw new IllegalArgumentException ( <str> ) ; } } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } } double sum = <float> ; for ( int i = <int> ; i < lambdas . length ; i + + ) { sum + = lambdas [ i ] ; } if ( Math . abs ( sum - <float> ) > <float> ) { throw new IllegalArgumentException ( <str> ) ; } suggestion . setModel ( new WordScorer . WordScorerFactory ( ) { @Override public WordScorer newScorer ( IndexReader reader , Terms terms , String field , double realWordLikelyhood , BytesRef separator ) throws IOException { return new LinearInterpoatingScorer ( reader , terms , field , realWordLikelyhood , separator , lambdas [ <int> ] , lambdas [ <int> ] , lambdas [ <int> ] ) ; } } ) ; } else if ( <str> . equals ( fieldName ) ) { ensureNoSmoothing ( suggestion ) ; double theAlpha = <float> ; while ( ( token = parser . nextToken ( ) ) ! = Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } if ( token . isValue ( ) & & <str> . equals ( fieldName ) ) { theAlpha = parser . doubleValue ( ) ; } } final double alpha = theAlpha ; suggestion . setModel ( new WordScorer . WordScorerFactory ( ) { @Override public WordScorer newScorer ( IndexReader reader , Terms terms , String field , double realWordLikelyhood , BytesRef separator ) throws IOException { return new LaplaceScorer ( reader , terms , field , realWordLikelyhood , separator , alpha ) ; } } ) ; } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { ensureNoSmoothing ( suggestion ) ; double theDiscount = <float> ; while ( ( token = parser . nextToken ( ) ) ! = Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } if ( token . isValue ( ) & & <str> . equals ( fieldName ) ) { theDiscount = parser . doubleValue ( ) ; } } final double discount = theDiscount ; suggestion . setModel ( new WordScorer . WordScorerFactory ( ) { @Override public WordScorer newScorer ( IndexReader reader , Terms terms , String field , double realWordLikelyhood , BytesRef separator ) throws IOException { return new StupidBackoffScorer ( reader , terms , field , realWordLikelyhood , separator , discount ) ; } } ) ; } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } } } private void ensureNoSmoothing ( PhraseSuggestionContext suggestion ) { if ( suggestion . model ( ) ! = null ) { throw new IllegalArgumentException ( <str> ) ; } } private void verifyGenerator ( PhraseSuggestionContext . DirectCandidateGenerator suggestion ) { if ( suggestion . field ( ) = = null ) { throw new IllegalArgumentException ( <str> ) ; } } private void parseCandidateGenerator ( XContentParser parser , MapperService mapperService , String fieldName , PhraseSuggestionContext . DirectCandidateGenerator generator , ParseFieldMatcher parseFieldMatcher ) throws IOException { if ( ! SuggestUtils . parseDirectSpellcheckerSettings ( parser , fieldName , generator , parseFieldMatcher ) ) { if ( <str> . equals ( fieldName ) ) { generator . setField ( parser . text ( ) ) ; if ( mapperService . smartNameFieldType ( generator . field ( ) ) = = null ) { throw new IllegalArgumentException ( <str> + generator . field ( ) + <str> ) ; } } else if ( <str> . equals ( fieldName ) ) { generator . size ( parser . intValue ( ) ) ; } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { String analyzerName = parser . text ( ) ; Analyzer analyzer = mapperService . analysisService ( ) . analyzer ( analyzerName ) ; if ( analyzer = = null ) { throw new IllegalArgumentException ( <str> + analyzerName + <str> ) ; } generator . preFilter ( analyzer ) ; } else if ( <str> . equals ( fieldName ) | | <str> . equals ( fieldName ) ) { String analyzerName = parser . text ( ) ; Analyzer analyzer = mapperService . analysisService ( ) . analyzer ( analyzerName ) ; if ( analyzer = = null ) { throw new IllegalArgumentException ( <str> + analyzerName + <str> ) ; } generator . postFilter ( analyzer ) ; } else { throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } } } } 
