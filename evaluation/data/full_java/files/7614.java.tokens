package org . elasticsearch . search . suggest . term ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . spell . DirectSpellChecker ; import org . apache . lucene . search . spell . SuggestWord ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . apache . lucene . util . CharsRefBuilder ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . text . BytesText ; import org . elasticsearch . common . text . StringText ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . search . suggest . SuggestContextParser ; import org . elasticsearch . search . suggest . SuggestUtils ; import org . elasticsearch . search . suggest . Suggester ; import org . elasticsearch . search . suggest . SuggestionSearchContext . SuggestionContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public final class TermSuggester extends Suggester < TermSuggestionContext > { @Override public TermSuggestion innerExecute ( String name , TermSuggestionContext suggestion , IndexSearcher searcher , CharsRefBuilder spare ) throws IOException { DirectSpellChecker directSpellChecker = SuggestUtils . getDirectSpellChecker ( suggestion . getDirectSpellCheckerSettings ( ) ) ; final IndexReader indexReader = searcher . getIndexReader ( ) ; TermSuggestion response = new TermSuggestion ( name , suggestion . getSize ( ) , suggestion . getDirectSpellCheckerSettings ( ) . sort ( ) ) ; List < Token > tokens = queryTerms ( suggestion , spare ) ; for ( Token token : tokens ) { SuggestWord [ ] suggestedWords = directSpellChecker . suggestSimilar ( token . term , suggestion . getShardSize ( ) , indexReader , suggestion . getDirectSpellCheckerSettings ( ) . suggestMode ( ) ) ; Text key = new BytesText ( new BytesArray ( token . term . bytes ( ) ) ) ; TermSuggestion . Entry resultEntry = new TermSuggestion . Entry ( key , token . startOffset , token . endOffset - token . startOffset ) ; for ( SuggestWord suggestWord : suggestedWords ) { Text word = new StringText ( suggestWord . string ) ; resultEntry . addOption ( new TermSuggestion . Entry . Option ( word , suggestWord . freq , suggestWord . score ) ) ; } response . addTerm ( resultEntry ) ; } return response ; } @Override public SuggestContextParser getContextParser ( ) { return new TermSuggestParser ( this ) ; } private List < Token > queryTerms ( SuggestionContext suggestion , CharsRefBuilder spare ) throws IOException { final List < Token > result = new ArrayList < > ( ) ; final String field = suggestion . getField ( ) ; SuggestUtils . analyze ( suggestion . getAnalyzer ( ) , suggestion . getText ( ) , field , new SuggestUtils . TokenConsumer ( ) { @Override public void nextToken ( ) { Term term = new Term ( field , BytesRef . deepCopyOf ( fillBytesRef ( new BytesRefBuilder ( ) ) ) ) ; result . add ( new Token ( term , offsetAttr . startOffset ( ) , offsetAttr . endOffset ( ) ) ) ; } } , spare ) ; return result ; } private static class Token { public final Term term ; public final int startOffset ; public final int endOffset ; private Token ( Term term , int startOffset , int endOffset ) { this . term = term ; this . startOffset = startOffset ; this . endOffset = endOffset ; } } } 
