package org . elasticsearch . index . engine ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsResponse ; import org . elasticsearch . action . bulk . BulkRequestBuilder ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . client . Requests ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; @ClusterScope ( numDataNodes = <int> , scope = Scope . SUITE ) public class InternalEngineMergeIT extends ESIntegTestCase { public void testMergesHappening ( ) throws InterruptedException , IOException , ExecutionException { final int numOfShards = randomIntBetween ( <int> , <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , numOfShards ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . build ( ) ) ) ; long id = <int> ; final int rounds = scaledRandomIntBetween ( <int> , <int> ) ; logger . info ( <str> , rounds ) ; for ( int i = <int> ; i < rounds ; + + i ) { final int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; BulkRequestBuilder request = client ( ) . prepareBulk ( ) ; for ( int j = <int> ; j < numDocs ; + + j ) { request . add ( Requests . indexRequest ( <str> ) . type ( <str> ) . id ( Long . toString ( id + + ) ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , randomLong ( ) ) . endObject ( ) ) ) ; } BulkResponse response = request . execute ( ) . actionGet ( ) ; refresh ( ) ; assertNoFailures ( response ) ; IndicesStatsResponse stats = client ( ) . admin ( ) . indices ( ) . prepareStats ( <str> ) . setSegments ( true ) . setMerge ( true ) . get ( ) ; logger . info ( <str> , i , stats . getPrimaries ( ) . getSegments ( ) . getCount ( ) , stats . getPrimaries ( ) . getMerge ( ) . getTotal ( ) , stats . getPrimaries ( ) . getMerge ( ) . getCurrent ( ) ) ; } final long upperNumberSegments = <int> * numOfShards * <int> ; awaitBusy ( ( ) - > { IndicesStatsResponse stats = client ( ) . admin ( ) . indices ( ) . prepareStats ( ) . setSegments ( true ) . setMerge ( true ) . get ( ) ; logger . info ( <str> , numOfShards , stats . getPrimaries ( ) . getSegments ( ) . getCount ( ) , stats . getPrimaries ( ) . getMerge ( ) . getTotal ( ) , stats . getPrimaries ( ) . getMerge ( ) . getCurrent ( ) ) ; long current = stats . getPrimaries ( ) . getMerge ( ) . getCurrent ( ) ; long count = stats . getPrimaries ( ) . getSegments ( ) . getCount ( ) ; return count < upperNumberSegments & & current = = <int> ; } ) ; IndicesStatsResponse stats = client ( ) . admin ( ) . indices ( ) . prepareStats ( ) . setSegments ( true ) . setMerge ( true ) . get ( ) ; logger . info ( <str> , numOfShards , stats . getPrimaries ( ) . getSegments ( ) . getCount ( ) , stats . getPrimaries ( ) . getMerge ( ) . getTotal ( ) , stats . getPrimaries ( ) . getMerge ( ) . getCurrent ( ) ) ; long count = stats . getPrimaries ( ) . getSegments ( ) . getCount ( ) ; assertThat ( count , Matchers . lessThanOrEqualTo ( upperNumberSegments ) ) ; } } 
