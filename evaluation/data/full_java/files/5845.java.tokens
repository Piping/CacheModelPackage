package org . elasticsearch . common . inject . internal ; import java . util . concurrent . ConcurrentHashMap ; public abstract class FailableCache < K , V > { private final ConcurrentHashMap < K , Object > cache = new ConcurrentHashMap < > ( ) ; protected abstract V create ( K key , Errors errors ) throws ErrorsException ; public V get ( K key , Errors errors ) throws ErrorsException { Object resultOrError = cache . get ( key ) ; if ( resultOrError = = null ) { synchronized ( this ) { resultOrError = load ( key ) ; cache . putIfAbsent ( key , resultOrError ) ; } } if ( resultOrError instanceof Errors ) { errors . merge ( ( Errors ) resultOrError ) ; throw errors . toException ( ) ; } else { @SuppressWarnings ( <str> ) V result = ( V ) resultOrError ; return result ; } } private Object load ( K key ) { Errors errors = new Errors ( ) ; V result = null ; try { result = create ( key , errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } return errors . hasErrors ( ) ? errors : result ; } } 
