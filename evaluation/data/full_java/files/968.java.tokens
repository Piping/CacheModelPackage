package org . apache . cassandra . service . pager ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . Clustering ; import org . apache . cassandra . db . LegacyLayout ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . io . util . DataOutputBufferFixed ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . transport . ProtocolException ; import org . apache . cassandra . utils . ByteBufferUtil ; public class PagingState { public final ByteBuffer partitionKey ; public final RowMark rowMark ; public final int remaining ; public final int remainingInPartition ; public PagingState ( ByteBuffer partitionKey , RowMark rowMark , int remaining , int remainingInPartition ) { this . partitionKey = partitionKey ; this . rowMark = rowMark ; this . remaining = remaining ; this . remainingInPartition = remainingInPartition ; } public static PagingState deserialize ( ByteBuffer bytes , int protocolVersion ) { if ( bytes = = null ) return null ; try ( DataInputBuffer in = new DataInputBuffer ( bytes , true ) ) { ByteBuffer pk ; RowMark mark ; int remaining , remainingInPartition ; if ( protocolVersion < = Server . VERSION_3 ) { pk = ByteBufferUtil . readWithShortLength ( in ) ; mark = new RowMark ( ByteBufferUtil . readWithShortLength ( in ) , protocolVersion ) ; remaining = in . readInt ( ) ; remainingInPartition = in . available ( ) > <int> ? in . readInt ( ) : Integer . MAX_VALUE ; } else { pk = ByteBufferUtil . readWithVIntLength ( in ) ; mark = new RowMark ( ByteBufferUtil . readWithVIntLength ( in ) , protocolVersion ) ; remaining = ( int ) in . readUnsignedVInt ( ) ; remainingInPartition = ( int ) in . readUnsignedVInt ( ) ; } return new PagingState ( pk . hasRemaining ( ) ? pk : null , mark . mark . hasRemaining ( ) ? mark : null , remaining , remainingInPartition ) ; } catch ( IOException e ) { throw new ProtocolException ( <str> ) ; } } public ByteBuffer serialize ( int protocolVersion ) { assert rowMark = = null | | protocolVersion = = rowMark . protocolVersion ; try ( DataOutputBuffer out = new DataOutputBufferFixed ( serializedSize ( protocolVersion ) ) ) { ByteBuffer pk = partitionKey = = null ? ByteBufferUtil . EMPTY_BYTE_BUFFER : partitionKey ; ByteBuffer mark = rowMark = = null ? ByteBufferUtil . EMPTY_BYTE_BUFFER : rowMark . mark ; if ( protocolVersion < = Server . VERSION_3 ) { ByteBufferUtil . writeWithShortLength ( pk , out ) ; ByteBufferUtil . writeWithShortLength ( mark , out ) ; out . writeInt ( remaining ) ; out . writeInt ( remainingInPartition ) ; } else { ByteBufferUtil . writeWithVIntLength ( pk , out ) ; ByteBufferUtil . writeWithVIntLength ( mark , out ) ; out . writeUnsignedVInt ( remaining ) ; out . writeUnsignedVInt ( remainingInPartition ) ; } return out . buffer ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public int serializedSize ( int protocolVersion ) { assert rowMark = = null | | protocolVersion = = rowMark . protocolVersion ; ByteBuffer pk = partitionKey = = null ? ByteBufferUtil . EMPTY_BYTE_BUFFER : partitionKey ; ByteBuffer mark = rowMark = = null ? ByteBufferUtil . EMPTY_BYTE_BUFFER : rowMark . mark ; if ( protocolVersion < = Server . VERSION_3 ) { return ByteBufferUtil . serializedSizeWithShortLength ( pk ) + ByteBufferUtil . serializedSizeWithShortLength ( mark ) + <int> ; } else { return ByteBufferUtil . serializedSizeWithVIntLength ( pk ) + ByteBufferUtil . serializedSizeWithVIntLength ( mark ) + TypeSizes . sizeofUnsignedVInt ( remaining ) + TypeSizes . sizeofUnsignedVInt ( remainingInPartition ) ; } } @Override public final int hashCode ( ) { return Objects . hash ( partitionKey , rowMark , remaining , remainingInPartition ) ; } @Override public final boolean equals ( Object o ) { if ( ! ( o instanceof PagingState ) ) return false ; PagingState that = ( PagingState ) o ; return Objects . equals ( this . partitionKey , that . partitionKey ) & & Objects . equals ( this . rowMark , that . rowMark ) & & this . remaining = = that . remaining & & this . remainingInPartition = = that . remainingInPartition ; } @Override public String toString ( ) { return String . format ( <str> , ByteBufferUtil . bytesToHex ( partitionKey ) , rowMark , remaining , remainingInPartition ) ; } public static class RowMark { private final ByteBuffer mark ; private final int protocolVersion ; private RowMark ( ByteBuffer mark , int protocolVersion ) { this . mark = mark ; this . protocolVersion = protocolVersion ; } private static List < AbstractType < ? > > makeClusteringTypes ( CFMetaData metadata ) { int size = metadata . clusteringColumns ( ) . size ( ) ; List < AbstractType < ? > > l = new ArrayList < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) l . add ( BytesType . instance ) ; return l ; } public static RowMark create ( CFMetaData metadata , Row row , int protocolVersion ) { ByteBuffer mark ; if ( protocolVersion < = Server . VERSION_3 ) { Iterator < Cell > cells = row . cellsInLegacyOrder ( metadata , true ) . iterator ( ) ; if ( ! cells . hasNext ( ) ) { mark = LegacyLayout . encodeClustering ( metadata , row . clustering ( ) ) ; } else { Cell cell = cells . next ( ) ; mark = LegacyLayout . encodeCellName ( metadata , row . clustering ( ) , cell . column ( ) . name . bytes , cell . column ( ) . isComplex ( ) ? cell . path ( ) . get ( <int> ) : null ) ; } } else { mark = Clustering . serializer . serialize ( row . clustering ( ) , MessagingService . VERSION_30 , makeClusteringTypes ( metadata ) ) ; } return new RowMark ( mark , protocolVersion ) ; } public Clustering clustering ( CFMetaData metadata ) { if ( mark = = null ) return null ; return protocolVersion < = Server . VERSION_3 ? LegacyLayout . decodeClustering ( metadata , mark ) : Clustering . serializer . deserialize ( mark , MessagingService . VERSION_30 , makeClusteringTypes ( metadata ) ) ; } @Override public final int hashCode ( ) { return Objects . hash ( mark , protocolVersion ) ; } @Override public final boolean equals ( Object o ) { if ( ! ( o instanceof RowMark ) ) return false ; RowMark that = ( RowMark ) o ; return Objects . equals ( this . mark , that . mark ) & & this . protocolVersion = = that . protocolVersion ; } @Override public String toString ( ) { return ByteBufferUtil . bytesToHex ( mark ) ; } } } 
