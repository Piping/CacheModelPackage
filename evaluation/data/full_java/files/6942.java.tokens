package org . elasticsearch . repositories . blobstore ; import org . apache . lucene . codecs . CodecUtil ; import org . apache . lucene . index . CorruptIndexException ; import org . apache . lucene . index . IndexFormatTooNewException ; import org . apache . lucene . index . IndexFormatTooOldException ; import org . apache . lucene . store . OutputStreamIndexOutput ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . blobstore . BlobContainer ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . compress . CompressorFactory ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . store . ByteArrayIndexInput ; import org . elasticsearch . common . lucene . store . IndexOutputOutputStream ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . gateway . CorruptStateException ; import java . io . * ; import java . util . Locale ; public class ChecksumBlobStoreFormat < T extends ToXContent > extends BlobStoreFormat < T > { private static final String TEMP_FILE_PREFIX = <str> ; private static final XContentType DEFAULT_X_CONTENT_TYPE = XContentType . SMILE ; public static final int VERSION = <int> ; private static final int BUFFER_SIZE = <int> ; protected final XContentType xContentType ; protected final boolean compress ; private final String codec ; public ChecksumBlobStoreFormat ( String codec , String blobNameFormat , FromXContentBuilder < T > reader , ParseFieldMatcher parseFieldMatcher , boolean compress , XContentType xContentType ) { super ( blobNameFormat , reader , parseFieldMatcher ) ; this . xContentType = xContentType ; this . compress = compress ; this . codec = codec ; } public ChecksumBlobStoreFormat ( String codec , String blobNameFormat , FromXContentBuilder < T > reader , ParseFieldMatcher parseFieldMatcher , boolean compress ) { this ( codec , blobNameFormat , reader , parseFieldMatcher , compress , DEFAULT_X_CONTENT_TYPE ) ; } public T readBlob ( BlobContainer blobContainer , String blobName ) throws IOException { try ( InputStream inputStream = blobContainer . readBlob ( blobName ) ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Streams . copy ( inputStream , out ) ; final byte [ ] bytes = out . toByteArray ( ) ; final String resourceDesc = <str> + blobName + <str> ; try ( ByteArrayIndexInput indexInput = new ByteArrayIndexInput ( resourceDesc , bytes ) ) { CodecUtil . checksumEntireFile ( indexInput ) ; CodecUtil . checkHeader ( indexInput , codec , VERSION , VERSION ) ; long filePointer = indexInput . getFilePointer ( ) ; long contentSize = indexInput . length ( ) - CodecUtil . footerLength ( ) - filePointer ; BytesReference bytesReference = new BytesArray ( bytes , ( int ) filePointer , ( int ) contentSize ) ; return read ( bytesReference ) ; } catch ( CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex ) { throw new CorruptStateException ( ex ) ; } } } public void writeAtomic ( T obj , BlobContainer blobContainer , String name ) throws IOException { String blobName = blobName ( name ) ; String tempBlobName = tempBlobName ( name ) ; writeBlob ( obj , blobContainer , tempBlobName ) ; try { blobContainer . move ( tempBlobName , blobName ) ; } catch ( IOException ex ) { blobContainer . deleteBlob ( tempBlobName ) ; throw ex ; } } public void write ( T obj , BlobContainer blobContainer , String name ) throws IOException { String blobName = blobName ( name ) ; writeBlob ( obj , blobContainer , blobName ) ; } protected void writeBlob ( T obj , BlobContainer blobContainer , String blobName ) throws IOException { BytesReference bytes = write ( obj ) ; try ( ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ) { final String resourceDesc = <str> + blobName + <str> ; try ( OutputStreamIndexOutput indexOutput = new OutputStreamIndexOutput ( resourceDesc , byteArrayOutputStream , BUFFER_SIZE ) ) { CodecUtil . writeHeader ( indexOutput , codec , VERSION ) ; try ( OutputStream indexOutputOutputStream = new IndexOutputOutputStream ( indexOutput ) { @Override public void close ( ) throws IOException { } } ) { bytes . writeTo ( indexOutputOutputStream ) ; } CodecUtil . writeFooter ( indexOutput ) ; } blobContainer . writeBlob ( blobName , new BytesArray ( byteArrayOutputStream . toByteArray ( ) ) ) ; } } public boolean isTempBlobName ( String blobName ) { return blobName . startsWith ( ChecksumBlobStoreFormat . TEMP_FILE_PREFIX ) ; } protected BytesReference write ( T obj ) throws IOException { try ( BytesStreamOutput bytesStreamOutput = new BytesStreamOutput ( ) ) { if ( compress ) { try ( StreamOutput compressedStreamOutput = CompressorFactory . defaultCompressor ( ) . streamOutput ( bytesStreamOutput ) ) { write ( obj , compressedStreamOutput ) ; } } else { write ( obj , bytesStreamOutput ) ; } return bytesStreamOutput . bytes ( ) ; } } protected void write ( T obj , StreamOutput streamOutput ) throws IOException { try ( XContentBuilder builder = XContentFactory . contentBuilder ( xContentType , streamOutput ) ) { builder . startObject ( ) ; obj . toXContent ( builder , SNAPSHOT_ONLY_FORMAT_PARAMS ) ; builder . endObject ( ) ; } } protected String tempBlobName ( String name ) { return TEMP_FILE_PREFIX + String . format ( Locale . ROOT , blobNameFormat , name ) ; } } 
