package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; public class NodeVersionAllocationDecider extends AllocationDecider { public static final String NAME = <str> ; @Inject public NodeVersionAllocationDecider ( Settings settings ) { super ( settings ) ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { String sourceNodeId = shardRouting . currentNodeId ( ) ; if ( sourceNodeId = = null ) { if ( shardRouting . primary ( ) ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } final ShardRouting primary = allocation . routingNodes ( ) . activePrimary ( shardRouting ) ; if ( primary = = null ) { return allocation . decision ( Decision . YES , NAME , <str> ) ; } sourceNodeId = primary . currentNodeId ( ) ; } return isVersionCompatible ( allocation . routingNodes ( ) , sourceNodeId , node , allocation ) ; } private Decision isVersionCompatible ( final RoutingNodes routingNodes , final String sourceNodeId , final RoutingNode target , RoutingAllocation allocation ) { final RoutingNode source = routingNodes . node ( sourceNodeId ) ; if ( target . node ( ) . version ( ) . onOrAfter ( source . node ( ) . version ( ) ) ) { return allocation . decision ( Decision . YES , NAME , <str> , target . node ( ) . version ( ) , source . node ( ) . version ( ) ) ; } else { return allocation . decision ( Decision . NO , NAME , <str> , target . node ( ) . version ( ) , source . node ( ) . version ( ) ) ; } } } 
