package org . eclipse . debug . internal . ui . viewers . update ; import java . util . HashMap ; import java . util . Map ; import java . util . Timer ; import java . util . TimerTask ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IDebugEventSetListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . provisional . AbstractModelProxy ; public abstract class EventHandlerModelProxy extends AbstractModelProxy implements IDebugEventSetListener { private Map < Object , PendingSuspendTask > fTimerTasks = new HashMap < Object , PendingSuspendTask > ( ) ; private Timer fTimer = new Timer ( true ) ; private Map < Object , DebugEvent > fPendingSuspends = new HashMap < Object , DebugEvent > ( ) ; private DebugEventHandler [ ] fHandlers = new DebugEventHandler [ <int> ] ; private class PendingSuspendTask extends TimerTask { private DebugEvent fEvent ; private DebugEventHandler fHandler ; public PendingSuspendTask ( DebugEventHandler handler , DebugEvent resume ) { fHandler = handler ; fEvent = resume ; } @Override public void run ( ) { synchronized ( fPendingSuspends ) { fPendingSuspends . put ( fEvent . getSource ( ) , fEvent ) ; } dispatchSuspendTimeout ( fHandler , fEvent ) ; } } protected abstract DebugEventHandler [ ] createEventHandlers ( ) ; @Override public synchronized void dispose ( ) { super . dispose ( ) ; fTimer . cancel ( ) ; fTimerTasks . clear ( ) ; DebugPlugin . getDefault ( ) . removeDebugEventListener ( this ) ; for ( int i = <int> ; i < fHandlers . length ; i + + ) { DebugEventHandler handler = fHandlers [ i ] ; handler . dispose ( ) ; } } @Override public void init ( IPresentationContext context ) { super . init ( context ) ; DebugPlugin . getDefault ( ) . addDebugEventListener ( this ) ; fHandlers = createEventHandlers ( ) ; } @Override public final void handleDebugEvents ( DebugEvent [ ] events ) { if ( isDisposed ( ) ) { return ; } for ( int i = <int> ; i < events . length ; i + + ) { DebugEvent event = events [ i ] ; if ( containsEvent ( event ) ) { for ( int j = <int> ; j < fHandlers . length ; j + + ) { DebugEventHandler handler = fHandlers [ j ] ; if ( isDisposed ( ) ) { return ; } if ( handler . handlesEvent ( event ) ) { switch ( event . getKind ( ) ) { case DebugEvent . CREATE : dispatchCreate ( handler , event ) ; break ; case DebugEvent . TERMINATE : dispatchTerminate ( handler , event ) ; break ; case DebugEvent . SUSPEND : dispatchSuspend ( handler , event ) ; break ; case DebugEvent . RESUME : dispatchResume ( handler , event ) ; break ; case DebugEvent . CHANGE : dispatchChange ( handler , event ) ; break ; default : dispatchOther ( handler , event ) ; break ; } } } } } } protected boolean containsEvent ( DebugEvent event ) { return true ; } protected void dispatchCreate ( DebugEventHandler handler , DebugEvent event ) { handler . handleCreate ( event ) ; } protected void dispatchTerminate ( DebugEventHandler handler , DebugEvent event ) { handler . handleTerminate ( event ) ; } protected void dispatchSuspend ( DebugEventHandler handler , DebugEvent event ) { synchronized ( this ) { TimerTask task = fTimerTasks . remove ( event . getSource ( ) ) ; if ( task ! = null ) { task . cancel ( ) ; } } DebugEvent resume = null ; synchronized ( this ) { resume = fPendingSuspends . remove ( event . getSource ( ) ) ; } if ( resume = = null ) { handler . handleSuspend ( event ) ; } else { handler . handleLateSuspend ( event , resume ) ; } } protected void dispatchResume ( DebugEventHandler handler , DebugEvent event ) { if ( event . isEvaluation ( ) | | event . isStepStart ( ) ) { synchronized ( this ) { if ( ! isDisposed ( ) ) { PendingSuspendTask task = new PendingSuspendTask ( handler , event ) ; fTimerTasks . put ( event . getSource ( ) , task ) ; fTimer . schedule ( task , <int> ) ; } } if ( ! isDisposed ( ) ) { handler . handleResumeExpectingSuspend ( event ) ; } } else { handler . handleResume ( event ) ; } } protected void dispatchChange ( DebugEventHandler handler , DebugEvent event ) { handler . handleChange ( event ) ; } protected void dispatchOther ( DebugEventHandler handler , DebugEvent event ) { handler . handleOther ( event ) ; } protected void dispatchSuspendTimeout ( DebugEventHandler handler , DebugEvent resume ) { handler . handleSuspendTimeout ( resume ) ; } protected int indexOf ( Object [ ] list , Object element ) { for ( int i = <int> ; i < list . length ; i + + ) { if ( element . equals ( list [ i ] ) ) { return i ; } } return - <int> ; } } 
