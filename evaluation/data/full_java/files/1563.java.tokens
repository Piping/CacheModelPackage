package org . apache . cassandra . io . sstable ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . * ; import com . google . common . collect . Sets ; import org . junit . Assert ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterators ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . LocalPartitioner . LocalToken ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . util . FileDataInput ; import org . apache . cassandra . io . util . MmappedRegions ; import org . apache . cassandra . io . util . SegmentedFile ; import org . apache . cassandra . schema . CachingParams ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . CacheService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . Pair ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class SSTableReaderTest { public static final String KEYSPACE1 = <str> ; public static final String CF_STANDARD = <str> ; public static final String CF_STANDARD2 = <str> ; public static final String CF_INDEXED = <str> ; public static final String CF_STANDARDLOWINDEXINTERVAL = <str> ; private IPartitioner partitioner ; Token t ( int i ) { return partitioner . getToken ( ByteBufferUtil . bytes ( String . valueOf ( i ) ) ) ; } @BeforeClass public static void defineSchema ( ) throws Exception { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD2 ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE1 , CF_INDEXED , true ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARDLOWINDEXINTERVAL ) . minIndexInterval ( <int> ) . maxIndexInterval ( <int> ) . caching ( CachingParams . CACHE_NOTHING ) ) ; } @Test public void testGetPositionsForRanges ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; partitioner = store . getPartitioner ( ) ; CompactionManager . instance . disableAutoCompaction ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { new RowUpdateBuilder ( store . metadata , j , String . valueOf ( j ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; CompactionManager . instance . performMaximal ( store , false ) ; List < Range < Token > > ranges = new ArrayList < Range < Token > > ( ) ; ranges . add ( new Range < > ( t ( <int> ) , t ( <int> ) ) ) ; ranges . add ( new Range < > ( t ( <int> ) , t ( <int> ) ) ) ; ranges . add ( new Range < > ( t ( <int> ) , partitioner . getMinimumToken ( ) ) ) ; ranges . add ( new Range < > ( t ( <int> ) , t ( <int> ) ) ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; long previous = - <int> ; for ( Pair < Long , Long > section : sstable . getPositionsForRanges ( ranges ) ) { assert previous < = section . left : previous + <str> + section . left ; assert section . left < section . right : section . left + <str> + section . right ; previous = section . right ; } } @Test public void testSpannedIndexPositions ( ) throws IOException { MmappedRegions . MAX_SEGMENT_SIZE = <int> ; Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; partitioner = store . getPartitioner ( ) ; CompactionManager . instance . disableAutoCompaction ( ) ; for ( int j = <int> ; j < <int> ; j + = <int> ) { new RowUpdateBuilder ( store . metadata , j , String . valueOf ( j ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; CompactionManager . instance . performMaximal ( store , false ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; for ( int j = <int> ; j < <int> ; j + = <int> ) { DecoratedKey dk = Util . dk ( String . valueOf ( j ) ) ; FileDataInput file = sstable . getFileDataInput ( sstable . getPosition ( dk , SSTableReader . Operator . EQ ) . position ) ; DecoratedKey keyInDisk = sstable . decorateKey ( ByteBufferUtil . readWithShortLength ( file ) ) ; assert keyInDisk . equals ( dk ) : String . format ( <str> , keyInDisk , dk , file . getPath ( ) ) ; } for ( int j = <int> ; j < <int> ; j + = <int> ) { DecoratedKey dk = Util . dk ( String . valueOf ( j ) ) ; assert sstable . getPosition ( dk , SSTableReader . Operator . EQ ) = = null ; } } @Test public void testPersistentStatistics ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; partitioner = store . getPartitioner ( ) ; for ( int j = <int> ; j < <int> ; j + = <int> ) { new RowUpdateBuilder ( store . metadata , j , String . valueOf ( j ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; clearAndLoad ( store ) ; assert store . metric . maxPartitionSize . getValue ( ) ! = <int> ; } private void clearAndLoad ( ColumnFamilyStore cfs ) { cfs . clearUnsafe ( ) ; cfs . loadNewSSTables ( ) ; } @Test public void testReadRateTracking ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; partitioner = store . getPartitioner ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { new RowUpdateBuilder ( store . metadata , j , String . valueOf ( j ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assertEquals ( <int> , sstable . getReadMeter ( ) . count ( ) ) ; DecoratedKey key = sstable . decorateKey ( ByteBufferUtil . bytes ( <str> ) ) ; Util . getAll ( Util . cmd ( store , key ) . build ( ) ) ; assertEquals ( <int> , sstable . getReadMeter ( ) . count ( ) ) ; Util . getAll ( Util . cmd ( store , key ) . includeRow ( <str> ) . build ( ) ) ; assertEquals ( <int> , sstable . getReadMeter ( ) . count ( ) ) ; } @Test public void testGetPositionsForRangesWithKeyCache ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; partitioner = store . getPartitioner ( ) ; CacheService . instance . keyCache . setCapacity ( <int> ) ; CompactionManager . instance . disableAutoCompaction ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { new RowUpdateBuilder ( store . metadata , j , String . valueOf ( j ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; CompactionManager . instance . performMaximal ( store , false ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; long p2 = sstable . getPosition ( k ( <int> ) , SSTableReader . Operator . EQ ) . position ; long p3 = sstable . getPosition ( k ( <int> ) , SSTableReader . Operator . EQ ) . position ; long p6 = sstable . getPosition ( k ( <int> ) , SSTableReader . Operator . EQ ) . position ; long p7 = sstable . getPosition ( k ( <int> ) , SSTableReader . Operator . EQ ) . position ; Pair < Long , Long > p = sstable . getPositionsForRanges ( makeRanges ( t ( <int> ) , t ( <int> ) ) ) . get ( <int> ) ; assert p . left = = p3 ; assert p . right = = p7 ; } @Test public void testPersistentStatisticsWithSecondaryIndex ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( CF_INDEXED ) ; partitioner = store . getPartitioner ( ) ; new RowUpdateBuilder ( store . metadata , System . currentTimeMillis ( ) , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; store . forceBlockingFlush ( ) ; assertIndexQueryWorks ( store ) ; } public void testGetPositionsKeyCacheStats ( ) { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; partitioner = store . getPartitioner ( ) ; CacheService . instance . keyCache . setCapacity ( <int> ) ; CompactionManager . instance . disableAutoCompaction ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { new RowUpdateBuilder ( store . metadata , j , String . valueOf ( j ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; CompactionManager . instance . performMaximal ( store , false ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; sstable . getPosition ( k ( <int> ) , SSTableReader . Operator . EQ ) ; assertEquals ( <int> , sstable . getKeyCacheHit ( ) ) ; assertEquals ( <int> , sstable . getBloomFilterTruePositiveCount ( ) ) ; sstable . getPosition ( k ( <int> ) , SSTableReader . Operator . EQ ) ; assertEquals ( <int> , sstable . getKeyCacheHit ( ) ) ; assertEquals ( <int> , sstable . getBloomFilterTruePositiveCount ( ) ) ; sstable . getPosition ( k ( <int> ) , SSTableReader . Operator . EQ ) ; assertEquals ( <int> , sstable . getKeyCacheHit ( ) ) ; assertEquals ( <int> , sstable . getBloomFilterTruePositiveCount ( ) ) ; } @Test public void testOpeningSSTable ( ) throws Exception { String ks = KEYSPACE1 ; String cf = <str> ; Keyspace keyspace = Keyspace . open ( ks ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( cf ) ; store . clearUnsafe ( ) ; store . disableAutoCompaction ( ) ; DecoratedKey firstKey = null , lastKey = null ; long timestamp = System . currentTimeMillis ( ) ; for ( int i = <int> ; i < store . metadata . params . minIndexInterval ; i + + ) { DecoratedKey key = Util . dk ( String . valueOf ( i ) ) ; if ( firstKey = = null ) firstKey = key ; if ( lastKey = = null ) lastKey = key ; if ( store . metadata . getKeyValidator ( ) . compare ( lastKey . getKey ( ) , key . getKey ( ) ) < <int> ) lastKey = key ; new RowUpdateBuilder ( store . metadata , timestamp , key . getKey ( ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; Descriptor desc = sstable . descriptor ; SSTableReader target = SSTableReader . open ( desc ) ; Assert . assertEquals ( target . getIndexSummarySize ( ) , <int> ) ; Assert . assertArrayEquals ( ByteBufferUtil . getArray ( firstKey . getKey ( ) ) , target . getIndexSummaryKey ( <int> ) ) ; assert target . first . equals ( firstKey ) ; assert target . last . equals ( lastKey ) ; target . selfRef ( ) . release ( ) ; } @Test public void testLoadingSummaryUsesCorrectPartitioner ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; new RowUpdateBuilder ( store . metadata , System . currentTimeMillis ( ) , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; store . forceBlockingFlush ( ) ; for ( ColumnFamilyStore indexCfs : store . indexManager . getAllIndexColumnFamilyStores ( ) ) { assert indexCfs . isIndex ( ) ; SSTableReader sstable = indexCfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; assert sstable . first . getToken ( ) instanceof LocalToken ; try ( SegmentedFile . Builder ibuilder = SegmentedFile . getBuilder ( DatabaseDescriptor . getIndexAccessMode ( ) , false ) ; SegmentedFile . Builder dbuilder = SegmentedFile . getBuilder ( DatabaseDescriptor . getDiskAccessMode ( ) , sstable . compression ) ) { sstable . saveSummary ( ibuilder , dbuilder ) ; } SSTableReader reopened = SSTableReader . open ( sstable . descriptor ) ; assert reopened . first . getToken ( ) instanceof LocalToken ; reopened . selfRef ( ) . release ( ) ; } } @Test public void testGetScannerForNoIntersectingRanges ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; partitioner = store . getPartitioner ( ) ; new RowUpdateBuilder ( store . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) . applyUnsafe ( ) ; store . forceBlockingFlush ( ) ; boolean foundScanner = false ; for ( SSTableReader s : store . getLiveSSTables ( ) ) { try ( ISSTableScanner scanner = s . getScanner ( new Range < Token > ( t ( <int> ) , t ( <int> ) ) , null ) ) { scanner . next ( ) ; foundScanner = true ; } } assertTrue ( foundScanner ) ; } @Test public void testGetPositionsForRangesFromTableOpenedForBulkLoading ( ) throws IOException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; partitioner = store . getPartitioner ( ) ; CompactionManager . instance . disableAutoCompaction ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { new RowUpdateBuilder ( store . metadata , j , String . valueOf ( j ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; CompactionManager . instance . performMaximal ( store , false ) ; List < Range < Token > > ranges = new ArrayList < Range < Token > > ( ) ; ranges . add ( new Range < Token > ( t ( <int> ) , t ( <int> ) ) ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; List < Pair < Long , Long > > sections = sstable . getPositionsForRanges ( ranges ) ; assert sections . size ( ) = = <int> : <str> ; Set < Component > components = Sets . newHashSet ( Component . DATA , Component . PRIMARY_INDEX ) ; if ( sstable . components . contains ( Component . COMPRESSION_INFO ) ) components . add ( Component . COMPRESSION_INFO ) ; SSTableReader bulkLoaded = SSTableReader . openForBatch ( sstable . descriptor , components , store . metadata ) ; sections = bulkLoaded . getPositionsForRanges ( ranges ) ; assert sections . size ( ) = = <int> : <str> ; bulkLoaded . selfRef ( ) . release ( ) ; } @Test public void testIndexSummaryReplacement ( ) throws IOException , ExecutionException , InterruptedException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; final ColumnFamilyStore store = keyspace . getColumnFamilyStore ( <str> ) ; CompactionManager . instance . disableAutoCompaction ( ) ; final int NUM_PARTITIONS = <int> ; for ( int j = <int> ; j < NUM_PARTITIONS ; j + + ) { new RowUpdateBuilder ( store . metadata , j , String . format ( <str> , j ) ) . clustering ( <str> ) . add ( <str> , String . format ( <str> , j ) ) . build ( ) . applyUnsafe ( ) ; } store . forceBlockingFlush ( ) ; CompactionManager . instance . performMaximal ( store , false ) ; Collection < SSTableReader > sstables = store . getLiveSSTables ( ) ; assert sstables . size ( ) = = <int> ; final SSTableReader sstable = sstables . iterator ( ) . next ( ) ; ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor ( <int> ) ; List < Future > futures = new ArrayList < > ( NUM_PARTITIONS * <int> ) ; for ( int i = <int> ; i < NUM_PARTITIONS ; i + + ) { final ByteBuffer key = ByteBufferUtil . bytes ( String . format ( <str> , i ) ) ; final int index = i ; futures . add ( executor . submit ( new Runnable ( ) { public void run ( ) { Row row = Util . getOnlyRowUnfiltered ( Util . cmd ( store , key ) . build ( ) ) ; assertEquals ( <int> , ByteBufferUtil . compare ( String . format ( <str> , index ) . getBytes ( ) , row . cells ( ) . iterator ( ) . next ( ) . value ( ) ) ) ; } } ) ) ; futures . add ( executor . submit ( new Runnable ( ) { public void run ( ) { Iterable < DecoratedKey > results = store . keySamples ( new Range < > ( sstable . getPartitioner ( ) . getMinimumToken ( ) , sstable . getPartitioner ( ) . getToken ( key ) ) ) ; assertTrue ( results . iterator ( ) . hasNext ( ) ) ; } } ) ) ; } SSTableReader replacement ; try ( LifecycleTransaction txn = store . getTracker ( ) . tryModify ( Arrays . asList ( sstable ) , OperationType . UNKNOWN ) ) { replacement = sstable . cloneWithNewSummarySamplingLevel ( store , <int> ) ; txn . update ( replacement , true ) ; txn . finish ( ) ; } for ( Future future : futures ) future . get ( ) ; assertEquals ( sstable . estimatedKeys ( ) , replacement . estimatedKeys ( ) , <int> ) ; } private void assertIndexQueryWorks ( ColumnFamilyStore indexedCFS ) { assert <str> . equals ( indexedCFS . name ) ; for ( ColumnFamilyStore cfs : indexedCFS . concatWithIndexes ( ) ) clearAndLoad ( cfs ) ; ReadCommand rc = Util . cmd ( indexedCFS ) . fromKeyIncl ( <str> ) . toKeyIncl ( <str> ) . columns ( <str> ) . filterOn ( <str> , Operator . EQ , <int> ) . build ( ) ; Index . Searcher searcher = indexedCFS . indexManager . getBestIndexFor ( rc ) . searcherFor ( rc ) ; assertNotNull ( searcher ) ; try ( ReadExecutionController executionController = ReadExecutionController . forCommand ( rc ) ) { assertEquals ( <int> , Util . size ( UnfilteredPartitionIterators . filter ( searcher . search ( executionController ) , rc . nowInSec ( ) ) ) ) ; } } private List < Range < Token > > makeRanges ( Token left , Token right ) { return Arrays . asList ( new Range < > ( left , right ) ) ; } private DecoratedKey k ( int i ) { return new BufferDecoratedKey ( t ( i ) , ByteBufferUtil . bytes ( String . valueOf ( i ) ) ) ; } } 
