package org . elasticsearch . gateway ; import org . apache . lucene . codecs . CodecUtil ; import org . apache . lucene . index . CorruptIndexException ; import org . apache . lucene . index . IndexFormatTooNewException ; import org . apache . lucene . index . IndexFormatTooOldException ; import org . apache . lucene . store . * ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . lucene . store . IndexOutputOutputStream ; import org . elasticsearch . common . lucene . store . InputStreamIndexInput ; import org . elasticsearch . common . xcontent . * ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . io . OutputStream ; import java . nio . file . * ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . function . Predicate ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . stream . Collectors ; public abstract class MetaDataStateFormat < T > { public static final String STATE_DIR_NAME = <str> ; public static final String STATE_FILE_EXTENSION = <str> ; private static final String STATE_FILE_CODEC = <str> ; private static final int STATE_FILE_VERSION = <int> ; private static final int BUFFER_SIZE = <int> ; private final XContentType format ; private final String prefix ; private final Pattern stateFilePattern ; protected MetaDataStateFormat ( XContentType format , String prefix ) { this . format = format ; this . prefix = prefix ; this . stateFilePattern = Pattern . compile ( Pattern . quote ( prefix ) + <str> + MetaDataStateFormat . STATE_FILE_EXTENSION + <str> ) ; } public XContentType format ( ) { return format ; } public final void write ( final T state , final long version , final Path . . . locations ) throws IOException { if ( locations = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( locations . length < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } final long maxStateId = findMaxStateId ( prefix , locations ) + <int> ; assert maxStateId > = <int> : <str> + maxStateId + <str> ; final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION ; Path stateLocation = locations [ <int> ] . resolve ( STATE_DIR_NAME ) ; Files . createDirectories ( stateLocation ) ; final Path tmpStatePath = stateLocation . resolve ( fileName + <str> ) ; final Path finalStatePath = stateLocation . resolve ( fileName ) ; try { final String resourceDesc = <str> + tmpStatePath + <str> ; try ( OutputStreamIndexOutput out = new OutputStreamIndexOutput ( resourceDesc , Files . newOutputStream ( tmpStatePath ) , BUFFER_SIZE ) ) { CodecUtil . writeHeader ( out , STATE_FILE_CODEC , STATE_FILE_VERSION ) ; out . writeInt ( format . index ( ) ) ; out . writeLong ( version ) ; try ( XContentBuilder builder = newXContentBuilder ( format , new IndexOutputOutputStream ( out ) { @Override public void close ( ) throws IOException { } } ) ) { builder . startObject ( ) ; { toXContent ( builder , state ) ; } builder . endObject ( ) ; } CodecUtil . writeFooter ( out ) ; } IOUtils . fsync ( tmpStatePath , false ) ; Files . move ( tmpStatePath , finalStatePath , StandardCopyOption . ATOMIC_MOVE ) ; IOUtils . fsync ( stateLocation , true ) ; for ( int i = <int> ; i < locations . length ; i + + ) { stateLocation = locations [ i ] . resolve ( STATE_DIR_NAME ) ; Files . createDirectories ( stateLocation ) ; Path tmpPath = stateLocation . resolve ( fileName + <str> ) ; Path finalPath = stateLocation . resolve ( fileName ) ; try { Files . copy ( finalStatePath , tmpPath ) ; Files . move ( tmpPath , finalPath , StandardCopyOption . ATOMIC_MOVE ) ; IOUtils . fsync ( stateLocation , true ) ; } finally { Files . deleteIfExists ( tmpPath ) ; } } } finally { Files . deleteIfExists ( tmpStatePath ) ; } cleanupOldFiles ( prefix , fileName , locations ) ; } protected XContentBuilder newXContentBuilder ( XContentType type , OutputStream stream ) throws IOException { return XContentFactory . contentBuilder ( type , stream ) ; } public abstract void toXContent ( XContentBuilder builder , T state ) throws IOException ; public abstract T fromXContent ( XContentParser parser ) throws IOException ; public final T read ( Path file ) throws IOException { try ( Directory dir = newDirectory ( file . getParent ( ) ) ) { try ( final IndexInput indexInput = dir . openInput ( file . getFileName ( ) . toString ( ) , IOContext . DEFAULT ) ) { CodecUtil . checksumEntireFile ( indexInput ) ; CodecUtil . checkHeader ( indexInput , STATE_FILE_CODEC , STATE_FILE_VERSION , STATE_FILE_VERSION ) ; final XContentType xContentType = XContentType . values ( ) [ indexInput . readInt ( ) ] ; indexInput . readLong ( ) ; long filePointer = indexInput . getFilePointer ( ) ; long contentSize = indexInput . length ( ) - CodecUtil . footerLength ( ) - filePointer ; try ( IndexInput slice = indexInput . slice ( <str> , filePointer , contentSize ) ) { try ( XContentParser parser = XContentFactory . xContent ( xContentType ) . createParser ( new InputStreamIndexInput ( slice , contentSize ) ) ) { return fromXContent ( parser ) ; } } } catch ( CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex ) { throw new CorruptStateException ( ex ) ; } } } protected Directory newDirectory ( Path dir ) throws IOException { return new SimpleFSDirectory ( dir ) ; } private void cleanupOldFiles ( final String prefix , final String currentStateFile , Path [ ] locations ) throws IOException { final DirectoryStream . Filter < Path > filter = new DirectoryStream . Filter < Path > ( ) { @Override public boolean accept ( Path entry ) throws IOException { final String entryFileName = entry . getFileName ( ) . toString ( ) ; return Files . isRegularFile ( entry ) & & entryFileName . startsWith ( prefix ) & & currentStateFile . equals ( entryFileName ) = = false ; } } ; for ( Path dataLocation : locations ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( dataLocation . resolve ( STATE_DIR_NAME ) , filter ) ) { for ( Path stateFile : stream ) { Files . deleteIfExists ( stateFile ) ; } } } } long findMaxStateId ( final String prefix , Path . . . locations ) throws IOException { long maxId = - <int> ; for ( Path dataLocation : locations ) { final Path resolve = dataLocation . resolve ( STATE_DIR_NAME ) ; if ( Files . exists ( resolve ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( resolve , prefix + <str> ) ) { for ( Path stateFile : stream ) { final Matcher matcher = stateFilePattern . matcher ( stateFile . getFileName ( ) . toString ( ) ) ; if ( matcher . matches ( ) ) { final long id = Long . parseLong ( matcher . group ( <int> ) ) ; maxId = Math . max ( maxId , id ) ; } } } } } return maxId ; } public T loadLatestState ( ESLogger logger , Path . . . dataLocations ) throws IOException { List < PathAndStateId > files = new ArrayList < > ( ) ; long maxStateId = - <int> ; boolean maxStateIdIsLegacy = true ; if ( dataLocations ! = null ) { for ( Path dataLocation : dataLocations ) { final Path stateDir = dataLocation . resolve ( STATE_DIR_NAME ) ; try ( DirectoryStream < Path > paths = Files . newDirectoryStream ( stateDir ) ) { for ( Path stateFile : paths ) { final Matcher matcher = stateFilePattern . matcher ( stateFile . getFileName ( ) . toString ( ) ) ; if ( matcher . matches ( ) ) { final long stateId = Long . parseLong ( matcher . group ( <int> ) ) ; maxStateId = Math . max ( maxStateId , stateId ) ; final boolean legacy = MetaDataStateFormat . STATE_FILE_EXTENSION . equals ( matcher . group ( <int> ) ) = = false ; maxStateIdIsLegacy & = legacy ; PathAndStateId pav = new PathAndStateId ( stateFile , stateId , legacy ) ; logger . trace ( <str> , pav ) ; files . add ( pav ) ; } } } catch ( NoSuchFileException | FileNotFoundException ex ) { } } } final List < Throwable > exceptions = new ArrayList < > ( ) ; T state = null ; Collection < PathAndStateId > pathAndStateIds = files . stream ( ) . filter ( new StateIdAndLegacyPredicate ( maxStateId , maxStateIdIsLegacy ) ) . collect ( Collectors . toCollection ( ArrayList : : new ) ) ; for ( PathAndStateId pathAndStateId : pathAndStateIds ) { try { final Path stateFile = pathAndStateId . file ; final long id = pathAndStateId . id ; final XContentParser parser ; if ( pathAndStateId . legacy ) { final byte [ ] data = Files . readAllBytes ( stateFile ) ; if ( data . length = = <int> ) { logger . debug ( <str> , prefix , stateFile . toAbsolutePath ( ) ) ; continue ; } parser = XContentHelper . createParser ( new BytesArray ( data ) ) ; state = fromXContent ( parser ) ; if ( state = = null ) { logger . debug ( <str> , prefix , stateFile . toAbsolutePath ( ) ) ; } } else { state = read ( stateFile ) ; logger . trace ( <str> , id , stateFile . getFileName ( ) ) ; } return state ; } catch ( Throwable e ) { exceptions . add ( e ) ; logger . debug ( <str> , e , pathAndStateId . file . toAbsolutePath ( ) , prefix ) ; } } ExceptionsHelper . maybeThrowRuntimeAndSuppress ( exceptions ) ; if ( files . size ( ) > <int> ) { throw new IllegalStateException ( <str> + files ) ; } return state ; } private static final class StateIdAndLegacyPredicate implements Predicate < PathAndStateId > { private final long id ; private final boolean legacy ; StateIdAndLegacyPredicate ( long id , boolean legacy ) { this . id = id ; this . legacy = legacy ; } @Override public boolean test ( PathAndStateId input ) { return input . id = = id & & input . legacy = = legacy ; } } private static class PathAndStateId { final Path file ; final long id ; final boolean legacy ; private PathAndStateId ( Path file , long id , boolean legacy ) { this . file = file ; this . id = id ; this . legacy = legacy ; } @Override public String toString ( ) { return <str> + id + <str> + legacy + <str> + file . toAbsolutePath ( ) + <str> ; } } public static void deleteMetaState ( Path . . . dataLocations ) throws IOException { Path [ ] stateDirectories = new Path [ dataLocations . length ] ; for ( int i = <int> ; i < dataLocations . length ; i + + ) { stateDirectories [ i ] = dataLocations [ i ] . resolve ( STATE_DIR_NAME ) ; } IOUtils . rm ( stateDirectories ) ; } } 
