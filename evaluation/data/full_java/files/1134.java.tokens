package org . apache . cassandra . tools . nodetool ; import io . airlift . command . Arguments ; import io . airlift . command . Command ; import io . airlift . command . Option ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . text . DecimalFormat ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . SortedMap ; import org . apache . cassandra . locator . EndpointSnitchInfoMBean ; import org . apache . cassandra . tools . NodeProbe ; import org . apache . cassandra . tools . NodeTool ; import org . apache . cassandra . tools . NodeTool . NodeToolCmd ; import com . google . common . collect . ArrayListMultimap ; @Command ( name = <str> , description = <str> ) public class Status extends NodeToolCmd { @Arguments ( usage = <str> , description = <str> ) private String keyspace = null ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean resolveIp = false ; private boolean isTokenPerNode = true ; private int maxAddressLength = <int> ; private String format = null ; private Collection < String > joiningNodes , leavingNodes , movingNodes , liveNodes , unreachableNodes ; private Map < String , String > loadMap , hostIDMap ; private EndpointSnitchInfoMBean epSnitchInfo ; @Override public void execute ( NodeProbe probe ) { joiningNodes = probe . getJoiningNodes ( ) ; leavingNodes = probe . getLeavingNodes ( ) ; movingNodes = probe . getMovingNodes ( ) ; loadMap = probe . getLoadMap ( ) ; Map < String , String > tokensToEndpoints = probe . getTokenToEndpointMap ( ) ; liveNodes = probe . getLiveNodes ( ) ; unreachableNodes = probe . getUnreachableNodes ( ) ; hostIDMap = probe . getHostIdMap ( ) ; epSnitchInfo = probe . getEndpointSnitchInfoProxy ( ) ; StringBuffer errors = new StringBuffer ( ) ; Map < InetAddress , Float > ownerships = null ; boolean hasEffectiveOwns = false ; try { ownerships = probe . effectiveOwnership ( keyspace ) ; hasEffectiveOwns = true ; } catch ( IllegalStateException e ) { ownerships = probe . getOwnership ( ) ; errors . append ( <str> + e . getMessage ( ) + <str> ) ; } catch ( IllegalArgumentException ex ) { System . out . printf ( <str> + ex . getMessage ( ) + <str> ) ; System . exit ( <int> ) ; } SortedMap < String , SetHostStat > dcs = NodeTool . getOwnershipByDc ( probe , resolveIp , tokensToEndpoints , ownerships ) ; if ( dcs . values ( ) . size ( ) < tokensToEndpoints . keySet ( ) . size ( ) ) isTokenPerNode = false ; findMaxAddressLength ( dcs ) ; for ( Map . Entry < String , SetHostStat > dc : dcs . entrySet ( ) ) { String dcHeader = String . format ( <str> , dc . getKey ( ) ) ; System . out . printf ( dcHeader ) ; for ( int i = <int> ; i < ( dcHeader . length ( ) - <int> ) ; i + + ) System . out . print ( <str> ) ; System . out . println ( ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; printNodesHeader ( hasEffectiveOwns , isTokenPerNode ) ; ArrayListMultimap < InetAddress , HostStat > hostToTokens = ArrayListMultimap . create ( ) ; for ( HostStat stat : dc . getValue ( ) ) hostToTokens . put ( stat . endpoint , stat ) ; for ( InetAddress endpoint : hostToTokens . keySet ( ) ) { Float owns = ownerships . get ( endpoint ) ; List < HostStat > tokens = hostToTokens . get ( endpoint ) ; printNode ( endpoint . getHostAddress ( ) , owns , tokens , hasEffectiveOwns , isTokenPerNode ) ; } } System . out . printf ( <str> + errors . toString ( ) ) ; } private void findMaxAddressLength ( Map < String , SetHostStat > dcs ) { maxAddressLength = <int> ; for ( Map . Entry < String , SetHostStat > dc : dcs . entrySet ( ) ) { for ( HostStat stat : dc . getValue ( ) ) { maxAddressLength = Math . max ( maxAddressLength , stat . ipOrDns ( ) . length ( ) ) ; } } } private void printNodesHeader ( boolean hasEffectiveOwns , boolean isTokenPerNode ) { String fmt = getFormat ( hasEffectiveOwns , isTokenPerNode ) ; String owns = hasEffectiveOwns ? <str> : <str> ; if ( isTokenPerNode ) System . out . printf ( fmt , <str> , <str> , <str> , <str> , owns , <str> , <str> , <str> ) ; else System . out . printf ( fmt , <str> , <str> , <str> , <str> , <str> , owns , <str> , <str> ) ; } private void printNode ( String endpoint , Float owns , List < HostStat > tokens , boolean hasEffectiveOwns , boolean isTokenPerNode ) { String status , state , load , strOwns , hostID , rack , fmt ; fmt = getFormat ( hasEffectiveOwns , isTokenPerNode ) ; if ( liveNodes . contains ( endpoint ) ) status = <str> ; else if ( unreachableNodes . contains ( endpoint ) ) status = <str> ; else status = <str> ; if ( joiningNodes . contains ( endpoint ) ) state = <str> ; else if ( leavingNodes . contains ( endpoint ) ) state = <str> ; else if ( movingNodes . contains ( endpoint ) ) state = <str> ; else state = <str> ; load = loadMap . containsKey ( endpoint ) ? loadMap . get ( endpoint ) : <str> ; strOwns = owns ! = null & & hasEffectiveOwns ? new DecimalFormat ( <str> ) . format ( owns ) : <str> ; hostID = hostIDMap . get ( endpoint ) ; try { rack = epSnitchInfo . getRack ( endpoint ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } String endpointDns = tokens . get ( <int> ) . ipOrDns ( ) ; if ( isTokenPerNode ) System . out . printf ( fmt , status , state , endpointDns , load , strOwns , hostID , tokens . get ( <int> ) . token , rack ) ; else System . out . printf ( fmt , status , state , endpointDns , load , tokens . size ( ) , strOwns , hostID , rack ) ; } private String getFormat ( boolean hasEffectiveOwns , boolean isTokenPerNode ) { if ( format = = null ) { StringBuilder buf = new StringBuilder ( ) ; String addressPlaceholder = String . format ( <str> , maxAddressLength ) ; buf . append ( <str> ) ; buf . append ( addressPlaceholder ) ; buf . append ( <str> ) ; if ( ! isTokenPerNode ) buf . append ( <str> ) ; if ( hasEffectiveOwns ) buf . append ( <str> ) ; else buf . append ( <str> ) ; buf . append ( <str> ) ; if ( isTokenPerNode ) buf . append ( <str> ) ; buf . append ( <str> ) ; format = buf . toString ( ) ; } return format ; } } 
