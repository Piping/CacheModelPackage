package org . elasticsearch . common . netty ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . metrics . CounterMetric ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . jboss . netty . channel . * ; import java . util . Set ; @ChannelHandler.Sharable public class OpenChannelsHandler implements ChannelUpstreamHandler { final Set < Channel > openChannels = ConcurrentCollections . newConcurrentSet ( ) ; final CounterMetric openChannelsMetric = new CounterMetric ( ) ; final CounterMetric totalChannelsMetric = new CounterMetric ( ) ; final ESLogger logger ; public OpenChannelsHandler ( ESLogger logger ) { this . logger = logger ; } final ChannelFutureListener remover = new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { boolean removed = openChannels . remove ( future . getChannel ( ) ) ; if ( removed ) { openChannelsMetric . dec ( ) ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , future . getChannel ( ) ) ; } } } ; @Override public void handleUpstream ( ChannelHandlerContext ctx , ChannelEvent e ) throws Exception { if ( e instanceof ChannelStateEvent ) { ChannelStateEvent evt = ( ChannelStateEvent ) e ; if ( evt . getState ( ) = = ChannelState . OPEN & & Boolean . TRUE . equals ( evt . getValue ( ) ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , ctx . getChannel ( ) ) ; } boolean added = openChannels . add ( ctx . getChannel ( ) ) ; if ( added ) { openChannelsMetric . inc ( ) ; totalChannelsMetric . inc ( ) ; ctx . getChannel ( ) . getCloseFuture ( ) . addListener ( remover ) ; } } } ctx . sendUpstream ( e ) ; } public long numberOfOpenChannels ( ) { return openChannelsMetric . count ( ) ; } public long totalChannels ( ) { return totalChannelsMetric . count ( ) ; } public void close ( ) { for ( Channel channel : openChannels ) { channel . close ( ) . awaitUninterruptibly ( ) ; } } } 
