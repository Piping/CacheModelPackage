package org . elasticsearch . common . io ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . common . collect . Iterators ; import org . elasticsearch . common . logging . ESLogger ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . URL ; import java . nio . charset . Charset ; import java . nio . charset . CharsetDecoder ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . Arrays ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . stream . StreamSupport ; import static java . nio . file . FileVisitResult . CONTINUE ; import static java . nio . file . FileVisitResult . SKIP_SUBTREE ; public final class FileSystemUtils { private FileSystemUtils ( ) { } public static boolean hasExtensions ( Path root , final String . . . extensions ) throws IOException { final AtomicBoolean retVal = new AtomicBoolean ( false ) ; Files . walkFileTree ( root , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { for ( String extension : extensions ) { if ( file . getFileName ( ) . toString ( ) . endsWith ( extension ) ) { retVal . set ( true ) ; return FileVisitResult . TERMINATE ; } } return super . visitFile ( file , attrs ) ; } } ) ; return retVal . get ( ) ; } public static boolean exists ( Path . . . files ) { for ( Path file : files ) { if ( Files . exists ( file ) ) { return true ; } } return false ; } public static boolean isHidden ( Path path ) { Path fileName = path . getFileName ( ) ; if ( fileName = = null ) { return false ; } return fileName . toString ( ) . startsWith ( <str> ) ; } public static Path append ( Path base , Path path , int strip ) { for ( Path subPath : path ) { if ( strip - - > <int> ) { continue ; } base = base . resolve ( subPath . toString ( ) ) ; } return base ; } public static void deleteSubDirectories ( Path . . . paths ) throws IOException { for ( Path path : paths ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( path ) ) { for ( Path subPath : stream ) { if ( Files . isDirectory ( subPath ) ) { IOUtils . rm ( subPath ) ; } } } } } public static boolean isAccessibleDirectory ( Path directory , ESLogger logger ) { assert directory ! = null & & logger ! = null ; if ( ! Files . exists ( directory ) ) { logger . debug ( <str> , directory . toAbsolutePath ( ) ) ; return false ; } if ( ! Files . isDirectory ( directory ) ) { logger . debug ( <str> , directory . toAbsolutePath ( ) ) ; return false ; } if ( ! Files . isReadable ( directory ) ) { logger . debug ( <str> , directory . toAbsolutePath ( ) ) ; return false ; } return true ; } public static BufferedReader newBufferedReader ( URL url , Charset cs ) throws IOException { CharsetDecoder decoder = cs . newDecoder ( ) ; Reader reader = new InputStreamReader ( url . openStream ( ) , decoder ) ; return new BufferedReader ( reader ) ; } public static void moveFilesWithoutOverwriting ( Path source , final Path destination , final String suffix ) throws IOException { Files . createDirectories ( destination ) ; final int configPathRootLevel = source . getNameCount ( ) ; Files . walkFileTree ( source , new SimpleFileVisitor < Path > ( ) { private Path buildPath ( Path path ) { return destination . resolve ( path ) ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { if ( configPathRootLevel ! = dir . getNameCount ( ) ) { Path subpath = dir . subpath ( configPathRootLevel , dir . getNameCount ( ) ) ; Path path = buildPath ( subpath ) ; if ( ! Files . exists ( path ) ) { move ( dir , path ) ; return FileVisitResult . SKIP_SUBTREE ; } } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Path subpath = null ; if ( configPathRootLevel ! = file . getNameCount ( ) ) { subpath = file . subpath ( configPathRootLevel , file . getNameCount ( ) ) ; } Path path = buildPath ( subpath ) ; if ( ! Files . exists ( path ) ) { move ( file , path ) ; } else if ( suffix ! = null ) { if ( ! isSameFile ( file , path ) ) { path = path . resolveSibling ( path . getFileName ( ) . toString ( ) . concat ( suffix ) ) ; Files . move ( file , path , StandardCopyOption . REPLACE_EXISTING ) ; } } return FileVisitResult . CONTINUE ; } private boolean isSameFile ( Path first , Path second ) throws IOException { boolean sameFileSize = Files . size ( first ) = = Files . size ( second ) ; if ( ! sameFileSize ) { return false ; } byte [ ] firstBytes = Files . readAllBytes ( first ) ; byte [ ] secondBytes = Files . readAllBytes ( second ) ; return Arrays . equals ( firstBytes , secondBytes ) ; } } ) ; } public static void copyDirectoryRecursively ( Path source , Path destination ) throws IOException { Files . walkFileTree ( source , new TreeCopier ( source , destination , false ) ) ; } public static void move ( Path source , Path destination ) throws IOException { try { Files . move ( source , destination ) ; } catch ( DirectoryNotEmptyException e ) { Files . walkFileTree ( source , new TreeCopier ( source , destination , true ) ) ; } } static class TreeCopier extends SimpleFileVisitor < Path > { private final Path source ; private final Path target ; private final boolean delete ; TreeCopier ( Path source , Path target , boolean delete ) { this . source = source ; this . target = target ; this . delete = delete ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) { Path newDir = target . resolve ( source . relativize ( dir ) ) ; try { Files . copy ( dir , newDir ) ; } catch ( FileAlreadyExistsException x ) { } catch ( IOException x ) { return SKIP_SUBTREE ; } return CONTINUE ; } @Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { if ( delete ) { IOUtils . rm ( dir ) ; } return CONTINUE ; } @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { Path newFile = target . resolve ( source . relativize ( file ) ) ; try { Files . copy ( file , newFile ) ; if ( delete ) { Files . deleteIfExists ( file ) ; } } catch ( IOException x ) { } return CONTINUE ; } } public static Path [ ] files ( Path from , DirectoryStream . Filter < Path > filter ) throws IOException { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( from , filter ) ) { return toArray ( stream ) ; } } public static Path [ ] files ( Path directory ) throws IOException { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( directory ) ) { return toArray ( stream ) ; } } public static Path [ ] files ( Path directory , String glob ) throws IOException { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( directory , glob ) ) { return toArray ( stream ) ; } } private static Path [ ] toArray ( DirectoryStream < Path > stream ) { return StreamSupport . stream ( stream . spliterator ( ) , false ) . toArray ( length - > new Path [ length ] ) ; } } 
