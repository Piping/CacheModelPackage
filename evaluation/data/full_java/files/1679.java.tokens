package org . apache . cassandra . stress ; import java . io . IOException ; import java . io . OutputStream ; import java . io . PrintStream ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import com . google . common . util . concurrent . RateLimiter ; import com . google . common . util . concurrent . Uninterruptibles ; import org . apache . cassandra . stress . operations . OpDistribution ; import org . apache . cassandra . stress . operations . OpDistributionFactory ; import org . apache . cassandra . stress . settings . SettingsCommand ; import org . apache . cassandra . stress . settings . StressSettings ; import org . apache . cassandra . stress . util . JavaDriverClient ; import org . apache . cassandra . stress . util . ThriftClient ; import org . apache . cassandra . transport . SimpleClient ; public class StressAction implements Runnable { private final StressSettings settings ; private final PrintStream output ; public StressAction ( StressSettings settings , PrintStream out ) { this . settings = settings ; output = out ; } public void run ( ) { settings . maybeCreateKeyspaces ( ) ; output . println ( <str> ) ; Uninterruptibles . sleepUninterruptibly ( <int> , TimeUnit . SECONDS ) ; if ( ! settings . command . noWarmup ) warmup ( settings . command . getFactory ( settings ) ) ; if ( settings . command . truncate = = SettingsCommand . TruncateWhen . ONCE ) settings . command . truncateTables ( settings ) ; RateLimiter rateLimiter = null ; if ( settings . rate . opRateTargetPerSecond > <int> ) rateLimiter = RateLimiter . create ( settings . rate . opRateTargetPerSecond ) ; boolean success ; if ( settings . rate . minThreads > <int> ) success = runMulti ( settings . rate . auto , rateLimiter ) ; else success = null ! = run ( settings . command . getFactory ( settings ) , settings . rate . threadCount , settings . command . count , settings . command . duration , rateLimiter , settings . command . durationUnits , output ) ; if ( success ) output . println ( <str> ) ; else output . println ( <str> ) ; settings . disconnect ( ) ; } private void warmup ( OpDistributionFactory operations ) { PrintStream warmupOutput = new PrintStream ( new OutputStream ( ) { @Override public void write ( int b ) throws IOException { } } ) ; int iterations = <int> * settings . node . nodes . size ( ) ; int threads = <int> ; if ( iterations > settings . command . count & & settings . command . count > <int> ) return ; if ( settings . rate . maxThreads > <int> ) threads = Math . min ( threads , settings . rate . maxThreads ) ; if ( settings . rate . threadCount > <int> ) threads = Math . min ( threads , settings . rate . threadCount ) ; for ( OpDistributionFactory single : operations . each ( ) ) { output . println ( String . format ( <str> , single . desc ( ) , iterations ) ) ; run ( single , threads , iterations , <int> , null , null , warmupOutput ) ; } } private boolean runMulti ( boolean auto , RateLimiter rateLimiter ) { if ( settings . command . targetUncertainty > = <int> ) output . println ( <str> ) ; int prevThreadCount = - <int> ; int threadCount = settings . rate . minThreads ; List < StressMetrics > results = new ArrayList < > ( ) ; List < String > runIds = new ArrayList < > ( ) ; do { output . println ( <str> ) ; output . println ( String . format ( <str> , threadCount ) ) ; if ( settings . command . truncate = = SettingsCommand . TruncateWhen . ALWAYS ) settings . command . truncateTables ( settings ) ; StressMetrics result = run ( settings . command . getFactory ( settings ) , threadCount , settings . command . count , settings . command . duration , rateLimiter , settings . command . durationUnits , output ) ; if ( result = = null ) return false ; results . add ( result ) ; if ( prevThreadCount > <int> ) System . out . println ( String . format ( <str> , prevThreadCount , <int> * averageImprovement ( results , <int> ) ) ) ; runIds . add ( threadCount + <str> ) ; prevThreadCount = threadCount ; if ( threadCount < <int> ) threadCount * = <int> ; else threadCount * = <float> ; if ( ! results . isEmpty ( ) & & threadCount > settings . rate . maxThreads ) break ; if ( settings . command . type . updates ) { output . println ( <str> ) ; try { Thread . sleep ( <int> * <int> ) ; } catch ( InterruptedException e ) { return false ; } } } while ( ! auto | | ( hasAverageImprovement ( results , <int> , <int> ) & & hasAverageImprovement ( results , <int> , settings . command . targetUncertainty ) ) ) ; StressMetrics . summarise ( runIds , results , output , settings . samples . historyCount ) ; return true ; } private boolean hasAverageImprovement ( List < StressMetrics > results , int count , double minImprovement ) { return results . size ( ) < count + <int> | | averageImprovement ( results , count ) > = minImprovement ; } private double averageImprovement ( List < StressMetrics > results , int count ) { double improvement = <int> ; for ( int i = results . size ( ) - count ; i < results . size ( ) ; i + + ) { double prev = results . get ( i - <int> ) . getTiming ( ) . getHistory ( ) . opRate ( ) ; double cur = results . get ( i ) . getTiming ( ) . getHistory ( ) . opRate ( ) ; improvement + = ( cur - prev ) / prev ; } return improvement / count ; } private StressMetrics run ( OpDistributionFactory operations , int threadCount , long opCount , long duration , RateLimiter rateLimiter , TimeUnit durationUnits , PrintStream output ) { output . println ( String . format ( <str> , operations . desc ( ) , threadCount , durationUnits ! = null ? duration + <str> + durationUnits . toString ( ) . toLowerCase ( ) : opCount > <int> ? <str> + opCount + <str> : <str> + settings . command . targetUncertainty ) ) ; final WorkManager workManager ; if ( opCount < <int> ) workManager = new WorkManager . ContinuousWorkManager ( ) ; else workManager = new WorkManager . FixedWorkManager ( opCount ) ; final StressMetrics metrics = new StressMetrics ( output , settings . log . intervalMillis , settings ) ; final CountDownLatch done = new CountDownLatch ( threadCount ) ; final Consumer [ ] consumers = new Consumer [ threadCount ] ; for ( int i = <int> ; i < threadCount ; i + + ) { consumers [ i ] = new Consumer ( operations , done , workManager , metrics , rateLimiter , settings . samples . liveCount / threadCount ) ; } for ( int i = <int> ; i < threadCount ; i + + ) consumers [ i ] . start ( ) ; metrics . start ( ) ; if ( durationUnits ! = null ) { Uninterruptibles . sleepUninterruptibly ( duration , durationUnits ) ; workManager . stop ( ) ; } else if ( opCount < = <int> ) { try { metrics . waitUntilConverges ( settings . command . targetUncertainty , settings . command . minimumUncertaintyMeasurements , settings . command . maximumUncertaintyMeasurements ) ; } catch ( InterruptedException e ) { } workManager . stop ( ) ; } try { done . await ( ) ; metrics . stop ( ) ; } catch ( InterruptedException e ) { } if ( metrics . wasCancelled ( ) ) return null ; metrics . summarise ( ) ; boolean success = true ; for ( Consumer consumer : consumers ) success & = consumer . success ; if ( ! success ) return null ; return metrics ; } private class Consumer extends Thread { private final OpDistribution operations ; private final StressMetrics metrics ; private final RateLimiter rateLimiter ; private volatile boolean success = true ; private final WorkManager workManager ; private final CountDownLatch done ; public Consumer ( OpDistributionFactory operations , CountDownLatch done , WorkManager workManager , StressMetrics metrics , RateLimiter rateLimiter , int sampleCount ) { this . done = done ; this . rateLimiter = rateLimiter ; this . workManager = workManager ; this . metrics = metrics ; this . operations = operations . get ( metrics . getTiming ( ) , sampleCount ) ; } public void run ( ) { operations . initTimers ( ) ; try { SimpleClient sclient = null ; ThriftClient tclient = null ; JavaDriverClient jclient = null ; switch ( settings . mode . api ) { case JAVA_DRIVER_NATIVE : jclient = settings . getJavaDriverClient ( ) ; break ; case SIMPLE_NATIVE : sclient = settings . getSimpleNativeClient ( ) ; break ; case THRIFT : case THRIFT_SMART : tclient = settings . getThriftClient ( ) ; break ; default : throw new IllegalStateException ( ) ; } while ( true ) { Operation op = operations . next ( ) ; if ( ! op . ready ( workManager , rateLimiter ) ) break ; try { switch ( settings . mode . api ) { case JAVA_DRIVER_NATIVE : op . run ( jclient ) ; break ; case SIMPLE_NATIVE : op . run ( sclient ) ; break ; case THRIFT : case THRIFT_SMART : default : op . run ( tclient ) ; } } catch ( Exception e ) { if ( output = = null ) { System . err . println ( e . getMessage ( ) ) ; success = false ; System . exit ( - <int> ) ; } e . printStackTrace ( output ) ; success = false ; workManager . stop ( ) ; metrics . cancel ( ) ; return ; } } } finally { done . countDown ( ) ; operations . closeTimers ( ) ; } } } } 
