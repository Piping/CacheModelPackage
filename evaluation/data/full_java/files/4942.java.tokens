package org . elasticsearch . action . admin . cluster . health ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . action . support . master . TransportMasterNodeReadAction ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . health . ClusterHealthStatus ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . routing . UnassignedInfo ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . gateway . GatewayAllocator ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; public class TransportClusterHealthAction extends TransportMasterNodeReadAction < ClusterHealthRequest , ClusterHealthResponse > { private final ClusterName clusterName ; private final GatewayAllocator gatewayAllocator ; @Inject public TransportClusterHealthAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , ClusterName clusterName , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , GatewayAllocator gatewayAllocator ) { super ( settings , ClusterHealthAction . NAME , transportService , clusterService , threadPool , actionFilters , indexNameExpressionResolver , ClusterHealthRequest : : new ) ; this . clusterName = clusterName ; this . gatewayAllocator = gatewayAllocator ; } @Override protected String executor ( ) { return ThreadPool . Names . SAME ; } @Override protected ClusterBlockException checkBlock ( ClusterHealthRequest request , ClusterState state ) { return null ; } @Override protected ClusterHealthResponse newResponse ( ) { return new ClusterHealthResponse ( ) ; } @Override protected void masterOperation ( final ClusterHealthRequest request , final ClusterState unusedState , final ActionListener < ClusterHealthResponse > listener ) { if ( request . waitForEvents ( ) ! = null ) { final long endTimeMS = TimeValue . nsecToMSec ( System . nanoTime ( ) ) + request . timeout ( ) . millis ( ) ; clusterService . submitStateUpdateTask ( <str> + request . waitForEvents ( ) + <str> , new ClusterStateUpdateTask ( request . waitForEvents ( ) ) { @Override public ClusterState execute ( ClusterState currentState ) { return currentState ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { final long timeoutInMillis = Math . max ( <int> , endTimeMS - TimeValue . nsecToMSec ( System . nanoTime ( ) ) ) ; final TimeValue newTimeout = TimeValue . timeValueMillis ( timeoutInMillis ) ; request . timeout ( newTimeout ) ; executeHealth ( request , listener ) ; } @Override public void onNoLongerMaster ( String source ) { logger . trace ( <str> , request . waitForEvents ( ) ) ; doExecute ( request , listener ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; listener . onFailure ( t ) ; } @Override public boolean runOnlyOnMaster ( ) { return ! request . local ( ) ; } } ) ; } else { executeHealth ( request , listener ) ; } } private void executeHealth ( final ClusterHealthRequest request , final ActionListener < ClusterHealthResponse > listener ) { int waitFor = <int> ; if ( request . waitForStatus ( ) = = null ) { waitFor - - ; } if ( request . waitForRelocatingShards ( ) = = - <int> ) { waitFor - - ; } if ( request . waitForActiveShards ( ) = = - <int> ) { waitFor - - ; } if ( request . waitForNodes ( ) . isEmpty ( ) ) { waitFor - - ; } if ( request . indices ( ) = = null | | request . indices ( ) . length = = <int> ) { waitFor - - ; } assert waitFor > = <int> ; final ClusterStateObserver observer = new ClusterStateObserver ( clusterService , logger ) ; final ClusterState state = observer . observedState ( ) ; if ( waitFor = = <int> | | request . timeout ( ) . millis ( ) = = <int> ) { listener . onResponse ( getResponse ( request , state , waitFor , request . timeout ( ) . millis ( ) = = <int> ) ) ; return ; } final int concreteWaitFor = waitFor ; final ClusterStateObserver . ChangePredicate validationPredicate = new ClusterStateObserver . ValidationPredicate ( ) { @Override protected boolean validate ( ClusterState newState ) { return newState . status ( ) = = ClusterState . ClusterStateStatus . APPLIED & & validateRequest ( request , newState , concreteWaitFor ) ; } } ; final ClusterStateObserver . Listener stateListener = new ClusterStateObserver . Listener ( ) { @Override public void onNewClusterState ( ClusterState clusterState ) { listener . onResponse ( getResponse ( request , clusterState , concreteWaitFor , false ) ) ; } @Override public void onClusterServiceClose ( ) { listener . onFailure ( new IllegalStateException ( <str> ) ) ; } @Override public void onTimeout ( TimeValue timeout ) { final ClusterState clusterState = clusterService . state ( ) ; final ClusterHealthResponse response = getResponse ( request , clusterState , concreteWaitFor , true ) ; listener . onResponse ( response ) ; } } ; if ( state . status ( ) = = ClusterState . ClusterStateStatus . APPLIED & & validateRequest ( request , state , concreteWaitFor ) ) { stateListener . onNewClusterState ( state ) ; } else { observer . waitForNextChange ( stateListener , validationPredicate , request . timeout ( ) ) ; } } private boolean validateRequest ( final ClusterHealthRequest request , ClusterState clusterState , final int waitFor ) { ClusterHealthResponse response = clusterHealth ( request , clusterState , clusterService . numberOfPendingTasks ( ) , gatewayAllocator . getNumberOfInFlightFetch ( ) , clusterService . getMaxTaskWaitTime ( ) ) ; return prepareResponse ( request , response , clusterState , waitFor ) ; } private ClusterHealthResponse getResponse ( final ClusterHealthRequest request , ClusterState clusterState , final int waitFor , boolean timedOut ) { ClusterHealthResponse response = clusterHealth ( request , clusterState , clusterService . numberOfPendingTasks ( ) , gatewayAllocator . getNumberOfInFlightFetch ( ) , clusterService . getMaxTaskWaitTime ( ) ) ; boolean valid = prepareResponse ( request , response , clusterState , waitFor ) ; assert valid | | timedOut ; response . setTimedOut ( timedOut & & valid = = false ) ; return response ; } private boolean prepareResponse ( final ClusterHealthRequest request , final ClusterHealthResponse response , ClusterState clusterState , final int waitFor ) { int waitForCounter = <int> ; if ( request . waitForStatus ( ) ! = null & & response . getStatus ( ) . value ( ) < = request . waitForStatus ( ) . value ( ) ) { waitForCounter + + ; } if ( request . waitForRelocatingShards ( ) ! = - <int> & & response . getRelocatingShards ( ) < = request . waitForRelocatingShards ( ) ) { waitForCounter + + ; } if ( request . waitForActiveShards ( ) ! = - <int> & & response . getActiveShards ( ) > = request . waitForActiveShards ( ) ) { waitForCounter + + ; } if ( request . indices ( ) ! = null & & request . indices ( ) . length > <int> ) { try { indexNameExpressionResolver . concreteIndices ( clusterState , IndicesOptions . strictExpand ( ) , request . indices ( ) ) ; waitForCounter + + ; } catch ( IndexNotFoundException e ) { response . setStatus ( ClusterHealthStatus . RED ) ; } } if ( ! request . waitForNodes ( ) . isEmpty ( ) ) { if ( request . waitForNodes ( ) . startsWith ( <str> ) ) { int expected = Integer . parseInt ( request . waitForNodes ( ) . substring ( <int> ) ) ; if ( response . getNumberOfNodes ( ) > = expected ) { waitForCounter + + ; } } else if ( request . waitForNodes ( ) . startsWith ( <str> ) ) { int expected = Integer . parseInt ( request . waitForNodes ( ) . substring ( <int> , request . waitForNodes ( ) . length ( ) - <int> ) ) ; if ( response . getNumberOfNodes ( ) > = expected ) { waitForCounter + + ; } } else if ( request . waitForNodes ( ) . startsWith ( <str> ) ) { int expected = Integer . parseInt ( request . waitForNodes ( ) . substring ( <int> ) ) ; if ( response . getNumberOfNodes ( ) < = expected ) { waitForCounter + + ; } } else if ( request . waitForNodes ( ) . startsWith ( <str> ) ) { int expected = Integer . parseInt ( request . waitForNodes ( ) . substring ( <int> , request . waitForNodes ( ) . length ( ) - <int> ) ) ; if ( response . getNumberOfNodes ( ) < = expected ) { waitForCounter + + ; } } else if ( request . waitForNodes ( ) . startsWith ( <str> ) ) { int expected = Integer . parseInt ( request . waitForNodes ( ) . substring ( <int> ) ) ; if ( response . getNumberOfNodes ( ) > expected ) { waitForCounter + + ; } } else if ( request . waitForNodes ( ) . startsWith ( <str> ) ) { int expected = Integer . parseInt ( request . waitForNodes ( ) . substring ( <int> , request . waitForNodes ( ) . length ( ) - <int> ) ) ; if ( response . getNumberOfNodes ( ) > expected ) { waitForCounter + + ; } } else if ( request . waitForNodes ( ) . startsWith ( <str> ) ) { int expected = Integer . parseInt ( request . waitForNodes ( ) . substring ( <int> ) ) ; if ( response . getNumberOfNodes ( ) < expected ) { waitForCounter + + ; } } else if ( request . waitForNodes ( ) . startsWith ( <str> ) ) { int expected = Integer . parseInt ( request . waitForNodes ( ) . substring ( <int> , request . waitForNodes ( ) . length ( ) - <int> ) ) ; if ( response . getNumberOfNodes ( ) < expected ) { waitForCounter + + ; } } else { int expected = Integer . parseInt ( request . waitForNodes ( ) ) ; if ( response . getNumberOfNodes ( ) = = expected ) { waitForCounter + + ; } } } return waitForCounter = = waitFor ; } private ClusterHealthResponse clusterHealth ( ClusterHealthRequest request , ClusterState clusterState , int numberOfPendingTasks , int numberOfInFlightFetch , TimeValue pendingTaskTimeInQueue ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , clusterState . version ( ) ) ; } String [ ] concreteIndices ; try { concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , request ) ; } catch ( IndexNotFoundException e ) { ClusterHealthResponse response = new ClusterHealthResponse ( clusterName . value ( ) , Strings . EMPTY_ARRAY , clusterState , numberOfPendingTasks , numberOfInFlightFetch , UnassignedInfo . getNumberOfDelayedUnassigned ( clusterState ) , pendingTaskTimeInQueue ) ; response . setStatus ( ClusterHealthStatus . RED ) ; return response ; } return new ClusterHealthResponse ( clusterName . value ( ) , concreteIndices , clusterState , numberOfPendingTasks , numberOfInFlightFetch , UnassignedInfo . getNumberOfDelayedUnassigned ( clusterState ) , pendingTaskTimeInQueue ) ; } } 
