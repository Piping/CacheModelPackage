package com . badlogic . gdx . utils . compression . rangecoder ; import java . io . IOException ; public class Encoder { static final int kTopMask = ~ ( ( <int> < < <int> ) - <int> ) ; static final int kNumBitModelTotalBits = <int> ; static final int kBitModelTotal = ( <int> < < kNumBitModelTotalBits ) ; static final int kNumMoveBits = <int> ; java . io . OutputStream Stream ; long Low ; int Range ; int _cacheSize ; int _cache ; long _position ; public void SetStream ( java . io . OutputStream stream ) { Stream = stream ; } public void ReleaseStream ( ) { Stream = null ; } public void Init ( ) { _position = <int> ; Low = <int> ; Range = - <int> ; _cacheSize = <int> ; _cache = <int> ; } public void FlushData ( ) throws IOException { for ( int i = <int> ; i < <int> ; i + + ) ShiftLow ( ) ; } public void FlushStream ( ) throws IOException { Stream . flush ( ) ; } public void ShiftLow ( ) throws IOException { int LowHi = ( int ) ( Low > > > <int> ) ; if ( LowHi ! = <int> | | Low < <hex> ) { _position + = _cacheSize ; int temp = _cache ; do { Stream . write ( temp + LowHi ) ; temp = <hex> ; } while ( - - _cacheSize ! = <int> ) ; _cache = ( ( ( int ) Low ) > > > <int> ) ; } _cacheSize + + ; Low = ( Low & <hex> ) < < <int> ; } public void EncodeDirectBits ( int v , int numTotalBits ) throws IOException { for ( int i = numTotalBits - <int> ; i > = <int> ; i - - ) { Range > > > = <int> ; if ( ( ( v > > > i ) & <int> ) = = <int> ) Low + = Range ; if ( ( Range & Encoder . kTopMask ) = = <int> ) { Range < < = <int> ; ShiftLow ( ) ; } } } public long GetProcessedSizeAdd ( ) { return _cacheSize + _position + <int> ; } static final int kNumMoveReducingBits = <int> ; public static final int kNumBitPriceShiftBits = <int> ; public static void InitBitModels ( short [ ] probs ) { for ( int i = <int> ; i < probs . length ; i + + ) probs [ i ] = ( kBitModelTotal > > > <int> ) ; } public void Encode ( short [ ] probs , int index , int symbol ) throws IOException { int prob = probs [ index ] ; int newBound = ( Range > > > kNumBitModelTotalBits ) * prob ; if ( symbol = = <int> ) { Range = newBound ; probs [ index ] = ( short ) ( prob + ( ( kBitModelTotal - prob ) > > > kNumMoveBits ) ) ; } else { Low + = ( newBound & <hex> ) ; Range - = newBound ; probs [ index ] = ( short ) ( prob - ( ( prob ) > > > kNumMoveBits ) ) ; } if ( ( Range & kTopMask ) = = <int> ) { Range < < = <int> ; ShiftLow ( ) ; } } private static int [ ] ProbPrices = new int [ kBitModelTotal > > > kNumMoveReducingBits ] ; static { int kNumBits = ( kNumBitModelTotalBits - kNumMoveReducingBits ) ; for ( int i = kNumBits - <int> ; i > = <int> ; i - - ) { int start = <int> < < ( kNumBits - i - <int> ) ; int end = <int> < < ( kNumBits - i ) ; for ( int j = start ; j < end ; j + + ) ProbPrices [ j ] = ( i < < kNumBitPriceShiftBits ) + ( ( ( end - j ) < < kNumBitPriceShiftBits ) > > > ( kNumBits - i - <int> ) ) ; } } static public int GetPrice ( int Prob , int symbol ) { return ProbPrices [ ( ( ( Prob - symbol ) ^ ( ( - symbol ) ) ) & ( kBitModelTotal - <int> ) ) > > > kNumMoveReducingBits ] ; } static public int GetPrice0 ( int Prob ) { return ProbPrices [ Prob > > > kNumMoveReducingBits ] ; } static public int GetPrice1 ( int Prob ) { return ProbPrices [ ( kBitModelTotal - Prob ) > > > kNumMoveReducingBits ] ; } } 
