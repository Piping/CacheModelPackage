package org . elasticsearch . rest . action . get ; import org . elasticsearch . action . get . GetRequest ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestActions ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import org . elasticsearch . search . fetch . source . FetchSourceContext ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestStatus . NOT_FOUND ; import static org . elasticsearch . rest . RestStatus . OK ; public class RestGetAction extends BaseRestHandler { @Inject public RestGetAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final GetRequest getRequest = new GetRequest ( request . param ( <str> ) , request . param ( <str> ) , request . param ( <str> ) ) ; getRequest . operationThreaded ( true ) ; getRequest . refresh ( request . paramAsBoolean ( <str> , getRequest . refresh ( ) ) ) ; getRequest . routing ( request . param ( <str> ) ) ; getRequest . parent ( request . param ( <str> ) ) ; getRequest . preference ( request . param ( <str> ) ) ; getRequest . realtime ( request . paramAsBoolean ( <str> , null ) ) ; getRequest . ignoreErrorsOnGeneratedFields ( request . paramAsBoolean ( <str> , false ) ) ; String sField = request . param ( <str> ) ; if ( sField ! = null ) { String [ ] sFields = Strings . splitStringByCommaToArray ( sField ) ; if ( sFields ! = null ) { getRequest . fields ( sFields ) ; } } getRequest . version ( RestActions . parseVersion ( request ) ) ; getRequest . versionType ( VersionType . fromString ( request . param ( <str> ) , getRequest . versionType ( ) ) ) ; getRequest . fetchSourceContext ( FetchSourceContext . parseFromRestRequest ( request ) ) ; client . get ( getRequest , new RestBuilderListener < GetResponse > ( channel ) { @Override public RestResponse buildResponse ( GetResponse response , XContentBuilder builder ) throws Exception { builder . startObject ( ) ; response . toXContent ( builder , request ) ; builder . endObject ( ) ; if ( ! response . isExists ( ) ) { return new BytesRestResponse ( NOT_FOUND , builder ) ; } else { return new BytesRestResponse ( OK , builder ) ; } } } ) ; } } 
