package com . badlogic . gdx . tools . hiero ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . IntIntMap ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . EOFException ; import java . io . IOException ; import java . io . InputStream ; class Kerning { private TTFInputStream input ; private float scale ; private int headOffset = - <int> ; private int kernOffset = - <int> ; private int gposOffset = - <int> ; private IntIntMap kernings = new IntIntMap ( ) ; public void load ( InputStream inputStream , int fontSize ) throws IOException { if ( inputStream = = null ) throw new IllegalArgumentException ( <str> ) ; input = new TTFInputStream ( inputStream ) ; inputStream . close ( ) ; readTableDirectory ( ) ; if ( headOffset = = - <int> ) throw new IOException ( <str> ) ; readHEAD ( fontSize ) ; if ( gposOffset ! = - <int> ) { input . seek ( gposOffset ) ; readGPOS ( ) ; } if ( kernOffset ! = - <int> ) { input . seek ( kernOffset ) ; readKERN ( ) ; } input . close ( ) ; input = null ; } public IntIntMap getKernings ( ) { return kernings ; } private void storeKerningOffset ( int firstGlyphCode , int secondGlyphCode , int offset ) { int value = Math . round ( offset * scale ) ; if ( value = = <int> ) { return ; } int key = ( firstGlyphCode < < <int> ) | secondGlyphCode ; kernings . put ( key , value ) ; } private void readTableDirectory ( ) throws IOException { input . skip ( <int> ) ; int tableCount = input . readUnsignedShort ( ) ; input . skip ( <int> ) ; byte [ ] tagBytes = new byte [ <int> ] ; for ( int i = <int> ; i < tableCount ; i + + ) { tagBytes [ <int> ] = input . readByte ( ) ; tagBytes [ <int> ] = input . readByte ( ) ; tagBytes [ <int> ] = input . readByte ( ) ; tagBytes [ <int> ] = input . readByte ( ) ; input . skip ( <int> ) ; int offset = ( int ) input . readUnsignedLong ( ) ; input . skip ( <int> ) ; String tag = new String ( tagBytes , <str> ) ; if ( tag . equals ( <str> ) ) { headOffset = offset ; } else if ( tag . equals ( <str> ) ) { kernOffset = offset ; } else if ( tag . equals ( <str> ) ) { gposOffset = offset ; } } } private void readHEAD ( int fontSize ) throws IOException { input . seek ( headOffset + <int> * <int> + <int> * <int> + <int> ) ; int unitsPerEm = input . readUnsignedShort ( ) ; scale = ( float ) fontSize / unitsPerEm ; } private void readKERN ( ) throws IOException { input . seek ( kernOffset + <int> ) ; for ( int subTableCount = input . readUnsignedShort ( ) ; subTableCount > <int> ; subTableCount - - ) { input . skip ( <int> * <int> ) ; int tupleIndex = input . readUnsignedShort ( ) ; if ( ! ( ( tupleIndex & <int> ) ! = <int> ) | | ( tupleIndex & <int> ) ! = <int> | | ( tupleIndex & <int> ) ! = <int> ) return ; if ( tupleIndex > > <int> ! = <int> ) continue ; int kerningCount = input . readUnsignedShort ( ) ; input . skip ( <int> * <int> ) ; while ( kerningCount - - > <int> ) { int firstGlyphCode = input . readUnsignedShort ( ) ; int secondGlyphCode = input . readUnsignedShort ( ) ; int offset = ( int ) input . readShort ( ) ; storeKerningOffset ( firstGlyphCode , secondGlyphCode , offset ) ; } } } private void readGPOS ( ) throws IOException { input . seek ( gposOffset + <int> + <int> + <int> ) ; int lookupListOffset = input . readUnsignedShort ( ) ; input . seek ( gposOffset + lookupListOffset ) ; int lookupListPosition = input . getPosition ( ) ; int lookupCount = input . readUnsignedShort ( ) ; int [ ] lookupOffsets = input . readUnsignedShortArray ( lookupCount ) ; for ( int i = <int> ; i < lookupCount ; i + + ) { int lookupPosition = lookupListPosition + lookupOffsets [ i ] ; input . seek ( lookupPosition ) ; int type = input . readUnsignedShort ( ) ; if ( type = = <int> ) { readPairAdjustments ( lookupPosition ) ; } } } private void readPairAdjustments ( int lookupPosition ) throws IOException { input . skip ( <int> ) ; int subTableCount = input . readUnsignedShort ( ) ; int [ ] subTableOffsets = input . readUnsignedShortArray ( subTableCount ) ; for ( int i = <int> ; i < subTableCount ; i + + ) { int subTablePosition = lookupPosition + subTableOffsets [ i ] ; input . seek ( ( int ) subTablePosition ) ; int type = input . readUnsignedShort ( ) ; if ( type = = <int> ) { readPairPositioningAdjustmentFormat1 ( subTablePosition ) ; } else if ( type = = <int> ) { readPairPositioningAdjustmentFormat2 ( subTablePosition ) ; } } } private void readPairPositioningAdjustmentFormat1 ( long subTablePosition ) throws IOException { int coverageOffset = input . readUnsignedShort ( ) ; int valueFormat1 = input . readUnsignedShort ( ) ; int valueFormat2 = input . readUnsignedShort ( ) ; int pairSetCount = input . readUnsignedShort ( ) ; int [ ] pairSetOffsets = input . readUnsignedShortArray ( pairSetCount ) ; input . seek ( ( int ) ( subTablePosition + coverageOffset ) ) ; int [ ] coverage = readCoverageTable ( ) ; pairSetCount = Math . min ( pairSetCount , coverage . length ) ; for ( int i = <int> ; i < pairSetCount ; i + + ) { int firstGlyph = coverage [ i ] ; input . seek ( ( int ) ( subTablePosition + pairSetOffsets [ i ] ) ) ; int pairValueCount = input . readUnsignedShort ( ) ; for ( int j = <int> ; j < pairValueCount ; j + + ) { int secondGlyph = input . readUnsignedShort ( ) ; int xAdvance1 = readXAdvanceFromValueRecord ( valueFormat1 ) ; readXAdvanceFromValueRecord ( valueFormat2 ) ; if ( xAdvance1 ! = <int> ) { storeKerningOffset ( firstGlyph , secondGlyph , xAdvance1 ) ; } } } } private void readPairPositioningAdjustmentFormat2 ( int subTablePosition ) throws IOException { int coverageOffset = input . readUnsignedShort ( ) ; int valueFormat1 = input . readUnsignedShort ( ) ; int valueFormat2 = input . readUnsignedShort ( ) ; int classDefOffset1 = input . readUnsignedShort ( ) ; int classDefOffset2 = input . readUnsignedShort ( ) ; int class1Count = input . readUnsignedShort ( ) ; int class2Count = input . readUnsignedShort ( ) ; int position = input . getPosition ( ) ; IntArray [ ] glyphsByClass1 = readClassDefinition ( subTablePosition + classDefOffset1 , class1Count ) ; IntArray [ ] glyphsByClass2 = readClassDefinition ( subTablePosition + classDefOffset2 , class2Count ) ; input . seek ( position ) ; for ( int i = <int> ; i < class1Count ; i + + ) { for ( int j = <int> ; j < class2Count ; j + + ) { int xAdvance1 = readXAdvanceFromValueRecord ( valueFormat1 ) ; readXAdvanceFromValueRecord ( valueFormat2 ) ; if ( xAdvance1 = = <int> ) continue ; for ( int k = <int> ; k < glyphsByClass1 [ i ] . size ; k + + ) { int glyph1 = glyphsByClass1 [ i ] . items [ k ] ; for ( int l = <int> ; l < glyphsByClass2 [ j ] . size ; l + + ) { int glyph2 = glyphsByClass2 [ j ] . items [ l ] ; storeKerningOffset ( glyph1 , glyph2 , xAdvance1 ) ; } } } } } private IntArray [ ] readClassDefinition ( int position , int classCount ) throws IOException { input . seek ( position ) ; IntArray [ ] glyphsByClass = new IntArray [ classCount ] ; for ( int i = <int> ; i < classCount ; i + + ) { glyphsByClass [ i ] = new IntArray ( ) ; } int classFormat = input . readUnsignedShort ( ) ; if ( classFormat = = <int> ) { readClassDefinitionFormat1 ( glyphsByClass ) ; } else if ( classFormat = = <int> ) { readClassDefinitionFormat2 ( glyphsByClass ) ; } else { throw new IOException ( <str> + classFormat ) ; } return glyphsByClass ; } private void readClassDefinitionFormat1 ( IntArray [ ] glyphsByClass ) throws IOException { int startGlyph = input . readUnsignedShort ( ) ; int glyphCount = input . readUnsignedShort ( ) ; int [ ] classValueArray = input . readUnsignedShortArray ( glyphCount ) ; for ( int i = <int> ; i < glyphCount ; i + + ) { int glyph = startGlyph + i ; int glyphClass = classValueArray [ i ] ; if ( glyphClass < glyphsByClass . length ) { glyphsByClass [ glyphClass ] . add ( glyph ) ; } } } private void readClassDefinitionFormat2 ( IntArray [ ] glyphsByClass ) throws IOException { int classRangeCount = input . readUnsignedShort ( ) ; for ( int i = <int> ; i < classRangeCount ; i + + ) { int start = input . readUnsignedShort ( ) ; int end = input . readUnsignedShort ( ) ; int glyphClass = input . readUnsignedShort ( ) ; if ( glyphClass < glyphsByClass . length ) { for ( int glyph = start ; glyph < = end ; glyph + + ) { glyphsByClass [ glyphClass ] . add ( glyph ) ; } } } } private int [ ] readCoverageTable ( ) throws IOException { int format = input . readUnsignedShort ( ) ; if ( format = = <int> ) { int glyphCount = input . readUnsignedShort ( ) ; int [ ] glyphArray = input . readUnsignedShortArray ( glyphCount ) ; return glyphArray ; } else if ( format = = <int> ) { int rangeCount = input . readUnsignedShort ( ) ; IntArray glyphArray = new IntArray ( ) ; for ( int i = <int> ; i < rangeCount ; i + + ) { int start = input . readUnsignedShort ( ) ; int end = input . readUnsignedShort ( ) ; input . skip ( <int> ) ; for ( int glyph = start ; glyph < = end ; glyph + + ) { glyphArray . add ( glyph ) ; } } return glyphArray . shrink ( ) ; } throw new IOException ( <str> + format ) ; } private int readXAdvanceFromValueRecord ( int valueFormat ) throws IOException { int xAdvance = <int> ; for ( int mask = <int> ; mask < = <hex> & & mask < = valueFormat ; mask < < = <int> ) { if ( ( valueFormat & mask ) ! = <int> ) { int value = ( int ) input . readShort ( ) ; if ( mask = = <hex> ) { xAdvance = value ; } } } return xAdvance ; } private static class TTFInputStream extends ByteArrayInputStream { public TTFInputStream ( InputStream input ) throws IOException { super ( readAllBytes ( input ) ) ; } private static byte [ ] readAllBytes ( InputStream input ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; int numRead ; byte [ ] buffer = new byte [ <int> ] ; while ( ( numRead = input . read ( buffer , <int> , buffer . length ) ) ! = - <int> ) { out . write ( buffer , <int> , numRead ) ; } return out . toByteArray ( ) ; } public int getPosition ( ) { return pos ; } public void seek ( int position ) { pos = position ; } public int readUnsignedByte ( ) throws IOException { int b = read ( ) ; if ( b = = - <int> ) throw new EOFException ( <str> ) ; return b ; } public byte readByte ( ) throws IOException { return ( byte ) readUnsignedByte ( ) ; } public int readUnsignedShort ( ) throws IOException { return ( readUnsignedByte ( ) < < <int> ) + readUnsignedByte ( ) ; } public short readShort ( ) throws IOException { return ( short ) readUnsignedShort ( ) ; } public long readUnsignedLong ( ) throws IOException { long value = readUnsignedByte ( ) ; value = ( value < < <int> ) + readUnsignedByte ( ) ; value = ( value < < <int> ) + readUnsignedByte ( ) ; value = ( value < < <int> ) + readUnsignedByte ( ) ; return value ; } public int [ ] readUnsignedShortArray ( int count ) throws IOException { int [ ] shorts = new int [ count ] ; for ( int i = <int> ; i < count ; i + + ) { shorts [ i ] = readUnsignedShort ( ) ; } return shorts ; } } } 
