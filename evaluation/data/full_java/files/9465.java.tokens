package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import static com . google . common . math . DoubleUtils . ensureNonNegative ; import static com . google . common . math . StatsAccumulator . calculateNewMeanNonFinite ; import static com . google . common . primitives . Doubles . isFinite ; import static java . lang . Double . NaN ; import static java . lang . Double . doubleToLongBits ; import static java . lang . Double . isNaN ; import com . google . common . annotations . Beta ; import com . google . common . base . MoreObjects ; import com . google . common . base . Objects ; import java . io . Serializable ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . Iterator ; import javax . annotation . Nullable ; @Beta public final class Stats implements Serializable { private final long count ; private final double mean ; private final double sumOfSquaresOfDeltas ; private final double min ; private final double max ; Stats ( long count , double mean , double sumOfSquaresOfDeltas , double min , double max ) { this . count = count ; this . mean = mean ; this . sumOfSquaresOfDeltas = sumOfSquaresOfDeltas ; this . min = min ; this . max = max ; } public static Stats of ( Iterable < ? extends Number > values ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( values ) ; return accumulator . snapshot ( ) ; } public static Stats of ( Iterator < ? extends Number > values ) { StatsAccumulator accumulator = new StatsAccumulator ( ) ; accumulator . addAll ( values ) ; return accumulator . snapshot ( ) ; } public static Stats of ( double . . . values ) { StatsAccumulator acummulator = new StatsAccumulator ( ) ; acummulator . addAll ( values ) ; return acummulator . snapshot ( ) ; } public static Stats of ( int . . . values ) { StatsAccumulator acummulator = new StatsAccumulator ( ) ; acummulator . addAll ( values ) ; return acummulator . snapshot ( ) ; } public static Stats of ( long . . . values ) { StatsAccumulator acummulator = new StatsAccumulator ( ) ; acummulator . addAll ( values ) ; return acummulator . snapshot ( ) ; } public long count ( ) { return count ; } public double mean ( ) { checkState ( count ! = <int> ) ; return mean ; } public double sum ( ) { return mean * count ; } public double populationVariance ( ) { checkState ( count > <int> ) ; if ( isNaN ( sumOfSquaresOfDeltas ) ) { return NaN ; } if ( count = = <int> ) { return <float> ; } return ensureNonNegative ( sumOfSquaresOfDeltas ) / count ( ) ; } public double populationStandardDeviation ( ) { return Math . sqrt ( populationVariance ( ) ) ; } public double sampleVariance ( ) { checkState ( count > <int> ) ; if ( isNaN ( sumOfSquaresOfDeltas ) ) { return NaN ; } return ensureNonNegative ( sumOfSquaresOfDeltas ) / ( count - <int> ) ; } public double sampleStandardDeviation ( ) { return Math . sqrt ( sampleVariance ( ) ) ; } public double min ( ) { checkState ( count ! = <int> ) ; return min ; } public double max ( ) { checkState ( count ! = <int> ) ; return max ; } @Override public boolean equals ( @Nullable Object obj ) { if ( obj = = null ) { return false ; } if ( getClass ( ) ! = obj . getClass ( ) ) { return false ; } Stats other = ( Stats ) obj ; return ( count = = other . count ) & & ( doubleToLongBits ( mean ) = = doubleToLongBits ( other . mean ) ) & & ( doubleToLongBits ( sumOfSquaresOfDeltas ) = = doubleToLongBits ( other . sumOfSquaresOfDeltas ) ) & & ( doubleToLongBits ( min ) = = doubleToLongBits ( other . min ) ) & & ( doubleToLongBits ( max ) = = doubleToLongBits ( other . max ) ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( count , mean , sumOfSquaresOfDeltas , min , max ) ; } @Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( <str> , count ) . add ( <str> , mean ) . add ( <str> , populationStandardDeviation ( ) ) . add ( <str> , min ) . add ( <str> , max ) . toString ( ) ; } double sumOfSquaresOfDeltas ( ) { return sumOfSquaresOfDeltas ; } public static double meanOf ( Iterable < ? extends Number > values ) { return meanOf ( values . iterator ( ) ) ; } public static double meanOf ( Iterator < ? extends Number > values ) { checkArgument ( values . hasNext ( ) ) ; long count = <int> ; double mean = values . next ( ) . doubleValue ( ) ; while ( values . hasNext ( ) ) { double value = values . next ( ) . doubleValue ( ) ; count + + ; if ( isFinite ( value ) & & isFinite ( mean ) ) { mean + = ( value - mean ) / count ; } else { mean = calculateNewMeanNonFinite ( mean , value ) ; } } return mean ; } public static double meanOf ( double . . . values ) { checkArgument ( values . length > <int> ) ; double mean = values [ <int> ] ; for ( int index = <int> ; index < values . length ; index + + ) { double value = values [ index ] ; if ( isFinite ( value ) & & isFinite ( mean ) ) { mean + = ( value - mean ) / ( index + <int> ) ; } else { mean = calculateNewMeanNonFinite ( mean , value ) ; } } return mean ; } public static double meanOf ( int . . . values ) { checkArgument ( values . length > <int> ) ; double mean = values [ <int> ] ; for ( int index = <int> ; index < values . length ; index + + ) { double value = values [ index ] ; if ( isFinite ( value ) & & isFinite ( mean ) ) { mean + = ( value - mean ) / ( index + <int> ) ; } else { mean = calculateNewMeanNonFinite ( mean , value ) ; } } return mean ; } public static double meanOf ( long . . . values ) { checkArgument ( values . length > <int> ) ; double mean = values [ <int> ] ; for ( int index = <int> ; index < values . length ; index + + ) { double value = values [ index ] ; if ( isFinite ( value ) & & isFinite ( mean ) ) { mean + = ( value - mean ) / ( index + <int> ) ; } else { mean = calculateNewMeanNonFinite ( mean , value ) ; } } return mean ; } public static final int BYTES = ( Long . SIZE + Double . SIZE * <int> ) / Byte . SIZE ; public byte [ ] toByteArray ( ) { return ByteBuffer . allocate ( BYTES ) . order ( ByteOrder . LITTLE_ENDIAN ) . putLong ( count ) . putDouble ( mean ) . putDouble ( sumOfSquaresOfDeltas ) . putDouble ( min ) . putDouble ( max ) . array ( ) ; } public static Stats fromByteArray ( byte [ ] byteArray ) { checkNotNull ( byteArray ) ; checkArgument ( byteArray . length > = BYTES , <str> , BYTES , byteArray . length ) ; ByteBuffer buff = ByteBuffer . wrap ( byteArray ) . order ( ByteOrder . LITTLE_ENDIAN ) ; return new Stats ( buff . getLong ( ) , buff . getDouble ( ) , buff . getDouble ( ) , buff . getDouble ( ) , buff . getDouble ( ) ) ; } private static final long serialVersionUID = <int> ; } 
