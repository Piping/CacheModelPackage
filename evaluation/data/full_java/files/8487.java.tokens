package org . elasticsearch . search . aggregations . pipeline . serialdiff ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . collect . EvictingQueue ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram ; import org . elasticsearch . search . aggregations . metrics . ValuesSourceMetricsAggregationBuilder ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregationHelperTests ; import org . elasticsearch . search . aggregations . pipeline . SimpleValue ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . avg ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . max ; import static org . elasticsearch . search . aggregations . AggregationBuilders . min ; import static org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilders . diff ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . core . IsNull . notNullValue ; import static org . hamcrest . core . IsNull . nullValue ; @ESIntegTestCase.SuiteScopeTestCase public class SerialDiffIT extends ESIntegTestCase { private static final String INTERVAL_FIELD = <str> ; private static final String VALUE_FIELD = <str> ; static int interval ; static int numBuckets ; static int lag ; static BucketHelpers . GapPolicy gapPolicy ; static ValuesSourceMetricsAggregationBuilder metric ; static List < PipelineAggregationHelperTests . MockBucket > mockHisto ; static Map < String , ArrayList < Double > > testValues ; enum MetricTarget { VALUE ( <str> ) , COUNT ( <str> ) ; private final String name ; MetricTarget ( String s ) { name = s ; } @Override public String toString ( ) { return name ; } } private ValuesSourceMetricsAggregationBuilder randomMetric ( String name , String field ) { int rand = randomIntBetween ( <int> , <int> ) ; switch ( rand ) { case <int> : return min ( name ) . field ( field ) ; case <int> : return max ( name ) . field ( field ) ; case <int> : return avg ( name ) . field ( field ) ; default : return avg ( name ) . field ( field ) ; } } private void assertValidIterators ( Iterator expectedBucketIter , Iterator expectedCountsIter , Iterator expectedValuesIter ) { if ( ! expectedBucketIter . hasNext ( ) ) { fail ( <str> ) ; } if ( ! expectedCountsIter . hasNext ( ) ) { fail ( <str> ) ; } if ( ! expectedValuesIter . hasNext ( ) ) { fail ( <str> ) ; } } private void assertBucketContents ( Histogram . Bucket actual , Double expectedCount , Double expectedValue ) { SimpleValue countDiff = actual . getAggregations ( ) . get ( <str> ) ; if ( expectedCount = = null ) { assertThat ( <str> , countDiff , nullValue ( ) ) ; } else { assertThat ( <str> , countDiff , notNullValue ( ) ) ; assertThat ( <str> + countDiff . value ( ) + <str> + expectedCount + <str> , countDiff . value ( ) , closeTo ( expectedCount , <float> ) ) ; } SimpleValue valuesDiff = actual . getAggregations ( ) . get ( <str> ) ; if ( expectedValue = = null ) { assertThat ( <str> , valuesDiff , Matchers . nullValue ( ) ) ; } else { assertThat ( <str> , valuesDiff , notNullValue ( ) ) ; assertThat ( <str> + valuesDiff . value ( ) + <str> + expectedValue + <str> , valuesDiff . value ( ) , closeTo ( expectedValue , <float> ) ) ; } } @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; interval = <int> ; numBuckets = randomIntBetween ( <int> , <int> ) ; lag = randomIntBetween ( <int> , numBuckets / <int> ) ; gapPolicy = randomBoolean ( ) ? BucketHelpers . GapPolicy . SKIP : BucketHelpers . GapPolicy . INSERT_ZEROS ; metric = randomMetric ( <str> , VALUE_FIELD ) ; mockHisto = PipelineAggregationHelperTests . generateHistogram ( interval , numBuckets , randomDouble ( ) , randomDouble ( ) ) ; testValues = new HashMap < > ( <int> ) ; for ( MetricTarget target : MetricTarget . values ( ) ) { setupExpected ( target ) ; } for ( PipelineAggregationHelperTests . MockBucket mockBucket : mockHisto ) { for ( double value : mockBucket . docValues ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( INTERVAL_FIELD , mockBucket . key ) . field ( VALUE_FIELD , value ) . endObject ( ) ) ) ; } } indexRandom ( true , builders ) ; ensureSearchable ( ) ; } private void setupExpected ( MetricTarget target ) { ArrayList < Double > values = new ArrayList < > ( numBuckets ) ; EvictingQueue < Double > lagWindow = new EvictingQueue < > ( lag ) ; int counter = <int> ; for ( PipelineAggregationHelperTests . MockBucket mockBucket : mockHisto ) { Double metricValue ; double [ ] docValues = mockBucket . docValues ; if ( mockBucket . count = = <int> & & target . equals ( MetricTarget . VALUE ) ) { if ( gapPolicy . equals ( BucketHelpers . GapPolicy . SKIP ) ) { metricValue = null ; } else if ( gapPolicy . equals ( BucketHelpers . GapPolicy . INSERT_ZEROS ) ) { metricValue = <float> ; } else { metricValue = PipelineAggregationHelperTests . calculateMetric ( docValues , metric ) ; } } else { metricValue = target . equals ( MetricTarget . VALUE ) ? PipelineAggregationHelperTests . calculateMetric ( docValues , metric ) : mockBucket . count ; } counter + = <int> ; Double lagValue ; if ( counter < = lag ) { lagValue = Double . NaN ; } else { lagValue = lagWindow . peek ( ) ; } if ( metricValue = = null ) { metricValue = Double . NaN ; } if ( ! Double . isNaN ( metricValue ) & & ! Double . isNaN ( lagValue ) ) { double diff = metricValue - lagValue ; values . add ( diff ) ; } else { values . add ( null ) ; } lagWindow . add ( metricValue ) ; } testValues . put ( target . toString ( ) , values ) ; } public void testBasicDiff ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( diff ( <str> ) . lag ( lag ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) . subAggregation ( diff ( <str> ) . lag ( lag ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < InternalHistogram . Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends InternalHistogram . Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( mockHisto . size ( ) ) ) ; List < Double > expectedCounts = testValues . get ( MetricTarget . COUNT . toString ( ) ) ; List < Double > expectedValues = testValues . get ( MetricTarget . VALUE . toString ( ) ) ; Iterator < ? extends Histogram . Bucket > actualIter = buckets . iterator ( ) ; Iterator < PipelineAggregationHelperTests . MockBucket > expectedBucketIter = mockHisto . iterator ( ) ; Iterator < Double > expectedCountsIter = expectedCounts . iterator ( ) ; Iterator < Double > expectedValuesIter = expectedValues . iterator ( ) ; while ( actualIter . hasNext ( ) ) { assertValidIterators ( expectedBucketIter , expectedCountsIter , expectedValuesIter ) ; Histogram . Bucket actual = actualIter . next ( ) ; PipelineAggregationHelperTests . MockBucket expected = expectedBucketIter . next ( ) ; Double expectedCount = expectedCountsIter . next ( ) ; Double expectedValue = expectedValuesIter . next ( ) ; assertThat ( <str> , ( ( Number ) actual . getKey ( ) ) . longValue ( ) , equalTo ( expected . key ) ) ; assertThat ( <str> , actual . getDocCount ( ) , equalTo ( ( long ) expected . count ) ) ; assertBucketContents ( actual , expectedCount , expectedValue ) ; } } public void testInvalidLagSize ( ) { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( diff ( <str> ) . lag ( - <int> ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; } catch ( SearchPhaseExecutionException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } } 
