package org . elasticsearch . test . transport ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . component . Lifecycle ; import org . elasticsearch . common . component . LifecycleListener ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . BoundTransportAddress ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . ConnectTransportException ; import org . elasticsearch . transport . RequestHandlerRegistry ; import org . elasticsearch . transport . Transport ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportModule ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import org . elasticsearch . transport . TransportServiceAdapter ; import java . io . IOException ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; public class MockTransportService extends TransportService { public static class TestPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( TransportModule transportModule ) { transportModule . addTransportService ( <str> , MockTransportService . class ) ; } @Override public Settings additionalSettings ( ) { return Settings . builder ( ) . put ( TransportModule . TRANSPORT_SERVICE_TYPE_KEY , <str> ) . build ( ) ; } } private final Transport original ; @Inject public MockTransportService ( Settings settings , Transport transport , ThreadPool threadPool ) { super ( settings , new LookupTestTransport ( transport ) , threadPool ) ; this . original = transport ; } public static TransportAddress [ ] extractTransportAddresses ( TransportService transportService ) { HashSet < TransportAddress > transportAddresses = new HashSet < > ( ) ; BoundTransportAddress boundTransportAddress = transportService . boundAddress ( ) ; transportAddresses . addAll ( Arrays . asList ( boundTransportAddress . boundAddresses ( ) ) ) ; transportAddresses . add ( boundTransportAddress . publishAddress ( ) ) ; return transportAddresses . toArray ( new TransportAddress [ transportAddresses . size ( ) ] ) ; } public void clearAllRules ( ) { transport ( ) . transports . clear ( ) ; } public void clearRule ( TransportService transportService ) { for ( TransportAddress transportAddress : extractTransportAddresses ( transportService ) ) { clearRule ( transportAddress ) ; } } public void clearRule ( TransportAddress transportAddress ) { transport ( ) . transports . remove ( transportAddress ) ; } public Transport original ( ) { return original ; } public void addFailToSendNoConnectRule ( TransportService transportService ) { for ( TransportAddress transportAddress : extractTransportAddresses ( transportService ) ) { addFailToSendNoConnectRule ( transportAddress ) ; } } public void addFailToSendNoConnectRule ( TransportAddress transportAddress ) { addDelegate ( transportAddress , new DelegateTransport ( original ) { @Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { throw new ConnectTransportException ( node , <str> ) ; } @Override public void connectToNodeLight ( DiscoveryNode node ) throws ConnectTransportException { throw new ConnectTransportException ( node , <str> ) ; } @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { throw new ConnectTransportException ( node , <str> ) ; } } ) ; } public void addFailToSendNoConnectRule ( TransportService transportService , final String . . . blockedActions ) { addFailToSendNoConnectRule ( transportService , new HashSet < > ( Arrays . asList ( blockedActions ) ) ) ; } public void addFailToSendNoConnectRule ( TransportAddress transportAddress , final String . . . blockedActions ) { addFailToSendNoConnectRule ( transportAddress , new HashSet < > ( Arrays . asList ( blockedActions ) ) ) ; } public void addFailToSendNoConnectRule ( TransportService transportService , final Set < String > blockedActions ) { for ( TransportAddress transportAddress : extractTransportAddresses ( transportService ) ) { addFailToSendNoConnectRule ( transportAddress , blockedActions ) ; } } public void addFailToSendNoConnectRule ( TransportAddress transportAddress , final Set < String > blockedActions ) { addDelegate ( transportAddress , new DelegateTransport ( original ) { @Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { original . connectToNode ( node ) ; } @Override public void connectToNodeLight ( DiscoveryNode node ) throws ConnectTransportException { original . connectToNodeLight ( node ) ; } @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { if ( blockedActions . contains ( action ) ) { logger . info ( <str> , action ) ; throw new ConnectTransportException ( node , <str> + action + <str> ) ; } original . sendRequest ( node , requestId , action , request , options ) ; } } ) ; } public void addUnresponsiveRule ( TransportService transportService ) { for ( TransportAddress transportAddress : extractTransportAddresses ( transportService ) ) { addUnresponsiveRule ( transportAddress ) ; } } public void addUnresponsiveRule ( TransportAddress transportAddress ) { addDelegate ( transportAddress , new DelegateTransport ( original ) { @Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { throw new ConnectTransportException ( node , <str> ) ; } @Override public void connectToNodeLight ( DiscoveryNode node ) throws ConnectTransportException { throw new ConnectTransportException ( node , <str> ) ; } @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { } } ) ; } public void addUnresponsiveRule ( TransportService transportService , final TimeValue duration ) { for ( TransportAddress transportAddress : extractTransportAddresses ( transportService ) ) { addUnresponsiveRule ( transportAddress , duration ) ; } } public void addUnresponsiveRule ( TransportAddress transportAddress , final TimeValue duration ) { final long startTime = System . currentTimeMillis ( ) ; addDelegate ( transportAddress , new DelegateTransport ( original ) { TimeValue getDelay ( ) { return new TimeValue ( duration . millis ( ) - ( System . currentTimeMillis ( ) - startTime ) ) ; } @Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { TimeValue delay = getDelay ( ) ; if ( delay . millis ( ) < = <int> ) { original . connectToNode ( node ) ; return ; } TimeValue connectingTimeout = NetworkService . TcpSettings . TCP_DEFAULT_CONNECT_TIMEOUT ; try { if ( delay . millis ( ) < connectingTimeout . millis ( ) ) { Thread . sleep ( delay . millis ( ) ) ; original . connectToNode ( node ) ; } else { Thread . sleep ( connectingTimeout . millis ( ) ) ; throw new ConnectTransportException ( node , <str> ) ; } } catch ( InterruptedException e ) { throw new ConnectTransportException ( node , <str> , e ) ; } } @Override public void connectToNodeLight ( DiscoveryNode node ) throws ConnectTransportException { TimeValue delay = getDelay ( ) ; if ( delay . millis ( ) < = <int> ) { original . connectToNodeLight ( node ) ; return ; } TimeValue connectingTimeout = NetworkService . TcpSettings . TCP_DEFAULT_CONNECT_TIMEOUT ; try { if ( delay . millis ( ) < connectingTimeout . millis ( ) ) { Thread . sleep ( delay . millis ( ) ) ; original . connectToNodeLight ( node ) ; } else { Thread . sleep ( connectingTimeout . millis ( ) ) ; throw new ConnectTransportException ( node , <str> ) ; } } catch ( InterruptedException e ) { throw new ConnectTransportException ( node , <str> , e ) ; } } @Override public void sendRequest ( final DiscoveryNode node , final long requestId , final String action , TransportRequest request , final TransportRequestOptions options ) throws IOException , TransportException { TimeValue delay = getDelay ( ) ; if ( delay . millis ( ) < = <int> ) { original . sendRequest ( node , requestId , action , request , options ) ; return ; } RequestHandlerRegistry reg = MockTransportService . this . getRequestHandler ( action ) ; BytesStreamOutput bStream = new BytesStreamOutput ( ) ; request . writeTo ( bStream ) ; final TransportRequest clonedRequest = reg . newRequest ( ) ; clonedRequest . readFrom ( StreamInput . wrap ( bStream . bytes ( ) ) ) ; threadPool . schedule ( delay , ThreadPool . Names . GENERIC , new AbstractRunnable ( ) { @Override public void onFailure ( Throwable e ) { logger . debug ( <str> , e ) ; } @Override protected void doRun ( ) throws IOException { original . sendRequest ( node , requestId , action , clonedRequest , options ) ; } } ) ; } } ) ; } public boolean addDelegate ( TransportService transportService , DelegateTransport transport ) { boolean noRegistered = true ; for ( TransportAddress transportAddress : extractTransportAddresses ( transportService ) ) { noRegistered & = addDelegate ( transportAddress , transport ) ; } return noRegistered ; } public boolean addDelegate ( TransportAddress transportAddress , DelegateTransport transport ) { return transport ( ) . transports . put ( transportAddress , transport ) = = null ; } private LookupTestTransport transport ( ) { return ( LookupTestTransport ) transport ; } private static class LookupTestTransport extends DelegateTransport { final ConcurrentMap < TransportAddress , Transport > transports = ConcurrentCollections . newConcurrentMap ( ) ; LookupTestTransport ( Transport transport ) { super ( transport ) ; } private Transport getTransport ( DiscoveryNode node ) { Transport transport = transports . get ( node . getAddress ( ) ) ; if ( transport ! = null ) { return transport ; } return this . transport ; } @Override public boolean nodeConnected ( DiscoveryNode node ) { return getTransport ( node ) . nodeConnected ( node ) ; } @Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { getTransport ( node ) . connectToNode ( node ) ; } @Override public void connectToNodeLight ( DiscoveryNode node ) throws ConnectTransportException { getTransport ( node ) . connectToNodeLight ( node ) ; } @Override public void disconnectFromNode ( DiscoveryNode node ) { getTransport ( node ) . disconnectFromNode ( node ) ; } @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { getTransport ( node ) . sendRequest ( node , requestId , action , request , options ) ; } } public static class DelegateTransport implements Transport { protected final Transport transport ; public DelegateTransport ( Transport transport ) { this . transport = transport ; } @Override public void transportServiceAdapter ( TransportServiceAdapter service ) { transport . transportServiceAdapter ( service ) ; } @Override public BoundTransportAddress boundAddress ( ) { return transport . boundAddress ( ) ; } @Override public TransportAddress [ ] addressesFromString ( String address , int perAddressLimit ) throws Exception { return transport . addressesFromString ( address , perAddressLimit ) ; } @Override public boolean addressSupported ( Class < ? extends TransportAddress > address ) { return transport . addressSupported ( address ) ; } @Override public boolean nodeConnected ( DiscoveryNode node ) { return transport . nodeConnected ( node ) ; } @Override public void connectToNode ( DiscoveryNode node ) throws ConnectTransportException { transport . connectToNode ( node ) ; } @Override public void connectToNodeLight ( DiscoveryNode node ) throws ConnectTransportException { transport . connectToNodeLight ( node ) ; } @Override public void disconnectFromNode ( DiscoveryNode node ) { transport . disconnectFromNode ( node ) ; } @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { transport . sendRequest ( node , requestId , action , request , options ) ; } @Override public long serverOpen ( ) { return transport . serverOpen ( ) ; } @Override public List < String > getLocalAddresses ( ) { return transport . getLocalAddresses ( ) ; } @Override public Lifecycle . State lifecycleState ( ) { return transport . lifecycleState ( ) ; } @Override public void addLifecycleListener ( LifecycleListener listener ) { transport . addLifecycleListener ( listener ) ; } @Override public void removeLifecycleListener ( LifecycleListener listener ) { transport . removeLifecycleListener ( listener ) ; } @Override public Transport start ( ) { transport . start ( ) ; return this ; } @Override public Transport stop ( ) { transport . stop ( ) ; return this ; } @Override public void close ( ) { transport . close ( ) ; } @Override public Map < String , BoundTransportAddress > profileBoundAddresses ( ) { return transport . profileBoundAddresses ( ) ; } } List < Tracer > activeTracers = new CopyOnWriteArrayList < > ( ) ; public static class Tracer { public void receivedRequest ( long requestId , String action ) { } public void responseSent ( long requestId , String action ) { } public void responseSent ( long requestId , String action , Throwable t ) { } public void receivedResponse ( long requestId , DiscoveryNode sourceNode , String action ) { } public void requestSent ( DiscoveryNode node , long requestId , String action , TransportRequestOptions options ) { } } public void addTracer ( Tracer tracer ) { activeTracers . add ( tracer ) ; } public boolean removeTracer ( Tracer tracer ) { return activeTracers . remove ( tracer ) ; } public void clearTracers ( ) { activeTracers . clear ( ) ; } @Override protected Adapter createAdapter ( ) { return new MockAdapter ( ) ; } class MockAdapter extends Adapter { @Override protected boolean traceEnabled ( ) { return super . traceEnabled ( ) | | activeTracers . isEmpty ( ) = = false ; } @Override protected void traceReceivedRequest ( long requestId , String action ) { super . traceReceivedRequest ( requestId , action ) ; for ( Tracer tracer : activeTracers ) { tracer . receivedRequest ( requestId , action ) ; } } @Override protected void traceResponseSent ( long requestId , String action ) { super . traceResponseSent ( requestId , action ) ; for ( Tracer tracer : activeTracers ) { tracer . responseSent ( requestId , action ) ; } } @Override protected void traceResponseSent ( long requestId , String action , Throwable t ) { super . traceResponseSent ( requestId , action , t ) ; for ( Tracer tracer : activeTracers ) { tracer . responseSent ( requestId , action , t ) ; } } @Override protected void traceReceivedResponse ( long requestId , DiscoveryNode sourceNode , String action ) { super . traceReceivedResponse ( requestId , sourceNode , action ) ; for ( Tracer tracer : activeTracers ) { tracer . receivedResponse ( requestId , sourceNode , action ) ; } } @Override protected void traceRequestSent ( DiscoveryNode node , long requestId , String action , TransportRequestOptions options ) { super . traceRequestSent ( node , requestId , action , options ) ; for ( Tracer tracer : activeTracers ) { tracer . requestSent ( node , requestId , action , options ) ; } } } } 
