package org . nd4j . linalg . api . parallel . tasks . cpu . scalar ; import io . netty . buffer . ByteBuf ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ops . ScalarOp ; import org . nd4j . linalg . api . parallel . tasks . Task ; import org . nd4j . linalg . api . parallel . tasks . TaskExecutorProvider ; import java . util . ArrayList ; import java . util . concurrent . RecursiveAction ; import java . util . concurrent . RecursiveTask ; public class CPUScalarOpAction extends BaseCPUScalarOpAction { public CPUScalarOpAction ( ScalarOp op , int threshold , int n , int offsetX , int offsetZ , int incrX , int incrZ ) { super ( op , threshold , n , offsetX , offsetZ , incrX , incrZ ) ; } public CPUScalarOpAction ( ScalarOp op , int threshold ) { super ( op , threshold ) ; } public CPUScalarOpAction ( ScalarOp op , int threshold , int tadIdx , int tadDim ) { super ( op , threshold , tadIdx , tadDim ) ; } @Override public Void call ( ) { if ( doTensorFirst ) doTensorFirst ( op ) ; if ( n > threshold ) { int nSubTasks = <int> + n / threshold ; subTasks = new ArrayList < > ( nSubTasks ) ; int taskSize = n / nSubTasks ; int soFar = <int> ; for ( int i = <int> ; i < nSubTasks ; i + + ) { int nInTask ; if ( i = = nSubTasks - <int> ) { nInTask = n - soFar ; } else { nInTask = taskSize ; } int offsetXNew = offsetX + soFar * incrX ; int offsetZNew = offsetZ + soFar * incrZ ; Task t = new CPUScalarOpAction ( op , threshold , nInTask , offsetXNew , offsetZNew , incrX , incrZ ) ; t . invokeAsync ( ) ; subTasks . add ( t ) ; soFar + = nInTask ; } } else { execute ( ) ; } return null ; } @Override protected void compute ( ) { if ( doTensorFirst ) doTensorFirst ( op ) ; if ( n > threshold ) { int nFirst = n / <int> ; RecursiveAction first = new CPUScalarOpAction ( op , threshold , nFirst , offsetX , offsetZ , incrX , incrZ ) ; first . fork ( ) ; int nSecond = n - nFirst ; int offsetX2 = offsetX + nFirst * incrX ; int offsetZ2 = offsetZ + nFirst * incrZ ; RecursiveAction second = new CPUScalarOpAction ( op , threshold , nSecond , offsetX2 , offsetZ2 , incrX , incrZ ) ; second . fork ( ) ; first . join ( ) ; second . join ( ) ; } else { execute ( ) ; } } private void execute ( ) { if ( doTensorFirst ) doTensorFirst ( op ) ; DataBuffer x = op . x ( ) . data ( ) ; DataBuffer z = op . z ( ) . data ( ) ; if ( x . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { float [ ] xf = ( float [ ] ) x . array ( ) ; if ( incrX = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i ; xf [ xIdx ] = op . op ( xf [ xIdx ] ) ; } } else { float [ ] zf = ( float [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zf [ offsetZ + i ] = op . op ( xf [ offsetX + i ] ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i * incrX ; xf [ xIdx ] = op . op ( xf [ xIdx ] ) ; } } else { float [ ] zf = ( float [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zf [ offsetZ + i * incrZ ] = op . op ( xf [ offsetX + i * incrX ] ) ; } } } } else { double [ ] xd = ( double [ ] ) x . array ( ) ; if ( incrX = = <int> & & incrZ = = <int> ) { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i ; xd [ xIdx ] = op . op ( xd [ xIdx ] ) ; } } else { double [ ] zd = ( double [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zd [ offsetZ + i ] = op . op ( xd [ offsetX + i ] ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < n ; i + + ) { int xIdx = offsetX + i * incrX ; xd [ xIdx ] = op . op ( xd [ xIdx ] ) ; } } else { double [ ] zd = ( double [ ] ) z . array ( ) ; for ( int i = <int> ; i < n ; i + + ) { zd [ offsetZ + i * incrZ ] = op . op ( xd [ offsetX + i * incrX ] ) ; } } } } } else { ByteBuf nbbx = x . asNetty ( ) ; ByteBuf nbbz = z . asNetty ( ) ; if ( x . dataType ( ) = = DataBuffer . Type . FLOAT ) { int byteOffsetX = <int> * offsetX ; int byteOffsetZ = <int> * offsetZ ; if ( incrX = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbIdx = byteOffsetX + i ; nbbx . setFloat ( xbIdx , op . op ( nbbx . getFloat ( xbIdx ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setFloat ( byteOffsetZ + i , op . op ( nbbx . getFloat ( byteOffsetX + i ) ) ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbIdx = byteOffsetX + i * incrX ; nbbx . setFloat ( xbIdx , op . op ( nbbx . getFloat ( xbIdx ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setFloat ( byteOffsetZ + i * incrZ , op . op ( nbbx . getFloat ( byteOffsetX + i * incrX ) ) ) ; } } } } else { int byteOffsetX = <int> * offsetX ; int byteOffsetZ = <int> * offsetZ ; if ( incrX = = <int> & & ( x = = z | | incrZ = = <int> ) ) { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbIdx = byteOffsetX + i ; nbbx . setDouble ( xbIdx , op . op ( nbbx . getDouble ( xbIdx ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setDouble ( byteOffsetZ + i , op . op ( nbbx . getDouble ( byteOffsetX + i ) ) ) ; } } } else { if ( x = = z ) { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { int xbIdx = byteOffsetX + i * incrX ; nbbx . setDouble ( xbIdx , op . op ( nbbx . getDouble ( xbIdx ) ) ) ; } } else { for ( int i = <int> ; i < <int> * n ; i + = <int> ) { nbbz . setDouble ( byteOffsetZ + i * incrZ , op . op ( nbbx . getDouble ( byteOffsetX + i * incrX ) ) ) ; } } } } } } } 
