package org . nd4j . linalg . api . ops . impl . accum ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . BaseAccumulation ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . util . ArrayUtil ; public class Bias extends BaseAccumulation { private double mean ; public Bias ( ) { } public Bias ( INDArray x , INDArray y , INDArray z , int n ) { super ( x , y , z , n ) ; this . passThrough = true ; } public Bias ( INDArray x , INDArray y , int n ) { this ( x , y , x , n ) ; this . passThrough = true ; } public Bias ( INDArray x ) { super ( x ) ; this . passThrough = true ; } public Bias ( INDArray x , INDArray y ) { super ( x , y ) ; this . passThrough = true ; } @Override public String name ( ) { return <str> ; } @Override public Op opForDimension ( int index , int dimension ) { INDArray xAlongDimension = x . vectorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new Bias ( xAlongDimension , y . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new Bias ( x . vectorAlongDimension ( index , dimension ) ) ; } @Override public Op opForDimension ( int index , int . . . dimension ) { INDArray xAlongDimension = x . tensorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new Bias ( xAlongDimension , y . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new Bias ( x . tensorAlongDimension ( index , dimension ) ) ; } @Override public IComplexNumber op ( IComplexNumber origin ) { return origin . sub ( mean ) ; } @Override public double op ( double origin ) { return origin - mean ; } @Override public float op ( float origin ) { return ( float ) ( origin - mean ) ; } @Override public double update ( double accum , double x ) { return accum + x ; } @Override public double update ( double accum , double x , double y ) { return accum + x ; } @Override public float update ( float accum , float x ) { return accum + x ; } @Override public float update ( float accum , float x , float y ) { return accum + x ; } @Override public IComplexNumber update ( IComplexNumber accum , double x ) { return accum . add ( x ) ; } @Override public IComplexNumber update ( IComplexNumber accum , double x , double y ) { return accum . add ( x ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x ) { return accum . add ( x ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x , IComplexNumber y ) { return accum . add ( x ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x , double y ) { return accum . add ( x ) ; } @Override public IComplexNumber zeroComplex ( ) { return Nd4j . createComplexNumber ( <float> , <float> ) ; } @Override public void init ( INDArray x , INDArray y , INDArray z , int n ) { super . init ( x , y , z , n ) ; } @Override public double combineSubResults ( double first , double second ) { return first + second ; } @Override public float combineSubResults ( float first , float second ) { return first + second ; } @Override public IComplexNumber combineSubResults ( IComplexNumber first , IComplexNumber second ) { return first . add ( second ) ; } @Override public void exec ( ) { this . mean = Nd4j . getExecutioner ( ) . execAndReturn ( new Mean ( x ) ) . getFinalResult ( ) . doubleValue ( ) ; INDArray xMinusMean = x . sub ( mean ) ; double sum = Nd4j . getExecutioner ( ) . execAndReturn ( new Sum ( xMinusMean ) ) . getFinalResult ( ) . doubleValue ( ) ; this . finalResult = sum ; } @Override public void exec ( int . . . dimension ) { int [ ] retShape = ArrayUtil . removeIndex ( x . shape ( ) , dimension ) ; int nOps = x . tensorssAlongDimension ( dimension ) ; z = Nd4j . create ( retShape ) ; for ( int i = <int> ; i < nOps ; i + + ) { double d = Nd4j . getExecutioner ( ) . execAndReturn ( ( Bias ) opForDimension ( i , dimension ) ) . getFinalResult ( ) . doubleValue ( ) ; z . putScalar ( i , d ) ; } } } 
