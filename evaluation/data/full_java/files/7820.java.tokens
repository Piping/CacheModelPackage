package org . elasticsearch . cluster . health ; import org . elasticsearch . Version ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matchers ; import java . io . IOException ; import static org . hamcrest . CoreMatchers . allOf ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . Matchers . * ; public class ClusterStateHealthTests extends ESTestCase { private final IndexNameExpressionResolver indexNameExpressionResolver = new IndexNameExpressionResolver ( Settings . EMPTY ) ; public void testClusterHealth ( ) throws IOException { RoutingTableGenerator routingTableGenerator = new RoutingTableGenerator ( ) ; RoutingTableGenerator . ShardCounter counter = new RoutingTableGenerator . ShardCounter ( ) ; RoutingTable . Builder routingTable = RoutingTable . builder ( ) ; MetaData . Builder metaData = MetaData . builder ( ) ; for ( int i = randomInt ( <int> ) ; i > = <int> ; i - - ) { int numberOfShards = randomInt ( <int> ) + <int> ; int numberOfReplicas = randomInt ( <int> ) ; IndexMetaData indexMetaData = IndexMetaData . builder ( <str> + Integer . toString ( i ) ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( numberOfShards ) . numberOfReplicas ( numberOfReplicas ) . build ( ) ; IndexRoutingTable indexRoutingTable = routingTableGenerator . genIndexRoutingTable ( indexMetaData , counter ) ; metaData . put ( indexMetaData , true ) ; routingTable . add ( indexRoutingTable ) ; } ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable . build ( ) ) . build ( ) ; String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , IndicesOptions . strictExpand ( ) , ( String [ ] ) null ) ; ClusterStateHealth clusterStateHealth = new ClusterStateHealth ( clusterState , concreteIndices ) ; logger . info ( <str> , clusterStateHealth . getStatus ( ) , counter . status ( ) ) ; clusterStateHealth = maybeSerialize ( clusterStateHealth ) ; assertClusterHealth ( clusterStateHealth , counter ) ; } public void testValidations ( ) throws IOException { RoutingTableGenerator routingTableGenerator = new RoutingTableGenerator ( ) ; IndexMetaData indexMetaData = IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) . build ( ) ; RoutingTableGenerator . ShardCounter counter = new RoutingTableGenerator . ShardCounter ( ) ; IndexRoutingTable indexRoutingTable = routingTableGenerator . genIndexRoutingTable ( indexMetaData , counter ) ; indexMetaData = IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) . build ( ) ; ClusterIndexHealth indexHealth = new ClusterIndexHealth ( indexMetaData , indexRoutingTable ) ; assertThat ( indexHealth . getValidationFailures ( ) , Matchers . hasSize ( <int> ) ) ; RoutingTable . Builder routingTable = RoutingTable . builder ( ) ; MetaData . Builder metaData = MetaData . builder ( ) ; metaData . put ( indexMetaData , true ) ; routingTable . add ( indexRoutingTable ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable . build ( ) ) . build ( ) ; String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , IndicesOptions . strictExpand ( ) , ( String [ ] ) null ) ; ClusterStateHealth clusterStateHealth = new ClusterStateHealth ( clusterState , concreteIndices ) ; clusterStateHealth = maybeSerialize ( clusterStateHealth ) ; assertThat ( clusterStateHealth . getValidationFailures ( ) , Matchers . hasSize ( <int> ) ) ; } ClusterStateHealth maybeSerialize ( ClusterStateHealth clusterStateHealth ) throws IOException { if ( randomBoolean ( ) ) { BytesStreamOutput out = new BytesStreamOutput ( ) ; clusterStateHealth . writeTo ( out ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ; clusterStateHealth = ClusterStateHealth . readClusterHealth ( in ) ; } return clusterStateHealth ; } private void assertClusterHealth ( ClusterStateHealth clusterStateHealth , RoutingTableGenerator . ShardCounter counter ) { assertThat ( clusterStateHealth . getStatus ( ) , equalTo ( counter . status ( ) ) ) ; assertThat ( clusterStateHealth . getActiveShards ( ) , equalTo ( counter . active ) ) ; assertThat ( clusterStateHealth . getActivePrimaryShards ( ) , equalTo ( counter . primaryActive ) ) ; assertThat ( clusterStateHealth . getInitializingShards ( ) , equalTo ( counter . initializing ) ) ; assertThat ( clusterStateHealth . getRelocatingShards ( ) , equalTo ( counter . relocating ) ) ; assertThat ( clusterStateHealth . getUnassignedShards ( ) , equalTo ( counter . unassigned ) ) ; assertThat ( clusterStateHealth . getValidationFailures ( ) , empty ( ) ) ; assertThat ( clusterStateHealth . getActiveShardsPercent ( ) , is ( allOf ( greaterThanOrEqualTo ( <float> ) , lessThanOrEqualTo ( <float> ) ) ) ) ; } } 
