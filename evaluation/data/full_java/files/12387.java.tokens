package org . gradle . api . internal . file . collections ; import org . gradle . api . Action ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . internal . file . TestFiles ; import org . gradle . test . fixtures . file . TestFile ; import org . gradle . test . fixtures . file . TestNameTestDirectoryProvider ; import org . junit . Rule ; import org . junit . Test ; import java . io . File ; import java . io . IOException ; import java . io . OutputStream ; import java . util . List ; import java . util . concurrent . atomic . AtomicInteger ; import static org . gradle . api . file . FileVisitorUtil . assertCanStopVisiting ; import static org . gradle . api . file . FileVisitorUtil . assertVisits ; import static org . gradle . api . tasks . AntBuilderAwareUtil . assertSetContainsForAllTypes ; import static org . gradle . util . WrapUtil . toList ; import static org . hamcrest . Matchers . equalTo ; import static org . junit . Assert . * ; public class MapFileTreeTest { @Rule public final TestNameTestDirectoryProvider tmpDir = new TestNameTestDirectoryProvider ( ) ; private TestFile rootDir = tmpDir . getTestDirectory ( ) ; private final MapFileTree tree = new MapFileTree ( rootDir , TestFiles . fileSystem ( ) ) ; @Test public void isEmptyByDefault ( ) { List < String > emptyList = toList ( ) ; assertVisits ( tree , emptyList , emptyList ) ; assertSetContainsForAllTypes ( tree , emptyList ) ; } @Test public void canAddAnElementUsingAClosureToGeneratedContent ( ) { Action < OutputStream > action = getAction ( ) ; tree . add ( <str> , action ) ; assertVisits ( tree , toList ( <str> ) , toList ( <str> ) ) ; assertSetContainsForAllTypes ( tree , toList ( <str> ) ) ; rootDir . file ( <str> ) . assertIsDir ( ) ; rootDir . file ( <str> ) . assertContents ( equalTo ( <str> ) ) ; } @Test public void canAddMultipleElementsInDifferentDirs ( ) { Action < OutputStream > action = getAction ( ) ; tree . add ( <str> , action ) ; tree . add ( <str> , action ) ; tree . add ( <str> , action ) ; assertVisits ( tree , toList ( <str> , <str> , <str> ) , toList ( <str> , <str> ) ) ; assertSetContainsForAllTypes ( tree , toList ( <str> , <str> , <str> ) ) ; } @Test public void canStopVisitingElements ( ) { Action < OutputStream > closure = getAction ( ) ; tree . add ( <str> , closure ) ; tree . add ( <str> , closure ) ; assertCanStopVisiting ( tree ) ; } @Test public void containsWontCreateFiles ( ) { final AtomicInteger callCounter = new AtomicInteger ( <int> ) ; Action < OutputStream > fileAction = new Action < OutputStream > ( ) { @Override public void execute ( OutputStream outputStream ) { callCounter . incrementAndGet ( ) ; } } ; tree . add ( <str> , fileAction ) ; FileTreeAdapter fileTreeAdapter = new FileTreeAdapter ( tree ) ; File file = rootDir . file ( <str> ) ; assertTrue ( fileTreeAdapter . contains ( file ) ) ; assertTrue ( fileTreeAdapter . contains ( file ) ) ; assertFalse ( fileTreeAdapter . contains ( rootDir . file ( <str> ) ) ) ; assertEquals ( <int> , callCounter . get ( ) ) ; } private Action < OutputStream > getAction ( ) { return new Action < OutputStream > ( ) { public void execute ( OutputStream outputStream ) { try { outputStream . write ( <str> . getBytes ( ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } } ; } } 
