package com . badlogic . gdx . graphics ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Pixmap . Blending ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . Texture . TextureWrap ; import com . badlogic . gdx . graphics . TextureData . TextureDataType ; import com . badlogic . gdx . graphics . glutils . MipMapGenerator ; import com . badlogic . gdx . utils . Disposable ; public abstract class GLTexture implements Disposable { public final int glTarget ; protected int glHandle ; protected TextureFilter minFilter = TextureFilter . Nearest ; protected TextureFilter magFilter = TextureFilter . Nearest ; protected TextureWrap uWrap = TextureWrap . ClampToEdge ; protected TextureWrap vWrap = TextureWrap . ClampToEdge ; public abstract int getWidth ( ) ; public abstract int getHeight ( ) ; public abstract int getDepth ( ) ; public GLTexture ( int glTarget ) { this ( glTarget , Gdx . gl . glGenTexture ( ) ) ; } public GLTexture ( int glTarget , int glHandle ) { this . glTarget = glTarget ; this . glHandle = glHandle ; } public abstract boolean isManaged ( ) ; protected abstract void reload ( ) ; public void bind ( ) { Gdx . gl . glBindTexture ( glTarget , glHandle ) ; } public void bind ( int unit ) { Gdx . gl . glActiveTexture ( GL20 . GL_TEXTURE0 + unit ) ; Gdx . gl . glBindTexture ( glTarget , glHandle ) ; } public TextureFilter getMinFilter ( ) { return minFilter ; } public TextureFilter getMagFilter ( ) { return magFilter ; } public TextureWrap getUWrap ( ) { return uWrap ; } public TextureWrap getVWrap ( ) { return vWrap ; } public int getTextureObjectHandle ( ) { return glHandle ; } public void unsafeSetWrap ( TextureWrap u , TextureWrap v ) { unsafeSetWrap ( u , v , false ) ; } public void unsafeSetWrap ( TextureWrap u , TextureWrap v , boolean force ) { if ( u ! = null & & ( force | | uWrap ! = u ) ) { Gdx . gl . glTexParameterf ( glTarget , GL20 . GL_TEXTURE_WRAP_S , u . getGLEnum ( ) ) ; uWrap = u ; } if ( v ! = null & & ( force | | vWrap ! = v ) ) { Gdx . gl . glTexParameterf ( glTarget , GL20 . GL_TEXTURE_WRAP_T , v . getGLEnum ( ) ) ; vWrap = v ; } } public void setWrap ( TextureWrap u , TextureWrap v ) { this . uWrap = u ; this . vWrap = v ; bind ( ) ; Gdx . gl . glTexParameterf ( glTarget , GL20 . GL_TEXTURE_WRAP_S , u . getGLEnum ( ) ) ; Gdx . gl . glTexParameterf ( glTarget , GL20 . GL_TEXTURE_WRAP_T , v . getGLEnum ( ) ) ; } public void unsafeSetFilter ( TextureFilter minFilter , TextureFilter magFilter ) { unsafeSetFilter ( minFilter , magFilter , false ) ; } public void unsafeSetFilter ( TextureFilter minFilter , TextureFilter magFilter , boolean force ) { if ( minFilter ! = null & & ( force | | this . minFilter ! = minFilter ) ) { Gdx . gl . glTexParameterf ( glTarget , GL20 . GL_TEXTURE_MIN_FILTER , minFilter . getGLEnum ( ) ) ; this . minFilter = minFilter ; } if ( magFilter ! = null & & ( force | | this . magFilter ! = magFilter ) ) { Gdx . gl . glTexParameterf ( glTarget , GL20 . GL_TEXTURE_MAG_FILTER , magFilter . getGLEnum ( ) ) ; this . magFilter = magFilter ; } } public void setFilter ( TextureFilter minFilter , TextureFilter magFilter ) { this . minFilter = minFilter ; this . magFilter = magFilter ; bind ( ) ; Gdx . gl . glTexParameterf ( glTarget , GL20 . GL_TEXTURE_MIN_FILTER , minFilter . getGLEnum ( ) ) ; Gdx . gl . glTexParameterf ( glTarget , GL20 . GL_TEXTURE_MAG_FILTER , magFilter . getGLEnum ( ) ) ; } protected void delete ( ) { if ( glHandle ! = <int> ) { Gdx . gl . glDeleteTexture ( glHandle ) ; glHandle = <int> ; } } @Override public void dispose ( ) { delete ( ) ; } protected static void uploadImageData ( int target , TextureData data ) { uploadImageData ( target , data , <int> ) ; } public static void uploadImageData ( int target , TextureData data , int miplevel ) { if ( data = = null ) { return ; } if ( ! data . isPrepared ( ) ) data . prepare ( ) ; final TextureDataType type = data . getType ( ) ; if ( type = = TextureDataType . Custom ) { data . consumeCustomData ( target ) ; return ; } Pixmap pixmap = data . consumePixmap ( ) ; boolean disposePixmap = data . disposePixmap ( ) ; if ( data . getFormat ( ) ! = pixmap . getFormat ( ) ) { Pixmap tmp = new Pixmap ( pixmap . getWidth ( ) , pixmap . getHeight ( ) , data . getFormat ( ) ) ; Blending blend = Pixmap . getBlending ( ) ; Pixmap . setBlending ( Blending . None ) ; tmp . drawPixmap ( pixmap , <int> , <int> , <int> , <int> , pixmap . getWidth ( ) , pixmap . getHeight ( ) ) ; Pixmap . setBlending ( blend ) ; if ( data . disposePixmap ( ) ) { pixmap . dispose ( ) ; } pixmap = tmp ; disposePixmap = true ; } Gdx . gl . glPixelStorei ( GL20 . GL_UNPACK_ALIGNMENT , <int> ) ; if ( data . useMipMaps ( ) ) { MipMapGenerator . generateMipMap ( target , pixmap , pixmap . getWidth ( ) , pixmap . getHeight ( ) ) ; } else { Gdx . gl . glTexImage2D ( target , miplevel , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; } if ( disposePixmap ) pixmap . dispose ( ) ; } } 
