package org . gradle . language . scala . tasks ; import com . google . common . base . Predicate ; import com . google . common . collect . Maps ; import com . google . common . collect . Sets ; import org . gradle . api . Project ; import org . gradle . api . internal . tasks . scala . DefaultScalaJavaJointCompileSpec ; import org . gradle . api . internal . tasks . scala . DefaultScalaJavaJointCompileSpecFactory ; import org . gradle . api . internal . tasks . scala . ScalaCompileSpec ; import org . gradle . api . internal . tasks . scala . ScalaJavaJointCompileSpec ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . plugins . ExtraPropertiesExtension ; import org . gradle . api . tasks . Nested ; import org . gradle . api . tasks . TaskAction ; import org . gradle . api . tasks . compile . AbstractCompile ; import org . gradle . api . tasks . compile . CompileOptions ; import java . io . File ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . Set ; abstract public class AbstractScalaCompile extends AbstractCompile { protected static final Logger LOGGER = Logging . getLogger ( AbstractScalaCompile . class ) ; private final BaseScalaCompileOptions scalaCompileOptions ; private final CompileOptions compileOptions = new CompileOptions ( ) ; protected AbstractScalaCompile ( BaseScalaCompileOptions scalaCompileOptions ) { this . scalaCompileOptions = scalaCompileOptions ; } @Nested public BaseScalaCompileOptions getScalaCompileOptions ( ) { return scalaCompileOptions ; } @Nested public CompileOptions getOptions ( ) { return compileOptions ; } abstract protected org . gradle . language . base . internal . compile . Compiler < ScalaJavaJointCompileSpec > getCompiler ( ScalaJavaJointCompileSpec spec ) ; @TaskAction protected void compile ( ) { ScalaJavaJointCompileSpec spec = createSpec ( ) ; configureIncrementalCompilation ( spec ) ; getCompiler ( spec ) . execute ( spec ) ; } protected ScalaJavaJointCompileSpec createSpec ( ) { DefaultScalaJavaJointCompileSpec spec = new DefaultScalaJavaJointCompileSpecFactory ( compileOptions ) . create ( ) ; spec . setSource ( getSource ( ) ) ; spec . setDestinationDir ( getDestinationDir ( ) ) ; spec . setWorkingDir ( getProject ( ) . getProjectDir ( ) ) ; spec . setTempDir ( getTemporaryDir ( ) ) ; spec . setClasspath ( getClasspath ( ) ) ; spec . setSourceCompatibility ( getSourceCompatibility ( ) ) ; spec . setTargetCompatibility ( getTargetCompatibility ( ) ) ; spec . setCompileOptions ( getOptions ( ) ) ; spec . setScalaCompileOptions ( scalaCompileOptions ) ; return spec ; } protected void configureIncrementalCompilation ( ScalaCompileSpec spec ) { Map < File , File > globalAnalysisMap = getOrCreateGlobalAnalysisMap ( ) ; HashMap < File , File > filteredMap = filterForClasspath ( globalAnalysisMap , spec . getClasspath ( ) ) ; spec . setAnalysisMap ( filteredMap ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( <str> , scalaCompileOptions . getIncrementalOptions ( ) . getAnalysisFile ( ) ) ; LOGGER . debug ( <str> , scalaCompileOptions . getIncrementalOptions ( ) . getPublishedCode ( ) ) ; LOGGER . debug ( <str> , filteredMap ) ; } } @SuppressWarnings ( <str> ) protected Map < File , File > getOrCreateGlobalAnalysisMap ( ) { ExtraPropertiesExtension extraProperties = getProject ( ) . getRootProject ( ) . getExtensions ( ) . getExtraProperties ( ) ; Map < File , File > analysisMap ; if ( extraProperties . has ( <str> ) ) { analysisMap = ( Map ) extraProperties . get ( <str> ) ; } else { analysisMap = Maps . newHashMap ( ) ; for ( Project project : getProject ( ) . getRootProject ( ) . getAllprojects ( ) ) { for ( AbstractScalaCompile task : project . getTasks ( ) . withType ( AbstractScalaCompile . class ) ) { File publishedCode = task . getScalaCompileOptions ( ) . getIncrementalOptions ( ) . getPublishedCode ( ) ; File analysisFile = task . getScalaCompileOptions ( ) . getIncrementalOptions ( ) . getAnalysisFile ( ) ; analysisMap . put ( publishedCode , analysisFile ) ; } } extraProperties . set ( <str> , Collections . unmodifiableMap ( analysisMap ) ) ; } return analysisMap ; } protected HashMap < File , File > filterForClasspath ( Map < File , File > analysisMap , Iterable < File > classpath ) { final Set < File > classpathLookup = Sets . newHashSet ( classpath ) ; return Maps . newHashMap ( Maps . filterEntries ( analysisMap , new Predicate < Map . Entry < File , File > > ( ) { public boolean apply ( Map . Entry < File , File > entry ) { return classpathLookup . contains ( entry . getKey ( ) ) ; } } ) ) ; } } 
