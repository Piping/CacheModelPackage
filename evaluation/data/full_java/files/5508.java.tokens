package org . elasticsearch . client . transport ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . admin . cluster . node . liveness . LivenessRequest ; import org . elasticsearch . action . admin . cluster . node . liveness . LivenessResponse ; import org . elasticsearch . action . admin . cluster . node . liveness . TransportLivenessAction ; import org . elasticsearch . action . admin . cluster . state . ClusterStateAction ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . client . Requests ; import org . elasticsearch . client . support . Headers ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . BaseTransportResponseHandler ; import org . elasticsearch . transport . ConnectTransportException ; import org . elasticsearch . transport . FutureTransportResponseHandler ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . common . unit . TimeValue . timeValueSeconds ; public class TransportClientNodesService extends AbstractComponent { private final TimeValue nodesSamplerInterval ; private final long pingTimeout ; private final ClusterName clusterName ; private final TransportService transportService ; private final ThreadPool threadPool ; private final Version minCompatibilityVersion ; private final Headers headers ; private volatile List < DiscoveryNode > listedNodes = Collections . emptyList ( ) ; private final Object mutex = new Object ( ) ; private volatile List < DiscoveryNode > nodes = Collections . emptyList ( ) ; private volatile List < DiscoveryNode > filteredNodes = Collections . emptyList ( ) ; private final AtomicInteger tempNodeIdGenerator = new AtomicInteger ( ) ; private final NodeSampler nodesSampler ; private volatile ScheduledFuture nodesSamplerFuture ; private final AtomicInteger randomNodeGenerator = new AtomicInteger ( ) ; private final boolean ignoreClusterName ; private volatile boolean closed ; @Inject public TransportClientNodesService ( Settings settings , ClusterName clusterName , TransportService transportService , ThreadPool threadPool , Headers headers , Version version ) { super ( settings ) ; this . clusterName = clusterName ; this . transportService = transportService ; this . threadPool = threadPool ; this . minCompatibilityVersion = version . minimumCompatibilityVersion ( ) ; this . headers = headers ; this . nodesSamplerInterval = this . settings . getAsTime ( <str> , timeValueSeconds ( <int> ) ) ; this . pingTimeout = this . settings . getAsTime ( <str> , timeValueSeconds ( <int> ) ) . millis ( ) ; this . ignoreClusterName = this . settings . getAsBoolean ( <str> , false ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + nodesSamplerInterval + <str> ) ; } if ( this . settings . getAsBoolean ( <str> , false ) ) { this . nodesSampler = new SniffNodesSampler ( ) ; } else { this . nodesSampler = new SimpleNodeSampler ( ) ; } this . nodesSamplerFuture = threadPool . schedule ( nodesSamplerInterval , ThreadPool . Names . GENERIC , new ScheduledNodeSampler ( ) ) ; } public List < TransportAddress > transportAddresses ( ) { List < TransportAddress > lstBuilder = new ArrayList < > ( ) ; for ( DiscoveryNode listedNode : listedNodes ) { lstBuilder . add ( listedNode . address ( ) ) ; } return Collections . unmodifiableList ( lstBuilder ) ; } public List < DiscoveryNode > connectedNodes ( ) { return this . nodes ; } public List < DiscoveryNode > filteredNodes ( ) { return this . filteredNodes ; } public List < DiscoveryNode > listedNodes ( ) { return this . listedNodes ; } public TransportClientNodesService addTransportAddresses ( TransportAddress . . . transportAddresses ) { synchronized ( mutex ) { if ( closed ) { throw new IllegalStateException ( <str> ) ; } List < TransportAddress > filtered = new ArrayList < > ( transportAddresses . length ) ; for ( TransportAddress transportAddress : transportAddresses ) { boolean found = false ; for ( DiscoveryNode otherNode : listedNodes ) { if ( otherNode . address ( ) . equals ( transportAddress ) ) { found = true ; logger . debug ( <str> , transportAddress , otherNode ) ; break ; } } if ( ! found ) { filtered . add ( transportAddress ) ; } } if ( filtered . isEmpty ( ) ) { return this ; } List < DiscoveryNode > builder = new ArrayList < > ( ) ; builder . addAll ( listedNodes ( ) ) ; for ( TransportAddress transportAddress : filtered ) { DiscoveryNode node = new DiscoveryNode ( <str> + tempNodeIdGenerator . incrementAndGet ( ) , transportAddress , minCompatibilityVersion ) ; logger . debug ( <str> , node ) ; builder . add ( node ) ; } listedNodes = Collections . unmodifiableList ( builder ) ; nodesSampler . sample ( ) ; } return this ; } public TransportClientNodesService removeTransportAddress ( TransportAddress transportAddress ) { synchronized ( mutex ) { if ( closed ) { throw new IllegalStateException ( <str> ) ; } List < DiscoveryNode > builder = new ArrayList < > ( ) ; for ( DiscoveryNode otherNode : listedNodes ) { if ( ! otherNode . address ( ) . equals ( transportAddress ) ) { builder . add ( otherNode ) ; } else { logger . debug ( <str> , otherNode ) ; } } listedNodes = Collections . unmodifiableList ( builder ) ; nodesSampler . sample ( ) ; } return this ; } public < Response > void execute ( NodeListenerCallback < Response > callback , ActionListener < Response > listener ) { List < DiscoveryNode > nodes = this . nodes ; ensureNodesAreAvailable ( nodes ) ; int index = getNodeNumber ( ) ; RetryListener < Response > retryListener = new RetryListener < > ( callback , listener , nodes , index ) ; DiscoveryNode node = nodes . get ( ( index ) % nodes . size ( ) ) ; try { callback . doWithNode ( node , retryListener ) ; } catch ( Throwable t ) { listener . onFailure ( t ) ; } } public static class RetryListener < Response > implements ActionListener < Response > { private final NodeListenerCallback < Response > callback ; private final ActionListener < Response > listener ; private final List < DiscoveryNode > nodes ; private final int index ; private volatile int i ; public RetryListener ( NodeListenerCallback < Response > callback , ActionListener < Response > listener , List < DiscoveryNode > nodes , int index ) { this . callback = callback ; this . listener = listener ; this . nodes = nodes ; this . index = index ; } @Override public void onResponse ( Response response ) { listener . onResponse ( response ) ; } @Override public void onFailure ( Throwable e ) { if ( ExceptionsHelper . unwrapCause ( e ) instanceof ConnectTransportException ) { int i = + + this . i ; if ( i > = nodes . size ( ) ) { listener . onFailure ( new NoNodeAvailableException ( <str> + nodes , e ) ) ; } else { try { callback . doWithNode ( nodes . get ( ( index + i ) % nodes . size ( ) ) , this ) ; } catch ( final Throwable t ) { listener . onFailure ( t ) ; } } } else { listener . onFailure ( e ) ; } } } public void close ( ) { synchronized ( mutex ) { if ( closed ) { return ; } closed = true ; FutureUtils . cancel ( nodesSamplerFuture ) ; for ( DiscoveryNode node : nodes ) { transportService . disconnectFromNode ( node ) ; } for ( DiscoveryNode listedNode : listedNodes ) { transportService . disconnectFromNode ( listedNode ) ; } nodes = Collections . emptyList ( ) ; } } private int getNodeNumber ( ) { int index = randomNodeGenerator . incrementAndGet ( ) ; if ( index < <int> ) { index = <int> ; randomNodeGenerator . set ( <int> ) ; } return index ; } private void ensureNodesAreAvailable ( List < DiscoveryNode > nodes ) { if ( nodes . isEmpty ( ) ) { String message = String . format ( Locale . ROOT , <str> , this . listedNodes ) ; throw new NoNodeAvailableException ( message ) ; } } abstract class NodeSampler { public void sample ( ) { synchronized ( mutex ) { if ( closed ) { return ; } doSample ( ) ; } } protected abstract void doSample ( ) ; protected List < DiscoveryNode > validateNewNodes ( Set < DiscoveryNode > nodes ) { for ( Iterator < DiscoveryNode > it = nodes . iterator ( ) ; it . hasNext ( ) ; ) { DiscoveryNode node = it . next ( ) ; if ( ! transportService . nodeConnected ( node ) ) { try { logger . trace ( <str> , node ) ; transportService . connectToNode ( node ) ; } catch ( Throwable e ) { it . remove ( ) ; logger . debug ( <str> + node + <str> , e ) ; } } } return Collections . unmodifiableList ( new ArrayList < > ( nodes ) ) ; } } class ScheduledNodeSampler implements Runnable { @Override public void run ( ) { try { nodesSampler . sample ( ) ; if ( ! closed ) { nodesSamplerFuture = threadPool . schedule ( nodesSamplerInterval , ThreadPool . Names . GENERIC , this ) ; } } catch ( Exception e ) { logger . warn ( <str> , e ) ; } } } class SimpleNodeSampler extends NodeSampler { @Override protected void doSample ( ) { HashSet < DiscoveryNode > newNodes = new HashSet < > ( ) ; HashSet < DiscoveryNode > newFilteredNodes = new HashSet < > ( ) ; for ( DiscoveryNode listedNode : listedNodes ) { if ( ! transportService . nodeConnected ( listedNode ) ) { try { logger . trace ( <str> , listedNode ) ; transportService . connectToNodeLight ( listedNode ) ; } catch ( Throwable e ) { logger . debug ( <str> , e , listedNode ) ; continue ; } } try { LivenessResponse livenessResponse = transportService . submitRequest ( listedNode , TransportLivenessAction . NAME , headers . applyTo ( new LivenessRequest ( ) ) , TransportRequestOptions . builder ( ) . withType ( TransportRequestOptions . Type . STATE ) . withTimeout ( pingTimeout ) . build ( ) , new FutureTransportResponseHandler < LivenessResponse > ( ) { @Override public LivenessResponse newInstance ( ) { return new LivenessResponse ( ) ; } } ) . txGet ( ) ; if ( ! ignoreClusterName & & ! clusterName . equals ( livenessResponse . getClusterName ( ) ) ) { logger . warn ( <str> , listedNode , clusterName ) ; newFilteredNodes . add ( listedNode ) ; } else if ( livenessResponse . getDiscoveryNode ( ) ! = null ) { DiscoveryNode nodeWithInfo = livenessResponse . getDiscoveryNode ( ) ; newNodes . add ( new DiscoveryNode ( nodeWithInfo . name ( ) , nodeWithInfo . id ( ) , nodeWithInfo . getHostName ( ) , nodeWithInfo . getHostAddress ( ) , listedNode . address ( ) , nodeWithInfo . attributes ( ) , nodeWithInfo . version ( ) ) ) ; } else { logger . debug ( <str> , listedNode ) ; newNodes . add ( listedNode ) ; } } catch ( Throwable e ) { logger . info ( <str> , e , listedNode ) ; transportService . disconnectFromNode ( listedNode ) ; } } nodes = validateNewNodes ( newNodes ) ; filteredNodes = Collections . unmodifiableList ( new ArrayList < > ( newFilteredNodes ) ) ; } } class SniffNodesSampler extends NodeSampler { @Override protected void doSample ( ) { Set < DiscoveryNode > nodesToPing = new HashSet < > ( ) ; for ( DiscoveryNode node : listedNodes ) { nodesToPing . add ( node ) ; } for ( DiscoveryNode node : nodes ) { nodesToPing . add ( node ) ; } final CountDownLatch latch = new CountDownLatch ( nodesToPing . size ( ) ) ; final ConcurrentMap < DiscoveryNode , ClusterStateResponse > clusterStateResponses = ConcurrentCollections . newConcurrentMap ( ) ; for ( final DiscoveryNode listedNode : nodesToPing ) { threadPool . executor ( ThreadPool . Names . MANAGEMENT ) . execute ( new Runnable ( ) { @Override public void run ( ) { try { if ( ! transportService . nodeConnected ( listedNode ) ) { try { if ( nodes . contains ( listedNode ) ) { logger . trace ( <str> , listedNode ) ; transportService . connectToNode ( listedNode ) ; } else { logger . trace ( <str> , listedNode ) ; transportService . connectToNodeLight ( listedNode ) ; } } catch ( Exception e ) { logger . debug ( <str> , e , listedNode ) ; latch . countDown ( ) ; return ; } } transportService . sendRequest ( listedNode , ClusterStateAction . NAME , headers . applyTo ( Requests . clusterStateRequest ( ) . clear ( ) . nodes ( true ) . local ( true ) ) , TransportRequestOptions . builder ( ) . withType ( TransportRequestOptions . Type . STATE ) . withTimeout ( pingTimeout ) . build ( ) , new BaseTransportResponseHandler < ClusterStateResponse > ( ) { @Override public ClusterStateResponse newInstance ( ) { return new ClusterStateResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } @Override public void handleResponse ( ClusterStateResponse response ) { clusterStateResponses . put ( listedNode , response ) ; latch . countDown ( ) ; } @Override public void handleException ( TransportException e ) { logger . info ( <str> , e , listedNode ) ; transportService . disconnectFromNode ( listedNode ) ; latch . countDown ( ) ; } } ) ; } catch ( Throwable e ) { logger . info ( <str> , e , listedNode ) ; transportService . disconnectFromNode ( listedNode ) ; latch . countDown ( ) ; } } } ) ; } try { latch . await ( ) ; } catch ( InterruptedException e ) { return ; } HashSet < DiscoveryNode > newNodes = new HashSet < > ( ) ; HashSet < DiscoveryNode > newFilteredNodes = new HashSet < > ( ) ; for ( Map . Entry < DiscoveryNode , ClusterStateResponse > entry : clusterStateResponses . entrySet ( ) ) { if ( ! ignoreClusterName & & ! clusterName . equals ( entry . getValue ( ) . getClusterName ( ) ) ) { logger . warn ( <str> , entry . getValue ( ) . getState ( ) . nodes ( ) . localNode ( ) , clusterName ) ; newFilteredNodes . add ( entry . getKey ( ) ) ; continue ; } for ( ObjectCursor < DiscoveryNode > cursor : entry . getValue ( ) . getState ( ) . nodes ( ) . dataNodes ( ) . values ( ) ) { newNodes . add ( cursor . value ) ; } } nodes = validateNewNodes ( newNodes ) ; filteredNodes = Collections . unmodifiableList ( new ArrayList < > ( newFilteredNodes ) ) ; } } public interface NodeListenerCallback < Response > { void doWithNode ( DiscoveryNode node , ActionListener < Response > listener ) ; } } 
