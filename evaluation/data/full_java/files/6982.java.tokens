package org . elasticsearch . rest . action . admin . indices . alias . get ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . action . admin . indices . alias . get . GetAliasesRequest ; import org . elasticsearch . action . admin . indices . alias . get . GetAliasesResponse ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . metadata . AliasMetaData ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import java . util . List ; import java . util . Locale ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestStatus . OK ; public class RestGetAliasesAction extends BaseRestHandler { @Inject public RestGetAliasesAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final String [ ] aliases = request . paramAsStringArrayOrEmptyIfAll ( <str> ) ; final String [ ] indices = Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ; final GetAliasesRequest getAliasesRequest = new GetAliasesRequest ( aliases ) ; getAliasesRequest . indices ( indices ) ; getAliasesRequest . indicesOptions ( IndicesOptions . fromRequest ( request , getAliasesRequest . indicesOptions ( ) ) ) ; getAliasesRequest . local ( request . paramAsBoolean ( <str> , getAliasesRequest . local ( ) ) ) ; client . admin ( ) . indices ( ) . getAliases ( getAliasesRequest , new RestBuilderListener < GetAliasesResponse > ( channel ) { @Override public RestResponse buildResponse ( GetAliasesResponse response , XContentBuilder builder ) throws Exception { if ( indices . length > <int> & & response . getAliases ( ) . isEmpty ( ) ) { return new BytesRestResponse ( OK , builder . startObject ( ) . endObject ( ) ) ; } else if ( response . getAliases ( ) . isEmpty ( ) ) { String message = String . format ( Locale . ROOT , <str> , toNamesString ( getAliasesRequest . aliases ( ) ) ) ; builder . startObject ( ) . field ( <str> , message ) . field ( <str> , RestStatus . NOT_FOUND . getStatus ( ) ) . endObject ( ) ; return new BytesRestResponse ( RestStatus . NOT_FOUND , builder ) ; } builder . startObject ( ) ; for ( ObjectObjectCursor < String , List < AliasMetaData > > entry : response . getAliases ( ) ) { builder . startObject ( entry . key , XContentBuilder . FieldCaseConversion . NONE ) ; builder . startObject ( Fields . ALIASES ) ; for ( AliasMetaData alias : entry . value ) { AliasMetaData . Builder . toXContent ( alias , builder , ToXContent . EMPTY_PARAMS ) ; } builder . endObject ( ) ; builder . endObject ( ) ; } builder . endObject ( ) ; return new BytesRestResponse ( OK , builder ) ; } } ) ; } private static String toNamesString ( String . . . names ) { if ( names = = null | | names . length = = <int> ) { return <str> ; } else if ( names . length = = <int> ) { return names [ <int> ] ; } else { StringBuilder builder = new StringBuilder ( names [ <int> ] ) ; for ( int i = <int> ; i < names . length ; i + + ) { builder . append ( <str> ) . append ( names [ i ] ) ; } return builder . toString ( ) ; } } static class Fields { static final XContentBuilderString ALIASES = new XContentBuilderString ( <str> ) ; } } 
