package com . google . common . collect . testing . testers ; import static com . google . common . collect . testing . features . CollectionFeature . SUPPORTS_REMOVE ; import static com . google . common . collect . testing . features . CollectionSize . ONE ; import static com . google . common . collect . testing . features . CollectionSize . SEVERAL ; import static com . google . common . collect . testing . features . CollectionSize . ZERO ; import com . google . common . collect . testing . Helpers ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . NavigableSet ; import java . util . TreeSet ; public class NavigableSetNavigationTester < E > extends AbstractSetTester < E > { private NavigableSet < E > navigableSet ; private List < E > values ; private E a ; private E b ; private E c ; @Override public void setUp ( ) throws Exception { super . setUp ( ) ; navigableSet = ( NavigableSet < E > ) getSet ( ) ; values = Helpers . copyToList ( getSubjectGenerator ( ) . getSampleElements ( getSubjectGenerator ( ) . getCollectionSize ( ) . getNumElements ( ) ) ) ; Collections . sort ( values , navigableSet . comparator ( ) ) ; if ( values . size ( ) > = <int> ) { a = values . get ( <int> ) ; if ( values . size ( ) > = <int> ) { b = values . get ( <int> ) ; c = values . get ( <int> ) ; } } } protected void resetWithHole ( ) { super . resetContainer ( getSubjectGenerator ( ) . create ( a , c ) ) ; navigableSet = ( NavigableSet < E > ) getSet ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testEmptySetPollFirst ( ) { assertNull ( navigableSet . pollFirst ( ) ) ; } @CollectionSize.Require ( ZERO ) public void testEmptySetNearby ( ) { assertNull ( navigableSet . lower ( e0 ( ) ) ) ; assertNull ( navigableSet . floor ( e0 ( ) ) ) ; assertNull ( navigableSet . ceiling ( e0 ( ) ) ) ; assertNull ( navigableSet . higher ( e0 ( ) ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testEmptySetPollLast ( ) { assertNull ( navigableSet . pollLast ( ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ONE ) public void testSingletonSetPollFirst ( ) { assertEquals ( a , navigableSet . pollFirst ( ) ) ; assertTrue ( navigableSet . isEmpty ( ) ) ; } @CollectionSize.Require ( ONE ) public void testSingletonSetNearby ( ) { assertNull ( navigableSet . lower ( e0 ( ) ) ) ; assertEquals ( a , navigableSet . floor ( e0 ( ) ) ) ; assertEquals ( a , navigableSet . ceiling ( e0 ( ) ) ) ; assertNull ( navigableSet . higher ( e0 ( ) ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ONE ) public void testSingletonSetPollLast ( ) { assertEquals ( a , navigableSet . pollLast ( ) ) ; assertTrue ( navigableSet . isEmpty ( ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( SEVERAL ) public void testPollFirst ( ) { assertEquals ( a , navigableSet . pollFirst ( ) ) ; assertEquals ( values . subList ( <int> , values . size ( ) ) , Helpers . copyToList ( navigableSet ) ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) public void testPollFirstUnsupported ( ) { try { navigableSet . pollFirst ( ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } } @CollectionSize.Require ( SEVERAL ) public void testLowerHole ( ) { resetWithHole ( ) ; assertEquals ( null , navigableSet . lower ( a ) ) ; assertEquals ( a , navigableSet . lower ( b ) ) ; assertEquals ( a , navigableSet . lower ( c ) ) ; } @CollectionSize.Require ( SEVERAL ) public void testFloorHole ( ) { resetWithHole ( ) ; assertEquals ( a , navigableSet . floor ( a ) ) ; assertEquals ( a , navigableSet . floor ( b ) ) ; assertEquals ( c , navigableSet . floor ( c ) ) ; } @CollectionSize.Require ( SEVERAL ) public void testCeilingHole ( ) { resetWithHole ( ) ; assertEquals ( a , navigableSet . ceiling ( a ) ) ; assertEquals ( c , navigableSet . ceiling ( b ) ) ; assertEquals ( c , navigableSet . ceiling ( c ) ) ; } @CollectionSize.Require ( SEVERAL ) public void testHigherHole ( ) { resetWithHole ( ) ; assertEquals ( c , navigableSet . higher ( a ) ) ; assertEquals ( c , navigableSet . higher ( b ) ) ; assertEquals ( null , navigableSet . higher ( c ) ) ; } @CollectionSize.Require ( SEVERAL ) public void testLower ( ) { assertEquals ( null , navigableSet . lower ( a ) ) ; assertEquals ( a , navigableSet . lower ( b ) ) ; assertEquals ( b , navigableSet . lower ( c ) ) ; } @CollectionSize.Require ( SEVERAL ) public void testFloor ( ) { assertEquals ( a , navigableSet . floor ( a ) ) ; assertEquals ( b , navigableSet . floor ( b ) ) ; assertEquals ( c , navigableSet . floor ( c ) ) ; } @CollectionSize.Require ( SEVERAL ) public void testCeiling ( ) { assertEquals ( a , navigableSet . ceiling ( a ) ) ; assertEquals ( b , navigableSet . ceiling ( b ) ) ; assertEquals ( c , navigableSet . ceiling ( c ) ) ; } @CollectionSize.Require ( SEVERAL ) public void testHigher ( ) { assertEquals ( b , navigableSet . higher ( a ) ) ; assertEquals ( c , navigableSet . higher ( b ) ) ; assertEquals ( null , navigableSet . higher ( c ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( SEVERAL ) public void testPollLast ( ) { assertEquals ( c , navigableSet . pollLast ( ) ) ; assertEquals ( values . subList ( <int> , values . size ( ) - <int> ) , Helpers . copyToList ( navigableSet ) ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) public void testPollLastUnsupported ( ) { try { navigableSet . pollLast ( ) ; fail ( ) ; } catch ( UnsupportedOperationException e ) { } } @CollectionSize.Require ( SEVERAL ) public void testDescendingNavigation ( ) { List < E > descending = new ArrayList < E > ( ) ; for ( Iterator < E > i = navigableSet . descendingIterator ( ) ; i . hasNext ( ) ; ) { descending . add ( i . next ( ) ) ; } Collections . reverse ( descending ) ; assertEquals ( values , descending ) ; } public void testEmptySubSet ( ) { NavigableSet < E > empty = navigableSet . subSet ( e0 ( ) , false , e0 ( ) , false ) ; assertEquals ( new TreeSet < E > ( ) , empty ) ; } public static Method [ ] getHoleMethods ( ) { return new Method [ ] { Helpers . getMethod ( NavigableSetNavigationTester . class , <str> ) , Helpers . getMethod ( NavigableSetNavigationTester . class , <str> ) , Helpers . getMethod ( NavigableSetNavigationTester . class , <str> ) , Helpers . getMethod ( NavigableSetNavigationTester . class , <str> ) , } ; } } 
