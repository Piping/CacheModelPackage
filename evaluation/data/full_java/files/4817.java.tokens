package org . eclipse . ui . internal . console ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . DocumentEvent ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentListener ; import org . eclipse . ui . console . ConsolePlugin ; import org . eclipse . ui . console . IPatternMatchListener ; import org . eclipse . ui . console . PatternMatchEvent ; import org . eclipse . ui . console . TextConsole ; public class ConsolePatternMatcher implements IDocumentListener { private MatchJob fMatchJob = new MatchJob ( ) ; private ArrayList < CompiledPatternMatchListener > fPatterns = new ArrayList < CompiledPatternMatchListener > ( ) ; private TextConsole fConsole ; private boolean fFinalMatch ; private boolean fScheduleFinal ; public ConsolePatternMatcher ( TextConsole console ) { fConsole = console ; } private class MatchJob extends Job { MatchJob ( ) { super ( <str> ) ; setSystem ( true ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { IDocument doc = fConsole . getDocument ( ) ; String text = null ; int prevBaseOffset = - <int> ; if ( doc ! = null & & ! monitor . isCanceled ( ) ) { int endOfSearch = doc . getLength ( ) ; int indexOfLastChar = endOfSearch ; if ( indexOfLastChar > <int> ) { indexOfLastChar - - ; } int lastLineToSearch = <int> ; int offsetOfLastLineToSearch = <int> ; try { lastLineToSearch = doc . getLineOfOffset ( indexOfLastChar ) ; offsetOfLastLineToSearch = doc . getLineOffset ( lastLineToSearch ) ; } catch ( BadLocationException e ) { return Status . OK_STATUS ; } Object [ ] patterns = null ; synchronized ( fPatterns ) { patterns = fPatterns . toArray ( ) ; } for ( int i = <int> ; i < patterns . length ; i + + ) { if ( monitor . isCanceled ( ) ) { break ; } CompiledPatternMatchListener notifier = ( CompiledPatternMatchListener ) patterns [ i ] ; int baseOffset = notifier . end ; int lengthToSearch = endOfSearch - baseOffset ; if ( lengthToSearch > <int> ) { try { if ( prevBaseOffset ! = baseOffset ) { text = doc . get ( baseOffset , lengthToSearch ) ; } if ( text = = null ) { continue ; } Matcher reg = notifier . pattern . matcher ( text ) ; Matcher quick = null ; if ( notifier . qualifier ! = null ) { quick = notifier . qualifier . matcher ( text ) ; } int startOfNextSearch = <int> ; int endOfLastMatch = - <int> ; int lineOfLastMatch = - <int> ; while ( ( startOfNextSearch < lengthToSearch ) & & ! monitor . isCanceled ( ) ) { if ( quick ! = null ) { if ( quick . find ( startOfNextSearch ) ) { int matchLine = doc . getLineOfOffset ( baseOffset + quick . start ( ) ) ; if ( lineOfLastMatch = = matchLine ) { startOfNextSearch = endOfLastMatch ; } else { startOfNextSearch = doc . getLineOffset ( matchLine ) - baseOffset ; } } else { startOfNextSearch = lengthToSearch ; } } if ( startOfNextSearch < <int> ) { startOfNextSearch = <int> ; } if ( startOfNextSearch < lengthToSearch ) { if ( reg . find ( startOfNextSearch ) ) { endOfLastMatch = reg . end ( ) ; lineOfLastMatch = doc . getLineOfOffset ( baseOffset + endOfLastMatch - <int> ) ; int regStart = reg . start ( ) ; IPatternMatchListener listener = notifier . listener ; if ( listener ! = null & & ! monitor . isCanceled ( ) ) { listener . matchFound ( new PatternMatchEvent ( fConsole , baseOffset + regStart , endOfLastMatch - regStart ) ) ; } startOfNextSearch = endOfLastMatch ; } else { startOfNextSearch = lengthToSearch ; } } } if ( lastLineToSearch = = lineOfLastMatch ) { notifier . end = baseOffset + endOfLastMatch ; } else { notifier . end = offsetOfLastLineToSearch ; } } catch ( BadLocationException e ) { ConsolePlugin . log ( e ) ; } } prevBaseOffset = baseOffset ; } } if ( fFinalMatch ) { disconnect ( ) ; fConsole . matcherFinished ( ) ; } else if ( fScheduleFinal ) { fFinalMatch = true ; schedule ( ) ; } return Status . OK_STATUS ; } @Override public boolean belongsTo ( Object family ) { return family = = fConsole ; } } private class CompiledPatternMatchListener { Pattern pattern ; Pattern qualifier ; IPatternMatchListener listener ; int end = <int> ; CompiledPatternMatchListener ( Pattern pattern , Pattern qualifier , IPatternMatchListener matchListener ) { this . pattern = pattern ; this . listener = matchListener ; this . qualifier = qualifier ; } public void dispose ( ) { listener . disconnect ( ) ; pattern = null ; qualifier = null ; listener = null ; } } public void addPatternMatchListener ( IPatternMatchListener matchListener ) { synchronized ( fPatterns ) { for ( CompiledPatternMatchListener listener : fPatterns ) { if ( listener . listener = = matchListener ) { return ; } } if ( matchListener = = null | | matchListener . getPattern ( ) = = null ) { throw new IllegalArgumentException ( <str> ) ; } Pattern pattern = Pattern . compile ( matchListener . getPattern ( ) , matchListener . getCompilerFlags ( ) ) ; String qualifier = matchListener . getLineQualifier ( ) ; Pattern qPattern = null ; if ( qualifier ! = null ) { qPattern = Pattern . compile ( qualifier , matchListener . getCompilerFlags ( ) ) ; } CompiledPatternMatchListener notifier = new CompiledPatternMatchListener ( pattern , qPattern , matchListener ) ; fPatterns . add ( notifier ) ; matchListener . connect ( fConsole ) ; fMatchJob . schedule ( ) ; } } public void removePatternMatchListener ( IPatternMatchListener matchListener ) { synchronized ( fPatterns ) { for ( Iterator < CompiledPatternMatchListener > iter = fPatterns . iterator ( ) ; iter . hasNext ( ) ; ) { CompiledPatternMatchListener element = iter . next ( ) ; if ( element . listener = = matchListener ) { iter . remove ( ) ; matchListener . disconnect ( ) ; } } } } public void disconnect ( ) { fMatchJob . cancel ( ) ; synchronized ( fPatterns ) { for ( CompiledPatternMatchListener listener : fPatterns ) { listener . dispose ( ) ; } fPatterns . clear ( ) ; } } @Override public void documentAboutToBeChanged ( DocumentEvent event ) { } @Override public void documentChanged ( DocumentEvent event ) { if ( event . fLength > <int> ) { synchronized ( fPatterns ) { if ( event . fDocument . getLength ( ) = = <int> ) { for ( CompiledPatternMatchListener notifier : fPatterns ) { notifier . end = <int> ; } } else { if ( event . fOffset = = <int> ) { for ( CompiledPatternMatchListener notifier : fPatterns ) { notifier . end = notifier . end > event . fLength ? notifier . end - event . fLength : <int> ; } } } } } fMatchJob . schedule ( ) ; } public void forceFinalMatching ( ) { fScheduleFinal = true ; fMatchJob . schedule ( ) ; } } 
