package com . google . common . reflect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . Iterables . transform ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Function ; import com . google . common . base . Joiner ; import com . google . common . base . Objects ; import com . google . common . base . Predicates ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Iterables ; import java . io . Serializable ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Array ; import java . lang . reflect . GenericArrayType ; import java . lang . reflect . GenericDeclaration ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Proxy ; import java . lang . reflect . Type ; import java . lang . reflect . TypeVariable ; import java . lang . reflect . WildcardType ; import java . security . AccessControlException ; import java . util . Arrays ; import java . util . Collection ; import java . util . concurrent . atomic . AtomicReference ; import javax . annotation . Nullable ; final class Types { private static final Function < Type , String > TYPE_NAME = new Function < Type , String > ( ) { @Override public String apply ( Type from ) { return JavaVersion . CURRENT . typeName ( from ) ; } } ; private static final Joiner COMMA_JOINER = Joiner . on ( <str> ) . useForNull ( <str> ) ; static Type newArrayType ( Type componentType ) { if ( componentType instanceof WildcardType ) { WildcardType wildcard = ( WildcardType ) componentType ; Type [ ] lowerBounds = wildcard . getLowerBounds ( ) ; checkArgument ( lowerBounds . length < = <int> , <str> ) ; if ( lowerBounds . length = = <int> ) { return supertypeOf ( newArrayType ( lowerBounds [ <int> ] ) ) ; } else { Type [ ] upperBounds = wildcard . getUpperBounds ( ) ; checkArgument ( upperBounds . length = = <int> , <str> ) ; return subtypeOf ( newArrayType ( upperBounds [ <int> ] ) ) ; } } return JavaVersion . CURRENT . newArrayType ( componentType ) ; } static ParameterizedType newParameterizedTypeWithOwner ( @Nullable Type ownerType , Class < ? > rawType , Type . . . arguments ) { if ( ownerType = = null ) { return newParameterizedType ( rawType , arguments ) ; } checkNotNull ( arguments ) ; checkArgument ( rawType . getEnclosingClass ( ) ! = null , <str> , rawType ) ; return new ParameterizedTypeImpl ( ownerType , rawType , arguments ) ; } static ParameterizedType newParameterizedType ( Class < ? > rawType , Type . . . arguments ) { return new ParameterizedTypeImpl ( ClassOwnership . JVM_BEHAVIOR . getOwnerType ( rawType ) , rawType , arguments ) ; } private enum ClassOwnership { OWNED_BY_ENCLOSING_CLASS { @Nullable @Override Class < ? > getOwnerType ( Class < ? > rawType ) { return rawType . getEnclosingClass ( ) ; } } , LOCAL_CLASS_HAS_NO_OWNER { @Nullable @Override Class < ? > getOwnerType ( Class < ? > rawType ) { if ( rawType . isLocalClass ( ) ) { return null ; } else { return rawType . getEnclosingClass ( ) ; } } } ; @Nullable abstract Class < ? > getOwnerType ( Class < ? > rawType ) ; static final ClassOwnership JVM_BEHAVIOR = detectJvmBehavior ( ) ; private static ClassOwnership detectJvmBehavior ( ) { class LocalClass < T > { } Class < ? > subclass = new LocalClass < String > ( ) { } . getClass ( ) ; ParameterizedType parameterizedType = ( ParameterizedType ) subclass . getGenericSuperclass ( ) ; for ( ClassOwnership behavior : ClassOwnership . values ( ) ) { if ( behavior . getOwnerType ( LocalClass . class ) = = parameterizedType . getOwnerType ( ) ) { return behavior ; } } throw new AssertionError ( ) ; } } static < D extends GenericDeclaration > TypeVariable < D > newArtificialTypeVariable ( D declaration , String name , Type . . . bounds ) { return newTypeVariableImpl ( declaration , name , ( bounds . length = = <int> ) ? new Type [ ] { Object . class } : bounds ) ; } @VisibleForTesting static WildcardType subtypeOf ( Type upperBound ) { return new WildcardTypeImpl ( new Type [ <int> ] , new Type [ ] { upperBound } ) ; } @VisibleForTesting static WildcardType supertypeOf ( Type lowerBound ) { return new WildcardTypeImpl ( new Type [ ] { lowerBound } , new Type [ ] { Object . class } ) ; } static String toString ( Type type ) { return ( type instanceof Class ) ? ( ( Class < ? > ) type ) . getName ( ) : type . toString ( ) ; } @Nullable static Type getComponentType ( Type type ) { checkNotNull ( type ) ; final AtomicReference < Type > result = new AtomicReference < Type > ( ) ; new TypeVisitor ( ) { @Override void visitTypeVariable ( TypeVariable < ? > t ) { result . set ( subtypeOfComponentType ( t . getBounds ( ) ) ) ; } @Override void visitWildcardType ( WildcardType t ) { result . set ( subtypeOfComponentType ( t . getUpperBounds ( ) ) ) ; } @Override void visitGenericArrayType ( GenericArrayType t ) { result . set ( t . getGenericComponentType ( ) ) ; } @Override void visitClass ( Class < ? > t ) { result . set ( t . getComponentType ( ) ) ; } } . visit ( type ) ; return result . get ( ) ; } @Nullable private static Type subtypeOfComponentType ( Type [ ] bounds ) { for ( Type bound : bounds ) { Type componentType = getComponentType ( bound ) ; if ( componentType ! = null ) { if ( componentType instanceof Class ) { Class < ? > componentClass = ( Class < ? > ) componentType ; if ( componentClass . isPrimitive ( ) ) { return componentClass ; } } return subtypeOf ( componentType ) ; } } return null ; } private static final class GenericArrayTypeImpl implements GenericArrayType , Serializable { private final Type componentType ; GenericArrayTypeImpl ( Type componentType ) { this . componentType = JavaVersion . CURRENT . usedInGenericType ( componentType ) ; } @Override public Type getGenericComponentType ( ) { return componentType ; } @Override public String toString ( ) { return Types . toString ( componentType ) + <str> ; } @Override public int hashCode ( ) { return componentType . hashCode ( ) ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof GenericArrayType ) { GenericArrayType that = ( GenericArrayType ) obj ; return Objects . equal ( getGenericComponentType ( ) , that . getGenericComponentType ( ) ) ; } return false ; } private static final long serialVersionUID = <int> ; } private static final class ParameterizedTypeImpl implements ParameterizedType , Serializable { private final Type ownerType ; private final ImmutableList < Type > argumentsList ; private final Class < ? > rawType ; ParameterizedTypeImpl ( @Nullable Type ownerType , Class < ? > rawType , Type [ ] typeArguments ) { checkNotNull ( rawType ) ; checkArgument ( typeArguments . length = = rawType . getTypeParameters ( ) . length ) ; disallowPrimitiveType ( typeArguments , <str> ) ; this . ownerType = ownerType ; this . rawType = rawType ; this . argumentsList = JavaVersion . CURRENT . usedInGenericType ( typeArguments ) ; } @Override public Type [ ] getActualTypeArguments ( ) { return toArray ( argumentsList ) ; } @Override public Type getRawType ( ) { return rawType ; } @Override public Type getOwnerType ( ) { return ownerType ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( ownerType ! = null ) { builder . append ( JavaVersion . CURRENT . typeName ( ownerType ) ) . append ( <str> ) ; } builder . append ( rawType . getName ( ) ) . append ( <str> ) . append ( COMMA_JOINER . join ( transform ( argumentsList , TYPE_NAME ) ) ) . append ( <str> ) ; return builder . toString ( ) ; } @Override public int hashCode ( ) { return ( ownerType = = null ? <int> : ownerType . hashCode ( ) ) ^ argumentsList . hashCode ( ) ^ rawType . hashCode ( ) ; } @Override public boolean equals ( Object other ) { if ( ! ( other instanceof ParameterizedType ) ) { return false ; } ParameterizedType that = ( ParameterizedType ) other ; return getRawType ( ) . equals ( that . getRawType ( ) ) & & Objects . equal ( getOwnerType ( ) , that . getOwnerType ( ) ) & & Arrays . equals ( getActualTypeArguments ( ) , that . getActualTypeArguments ( ) ) ; } private static final long serialVersionUID = <int> ; } private static < D extends GenericDeclaration > TypeVariable < D > newTypeVariableImpl ( D genericDeclaration , String name , Type [ ] bounds ) { TypeVariableImpl < D > typeVariableImpl = new TypeVariableImpl < D > ( genericDeclaration , name , bounds ) ; @SuppressWarnings ( <str> ) TypeVariable < D > typeVariable = Reflection . newProxy ( TypeVariable . class , new TypeVariableInvocationHandler ( typeVariableImpl ) ) ; return typeVariable ; } private static final class TypeVariableInvocationHandler implements InvocationHandler { private static final ImmutableMap < String , Method > typeVariableMethods ; static { ImmutableMap . Builder < String , Method > builder = ImmutableMap . builder ( ) ; for ( Method method : TypeVariableImpl . class . getMethods ( ) ) { if ( method . getDeclaringClass ( ) . equals ( TypeVariableImpl . class ) ) { try { method . setAccessible ( true ) ; } catch ( AccessControlException e ) { } builder . put ( method . getName ( ) , method ) ; } } typeVariableMethods = builder . build ( ) ; } private final TypeVariableImpl < ? > typeVariableImpl ; TypeVariableInvocationHandler ( TypeVariableImpl < ? > typeVariableImpl ) { this . typeVariableImpl = typeVariableImpl ; } @Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { String methodName = method . getName ( ) ; Method typeVariableMethod = typeVariableMethods . get ( methodName ) ; if ( typeVariableMethod = = null ) { throw new UnsupportedOperationException ( methodName ) ; } else { try { return typeVariableMethod . invoke ( typeVariableImpl , args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } } } } private static final class TypeVariableImpl < D extends GenericDeclaration > { private final D genericDeclaration ; private final String name ; private final ImmutableList < Type > bounds ; TypeVariableImpl ( D genericDeclaration , String name , Type [ ] bounds ) { disallowPrimitiveType ( bounds , <str> ) ; this . genericDeclaration = checkNotNull ( genericDeclaration ) ; this . name = checkNotNull ( name ) ; this . bounds = ImmutableList . copyOf ( bounds ) ; } public Type [ ] getBounds ( ) { return toArray ( bounds ) ; } public D getGenericDeclaration ( ) { return genericDeclaration ; } public String getName ( ) { return name ; } public String getTypeName ( ) { return name ; } @Override public String toString ( ) { return name ; } @Override public int hashCode ( ) { return genericDeclaration . hashCode ( ) ^ name . hashCode ( ) ; } @Override public boolean equals ( Object obj ) { if ( NativeTypeVariableEquals . NATIVE_TYPE_VARIABLE_ONLY ) { if ( obj ! = null & & Proxy . isProxyClass ( obj . getClass ( ) ) & & Proxy . getInvocationHandler ( obj ) instanceof TypeVariableInvocationHandler ) { TypeVariableInvocationHandler typeVariableInvocationHandler = ( TypeVariableInvocationHandler ) Proxy . getInvocationHandler ( obj ) ; TypeVariableImpl < ? > that = typeVariableInvocationHandler . typeVariableImpl ; return name . equals ( that . getName ( ) ) & & genericDeclaration . equals ( that . getGenericDeclaration ( ) ) & & bounds . equals ( that . bounds ) ; } return false ; } else { if ( obj instanceof TypeVariable ) { TypeVariable < ? > that = ( TypeVariable < ? > ) obj ; return name . equals ( that . getName ( ) ) & & genericDeclaration . equals ( that . getGenericDeclaration ( ) ) ; } return false ; } } } static final class WildcardTypeImpl implements WildcardType , Serializable { private final ImmutableList < Type > lowerBounds ; private final ImmutableList < Type > upperBounds ; WildcardTypeImpl ( Type [ ] lowerBounds , Type [ ] upperBounds ) { disallowPrimitiveType ( lowerBounds , <str> ) ; disallowPrimitiveType ( upperBounds , <str> ) ; this . lowerBounds = JavaVersion . CURRENT . usedInGenericType ( lowerBounds ) ; this . upperBounds = JavaVersion . CURRENT . usedInGenericType ( upperBounds ) ; } @Override public Type [ ] getLowerBounds ( ) { return toArray ( lowerBounds ) ; } @Override public Type [ ] getUpperBounds ( ) { return toArray ( upperBounds ) ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof WildcardType ) { WildcardType that = ( WildcardType ) obj ; return lowerBounds . equals ( Arrays . asList ( that . getLowerBounds ( ) ) ) & & upperBounds . equals ( Arrays . asList ( that . getUpperBounds ( ) ) ) ; } return false ; } @Override public int hashCode ( ) { return lowerBounds . hashCode ( ) ^ upperBounds . hashCode ( ) ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( <str> ) ; for ( Type lowerBound : lowerBounds ) { builder . append ( <str> ) . append ( JavaVersion . CURRENT . typeName ( lowerBound ) ) ; } for ( Type upperBound : filterUpperBounds ( upperBounds ) ) { builder . append ( <str> ) . append ( JavaVersion . CURRENT . typeName ( upperBound ) ) ; } return builder . toString ( ) ; } private static final long serialVersionUID = <int> ; } private static Type [ ] toArray ( Collection < Type > types ) { return types . toArray ( new Type [ types . size ( ) ] ) ; } private static Iterable < Type > filterUpperBounds ( Iterable < Type > bounds ) { return Iterables . filter ( bounds , Predicates . not ( Predicates . < Type > equalTo ( Object . class ) ) ) ; } private static void disallowPrimitiveType ( Type [ ] types , String usedAs ) { for ( Type type : types ) { if ( type instanceof Class ) { Class < ? > cls = ( Class < ? > ) type ; checkArgument ( ! cls . isPrimitive ( ) , <str> , cls , usedAs ) ; } } } static Class < ? > getArrayClass ( Class < ? > componentType ) { return Array . newInstance ( componentType , <int> ) . getClass ( ) ; } enum JavaVersion { JAVA6 { @Override GenericArrayType newArrayType ( Type componentType ) { return new GenericArrayTypeImpl ( componentType ) ; } @Override Type usedInGenericType ( Type type ) { checkNotNull ( type ) ; if ( type instanceof Class ) { Class < ? > cls = ( Class < ? > ) type ; if ( cls . isArray ( ) ) { return new GenericArrayTypeImpl ( cls . getComponentType ( ) ) ; } } return type ; } } , JAVA7 { @Override Type newArrayType ( Type componentType ) { if ( componentType instanceof Class ) { return getArrayClass ( ( Class < ? > ) componentType ) ; } else { return new GenericArrayTypeImpl ( componentType ) ; } } @Override Type usedInGenericType ( Type type ) { return checkNotNull ( type ) ; } } , JAVA8 { @Override Type newArrayType ( Type componentType ) { return JAVA7 . newArrayType ( componentType ) ; } @Override Type usedInGenericType ( Type type ) { return JAVA7 . usedInGenericType ( type ) ; } @Override String typeName ( Type type ) { try { Method getTypeName = Type . class . getMethod ( <str> ) ; return ( String ) getTypeName . invoke ( type ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( <str> ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } } ; static final JavaVersion CURRENT ; static { if ( AnnotatedElement . class . isAssignableFrom ( TypeVariable . class ) ) { CURRENT = JAVA8 ; } else if ( new TypeCapture < int [ ] > ( ) { } . capture ( ) instanceof Class ) { CURRENT = JAVA7 ; } else { CURRENT = JAVA6 ; } } abstract Type newArrayType ( Type componentType ) ; abstract Type usedInGenericType ( Type type ) ; String typeName ( Type type ) { return Types . toString ( type ) ; } final ImmutableList < Type > usedInGenericType ( Type [ ] types ) { ImmutableList . Builder < Type > builder = ImmutableList . builder ( ) ; for ( Type type : types ) { builder . add ( usedInGenericType ( type ) ) ; } return builder . build ( ) ; } } static final class NativeTypeVariableEquals < X > { static final boolean NATIVE_TYPE_VARIABLE_ONLY = ! NativeTypeVariableEquals . class . getTypeParameters ( ) [ <int> ] . equals ( newArtificialTypeVariable ( NativeTypeVariableEquals . class , <str> ) ) ; } private Types ( ) { } } 
