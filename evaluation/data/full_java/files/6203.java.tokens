package org . elasticsearch . gateway ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateListener ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . MetaDataIndexUpgradeService ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . MultiDataPathUpgrader ; import org . elasticsearch . env . NodeEnvironment ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import static java . util . Collections . emptySet ; import static java . util . Collections . unmodifiableSet ; public class GatewayMetaState extends AbstractComponent implements ClusterStateListener { private final NodeEnvironment nodeEnv ; private final MetaStateService metaStateService ; private final DanglingIndicesState danglingIndicesState ; private final MetaDataIndexUpgradeService metaDataIndexUpgradeService ; @Nullable private volatile MetaData previousMetaData ; private volatile Set < String > previouslyWrittenIndices = emptySet ( ) ; @Inject public GatewayMetaState ( Settings settings , NodeEnvironment nodeEnv , MetaStateService metaStateService , DanglingIndicesState danglingIndicesState , TransportNodesListGatewayMetaState nodesListGatewayMetaState , MetaDataIndexUpgradeService metaDataIndexUpgradeService ) throws Exception { super ( settings ) ; this . nodeEnv = nodeEnv ; this . metaStateService = metaStateService ; this . danglingIndicesState = danglingIndicesState ; this . metaDataIndexUpgradeService = metaDataIndexUpgradeService ; nodesListGatewayMetaState . init ( this ) ; if ( DiscoveryNode . dataNode ( settings ) ) { ensureNoPre019ShardState ( nodeEnv ) ; MultiDataPathUpgrader . upgradeMultiDataPath ( nodeEnv , logger ) ; } if ( DiscoveryNode . masterNode ( settings ) | | DiscoveryNode . dataNode ( settings ) ) { nodeEnv . ensureAtomicMoveSupported ( ) ; } if ( DiscoveryNode . masterNode ( settings ) | | DiscoveryNode . dataNode ( settings ) ) { try { ensureNoPre019State ( ) ; pre20Upgrade ( ) ; long startNS = System . nanoTime ( ) ; metaStateService . loadFullState ( ) ; logger . debug ( <str> , TimeValue . timeValueMillis ( TimeValue . nsecToMSec ( System . nanoTime ( ) - startNS ) ) ) ; } catch ( Exception e ) { logger . error ( <str> , e ) ; throw e ; } } } public MetaData loadMetaState ( ) throws Exception { return metaStateService . loadFullState ( ) ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { Set < String > relevantIndices = new HashSet < > ( ) ; final ClusterState state = event . state ( ) ; if ( state . blocks ( ) . disableStatePersistence ( ) ) { this . previousMetaData = null ; previouslyWrittenIndices = emptySet ( ) ; return ; } MetaData newMetaData = state . metaData ( ) ; boolean success = true ; if ( state . nodes ( ) . localNode ( ) . masterNode ( ) | | state . nodes ( ) . localNode ( ) . dataNode ( ) ) { if ( previousMetaData = = null ) { try { if ( isDataOnlyNode ( state ) ) { Set < String > newPreviouslyWrittenIndices = new HashSet < > ( previouslyWrittenIndices . size ( ) ) ; for ( IndexMetaData indexMetaData : newMetaData ) { IndexMetaData indexMetaDataOnDisk = null ; if ( indexMetaData . getState ( ) . equals ( IndexMetaData . State . CLOSE ) ) { indexMetaDataOnDisk = metaStateService . loadIndexState ( indexMetaData . getIndex ( ) ) ; } if ( indexMetaDataOnDisk ! = null ) { newPreviouslyWrittenIndices . add ( indexMetaDataOnDisk . getIndex ( ) ) ; } } newPreviouslyWrittenIndices . addAll ( previouslyWrittenIndices ) ; previouslyWrittenIndices = unmodifiableSet ( newPreviouslyWrittenIndices ) ; } } catch ( Throwable e ) { success = false ; } } if ( previousMetaData = = null | | ! MetaData . isGlobalStateEquals ( previousMetaData , newMetaData ) ) { try { metaStateService . writeGlobalState ( <str> , newMetaData ) ; } catch ( Throwable e ) { success = false ; } } Iterable < IndexMetaWriteInfo > writeInfo ; relevantIndices = getRelevantIndices ( event . state ( ) , event . previousState ( ) , previouslyWrittenIndices ) ; writeInfo = resolveStatesToBeWritten ( previouslyWrittenIndices , relevantIndices , previousMetaData , event . state ( ) . metaData ( ) ) ; for ( IndexMetaWriteInfo indexMetaWrite : writeInfo ) { try { metaStateService . writeIndex ( indexMetaWrite . reason , indexMetaWrite . newMetaData , indexMetaWrite . previousMetaData ) ; } catch ( Throwable e ) { success = false ; } } } danglingIndicesState . processDanglingIndices ( newMetaData ) ; if ( success ) { previousMetaData = newMetaData ; previouslyWrittenIndices = unmodifiableSet ( relevantIndices ) ; } } public static Set < String > getRelevantIndices ( ClusterState state , ClusterState previousState , Set < String > previouslyWrittenIndices ) { Set < String > relevantIndices ; if ( isDataOnlyNode ( state ) ) { relevantIndices = getRelevantIndicesOnDataOnlyNode ( state , previousState , previouslyWrittenIndices ) ; } else if ( state . nodes ( ) . localNode ( ) . masterNode ( ) = = true ) { relevantIndices = getRelevantIndicesForMasterEligibleNode ( state ) ; } else { relevantIndices = Collections . emptySet ( ) ; } return relevantIndices ; } protected static boolean isDataOnlyNode ( ClusterState state ) { return ( ( state . nodes ( ) . localNode ( ) . masterNode ( ) = = false ) & & state . nodes ( ) . localNode ( ) . dataNode ( ) ) ; } private void ensureNoPre019State ( ) throws Exception { for ( Path dataLocation : nodeEnv . nodeDataPaths ( ) ) { final Path stateLocation = dataLocation . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) ; if ( ! Files . exists ( stateLocation ) ) { continue ; } try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( stateLocation ) ) { for ( Path stateFile : stream ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> + stateFile . getFileName ( ) + <str> ) ; } final String name = stateFile . getFileName ( ) . toString ( ) ; if ( name . startsWith ( <str> ) ) { throw new IllegalStateException ( <str> + Version . CURRENT . minimumCompatibilityVersion ( ) + <str> + stateFile . getParent ( ) . toAbsolutePath ( ) ) ; } } } } } private void pre20Upgrade ( ) throws Exception { MetaData metaData = loadMetaState ( ) ; List < IndexMetaData > updateIndexMetaData = new ArrayList < > ( ) ; for ( IndexMetaData indexMetaData : metaData ) { IndexMetaData newMetaData = metaDataIndexUpgradeService . upgradeIndexMetaData ( indexMetaData ) ; if ( indexMetaData ! = newMetaData ) { updateIndexMetaData . add ( newMetaData ) ; } } for ( IndexMetaData indexMetaData : updateIndexMetaData ) { metaStateService . writeIndex ( <str> , indexMetaData , null ) ; } } private void ensureNoPre019ShardState ( NodeEnvironment nodeEnv ) throws Exception { for ( Path dataLocation : nodeEnv . nodeDataPaths ( ) ) { final Path stateLocation = dataLocation . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) ; if ( Files . exists ( stateLocation ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( stateLocation , <str> ) ) { for ( Path stateFile : stream ) { throw new IllegalStateException ( <str> + Version . CURRENT . minimumCompatibilityVersion ( ) + <str> + stateFile . getParent ( ) . toAbsolutePath ( ) ) ; } } } } } public static Iterable < GatewayMetaState . IndexMetaWriteInfo > resolveStatesToBeWritten ( Set < String > previouslyWrittenIndices , Set < String > potentiallyUnwrittenIndices , MetaData previousMetaData , MetaData newMetaData ) { List < GatewayMetaState . IndexMetaWriteInfo > indicesToWrite = new ArrayList < > ( ) ; for ( String index : potentiallyUnwrittenIndices ) { IndexMetaData newIndexMetaData = newMetaData . index ( index ) ; IndexMetaData previousIndexMetaData = previousMetaData = = null ? null : previousMetaData . index ( index ) ; String writeReason = null ; if ( previouslyWrittenIndices . contains ( index ) = = false | | previousIndexMetaData = = null ) { writeReason = <str> ; } else if ( previousIndexMetaData . getVersion ( ) ! = newIndexMetaData . getVersion ( ) ) { writeReason = <str> + previousIndexMetaData . getVersion ( ) + <str> + newIndexMetaData . getVersion ( ) + <str> ; } if ( writeReason ! = null ) { indicesToWrite . add ( new GatewayMetaState . IndexMetaWriteInfo ( newIndexMetaData , previousIndexMetaData , writeReason ) ) ; } } return indicesToWrite ; } public static Set < String > getRelevantIndicesOnDataOnlyNode ( ClusterState state , ClusterState previousState , Set < String > previouslyWrittenIndices ) { RoutingNode newRoutingNode = state . getRoutingNodes ( ) . node ( state . nodes ( ) . localNodeId ( ) ) ; if ( newRoutingNode = = null ) { throw new IllegalStateException ( <str> ) ; } Set < String > indices = new HashSet < > ( ) ; for ( ShardRouting routing : newRoutingNode ) { indices . add ( routing . index ( ) ) ; } for ( IndexMetaData indexMetaData : state . metaData ( ) ) { boolean isOrWasClosed = indexMetaData . getState ( ) . equals ( IndexMetaData . State . CLOSE ) ; IndexMetaData previousMetaData = previousState . metaData ( ) . getIndices ( ) . get ( indexMetaData . getIndex ( ) ) ; if ( previousMetaData ! = null ) { isOrWasClosed = isOrWasClosed | | previousMetaData . getState ( ) . equals ( IndexMetaData . State . CLOSE ) ; } if ( previouslyWrittenIndices . contains ( indexMetaData . getIndex ( ) ) & & isOrWasClosed ) { indices . add ( indexMetaData . getIndex ( ) ) ; } } return indices ; } public static Set < String > getRelevantIndicesForMasterEligibleNode ( ClusterState state ) { Set < String > relevantIndices ; relevantIndices = new HashSet < > ( ) ; for ( IndexMetaData indexMetaData : state . metaData ( ) ) { relevantIndices . add ( indexMetaData . getIndex ( ) ) ; } return relevantIndices ; } public static class IndexMetaWriteInfo { final IndexMetaData newMetaData ; final String reason ; final IndexMetaData previousMetaData ; public IndexMetaWriteInfo ( IndexMetaData newMetaData , IndexMetaData previousMetaData , String reason ) { this . newMetaData = newMetaData ; this . reason = reason ; this . previousMetaData = previousMetaData ; } public IndexMetaData getNewMetaData ( ) { return newMetaData ; } public String getReason ( ) { return reason ; } } } 
