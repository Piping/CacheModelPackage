package com . badlogic . gdx . tests . g3d ; import java . io . BufferedReader ; import java . io . IOException ; import java . util . Scanner ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . ObjectMap ; public class ShaderLoader { public FileHandle root ; public ObjectMap < String , ObjectMap < String , String > > snippets = new ObjectMap < String , ObjectMap < String , String > > ( ) ; private Array < String > includes = new Array < String > ( ) ; public ShaderLoader ( FileHandle root ) { this . root = root ; } public ShaderProgram load ( String vertex , String fragment ) { StringBuilder out = new StringBuilder ( ) ; load ( out , vertex ) ; vertex = out . toString ( ) ; includes . clear ( ) ; out . setLength ( <int> ) ; load ( out , fragment ) ; fragment = out . toString ( ) ; includes . clear ( ) ; return new ShaderProgram ( vertex , fragment ) ; } public String load ( final String name ) { StringBuilder out = new StringBuilder ( ) ; load ( out , name ) ; includes . clear ( ) ; return out . toString ( ) ; } protected void load ( final StringBuilder out , final String name ) { final int idx = name . lastIndexOf ( <str> ) ; final String fileName = idx < <int> ? name : name . substring ( <int> , idx ) ; final String snipName = idx < <int> | | ( idx > = name . length ( ) - <int> ) ? <str> : name . substring ( idx + <int> ) ; ObjectMap < String , String > snips = snippets . get ( fileName , null ) ; if ( snips = = null ) { snips = parse ( root . child ( fileName ) ) ; snippets . put ( fileName , snips ) ; } String result = snips . get ( snipName , null ) ; if ( result = = null ) throw new GdxRuntimeException ( <str> + snipName + <str> + root . child ( fileName ) . path ( ) ) ; parse ( out , fileName , result ) ; } protected void parse ( final StringBuilder out , final String currentFile , final String code ) { String [ ] lines = code . split ( <str> ) ; int idx , jdx ; for ( final String line : lines ) { if ( ( ( idx = line . indexOf ( <str> ) ) = = <int> ) & & ( ( idx = line . indexOf ( <str> , idx ) ) > <int> ) & & ( ( jdx = line . indexOf ( <str> , + + idx ) ) > idx ) ) { String name = line . substring ( idx , jdx ) ; if ( name . length ( ) > <int> ) { if ( name . charAt ( <int> ) = = <str> ) name = currentFile + name ; if ( ! includes . contains ( name , false ) ) { includes . add ( name ) ; load ( out , name ) ; } } } else out . append ( line . trim ( ) ) . append ( <str> ) ; } } final static StringBuilder stringBuilder = new StringBuilder ( ) ; protected ObjectMap < String , String > parse ( final FileHandle file ) { ObjectMap < String , String > result = new ObjectMap < String , String > ( ) ; BufferedReader reader = file . reader ( <int> ) ; String line ; String snipName = <str> ; stringBuilder . setLength ( <int> ) ; int idx ; try { while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . length ( ) > <int> & & line . charAt ( <int> ) = = <str> & & ( idx = line . indexOf ( <str> ) ) > <int> ) { if ( snipName . length ( ) > <int> | | stringBuilder . length ( ) > <int> ) result . put ( snipName , stringBuilder . toString ( ) ) ; stringBuilder . setLength ( <int> ) ; snipName = line . substring ( <int> , idx ) ; } else stringBuilder . append ( line . trim ( ) ) . append ( <str> ) ; } } catch ( IOException e ) { throw new GdxRuntimeException ( e ) ; } if ( snipName . length ( ) > <int> | | stringBuilder . length ( ) > <int> ) result . put ( snipName , stringBuilder . toString ( ) ) ; return result ; } @Override public String toString ( ) { stringBuilder . setLength ( <int> ) ; for ( final ObjectMap . Entry < String , ObjectMap < String , String > > entry : snippets . entries ( ) ) { stringBuilder . append ( entry . key ) . append ( <str> ) ; for ( final String snipname : entry . value . keys ( ) ) stringBuilder . append ( snipname ) . append ( <str> ) ; stringBuilder . append ( <str> ) ; } return stringBuilder . toString ( ) ; } } 
