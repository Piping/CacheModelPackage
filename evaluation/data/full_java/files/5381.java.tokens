package org . elasticsearch . action . search . type ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionRunnable ; import org . elasticsearch . action . search . ReduceSearchPhaseException ; import org . elasticsearch . action . search . SearchRequest ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . search . action . SearchServiceTransportAction ; import org . elasticsearch . search . controller . SearchPhaseController ; import org . elasticsearch . search . fetch . QueryFetchSearchResult ; import org . elasticsearch . search . internal . InternalSearchResponse ; import org . elasticsearch . search . internal . ShardSearchTransportRequest ; import org . elasticsearch . threadpool . ThreadPool ; import java . io . IOException ; import static org . elasticsearch . action . search . type . TransportSearchHelper . buildScrollId ; public class TransportSearchQueryAndFetchAction extends TransportSearchTypeAction { @Inject public TransportSearchQueryAndFetchAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , SearchServiceTransportAction searchService , SearchPhaseController searchPhaseController , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , threadPool , clusterService , searchService , searchPhaseController , actionFilters , indexNameExpressionResolver ) ; } @Override protected void doExecute ( SearchRequest searchRequest , ActionListener < SearchResponse > listener ) { new AsyncAction ( searchRequest , listener ) . start ( ) ; } private class AsyncAction extends BaseAsyncAction < QueryFetchSearchResult > { private AsyncAction ( SearchRequest request , ActionListener < SearchResponse > listener ) { super ( request , listener ) ; } @Override protected String firstPhaseName ( ) { return <str> ; } @Override protected void sendExecuteFirstPhase ( DiscoveryNode node , ShardSearchTransportRequest request , ActionListener < QueryFetchSearchResult > listener ) { searchService . sendExecuteFetch ( node , request , listener ) ; } @Override protected void moveToSecondPhase ( ) throws Exception { threadPool . executor ( ThreadPool . Names . SEARCH ) . execute ( new ActionRunnable < SearchResponse > ( listener ) { @Override public void doRun ( ) throws IOException { boolean useScroll = request . scroll ( ) ! = null ; sortedShardList = searchPhaseController . sortDocs ( useScroll , firstResults ) ; final InternalSearchResponse internalResponse = searchPhaseController . merge ( sortedShardList , firstResults , firstResults , request ) ; String scrollId = null ; if ( request . scroll ( ) ! = null ) { scrollId = buildScrollId ( request . searchType ( ) , firstResults , null ) ; } listener . onResponse ( new SearchResponse ( internalResponse , scrollId , expectedSuccessfulOps , successfulOps . get ( ) , buildTookInMillis ( ) , buildShardFailures ( ) ) ) ; } @Override public void onFailure ( Throwable t ) { ReduceSearchPhaseException failure = new ReduceSearchPhaseException ( <str> , <str> , t , buildShardFailures ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , failure ) ; } super . onFailure ( failure ) ; } } ) ; } } } 
