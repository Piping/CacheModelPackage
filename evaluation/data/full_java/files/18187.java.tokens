package com . badlogic . gdx . math ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . math . Plane . PlaneSide ; import com . badlogic . gdx . math . collision . BoundingBox ; public class Frustum { protected static final Vector3 [ ] clipSpacePlanePoints = { new Vector3 ( - <int> , - <int> , - <int> ) , new Vector3 ( <int> , - <int> , - <int> ) , new Vector3 ( <int> , <int> , - <int> ) , new Vector3 ( - <int> , <int> , - <int> ) , new Vector3 ( - <int> , - <int> , <int> ) , new Vector3 ( <int> , - <int> , <int> ) , new Vector3 ( <int> , <int> , <int> ) , new Vector3 ( - <int> , <int> , <int> ) } ; protected static final float [ ] clipSpacePlanePointsArray = new float [ <int> * <int> ] ; static { int j = <int> ; for ( Vector3 v : clipSpacePlanePoints ) { clipSpacePlanePointsArray [ j + + ] = v . x ; clipSpacePlanePointsArray [ j + + ] = v . y ; clipSpacePlanePointsArray [ j + + ] = v . z ; } } private final static Vector3 tmpV = new Vector3 ( ) ; public final Plane [ ] planes = new Plane [ <int> ] ; public final Vector3 [ ] planePoints = { new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) , new Vector3 ( ) } ; protected final float [ ] planePointsArray = new float [ <int> * <int> ] ; public Frustum ( ) { for ( int i = <int> ; i < <int> ; i + + ) { planes [ i ] = new Plane ( new Vector3 ( ) , <int> ) ; } } public void update ( Matrix4 inverseProjectionView ) { System . arraycopy ( clipSpacePlanePointsArray , <int> , planePointsArray , <int> , clipSpacePlanePointsArray . length ) ; Matrix4 . prj ( inverseProjectionView . val , planePointsArray , <int> , <int> , <int> ) ; for ( int i = <int> , j = <int> ; i < <int> ; i + + ) { Vector3 v = planePoints [ i ] ; v . x = planePointsArray [ j + + ] ; v . y = planePointsArray [ j + + ] ; v . z = planePointsArray [ j + + ] ; } planes [ <int> ] . set ( planePoints [ <int> ] , planePoints [ <int> ] , planePoints [ <int> ] ) ; planes [ <int> ] . set ( planePoints [ <int> ] , planePoints [ <int> ] , planePoints [ <int> ] ) ; planes [ <int> ] . set ( planePoints [ <int> ] , planePoints [ <int> ] , planePoints [ <int> ] ) ; planes [ <int> ] . set ( planePoints [ <int> ] , planePoints [ <int> ] , planePoints [ <int> ] ) ; planes [ <int> ] . set ( planePoints [ <int> ] , planePoints [ <int> ] , planePoints [ <int> ] ) ; planes [ <int> ] . set ( planePoints [ <int> ] , planePoints [ <int> ] , planePoints [ <int> ] ) ; } public boolean pointInFrustum ( Vector3 point ) { for ( int i = <int> ; i < planes . length ; i + + ) { PlaneSide result = planes [ i ] . testPoint ( point ) ; if ( result = = PlaneSide . Back ) return false ; } return true ; } public boolean pointInFrustum ( float x , float y , float z ) { for ( int i = <int> ; i < planes . length ; i + + ) { PlaneSide result = planes [ i ] . testPoint ( x , y , z ) ; if ( result = = PlaneSide . Back ) return false ; } return true ; } public boolean sphereInFrustum ( Vector3 center , float radius ) { for ( int i = <int> ; i < <int> ; i + + ) if ( ( planes [ i ] . normal . x * center . x + planes [ i ] . normal . y * center . y + planes [ i ] . normal . z * center . z ) < ( - radius - planes [ i ] . d ) ) return false ; return true ; } public boolean sphereInFrustum ( float x , float y , float z , float radius ) { for ( int i = <int> ; i < <int> ; i + + ) if ( ( planes [ i ] . normal . x * x + planes [ i ] . normal . y * y + planes [ i ] . normal . z * z ) < ( - radius - planes [ i ] . d ) ) return false ; return true ; } public boolean sphereInFrustumWithoutNearFar ( Vector3 center , float radius ) { for ( int i = <int> ; i < <int> ; i + + ) if ( ( planes [ i ] . normal . x * center . x + planes [ i ] . normal . y * center . y + planes [ i ] . normal . z * center . z ) < ( - radius - planes [ i ] . d ) ) return false ; return true ; } public boolean sphereInFrustumWithoutNearFar ( float x , float y , float z , float radius ) { for ( int i = <int> ; i < <int> ; i + + ) if ( ( planes [ i ] . normal . x * x + planes [ i ] . normal . y * y + planes [ i ] . normal . z * z ) < ( - radius - planes [ i ] . d ) ) return false ; return true ; } public boolean boundsInFrustum ( BoundingBox bounds ) { for ( int i = <int> , len2 = planes . length ; i < len2 ; i + + ) { if ( planes [ i ] . testPoint ( bounds . getCorner000 ( tmpV ) ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( bounds . getCorner001 ( tmpV ) ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( bounds . getCorner010 ( tmpV ) ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( bounds . getCorner011 ( tmpV ) ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( bounds . getCorner100 ( tmpV ) ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( bounds . getCorner101 ( tmpV ) ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( bounds . getCorner110 ( tmpV ) ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( bounds . getCorner111 ( tmpV ) ) ! = PlaneSide . Back ) continue ; return false ; } return true ; } public boolean boundsInFrustum ( Vector3 center , Vector3 dimensions ) { return boundsInFrustum ( center . x , center . y , center . z , dimensions . x / <int> , dimensions . y / <int> , dimensions . z / <int> ) ; } public boolean boundsInFrustum ( float x , float y , float z , float halfWidth , float halfHeight , float halfDepth ) { for ( int i = <int> , len2 = planes . length ; i < len2 ; i + + ) { if ( planes [ i ] . testPoint ( x + halfWidth , y + halfHeight , z + halfDepth ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( x + halfWidth , y + halfHeight , z - halfDepth ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( x + halfWidth , y - halfHeight , z + halfDepth ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( x + halfWidth , y - halfHeight , z - halfDepth ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( x - halfWidth , y + halfHeight , z + halfDepth ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( x - halfWidth , y + halfHeight , z - halfDepth ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( x - halfWidth , y - halfHeight , z + halfDepth ) ! = PlaneSide . Back ) continue ; if ( planes [ i ] . testPoint ( x - halfWidth , y - halfHeight , z - halfDepth ) ! = PlaneSide . Back ) continue ; return false ; } return true ; } } 
