package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http2 . Http2Error . INTERNAL_ERROR ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . handler . codec . http . FullHttpMessage ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpStatusClass ; import io . netty . util . collection . IntObjectHashMap ; import io . netty . util . collection . IntObjectMap ; public class InboundHttp2ToHttpAdapter extends Http2EventAdapter { private static final ImmediateSendDetector DEFAULT_SEND_DETECTOR = new ImmediateSendDetector ( ) { @Override public boolean mustSendImmediately ( FullHttpMessage msg ) { if ( msg instanceof FullHttpResponse ) { return ( ( FullHttpResponse ) msg ) . status ( ) . codeClass ( ) = = HttpStatusClass . INFORMATIONAL ; } if ( msg instanceof FullHttpRequest ) { return msg . headers ( ) . contains ( HttpHeaderNames . EXPECT ) ; } return false ; } @Override public FullHttpMessage copyIfNeeded ( FullHttpMessage msg ) { if ( msg instanceof FullHttpRequest ) { FullHttpRequest copy = ( ( FullHttpRequest ) msg ) . copy ( null ) ; copy . headers ( ) . remove ( HttpHeaderNames . EXPECT ) ; return copy ; } return null ; } } ; private final int maxContentLength ; protected final Http2Connection connection ; protected final boolean validateHttpHeaders ; private final ImmediateSendDetector sendDetector ; protected final IntObjectMap < FullHttpMessage > messageMap ; private final boolean propagateSettings ; public static class Builder { private final Http2Connection connection ; private int maxContentLength ; private boolean validateHttpHeaders ; private boolean propagateSettings ; public Builder ( Http2Connection connection ) { this . connection = connection ; } public Builder maxContentLength ( int maxContentLength ) { this . maxContentLength = maxContentLength ; return this ; } public Builder validateHttpHeaders ( boolean validate ) { validateHttpHeaders = validate ; return this ; } public Builder propagateSettings ( boolean propagate ) { propagateSettings = propagate ; return this ; } public InboundHttp2ToHttpAdapter build ( ) { InboundHttp2ToHttpAdapter instance = new InboundHttp2ToHttpAdapter ( this ) ; connection . addListener ( instance ) ; return instance ; } } protected InboundHttp2ToHttpAdapter ( Builder builder ) { checkNotNull ( builder . connection , <str> ) ; if ( builder . maxContentLength < = <int> ) { throw new IllegalArgumentException ( <str> + builder . maxContentLength ) ; } connection = builder . connection ; maxContentLength = builder . maxContentLength ; validateHttpHeaders = builder . validateHttpHeaders ; propagateSettings = builder . propagateSettings ; sendDetector = DEFAULT_SEND_DETECTOR ; messageMap = new IntObjectHashMap < FullHttpMessage > ( ) ; } protected void removeMessage ( int streamId ) { messageMap . remove ( streamId ) ; } @Override public void onStreamRemoved ( Http2Stream stream ) { removeMessage ( stream . id ( ) ) ; } protected void fireChannelRead ( ChannelHandlerContext ctx , FullHttpMessage msg , int streamId ) { removeMessage ( streamId ) ; HttpUtil . setContentLength ( msg , msg . content ( ) . readableBytes ( ) ) ; ctx . fireChannelRead ( msg ) ; } protected FullHttpMessage newMessage ( int streamId , Http2Headers headers , boolean validateHttpHeaders ) throws Http2Exception { return connection . isServer ( ) ? HttpConversionUtil . toHttpRequest ( streamId , headers , validateHttpHeaders ) : HttpConversionUtil . toHttpResponse ( streamId , headers , validateHttpHeaders ) ; } protected FullHttpMessage processHeadersBegin ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , boolean endOfStream , boolean allowAppend , boolean appendToTrailer ) throws Http2Exception { FullHttpMessage msg = messageMap . get ( streamId ) ; if ( msg = = null ) { msg = newMessage ( streamId , headers , validateHttpHeaders ) ; } else if ( allowAppend ) { try { HttpConversionUtil . addHttp2ToHttpHeaders ( streamId , headers , msg , appendToTrailer ) ; } catch ( Http2Exception e ) { removeMessage ( streamId ) ; throw e ; } } else { msg = null ; } if ( sendDetector . mustSendImmediately ( msg ) ) { final FullHttpMessage copy = endOfStream ? null : sendDetector . copyIfNeeded ( msg ) ; fireChannelRead ( ctx , msg , streamId ) ; return copy ; } return msg ; } private void processHeadersEnd ( ChannelHandlerContext ctx , int streamId , FullHttpMessage msg , boolean endOfStream ) { if ( endOfStream ) { fireChannelRead ( ctx , msg , streamId ) ; } else { messageMap . put ( streamId , msg ) ; } } @Override public int onDataRead ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { FullHttpMessage msg = messageMap . get ( streamId ) ; if ( msg = = null ) { throw connectionError ( PROTOCOL_ERROR , <str> , streamId ) ; } ByteBuf content = msg . content ( ) ; final int dataReadableBytes = data . readableBytes ( ) ; if ( content . readableBytes ( ) > maxContentLength - dataReadableBytes ) { throw connectionError ( INTERNAL_ERROR , <str> , maxContentLength , streamId ) ; } content . writeBytes ( data , data . readerIndex ( ) , dataReadableBytes ) ; if ( endOfStream ) { fireChannelRead ( ctx , msg , streamId ) ; } return dataReadableBytes + padding ; } @Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endOfStream ) throws Http2Exception { FullHttpMessage msg = processHeadersBegin ( ctx , streamId , headers , endOfStream , true , true ) ; if ( msg ! = null ) { processHeadersEnd ( ctx , streamId , msg , endOfStream ) ; } } @Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endOfStream ) throws Http2Exception { FullHttpMessage msg = processHeadersBegin ( ctx , streamId , headers , endOfStream , true , true ) ; if ( msg ! = null ) { processHeadersEnd ( ctx , streamId , msg , endOfStream ) ; } } @Override public void onRstStreamRead ( ChannelHandlerContext ctx , int streamId , long errorCode ) throws Http2Exception { FullHttpMessage msg = messageMap . get ( streamId ) ; if ( msg ! = null ) { fireChannelRead ( ctx , msg , streamId ) ; } } @Override public void onPushPromiseRead ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding ) throws Http2Exception { FullHttpMessage msg = processHeadersBegin ( ctx , promisedStreamId , headers , false , false , false ) ; if ( msg = = null ) { throw connectionError ( PROTOCOL_ERROR , <str> , promisedStreamId ) ; } msg . headers ( ) . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_PROMISE_ID . text ( ) , streamId ) ; processHeadersEnd ( ctx , promisedStreamId , msg , false ) ; } @Override public void onSettingsRead ( ChannelHandlerContext ctx , Http2Settings settings ) throws Http2Exception { if ( propagateSettings ) { ctx . fireChannelRead ( settings ) ; } } private interface ImmediateSendDetector { boolean mustSendImmediately ( FullHttpMessage msg ) ; FullHttpMessage copyIfNeeded ( FullHttpMessage msg ) ; } } 
