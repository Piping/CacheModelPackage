package org . elasticsearch . index . snapshots . blobstore ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . Version ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . xcontent . FromXContentBuilder ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . store . StoreFileMetaData ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class BlobStoreIndexShardSnapshot implements ToXContent , FromXContentBuilder < BlobStoreIndexShardSnapshot > { public static final BlobStoreIndexShardSnapshot PROTO = new BlobStoreIndexShardSnapshot ( ) ; public static class FileInfo { private final String name ; private final ByteSizeValue partSize ; private final long partBytes ; private final long numberOfParts ; private final StoreFileMetaData metadata ; public FileInfo ( String name , StoreFileMetaData metaData , ByteSizeValue partSize ) { this . name = name ; this . metadata = metaData ; long partBytes = Long . MAX_VALUE ; if ( partSize ! = null ) { partBytes = partSize . bytes ( ) ; } long totalLength = metaData . length ( ) ; long numberOfParts = totalLength / partBytes ; if ( totalLength % partBytes > <int> ) { numberOfParts + + ; } if ( numberOfParts = = <int> ) { numberOfParts + + ; } this . numberOfParts = numberOfParts ; this . partSize = partSize ; this . partBytes = partBytes ; } public String name ( ) { return name ; } public String partName ( long part ) { if ( numberOfParts > <int> ) { return name + <str> + part ; } else { return name ; } } public static String canonicalName ( String blobName ) { if ( blobName . contains ( <str> ) ) { return blobName . substring ( <int> , blobName . indexOf ( <str> ) ) ; } return blobName ; } public String physicalName ( ) { return metadata . name ( ) ; } public long length ( ) { return metadata . length ( ) ; } public ByteSizeValue partSize ( ) { return partSize ; } public long partBytes ( int part ) { if ( numberOfParts = = <int> ) { return length ( ) ; } if ( part < ( numberOfParts - <int> ) ) { return partBytes ; } return length ( ) - ( partBytes * ( numberOfParts - <int> ) ) ; } public long numberOfParts ( ) { return numberOfParts ; } @Nullable public String checksum ( ) { return metadata . checksum ( ) ; } public StoreFileMetaData metadata ( ) { return metadata ; } public boolean isSame ( StoreFileMetaData md ) { return metadata . isSame ( md ) ; } public boolean isSame ( FileInfo fileInfo ) { if ( numberOfParts ! = fileInfo . numberOfParts ) return false ; if ( partBytes ! = fileInfo . partBytes ) return false ; if ( ! name . equals ( fileInfo . name ) ) return false ; if ( partSize ! = null ) { if ( ! partSize . equals ( fileInfo . partSize ) ) return false ; } else { if ( fileInfo . partSize ! = null ) return false ; } return metadata . isSame ( fileInfo . metadata ) ; } static final class Fields { static final XContentBuilderString NAME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PHYSICAL_NAME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString LENGTH = new XContentBuilderString ( <str> ) ; static final XContentBuilderString CHECKSUM = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PART_SIZE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString WRITTEN_BY = new XContentBuilderString ( <str> ) ; static final XContentBuilderString META_HASH = new XContentBuilderString ( <str> ) ; } public static void toXContent ( FileInfo file , XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startObject ( ) ; builder . field ( Fields . NAME , file . name ) ; builder . field ( Fields . PHYSICAL_NAME , file . metadata . name ( ) ) ; builder . field ( Fields . LENGTH , file . metadata . length ( ) ) ; if ( file . metadata . checksum ( ) ! = null ) { builder . field ( Fields . CHECKSUM , file . metadata . checksum ( ) ) ; } if ( file . partSize ! = null ) { builder . field ( Fields . PART_SIZE , file . partSize . bytes ( ) ) ; } if ( file . metadata . writtenBy ( ) ! = null ) { builder . field ( Fields . WRITTEN_BY , file . metadata . writtenBy ( ) ) ; } if ( file . metadata . hash ( ) ! = null & & file . metadata ( ) . hash ( ) . length > <int> ) { builder . field ( Fields . META_HASH , file . metadata . hash ( ) ) ; } builder . endObject ( ) ; } public static FileInfo fromXContent ( XContentParser parser ) throws IOException { XContentParser . Token token = parser . currentToken ( ) ; String name = null ; String physicalName = null ; long length = - <int> ; String checksum = null ; ByteSizeValue partSize = null ; Version writtenBy = null ; BytesRef metaHash = new BytesRef ( ) ; if ( token = = XContentParser . Token . START_OBJECT ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String currentFieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { name = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { physicalName = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { length = parser . longValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { checksum = parser . text ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { partSize = new ByteSizeValue ( parser . longValue ( ) ) ; } else if ( <str> . equals ( currentFieldName ) ) { writtenBy = Lucene . parseVersionLenient ( parser . text ( ) , null ) ; } else if ( <str> . equals ( currentFieldName ) ) { metaHash . bytes = parser . binaryValue ( ) ; metaHash . offset = <int> ; metaHash . length = metaHash . bytes . length ; } else { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } } else { throw new ElasticsearchParseException ( <str> , token ) ; } } else { throw new ElasticsearchParseException ( <str> , token ) ; } } } if ( name = = null | | Strings . validFileName ( name ) = = false ) { throw new ElasticsearchParseException ( <str> + name + <str> ) ; } else if ( physicalName = = null | | Strings . validFileName ( physicalName ) = = false ) { throw new ElasticsearchParseException ( <str> + physicalName + <str> ) ; } else if ( length < <int> ) { throw new ElasticsearchParseException ( <str> ) ; } return new FileInfo ( name , new StoreFileMetaData ( physicalName , length , checksum , writtenBy , metaHash ) , partSize ) ; } } private final String snapshot ; private final long indexVersion ; private final long startTime ; private final long time ; private final int numberOfFiles ; private final long totalSize ; private final List < FileInfo > indexFiles ; public BlobStoreIndexShardSnapshot ( String snapshot , long indexVersion , List < FileInfo > indexFiles , long startTime , long time , int numberOfFiles , long totalSize ) { assert snapshot ! = null ; assert indexVersion > = <int> ; this . snapshot = snapshot ; this . indexVersion = indexVersion ; this . indexFiles = Collections . unmodifiableList ( new ArrayList < > ( indexFiles ) ) ; this . startTime = startTime ; this . time = time ; this . numberOfFiles = numberOfFiles ; this . totalSize = totalSize ; } private BlobStoreIndexShardSnapshot ( ) { this . snapshot = <str> ; this . indexVersion = <int> ; this . indexFiles = Collections . emptyList ( ) ; this . startTime = <int> ; this . time = <int> ; this . numberOfFiles = <int> ; this . totalSize = <int> ; } public long indexVersion ( ) { return indexVersion ; } public String snapshot ( ) { return snapshot ; } public List < FileInfo > indexFiles ( ) { return indexFiles ; } public long startTime ( ) { return startTime ; } public long time ( ) { return time ; } public int numberOfFiles ( ) { return numberOfFiles ; } public long totalSize ( ) { return totalSize ; } static final class Fields { static final XContentBuilderString NAME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString INDEX_VERSION = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NUMBER_OF_FILES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_SIZE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FILES = new XContentBuilderString ( <str> ) ; } static final class ParseFields { static final ParseField NAME = new ParseField ( <str> ) ; static final ParseField INDEX_VERSION = new ParseField ( <str> , <str> ) ; static final ParseField START_TIME = new ParseField ( <str> ) ; static final ParseField TIME = new ParseField ( <str> ) ; static final ParseField NUMBER_OF_FILES = new ParseField ( <str> ) ; static final ParseField TOTAL_SIZE = new ParseField ( <str> ) ; static final ParseField FILES = new ParseField ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( Fields . NAME , snapshot ) ; builder . field ( Fields . INDEX_VERSION , indexVersion ) ; builder . field ( Fields . START_TIME , startTime ) ; builder . field ( Fields . TIME , time ) ; builder . field ( Fields . NUMBER_OF_FILES , numberOfFiles ) ; builder . field ( Fields . TOTAL_SIZE , totalSize ) ; builder . startArray ( Fields . FILES ) ; for ( FileInfo fileInfo : indexFiles ) { FileInfo . toXContent ( fileInfo , builder , params ) ; } builder . endArray ( ) ; return builder ; } public BlobStoreIndexShardSnapshot fromXContent ( XContentParser parser , ParseFieldMatcher parseFieldMatcher ) throws IOException { String snapshot = null ; long indexVersion = - <int> ; long startTime = <int> ; long time = <int> ; int numberOfFiles = <int> ; long totalSize = <int> ; List < FileInfo > indexFiles = new ArrayList < > ( ) ; if ( parser . currentToken ( ) = = null ) { parser . nextToken ( ) ; } XContentParser . Token token = parser . currentToken ( ) ; if ( token = = XContentParser . Token . START_OBJECT ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String currentFieldName = parser . currentName ( ) ; token = parser . nextToken ( ) ; if ( token . isValue ( ) ) { if ( parseFieldMatcher . match ( currentFieldName , ParseFields . NAME ) ) { snapshot = parser . text ( ) ; } else if ( parseFieldMatcher . match ( currentFieldName , ParseFields . INDEX_VERSION ) ) { indexVersion = parser . longValue ( ) ; } else if ( parseFieldMatcher . match ( currentFieldName , ParseFields . START_TIME ) ) { startTime = parser . longValue ( ) ; } else if ( parseFieldMatcher . match ( currentFieldName , ParseFields . TIME ) ) { time = parser . longValue ( ) ; } else if ( parseFieldMatcher . match ( currentFieldName , ParseFields . NUMBER_OF_FILES ) ) { numberOfFiles = parser . intValue ( ) ; } else if ( parseFieldMatcher . match ( currentFieldName , ParseFields . TOTAL_SIZE ) ) { totalSize = parser . longValue ( ) ; } else { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( parseFieldMatcher . match ( currentFieldName , ParseFields . FILES ) ) { while ( ( parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { indexFiles . add ( FileInfo . fromXContent ( parser ) ) ; } } else { throw new ElasticsearchParseException ( <str> , currentFieldName ) ; } } else { throw new ElasticsearchParseException ( <str> , token ) ; } } else { throw new ElasticsearchParseException ( <str> , token ) ; } } } return new BlobStoreIndexShardSnapshot ( snapshot , indexVersion , Collections . unmodifiableList ( indexFiles ) , startTime , time , numberOfFiles , totalSize ) ; } } 
