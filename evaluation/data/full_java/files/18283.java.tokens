package com . badlogic . gdx . scenes . scene2d . ui ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . Actor ; import com . badlogic . gdx . scenes . scene2d . InputEvent ; import com . badlogic . gdx . scenes . scene2d . InputListener ; import com . badlogic . gdx . scenes . scene2d . utils . Drawable ; import com . badlogic . gdx . scenes . scene2d . utils . Layout ; import com . badlogic . gdx . scenes . scene2d . utils . ScissorStack ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class SplitPane extends WidgetGroup { SplitPaneStyle style ; private Actor firstWidget , secondWidget ; boolean vertical ; float splitAmount = <float> , minAmount , maxAmount = <int> ; private float oldSplitAmount ; private Rectangle firstWidgetBounds = new Rectangle ( ) ; private Rectangle secondWidgetBounds = new Rectangle ( ) ; Rectangle handleBounds = new Rectangle ( ) ; private Rectangle firstScissors = new Rectangle ( ) ; private Rectangle secondScissors = new Rectangle ( ) ; Vector2 lastPoint = new Vector2 ( ) ; Vector2 handlePosition = new Vector2 ( ) ; public SplitPane ( Actor firstWidget , Actor secondWidget , boolean vertical , Skin skin ) { this ( firstWidget , secondWidget , vertical , skin , <str> + ( vertical ? <str> : <str> ) ) ; } public SplitPane ( Actor firstWidget , Actor secondWidget , boolean vertical , Skin skin , String styleName ) { this ( firstWidget , secondWidget , vertical , skin . get ( styleName , SplitPaneStyle . class ) ) ; } public SplitPane ( Actor firstWidget , Actor secondWidget , boolean vertical , SplitPaneStyle style ) { this . firstWidget = firstWidget ; this . secondWidget = secondWidget ; this . vertical = vertical ; setStyle ( style ) ; setFirstWidget ( firstWidget ) ; setSecondWidget ( secondWidget ) ; setSize ( getPrefWidth ( ) , getPrefHeight ( ) ) ; initialize ( ) ; } private void initialize ( ) { addListener ( new InputListener ( ) { int draggingPointer = - <int> ; public boolean touchDown ( InputEvent event , float x , float y , int pointer , int button ) { if ( draggingPointer ! = - <int> ) return false ; if ( pointer = = <int> & & button ! = <int> ) return false ; if ( handleBounds . contains ( x , y ) ) { draggingPointer = pointer ; lastPoint . set ( x , y ) ; handlePosition . set ( handleBounds . x , handleBounds . y ) ; return true ; } return false ; } public void touchUp ( InputEvent event , float x , float y , int pointer , int button ) { if ( pointer = = draggingPointer ) draggingPointer = - <int> ; } public void touchDragged ( InputEvent event , float x , float y , int pointer ) { if ( pointer ! = draggingPointer ) return ; Drawable handle = style . handle ; if ( ! vertical ) { float delta = x - lastPoint . x ; float availWidth = getWidth ( ) - handle . getMinWidth ( ) ; float dragX = handlePosition . x + delta ; handlePosition . x = dragX ; dragX = Math . max ( <int> , dragX ) ; dragX = Math . min ( availWidth , dragX ) ; splitAmount = dragX / availWidth ; if ( splitAmount < minAmount ) splitAmount = minAmount ; if ( splitAmount > maxAmount ) splitAmount = maxAmount ; lastPoint . set ( x , y ) ; } else { float delta = y - lastPoint . y ; float availHeight = getHeight ( ) - handle . getMinHeight ( ) ; float dragY = handlePosition . y + delta ; handlePosition . y = dragY ; dragY = Math . max ( <int> , dragY ) ; dragY = Math . min ( availHeight , dragY ) ; splitAmount = <int> - ( dragY / availHeight ) ; if ( splitAmount < minAmount ) splitAmount = minAmount ; if ( splitAmount > maxAmount ) splitAmount = maxAmount ; lastPoint . set ( x , y ) ; } invalidate ( ) ; } } ) ; } public void setStyle ( SplitPaneStyle style ) { this . style = style ; invalidateHierarchy ( ) ; } public SplitPaneStyle getStyle ( ) { return style ; } @Override public void layout ( ) { if ( ! vertical ) calculateHorizBoundsAndPositions ( ) ; else calculateVertBoundsAndPositions ( ) ; Actor firstWidget = this . firstWidget ; if ( firstWidget ! = null ) { Rectangle firstWidgetBounds = this . firstWidgetBounds ; firstWidget . setBounds ( firstWidgetBounds . x , firstWidgetBounds . y , firstWidgetBounds . width , firstWidgetBounds . height ) ; if ( firstWidget instanceof Layout ) ( ( Layout ) firstWidget ) . validate ( ) ; } Actor secondWidget = this . secondWidget ; if ( secondWidget ! = null ) { Rectangle secondWidgetBounds = this . secondWidgetBounds ; secondWidget . setBounds ( secondWidgetBounds . x , secondWidgetBounds . y , secondWidgetBounds . width , secondWidgetBounds . height ) ; if ( secondWidget instanceof Layout ) ( ( Layout ) secondWidget ) . validate ( ) ; } } @Override public float getPrefWidth ( ) { float first = firstWidget = = null ? <int> : ( firstWidget instanceof Layout ? ( ( Layout ) firstWidget ) . getPrefWidth ( ) : firstWidget . getWidth ( ) ) ; float second = secondWidget = = null ? <int> : ( secondWidget instanceof Layout ? ( ( Layout ) secondWidget ) . getPrefWidth ( ) : secondWidget . getWidth ( ) ) ; if ( vertical ) return Math . max ( first , second ) ; return first + style . handle . getMinWidth ( ) + second ; } @Override public float getPrefHeight ( ) { float first = firstWidget = = null ? <int> : ( firstWidget instanceof Layout ? ( ( Layout ) firstWidget ) . getPrefHeight ( ) : firstWidget . getHeight ( ) ) ; float second = secondWidget = = null ? <int> : ( secondWidget instanceof Layout ? ( ( Layout ) secondWidget ) . getPrefHeight ( ) : secondWidget . getHeight ( ) ) ; if ( ! vertical ) return Math . max ( first , second ) ; return first + style . handle . getMinHeight ( ) + second ; } public float getMinWidth ( ) { return <int> ; } public float getMinHeight ( ) { return <int> ; } public void setVertical ( boolean vertical ) { this . vertical = vertical ; } private void calculateHorizBoundsAndPositions ( ) { Drawable handle = style . handle ; float height = getHeight ( ) ; float availWidth = getWidth ( ) - handle . getMinWidth ( ) ; float leftAreaWidth = ( int ) ( availWidth * splitAmount ) ; float rightAreaWidth = availWidth - leftAreaWidth ; float handleWidth = handle . getMinWidth ( ) ; firstWidgetBounds . set ( <int> , <int> , leftAreaWidth , height ) ; secondWidgetBounds . set ( leftAreaWidth + handleWidth , <int> , rightAreaWidth , height ) ; handleBounds . set ( leftAreaWidth , <int> , handleWidth , height ) ; } private void calculateVertBoundsAndPositions ( ) { Drawable handle = style . handle ; float width = getWidth ( ) ; float height = getHeight ( ) ; float availHeight = height - handle . getMinHeight ( ) ; float topAreaHeight = ( int ) ( availHeight * splitAmount ) ; float bottomAreaHeight = availHeight - topAreaHeight ; float handleHeight = handle . getMinHeight ( ) ; firstWidgetBounds . set ( <int> , height - topAreaHeight , width , topAreaHeight ) ; secondWidgetBounds . set ( <int> , <int> , width , bottomAreaHeight ) ; handleBounds . set ( <int> , bottomAreaHeight , width , handleHeight ) ; } @Override public void draw ( Batch batch , float parentAlpha ) { validate ( ) ; Color color = getColor ( ) ; Drawable handle = style . handle ; applyTransform ( batch , computeTransform ( ) ) ; Matrix4 transform = batch . getTransformMatrix ( ) ; if ( firstWidget ! = null ) { batch . flush ( ) ; getStage ( ) . calculateScissors ( firstWidgetBounds , firstScissors ) ; if ( ScissorStack . pushScissors ( firstScissors ) ) { if ( firstWidget . isVisible ( ) ) firstWidget . draw ( batch , parentAlpha * color . a ) ; batch . flush ( ) ; ScissorStack . popScissors ( ) ; } } if ( secondWidget ! = null ) { batch . flush ( ) ; getStage ( ) . calculateScissors ( secondWidgetBounds , secondScissors ) ; if ( ScissorStack . pushScissors ( secondScissors ) ) { if ( secondWidget . isVisible ( ) ) secondWidget . draw ( batch , parentAlpha * color . a ) ; batch . flush ( ) ; ScissorStack . popScissors ( ) ; } } batch . setColor ( color . r , color . g , color . b , parentAlpha * color . a ) ; handle . draw ( batch , handleBounds . x , handleBounds . y , handleBounds . width , handleBounds . height ) ; resetTransform ( batch ) ; } public void setSplitAmount ( float split ) { this . splitAmount = Math . max ( Math . min ( maxAmount , split ) , minAmount ) ; invalidate ( ) ; } public float getSplit ( ) { return splitAmount ; } public void setMinSplitAmount ( float minAmount ) { if ( minAmount < <int> ) throw new GdxRuntimeException ( <str> ) ; if ( minAmount > = maxAmount ) throw new GdxRuntimeException ( <str> ) ; this . minAmount = minAmount ; } public void setMaxSplitAmount ( float maxAmount ) { if ( maxAmount > <int> ) throw new GdxRuntimeException ( <str> ) ; if ( maxAmount < = minAmount ) throw new GdxRuntimeException ( <str> ) ; this . maxAmount = maxAmount ; } public void setFirstWidget ( Actor widget ) { if ( firstWidget ! = null ) super . removeActor ( firstWidget ) ; firstWidget = widget ; if ( widget ! = null ) super . addActor ( widget ) ; invalidate ( ) ; } public void setSecondWidget ( Actor widget ) { if ( secondWidget ! = null ) super . removeActor ( secondWidget ) ; secondWidget = widget ; if ( widget ! = null ) super . addActor ( widget ) ; invalidate ( ) ; } public void addActor ( Actor actor ) { throw new UnsupportedOperationException ( <str> ) ; } public void addActorAt ( int index , Actor actor ) { throw new UnsupportedOperationException ( <str> ) ; } public void addActorBefore ( Actor actorBefore , Actor actor ) { throw new UnsupportedOperationException ( <str> ) ; } public boolean removeActor ( Actor actor ) { throw new UnsupportedOperationException ( <str> ) ; } static public class SplitPaneStyle { public Drawable handle ; public SplitPaneStyle ( ) { } public SplitPaneStyle ( Drawable handle ) { this . handle = handle ; } public SplitPaneStyle ( SplitPaneStyle style ) { this . handle = style . handle ; } } } 
