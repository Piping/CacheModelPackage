package io . netty . util . internal ; import org . junit . Test ; import java . util . Random ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotSame ; import static org . junit . Assert . assertTrue ; public class PlatformDependentTest { private static final Random r = new Random ( ) ; @Test public void testEquals ( ) { byte [ ] bytes1 = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; byte [ ] bytes2 = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; assertNotSame ( bytes1 , bytes2 ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length ) ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length - <int> ) ) ; bytes1 = new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> } ; bytes2 = new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; assertNotSame ( bytes1 , bytes2 ) ; assertFalse ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length ) ) ; assertTrue ( PlatformDependent . equals ( bytes2 , <int> , bytes1 , <int> , bytes1 . length ) ) ; bytes1 = new byte [ ] { <int> , <int> , <int> , <int> } ; bytes2 = new byte [ ] { <int> , <int> , <int> , <int> } ; assertFalse ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length ) ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , <int> ) ) ; bytes1 = new byte [ ] { <int> , <int> , <int> , <int> } ; bytes2 = new byte [ ] { <int> , <int> , <int> , <int> } ; assertFalse ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length ) ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length - <int> ) ) ; bytes1 = new byte [ <int> ] ; bytes2 = new byte [ <int> ] ; assertNotSame ( bytes1 , bytes2 ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , <int> ) ) ; bytes1 = new byte [ <int> ] ; bytes2 = new byte [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) { bytes1 [ i ] = ( byte ) i ; bytes2 [ i ] = ( byte ) i ; } assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length ) ) ; bytes1 [ <int> ] = <int> ; assertFalse ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length ) ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length - <int> ) ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , <int> ) ) ; bytes1 = new byte [ ] { <int> , <int> , <int> , <int> , <int> } ; bytes2 = new byte [ ] { <int> , <int> , <int> } ; assertFalse ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes2 . length ) ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes2 . length ) ) ; assertTrue ( PlatformDependent . equals ( bytes2 , <int> , bytes1 , <int> , bytes2 . length ) ) ; for ( int i = <int> ; i < <int> ; + + i ) { bytes1 = new byte [ i ] ; r . nextBytes ( bytes1 ) ; bytes2 = bytes1 . clone ( ) ; assertTrue ( PlatformDependent . equals ( bytes1 , <int> , bytes2 , <int> , bytes1 . length ) ) ; } } private static char randomCharInByteRange ( ) { return ( char ) r . nextInt ( <int> + <int> ) ; } @Test public void testHashCodeAscii ( ) { for ( int i = <int> ; i < <int> ; + + i ) { byte [ ] bytes = new byte [ i ] ; char [ ] bytesChar = new char [ i ] ; for ( int j = <int> ; j < bytesChar . length ; + + j ) { bytesChar [ j ] = randomCharInByteRange ( ) ; bytes [ j ] = ( byte ) ( bytesChar [ j ] & <hex> ) ; } String string = new String ( bytesChar ) ; assertEquals ( <str> + i , PlatformDependent . hashCodeAsciiSafe ( bytes , <int> , bytes . length ) , PlatformDependent . hashCodeAscii ( bytes , <int> , bytes . length ) ) ; assertEquals ( <str> + i , PlatformDependent . hashCodeAsciiSafe ( string ) , PlatformDependent . hashCodeAscii ( string ) ) ; assertEquals ( <str> + i , PlatformDependent . hashCodeAscii ( bytes , <int> , bytes . length ) , PlatformDependent . hashCodeAscii ( string ) ) ; } } } 
