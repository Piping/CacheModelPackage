package com . badlogic . gdx . graphics ; import java . nio . FloatBuffer ; import java . nio . ShortBuffer ; import java . util . HashMap ; import java . util . Map ; import com . badlogic . gdx . Application ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . glutils . IndexArray ; import com . badlogic . gdx . graphics . glutils . IndexBufferObject ; import com . badlogic . gdx . graphics . glutils . IndexBufferObjectSubData ; import com . badlogic . gdx . graphics . glutils . IndexData ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . graphics . glutils . VertexArray ; import com . badlogic . gdx . graphics . glutils . VertexBufferObject ; import com . badlogic . gdx . graphics . glutils . VertexBufferObjectSubData ; import com . badlogic . gdx . graphics . glutils . VertexBufferObjectWithVAO ; import com . badlogic . gdx . graphics . glutils . VertexData ; import com . badlogic . gdx . math . Matrix3 ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class Mesh implements Disposable { public enum VertexDataType { VertexArray , VertexBufferObject , VertexBufferObjectSubData , VertexBufferObjectWithVAO } static final Map < Application , Array < Mesh > > meshes = new HashMap < Application , Array < Mesh > > ( ) ; final VertexData vertices ; final IndexData indices ; boolean autoBind = true ; final boolean isVertexArray ; protected Mesh ( VertexData vertices , IndexData indices , boolean isVertexArray ) { this . vertices = vertices ; this . indices = indices ; this . isVertexArray = isVertexArray ; addManagedMesh ( Gdx . app , this ) ; } public Mesh ( boolean isStatic , int maxVertices , int maxIndices , VertexAttribute . . . attributes ) { vertices = makeVertexBuffer ( isStatic , maxVertices , new VertexAttributes ( attributes ) ) ; indices = new IndexBufferObject ( isStatic , maxIndices ) ; isVertexArray = false ; addManagedMesh ( Gdx . app , this ) ; } public Mesh ( boolean isStatic , int maxVertices , int maxIndices , VertexAttributes attributes ) { vertices = makeVertexBuffer ( isStatic , maxVertices , attributes ) ; indices = new IndexBufferObject ( isStatic , maxIndices ) ; isVertexArray = false ; addManagedMesh ( Gdx . app , this ) ; } public Mesh ( boolean staticVertices , boolean staticIndices , int maxVertices , int maxIndices , VertexAttributes attributes ) { vertices = makeVertexBuffer ( staticVertices , maxVertices , attributes ) ; indices = new IndexBufferObject ( staticIndices , maxIndices ) ; isVertexArray = false ; addManagedMesh ( Gdx . app , this ) ; } private VertexData makeVertexBuffer ( boolean isStatic , int maxVertices , VertexAttributes vertexAttributes ) { if ( Gdx . gl30 ! = null ) { return new VertexBufferObjectWithVAO ( isStatic , maxVertices , vertexAttributes ) ; } else { return new VertexBufferObject ( isStatic , maxVertices , vertexAttributes ) ; } } public Mesh ( VertexDataType type , boolean isStatic , int maxVertices , int maxIndices , VertexAttribute . . . attributes ) { switch ( type ) { case VertexBufferObject : vertices = new VertexBufferObject ( isStatic , maxVertices , attributes ) ; indices = new IndexBufferObject ( isStatic , maxIndices ) ; isVertexArray = false ; break ; case VertexBufferObjectSubData : vertices = new VertexBufferObjectSubData ( isStatic , maxVertices , attributes ) ; indices = new IndexBufferObjectSubData ( isStatic , maxIndices ) ; isVertexArray = false ; break ; case VertexBufferObjectWithVAO : vertices = new VertexBufferObjectWithVAO ( isStatic , maxVertices , attributes ) ; indices = new IndexBufferObjectSubData ( isStatic , maxIndices ) ; isVertexArray = false ; break ; case VertexArray : default : vertices = new VertexArray ( maxVertices , attributes ) ; indices = new IndexArray ( maxIndices ) ; isVertexArray = true ; break ; } addManagedMesh ( Gdx . app , this ) ; } public Mesh setVertices ( float [ ] vertices ) { this . vertices . setVertices ( vertices , <int> , vertices . length ) ; return this ; } public Mesh setVertices ( float [ ] vertices , int offset , int count ) { this . vertices . setVertices ( vertices , offset , count ) ; return this ; } public Mesh updateVertices ( int targetOffset , float [ ] source ) { return updateVertices ( targetOffset , source , <int> , source . length ) ; } public Mesh updateVertices ( int targetOffset , float [ ] source , int sourceOffset , int count ) { this . vertices . updateVertices ( targetOffset , source , sourceOffset , count ) ; return this ; } public float [ ] getVertices ( float [ ] vertices ) { return getVertices ( <int> , - <int> , vertices ) ; } public float [ ] getVertices ( int srcOffset , float [ ] vertices ) { return getVertices ( srcOffset , - <int> , vertices ) ; } public float [ ] getVertices ( int srcOffset , int count , float [ ] vertices ) { return getVertices ( srcOffset , count , vertices , <int> ) ; } public float [ ] getVertices ( int srcOffset , int count , float [ ] vertices , int destOffset ) { final int max = getNumVertices ( ) * getVertexSize ( ) / <int> ; if ( count = = - <int> ) { count = max - srcOffset ; if ( count > vertices . length - destOffset ) count = vertices . length - destOffset ; } if ( srcOffset < <int> | | count < = <int> | | ( srcOffset + count ) > max | | destOffset < <int> | | destOffset > = vertices . length ) throw new IndexOutOfBoundsException ( ) ; if ( ( vertices . length - destOffset ) < count ) throw new IllegalArgumentException ( <str> + vertices . length + <str> + count ) ; int pos = getVerticesBuffer ( ) . position ( ) ; getVerticesBuffer ( ) . position ( srcOffset ) ; getVerticesBuffer ( ) . get ( vertices , destOffset , count ) ; getVerticesBuffer ( ) . position ( pos ) ; return vertices ; } public Mesh setIndices ( short [ ] indices ) { this . indices . setIndices ( indices , <int> , indices . length ) ; return this ; } public Mesh setIndices ( short [ ] indices , int offset , int count ) { this . indices . setIndices ( indices , offset , count ) ; return this ; } public void getIndices ( short [ ] indices ) { getIndices ( indices , <int> ) ; } public void getIndices ( short [ ] indices , int destOffset ) { getIndices ( <int> , indices , destOffset ) ; } public void getIndices ( int srcOffset , short [ ] indices , int destOffset ) { getIndices ( srcOffset , - <int> , indices , destOffset ) ; } public void getIndices ( int srcOffset , int count , short [ ] indices , int destOffset ) { int max = getNumIndices ( ) ; if ( count < <int> ) count = max - srcOffset ; if ( srcOffset < <int> | | srcOffset > = max | | srcOffset + count > max ) throw new IllegalArgumentException ( <str> + srcOffset + <str> + count + <str> + max ) ; if ( ( indices . length - destOffset ) < count ) throw new IllegalArgumentException ( <str> + indices . length + <str> + count ) ; int pos = getIndicesBuffer ( ) . position ( ) ; getIndicesBuffer ( ) . position ( srcOffset ) ; getIndicesBuffer ( ) . get ( indices , destOffset , count ) ; getIndicesBuffer ( ) . position ( pos ) ; } public int getNumIndices ( ) { return indices . getNumIndices ( ) ; } public int getNumVertices ( ) { return vertices . getNumVertices ( ) ; } public int getMaxVertices ( ) { return vertices . getNumMaxVertices ( ) ; } public int getMaxIndices ( ) { return indices . getNumMaxIndices ( ) ; } public int getVertexSize ( ) { return vertices . getAttributes ( ) . vertexSize ; } public void setAutoBind ( boolean autoBind ) { this . autoBind = autoBind ; } public void bind ( final ShaderProgram shader ) { bind ( shader , null ) ; } public void bind ( final ShaderProgram shader , final int [ ] locations ) { vertices . bind ( shader , locations ) ; if ( indices . getNumIndices ( ) > <int> ) indices . bind ( ) ; } public void unbind ( final ShaderProgram shader ) { unbind ( shader , null ) ; } public void unbind ( final ShaderProgram shader , final int [ ] locations ) { vertices . unbind ( shader , locations ) ; if ( indices . getNumIndices ( ) > <int> ) indices . unbind ( ) ; } public void render ( ShaderProgram shader , int primitiveType ) { render ( shader , primitiveType , <int> , indices . getNumMaxIndices ( ) > <int> ? getNumIndices ( ) : getNumVertices ( ) , autoBind ) ; } public void render ( ShaderProgram shader , int primitiveType , int offset , int count ) { render ( shader , primitiveType , offset , count , autoBind ) ; } public void render ( ShaderProgram shader , int primitiveType , int offset , int count , boolean autoBind ) { if ( count = = <int> ) return ; if ( autoBind ) bind ( shader ) ; if ( isVertexArray ) { if ( indices . getNumIndices ( ) > <int> ) { ShortBuffer buffer = indices . getBuffer ( ) ; int oldPosition = buffer . position ( ) ; int oldLimit = buffer . limit ( ) ; buffer . position ( offset ) ; buffer . limit ( offset + count ) ; Gdx . gl20 . glDrawElements ( primitiveType , count , GL20 . GL_UNSIGNED_SHORT , buffer ) ; buffer . position ( oldPosition ) ; buffer . limit ( oldLimit ) ; } else { Gdx . gl20 . glDrawArrays ( primitiveType , offset , count ) ; } } else { if ( indices . getNumIndices ( ) > <int> ) Gdx . gl20 . glDrawElements ( primitiveType , count , GL20 . GL_UNSIGNED_SHORT , offset * <int> ) ; else Gdx . gl20 . glDrawArrays ( primitiveType , offset , count ) ; } if ( autoBind ) unbind ( shader ) ; } public void dispose ( ) { if ( meshes . get ( Gdx . app ) ! = null ) meshes . get ( Gdx . app ) . removeValue ( this , true ) ; vertices . dispose ( ) ; indices . dispose ( ) ; } public VertexAttribute getVertexAttribute ( int usage ) { VertexAttributes attributes = vertices . getAttributes ( ) ; int len = attributes . size ( ) ; for ( int i = <int> ; i < len ; i + + ) if ( attributes . get ( i ) . usage = = usage ) return attributes . get ( i ) ; return null ; } public VertexAttributes getVertexAttributes ( ) { return vertices . getAttributes ( ) ; } public FloatBuffer getVerticesBuffer ( ) { return vertices . getBuffer ( ) ; } public BoundingBox calculateBoundingBox ( ) { BoundingBox bbox = new BoundingBox ( ) ; calculateBoundingBox ( bbox ) ; return bbox ; } public void calculateBoundingBox ( BoundingBox bbox ) { final int numVertices = getNumVertices ( ) ; if ( numVertices = = <int> ) throw new GdxRuntimeException ( <str> ) ; final FloatBuffer verts = vertices . getBuffer ( ) ; bbox . inf ( ) ; final VertexAttribute posAttrib = getVertexAttribute ( Usage . Position ) ; final int offset = posAttrib . offset / <int> ; final int vertexSize = vertices . getAttributes ( ) . vertexSize / <int> ; int idx = offset ; switch ( posAttrib . numComponents ) { case <int> : for ( int i = <int> ; i < numVertices ; i + + ) { bbox . ext ( verts . get ( idx ) , <int> , <int> ) ; idx + = vertexSize ; } break ; case <int> : for ( int i = <int> ; i < numVertices ; i + + ) { bbox . ext ( verts . get ( idx ) , verts . get ( idx + <int> ) , <int> ) ; idx + = vertexSize ; } break ; case <int> : for ( int i = <int> ; i < numVertices ; i + + ) { bbox . ext ( verts . get ( idx ) , verts . get ( idx + <int> ) , verts . get ( idx + <int> ) ) ; idx + = vertexSize ; } break ; } } public BoundingBox calculateBoundingBox ( final BoundingBox out , int offset , int count ) { return extendBoundingBox ( out . inf ( ) , offset , count ) ; } public BoundingBox calculateBoundingBox ( final BoundingBox out , int offset , int count , final Matrix4 transform ) { return extendBoundingBox ( out . inf ( ) , offset , count , transform ) ; } public BoundingBox extendBoundingBox ( final BoundingBox out , int offset , int count ) { return extendBoundingBox ( out , offset , count , null ) ; } private final Vector3 tmpV = new Vector3 ( ) ; public BoundingBox extendBoundingBox ( final BoundingBox out , int offset , int count , final Matrix4 transform ) { final int numIndices = getNumIndices ( ) ; final int numVertices = getNumVertices ( ) ; final int max = numIndices = = <int> ? numVertices : numIndices ; if ( offset < <int> | | count < <int> | | offset + count > max ) throw new GdxRuntimeException ( <str> + offset + <str> + count + <str> + max + <str> ) ; final FloatBuffer verts = vertices . getBuffer ( ) ; final ShortBuffer index = indices . getBuffer ( ) ; final VertexAttribute posAttrib = getVertexAttribute ( Usage . Position ) ; final int posoff = posAttrib . offset / <int> ; final int vertexSize = vertices . getAttributes ( ) . vertexSize / <int> ; final int end = offset + count ; switch ( posAttrib . numComponents ) { case <int> : if ( numIndices > <int> ) { for ( int i = offset ; i < end ; i + + ) { final int idx = index . get ( i ) * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , <int> , <int> ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; out . ext ( tmpV ) ; } } else { for ( int i = offset ; i < end ; i + + ) { final int idx = i * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , <int> , <int> ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; out . ext ( tmpV ) ; } } break ; case <int> : if ( numIndices > <int> ) { for ( int i = offset ; i < end ; i + + ) { final int idx = index . get ( i ) * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , verts . get ( idx + <int> ) , <int> ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; out . ext ( tmpV ) ; } } else { for ( int i = offset ; i < end ; i + + ) { final int idx = i * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , verts . get ( idx + <int> ) , <int> ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; out . ext ( tmpV ) ; } } break ; case <int> : if ( numIndices > <int> ) { for ( int i = offset ; i < end ; i + + ) { final int idx = index . get ( i ) * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , verts . get ( idx + <int> ) , verts . get ( idx + <int> ) ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; out . ext ( tmpV ) ; } } else { for ( int i = offset ; i < end ; i + + ) { final int idx = i * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , verts . get ( idx + <int> ) , verts . get ( idx + <int> ) ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; out . ext ( tmpV ) ; } } break ; } return out ; } public float calculateRadiusSquared ( final float centerX , final float centerY , final float centerZ , int offset , int count , final Matrix4 transform ) { int numIndices = getNumIndices ( ) ; if ( offset < <int> | | count < <int> | | offset + count > numIndices ) throw new GdxRuntimeException ( <str> ) ; final FloatBuffer verts = vertices . getBuffer ( ) ; final ShortBuffer index = indices . getBuffer ( ) ; final VertexAttribute posAttrib = getVertexAttribute ( Usage . Position ) ; final int posoff = posAttrib . offset / <int> ; final int vertexSize = vertices . getAttributes ( ) . vertexSize / <int> ; final int end = offset + count ; float result = <int> ; switch ( posAttrib . numComponents ) { case <int> : for ( int i = offset ; i < end ; i + + ) { final int idx = index . get ( i ) * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , <int> , <int> ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; final float r = tmpV . sub ( centerX , centerY , centerZ ) . len2 ( ) ; if ( r > result ) result = r ; } break ; case <int> : for ( int i = offset ; i < end ; i + + ) { final int idx = index . get ( i ) * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , verts . get ( idx + <int> ) , <int> ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; final float r = tmpV . sub ( centerX , centerY , centerZ ) . len2 ( ) ; if ( r > result ) result = r ; } break ; case <int> : for ( int i = offset ; i < end ; i + + ) { final int idx = index . get ( i ) * vertexSize + posoff ; tmpV . set ( verts . get ( idx ) , verts . get ( idx + <int> ) , verts . get ( idx + <int> ) ) ; if ( transform ! = null ) tmpV . mul ( transform ) ; final float r = tmpV . sub ( centerX , centerY , centerZ ) . len2 ( ) ; if ( r > result ) result = r ; } break ; } return result ; } public float calculateRadius ( final float centerX , final float centerY , final float centerZ , int offset , int count , final Matrix4 transform ) { return ( float ) Math . sqrt ( calculateRadiusSquared ( centerX , centerY , centerZ , offset , count , transform ) ) ; } public float calculateRadius ( final Vector3 center , int offset , int count , final Matrix4 transform ) { return calculateRadius ( center . x , center . y , center . z , offset , count , transform ) ; } public float calculateRadius ( final float centerX , final float centerY , final float centerZ , int offset , int count ) { return calculateRadius ( centerX , centerY , centerZ , offset , count , null ) ; } public float calculateRadius ( final Vector3 center , int offset , int count ) { return calculateRadius ( center . x , center . y , center . z , offset , count , null ) ; } public float calculateRadius ( final float centerX , final float centerY , final float centerZ ) { return calculateRadius ( centerX , centerY , centerZ , <int> , getNumIndices ( ) , null ) ; } public float calculateRadius ( final Vector3 center ) { return calculateRadius ( center . x , center . y , center . z , <int> , getNumIndices ( ) , null ) ; } public ShortBuffer getIndicesBuffer ( ) { return indices . getBuffer ( ) ; } private static void addManagedMesh ( Application app , Mesh mesh ) { Array < Mesh > managedResources = meshes . get ( app ) ; if ( managedResources = = null ) managedResources = new Array < Mesh > ( ) ; managedResources . add ( mesh ) ; meshes . put ( app , managedResources ) ; } public static void invalidateAllMeshes ( Application app ) { Array < Mesh > meshesArray = meshes . get ( app ) ; if ( meshesArray = = null ) return ; for ( int i = <int> ; i < meshesArray . size ; i + + ) { meshesArray . get ( i ) . vertices . invalidate ( ) ; meshesArray . get ( i ) . indices . invalidate ( ) ; } } public static void clearAllMeshes ( Application app ) { meshes . remove ( app ) ; } public static String getManagedStatus ( ) { StringBuilder builder = new StringBuilder ( ) ; int i = <int> ; builder . append ( <str> ) ; for ( Application app : meshes . keySet ( ) ) { builder . append ( meshes . get ( app ) . size ) ; builder . append ( <str> ) ; } builder . append ( <str> ) ; return builder . toString ( ) ; } public void scale ( float scaleX , float scaleY , float scaleZ ) { final VertexAttribute posAttr = getVertexAttribute ( Usage . Position ) ; final int offset = posAttr . offset / <int> ; final int numComponents = posAttr . numComponents ; final int numVertices = getNumVertices ( ) ; final int vertexSize = getVertexSize ( ) / <int> ; final float [ ] vertices = new float [ numVertices * vertexSize ] ; getVertices ( vertices ) ; int idx = offset ; switch ( numComponents ) { case <int> : for ( int i = <int> ; i < numVertices ; i + + ) { vertices [ idx ] * = scaleX ; idx + = vertexSize ; } break ; case <int> : for ( int i = <int> ; i < numVertices ; i + + ) { vertices [ idx ] * = scaleX ; vertices [ idx + <int> ] * = scaleY ; idx + = vertexSize ; } break ; case <int> : for ( int i = <int> ; i < numVertices ; i + + ) { vertices [ idx ] * = scaleX ; vertices [ idx + <int> ] * = scaleY ; vertices [ idx + <int> ] * = scaleZ ; idx + = vertexSize ; } break ; } setVertices ( vertices ) ; } public void transform ( final Matrix4 matrix ) { transform ( matrix , <int> , getNumVertices ( ) ) ; } public void transform ( final Matrix4 matrix , final int start , final int count ) { final VertexAttribute posAttr = getVertexAttribute ( Usage . Position ) ; final int posOffset = posAttr . offset / <int> ; final int stride = getVertexSize ( ) / <int> ; final int numComponents = posAttr . numComponents ; final int numVertices = getNumVertices ( ) ; final float [ ] vertices = new float [ count * stride ] ; getVertices ( start * stride , count * stride , vertices ) ; transform ( matrix , vertices , stride , posOffset , numComponents , <int> , count ) ; updateVertices ( start * stride , vertices ) ; } public static void transform ( final Matrix4 matrix , final float [ ] vertices , int vertexSize , int offset , int dimensions , int start , int count ) { if ( offset < <int> | | dimensions < <int> | | ( offset + dimensions ) > vertexSize ) throw new IndexOutOfBoundsException ( ) ; if ( start < <int> | | count < <int> | | ( ( start + count ) * vertexSize ) > vertices . length ) throw new IndexOutOfBoundsException ( <str> + start + <str> + count + <str> + vertexSize + <str> + vertices . length ) ; final Vector3 tmp = new Vector3 ( ) ; int idx = offset + ( start * vertexSize ) ; switch ( dimensions ) { case <int> : for ( int i = <int> ; i < count ; i + + ) { tmp . set ( vertices [ idx ] , <int> , <int> ) . mul ( matrix ) ; vertices [ idx ] = tmp . x ; idx + = vertexSize ; } break ; case <int> : for ( int i = <int> ; i < count ; i + + ) { tmp . set ( vertices [ idx ] , vertices [ idx + <int> ] , <int> ) . mul ( matrix ) ; vertices [ idx ] = tmp . x ; vertices [ idx + <int> ] = tmp . y ; idx + = vertexSize ; } break ; case <int> : for ( int i = <int> ; i < count ; i + + ) { tmp . set ( vertices [ idx ] , vertices [ idx + <int> ] , vertices [ idx + <int> ] ) . mul ( matrix ) ; vertices [ idx ] = tmp . x ; vertices [ idx + <int> ] = tmp . y ; vertices [ idx + <int> ] = tmp . z ; idx + = vertexSize ; } break ; } } public void transformUV ( final Matrix3 matrix ) { transformUV ( matrix , <int> , getNumVertices ( ) ) ; } protected void transformUV ( final Matrix3 matrix , final int start , final int count ) { final VertexAttribute posAttr = getVertexAttribute ( Usage . TextureCoordinates ) ; final int offset = posAttr . offset / <int> ; final int vertexSize = getVertexSize ( ) / <int> ; final int numVertices = getNumVertices ( ) ; final float [ ] vertices = new float [ numVertices * vertexSize ] ; getVertices ( <int> , vertices . length , vertices ) ; transformUV ( matrix , vertices , vertexSize , offset , start , count ) ; setVertices ( vertices , <int> , vertices . length ) ; } public static void transformUV ( final Matrix3 matrix , final float [ ] vertices , int vertexSize , int offset , int start , int count ) { if ( start < <int> | | count < <int> | | ( ( start + count ) * vertexSize ) > vertices . length ) throw new IndexOutOfBoundsException ( <str> + start + <str> + count + <str> + vertexSize + <str> + vertices . length ) ; final Vector2 tmp = new Vector2 ( ) ; int idx = offset + ( start * vertexSize ) ; for ( int i = <int> ; i < count ; i + + ) { tmp . set ( vertices [ idx ] , vertices [ idx + <int> ] ) . mul ( matrix ) ; vertices [ idx ] = tmp . x ; vertices [ idx + <int> ] = tmp . y ; idx + = vertexSize ; } } public Mesh copy ( boolean isStatic , boolean removeDuplicates , final int [ ] usage ) { final int vertexSize = getVertexSize ( ) / <int> ; int numVertices = getNumVertices ( ) ; float [ ] vertices = new float [ numVertices * vertexSize ] ; getVertices ( <int> , vertices . length , vertices ) ; short [ ] checks = null ; VertexAttribute [ ] attrs = null ; int newVertexSize = <int> ; if ( usage ! = null ) { int size = <int> ; int as = <int> ; for ( int i = <int> ; i < usage . length ; i + + ) if ( getVertexAttribute ( usage [ i ] ) ! = null ) { size + = getVertexAttribute ( usage [ i ] ) . numComponents ; as + + ; } if ( size > <int> ) { attrs = new VertexAttribute [ as ] ; checks = new short [ size ] ; int idx = - <int> ; int ai = - <int> ; for ( int i = <int> ; i < usage . length ; i + + ) { VertexAttribute a = getVertexAttribute ( usage [ i ] ) ; if ( a = = null ) continue ; for ( int j = <int> ; j < a . numComponents ; j + + ) checks [ + + idx ] = ( short ) ( a . offset + j ) ; attrs [ + + ai ] = new VertexAttribute ( a . usage , a . numComponents , a . alias ) ; newVertexSize + = a . numComponents ; } } } if ( checks = = null ) { checks = new short [ vertexSize ] ; for ( short i = <int> ; i < vertexSize ; i + + ) checks [ i ] = i ; newVertexSize = vertexSize ; } int numIndices = getNumIndices ( ) ; short [ ] indices = null ; if ( numIndices > <int> ) { indices = new short [ numIndices ] ; getIndices ( indices ) ; if ( removeDuplicates | | newVertexSize ! = vertexSize ) { float [ ] tmp = new float [ vertices . length ] ; int size = <int> ; for ( int i = <int> ; i < numIndices ; i + + ) { final int idx1 = indices [ i ] * vertexSize ; short newIndex = - <int> ; if ( removeDuplicates ) { for ( short j = <int> ; j < size & & newIndex < <int> ; j + + ) { final int idx2 = j * newVertexSize ; boolean found = true ; for ( int k = <int> ; k < checks . length & & found ; k + + ) { if ( tmp [ idx2 + k ] ! = vertices [ idx1 + checks [ k ] ] ) found = false ; } if ( found ) newIndex = j ; } } if ( newIndex > <int> ) indices [ i ] = newIndex ; else { final int idx = size * newVertexSize ; for ( int j = <int> ; j < checks . length ; j + + ) tmp [ idx + j ] = vertices [ idx1 + checks [ j ] ] ; indices [ i ] = ( short ) size ; size + + ; } } vertices = tmp ; numVertices = size ; } } Mesh result ; if ( attrs = = null ) result = new Mesh ( isStatic , numVertices , indices = = null ? <int> : indices . length , getVertexAttributes ( ) ) ; else result = new Mesh ( isStatic , numVertices , indices = = null ? <int> : indices . length , attrs ) ; result . setVertices ( vertices , <int> , numVertices * newVertexSize ) ; result . setIndices ( indices ) ; return result ; } public Mesh copy ( boolean isStatic ) { return copy ( isStatic , false , null ) ; } } 
