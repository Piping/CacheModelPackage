package org . apache . cassandra . test . microbench ; import net . jpountz . lz4 . LZ4Compressor ; import net . jpountz . lz4 . LZ4Factory ; import net . jpountz . lz4 . LZ4FastDecompressor ; import org . openjdk . jmh . annotations . * ; import org . xerial . snappy . Snappy ; import java . io . IOException ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . TimeUnit ; @BenchmarkMode ( Mode . Throughput ) @OutputTimeUnit ( TimeUnit . MILLISECONDS ) @Warmup ( iterations = <int> , time = <int> , timeUnit = TimeUnit . SECONDS ) @Measurement ( iterations = <int> , time = <int> , timeUnit = TimeUnit . SECONDS ) @Fork ( value = <int> , jvmArgsAppend = <str> ) @Threads ( <int> ) @State ( Scope . Benchmark ) public class Sample { @Param ( { <str> } ) private int pageSize ; @Param ( { <str> } ) private int uniquePages ; @Param ( { <str> } ) private double randomRatio ; @Param ( { <str> } ) private String randomRunLength ; @Param ( { <str> } ) private String duplicateLookback ; private byte [ ] [ ] lz4Bytes ; private byte [ ] [ ] snappyBytes ; private byte [ ] [ ] rawBytes ; private LZ4FastDecompressor lz4Decompressor = LZ4Factory . fastestInstance ( ) . fastDecompressor ( ) ; private LZ4Compressor lz4Compressor = LZ4Factory . fastestInstance ( ) . fastCompressor ( ) ; @State ( Scope . Thread ) public static class ThreadState { byte [ ] bytes ; } @Setup public void setup ( ) throws IOException { ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; int [ ] randomRunLength = range ( this . randomRunLength ) ; int [ ] duplicateLookback = range ( this . duplicateLookback ) ; rawBytes = new byte [ uniquePages ] [ pageSize ] ; lz4Bytes = new byte [ uniquePages ] [ ] ; snappyBytes = new byte [ uniquePages ] [ ] ; byte [ ] [ ] runs = new byte [ duplicateLookback [ <int> ] - duplicateLookback [ <int> ] ] [ ] ; for ( int i = <int> ; i < rawBytes . length ; i + + ) { byte [ ] trg = rawBytes [ <int> ] ; int runCount = <int> ; int byteCount = <int> ; while ( byteCount < trg . length ) { byte [ ] nextRun ; if ( runCount = = <int> | | random . nextDouble ( ) < this . randomRatio ) { nextRun = new byte [ random . nextInt ( randomRunLength [ <int> ] , randomRunLength [ <int> ] ) ] ; random . nextBytes ( nextRun ) ; runs [ runCount % runs . length ] = nextRun ; runCount + + ; } else { int index = runCount < duplicateLookback [ <int> ] ? random . nextInt ( runCount ) : ( runCount - random . nextInt ( duplicateLookback [ <int> ] , duplicateLookback [ <int> ] ) ) ; nextRun = runs [ index % runs . length ] ; } System . arraycopy ( nextRun , <int> , trg , byteCount , Math . min ( nextRun . length , trg . length - byteCount ) ) ; byteCount + = nextRun . length ; } lz4Bytes [ i ] = lz4Compressor . compress ( trg ) ; snappyBytes [ i ] = Snappy . compress ( trg ) ; } } static int [ ] range ( String spec ) { String [ ] split = spec . split ( <str> ) ; return new int [ ] { Integer . parseInt ( split [ <int> ] ) , Integer . parseInt ( split [ <int> ] ) } ; } @Benchmark public void lz4 ( ThreadState state ) { if ( state . bytes = = null ) state . bytes = new byte [ this . pageSize ] ; byte [ ] in = lz4Bytes [ ThreadLocalRandom . current ( ) . nextInt ( lz4Bytes . length ) ] ; lz4Decompressor . decompress ( in , state . bytes ) ; } @Benchmark public void snappy ( ThreadState state ) throws IOException { byte [ ] in = snappyBytes [ ThreadLocalRandom . current ( ) . nextInt ( snappyBytes . length ) ] ; state . bytes = Snappy . uncompress ( in ) ; } } 
