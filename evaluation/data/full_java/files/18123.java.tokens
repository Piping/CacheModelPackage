package com . badlogic . gdx . graphics . glutils ; import java . io . BufferedInputStream ; import java . io . DataInputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . IntBuffer ; import java . util . zip . GZIPInputStream ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Cubemap ; import com . badlogic . gdx . graphics . CubemapData ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . TextureData ; import com . badlogic . gdx . graphics . glutils . ETC1 . ETC1Data ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . StreamUtils ; public class KTXTextureData implements TextureData , CubemapData { private FileHandle file ; private int glType ; private int glTypeSize ; private int glFormat ; private int glInternalFormat ; private int glBaseInternalFormat ; private int pixelWidth = - <int> ; private int pixelHeight = - <int> ; private int pixelDepth = - <int> ; private int numberOfArrayElements ; private int numberOfFaces ; private int numberOfMipmapLevels ; private int imagePos ; private ByteBuffer compressedData ; private boolean useMipMaps ; public KTXTextureData ( FileHandle file , boolean genMipMaps ) { this . file = file ; this . useMipMaps = genMipMaps ; } @Override public TextureDataType getType ( ) { return TextureDataType . Custom ; } @Override public boolean isPrepared ( ) { return compressedData ! = null ; } @Override public void prepare ( ) { if ( compressedData ! = null ) throw new GdxRuntimeException ( <str> ) ; if ( file = = null ) throw new GdxRuntimeException ( <str> ) ; if ( file . name ( ) . endsWith ( <str> ) ) { byte [ ] buffer = new byte [ <int> * <int> ] ; DataInputStream in = null ; try { in = new DataInputStream ( new BufferedInputStream ( new GZIPInputStream ( file . read ( ) ) ) ) ; int fileSize = in . readInt ( ) ; compressedData = BufferUtils . newUnsafeByteBuffer ( fileSize ) ; int readBytes = <int> ; while ( ( readBytes = in . read ( buffer ) ) ! = - <int> ) compressedData . put ( buffer , <int> , readBytes ) ; compressedData . position ( <int> ) ; compressedData . limit ( compressedData . capacity ( ) ) ; } catch ( Exception e ) { throw new GdxRuntimeException ( <str> + file + <str> , e ) ; } finally { StreamUtils . closeQuietly ( in ) ; } } else { compressedData = ByteBuffer . wrap ( file . readBytes ( ) ) ; } if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( compressedData . get ( ) ! = ( byte ) <hex> ) throw new GdxRuntimeException ( <str> ) ; int endianTag = compressedData . getInt ( ) ; if ( endianTag ! = <hex> & & endianTag ! = <hex> ) throw new GdxRuntimeException ( <str> ) ; if ( endianTag ! = <hex> ) compressedData . order ( compressedData . order ( ) = = ByteOrder . BIG_ENDIAN ? ByteOrder . LITTLE_ENDIAN : ByteOrder . BIG_ENDIAN ) ; glType = compressedData . getInt ( ) ; glTypeSize = compressedData . getInt ( ) ; glFormat = compressedData . getInt ( ) ; glInternalFormat = compressedData . getInt ( ) ; glBaseInternalFormat = compressedData . getInt ( ) ; pixelWidth = compressedData . getInt ( ) ; pixelHeight = compressedData . getInt ( ) ; pixelDepth = compressedData . getInt ( ) ; numberOfArrayElements = compressedData . getInt ( ) ; numberOfFaces = compressedData . getInt ( ) ; numberOfMipmapLevels = compressedData . getInt ( ) ; if ( numberOfMipmapLevels = = <int> ) { numberOfMipmapLevels = <int> ; useMipMaps = true ; } int bytesOfKeyValueData = compressedData . getInt ( ) ; imagePos = compressedData . position ( ) + bytesOfKeyValueData ; if ( ! compressedData . isDirect ( ) ) { int pos = imagePos ; for ( int level = <int> ; level < numberOfMipmapLevels ; level + + ) { int faceLodSize = compressedData . getInt ( pos ) ; int faceLodSizeRounded = ( faceLodSize + <int> ) & ~ <int> ; pos + = faceLodSizeRounded * numberOfFaces + <int> ; } compressedData . limit ( pos ) ; compressedData . position ( <int> ) ; ByteBuffer directBuffer = BufferUtils . newUnsafeByteBuffer ( pos ) ; directBuffer . order ( compressedData . order ( ) ) ; directBuffer . put ( compressedData ) ; compressedData = directBuffer ; } } private static final int GL_TEXTURE_1D = <hex> ; private static final int GL_TEXTURE_3D = <hex> ; private static final int GL_TEXTURE_1D_ARRAY_EXT = <hex> ; private static final int GL_TEXTURE_2D_ARRAY_EXT = <hex> ; @Override public void consumeCubemapData ( ) { consumeCustomData ( GL20 . GL_TEXTURE_CUBE_MAP ) ; } @Override public void consumeCustomData ( int target ) { if ( compressedData = = null ) throw new GdxRuntimeException ( <str> ) ; IntBuffer buffer = BufferUtils . newIntBuffer ( <int> ) ; boolean compressed = false ; if ( glType = = <int> | | glFormat = = <int> ) { if ( glType + glFormat ! = <int> ) throw new GdxRuntimeException ( <str> ) ; compressed = true ; } int textureDimensions = <int> ; int glTarget = GL_TEXTURE_1D ; if ( pixelHeight > <int> ) { textureDimensions = <int> ; glTarget = GL20 . GL_TEXTURE_2D ; } if ( pixelDepth > <int> ) { textureDimensions = <int> ; glTarget = GL_TEXTURE_3D ; } if ( numberOfFaces = = <int> ) { if ( textureDimensions = = <int> ) glTarget = GL20 . GL_TEXTURE_CUBE_MAP ; else throw new GdxRuntimeException ( <str> ) ; } else if ( numberOfFaces ! = <int> ) { throw new GdxRuntimeException ( <str> ) ; } if ( numberOfArrayElements > <int> ) { if ( glTarget = = GL_TEXTURE_1D ) glTarget = GL_TEXTURE_1D_ARRAY_EXT ; else if ( glTarget = = GL20 . GL_TEXTURE_2D ) glTarget = GL_TEXTURE_2D_ARRAY_EXT ; else throw new GdxRuntimeException ( <str> ) ; textureDimensions + + ; } if ( glTarget = = <hex> ) throw new GdxRuntimeException ( <str> ) ; int singleFace = - <int> ; if ( numberOfFaces = = <int> & & target ! = GL20 . GL_TEXTURE_CUBE_MAP ) { if ( ! ( GL20 . GL_TEXTURE_CUBE_MAP_POSITIVE_X < = target & & target < = GL20 . GL_TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) throw new GdxRuntimeException ( <str> ) ; singleFace = target - GL20 . GL_TEXTURE_CUBE_MAP_POSITIVE_X ; target = GL20 . GL_TEXTURE_CUBE_MAP_POSITIVE_X ; } else if ( numberOfFaces = = <int> & & target = = GL20 . GL_TEXTURE_CUBE_MAP ) { target = GL20 . GL_TEXTURE_CUBE_MAP_POSITIVE_X ; } else { if ( target ! = glTarget & & ! ( GL20 . GL_TEXTURE_CUBE_MAP_POSITIVE_X < = target & & target < = GL20 . GL_TEXTURE_CUBE_MAP_NEGATIVE_Z & & target = = GL20 . GL_TEXTURE_2D ) ) throw new GdxRuntimeException ( <str> + Integer . toHexString ( target ) + <str> + Integer . toHexString ( glTarget ) ) ; } Gdx . gl . glGetIntegerv ( GL20 . GL_UNPACK_ALIGNMENT , buffer ) ; int previousUnpackAlignment = buffer . get ( <int> ) ; if ( previousUnpackAlignment ! = <int> ) Gdx . gl . glPixelStorei ( GL20 . GL_UNPACK_ALIGNMENT , <int> ) ; int glInternalFormat = this . glInternalFormat ; int glFormat = this . glFormat ; int pos = imagePos ; for ( int level = <int> ; level < numberOfMipmapLevels ; level + + ) { int pixelWidth = Math . max ( <int> , this . pixelWidth > > level ) ; int pixelHeight = Math . max ( <int> , this . pixelHeight > > level ) ; int pixelDepth = Math . max ( <int> , this . pixelDepth > > level ) ; compressedData . position ( pos ) ; int faceLodSize = compressedData . getInt ( ) ; int faceLodSizeRounded = ( faceLodSize + <int> ) & ~ <int> ; pos + = <int> ; for ( int face = <int> ; face < numberOfFaces ; face + + ) { compressedData . position ( pos ) ; pos + = faceLodSizeRounded ; if ( singleFace ! = - <int> & & singleFace ! = face ) continue ; ByteBuffer data = compressedData . slice ( ) ; data . limit ( faceLodSizeRounded ) ; if ( textureDimensions = = <int> ) { } else if ( textureDimensions = = <int> ) { if ( numberOfArrayElements > <int> ) pixelHeight = numberOfArrayElements ; if ( compressed ) { if ( glInternalFormat = = ETC1 . ETC1_RGB8_OES ) { if ( ! Gdx . graphics . supportsExtension ( <str> ) ) { ETC1Data etcData = new ETC1Data ( pixelWidth , pixelHeight , data , <int> ) ; Pixmap pixmap = ETC1 . decodeImage ( etcData , Format . RGB888 ) ; Gdx . gl . glTexImage2D ( target + face , level , pixmap . getGLInternalFormat ( ) , pixmap . getWidth ( ) , pixmap . getHeight ( ) , <int> , pixmap . getGLFormat ( ) , pixmap . getGLType ( ) , pixmap . getPixels ( ) ) ; pixmap . dispose ( ) ; } else { Gdx . gl . glCompressedTexImage2D ( target + face , level , glInternalFormat , pixelWidth , pixelHeight , <int> , faceLodSize , data ) ; } } else { Gdx . gl . glCompressedTexImage2D ( target + face , level , glInternalFormat , pixelWidth , pixelHeight , <int> , faceLodSize , data ) ; } } else Gdx . gl . glTexImage2D ( target + face , level , glInternalFormat , pixelWidth , pixelHeight , <int> , glFormat , glType , data ) ; } else if ( textureDimensions = = <int> ) { if ( numberOfArrayElements > <int> ) pixelDepth = numberOfArrayElements ; } } } if ( previousUnpackAlignment ! = <int> ) Gdx . gl . glPixelStorei ( GL20 . GL_UNPACK_ALIGNMENT , previousUnpackAlignment ) ; if ( useMipMaps ( ) ) Gdx . gl . glGenerateMipmap ( target ) ; disposePreparedData ( ) ; } public void disposePreparedData ( ) { if ( compressedData ! = null ) BufferUtils . disposeUnsafeByteBuffer ( compressedData ) ; compressedData = null ; } @Override public Pixmap consumePixmap ( ) { throw new GdxRuntimeException ( <str> ) ; } @Override public boolean disposePixmap ( ) { throw new GdxRuntimeException ( <str> ) ; } @Override public int getWidth ( ) { return pixelWidth ; } @Override public int getHeight ( ) { return pixelHeight ; } public int getNumberOfMipMapLevels ( ) { return numberOfMipmapLevels ; } public int getNumberOfFaces ( ) { return numberOfFaces ; } public int getGlInternalFormat ( ) { return glInternalFormat ; } public ByteBuffer getData ( int requestedLevel , int requestedFace ) { int pos = imagePos ; for ( int level = <int> ; level < numberOfMipmapLevels ; level + + ) { int faceLodSize = compressedData . getInt ( pos ) ; int faceLodSizeRounded = ( faceLodSize + <int> ) & ~ <int> ; pos + = <int> ; if ( level = = requestedLevel ) { for ( int face = <int> ; face < numberOfFaces ; face + + ) { if ( face = = requestedFace ) { compressedData . position ( pos ) ; ByteBuffer data = compressedData . slice ( ) ; data . limit ( faceLodSizeRounded ) ; return data ; } pos + = faceLodSizeRounded ; } } else { pos + = faceLodSizeRounded * numberOfFaces ; } } return null ; } @Override public Format getFormat ( ) { throw new GdxRuntimeException ( <str> ) ; } @Override public boolean useMipMaps ( ) { return useMipMaps ; } @Override public boolean isManaged ( ) { return true ; } } 
