package com . google . common . primitives ; import com . google . common . collect . testing . Helpers ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . Comparator ; import java . util . List ; public class UnsignedBytesTest extends TestCase { private static final byte LEAST = <int> ; private static final byte GREATEST = ( byte ) <int> ; private static final byte [ ] VALUES = { LEAST , <int> , ( byte ) <int> , ( byte ) <int> , GREATEST } ; public void testToInt ( ) { assertEquals ( <int> , UnsignedBytes . toInt ( ( byte ) <int> ) ) ; assertEquals ( <int> , UnsignedBytes . toInt ( ( byte ) <int> ) ) ; assertEquals ( <int> , UnsignedBytes . toInt ( ( byte ) <int> ) ) ; assertEquals ( <int> , UnsignedBytes . toInt ( ( byte ) - <int> ) ) ; assertEquals ( <int> , UnsignedBytes . toInt ( ( byte ) - <int> ) ) ; assertEquals ( <int> , UnsignedBytes . toInt ( ( byte ) - <int> ) ) ; } public void testCheckedCast ( ) { for ( byte value : VALUES ) { assertEquals ( value , UnsignedBytes . checkedCast ( UnsignedBytes . toInt ( value ) ) ) ; } assertCastFails ( <int> ) ; assertCastFails ( - <int> ) ; assertCastFails ( Long . MAX_VALUE ) ; assertCastFails ( Long . MIN_VALUE ) ; } public void testSaturatedCast ( ) { for ( byte value : VALUES ) { assertEquals ( value , UnsignedBytes . saturatedCast ( UnsignedBytes . toInt ( value ) ) ) ; } assertEquals ( GREATEST , UnsignedBytes . saturatedCast ( <int> ) ) ; assertEquals ( LEAST , UnsignedBytes . saturatedCast ( - <int> ) ) ; assertEquals ( GREATEST , UnsignedBytes . saturatedCast ( Long . MAX_VALUE ) ) ; assertEquals ( LEAST , UnsignedBytes . saturatedCast ( Long . MIN_VALUE ) ) ; } @SuppressWarnings ( <str> ) private static void assertCastFails ( long value ) { try { UnsignedBytes . checkedCast ( value ) ; fail ( <str> + value ) ; } catch ( IllegalArgumentException ex ) { assertTrue ( value + <str> + ex . getMessage ( ) , ex . getMessage ( ) . contains ( String . valueOf ( value ) ) ) ; } } public void testCompare ( ) { for ( int i = <int> ; i < VALUES . length ; i + + ) { for ( int j = <int> ; j < VALUES . length ; j + + ) { byte x = VALUES [ i ] ; byte y = VALUES [ j ] ; assertEquals ( x + <str> + y , Math . signum ( UnsignedBytes . compare ( x , y ) ) , Math . signum ( Ints . compare ( i , j ) ) ) ; } } } @SuppressWarnings ( <str> ) public void testMax_noArgs ( ) { try { UnsignedBytes . max ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMax ( ) { assertEquals ( LEAST , UnsignedBytes . max ( LEAST ) ) ; assertEquals ( GREATEST , UnsignedBytes . max ( GREATEST ) ) ; assertEquals ( ( byte ) <int> , UnsignedBytes . max ( ( byte ) <int> , ( byte ) - <int> , ( byte ) - <int> , ( byte ) <int> , ( byte ) <int> ) ) ; } @SuppressWarnings ( <str> ) public void testMin_noArgs ( ) { try { UnsignedBytes . min ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testMin ( ) { assertEquals ( LEAST , UnsignedBytes . min ( LEAST ) ) ; assertEquals ( GREATEST , UnsignedBytes . min ( GREATEST ) ) ; assertEquals ( ( byte ) <int> , UnsignedBytes . min ( ( byte ) <int> , ( byte ) - <int> , ( byte ) - <int> , ( byte ) <int> , ( byte ) <int> ) ) ; assertEquals ( ( byte ) <int> , UnsignedBytes . min ( ( byte ) - <int> , ( byte ) <int> , ( byte ) <int> , ( byte ) - <int> , ( byte ) <int> ) ) ; } @SuppressWarnings ( <str> ) private static void assertParseFails ( String value ) { try { UnsignedBytes . parseUnsignedByte ( value ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testParseUnsignedByte ( ) { for ( int i = <int> ; i < = <hex> ; i + + ) { assertEquals ( ( byte ) i , UnsignedBytes . parseUnsignedByte ( Integer . toString ( i ) ) ) ; } assertParseFails ( <str> ) ; assertParseFails ( <str> ) ; assertParseFails ( <str> ) ; assertParseFails ( <str> ) ; } public void testMaxValue ( ) { assertTrue ( UnsignedBytes . compare ( UnsignedBytes . MAX_VALUE , ( byte ) ( UnsignedBytes . MAX_VALUE + <int> ) ) > <int> ) ; } @SuppressWarnings ( <str> ) private static void assertParseFails ( String value , int radix ) { try { UnsignedBytes . parseUnsignedByte ( value , radix ) ; fail ( ) ; } catch ( NumberFormatException expected ) { } } public void testParseUnsignedByteWithRadix ( ) throws NumberFormatException { for ( int radix = Character . MIN_RADIX ; radix < = Character . MAX_RADIX ; radix + + ) { for ( int i = <int> ; i < = <hex> ; i + + ) { assertEquals ( ( byte ) i , UnsignedBytes . parseUnsignedByte ( Integer . toString ( i , radix ) , radix ) ) ; } assertParseFails ( Integer . toString ( <int> , radix ) , radix ) ; assertParseFails ( Integer . toString ( - <int> , radix ) , radix ) ; assertParseFails ( Integer . toString ( - <int> , radix ) , radix ) ; assertParseFails ( Integer . toString ( <int> , radix ) , radix ) ; } } @SuppressWarnings ( <str> ) public void testParseUnsignedByteThrowsExceptionForInvalidRadix ( ) { try { UnsignedBytes . parseUnsignedByte ( <str> , Character . MIN_RADIX - <int> ) ; fail ( ) ; } catch ( NumberFormatException nfe ) { } try { UnsignedBytes . parseUnsignedByte ( <str> , Character . MAX_RADIX + <int> ) ; fail ( ) ; } catch ( NumberFormatException nfe ) { } try { UnsignedBytes . parseUnsignedByte ( <str> , - <int> ) ; fail ( ) ; } catch ( NumberFormatException nfe ) { } } public void testToString ( ) { for ( int i = <int> ; i < = <hex> ; i + + ) { assertEquals ( Integer . toString ( i ) , UnsignedBytes . toString ( ( byte ) i ) ) ; } } public void testToStringWithRadix ( ) { for ( int radix = Character . MIN_RADIX ; radix < = Character . MAX_RADIX ; radix + + ) { for ( int i = <int> ; i < = <hex> ; i + + ) { assertEquals ( Integer . toString ( i , radix ) , UnsignedBytes . toString ( ( byte ) i , radix ) ) ; } } } public void testJoin ( ) { assertEquals ( <str> , UnsignedBytes . join ( <str> , new byte [ ] { } ) ) ; assertEquals ( <str> , UnsignedBytes . join ( <str> , new byte [ ] { ( byte ) <int> } ) ) ; assertEquals ( <str> , UnsignedBytes . join ( <str> , ( byte ) <int> , ( byte ) <int> ) ) ; assertEquals ( <str> , UnsignedBytes . join ( <str> , ( byte ) <int> , ( byte ) <int> , ( byte ) <int> ) ) ; assertEquals ( <str> , UnsignedBytes . join ( <str> , ( byte ) <int> , ( byte ) - <int> ) ) ; } public void testLexicographicalComparatorDefaultChoice ( ) { Comparator < byte [ ] > defaultComparator = UnsignedBytes . lexicographicalComparator ( ) ; Comparator < byte [ ] > unsafeComparator = UnsignedBytes . LexicographicalComparatorHolder . UnsafeComparator . INSTANCE ; assertSame ( defaultComparator , unsafeComparator ) ; } public void testLexicographicalComparator ( ) { List < byte [ ] > ordered = Arrays . asList ( new byte [ ] { } , new byte [ ] { LEAST } , new byte [ ] { LEAST , LEAST } , new byte [ ] { LEAST , ( byte ) <int> } , new byte [ ] { ( byte ) <int> } , new byte [ ] { ( byte ) <int> , LEAST } , new byte [ ] { GREATEST , GREATEST - ( byte ) <int> } , new byte [ ] { GREATEST , GREATEST } , new byte [ ] { GREATEST , GREATEST , GREATEST } ) ; Comparator < byte [ ] > comparator = UnsignedBytes . lexicographicalComparator ( ) ; Helpers . testComparator ( comparator , ordered ) ; assertSame ( comparator , SerializableTester . reserialize ( comparator ) ) ; Comparator < byte [ ] > javaImpl = UnsignedBytes . lexicographicalComparatorJavaImpl ( ) ; Helpers . testComparator ( javaImpl , ordered ) ; assertSame ( javaImpl , SerializableTester . reserialize ( javaImpl ) ) ; } @SuppressWarnings ( <str> ) public void testLexicographicalComparatorLongInputs ( ) { for ( Comparator < byte [ ] > comparator : Arrays . asList ( UnsignedBytes . lexicographicalComparator ( ) , UnsignedBytes . lexicographicalComparatorJavaImpl ( ) ) ) { for ( int i = <int> ; i < <int> ; i + + ) { byte [ ] left = new byte [ <int> ] ; byte [ ] right = new byte [ <int> ] ; assertTrue ( comparator . compare ( left , right ) = = <int> ) ; left [ i ] = <int> ; assertTrue ( comparator . compare ( left , right ) > <int> ) ; assertTrue ( comparator . compare ( right , left ) < <int> ) ; } } } public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( UnsignedBytes . class ) ; } } 
