package org . elasticsearch . common . util . concurrent ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . transport . Transports ; import java . util . Objects ; import java . util . concurrent . * ; import java . util . concurrent . locks . AbstractQueuedSynchronizer ; public abstract class BaseFuture < V > implements Future < V > { private final Sync < V > sync = new Sync < > ( ) ; @Override public V get ( long timeout , TimeUnit unit ) throws InterruptedException , TimeoutException , ExecutionException { assert timeout < = <int> | | Transports . assertNotTransportThread ( <str> ) ; return sync . get ( unit . toNanos ( timeout ) ) ; } @Override public V get ( ) throws InterruptedException , ExecutionException { assert Transports . assertNotTransportThread ( <str> ) ; return sync . get ( ) ; } @Override public boolean isDone ( ) { return sync . isDone ( ) ; } @Override public boolean isCancelled ( ) { return sync . isCancelled ( ) ; } @Override public boolean cancel ( boolean mayInterruptIfRunning ) { if ( ! sync . cancel ( ) ) { return false ; } done ( ) ; if ( mayInterruptIfRunning ) { interruptTask ( ) ; } return true ; } protected void interruptTask ( ) { } protected boolean set ( @Nullable V value ) { boolean result = sync . set ( value ) ; if ( result ) { done ( ) ; } return result ; } protected boolean setException ( Throwable throwable ) { boolean result = sync . setException ( Objects . requireNonNull ( throwable ) ) ; if ( result ) { done ( ) ; } return result ; } protected void done ( ) { } static final class Sync < V > extends AbstractQueuedSynchronizer { private static final long serialVersionUID = <int> L ; static final int RUNNING = <int> ; static final int COMPLETING = <int> ; static final int COMPLETED = <int> ; static final int CANCELLED = <int> ; private V value ; private Throwable exception ; @Override protected int tryAcquireShared ( int ignored ) { if ( isDone ( ) ) { return <int> ; } return - <int> ; } @Override protected boolean tryReleaseShared ( int finalState ) { setState ( finalState ) ; return true ; } V get ( long nanos ) throws TimeoutException , CancellationException , ExecutionException , InterruptedException { if ( ! tryAcquireSharedNanos ( - <int> , nanos ) ) { throw new TimeoutException ( <str> ) ; } return getValue ( ) ; } V get ( ) throws CancellationException , ExecutionException , InterruptedException { acquireSharedInterruptibly ( - <int> ) ; return getValue ( ) ; } private V getValue ( ) throws CancellationException , ExecutionException { int state = getState ( ) ; switch ( state ) { case COMPLETED : if ( exception ! = null ) { throw new ExecutionException ( exception ) ; } else { return value ; } case CANCELLED : throw new CancellationException ( <str> ) ; default: throw new IllegalStateException ( <str> + state ) ; } } boolean isDone ( ) { return ( getState ( ) & ( COMPLETED | CANCELLED ) ) ! = <int> ; } boolean isCancelled ( ) { return getState ( ) = = CANCELLED ; } boolean set ( @Nullable V v ) { return complete ( v , null , COMPLETED ) ; } boolean setException ( Throwable t ) { return complete ( null , t , COMPLETED ) ; } boolean cancel ( ) { return complete ( null , null , CANCELLED ) ; } private boolean complete ( @Nullable V v , @Nullable Throwable t , int finalState ) { boolean doCompletion = compareAndSetState ( RUNNING , COMPLETING ) ; if ( doCompletion ) { this . value = v ; this . exception = t ; releaseShared ( finalState ) ; } else if ( getState ( ) = = COMPLETING ) { acquireShared ( - <int> ) ; } return doCompletion ; } } } 
