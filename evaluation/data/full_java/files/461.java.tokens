package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . nio . charset . CharacterCodingException ; import java . nio . charset . Charset ; import java . nio . charset . StandardCharsets ; import java . util . * ; import com . google . common . base . Objects ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . SyntaxException ; import org . apache . cassandra . serializers . * ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . Pair ; public class UserType extends TupleType { public final String keyspace ; public final ByteBuffer name ; private final List < ByteBuffer > fieldNames ; private final List < String > stringFieldNames ; public UserType ( String keyspace , ByteBuffer name , List < ByteBuffer > fieldNames , List < AbstractType < ? > > fieldTypes ) { super ( fieldTypes ) ; assert fieldNames . size ( ) = = fieldTypes . size ( ) ; this . keyspace = keyspace ; this . name = name ; this . fieldNames = fieldNames ; this . stringFieldNames = new ArrayList < > ( fieldNames . size ( ) ) ; for ( ByteBuffer fieldName : fieldNames ) { try { stringFieldNames . add ( ByteBufferUtil . string ( fieldName , StandardCharsets . UTF_8 ) ) ; } catch ( CharacterCodingException ex ) { throw new AssertionError ( <str> + ByteBufferUtil . bytesToHex ( fieldName ) , ex ) ; } } } public static UserType getInstance ( TypeParser parser ) throws ConfigurationException , SyntaxException { Pair < Pair < String , ByteBuffer > , List < Pair < ByteBuffer , AbstractType > > > params = parser . getUserTypeParameters ( ) ; String keyspace = params . left . left ; ByteBuffer name = params . left . right ; List < ByteBuffer > columnNames = new ArrayList < > ( params . right . size ( ) ) ; List < AbstractType < ? > > columnTypes = new ArrayList < > ( params . right . size ( ) ) ; for ( Pair < ByteBuffer , AbstractType > p : params . right ) { columnNames . add ( p . left ) ; columnTypes . add ( p . right . freeze ( ) ) ; } return new UserType ( keyspace , name , columnNames , columnTypes ) ; } public AbstractType < ? > fieldType ( int i ) { return type ( i ) ; } public List < AbstractType < ? > > fieldTypes ( ) { return types ; } public ByteBuffer fieldName ( int i ) { return fieldNames . get ( i ) ; } public String fieldNameAsString ( int i ) { return stringFieldNames . get ( i ) ; } public List < ByteBuffer > fieldNames ( ) { return fieldNames ; } public String getNameAsString ( ) { return UTF8Type . instance . compose ( name ) ; } @Override public void validate ( ByteBuffer bytes ) throws MarshalException { ByteBuffer input = bytes . duplicate ( ) ; for ( int i = <int> ; i < size ( ) ; i + + ) { if ( ! input . hasRemaining ( ) ) return ; if ( input . remaining ( ) < <int> ) throw new MarshalException ( String . format ( <str> , i , fieldName ( i ) ) ) ; int size = input . getInt ( ) ; if ( size < <int> ) continue ; if ( input . remaining ( ) < size ) throw new MarshalException ( String . format ( <str> , i , fieldName ( i ) ) ) ; ByteBuffer field = ByteBufferUtil . readBytes ( input , size ) ; types . get ( i ) . validate ( field ) ; } if ( input . hasRemaining ( ) ) throw new MarshalException ( <str> ) ; } @Override public Term fromJSONObject ( Object parsed ) throws MarshalException { if ( parsed instanceof String ) parsed = Json . decodeJson ( ( String ) parsed ) ; if ( ! ( parsed instanceof Map ) ) throw new MarshalException ( String . format ( <str> , parsed . getClass ( ) . getSimpleName ( ) , parsed ) ) ; Map < String , Object > map = ( Map < String , Object > ) parsed ; Json . handleCaseSensitivity ( map ) ; List < Term > terms = new ArrayList < > ( types . size ( ) ) ; Set keys = map . keySet ( ) ; assert keys . isEmpty ( ) | | keys . iterator ( ) . next ( ) instanceof String ; int foundValues = <int> ; for ( int i = <int> ; i < types . size ( ) ; i + + ) { Object value = map . get ( stringFieldNames . get ( i ) ) ; if ( value = = null ) { terms . add ( Constants . NULL_VALUE ) ; } else { terms . add ( types . get ( i ) . fromJSONObject ( value ) ) ; foundValues + = <int> ; } } if ( foundValues ! = map . size ( ) ) { for ( Object fieldName : keys ) { if ( ! stringFieldNames . contains ( fieldName ) ) throw new MarshalException ( String . format ( <str> , fieldName , getNameAsString ( ) ) ) ; } } return new UserTypes . DelayedValue ( this , terms ) ; } @Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { ByteBuffer [ ] buffers = split ( buffer ) ; StringBuilder sb = new StringBuilder ( <str> ) ; for ( int i = <int> ; i < types . size ( ) ; i + + ) { if ( i > <int> ) sb . append ( <str> ) ; String name = stringFieldNames . get ( i ) ; if ( ! name . equals ( name . toLowerCase ( Locale . US ) ) ) name = <str> + name + <str> ; sb . append ( <str> ) ; sb . append ( Json . JSON_STRING_ENCODER . quoteAsString ( name ) ) ; sb . append ( <str> ) ; ByteBuffer valueBuffer = buffers [ i ] ; if ( valueBuffer = = null ) sb . append ( <str> ) ; else sb . append ( types . get ( i ) . toJSONString ( valueBuffer , protocolVersion ) ) ; } return sb . append ( <str> ) . toString ( ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( keyspace , name , fieldNames , types ) ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof UserType ) ) return false ; UserType that = ( UserType ) o ; return keyspace . equals ( that . keyspace ) & & name . equals ( that . name ) & & fieldNames . equals ( that . fieldNames ) & & types . equals ( that . types ) ; } @Override public CQL3Type asCQL3Type ( ) { return CQL3Type . UserDefined . create ( this ) ; } @Override public String toString ( ) { return getClass ( ) . getName ( ) + TypeParser . stringifyUserTypeParameters ( keyspace , name , fieldNames , types ) ; } } 
