package org . gradle . api . internal ; import com . google . common . collect . Iterators ; import org . apache . commons . collections . collection . CompositeCollection ; import org . gradle . api . Action ; import org . gradle . api . DomainObjectCollection ; import org . gradle . api . specs . Spec ; import org . gradle . internal . Actions ; import java . util . Collection ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashSet ; public class CompositeDomainObjectSet < T > extends DelegatingDomainObjectSet < T > { private final Spec < T > uniqueSpec = new ItemIsUniqueInCompositeSpec ( ) ; private final Spec < T > notInSpec = new ItemNotInCompositeSpec ( ) ; private final DefaultDomainObjectSet < T > backingSet ; public static < T > CompositeDomainObjectSet < T > create ( Class < T > type , DomainObjectCollection < ? extends T > . . . collections ) { DefaultDomainObjectSet < T > backingSet = new DefaultDomainObjectSet < T > ( type , new CompositeCollection ( ) ) ; CompositeDomainObjectSet < T > out = new CompositeDomainObjectSet < T > ( backingSet ) ; for ( DomainObjectCollection < ? extends T > c : collections ) { out . addCollection ( c ) ; } return out ; } CompositeDomainObjectSet ( DefaultDomainObjectSet < T > backingSet ) { super ( backingSet ) ; this . backingSet = backingSet ; } public class ItemIsUniqueInCompositeSpec implements Spec < T > { public boolean isSatisfiedBy ( T element ) { int matches = <int> ; for ( Object collection : getStore ( ) . getCollections ( ) ) { if ( ( ( Collection ) collection ) . contains ( element ) ) { if ( + + matches > <int> ) { return false ; } } } return true ; } } public class ItemNotInCompositeSpec implements Spec < T > { public boolean isSatisfiedBy ( T element ) { return ! getStore ( ) . contains ( element ) ; } } @SuppressWarnings ( <str> ) protected CompositeCollection getStore ( ) { return ( CompositeCollection ) this . backingSet . getStore ( ) ; } public Action < ? super T > whenObjectAdded ( Action < ? super T > action ) { return super . whenObjectAdded ( Actions . filter ( action , uniqueSpec ) ) ; } public Action < ? super T > whenObjectRemoved ( Action < ? super T > action ) { return super . whenObjectRemoved ( Actions . filter ( action , notInSpec ) ) ; } public void addCollection ( DomainObjectCollection < ? extends T > collection ) { if ( ! getStore ( ) . getCollections ( ) . contains ( collection ) ) { getStore ( ) . addComposited ( collection ) ; collection . all ( backingSet . getEventRegister ( ) . getAddAction ( ) ) ; collection . whenObjectRemoved ( backingSet . getEventRegister ( ) . getRemoveAction ( ) ) ; } } public void removeCollection ( DomainObjectCollection < ? extends T > collection ) { getStore ( ) . removeComposited ( collection ) ; Action < ? super T > action = this . backingSet . getEventRegister ( ) . getRemoveAction ( ) ; for ( T item : collection ) { action . execute ( item ) ; } } @SuppressWarnings ( { <str> , <str> } ) @Override public Iterator < T > iterator ( ) { return Iterators . unmodifiableIterator ( new LinkedHashSet < T > ( getStore ( ) ) . iterator ( ) ) ; } @SuppressWarnings ( <str> ) public int size ( ) { return new HashSet < T > ( getStore ( ) ) . size ( ) ; } public void all ( Action < ? super T > action ) { whenObjectAdded ( action ) ; for ( T t : this ) { action . execute ( t ) ; } } } 
