package io . netty . channel . local ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandler . Sharable ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . DefaultEventLoopGroup ; import io . netty . util . ReferenceCountUtil ; import org . junit . Test ; import java . util . concurrent . atomic . AtomicInteger ; import static org . junit . Assert . * ; public class LocalTransportThreadModelTest2 { private static final String LOCAL_CHANNEL = LocalTransportThreadModelTest2 . class . getName ( ) ; static final int messageCountPerRun = <int> ; @Test ( timeout = <int> ) public void testSocketReuse ( ) throws InterruptedException { ServerBootstrap serverBootstrap = new ServerBootstrap ( ) ; LocalHander serverHandler = new LocalHander ( <str> ) ; serverBootstrap . group ( new DefaultEventLoopGroup ( ) , new DefaultEventLoopGroup ( ) ) . channel ( LocalServerChannel . class ) . childHandler ( serverHandler ) ; Bootstrap clientBootstrap = new Bootstrap ( ) ; LocalHander clientHandler = new LocalHander ( <str> ) ; clientBootstrap . group ( new DefaultEventLoopGroup ( ) ) . channel ( LocalChannel . class ) . remoteAddress ( new LocalAddress ( LOCAL_CHANNEL ) ) . handler ( clientHandler ) ; serverBootstrap . bind ( new LocalAddress ( LOCAL_CHANNEL ) ) . sync ( ) ; int count = <int> ; for ( int i = <int> ; i < count + <int> ; i + + ) { Channel ch = clientBootstrap . connect ( ) . sync ( ) . channel ( ) ; int target = i * messageCountPerRun ; while ( serverHandler . count . get ( ) ! = target | | clientHandler . count . get ( ) ! = target ) { Thread . sleep ( <int> ) ; } close ( ch , clientHandler ) ; } assertEquals ( count * <int> * messageCountPerRun , serverHandler . count . get ( ) + clientHandler . count . get ( ) ) ; } public void close ( final Channel localChannel , final LocalHander localRegistrationHandler ) { if ( localChannel . eventLoop ( ) . inEventLoop ( ) ) { if ( localRegistrationHandler . lastWriteFuture ! = null ) { localRegistrationHandler . lastWriteFuture . awaitUninterruptibly ( ) ; } localChannel . close ( ) ; return ; } localChannel . eventLoop ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { close ( localChannel , localRegistrationHandler ) ; } } ) ; localChannel . closeFuture ( ) . awaitUninterruptibly ( ) ; } @Sharable static class LocalHander extends ChannelInboundHandlerAdapter { private final String name ; public volatile ChannelFuture lastWriteFuture ; public final AtomicInteger count = new AtomicInteger ( <int> ) ; LocalHander ( String name ) { this . name = name ; } @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { for ( int i = <int> ; i < messageCountPerRun ; i + + ) { lastWriteFuture = ctx . channel ( ) . write ( name + <str> + i ) ; } ctx . channel ( ) . flush ( ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { count . incrementAndGet ( ) ; ReferenceCountUtil . release ( msg ) ; } } } 
