package org . elasticsearch . common . geo ; import org . apache . lucene . util . BitUtil ; import org . apache . lucene . util . GeoHashUtils ; import org . apache . lucene . util . GeoUtils ; public final class GeoPoint { private double lat ; private double lon ; public GeoPoint ( ) { } public GeoPoint ( String value ) { this . resetFromString ( value ) ; } public GeoPoint ( double lat , double lon ) { this . lat = lat ; this . lon = lon ; } public GeoPoint ( GeoPoint template ) { this ( template . getLat ( ) , template . getLon ( ) ) ; } public GeoPoint reset ( double lat , double lon ) { this . lat = lat ; this . lon = lon ; return this ; } public GeoPoint resetLat ( double lat ) { this . lat = lat ; return this ; } public GeoPoint resetLon ( double lon ) { this . lon = lon ; return this ; } public GeoPoint resetFromString ( String value ) { int comma = value . indexOf ( <str> ) ; if ( comma ! = - <int> ) { lat = Double . parseDouble ( value . substring ( <int> , comma ) . trim ( ) ) ; lon = Double . parseDouble ( value . substring ( comma + <int> ) . trim ( ) ) ; } else { resetFromGeoHash ( value ) ; } return this ; } public GeoPoint resetFromIndexHash ( long hash ) { lon = GeoUtils . mortonUnhashLon ( hash ) ; lat = GeoUtils . mortonUnhashLat ( hash ) ; return this ; } public GeoPoint resetFromGeoHash ( String geohash ) { final long hash = GeoHashUtils . mortonEncode ( geohash ) ; return this . reset ( GeoUtils . mortonUnhashLat ( hash ) , GeoUtils . mortonUnhashLon ( hash ) ) ; } public GeoPoint resetFromGeoHash ( long geohashLong ) { final int level = ( int ) ( <int> - ( geohashLong & <int> ) ) ; return this . resetFromIndexHash ( BitUtil . flipFlop ( ( geohashLong > > > <int> ) < < ( ( level * <int> ) + <int> ) ) ) ; } public final double lat ( ) { return this . lat ; } public final double getLat ( ) { return this . lat ; } public final double lon ( ) { return this . lon ; } public final double getLon ( ) { return this . lon ; } public final String geohash ( ) { return GeoHashUtils . stringEncode ( lon , lat ) ; } public final String getGeohash ( ) { return GeoHashUtils . stringEncode ( lon , lat ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; GeoPoint geoPoint = ( GeoPoint ) o ; if ( Double . compare ( geoPoint . lat , lat ) ! = <int> ) return false ; if ( Double . compare ( geoPoint . lon , lon ) ! = <int> ) return false ; return true ; } @Override public int hashCode ( ) { int result ; long temp ; temp = lat ! = + <float> ? Double . doubleToLongBits ( lat ) : <int> L ; result = Long . hashCode ( temp ) ; temp = lon ! = + <float> ? Double . doubleToLongBits ( lon ) : <int> L ; result = <int> * result + Long . hashCode ( temp ) ; return result ; } @Override public String toString ( ) { return <str> + lat + <str> + lon + <str> ; } public static GeoPoint parseFromLatLon ( String latLon ) { GeoPoint point = new GeoPoint ( latLon ) ; return point ; } public static GeoPoint fromGeohash ( String geohash ) { return new GeoPoint ( ) . resetFromGeoHash ( geohash ) ; } public static GeoPoint fromGeohash ( long geohashLong ) { return new GeoPoint ( ) . resetFromGeoHash ( geohashLong ) ; } public static GeoPoint fromIndexLong ( long indexLong ) { return new GeoPoint ( ) . resetFromIndexHash ( indexLong ) ; } } 
