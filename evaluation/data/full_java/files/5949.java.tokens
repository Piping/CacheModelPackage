package org . elasticsearch . common . joda ; import org . elasticsearch . ElasticsearchParseException ; import org . joda . time . DateTimeZone ; import org . joda . time . MutableDateTime ; import org . joda . time . format . DateTimeFormatter ; import java . util . Objects ; import java . util . concurrent . Callable ; public class DateMathParser { private final FormatDateTimeFormatter dateTimeFormatter ; public DateMathParser ( FormatDateTimeFormatter dateTimeFormatter ) { Objects . requireNonNull ( dateTimeFormatter ) ; this . dateTimeFormatter = dateTimeFormatter ; } public long parse ( String text , Callable < Long > now ) { return parse ( text , now , false , null ) ; } public long parse ( String text , Callable < Long > now , boolean roundUp , DateTimeZone timeZone ) { long time ; String mathString ; if ( text . startsWith ( <str> ) ) { try { time = now . call ( ) ; } catch ( Exception e ) { throw new ElasticsearchParseException ( <str> , e ) ; } mathString = text . substring ( <str> . length ( ) ) ; } else { int index = text . indexOf ( <str> ) ; if ( index = = - <int> ) { return parseDateTime ( text , timeZone ) ; } time = parseDateTime ( text . substring ( <int> , index ) , timeZone ) ; mathString = text . substring ( index + <int> ) ; if ( mathString . isEmpty ( ) ) { return time ; } } return parseMath ( mathString , time , roundUp , timeZone ) ; } private long parseMath ( String mathString , long time , boolean roundUp , DateTimeZone timeZone ) throws ElasticsearchParseException { if ( timeZone = = null ) { timeZone = DateTimeZone . UTC ; } MutableDateTime dateTime = new MutableDateTime ( time , timeZone ) ; for ( int i = <int> ; i < mathString . length ( ) ; ) { char c = mathString . charAt ( i + + ) ; final boolean round ; final int sign ; if ( c = = <str> ) { round = true ; sign = <int> ; } else { round = false ; if ( c = = <str> ) { sign = <int> ; } else if ( c = = <str> ) { sign = - <int> ; } else { throw new ElasticsearchParseException ( <str> , mathString ) ; } } if ( i > = mathString . length ( ) ) { throw new ElasticsearchParseException ( <str> , mathString ) ; } final int num ; if ( ! Character . isDigit ( mathString . charAt ( i ) ) ) { num = <int> ; } else { int numFrom = i ; while ( i < mathString . length ( ) & & Character . isDigit ( mathString . charAt ( i ) ) ) { i + + ; } if ( i > = mathString . length ( ) ) { throw new ElasticsearchParseException ( <str> , mathString ) ; } num = Integer . parseInt ( mathString . substring ( numFrom , i ) ) ; } if ( round ) { if ( num ! = <int> ) { throw new ElasticsearchParseException ( <str> , mathString ) ; } } char unit = mathString . charAt ( i + + ) ; MutableDateTime . Property propertyToRound = null ; switch ( unit ) { case <str> : if ( round ) { propertyToRound = dateTime . yearOfCentury ( ) ; } else { dateTime . addYears ( sign * num ) ; } break ; case <str> : if ( round ) { propertyToRound = dateTime . monthOfYear ( ) ; } else { dateTime . addMonths ( sign * num ) ; } break ; case <str> : if ( round ) { propertyToRound = dateTime . weekOfWeekyear ( ) ; } else { dateTime . addWeeks ( sign * num ) ; } break ; case <str> : if ( round ) { propertyToRound = dateTime . dayOfMonth ( ) ; } else { dateTime . addDays ( sign * num ) ; } break ; case <str> : case <str> : if ( round ) { propertyToRound = dateTime . hourOfDay ( ) ; } else { dateTime . addHours ( sign * num ) ; } break ; case <str> : if ( round ) { propertyToRound = dateTime . minuteOfHour ( ) ; } else { dateTime . addMinutes ( sign * num ) ; } break ; case <str> : if ( round ) { propertyToRound = dateTime . secondOfMinute ( ) ; } else { dateTime . addSeconds ( sign * num ) ; } break ; default : throw new ElasticsearchParseException ( <str> , unit , mathString ) ; } if ( propertyToRound ! = null ) { if ( roundUp ) { propertyToRound . add ( <int> ) ; propertyToRound . roundFloor ( ) ; dateTime . addMillis ( - <int> ) ; } else { propertyToRound . roundFloor ( ) ; } } } return dateTime . getMillis ( ) ; } private long parseDateTime ( String value , DateTimeZone timeZone ) { DateTimeFormatter parser = dateTimeFormatter . parser ( ) ; if ( timeZone ! = null ) { parser = parser . withZone ( timeZone ) ; } try { return parser . parseMillis ( value ) ; } catch ( IllegalArgumentException e ) { throw new ElasticsearchParseException ( <str> , e , value , dateTimeFormatter . format ( ) ) ; } } } 
