package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . io . util . * ; import org . apache . cassandra . utils . memory . AbstractAllocator ; public class Clustering extends AbstractClusteringPrefix { public static final Serializer serializer = new Serializer ( ) ; public static final Clustering STATIC_CLUSTERING = new Clustering ( EMPTY_VALUES_ARRAY ) { @Override public Kind kind ( ) { return Kind . STATIC_CLUSTERING ; } @Override public String toString ( ) { return <str> ; } @Override public String toString ( CFMetaData metadata ) { return toString ( ) ; } } ; public static final Clustering EMPTY = new Clustering ( EMPTY_VALUES_ARRAY ) { @Override public String toString ( CFMetaData metadata ) { return <str> ; } } ; public Clustering ( ByteBuffer . . . values ) { super ( Kind . CLUSTERING , values ) ; } public Kind kind ( ) { return Kind . CLUSTERING ; } public Clustering copy ( AbstractAllocator allocator ) { if ( size ( ) = = <int> ) return this ; ByteBuffer [ ] newValues = new ByteBuffer [ size ( ) ] ; for ( int i = <int> ; i < size ( ) ; i + + ) newValues [ i ] = values [ i ] = = null ? null : allocator . clone ( values [ i ] ) ; return new Clustering ( newValues ) ; } public String toString ( CFMetaData metadata ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = <int> ; i < size ( ) ; i + + ) { ColumnDefinition c = metadata . clusteringColumns ( ) . get ( i ) ; sb . append ( i = = <int> ? <str> : <str> ) . append ( c . name ) . append ( <str> ) . append ( get ( i ) = = null ? <str> : c . type . getString ( get ( i ) ) ) ; } return sb . toString ( ) ; } public String toCQLString ( CFMetaData metadata ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = <int> ; i < size ( ) ; i + + ) { ColumnDefinition c = metadata . clusteringColumns ( ) . get ( i ) ; sb . append ( i = = <int> ? <str> : <str> ) . append ( c . type . getString ( get ( i ) ) ) ; } return sb . toString ( ) ; } public static class Serializer { public void serialize ( Clustering clustering , DataOutputPlus out , int version , List < AbstractType < ? > > types ) throws IOException { assert clustering ! = STATIC_CLUSTERING : <str> ; assert clustering . size ( ) = = types . size ( ) : <str> + clustering ; ClusteringPrefix . serializer . serializeValuesWithoutSize ( clustering , out , version , types ) ; } public ByteBuffer serialize ( Clustering clustering , int version , List < AbstractType < ? > > types ) { try ( DataOutputBuffer buffer = new DataOutputBuffer ( ( int ) serializedSize ( clustering , version , types ) ) ) { serialize ( clustering , buffer , version , types ) ; return buffer . buffer ( ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } } public long serializedSize ( Clustering clustering , int version , List < AbstractType < ? > > types ) { return ClusteringPrefix . serializer . valuesWithoutSizeSerializedSize ( clustering , version , types ) ; } public Clustering deserialize ( DataInputPlus in , int version , List < AbstractType < ? > > types ) throws IOException { if ( types . isEmpty ( ) ) return EMPTY ; ByteBuffer [ ] values = ClusteringPrefix . serializer . deserializeValuesWithoutSize ( in , types . size ( ) , version , types ) ; return new Clustering ( values ) ; } public Clustering deserialize ( ByteBuffer in , int version , List < AbstractType < ? > > types ) { try ( DataInputBuffer buffer = new DataInputBuffer ( in , true ) ) { return deserialize ( buffer , version , types ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } } } } 
