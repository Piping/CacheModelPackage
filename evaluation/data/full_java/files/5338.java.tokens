package org . elasticsearch . action . percolate ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . CompositeIndicesRequest ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . get . GetRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContent ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . action . ValidateActions . addValidationError ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeStringArrayValue ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeStringValue ; public class MultiPercolateRequest extends ActionRequest < MultiPercolateRequest > implements CompositeIndicesRequest { private String [ ] indices ; private String documentType ; private IndicesOptions indicesOptions = IndicesOptions . strictExpandOpenAndForbidClosed ( ) ; private List < PercolateRequest > requests = new ArrayList < > ( ) ; public MultiPercolateRequest add ( PercolateRequestBuilder requestBuilder ) { return add ( requestBuilder . request ( ) ) ; } public MultiPercolateRequest add ( PercolateRequest request ) { if ( request . indices ( ) = = null & & indices ! = null ) { request . indices ( indices ) ; } if ( request . documentType ( ) = = null & & documentType ! = null ) { request . documentType ( documentType ) ; } if ( request . indicesOptions ( ) = = IndicesOptions . strictExpandOpenAndForbidClosed ( ) & & indicesOptions ! = IndicesOptions . strictExpandOpenAndForbidClosed ( ) ) { request . indicesOptions ( indicesOptions ) ; } requests . add ( request ) ; return this ; } public MultiPercolateRequest add ( byte [ ] data , int from , int length ) throws Exception { return add ( new BytesArray ( data , from , length ) , true ) ; } public MultiPercolateRequest add ( BytesReference data , boolean allowExplicitIndex ) throws Exception { XContent xContent = XContentFactory . xContent ( data ) ; int from = <int> ; int length = data . length ( ) ; byte marker = xContent . streamSeparator ( ) ; while ( true ) { int nextMarker = findNextMarker ( marker , from , data , length ) ; if ( nextMarker = = - <int> ) { break ; } if ( nextMarker = = <int> ) { from = nextMarker + <int> ; continue ; } PercolateRequest percolateRequest = new PercolateRequest ( ) ; if ( indices ! = null ) { percolateRequest . indices ( indices ) ; } if ( documentType ! = null ) { percolateRequest . documentType ( documentType ) ; } if ( indicesOptions ! = IndicesOptions . strictExpandOpenAndForbidClosed ( ) ) { percolateRequest . indicesOptions ( indicesOptions ) ; } if ( nextMarker - from > <int> ) { try ( XContentParser parser = xContent . createParser ( data . slice ( from , nextMarker - from ) ) ) { XContentParser . Token token = parser . nextToken ( ) ; if ( token ! = null ) { assert token = = XContentParser . Token . START_OBJECT ; token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . FIELD_NAME ) { throw new ElasticsearchParseException ( <str> ) ; } token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_OBJECT ) { throw new ElasticsearchParseException ( <str> ) ; } String percolateAction = parser . currentName ( ) ; if ( <str> . equals ( percolateAction ) ) { parsePercolateAction ( parser , percolateRequest , allowExplicitIndex ) ; } else if ( <str> . equals ( percolateAction ) ) { percolateRequest . onlyCount ( true ) ; parsePercolateAction ( parser , percolateRequest , allowExplicitIndex ) ; } else { throw new ElasticsearchParseException ( <str> , percolateAction ) ; } } } } from = nextMarker + <int> ; nextMarker = findNextMarker ( marker , from , data , length ) ; if ( nextMarker = = - <int> ) { break ; } percolateRequest . source ( data . slice ( from , nextMarker - from ) ) ; from = nextMarker + <int> ; add ( percolateRequest ) ; } return this ; } @Override public List < ? extends IndicesRequest > subRequests ( ) { List < IndicesRequest > indicesRequests = new ArrayList < > ( ) ; for ( PercolateRequest percolateRequest : this . requests ) { indicesRequests . addAll ( percolateRequest . subRequests ( ) ) ; } return indicesRequests ; } private void parsePercolateAction ( XContentParser parser , PercolateRequest percolateRequest , boolean allowExplicitIndex ) throws IOException { String globalIndex = indices ! = null & & indices . length > <int> ? indices [ <int> ] : null ; Map < String , Object > header = parser . map ( ) ; if ( header . containsKey ( <str> ) ) { GetRequest getRequest = new GetRequest ( globalIndex ) ; percolateRequest . getRequest ( getRequest ) ; for ( Map . Entry < String , Object > entry : header . entrySet ( ) ) { Object value = entry . getValue ( ) ; if ( <str> . equals ( entry . getKey ( ) ) ) { getRequest . id ( nodeStringValue ( value , null ) ) ; header . put ( <str> , entry . getValue ( ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) | | <str> . equals ( entry . getKey ( ) ) ) { if ( ! allowExplicitIndex ) { throw new IllegalArgumentException ( <str> ) ; } getRequest . index ( nodeStringValue ( value , null ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) ) { getRequest . type ( nodeStringValue ( value , null ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) ) { getRequest . preference ( nodeStringValue ( value , null ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) ) { getRequest . routing ( nodeStringValue ( value , null ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) | | <str> . equals ( entry . getKey ( ) ) | | <str> . equals ( entry . getKey ( ) ) | | <str> . equals ( entry . getKey ( ) ) ) { percolateRequest . indices ( nodeStringArrayValue ( value ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) | | <str> . equals ( entry . getKey ( ) ) ) { percolateRequest . documentType ( nodeStringValue ( value , null ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) | | <str> . equals ( entry . getKey ( ) ) ) { percolateRequest . preference ( nodeStringValue ( value , null ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) | | <str> . equals ( entry . getKey ( ) ) ) { percolateRequest . routing ( nodeStringValue ( value , null ) ) ; } } if ( ( percolateRequest . indices ( ) = = null | | percolateRequest . indices ( ) . length = = <int> ) & & getRequest . index ( ) ! = null ) { percolateRequest . indices ( getRequest . index ( ) ) ; } if ( percolateRequest . documentType ( ) = = null & & getRequest . type ( ) ! = null ) { percolateRequest . documentType ( getRequest . type ( ) ) ; } if ( percolateRequest . routing ( ) = = null & & getRequest . routing ( ) ! = null ) { percolateRequest . routing ( getRequest . routing ( ) ) ; } if ( percolateRequest . preference ( ) = = null & & getRequest . preference ( ) ! = null ) { percolateRequest . preference ( getRequest . preference ( ) ) ; } } else { for ( Map . Entry < String , Object > entry : header . entrySet ( ) ) { Object value = entry . getValue ( ) ; if ( <str> . equals ( entry . getKey ( ) ) | | <str> . equals ( entry . getKey ( ) ) ) { if ( ! allowExplicitIndex ) { throw new IllegalArgumentException ( <str> ) ; } percolateRequest . indices ( nodeStringArrayValue ( value ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) ) { percolateRequest . documentType ( nodeStringValue ( value , null ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) ) { percolateRequest . preference ( nodeStringValue ( value , null ) ) ; } else if ( <str> . equals ( entry . getKey ( ) ) ) { percolateRequest . routing ( nodeStringValue ( value , null ) ) ; } } } percolateRequest . indicesOptions ( IndicesOptions . fromMap ( header , indicesOptions ) ) ; } private int findNextMarker ( byte marker , int from , BytesReference data , int length ) { for ( int i = from ; i < length ; i + + ) { if ( data . get ( i ) = = marker ) { return i ; } } return - <int> ; } public List < PercolateRequest > requests ( ) { return this . requests ; } public IndicesOptions indicesOptions ( ) { return indicesOptions ; } public MultiPercolateRequest indicesOptions ( IndicesOptions indicesOptions ) { this . indicesOptions = indicesOptions ; return this ; } public String [ ] indices ( ) { return indices ; } public MultiPercolateRequest indices ( String . . . indices ) { this . indices = indices ; return this ; } public String documentType ( ) { return documentType ; } public MultiPercolateRequest documentType ( String type ) { this . documentType = type ; return this ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( requests . isEmpty ( ) ) { validationException = addValidationError ( <str> , validationException ) ; } for ( int i = <int> ; i < requests . size ( ) ; i + + ) { ActionRequestValidationException ex = requests . get ( i ) . validate ( ) ; if ( ex ! = null ) { if ( validationException = = null ) { validationException = new ActionRequestValidationException ( ) ; } validationException . addValidationErrors ( ex . validationErrors ( ) ) ; } } return validationException ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; indices = in . readStringArray ( ) ; documentType = in . readOptionalString ( ) ; indicesOptions = IndicesOptions . readIndicesOptions ( in ) ; int size = in . readVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { PercolateRequest request = new PercolateRequest ( ) ; request . readFrom ( in ) ; requests . add ( request ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeStringArrayNullable ( indices ) ; out . writeOptionalString ( documentType ) ; indicesOptions . writeIndicesOptions ( out ) ; out . writeVInt ( requests . size ( ) ) ; for ( PercolateRequest request : requests ) { request . writeTo ( out ) ; } } } 
