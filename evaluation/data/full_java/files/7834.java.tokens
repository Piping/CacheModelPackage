package org . elasticsearch . cluster . routing ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESAllocationTestCase ; import org . elasticsearch . test . cluster . TestClusterService ; import org . elasticsearch . threadpool . ThreadPool ; import org . junit . After ; import org . junit . Before ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicBoolean ; import static java . util . Collections . singletonMap ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . cluster . routing . ShardRoutingState . STARTED ; import static org . hamcrest . Matchers . equalTo ; public class RoutingServiceTests extends ESAllocationTestCase { private TestRoutingService routingService ; @Before public void createRoutingService ( ) { routingService = new TestRoutingService ( ) ; } @After public void shutdownRoutingService ( ) throws Exception { routingService . shutdown ( ) ; } public void testReroute ( ) { assertThat ( routingService . hasReroutedAndClear ( ) , equalTo ( false ) ) ; routingService . reroute ( <str> ) ; assertThat ( routingService . hasReroutedAndClear ( ) , equalTo ( true ) ) ; } public void testNoDelayedUnassigned ( ) throws Exception { AllocationService allocation = createAllocationService ( Settings . EMPTY , new DelayedShardsMockGatewayAllocator ( ) ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , <str> ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . localNodeId ( <str> ) . masterNodeId ( <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) > <int> , equalTo ( false ) ) ; ClusterState prevState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . remove ( <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; ClusterState newState = clusterState ; assertThat ( routingService . getMinDelaySettingAtLastSchedulingNanos ( ) , equalTo ( Long . MAX_VALUE ) ) ; routingService . clusterChanged ( new ClusterChangedEvent ( <str> , newState , prevState ) ) ; assertThat ( routingService . getMinDelaySettingAtLastSchedulingNanos ( ) , equalTo ( Long . MAX_VALUE ) ) ; assertThat ( routingService . hasReroutedAndClear ( ) , equalTo ( false ) ) ; } public void testDelayedUnassignedScheduleReroute ( ) throws Exception { MockAllocationService allocation = createAllocationService ( Settings . EMPTY , new DelayedShardsMockGatewayAllocator ( ) ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , <str> ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . localNodeId ( <str> ) . masterNodeId ( <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; assertFalse ( <str> , clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) > <int> ) ; String nodeId = null ; final List < ShardRouting > allShards = clusterState . getRoutingNodes ( ) . routingTable ( ) . allShards ( <str> ) ; for ( ShardRouting shardRouting : allShards ) { if ( shardRouting . primary ( ) = = false ) { nodeId = shardRouting . currentNodeId ( ) ; break ; } } assertNotNull ( nodeId ) ; ClusterState prevState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . remove ( nodeId ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; assertEquals ( <int> , clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) ) ; ClusterState newState = clusterState ; routingService . clusterChanged ( new ClusterChangedEvent ( <str> , newState , prevState ) ) ; assertBusy ( ( ) - > assertTrue ( <str> , routingService . hasReroutedAndClear ( ) ) ) ; assertThat ( routingService . getMinDelaySettingAtLastSchedulingNanos ( ) , equalTo ( Long . MAX_VALUE ) ) ; } public void testDelayedUnassignedScheduleRerouteAfterDelayedReroute ( ) throws Exception { final ThreadPool testThreadPool = new ThreadPool ( getTestName ( ) ) ; try { MockAllocationService allocation = createAllocationService ( Settings . EMPTY , new DelayedShardsMockGatewayAllocator ( ) ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , <str> ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , <str> ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> , singletonMap ( <str> , Boolean . FALSE . toString ( ) ) ) ) . localNodeId ( <str> ) . masterNodeId ( <str> ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; assertThat ( <str> , clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . size ( ) , equalTo ( <int> ) ) ; ShardRouting shortDelayReplica = null ; for ( ShardRouting shardRouting : clusterState . getRoutingNodes ( ) . routingTable ( ) . allShards ( <str> ) ) { if ( shardRouting . primary ( ) = = false ) { shortDelayReplica = shardRouting ; break ; } } assertNotNull ( shortDelayReplica ) ; ShardRouting longDelayReplica = null ; for ( ShardRouting shardRouting : clusterState . getRoutingNodes ( ) . routingTable ( ) . allShards ( <str> ) ) { if ( shardRouting . primary ( ) = = false ) { longDelayReplica = shardRouting ; break ; } } assertNotNull ( longDelayReplica ) ; final long baseTime = System . nanoTime ( ) ; ClusterState prevState = clusterState ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . remove ( shortDelayReplica . currentNodeId ( ) ) . remove ( longDelayReplica . currentNodeId ( ) ) ) . build ( ) ; allocation . setNanoTimeOverride ( baseTime ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; RoutingNodes . UnassignedShards unassigned = clusterState . getRoutingNodes ( ) . unassigned ( ) ; assertEquals ( <int> , unassigned . size ( ) ) ; ShardRouting shortDelayUnassignedReplica = null ; ShardRouting longDelayUnassignedReplica = null ; for ( ShardRouting shr : unassigned ) { if ( shr . getIndex ( ) . equals ( <str> ) ) { shortDelayUnassignedReplica = shr ; } else { longDelayUnassignedReplica = shr ; } } assertTrue ( shortDelayReplica . isSameShard ( shortDelayUnassignedReplica ) ) ; assertTrue ( longDelayReplica . isSameShard ( longDelayUnassignedReplica ) ) ; ClusterState newState = clusterState ; TestClusterService clusterService = new TestClusterService ( newState , testThreadPool ) ; RoutingService routingService = new RoutingService ( Settings . EMPTY , testThreadPool , clusterService , allocation ) ; routingService . start ( ) ; allocation . setNanoTimeOverride ( baseTime + TimeValue . timeValueSeconds ( <int> ) . nanos ( ) ) ; CountDownLatch latch = new CountDownLatch ( <int> ) ; clusterService . addLast ( event - > latch . countDown ( ) ) ; routingService . clusterChanged ( new ClusterChangedEvent ( <str> , newState , prevState ) ) ; latch . await ( ) ; assertThat ( routingService . getMinDelaySettingAtLastSchedulingNanos ( ) , equalTo ( TimeValue . timeValueSeconds ( <int> ) . nanos ( ) ) ) ; } finally { terminate ( testThreadPool ) ; } } private class TestRoutingService extends RoutingService { private AtomicBoolean rerouted = new AtomicBoolean ( ) ; public TestRoutingService ( ) { super ( Settings . EMPTY , new ThreadPool ( getTestName ( ) ) , null , null ) ; } void shutdown ( ) throws Exception { terminate ( threadPool ) ; } public boolean hasReroutedAndClear ( ) { return rerouted . getAndSet ( false ) ; } @Override protected void performReroute ( String reason ) { logger . info ( <str> , reason ) ; rerouted . set ( true ) ; } } } 
