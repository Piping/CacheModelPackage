package org . jbox2d . particle ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Vec2 ; import org . jbox2d . pooling . normal . MutableStack ; public class VoronoiDiagram { public static class Generator { final Vec2 center = new Vec2 ( ) ; int tag ; } public static class VoronoiDiagramTask { int m_x , m_y , m_i ; Generator m_generator ; public VoronoiDiagramTask ( ) { } public VoronoiDiagramTask ( int x , int y , int i , Generator g ) { m_x = x ; m_y = y ; m_i = i ; m_generator = g ; } public VoronoiDiagramTask set ( int x , int y , int i , Generator g ) { m_x = x ; m_y = y ; m_i = i ; m_generator = g ; return this ; } } public static interface VoronoiDiagramCallback { void callback ( int aTag , int bTag , int cTag ) ; } private Generator [ ] m_generatorBuffer ; private int m_generatorCount ; private int m_countX , m_countY ; private Generator [ ] m_diagram ; public VoronoiDiagram ( int generatorCapacity ) { m_generatorBuffer = new Generator [ generatorCapacity ] ; for ( int i = <int> ; i < generatorCapacity ; i + + ) { m_generatorBuffer [ i ] = new Generator ( ) ; } m_generatorCount = <int> ; m_countX = <int> ; m_countY = <int> ; m_diagram = null ; } public void getNodes ( VoronoiDiagramCallback callback ) { for ( int y = <int> ; y < m_countY - <int> ; y + + ) { for ( int x = <int> ; x < m_countX - <int> ; x + + ) { int i = x + y * m_countX ; Generator a = m_diagram [ i ] ; Generator b = m_diagram [ i + <int> ] ; Generator c = m_diagram [ i + m_countX ] ; Generator d = m_diagram [ i + <int> + m_countX ] ; if ( b ! = c ) { if ( a ! = b & & a ! = c ) { callback . callback ( a . tag , b . tag , c . tag ) ; } if ( d ! = b & & d ! = c ) { callback . callback ( b . tag , d . tag , c . tag ) ; } } } } } public void addGenerator ( Vec2 center , int tag ) { Generator g = m_generatorBuffer [ m_generatorCount + + ] ; g . center . x = center . x ; g . center . y = center . y ; g . tag = tag ; } private final Vec2 lower = new Vec2 ( ) ; private final Vec2 upper = new Vec2 ( ) ; private MutableStack < VoronoiDiagramTask > taskPool = new MutableStack < VoronoiDiagram . VoronoiDiagramTask > ( <int> ) { @Override protected VoronoiDiagramTask newInstance ( ) { return new VoronoiDiagramTask ( ) ; } @Override protected VoronoiDiagramTask [ ] newArray ( int size ) { return new VoronoiDiagramTask [ size ] ; } } ; private final StackQueue < VoronoiDiagramTask > queue = new StackQueue < VoronoiDiagramTask > ( ) ; public void generate ( float radius ) { assert ( m_diagram = = null ) ; float inverseRadius = <int> / radius ; lower . x = Float . MAX_VALUE ; lower . y = Float . MAX_VALUE ; upper . x = - Float . MAX_VALUE ; upper . y = - Float . MAX_VALUE ; for ( int k = <int> ; k < m_generatorCount ; k + + ) { Generator g = m_generatorBuffer [ k ] ; Vec2 . minToOut ( lower , g . center , lower ) ; Vec2 . maxToOut ( upper , g . center , upper ) ; } m_countX = <int> + ( int ) ( inverseRadius * ( upper . x - lower . x ) ) ; m_countY = <int> + ( int ) ( inverseRadius * ( upper . y - lower . y ) ) ; m_diagram = new Generator [ m_countX * m_countY ] ; queue . reset ( new VoronoiDiagramTask [ <int> * m_countX * m_countX ] ) ; for ( int k = <int> ; k < m_generatorCount ; k + + ) { Generator g = m_generatorBuffer [ k ] ; g . center . x = inverseRadius * ( g . center . x - lower . x ) ; g . center . y = inverseRadius * ( g . center . y - lower . y ) ; int x = MathUtils . max ( <int> , MathUtils . min ( ( int ) g . center . x , m_countX - <int> ) ) ; int y = MathUtils . max ( <int> , MathUtils . min ( ( int ) g . center . y , m_countY - <int> ) ) ; queue . push ( taskPool . pop ( ) . set ( x , y , x + y * m_countX , g ) ) ; } while ( ! queue . empty ( ) ) { VoronoiDiagramTask front = queue . pop ( ) ; int x = front . m_x ; int y = front . m_y ; int i = front . m_i ; Generator g = front . m_generator ; if ( m_diagram [ i ] = = null ) { m_diagram [ i ] = g ; if ( x > <int> ) { queue . push ( taskPool . pop ( ) . set ( x - <int> , y , i - <int> , g ) ) ; } if ( y > <int> ) { queue . push ( taskPool . pop ( ) . set ( x , y - <int> , i - m_countX , g ) ) ; } if ( x < m_countX - <int> ) { queue . push ( taskPool . pop ( ) . set ( x + <int> , y , i + <int> , g ) ) ; } if ( y < m_countY - <int> ) { queue . push ( taskPool . pop ( ) . set ( x , y + <int> , i + m_countX , g ) ) ; } } taskPool . push ( front ) ; } int maxIteration = m_countX + m_countY ; for ( int iteration = <int> ; iteration < maxIteration ; iteration + + ) { for ( int y = <int> ; y < m_countY ; y + + ) { for ( int x = <int> ; x < m_countX - <int> ; x + + ) { int i = x + y * m_countX ; Generator a = m_diagram [ i ] ; Generator b = m_diagram [ i + <int> ] ; if ( a ! = b ) { queue . push ( taskPool . pop ( ) . set ( x , y , i , b ) ) ; queue . push ( taskPool . pop ( ) . set ( x + <int> , y , i + <int> , a ) ) ; } } } for ( int y = <int> ; y < m_countY - <int> ; y + + ) { for ( int x = <int> ; x < m_countX ; x + + ) { int i = x + y * m_countX ; Generator a = m_diagram [ i ] ; Generator b = m_diagram [ i + m_countX ] ; if ( a ! = b ) { queue . push ( taskPool . pop ( ) . set ( x , y , i , b ) ) ; queue . push ( taskPool . pop ( ) . set ( x , y + <int> , i + m_countX , a ) ) ; } } } boolean updated = false ; while ( ! queue . empty ( ) ) { VoronoiDiagramTask front = queue . pop ( ) ; int x = front . m_x ; int y = front . m_y ; int i = front . m_i ; Generator k = front . m_generator ; Generator a = m_diagram [ i ] ; Generator b = k ; if ( a ! = b ) { float ax = a . center . x - x ; float ay = a . center . y - y ; float bx = b . center . x - x ; float by = b . center . y - y ; float a2 = ax * ax + ay * ay ; float b2 = bx * bx + by * by ; if ( a2 > b2 ) { m_diagram [ i ] = b ; if ( x > <int> ) { queue . push ( taskPool . pop ( ) . set ( x - <int> , y , i - <int> , b ) ) ; } if ( y > <int> ) { queue . push ( taskPool . pop ( ) . set ( x , y - <int> , i - m_countX , b ) ) ; } if ( x < m_countX - <int> ) { queue . push ( taskPool . pop ( ) . set ( x + <int> , y , i + <int> , b ) ) ; } if ( y < m_countY - <int> ) { queue . push ( taskPool . pop ( ) . set ( x , y + <int> , i + m_countX , b ) ) ; } updated = true ; } } taskPool . push ( front ) ; } if ( ! updated ) { break ; } } } } 
