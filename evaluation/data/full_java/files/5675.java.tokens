package org . elasticsearch . common . blobstore . fs ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . common . blobstore . BlobMetaData ; import org . elasticsearch . common . blobstore . BlobPath ; import org . elasticsearch . common . blobstore . support . AbstractBlobContainer ; import org . elasticsearch . common . blobstore . support . PlainBlobMetaData ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . Streams ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardCopyOption ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public class FsBlobContainer extends AbstractBlobContainer { protected final FsBlobStore blobStore ; protected final Path path ; public FsBlobContainer ( FsBlobStore blobStore , BlobPath blobPath , Path path ) { super ( blobPath ) ; this . blobStore = blobStore ; this . path = path ; } @Override public Map < String , BlobMetaData > listBlobs ( ) throws IOException { return listBlobsByPrefix ( null ) ; } @Override public Map < String , BlobMetaData > listBlobsByPrefix ( String blobNamePrefix ) throws IOException { Map < String , BlobMetaData > builder = new HashMap < > ( ) ; blobNamePrefix = blobNamePrefix = = null ? <str> : blobNamePrefix ; try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( path , blobNamePrefix + <str> ) ) { for ( Path file : stream ) { final BasicFileAttributes attrs = Files . readAttributes ( file , BasicFileAttributes . class ) ; if ( attrs . isRegularFile ( ) ) { builder . put ( file . getFileName ( ) . toString ( ) , new PlainBlobMetaData ( file . getFileName ( ) . toString ( ) , attrs . size ( ) ) ) ; } } } return unmodifiableMap ( builder ) ; } @Override public void deleteBlob ( String blobName ) throws IOException { Path blobPath = path . resolve ( blobName ) ; Files . deleteIfExists ( blobPath ) ; } @Override public boolean blobExists ( String blobName ) { return Files . exists ( path . resolve ( blobName ) ) ; } @Override public InputStream readBlob ( String name ) throws IOException { return new BufferedInputStream ( Files . newInputStream ( path . resolve ( name ) ) , blobStore . bufferSizeInBytes ( ) ) ; } @Override public void writeBlob ( String blobName , InputStream inputStream , long blobSize ) throws IOException { final Path file = path . resolve ( blobName ) ; try ( OutputStream outputStream = Files . newOutputStream ( file ) ) { Streams . copy ( inputStream , outputStream , new byte [ blobStore . bufferSizeInBytes ( ) ] ) ; } IOUtils . fsync ( file , false ) ; IOUtils . fsync ( path , true ) ; } @Override public void writeBlob ( String blobName , BytesReference data ) throws IOException { final Path file = path . resolve ( blobName ) ; try ( OutputStream outputStream = Files . newOutputStream ( file ) ) { data . writeTo ( outputStream ) ; } IOUtils . fsync ( file , false ) ; IOUtils . fsync ( path , true ) ; } @Override public void move ( String source , String target ) throws IOException { Path sourcePath = path . resolve ( source ) ; Path targetPath = path . resolve ( target ) ; assert ! Files . exists ( targetPath ) ; Files . move ( sourcePath , targetPath , StandardCopyOption . ATOMIC_MOVE ) ; IOUtils . fsync ( path , true ) ; } } 
