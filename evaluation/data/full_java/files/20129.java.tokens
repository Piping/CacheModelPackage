package io . netty . testsuite . transport . sctp ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . sctp . SctpChannel ; import io . netty . handler . codec . sctp . SctpInboundByteStreamHandler ; import io . netty . handler . codec . sctp . SctpMessageCompletionHandler ; import io . netty . handler . codec . sctp . SctpOutboundByteStreamHandler ; import io . netty . testsuite . util . TestUtils ; import org . junit . Assume ; import org . junit . Test ; import java . io . IOException ; import java . util . Random ; import java . util . concurrent . atomic . AtomicReference ; import static org . junit . Assert . * ; public class SctpEchoTest extends AbstractSctpTest { private static final Random random = new Random ( ) ; static final byte [ ] data = new byte [ <int> ] ; static { random . nextBytes ( data ) ; } @Test public void testSimpleEcho ( ) throws Throwable { Assume . assumeTrue ( TestUtils . isSctpSupported ( ) ) ; run ( ) ; } public void testSimpleEcho ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { testSimpleEcho0 ( sb , cb , false ) ; } @Test public void testSimpleEchoUnordered ( ) throws Throwable { Assume . assumeTrue ( TestUtils . isSctpSupported ( ) ) ; run ( ) ; } public void testSimpleEchoUnordered ( ServerBootstrap sb , Bootstrap cb ) throws Throwable { testSimpleEcho0 ( sb , cb , true ) ; } private static void testSimpleEcho0 ( ServerBootstrap sb , Bootstrap cb , final boolean unordered ) throws Throwable { final EchoHandler sh = new EchoHandler ( ) ; final EchoHandler ch = new EchoHandler ( ) ; sb . childHandler ( new ChannelInitializer < SctpChannel > ( ) { @Override public void initChannel ( SctpChannel c ) throws Exception { c . pipeline ( ) . addLast ( new SctpMessageCompletionHandler ( ) , new SctpInboundByteStreamHandler ( <int> , <int> ) , new SctpOutboundByteStreamHandler ( <int> , <int> , unordered ) , sh ) ; } } ) ; cb . handler ( new ChannelInitializer < SctpChannel > ( ) { @Override public void initChannel ( SctpChannel c ) throws Exception { c . pipeline ( ) . addLast ( new SctpMessageCompletionHandler ( ) , new SctpInboundByteStreamHandler ( <int> , <int> ) , new SctpOutboundByteStreamHandler ( <int> , <int> , unordered ) , ch ) ; } } ) ; Channel sc = sb . bind ( ) . sync ( ) . channel ( ) ; Channel cc = cb . connect ( ) . sync ( ) . channel ( ) ; for ( int i = <int> ; i < data . length ; ) { int length = Math . min ( random . nextInt ( <int> * <int> ) , data . length - i ) ; cc . writeAndFlush ( Unpooled . wrappedBuffer ( data , i , length ) ) ; i + = length ; } while ( ch . counter < data . length ) { if ( sh . exception . get ( ) ! = null ) { break ; } if ( ch . exception . get ( ) ! = null ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } while ( sh . counter < data . length ) { if ( sh . exception . get ( ) ! = null ) { break ; } if ( ch . exception . get ( ) ! = null ) { break ; } try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } sh . channel . close ( ) . sync ( ) ; ch . channel . close ( ) . sync ( ) ; sc . close ( ) . sync ( ) ; if ( sh . exception . get ( ) ! = null & & ! ( sh . exception . get ( ) instanceof IOException ) ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null & & ! ( ch . exception . get ( ) instanceof IOException ) ) { throw ch . exception . get ( ) ; } if ( sh . exception . get ( ) ! = null ) { throw sh . exception . get ( ) ; } if ( ch . exception . get ( ) ! = null ) { throw ch . exception . get ( ) ; } } private static class EchoHandler extends SimpleChannelInboundHandler < ByteBuf > { volatile Channel channel ; final AtomicReference < Throwable > exception = new AtomicReference < Throwable > ( ) ; volatile int counter ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { channel = ctx . channel ( ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , ByteBuf in ) throws Exception { byte [ ] actual = new byte [ in . readableBytes ( ) ] ; in . readBytes ( actual ) ; int lastIdx = counter ; for ( int i = <int> ; i < actual . length ; i + + ) { assertEquals ( data [ i + lastIdx ] , actual [ i ] ) ; } if ( channel . parent ( ) ! = null ) { channel . writeAndFlush ( Unpooled . wrappedBuffer ( actual ) ) ; } counter + = actual . length ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( exception . compareAndSet ( null , cause ) ) { ctx . close ( ) ; } } } } 
