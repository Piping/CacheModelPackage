package io . netty . channel . unix ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import static io . netty . channel . unix . Errors . CONNECTION_RESET_EXCEPTION_READ ; import static io . netty . channel . unix . Errors . CONNECTION_RESET_EXCEPTION_WRITE ; import static io . netty . channel . unix . Errors . CONNECTION_RESET_EXCEPTION_WRITEV ; import static io . netty . channel . unix . Errors . ioResult ; import static io . netty . channel . unix . Errors . newIOException ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public class FileDescriptor { private final int fd ; private volatile boolean open = true ; public FileDescriptor ( int fd ) { if ( fd < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . fd = fd ; } public int intValue ( ) { return fd ; } public void close ( ) throws IOException { open = false ; int res = close ( fd ) ; if ( res < <int> ) { throw newIOException ( <str> , res ) ; } } public boolean isOpen ( ) { return open ; } public final int write ( ByteBuffer buf , int pos , int limit ) throws IOException { int res = write ( fd , buf , pos , limit ) ; if ( res > = <int> ) { return res ; } return ioResult ( <str> , res , CONNECTION_RESET_EXCEPTION_WRITE ) ; } public final int writeAddress ( long address , int pos , int limit ) throws IOException { int res = writeAddress ( fd , address , pos , limit ) ; if ( res > = <int> ) { return res ; } return ioResult ( <str> , res , CONNECTION_RESET_EXCEPTION_WRITE ) ; } public final long writev ( ByteBuffer [ ] buffers , int offset , int length ) throws IOException { long res = writev ( fd , buffers , offset , length ) ; if ( res > = <int> ) { return res ; } return ioResult ( <str> , ( int ) res , CONNECTION_RESET_EXCEPTION_WRITEV ) ; } public final long writevAddresses ( long memoryAddress , int length ) throws IOException { long res = writevAddresses ( fd , memoryAddress , length ) ; if ( res > = <int> ) { return res ; } return ioResult ( <str> , ( int ) res , CONNECTION_RESET_EXCEPTION_WRITEV ) ; } public final int read ( ByteBuffer buf , int pos , int limit ) throws IOException { int res = read ( fd , buf , pos , limit ) ; if ( res > <int> ) { return res ; } if ( res = = <int> ) { return - <int> ; } return ioResult ( <str> , res , CONNECTION_RESET_EXCEPTION_READ ) ; } public final int readAddress ( long address , int pos , int limit ) throws IOException { int res = readAddress ( fd , address , pos , limit ) ; if ( res > <int> ) { return res ; } if ( res = = <int> ) { return - <int> ; } return ioResult ( <str> , res , CONNECTION_RESET_EXCEPTION_READ ) ; } @Override public String toString ( ) { return <str> + <str> + fd + <str> ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( ! ( o instanceof FileDescriptor ) ) { return false ; } return fd = = ( ( FileDescriptor ) o ) . fd ; } @Override public int hashCode ( ) { return fd ; } public static FileDescriptor from ( String path ) throws IOException { checkNotNull ( path , <str> ) ; int res = open ( path ) ; if ( res < <int> ) { throw newIOException ( <str> , res ) ; } return new FileDescriptor ( res ) ; } public static FileDescriptor from ( File file ) throws IOException { return from ( checkNotNull ( file , <str> ) . getPath ( ) ) ; } public static FileDescriptor [ ] pipe ( ) throws IOException { long res = newPipe ( ) ; if ( res < <int> ) { throw newIOException ( <str> , ( int ) res ) ; } return new FileDescriptor [ ] { new FileDescriptor ( ( int ) ( res > > > <int> ) ) , new FileDescriptor ( ( int ) res ) } ; } private static native int open ( String path ) ; private static native int close ( int fd ) ; private static native int write ( int fd , ByteBuffer buf , int pos , int limit ) ; private static native int writeAddress ( int fd , long address , int pos , int limit ) ; private static native long writev ( int fd , ByteBuffer [ ] buffers , int offset , int length ) ; private static native long writevAddresses ( int fd , long memoryAddress , int length ) ; private static native int read ( int fd , ByteBuffer buf , int pos , int limit ) ; private static native int readAddress ( int fd , long address , int pos , int limit ) ; private static native long newPipe ( ) ; } 
