package org . apache . cassandra . hints ; import java . io . File ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; import java . nio . file . Files ; import java . util . Iterator ; import java . util . UUID ; import java . util . concurrent . TimeUnit ; import java . util . zip . CRC32 ; import com . google . common . collect . Iterables ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Mutation ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . FBUtilities ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . assertNotNull ; import static junit . framework . Assert . assertTrue ; import static org . apache . cassandra . Util . dk ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; public class HintsWriteThenReadTest { private static final String KEYSPACE = <str> ; private static final String TABLE = <str> ; private static final int HINTS_COUNT = <int> ; @Test public void testWriteReadCycle ( ) throws IOException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE , TABLE ) ) ; HintsDescriptor descriptor = new HintsDescriptor ( UUID . randomUUID ( ) , System . currentTimeMillis ( ) ) ; File directory = Files . createTempDirectory ( null ) . toFile ( ) ; try { testWriteReadCycle ( directory , descriptor ) ; } finally { directory . deleteOnExit ( ) ; } } private void testWriteReadCycle ( File directory , HintsDescriptor descriptor ) throws IOException { writeHints ( directory , descriptor ) ; verifyChecksum ( directory , descriptor ) ; verifyHints ( directory , descriptor ) ; } private void writeHints ( File directory , HintsDescriptor descriptor ) throws IOException { try ( HintsWriter writer = HintsWriter . create ( directory , descriptor ) ) { write ( writer , descriptor . timestamp ) ; } } private static void verifyChecksum ( File directory , HintsDescriptor descriptor ) throws IOException { File hintsFile = new File ( directory , descriptor . fileName ( ) ) ; File checksumFile = new File ( directory , descriptor . checksumFileName ( ) ) ; assertTrue ( checksumFile . exists ( ) ) ; String actualChecksum = Integer . toHexString ( calculateChecksum ( hintsFile ) ) ; String expectedChecksum = Files . readAllLines ( checksumFile . toPath ( ) ) . iterator ( ) . next ( ) ; assertEquals ( expectedChecksum , actualChecksum ) ; } private void verifyHints ( File directory , HintsDescriptor descriptor ) { long baseTimestamp = descriptor . timestamp ; int index = <int> ; try ( HintsReader reader = HintsReader . open ( new File ( directory , descriptor . fileName ( ) ) ) ) { for ( HintsReader . Page page : reader ) { Iterator < Hint > hints = page . hintsIterator ( ) ; while ( hints . hasNext ( ) ) { Hint hint = hints . next ( ) ; long timestamp = baseTimestamp + index ; Mutation mutation = hint . mutation ; assertEquals ( timestamp , hint . creationTime ) ; assertEquals ( dk ( bytes ( index ) ) , mutation . key ( ) ) ; Row row = mutation . getPartitionUpdates ( ) . iterator ( ) . next ( ) . iterator ( ) . next ( ) ; assertEquals ( <int> , Iterables . size ( row . cells ( ) ) ) ; assertEquals ( bytes ( index ) , row . clustering ( ) . get ( <int> ) ) ; Cell cell = row . cells ( ) . iterator ( ) . next ( ) ; assertNotNull ( cell ) ; assertEquals ( bytes ( index ) , cell . value ( ) ) ; assertEquals ( timestamp * <int> , cell . timestamp ( ) ) ; index + + ; } } } assertEquals ( index , HINTS_COUNT ) ; } private void write ( HintsWriter writer , long timestamp ) throws IOException { ByteBuffer buffer = ByteBuffer . allocateDirect ( <int> * <int> ) ; try ( HintsWriter . Session session = writer . newSession ( buffer ) ) { write ( session , timestamp ) ; } FileUtils . clean ( buffer ) ; } private void write ( HintsWriter . Session session , long timestamp ) throws IOException { for ( int i = <int> ; i < HINTS_COUNT ; i + + ) session . append ( createHint ( i , timestamp ) ) ; } private static Hint createHint ( int idx , long baseTimestamp ) { long timestamp = baseTimestamp + idx ; return Hint . create ( createMutation ( idx , TimeUnit . MILLISECONDS . toMicros ( timestamp ) ) , timestamp ) ; } private static Mutation createMutation ( int index , long timestamp ) { CFMetaData table = Schema . instance . getCFMetaData ( KEYSPACE , TABLE ) ; return new RowUpdateBuilder ( table , timestamp , bytes ( index ) ) . clustering ( bytes ( index ) ) . add ( <str> , bytes ( index ) ) . build ( ) ; } private static int calculateChecksum ( File file ) throws IOException { CRC32 crc = new CRC32 ( ) ; byte [ ] buffer = new byte [ FBUtilities . MAX_UNSIGNED_SHORT ] ; try ( InputStream in = Files . newInputStream ( file . toPath ( ) ) ) { int bytesRead ; while ( ( bytesRead = in . read ( buffer ) ) ! = - <int> ) crc . update ( buffer , <int> , bytesRead ) ; } return ( int ) crc . getValue ( ) ; } } 
