package org . apache . cassandra . dht ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Random ; import java . util . Set ; import com . google . common . base . Joiner ; import org . apache . commons . lang3 . StringUtils ; import org . junit . Test ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . dht . ByteOrderedPartitioner . BytesToken ; import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; import static java . util . Arrays . asList ; import static org . apache . cassandra . Util . range ; import static org . junit . Assert . * ; public class RangeTest { @Test public void testContains ( ) { Range < Token > left = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assert ! left . contains ( new BigIntegerToken ( <str> ) ) ; assert left . contains ( new BigIntegerToken ( <str> ) ) ; assert left . contains ( new BigIntegerToken ( <str> ) ) ; assert ! left . contains ( new BigIntegerToken ( <str> ) ) ; } @Test public void testContainsWrapping ( ) { Range < Token > range = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assert range . contains ( new BigIntegerToken ( <str> ) ) ; assert range . contains ( new BigIntegerToken ( <str> ) ) ; assert range . contains ( new BigIntegerToken ( <str> ) ) ; assert range . contains ( new BigIntegerToken ( <str> ) ) ; range = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assert range . contains ( new BigIntegerToken ( <str> ) ) ; assert ! range . contains ( new BigIntegerToken ( <str> ) ) ; assert ! range . contains ( new BigIntegerToken ( <str> ) ) ; assert range . contains ( new BigIntegerToken ( <str> ) ) ; } @Test public void testContainsRange ( ) { Range < Token > one = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > two = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > thr = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > fou = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assert one . contains ( two ) ; assert one . contains ( thr ) ; assert ! one . contains ( fou ) ; assert ! two . contains ( one ) ; assert ! two . contains ( thr ) ; assert ! two . contains ( fou ) ; assert ! thr . contains ( one ) ; assert ! thr . contains ( two ) ; assert ! thr . contains ( fou ) ; assert ! fou . contains ( one ) ; assert ! fou . contains ( two ) ; assert ! fou . contains ( thr ) ; } @Test public void testContainsRangeWrapping ( ) { Range < Token > one = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > two = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > thr = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > fou = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > fiv = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assert ! one . contains ( two ) ; assert one . contains ( thr ) ; assert ! one . contains ( fou ) ; assert two . contains ( one ) ; assert two . contains ( thr ) ; assert ! two . contains ( fou ) ; assert ! thr . contains ( one ) ; assert ! thr . contains ( two ) ; assert ! thr . contains ( fou ) ; assert ! fou . contains ( one ) ; assert ! fou . contains ( two ) ; assert ! fou . contains ( thr ) ; assert fiv . contains ( one ) ; assert fiv . contains ( two ) ; assert fiv . contains ( thr ) ; assert fiv . contains ( fou ) ; } @Test public void testContainsRangeOneWrapping ( ) { Range < Token > wrap1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wrap2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap3 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assert wrap1 . contains ( nowrap1 ) ; assert wrap1 . contains ( nowrap2 ) ; assert wrap1 . contains ( nowrap3 ) ; assert wrap2 . contains ( nowrap1 ) ; assert ! wrap2 . contains ( nowrap2 ) ; assert wrap2 . contains ( nowrap3 ) ; } @Test public void testIntersects ( ) { Range < Token > all = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > one = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > two = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > not = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assert all . intersects ( one ) ; assert all . intersects ( two ) ; assert one . intersects ( two ) ; assert two . intersects ( one ) ; assert ! one . intersects ( not ) ; assert ! not . intersects ( one ) ; assert ! two . intersects ( not ) ; assert ! not . intersects ( two ) ; } @Test public void testIntersectsWrapping ( ) { Range < Token > onewrap = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > onecomplement = new Range < Token > ( onewrap . right , onewrap . left ) ; Range < Token > onestartswith = new Range < Token > ( onewrap . left , new BigIntegerToken ( <str> ) ) ; Range < Token > oneendswith = new Range < Token > ( new BigIntegerToken ( <str> ) , onewrap . right ) ; Range < Token > twowrap = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > not = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assert ! onewrap . intersects ( onecomplement ) ; assert onewrap . intersects ( onestartswith ) ; assert onewrap . intersects ( oneendswith ) ; assert onewrap . intersects ( twowrap ) ; assert twowrap . intersects ( onewrap ) ; assert ! onewrap . intersects ( not ) ; assert ! not . intersects ( onewrap ) ; assert twowrap . intersects ( not ) ; assert not . intersects ( twowrap ) ; } @SafeVarargs static < T extends RingPosition < T > > void assertIntersection ( Range < T > one , Range < T > two , Range < T > . . . ranges ) { Set < Range < T > > correct = Range . rangeSet ( ranges ) ; Set < Range < T > > result1 = one . intersectionWith ( two ) ; assert result1 . equals ( correct ) : String . format ( <str> , StringUtils . join ( result1 , <str> ) , StringUtils . join ( correct , <str> ) ) ; Set < Range < T > > result2 = two . intersectionWith ( one ) ; assert result2 . equals ( correct ) : String . format ( <str> , StringUtils . join ( result2 , <str> ) , StringUtils . join ( correct , <str> ) ) ; } private void assertNoIntersection ( Range < Token > wraps1 , Range < Token > nowrap3 ) { assertIntersection ( wraps1 , nowrap3 ) ; } @Test public void testIntersectionWithAll ( ) { Range < Token > all0 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > all10 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > all100 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > all1000 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assertIntersection ( all0 , wraps , wraps ) ; assertIntersection ( all10 , wraps , wraps ) ; assertIntersection ( all100 , wraps , wraps ) ; assertIntersection ( all1000 , wraps , wraps ) ; } @Test public void testIntersectionContains ( ) { Range < Token > wraps1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps3 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap3 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assertIntersection ( wraps1 , wraps2 , wraps1 ) ; assertIntersection ( wraps3 , wraps2 , wraps3 ) ; assertIntersection ( wraps1 , nowrap1 , nowrap1 ) ; assertIntersection ( wraps1 , nowrap2 , nowrap2 ) ; assertIntersection ( nowrap2 , nowrap3 , nowrap3 ) ; assertIntersection ( wraps1 , wraps1 , wraps1 ) ; assertIntersection ( nowrap1 , nowrap1 , nowrap1 ) ; assertIntersection ( nowrap2 , nowrap2 , nowrap2 ) ; assertIntersection ( wraps3 , wraps3 , wraps3 ) ; } @Test public void testNoIntersection ( ) { Range < Token > wraps1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap3 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assertNoIntersection ( wraps1 , nowrap3 ) ; assertNoIntersection ( wraps2 , nowrap1 ) ; assertNoIntersection ( nowrap1 , nowrap2 ) ; } @Test public void testIntersectionOneWraps ( ) { Range < Token > wraps1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > nowrap2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assertIntersection ( wraps1 , nowrap1 , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ) ; assertIntersection ( wraps2 , nowrap1 , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ) ; assertIntersection ( wraps1 , nowrap2 , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ) ; } @Test public void testIntersectionTwoWraps ( ) { Range < Token > wraps1 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps2 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps3 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps4 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps5 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; Range < Token > wraps6 = new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ; assertIntersection ( wraps1 , wraps2 , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ) ; assertIntersection ( wraps1 , wraps3 , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ) ; assertIntersection ( wraps1 , wraps4 , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ) ; assertIntersection ( wraps1 , wraps5 , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ) ; assertIntersection ( wraps1 , wraps6 , new Range < Token > ( new BigIntegerToken ( <str> ) , new BigIntegerToken ( <str> ) ) ) ; } @Test public void testByteTokensCompare ( ) { Token t1 = new BytesToken ( ByteBuffer . wrap ( new byte [ ] { <int> , <int> , <int> } ) ) ; Token t2 = new BytesToken ( ByteBuffer . wrap ( new byte [ ] { <int> , <int> , <int> } ) ) ; Token t3 = new BytesToken ( ByteBuffer . wrap ( new byte [ ] { <int> , <int> , <int> , <int> } ) ) ; assert t1 . compareTo ( t2 ) = = <int> ; assert t1 . compareTo ( t3 ) < <int> ; assert t3 . compareTo ( t1 ) > <int> ; assert t1 . compareTo ( t1 ) = = <int> ; Token t4 = new BytesToken ( new byte [ ] { <int> , <int> , <int> } ) ; Token t5 = new BytesToken ( new byte [ ] { <int> , <int> , <int> , <int> } ) ; assert t4 . compareTo ( t5 ) < <int> ; assert t5 . compareTo ( t4 ) > <int> ; assert t1 . compareTo ( t4 ) = = <int> ; } private Range < Token > makeRange ( String token1 , String token2 ) { return new Range < Token > ( new BigIntegerToken ( token1 ) , new BigIntegerToken ( token2 ) ) ; } private Set < Range < Token > > makeRanges ( String [ ] [ ] tokenPairs ) { Set < Range < Token > > ranges = new HashSet < Range < Token > > ( ) ; for ( int i = <int> ; i < tokenPairs . length ; + + i ) ranges . add ( makeRange ( tokenPairs [ i ] [ <int> ] , tokenPairs [ i ] [ <int> ] ) ) ; return ranges ; } private void checkDifference ( Range < Token > oldRange , String [ ] [ ] newTokens , String [ ] [ ] expected ) { Set < Range < Token > > ranges = makeRanges ( newTokens ) ; for ( Range < Token > newRange : ranges ) { Set < Range < Token > > diff = oldRange . differenceToFetch ( newRange ) ; assert diff . equals ( makeRanges ( expected ) ) : <str> + <str> + oldRange . toString ( ) + <str> + <str> + newRange . toString ( ) + <str> + <str> + diff . toString ( ) + <str> + makeRanges ( expected ) + <str> ; } } @Test public void testDifferenceToFetchNoWrap ( ) { Range < Token > oldRange = makeRange ( <str> , <str> ) ; String [ ] [ ] newTokens1 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected1 = { } ; checkDifference ( oldRange , newTokens1 , expected1 ) ; String [ ] [ ] newTokens2 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected2 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens2 , expected2 ) ; String [ ] [ ] newTokens3 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected3 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens3 , expected3 ) ; String [ ] [ ] newTokens4 = { { <str> , <str> } } ; String [ ] [ ] expected4 = { { <str> , <str> } , { <str> , <str> } } ; checkDifference ( oldRange , newTokens4 , expected4 ) ; } @Test public void testDifferenceToFetchBothWrap ( ) { Range < Token > oldRange = makeRange ( <str> , <str> ) ; String [ ] [ ] newTokens1 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected1 = { } ; checkDifference ( oldRange , newTokens1 , expected1 ) ; String [ ] [ ] newTokens2 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected2 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens2 , expected2 ) ; String [ ] [ ] newTokens3 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected3 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens3 , expected3 ) ; String [ ] [ ] newTokens4 = { { <str> , <str> } } ; String [ ] [ ] expected4 = { { <str> , <str> } , { <str> , <str> } } ; checkDifference ( oldRange , newTokens4 , expected4 ) ; } @Test public void testDifferenceToFetchOldWraps ( ) { Range < Token > oldRange = makeRange ( <str> , <str> ) ; String [ ] [ ] newTokens1 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected1 = { } ; checkDifference ( oldRange , newTokens1 , expected1 ) ; String [ ] [ ] newTokens2 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected2 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens2 , expected2 ) ; String [ ] [ ] newTokens3 = { { <str> , <str> } } ; String [ ] [ ] expected3 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens3 , expected3 ) ; String [ ] [ ] newTokens4 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected4 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens4 , expected4 ) ; String [ ] [ ] newTokens5 = { { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected5 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens5 , expected5 ) ; } @Test public void testDifferenceToFetchNewWraps ( ) { Range < Token > oldRange = makeRange ( <str> , <str> ) ; String [ ] [ ] newTokens1 = { { <str> , <str> } , { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected1 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens1 , expected1 ) ; String [ ] [ ] newTokens2 = { { <str> , <str> } } ; String [ ] [ ] expected2 = { { <str> , <str> } , { <str> , <str> } } ; checkDifference ( oldRange , newTokens2 , expected2 ) ; oldRange = makeRange ( <str> , <str> ) ; String [ ] [ ] newTokens3 = { { <str> , <str> } } ; String [ ] [ ] expected3 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens3 , expected3 ) ; String [ ] [ ] newTokens4 = { { <str> , <str> } } ; String [ ] [ ] expected4 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens4 , expected4 ) ; String [ ] [ ] newTokens5 = { { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected5 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens5 , expected5 ) ; String [ ] [ ] newTokens6 = { { <str> , <str> } , { <str> , <str> } } ; String [ ] [ ] expected6 = { { <str> , <str> } } ; checkDifference ( oldRange , newTokens6 , expected6 ) ; } private < T extends RingPosition < T > > void assertNormalize ( List < Range < T > > input , List < Range < T > > expected ) { List < Range < T > > result = Range . normalize ( input ) ; assert result . equals ( expected ) : <str> + expected + <str> + result ; } @Test public void testNormalizeNoop ( ) { List < Range < PartitionPosition > > l ; l = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) ) ; assertNormalize ( l , l ) ; } @Test public void testNormalizeSimpleOverlap ( ) { List < Range < PartitionPosition > > input , expected ; input = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) ) ; expected = asList ( range ( <str> , <str> ) ) ; assertNormalize ( input , expected ) ; input = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) ) ; expected = asList ( range ( <str> , <str> ) ) ; assertNormalize ( input , expected ) ; } @Test public void testNormalizeSort ( ) { List < Range < PartitionPosition > > input , expected ; input = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) ) ; expected = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) ) ; assertNormalize ( input , expected ) ; } @Test public void testNormalizeUnwrap ( ) { List < Range < PartitionPosition > > input , expected ; input = asList ( range ( <str> , <str> ) ) ; expected = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) ) ; assertNormalize ( input , expected ) ; } @Test public void testNormalizeComplex ( ) { List < Range < PartitionPosition > > input , expected ; input = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) , range ( <str> , <str> ) ) ; expected = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) , range ( <str> , <str> ) ) ; assertNormalize ( input , expected ) ; input = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) ) ; expected = asList ( range ( <str> , <str> ) ) ; assertNormalize ( input , expected ) ; input = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) , range ( <str> , <str> ) , range ( <str> , <str> ) ) ; expected = asList ( range ( <str> , <str> ) ) ; assertNormalize ( input , expected ) ; input = asList ( range ( <str> , <str> ) , range ( <str> , <str> ) , range ( <str> , <str> ) , range ( <str> , <str> ) ) ; expected = asList ( range ( <str> , <str> ) ) ; assertNormalize ( input , expected ) ; } @Test public void testRandomOrderedRangeContainmentChecker ( ) { Random r = new Random ( ) ; for ( int j = <int> ; j < <int> ; j + + ) { int numTokens = r . nextInt ( <int> ) + <int> ; List < Range < Token > > ranges = new ArrayList < > ( numTokens ) ; List < Token > tokens = new ArrayList < > ( <int> * numTokens ) ; for ( int i = <int> ; i < <int> * numTokens ; i + + ) tokens . add ( t ( r . nextLong ( ) ) ) ; Collections . sort ( tokens ) ; for ( int i = <int> ; i < tokens . size ( ) ; i + + ) { ranges . add ( new Range < > ( tokens . get ( i ) , tokens . get ( i + <int> ) ) ) ; i + + ; } List < Token > tokensToTest = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) tokensToTest . add ( t ( r . nextLong ( ) ) ) ; tokensToTest . add ( t ( Long . MAX_VALUE ) ) ; tokensToTest . add ( t ( Long . MIN_VALUE ) ) ; tokensToTest . add ( t ( Long . MAX_VALUE - <int> ) ) ; tokensToTest . add ( t ( Long . MIN_VALUE + <int> ) ) ; Collections . sort ( tokensToTest ) ; Range . OrderedRangeContainmentChecker checker = new Range . OrderedRangeContainmentChecker ( ranges ) ; for ( Token t : tokensToTest ) { if ( checker . contains ( t ) ! = Range . isInRanges ( t , ranges ) ) fail ( String . format ( <str> , Joiner . on ( <str> ) . join ( ranges ) , t ) ) ; } } } @Test public void testBoundariesORCC ( ) { List < Range < Token > > ranges = asList ( r ( Long . MIN_VALUE , Long . MIN_VALUE + <int> ) , r ( Long . MAX_VALUE - <int> , Long . MAX_VALUE ) ) ; Range . OrderedRangeContainmentChecker checker = new Range . OrderedRangeContainmentChecker ( ranges ) ; assertFalse ( checker . contains ( t ( Long . MIN_VALUE ) ) ) ; assertTrue ( checker . contains ( t ( Long . MIN_VALUE + <int> ) ) ) ; assertFalse ( checker . contains ( t ( <int> ) ) ) ; assertFalse ( checker . contains ( t ( Long . MAX_VALUE - <int> ) ) ) ; assertTrue ( checker . contains ( t ( Long . MAX_VALUE ) ) ) ; } private static Range < Token > r ( long left , long right ) { return new Range < > ( t ( left ) , t ( right ) ) ; } private static Token t ( long t ) { return new Murmur3Partitioner . LongToken ( t ) ; } } 
