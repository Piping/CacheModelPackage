package org . elasticsearch . action . admin . cluster . snapshots . status ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . index . snapshots . IndexShardSnapshotStatus ; import java . io . IOException ; public class SnapshotStats implements Streamable , ToXContent { private long startTime ; private long time ; private int numberOfFiles ; private int processedFiles ; private long totalSize ; private long processedSize ; SnapshotStats ( ) { } SnapshotStats ( IndexShardSnapshotStatus indexShardStatus ) { startTime = indexShardStatus . startTime ( ) ; time = indexShardStatus . time ( ) ; numberOfFiles = indexShardStatus . numberOfFiles ( ) ; processedFiles = indexShardStatus . processedFiles ( ) ; totalSize = indexShardStatus . totalSize ( ) ; processedSize = indexShardStatus . processedSize ( ) ; } public long getStartTime ( ) { return startTime ; } public long getTime ( ) { return time ; } public int getNumberOfFiles ( ) { return numberOfFiles ; } public int getProcessedFiles ( ) { return processedFiles ; } public long getTotalSize ( ) { return totalSize ; } public long getProcessedSize ( ) { return processedSize ; } public static SnapshotStats readSnapshotStats ( StreamInput in ) throws IOException { SnapshotStats stats = new SnapshotStats ( ) ; stats . readFrom ( in ) ; return stats ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVLong ( startTime ) ; out . writeVLong ( time ) ; out . writeVInt ( numberOfFiles ) ; out . writeVInt ( processedFiles ) ; out . writeVLong ( totalSize ) ; out . writeVLong ( processedSize ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { startTime = in . readVLong ( ) ; time = in . readVLong ( ) ; numberOfFiles = in . readVInt ( ) ; processedFiles = in . readVInt ( ) ; totalSize = in . readVLong ( ) ; processedSize = in . readVLong ( ) ; } static final class Fields { static final XContentBuilderString STATS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NUMBER_OF_FILES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PROCESSED_FILES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_SIZE_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_SIZE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PROCESSED_SIZE_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PROCESSED_SIZE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TIME = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , ToXContent . Params params ) throws IOException { builder . startObject ( Fields . STATS ) ; builder . field ( Fields . NUMBER_OF_FILES , getNumberOfFiles ( ) ) ; builder . field ( Fields . PROCESSED_FILES , getProcessedFiles ( ) ) ; builder . byteSizeField ( Fields . TOTAL_SIZE_IN_BYTES , Fields . TOTAL_SIZE , getTotalSize ( ) ) ; builder . byteSizeField ( Fields . PROCESSED_SIZE_IN_BYTES , Fields . PROCESSED_SIZE , getProcessedSize ( ) ) ; builder . field ( Fields . START_TIME_IN_MILLIS , getStartTime ( ) ) ; builder . timeValueField ( Fields . TIME_IN_MILLIS , Fields . TIME , getTime ( ) ) ; builder . endObject ( ) ; return builder ; } void add ( SnapshotStats stats ) { numberOfFiles + = stats . numberOfFiles ; processedFiles + = stats . processedFiles ; totalSize + = stats . totalSize ; processedSize + = stats . processedSize ; if ( startTime = = <int> ) { startTime = stats . startTime ; time = stats . time ; } else { long endTime = Math . max ( startTime + time , stats . startTime + stats . time ) ; startTime = Math . min ( startTime , stats . startTime ) ; time = endTime - startTime ; } } } 
