package io . netty . example . memcache . binary ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelDuplexHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . memcache . binary . BinaryMemcacheOpcodes ; import io . netty . handler . codec . memcache . binary . BinaryMemcacheRequest ; import io . netty . handler . codec . memcache . binary . DefaultBinaryMemcacheRequest ; import io . netty . handler . codec . memcache . binary . DefaultFullBinaryMemcacheRequest ; import io . netty . handler . codec . memcache . binary . FullBinaryMemcacheResponse ; import io . netty . util . CharsetUtil ; public class MemcacheClientHandler extends ChannelDuplexHandler { @Override public void write ( ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) { String command = ( String ) msg ; if ( command . startsWith ( <str> ) ) { String key = command . substring ( <str> . length ( ) ) ; BinaryMemcacheRequest req = new DefaultBinaryMemcacheRequest ( key ) ; req . setOpcode ( BinaryMemcacheOpcodes . GET ) ; req . setKeyLength ( ( short ) key . length ( ) ) ; req . setTotalBodyLength ( key . length ( ) ) ; ctx . write ( req , promise ) ; } else if ( command . startsWith ( <str> ) ) { String [ ] parts = command . split ( <str> , <int> ) ; if ( parts . length < <int> ) { throw new IllegalArgumentException ( <str> + command ) ; } String key = parts [ <int> ] ; String value = parts [ <int> ] ; ByteBuf content = Unpooled . wrappedBuffer ( value . getBytes ( CharsetUtil . UTF_8 ) ) ; ByteBuf extras = ctx . alloc ( ) . buffer ( <int> ) ; extras . writeZero ( <int> ) ; BinaryMemcacheRequest req = new DefaultFullBinaryMemcacheRequest ( key , extras , content ) ; req . setOpcode ( BinaryMemcacheOpcodes . SET ) ; req . setKeyLength ( ( short ) key . length ( ) ) ; req . setExtrasLength ( ( byte ) <int> ) ; req . setTotalBodyLength ( key . length ( ) + <int> + value . length ( ) ) ; ctx . write ( req , promise ) ; } else { throw new IllegalStateException ( <str> + msg ) ; } } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) { FullBinaryMemcacheResponse res = ( FullBinaryMemcacheResponse ) msg ; System . out . println ( res . content ( ) . toString ( CharsetUtil . UTF_8 ) ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { cause . printStackTrace ( ) ; ctx . close ( ) ; } } 
