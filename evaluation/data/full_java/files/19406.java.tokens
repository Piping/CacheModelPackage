package io . netty . handler . codec . http2 ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerAdapter ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultEventLoopGroup ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . local . LocalAddress ; import io . netty . channel . local . LocalChannel ; import io . netty . channel . local . LocalServerChannel ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpMessage ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpObject ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http2 . Http2TestUtil . FrameAdapter ; import io . netty . handler . codec . http2 . Http2TestUtil . Http2Runnable ; import io . netty . util . AsciiString ; import io . netty . util . CharsetUtil ; import io . netty . util . concurrent . Future ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mockito . ArgumentCaptor ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import static io . netty . handler . codec . http2 . Http2CodecUtil . getEmbeddedHttp2Exception ; import static io . netty . handler . codec . http2 . Http2Exception . isStreamError ; import static io . netty . handler . codec . http2 . Http2TestUtil . of ; import static io . netty . handler . codec . http2 . Http2TestUtil . runInChannel ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; public class InboundHttp2ToHttpAdapterTest { private List < FullHttpMessage > capturedRequests ; private List < FullHttpMessage > capturedResponses ; @Mock private HttpResponseListener serverListener ; @Mock private HttpResponseListener clientListener ; @Mock private HttpSettingsListener settingsListener ; private Http2FrameWriter frameWriter ; private ServerBootstrap sb ; private Bootstrap cb ; private Channel serverChannel ; private Channel serverConnectedChannel ; private Channel clientChannel ; private CountDownLatch serverLatch ; private CountDownLatch clientLatch ; private CountDownLatch settingsLatch ; private int maxContentLength ; private HttpResponseDelegator serverDelegator ; private HttpResponseDelegator clientDelegator ; private HttpSettingsDelegator settingsDelegator ; private Http2Exception serverException ; @Before public void setup ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; } @After public void teardown ( ) throws Exception { cleanupCapturedRequests ( ) ; cleanupCapturedResponses ( ) ; if ( clientChannel ! = null ) { clientChannel . close ( ) . sync ( ) ; clientChannel = null ; } if ( serverChannel ! = null ) { serverChannel . close ( ) . sync ( ) ; serverChannel = null ; } Future < ? > serverGroup = sb . group ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; Future < ? > serverChildGroup = sb . childGroup ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; Future < ? > clientGroup = cb . group ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; serverGroup . sync ( ) ; serverChildGroup . sync ( ) ; clientGroup . sync ( ) ; clientDelegator = null ; serverDelegator = null ; serverConnectedChannel = null ; } @Test public void clientRequestSingleHeaderNoDataFrames ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; } } @Test public void clientRequestSingleHeaderCookieSplitIntoMultipleEntries ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; httpHeaders . set ( HttpHeaderNames . COOKIE , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . add ( HttpHeaderNames . COOKIE , <str> ) . add ( HttpHeaderNames . COOKIE , <str> ) . add ( HttpHeaderNames . COOKIE , <str> ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; } } @Test public void clientRequestSingleHeaderCookieSplitIntoMultipleEntries2 ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; httpHeaders . set ( HttpHeaderNames . COOKIE , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . add ( HttpHeaderNames . COOKIE , <str> ) . add ( HttpHeaderNames . COOKIE , <str> ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; } } @Test public void clientRequestSingleHeaderNonAsciiShouldThrow ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> . getBytes ( CharsetUtil . UTF_8 ) ) , new AsciiString ( <str> . getBytes ( CharsetUtil . UTF_8 ) ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; assertTrue ( isStreamError ( serverException ) ) ; } @Test public void clientRequestOneDataFrame ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final String text = <str> ; final ByteBuf content = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , content , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . duplicate ( ) . retain ( ) , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; } } @Test public void clientRequestMultipleDataFrames ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final String text = <str> ; final ByteBuf content = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , content , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; final int midPoint = text . length ( ) / <int> ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . slice ( <int> , midPoint ) . retain ( ) , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . slice ( midPoint , text . length ( ) - midPoint ) . retain ( ) , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; } } @Test public void clientRequestMultipleEmptyDataFrames ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final String text = <str> ; final ByteBuf content = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , content , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . retain ( ) , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . retain ( ) , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . retain ( ) , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; } } @Test public void clientRequestMultipleHeaders ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final String text = <str> ; final ByteBuf content = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , content , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; HttpHeaders trailingHeaders = request . trailingHeaders ( ) ; trailingHeaders . set ( of ( <str> ) , of ( <str> ) ) ; trailingHeaders . set ( of ( <str> ) , of ( <str> ) ) ; trailingHeaders . add ( of ( <str> ) , of ( <str> ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; final Http2Headers http2Headers2 = new DefaultHttp2Headers ( ) . set ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . set ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers2 , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . retain ( ) , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; } } @Test public void clientRequestTrailingHeaders ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final String text = <str> ; final ByteBuf content = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , content , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; HttpHeaders trailingHeaders = request . trailingHeaders ( ) ; trailingHeaders . set ( of ( <str> ) , of ( <str> ) ) ; trailingHeaders . set ( of ( <str> ) , of ( <str> ) ) ; trailingHeaders . add ( of ( <str> ) , of ( <str> ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; final Http2Headers http2Headers2 = new DefaultHttp2Headers ( ) . set ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . set ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . duplicate ( ) . retain ( ) , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers2 , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; } } @Test public void clientRequestStreamDependencyInHttpMessageFlow ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final String text = <str> ; final ByteBuf content = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final String text2 = <str> ; final ByteBuf content2 = Unpooled . copiedBuffer ( text2 . getBytes ( ) ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> , content , true ) ; final FullHttpMessage request2 = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> , content2 , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; HttpHeaders httpHeaders2 = request2 . headers ( ) ; httpHeaders2 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders2 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_DEPENDENCY_ID . text ( ) , <int> ) ; httpHeaders2 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_WEIGHT . text ( ) , <int> ) ; httpHeaders2 . setInt ( HttpHeaderNames . CONTENT_LENGTH , text2 . length ( ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; final Http2Headers http2Headers2 = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers2 , <int> , false , newPromiseClient ( ) ) ; frameWriter . writePriority ( ctxClient ( ) , <int> , <int> , ( short ) <int> , true , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . duplicate ( ) . retain ( ) , <int> , true , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content2 . duplicate ( ) . retain ( ) , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > httpObjectCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener , times ( <int> ) ) . messageReceived ( httpObjectCaptor . capture ( ) ) ; capturedRequests = httpObjectCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; assertEquals ( request2 , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; request2 . release ( ) ; } } @Test public void clientRequestStreamDependencyOutsideHttpMessageFlow ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final String text = <str> ; final ByteBuf content = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final String text2 = <str> ; final ByteBuf content2 = Unpooled . copiedBuffer ( text2 . getBytes ( ) ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> , content , true ) ; final FullHttpMessage request2 = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> , content2 , true ) ; final FullHttpMessage request3 = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpConversionUtil . OUT_OF_MESSAGE_SEQUENCE_METHOD , HttpConversionUtil . OUT_OF_MESSAGE_SEQUENCE_PATH , true ) ; try { HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; HttpHeaders httpHeaders2 = request2 . headers ( ) ; httpHeaders2 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders2 . setInt ( HttpHeaderNames . CONTENT_LENGTH , text2 . length ( ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; final Http2Headers http2Headers2 = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; HttpHeaders httpHeaders3 = request3 . headers ( ) ; httpHeaders3 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders3 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_DEPENDENCY_ID . text ( ) , <int> ) ; httpHeaders3 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_WEIGHT . text ( ) , <int> ) ; httpHeaders3 . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers2 , <int> , false , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content . duplicate ( ) . retain ( ) , <int> , true , newPromiseClient ( ) ) ; frameWriter . writeData ( ctxClient ( ) , <int> , content2 . duplicate ( ) . retain ( ) , <int> , true , newPromiseClient ( ) ) ; frameWriter . writePriority ( ctxClient ( ) , <int> , <int> , ( short ) <int> , false , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > httpObjectCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener , times ( <int> ) ) . messageReceived ( httpObjectCaptor . capture ( ) ) ; capturedRequests = httpObjectCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; assertEquals ( request2 , capturedRequests . get ( <int> ) ) ; assertEquals ( request3 , capturedRequests . get ( <int> ) ) ; } finally { request . release ( ) ; request2 . release ( ) ; request3 . release ( ) ; } } @Test public void serverRequestPushPromise ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final String text = <str> ; final ByteBuf content = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final String text2 = <str> ; final ByteBuf content2 = Unpooled . copiedBuffer ( text2 . getBytes ( ) ) ; final FullHttpMessage response = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK , content , true ) ; final FullHttpMessage response2 = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . CREATED , content2 , true ) ; final FullHttpMessage request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . GET , <str> , true ) ; try { HttpHeaders httpHeaders = response . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; HttpHeaders httpHeaders2 = response2 . headers ( ) ; httpHeaders2 . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; httpHeaders2 . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders2 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders2 . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_PROMISE_ID . text ( ) , <int> ) ; httpHeaders2 . setInt ( HttpHeaderNames . CONTENT_LENGTH , text2 . length ( ) ) ; httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; final Http2Headers http2Headers3 = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers3 , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . status ( new AsciiString ( <str> ) ) ; final Http2Headers http2Headers2 = new DefaultHttp2Headers ( ) . status ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) ; runInChannel ( serverConnectedChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxServer ( ) , <int> , http2Headers , <int> , false , newPromiseServer ( ) ) ; frameWriter . writePushPromise ( ctxServer ( ) , <int> , <int> , http2Headers2 , <int> , newPromiseServer ( ) ) ; frameWriter . writeData ( ctxServer ( ) , <int> , content . duplicate ( ) . retain ( ) , <int> , true , newPromiseServer ( ) ) ; frameWriter . writeData ( ctxServer ( ) , <int> , content2 . duplicate ( ) . retain ( ) , <int> , true , newPromiseServer ( ) ) ; ctxServer ( ) . flush ( ) ; } } ) ; awaitResponses ( ) ; ArgumentCaptor < FullHttpMessage > responseCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( clientListener , times ( <int> ) ) . messageReceived ( responseCaptor . capture ( ) ) ; capturedResponses = responseCaptor . getAllValues ( ) ; assertEquals ( response , capturedResponses . get ( <int> ) ) ; assertEquals ( response2 , capturedResponses . get ( <int> ) ) ; } finally { request . release ( ) ; response . release ( ) ; response2 . release ( ) ; } } @Test public void serverResponseHeaderInformational ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final FullHttpMessage request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . PUT , <str> , true ) ; HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . EXPECT , HttpHeaderValues . CONTINUE ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . set ( new AsciiString ( HttpHeaderNames . EXPECT . toString ( ) ) , new AsciiString ( HttpHeaderValues . CONTINUE . toString ( ) ) ) ; final FullHttpMessage response = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . CONTINUE ) ; final String text = <str> ; final ByteBuf payload = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; final FullHttpMessage request2 = request . copy ( payload ) ; final FullHttpMessage response2 = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . OK ) ; try { runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxClient ( ) , <int> , http2Headers , <int> , false , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; httpHeaders = response . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; final Http2Headers http2HeadersResponse = new DefaultHttp2Headers ( ) . status ( new AsciiString ( <str> ) ) ; runInChannel ( serverConnectedChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxServer ( ) , <int> , http2HeadersResponse , <int> , false , newPromiseServer ( ) ) ; ctxServer ( ) . flush ( ) ; } } ) ; httpHeaders = request2 . headers ( ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , text . length ( ) ) ; httpHeaders . remove ( HttpHeaderNames . EXPECT ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeData ( ctxClient ( ) , <int> , payload . duplicate ( ) . retain ( ) , <int> , true , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; httpHeaders = response2 . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; final Http2Headers http2HeadersResponse2 = new DefaultHttp2Headers ( ) . status ( new AsciiString ( <str> ) ) ; runInChannel ( serverConnectedChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeHeaders ( ctxServer ( ) , <int> , http2HeadersResponse2 , <int> , true , newPromiseServer ( ) ) ; ctxServer ( ) . flush ( ) ; } } ) ; awaitRequests ( ) ; ArgumentCaptor < FullHttpMessage > requestCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( serverListener , times ( <int> ) ) . messageReceived ( requestCaptor . capture ( ) ) ; capturedRequests = requestCaptor . getAllValues ( ) ; assertEquals ( <int> , capturedRequests . size ( ) ) ; assertEquals ( request , capturedRequests . get ( <int> ) ) ; assertEquals ( request2 , capturedRequests . get ( <int> ) ) ; awaitResponses ( ) ; ArgumentCaptor < FullHttpMessage > responseCaptor = ArgumentCaptor . forClass ( FullHttpMessage . class ) ; verify ( clientListener , times ( <int> ) ) . messageReceived ( responseCaptor . capture ( ) ) ; capturedResponses = responseCaptor . getAllValues ( ) ; assertEquals ( <int> , capturedResponses . size ( ) ) ; assertEquals ( response , capturedResponses . get ( <int> ) ) ; assertEquals ( response2 , capturedResponses . get ( <int> ) ) ; } finally { request . release ( ) ; request2 . release ( ) ; response . release ( ) ; response2 . release ( ) ; } } @Test public void propagateSettings ( ) throws Exception { boostrapEnv ( <int> , <int> , <int> ) ; final Http2Settings settings = new Http2Settings ( ) . pushEnabled ( true ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) { frameWriter . writeSettings ( ctxClient ( ) , settings , newPromiseClient ( ) ) ; ctxClient ( ) . flush ( ) ; } } ) ; assertTrue ( settingsLatch . await ( <int> , SECONDS ) ) ; ArgumentCaptor < Http2Settings > settingsCaptor = ArgumentCaptor . forClass ( Http2Settings . class ) ; verify ( settingsListener ) . messageReceived ( settingsCaptor . capture ( ) ) ; assertEquals ( settings , settingsCaptor . getValue ( ) ) ; } private void boostrapEnv ( int clientLatchCount , int serverLatchCount , int settingsLatchCount ) throws InterruptedException { clientDelegator = null ; serverDelegator = null ; serverConnectedChannel = null ; maxContentLength = <int> ; final CountDownLatch serverChannelLatch = new CountDownLatch ( <int> ) ; serverLatch = new CountDownLatch ( serverLatchCount ) ; clientLatch = new CountDownLatch ( clientLatchCount ) ; settingsLatch = new CountDownLatch ( settingsLatchCount ) ; frameWriter = new DefaultHttp2FrameWriter ( ) ; sb = new ServerBootstrap ( ) ; cb = new Bootstrap ( ) ; sb . group ( new DefaultEventLoopGroup ( ) ) ; sb . channel ( LocalServerChannel . class ) ; sb . childHandler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; Http2Connection connection = new DefaultHttp2Connection ( true ) ; p . addLast ( new HttpAdapterFrameAdapter ( connection , new InboundHttp2ToHttpPriorityAdapter . Builder ( connection ) . maxContentLength ( maxContentLength ) . validateHttpHeaders ( true ) . propagateSettings ( true ) . build ( ) , new CountDownLatch ( <int> ) ) ) ; serverDelegator = new HttpResponseDelegator ( serverListener , serverLatch ) ; p . addLast ( serverDelegator ) ; serverConnectedChannel = ch ; settingsDelegator = new HttpSettingsDelegator ( settingsListener , settingsLatch ) ; p . addLast ( settingsDelegator ) ; p . addLast ( new ChannelHandlerAdapter ( ) { @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { Http2Exception e = getEmbeddedHttp2Exception ( cause ) ; if ( e ! = null ) { serverException = e ; serverLatch . countDown ( ) ; } else { super . exceptionCaught ( ctx , cause ) ; } } } ) ; serverChannelLatch . countDown ( ) ; } } ) ; cb . group ( new DefaultEventLoopGroup ( ) ) ; cb . channel ( LocalChannel . class ) ; cb . handler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; Http2Connection connection = new DefaultHttp2Connection ( false ) ; p . addLast ( new HttpAdapterFrameAdapter ( connection , new InboundHttp2ToHttpPriorityAdapter . Builder ( connection ) . maxContentLength ( maxContentLength ) . build ( ) , new CountDownLatch ( <int> ) ) ) ; clientDelegator = new HttpResponseDelegator ( clientListener , clientLatch ) ; p . addLast ( clientDelegator ) ; } } ) ; serverChannel = sb . bind ( new LocalAddress ( <str> ) ) . sync ( ) . channel ( ) ; ChannelFuture ccf = cb . connect ( serverChannel . localAddress ( ) ) ; assertTrue ( ccf . awaitUninterruptibly ( ) . isSuccess ( ) ) ; clientChannel = ccf . channel ( ) ; assertTrue ( serverChannelLatch . await ( <int> , SECONDS ) ) ; } private void cleanupCapturedRequests ( ) { if ( capturedRequests ! = null ) { for ( FullHttpMessage capturedRequest : capturedRequests ) { capturedRequest . release ( ) ; } capturedRequests = null ; } } private void cleanupCapturedResponses ( ) { if ( capturedResponses ! = null ) { for ( FullHttpMessage capturedResponse : capturedResponses ) { capturedResponse . release ( ) ; } capturedResponses = null ; } } private void awaitRequests ( ) throws Exception { assertTrue ( serverLatch . await ( <int> , SECONDS ) ) ; } private void awaitResponses ( ) throws Exception { assertTrue ( clientLatch . await ( <int> , SECONDS ) ) ; } private ChannelHandlerContext ctxClient ( ) { return clientChannel . pipeline ( ) . firstContext ( ) ; } private ChannelPromise newPromiseClient ( ) { return ctxClient ( ) . newPromise ( ) ; } private ChannelHandlerContext ctxServer ( ) { return serverConnectedChannel . pipeline ( ) . firstContext ( ) ; } private ChannelPromise newPromiseServer ( ) { return ctxServer ( ) . newPromise ( ) ; } private interface HttpResponseListener { void messageReceived ( HttpObject obj ) ; } private interface HttpSettingsListener { void messageReceived ( Http2Settings settings ) ; } private static final class HttpResponseDelegator extends SimpleChannelInboundHandler < HttpObject > { private final HttpResponseListener listener ; private final CountDownLatch latch ; HttpResponseDelegator ( HttpResponseListener listener , CountDownLatch latch ) { super ( false ) ; this . listener = listener ; this . latch = latch ; } @Override protected void channelRead0 ( ChannelHandlerContext ctx , HttpObject msg ) throws Exception { listener . messageReceived ( msg ) ; latch . countDown ( ) ; } } private static final class HttpSettingsDelegator extends SimpleChannelInboundHandler < Http2Settings > { private final HttpSettingsListener listener ; private final CountDownLatch latch ; HttpSettingsDelegator ( HttpSettingsListener listener , CountDownLatch latch ) { super ( false ) ; this . listener = listener ; this . latch = latch ; } @Override protected void channelRead0 ( ChannelHandlerContext ctx , Http2Settings settings ) throws Exception { listener . messageReceived ( settings ) ; latch . countDown ( ) ; } } private static final class HttpAdapterFrameAdapter extends FrameAdapter { HttpAdapterFrameAdapter ( Http2Connection connection , Http2FrameListener listener , CountDownLatch latch ) { super ( connection , listener , latch ) ; } @Override protected void closeStream ( Http2Stream stream , boolean dataRead ) { if ( ! dataRead ) { super . closeStream ( stream , dataRead ) ; } } } } 
