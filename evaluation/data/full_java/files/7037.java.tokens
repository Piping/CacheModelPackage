package org . elasticsearch . rest . action . cat ; import org . elasticsearch . action . admin . cluster . node . info . NodeInfo ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoRequest ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoResponse ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsRequest ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . cluster . state . ClusterStateRequest ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . Table ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . InetSocketTransportAddress ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . RestResponse ; import org . elasticsearch . rest . action . support . RestActionListener ; import org . elasticsearch . rest . action . support . RestResponseListener ; import org . elasticsearch . rest . action . support . RestTable ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . threadpool . ThreadPoolStats ; import java . util . Collections ; import java . util . HashMap ; import java . util . LinkedHashSet ; import java . util . Map ; import java . util . Set ; import static org . elasticsearch . rest . RestRequest . Method . GET ; public class RestThreadPoolAction extends AbstractCatAction { private final static String [ ] SUPPORTED_NAMES = new String [ ] { ThreadPool . Names . BULK , ThreadPool . Names . FLUSH , ThreadPool . Names . GENERIC , ThreadPool . Names . GET , ThreadPool . Names . INDEX , ThreadPool . Names . MANAGEMENT , ThreadPool . Names . FORCE_MERGE , ThreadPool . Names . PERCOLATE , ThreadPool . Names . REFRESH , ThreadPool . Names . SEARCH , ThreadPool . Names . SNAPSHOT , ThreadPool . Names . SUGGEST , ThreadPool . Names . WARMER } ; private final static String [ ] SUPPORTED_ALIASES = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; static { assert SUPPORTED_ALIASES . length = = SUPPORTED_NAMES . length : <str> ; } private final static String [ ] DEFAULT_THREAD_POOLS = new String [ ] { ThreadPool . Names . BULK , ThreadPool . Names . INDEX , ThreadPool . Names . SEARCH , } ; private final static Map < String , String > ALIAS_TO_THREAD_POOL ; private final static Map < String , String > THREAD_POOL_TO_ALIAS ; static { ALIAS_TO_THREAD_POOL = new HashMap < > ( SUPPORTED_NAMES . length ) ; for ( String supportedThreadPool : SUPPORTED_NAMES ) { ALIAS_TO_THREAD_POOL . put ( supportedThreadPool . substring ( <int> , <int> ) , supportedThreadPool ) ; } THREAD_POOL_TO_ALIAS = new HashMap < > ( SUPPORTED_NAMES . length ) ; for ( int i = <int> ; i < SUPPORTED_NAMES . length ; i + + ) { THREAD_POOL_TO_ALIAS . put ( SUPPORTED_NAMES [ i ] , SUPPORTED_ALIASES [ i ] ) ; } } @Inject public RestThreadPoolAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override protected void documentation ( StringBuilder sb ) { sb . append ( <str> ) ; } @Override public void doRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final ClusterStateRequest clusterStateRequest = new ClusterStateRequest ( ) ; clusterStateRequest . clear ( ) . nodes ( true ) ; clusterStateRequest . local ( request . paramAsBoolean ( <str> , clusterStateRequest . local ( ) ) ) ; clusterStateRequest . masterNodeTimeout ( request . paramAsTime ( <str> , clusterStateRequest . masterNodeTimeout ( ) ) ) ; client . admin ( ) . cluster ( ) . state ( clusterStateRequest , new RestActionListener < ClusterStateResponse > ( channel ) { @Override public void processResponse ( final ClusterStateResponse clusterStateResponse ) { NodesInfoRequest nodesInfoRequest = new NodesInfoRequest ( ) ; nodesInfoRequest . clear ( ) . process ( true ) . threadPool ( true ) ; client . admin ( ) . cluster ( ) . nodesInfo ( nodesInfoRequest , new RestActionListener < NodesInfoResponse > ( channel ) { @Override public void processResponse ( final NodesInfoResponse nodesInfoResponse ) { NodesStatsRequest nodesStatsRequest = new NodesStatsRequest ( ) ; nodesStatsRequest . clear ( ) . threadPool ( true ) ; client . admin ( ) . cluster ( ) . nodesStats ( nodesStatsRequest , new RestResponseListener < NodesStatsResponse > ( channel ) { @Override public RestResponse buildResponse ( NodesStatsResponse nodesStatsResponse ) throws Exception { return RestTable . buildResponse ( buildTable ( request , clusterStateResponse , nodesInfoResponse , nodesStatsResponse ) , channel ) ; } } ) ; } } ) ; } } ) ; } @Override protected Table getTableWithHeader ( final RestRequest request ) { Table table = new Table ( ) ; table . startHeaders ( ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; table . addCell ( <str> , <str> ) ; final String [ ] requestedPools = fetchSortedPools ( request , DEFAULT_THREAD_POOLS ) ; for ( String pool : SUPPORTED_NAMES ) { String poolAlias = THREAD_POOL_TO_ALIAS . get ( pool ) ; boolean display = false ; for ( String requestedPool : requestedPools ) { if ( pool . equals ( requestedPool ) ) { display = true ; break ; } } String defaultDisplayVal = Boolean . toString ( display ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + defaultDisplayVal + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + defaultDisplayVal + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + defaultDisplayVal + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + pool + <str> ) ; table . addCell ( pool + <str> , <str> + poolAlias + <str> + pool + <str> ) ; } table . endHeaders ( ) ; return table ; } private Table buildTable ( RestRequest req , ClusterStateResponse state , NodesInfoResponse nodesInfo , NodesStatsResponse nodesStats ) { boolean fullId = req . paramAsBoolean ( <str> , false ) ; DiscoveryNodes nodes = state . getState ( ) . nodes ( ) ; Table table = getTableWithHeader ( req ) ; for ( DiscoveryNode node : nodes ) { NodeInfo info = nodesInfo . getNodesMap ( ) . get ( node . id ( ) ) ; NodeStats stats = nodesStats . getNodesMap ( ) . get ( node . id ( ) ) ; table . startRow ( ) ; table . addCell ( fullId ? node . id ( ) : Strings . substring ( node . getId ( ) , <int> , <int> ) ) ; table . addCell ( info = = null ? null : info . getProcess ( ) . getId ( ) ) ; table . addCell ( node . getHostName ( ) ) ; table . addCell ( node . getHostAddress ( ) ) ; if ( node . address ( ) instanceof InetSocketTransportAddress ) { table . addCell ( ( ( InetSocketTransportAddress ) node . address ( ) ) . address ( ) . getPort ( ) ) ; } else { table . addCell ( <str> ) ; } final Map < String , ThreadPoolStats . Stats > poolThreadStats ; final Map < String , ThreadPool . Info > poolThreadInfo ; if ( stats = = null ) { poolThreadStats = Collections . emptyMap ( ) ; poolThreadInfo = Collections . emptyMap ( ) ; } else { poolThreadStats = new HashMap < > ( <int> ) ; poolThreadInfo = new HashMap < > ( <int> ) ; ThreadPoolStats threadPoolStats = stats . getThreadPool ( ) ; for ( ThreadPoolStats . Stats threadPoolStat : threadPoolStats ) { poolThreadStats . put ( threadPoolStat . getName ( ) , threadPoolStat ) ; } if ( info ! = null ) { for ( ThreadPool . Info threadPoolInfo : info . getThreadPool ( ) ) { poolThreadInfo . put ( threadPoolInfo . getName ( ) , threadPoolInfo ) ; } } } for ( String pool : SUPPORTED_NAMES ) { ThreadPoolStats . Stats poolStats = poolThreadStats . get ( pool ) ; ThreadPool . Info poolInfo = poolThreadInfo . get ( pool ) ; Long maxQueueSize = null ; String keepAlive = null ; Integer minThreads = null ; Integer maxThreads = null ; if ( poolInfo ! = null ) { if ( poolInfo . getQueueSize ( ) ! = null ) { maxQueueSize = poolInfo . getQueueSize ( ) . singles ( ) ; } if ( poolInfo . getKeepAlive ( ) ! = null ) { keepAlive = poolInfo . getKeepAlive ( ) . toString ( ) ; } if ( poolInfo . getMin ( ) > = <int> ) { minThreads = poolInfo . getMin ( ) ; } if ( poolInfo . getMax ( ) > = <int> ) { maxThreads = poolInfo . getMax ( ) ; } } table . addCell ( poolInfo = = null ? null : poolInfo . getThreadPoolType ( ) . getType ( ) ) ; table . addCell ( poolStats = = null ? null : poolStats . getActive ( ) ) ; table . addCell ( poolStats = = null ? null : poolStats . getThreads ( ) ) ; table . addCell ( poolStats = = null ? null : poolStats . getQueue ( ) ) ; table . addCell ( maxQueueSize ) ; table . addCell ( poolStats = = null ? null : poolStats . getRejected ( ) ) ; table . addCell ( poolStats = = null ? null : poolStats . getLargest ( ) ) ; table . addCell ( poolStats = = null ? null : poolStats . getCompleted ( ) ) ; table . addCell ( minThreads ) ; table . addCell ( maxThreads ) ; table . addCell ( keepAlive ) ; } table . endRow ( ) ; } return table ; } private String [ ] fetchSortedPools ( RestRequest request , String [ ] defaults ) { String [ ] headers = request . paramAsStringArray ( <str> , null ) ; if ( headers = = null ) { return defaults ; } else { Set < String > requestedPools = new LinkedHashSet < > ( headers . length ) ; for ( String header : headers ) { int dotIndex = header . indexOf ( <str> ) ; if ( dotIndex ! = - <int> ) { String headerPrefix = header . substring ( <int> , dotIndex ) ; if ( THREAD_POOL_TO_ALIAS . containsKey ( headerPrefix ) ) { requestedPools . add ( headerPrefix ) ; } } else if ( ALIAS_TO_THREAD_POOL . containsKey ( header ) ) { requestedPools . add ( ALIAS_TO_THREAD_POOL . get ( header ) ) ; } } return requestedPools . toArray ( new String [ requestedPools . size ( ) ] ) ; } } } 
