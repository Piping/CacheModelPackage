package io . netty . example . sctp . multihoming ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . sctp . SctpChannel ; import io . netty . channel . sctp . SctpServerChannel ; import io . netty . channel . sctp . nio . NioSctpServerChannel ; import io . netty . example . sctp . SctpEchoServerHandler ; import io . netty . handler . logging . LogLevel ; import io . netty . handler . logging . LoggingHandler ; import java . net . InetAddress ; import java . net . InetSocketAddress ; public final class SctpMultiHomingEchoServer { private static final String SERVER_PRIMARY_HOST = System . getProperty ( <str> , <str> ) ; private static final String SERVER_SECONDARY_HOST = System . getProperty ( <str> , <str> ) ; private static final int SERVER_PORT = Integer . parseInt ( System . getProperty ( <str> , <str> ) ) ; public static void main ( String [ ] args ) throws Exception { EventLoopGroup bossGroup = new NioEventLoopGroup ( <int> ) ; EventLoopGroup workerGroup = new NioEventLoopGroup ( ) ; try { ServerBootstrap b = new ServerBootstrap ( ) ; b . group ( bossGroup , workerGroup ) . channel ( NioSctpServerChannel . class ) . option ( ChannelOption . SO_BACKLOG , <int> ) . handler ( new LoggingHandler ( LogLevel . INFO ) ) . childHandler ( new ChannelInitializer < SctpChannel > ( ) { @Override public void initChannel ( SctpChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new SctpEchoServerHandler ( ) ) ; } } ) ; InetSocketAddress localAddress = new InetSocketAddress ( SERVER_PRIMARY_HOST , SERVER_PORT ) ; InetAddress localSecondaryAddress = InetAddress . getByName ( SERVER_SECONDARY_HOST ) ; ChannelFuture bindFuture = b . bind ( localAddress ) . sync ( ) ; SctpServerChannel channel = ( SctpServerChannel ) bindFuture . channel ( ) ; ChannelFuture connectFuture = channel . bindAddress ( localSecondaryAddress ) . sync ( ) ; connectFuture . channel ( ) . closeFuture ( ) . sync ( ) ; } finally { bossGroup . shutdownGracefully ( ) ; workerGroup . shutdownGracefully ( ) ; } } } 
