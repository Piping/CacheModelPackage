package org . eclipse . debug . core . model ; import java . util . HashMap ; import java . util . Map ; import java . util . Map . Entry ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . PlatformObject ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . internal . core . DebugCoreMessages ; import org . eclipse . debug . internal . core . NullStreamsProxy ; import org . eclipse . debug . internal . core . StreamsProxy ; public class RuntimeProcess extends PlatformObject implements IProcess { private static final int MAX_WAIT_FOR_DEATH_ATTEMPTS = <int> ; private static final int TIME_TO_WAIT_FOR_THREAD_DEATH = <int> ; private ILaunch fLaunch ; private Process fProcess ; private int fExitValue ; private ProcessMonitorThread fMonitor ; private IStreamsProxy fStreamsProxy ; private String fName ; private boolean fTerminated ; private Map < String , String > fAttributes ; private boolean fCaptureOutput = true ; public RuntimeProcess ( ILaunch launch , Process process , String name , Map < String , String > attributes ) { setLaunch ( launch ) ; initializeAttributes ( attributes ) ; fProcess = process ; fName = name ; fTerminated = true ; try { fExitValue = process . exitValue ( ) ; } catch ( IllegalThreadStateException e ) { fTerminated = false ; } String captureOutput = launch . getAttribute ( DebugPlugin . ATTR_CAPTURE_OUTPUT ) ; fCaptureOutput = ! ( <str> . equals ( captureOutput ) ) ; fStreamsProxy = createStreamsProxy ( ) ; fMonitor = new ProcessMonitorThread ( this ) ; fMonitor . start ( ) ; launch . addProcess ( this ) ; fireCreationEvent ( ) ; } private void initializeAttributes ( Map < String , String > attributes ) { if ( attributes ! = null ) { for ( Entry < String , String > entry : attributes . entrySet ( ) ) { setAttribute ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } @Override public synchronized boolean canTerminate ( ) { return ! fTerminated ; } @Override public String getLabel ( ) { return fName ; } protected void setLaunch ( ILaunch launch ) { fLaunch = launch ; } @Override public ILaunch getLaunch ( ) { return fLaunch ; } protected Process getSystemProcess ( ) { return fProcess ; } @Override public synchronized boolean isTerminated ( ) { return fTerminated ; } @Override public void terminate ( ) throws DebugException { if ( ! isTerminated ( ) ) { if ( fStreamsProxy instanceof StreamsProxy ) { ( ( StreamsProxy ) fStreamsProxy ) . kill ( ) ; } Process process = getSystemProcess ( ) ; if ( process ! = null ) { process . destroy ( ) ; } int attempts = <int> ; while ( attempts < MAX_WAIT_FOR_DEATH_ATTEMPTS ) { try { process = getSystemProcess ( ) ; if ( process ! = null ) { fExitValue = process . exitValue ( ) ; } return ; } catch ( IllegalThreadStateException ie ) { } try { Thread . sleep ( TIME_TO_WAIT_FOR_THREAD_DEATH ) ; } catch ( InterruptedException e ) { } attempts + + ; } if ( fMonitor ! = null ) { fMonitor . killThread ( ) ; fMonitor = null ; } IStatus status = new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugException . TARGET_REQUEST_FAILED , DebugCoreMessages . RuntimeProcess_terminate_failed , null ) ; throw new DebugException ( status ) ; } } protected void terminated ( ) { if ( fStreamsProxy instanceof StreamsProxy ) { ( ( StreamsProxy ) fStreamsProxy ) . close ( ) ; } int exitValue = - <int> ; boolean running = false ; try { exitValue = fProcess . exitValue ( ) ; } catch ( IllegalThreadStateException ie ) { running = true ; } synchronized ( this ) { fTerminated = true ; if ( ! running ) { fExitValue = exitValue ; } fProcess = null ; } fireTerminateEvent ( ) ; } @Override public IStreamsProxy getStreamsProxy ( ) { if ( ! fCaptureOutput ) { return null ; } return fStreamsProxy ; } protected IStreamsProxy createStreamsProxy ( ) { if ( ! fCaptureOutput ) { return new NullStreamsProxy ( getSystemProcess ( ) ) ; } String encoding = getLaunch ( ) . getAttribute ( DebugPlugin . ATTR_CONSOLE_ENCODING ) ; return new StreamsProxy ( getSystemProcess ( ) , encoding ) ; } protected void fireCreationEvent ( ) { fireEvent ( new DebugEvent ( this , DebugEvent . CREATE ) ) ; } protected void fireEvent ( DebugEvent event ) { DebugPlugin manager = DebugPlugin . getDefault ( ) ; if ( manager ! = null ) { manager . fireDebugEventSet ( new DebugEvent [ ] { event } ) ; } } protected void fireTerminateEvent ( ) { fireEvent ( new DebugEvent ( this , DebugEvent . TERMINATE ) ) ; } protected void fireChangeEvent ( ) { fireEvent ( new DebugEvent ( this , DebugEvent . CHANGE ) ) ; } @Override public void setAttribute ( String key , String value ) { if ( fAttributes = = null ) { fAttributes = new HashMap < String , String > ( <int> ) ; } Object origVal = fAttributes . get ( key ) ; if ( origVal ! = null & & origVal . equals ( value ) ) { return ; } fAttributes . put ( key , value ) ; fireChangeEvent ( ) ; } @Override public String getAttribute ( String key ) { if ( fAttributes = = null ) { return null ; } return fAttributes . get ( key ) ; } @SuppressWarnings ( <str> ) @Override public < T > T getAdapter ( Class < T > adapter ) { if ( adapter . equals ( IProcess . class ) ) { return ( T ) this ; } if ( adapter . equals ( IDebugTarget . class ) ) { ILaunch launch = getLaunch ( ) ; IDebugTarget [ ] targets = launch . getDebugTargets ( ) ; for ( int i = <int> ; i < targets . length ; i + + ) { if ( this . equals ( targets [ i ] . getProcess ( ) ) ) { return ( T ) targets [ i ] ; } } return null ; } if ( adapter . equals ( ILaunch . class ) ) { return ( T ) getLaunch ( ) ; } if ( adapter . equals ( ILaunchConfiguration . class ) ) { return ( T ) getLaunch ( ) . getLaunchConfiguration ( ) ; } return super . getAdapter ( adapter ) ; } @Override public synchronized int getExitValue ( ) throws DebugException { if ( isTerminated ( ) ) { return fExitValue ; } throw new DebugException ( new Status ( IStatus . ERROR , DebugPlugin . getUniqueIdentifier ( ) , DebugException . TARGET_REQUEST_FAILED , DebugCoreMessages . RuntimeProcess_Exit_value_not_available_until_process_terminates__1 , null ) ) ; } class ProcessMonitorThread extends Thread { protected boolean fExit ; protected Process fOSProcess ; protected RuntimeProcess fRuntimeProcess ; protected Thread fThread ; private final Object fThreadLock = new Object ( ) ; @Override public void run ( ) { synchronized ( fThreadLock ) { if ( fExit ) { return ; } fThread = Thread . currentThread ( ) ; } while ( fOSProcess ! = null ) { try { fOSProcess . waitFor ( ) ; } catch ( InterruptedException ie ) { Thread . interrupted ( ) ; } finally { fOSProcess = null ; fRuntimeProcess . terminated ( ) ; } } fThread = null ; } public ProcessMonitorThread ( RuntimeProcess process ) { super ( DebugCoreMessages . ProcessMonitorJob_0 ) ; setDaemon ( true ) ; fRuntimeProcess = process ; fOSProcess = process . getSystemProcess ( ) ; } protected void killThread ( ) { synchronized ( fThreadLock ) { if ( fThread = = null ) { fExit = true ; } else { fThread . interrupt ( ) ; } } } } } 
