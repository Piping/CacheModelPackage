package com . google . common . collect ; import com . google . common . base . Function ; import com . google . common . primitives . Ints ; import junit . framework . TestCase ; import java . util . List ; import java . util . Random ; import java . util . concurrent . Callable ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentSkipListMap ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . atomic . AtomicInteger ; public class ConcurrentHashMultisetBasherTest extends TestCase { public void testAddAndRemove_ConcurrentHashMap ( ) throws Exception { testAddAndRemove ( new ConcurrentHashMap < String , AtomicInteger > ( ) ) ; } public void testAddAndRemove_ConcurrentSkipListMap ( ) throws Exception { testAddAndRemove ( new ConcurrentSkipListMap < String , AtomicInteger > ( ) ) ; } public void testAddAndRemove_MapMakerMap ( ) throws Exception { MapMaker mapMaker = new MapMaker ( ) ; mapMaker . useCustomMap = true ; testAddAndRemove ( mapMaker . < String , AtomicInteger > makeMap ( ) ) ; } private void testAddAndRemove ( ConcurrentMap < String , AtomicInteger > map ) throws ExecutionException , InterruptedException { final ConcurrentHashMultiset < String > multiset = new ConcurrentHashMultiset < String > ( map ) ; int nThreads = <int> ; int tasksPerThread = <int> ; int nTasks = nThreads * tasksPerThread ; ExecutorService pool = Executors . newFixedThreadPool ( nThreads ) ; ImmutableList < String > keys = ImmutableList . of ( <str> , <str> , <str> ) ; try { List < Future < int [ ] > > futures = Lists . newArrayListWithExpectedSize ( nTasks ) ; for ( int i = <int> ; i < nTasks ; i + + ) { futures . add ( pool . submit ( new MutateTask ( multiset , keys ) ) ) ; } int [ ] deltas = new int [ <int> ] ; for ( Future < int [ ] > future : futures ) { int [ ] taskDeltas = future . get ( ) ; for ( int i = <int> ; i < deltas . length ; i + + ) { deltas [ i ] + = taskDeltas [ i ] ; } } List < Integer > actualCounts = Lists . transform ( keys , new Function < String , Integer > ( ) { @Override public Integer apply ( String key ) { return multiset . count ( key ) ; } } ) ; assertEquals ( <str> , Ints . asList ( deltas ) , actualCounts ) ; } finally { pool . shutdownNow ( ) ; } for ( AtomicInteger value : map . values ( ) ) { assertTrue ( <str> , value . get ( ) ! = <int> ) ; } } private static class MutateTask implements Callable < int [ ] > { private final ConcurrentHashMultiset < String > multiset ; private final ImmutableList < String > keys ; private final Random random = new Random ( ) ; private MutateTask ( ConcurrentHashMultiset < String > multiset , ImmutableList < String > keys ) { this . multiset = multiset ; this . keys = keys ; } @Override public int [ ] call ( ) throws Exception { int iterations = <int> ; int nKeys = keys . size ( ) ; int [ ] deltas = new int [ nKeys ] ; Operation [ ] operations = Operation . values ( ) ; for ( int i = <int> ; i < iterations ; i + + ) { int keyIndex = random . nextInt ( nKeys ) ; String key = keys . get ( keyIndex ) ; Operation op = operations [ random . nextInt ( operations . length ) ] ; switch ( op ) { case ADD : { int delta = random . nextInt ( <int> ) ; multiset . add ( key , delta ) ; deltas [ keyIndex ] + = delta ; break ; } case SET_COUNT : { int newValue = random . nextInt ( <int> ) ; int oldValue = multiset . setCount ( key , newValue ) ; deltas [ keyIndex ] + = ( newValue - oldValue ) ; break ; } case SET_COUNT_IF : { int newValue = random . nextInt ( <int> ) ; int oldValue = multiset . count ( key ) ; if ( multiset . setCount ( key , oldValue , newValue ) ) { deltas [ keyIndex ] + = ( newValue - oldValue ) ; } break ; } case REMOVE : { int delta = random . nextInt ( <int> ) ; int oldValue = multiset . remove ( key , delta ) ; deltas [ keyIndex ] - = Math . min ( delta , oldValue ) ; break ; } case REMOVE_EXACTLY : { int delta = random . nextInt ( <int> ) ; if ( multiset . removeExactly ( key , delta ) ) { deltas [ keyIndex ] - = delta ; } break ; } } } return deltas ; } private enum Operation { ADD , SET_COUNT , SET_COUNT_IF , REMOVE , REMOVE_EXACTLY , ; } } } 
