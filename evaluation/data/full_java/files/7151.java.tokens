package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . Aggregation ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregations ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public abstract class InternalSingleBucketAggregation extends InternalAggregation implements SingleBucketAggregation { private long docCount ; private InternalAggregations aggregations ; protected InternalSingleBucketAggregation ( ) { } protected InternalSingleBucketAggregation ( String name , long docCount , InternalAggregations aggregations , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) { super ( name , pipelineAggregators , metaData ) ; this . docCount = docCount ; this . aggregations = aggregations ; } @Override public long getDocCount ( ) { return docCount ; } @Override public InternalAggregations getAggregations ( ) { return aggregations ; } public InternalSingleBucketAggregation create ( InternalAggregations subAggregations ) { return newAggregation ( getName ( ) , getDocCount ( ) , subAggregations ) ; } protected abstract InternalSingleBucketAggregation newAggregation ( String name , long docCount , InternalAggregations subAggregations ) ; @Override public InternalAggregation doReduce ( List < InternalAggregation > aggregations , ReduceContext reduceContext ) { long docCount = <int> L ; List < InternalAggregations > subAggregationsList = new ArrayList < > ( aggregations . size ( ) ) ; for ( InternalAggregation aggregation : aggregations ) { assert aggregation . getName ( ) . equals ( getName ( ) ) ; docCount + = ( ( InternalSingleBucketAggregation ) aggregation ) . docCount ; subAggregationsList . add ( ( ( InternalSingleBucketAggregation ) aggregation ) . aggregations ) ; } final InternalAggregations aggs = InternalAggregations . reduce ( subAggregationsList , reduceContext ) ; return newAggregation ( getName ( ) , docCount , aggs ) ; } @Override public Object getProperty ( List < String > path ) { if ( path . isEmpty ( ) ) { return this ; } else { String aggName = path . get ( <int> ) ; if ( aggName . equals ( <str> ) ) { if ( path . size ( ) > <int> ) { throw new IllegalArgumentException ( <str> ) ; } return getDocCount ( ) ; } InternalAggregation aggregation = aggregations . get ( aggName ) ; if ( aggregation = = null ) { throw new IllegalArgumentException ( <str> + aggName + <str> + getName ( ) + <str> ) ; } return aggregation . getProperty ( path . subList ( <int> , path . size ( ) ) ) ; } } @Override protected void doReadFrom ( StreamInput in ) throws IOException { docCount = in . readVLong ( ) ; aggregations = InternalAggregations . readAggregations ( in ) ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeVLong ( docCount ) ; aggregations . writeTo ( out ) ; } @Override public XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { builder . field ( CommonFields . DOC_COUNT , docCount ) ; aggregations . toXContentInternal ( builder , params ) ; return builder ; } } 
