package org . elasticsearch . common . util . concurrent ; import org . elasticsearch . common . settings . Settings ; import java . util . Arrays ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . stream . Collectors ; public class EsExecutors { public static final String PROCESSORS = <str> ; public static final String DEFAULT_SYSPROP = <str> ; public static int boundedNumberOfProcessors ( Settings settings ) { int defaultValue = Math . min ( <int> , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; try { defaultValue = Integer . parseInt ( System . getProperty ( DEFAULT_SYSPROP ) ) ; } catch ( Throwable ignored ) { } return settings . getAsInt ( PROCESSORS , defaultValue ) ; } public static PrioritizedEsThreadPoolExecutor newSinglePrioritizing ( String name , ThreadFactory threadFactory ) { return new PrioritizedEsThreadPoolExecutor ( name , <int> , <int> , <int> L , TimeUnit . MILLISECONDS , threadFactory ) ; } public static EsThreadPoolExecutor newScaling ( String name , int min , int max , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory ) { ExecutorScalingQueue < Runnable > queue = new ExecutorScalingQueue < > ( ) ; EsThreadPoolExecutor executor = new EsThreadPoolExecutor ( name , min , max , keepAliveTime , unit , queue , threadFactory , new ForceQueuePolicy ( ) ) ; queue . executor = executor ; return executor ; } public static EsThreadPoolExecutor newCached ( String name , long keepAliveTime , TimeUnit unit , ThreadFactory threadFactory ) { return new EsThreadPoolExecutor ( name , <int> , Integer . MAX_VALUE , keepAliveTime , unit , new SynchronousQueue < Runnable > ( ) , threadFactory , new EsAbortPolicy ( ) ) ; } public static EsThreadPoolExecutor newFixed ( String name , int size , int queueCapacity , ThreadFactory threadFactory ) { BlockingQueue < Runnable > queue ; if ( queueCapacity < <int> ) { queue = ConcurrentCollections . newBlockingQueue ( ) ; } else { queue = new SizeBlockingQueue < > ( ConcurrentCollections . < Runnable > newBlockingQueue ( ) , queueCapacity ) ; } return new EsThreadPoolExecutor ( name , size , size , <int> , TimeUnit . MILLISECONDS , queue , threadFactory , new EsAbortPolicy ( ) ) ; } public static String threadName ( Settings settings , String . . . names ) { String namePrefix = Arrays . stream ( names ) . filter ( name - > name ! = null ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ; return threadName ( settings , namePrefix ) ; } public static String threadName ( Settings settings , String namePrefix ) { String name = settings . get ( <str> ) ; if ( name = = null ) { name = <str> ; } else { name = <str> + name + <str> ; } return name + <str> + namePrefix + <str> ; } public static ThreadFactory daemonThreadFactory ( Settings settings , String namePrefix ) { return daemonThreadFactory ( threadName ( settings , namePrefix ) ) ; } public static ThreadFactory daemonThreadFactory ( Settings settings , String . . . names ) { return daemonThreadFactory ( threadName ( settings , names ) ) ; } public static ThreadFactory daemonThreadFactory ( String namePrefix ) { return new EsThreadFactory ( namePrefix ) ; } static class EsThreadFactory implements ThreadFactory { final ThreadGroup group ; final AtomicInteger threadNumber = new AtomicInteger ( <int> ) ; final String namePrefix ; public EsThreadFactory ( String namePrefix ) { this . namePrefix = namePrefix ; SecurityManager s = System . getSecurityManager ( ) ; group = ( s ! = null ) ? s . getThreadGroup ( ) : Thread . currentThread ( ) . getThreadGroup ( ) ; } @Override public Thread newThread ( Runnable r ) { Thread t = new Thread ( group , r , namePrefix + <str> + threadNumber . getAndIncrement ( ) + <str> , <int> ) ; t . setDaemon ( true ) ; return t ; } } private EsExecutors ( ) { } static class ExecutorScalingQueue < E > extends LinkedTransferQueue < E > { ThreadPoolExecutor executor ; public ExecutorScalingQueue ( ) { } @Override public boolean offer ( E e ) { if ( ! tryTransfer ( e ) ) { int left = executor . getMaximumPoolSize ( ) - executor . getCorePoolSize ( ) ; if ( left > <int> ) { return false ; } else { return super . offer ( e ) ; } } else { return true ; } } } static class ForceQueuePolicy implements XRejectedExecutionHandler { @Override public void rejectedExecution ( Runnable r , ThreadPoolExecutor executor ) { try { executor . getQueue ( ) . put ( r ) ; } catch ( InterruptedException e ) { throw new EsRejectedExecutionException ( e ) ; } } @Override public long rejected ( ) { return <int> ; } } } 
