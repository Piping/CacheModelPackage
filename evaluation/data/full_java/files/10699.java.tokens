package org . gradle . build . docs . dsl . docbook ; import org . gradle . build . docs . dsl . docbook . model . ClassDoc ; import org . gradle . build . docs . dsl . docbook . model . ExtraAttributeDoc ; import org . gradle . build . docs . dsl . docbook . model . PropertyDoc ; import org . gradle . build . docs . dsl . source . model . PropertyMetaData ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import java . util . * ; public class ClassDocPropertiesBuilder extends ModelBuilderSupport { private final JavadocConverter javadocConverter ; private final GenerationListener listener ; private static final Logger LOG = Logging . getLogger ( ClassDocPropertiesBuilder . class ) ; public ClassDocPropertiesBuilder ( JavadocConverter javadocConverter , GenerationListener listener ) { this . javadocConverter = javadocConverter ; this . listener = listener ; } void build ( ClassDoc classDoc ) { Element thead = getChild ( classDoc . getPropertiesTable ( ) , <str> ) ; Element tr = getChild ( thead , <str> ) ; List < Element > header = children ( tr , <str> ) ; if ( header . size ( ) < <int> ) { throw new RuntimeException ( String . format ( <str> , header ) ) ; } Map < String , Element > inheritedValueTitleMapping = new HashMap < String , Element > ( ) ; List < Element > valueTitles = new ArrayList < Element > ( ) ; for ( int i = <int> ; i < header . size ( ) ; i + + ) { Element element = header . get ( i ) ; Element override = findChild ( element , <str> ) ; if ( override ! = null ) { element . removeChild ( override ) ; inheritedValueTitleMapping . put ( override . getTextContent ( ) , element ) ; } Node firstChild = element . getFirstChild ( ) ; if ( firstChild instanceof Text ) { firstChild . setTextContent ( firstChild . getTextContent ( ) . replaceFirst ( <str> , <str> ) ) ; } Node lastChild = element . getLastChild ( ) ; if ( lastChild instanceof Text ) { lastChild . setTextContent ( lastChild . getTextContent ( ) . replaceFirst ( <str> , <str> ) ) ; } valueTitles . add ( element ) ; } Map < String , PropertyDoc > props = new TreeMap < String , PropertyDoc > ( ) ; List < ClassDoc > superTypes = classDoc . getSuperTypes ( ) ; for ( ClassDoc superType : superTypes ) { LOG . info ( <str> , superType . getName ( ) ) ; for ( PropertyDoc propertyDoc : superType . getClassProperties ( ) ) { Map < String , ExtraAttributeDoc > additionalValues = new LinkedHashMap < String , ExtraAttributeDoc > ( ) ; for ( ExtraAttributeDoc attributeDoc : propertyDoc . getAdditionalValues ( ) ) { String key = attributeDoc . getKey ( ) ; if ( inheritedValueTitleMapping . get ( key ) ! = null ) { ExtraAttributeDoc newAttribute = new ExtraAttributeDoc ( inheritedValueTitleMapping . get ( key ) , attributeDoc . getValueCell ( ) ) ; additionalValues . put ( newAttribute . getKey ( ) , newAttribute ) ; } else { additionalValues . put ( key , attributeDoc ) ; } } props . put ( propertyDoc . getName ( ) , propertyDoc . forClass ( classDoc , additionalValues . values ( ) ) ) ; } } for ( Element row : children ( classDoc . getPropertiesTable ( ) , <str> ) ) { List < Element > cells = children ( row , <str> ) ; if ( cells . size ( ) ! = header . size ( ) ) { throw new RuntimeException ( String . format ( <str> , header . size ( ) , tr ) ) ; } String propName = cells . get ( <int> ) . getTextContent ( ) . trim ( ) ; PropertyMetaData property = classDoc . getClassMetaData ( ) . findProperty ( propName ) ; if ( property = = null ) { throw new RuntimeException ( String . format ( <str> , classDoc . getName ( ) , propName , classDoc . getClassMetaData ( ) . getPropertyNames ( ) ) ) ; } Map < String , ExtraAttributeDoc > additionalValues = new LinkedHashMap < String , ExtraAttributeDoc > ( ) ; if ( ! superTypes . isEmpty ( ) ) { PropertyDoc overriddenProp = props . get ( propName ) ; if ( overriddenProp ! = null ) { for ( ExtraAttributeDoc attributeDoc : overriddenProp . getAdditionalValues ( ) ) { additionalValues . put ( attributeDoc . getKey ( ) , attributeDoc ) ; } } } for ( int i = <int> ; i < header . size ( ) ; i + + ) { if ( cells . get ( i ) . getFirstChild ( ) = = null ) { continue ; } ExtraAttributeDoc attributeDoc = new ExtraAttributeDoc ( valueTitles . get ( i - <int> ) , cells . get ( i ) ) ; additionalValues . put ( attributeDoc . getKey ( ) , attributeDoc ) ; } PropertyDoc propertyDoc = new PropertyDoc ( property , javadocConverter . parse ( property , listener ) . getDocbook ( ) , new ArrayList < ExtraAttributeDoc > ( additionalValues . values ( ) ) ) ; if ( propertyDoc . getDescription ( ) = = null ) { throw new RuntimeException ( String . format ( <str> , classDoc . getName ( ) , propName ) ) ; } props . put ( propName , propertyDoc ) ; } for ( PropertyDoc propertyDoc : props . values ( ) ) { classDoc . addClassProperty ( propertyDoc ) ; } } } 
