package io . netty . handler . codec . http2 ; import static io . netty . buffer . Unpooled . EMPTY_BUFFER ; import static io . netty . buffer . Unpooled . wrappedBuffer ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT ; import static io . netty . handler . codec . http2 . Http2CodecUtil . emptyPingBuf ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Stream . State . HALF_CLOSED_REMOTE ; import static io . netty . handler . codec . http2 . Http2Stream . State . IDLE ; import static io . netty . handler . codec . http2 . Http2Stream . State . RESERVED_LOCAL ; import static io . netty . util . CharsetUtil . UTF_8 ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyBoolean ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyLong ; import static org . mockito . Matchers . anyShort ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . doNothing ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . verifyNoMoreInteractions ; import static org . mockito . Mockito . when ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . PooledByteBufAllocator ; import io . netty . buffer . Unpooled ; import io . netty . buffer . UnpooledByteBufAllocator ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultChannelPromise ; import io . netty . handler . codec . http2 . Http2RemoteFlowController . FlowControlled ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . GenericFutureListener ; import io . netty . util . concurrent . ImmediateEventExecutor ; import junit . framework . AssertionFailedError ; import org . junit . Before ; import org . junit . Test ; import org . mockito . ArgumentCaptor ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import java . util . ArrayList ; import java . util . List ; public class DefaultHttp2ConnectionEncoderTest { private static final int STREAM_ID = <int> ; private static final int PUSH_STREAM_ID = <int> ; @Mock private Http2RemoteFlowController remoteFlow ; @Mock private ChannelHandlerContext ctx ; @Mock private Channel channel ; @Mock private Http2FrameListener listener ; @Mock private Http2FrameWriter writer ; @Mock private Http2FrameWriter . Configuration writerConfig ; @Mock private Http2FrameSizePolicy frameSizePolicy ; @Mock private Http2LifecycleManager lifecycleManager ; private DefaultHttp2ConnectionEncoder encoder ; private Http2Connection connection ; private ArgumentCaptor < Http2RemoteFlowController . FlowControlled > payloadCaptor ; private List < String > writtenData ; private List < Integer > writtenPadding ; private boolean streamClosed ; @Before public void setup ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; when ( channel . isActive ( ) ) . thenReturn ( true ) ; when ( writer . configuration ( ) ) . thenReturn ( writerConfig ) ; when ( writerConfig . frameSizePolicy ( ) ) . thenReturn ( frameSizePolicy ) ; when ( frameSizePolicy . maxFrameSize ( ) ) . thenReturn ( <int> ) ; doAnswer ( new Answer < ChannelFuture > ( ) { @Override public ChannelFuture answer ( InvocationOnMock in ) throws Throwable { return ( ( ChannelPromise ) in . getArguments ( ) [ <int> ] ) . setSuccess ( ) ; } } ) . when ( writer ) . writeSettings ( eq ( ctx ) , any ( Http2Settings . class ) , any ( ChannelPromise . class ) ) ; doAnswer ( new Answer < ChannelFuture > ( ) { @Override public ChannelFuture answer ( InvocationOnMock in ) throws Throwable { ( ( ByteBuf ) in . getArguments ( ) [ <int> ] ) . release ( ) ; return ( ( ChannelPromise ) in . getArguments ( ) [ <int> ] ) . setSuccess ( ) ; } } ) . when ( writer ) . writeGoAway ( eq ( ctx ) , anyInt ( ) , anyInt ( ) , any ( ByteBuf . class ) , any ( ChannelPromise . class ) ) ; writtenData = new ArrayList < String > ( ) ; writtenPadding = new ArrayList < Integer > ( ) ; when ( writer . writeData ( eq ( ctx ) , anyInt ( ) , any ( ByteBuf . class ) , anyInt ( ) , anyBoolean ( ) , any ( ChannelPromise . class ) ) ) . then ( new Answer < ChannelFuture > ( ) { @Override public ChannelFuture answer ( InvocationOnMock in ) throws Throwable { ChannelPromise promise = ( ChannelPromise ) in . getArguments ( ) [ <int> ] ; if ( streamClosed ) { fail ( <str> ) ; } else { streamClosed = ( Boolean ) in . getArguments ( ) [ <int> ] ; } writtenPadding . add ( ( Integer ) in . getArguments ( ) [ <int> ] ) ; ByteBuf data = ( ByteBuf ) in . getArguments ( ) [ <int> ] ; writtenData . add ( data . toString ( UTF_8 ) ) ; data . release ( ) ; return promise . setSuccess ( ) ; } } ) ; when ( writer . writeHeaders ( eq ( ctx ) , anyInt ( ) , any ( Http2Headers . class ) , anyInt ( ) , anyShort ( ) , anyBoolean ( ) , anyInt ( ) , anyBoolean ( ) , any ( ChannelPromise . class ) ) ) . then ( new Answer < ChannelFuture > ( ) { @Override public ChannelFuture answer ( InvocationOnMock invocationOnMock ) throws Throwable { ChannelPromise promise = ( ChannelPromise ) invocationOnMock . getArguments ( ) [ <int> ] ; if ( streamClosed ) { fail ( <str> ) ; } else { streamClosed = ( Boolean ) invocationOnMock . getArguments ( ) [ <int> ] ; } return promise . setSuccess ( ) ; } } ) ; payloadCaptor = ArgumentCaptor . forClass ( Http2RemoteFlowController . FlowControlled . class ) ; doNothing ( ) . when ( remoteFlow ) . addFlowControlled ( any ( Http2Stream . class ) , payloadCaptor . capture ( ) ) ; when ( ctx . alloc ( ) ) . thenReturn ( UnpooledByteBufAllocator . DEFAULT ) ; when ( ctx . channel ( ) ) . thenReturn ( channel ) ; doAnswer ( new Answer < ChannelPromise > ( ) { @Override public ChannelPromise answer ( InvocationOnMock in ) throws Throwable { return newPromise ( ) ; } } ) . when ( ctx ) . newPromise ( ) ; doAnswer ( new Answer < ChannelFuture > ( ) { @Override public ChannelFuture answer ( InvocationOnMock in ) throws Throwable { return newSucceededFuture ( ) ; } } ) . when ( ctx ) . newSucceededFuture ( ) ; when ( ctx . flush ( ) ) . thenThrow ( new AssertionFailedError ( <str> ) ) ; when ( channel . alloc ( ) ) . thenReturn ( PooledByteBufAllocator . DEFAULT ) ; connection = new DefaultHttp2Connection ( true ) ; connection . remote ( ) . flowController ( remoteFlow ) ; encoder = new DefaultHttp2ConnectionEncoder ( connection , writer ) ; encoder . lifecycleManager ( lifecycleManager ) ; } @Test public void dataWriteShouldSucceed ( ) throws Exception { createStream ( STREAM_ID , false ) ; final ByteBuf data = dummyData ( ) ; ChannelPromise p = newPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , true , p ) ; assertEquals ( payloadCaptor . getValue ( ) . size ( ) , <int> ) ; payloadCaptor . getValue ( ) . write ( ctx , <int> ) ; assertEquals ( <int> , payloadCaptor . getValue ( ) . size ( ) ) ; assertEquals ( <str> , writtenData . get ( <int> ) ) ; assertEquals ( <int> , data . refCnt ( ) ) ; assertTrue ( p . isSuccess ( ) ) ; } @Test public void dataFramesShouldMerge ( ) throws Exception { createStream ( STREAM_ID , false ) ; final ByteBuf data = dummyData ( ) . retain ( ) ; ChannelPromise promise1 = newPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , true , promise1 ) ; ChannelPromise promise2 = newPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , true , promise2 ) ; List < FlowControlled > capturedWrites = payloadCaptor . getAllValues ( ) ; FlowControlled mergedPayload = capturedWrites . get ( <int> ) ; mergedPayload . merge ( ctx , capturedWrites . get ( <int> ) ) ; assertEquals ( <int> , mergedPayload . size ( ) ) ; assertFalse ( promise1 . isDone ( ) ) ; assertFalse ( promise2 . isDone ( ) ) ; mergedPayload . write ( ctx , <int> ) ; assertEquals ( <int> , mergedPayload . size ( ) ) ; assertEquals ( <str> , writtenData . get ( <int> ) ) ; assertEquals ( <int> , data . refCnt ( ) ) ; assertTrue ( promise1 . isSuccess ( ) ) ; assertTrue ( promise2 . isSuccess ( ) ) ; } @Test public void dataFramesShouldMergeUseVoidPromise ( ) throws Exception { createStream ( STREAM_ID , false ) ; final ByteBuf data = dummyData ( ) . retain ( ) ; ChannelPromise promise1 = newVoidPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , true , promise1 ) ; ChannelPromise promise2 = newVoidPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , true , promise2 ) ; List < FlowControlled > capturedWrites = payloadCaptor . getAllValues ( ) ; FlowControlled mergedPayload = capturedWrites . get ( <int> ) ; mergedPayload . merge ( ctx , capturedWrites . get ( <int> ) ) ; assertEquals ( <int> , mergedPayload . size ( ) ) ; assertFalse ( promise1 . isSuccess ( ) ) ; assertFalse ( promise2 . isSuccess ( ) ) ; mergedPayload . write ( ctx , <int> ) ; assertEquals ( <int> , mergedPayload . size ( ) ) ; assertEquals ( <str> , writtenData . get ( <int> ) ) ; assertEquals ( <int> , data . refCnt ( ) ) ; assertFalse ( promise1 . isSuccess ( ) ) ; assertFalse ( promise2 . isSuccess ( ) ) ; } @Test public void dataFramesDontMergeWithHeaders ( ) throws Exception { createStream ( STREAM_ID , false ) ; final ByteBuf data = dummyData ( ) . retain ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , true , newPromise ( ) ) ; encoder . writeHeaders ( ctx , STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , false , newPromise ( ) ) ; List < FlowControlled > capturedWrites = payloadCaptor . getAllValues ( ) ; assertFalse ( capturedWrites . get ( <int> ) . merge ( ctx , capturedWrites . get ( <int> ) ) ) ; } @Test public void emptyFrameShouldSplitPadding ( ) throws Exception { ByteBuf data = Unpooled . buffer ( <int> ) ; assertSplitPaddingOnEmptyBuffer ( data ) ; assertEquals ( <int> , data . refCnt ( ) ) ; } private void assertSplitPaddingOnEmptyBuffer ( ByteBuf data ) throws Exception { createStream ( STREAM_ID , false ) ; when ( frameSizePolicy . maxFrameSize ( ) ) . thenReturn ( <int> ) ; ChannelPromise p = newPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , true , p ) ; assertEquals ( payloadCaptor . getValue ( ) . size ( ) , <int> ) ; payloadCaptor . getValue ( ) . write ( ctx , <int> ) ; assertEquals ( <int> , writtenData . size ( ) ) ; assertEquals ( <str> , writtenData . get ( <int> ) ) ; assertEquals ( <int> , ( int ) writtenPadding . get ( <int> ) ) ; assertEquals ( <int> , data . refCnt ( ) ) ; assertTrue ( p . isSuccess ( ) ) ; } @Test public void headersWriteForUnknownStreamShouldCreateStream ( ) throws Exception { writeAllFlowControlledFrames ( ) ; final int streamId = <int> ; ChannelPromise promise = newPromise ( ) ; encoder . writeHeaders ( ctx , streamId , EmptyHttp2Headers . INSTANCE , <int> , false , promise ) ; verify ( writer ) . writeHeaders ( eq ( ctx ) , eq ( streamId ) , eq ( EmptyHttp2Headers . INSTANCE ) , eq ( <int> ) , eq ( DEFAULT_PRIORITY_WEIGHT ) , eq ( false ) , eq ( <int> ) , eq ( false ) , eq ( promise ) ) ; assertTrue ( promise . isSuccess ( ) ) ; } @Test public void headersWriteShouldOpenStreamForPush ( ) throws Exception { writeAllFlowControlledFrames ( ) ; Http2Stream parent = createStream ( STREAM_ID , false ) ; reservePushStream ( PUSH_STREAM_ID , parent ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeHeaders ( ctx , PUSH_STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , false , promise ) ; assertEquals ( HALF_CLOSED_REMOTE , stream ( PUSH_STREAM_ID ) . state ( ) ) ; verify ( writer ) . writeHeaders ( eq ( ctx ) , eq ( PUSH_STREAM_ID ) , eq ( EmptyHttp2Headers . INSTANCE ) , eq ( <int> ) , eq ( DEFAULT_PRIORITY_WEIGHT ) , eq ( false ) , eq ( <int> ) , eq ( false ) , eq ( promise ) ) ; } @Test public void pushPromiseWriteAfterGoAwayReceivedShouldFail ( ) throws Exception { createStream ( STREAM_ID , false ) ; goAwayReceived ( <int> ) ; ChannelFuture future = encoder . writePushPromise ( ctx , STREAM_ID , PUSH_STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , newPromise ( ) ) ; assertTrue ( future . isDone ( ) ) ; assertFalse ( future . isSuccess ( ) ) ; } @Test public void pushPromiseWriteShouldReserveStream ( ) throws Exception { createStream ( STREAM_ID , false ) ; ChannelPromise promise = newPromise ( ) ; encoder . writePushPromise ( ctx , STREAM_ID , PUSH_STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , promise ) ; assertEquals ( RESERVED_LOCAL , stream ( PUSH_STREAM_ID ) . state ( ) ) ; verify ( writer ) . writePushPromise ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( PUSH_STREAM_ID ) , eq ( EmptyHttp2Headers . INSTANCE ) , eq ( <int> ) , eq ( promise ) ) ; } @Test public void priorityWriteAfterGoAwayShouldSucceed ( ) throws Exception { createStream ( STREAM_ID , false ) ; goAwayReceived ( Integer . MAX_VALUE ) ; ChannelPromise promise = newPromise ( ) ; encoder . writePriority ( ctx , STREAM_ID , <int> , ( short ) <int> , true , promise ) ; verify ( writer ) . writePriority ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( true ) , eq ( promise ) ) ; } @Test public void priorityWriteShouldSetPriorityForStream ( ) throws Exception { ChannelPromise promise = newPromise ( ) ; short weight = <int> ; encoder . writePriority ( ctx , STREAM_ID , <int> , weight , true , promise ) ; Http2Stream stream = stream ( STREAM_ID ) ; assertEquals ( IDLE , stream . state ( ) ) ; assertEquals ( weight , stream . weight ( ) ) ; verify ( writer ) . writePriority ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( ( short ) <int> ) , eq ( true ) , eq ( promise ) ) ; } @Test public void priorityWriteOnPreviouslyExistingStreamShouldSucceed ( ) throws Exception { createStream ( STREAM_ID , false ) . close ( ) ; ChannelPromise promise = newPromise ( ) ; short weight = <int> ; encoder . writePriority ( ctx , STREAM_ID , <int> , weight , true , promise ) ; verify ( writer ) . writePriority ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( <int> ) , eq ( weight ) , eq ( true ) , eq ( promise ) ) ; } @Test public void priorityWriteOnPreviouslyExistingParentStreamShouldSucceed ( ) throws Exception { final int parentStreamId = STREAM_ID + <int> ; createStream ( STREAM_ID , false ) ; createStream ( parentStreamId , false ) . close ( ) ; ChannelPromise promise = newPromise ( ) ; short weight = <int> ; encoder . writePriority ( ctx , STREAM_ID , parentStreamId , weight , true , promise ) ; verify ( writer ) . writePriority ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( parentStreamId ) , eq ( weight ) , eq ( true ) , eq ( promise ) ) ; } @Test public void rstStreamWriteForUnknownStreamShouldIgnore ( ) throws Exception { ChannelPromise promise = newPromise ( ) ; encoder . writeRstStream ( ctx , <int> , PROTOCOL_ERROR . code ( ) , promise ) ; verify ( writer , never ( ) ) . writeRstStream ( eq ( ctx ) , anyInt ( ) , anyLong ( ) , eq ( promise ) ) ; } @Test public void rstStreamShouldCloseStream ( ) throws Exception { writeAllFlowControlledFrames ( ) ; encoder . writeHeaders ( ctx , STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , true , newPromise ( ) ) ; stream ( STREAM_ID ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeRstStream ( ctx , STREAM_ID , PROTOCOL_ERROR . code ( ) , promise ) ; verify ( lifecycleManager ) . resetStream ( eq ( ctx ) , eq ( STREAM_ID ) , anyInt ( ) , eq ( promise ) ) ; } @Test public void pingWriteAfterGoAwayShouldSucceed ( ) throws Exception { ChannelPromise promise = newPromise ( ) ; goAwayReceived ( <int> ) ; encoder . writePing ( ctx , false , emptyPingBuf ( ) , promise ) ; verify ( writer ) . writePing ( eq ( ctx ) , eq ( false ) , eq ( emptyPingBuf ( ) ) , eq ( promise ) ) ; } @Test public void pingWriteShouldSucceed ( ) throws Exception { ChannelPromise promise = newPromise ( ) ; encoder . writePing ( ctx , false , emptyPingBuf ( ) , promise ) ; verify ( writer ) . writePing ( eq ( ctx ) , eq ( false ) , eq ( emptyPingBuf ( ) ) , eq ( promise ) ) ; } @Test public void settingsWriteAfterGoAwayShouldSucceed ( ) throws Exception { goAwayReceived ( <int> ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeSettings ( ctx , new Http2Settings ( ) , promise ) ; verify ( writer ) . writeSettings ( eq ( ctx ) , any ( Http2Settings . class ) , eq ( promise ) ) ; } @Test public void settingsWriteShouldNotUpdateSettings ( ) throws Exception { Http2Settings settings = new Http2Settings ( ) ; settings . initialWindowSize ( <int> ) ; settings . maxConcurrentStreams ( <int> ) ; settings . headerTableSize ( <int> ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeSettings ( ctx , settings , promise ) ; verify ( writer ) . writeSettings ( eq ( ctx ) , eq ( settings ) , eq ( promise ) ) ; } @Test public void dataWriteShouldCreateHalfClosedStream ( ) throws Exception { writeAllFlowControlledFrames ( ) ; Http2Stream stream = createStream ( STREAM_ID , false ) ; ByteBuf data = dummyData ( ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data . retain ( ) , <int> , true , promise ) ; assertTrue ( promise . isSuccess ( ) ) ; verify ( remoteFlow ) . addFlowControlled ( eq ( stream ) , any ( FlowControlled . class ) ) ; verify ( lifecycleManager ) . closeStreamLocal ( stream , promise ) ; assertEquals ( data . toString ( UTF_8 ) , writtenData . get ( <int> ) ) ; data . release ( ) ; } @Test public void headersWriteShouldHalfCloseStream ( ) throws Exception { writeAllFlowControlledFrames ( ) ; createStream ( STREAM_ID , false ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeHeaders ( ctx , STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , true , promise ) ; assertTrue ( promise . isSuccess ( ) ) ; verify ( lifecycleManager ) . closeStreamLocal ( eq ( stream ( STREAM_ID ) ) , eq ( promise ) ) ; } @Test public void headersWriteShouldHalfClosePushStream ( ) throws Exception { writeAllFlowControlledFrames ( ) ; Http2Stream parent = createStream ( STREAM_ID , false ) ; Http2Stream stream = reservePushStream ( PUSH_STREAM_ID , parent ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeHeaders ( ctx , PUSH_STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , true , promise ) ; assertEquals ( HALF_CLOSED_REMOTE , stream . state ( ) ) ; assertTrue ( promise . isSuccess ( ) ) ; verify ( lifecycleManager ) . closeStreamLocal ( eq ( stream ) , eq ( promise ) ) ; } @Test public void encoderDelegatesGoAwayToLifeCycleManager ( ) { ChannelPromise promise = newPromise ( ) ; encoder . writeGoAway ( ctx , STREAM_ID , Http2Error . INTERNAL_ERROR . code ( ) , null , promise ) ; verify ( lifecycleManager ) . goAway ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( Http2Error . INTERNAL_ERROR . code ( ) ) , eq ( ( ByteBuf ) null ) , eq ( promise ) ) ; verifyNoMoreInteractions ( writer ) ; } @Test public void dataWriteToClosedStreamShouldFail ( ) throws Exception { createStream ( STREAM_ID , false ) . close ( ) ; ByteBuf data = mock ( ByteBuf . class ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , false , promise ) ; assertTrue ( promise . isDone ( ) ) ; assertFalse ( promise . isSuccess ( ) ) ; assertThat ( promise . cause ( ) , instanceOf ( IllegalArgumentException . class ) ) ; verify ( data ) . release ( ) ; } @Test public void dataWriteToHalfClosedLocalStreamShouldFail ( ) throws Exception { createStream ( STREAM_ID , true ) ; ByteBuf data = mock ( ByteBuf . class ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , false , promise ) ; assertTrue ( promise . isDone ( ) ) ; assertFalse ( promise . isSuccess ( ) ) ; assertThat ( promise . cause ( ) , instanceOf ( IllegalStateException . class ) ) ; verify ( data ) . release ( ) ; } @Test public void canWriteDataFrameAfterGoAwaySent ( ) throws Exception { Http2Stream stream = createStream ( STREAM_ID , false ) ; connection . goAwaySent ( <int> , <int> , EMPTY_BUFFER ) ; ByteBuf data = mock ( ByteBuf . class ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , false , newPromise ( ) ) ; verify ( remoteFlow ) . addFlowControlled ( eq ( stream ) , any ( FlowControlled . class ) ) ; } @Test public void canWriteHeaderFrameAfterGoAwaySent ( ) throws Exception { writeAllFlowControlledFrames ( ) ; createStream ( STREAM_ID , false ) ; goAwaySent ( <int> ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeHeaders ( ctx , STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , false , promise ) ; verify ( writer ) . writeHeaders ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( EmptyHttp2Headers . INSTANCE ) , eq ( <int> ) , eq ( DEFAULT_PRIORITY_WEIGHT ) , eq ( false ) , eq ( <int> ) , eq ( false ) , eq ( promise ) ) ; } @Test public void canWriteDataFrameAfterGoAwayReceived ( ) throws Exception { Http2Stream stream = createStream ( STREAM_ID , false ) ; goAwayReceived ( STREAM_ID ) ; ByteBuf data = mock ( ByteBuf . class ) ; encoder . writeData ( ctx , STREAM_ID , data , <int> , false , newPromise ( ) ) ; verify ( remoteFlow ) . addFlowControlled ( eq ( stream ) , any ( FlowControlled . class ) ) ; } @Test public void canWriteHeaderFrameAfterGoAwayReceived ( ) { writeAllFlowControlledFrames ( ) ; goAwayReceived ( STREAM_ID ) ; ChannelPromise promise = newPromise ( ) ; encoder . writeHeaders ( ctx , STREAM_ID , EmptyHttp2Headers . INSTANCE , <int> , false , promise ) ; verify ( writer ) . writeHeaders ( eq ( ctx ) , eq ( STREAM_ID ) , eq ( EmptyHttp2Headers . INSTANCE ) , eq ( <int> ) , eq ( DEFAULT_PRIORITY_WEIGHT ) , eq ( false ) , eq ( <int> ) , eq ( false ) , eq ( promise ) ) ; } private void writeAllFlowControlledFrames ( ) { doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock invocationOnMock ) throws Throwable { FlowControlled flowControlled = ( FlowControlled ) invocationOnMock . getArguments ( ) [ <int> ] ; flowControlled . write ( ctx , Integer . MAX_VALUE ) ; flowControlled . writeComplete ( ) ; return null ; } } ) . when ( remoteFlow ) . addFlowControlled ( any ( Http2Stream . class ) , payloadCaptor . capture ( ) ) ; } private Http2Stream createStream ( int streamId , boolean halfClosed ) throws Http2Exception { return connection . local ( ) . createStream ( streamId , halfClosed ) ; } private Http2Stream reservePushStream ( int pushStreamId , Http2Stream parent ) throws Http2Exception { return connection . local ( ) . reservePushStream ( pushStreamId , parent ) ; } private Http2Stream stream ( int streamId ) { return connection . stream ( streamId ) ; } private void goAwayReceived ( int lastStreamId ) { connection . goAwayReceived ( lastStreamId , <int> , EMPTY_BUFFER ) ; } private void goAwaySent ( int lastStreamId ) { connection . goAwaySent ( lastStreamId , <int> , EMPTY_BUFFER ) ; } private ChannelPromise newPromise ( ) { return new DefaultChannelPromise ( channel , ImmediateEventExecutor . INSTANCE ) ; } private ChannelPromise newVoidPromise ( ) { return new DefaultChannelPromise ( channel , ImmediateEventExecutor . INSTANCE ) { @Override public ChannelPromise addListener ( GenericFutureListener < ? extends Future < ? super Void > > listener ) { throw new AssertionFailedError ( ) ; } @Override public ChannelPromise addListeners ( GenericFutureListener < ? extends Future < ? super Void > > . . . listeners ) { throw new AssertionFailedError ( ) ; } @Override public boolean isVoid ( ) { return true ; } } ; } private ChannelFuture newSucceededFuture ( ) { return newPromise ( ) . setSuccess ( ) ; } private static ByteBuf dummyData ( ) { return wrappedBuffer ( <str> . getBytes ( UTF_8 ) ) ; } } 
