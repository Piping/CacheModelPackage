package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . util . HashMap ; import java . util . Map ; import com . google . common . collect . ImmutableMap ; import org . apache . cassandra . cql3 . Term ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . SyntaxException ; import org . apache . cassandra . serializers . TypeSerializer ; import org . apache . cassandra . serializers . BytesSerializer ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . ByteBufferUtil ; public class ColumnToCollectionType extends AbstractType < ByteBuffer > { private static final Map < Map < ByteBuffer , CollectionType > , ColumnToCollectionType > instances = new HashMap < > ( ) ; public final Map < ByteBuffer , CollectionType > defined ; public static ColumnToCollectionType getInstance ( TypeParser parser ) throws SyntaxException , ConfigurationException { return getInstance ( parser . getCollectionsParameters ( ) ) ; } public static synchronized ColumnToCollectionType getInstance ( Map < ByteBuffer , CollectionType > defined ) { assert defined ! = null ; ColumnToCollectionType t = instances . get ( defined ) ; if ( t = = null ) { t = new ColumnToCollectionType ( defined ) ; instances . put ( defined , t ) ; } return t ; } private ColumnToCollectionType ( Map < ByteBuffer , CollectionType > defined ) { super ( ComparisonType . CUSTOM ) ; this . defined = ImmutableMap . copyOf ( defined ) ; } public int compareCustom ( ByteBuffer o1 , ByteBuffer o2 ) { throw new UnsupportedOperationException ( <str> ) ; } public int compareCollectionMembers ( ByteBuffer o1 , ByteBuffer o2 , ByteBuffer collectionName ) { CollectionType t = defined . get ( collectionName ) ; if ( t = = null ) throw new RuntimeException ( ByteBufferUtil . bytesToHex ( collectionName ) + <str> ) ; return t . nameComparator ( ) . compare ( o1 , o2 ) ; } public String getString ( ByteBuffer bytes ) { return BytesType . instance . getString ( bytes ) ; } public ByteBuffer fromString ( String source ) { try { return ByteBufferUtil . hexToBytes ( source ) ; } catch ( NumberFormatException e ) { throw new MarshalException ( String . format ( <str> , source ) , e ) ; } } @Override public Term fromJSONObject ( Object parsed ) throws MarshalException { throw new UnsupportedOperationException ( ) ; } @Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { throw new UnsupportedOperationException ( ) ; } @Override public void validate ( ByteBuffer bytes ) { throw new UnsupportedOperationException ( <str> ) ; } public TypeSerializer < ByteBuffer > getSerializer ( ) { return BytesSerializer . instance ; } public void validateCollectionMember ( ByteBuffer bytes , ByteBuffer collectionName ) throws MarshalException { CollectionType t = defined . get ( collectionName ) ; if ( t = = null ) throw new MarshalException ( ByteBufferUtil . bytesToHex ( collectionName ) + <str> ) ; t . nameComparator ( ) . validate ( bytes ) ; } @Override public boolean isCompatibleWith ( AbstractType < ? > previous ) { if ( ! ( previous instanceof ColumnToCollectionType ) ) return false ; ColumnToCollectionType prev = ( ColumnToCollectionType ) previous ; for ( Map . Entry < ByteBuffer , CollectionType > entry : prev . defined . entrySet ( ) ) { CollectionType newType = defined . get ( entry . getKey ( ) ) ; if ( newType = = null | | ! newType . isCompatibleWith ( entry . getValue ( ) ) ) return false ; } return true ; } @Override public String toString ( ) { return getClass ( ) . getName ( ) + TypeParser . stringifyCollectionsParameters ( defined ) ; } } 
