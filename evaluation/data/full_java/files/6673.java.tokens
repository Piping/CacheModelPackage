package org . elasticsearch . index . query ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . xcontent . XContentParser ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public class SpanNearQueryParser implements QueryParser < SpanNearQueryBuilder > { public static final ParseField SLOP_FIELD = new ParseField ( <str> ) ; public static final ParseField COLLECT_PAYLOADS_FIELD = new ParseField ( <str> ) ; public static final ParseField CLAUSES_FIELD = new ParseField ( <str> ) ; public static final ParseField IN_ORDER_FIELD = new ParseField ( <str> ) ; @Override public String [ ] names ( ) { return new String [ ] { SpanNearQueryBuilder . NAME , Strings . toCamelCase ( SpanNearQueryBuilder . NAME ) } ; } @Override public SpanNearQueryBuilder fromXContent ( QueryParseContext parseContext ) throws IOException { XContentParser parser = parseContext . parser ( ) ; float boost = AbstractQueryBuilder . DEFAULT_BOOST ; Integer slop = null ; boolean inOrder = SpanNearQueryBuilder . DEFAULT_IN_ORDER ; boolean collectPayloads = SpanNearQueryBuilder . DEFAULT_COLLECT_PAYLOADS ; String queryName = null ; List < SpanQueryBuilder > clauses = new ArrayList < > ( ) ; String currentFieldName = null ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , CLAUSES_FIELD ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { QueryBuilder query = parseContext . parseInnerQueryBuilder ( ) ; if ( ! ( query instanceof SpanQueryBuilder ) ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } clauses . add ( ( SpanQueryBuilder ) query ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } else if ( token . isValue ( ) ) { if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , IN_ORDER_FIELD ) ) { inOrder = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , COLLECT_PAYLOADS_FIELD ) ) { collectPayloads = parser . booleanValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , SLOP_FIELD ) ) { slop = parser . intValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , AbstractQueryBuilder . BOOST_FIELD ) ) { boost = parser . floatValue ( ) ; } else if ( parseContext . parseFieldMatcher ( ) . match ( currentFieldName , AbstractQueryBuilder . NAME_FIELD ) ) { queryName = parser . text ( ) ; } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + currentFieldName + <str> ) ; } } if ( clauses . isEmpty ( ) ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } if ( slop = = null ) { throw new ParsingException ( parser . getTokenLocation ( ) , <str> ) ; } SpanNearQueryBuilder queryBuilder = new SpanNearQueryBuilder ( clauses . get ( <int> ) , slop ) ; for ( int i = <int> ; i < clauses . size ( ) ; i + + ) { queryBuilder . clause ( clauses . get ( i ) ) ; } queryBuilder . inOrder ( inOrder ) ; queryBuilder . collectPayloads ( collectPayloads ) ; queryBuilder . boost ( boost ) ; queryBuilder . queryName ( queryName ) ; return queryBuilder ; } @Override public SpanNearQueryBuilder getBuilderPrototype ( ) { return SpanNearQueryBuilder . PROTOTYPE ; } } 
