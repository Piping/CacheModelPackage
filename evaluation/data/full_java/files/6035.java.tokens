package org . elasticsearch . common . recycler ; import com . carrotsearch . hppc . BitMixer ; import java . util . ArrayDeque ; public enum Recyclers { ; public static < T > Recycler < T > none ( Recycler . C < T > c ) { return new NoneRecycler < > ( c ) ; } public static < T > Recycler < T > concurrentDeque ( Recycler . C < T > c , int limit ) { return new ConcurrentDequeRecycler < > ( c , limit ) ; } public static < T > Recycler < T > deque ( Recycler . C < T > c , int limit ) { return new DequeRecycler < > ( c , new ArrayDeque < > ( ) , limit ) ; } public static < T > Recycler . Factory < T > dequeFactory ( final Recycler . C < T > c , final int limit ) { return new Recycler . Factory < T > ( ) { @Override public Recycler < T > build ( ) { return deque ( c , limit ) ; } } ; } public static < T > Recycler < T > sizing ( final Recycler < T > defaultRecycler , final Recycler < T > smallObjectRecycler , final int minSize ) { return new FilterRecycler < T > ( ) { @Override protected Recycler < T > getDelegate ( ) { return defaultRecycler ; } @Override public Recycler . V < T > obtain ( int sizing ) { if ( sizing > <int> & & sizing < minSize ) { return smallObjectRecycler . obtain ( sizing ) ; } return super . obtain ( sizing ) ; } @Override public void close ( ) { defaultRecycler . close ( ) ; smallObjectRecycler . close ( ) ; } } ; } public static < T > Recycler < T > locked ( final Recycler < T > recycler ) { return new FilterRecycler < T > ( ) { private final Object lock ; { this . lock = new Object ( ) ; } @Override protected Recycler < T > getDelegate ( ) { return recycler ; } @Override public org . elasticsearch . common . recycler . Recycler . V < T > obtain ( int sizing ) { synchronized ( lock ) { return super . obtain ( sizing ) ; } } @Override public org . elasticsearch . common . recycler . Recycler . V < T > obtain ( ) { synchronized ( lock ) { return super . obtain ( ) ; } } @Override protected Recycler . V < T > wrap ( final Recycler . V < T > delegate ) { return new Recycler . V < T > ( ) { @Override public void close ( ) { synchronized ( lock ) { delegate . close ( ) ; } } @Override public T v ( ) { return delegate . v ( ) ; } @Override public boolean isRecycled ( ) { return delegate . isRecycled ( ) ; } } ; } } ; } public static < T > Recycler < T > concurrent ( final Recycler . Factory < T > factory , final int concurrencyLevel ) { if ( concurrencyLevel < <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( concurrencyLevel = = <int> ) { return locked ( factory . build ( ) ) ; } return new FilterRecycler < T > ( ) { private final Recycler < T > [ ] recyclers ; { @SuppressWarnings ( <str> ) final Recycler < T > [ ] recyclers = new Recycler [ concurrencyLevel ] ; this . recyclers = recyclers ; for ( int i = <int> ; i < concurrencyLevel ; + + i ) { recyclers [ i ] = locked ( factory . build ( ) ) ; } } final int slot ( ) { final long id = Thread . currentThread ( ) . getId ( ) ; int slot = ( int ) BitMixer . mix64 ( id ) ; slot & = <hex> ; slot % = concurrencyLevel ; return slot ; } @Override protected Recycler < T > getDelegate ( ) { return recyclers [ slot ( ) ] ; } @Override public void close ( ) { for ( Recycler < T > recycler : recyclers ) { recycler . close ( ) ; } } } ; } public static < T > Recycler < T > concurrent ( final Recycler . Factory < T > factory ) { return concurrent ( factory , Runtime . getRuntime ( ) . availableProcessors ( ) ) ; } } 
