package clojure . lang ; import java . io . Serializable ; import java . util . Arrays ; import java . util . Iterator ; import java . util . Map ; import java . util . NoSuchElementException ; public class PersistentArrayMap extends APersistentMap implements IObj , IEditableCollection , IMapIterable , IKVReduce { final Object [ ] array ; static final int HASHTABLE_THRESHOLD = <int> ; public static final PersistentArrayMap EMPTY = new PersistentArrayMap ( ) ; private final IPersistentMap _meta ; static public IPersistentMap create ( Map other ) { ITransientMap ret = EMPTY . asTransient ( ) ; for ( Object o : other . entrySet ( ) ) { Map . Entry e = ( Entry ) o ; ret = ret . assoc ( e . getKey ( ) , e . getValue ( ) ) ; } return ret . persistent ( ) ; } protected PersistentArrayMap ( ) { this . array = new Object [ ] { } ; this . _meta = null ; } public PersistentArrayMap withMeta ( IPersistentMap meta ) { return new PersistentArrayMap ( meta , array ) ; } PersistentArrayMap create ( Object . . . init ) { return new PersistentArrayMap ( meta ( ) , init ) ; } IPersistentMap createHT ( Object [ ] init ) { return PersistentHashMap . create ( meta ( ) , init ) ; } static public PersistentArrayMap createWithCheck ( Object [ ] init ) { for ( int i = <int> ; i < init . length ; i + = <int> ) { for ( int j = i + <int> ; j < init . length ; j + = <int> ) { if ( equalKey ( init [ i ] , init [ j ] ) ) throw new IllegalArgumentException ( <str> + init [ i ] ) ; } } return new PersistentArrayMap ( init ) ; } static public PersistentArrayMap createAsIfByAssoc ( Object [ ] init ) { if ( ( init . length & <int> ) = = <int> ) throw new IllegalArgumentException ( String . format ( <str> , init [ init . length - <int> ] ) ) ; int n = <int> ; for ( int i = <int> ; i < init . length ; i + = <int> ) { boolean duplicateKey = false ; for ( int j = <int> ; j < i ; j + = <int> ) { if ( equalKey ( init [ i ] , init [ j ] ) ) { duplicateKey = true ; break ; } } if ( ! duplicateKey ) n + = <int> ; } if ( n < init . length ) { Object [ ] nodups = new Object [ n ] ; int m = <int> ; for ( int i = <int> ; i < init . length ; i + = <int> ) { boolean duplicateKey = false ; for ( int j = <int> ; j < m ; j + = <int> ) { if ( equalKey ( init [ i ] , nodups [ j ] ) ) { duplicateKey = true ; break ; } } if ( ! duplicateKey ) { int j ; for ( j = init . length - <int> ; j > = i ; j - = <int> ) { if ( equalKey ( init [ i ] , init [ j ] ) ) { break ; } } nodups [ m ] = init [ i ] ; nodups [ m + <int> ] = init [ j + <int> ] ; m + = <int> ; } } if ( m ! = n ) throw new IllegalArgumentException ( <str> + m ) ; init = nodups ; } return new PersistentArrayMap ( init ) ; } public PersistentArrayMap ( Object [ ] init ) { this . array = init ; this . _meta = null ; } public PersistentArrayMap ( IPersistentMap meta , Object [ ] init ) { this . _meta = meta ; this . array = init ; } public int count ( ) { return array . length / <int> ; } public boolean containsKey ( Object key ) { return indexOf ( key ) > = <int> ; } public IMapEntry entryAt ( Object key ) { int i = indexOf ( key ) ; if ( i > = <int> ) return ( IMapEntry ) Tuple . create ( array [ i ] , array [ i + <int> ] ) ; return null ; } public IPersistentMap assocEx ( Object key , Object val ) { int i = indexOf ( key ) ; Object [ ] newArray ; if ( i > = <int> ) { throw Util . runtimeException ( <str> ) ; } else { if ( array . length > HASHTABLE_THRESHOLD ) return createHT ( array ) . assocEx ( key , val ) ; newArray = new Object [ array . length + <int> ] ; if ( array . length > <int> ) System . arraycopy ( array , <int> , newArray , <int> , array . length ) ; newArray [ <int> ] = key ; newArray [ <int> ] = val ; } return create ( newArray ) ; } public IPersistentMap assoc ( Object key , Object val ) { int i = indexOf ( key ) ; Object [ ] newArray ; if ( i > = <int> ) { if ( array [ i + <int> ] = = val ) return this ; newArray = array . clone ( ) ; newArray [ i + <int> ] = val ; } else { if ( array . length > HASHTABLE_THRESHOLD ) return createHT ( array ) . assoc ( key , val ) ; newArray = new Object [ array . length + <int> ] ; if ( array . length > <int> ) System . arraycopy ( array , <int> , newArray , <int> , array . length ) ; newArray [ newArray . length - <int> ] = key ; newArray [ newArray . length - <int> ] = val ; } return create ( newArray ) ; } public IPersistentMap without ( Object key ) { int i = indexOf ( key ) ; if ( i > = <int> ) { int newlen = array . length - <int> ; if ( newlen = = <int> ) return empty ( ) ; Object [ ] newArray = new Object [ newlen ] ; System . arraycopy ( array , <int> , newArray , <int> , i ) ; System . arraycopy ( array , i + <int> , newArray , i , newlen - i ) ; return create ( newArray ) ; } return this ; } public IPersistentMap empty ( ) { return ( IPersistentMap ) EMPTY . withMeta ( meta ( ) ) ; } final public Object valAt ( Object key , Object notFound ) { int i = indexOf ( key ) ; if ( i > = <int> ) return array [ i + <int> ] ; return notFound ; } public Object valAt ( Object key ) { return valAt ( key , null ) ; } public int capacity ( ) { return count ( ) ; } private int indexOfObject ( Object key ) { Util . EquivPred ep = Util . equivPred ( key ) ; for ( int i = <int> ; i < array . length ; i + = <int> ) { if ( ep . equiv ( key , array [ i ] ) ) return i ; } return - <int> ; } private int indexOf ( Object key ) { if ( key instanceof Keyword ) { for ( int i = <int> ; i < array . length ; i + = <int> ) { if ( key = = array [ i ] ) return i ; } return - <int> ; } else return indexOfObject ( key ) ; } static boolean equalKey ( Object k1 , Object k2 ) { if ( k1 instanceof Keyword ) return k1 = = k2 ; return Util . equiv ( k1 , k2 ) ; } public Iterator iterator ( ) { return new Iter ( array , APersistentMap . MAKE_ENTRY ) ; } public Iterator keyIterator ( ) { return new Iter ( array , APersistentMap . MAKE_KEY ) ; } public Iterator valIterator ( ) { return new Iter ( array , APersistentMap . MAKE_VAL ) ; } public ISeq seq ( ) { if ( array . length > <int> ) return new Seq ( array , <int> ) ; return null ; } public IPersistentMap meta ( ) { return _meta ; } static class Seq extends ASeq implements Counted { final Object [ ] array ; final int i ; Seq ( Object [ ] array , int i ) { this . array = array ; this . i = i ; } public Seq ( IPersistentMap meta , Object [ ] array , int i ) { super ( meta ) ; this . array = array ; this . i = i ; } public Object first ( ) { return Tuple . create ( array [ i ] , array [ i + <int> ] ) ; } public ISeq next ( ) { if ( i + <int> < array . length ) return new Seq ( array , i + <int> ) ; return null ; } public int count ( ) { return ( array . length - i ) / <int> ; } public Obj withMeta ( IPersistentMap meta ) { return new Seq ( meta , array , i ) ; } } static class Iter implements Iterator { IFn f ; Object [ ] array ; int i ; Iter ( Object [ ] array , IFn f ) { this ( array , - <int> , f ) ; } Iter ( Object [ ] array , int i , IFn f ) { this . array = array ; this . i = i ; this . f = f ; } public boolean hasNext ( ) { return i < array . length - <int> ; } public Object next ( ) { try { i + = <int> ; return f . invoke ( array [ i ] , array [ i + <int> ] ) ; } catch ( IndexOutOfBoundsException e ) { throw new NoSuchElementException ( ) ; } } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } public Object kvreduce ( IFn f , Object init ) { for ( int i = <int> ; i < array . length ; i + = <int> ) { init = f . invoke ( init , array [ i ] , array [ i + <int> ] ) ; if ( RT . isReduced ( init ) ) return ( ( IDeref ) init ) . deref ( ) ; } return init ; } public ITransientMap asTransient ( ) { return new TransientArrayMap ( array ) ; } static final class TransientArrayMap extends ATransientMap { volatile int len ; final Object [ ] array ; volatile Thread owner ; public TransientArrayMap ( Object [ ] array ) { this . owner = Thread . currentThread ( ) ; this . array = new Object [ Math . max ( HASHTABLE_THRESHOLD , array . length ) ] ; System . arraycopy ( array , <int> , this . array , <int> , array . length ) ; this . len = array . length ; } private int indexOf ( Object key ) { for ( int i = <int> ; i < len ; i + = <int> ) { if ( equalKey ( array [ i ] , key ) ) return i ; } return - <int> ; } ITransientMap doAssoc ( Object key , Object val ) { int i = indexOf ( key ) ; if ( i > = <int> ) { if ( array [ i + <int> ] ! = val ) array [ i + <int> ] = val ; } else { if ( len > = array . length ) return PersistentHashMap . create ( array ) . asTransient ( ) . assoc ( key , val ) ; array [ len + + ] = key ; array [ len + + ] = val ; } return this ; } ITransientMap doWithout ( Object key ) { int i = indexOf ( key ) ; if ( i > = <int> ) { if ( len > = <int> ) { array [ i ] = array [ len - <int> ] ; array [ i + <int> ] = array [ len - <int> ] ; } len - = <int> ; } return this ; } Object doValAt ( Object key , Object notFound ) { int i = indexOf ( key ) ; if ( i > = <int> ) return array [ i + <int> ] ; return notFound ; } int doCount ( ) { return len / <int> ; } IPersistentMap doPersistent ( ) { ensureEditable ( ) ; owner = null ; Object [ ] a = new Object [ len ] ; System . arraycopy ( array , <int> , a , <int> , len ) ; return new PersistentArrayMap ( a ) ; } void ensureEditable ( ) { if ( owner = = null ) throw new IllegalAccessError ( <str> ) ; } } } 
