package org . apache . cassandra . dht ; import java . io . Serializable ; import java . util . * ; import org . apache . commons . lang3 . ObjectUtils ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . utils . Pair ; public class Range < T extends RingPosition < T > > extends AbstractBounds < T > implements Comparable < Range < T > > , Serializable { public static final long serialVersionUID = <int> ; public Range ( T left , T right ) { super ( left , right ) ; } public static < T extends RingPosition < T > > boolean contains ( T left , T right , T point ) { if ( isWrapAround ( left , right ) ) { if ( point . compareTo ( left ) > <int> ) return true ; else return right . compareTo ( point ) > = <int> ; } else { return point . compareTo ( left ) > <int> & & right . compareTo ( point ) > = <int> ; } } public boolean contains ( Range < T > that ) { if ( this . left . equals ( this . right ) ) { return true ; } boolean thiswraps = isWrapAround ( left , right ) ; boolean thatwraps = isWrapAround ( that . left , that . right ) ; if ( thiswraps = = thatwraps ) { return left . compareTo ( that . left ) < = <int> & & that . right . compareTo ( right ) < = <int> ; } else if ( thiswraps ) { return left . compareTo ( that . left ) < = <int> | | that . right . compareTo ( right ) < = <int> ; } else { return false ; } } public boolean contains ( T point ) { return contains ( left , right , point ) ; } public boolean intersects ( Range < T > that ) { return intersectionWith ( that ) . size ( ) > <int> ; } public boolean intersects ( AbstractBounds < T > that ) { if ( that instanceof Range ) return intersects ( ( Range < T > ) that ) ; if ( that instanceof Bounds ) return intersects ( ( Bounds < T > ) that ) ; throw new UnsupportedOperationException ( <str> + that . getClass ( ) ) ; } public boolean intersects ( Bounds < T > that ) { return contains ( that . left ) | | ( ! that . left . equals ( that . right ) & & intersects ( new Range < T > ( that . left , that . right ) ) ) ; } @SafeVarargs public static < T extends RingPosition < T > > Set < Range < T > > rangeSet ( Range < T > . . . ranges ) { return Collections . unmodifiableSet ( new HashSet < Range < T > > ( Arrays . asList ( ranges ) ) ) ; } public static < T extends RingPosition < T > > Set < Range < T > > rangeSet ( Range < T > range ) { return Collections . singleton ( range ) ; } public Set < Range < T > > intersectionWith ( Range < T > that ) { if ( that . contains ( this ) ) return rangeSet ( this ) ; if ( this . contains ( that ) ) return rangeSet ( that ) ; boolean thiswraps = isWrapAround ( left , right ) ; boolean thatwraps = isWrapAround ( that . left , that . right ) ; if ( ! thiswraps & & ! thatwraps ) { if ( ! ( left . compareTo ( that . right ) < <int> & & that . left . compareTo ( right ) < <int> ) ) return Collections . emptySet ( ) ; return rangeSet ( new Range < T > ( ObjectUtils . max ( this . left , that . left ) , ObjectUtils . min ( this . right , that . right ) ) ) ; } if ( thiswraps & & thatwraps ) { assert ! this . left . equals ( that . left ) ; return this . left . compareTo ( that . left ) < <int> ? intersectionBothWrapping ( this , that ) : intersectionBothWrapping ( that , this ) ; } if ( thiswraps & & ! thatwraps ) return intersectionOneWrapping ( this , that ) ; assert ( ! thiswraps & & thatwraps ) ; return intersectionOneWrapping ( that , this ) ; } private static < T extends RingPosition < T > > Set < Range < T > > intersectionBothWrapping ( Range < T > first , Range < T > that ) { Set < Range < T > > intersection = new HashSet < Range < T > > ( <int> ) ; if ( that . right . compareTo ( first . left ) > <int> ) intersection . add ( new Range < T > ( first . left , that . right ) ) ; intersection . add ( new Range < T > ( that . left , first . right ) ) ; return Collections . unmodifiableSet ( intersection ) ; } private static < T extends RingPosition < T > > Set < Range < T > > intersectionOneWrapping ( Range < T > wrapping , Range < T > other ) { Set < Range < T > > intersection = new HashSet < Range < T > > ( <int> ) ; if ( other . contains ( wrapping . right ) ) intersection . add ( new Range < T > ( other . left , wrapping . right ) ) ; if ( other . contains ( wrapping . left ) & & wrapping . left . compareTo ( other . right ) < <int> ) intersection . add ( new Range < T > ( wrapping . left , other . right ) ) ; return Collections . unmodifiableSet ( intersection ) ; } public Pair < AbstractBounds < T > , AbstractBounds < T > > split ( T position ) { assert contains ( position ) | | left . equals ( position ) ; if ( position . equals ( left ) | | position . equals ( right ) ) return null ; AbstractBounds < T > lb = new Range < T > ( left , position ) ; AbstractBounds < T > rb = new Range < T > ( position , right ) ; return Pair . create ( lb , rb ) ; } public boolean inclusiveLeft ( ) { return false ; } public boolean inclusiveRight ( ) { return true ; } public List < Range < T > > unwrap ( ) { T minValue = right . minValue ( ) ; if ( ! isWrapAround ( ) | | right . equals ( minValue ) ) return Arrays . asList ( this ) ; List < Range < T > > unwrapped = new ArrayList < Range < T > > ( <int> ) ; unwrapped . add ( new Range < T > ( left , minValue ) ) ; unwrapped . add ( new Range < T > ( minValue , right ) ) ; return unwrapped ; } public static < T extends RingPosition < T > > boolean isWrapAround ( T left , T right ) { return left . compareTo ( right ) > = <int> ; } public int compareTo ( Range < T > rhs ) { if ( isWrapAround ( left , right ) ) return - <int> ; if ( isWrapAround ( rhs . left , rhs . right ) ) return <int> ; return right . compareTo ( rhs . right ) ; } private ArrayList < Range < T > > subtractContained ( Range < T > contained ) { ArrayList < Range < T > > difference = new ArrayList < Range < T > > ( <int> ) ; if ( ! left . equals ( contained . left ) ) difference . add ( new Range < T > ( left , contained . left ) ) ; if ( ! right . equals ( contained . right ) ) difference . add ( new Range < T > ( contained . right , right ) ) ; return difference ; } public Set < Range < T > > subtract ( Range < T > rhs ) { return rhs . differenceToFetch ( this ) ; } public Set < Range < T > > differenceToFetch ( Range < T > rhs ) { Set < Range < T > > result ; Set < Range < T > > intersectionSet = this . intersectionWith ( rhs ) ; if ( intersectionSet . isEmpty ( ) ) { result = new HashSet < Range < T > > ( ) ; result . add ( rhs ) ; } else { @SuppressWarnings ( <str> ) Range < T > [ ] intersections = new Range [ intersectionSet . size ( ) ] ; intersectionSet . toArray ( intersections ) ; if ( intersections . length = = <int> ) { result = new HashSet < Range < T > > ( rhs . subtractContained ( intersections [ <int> ] ) ) ; } else { Range < T > first = intersections [ <int> ] ; Range < T > second = intersections [ <int> ] ; ArrayList < Range < T > > temp = rhs . subtractContained ( first ) ; Range < T > single = temp . get ( <int> ) ; result = new HashSet < Range < T > > ( single . subtractContained ( second ) ) ; } } return result ; } public static < T extends RingPosition < T > > boolean isInRanges ( T token , Iterable < Range < T > > ranges ) { assert ranges ! = null ; for ( Range < T > range : ranges ) { if ( range . contains ( token ) ) { return true ; } } return false ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof Range ) ) return false ; Range < ? > rhs = ( Range < ? > ) o ; return left . equals ( rhs . left ) & & right . equals ( rhs . right ) ; } @Override public String toString ( ) { return <str> + left + <str> + right + <str> ; } protected String getOpeningString ( ) { return <str> ; } protected String getClosingString ( ) { return <str> ; } public boolean isStartInclusive ( ) { return false ; } public boolean isEndInclusive ( ) { return true ; } public List < String > asList ( ) { ArrayList < String > ret = new ArrayList < String > ( <int> ) ; ret . add ( left . toString ( ) ) ; ret . add ( right . toString ( ) ) ; return ret ; } public boolean isWrapAround ( ) { return isWrapAround ( left , right ) ; } public static < T extends RingPosition < T > > List < Range < T > > normalize ( Collection < Range < T > > ranges ) { List < Range < T > > output = new ArrayList < Range < T > > ( ranges . size ( ) ) ; for ( Range < T > range : ranges ) output . addAll ( range . unwrap ( ) ) ; Collections . sort ( output , new Comparator < Range < T > > ( ) { public int compare ( Range < T > b1 , Range < T > b2 ) { return b1 . left . compareTo ( b2 . left ) ; } } ) ; return deoverlap ( output ) ; } private static < T extends RingPosition < T > > List < Range < T > > deoverlap ( List < Range < T > > ranges ) { if ( ranges . isEmpty ( ) ) return ranges ; List < Range < T > > output = new ArrayList < Range < T > > ( ) ; Iterator < Range < T > > iter = ranges . iterator ( ) ; Range < T > current = iter . next ( ) ; T min = current . left . minValue ( ) ; while ( iter . hasNext ( ) ) { if ( current . right . equals ( min ) ) { if ( current . left . equals ( min ) ) return Collections . < Range < T > > singletonList ( current ) ; output . add ( new Range < T > ( current . left , min ) ) ; return output ; } Range < T > next = iter . next ( ) ; if ( next . left . compareTo ( current . right ) < = <int> ) { if ( next . right . equals ( min ) | | current . right . compareTo ( next . right ) < <int> ) current = new Range < T > ( current . left , next . right ) ; } else { output . add ( current ) ; current = next ; } } output . add ( current ) ; return output ; } public AbstractBounds < T > withNewRight ( T newRight ) { return new Range < T > ( left , newRight ) ; } public static Range < PartitionPosition > makeRowRange ( Token left , Token right ) { return new Range < PartitionPosition > ( left . maxKeyBound ( ) , right . maxKeyBound ( ) ) ; } public static Range < PartitionPosition > makeRowRange ( Range < Token > tokenBounds ) { return makeRowRange ( tokenBounds . left , tokenBounds . right ) ; } public static class OrderedRangeContainmentChecker { private final Iterator < Range < Token > > normalizedRangesIterator ; private Token lastToken = null ; private Range < Token > currentRange ; public OrderedRangeContainmentChecker ( Collection < Range < Token > > ranges ) { normalizedRangesIterator = normalize ( ranges ) . iterator ( ) ; assert normalizedRangesIterator . hasNext ( ) ; currentRange = normalizedRangesIterator . next ( ) ; } public boolean contains ( Token t ) { assert lastToken = = null | | lastToken . compareTo ( t ) < = <int> ; lastToken = t ; while ( true ) { if ( t . compareTo ( currentRange . left ) < = <int> ) return false ; else if ( t . compareTo ( currentRange . right ) < = <int> | | currentRange . right . compareTo ( currentRange . left ) < = <int> ) return true ; if ( ! normalizedRangesIterator . hasNext ( ) ) return false ; currentRange = normalizedRangesIterator . next ( ) ; } } } } 
