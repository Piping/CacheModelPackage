package org . elasticsearch . action . percolate ; import org . elasticsearch . action . ShardOperationFailedException ; import org . elasticsearch . action . support . broadcast . BroadcastResponse ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . text . Text ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . percolator . PercolatorService ; import org . elasticsearch . rest . action . support . RestActions ; import org . elasticsearch . search . aggregations . InternalAggregations ; import org . elasticsearch . search . highlight . HighlightField ; import java . io . IOException ; import java . util . * ; public class PercolateResponse extends BroadcastResponse implements Iterable < PercolateResponse . Match > , ToXContent { public static final Match [ ] EMPTY = new Match [ <int> ] ; private long tookInMillis ; private Match [ ] matches ; private long count ; private InternalAggregations aggregations ; PercolateResponse ( int totalShards , int successfulShards , int failedShards , List < ShardOperationFailedException > shardFailures , Match [ ] matches , long count , long tookInMillis , InternalAggregations aggregations ) { super ( totalShards , successfulShards , failedShards , shardFailures ) ; if ( tookInMillis < <int> ) { throw new IllegalArgumentException ( <str> + tookInMillis ) ; } this . tookInMillis = tookInMillis ; this . matches = matches ; this . count = count ; this . aggregations = aggregations ; } PercolateResponse ( int totalShards , int successfulShards , int failedShards , List < ShardOperationFailedException > shardFailures , long tookInMillis , Match [ ] matches ) { super ( totalShards , successfulShards , failedShards , shardFailures ) ; if ( tookInMillis < <int> ) { throw new IllegalArgumentException ( <str> + tookInMillis ) ; } this . tookInMillis = tookInMillis ; this . matches = matches ; } PercolateResponse ( ) { } public TimeValue getTook ( ) { return new TimeValue ( tookInMillis ) ; } public long getTookInMillis ( ) { return tookInMillis ; } public Match [ ] getMatches ( ) { return this . matches ; } public long getCount ( ) { return count ; } public InternalAggregations getAggregations ( ) { return aggregations ; } @Override public Iterator < Match > iterator ( ) { return Arrays . asList ( matches ) . iterator ( ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( Fields . TOOK , tookInMillis ) ; RestActions . buildBroadcastShardsHeader ( builder , params , this ) ; builder . field ( Fields . TOTAL , count ) ; if ( matches ! = null ) { builder . startArray ( Fields . MATCHES ) ; boolean justIds = <str> . equals ( params . param ( <str> ) ) ; if ( justIds ) { for ( PercolateResponse . Match match : matches ) { builder . value ( match . getId ( ) ) ; } } else { for ( PercolateResponse . Match match : matches ) { builder . startObject ( ) ; builder . field ( Fields . _INDEX , match . getIndex ( ) ) ; builder . field ( Fields . _ID , match . getId ( ) ) ; float score = match . getScore ( ) ; if ( score ! = PercolatorService . NO_SCORE ) { builder . field ( Fields . _SCORE , match . getScore ( ) ) ; } if ( match . getHighlightFields ( ) ! = null ) { builder . startObject ( Fields . HIGHLIGHT ) ; for ( HighlightField field : match . getHighlightFields ( ) . values ( ) ) { builder . field ( field . name ( ) ) ; if ( field . fragments ( ) = = null ) { builder . nullValue ( ) ; } else { builder . startArray ( ) ; for ( Text fragment : field . fragments ( ) ) { builder . value ( fragment ) ; } builder . endArray ( ) ; } } builder . endObject ( ) ; } builder . endObject ( ) ; } } builder . endArray ( ) ; } if ( aggregations ! = null ) { aggregations . toXContent ( builder , params ) ; } return builder ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; tookInMillis = in . readVLong ( ) ; count = in . readVLong ( ) ; int size = in . readVInt ( ) ; if ( size ! = - <int> ) { matches = new Match [ size ] ; for ( int i = <int> ; i < size ; i + + ) { matches [ i ] = new Match ( ) ; matches [ i ] . readFrom ( in ) ; } } aggregations = InternalAggregations . readOptionalAggregations ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVLong ( tookInMillis ) ; out . writeVLong ( count ) ; if ( matches = = null ) { out . writeVInt ( - <int> ) ; } else { out . writeVInt ( matches . length ) ; for ( Match match : matches ) { match . writeTo ( out ) ; } } out . writeOptionalStreamable ( aggregations ) ; } public static class Match implements Streamable { private Text index ; private Text id ; private float score ; private Map < String , HighlightField > hl ; public Match ( Text index , Text id , float score , Map < String , HighlightField > hl ) { this . id = id ; this . score = score ; this . index = index ; this . hl = hl ; } public Match ( Text index , Text id , float score ) { this . id = id ; this . score = score ; this . index = index ; } Match ( ) { } public Text getIndex ( ) { return index ; } public Text getId ( ) { return id ; } public float getScore ( ) { return score ; } @Nullable public Map < String , HighlightField > getHighlightFields ( ) { return hl ; } @Override public void readFrom ( StreamInput in ) throws IOException { id = in . readText ( ) ; index = in . readText ( ) ; score = in . readFloat ( ) ; int size = in . readVInt ( ) ; if ( size > <int> ) { hl = new HashMap < > ( size ) ; for ( int j = <int> ; j < size ; j + + ) { hl . put ( in . readString ( ) , HighlightField . readHighlightField ( in ) ) ; } } } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeText ( id ) ; out . writeText ( index ) ; out . writeFloat ( score ) ; if ( hl ! = null ) { out . writeVInt ( hl . size ( ) ) ; for ( Map . Entry < String , HighlightField > entry : hl . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; entry . getValue ( ) . writeTo ( out ) ; } } else { out . writeVInt ( <int> ) ; } } } static final class Fields { static final XContentBuilderString TOOK = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MATCHES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString _INDEX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString _ID = new XContentBuilderString ( <str> ) ; static final XContentBuilderString _SCORE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString HIGHLIGHT = new XContentBuilderString ( <str> ) ; } } 
