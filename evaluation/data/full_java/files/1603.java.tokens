package org . apache . cassandra . schema ; import java . io . File ; import java . nio . ByteBuffer ; import java . util . HashMap ; import java . util . Map ; import java . util . function . Supplier ; import com . google . common . collect . ImmutableMap ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . locator . OldNetworkTopologyStrategy ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . utils . FBUtilities ; import static org . apache . cassandra . Util . throwAssert ; import static org . apache . cassandra . cql3 . CQLTester . assertRows ; import static org . apache . cassandra . cql3 . CQLTester . row ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class DefsTest { private static final String KEYSPACE1 = <str> ; private static final String KEYSPACE3 = <str> ; private static final String KEYSPACE6 = <str> ; private static final String EMPTY_KEYSPACE = <str> ; private static final String TABLE1 = <str> ; private static final String TABLE2 = <str> ; private static final String TABLE1i = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . startGossiper ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , TABLE1 ) , SchemaLoader . standardCFMD ( KEYSPACE1 , TABLE2 ) ) ; SchemaLoader . createKeyspace ( KEYSPACE3 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , TABLE1 ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE3 , TABLE1i , true ) ) ; SchemaLoader . createKeyspace ( KEYSPACE6 , KeyspaceParams . simple ( <int> ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE6 , TABLE1i , true ) ) ; } @Test public void testCFMetaDataApply ( ) throws ConfigurationException { CFMetaData cfm = CFMetaData . Builder . create ( KEYSPACE1 , <str> ) . addPartitionKey ( <str> , BytesType . instance ) . addClusteringColumn ( <str> , BytesType . instance ) . build ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { ByteBuffer name = ByteBuffer . wrap ( new byte [ ] { ( byte ) i } ) ; cfm . addColumnDefinition ( ColumnDefinition . regularDef ( cfm , name , BytesType . instance ) ) ; } cfm . comment ( <str> ) . readRepairChance ( <float> ) . gcGraceSeconds ( <int> ) . compaction ( CompactionParams . scts ( ImmutableMap . of ( <str> , <str> , <str> , <str> ) ) ) ; assertNull ( cfm . getColumnDefinition ( ByteBuffer . wrap ( new byte [ ] { <int> } ) ) ) ; CFMetaData cfNew = cfm . copy ( ) ; ColumnDefinition addIndexDef = ColumnDefinition . regularDef ( cfm , ByteBuffer . wrap ( new byte [ ] { <int> } ) , BytesType . instance ) ; cfNew . addColumnDefinition ( addIndexDef ) ; ColumnDefinition removeIndexDef = ColumnDefinition . regularDef ( cfm , ByteBuffer . wrap ( new byte [ ] { <int> } ) , BytesType . instance ) ; assertTrue ( cfNew . removeColumnDefinition ( removeIndexDef ) ) ; cfm . apply ( cfNew ) ; for ( int i = <int> ; i < cfm . allColumns ( ) . size ( ) ; i + + ) assertNotNull ( cfm . getColumnDefinition ( ByteBuffer . wrap ( new byte [ ] { <int> } ) ) ) ; assertNull ( cfm . getColumnDefinition ( ByteBuffer . wrap ( new byte [ ] { <int> } ) ) ) ; assertNotNull ( cfm . getColumnDefinition ( ByteBuffer . wrap ( new byte [ ] { <int> } ) ) ) ; } @Test public void testInvalidNames ( ) { String [ ] valid = { <str> , <str> , <str> , <str> , <str> , <str> } ; for ( String s : valid ) assertTrue ( CFMetaData . isNameValid ( s ) ) ; String [ ] invalid = { <str> , <str> , <str> , <str> , <str> , <str> } ; for ( String s : invalid ) assertFalse ( CFMetaData . isNameValid ( s ) ) ; } @Test public void addNewCfToBogusKeyspace ( ) { CFMetaData newCf = addTestTable ( <str> , <str> , <str> ) ; try { MigrationManager . announceNewColumnFamily ( newCf ) ; throw new AssertionError ( <str> ) ; } catch ( ConfigurationException expected ) { } } @Test public void addNewTable ( ) throws ConfigurationException { final String ksName = KEYSPACE1 ; final String tableName = <str> ; KeyspaceMetadata original = Schema . instance . getKSMetaData ( ksName ) ; CFMetaData cfm = addTestTable ( original . name , tableName , <str> ) ; assertFalse ( Schema . instance . getKSMetaData ( ksName ) . tables . get ( cfm . cfName ) . isPresent ( ) ) ; MigrationManager . announceNewColumnFamily ( cfm ) ; assertTrue ( Schema . instance . getKSMetaData ( ksName ) . tables . get ( cfm . cfName ) . isPresent ( ) ) ; assertEquals ( cfm , Schema . instance . getKSMetaData ( ksName ) . tables . get ( cfm . cfName ) . get ( ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , ksName , tableName ) , <str> , <str> , <str> ) ; ColumnFamilyStore cfs = Keyspace . open ( ksName ) . getColumnFamilyStore ( tableName ) ; assertNotNull ( cfs ) ; cfs . forceBlockingFlush ( ) ; UntypedResultSet rows = QueryProcessor . executeInternal ( String . format ( <str> , ksName , tableName ) ) ; assertRows ( rows , row ( <str> , <str> , <str> ) ) ; } @Test public void dropCf ( ) throws ConfigurationException { final KeyspaceMetadata ks = Schema . instance . getKSMetaData ( KEYSPACE1 ) ; assertNotNull ( ks ) ; final CFMetaData cfm = ks . tables . getNullable ( TABLE1 ) ; assertNotNull ( cfm ) ; for ( int i = <int> ; i < <int> ; i + + ) QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE1 , TABLE1 ) , <str> , <str> + i , <str> ) ; ColumnFamilyStore store = Keyspace . open ( cfm . ksName ) . getColumnFamilyStore ( cfm . cfName ) ; assertNotNull ( store ) ; store . forceBlockingFlush ( ) ; assertTrue ( store . getDirectories ( ) . sstableLister ( Directories . OnTxnErr . THROW ) . list ( ) . size ( ) > <int> ) ; MigrationManager . announceColumnFamilyDrop ( ks . name , cfm . cfName ) ; assertFalse ( Schema . instance . getKSMetaData ( ks . name ) . tables . get ( cfm . cfName ) . isPresent ( ) ) ; boolean success = true ; try { QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE1 , TABLE1 ) , <str> , <str> , <str> ) ; } catch ( Throwable th ) { success = false ; } assertFalse ( <str> , success ) ; Supplier < Object > lambda = ( ) - > { for ( File file : store . getDirectories ( ) . sstableLister ( Directories . OnTxnErr . THROW ) . listFiles ( ) ) { if ( file . getPath ( ) . endsWith ( <str> ) & & ! new File ( file . getPath ( ) . replace ( <str> , <str> ) ) . exists ( ) ) return false ; } return true ; } ; Util . spinAssertEquals ( true , lambda , <int> ) ; } @Test public void addNewKS ( ) throws ConfigurationException { CFMetaData cfm = addTestTable ( <str> , <str> , <str> ) ; KeyspaceMetadata newKs = KeyspaceMetadata . create ( cfm . ksName , KeyspaceParams . simple ( <int> ) , Tables . of ( cfm ) ) ; MigrationManager . announceNewKeyspace ( newKs ) ; assertNotNull ( Schema . instance . getKSMetaData ( cfm . ksName ) ) ; assertEquals ( Schema . instance . getKSMetaData ( cfm . ksName ) , newKs ) ; QueryProcessor . executeInternal ( <str> , <str> , <str> , <str> ) ; ColumnFamilyStore store = Keyspace . open ( cfm . ksName ) . getColumnFamilyStore ( cfm . cfName ) ; assertNotNull ( store ) ; store . forceBlockingFlush ( ) ; UntypedResultSet rows = QueryProcessor . executeInternal ( <str> ) ; assertRows ( rows , row ( <str> , <str> , <str> ) ) ; } @Test public void dropKS ( ) throws ConfigurationException { final KeyspaceMetadata ks = Schema . instance . getKSMetaData ( KEYSPACE1 ) ; assertNotNull ( ks ) ; final CFMetaData cfm = ks . tables . getNullable ( TABLE2 ) ; assertNotNull ( cfm ) ; for ( int i = <int> ; i < <int> ; i + + ) QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE1 , TABLE2 ) , <str> , <str> + i , <str> ) ; ColumnFamilyStore cfs = Keyspace . open ( cfm . ksName ) . getColumnFamilyStore ( cfm . cfName ) ; assertNotNull ( cfs ) ; cfs . forceBlockingFlush ( ) ; assertTrue ( ! cfs . getDirectories ( ) . sstableLister ( Directories . OnTxnErr . THROW ) . list ( ) . isEmpty ( ) ) ; MigrationManager . announceKeyspaceDrop ( ks . name ) ; assertNull ( Schema . instance . getKSMetaData ( ks . name ) ) ; boolean success = true ; try { QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE1 , TABLE2 ) , <str> , <str> , <str> ) ; } catch ( Throwable th ) { success = false ; } assertFalse ( <str> , success ) ; boolean threw = false ; try { Keyspace . open ( ks . name ) ; } catch ( Throwable th ) { threw = true ; } assertTrue ( threw ) ; } @Test public void dropKSUnflushed ( ) throws ConfigurationException { final KeyspaceMetadata ks = Schema . instance . getKSMetaData ( KEYSPACE3 ) ; assertNotNull ( ks ) ; final CFMetaData cfm = ks . tables . getNullable ( TABLE1 ) ; assertNotNull ( cfm ) ; for ( int i = <int> ; i < <int> ; i + + ) QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE3 , TABLE1 ) , <str> , <str> + i , <str> ) ; MigrationManager . announceKeyspaceDrop ( ks . name ) ; assertNull ( Schema . instance . getKSMetaData ( ks . name ) ) ; } @Test public void createEmptyKsAddNewCf ( ) throws ConfigurationException { assertNull ( Schema . instance . getKSMetaData ( EMPTY_KEYSPACE ) ) ; KeyspaceMetadata newKs = KeyspaceMetadata . create ( EMPTY_KEYSPACE , KeyspaceParams . simple ( <int> ) ) ; MigrationManager . announceNewKeyspace ( newKs ) ; assertNotNull ( Schema . instance . getKSMetaData ( EMPTY_KEYSPACE ) ) ; String tableName = <str> ; CFMetaData newCf = addTestTable ( EMPTY_KEYSPACE , tableName , <str> ) ; assertFalse ( Schema . instance . getKSMetaData ( newKs . name ) . tables . get ( newCf . cfName ) . isPresent ( ) ) ; MigrationManager . announceNewColumnFamily ( newCf ) ; assertTrue ( Schema . instance . getKSMetaData ( newKs . name ) . tables . get ( newCf . cfName ) . isPresent ( ) ) ; assertEquals ( Schema . instance . getKSMetaData ( newKs . name ) . tables . get ( newCf . cfName ) . get ( ) , newCf ) ; QueryProcessor . executeInternal ( String . format ( <str> , EMPTY_KEYSPACE , tableName ) , <str> , <str> , <str> ) ; ColumnFamilyStore cfs = Keyspace . open ( newKs . name ) . getColumnFamilyStore ( newCf . cfName ) ; assertNotNull ( cfs ) ; cfs . forceBlockingFlush ( ) ; UntypedResultSet rows = QueryProcessor . executeInternal ( String . format ( <str> , EMPTY_KEYSPACE , tableName ) ) ; assertRows ( rows , row ( <str> , <str> , <str> ) ) ; } @Test public void testUpdateKeyspace ( ) throws ConfigurationException { CFMetaData cf = addTestTable ( <str> , <str> , <str> ) ; KeyspaceMetadata oldKs = KeyspaceMetadata . create ( cf . ksName , KeyspaceParams . simple ( <int> ) , Tables . of ( cf ) ) ; MigrationManager . announceNewKeyspace ( oldKs ) ; assertNotNull ( Schema . instance . getKSMetaData ( cf . ksName ) ) ; assertEquals ( Schema . instance . getKSMetaData ( cf . ksName ) , oldKs ) ; KeyspaceMetadata newBadKs2 = KeyspaceMetadata . create ( cf . ksName + <str> , KeyspaceParams . simple ( <int> ) ) ; try { MigrationManager . announceKeyspaceUpdate ( newBadKs2 ) ; throw new AssertionError ( <str> ) ; } catch ( ConfigurationException ex ) { } Map < String , String > replicationMap = new HashMap < > ( ) ; replicationMap . put ( ReplicationParams . CLASS , OldNetworkTopologyStrategy . class . getName ( ) ) ; replicationMap . put ( <str> , <str> ) ; KeyspaceMetadata newKs = KeyspaceMetadata . create ( cf . ksName , KeyspaceParams . create ( true , replicationMap ) ) ; MigrationManager . announceKeyspaceUpdate ( newKs ) ; KeyspaceMetadata newFetchedKs = Schema . instance . getKSMetaData ( newKs . name ) ; assertEquals ( newFetchedKs . params . replication . klass , newKs . params . replication . klass ) ; assertFalse ( newFetchedKs . params . replication . klass . equals ( oldKs . params . replication . klass ) ) ; } @Test public void testDropIndex ( ) throws ConfigurationException { SchemaKeyspace . makeCreateKeyspaceMutation ( Schema . instance . getKSMetaData ( KEYSPACE6 ) , FBUtilities . timestampMicros ( ) ) . applyUnsafe ( ) ; ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE6 ) . getColumnFamilyStore ( TABLE1i ) ; String indexName = <str> ; QueryProcessor . executeInternal ( String . format ( <str> , KEYSPACE6 , TABLE1i ) , <str> , <str> , <int> , <int> ) ; cfs . forceBlockingFlush ( ) ; ColumnFamilyStore indexCfs = cfs . indexManager . getIndexByName ( indexName ) . getBackingTable ( ) . orElseThrow ( throwAssert ( <str> ) ) ; Descriptor desc = indexCfs . getLiveSSTables ( ) . iterator ( ) . next ( ) . descriptor ; CFMetaData meta = cfs . metadata . copy ( ) ; IndexMetadata existing = cfs . metadata . getIndexes ( ) . get ( indexName ) . orElseThrow ( throwAssert ( <str> ) ) ; meta . indexes ( meta . getIndexes ( ) . without ( existing . name ) ) ; MigrationManager . announceColumnFamilyUpdate ( meta , false ) ; assertTrue ( cfs . indexManager . listIndexes ( ) . isEmpty ( ) ) ; LifecycleTransaction . waitForDeletions ( ) ; assertFalse ( new File ( desc . filenameFor ( Component . DATA ) ) . exists ( ) ) ; } private CFMetaData addTestTable ( String ks , String cf , String comment ) { CFMetaData newCFMD = CFMetaData . Builder . create ( ks , cf ) . addPartitionKey ( <str> , UTF8Type . instance ) . addClusteringColumn ( <str> , UTF8Type . instance ) . addRegularColumn ( <str> , UTF8Type . instance ) . build ( ) ; newCFMD . comment ( comment ) . readRepairChance ( <float> ) ; return newCFMD ; } } 
