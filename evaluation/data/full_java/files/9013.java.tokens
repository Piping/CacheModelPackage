package org . elasticsearch . test . rest ; import org . elasticsearch . Version ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . test . rest . client . RestClient ; import org . elasticsearch . test . rest . client . RestException ; import org . elasticsearch . test . rest . client . RestResponse ; import org . elasticsearch . test . rest . spec . RestSpec ; import java . io . Closeable ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class RestTestExecutionContext implements Closeable { private static final ESLogger logger = Loggers . getLogger ( RestTestExecutionContext . class ) ; private final Stash stash = new Stash ( ) ; private final RestSpec restSpec ; private RestClient restClient ; private RestResponse response ; public RestTestExecutionContext ( RestSpec restSpec ) { this . restSpec = restSpec ; } public RestResponse callApi ( String apiName , Map < String , String > params , List < Map < String , Object > > bodies , Map < String , String > headers ) throws IOException , RestException { HashMap < String , String > requestParams = new HashMap < > ( params ) ; for ( Map . Entry < String , String > entry : requestParams . entrySet ( ) ) { if ( stash . isStashedValue ( entry . getValue ( ) ) ) { entry . setValue ( stash . unstashValue ( entry . getValue ( ) ) . toString ( ) ) ; } } String body = actualBody ( bodies ) ; try { response = callApiInternal ( apiName , requestParams , body , headers ) ; stash . stashValue ( <str> , response . getBody ( ) ) ; return response ; } catch ( RestException e ) { response = e . restResponse ( ) ; throw e ; } } private String actualBody ( List < Map < String , Object > > bodies ) throws IOException { if ( bodies . isEmpty ( ) ) { return <str> ; } if ( bodies . size ( ) = = <int> ) { return bodyAsString ( stash . unstashMap ( bodies . get ( <int> ) ) ) ; } StringBuilder bodyBuilder = new StringBuilder ( ) ; for ( Map < String , Object > body : bodies ) { bodyBuilder . append ( bodyAsString ( stash . unstashMap ( body ) ) ) . append ( <str> ) ; } return bodyBuilder . toString ( ) ; } private String bodyAsString ( Map < String , Object > body ) throws IOException { return XContentFactory . jsonBuilder ( ) . map ( body ) . string ( ) ; } private RestResponse callApiInternal ( String apiName , Map < String , String > params , String body , Map < String , String > headers ) throws IOException , RestException { return restClient . callApi ( apiName , params , body , headers ) ; } public Object response ( String path ) throws IOException { return response . evaluate ( path , stash ) ; } public void initClient ( InetSocketAddress [ ] addresses , Settings settings ) throws IOException , RestException { if ( restClient = = null ) { restClient = new RestClient ( restSpec , settings , addresses ) ; } } public void clear ( ) { logger . debug ( <str> ) ; response = null ; stash . clear ( ) ; } public Stash stash ( ) { return stash ; } public Version esVersion ( ) { return restClient . getEsVersion ( ) ; } @Override public void close ( ) { if ( restClient ! = null ) { restClient . close ( ) ; } } } 
