package org . elasticsearch . common . inject . internal ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . common . inject . ConfigurationException ; import org . elasticsearch . common . inject . CreationException ; import org . elasticsearch . common . inject . Key ; import org . elasticsearch . common . inject . MembersInjector ; import org . elasticsearch . common . inject . Provider ; import org . elasticsearch . common . inject . ProvisionException ; import org . elasticsearch . common . inject . Scope ; import org . elasticsearch . common . inject . TypeLiteral ; import org . elasticsearch . common . inject . spi . Dependency ; import org . elasticsearch . common . inject . spi . InjectionListener ; import org . elasticsearch . common . inject . spi . InjectionPoint ; import org . elasticsearch . common . inject . spi . Message ; import org . elasticsearch . common . inject . spi . TypeListenerBinding ; import java . io . PrintWriter ; import java . io . Serializable ; import java . io . StringWriter ; import java . lang . annotation . Annotation ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . Member ; import java . lang . reflect . Type ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Formatter ; import java . util . List ; import java . util . Locale ; import static java . util . Collections . emptySet ; import static java . util . Collections . unmodifiableList ; public final class Errors implements Serializable { private final Errors root ; private final Errors parent ; private final Object source ; private List < Message > errors ; public Errors ( ) { this . root = this ; this . parent = null ; this . source = SourceProvider . UNKNOWN_SOURCE ; } public Errors ( Object source ) { this . root = this ; this . parent = null ; this . source = source ; } private Errors ( Errors parent , Object source ) { this . root = parent . root ; this . parent = parent ; this . source = source ; } public Errors withSource ( Object source ) { return source = = SourceProvider . UNKNOWN_SOURCE ? this : new Errors ( this , source ) ; } public Errors missingImplementation ( Key key ) { return addMessage ( <str> , key ) ; } public Errors converterReturnedNull ( String stringValue , Object source , TypeLiteral < ? > type , MatcherAndConverter matchingConverter ) { return addMessage ( <str> + <str> , stringValue , convert ( source ) , type , matchingConverter ) ; } public Errors conversionTypeError ( String stringValue , Object source , TypeLiteral < ? > type , MatcherAndConverter matchingConverter , Object converted ) { return addMessage ( <str> + <str> + <str> , stringValue , convert ( source ) , type , matchingConverter , converted ) ; } public Errors conversionError ( String stringValue , Object source , TypeLiteral < ? > type , MatcherAndConverter matchingConverter , RuntimeException cause ) { return errorInUserCode ( cause , <str> + <str> + <str> , stringValue , convert ( source ) , type , matchingConverter , cause ) ; } public Errors ambiguousTypeConversion ( String stringValue , Object source , TypeLiteral < ? > type , MatcherAndConverter a , MatcherAndConverter b ) { return addMessage ( <str> + <str> + <str> + <str> , stringValue , convert ( source ) , type , a , b ) ; } public Errors bindingToProvider ( ) { return addMessage ( <str> ) ; } public Errors subtypeNotProvided ( Class < ? extends Provider < ? > > providerType , Class < ? > type ) { return addMessage ( <str> , providerType , type ) ; } public Errors notASubtype ( Class < ? > implementationType , Class < ? > type ) { return addMessage ( <str> , implementationType , type ) ; } public Errors recursiveImplementationType ( ) { return addMessage ( <str> ) ; } public Errors recursiveProviderType ( ) { return addMessage ( <str> ) ; } public Errors missingRuntimeRetention ( Object source ) { return addMessage ( <str> + <str> , convert ( source ) ) ; } public Errors missingScopeAnnotation ( ) { return addMessage ( <str> ) ; } public Errors optionalConstructor ( Constructor constructor ) { return addMessage ( <str> + <str> , constructor ) ; } public Errors cannotBindToGuiceType ( String simpleName ) { return addMessage ( <str> , simpleName ) ; } public Errors scopeNotFound ( Class < ? extends Annotation > scopeAnnotation ) { return addMessage ( <str> , scopeAnnotation ) ; } public Errors scopeAnnotationOnAbstractType ( Class < ? extends Annotation > scopeAnnotation , Class < ? > type , Object source ) { return addMessage ( <str> + <str> , type , scopeAnnotation , convert ( source ) ) ; } public Errors misplacedBindingAnnotation ( Member member , Annotation bindingAnnotation ) { return addMessage ( <str> + <str> , member , bindingAnnotation ) ; } private static final String CONSTRUCTOR_RULES = <str> + <str> ; public Errors missingConstructor ( Class < ? > implementation ) { return addMessage ( <str> + CONSTRUCTOR_RULES , implementation ) ; } public Errors tooManyConstructors ( Class < ? > implementation ) { return addMessage ( <str> + CONSTRUCTOR_RULES , implementation ) ; } public Errors duplicateScopes ( Scope existing , Class < ? extends Annotation > annotationType , Scope scope ) { return addMessage ( <str> , existing , annotationType , scope ) ; } public Errors voidProviderMethod ( ) { return addMessage ( <str> ) ; } public Errors missingConstantValues ( ) { return addMessage ( <str> ) ; } public Errors cannotInjectInnerClass ( Class < ? > type ) { return addMessage ( <str> + <str> , type ) ; } public Errors duplicateBindingAnnotations ( Member member , Class < ? extends Annotation > a , Class < ? extends Annotation > b ) { return addMessage ( <str> + <str> , member , a , b ) ; } public Errors duplicateScopeAnnotations ( Class < ? extends Annotation > a , Class < ? extends Annotation > b ) { return addMessage ( <str> , a , b ) ; } public Errors recursiveBinding ( ) { return addMessage ( <str> ) ; } public Errors bindingAlreadySet ( Key < ? > key , Object source ) { return addMessage ( <str> , key , convert ( source ) ) ; } public Errors childBindingAlreadySet ( Key < ? > key ) { return addMessage ( <str> , key ) ; } public Errors errorInjectingMethod ( Throwable cause ) { return errorInUserCode ( cause , <str> , cause ) ; } public Errors errorNotifyingTypeListener ( TypeListenerBinding listener , TypeLiteral < ? > type , Throwable cause ) { return errorInUserCode ( cause , <str> + <str> , listener . getListener ( ) , convert ( listener . getSource ( ) ) , type , cause ) ; } public Errors errorInjectingConstructor ( Throwable cause ) { return errorInUserCode ( cause , <str> , cause ) ; } public Errors errorInProvider ( RuntimeException runtimeException ) { return errorInUserCode ( runtimeException , <str> , runtimeException ) ; } public Errors errorInUserInjector ( MembersInjector < ? > listener , TypeLiteral < ? > type , RuntimeException cause ) { return errorInUserCode ( cause , <str> + <str> , type , listener , cause ) ; } public Errors errorNotifyingInjectionListener ( InjectionListener < ? > listener , TypeLiteral < ? > type , RuntimeException cause ) { return errorInUserCode ( cause , <str> + <str> , listener , type , cause ) ; } public void exposedButNotBound ( Key < ? > key ) { addMessage ( <str> , key ) ; } public static Collection < Message > getMessagesFromThrowable ( Throwable throwable ) { if ( throwable instanceof ProvisionException ) { return ( ( ProvisionException ) throwable ) . getErrorMessages ( ) ; } else if ( throwable instanceof ConfigurationException ) { return ( ( ConfigurationException ) throwable ) . getErrorMessages ( ) ; } else if ( throwable instanceof CreationException ) { return ( ( CreationException ) throwable ) . getErrorMessages ( ) ; } else { return emptySet ( ) ; } } public Errors errorInUserCode ( Throwable cause , String messageFormat , Object . . . arguments ) { Collection < Message > messages = getMessagesFromThrowable ( cause ) ; if ( ! messages . isEmpty ( ) ) { return merge ( messages ) ; } else { return addMessage ( cause , messageFormat , arguments ) ; } } public Errors cannotInjectRawProvider ( ) { return addMessage ( <str> ) ; } public Errors cannotInjectRawMembersInjector ( ) { return addMessage ( <str> ) ; } public Errors cannotInjectTypeLiteralOf ( Type unsupportedType ) { return addMessage ( <str> , unsupportedType ) ; } public Errors cannotInjectRawTypeLiteral ( ) { return addMessage ( <str> ) ; } public Errors cannotSatisfyCircularDependency ( Class < ? > expectedType ) { return addMessage ( <str> , expectedType ) ; } public void throwCreationExceptionIfErrorsExist ( ) { if ( ! hasErrors ( ) ) { return ; } throw new CreationException ( getMessages ( ) ) ; } public void throwConfigurationExceptionIfErrorsExist ( ) { if ( ! hasErrors ( ) ) { return ; } throw new ConfigurationException ( getMessages ( ) ) ; } public void throwProvisionExceptionIfErrorsExist ( ) { if ( ! hasErrors ( ) ) { return ; } throw new ProvisionException ( getMessages ( ) ) ; } private Message merge ( Message message ) { List < Object > sources = new ArrayList < > ( ) ; sources . addAll ( getSources ( ) ) ; sources . addAll ( message . getSources ( ) ) ; return new Message ( sources , message . getMessage ( ) , message . getCause ( ) ) ; } public Errors merge ( Collection < Message > messages ) { for ( Message message : messages ) { addMessage ( merge ( message ) ) ; } return this ; } public Errors merge ( Errors moreErrors ) { if ( moreErrors . root = = root | | moreErrors . root . errors = = null ) { return this ; } merge ( moreErrors . root . errors ) ; return this ; } public List < Object > getSources ( ) { List < Object > sources = new ArrayList < > ( ) ; for ( Errors e = this ; e ! = null ; e = e . parent ) { if ( e . source ! = SourceProvider . UNKNOWN_SOURCE ) { sources . add ( <int> , e . source ) ; } } return sources ; } public void throwIfNewErrors ( int expectedSize ) throws ErrorsException { if ( size ( ) = = expectedSize ) { return ; } throw toException ( ) ; } public ErrorsException toException ( ) { return new ErrorsException ( this ) ; } public boolean hasErrors ( ) { return root . errors ! = null ; } public Errors addMessage ( String messageFormat , Object . . . arguments ) { return addMessage ( null , messageFormat , arguments ) ; } private Errors addMessage ( Throwable cause , String messageFormat , Object . . . arguments ) { String message = format ( messageFormat , arguments ) ; addMessage ( new Message ( getSources ( ) , message , cause ) ) ; return this ; } public Errors addMessage ( Message message ) { if ( root . errors = = null ) { root . errors = new ArrayList < > ( ) ; } root . errors . add ( message ) ; return this ; } public static String format ( String messageFormat , Object . . . arguments ) { for ( int i = <int> ; i < arguments . length ; i + + ) { arguments [ i ] = Errors . convert ( arguments [ i ] ) ; } return String . format ( Locale . ROOT , messageFormat , arguments ) ; } public List < Message > getMessages ( ) { if ( root . errors = = null ) { return Collections . emptyList ( ) ; } List < Message > result = new ArrayList < > ( root . errors ) ; CollectionUtil . timSort ( result , new Comparator < Message > ( ) { @Override public int compare ( Message a , Message b ) { return a . getSource ( ) . compareTo ( b . getSource ( ) ) ; } } ) ; return unmodifiableList ( result ) ; } public static String format ( String heading , Collection < Message > errorMessages ) { try ( Formatter fmt = new Formatter ( Locale . ROOT ) ) { fmt . format ( heading ) . format ( <str> ) ; int index = <int> ; boolean displayCauses = getOnlyCause ( errorMessages ) = = null ; for ( Message errorMessage : errorMessages ) { fmt . format ( <str> , index + + , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - <int> ; i > = <int> ; i - - ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses & & cause ! = null ) { StringWriter writer = new StringWriter ( ) ; cause . printStackTrace ( new PrintWriter ( writer ) ) ; fmt . format ( <str> , writer . getBuffer ( ) ) ; } fmt . format ( <str> ) ; } if ( errorMessages . size ( ) = = <int> ) { fmt . format ( <str> ) ; } else { fmt . format ( <str> , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; } } public < T > T checkForNull ( T value , Object source , Dependency < ? > dependency ) throws ErrorsException { if ( value ! = null | | dependency . isNullable ( ) ) { return value ; } int parameterIndex = dependency . getParameterIndex ( ) ; String parameterName = ( parameterIndex ! = - <int> ) ? <str> + parameterIndex + <str> : <str> ; addMessage ( <str> , source , parameterName , dependency . getInjectionPoint ( ) . getMember ( ) ) ; throw toException ( ) ; } public static Throwable getOnlyCause ( Collection < Message > messages ) { Throwable onlyCause = null ; for ( Message message : messages ) { Throwable messageCause = message . getCause ( ) ; if ( messageCause = = null ) { continue ; } if ( onlyCause ! = null ) { return null ; } onlyCause = messageCause ; } return onlyCause ; } public int size ( ) { return root . errors = = null ? <int> : root . errors . size ( ) ; } private static abstract class Converter < T > { final Class < T > type ; Converter ( Class < T > type ) { this . type = type ; } boolean appliesTo ( Object o ) { return type . isAssignableFrom ( o . getClass ( ) ) ; } String convert ( Object o ) { return toString ( type . cast ( o ) ) ; } abstract String toString ( T t ) ; } private static final Collection < Converter < ? > > converters = Arrays . asList ( new Converter < Class > ( Class . class ) { @Override public String toString ( Class c ) { return c . getName ( ) ; } } , new Converter < Member > ( Member . class ) { @Override public String toString ( Member member ) { return MoreTypes . toString ( member ) ; } } , new Converter < Key > ( Key . class ) { @Override public String toString ( Key key ) { if ( key . getAnnotationType ( ) ! = null ) { return key . getTypeLiteral ( ) + <str> + ( key . getAnnotation ( ) ! = null ? key . getAnnotation ( ) : key . getAnnotationType ( ) ) ; } else { return key . getTypeLiteral ( ) . toString ( ) ; } } } ) ; public static Object convert ( Object o ) { for ( Converter < ? > converter : converters ) { if ( converter . appliesTo ( o ) ) { return converter . convert ( o ) ; } } return o ; } public static void formatSource ( Formatter formatter , Object source ) { if ( source instanceof Dependency ) { Dependency < ? > dependency = ( Dependency < ? > ) source ; InjectionPoint injectionPoint = dependency . getInjectionPoint ( ) ; if ( injectionPoint ! = null ) { formatInjectionPoint ( formatter , dependency , injectionPoint ) ; } else { formatSource ( formatter , dependency . getKey ( ) ) ; } } else if ( source instanceof InjectionPoint ) { formatInjectionPoint ( formatter , null , ( InjectionPoint ) source ) ; } else if ( source instanceof Class ) { formatter . format ( <str> , StackTraceElements . forType ( ( Class < ? > ) source ) ) ; } else if ( source instanceof Member ) { formatter . format ( <str> , StackTraceElements . forMember ( ( Member ) source ) ) ; } else if ( source instanceof TypeLiteral ) { formatter . format ( <str> , source ) ; } else if ( source instanceof Key ) { Key < ? > key = ( Key < ? > ) source ; formatter . format ( <str> , convert ( key ) ) ; } else { formatter . format ( <str> , source ) ; } } public static void formatInjectionPoint ( Formatter formatter , Dependency < ? > dependency , InjectionPoint injectionPoint ) { Member member = injectionPoint . getMember ( ) ; Class < ? extends Member > memberType = MoreTypes . memberType ( member ) ; if ( memberType = = Field . class ) { dependency = injectionPoint . getDependencies ( ) . get ( <int> ) ; formatter . format ( <str> , convert ( dependency . getKey ( ) ) ) ; formatter . format ( <str> , StackTraceElements . forMember ( member ) ) ; } else if ( dependency ! = null ) { formatter . format ( <str> , convert ( dependency . getKey ( ) ) ) ; formatter . format ( <str> , dependency . getParameterIndex ( ) , StackTraceElements . forMember ( member ) ) ; } else { formatSource ( formatter , injectionPoint . getMember ( ) ) ; } } } 
