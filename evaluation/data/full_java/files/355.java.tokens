package org . apache . cassandra . db ; import java . io . IOException ; import java . io . IOError ; import java . util . * ; import com . google . common . collect . Iterables ; import com . google . common . collect . PeekingIterator ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . FileDataInput ; import org . apache . cassandra . net . MessagingService ; public abstract class UnfilteredDeserializer { private static final Logger logger = LoggerFactory . getLogger ( UnfilteredDeserializer . class ) ; protected final CFMetaData metadata ; protected final DataInputPlus in ; protected final SerializationHelper helper ; protected UnfilteredDeserializer ( CFMetaData metadata , DataInputPlus in , SerializationHelper helper ) { this . metadata = metadata ; this . in = in ; this . helper = helper ; } public static UnfilteredDeserializer create ( CFMetaData metadata , DataInputPlus in , SerializationHeader header , SerializationHelper helper , DeletionTime partitionDeletion , boolean readAllAsDynamic ) { if ( helper . version > = MessagingService . VERSION_30 ) return new CurrentDeserializer ( metadata , in , header , helper ) ; else return new OldFormatDeserializer ( metadata , in , helper , partitionDeletion , readAllAsDynamic ) ; } public abstract boolean hasNext ( ) throws IOException ; public abstract int compareNextTo ( Slice . Bound bound ) throws IOException ; public abstract boolean nextIsRow ( ) throws IOException ; public abstract boolean nextIsStatic ( ) throws IOException ; public abstract Unfiltered readNext ( ) throws IOException ; public abstract void clearState ( ) throws IOException ; public abstract void skipNext ( ) throws IOException ; public abstract long bytesReadForUnconsumedData ( ) ; private static class CurrentDeserializer extends UnfilteredDeserializer { private final ClusteringPrefix . Deserializer clusteringDeserializer ; private final SerializationHeader header ; private int nextFlags ; private int nextExtendedFlags ; private boolean isReady ; private boolean isDone ; private final Row . Builder builder ; private CurrentDeserializer ( CFMetaData metadata , DataInputPlus in , SerializationHeader header , SerializationHelper helper ) { super ( metadata , in , helper ) ; this . header = header ; this . clusteringDeserializer = new ClusteringPrefix . Deserializer ( metadata . comparator , in , header ) ; this . builder = BTreeRow . sortedBuilder ( ) ; } public boolean hasNext ( ) throws IOException { if ( isReady ) return true ; prepareNext ( ) ; return ! isDone ; } private void prepareNext ( ) throws IOException { if ( isDone ) return ; nextFlags = in . readUnsignedByte ( ) ; if ( UnfilteredSerializer . isEndOfPartition ( nextFlags ) ) { isDone = true ; isReady = false ; return ; } nextExtendedFlags = UnfilteredSerializer . readExtendedFlags ( in , nextFlags ) ; clusteringDeserializer . prepare ( nextFlags , nextExtendedFlags ) ; isReady = true ; } public int compareNextTo ( Slice . Bound bound ) throws IOException { if ( ! isReady ) prepareNext ( ) ; assert ! isDone ; return clusteringDeserializer . compareNextTo ( bound ) ; } public boolean nextIsRow ( ) throws IOException { if ( ! isReady ) prepareNext ( ) ; return UnfilteredSerializer . kind ( nextFlags ) = = Unfiltered . Kind . ROW ; } public boolean nextIsStatic ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public Unfiltered readNext ( ) throws IOException { isReady = false ; if ( UnfilteredSerializer . kind ( nextFlags ) = = Unfiltered . Kind . RANGE_TOMBSTONE_MARKER ) { RangeTombstone . Bound bound = clusteringDeserializer . deserializeNextBound ( ) ; return UnfilteredSerializer . serializer . deserializeMarkerBody ( in , header , bound ) ; } else { builder . newRow ( clusteringDeserializer . deserializeNextClustering ( ) ) ; return UnfilteredSerializer . serializer . deserializeRowBody ( in , header , helper , nextFlags , nextExtendedFlags , builder ) ; } } public void skipNext ( ) throws IOException { isReady = false ; clusteringDeserializer . skipNext ( ) ; if ( UnfilteredSerializer . kind ( nextFlags ) = = Unfiltered . Kind . RANGE_TOMBSTONE_MARKER ) { UnfilteredSerializer . serializer . skipMarkerBody ( in ) ; } else { UnfilteredSerializer . serializer . skipRowBody ( in ) ; } } public void clearState ( ) { isReady = false ; isDone = false ; } public long bytesReadForUnconsumedData ( ) { return <int> ; } } public static class OldFormatDeserializer extends UnfilteredDeserializer { private final boolean readAllAsDynamic ; private boolean skipStatic ; private Unfiltered next ; private Unfiltered saved ; private boolean isFirst = true ; private final UnfilteredIterator iterator ; private long lastConsumedPosition ; private OldFormatDeserializer ( CFMetaData metadata , DataInputPlus in , SerializationHelper helper , DeletionTime partitionDeletion , boolean readAllAsDynamic ) { super ( metadata , in , helper ) ; this . iterator = new UnfilteredIterator ( partitionDeletion ) ; this . readAllAsDynamic = readAllAsDynamic ; this . lastConsumedPosition = currentPosition ( ) ; } public void setSkipStatic ( ) { this . skipStatic = true ; } private boolean isStatic ( Unfiltered unfiltered ) { return unfiltered . isRow ( ) & & ( ( Row ) unfiltered ) . isStatic ( ) ; } public boolean hasNext ( ) throws IOException { try { while ( next = = null ) { if ( saved = = null & & ! iterator . hasNext ( ) ) return false ; next = saved = = null ? iterator . next ( ) : saved ; saved = null ; if ( isFirst & & iterator . hasNext ( ) & & isStatic ( iterator . peek ( ) ) ) { saved = next ; next = iterator . next ( ) ; } isFirst = false ; if ( skipStatic & & isStatic ( next ) ) next = null ; } return true ; } catch ( IOError e ) { if ( e . getCause ( ) ! = null & & e . getCause ( ) instanceof IOException ) throw ( IOException ) e . getCause ( ) ; throw e ; } } private boolean isRow ( LegacyLayout . LegacyAtom atom ) { if ( atom . isCell ( ) ) return true ; LegacyLayout . LegacyRangeTombstone tombstone = atom . asRangeTombstone ( ) ; return tombstone . isCollectionTombstone ( ) | | tombstone . isRowDeletion ( metadata ) ; } public int compareNextTo ( Slice . Bound bound ) throws IOException { if ( ! hasNext ( ) ) throw new IllegalStateException ( ) ; return metadata . comparator . compare ( next . clustering ( ) , bound ) ; } public boolean nextIsRow ( ) throws IOException { if ( ! hasNext ( ) ) throw new IllegalStateException ( ) ; return next . isRow ( ) ; } public boolean nextIsStatic ( ) throws IOException { return nextIsRow ( ) & & ( ( Row ) next ) . isStatic ( ) ; } private long currentPosition ( ) { return in instanceof FileDataInput ? ( ( FileDataInput ) in ) . getFilePointer ( ) : <int> ; } public Unfiltered readNext ( ) throws IOException { if ( ! hasNext ( ) ) throw new IllegalStateException ( ) ; Unfiltered toReturn = next ; next = null ; lastConsumedPosition = currentPosition ( ) ; return toReturn ; } public void skipNext ( ) throws IOException { if ( ! hasNext ( ) ) throw new UnsupportedOperationException ( ) ; next = null ; lastConsumedPosition = currentPosition ( ) ; } public long bytesReadForUnconsumedData ( ) { if ( ! ( in instanceof FileDataInput ) ) throw new AssertionError ( ) ; return currentPosition ( ) - lastConsumedPosition ; } public void clearState ( ) { next = null ; saved = null ; iterator . clearState ( ) ; lastConsumedPosition = currentPosition ( ) ; } private class UnfilteredIterator implements PeekingIterator < Unfiltered > { private final AtomIterator atoms ; private final LegacyLayout . CellGrouper grouper ; private final TombstoneTracker tombstoneTracker ; private Unfiltered next ; private UnfilteredIterator ( DeletionTime partitionDeletion ) { this . grouper = new LegacyLayout . CellGrouper ( metadata , helper ) ; this . tombstoneTracker = new TombstoneTracker ( partitionDeletion ) ; this . atoms = new AtomIterator ( tombstoneTracker ) ; } public boolean hasNext ( ) { while ( next = = null ) { if ( atoms . hasNext ( ) ) { if ( tombstoneTracker . hasClosingMarkerBefore ( atoms . peek ( ) ) ) { next = tombstoneTracker . popClosingMarker ( ) ; } else { LegacyLayout . LegacyAtom atom = atoms . next ( ) ; next = isRow ( atom ) ? readRow ( atom ) : tombstoneTracker . openNew ( atom . asRangeTombstone ( ) ) ; } } else if ( tombstoneTracker . hasOpenTombstones ( ) ) { next = tombstoneTracker . popClosingMarker ( ) ; } else { return false ; } } return next ! = null ; } private Unfiltered readRow ( LegacyLayout . LegacyAtom first ) { LegacyLayout . CellGrouper grouper = first . isStatic ( ) ? LegacyLayout . CellGrouper . staticGrouper ( metadata , helper ) : this . grouper ; grouper . reset ( ) ; grouper . addAtom ( first ) ; while ( atoms . hasNext ( ) & & grouper . addAtom ( atoms . peek ( ) ) ) { atoms . next ( ) ; } return grouper . getRow ( ) ; } public Unfiltered next ( ) { if ( ! hasNext ( ) ) throw new UnsupportedOperationException ( ) ; Unfiltered toReturn = next ; next = null ; return toReturn ; } public Unfiltered peek ( ) { if ( ! hasNext ( ) ) throw new UnsupportedOperationException ( ) ; return next ; } public void clearState ( ) { atoms . clearState ( ) ; tombstoneTracker . clearState ( ) ; next = null ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private class AtomIterator implements PeekingIterator < LegacyLayout . LegacyAtom > { private final TombstoneTracker tombstoneTracker ; private boolean isDone ; private LegacyLayout . LegacyAtom next ; private AtomIterator ( TombstoneTracker tombstoneTracker ) { this . tombstoneTracker = tombstoneTracker ; } public boolean hasNext ( ) { if ( isDone ) return false ; while ( next = = null ) { next = readAtom ( ) ; if ( next = = null ) { isDone = true ; return false ; } if ( tombstoneTracker . isShadowed ( next ) ) next = null ; } return true ; } private LegacyLayout . LegacyAtom readAtom ( ) { try { return LegacyLayout . readLegacyAtom ( metadata , in , readAllAsDynamic ) ; } catch ( IOException e ) { throw new IOError ( e ) ; } } public LegacyLayout . LegacyAtom next ( ) { if ( ! hasNext ( ) ) throw new UnsupportedOperationException ( ) ; LegacyLayout . LegacyAtom toReturn = next ; next = null ; return toReturn ; } public LegacyLayout . LegacyAtom peek ( ) { if ( ! hasNext ( ) ) throw new UnsupportedOperationException ( ) ; return next ; } public void clearState ( ) { this . next = null ; this . isDone = false ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } private class TombstoneTracker { private final DeletionTime partitionDeletion ; private final SortedSet < LegacyLayout . LegacyRangeTombstone > openTombstones ; public TombstoneTracker ( DeletionTime partitionDeletion ) { this . partitionDeletion = partitionDeletion ; this . openTombstones = new TreeSet < > ( ( rt1 , rt2 ) - > metadata . comparator . compare ( rt1 . stop . bound , rt2 . stop . bound ) ) ; } public boolean isShadowed ( LegacyLayout . LegacyAtom atom ) { long timestamp = atom . isCell ( ) ? atom . asCell ( ) . timestamp : atom . asRangeTombstone ( ) . deletionTime . markedForDeleteAt ( ) ; if ( partitionDeletion . deletes ( timestamp ) ) return true ; SortedSet < LegacyLayout . LegacyRangeTombstone > coveringTombstones = isRow ( atom ) ? openTombstones : openTombstones . tailSet ( atom . asRangeTombstone ( ) ) ; return Iterables . any ( coveringTombstones , tombstone - > tombstone . deletionTime . deletes ( timestamp ) ) ; } public boolean hasClosingMarkerBefore ( LegacyLayout . LegacyAtom atom ) { return ! openTombstones . isEmpty ( ) & & metadata . comparator . compare ( openTombstones . first ( ) . stop . bound , atom . clustering ( ) ) < <int> ; } public Unfiltered popClosingMarker ( ) { assert ! openTombstones . isEmpty ( ) ; Iterator < LegacyLayout . LegacyRangeTombstone > iter = openTombstones . iterator ( ) ; LegacyLayout . LegacyRangeTombstone first = iter . next ( ) ; iter . remove ( ) ; if ( ! iter . hasNext ( ) ) return new RangeTombstoneBoundMarker ( first . stop . bound , first . deletionTime ) ; LegacyLayout . LegacyRangeTombstone next = iter . next ( ) ; return RangeTombstoneBoundaryMarker . makeBoundary ( false , first . stop . bound , first . stop . bound . invert ( ) , first . deletionTime , next . deletionTime ) ; } public Unfiltered openNew ( LegacyLayout . LegacyRangeTombstone tombstone ) { if ( openTombstones . isEmpty ( ) ) { openTombstones . add ( tombstone ) ; return new RangeTombstoneBoundMarker ( tombstone . start . bound , tombstone . deletionTime ) ; } Iterator < LegacyLayout . LegacyRangeTombstone > iter = openTombstones . iterator ( ) ; LegacyLayout . LegacyRangeTombstone first = iter . next ( ) ; if ( tombstone . deletionTime . supersedes ( first . deletionTime ) ) { if ( metadata . comparator . compare ( tombstone . stop . bound , first . stop . bound ) > = <int> ) iter . remove ( ) ; openTombstones . add ( tombstone ) ; return RangeTombstoneBoundaryMarker . makeBoundary ( false , tombstone . start . bound . invert ( ) , tombstone . start . bound , first . deletionTime , tombstone . deletionTime ) ; } else { assert metadata . comparator . compare ( tombstone . start . bound , first . stop . bound ) > <int> ; openTombstones . add ( tombstone ) ; return null ; } } public boolean hasOpenTombstones ( ) { return ! openTombstones . isEmpty ( ) ; } private boolean formBoundary ( LegacyLayout . LegacyRangeTombstone close , LegacyLayout . LegacyRangeTombstone open ) { return metadata . comparator . compare ( close . stop . bound , open . start . bound ) = = <int> ; } public void clearState ( ) { openTombstones . clear ( ) ; } } } } 
