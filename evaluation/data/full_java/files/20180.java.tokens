package io . netty . channel ; import java . util . ArrayList ; import java . util . List ; public class AdaptiveRecvByteBufAllocator extends DefaultMaxMessagesRecvByteBufAllocator { static final int DEFAULT_MINIMUM = <int> ; static final int DEFAULT_INITIAL = <int> ; static final int DEFAULT_MAXIMUM = <int> ; private static final int INDEX_INCREMENT = <int> ; private static final int INDEX_DECREMENT = <int> ; private static final int [ ] SIZE_TABLE ; static { List < Integer > sizeTable = new ArrayList < Integer > ( ) ; for ( int i = <int> ; i < <int> ; i + = <int> ) { sizeTable . add ( i ) ; } for ( int i = <int> ; i > <int> ; i < < = <int> ) { sizeTable . add ( i ) ; } SIZE_TABLE = new int [ sizeTable . size ( ) ] ; for ( int i = <int> ; i < SIZE_TABLE . length ; i + + ) { SIZE_TABLE [ i ] = sizeTable . get ( i ) ; } } @Deprecated public static final AdaptiveRecvByteBufAllocator DEFAULT = new AdaptiveRecvByteBufAllocator ( ) ; private static int getSizeTableIndex ( final int size ) { for ( int low = <int> , high = SIZE_TABLE . length - <int> ; ; ) { if ( high < low ) { return low ; } if ( high = = low ) { return high ; } int mid = low + high > > > <int> ; int a = SIZE_TABLE [ mid ] ; int b = SIZE_TABLE [ mid + <int> ] ; if ( size > b ) { low = mid + <int> ; } else if ( size < a ) { high = mid - <int> ; } else if ( size = = a ) { return mid ; } else { return mid + <int> ; } } } private final class HandleImpl extends MaxMessageHandle { private final int minIndex ; private final int maxIndex ; private int index ; private int nextReceiveBufferSize ; private boolean decreaseNow ; public HandleImpl ( int minIndex , int maxIndex , int initial ) { this . minIndex = minIndex ; this . maxIndex = maxIndex ; index = getSizeTableIndex ( initial ) ; nextReceiveBufferSize = SIZE_TABLE [ index ] ; } @Override public int guess ( ) { return nextReceiveBufferSize ; } private void record ( int actualReadBytes ) { if ( actualReadBytes < = SIZE_TABLE [ Math . max ( <int> , index - INDEX_DECREMENT - <int> ) ] ) { if ( decreaseNow ) { index = Math . max ( index - INDEX_DECREMENT , minIndex ) ; nextReceiveBufferSize = SIZE_TABLE [ index ] ; decreaseNow = false ; } else { decreaseNow = true ; } } else if ( actualReadBytes > = nextReceiveBufferSize ) { index = Math . min ( index + INDEX_INCREMENT , maxIndex ) ; nextReceiveBufferSize = SIZE_TABLE [ index ] ; decreaseNow = false ; } } @Override public void readComplete ( ) { record ( totalBytesRead ( ) ) ; } } private final int minIndex ; private final int maxIndex ; private final int initial ; public AdaptiveRecvByteBufAllocator ( ) { this ( DEFAULT_MINIMUM , DEFAULT_INITIAL , DEFAULT_MAXIMUM ) ; } public AdaptiveRecvByteBufAllocator ( int minimum , int initial , int maximum ) { if ( minimum < = <int> ) { throw new IllegalArgumentException ( <str> + minimum ) ; } if ( initial < minimum ) { throw new IllegalArgumentException ( <str> + initial ) ; } if ( maximum < initial ) { throw new IllegalArgumentException ( <str> + maximum ) ; } int minIndex = getSizeTableIndex ( minimum ) ; if ( SIZE_TABLE [ minIndex ] < minimum ) { this . minIndex = minIndex + <int> ; } else { this . minIndex = minIndex ; } int maxIndex = getSizeTableIndex ( maximum ) ; if ( SIZE_TABLE [ maxIndex ] > maximum ) { this . maxIndex = maxIndex - <int> ; } else { this . maxIndex = maxIndex ; } this . initial = initial ; } @Override public Handle newHandle ( ) { return new HandleImpl ( minIndex , maxIndex , initial ) ; } } 
