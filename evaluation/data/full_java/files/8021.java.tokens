package org . elasticsearch . discovery ; import org . apache . lucene . util . LuceneTestCase ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . Murmur3HashFunction ; import org . elasticsearch . cluster . routing . allocation . command . MoveAllocationCommand ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . zen . ZenDiscovery ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . discovery . zen . fd . FaultDetection ; import org . elasticsearch . discovery . zen . membership . MembershipAction ; import org . elasticsearch . discovery . zen . ping . ZenPing ; import org . elasticsearch . discovery . zen . ping . ZenPingService ; import org . elasticsearch . discovery . zen . ping . unicast . UnicastZenPing ; import org . elasticsearch . discovery . zen . publish . PublishClusterStateAction ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . store . IndicesStoreIntegrationIT ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . discovery . ClusterDiscoveryConfiguration ; import org . elasticsearch . test . disruption . * ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import org . junit . Before ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . * ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> , transportClientRatio = <int> ) @ESIntegTestCase.SuppressLocalMode public class DiscoveryWithServiceDisruptionsIT extends ESIntegTestCase { private static final TimeValue DISRUPTION_HEALING_OVERHEAD = TimeValue . timeValueSeconds ( <int> ) ; private ClusterDiscoveryConfiguration discoveryConfig ; @Override protected Settings nodeSettings ( int nodeOrdinal ) { return discoveryConfig . nodeSettings ( nodeOrdinal ) ; } @Before public void clearConfig ( ) { discoveryConfig = null ; } @Override protected int numberOfShards ( ) { return <int> ; } @Override protected int numberOfReplicas ( ) { return <int> ; } private List < String > startCluster ( int numberOfNodes ) throws ExecutionException , InterruptedException { return startCluster ( numberOfNodes , - <int> ) ; } private List < String > startCluster ( int numberOfNodes , int minimumMasterNode ) throws ExecutionException , InterruptedException { return startCluster ( numberOfNodes , minimumMasterNode , null ) ; } private List < String > startCluster ( int numberOfNodes , int minimumMasterNode , @Nullable int [ ] unicastHostsOrdinals ) throws ExecutionException , InterruptedException { configureUnicastCluster ( numberOfNodes , unicastHostsOrdinals , minimumMasterNode ) ; List < String > nodes = internalCluster ( ) . startNodesAsync ( numberOfNodes ) . get ( ) ; ensureStableCluster ( numberOfNodes ) ; for ( ZenPingService pingService : internalCluster ( ) . getInstances ( ZenPingService . class ) ) { for ( ZenPing zenPing : pingService . zenPings ( ) ) { if ( zenPing instanceof UnicastZenPing ) { ( ( UnicastZenPing ) zenPing ) . clearTemporalResponses ( ) ; } } } return nodes ; } final static Settings DEFAULT_SETTINGS = Settings . builder ( ) . put ( FaultDetection . SETTING_PING_TIMEOUT , <str> ) . put ( FaultDetection . SETTING_PING_RETRIES , <str> ) . put ( <str> , <str> ) . put ( DiscoverySettings . PUBLISH_TIMEOUT , <str> ) . put ( <str> , false ) . put ( <str> , <str> ) . build ( ) ; @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockTransportService . TestPlugin . class ) ; } private void configureUnicastCluster ( int numberOfNodes , @Nullable int [ ] unicastHostsOrdinals , int minimumMasterNode ) throws ExecutionException , InterruptedException { if ( minimumMasterNode < <int> ) { minimumMasterNode = numberOfNodes / <int> + <int> ; } logger . info ( <str> ) ; Settings nodeSettings = Settings . builder ( ) . put ( DEFAULT_SETTINGS ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , minimumMasterNode ) . build ( ) ; if ( discoveryConfig = = null ) { if ( unicastHostsOrdinals = = null ) { discoveryConfig = new ClusterDiscoveryConfiguration . UnicastZen ( numberOfNodes , nodeSettings ) ; } else { discoveryConfig = new ClusterDiscoveryConfiguration . UnicastZen ( numberOfNodes , nodeSettings , unicastHostsOrdinals ) ; } } } public void testFailWithMinimumMasterNodesConfigured ( ) throws Exception { List < String > nodes = startCluster ( <int> ) ; final String masterNode = internalCluster ( ) . getMasterName ( ) ; logger . info ( <str> + masterNode ) ; Set < String > nonMasters = new HashSet < > ( nodes ) ; nonMasters . remove ( masterNode ) ; final String unluckyNode = randomFrom ( nonMasters . toArray ( Strings . EMPTY_ARRAY ) ) ; NetworkDisconnectPartition networkDisconnect = new NetworkDisconnectPartition ( masterNode , unluckyNode , getRandom ( ) ) ; setDisruptionScheme ( networkDisconnect ) ; networkDisconnect . startDisrupting ( ) ; ensureStableCluster ( <int> , masterNode ) ; assertNoMaster ( unluckyNode ) ; networkDisconnect . stopDisrupting ( ) ; ensureStableCluster ( <int> ) ; assertMaster ( masterNode , nodes ) ; } public void testNodesFDAfterMasterReelection ( ) throws Exception { startCluster ( <int> ) ; logger . info ( <str> ) ; internalCluster ( ) . stopCurrentMasterNode ( ) ; ensureStableCluster ( <int> ) ; logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , <int> ) ) . get ( ) ) ; String master = internalCluster ( ) . getMasterName ( ) ; String nonMaster = null ; for ( String node : internalCluster ( ) . getNodeNames ( ) ) { if ( ! node . equals ( master ) ) { nonMaster = node ; } } logger . info ( <str> , nonMaster ) ; addRandomIsolation ( nonMaster ) . startDisrupting ( ) ; logger . info ( <str> ) ; ensureStableCluster ( <int> , master ) ; } public void testVerifyApiBlocksDuringPartition ( ) throws Exception { startCluster ( <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) ; ensureGreen ( <str> ) ; NetworkPartition networkPartition = addRandomPartition ( ) ; assertEquals ( <int> , networkPartition . getMinoritySide ( ) . size ( ) ) ; final String isolatedNode = networkPartition . getMinoritySide ( ) . iterator ( ) . next ( ) ; assertEquals ( <int> , networkPartition . getMajoritySide ( ) . size ( ) ) ; final String nonIsolatedNode = networkPartition . getMajoritySide ( ) . iterator ( ) . next ( ) ; networkPartition . startDisrupting ( ) ; logger . info ( <str> , isolatedNode ) ; assertNoMaster ( isolatedNode , DiscoverySettings . NO_MASTER_BLOCK_WRITES , TimeValue . timeValueSeconds ( <int> ) ) ; logger . info ( <str> , isolatedNode ) ; ensureStableCluster ( <int> , nonIsolatedNode ) ; for ( String node : networkPartition . getMajoritySide ( ) ) { ClusterState nodeState = getNodeClusterState ( node ) ; boolean success = true ; if ( nodeState . nodes ( ) . getMasterNode ( ) = = null ) { success = false ; } if ( ! nodeState . blocks ( ) . global ( ) . isEmpty ( ) ) { success = false ; } if ( ! success ) { fail ( <str> + node + <str> + nodeState . prettyPrint ( ) ) ; } } networkPartition . stopDisrupting ( ) ; ensureStableCluster ( <int> , new TimeValue ( DISRUPTION_HEALING_OVERHEAD . millis ( ) + networkPartition . expectedTimeToHeal ( ) . millis ( ) ) ) ; logger . info ( <str> , DiscoverySettings . NO_MASTER_BLOCK , <str> ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( DiscoverySettings . NO_MASTER_BLOCK , <str> ) ) . get ( ) ; networkPartition . startDisrupting ( ) ; logger . info ( <str> , isolatedNode ) ; assertNoMaster ( isolatedNode , DiscoverySettings . NO_MASTER_BLOCK_ALL , TimeValue . timeValueSeconds ( <int> ) ) ; ensureStableCluster ( <int> , nonIsolatedNode ) ; } public void testIsolateMasterAndVerifyClusterStateConsensus ( ) throws Exception { final List < String > nodes = startCluster ( <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> + randomInt ( <int> ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , randomInt ( <int> ) ) ) ) ; ensureGreen ( ) ; String isolatedNode = internalCluster ( ) . getMasterName ( ) ; NetworkPartition networkPartition = addRandomIsolation ( isolatedNode ) ; networkPartition . startDisrupting ( ) ; String nonIsolatedNode = networkPartition . getMajoritySide ( ) . iterator ( ) . next ( ) ; ensureStableCluster ( <int> , nonIsolatedNode ) ; assertNoMaster ( isolatedNode , TimeValue . timeValueSeconds ( <int> ) ) ; networkPartition . stopDisrupting ( ) ; for ( String node : nodes ) { ensureStableCluster ( <int> , new TimeValue ( DISRUPTION_HEALING_OVERHEAD . millis ( ) + networkPartition . expectedTimeToHeal ( ) . millis ( ) ) , true , node ) ; } logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) ) ; ensureGreen ( <str> ) ; ClusterState state = null ; for ( String node : nodes ) { ClusterState nodeState = getNodeClusterState ( node ) ; if ( state = = null ) { state = nodeState ; continue ; } try { assertEquals ( <str> , state . version ( ) , nodeState . version ( ) ) ; assertEquals ( <str> , state . nodes ( ) . size ( ) , nodeState . nodes ( ) . size ( ) ) ; assertEquals ( <str> , state . nodes ( ) . masterNodeId ( ) , nodeState . nodes ( ) . masterNodeId ( ) ) ; assertEquals ( <str> , state . metaData ( ) . version ( ) , nodeState . metaData ( ) . version ( ) ) ; if ( ! state . routingTable ( ) . prettyPrint ( ) . equals ( nodeState . routingTable ( ) . prettyPrint ( ) ) ) { fail ( <str> ) ; } } catch ( AssertionError t ) { fail ( <str> + t . getMessage ( ) + <str> + <str> + nodes . get ( <int> ) + <str> + state . prettyPrint ( ) + <str> + node + <str> + nodeState . prettyPrint ( ) ) ; } } } @LuceneTestCase.AwaitsFix ( bugUrl = <str> ) @TestLogging ( <str> ) public void testAckedIndexing ( ) throws Exception { final List < String > nodes = startCluster ( <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> + randomInt ( <int> ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , randomInt ( <int> ) ) ) ) ; ensureGreen ( ) ; ServiceDisruptionScheme disruptionScheme = addRandomDisruptionScheme ( ) ; logger . info ( <str> , disruptionScheme ) ; final ConcurrentHashMap < String , String > ackedDocs = new ConcurrentHashMap < > ( ) ; final AtomicBoolean stop = new AtomicBoolean ( false ) ; List < Thread > indexers = new ArrayList < > ( nodes . size ( ) ) ; List < Semaphore > semaphores = new ArrayList < > ( nodes . size ( ) ) ; final AtomicInteger idGenerator = new AtomicInteger ( <int> ) ; final AtomicReference < CountDownLatch > countDownLatchRef = new AtomicReference < > ( ) ; final List < Exception > exceptedExceptions = Collections . synchronizedList ( new ArrayList < Exception > ( ) ) ; logger . info ( <str> ) ; try { for ( final String node : nodes ) { final Semaphore semaphore = new Semaphore ( <int> ) ; semaphores . add ( semaphore ) ; final Client client = client ( node ) ; final String name = <str> + indexers . size ( ) ; final int numPrimaries = getNumShards ( <str> ) . numPrimaries ; Thread thread = new Thread ( new Runnable ( ) { @Override public void run ( ) { while ( ! stop . get ( ) ) { String id = null ; try { if ( ! semaphore . tryAcquire ( <int> , TimeUnit . SECONDS ) ) { continue ; } logger . info ( <str> , name , semaphore . availablePermits ( ) ) ; try { id = Integer . toString ( idGenerator . incrementAndGet ( ) ) ; int shard = Murmur3HashFunction . hash ( id ) % numPrimaries ; logger . trace ( <str> , name , id , node , shard ) ; IndexResponse response = client . prepareIndex ( <str> , <str> , id ) . setSource ( <str> ) . setTimeout ( <str> ) . get ( ) ; assertThat ( response . getVersion ( ) , equalTo ( <int> ) ) ; ackedDocs . put ( id , node ) ; logger . trace ( <str> , name , id , node ) ; } catch ( ElasticsearchException e ) { exceptedExceptions . add ( e ) ; logger . trace ( <str> , e , name , id , node ) ; } finally { countDownLatchRef . get ( ) . countDown ( ) ; logger . trace ( <str> , name , countDownLatchRef . get ( ) . getCount ( ) ) ; } } catch ( InterruptedException e ) { } catch ( Throwable t ) { logger . info ( <str> , t , node ) ; } } } } ) ; thread . setName ( name ) ; thread . start ( ) ; indexers . add ( thread ) ; } int docsPerIndexer = randomInt ( <int> ) ; logger . info ( <str> + docsPerIndexer + <str> ) ; countDownLatchRef . set ( new CountDownLatch ( docsPerIndexer * indexers . size ( ) ) ) ; for ( Semaphore semaphore : semaphores ) { semaphore . release ( docsPerIndexer ) ; } assertTrue ( countDownLatchRef . get ( ) . await ( <int> , TimeUnit . MINUTES ) ) ; for ( int iter = <int> + randomInt ( <int> ) ; iter > <int> ; iter - - ) { logger . info ( <str> , iter ) ; disruptionScheme . startDisrupting ( ) ; docsPerIndexer = <int> + randomInt ( <int> ) ; logger . info ( <str> + docsPerIndexer + <str> ) ; countDownLatchRef . set ( new CountDownLatch ( docsPerIndexer * indexers . size ( ) ) ) ; Collections . shuffle ( semaphores , random ( ) ) ; for ( Semaphore semaphore : semaphores ) { assertThat ( semaphore . availablePermits ( ) , equalTo ( <int> ) ) ; semaphore . release ( docsPerIndexer ) ; } assertTrue ( countDownLatchRef . get ( ) . await ( <int> + disruptionScheme . expectedTimeToHeal ( ) . millis ( ) * ( docsPerIndexer * indexers . size ( ) ) , TimeUnit . MILLISECONDS ) ) ; logger . info ( <str> ) ; disruptionScheme . stopDisrupting ( ) ; ensureStableCluster ( <int> , TimeValue . timeValueMillis ( disruptionScheme . expectedTimeToHeal ( ) . millis ( ) + DISRUPTION_HEALING_OVERHEAD . millis ( ) ) ) ; ensureGreen ( <str> ) ; logger . info ( <str> ) ; for ( String node : nodes ) { try { logger . debug ( <str> , node ) ; for ( String id : ackedDocs . keySet ( ) ) { assertTrue ( <str> + id + <str> + ackedDocs . get ( id ) + <str> , client ( node ) . prepareGet ( <str> , <str> , id ) . setPreference ( <str> ) . get ( ) . isExists ( ) ) ; } } catch ( AssertionError e ) { throw new AssertionError ( e . getMessage ( ) + <str> + node + <str> , e ) ; } } logger . info ( <str> , iter ) ; } } finally { if ( exceptedExceptions . size ( ) > <int> ) { StringBuilder sb = new StringBuilder ( <str> ) ; for ( Exception e : exceptedExceptions ) { sb . append ( <str> ) . append ( e . getMessage ( ) ) ; } logger . debug ( sb . toString ( ) ) ; } logger . info ( <str> ) ; stop . set ( true ) ; for ( Thread indexer : indexers ) { indexer . interrupt ( ) ; indexer . join ( <int> ) ; } } } public void testMasterNodeGCs ( ) throws Exception { List < String > nodes = startCluster ( <int> , - <int> ) ; String oldMasterNode = internalCluster ( ) . getMasterName ( ) ; SingleNodeDisruption masterNodeDisruption = new IntermittentLongGCDisruption ( oldMasterNode , getRandom ( ) , <int> , <int> , <int> , <int> ) ; internalCluster ( ) . setDisruptionScheme ( masterNodeDisruption ) ; masterNodeDisruption . startDisrupting ( ) ; Set < String > oldNonMasterNodesSet = new HashSet < > ( nodes ) ; oldNonMasterNodesSet . remove ( oldMasterNode ) ; List < String > oldNonMasterNodes = new ArrayList < > ( oldNonMasterNodesSet ) ; logger . info ( <str> , oldMasterNode ) ; for ( String node : oldNonMasterNodesSet ) { assertDifferentMaster ( node , oldMasterNode ) ; } logger . info ( <str> ) ; ensureStableCluster ( <int> , oldNonMasterNodes . get ( <int> ) ) ; logger . info ( <str> ) ; assertDiscoveryCompleted ( oldNonMasterNodes ) ; masterNodeDisruption . stopDisrupting ( ) ; ensureStableCluster ( <int> , new TimeValue ( DISRUPTION_HEALING_OVERHEAD . millis ( ) + masterNodeDisruption . expectedTimeToHeal ( ) . millis ( ) ) , false , oldNonMasterNodes . get ( <int> ) ) ; String newMaster = internalCluster ( ) . getMasterName ( ) ; assertThat ( newMaster , not ( equalTo ( oldMasterNode ) ) ) ; assertMaster ( newMaster , nodes ) ; } public void testStaleMasterNotHijackingMajority ( ) throws Exception { final List < String > nodes = startCluster ( <int> , <int> ) ; final String oldMasterNode = internalCluster ( ) . getMasterName ( ) ; for ( String node : nodes ) { ensureStableCluster ( <int> , node ) ; } assertMaster ( oldMasterNode , nodes ) ; SingleNodeDisruption masterNodeDisruption = new LongGCDisruption ( getRandom ( ) , oldMasterNode ) ; final List < String > majoritySide = new ArrayList < > ( nodes ) ; majoritySide . remove ( oldMasterNode ) ; final Map < String , List < Tuple < String , String > > > masters = Collections . synchronizedMap ( new HashMap < String , List < Tuple < String , String > > > ( ) ) ; for ( final String node : majoritySide ) { masters . put ( node , new ArrayList < Tuple < String , String > > ( ) ) ; internalCluster ( ) . getInstance ( ClusterService . class , node ) . add ( new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { DiscoveryNode previousMaster = event . previousState ( ) . nodes ( ) . getMasterNode ( ) ; DiscoveryNode currentMaster = event . state ( ) . nodes ( ) . getMasterNode ( ) ; if ( ! Objects . equals ( previousMaster , currentMaster ) ) { logger . info ( <str> , node , event . state ( ) , event . previousState ( ) ) ; String previousMasterNodeName = previousMaster ! = null ? previousMaster . name ( ) : null ; String currentMasterNodeName = currentMaster ! = null ? currentMaster . name ( ) : null ; masters . get ( node ) . add ( new Tuple < > ( previousMasterNodeName , currentMasterNodeName ) ) ; } } } ) ; } final CountDownLatch oldMasterNodeSteppedDown = new CountDownLatch ( <int> ) ; internalCluster ( ) . getInstance ( ClusterService . class , oldMasterNode ) . add ( new ClusterStateListener ( ) { @Override public void clusterChanged ( ClusterChangedEvent event ) { if ( event . state ( ) . nodes ( ) . masterNodeId ( ) = = null ) { oldMasterNodeSteppedDown . countDown ( ) ; } } } ) ; internalCluster ( ) . setDisruptionScheme ( masterNodeDisruption ) ; logger . info ( <str> , oldMasterNode ) ; masterNodeDisruption . startDisrupting ( ) ; assertDifferentMaster ( majoritySide . get ( <int> ) , oldMasterNode ) ; assertDifferentMaster ( majoritySide . get ( <int> ) , oldMasterNode ) ; assertDiscoveryCompleted ( majoritySide ) ; internalCluster ( ) . getInstance ( ClusterService . class , oldMasterNode ) . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( Priority . IMMEDIATE ) { @Override public ClusterState execute ( ClusterState currentState ) throws Exception { return ClusterState . builder ( currentState ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t , source ) ; } } ) ; final String newMasterNode = internalCluster ( ) . getMasterName ( majoritySide . get ( <int> ) ) ; logger . info ( <str> , newMasterNode ) ; logger . info ( <str> , oldMasterNode ) ; masterNodeDisruption . stopDisrupting ( ) ; oldMasterNodeSteppedDown . await ( <int> , TimeUnit . SECONDS ) ; assertDiscoveryCompleted ( nodes ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { assertMaster ( newMasterNode , nodes ) ; } } ) ; assertThat ( masters . size ( ) , equalTo ( <int> ) ) ; for ( Map . Entry < String , List < Tuple < String , String > > > entry : masters . entrySet ( ) ) { String nodeName = entry . getKey ( ) ; List < Tuple < String , String > > recordedMasterTransition = entry . getValue ( ) ; assertThat ( <str> + nodeName + <str> , recordedMasterTransition . size ( ) , equalTo ( <int> ) ) ; assertThat ( <str> + nodeName + <str> , recordedMasterTransition . get ( <int> ) . v1 ( ) , equalTo ( oldMasterNode ) ) ; assertThat ( <str> + nodeName + <str> + newMasterNode + <str> , recordedMasterTransition . get ( <int> ) . v2 ( ) , nullValue ( ) ) ; assertThat ( <str> + nodeName + <str> , recordedMasterTransition . get ( <int> ) . v1 ( ) , nullValue ( ) ) ; assertThat ( <str> + nodeName + <str> + newMasterNode + <str> , recordedMasterTransition . get ( <int> ) . v2 ( ) , equalTo ( newMasterNode ) ) ; } } @TestLogging ( value = <str> ) public void testRejoinDocumentExistsInAllShardCopies ( ) throws Exception { List < String > nodes = startCluster ( <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) . get ( ) ) ; ensureGreen ( <str> ) ; nodes = new ArrayList < > ( nodes ) ; Collections . shuffle ( nodes , random ( ) ) ; String isolatedNode = nodes . get ( <int> ) ; String notIsolatedNode = nodes . get ( <int> ) ; ServiceDisruptionScheme scheme = addRandomIsolation ( isolatedNode ) ; scheme . startDisrupting ( ) ; ensureStableCluster ( <int> , notIsolatedNode ) ; assertFalse ( client ( notIsolatedNode ) . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForYellowStatus ( ) . get ( ) . isTimedOut ( ) ) ; IndexResponse indexResponse = internalCluster ( ) . client ( notIsolatedNode ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; logger . info ( <str> + notIsolatedNode + <str> ) ; GetResponse getResponse = internalCluster ( ) . client ( notIsolatedNode ) . prepareGet ( <str> , <str> , indexResponse . getId ( ) ) . setPreference ( <str> ) . get ( ) ; assertThat ( getResponse . isExists ( ) , is ( true ) ) ; assertThat ( getResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertThat ( getResponse . getId ( ) , equalTo ( indexResponse . getId ( ) ) ) ; scheme . stopDisrupting ( ) ; ensureStableCluster ( <int> ) ; ensureGreen ( <str> ) ; for ( String node : nodes ) { logger . info ( <str> + isolatedNode + <str> + node + <str> ) ; getResponse = internalCluster ( ) . client ( node ) . prepareGet ( <str> , <str> , indexResponse . getId ( ) ) . setPreference ( <str> ) . get ( ) ; assertThat ( getResponse . isExists ( ) , is ( true ) ) ; assertThat ( getResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertThat ( getResponse . getId ( ) , equalTo ( indexResponse . getId ( ) ) ) ; } } public void testUnicastSinglePingResponseContainsMaster ( ) throws Exception { List < String > nodes = startCluster ( <int> , - <int> , new int [ ] { <int> } ) ; final String masterNode = internalCluster ( ) . getMasterName ( ) ; logger . info ( <str> + masterNode ) ; List < String > otherNodes = new ArrayList < > ( nodes ) ; otherNodes . remove ( masterNode ) ; otherNodes . remove ( nodes . get ( <int> ) ) ; final String isolatedNode = otherNodes . get ( <int> ) ; for ( ZenPingService pingService : internalCluster ( ) . getInstances ( ZenPingService . class ) ) { for ( ZenPing zenPing : pingService . zenPings ( ) ) { ( ( UnicastZenPing ) zenPing ) . clearTemporalResponses ( ) ; } } NetworkDisconnectPartition networkDisconnect = new NetworkDisconnectPartition ( masterNode , isolatedNode , getRandom ( ) ) ; setDisruptionScheme ( networkDisconnect ) ; networkDisconnect . startDisrupting ( ) ; ensureStableCluster ( <int> , masterNode ) ; assertNoMaster ( isolatedNode ) ; networkDisconnect . stopDisrupting ( ) ; ensureStableCluster ( <int> ) ; assertMaster ( masterNode , nodes ) ; } @TestLogging ( <str> ) public void testIsolatedUnicastNodes ( ) throws Exception { List < String > nodes = startCluster ( <int> , - <int> , new int [ ] { <int> } ) ; final String unicastTarget = nodes . get ( <int> ) ; Set < String > unicastTargetSide = new HashSet < > ( ) ; unicastTargetSide . add ( unicastTarget ) ; Set < String > restOfClusterSide = new HashSet < > ( ) ; restOfClusterSide . addAll ( nodes ) ; restOfClusterSide . remove ( unicastTarget ) ; for ( ZenPingService pingService : internalCluster ( ) . getInstances ( ZenPingService . class ) ) { for ( ZenPing zenPing : pingService . zenPings ( ) ) { ( ( UnicastZenPing ) zenPing ) . clearTemporalResponses ( ) ; } } NetworkDisconnectPartition networkDisconnect = new NetworkDisconnectPartition ( unicastTargetSide , restOfClusterSide , getRandom ( ) ) ; setDisruptionScheme ( networkDisconnect ) ; networkDisconnect . startDisrupting ( ) ; ensureStableCluster ( <int> , nodes . get ( <int> ) ) ; assertNoMaster ( unicastTarget ) ; networkDisconnect . stopDisrupting ( ) ; ensureStableCluster ( <int> ) ; } public void testClusterJoinDespiteOfPublishingIssues ( ) throws Exception { List < String > nodes = startCluster ( <int> , <int> ) ; String masterNode = internalCluster ( ) . getMasterName ( ) ; String nonMasterNode ; if ( masterNode . equals ( nodes . get ( <int> ) ) ) { nonMasterNode = nodes . get ( <int> ) ; } else { nonMasterNode = nodes . get ( <int> ) ; } DiscoveryNodes discoveryNodes = internalCluster ( ) . getInstance ( ClusterService . class , nonMasterNode ) . state ( ) . nodes ( ) ; TransportService masterTranspotService = internalCluster ( ) . getInstance ( TransportService . class , discoveryNodes . masterNode ( ) . getName ( ) ) ; logger . info ( <str> , nonMasterNode , masterNode ) ; MockTransportService nonMasterTransportService = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , nonMasterNode ) ; nonMasterTransportService . addFailToSendNoConnectRule ( masterTranspotService ) ; assertNoMaster ( nonMasterNode ) ; logger . info ( <str> , masterNode , nonMasterNode ) ; MockTransportService masterTransportService = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , masterNode ) ; TransportService localTransportService = internalCluster ( ) . getInstance ( TransportService . class , discoveryNodes . localNode ( ) . getName ( ) ) ; if ( randomBoolean ( ) ) { masterTransportService . addFailToSendNoConnectRule ( localTransportService , PublishClusterStateAction . SEND_ACTION_NAME ) ; } else { masterTransportService . addFailToSendNoConnectRule ( localTransportService , PublishClusterStateAction . COMMIT_ACTION_NAME ) ; } logger . info ( <str> , nonMasterNode , masterNode ) ; final CountDownLatch countDownLatch = new CountDownLatch ( <int> ) ; nonMasterTransportService . addDelegate ( masterTranspotService , new MockTransportService . DelegateTransport ( nonMasterTransportService . original ( ) ) { @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { if ( action . equals ( MembershipAction . DISCOVERY_JOIN_ACTION_NAME ) ) { countDownLatch . countDown ( ) ; } super . sendRequest ( node , requestId , action , request , options ) ; } } ) ; countDownLatch . await ( ) ; logger . info ( <str> ) ; masterTransportService . clearRule ( localTransportService ) ; nonMasterTransportService . clearRule ( localTransportService ) ; ensureStableCluster ( <int> ) ; internalCluster ( ) . stopRandomNonMasterNode ( ) ; } public void testClusterFormingWithASlowNode ( ) throws Exception { configureUnicastCluster ( <int> , null , <int> ) ; SlowClusterStateProcessing disruption = new SlowClusterStateProcessing ( getRandom ( ) , <int> , <int> , <int> , <int> ) ; internalCluster ( ) . startNodesAsync ( <int> , Settings . builder ( ) . put ( DiscoveryService . SETTING_INITIAL_STATE_TIMEOUT , <str> ) . put ( DiscoverySettings . PUBLISH_TIMEOUT , <str> ) . build ( ) ) . get ( ) ; logger . info ( <str> ) ; internalCluster ( ) . setDisruptionScheme ( disruption ) ; disruption . startDisrupting ( ) ; ensureStableCluster ( <int> ) ; } @TestLogging ( <str> ) public void testNodeNotReachableFromMaster ( ) throws Exception { startCluster ( <int> ) ; String masterNode = internalCluster ( ) . getMasterName ( ) ; String nonMasterNode = null ; while ( nonMasterNode = = null ) { nonMasterNode = randomFrom ( internalCluster ( ) . getNodeNames ( ) ) ; if ( nonMasterNode . equals ( masterNode ) ) { nonMasterNode = null ; } } logger . info ( <str> , masterNode , nonMasterNode ) ; MockTransportService masterTransportService = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , masterNode ) ; if ( randomBoolean ( ) ) { masterTransportService . addUnresponsiveRule ( internalCluster ( ) . getInstance ( TransportService . class , nonMasterNode ) ) ; } else { masterTransportService . addFailToSendNoConnectRule ( internalCluster ( ) . getInstance ( TransportService . class , nonMasterNode ) ) ; } logger . info ( <str> , nonMasterNode ) ; ensureStableCluster ( <int> , masterNode ) ; logger . info ( <str> , nonMasterNode ) ; assertNoMaster ( nonMasterNode ) ; logger . info ( <str> ) ; masterTransportService . clearAllRules ( ) ; ensureStableCluster ( <int> ) ; } public void testSearchWithRelocationAndSlowClusterStateProcessing ( ) throws Exception { configureUnicastCluster ( <int> , null , <int> ) ; InternalTestCluster . Async < String > masterNodeFuture = internalCluster ( ) . startMasterOnlyNodeAsync ( ) ; InternalTestCluster . Async < String > node_1Future = internalCluster ( ) . startDataOnlyNodeAsync ( ) ; final String node_1 = node_1Future . get ( ) ; final String masterNode = masterNodeFuture . get ( ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( indexSettings ( ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) ; ensureGreen ( <str> ) ; InternalTestCluster . Async < String > node_2Future = internalCluster ( ) . startDataOnlyNodeAsync ( ) ; final String node_2 = node_2Future . get ( ) ; List < IndexRequestBuilder > indexRequestBuilderList = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { indexRequestBuilderList . add ( client ( ) . prepareIndex ( ) . setIndex ( <str> ) . setType ( <str> ) . setSource ( <str> ) ) ; } indexRandom ( true , indexRequestBuilderList ) ; SingleNodeDisruption disruption = new BlockClusterStateProcessing ( node_2 , getRandom ( ) ) ; internalCluster ( ) . setDisruptionScheme ( disruption ) ; MockTransportService transportServiceNode2 = ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , node_2 ) ; CountDownLatch beginRelocationLatch = new CountDownLatch ( <int> ) ; CountDownLatch endRelocationLatch = new CountDownLatch ( <int> ) ; transportServiceNode2 . addTracer ( new IndicesStoreIntegrationIT . ReclocationStartEndTracer ( logger , beginRelocationLatch , endRelocationLatch ) ) ; internalCluster ( ) . client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , node_2 ) ) . get ( ) ; beginRelocationLatch . await ( ) ; disruption . startDisrupting ( ) ; endRelocationLatch . await ( ) ; assertThat ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; } public void testIndexImportedFromDataOnlyNodesIfMasterLostDataFolder ( ) throws Exception { configureUnicastCluster ( <int> , null , <int> ) ; String masterNode = internalCluster ( ) . startMasterOnlyNode ( Settings . EMPTY ) ; internalCluster ( ) . startDataOnlyNode ( Settings . EMPTY ) ; ensureStableCluster ( <int> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , <int> ) ) ) ; index ( <str> , <str> , <str> , jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) ; ensureGreen ( ) ; internalCluster ( ) . restartNode ( masterNode , new InternalTestCluster . RestartCallback ( ) { @Override public boolean clearData ( String nodeName ) { return true ; } } ) ; ensureGreen ( <str> ) ; assertTrue ( client ( ) . prepareGet ( <str> , <str> , <str> ) . get ( ) . isExists ( ) ) ; } @AwaitsFix ( bugUrl = <str> ) public void testIndicesDeleted ( ) throws Exception { configureUnicastCluster ( <int> , null , <int> ) ; InternalTestCluster . Async < List < String > > masterNodes = internalCluster ( ) . startMasterOnlyNodesAsync ( <int> ) ; InternalTestCluster . Async < String > dataNode = internalCluster ( ) . startDataOnlyNodeAsync ( ) ; dataNode . get ( ) ; masterNodes . get ( ) ; ensureStableCluster ( <int> ) ; assertAcked ( prepareCreate ( <str> ) ) ; ensureYellow ( ) ; String masterNode1 = internalCluster ( ) . getMasterName ( ) ; NetworkPartition networkPartition = new NetworkUnresponsivePartition ( masterNode1 , dataNode . get ( ) , getRandom ( ) ) ; internalCluster ( ) . setDisruptionScheme ( networkPartition ) ; networkPartition . startDisrupting ( ) ; internalCluster ( ) . client ( masterNode1 ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . setTimeout ( <str> ) . get ( ) ; internalCluster ( ) . restartNode ( masterNode1 , InternalTestCluster . EMPTY_CALLBACK ) ; ensureYellow ( ) ; assertFalse ( client ( ) . admin ( ) . indices ( ) . prepareExists ( <str> ) . get ( ) . isExists ( ) ) ; } protected NetworkPartition addRandomPartition ( ) { NetworkPartition partition ; if ( randomBoolean ( ) ) { partition = new NetworkUnresponsivePartition ( getRandom ( ) ) ; } else { partition = new NetworkDisconnectPartition ( getRandom ( ) ) ; } setDisruptionScheme ( partition ) ; return partition ; } protected NetworkPartition addRandomIsolation ( String isolatedNode ) { Set < String > side1 = new HashSet < > ( ) ; Set < String > side2 = new HashSet < > ( Arrays . asList ( internalCluster ( ) . getNodeNames ( ) ) ) ; side1 . add ( isolatedNode ) ; side2 . remove ( isolatedNode ) ; NetworkPartition partition ; if ( randomBoolean ( ) ) { partition = new NetworkUnresponsivePartition ( side1 , side2 , getRandom ( ) ) ; } else { partition = new NetworkDisconnectPartition ( side1 , side2 , getRandom ( ) ) ; } internalCluster ( ) . setDisruptionScheme ( partition ) ; return partition ; } private ServiceDisruptionScheme addRandomDisruptionScheme ( ) { List < ServiceDisruptionScheme > list = Arrays . asList ( new NetworkUnresponsivePartition ( getRandom ( ) ) , new NetworkDelaysPartition ( getRandom ( ) ) , new NetworkDisconnectPartition ( getRandom ( ) ) , new SlowClusterStateProcessing ( getRandom ( ) ) ) ; Collections . shuffle ( list , random ( ) ) ; setDisruptionScheme ( list . get ( <int> ) ) ; return list . get ( <int> ) ; } private ClusterState getNodeClusterState ( String node ) { return client ( node ) . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . get ( ) . getState ( ) ; } private void assertNoMaster ( final String node ) throws Exception { assertNoMaster ( node , null , TimeValue . timeValueSeconds ( <int> ) ) ; } private void assertNoMaster ( final String node , TimeValue maxWaitTime ) throws Exception { assertNoMaster ( node , null , maxWaitTime ) ; } private void assertNoMaster ( final String node , @Nullable final ClusterBlock expectedBlocks , TimeValue maxWaitTime ) throws Exception { assertBusy ( new Runnable ( ) { @Override public void run ( ) { ClusterState state = getNodeClusterState ( node ) ; assertNull ( <str> + node + <str> + state . nodes ( ) . masterNode ( ) + <str> , state . nodes ( ) . masterNode ( ) ) ; if ( expectedBlocks ! = null ) { for ( ClusterBlockLevel level : expectedBlocks . levels ( ) ) { assertTrue ( <str> + node + <str> + level + <str> , state . getBlocks ( ) . hasGlobalBlock ( level ) ) ; } } } } , maxWaitTime . getMillis ( ) , TimeUnit . MILLISECONDS ) ; } private void assertDifferentMaster ( final String node , final String oldMasterNode ) throws Exception { assertBusy ( new Runnable ( ) { @Override public void run ( ) { ClusterState state = getNodeClusterState ( node ) ; String masterNode = null ; if ( state . nodes ( ) . masterNode ( ) ! = null ) { masterNode = state . nodes ( ) . masterNode ( ) . name ( ) ; } logger . trace ( <str> , node , state . nodes ( ) . masterNode ( ) ) ; assertThat ( <str> + node + <str> + masterNode + <str> , oldMasterNode , not ( equalTo ( masterNode ) ) ) ; } } , <int> , TimeUnit . SECONDS ) ; } private void assertMaster ( String masterNode , List < String > nodes ) { for ( String node : nodes ) { ClusterState state = getNodeClusterState ( node ) ; String failMsgSuffix = <str> + state . prettyPrint ( ) ; assertThat ( <str> + node + <str> + failMsgSuffix , state . nodes ( ) . size ( ) , equalTo ( nodes . size ( ) ) ) ; String otherMasterNodeName = state . nodes ( ) . masterNode ( ) ! = null ? state . nodes ( ) . masterNode ( ) . name ( ) : null ; assertThat ( <str> + node + <str> + failMsgSuffix , otherMasterNodeName , equalTo ( masterNode ) ) ; } } private void assertDiscoveryCompleted ( List < String > nodes ) throws InterruptedException { for ( final String node : nodes ) { assertTrue ( <str> + node + <str> , awaitBusy ( ( ) - > ! ( ( ZenDiscovery ) internalCluster ( ) . getInstance ( Discovery . class , node ) ) . joiningCluster ( ) , <int> , TimeUnit . SECONDS ) ) ; } } } 
