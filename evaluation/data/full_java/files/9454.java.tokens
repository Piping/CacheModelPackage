package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . math . MathPreconditions . checkNonNegative ; import static com . google . common . math . MathPreconditions . checkPositive ; import static com . google . common . math . MathPreconditions . checkRoundingUnnecessary ; import static java . math . RoundingMode . CEILING ; import static java . math . RoundingMode . FLOOR ; import static java . math . RoundingMode . HALF_EVEN ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . annotations . VisibleForTesting ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . math . RoundingMode ; import java . util . ArrayList ; import java . util . List ; @GwtCompatible ( emulated = true ) public final class BigIntegerMath { public static boolean isPowerOfTwo ( BigInteger x ) { checkNotNull ( x ) ; return x . signum ( ) > <int> & & x . getLowestSetBit ( ) = = x . bitLength ( ) - <int> ; } @SuppressWarnings ( <str> ) public static int log2 ( BigInteger x , RoundingMode mode ) { checkPositive ( <str> , checkNotNull ( x ) ) ; int logFloor = x . bitLength ( ) - <int> ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( isPowerOfTwo ( x ) ) ; case DOWN : case FLOOR : return logFloor ; case UP : case CEILING : return isPowerOfTwo ( x ) ? logFloor : logFloor + <int> ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : if ( logFloor < SQRT2_PRECOMPUTE_THRESHOLD ) { BigInteger halfPower = SQRT2_PRECOMPUTED_BITS . shiftRight ( SQRT2_PRECOMPUTE_THRESHOLD - logFloor ) ; if ( x . compareTo ( halfPower ) < = <int> ) { return logFloor ; } else { return logFloor + <int> ; } } BigInteger x2 = x . pow ( <int> ) ; int logX2Floor = x2 . bitLength ( ) - <int> ; return ( logX2Floor < <int> * logFloor + <int> ) ? logFloor : logFloor + <int> ; default: throw new AssertionError ( ) ; } } @VisibleForTesting static final int SQRT2_PRECOMPUTE_THRESHOLD = <int> ; @VisibleForTesting static final BigInteger SQRT2_PRECOMPUTED_BITS = new BigInteger ( <str> , <int> ) ; @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static int log10 ( BigInteger x , RoundingMode mode ) { checkPositive ( <str> , x ) ; if ( fitsInLong ( x ) ) { return LongMath . log10 ( x . longValue ( ) , mode ) ; } int approxLog10 = ( int ) ( log2 ( x , FLOOR ) * LN_2 / LN_10 ) ; BigInteger approxPow = BigInteger . TEN . pow ( approxLog10 ) ; int approxCmp = approxPow . compareTo ( x ) ; if ( approxCmp > <int> ) { do { approxLog10 - - ; approxPow = approxPow . divide ( BigInteger . TEN ) ; approxCmp = approxPow . compareTo ( x ) ; } while ( approxCmp > <int> ) ; } else { BigInteger nextPow = BigInteger . TEN . multiply ( approxPow ) ; int nextCmp = nextPow . compareTo ( x ) ; while ( nextCmp < = <int> ) { approxLog10 + + ; approxPow = nextPow ; approxCmp = nextCmp ; nextPow = BigInteger . TEN . multiply ( approxPow ) ; nextCmp = nextPow . compareTo ( x ) ; } } int floorLog = approxLog10 ; BigInteger floorPow = approxPow ; int floorCmp = approxCmp ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( floorCmp = = <int> ) ; case FLOOR : case DOWN : return floorLog ; case CEILING : case UP : return floorPow . equals ( x ) ? floorLog : floorLog + <int> ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : BigInteger x2 = x . pow ( <int> ) ; BigInteger halfPowerSquared = floorPow . pow ( <int> ) . multiply ( BigInteger . TEN ) ; return ( x2 . compareTo ( halfPowerSquared ) < = <int> ) ? floorLog : floorLog + <int> ; default : throw new AssertionError ( ) ; } } private static final double LN_10 = Math . log ( <int> ) ; private static final double LN_2 = Math . log ( <int> ) ; @GwtIncompatible ( <str> ) @SuppressWarnings ( <str> ) public static BigInteger sqrt ( BigInteger x , RoundingMode mode ) { checkNonNegative ( <str> , x ) ; if ( fitsInLong ( x ) ) { return BigInteger . valueOf ( LongMath . sqrt ( x . longValue ( ) , mode ) ) ; } BigInteger sqrtFloor = sqrtFloor ( x ) ; switch ( mode ) { case UNNECESSARY : checkRoundingUnnecessary ( sqrtFloor . pow ( <int> ) . equals ( x ) ) ; case FLOOR : case DOWN : return sqrtFloor ; case CEILING : case UP : int sqrtFloorInt = sqrtFloor . intValue ( ) ; boolean sqrtFloorIsExact = ( sqrtFloorInt * sqrtFloorInt = = x . intValue ( ) ) & & sqrtFloor . pow ( <int> ) . equals ( x ) ; return sqrtFloorIsExact ? sqrtFloor : sqrtFloor . add ( BigInteger . ONE ) ; case HALF_DOWN : case HALF_UP : case HALF_EVEN : BigInteger halfSquare = sqrtFloor . pow ( <int> ) . add ( sqrtFloor ) ; return ( halfSquare . compareTo ( x ) > = <int> ) ? sqrtFloor : sqrtFloor . add ( BigInteger . ONE ) ; default : throw new AssertionError ( ) ; } } @GwtIncompatible ( <str> ) private static BigInteger sqrtFloor ( BigInteger x ) { BigInteger sqrt0 ; int log2 = log2 ( x , FLOOR ) ; if ( log2 < Double . MAX_EXPONENT ) { sqrt0 = sqrtApproxWithDoubles ( x ) ; } else { int shift = ( log2 - DoubleUtils . SIGNIFICAND_BITS ) & ~ <int> ; sqrt0 = sqrtApproxWithDoubles ( x . shiftRight ( shift ) ) . shiftLeft ( shift > > <int> ) ; } BigInteger sqrt1 = sqrt0 . add ( x . divide ( sqrt0 ) ) . shiftRight ( <int> ) ; if ( sqrt0 . equals ( sqrt1 ) ) { return sqrt0 ; } do { sqrt0 = sqrt1 ; sqrt1 = sqrt0 . add ( x . divide ( sqrt0 ) ) . shiftRight ( <int> ) ; } while ( sqrt1 . compareTo ( sqrt0 ) < <int> ) ; return sqrt0 ; } @GwtIncompatible ( <str> ) private static BigInteger sqrtApproxWithDoubles ( BigInteger x ) { return DoubleMath . roundToBigInteger ( Math . sqrt ( DoubleUtils . bigToDouble ( x ) ) , HALF_EVEN ) ; } @GwtIncompatible ( <str> ) public static BigInteger divide ( BigInteger p , BigInteger q , RoundingMode mode ) { BigDecimal pDec = new BigDecimal ( p ) ; BigDecimal qDec = new BigDecimal ( q ) ; return pDec . divide ( qDec , <int> , mode ) . toBigIntegerExact ( ) ; } public static BigInteger factorial ( int n ) { checkNonNegative ( <str> , n ) ; if ( n < LongMath . factorials . length ) { return BigInteger . valueOf ( LongMath . factorials [ n ] ) ; } int approxSize = IntMath . divide ( n * IntMath . log2 ( n , CEILING ) , Long . SIZE , CEILING ) ; ArrayList < BigInteger > bignums = new ArrayList < BigInteger > ( approxSize ) ; int startingNumber = LongMath . factorials . length ; long product = LongMath . factorials [ startingNumber - <int> ] ; int shift = Long . numberOfTrailingZeros ( product ) ; product > > = shift ; int productBits = LongMath . log2 ( product , FLOOR ) + <int> ; int bits = LongMath . log2 ( startingNumber , FLOOR ) + <int> ; int nextPowerOfTwo = <int> < < ( bits - <int> ) ; for ( long num = startingNumber ; num < = n ; num + + ) { if ( ( num & nextPowerOfTwo ) ! = <int> ) { nextPowerOfTwo < < = <int> ; bits + + ; } int tz = Long . numberOfTrailingZeros ( num ) ; long normalizedNum = num > > tz ; shift + = tz ; int normalizedBits = bits - tz ; if ( normalizedBits + productBits > = Long . SIZE ) { bignums . add ( BigInteger . valueOf ( product ) ) ; product = <int> ; productBits = <int> ; } product * = normalizedNum ; productBits = LongMath . log2 ( product , FLOOR ) + <int> ; } if ( product > <int> ) { bignums . add ( BigInteger . valueOf ( product ) ) ; } return listProduct ( bignums ) . shiftLeft ( shift ) ; } static BigInteger listProduct ( List < BigInteger > nums ) { return listProduct ( nums , <int> , nums . size ( ) ) ; } static BigInteger listProduct ( List < BigInteger > nums , int start , int end ) { switch ( end - start ) { case <int> : return BigInteger . ONE ; case <int> : return nums . get ( start ) ; case <int> : return nums . get ( start ) . multiply ( nums . get ( start + <int> ) ) ; case <int> : return nums . get ( start ) . multiply ( nums . get ( start + <int> ) ) . multiply ( nums . get ( start + <int> ) ) ; default : int m = ( end + start ) > > > <int> ; return listProduct ( nums , start , m ) . multiply ( listProduct ( nums , m , end ) ) ; } } public static BigInteger binomial ( int n , int k ) { checkNonNegative ( <str> , n ) ; checkNonNegative ( <str> , k ) ; checkArgument ( k < = n , <str> , k , n ) ; if ( k > ( n > > <int> ) ) { k = n - k ; } if ( k < LongMath . biggestBinomials . length & & n < = LongMath . biggestBinomials [ k ] ) { return BigInteger . valueOf ( LongMath . binomial ( n , k ) ) ; } BigInteger accum = BigInteger . ONE ; long numeratorAccum = n ; long denominatorAccum = <int> ; int bits = LongMath . log2 ( n , RoundingMode . CEILING ) ; int numeratorBits = bits ; for ( int i = <int> ; i < k ; i + + ) { int p = n - i ; int q = i + <int> ; if ( numeratorBits + bits > = Long . SIZE - <int> ) { accum = accum . multiply ( BigInteger . valueOf ( numeratorAccum ) ) . divide ( BigInteger . valueOf ( denominatorAccum ) ) ; numeratorAccum = p ; denominatorAccum = q ; numeratorBits = bits ; } else { numeratorAccum * = p ; denominatorAccum * = q ; numeratorBits + = bits ; } } return accum . multiply ( BigInteger . valueOf ( numeratorAccum ) ) . divide ( BigInteger . valueOf ( denominatorAccum ) ) ; } @GwtIncompatible ( <str> ) static boolean fitsInLong ( BigInteger x ) { return x . bitLength ( ) < = Long . SIZE - <int> ; } private BigIntegerMath ( ) { } } 
