package org . apache . cassandra . tools ; import java . io . IOException ; import java . io . PrintStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import com . google . common . base . Throwables ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . SSTableReader ; public class SSTableOfflineRelevel { public static void main ( String [ ] args ) throws IOException { PrintStream out = System . out ; if ( args . length < <int> ) { out . println ( <str> ) ; out . println ( <str> ) ; System . exit ( <int> ) ; } Util . initDatabaseDescriptor ( ) ; boolean dryRun = args [ <int> ] . equals ( <str> ) ; String keyspace = args [ args . length - <int> ] ; String columnfamily = args [ args . length - <int> ] ; Schema . instance . loadFromDisk ( false ) ; if ( Schema . instance . getCFMetaData ( keyspace , columnfamily ) = = null ) throw new IllegalArgumentException ( String . format ( <str> , keyspace , columnfamily ) ) ; Keyspace ks = Keyspace . openWithoutSSTables ( keyspace ) ; ColumnFamilyStore cfs = ks . getColumnFamilyStore ( columnfamily ) ; Directories . SSTableLister lister = cfs . getDirectories ( ) . sstableLister ( Directories . OnTxnErr . THROW ) . skipTemporary ( true ) ; Set < SSTableReader > sstables = new HashSet < > ( ) ; for ( Map . Entry < Descriptor , Set < Component > > sstable : lister . list ( ) . entrySet ( ) ) { if ( sstable . getKey ( ) ! = null ) { try { SSTableReader reader = SSTableReader . open ( sstable . getKey ( ) ) ; sstables . add ( reader ) ; } catch ( Throwable t ) { out . println ( <str> + sstable . getKey ( ) . filenameFor ( Component . DATA ) ) ; Throwables . propagate ( t ) ; } } } if ( sstables . isEmpty ( ) ) { out . println ( <str> + keyspace + <str> + columnfamily ) ; System . exit ( <int> ) ; } Relevel rl = new Relevel ( sstables ) ; rl . relevel ( dryRun ) ; System . exit ( <int> ) ; } private static class Relevel { private final Set < SSTableReader > sstables ; private final int approxExpectedLevels ; public Relevel ( Set < SSTableReader > sstables ) { this . sstables = sstables ; approxExpectedLevels = ( int ) Math . ceil ( Math . log10 ( sstables . size ( ) ) ) ; } public void relevel ( boolean dryRun ) throws IOException { List < SSTableReader > sortedSSTables = new ArrayList < > ( sstables ) ; Collections . sort ( sortedSSTables , new Comparator < SSTableReader > ( ) { @Override public int compare ( SSTableReader o1 , SSTableReader o2 ) { return o1 . last . compareTo ( o2 . last ) ; } } ) ; List < List < SSTableReader > > levels = new ArrayList < > ( ) ; while ( ! sortedSSTables . isEmpty ( ) ) { Iterator < SSTableReader > it = sortedSSTables . iterator ( ) ; List < SSTableReader > level = new ArrayList < > ( ) ; DecoratedKey lastLast = null ; while ( it . hasNext ( ) ) { SSTableReader sstable = it . next ( ) ; if ( lastLast = = null | | lastLast . compareTo ( sstable . first ) < <int> ) { level . add ( sstable ) ; lastLast = sstable . last ; it . remove ( ) ; } } levels . add ( level ) ; } List < SSTableReader > l0 = new ArrayList < > ( ) ; if ( approxExpectedLevels < levels . size ( ) ) { for ( int i = approxExpectedLevels ; i < levels . size ( ) ; i + + ) l0 . addAll ( levels . get ( i ) ) ; levels = levels . subList ( <int> , approxExpectedLevels ) ; } if ( dryRun ) System . out . println ( <str> ) ; else System . out . println ( <str> ) ; System . out . println ( <str> + l0 . size ( ) ) ; for ( int i = levels . size ( ) - <int> ; i > = <int> ; i - - ) System . out . println ( String . format ( <str> , levels . size ( ) - i , levels . get ( i ) . size ( ) ) ) ; if ( ! dryRun ) { for ( SSTableReader sstable : l0 ) { if ( sstable . getSSTableLevel ( ) ! = <int> ) sstable . descriptor . getMetadataSerializer ( ) . mutateLevel ( sstable . descriptor , <int> ) ; } for ( int i = levels . size ( ) - <int> ; i > = <int> ; i - - ) { for ( SSTableReader sstable : levels . get ( i ) ) { int newLevel = levels . size ( ) - i ; if ( newLevel ! = sstable . getSSTableLevel ( ) ) sstable . descriptor . getMetadataSerializer ( ) . mutateLevel ( sstable . descriptor , newLevel ) ; } } } } } } 
