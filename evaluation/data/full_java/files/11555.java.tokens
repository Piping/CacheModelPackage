package org . gradle . api . internal . file . copy ; import org . gradle . api . file . DeleteAction ; import org . gradle . api . file . UnableToDeleteFileException ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . internal . os . OperatingSystem ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; public class DeleteActionImpl implements DeleteAction { private static Logger logger = LoggerFactory . getLogger ( DeleteActionImpl . class ) ; private FileResolver fileResolver ; private static final int DELETE_RETRY_SLEEP_MILLIS = <int> ; public DeleteActionImpl ( FileResolver fileResolver ) { this . fileResolver = fileResolver ; } public boolean delete ( Object . . . deletes ) { boolean didWork = false ; for ( File file : fileResolver . resolveFiles ( deletes ) ) { if ( ! file . exists ( ) ) { continue ; } logger . debug ( <str> , file ) ; didWork = true ; doDelete ( file ) ; } return didWork ; } private void doDelete ( File file ) { if ( file . isDirectory ( ) ) { File [ ] contents = file . listFiles ( ) ; if ( contents = = null ) { return ; } for ( File item : contents ) { doDelete ( item ) ; } } if ( ! file . delete ( ) & & file . exists ( ) ) { handleFailedDelete ( file ) ; } } private boolean isRunGcOnFailedDelete ( ) { return OperatingSystem . current ( ) . isWindows ( ) ; } private void handleFailedDelete ( File file ) { if ( isRunGcOnFailedDelete ( ) ) { System . gc ( ) ; } try { Thread . sleep ( DELETE_RETRY_SLEEP_MILLIS ) ; } catch ( InterruptedException ex ) { } if ( ! file . delete ( ) & & file . exists ( ) ) { throw new UnableToDeleteFileException ( file ) ; } } } 
