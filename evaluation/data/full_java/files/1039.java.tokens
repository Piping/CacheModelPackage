package org . apache . cassandra . thrift ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Comparator ; import java . util . List ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . Attributes ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . index . SecondaryIndexManager ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; public class ThriftValidation { private static final Logger logger = LoggerFactory . getLogger ( ThriftValidation . class ) ; public static void validateKey ( CFMetaData metadata , ByteBuffer key ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( key = = null | | key . remaining ( ) = = <int> ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } if ( key . remaining ( ) > FBUtilities . MAX_UNSIGNED_SHORT ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + key . remaining ( ) + <str> + FBUtilities . MAX_UNSIGNED_SHORT ) ; } try { metadata . getKeyValidator ( ) . validate ( key ) ; } catch ( MarshalException e ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( e . getMessage ( ) ) ; } } public static void validateKeyspace ( String keyspaceName ) throws KeyspaceNotDefinedException { if ( ! Schema . instance . getKeyspaces ( ) . contains ( keyspaceName ) ) { throw new KeyspaceNotDefinedException ( <str> + keyspaceName + <str> ) ; } } public static CFMetaData validateColumnFamily ( String keyspaceName , String cfName , boolean isCommutativeOp ) throws org . apache . cassandra . exceptions . InvalidRequestException { CFMetaData metadata = validateColumnFamily ( keyspaceName , cfName ) ; if ( isCommutativeOp ) { if ( ! metadata . isCounter ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + cfName ) ; } else { if ( metadata . isCounter ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + cfName ) ; } return metadata ; } public static CFMetaData validateColumnFamily ( String keyspaceName , String cfName ) throws org . apache . cassandra . exceptions . InvalidRequestException { validateKeyspace ( keyspaceName ) ; if ( cfName . isEmpty ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; CFMetaData metadata = Schema . instance . getCFMetaData ( keyspaceName , cfName ) ; if ( metadata = = null ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + cfName ) ; return metadata ; } public static void validateColumnPath ( CFMetaData metadata , ColumnPath column_path ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( ! metadata . isSuper ( ) ) { if ( column_path . super_column ! = null ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; } if ( column_path . column = = null ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; } } else { if ( column_path . super_column = = null ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; } if ( column_path . column ! = null ) { validateColumnNames ( metadata , column_path . super_column , Arrays . asList ( column_path . column ) ) ; } if ( column_path . super_column ! = null ) { validateColumnNames ( metadata , ( ByteBuffer ) null , Arrays . asList ( column_path . super_column ) ) ; } } public static void validateColumnParent ( CFMetaData metadata , ColumnParent column_parent ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( ! metadata . isSuper ( ) ) { if ( column_parent . super_column ! = null ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; } } if ( column_parent . super_column ! = null ) { validateColumnNames ( metadata , ( ByteBuffer ) null , Arrays . asList ( column_parent . super_column ) ) ; } } static void validateColumnPathOrParent ( CFMetaData metadata , ColumnPath column_path_or_parent ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( metadata . isSuper ( ) ) { if ( column_path_or_parent . super_column = = null & & column_path_or_parent . column ! = null ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; } } else { if ( column_path_or_parent . super_column ! = null ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; } } if ( column_path_or_parent . column ! = null ) { validateColumnNames ( metadata , column_path_or_parent . super_column , Arrays . asList ( column_path_or_parent . column ) ) ; } if ( column_path_or_parent . super_column ! = null ) { validateColumnNames ( metadata , ( ByteBuffer ) null , Arrays . asList ( column_path_or_parent . super_column ) ) ; } } private static AbstractType < ? > getThriftColumnNameComparator ( CFMetaData metadata , ByteBuffer superColumnName ) { if ( ! metadata . isSuper ( ) ) return LegacyLayout . makeLegacyComparator ( metadata ) ; if ( superColumnName = = null ) { return metadata . comparator . subtype ( <int> ) ; } else { return metadata . thriftColumnNameType ( ) ; } } private static void validateColumnNames ( CFMetaData metadata , ByteBuffer superColumnName , Iterable < ByteBuffer > column_names ) throws org . apache . cassandra . exceptions . InvalidRequestException { int maxNameLength = LegacyLayout . MAX_CELL_NAME_LENGTH ; if ( superColumnName ! = null ) { if ( superColumnName . remaining ( ) > maxNameLength ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + maxNameLength ) ; if ( superColumnName . remaining ( ) = = <int> ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; if ( ! metadata . isSuper ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName + <str> ) ; } AbstractType < ? > comparator = getThriftColumnNameComparator ( metadata , superColumnName ) ; boolean isCQL3Table = ! metadata . isThriftCompatible ( ) ; for ( ByteBuffer name : column_names ) { if ( name . remaining ( ) > maxNameLength ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + maxNameLength ) ; if ( name . remaining ( ) = = <int> ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; try { comparator . validate ( name ) ; } catch ( MarshalException e ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( e . getMessage ( ) ) ; } if ( isCQL3Table ) { try { LegacyLayout . LegacyCellName cname = LegacyLayout . decodeCellName ( metadata , name ) ; assert cname . clustering . size ( ) = = metadata . comparator . size ( ) ; for ( int i = <int> ; i < cname . clustering . size ( ) ; i + + ) { if ( cname . clustering . get ( i ) = = null ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , i , metadata . comparator . size ( ) + <int> , metadata . cfName ) ) ; } if ( cname . column ! = null & & cname . collectionElement ! = null & & ! cname . column . type . isCollection ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , cname . column . name ) ) ; } catch ( IllegalArgumentException | UnknownColumnException e ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , metadata . cfName , e . getMessage ( ) ) ) ; } } } } public static void validateColumnNames ( CFMetaData metadata , ColumnParent column_parent , Iterable < ByteBuffer > column_names ) throws org . apache . cassandra . exceptions . InvalidRequestException { validateColumnNames ( metadata , column_parent . super_column , column_names ) ; } public static void validateRange ( CFMetaData metadata , ColumnParent column_parent , SliceRange range ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( range . count < <int> ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; int maxNameLength = LegacyLayout . MAX_CELL_NAME_LENGTH ; if ( range . start . remaining ( ) > maxNameLength ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + maxNameLength ) ; if ( range . finish . remaining ( ) > maxNameLength ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + maxNameLength ) ; AbstractType < ? > comparator = getThriftColumnNameComparator ( metadata , column_parent . super_column ) ; try { comparator . validate ( range . start ) ; comparator . validate ( range . finish ) ; } catch ( MarshalException e ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( e . getMessage ( ) ) ; } Comparator < ByteBuffer > orderedComparator = range . isReversed ( ) ? comparator . reverseComparator : comparator ; if ( range . start . remaining ( ) > <int> & & range . finish . remaining ( ) > <int> & & orderedComparator . compare ( range . start , range . finish ) > <int> ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } } public static void validateColumnOrSuperColumn ( CFMetaData metadata , ColumnOrSuperColumn cosc ) throws org . apache . cassandra . exceptions . InvalidRequestException { boolean isCommutative = metadata . isCounter ( ) ; int nulls = <int> ; if ( cosc . column = = null ) nulls + + ; if ( cosc . super_column = = null ) nulls + + ; if ( cosc . counter_column = = null ) nulls + + ; if ( cosc . counter_super_column = = null ) nulls + + ; if ( nulls ! = <int> ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; if ( cosc . column ! = null ) { if ( isCommutative ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; validateTtl ( cosc . column ) ; validateColumnPath ( metadata , new ColumnPath ( metadata . cfName ) . setSuper_column ( ( ByteBuffer ) null ) . setColumn ( cosc . column . name ) ) ; validateColumnData ( metadata , null , cosc . column ) ; } if ( cosc . super_column ! = null ) { if ( isCommutative ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; for ( Column c : cosc . super_column . columns ) { validateColumnPath ( metadata , new ColumnPath ( metadata . cfName ) . setSuper_column ( cosc . super_column . name ) . setColumn ( c . name ) ) ; validateColumnData ( metadata , cosc . super_column . name , c ) ; } } if ( cosc . counter_column ! = null ) { if ( ! isCommutative ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; validateColumnPath ( metadata , new ColumnPath ( metadata . cfName ) . setSuper_column ( ( ByteBuffer ) null ) . setColumn ( cosc . counter_column . name ) ) ; } if ( cosc . counter_super_column ! = null ) { if ( ! isCommutative ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; for ( CounterColumn c : cosc . counter_super_column . columns ) validateColumnPath ( metadata , new ColumnPath ( metadata . cfName ) . setSuper_column ( cosc . counter_super_column . name ) . setColumn ( c . name ) ) ; } } private static void validateTtl ( Column column ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( column . isSetTtl ( ) ) { if ( column . ttl < = <int> ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; if ( column . ttl > Attributes . MAX_TTL ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , column . ttl , Attributes . MAX_TTL ) ) ; } else { assert column . ttl = = <int> ; } } public static void validateMutation ( CFMetaData metadata , Mutation mut ) throws org . apache . cassandra . exceptions . InvalidRequestException { ColumnOrSuperColumn cosc = mut . column_or_supercolumn ; Deletion del = mut . deletion ; int nulls = <int> ; if ( cosc = = null ) nulls + + ; if ( del = = null ) nulls + + ; if ( nulls ! = <int> ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } if ( cosc ! = null ) { validateColumnOrSuperColumn ( metadata , cosc ) ; } else { validateDeletion ( metadata , del ) ; } } public static void validateDeletion ( CFMetaData metadata , Deletion del ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( del . super_column ! = null ) validateColumnNames ( metadata , ( ByteBuffer ) null , Arrays . asList ( del . super_column ) ) ; if ( del . predicate ! = null ) validateSlicePredicate ( metadata , del . super_column , del . predicate ) ; if ( ! metadata . isSuper ( ) & & del . super_column ! = null ) { String msg = String . format ( <str> , metadata . ksName , metadata . cfName , del ) ; throw new org . apache . cassandra . exceptions . InvalidRequestException ( msg ) ; } if ( metadata . isCounter ( ) ) { del . timestamp = FBUtilities . timestampMicros ( ) ; } else if ( ! del . isSetTimestamp ( ) ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> + metadata . cfName ) ; } } public static void validateSlicePredicate ( CFMetaData metadata , ByteBuffer scName , SlicePredicate predicate ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( predicate . column_names = = null & & predicate . slice_range = = null ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; if ( predicate . slice_range ! = null ) validateRange ( metadata , new ColumnParent ( metadata . cfName ) . setSuper_column ( scName ) , predicate . slice_range ) ; if ( predicate . column_names ! = null ) validateColumnNames ( metadata , scName , predicate . column_names ) ; } public static void validateColumnData ( CFMetaData metadata , ByteBuffer scName , Column column ) throws org . apache . cassandra . exceptions . InvalidRequestException { validateTtl ( column ) ; if ( ! column . isSetValue ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; if ( ! column . isSetTimestamp ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; try { LegacyLayout . LegacyCellName cn = LegacyLayout . decodeCellName ( metadata , scName , column . name ) ; cn . column . validateCellValue ( column . value ) ; } catch ( UnknownColumnException e ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( e . getMessage ( ) ) ; } catch ( MarshalException me ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , ByteBufferUtil . bytesToHex ( summarize ( column . value ) ) ) ; throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , me . getMessage ( ) , metadata . ksName , metadata . cfName , ( getThriftColumnNameComparator ( metadata , scName ) ) . getString ( column . name ) ) ) ; } } private static ByteBuffer summarize ( ByteBuffer buffer ) { int MAX = Short . MAX_VALUE ; if ( buffer . remaining ( ) < = MAX ) return buffer ; return ( ByteBuffer ) buffer . slice ( ) . limit ( buffer . position ( ) + MAX ) ; } public static void validatePredicate ( CFMetaData metadata , ColumnParent column_parent , SlicePredicate predicate ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( predicate . column_names = = null & & predicate . slice_range = = null ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; if ( predicate . column_names ! = null & & predicate . slice_range ! = null ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; if ( predicate . getSlice_range ( ) ! = null ) validateRange ( metadata , column_parent , predicate . slice_range ) ; else validateColumnNames ( metadata , column_parent , predicate . column_names ) ; } public static void validateKeyRange ( CFMetaData metadata , ByteBuffer superColumn , KeyRange range ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( ( range . start_key = = null ) = = ( range . start_token = = null ) | | ( range . end_key = = null ) = = ( range . end_token = = null ) ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } if ( range . start_token ! = null & & range . end_key ! = null ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; IPartitioner p = metadata . partitioner ; if ( range . start_key ! = null & & range . end_key ! = null ) { Token startToken = p . getToken ( range . start_key ) ; Token endToken = p . getToken ( range . end_key ) ; if ( startToken . compareTo ( endToken ) > <int> & & ! endToken . isMinimum ( ) ) { if ( p . preservesOrder ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; else throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } } else if ( range . start_key ! = null & & range . end_token ! = null ) { PartitionPosition stop = p . getTokenFactory ( ) . fromString ( range . end_token ) . maxKeyBound ( ) ; if ( PartitionPosition . ForKey . get ( range . start_key , p ) . compareTo ( stop ) > <int> & & ! stop . isMinimum ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } validateFilterClauses ( metadata , range . row_filter ) ; if ( ! isEmpty ( range . row_filter ) & & superColumn ! = null ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } if ( range . count < = <int> ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } } private static boolean isEmpty ( List < IndexExpression > clause ) { return clause = = null | | clause . isEmpty ( ) ; } public static void validateIndexClauses ( CFMetaData metadata , IndexClause index_clause ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( index_clause . expressions . isEmpty ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; if ( ! validateFilterClauses ( metadata , index_clause . expressions ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; } public static boolean validateFilterClauses ( CFMetaData metadata , List < IndexExpression > index_clause ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( isEmpty ( index_clause ) ) return false ; SecondaryIndexManager idxManager = Keyspace . open ( metadata . ksName ) . getColumnFamilyStore ( metadata . cfName ) . indexManager ; AbstractType < ? > nameValidator = getThriftColumnNameComparator ( metadata , null ) ; boolean isIndexed = false ; for ( IndexExpression expression : index_clause ) { try { nameValidator . validate ( expression . column_name ) ; } catch ( MarshalException me ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , ByteBufferUtil . bytesToHex ( expression . column_name ) , ByteBufferUtil . bytesToHex ( expression . value ) , me . getMessage ( ) ) ) ; } if ( expression . value . remaining ( ) > <hex> ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( <str> ) ; ColumnDefinition def = metadata . getColumnDefinition ( expression . column_name ) ; if ( def = = null ) { if ( ! metadata . isCompactTable ( ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , nameValidator . getString ( expression . column_name ) ) ) ; def = metadata . compactValueColumn ( ) ; } try { def . type . validate ( expression . value ) ; } catch ( MarshalException me ) { throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , ByteBufferUtil . bytesToHex ( expression . column_name ) , ByteBufferUtil . bytesToHex ( expression . value ) , me . getMessage ( ) ) ) ; } for ( Index index : idxManager . listIndexes ( ) ) isIndexed | = index . supportsExpression ( def , Operator . valueOf ( expression . op . name ( ) ) ) ; } return isIndexed ; } public static void validateKeyspaceNotYetExisting ( String newKsName ) throws org . apache . cassandra . exceptions . InvalidRequestException { for ( String ksName : Schema . instance . getKeyspaces ( ) ) { if ( ksName . equalsIgnoreCase ( newKsName ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , newKsName , ksName ) ) ; } } public static void validateKeyspaceNotSystem ( String modifiedKeyspace ) throws org . apache . cassandra . exceptions . InvalidRequestException { if ( Schema . isSystemKeyspace ( modifiedKeyspace ) ) throw new org . apache . cassandra . exceptions . InvalidRequestException ( String . format ( <str> , modifiedKeyspace ) ) ; } } 
