package org . elasticsearch . search . scroll ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . routing . allocation . decider . ShardsLimitAllocationDecider ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAllSuccessful ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . lessThan ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> , numClientNodes = <int> ) public class SearchScrollWithFailingNodesIT extends ESIntegTestCase { @Override protected int numberOfShards ( ) { return <int> ; } @Override protected int numberOfReplicas ( ) { return <int> ; } public void testScanScrollWithShardExceptions ( ) throws Exception { internalCluster ( ) . startNode ( ) ; internalCluster ( ) . startNode ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( indexSettings ( ) ) . put ( ShardsLimitAllocationDecider . INDEX_TOTAL_SHARDS_PER_NODE , <int> ) ) ) ; List < IndexRequestBuilder > writes = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { writes . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , i ) . endObject ( ) ) ) ; } indexRandom ( false , writes ) ; refresh ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setSize ( <int> ) . setScroll ( TimeValue . timeValueMinutes ( <int> ) ) . get ( ) ; assertAllSuccessful ( searchResponse ) ; long numHits = <int> ; do { numHits + = searchResponse . getHits ( ) . hits ( ) . length ; searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( TimeValue . timeValueMinutes ( <int> ) ) . get ( ) ; assertAllSuccessful ( searchResponse ) ; } while ( searchResponse . getHits ( ) . hits ( ) . length > <int> ) ; assertThat ( numHits , equalTo ( <int> ) ) ; clearScroll ( <str> ) ; internalCluster ( ) . stopRandomNonMasterNode ( ) ; searchResponse = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setSize ( <int> ) . setScroll ( TimeValue . timeValueMinutes ( <int> ) ) . get ( ) ; assertThat ( searchResponse . getSuccessfulShards ( ) , lessThan ( searchResponse . getTotalShards ( ) ) ) ; numHits = <int> ; int numberOfSuccessfulShards = searchResponse . getSuccessfulShards ( ) ; do { numHits + = searchResponse . getHits ( ) . hits ( ) . length ; searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( TimeValue . timeValueMinutes ( <int> ) ) . get ( ) ; assertThat ( searchResponse . getSuccessfulShards ( ) , equalTo ( numberOfSuccessfulShards ) ) ; } while ( searchResponse . getHits ( ) . hits ( ) . length > <int> ) ; assertThat ( numHits , greaterThan ( <int> l ) ) ; clearScroll ( searchResponse . getScrollId ( ) ) ; } } 
