package io . netty . handler . codec . memcache . binary ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . memcache . LastMemcacheContent ; import io . netty . handler . codec . memcache . MemcacheContent ; import io . netty . util . CharsetUtil ; import io . netty . util . ReferenceCounted ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import static org . hamcrest . CoreMatchers . * ; import static org . hamcrest . MatcherAssert . * ; import static org . hamcrest . core . IsNull . notNullValue ; import static org . hamcrest . core . IsNull . nullValue ; public class BinaryMemcacheDecoderTest { private static final byte [ ] GET_REQUEST = { ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; private static final byte [ ] SET_REQUEST_WITH_CONTENT = { ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; private static final byte [ ] GET_RESPONSE_CHUNK_1 = { ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , } ; private static final byte [ ] GET_RESPONSE_CHUNK_2 = { <hex> , <hex> , ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; private EmbeddedChannel channel ; @Before public void setup ( ) throws Exception { channel = new EmbeddedChannel ( new BinaryMemcacheRequestDecoder ( ) ) ; } @After public void teardown ( ) throws Exception { channel . finish ( ) ; } @Test public void shouldDecodeRequestWithSimpleValue ( ) { ByteBuf incoming = Unpooled . buffer ( ) ; incoming . writeBytes ( GET_REQUEST ) ; channel . writeInbound ( incoming ) ; BinaryMemcacheRequest request = channel . readInbound ( ) ; assertThat ( request , notNullValue ( ) ) ; assertThat ( request . key ( ) , notNullValue ( ) ) ; assertThat ( request . extras ( ) , nullValue ( ) ) ; assertThat ( request . keyLength ( ) , is ( ( short ) <int> ) ) ; assertThat ( request . extrasLength ( ) , is ( ( byte ) <int> ) ) ; assertThat ( request . totalBodyLength ( ) , is ( <int> ) ) ; request . release ( ) ; assertThat ( channel . readInbound ( ) , instanceOf ( LastMemcacheContent . class ) ) ; } @Test public void shouldDecodeRequestWithChunkedContent ( ) { int smallBatchSize = <int> ; channel = new EmbeddedChannel ( new BinaryMemcacheRequestDecoder ( smallBatchSize ) ) ; ByteBuf incoming = Unpooled . buffer ( ) ; incoming . writeBytes ( SET_REQUEST_WITH_CONTENT ) ; channel . writeInbound ( incoming ) ; BinaryMemcacheRequest request = channel . readInbound ( ) ; assertThat ( request , notNullValue ( ) ) ; assertThat ( request . key ( ) , notNullValue ( ) ) ; assertThat ( request . extras ( ) , nullValue ( ) ) ; assertThat ( request . keyLength ( ) , is ( ( short ) <int> ) ) ; assertThat ( request . extrasLength ( ) , is ( ( byte ) <int> ) ) ; assertThat ( request . totalBodyLength ( ) , is ( <int> ) ) ; request . release ( ) ; int expectedContentChunks = <int> ; for ( int i = <int> ; i < = expectedContentChunks ; i + + ) { MemcacheContent content = channel . readInbound ( ) ; if ( i < expectedContentChunks ) { assertThat ( content , instanceOf ( MemcacheContent . class ) ) ; } else { assertThat ( content , instanceOf ( LastMemcacheContent . class ) ) ; } assertThat ( content . content ( ) . readableBytes ( ) , is ( <int> ) ) ; content . release ( ) ; } assertThat ( channel . readInbound ( ) , nullValue ( ) ) ; } @Test public void shouldHandleNonUniformNetworkBatches ( ) { ByteBuf incoming = Unpooled . copiedBuffer ( SET_REQUEST_WITH_CONTENT ) ; while ( incoming . isReadable ( ) ) { channel . writeInbound ( incoming . readBytes ( <int> ) ) ; } BinaryMemcacheRequest request = channel . readInbound ( ) ; assertThat ( request , notNullValue ( ) ) ; assertThat ( request . key ( ) , notNullValue ( ) ) ; assertThat ( request . extras ( ) , nullValue ( ) ) ; request . release ( ) ; MemcacheContent content1 = channel . readInbound ( ) ; MemcacheContent content2 = channel . readInbound ( ) ; assertThat ( content1 , instanceOf ( MemcacheContent . class ) ) ; assertThat ( content2 , instanceOf ( LastMemcacheContent . class ) ) ; assertThat ( content1 . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( content2 . content ( ) . readableBytes ( ) , is ( <int> ) ) ; content1 . release ( ) ; content2 . release ( ) ; } @Test public void shouldHandleTwoMessagesInOneBatch ( ) { channel . writeInbound ( Unpooled . buffer ( ) . writeBytes ( GET_REQUEST ) . writeBytes ( GET_REQUEST ) ) ; BinaryMemcacheRequest request = channel . readInbound ( ) ; assertThat ( request , instanceOf ( BinaryMemcacheRequest . class ) ) ; assertThat ( request , notNullValue ( ) ) ; request . release ( ) ; Object lastContent = channel . readInbound ( ) ; assertThat ( lastContent , instanceOf ( LastMemcacheContent . class ) ) ; ( ( ReferenceCounted ) lastContent ) . release ( ) ; request = channel . readInbound ( ) ; assertThat ( request , instanceOf ( BinaryMemcacheRequest . class ) ) ; assertThat ( request , notNullValue ( ) ) ; request . release ( ) ; lastContent = channel . readInbound ( ) ; assertThat ( lastContent , instanceOf ( LastMemcacheContent . class ) ) ; ( ( ReferenceCounted ) lastContent ) . release ( ) ; } @Test public void shouldDecodeSeparatedValues ( ) { String msgBody = <str> ; channel = new EmbeddedChannel ( new BinaryMemcacheResponseDecoder ( ) ) ; channel . writeInbound ( Unpooled . buffer ( ) . writeBytes ( GET_RESPONSE_CHUNK_1 ) ) ; channel . writeInbound ( Unpooled . buffer ( ) . writeBytes ( GET_RESPONSE_CHUNK_2 ) ) ; BinaryMemcacheResponse response = channel . readInbound ( ) ; assertThat ( response . status ( ) , is ( BinaryMemcacheResponseStatus . KEY_ENOENT ) ) ; assertThat ( response . totalBodyLength ( ) , is ( msgBody . length ( ) ) ) ; response . release ( ) ; MemcacheContent content = channel . readInbound ( ) ; assertThat ( content , instanceOf ( LastMemcacheContent . class ) ) ; assertThat ( content . content ( ) . toString ( CharsetUtil . UTF_8 ) , is ( msgBody ) ) ; content . release ( ) ; response = channel . readInbound ( ) ; assertThat ( response . status ( ) , is ( BinaryMemcacheResponseStatus . KEY_ENOENT ) ) ; assertThat ( response . totalBodyLength ( ) , is ( msgBody . length ( ) ) ) ; response . release ( ) ; content = channel . readInbound ( ) ; assertThat ( content , instanceOf ( MemcacheContent . class ) ) ; assertThat ( content . content ( ) . toString ( CharsetUtil . UTF_8 ) , is ( msgBody . substring ( <int> , <int> ) ) ) ; content . release ( ) ; content = channel . readInbound ( ) ; assertThat ( content , instanceOf ( LastMemcacheContent . class ) ) ; assertThat ( content . content ( ) . toString ( CharsetUtil . UTF_8 ) , is ( msgBody . substring ( <int> , <int> ) ) ) ; content . release ( ) ; response = channel . readInbound ( ) ; assertThat ( response . status ( ) , is ( BinaryMemcacheResponseStatus . KEY_ENOENT ) ) ; assertThat ( response . totalBodyLength ( ) , is ( msgBody . length ( ) ) ) ; response . release ( ) ; content = channel . readInbound ( ) ; assertThat ( content , instanceOf ( LastMemcacheContent . class ) ) ; assertThat ( content . content ( ) . toString ( CharsetUtil . UTF_8 ) , is ( msgBody ) ) ; content . release ( ) ; } } 
