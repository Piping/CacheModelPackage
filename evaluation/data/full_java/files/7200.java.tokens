package org . elasticsearch . search . aggregations . bucket . nested ; import org . apache . lucene . index . IndexReaderContext ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . ReaderUtil ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Weight ; import org . apache . lucene . search . join . BitSetProducer ; import org . apache . lucene . util . BitSet ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import org . elasticsearch . search . aggregations . AggregationExecutionException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . LeafBucketCollectorBase ; import org . elasticsearch . search . aggregations . NonCollectingAggregator ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class NestedAggregator extends SingleBucketAggregator { private BitSetProducer parentFilter ; private final Query childFilter ; private DocIdSetIterator childDocs ; private BitSet parentDocs ; public NestedAggregator ( String name , AggregatorFactories factories , ObjectMapper objectMapper , AggregationContext aggregationContext , Aggregator parentAggregator , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , aggregationContext , parentAggregator , pipelineAggregators , metaData ) ; childFilter = objectMapper . nestedTypeFilter ( ) ; } @Override public LeafBucketCollector getLeafCollector ( final LeafReaderContext ctx , final LeafBucketCollector sub ) throws IOException { this . parentFilter = null ; final IndexReaderContext topLevelContext = ReaderUtil . getTopLevelContext ( ctx ) ; final IndexSearcher searcher = new IndexSearcher ( topLevelContext ) ; searcher . setQueryCache ( null ) ; final Weight weight = searcher . createNormalizedWeight ( childFilter , false ) ; childDocs = weight . scorer ( ctx ) ; return new LeafBucketCollectorBase ( sub , null ) { @Override public void collect ( int parentDoc , long bucket ) throws IOException { if ( parentDoc = = <int> | | childDocs = = null ) { return ; } if ( parentFilter = = null ) { Query parentFilterNotCached = findClosestNestedPath ( parent ( ) ) ; if ( parentFilterNotCached = = null ) { parentFilterNotCached = Queries . newNonNestedFilter ( ) ; } parentFilter = context . searchContext ( ) . bitsetFilterCache ( ) . getBitSetProducer ( parentFilterNotCached ) ; parentDocs = parentFilter . getBitSet ( ctx ) ; if ( parentDocs = = null ) { childDocs = null ; return ; } } final int prevParentDoc = parentDocs . prevSetBit ( parentDoc - <int> ) ; int childDocId = childDocs . docID ( ) ; if ( childDocId < = prevParentDoc ) { childDocId = childDocs . advance ( prevParentDoc + <int> ) ; } for ( ; childDocId < parentDoc ; childDocId = childDocs . nextDoc ( ) ) { collectBucket ( sub , childDocId , bucket ) ; } } } ; } @Override public InternalAggregation buildAggregation ( long owningBucketOrdinal ) throws IOException { return new InternalNested ( name , bucketDocCount ( owningBucketOrdinal ) , bucketAggregations ( owningBucketOrdinal ) , pipelineAggregators ( ) , metaData ( ) ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return new InternalNested ( name , <int> , buildEmptySubAggregations ( ) , pipelineAggregators ( ) , metaData ( ) ) ; } private static Query findClosestNestedPath ( Aggregator parent ) { for ( ; parent ! = null ; parent = parent . parent ( ) ) { if ( parent instanceof NestedAggregator ) { return ( ( NestedAggregator ) parent ) . childFilter ; } else if ( parent instanceof ReverseNestedAggregator ) { return ( ( ReverseNestedAggregator ) parent ) . getParentFilter ( ) ; } } return null ; } public static class Factory extends AggregatorFactory { private final String path ; public Factory ( String name , String path ) { super ( name , InternalNested . TYPE . name ( ) ) ; this . path = path ; } @Override public Aggregator createInternal ( AggregationContext context , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { if ( collectsFromSingleBucket = = false ) { return asMultiBucketAggregator ( this , context , parent ) ; } ObjectMapper objectMapper = context . searchContext ( ) . getObjectMapper ( path ) ; if ( objectMapper = = null ) { return new Unmapped ( name , context , parent , pipelineAggregators , metaData ) ; } if ( ! objectMapper . nested ( ) . isNested ( ) ) { throw new AggregationExecutionException ( <str> + path + <str> ) ; } return new NestedAggregator ( name , factories , objectMapper , context , parent , pipelineAggregators , metaData ) ; } private final static class Unmapped extends NonCollectingAggregator { public Unmapped ( String name , AggregationContext context , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , context , parent , pipelineAggregators , metaData ) ; } @Override public InternalAggregation buildEmptyAggregation ( ) { return new InternalNested ( name , <int> , buildEmptySubAggregations ( ) , pipelineAggregators ( ) , metaData ( ) ) ; } } } } 
