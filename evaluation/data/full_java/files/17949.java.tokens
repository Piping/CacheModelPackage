package com . badlogic . gdx . graphics ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; public class OrthographicCamera extends Camera { public float zoom = <int> ; public OrthographicCamera ( ) { this . near = <int> ; } public OrthographicCamera ( float viewportWidth , float viewportHeight ) { this . viewportWidth = viewportWidth ; this . viewportHeight = viewportHeight ; this . near = <int> ; update ( ) ; } private final Vector3 tmp = new Vector3 ( ) ; @Override public void update ( ) { update ( true ) ; } @Override public void update ( boolean updateFrustum ) { projection . setToOrtho ( zoom * - viewportWidth / <int> , zoom * ( viewportWidth / <int> ) , zoom * - ( viewportHeight / <int> ) , zoom * viewportHeight / <int> , near , far ) ; view . setToLookAt ( position , tmp . set ( position ) . add ( direction ) , up ) ; combined . set ( projection ) ; Matrix4 . mul ( combined . val , view . val ) ; if ( updateFrustum ) { invProjectionView . set ( combined ) ; Matrix4 . inv ( invProjectionView . val ) ; frustum . update ( invProjectionView ) ; } } public void setToOrtho ( boolean yDown ) { setToOrtho ( yDown , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; } public void setToOrtho ( boolean yDown , float viewportWidth , float viewportHeight ) { if ( yDown ) { up . set ( <int> , - <int> , <int> ) ; direction . set ( <int> , <int> , <int> ) ; } else { up . set ( <int> , <int> , <int> ) ; direction . set ( <int> , <int> , - <int> ) ; } position . set ( zoom * viewportWidth / <float> , zoom * viewportHeight / <float> , <int> ) ; this . viewportWidth = viewportWidth ; this . viewportHeight = viewportHeight ; update ( ) ; } public void rotate ( float angle ) { rotate ( direction , angle ) ; } public void translate ( float x , float y ) { translate ( x , y , <int> ) ; } public void translate ( Vector2 vec ) { translate ( vec . x , vec . y , <int> ) ; } } 
