package org . elasticsearch . indices . state ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . cluster . health . ClusterHealthStatus ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . admin . indices . close . CloseIndexResponse ; import org . elasticsearch . action . admin . indices . create . CreateIndexResponse ; import org . elasticsearch . action . admin . indices . open . OpenIndexResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsException ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . indices . IndexClosedException ; import org . elasticsearch . indices . IndexPrimaryShardNotAllocatedException ; import org . elasticsearch . test . ESIntegTestCase ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . nullValue ; @ESIntegTestCase.ClusterScope ( minNumDataNodes = <int> ) public class SimpleIndexStateIT extends ESIntegTestCase { private final ESLogger logger = Loggers . getLogger ( SimpleIndexStateIT . class ) ; public void testSimpleOpenClose ( ) { logger . info ( <str> ) ; createIndex ( <str> ) ; logger . info ( <str> ) ; ensureGreen ( ) ; NumShards numShards = getNumShards ( <str> ) ; ClusterStateResponse stateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; assertThat ( stateResponse . getState ( ) . metaData ( ) . index ( <str> ) . getState ( ) , equalTo ( IndexMetaData . State . OPEN ) ) ; assertThat ( stateResponse . getState ( ) . routingTable ( ) . index ( <str> ) . shards ( ) . size ( ) , equalTo ( numShards . numPrimaries ) ) ; assertThat ( stateResponse . getState ( ) . routingTable ( ) . index ( <str> ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( numShards . totalNumShards ) ) ; logger . info ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; logger . info ( <str> ) ; CloseIndexResponse closeIndexResponse = client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . get ( ) ; assertThat ( closeIndexResponse . isAcknowledged ( ) , equalTo ( true ) ) ; stateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; assertThat ( stateResponse . getState ( ) . metaData ( ) . index ( <str> ) . getState ( ) , equalTo ( IndexMetaData . State . CLOSE ) ) ; assertThat ( stateResponse . getState ( ) . routingTable ( ) . index ( <str> ) , nullValue ( ) ) ; logger . info ( <str> ) ; try { client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; fail ( ) ; } catch ( IndexClosedException e ) { } logger . info ( <str> ) ; OpenIndexResponse openIndexResponse = client ( ) . admin ( ) . indices ( ) . prepareOpen ( <str> ) . get ( ) ; assertThat ( openIndexResponse . isAcknowledged ( ) , equalTo ( true ) ) ; logger . info ( <str> ) ; ensureGreen ( ) ; stateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; assertThat ( stateResponse . getState ( ) . metaData ( ) . index ( <str> ) . getState ( ) , equalTo ( IndexMetaData . State . OPEN ) ) ; assertThat ( stateResponse . getState ( ) . routingTable ( ) . index ( <str> ) . shards ( ) . size ( ) , equalTo ( numShards . numPrimaries ) ) ; assertThat ( stateResponse . getState ( ) . routingTable ( ) . index ( <str> ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( numShards . totalNumShards ) ) ; logger . info ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; } public void testFastCloseAfterCreateDoesNotClose ( ) { logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ) . get ( ) ; ClusterHealthResponse health = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( <str> ) . setWaitForNodes ( <str> ) . get ( ) ; assertThat ( health . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( health . getStatus ( ) , equalTo ( ClusterHealthStatus . RED ) ) ; try { client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . get ( ) ; fail ( <str> ) ; } catch ( IndexPrimaryShardNotAllocatedException e ) { } logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , <str> ) . build ( ) ) . get ( ) ; logger . info ( <str> ) ; ensureGreen ( ) ; NumShards numShards = getNumShards ( <str> ) ; ClusterStateResponse stateResponse = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; assertThat ( stateResponse . getState ( ) . metaData ( ) . index ( <str> ) . getState ( ) , equalTo ( IndexMetaData . State . OPEN ) ) ; assertThat ( stateResponse . getState ( ) . routingTable ( ) . index ( <str> ) . shards ( ) . size ( ) , equalTo ( numShards . numPrimaries ) ) ; assertThat ( stateResponse . getState ( ) . routingTable ( ) . index ( <str> ) . shardsWithState ( ShardRoutingState . STARTED ) . size ( ) , equalTo ( numShards . totalNumShards ) ) ; logger . info ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; } public void testConsistencyAfterIndexCreationFailure ( ) { logger . info ( <str> ) ; try { client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ; } catch ( IndexNotFoundException ex ) { } logger . info ( <str> ) ; try { client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <str> ) ) . get ( ) ; fail ( ) ; } catch ( SettingsException ex ) { } logger . info ( <str> ) ; CreateIndexResponse response = client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . get ( ) ; assertThat ( response . isAcknowledged ( ) , equalTo ( true ) ) ; } } 
