package org . elasticsearch . index . mapper . all ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . lucene . all . AllEntries ; import org . elasticsearch . common . lucene . all . AllField ; import org . elasticsearch . common . lucene . all . AllTermQuery ; import org . elasticsearch . common . lucene . all . AllTokenStream ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . engine . Engine . Searcher ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . ParseContext . Document ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . internal . AllFieldMapper ; import org . elasticsearch . index . mapper . internal . TimestampFieldMapper ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . util . * ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . StreamsUtils . copyToBytesFromClasspath ; import static org . elasticsearch . test . StreamsUtils . copyToStringFromClasspath ; import static org . hamcrest . Matchers . * ; public class SimpleAllMapperTests extends ESSingleNodeTestCase { public void testSimpleAllMappers ( ) throws Exception { String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; assertThat ( field . tokenStream ( docMapper . mappers ( ) . indexAnalyzer ( ) , null ) , Matchers . instanceOf ( AllTokenStream . class ) ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; AllFieldMapper mapper = docMapper . allFieldMapper ( ) ; assertThat ( field . fieldType ( ) . omitNorms ( ) , equalTo ( true ) ) ; assertThat ( mapper . fieldType ( ) . queryStringTermQuery ( new Term ( <str> , <str> ) ) , Matchers . instanceOf ( AllTermQuery . class ) ) ; } public void testAllMappersNoBoost ( ) throws Exception { String mapping = copyToStringFromClasspath ( <str> ) ; IndexService index = createIndex ( <str> ) ; DocumentMapper docMapper = index . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( field . fieldType ( ) . omitNorms ( ) , equalTo ( false ) ) ; } public void testAllMappersTermQuery ( ) throws Exception { String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; AllFieldMapper mapper = docMapper . allFieldMapper ( ) ; assertThat ( field . fieldType ( ) . omitNorms ( ) , equalTo ( false ) ) ; assertThat ( mapper . fieldType ( ) . queryStringTermQuery ( new Term ( <str> , <str> ) ) , Matchers . instanceOf ( AllTermQuery . class ) ) ; } public void testAllMappersWithOffsetsTermQuery ( ) throws Exception { String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; assertThat ( field . tokenStream ( docMapper . mappers ( ) . indexAnalyzer ( ) , null ) , Matchers . instanceOf ( AllTokenStream . class ) ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; AllFieldMapper mapper = docMapper . allFieldMapper ( ) ; assertThat ( field . fieldType ( ) . omitNorms ( ) , equalTo ( false ) ) ; assertThat ( mapper . fieldType ( ) . queryStringTermQuery ( new Term ( <str> , <str> ) ) , Matchers . instanceOf ( AllTermQuery . class ) ) ; } public void testBoostWithOmitPositions ( ) throws Exception { String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; assertThat ( field . tokenStream ( docMapper . mappers ( ) . indexAnalyzer ( ) , null ) , Matchers . not ( Matchers . instanceOf ( AllTokenStream . class ) ) ) ; } public void testNoBoost ( ) throws Exception { String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; assertThat ( field . tokenStream ( docMapper . mappers ( ) . indexAnalyzer ( ) , null ) , Matchers . not ( Matchers . instanceOf ( AllTokenStream . class ) ) ) ; } public void testSimpleAllMappersWithReparse ( ) throws Exception { DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = parser . parse ( mapping ) ; String builtMapping = docMapper . mappingSource ( ) . string ( ) ; DocumentMapper builtDocMapper = parser . parse ( builtMapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = builtDocMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) . toString ( ) , allEntries . fields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( field . fieldType ( ) . omitNorms ( ) , equalTo ( true ) ) ; } public void testSimpleAllMappersWithStore ( ) throws Exception { String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; String text = field . stringValue ( ) ; assertThat ( text , equalTo ( allEntries . buildText ( ) ) ) ; assertThat ( field . fieldType ( ) . omitNorms ( ) , equalTo ( false ) ) ; } public void testSimpleAllMappersWithReparseWithStore ( ) throws Exception { DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = parser . parse ( mapping ) ; String builtMapping = docMapper . mappingSource ( ) . string ( ) ; DocumentMapper builtDocMapper = parser . parse ( builtMapping ) ; byte [ ] json = copyToBytesFromClasspath ( <str> ) ; Document doc = builtDocMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; String text = field . stringValue ( ) ; assertThat ( text , equalTo ( allEntries . buildText ( ) ) ) ; assertThat ( field . fieldType ( ) . omitNorms ( ) , equalTo ( false ) ) ; } public void testRandom ( ) throws Exception { boolean omitNorms = false ; boolean stored = false ; boolean enabled = true ; boolean tv_stored = false ; boolean tv_payloads = false ; boolean tv_offsets = false ; boolean tv_positions = false ; String similarity = null ; XContentBuilder mappingBuilder = jsonBuilder ( ) ; mappingBuilder . startObject ( ) . startObject ( <str> ) ; List < Tuple < String , Boolean > > booleanOptionList = new ArrayList < > ( ) ; boolean allDefault = true ; if ( frequently ( ) ) { allDefault = false ; mappingBuilder . startObject ( <str> ) ; if ( randomBoolean ( ) ) { booleanOptionList . add ( new Tuple < > ( <str> , omitNorms = randomBoolean ( ) ) ) ; } if ( randomBoolean ( ) ) { booleanOptionList . add ( new Tuple < > ( <str> , stored = randomBoolean ( ) ) ) ; } if ( randomBoolean ( ) ) { booleanOptionList . add ( new Tuple < > ( <str> , tv_stored = randomBoolean ( ) ) ) ; } if ( randomBoolean ( ) ) { booleanOptionList . add ( new Tuple < > ( <str> , enabled = randomBoolean ( ) ) ) ; } if ( randomBoolean ( ) ) { booleanOptionList . add ( new Tuple < > ( <str> , tv_offsets = randomBoolean ( ) ) ) ; } if ( randomBoolean ( ) ) { booleanOptionList . add ( new Tuple < > ( <str> , tv_positions = randomBoolean ( ) ) ) ; } if ( randomBoolean ( ) ) { booleanOptionList . add ( new Tuple < > ( <str> , tv_payloads = randomBoolean ( ) ) ) ; } Collections . shuffle ( booleanOptionList , random ( ) ) ; for ( Tuple < String , Boolean > option : booleanOptionList ) { mappingBuilder . field ( option . v1 ( ) , option . v2 ( ) . booleanValue ( ) ) ; } tv_stored | = tv_positions | | tv_payloads | | tv_offsets ; if ( randomBoolean ( ) ) { mappingBuilder . field ( <str> , similarity = randomBoolean ( ) ? <str> : <str> ) ; } mappingBuilder . endObject ( ) ; } DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; String mapping = mappingBuilder . endObject ( ) . endObject ( ) . bytes ( ) . toUtf8 ( ) ; logger . info ( mapping ) ; DocumentMapper docMapper = parser . parse ( mapping ) ; String builtMapping = docMapper . mappingSource ( ) . string ( ) ; DocumentMapper builtDocMapper = parser . parse ( builtMapping ) ; byte [ ] json = jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) . toBytes ( ) ; Document doc = builtDocMapper . parse ( <str> , <str> , <str> , new BytesArray ( json ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; if ( enabled ) { assertThat ( field . fieldType ( ) . omitNorms ( ) , equalTo ( omitNorms ) ) ; assertThat ( field . fieldType ( ) . stored ( ) , equalTo ( stored ) ) ; assertThat ( field . fieldType ( ) . storeTermVectorOffsets ( ) , equalTo ( tv_offsets ) ) ; assertThat ( field . fieldType ( ) . storeTermVectorPayloads ( ) , equalTo ( tv_payloads ) ) ; assertThat ( field . fieldType ( ) . storeTermVectorPositions ( ) , equalTo ( tv_positions ) ) ; assertThat ( field . fieldType ( ) . storeTermVectors ( ) , equalTo ( tv_stored ) ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( allEntries . fields ( ) . contains ( <str> ) , equalTo ( true ) ) ; if ( ! stored ) { assertThat ( field . stringValue ( ) , nullValue ( ) ) ; } String text = stored ? field . stringValue ( ) : <str> ; assertThat ( text . trim ( ) , equalTo ( allEntries . buildText ( ) . trim ( ) ) ) ; } else { assertThat ( field , nullValue ( ) ) ; } if ( similarity = = null | | similarity . equals ( <str> ) ) { assertThat ( builtDocMapper . allFieldMapper ( ) . fieldType ( ) . similarity ( ) , nullValue ( ) ) ; } else { assertThat ( similarity , equalTo ( builtDocMapper . allFieldMapper ( ) . fieldType ( ) . similarity ( ) . name ( ) ) ) ; } if ( allDefault ) { BytesStreamOutput bytesStreamOutput = new BytesStreamOutput ( <int> ) ; XContentBuilder b = new XContentBuilder ( XContentType . JSON . xContent ( ) , bytesStreamOutput ) ; XContentBuilder xContentBuilder = builtDocMapper . allFieldMapper ( ) . toXContent ( b , ToXContent . EMPTY_PARAMS ) ; xContentBuilder . flush ( ) ; assertThat ( bytesStreamOutput . size ( ) , equalTo ( <int> ) ) ; } } public void testMultiField_includeInAllSetToFalse ( ) throws IOException { String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; XContentBuilder builder = XContentFactory . jsonBuilder ( ) ; builder . startObject ( ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , builder . bytes ( ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) , empty ( ) ) ; } public void testMultiField_defaults ( ) throws IOException { String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; XContentBuilder builder = XContentFactory . jsonBuilder ( ) ; builder . startObject ( ) . field ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ; Document doc = docMapper . parse ( <str> , <str> , <str> , builder . bytes ( ) ) . rootDoc ( ) ; AllField field = ( AllField ) doc . getField ( <str> ) ; AllEntries allEntries = field . getAllEntries ( ) ; assertThat ( allEntries . fields ( ) , hasSize ( <int> ) ) ; assertThat ( allEntries . fields ( ) , hasItem ( <str> ) ) ; } public void testMisplacedTypeInRoot ( ) throws IOException { String mapping = copyToStringFromClasspath ( <str> ) ; try { createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( <str> , mapping ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testMistypedTypeInRoot ( ) throws IOException { String mapping = copyToStringFromClasspath ( <str> ) ; try { createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( <str> , mapping ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testMisplacedMappingAsRoot ( ) throws IOException { String mapping = copyToStringFromClasspath ( <str> ) ; try { createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( <str> , mapping ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testRootObjectMapperPropertiesDoNotCauseException ( ) throws IOException { DocumentMapperParser parser = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; parser . parse ( <str> , mapping ) ; mapping = copyToStringFromClasspath ( <str> ) ; parser . parse ( <str> , mapping ) ; mapping = copyToStringFromClasspath ( <str> ) ; parser . parse ( <str> , mapping ) ; mapping = copyToStringFromClasspath ( <str> ) ; parser . parse ( <str> , mapping ) ; } public void testMetadataMappersStillWorking ( ) { String mapping = <str> ; Map < String , String > rootTypes = new HashMap < > ( ) ; rootTypes . put ( TimestampFieldMapper . NAME , <str> ) ; rootTypes . put ( <str> , <str> ) ; rootTypes . put ( <str> , <str> ) ; rootTypes . put ( <str> , <str> ) ; rootTypes . put ( <str> , <str> ) ; for ( String key : rootTypes . keySet ( ) ) { mapping + = <str> + key + <str> + <str> + rootTypes . get ( key ) + <str> ; } mapping + = <str> ; createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( <str> , mapping ) ; } public void testDocValuesNotAllowed ( ) throws IOException { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; try { createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; fail ( ) ; } catch ( MapperParsingException e ) { assertThat ( e . getDetailedMessage ( ) , containsString ( <str> ) ) ; } mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; Settings legacySettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; try { createIndex ( <str> , legacySettings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; fail ( ) ; } catch ( MapperParsingException e ) { assertThat ( e . getDetailedMessage ( ) , containsString ( <str> ) ) ; } } public void testAutoBoost ( ) throws Exception { for ( boolean boost : new boolean [ ] { false , true } ) { String index = <str> + boost ; IndexService indexService = createIndex ( index , client ( ) . admin ( ) . indices ( ) . prepareCreate ( index ) . addMapping ( <str> , <str> , <str> + ( boost ? <str> : <str> ) ) ) ; client ( ) . prepareIndex ( index , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( index ) . get ( ) ; Query query = indexService . mapperService ( ) . documentMapper ( <str> ) . allFieldMapper ( ) . fieldType ( ) . termQuery ( <str> , null ) ; try ( Searcher searcher = indexService . getShardOrNull ( <int> ) . acquireSearcher ( <str> ) ) { query = searcher . searcher ( ) . rewrite ( query ) ; final Class < ? > expected = boost ? AllTermQuery . class : TermQuery . class ; assertThat ( query , Matchers . instanceOf ( expected ) ) ; } } } public void testIncludeInObjectBackcompat ( ) throws Exception { String mapping = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; Settings settings = Settings . builder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . V_1_4_2 . id ) . build ( ) ; DocumentMapper docMapper = createIndex ( <str> , settings ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; ParsedDocument doc = docMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; assertNull ( doc . rootDoc ( ) . get ( <str> ) ) ; AllField field = ( AllField ) doc . rootDoc ( ) . getField ( <str> ) ; assertFalse ( field . getAllEntries ( ) . fields ( ) . iterator ( ) . hasNext ( ) ) ; } public void testIncludeInObjectNotAllowed ( ) throws Exception { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . string ( ) ; DocumentMapper docMapper = createIndex ( <str> ) . mapperService ( ) . documentMapperParser ( ) . parse ( mapping ) ; try { docMapper . parse ( <str> , <str> , <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . bytes ( ) ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } } } 
