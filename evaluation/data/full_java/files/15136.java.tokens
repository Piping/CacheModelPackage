package org . gradle . play . internal ; import org . gradle . api . tasks . Optional ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . typeconversion . * ; import org . gradle . platform . base . internal . DefaultPlatformRequirement ; import org . gradle . platform . base . internal . PlatformRequirement ; public class PlayPlatformNotationParser { private static final NotationParserBuilder < PlatformRequirement > BUILDER = NotationParserBuilder . toType ( PlatformRequirement . class ) . fromCharSequence ( new StringConverter ( ) ) . converter ( new MapConverter ( ) ) ; public static NotationParser < Object , PlatformRequirement > parser ( ) { return builder ( ) . toComposite ( ) ; } private static NotationParserBuilder < PlatformRequirement > builder ( ) { return BUILDER ; } static class MapConverter extends MapNotationConverter < PlatformRequirement > { @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) . example ( <str> + DefaultPlayPlatform . DEFAULT_PLAY_VERSION + <str> ) ; } protected PlatformRequirement parseMap ( @MapKey ( <str> ) String playVersion , @MapKey ( <str> ) @Optional String scalaVersion , @MapKey ( <str> ) @Optional String javaVersion ) { return new PlayPlatformRequirement ( playVersion , scalaVersion , javaVersion ) ; } } static class StringConverter implements NotationConverter < String , PlatformRequirement > { @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) . example ( <str> + DefaultPlayPlatform . DEFAULT_PLAY_VERSION + <str> ) ; } public void convert ( String notation , NotationConvertResult < ? super PlatformRequirement > result ) throws TypeConversionException { result . converted ( new DefaultPlatformRequirement ( notation ) ) ; } } } 
