package io . netty . handler . codec . mqtt ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToMessageEncoder ; import io . netty . util . CharsetUtil ; import java . util . List ; import static io . netty . handler . codec . mqtt . MqttCodecUtil . * ; public class MqttEncoder extends MessageToMessageEncoder < MqttMessage > { public static final MqttEncoder DEFAUL_ENCODER = new MqttEncoder ( ) ; private static final byte [ ] EMPTY = new byte [ <int> ] ; @Override protected void encode ( ChannelHandlerContext ctx , MqttMessage msg , List < Object > out ) throws Exception { out . add ( doEncode ( ctx . alloc ( ) , msg ) ) ; } static ByteBuf doEncode ( ByteBufAllocator byteBufAllocator , MqttMessage message ) { switch ( message . fixedHeader ( ) . messageType ( ) ) { case CONNECT : return encodeConnectMessage ( byteBufAllocator , ( MqttConnectMessage ) message ) ; case CONNACK : return encodeConnAckMessage ( byteBufAllocator , ( MqttConnAckMessage ) message ) ; case PUBLISH : return encodePublishMessage ( byteBufAllocator , ( MqttPublishMessage ) message ) ; case SUBSCRIBE : return encodeSubscribeMessage ( byteBufAllocator , ( MqttSubscribeMessage ) message ) ; case UNSUBSCRIBE : return encodeUnsubscribeMessage ( byteBufAllocator , ( MqttUnsubscribeMessage ) message ) ; case SUBACK : return encodeSubAckMessage ( byteBufAllocator , ( MqttSubAckMessage ) message ) ; case UNSUBACK : case PUBACK : case PUBREC : case PUBREL : case PUBCOMP : return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId ( byteBufAllocator , message ) ; case PINGREQ : case PINGRESP : case DISCONNECT : return encodeMessageWithOnlySingleByteFixedHeader ( byteBufAllocator , message ) ; default: throw new IllegalArgumentException ( <str> + message . fixedHeader ( ) . messageType ( ) . value ( ) ) ; } } private static ByteBuf encodeConnectMessage ( ByteBufAllocator byteBufAllocator , MqttConnectMessage message ) { int payloadBufferSize = <int> ; MqttFixedHeader mqttFixedHeader = message . fixedHeader ( ) ; MqttConnectVariableHeader variableHeader = message . variableHeader ( ) ; MqttConnectPayload payload = message . payload ( ) ; MqttVersion mqttVersion = MqttVersion . fromProtocolNameAndLevel ( variableHeader . name ( ) , ( byte ) variableHeader . version ( ) ) ; String clientIdentifier = payload . clientIdentifier ( ) ; if ( ! isValidClientId ( mqttVersion , clientIdentifier ) ) { throw new MqttIdentifierRejectedException ( <str> + clientIdentifier ) ; } byte [ ] clientIdentifierBytes = encodeStringUtf8 ( clientIdentifier ) ; payloadBufferSize + = <int> + clientIdentifierBytes . length ; String willTopic = payload . willTopic ( ) ; byte [ ] willTopicBytes = willTopic ! = null ? encodeStringUtf8 ( willTopic ) : EMPTY ; String willMessage = payload . willMessage ( ) ; byte [ ] willMessageBytes = willMessage ! = null ? encodeStringUtf8 ( willMessage ) : EMPTY ; if ( variableHeader . isWillFlag ( ) ) { payloadBufferSize + = <int> + willTopicBytes . length ; payloadBufferSize + = <int> + willMessageBytes . length ; } String userName = payload . userName ( ) ; byte [ ] userNameBytes = userName ! = null ? encodeStringUtf8 ( userName ) : EMPTY ; if ( variableHeader . hasUserName ( ) ) { payloadBufferSize + = <int> + userNameBytes . length ; } String password = payload . password ( ) ; byte [ ] passwordBytes = password ! = null ? encodeStringUtf8 ( password ) : EMPTY ; if ( variableHeader . hasPassword ( ) ) { payloadBufferSize + = <int> + passwordBytes . length ; } byte [ ] protocolNameBytes = mqttVersion . protocolNameBytes ( ) ; int variableHeaderBufferSize = <int> + protocolNameBytes . length + <int> ; int variablePartSize = variableHeaderBufferSize + payloadBufferSize ; int fixedHeaderBufferSize = <int> + getVariableLengthInt ( variablePartSize ) ; ByteBuf buf = byteBufAllocator . buffer ( fixedHeaderBufferSize + variablePartSize ) ; buf . writeByte ( getFixedHeaderByte1 ( mqttFixedHeader ) ) ; writeVariableLengthInt ( buf , variablePartSize ) ; buf . writeShort ( protocolNameBytes . length ) ; buf . writeBytes ( protocolNameBytes ) ; buf . writeByte ( variableHeader . version ( ) ) ; buf . writeByte ( getConnVariableHeaderFlag ( variableHeader ) ) ; buf . writeShort ( variableHeader . keepAliveTimeSeconds ( ) ) ; buf . writeShort ( clientIdentifierBytes . length ) ; buf . writeBytes ( clientIdentifierBytes , <int> , clientIdentifierBytes . length ) ; if ( variableHeader . isWillFlag ( ) ) { buf . writeShort ( willTopicBytes . length ) ; buf . writeBytes ( willTopicBytes , <int> , willTopicBytes . length ) ; buf . writeShort ( willMessageBytes . length ) ; buf . writeBytes ( willMessageBytes , <int> , willMessageBytes . length ) ; } if ( variableHeader . hasUserName ( ) ) { buf . writeShort ( userNameBytes . length ) ; buf . writeBytes ( userNameBytes , <int> , userNameBytes . length ) ; } if ( variableHeader . hasPassword ( ) ) { buf . writeShort ( passwordBytes . length ) ; buf . writeBytes ( passwordBytes , <int> , passwordBytes . length ) ; } return buf ; } private static int getConnVariableHeaderFlag ( MqttConnectVariableHeader variableHeader ) { int flagByte = <int> ; if ( variableHeader . hasUserName ( ) ) { flagByte | = <hex> ; } if ( variableHeader . hasPassword ( ) ) { flagByte | = <hex> ; } if ( variableHeader . isWillRetain ( ) ) { flagByte | = <hex> ; } flagByte | = ( variableHeader . willQos ( ) & <hex> ) < < <int> ; if ( variableHeader . isWillFlag ( ) ) { flagByte | = <hex> ; } if ( variableHeader . isCleanSession ( ) ) { flagByte | = <hex> ; } return flagByte ; } private static ByteBuf encodeConnAckMessage ( ByteBufAllocator byteBufAllocator , MqttConnAckMessage message ) { ByteBuf buf = byteBufAllocator . buffer ( <int> ) ; buf . writeByte ( getFixedHeaderByte1 ( message . fixedHeader ( ) ) ) ; buf . writeByte ( <int> ) ; buf . writeByte ( message . variableHeader ( ) . isSessionPresent ( ) ? <hex> : <hex> ) ; buf . writeByte ( message . variableHeader ( ) . connectReturnCode ( ) . byteValue ( ) ) ; return buf ; } private static ByteBuf encodeSubscribeMessage ( ByteBufAllocator byteBufAllocator , MqttSubscribeMessage message ) { int variableHeaderBufferSize = <int> ; int payloadBufferSize = <int> ; MqttFixedHeader mqttFixedHeader = message . fixedHeader ( ) ; MqttMessageIdVariableHeader variableHeader = message . variableHeader ( ) ; MqttSubscribePayload payload = message . payload ( ) ; for ( MqttTopicSubscription topic : payload . topicSubscriptions ( ) ) { String topicName = topic . topicName ( ) ; byte [ ] topicNameBytes = encodeStringUtf8 ( topicName ) ; payloadBufferSize + = <int> + topicNameBytes . length ; payloadBufferSize + = <int> ; } int variablePartSize = variableHeaderBufferSize + payloadBufferSize ; int fixedHeaderBufferSize = <int> + getVariableLengthInt ( variablePartSize ) ; ByteBuf buf = byteBufAllocator . buffer ( fixedHeaderBufferSize + variablePartSize ) ; buf . writeByte ( getFixedHeaderByte1 ( mqttFixedHeader ) ) ; writeVariableLengthInt ( buf , variablePartSize ) ; int messageId = variableHeader . messageId ( ) ; buf . writeShort ( messageId ) ; for ( MqttTopicSubscription topic : payload . topicSubscriptions ( ) ) { String topicName = topic . topicName ( ) ; byte [ ] topicNameBytes = encodeStringUtf8 ( topicName ) ; buf . writeShort ( topicNameBytes . length ) ; buf . writeBytes ( topicNameBytes , <int> , topicNameBytes . length ) ; buf . writeByte ( topic . qualityOfService ( ) . value ( ) ) ; } return buf ; } private static ByteBuf encodeUnsubscribeMessage ( ByteBufAllocator byteBufAllocator , MqttUnsubscribeMessage message ) { int variableHeaderBufferSize = <int> ; int payloadBufferSize = <int> ; MqttFixedHeader mqttFixedHeader = message . fixedHeader ( ) ; MqttMessageIdVariableHeader variableHeader = message . variableHeader ( ) ; MqttUnsubscribePayload payload = message . payload ( ) ; for ( String topicName : payload . topics ( ) ) { byte [ ] topicNameBytes = encodeStringUtf8 ( topicName ) ; payloadBufferSize + = <int> + topicNameBytes . length ; } int variablePartSize = variableHeaderBufferSize + payloadBufferSize ; int fixedHeaderBufferSize = <int> + getVariableLengthInt ( variablePartSize ) ; ByteBuf buf = byteBufAllocator . buffer ( fixedHeaderBufferSize + variablePartSize ) ; buf . writeByte ( getFixedHeaderByte1 ( mqttFixedHeader ) ) ; writeVariableLengthInt ( buf , variablePartSize ) ; int messageId = variableHeader . messageId ( ) ; buf . writeShort ( messageId ) ; for ( String topicName : payload . topics ( ) ) { byte [ ] topicNameBytes = encodeStringUtf8 ( topicName ) ; buf . writeShort ( topicNameBytes . length ) ; buf . writeBytes ( topicNameBytes , <int> , topicNameBytes . length ) ; } return buf ; } private static ByteBuf encodeSubAckMessage ( ByteBufAllocator byteBufAllocator , MqttSubAckMessage message ) { int variableHeaderBufferSize = <int> ; int payloadBufferSize = message . payload ( ) . grantedQoSLevels ( ) . size ( ) ; int variablePartSize = variableHeaderBufferSize + payloadBufferSize ; int fixedHeaderBufferSize = <int> + getVariableLengthInt ( variablePartSize ) ; ByteBuf buf = byteBufAllocator . buffer ( fixedHeaderBufferSize + variablePartSize ) ; buf . writeByte ( getFixedHeaderByte1 ( message . fixedHeader ( ) ) ) ; writeVariableLengthInt ( buf , variablePartSize ) ; buf . writeShort ( message . variableHeader ( ) . messageId ( ) ) ; for ( int qos : message . payload ( ) . grantedQoSLevels ( ) ) { buf . writeByte ( qos ) ; } return buf ; } private static ByteBuf encodePublishMessage ( ByteBufAllocator byteBufAllocator , MqttPublishMessage message ) { MqttFixedHeader mqttFixedHeader = message . fixedHeader ( ) ; MqttPublishVariableHeader variableHeader = message . variableHeader ( ) ; ByteBuf payload = message . payload ( ) . duplicate ( ) ; String topicName = variableHeader . topicName ( ) ; byte [ ] topicNameBytes = encodeStringUtf8 ( topicName ) ; int variableHeaderBufferSize = <int> + topicNameBytes . length + ( mqttFixedHeader . qosLevel ( ) . value ( ) > <int> ? <int> : <int> ) ; int payloadBufferSize = payload . readableBytes ( ) ; int variablePartSize = variableHeaderBufferSize + payloadBufferSize ; int fixedHeaderBufferSize = <int> + getVariableLengthInt ( variablePartSize ) ; ByteBuf buf = byteBufAllocator . buffer ( fixedHeaderBufferSize + variablePartSize ) ; buf . writeByte ( getFixedHeaderByte1 ( mqttFixedHeader ) ) ; writeVariableLengthInt ( buf , variablePartSize ) ; buf . writeShort ( topicNameBytes . length ) ; buf . writeBytes ( topicNameBytes ) ; if ( mqttFixedHeader . qosLevel ( ) . value ( ) > <int> ) { buf . writeShort ( variableHeader . messageId ( ) ) ; } buf . writeBytes ( payload ) ; return buf ; } private static ByteBuf encodeMessageWithOnlySingleByteFixedHeaderAndMessageId ( ByteBufAllocator byteBufAllocator , MqttMessage message ) { MqttFixedHeader mqttFixedHeader = message . fixedHeader ( ) ; MqttMessageIdVariableHeader variableHeader = ( MqttMessageIdVariableHeader ) message . variableHeader ( ) ; int msgId = variableHeader . messageId ( ) ; int variableHeaderBufferSize = <int> ; int fixedHeaderBufferSize = <int> + getVariableLengthInt ( variableHeaderBufferSize ) ; ByteBuf buf = byteBufAllocator . buffer ( fixedHeaderBufferSize + variableHeaderBufferSize ) ; buf . writeByte ( getFixedHeaderByte1 ( mqttFixedHeader ) ) ; writeVariableLengthInt ( buf , variableHeaderBufferSize ) ; buf . writeShort ( msgId ) ; return buf ; } private static ByteBuf encodeMessageWithOnlySingleByteFixedHeader ( ByteBufAllocator byteBufAllocator , MqttMessage message ) { MqttFixedHeader mqttFixedHeader = message . fixedHeader ( ) ; ByteBuf buf = byteBufAllocator . buffer ( <int> ) ; buf . writeByte ( getFixedHeaderByte1 ( mqttFixedHeader ) ) ; buf . writeByte ( <int> ) ; return buf ; } private static int getFixedHeaderByte1 ( MqttFixedHeader header ) { int ret = <int> ; ret | = header . messageType ( ) . value ( ) < < <int> ; if ( header . isDup ( ) ) { ret | = <hex> ; } ret | = header . qosLevel ( ) . value ( ) < < <int> ; if ( header . isRetain ( ) ) { ret | = <hex> ; } return ret ; } private static void writeVariableLengthInt ( ByteBuf buf , int num ) { do { int digit = num % <int> ; num / = <int> ; if ( num > <int> ) { digit | = <hex> ; } buf . writeByte ( digit ) ; } while ( num > <int> ) ; } private static int getVariableLengthInt ( int num ) { int count = <int> ; do { num / = <int> ; count + + ; } while ( num > <int> ) ; return count ; } private static byte [ ] encodeStringUtf8 ( String s ) { return s . getBytes ( CharsetUtil . UTF_8 ) ; } } 
