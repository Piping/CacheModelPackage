package io . netty . channel . pool ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . local . LocalAddress ; import io . netty . channel . local . LocalChannel ; import io . netty . channel . local . LocalEventLoopGroup ; import io . netty . channel . local . LocalServerChannel ; import io . netty . util . concurrent . Future ; import org . hamcrest . CoreMatchers ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . ExpectedException ; import java . util . Queue ; import java . util . concurrent . LinkedBlockingQueue ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotSame ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . fail ; public class SimpleChannelPoolTest { private static final String LOCAL_ADDR_ID = <str> ; @Rule public ExpectedException expectedException = ExpectedException . none ( ) ; @Test public void testAcquire ( ) throws Exception { EventLoopGroup group = new LocalEventLoopGroup ( ) ; LocalAddress addr = new LocalAddress ( LOCAL_ADDR_ID ) ; Bootstrap cb = new Bootstrap ( ) ; cb . remoteAddress ( addr ) ; cb . group ( group ) . channel ( LocalChannel . class ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . group ( group ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) ) ; } } ) ; Channel sc = sb . bind ( addr ) . sync ( ) . channel ( ) ; CountingChannelPoolHandler handler = new CountingChannelPoolHandler ( ) ; ChannelPool pool = new SimpleChannelPool ( cb , handler ) ; Channel channel = pool . acquire ( ) . sync ( ) . getNow ( ) ; pool . release ( channel ) . syncUninterruptibly ( ) ; Channel channel2 = pool . acquire ( ) . sync ( ) . getNow ( ) ; assertSame ( channel , channel2 ) ; assertEquals ( <int> , handler . channelCount ( ) ) ; pool . release ( channel2 ) . syncUninterruptibly ( ) ; try { pool . release ( channel2 ) . syncUninterruptibly ( ) ; fail ( ) ; } catch ( IllegalArgumentException e ) { assertFalse ( channel . isActive ( ) ) ; } assertEquals ( <int> , handler . acquiredCount ( ) ) ; assertEquals ( <int> , handler . releasedCount ( ) ) ; sc . close ( ) . sync ( ) ; group . shutdownGracefully ( ) ; } @Test public void testBoundedChannelPoolSegment ( ) throws Exception { EventLoopGroup group = new LocalEventLoopGroup ( ) ; LocalAddress addr = new LocalAddress ( LOCAL_ADDR_ID ) ; Bootstrap cb = new Bootstrap ( ) ; cb . remoteAddress ( addr ) ; cb . group ( group ) . channel ( LocalChannel . class ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . group ( group ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) ) ; } } ) ; Channel sc = sb . bind ( addr ) . sync ( ) . channel ( ) ; CountingChannelPoolHandler handler = new CountingChannelPoolHandler ( ) ; ChannelPool pool = new SimpleChannelPool ( cb , handler , ChannelHealthChecker . ACTIVE ) { private final Queue < Channel > queue = new LinkedBlockingQueue < Channel > ( <int> ) ; @Override protected Channel pollChannel ( ) { return queue . poll ( ) ; } @Override protected boolean offerChannel ( Channel ch ) { return queue . offer ( ch ) ; } } ; Channel channel = pool . acquire ( ) . sync ( ) . getNow ( ) ; Channel channel2 = pool . acquire ( ) . sync ( ) . getNow ( ) ; pool . release ( channel ) . syncUninterruptibly ( ) . getNow ( ) ; try { pool . release ( channel2 ) . syncUninterruptibly ( ) ; fail ( ) ; } catch ( IllegalStateException e ) { } channel2 . close ( ) . sync ( ) ; assertEquals ( <int> , handler . channelCount ( ) ) ; assertEquals ( <int> , handler . acquiredCount ( ) ) ; assertEquals ( <int> , handler . releasedCount ( ) ) ; sc . close ( ) . sync ( ) ; channel . close ( ) . sync ( ) ; channel2 . close ( ) . sync ( ) ; group . shutdownGracefully ( ) ; } @Test public void testUnhealthyChannelIsNotOffered ( ) throws Exception { EventLoopGroup group = new LocalEventLoopGroup ( ) ; LocalAddress addr = new LocalAddress ( LOCAL_ADDR_ID ) ; Bootstrap cb = new Bootstrap ( ) ; cb . remoteAddress ( addr ) ; cb . group ( group ) . channel ( LocalChannel . class ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . group ( group ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) ) ; } } ) ; Channel sc = sb . bind ( addr ) . syncUninterruptibly ( ) . channel ( ) ; ChannelPoolHandler handler = new CountingChannelPoolHandler ( ) ; ChannelPool pool = new SimpleChannelPool ( cb , handler ) ; Channel channel1 = pool . acquire ( ) . syncUninterruptibly ( ) . getNow ( ) ; pool . release ( channel1 ) . syncUninterruptibly ( ) ; Channel channel2 = pool . acquire ( ) . syncUninterruptibly ( ) . getNow ( ) ; assertSame ( channel1 , channel2 ) ; expectedException . expect ( IllegalStateException . class ) ; channel1 . close ( ) . syncUninterruptibly ( ) ; try { pool . release ( channel1 ) . syncUninterruptibly ( ) ; } finally { sc . close ( ) . syncUninterruptibly ( ) ; channel2 . close ( ) . syncUninterruptibly ( ) ; group . shutdownGracefully ( ) ; } } @Test public void testUnhealthyChannelIsOfferedWhenNoHealthCheckRequested ( ) throws Exception { EventLoopGroup group = new LocalEventLoopGroup ( ) ; LocalAddress addr = new LocalAddress ( LOCAL_ADDR_ID ) ; Bootstrap cb = new Bootstrap ( ) ; cb . remoteAddress ( addr ) ; cb . group ( group ) . channel ( LocalChannel . class ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; sb . group ( group ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) ) ; } } ) ; Channel sc = sb . bind ( addr ) . syncUninterruptibly ( ) . channel ( ) ; ChannelPoolHandler handler = new CountingChannelPoolHandler ( ) ; ChannelPool pool = new SimpleChannelPool ( cb , handler , ChannelHealthChecker . ACTIVE , false ) ; Channel channel1 = pool . acquire ( ) . syncUninterruptibly ( ) . getNow ( ) ; channel1 . close ( ) . syncUninterruptibly ( ) ; Future < Void > releaseFuture = pool . release ( channel1 , channel1 . eventLoop ( ) . < Void > newPromise ( ) ) . syncUninterruptibly ( ) ; assertThat ( releaseFuture . isSuccess ( ) , CoreMatchers . is ( true ) ) ; Channel channel2 = pool . acquire ( ) . syncUninterruptibly ( ) . getNow ( ) ; assertNotSame ( channel1 , channel2 ) ; sc . close ( ) . syncUninterruptibly ( ) ; channel2 . close ( ) . syncUninterruptibly ( ) ; group . shutdownGracefully ( ) ; } } 
