package org . apache . cassandra . streaming ; import java . io . IOException ; import java . net . InetAddress ; import java . net . Socket ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import com . google . common . collect . * ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . gms . * ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . metrics . StreamingMetrics ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . streaming . messages . * ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . Pair ; import org . apache . cassandra . utils . concurrent . Ref ; import org . apache . cassandra . utils . concurrent . Refs ; public class StreamSession implements IEndpointStateChangeSubscriber { private static final Logger logger = LoggerFactory . getLogger ( StreamSession . class ) ; public final InetAddress peer ; private final int index ; public final InetAddress connecting ; private StreamResultFuture streamResult ; protected final Set < StreamRequest > requests = Sets . newConcurrentHashSet ( ) ; private final ConcurrentHashMap < UUID , StreamTransferTask > transfers = new ConcurrentHashMap < > ( ) ; private final Map < UUID , StreamReceiveTask > receivers = new ConcurrentHashMap < > ( ) ; private final StreamingMetrics metrics ; private final StreamConnectionFactory factory ; public final ConnectionHandler handler ; private int retries ; private AtomicBoolean isAborted = new AtomicBoolean ( false ) ; private final boolean keepSSTableLevel ; private final boolean isIncremental ; public static enum State { INITIALIZED , PREPARING , STREAMING , WAIT_COMPLETE , COMPLETE , FAILED , } private volatile State state = State . INITIALIZED ; private volatile boolean completeSent = false ; public StreamSession ( InetAddress peer , InetAddress connecting , StreamConnectionFactory factory , int index , boolean keepSSTableLevel , boolean isIncremental ) { this . peer = peer ; this . connecting = connecting ; this . index = index ; this . factory = factory ; this . handler = new ConnectionHandler ( this ) ; this . metrics = StreamingMetrics . get ( connecting ) ; this . keepSSTableLevel = keepSSTableLevel ; this . isIncremental = isIncremental ; } public UUID planId ( ) { return streamResult = = null ? null : streamResult . planId ; } public int sessionIndex ( ) { return index ; } public String description ( ) { return streamResult = = null ? null : streamResult . description ; } public boolean keepSSTableLevel ( ) { return keepSSTableLevel ; } public boolean isIncremental ( ) { return isIncremental ; } public LifecycleTransaction getTransaction ( UUID cfId ) { assert receivers . containsKey ( cfId ) ; return receivers . get ( cfId ) . txn ; } public void init ( StreamResultFuture streamResult ) { this . streamResult = streamResult ; } public void start ( ) { if ( requests . isEmpty ( ) & & transfers . isEmpty ( ) ) { logger . info ( <str> , planId ( ) ) ; closeSession ( State . COMPLETE ) ; return ; } try { logger . info ( <str> , planId ( ) , peer , peer . equals ( connecting ) ? <str> : <str> + connecting ) ; handler . initiate ( ) ; onInitializationComplete ( ) ; } catch ( Exception e ) { JVMStabilityInspector . inspectThrowable ( e ) ; onError ( e ) ; } } public Socket createConnection ( ) throws IOException { assert factory ! = null ; return factory . createConnection ( connecting ) ; } public void addStreamRequest ( String keyspace , Collection < Range < Token > > ranges , Collection < String > columnFamilies , long repairedAt ) { requests . add ( new StreamRequest ( keyspace , ranges , columnFamilies , repairedAt ) ) ; } public void addTransferRanges ( String keyspace , Collection < Range < Token > > ranges , Collection < String > columnFamilies , boolean flushTables , long repairedAt ) { Collection < ColumnFamilyStore > stores = getColumnFamilyStores ( keyspace , columnFamilies ) ; if ( flushTables ) flushSSTables ( stores ) ; List < Range < Token > > normalizedRanges = Range . normalize ( ranges ) ; List < SSTableStreamingSections > sections = getSSTableSectionsForRanges ( normalizedRanges , stores , repairedAt ) ; try { addTransferFiles ( sections ) ; } finally { for ( SSTableStreamingSections release : sections ) release . ref . release ( ) ; } } private Collection < ColumnFamilyStore > getColumnFamilyStores ( String keyspace , Collection < String > columnFamilies ) { Collection < ColumnFamilyStore > stores = new HashSet < > ( ) ; if ( columnFamilies . isEmpty ( ) ) { stores . addAll ( Keyspace . open ( keyspace ) . getColumnFamilyStores ( ) ) ; } else { for ( String cf : columnFamilies ) stores . add ( Keyspace . open ( keyspace ) . getColumnFamilyStore ( cf ) ) ; } return stores ; } private List < SSTableStreamingSections > getSSTableSectionsForRanges ( Collection < Range < Token > > ranges , Collection < ColumnFamilyStore > stores , long overriddenRepairedAt ) { Refs < SSTableReader > refs = new Refs < > ( ) ; try { for ( ColumnFamilyStore cfStore : stores ) { final List < Range < PartitionPosition > > keyRanges = new ArrayList < > ( ranges . size ( ) ) ; for ( Range < Token > range : ranges ) keyRanges . add ( Range . makeRowRange ( range ) ) ; refs . addAll ( cfStore . selectAndReference ( view - > { Set < SSTableReader > sstables = Sets . newHashSet ( ) ; for ( Range < PartitionPosition > keyRange : keyRanges ) { for ( SSTableReader sstable : view . sstablesInBounds ( SSTableSet . CANONICAL , keyRange . left , keyRange . right ) ) { if ( ! isIncremental | | ! sstable . isRepaired ( ) ) sstables . add ( sstable ) ; } } if ( logger . isDebugEnabled ( ) ) logger . debug ( <str> , sstables . size ( ) , Iterables . size ( view . sstables ( SSTableSet . CANONICAL ) ) ) ; return sstables ; } ) . refs ) ; } List < SSTableStreamingSections > sections = new ArrayList < > ( refs . size ( ) ) ; for ( SSTableReader sstable : refs ) { long repairedAt = overriddenRepairedAt ; if ( overriddenRepairedAt = = ActiveRepairService . UNREPAIRED_SSTABLE ) repairedAt = sstable . getSSTableMetadata ( ) . repairedAt ; sections . add ( new SSTableStreamingSections ( refs . get ( sstable ) , sstable . getPositionsForRanges ( ranges ) , sstable . estimatedKeysForRanges ( ranges ) , repairedAt ) ) ; } return sections ; } catch ( Throwable t ) { refs . release ( ) ; throw t ; } } public void addTransferFiles ( Collection < SSTableStreamingSections > sstableDetails ) { Iterator < SSTableStreamingSections > iter = sstableDetails . iterator ( ) ; while ( iter . hasNext ( ) ) { SSTableStreamingSections details = iter . next ( ) ; if ( details . sections . isEmpty ( ) ) { details . ref . release ( ) ; iter . remove ( ) ; continue ; } UUID cfId = details . ref . get ( ) . metadata . cfId ; StreamTransferTask task = transfers . get ( cfId ) ; if ( task = = null ) { StreamTransferTask newTask = new StreamTransferTask ( this , cfId ) ; task = transfers . putIfAbsent ( cfId , newTask ) ; if ( task = = null ) task = newTask ; } task . addTransferFile ( details . ref , details . estimatedKeys , details . sections , details . repairedAt ) ; iter . remove ( ) ; } } public static class SSTableStreamingSections { public final Ref < SSTableReader > ref ; public final List < Pair < Long , Long > > sections ; public final long estimatedKeys ; public final long repairedAt ; public SSTableStreamingSections ( Ref < SSTableReader > ref , List < Pair < Long , Long > > sections , long estimatedKeys , long repairedAt ) { this . ref = ref ; this . sections = sections ; this . estimatedKeys = estimatedKeys ; this . repairedAt = repairedAt ; } } private synchronized void closeSession ( State finalState ) { if ( isAborted . compareAndSet ( false , true ) ) { state ( finalState ) ; if ( finalState = = State . FAILED ) { for ( StreamTask task : Iterables . concat ( receivers . values ( ) , transfers . values ( ) ) ) task . abort ( ) ; } handler . close ( ) ; streamResult . handleSessionComplete ( this ) ; } } public void state ( State newState ) { state = newState ; } public State state ( ) { return state ; } public boolean isSuccess ( ) { return state = = State . COMPLETE ; } public void messageReceived ( StreamMessage message ) { switch ( message . type ) { case PREPARE : PrepareMessage msg = ( PrepareMessage ) message ; prepare ( msg . requests , msg . summaries ) ; break ; case FILE : receive ( ( IncomingFileMessage ) message ) ; break ; case RECEIVED : ReceivedMessage received = ( ReceivedMessage ) message ; received ( received . cfId , received . sequenceNumber ) ; break ; case RETRY : RetryMessage retry = ( RetryMessage ) message ; retry ( retry . cfId , retry . sequenceNumber ) ; break ; case COMPLETE : complete ( ) ; break ; case SESSION_FAILED : sessionFailed ( ) ; break ; } } public void onInitializationComplete ( ) { state ( State . PREPARING ) ; PrepareMessage prepare = new PrepareMessage ( ) ; prepare . requests . addAll ( requests ) ; for ( StreamTransferTask task : transfers . values ( ) ) prepare . summaries . add ( task . getSummary ( ) ) ; handler . sendMessage ( prepare ) ; if ( requests . isEmpty ( ) ) startStreamingFiles ( ) ; } public void onError ( Throwable e ) { logger . error ( <str> , planId ( ) , e ) ; if ( handler . isOutgoingConnected ( ) ) handler . sendMessage ( new SessionFailedMessage ( ) ) ; closeSession ( State . FAILED ) ; } public void prepare ( Collection < StreamRequest > requests , Collection < StreamSummary > summaries ) { state ( State . PREPARING ) ; for ( StreamRequest request : requests ) addTransferRanges ( request . keyspace , request . ranges , request . columnFamilies , true , request . repairedAt ) ; for ( StreamSummary summary : summaries ) prepareReceiving ( summary ) ; if ( ! requests . isEmpty ( ) ) { PrepareMessage prepare = new PrepareMessage ( ) ; for ( StreamTransferTask task : transfers . values ( ) ) prepare . summaries . add ( task . getSummary ( ) ) ; handler . sendMessage ( prepare ) ; } if ( ! maybeCompleted ( ) ) startStreamingFiles ( ) ; } public void fileSent ( FileMessageHeader header ) { long headerSize = header . size ( ) ; StreamingMetrics . totalOutgoingBytes . inc ( headerSize ) ; metrics . outgoingBytes . inc ( headerSize ) ; StreamTransferTask task = transfers . get ( header . cfId ) ; if ( task ! = null ) { task . scheduleTimeout ( header . sequenceNumber , <int> , TimeUnit . HOURS ) ; } } public void receive ( IncomingFileMessage message ) { long headerSize = message . header . size ( ) ; StreamingMetrics . totalIncomingBytes . inc ( headerSize ) ; metrics . incomingBytes . inc ( headerSize ) ; handler . sendMessage ( new ReceivedMessage ( message . header . cfId , message . header . sequenceNumber ) ) ; receivers . get ( message . header . cfId ) . received ( message . sstable ) ; } public void progress ( Descriptor desc , ProgressInfo . Direction direction , long bytes , long total ) { ProgressInfo progress = new ProgressInfo ( peer , index , desc . filenameFor ( Component . DATA ) , direction , bytes , total ) ; streamResult . handleProgress ( progress ) ; } public void received ( UUID cfId , int sequenceNumber ) { transfers . get ( cfId ) . complete ( sequenceNumber ) ; } public void retry ( UUID cfId , int sequenceNumber ) { OutgoingFileMessage message = transfers . get ( cfId ) . createMessageForRetry ( sequenceNumber ) ; handler . sendMessage ( message ) ; } public synchronized void complete ( ) { if ( state = = State . WAIT_COMPLETE ) { if ( ! completeSent ) { handler . sendMessage ( new CompleteMessage ( ) ) ; completeSent = true ; } closeSession ( State . COMPLETE ) ; } else { state ( State . WAIT_COMPLETE ) ; } } public synchronized void sessionFailed ( ) { closeSession ( State . FAILED ) ; } public void doRetry ( FileMessageHeader header , Throwable e ) { logger . warn ( <str> , planId ( ) , e ) ; retries + + ; if ( retries > DatabaseDescriptor . getMaxStreamingRetries ( ) ) onError ( new IOException ( <str> + header , e ) ) ; else handler . sendMessage ( new RetryMessage ( header . cfId , header . sequenceNumber ) ) ; } public SessionInfo getSessionInfo ( ) { List < StreamSummary > receivingSummaries = Lists . newArrayList ( ) ; for ( StreamTask receiver : receivers . values ( ) ) receivingSummaries . add ( receiver . getSummary ( ) ) ; List < StreamSummary > transferSummaries = Lists . newArrayList ( ) ; for ( StreamTask transfer : transfers . values ( ) ) transferSummaries . add ( transfer . getSummary ( ) ) ; return new SessionInfo ( peer , index , connecting , receivingSummaries , transferSummaries , state ) ; } public synchronized void taskCompleted ( StreamReceiveTask completedTask ) { receivers . remove ( completedTask . cfId ) ; maybeCompleted ( ) ; } public synchronized void taskCompleted ( StreamTransferTask completedTask ) { transfers . remove ( completedTask . cfId ) ; maybeCompleted ( ) ; } public void onJoin ( InetAddress endpoint , EndpointState epState ) { } public void beforeChange ( InetAddress endpoint , EndpointState currentState , ApplicationState newStateKey , VersionedValue newValue ) { } public void onChange ( InetAddress endpoint , ApplicationState state , VersionedValue value ) { } public void onAlive ( InetAddress endpoint , EndpointState state ) { } public void onDead ( InetAddress endpoint , EndpointState state ) { } public void onRemove ( InetAddress endpoint ) { closeSession ( State . FAILED ) ; } public void onRestart ( InetAddress endpoint , EndpointState epState ) { closeSession ( State . FAILED ) ; } private boolean maybeCompleted ( ) { boolean completed = receivers . isEmpty ( ) & & transfers . isEmpty ( ) ; if ( completed ) { if ( state = = State . WAIT_COMPLETE ) { if ( ! completeSent ) { handler . sendMessage ( new CompleteMessage ( ) ) ; completeSent = true ; } closeSession ( State . COMPLETE ) ; } else { handler . sendMessage ( new CompleteMessage ( ) ) ; completeSent = true ; state ( State . WAIT_COMPLETE ) ; } } return completed ; } private void flushSSTables ( Iterable < ColumnFamilyStore > stores ) { List < Future < ? > > flushes = new ArrayList < > ( ) ; for ( ColumnFamilyStore cfs : stores ) flushes . add ( cfs . forceFlush ( ) ) ; FBUtilities . waitOnFutures ( flushes ) ; } private void prepareReceiving ( StreamSummary summary ) { if ( summary . files > <int> ) receivers . put ( summary . cfId , new StreamReceiveTask ( this , summary . cfId , summary . files , summary . totalSize ) ) ; } private void startStreamingFiles ( ) { streamResult . handleSessionPrepared ( this ) ; state ( State . STREAMING ) ; for ( StreamTransferTask task : transfers . values ( ) ) { Collection < OutgoingFileMessage > messages = task . getFileMessages ( ) ; if ( messages . size ( ) > <int> ) handler . sendMessages ( messages ) ; else taskCompleted ( task ) ; } } } 
