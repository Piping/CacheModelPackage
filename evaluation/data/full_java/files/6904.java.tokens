package org . elasticsearch . node ; import org . elasticsearch . Build ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionModule ; import org . elasticsearch . bootstrap . Elasticsearch ; import org . elasticsearch . cache . recycler . PageCacheRecycler ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . node . NodeClientModule ; import org . elasticsearch . cluster . ClusterModule ; import org . elasticsearch . cluster . ClusterNameModule ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . action . index . MappingUpdatedAction ; import org . elasticsearch . cluster . routing . RoutingService ; import org . elasticsearch . common . StopWatch ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . component . Lifecycle ; import org . elasticsearch . common . component . LifecycleComponent ; import org . elasticsearch . common . inject . Injector ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . inject . ModulesBuilder ; import org . elasticsearch . common . lease . Releasable ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . network . NetworkAddress ; import org . elasticsearch . common . network . NetworkModule ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import org . elasticsearch . common . settings . SettingsModule ; import org . elasticsearch . common . transport . BoundTransportAddress ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . discovery . DiscoveryModule ; import org . elasticsearch . discovery . DiscoveryService ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . EnvironmentModule ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . env . NodeEnvironmentModule ; import org . elasticsearch . gateway . GatewayAllocator ; import org . elasticsearch . gateway . GatewayModule ; import org . elasticsearch . gateway . GatewayService ; import org . elasticsearch . http . HttpServer ; import org . elasticsearch . http . HttpServerModule ; import org . elasticsearch . http . HttpServerTransport ; import org . elasticsearch . indices . IndicesModule ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . indices . analysis . AnalysisModule ; import org . elasticsearch . indices . breaker . CircuitBreakerModule ; import org . elasticsearch . indices . cache . query . IndicesQueryCache ; import org . elasticsearch . indices . cluster . IndicesClusterStateService ; import org . elasticsearch . indices . fielddata . cache . IndicesFieldDataCache ; import org . elasticsearch . indices . memory . IndexingMemoryController ; import org . elasticsearch . indices . recovery . RecoverySettings ; import org . elasticsearch . indices . store . IndicesStore ; import org . elasticsearch . indices . ttl . IndicesTTLService ; import org . elasticsearch . monitor . MonitorService ; import org . elasticsearch . monitor . jvm . JvmInfo ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . percolator . PercolatorModule ; import org . elasticsearch . percolator . PercolatorService ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . plugins . PluginsModule ; import org . elasticsearch . plugins . PluginsService ; import org . elasticsearch . repositories . RepositoriesModule ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestModule ; import org . elasticsearch . script . ScriptModule ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . search . SearchModule ; import org . elasticsearch . search . SearchService ; import org . elasticsearch . snapshots . SnapshotShardsService ; import org . elasticsearch . snapshots . SnapshotsService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . threadpool . ThreadPoolModule ; import org . elasticsearch . transport . TransportModule ; import org . elasticsearch . transport . TransportService ; import org . elasticsearch . tribe . TribeModule ; import org . elasticsearch . tribe . TribeService ; import org . elasticsearch . watcher . ResourceWatcherModule ; import org . elasticsearch . watcher . ResourceWatcherService ; import java . io . BufferedWriter ; import java . io . IOException ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . nio . charset . Charset ; import java . nio . file . CopyOption ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . StandardCopyOption ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; public class Node implements Releasable { private static final String CLIENT_TYPE = <str> ; public static final String HTTP_ENABLED = <str> ; private final Lifecycle lifecycle = new Lifecycle ( ) ; private final Injector injector ; private final Settings settings ; private final Environment environment ; private final PluginsService pluginsService ; private final Client client ; public Node ( Settings preparedSettings ) { this ( InternalSettingsPreparer . prepareEnvironment ( preparedSettings , null ) , Version . CURRENT , Collections . < Class < ? extends Plugin > > emptyList ( ) ) ; } protected Node ( Environment tmpEnv , Version version , Collection < Class < ? extends Plugin > > classpathPlugins ) { Settings tmpSettings = settingsBuilder ( ) . put ( tmpEnv . settings ( ) ) . put ( Client . CLIENT_TYPE_SETTING , CLIENT_TYPE ) . build ( ) ; tmpSettings = TribeService . processSettings ( tmpSettings ) ; ESLogger logger = Loggers . getLogger ( Node . class , tmpSettings . get ( <str> ) ) ; logger . info ( <str> , version , JvmInfo . jvmInfo ( ) . pid ( ) , Build . CURRENT . shortHash ( ) , Build . CURRENT . date ( ) ) ; logger . info ( <str> ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , tmpEnv . configFile ( ) , Arrays . toString ( tmpEnv . dataFiles ( ) ) , tmpEnv . logsFile ( ) , tmpEnv . pluginsFile ( ) ) ; } this . pluginsService = new PluginsService ( tmpSettings , tmpEnv . modulesFile ( ) , tmpEnv . pluginsFile ( ) , classpathPlugins ) ; this . settings = pluginsService . updatedSettings ( ) ; this . environment = new Environment ( this . settings ( ) ) ; final NodeEnvironment nodeEnvironment ; try { nodeEnvironment = new NodeEnvironment ( this . settings , this . environment ) ; } catch ( IOException ex ) { throw new IllegalStateException ( <str> , ex ) ; } final NetworkService networkService = new NetworkService ( settings ) ; final NodeSettingsService nodeSettingsService = new NodeSettingsService ( settings ) ; final SettingsFilter settingsFilter = new SettingsFilter ( settings ) ; final ThreadPool threadPool = new ThreadPool ( settings ) ; boolean success = false ; try { final MonitorService monitorService = new MonitorService ( settings , nodeEnvironment , threadPool ) ; ModulesBuilder modules = new ModulesBuilder ( ) ; modules . add ( new Version . Module ( version ) ) ; modules . add ( new CircuitBreakerModule ( settings ) ) ; for ( Module pluginModule : pluginsService . nodeModules ( ) ) { modules . add ( pluginModule ) ; } modules . add ( new PluginsModule ( pluginsService ) ) ; modules . add ( new SettingsModule ( this . settings , settingsFilter ) ) ; modules . add ( new NodeModule ( this , nodeSettingsService , monitorService ) ) ; modules . add ( new NetworkModule ( networkService ) ) ; modules . add ( new ScriptModule ( this . settings ) ) ; modules . add ( new EnvironmentModule ( environment ) ) ; modules . add ( new NodeEnvironmentModule ( nodeEnvironment ) ) ; modules . add ( new ClusterNameModule ( this . settings ) ) ; modules . add ( new ThreadPoolModule ( threadPool ) ) ; modules . add ( new DiscoveryModule ( this . settings ) ) ; modules . add ( new ClusterModule ( this . settings ) ) ; modules . add ( new RestModule ( this . settings ) ) ; modules . add ( new TransportModule ( settings ) ) ; if ( settings . getAsBoolean ( HTTP_ENABLED , true ) ) { modules . add ( new HttpServerModule ( settings ) ) ; } modules . add ( new IndicesModule ( ) ) ; modules . add ( new SearchModule ( ) ) ; modules . add ( new ActionModule ( false ) ) ; modules . add ( new GatewayModule ( settings ) ) ; modules . add ( new NodeClientModule ( ) ) ; modules . add ( new PercolatorModule ( ) ) ; modules . add ( new ResourceWatcherModule ( ) ) ; modules . add ( new RepositoriesModule ( ) ) ; modules . add ( new TribeModule ( ) ) ; modules . add ( new AnalysisModule ( environment ) ) ; pluginsService . processModules ( modules ) ; injector = modules . createInjector ( ) ; client = injector . getInstance ( Client . class ) ; threadPool . setNodeSettingsService ( injector . getInstance ( NodeSettingsService . class ) ) ; success = true ; } catch ( IOException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } finally { if ( ! success ) { nodeEnvironment . close ( ) ; ThreadPool . terminate ( threadPool , <int> , TimeUnit . SECONDS ) ; } } logger . info ( <str> ) ; } public Settings settings ( ) { return this . settings ; } public Client client ( ) { return client ; } public Node start ( ) { if ( ! lifecycle . moveToStarted ( ) ) { return this ; } ESLogger logger = Loggers . getLogger ( Node . class , settings . get ( <str> ) ) ; logger . info ( <str> ) ; injector . getInstance ( Discovery . class ) . setRoutingService ( injector . getInstance ( RoutingService . class ) ) ; for ( Class < ? extends LifecycleComponent > plugin : pluginsService . nodeServices ( ) ) { injector . getInstance ( plugin ) . start ( ) ; } injector . getInstance ( MappingUpdatedAction . class ) . setClient ( client ) ; injector . getInstance ( IndicesService . class ) . start ( ) ; injector . getInstance ( IndexingMemoryController . class ) . start ( ) ; injector . getInstance ( IndicesClusterStateService . class ) . start ( ) ; injector . getInstance ( IndicesTTLService . class ) . start ( ) ; injector . getInstance ( SnapshotsService . class ) . start ( ) ; injector . getInstance ( SnapshotShardsService . class ) . start ( ) ; injector . getInstance ( TransportService . class ) . start ( ) ; injector . getInstance ( ClusterService . class ) . start ( ) ; injector . getInstance ( RoutingService . class ) . start ( ) ; injector . getInstance ( SearchService . class ) . start ( ) ; injector . getInstance ( MonitorService . class ) . start ( ) ; injector . getInstance ( RestController . class ) . start ( ) ; injector . getInstance ( GatewayAllocator . class ) . setReallocation ( injector . getInstance ( ClusterService . class ) , injector . getInstance ( RoutingService . class ) ) ; DiscoveryService discoService = injector . getInstance ( DiscoveryService . class ) . start ( ) ; discoService . waitForInitialState ( ) ; injector . getInstance ( GatewayService . class ) . start ( ) ; if ( settings . getAsBoolean ( <str> , true ) ) { injector . getInstance ( HttpServer . class ) . start ( ) ; } injector . getInstance ( ResourceWatcherService . class ) . start ( ) ; injector . getInstance ( TribeService . class ) . start ( ) ; if ( System . getProperty ( <str> , <str> ) . equals ( <str> ) ) { if ( settings . getAsBoolean ( <str> , true ) ) { HttpServerTransport http = injector . getInstance ( HttpServerTransport . class ) ; writePortsFile ( <str> , http . boundAddress ( ) ) ; } TransportService transport = injector . getInstance ( TransportService . class ) ; writePortsFile ( <str> , transport . boundAddress ( ) ) ; } logger . info ( <str> ) ; return this ; } private Node stop ( ) { if ( ! lifecycle . moveToStopped ( ) ) { return this ; } ESLogger logger = Loggers . getLogger ( Node . class , settings . get ( <str> ) ) ; logger . info ( <str> ) ; injector . getInstance ( TribeService . class ) . stop ( ) ; injector . getInstance ( ResourceWatcherService . class ) . stop ( ) ; if ( settings . getAsBoolean ( <str> , true ) ) { injector . getInstance ( HttpServer . class ) . stop ( ) ; } injector . getInstance ( SnapshotsService . class ) . stop ( ) ; injector . getInstance ( SnapshotShardsService . class ) . stop ( ) ; injector . getInstance ( IndicesClusterStateService . class ) . stop ( ) ; injector . getInstance ( IndexingMemoryController . class ) . stop ( ) ; injector . getInstance ( IndicesTTLService . class ) . stop ( ) ; injector . getInstance ( RoutingService . class ) . stop ( ) ; injector . getInstance ( ClusterService . class ) . stop ( ) ; injector . getInstance ( DiscoveryService . class ) . stop ( ) ; injector . getInstance ( MonitorService . class ) . stop ( ) ; injector . getInstance ( GatewayService . class ) . stop ( ) ; injector . getInstance ( SearchService . class ) . stop ( ) ; injector . getInstance ( RestController . class ) . stop ( ) ; injector . getInstance ( TransportService . class ) . stop ( ) ; for ( Class < ? extends LifecycleComponent > plugin : pluginsService . nodeServices ( ) ) { injector . getInstance ( plugin ) . stop ( ) ; } injector . getInstance ( RecoverySettings . class ) . close ( ) ; injector . getInstance ( IndicesService . class ) . stop ( ) ; logger . info ( <str> ) ; return this ; } @Override public synchronized void close ( ) { if ( lifecycle . started ( ) ) { stop ( ) ; } if ( ! lifecycle . moveToClosed ( ) ) { return ; } ESLogger logger = Loggers . getLogger ( Node . class , settings . get ( <str> ) ) ; logger . info ( <str> ) ; StopWatch stopWatch = new StopWatch ( <str> ) ; stopWatch . start ( <str> ) ; injector . getInstance ( TribeService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; if ( settings . getAsBoolean ( <str> , true ) ) { injector . getInstance ( HttpServer . class ) . close ( ) ; } stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( SnapshotsService . class ) . close ( ) ; injector . getInstance ( SnapshotShardsService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; Releasables . close ( injector . getInstance ( Client . class ) ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( IndicesClusterStateService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( IndexingMemoryController . class ) . close ( ) ; injector . getInstance ( IndicesTTLService . class ) . close ( ) ; injector . getInstance ( IndicesService . class ) . close ( ) ; injector . getInstance ( IndicesQueryCache . class ) . close ( ) ; injector . getInstance ( IndicesFieldDataCache . class ) . close ( ) ; injector . getInstance ( IndicesStore . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( RoutingService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( ClusterService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( DiscoveryService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( MonitorService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( GatewayService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( SearchService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( RestController . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( TransportService . class ) . close ( ) ; stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( PercolatorService . class ) . close ( ) ; for ( Class < ? extends LifecycleComponent > plugin : pluginsService . nodeServices ( ) ) { stopWatch . stop ( ) . start ( <str> + plugin . getName ( ) + <str> ) ; injector . getInstance ( plugin ) . close ( ) ; } stopWatch . stop ( ) . start ( <str> ) ; try { injector . getInstance ( ScriptService . class ) . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } stopWatch . stop ( ) . start ( <str> ) ; injector . getInstance ( ThreadPool . class ) . shutdown ( ) ; try { injector . getInstance ( ThreadPool . class ) . awaitTermination ( <int> , TimeUnit . SECONDS ) ; } catch ( InterruptedException e ) { } stopWatch . stop ( ) . start ( <str> ) ; try { injector . getInstance ( ThreadPool . class ) . shutdownNow ( ) ; } catch ( Exception e ) { } stopWatch . stop ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , stopWatch . prettyPrint ( ) ) ; } injector . getInstance ( NodeEnvironment . class ) . close ( ) ; injector . getInstance ( PageCacheRecycler . class ) . close ( ) ; logger . info ( <str> ) ; } public boolean isClosed ( ) { return lifecycle . closed ( ) ; } public Injector injector ( ) { return this . injector ; } private void writePortsFile ( String type , BoundTransportAddress boundAddress ) { Path tmpPortsFile = environment . logsFile ( ) . resolve ( type + <str> ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( tmpPortsFile , Charset . forName ( <str> ) ) ) { for ( TransportAddress address : boundAddress . boundAddresses ( ) ) { InetAddress inetAddress = InetAddress . getByName ( address . getAddress ( ) ) ; if ( inetAddress instanceof Inet6Address & & inetAddress . isLinkLocalAddress ( ) ) { continue ; } writer . write ( NetworkAddress . formatAddress ( new InetSocketAddress ( inetAddress , address . getPort ( ) ) ) + <str> ) ; } } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } Path portsFile = environment . logsFile ( ) . resolve ( type + <str> ) ; try { Files . move ( tmpPortsFile , portsFile , StandardCopyOption . ATOMIC_MOVE ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> , e ) ; } } } 
