package org . gradle . play . internal . run ; import org . gradle . api . Action ; import org . gradle . api . logging . Logging ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . process . internal . WorkerProcessContext ; import java . io . IOException ; import java . io . Serializable ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . net . URLConnection ; import java . util . concurrent . CountDownLatch ; public class PlayWorkerServer implements Action < WorkerProcessContext > , PlayRunWorkerServerProtocol , Serializable { private PlayRunSpec runSpec ; private VersionedPlayRunAdapter runAdapter ; private volatile CountDownLatch stop ; public PlayWorkerServer ( PlayRunSpec runSpec , VersionedPlayRunAdapter runAdapter ) { this . runSpec = runSpec ; this . runAdapter = runAdapter ; } public void execute ( WorkerProcessContext context ) { stop = new CountDownLatch ( <int> ) ; final PlayRunWorkerClientProtocol clientProtocol = context . getServerConnection ( ) . addOutgoing ( PlayRunWorkerClientProtocol . class ) ; context . getServerConnection ( ) . addIncoming ( PlayRunWorkerServerProtocol . class , this ) ; context . getServerConnection ( ) . connect ( ) ; final PlayAppLifecycleUpdate result = startServer ( ) ; try { clientProtocol . update ( result ) ; stop . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } finally { clientProtocol . update ( PlayAppLifecycleUpdate . stopped ( ) ) ; } } private PlayAppLifecycleUpdate startServer ( ) { try { run ( ) ; return PlayAppLifecycleUpdate . running ( ) ; } catch ( Exception e ) { Logging . getLogger ( this . getClass ( ) ) . error ( <str> , e ) ; return PlayAppLifecycleUpdate . failed ( e ) ; } } private void run ( ) { disableUrlConnectionCaching ( ) ; final Thread thread = Thread . currentThread ( ) ; final ClassLoader previousContextClassLoader = thread . getContextClassLoader ( ) ; final ClassLoader classLoader = new URLClassLoader ( new DefaultClassPath ( runSpec . getClasspath ( ) ) . getAsURLArray ( ) , null ) ; thread . setContextClassLoader ( classLoader ) ; try { Object buildDocHandler = runAdapter . getBuildDocHandler ( classLoader , runSpec . getClasspath ( ) ) ; Object buildLink = runAdapter . getBuildLink ( classLoader , runSpec . getProjectPath ( ) , runSpec . getApplicationJar ( ) , runSpec . getChangingClasspath ( ) , runSpec . getAssetsJar ( ) , runSpec . getAssetsDirs ( ) ) ; runAdapter . runDevHttpServer ( classLoader , classLoader , buildLink , buildDocHandler , runSpec . getHttpPort ( ) ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } finally { thread . setContextClassLoader ( previousContextClassLoader ) ; } } private void disableUrlConnectionCaching ( ) { try { URL url = new URL ( <str> ) ; URLConnection urlConnection = url . openConnection ( ) ; urlConnection . setDefaultUseCaches ( false ) ; } catch ( MalformedURLException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } catch ( IOException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public void stop ( ) { stop . countDown ( ) ; } @Override public void reload ( ) { runAdapter . reload ( ) ; } @Override public void buildError ( Throwable throwable ) { runAdapter . buildError ( throwable ) ; } } 
