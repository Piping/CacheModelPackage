package org . apache . cassandra . hints ; import java . io . IOException ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . FilteredPartition ; import org . apache . cassandra . db . partitions . PartitionIterator ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputBuffer ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . schema . TableParams ; import org . apache . cassandra . utils . FBUtilities ; import static junit . framework . Assert . * ; import static org . apache . cassandra . Util . dk ; import static org . apache . cassandra . hints . HintsTestUtil . assertHintsEqual ; import static org . apache . cassandra . hints . HintsTestUtil . assertPartitionsEqual ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; public class HintTest { private static final String KEYSPACE = <str> ; private static final String TABLE0 = <str> ; private static final String TABLE1 = <str> ; private static final String TABLE2 = <str> ; @BeforeClass public static void defineSchema ( ) { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE , TABLE0 ) , SchemaLoader . standardCFMD ( KEYSPACE , TABLE1 ) , SchemaLoader . standardCFMD ( KEYSPACE , TABLE2 ) ) ; } @Before public void resetGcGraceSeconds ( ) { for ( CFMetaData table : Schema . instance . getTablesAndViews ( KEYSPACE ) ) table . gcGraceSeconds ( TableParams . DEFAULT_GC_GRACE_SECONDS ) ; } @Test public void testSerializer ( ) throws IOException { long now = FBUtilities . timestampMicros ( ) ; Mutation mutation = createMutation ( <str> , now ) ; Hint hint = Hint . create ( mutation , now / <int> ) ; int serializedSize = ( int ) Hint . serializer . serializedSize ( hint , MessagingService . current_version ) ; DataOutputBuffer dob = new DataOutputBuffer ( ) ; Hint . serializer . serialize ( hint , dob , MessagingService . current_version ) ; assertEquals ( serializedSize , dob . getLength ( ) ) ; DataInputPlus di = new DataInputBuffer ( dob . buffer ( ) , true ) ; Hint deserializedHint = Hint . serializer . deserialize ( di , MessagingService . current_version ) ; assertHintsEqual ( hint , deserializedHint ) ; } @Test public void testApply ( ) { long now = FBUtilities . timestampMicros ( ) ; String key = <str> ; Mutation mutation = createMutation ( key , now ) ; Hint hint = Hint . create ( mutation , now / <int> ) ; assertNoPartitions ( key , TABLE0 ) ; assertNoPartitions ( key , TABLE1 ) ; assertNoPartitions ( key , TABLE2 ) ; hint . apply ( ) ; for ( PartitionUpdate partition : mutation . getPartitionUpdates ( ) ) assertPartitionsEqual ( partition , readPartition ( key , partition . metadata ( ) . cfName ) ) ; } @Test public void testApplyWithTruncation ( ) { long now = FBUtilities . timestampMicros ( ) ; String key = <str> ; Mutation mutation = createMutation ( key , now ) ; assertNoPartitions ( key , TABLE0 ) ; assertNoPartitions ( key , TABLE1 ) ; assertNoPartitions ( key , TABLE2 ) ; Keyspace . open ( KEYSPACE ) . getColumnFamilyStore ( TABLE1 ) . truncateBlocking ( ) ; Hint . create ( mutation , now / <int> - <int> ) . apply ( ) ; assertNoPartitions ( key , TABLE1 ) ; assertPartitionsEqual ( mutation . getPartitionUpdate ( Schema . instance . getId ( KEYSPACE , TABLE0 ) ) , readPartition ( key , TABLE0 ) ) ; assertPartitionsEqual ( mutation . getPartitionUpdate ( Schema . instance . getId ( KEYSPACE , TABLE2 ) ) , readPartition ( key , TABLE2 ) ) ; } @Test public void testApplyWithRegularExpiration ( ) { long now = FBUtilities . timestampMicros ( ) ; String key = <str> ; Mutation mutation = createMutation ( key , now ) ; assertNoPartitions ( key , TABLE0 ) ; assertNoPartitions ( key , TABLE1 ) ; assertNoPartitions ( key , TABLE2 ) ; Schema . instance . getCFMetaData ( KEYSPACE , TABLE0 ) . gcGraceSeconds ( <int> ) ; Hint . create ( mutation , now / <int> ) . apply ( ) ; assertNoPartitions ( key , TABLE0 ) ; assertNoPartitions ( key , TABLE1 ) ; assertNoPartitions ( key , TABLE2 ) ; } @Test public void testApplyWithGCGSReducedLater ( ) { long now = FBUtilities . timestampMicros ( ) ; String key = <str> ; Mutation mutation = createMutation ( key , now ) ; Hint hint = Hint . create ( mutation , now / <int> ) ; assertNoPartitions ( key , TABLE0 ) ; assertNoPartitions ( key , TABLE1 ) ; assertNoPartitions ( key , TABLE2 ) ; Schema . instance . getCFMetaData ( KEYSPACE , TABLE0 ) . gcGraceSeconds ( <int> ) ; hint . apply ( ) ; assertNoPartitions ( key , TABLE0 ) ; assertNoPartitions ( key , TABLE1 ) ; assertNoPartitions ( key , TABLE2 ) ; } private static Mutation createMutation ( String key , long now ) { Mutation mutation = new Mutation ( KEYSPACE , dk ( key ) ) ; new RowUpdateBuilder ( Schema . instance . getCFMetaData ( KEYSPACE , TABLE0 ) , now , mutation ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) ; new RowUpdateBuilder ( Schema . instance . getCFMetaData ( KEYSPACE , TABLE1 ) , now + <int> , mutation ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) ; new RowUpdateBuilder ( Schema . instance . getCFMetaData ( KEYSPACE , TABLE2 ) , now + <int> , mutation ) . clustering ( <str> ) . add ( <str> , <str> ) . build ( ) ; return mutation ; } private static SinglePartitionReadCommand cmd ( String key , String table ) { CFMetaData meta = Schema . instance . getCFMetaData ( KEYSPACE , table ) ; return SinglePartitionReadCommand . fullPartitionRead ( meta , FBUtilities . nowInSeconds ( ) , bytes ( key ) ) ; } private static FilteredPartition readPartition ( String key , String table ) { return Util . getOnlyPartition ( cmd ( key , table ) ) ; } private static void assertNoPartitions ( String key , String table ) { ReadCommand cmd = cmd ( key , table ) ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; PartitionIterator iterator = cmd . executeInternal ( executionController ) ) { assertFalse ( iterator . hasNext ( ) ) ; } } } 
