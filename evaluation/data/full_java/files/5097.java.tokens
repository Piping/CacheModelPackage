package org . elasticsearch . action . admin . indices . create ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . master . TransportMasterNodeAction ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ack . ClusterStateUpdateResponse ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MetaDataCreateIndexService ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . indices . IndexAlreadyExistsException ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; public class TransportCreateIndexAction extends TransportMasterNodeAction < CreateIndexRequest , CreateIndexResponse > { private final MetaDataCreateIndexService createIndexService ; @Inject public TransportCreateIndexAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , MetaDataCreateIndexService createIndexService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , CreateIndexAction . NAME , transportService , clusterService , threadPool , actionFilters , indexNameExpressionResolver , CreateIndexRequest : : new ) ; this . createIndexService = createIndexService ; } @Override protected String executor ( ) { return ThreadPool . Names . SAME ; } @Override protected CreateIndexResponse newResponse ( ) { return new CreateIndexResponse ( ) ; } @Override protected ClusterBlockException checkBlock ( CreateIndexRequest request , ClusterState state ) { return state . blocks ( ) . indexBlockedException ( ClusterBlockLevel . METADATA_WRITE , request . index ( ) ) ; } @Override protected void masterOperation ( final CreateIndexRequest request , final ClusterState state , final ActionListener < CreateIndexResponse > listener ) { String cause = request . cause ( ) ; if ( cause . length ( ) = = <int> ) { cause = <str> ; } final String indexName = indexNameExpressionResolver . resolveDateMathExpression ( request . index ( ) ) ; final CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest ( request , cause , indexName , request . updateAllTypes ( ) ) . ackTimeout ( request . timeout ( ) ) . masterNodeTimeout ( request . masterNodeTimeout ( ) ) . settings ( request . settings ( ) ) . mappings ( request . mappings ( ) ) . aliases ( request . aliases ( ) ) . customs ( request . customs ( ) ) ; createIndexService . createIndex ( updateRequest , new ActionListener < ClusterStateUpdateResponse > ( ) { @Override public void onResponse ( ClusterStateUpdateResponse response ) { listener . onResponse ( new CreateIndexResponse ( response . isAcknowledged ( ) ) ) ; } @Override public void onFailure ( Throwable t ) { if ( t instanceof IndexAlreadyExistsException ) { logger . trace ( <str> , t , request . index ( ) ) ; } else { logger . debug ( <str> , t , request . index ( ) ) ; } listener . onFailure ( t ) ; } } ) ; } } 
