package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; public abstract class Decision implements ToXContent { public static final Decision ALWAYS = new Single ( Type . YES ) ; public static final Decision YES = new Single ( Type . YES ) ; public static final Decision NO = new Single ( Type . NO ) ; public static final Decision THROTTLE = new Single ( Type . THROTTLE ) ; public static Decision single ( Type type , String label , String explanation , Object . . . explanationParams ) { return new Single ( type , label , explanation , explanationParams ) ; } public static void writeTo ( Decision decision , StreamOutput out ) throws IOException { if ( decision instanceof Multi ) { out . writeBoolean ( true ) ; out . writeVInt ( ( ( Multi ) decision ) . decisions . size ( ) ) ; for ( Decision d : ( ( Multi ) decision ) . decisions ) { writeTo ( d , out ) ; } } else { out . writeBoolean ( false ) ; Single d = ( ( Single ) decision ) ; Type . writeTo ( d . type , out ) ; out . writeOptionalString ( d . label ) ; out . writeOptionalString ( d . getExplanation ( ) ) ; } } public static Decision readFrom ( StreamInput in ) throws IOException { if ( in . readBoolean ( ) ) { Multi result = new Multi ( ) ; int decisionCount = in . readVInt ( ) ; for ( int i = <int> ; i < decisionCount ; i + + ) { Decision s = readFrom ( in ) ; result . decisions . add ( s ) ; } return result ; } else { Single result = new Single ( ) ; result . type = Type . readFrom ( in ) ; result . label = in . readOptionalString ( ) ; result . explanationString = in . readOptionalString ( ) ; return result ; } } public static enum Type { YES , NO , THROTTLE ; public static Type resolve ( String s ) { return Type . valueOf ( s . toUpperCase ( Locale . ROOT ) ) ; } public static Type readFrom ( StreamInput in ) throws IOException { int i = in . readVInt ( ) ; switch ( i ) { case <int> : return NO ; case <int> : return YES ; case <int> : return THROTTLE ; default : throw new IllegalArgumentException ( <str> + i + <str> ) ; } } public static void writeTo ( Type type , StreamOutput out ) throws IOException { switch ( type ) { case NO : out . writeVInt ( <int> ) ; break ; case YES : out . writeVInt ( <int> ) ; break ; case THROTTLE : out . writeVInt ( <int> ) ; break ; default : throw new IllegalArgumentException ( <str> + type + <str> ) ; } } } public abstract Type type ( ) ; public abstract String label ( ) ; public static class Single extends Decision { private Type type ; private String label ; private String explanation ; private String explanationString ; private Object [ ] explanationParams ; public Single ( ) { } public Single ( Type type ) { this ( type , null , null , ( Object [ ] ) null ) ; } public Single ( Type type , String label , String explanation , Object . . . explanationParams ) { this . type = type ; this . label = label ; this . explanation = explanation ; this . explanationParams = explanationParams ; } @Override public Type type ( ) { return this . type ; } @Override public String label ( ) { return this . label ; } public String getExplanation ( ) { if ( explanationString = = null & & explanation ! = null ) { explanationString = String . format ( Locale . ROOT , explanation , explanationParams ) ; } return this . explanationString ; } @Override public String toString ( ) { if ( explanation = = null ) { return type + <str> ; } return type + <str> + getExplanation ( ) + <str> ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; builder . field ( <str> , label ) ; builder . field ( <str> , type ) ; String explanation = getExplanation ( ) ; builder . field ( <str> , explanation ! = null ? explanation : <str> ) ; builder . endObject ( ) ; return builder ; } } public static class Multi extends Decision { private final List < Decision > decisions = new ArrayList < > ( ) ; public Multi add ( Decision decision ) { decisions . add ( decision ) ; return this ; } @Override public Type type ( ) { Type ret = Type . YES ; for ( int i = <int> ; i < decisions . size ( ) ; i + + ) { Type type = decisions . get ( i ) . type ( ) ; if ( type = = Type . NO ) { return type ; } else if ( type = = Type . THROTTLE ) { ret = type ; } } return ret ; } @Override public String label ( ) { return null ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Decision decision : decisions ) { sb . append ( <str> ) . append ( decision . toString ( ) ) . append ( <str> ) ; } return sb . toString ( ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startArray ( <str> ) ; for ( Decision d : decisions ) { d . toXContent ( builder , params ) ; } builder . endArray ( ) ; return builder ; } } } 
