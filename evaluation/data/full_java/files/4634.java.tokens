package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; import org . eclipse . debug . core . model . MemoryByte ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . ui . IDebugUIConstants ; public class UnsignedIntegerRendering extends AbstractIntegerRendering { public UnsignedIntegerRendering ( String renderingId ) { super ( renderingId ) ; } private String convertToString ( byte [ ] byteArray , int columnSize , int endianess ) { String ret ; long result = <int> ; if ( columnSize = = <int> ) { result = byteArray [ <int> ] ; result & = <hex> ; } else if ( columnSize = = <int> ) { result = RenderingsUtil . convertByteArrayToInt ( byteArray , endianess ) ; } else if ( columnSize = = <int> ) { result = RenderingsUtil . convertByteArrayToLong ( byteArray , endianess ) ; } else if ( columnSize = = <int> ) { BigInteger value = RenderingsUtil . convertByteArrayToUnsignedLong ( byteArray , endianess ) ; return value . toString ( ) ; } else if ( columnSize = = <int> ) { BigInteger bigRet = RenderingsUtil . convertByteArrayToUnsignedBigInt ( byteArray , endianess ) ; return bigRet . toString ( ) ; } else { BigInteger bigRet = RenderingsUtil . convertByteArrayToUnsignedBigInt ( byteArray , endianess , columnSize ) ; return bigRet . toString ( ) ; } ret = new Long ( result ) . toString ( ) ; return ret ; } private byte [ ] convertToBytes ( int colSize , String newValue , int endianess ) { try { byte [ ] bytes ; if ( colSize = = <int> ) { short i = Short . parseShort ( newValue ) ; bytes = RenderingsUtil . convertShortToByteArray ( i , endianess ) ; bytes = extractBytes ( bytes , endianess , colSize ) ; } else if ( colSize = = <int> ) { int i = Integer . parseInt ( newValue ) ; bytes = RenderingsUtil . convertIntToByteArray ( i , endianess ) ; bytes = extractBytes ( bytes , endianess , colSize ) ; } else if ( colSize = = <int> ) { long i = Long . parseLong ( newValue ) ; bytes = RenderingsUtil . convertLongToByteArray ( i , endianess ) ; bytes = extractBytes ( bytes , endianess , colSize ) ; } else if ( colSize = = <int> ) { BigInteger i = new BigInteger ( newValue ) ; bytes = RenderingsUtil . convertBigIntegerToByteArray ( i , endianess ) ; bytes = extractBytes ( bytes , endianess , colSize ) ; } else if ( colSize = = <int> ) { BigInteger i = new BigInteger ( newValue ) ; bytes = RenderingsUtil . convertUnsignedBigIntegerToByteArray ( i , endianess ) ; bytes = extractBytes ( bytes , endianess , colSize ) ; return bytes ; } else { BigInteger i = new BigInteger ( newValue ) ; bytes = RenderingsUtil . convertUnsignedBigIntToByteArray ( i , endianess , colSize ) ; bytes = extractBytes ( bytes , endianess , colSize ) ; return bytes ; } return bytes ; } catch ( NumberFormatException e ) { throw e ; } } @Override public String getString ( String dataType , BigInteger address , MemoryByte [ ] data ) { String paddedStr = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IDebugUIConstants . PREF_PADDED_STR ) ; boolean invalid = false ; for ( int i = <int> ; i < data . length ; i + + ) { if ( ! data [ i ] . isReadable ( ) ) { invalid = true ; break ; } } if ( invalid ) { StringBuffer strBuf = new StringBuffer ( ) ; for ( int i = <int> ; i < data . length ; i + + ) { strBuf . append ( paddedStr ) ; } return strBuf . toString ( ) ; } int columnSize = getBytesPerColumn ( ) ; int endianess = getDisplayEndianess ( ) ; if ( endianess = = RenderingsUtil . ENDIANESS_UNKNOWN ) endianess = getBytesEndianess ( data ) ; byte [ ] byteArray = new byte [ data . length ] ; for ( int i = <int> ; i < byteArray . length ; i + + ) { byteArray [ i ] = data [ i ] . getValue ( ) ; } if ( RenderingsUtil . ENDIANESS_UNKNOWN = = endianess ) { StringBuffer strBuf = new StringBuffer ( ) ; for ( int i = <int> ; i < byteArray . length ; i + + ) { strBuf . append ( paddedStr ) ; } return strBuf . toString ( ) ; } return convertToString ( byteArray , columnSize , endianess ) ; } @Override public byte [ ] getBytes ( String dataType , BigInteger address , MemoryByte [ ] currentValues , String data ) { int columnSize = getBytesPerColumn ( ) ; int endianess = getDisplayEndianess ( ) ; if ( endianess = = RenderingsUtil . ENDIANESS_UNKNOWN ) endianess = getBytesEndianess ( currentValues ) ; if ( endianess = = RenderingsUtil . ENDIANESS_UNKNOWN ) { byte [ ] retBytes = new byte [ currentValues . length ] ; for ( int i = <int> ; i < currentValues . length ; i + + ) retBytes [ i ] = currentValues [ i ] . getValue ( ) ; return retBytes ; } return convertToBytes ( columnSize , data , endianess ) ; } private byte [ ] extractBytes ( byte [ ] bytes , int endianess , int colSize ) { if ( colSize > bytes . length ) throw new NumberFormatException ( ) ; if ( endianess = = RenderingsUtil . BIG_ENDIAN ) { for ( int i = <int> ; i < colSize ; i + + ) { if ( bytes [ i ] ! = <int> ) throw new NumberFormatException ( ) ; } byte [ ] copy = new byte [ colSize ] ; for ( int j = <int> , k = bytes . length - colSize ; j < copy . length & & k < bytes . length ; j + + , k + + ) { copy [ j ] = bytes [ k ] ; } bytes = copy ; } else { for ( int i = colSize ; i < bytes . length ; i + + ) { if ( bytes [ i ] ! = <int> ) throw new NumberFormatException ( ) ; } byte [ ] copy = new byte [ colSize ] ; for ( int j = <int> ; j < copy . length ; j + + ) { copy [ j ] = bytes [ j ] ; } bytes = copy ; } return bytes ; } } 
