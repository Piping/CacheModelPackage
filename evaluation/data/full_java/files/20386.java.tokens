package io . netty . channel . epoll ; import io . netty . util . internal . ObjectUtil ; import java . net . InetAddress ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; import java . util . Map . Entry ; final class TcpMd5Util { static Collection < InetAddress > newTcpMd5Sigs ( AbstractEpollChannel channel , Collection < InetAddress > current , Map < InetAddress , byte [ ] > newKeys ) { ObjectUtil . checkNotNull ( channel , <str> ) ; ObjectUtil . checkNotNull ( current , <str> ) ; ObjectUtil . checkNotNull ( newKeys , <str> ) ; for ( Entry < InetAddress , byte [ ] > e : newKeys . entrySet ( ) ) { final byte [ ] key = e . getValue ( ) ; if ( e . getKey ( ) = = null ) { throw new IllegalArgumentException ( <str> + newKeys ) ; } if ( key = = null ) { throw new NullPointerException ( <str> + e . getKey ( ) + <str> ) ; } if ( key . length = = <int> ) { throw new IllegalArgumentException ( <str> + e . getKey ( ) + <str> ) ; } if ( key . length > Native . TCP_MD5SIG_MAXKEYLEN ) { throw new IllegalArgumentException ( <str> + e . getKey ( ) + <str> + Native . TCP_MD5SIG_MAXKEYLEN + <str> ) ; } } for ( InetAddress addr : current ) { if ( ! newKeys . containsKey ( addr ) ) { Native . setTcpMd5Sig ( channel . fd ( ) . intValue ( ) , addr , null ) ; } } if ( newKeys . isEmpty ( ) ) { return Collections . emptySet ( ) ; } final Collection < InetAddress > addresses = new ArrayList < InetAddress > ( newKeys . size ( ) ) ; for ( Entry < InetAddress , byte [ ] > e : newKeys . entrySet ( ) ) { Native . setTcpMd5Sig ( channel . fd ( ) . intValue ( ) , e . getKey ( ) , e . getValue ( ) ) ; addresses . add ( e . getKey ( ) ) ; } return addresses ; } private TcpMd5Util ( ) { } } 
