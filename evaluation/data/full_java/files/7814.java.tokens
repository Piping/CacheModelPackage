package org . elasticsearch . cluster . allocation ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . cluster . health . ClusterHealthStatus ; import org . elasticsearch . action . admin . cluster . reroute . ClusterRerouteResponse ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . RerouteExplanation ; import org . elasticsearch . cluster . routing . allocation . RoutingExplanations ; import org . elasticsearch . cluster . routing . allocation . command . AllocateAllocationCommand ; import org . elasticsearch . cluster . routing . allocation . command . MoveAllocationCommand ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider . Allocation ; import org . elasticsearch . cluster . routing . allocation . decider . ThrottlingAllocationDecider ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . InternalTestCluster ; import java . nio . file . Path ; import java . util . Arrays ; import java . util . List ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_BLOCKS_METADATA ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_BLOCKS_READ ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_BLOCKS_WRITE ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_READ_ONLY ; import static org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertBlocked ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . hasSize ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> ) public class ClusterRerouteIT extends ESIntegTestCase { private final ESLogger logger = Loggers . getLogger ( ClusterRerouteIT . class ) ; public void testRerouteWithCommands_disableAllocationSettings ( ) throws Exception { Settings commonSettings = settingsBuilder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_REBALANCE_ENABLE , <str> ) . build ( ) ; rerouteWithCommands ( commonSettings ) ; } public void testRerouteWithCommands_enableAllocationSettings ( ) throws Exception { Settings commonSettings = settingsBuilder ( ) . put ( CLUSTER_ROUTING_ALLOCATION_ENABLE , Allocation . NONE . name ( ) ) . build ( ) ; rerouteWithCommands ( commonSettings ) ; } private void rerouteWithCommands ( Settings commonSettings ) throws Exception { List < String > nodesIds = internalCluster ( ) . startNodesAsync ( <int> , commonSettings ) . get ( ) ; final String node_1 = nodesIds . get ( <int> ) ; final String node_2 = nodesIds . get ( <int> ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . setExplain ( randomBoolean ( ) ) . add ( new AllocateAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , true ) ) . setDryRun ( true ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_1 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . INITIALIZING ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . setExplain ( randomBoolean ( ) ) . add ( new AllocateAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , true ) ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_1 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . INITIALIZING ) ) ; ClusterHealthResponse healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForYellowStatus ( ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_1 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . STARTED ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . setExplain ( randomBoolean ( ) ) . add ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , node_2 ) ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_1 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . RELOCATING ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_2 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . INITIALIZING ) ) ; healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForYellowStatus ( ) . setWaitForRelocatingShards ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_2 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . STARTED ) ) ; } public void testRerouteWithAllocateLocalGateway_disableAllocationSettings ( ) throws Exception { Settings commonSettings = settingsBuilder ( ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , <str> ) . put ( EnableAllocationDecider . CLUSTER_ROUTING_REBALANCE_ENABLE , <str> ) . build ( ) ; rerouteWithAllocateLocalGateway ( commonSettings ) ; } public void testRerouteWithAllocateLocalGateway_enableAllocationSettings ( ) throws Exception { Settings commonSettings = settingsBuilder ( ) . put ( CLUSTER_ROUTING_ALLOCATION_ENABLE , Allocation . NONE . name ( ) ) . build ( ) ; rerouteWithAllocateLocalGateway ( commonSettings ) ; } public void testDelayWithALargeAmountOfShards ( ) throws Exception { Settings commonSettings = settingsBuilder ( ) . put ( ThrottlingAllocationDecider . CLUSTER_ROUTING_ALLOCATION_CONCURRENT_RECOVERIES , <int> ) . build ( ) ; logger . info ( <str> ) ; String node_1 = internalCluster ( ) . startNode ( commonSettings ) ; internalCluster ( ) . startNode ( commonSettings ) ; internalCluster ( ) . startNode ( commonSettings ) ; internalCluster ( ) . startNode ( commonSettings ) ; assertThat ( cluster ( ) . size ( ) , equalTo ( <int> ) ) ; ClusterHealthResponse healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> + i ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , randomIntBetween ( <int> , <int> ) + <str> ) ) . execute ( ) . actionGet ( ) ; } ensureGreen ( TimeValue . timeValueMinutes ( <int> ) ) ; logger . info ( <str> ) ; internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( node_1 ) ) ; ensureGreen ( TimeValue . timeValueMinutes ( <int> ) ) ; } private void rerouteWithAllocateLocalGateway ( Settings commonSettings ) throws Exception { logger . info ( <str> ) ; String node_1 = internalCluster ( ) . startNode ( commonSettings ) ; internalCluster ( ) . startNode ( commonSettings ) ; assertThat ( cluster ( ) . size ( ) , equalTo ( <int> ) ) ; ClusterHealthResponse healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . setExplain ( randomBoolean ( ) ) . add ( new AllocateAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , true ) ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_1 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . INITIALIZING ) ) ; healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForYellowStatus ( ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_1 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . STARTED ) ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setRefresh ( true ) . execute ( ) . actionGet ( ) ; logger . info ( <str> ) ; Path [ ] shardLocation = internalCluster ( ) . getInstance ( NodeEnvironment . class , node_1 ) . availableShardPaths ( new ShardId ( <str> , <int> ) ) ; assertThat ( FileSystemUtils . exists ( shardLocation ) , equalTo ( true ) ) ; internalCluster ( ) . closeNonSharedNodes ( false ) ; logger . info ( <str> , Arrays . toString ( shardLocation ) ) ; assertThat ( FileSystemUtils . exists ( shardLocation ) , equalTo ( true ) ) ; IOUtils . rm ( shardLocation ) ; logger . info ( <str> ) ; node_1 = internalCluster ( ) . startNode ( commonSettings ) ; internalCluster ( ) . startNode ( commonSettings ) ; client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . get ( ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) . getStatus ( ) , equalTo ( ClusterHealthStatus . RED ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . setExplain ( randomBoolean ( ) ) . add ( new AllocateAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , true ) ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_1 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . INITIALIZING ) ) ; healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForYellowStatus ( ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; assertThat ( state . getRoutingNodes ( ) . unassigned ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( state . getRoutingNodes ( ) . node ( state . nodes ( ) . resolveNode ( node_1 ) . id ( ) ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . STARTED ) ) ; } public void testRerouteExplain ( ) { Settings commonSettings = settingsBuilder ( ) . build ( ) ; logger . info ( <str> ) ; String node_1 = internalCluster ( ) . startNode ( commonSettings ) ; assertThat ( cluster ( ) . size ( ) , equalTo ( <int> ) ) ; ClusterHealthResponse healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; ensureGreen ( <str> ) ; logger . info ( <str> ) ; Settings newSettings = settingsBuilder ( ) . put ( CLUSTER_ROUTING_ALLOCATION_ENABLE , Allocation . NONE . name ( ) ) . build ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( newSettings ) . execute ( ) . actionGet ( ) ; logger . info ( <str> ) ; String node_2 = internalCluster ( ) . startNode ( commonSettings ) ; assertThat ( cluster ( ) . size ( ) , equalTo ( <int> ) ) ; healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; MoveAllocationCommand cmd = new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , node_1 , node_2 ) ; ClusterRerouteResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( cmd ) . setExplain ( true ) . execute ( ) . actionGet ( ) ; RoutingExplanations e = resp . getExplanations ( ) ; assertThat ( e . explanations ( ) . size ( ) , equalTo ( <int> ) ) ; RerouteExplanation explanation = e . explanations ( ) . get ( <int> ) ; assertThat ( explanation . command ( ) . name ( ) , equalTo ( cmd . name ( ) ) ) ; assertThat ( ( ( MoveAllocationCommand ) explanation . command ( ) ) . shardId ( ) , equalTo ( cmd . shardId ( ) ) ) ; assertThat ( ( ( MoveAllocationCommand ) explanation . command ( ) ) . fromNode ( ) , equalTo ( cmd . fromNode ( ) ) ) ; assertThat ( ( ( MoveAllocationCommand ) explanation . command ( ) ) . toNode ( ) , equalTo ( cmd . toNode ( ) ) ) ; assertThat ( explanation . decisions ( ) . type ( ) , equalTo ( Decision . Type . YES ) ) ; } public void testClusterRerouteWithBlocks ( ) throws Exception { List < String > nodesIds = internalCluster ( ) . startNodesAsync ( <int> ) . get ( ) ; logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) ) ; ensureGreen ( <str> ) ; logger . info ( <str> ) ; ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; List < ShardRouting > shards = state . routingTable ( ) . allShards ( <str> ) ; assertThat ( shards , hasSize ( <int> ) ) ; logger . info ( <str> ) ; ShardRouting shard = shards . get ( <int> ) ; assertThat ( shard . assignedToNode ( ) , equalTo ( true ) ) ; logger . info ( <str> ) ; DiscoveryNode node = state . nodes ( ) . resolveNode ( shard . currentNodeId ( ) ) ; assertNotNull ( node ) ; int toggle = nodesIds . indexOf ( node . getName ( ) ) ; for ( String blockSetting : Arrays . asList ( SETTING_BLOCKS_READ , SETTING_BLOCKS_WRITE , SETTING_READ_ONLY , SETTING_BLOCKS_METADATA ) ) { try { enableIndexBlock ( <str> , blockSetting ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , nodesIds . get ( toggle % <int> ) , nodesIds . get ( + + toggle % <int> ) ) ) ) ; ClusterHealthResponse healthResponse = client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForYellowStatus ( ) . setWaitForRelocatingShards ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( healthResponse . isTimedOut ( ) , equalTo ( false ) ) ; } finally { disableIndexBlock ( <str> , blockSetting ) ; } } try { setClusterReadOnly ( true ) ; assertBlocked ( client ( ) . admin ( ) . cluster ( ) . prepareReroute ( ) . add ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , nodesIds . get ( toggle % <int> ) , nodesIds . get ( + + toggle % <int> ) ) ) ) ; } finally { setClusterReadOnly ( false ) ; } } } 
