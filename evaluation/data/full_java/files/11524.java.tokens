package org . gradle . api . internal . file . collections ; import org . gradle . api . Buildable ; import org . gradle . api . file . FileTree ; import org . gradle . api . file . FileVisitor ; import org . gradle . api . internal . file . AbstractFileTree ; import org . gradle . api . internal . file . FileSystemSubset ; import org . gradle . api . tasks . TaskDependency ; import org . gradle . api . tasks . util . PatternFilterable ; import java . io . File ; import java . util . Collection ; import java . util . Collections ; public class FileTreeAdapter extends AbstractFileTree implements FileCollectionContainer { private final MinimalFileTree tree ; public FileTreeAdapter ( MinimalFileTree tree ) { this . tree = tree ; } public MinimalFileTree getTree ( ) { return tree ; } @Override public String getDisplayName ( ) { return tree . getDisplayName ( ) ; } @Override public void visitContents ( FileCollectionResolveContext context ) { context . add ( tree ) ; } @Override public void registerWatchPoints ( FileSystemSubset . Builder builder ) { tree . registerWatchPoints ( builder ) ; } @Override protected Collection < DirectoryFileTree > getAsFileTrees ( ) { if ( tree instanceof FileSystemMirroringFileTree ) { FileSystemMirroringFileTree mirroringTree = ( FileSystemMirroringFileTree ) tree ; if ( visitAll ( ) ) { return Collections . singletonList ( mirroringTree . getMirror ( ) ) ; } else { return Collections . emptyList ( ) ; } } else if ( tree instanceof LocalFileTree ) { LocalFileTree fileTree = ( LocalFileTree ) tree ; return fileTree . getLocalContents ( ) ; } throw new UnsupportedOperationException ( String . format ( <str> , tree ) ) ; } @Override public TaskDependency getBuildDependencies ( ) { if ( tree instanceof Buildable ) { Buildable buildable = ( Buildable ) tree ; return buildable . getBuildDependencies ( ) ; } return super . getBuildDependencies ( ) ; } @Override public boolean contains ( File file ) { if ( tree instanceof RandomAccessFileCollection ) { RandomAccessFileCollection randomAccess = ( RandomAccessFileCollection ) tree ; return randomAccess . contains ( file ) ; } if ( tree instanceof MapFileTree ) { return ( ( MapFileTree ) tree ) . getFilesWithoutCreating ( ) . contains ( file ) ; } if ( tree instanceof FileSystemMirroringFileTree ) { return ( ( FileSystemMirroringFileTree ) tree ) . getMirror ( ) . contains ( file ) ; } return super . contains ( file ) ; } @Override public FileTree matching ( PatternFilterable patterns ) { if ( tree instanceof PatternFilterableFileTree ) { PatternFilterableFileTree filterableTree = ( PatternFilterableFileTree ) tree ; return new FileTreeAdapter ( filterableTree . filter ( patterns ) ) ; } return super . matching ( patterns ) ; } public FileTree visit ( FileVisitor visitor ) { tree . visit ( visitor ) ; return this ; } public void visitTreeOrBackingFile ( FileVisitor visitor ) { getTree ( ) . visitTreeOrBackingFile ( visitor ) ; } } 
