package org . eclipse . debug . internal . ui . launchConfigurations ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . IStatusHandler ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . jface . dialogs . IDialogConstants ; import org . eclipse . jface . dialogs . MessageDialog ; import org . eclipse . jface . dialogs . MessageDialogWithToggle ; import org . eclipse . jface . preference . IPreferenceStore ; import org . eclipse . swt . widgets . Shell ; import com . ibm . icu . text . MessageFormat ; public class CompileErrorProjectPromptStatusHandler implements IStatusHandler { @Override public Object handleStatus ( IStatus status , Object source ) throws CoreException { ILaunchConfiguration config = null ; List < Object > projects = new ArrayList < Object > ( ) ; if ( source instanceof List ) { List < ? > args = ( List < ? > ) source ; Iterator < ? > iterator = args . iterator ( ) ; while ( iterator . hasNext ( ) ) { Object arg = iterator . next ( ) ; if ( arg instanceof ILaunchConfiguration ) { config = ( ILaunchConfiguration ) arg ; if ( DebugUITools . isPrivate ( config ) ) { return Boolean . TRUE ; } } else if ( arg instanceof IProject ) { projects . add ( arg ) ; } } } Shell shell = DebugUIPlugin . getShell ( ) ; StringBuffer projectList = new StringBuffer ( ) ; int size = Math . min ( <int> , projects . size ( ) ) ; for ( int i = <int> ; i < size ; i + + ) { if ( i > <int> ) { projectList . append ( <str> ) ; } projectList . append ( ( ( IProject ) projects . get ( i ) ) . getName ( ) ) ; } String projectMessage = null ; if ( projects . size ( ) > <int> ) { projectMessage = MessageFormat . format ( LaunchConfigurationsMessages . CompileErrorProjectPromptStatusHandler_0 , new Object [ ] { projectList . toString ( ) } ) ; } else { projectMessage = projectList . toString ( ) ; } String title = LaunchConfigurationsMessages . CompileErrorPromptStatusHandler_0 ; String message = MessageFormat . format ( LaunchConfigurationsMessages . CompileErrorPromptStatusHandler_2 , new Object [ ] { projectMessage } ) ; IPreferenceStore store = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) ; String pref = store . getString ( IInternalDebugUIConstants . PREF_CONTINUE_WITH_COMPILE_ERROR ) ; if ( pref ! = null ) { if ( pref . equals ( MessageDialogWithToggle . ALWAYS ) ) { return Boolean . TRUE ; } } MessageDialogWithToggle dialog = new MessageDialogWithToggle ( shell , title , null , message , MessageDialog . QUESTION , new String [ ] { IDialogConstants . PROCEED_LABEL , IDialogConstants . CANCEL_LABEL } , <int> , LaunchConfigurationsMessages . CompileErrorProjectPromptStatusHandler_1 , false ) ; int open = dialog . open ( ) ; if ( open = = IDialogConstants . PROCEED_ID ) { if ( dialog . getToggleState ( ) ) { store . setValue ( IInternalDebugUIConstants . PREF_CONTINUE_WITH_COMPILE_ERROR , MessageDialogWithToggle . ALWAYS ) ; } return Boolean . TRUE ; } else { return Boolean . FALSE ; } } } 
