package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import java . util . List ; import java . util . zip . CRC32 ; import java . util . zip . DataFormatException ; import java . util . zip . Deflater ; import java . util . zip . Inflater ; public class JdkZlibDecoder extends ZlibDecoder { private static final int FHCRC = <hex> ; private static final int FEXTRA = <hex> ; private static final int FNAME = <hex> ; private static final int FCOMMENT = <hex> ; private static final int FRESERVED = <hex> ; private Inflater inflater ; private final byte [ ] dictionary ; private final CRC32 crc ; private enum GzipState { HEADER_START , HEADER_END , FLG_READ , XLEN_READ , SKIP_FNAME , SKIP_COMMENT , PROCESS_FHCRC , FOOTER_START , } private GzipState gzipState = GzipState . HEADER_START ; private int flags = - <int> ; private int xlen = - <int> ; private volatile boolean finished ; private boolean decideZlibOrNone ; public JdkZlibDecoder ( ) { this ( ZlibWrapper . ZLIB , null ) ; } public JdkZlibDecoder ( byte [ ] dictionary ) { this ( ZlibWrapper . ZLIB , dictionary ) ; } public JdkZlibDecoder ( ZlibWrapper wrapper ) { this ( wrapper , null ) ; } private JdkZlibDecoder ( ZlibWrapper wrapper , byte [ ] dictionary ) { if ( wrapper = = null ) { throw new NullPointerException ( <str> ) ; } switch ( wrapper ) { case GZIP : inflater = new Inflater ( true ) ; crc = new CRC32 ( ) ; break ; case NONE : inflater = new Inflater ( true ) ; crc = null ; break ; case ZLIB : inflater = new Inflater ( ) ; crc = null ; break ; case ZLIB_OR_NONE : decideZlibOrNone = true ; crc = null ; break ; default : throw new IllegalArgumentException ( <str> + wrapper ) ; } this . dictionary = dictionary ; } @Override public boolean isClosed ( ) { return finished ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( finished ) { in . skipBytes ( in . readableBytes ( ) ) ; return ; } int readableBytes = in . readableBytes ( ) ; if ( readableBytes = = <int> ) { return ; } if ( decideZlibOrNone ) { if ( readableBytes < <int> ) { return ; } boolean nowrap = ! looksLikeZlib ( in . getShort ( in . readerIndex ( ) ) ) ; inflater = new Inflater ( nowrap ) ; decideZlibOrNone = false ; } if ( crc ! = null ) { switch ( gzipState ) { case FOOTER_START : if ( readGZIPFooter ( in ) ) { finished = true ; } return ; default : if ( gzipState ! = GzipState . HEADER_END ) { if ( ! readGZIPHeader ( in ) ) { return ; } } } readableBytes = in . readableBytes ( ) ; } if ( in . hasArray ( ) ) { inflater . setInput ( in . array ( ) , in . arrayOffset ( ) + in . readerIndex ( ) , readableBytes ) ; } else { byte [ ] array = new byte [ readableBytes ] ; in . getBytes ( in . readerIndex ( ) , array ) ; inflater . setInput ( array ) ; } int maxOutputLength = inflater . getRemaining ( ) < < <int> ; ByteBuf decompressed = ctx . alloc ( ) . heapBuffer ( maxOutputLength ) ; try { boolean readFooter = false ; byte [ ] outArray = decompressed . array ( ) ; while ( ! inflater . needsInput ( ) ) { int writerIndex = decompressed . writerIndex ( ) ; int outIndex = decompressed . arrayOffset ( ) + writerIndex ; int length = decompressed . writableBytes ( ) ; if ( length = = <int> ) { out . add ( decompressed ) ; decompressed = ctx . alloc ( ) . heapBuffer ( maxOutputLength ) ; outArray = decompressed . array ( ) ; continue ; } int outputLength = inflater . inflate ( outArray , outIndex , length ) ; if ( outputLength > <int> ) { decompressed . writerIndex ( writerIndex + outputLength ) ; if ( crc ! = null ) { crc . update ( outArray , outIndex , outputLength ) ; } } else { if ( inflater . needsDictionary ( ) ) { if ( dictionary = = null ) { throw new DecompressionException ( <str> ) ; } inflater . setDictionary ( dictionary ) ; } } if ( inflater . finished ( ) ) { if ( crc = = null ) { finished = true ; } else { readFooter = true ; } break ; } } in . skipBytes ( readableBytes - inflater . getRemaining ( ) ) ; if ( readFooter ) { gzipState = GzipState . FOOTER_START ; if ( readGZIPFooter ( in ) ) { finished = true ; } } } catch ( DataFormatException e ) { throw new DecompressionException ( <str> , e ) ; } finally { if ( decompressed . isReadable ( ) ) { out . add ( decompressed ) ; } else { decompressed . release ( ) ; } } } @Override protected void handlerRemoved0 ( ChannelHandlerContext ctx ) throws Exception { super . handlerRemoved0 ( ctx ) ; if ( inflater ! = null ) { inflater . end ( ) ; } } private boolean readGZIPHeader ( ByteBuf in ) { switch ( gzipState ) { case HEADER_START : if ( in . readableBytes ( ) < <int> ) { return false ; } int magic0 = in . readByte ( ) ; int magic1 = in . readByte ( ) ; if ( magic0 ! = <int> ) { throw new DecompressionException ( <str> ) ; } crc . update ( magic0 ) ; crc . update ( magic1 ) ; int method = in . readUnsignedByte ( ) ; if ( method ! = Deflater . DEFLATED ) { throw new DecompressionException ( <str> + method + <str> ) ; } crc . update ( method ) ; flags = in . readUnsignedByte ( ) ; crc . update ( flags ) ; if ( ( flags & FRESERVED ) ! = <int> ) { throw new DecompressionException ( <str> ) ; } crc . update ( in . readByte ( ) ) ; crc . update ( in . readByte ( ) ) ; crc . update ( in . readByte ( ) ) ; crc . update ( in . readByte ( ) ) ; crc . update ( in . readUnsignedByte ( ) ) ; crc . update ( in . readUnsignedByte ( ) ) ; gzipState = GzipState . FLG_READ ; case FLG_READ : if ( ( flags & FEXTRA ) ! = <int> ) { if ( in . readableBytes ( ) < <int> ) { return false ; } int xlen1 = in . readUnsignedByte ( ) ; int xlen2 = in . readUnsignedByte ( ) ; crc . update ( xlen1 ) ; crc . update ( xlen2 ) ; xlen | = xlen1 < < <int> | xlen2 ; } gzipState = GzipState . XLEN_READ ; case XLEN_READ : if ( xlen ! = - <int> ) { if ( in . readableBytes ( ) < xlen ) { return false ; } byte [ ] xtra = new byte [ xlen ] ; in . readBytes ( xtra ) ; crc . update ( xtra ) ; } gzipState = GzipState . SKIP_FNAME ; case SKIP_FNAME : if ( ( flags & FNAME ) ! = <int> ) { if ( ! in . isReadable ( ) ) { return false ; } do { int b = in . readUnsignedByte ( ) ; crc . update ( b ) ; if ( b = = <hex> ) { break ; } } while ( in . isReadable ( ) ) ; } gzipState = GzipState . SKIP_COMMENT ; case SKIP_COMMENT : if ( ( flags & FCOMMENT ) ! = <int> ) { if ( ! in . isReadable ( ) ) { return false ; } do { int b = in . readUnsignedByte ( ) ; crc . update ( b ) ; if ( b = = <hex> ) { break ; } } while ( in . isReadable ( ) ) ; } gzipState = GzipState . PROCESS_FHCRC ; case PROCESS_FHCRC : if ( ( flags & FHCRC ) ! = <int> ) { if ( in . readableBytes ( ) < <int> ) { return false ; } verifyCrc ( in ) ; } crc . reset ( ) ; gzipState = GzipState . HEADER_END ; case HEADER_END : return true ; default : throw new IllegalStateException ( ) ; } } private boolean readGZIPFooter ( ByteBuf buf ) { if ( buf . readableBytes ( ) < <int> ) { return false ; } verifyCrc ( buf ) ; int dataLength = <int> ; for ( int i = <int> ; i < <int> ; + + i ) { dataLength | = buf . readUnsignedByte ( ) < < i * <int> ; } int readLength = inflater . getTotalOut ( ) ; if ( dataLength ! = readLength ) { throw new DecompressionException ( <str> + dataLength + <str> + readLength ) ; } return true ; } private void verifyCrc ( ByteBuf in ) { long crcValue = <int> ; for ( int i = <int> ; i < <int> ; + + i ) { crcValue | = ( long ) in . readUnsignedByte ( ) < < i * <int> ; } long readCrc = crc . getValue ( ) ; if ( crcValue ! = readCrc ) { throw new DecompressionException ( <str> + crcValue + <str> + readCrc ) ; } } private static boolean looksLikeZlib ( short cmf_flg ) { return ( cmf_flg & <hex> ) = = <hex> & & cmf_flg % <int> = = <int> ; } } 
