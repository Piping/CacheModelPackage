package org . apache . cassandra . io . util ; import java . io . BufferedWriter ; import java . io . Closeable ; import java . io . DataOutput ; import java . io . File ; import java . io . IOError ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . file . Files ; import java . util . zip . CRC32 ; import java . util . zip . CheckedInputStream ; import java . util . zip . Checksum ; import com . google . common . base . Charsets ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . utils . Throwables ; public class DataIntegrityMetadata { public static ChecksumValidator checksumValidator ( Descriptor desc ) throws IOException { return new ChecksumValidator ( desc ) ; } public static class ChecksumValidator implements Closeable { private final Checksum checksum ; private final RandomAccessReader reader ; public final int chunkSize ; private final String dataFilename ; public ChecksumValidator ( Descriptor descriptor ) throws IOException { this ( descriptor . version . uncompressedChecksumType ( ) . newInstance ( ) , RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . CRC ) ) ) , descriptor . filenameFor ( Component . DATA ) ) ; } public ChecksumValidator ( Checksum checksum , RandomAccessReader reader , String dataFilename ) throws IOException { this . checksum = checksum ; this . reader = reader ; this . dataFilename = dataFilename ; chunkSize = reader . readInt ( ) ; } public void seek ( long offset ) { long start = chunkStart ( offset ) ; reader . seek ( ( ( start / chunkSize ) * <int> ) + <int> ) ; } public long chunkStart ( long offset ) { long startChunk = offset / chunkSize ; return startChunk * chunkSize ; } public void validate ( byte [ ] bytes , int start , int end ) throws IOException { checksum . update ( bytes , start , end ) ; int current = ( int ) checksum . getValue ( ) ; checksum . reset ( ) ; int actual = reader . readInt ( ) ; if ( current ! = actual ) throw new IOException ( <str> + dataFilename ) ; } public void close ( ) { reader . close ( ) ; } } public static FileDigestValidator fileDigestValidator ( Descriptor desc ) throws IOException { return new FileDigestValidator ( desc ) ; } public static class FileDigestValidator implements Closeable { private final Checksum checksum ; private final RandomAccessReader digestReader ; private final RandomAccessReader dataReader ; private final Descriptor descriptor ; private long storedDigestValue ; public FileDigestValidator ( Descriptor descriptor ) throws IOException { this . descriptor = descriptor ; checksum = descriptor . version . uncompressedChecksumType ( ) . newInstance ( ) ; digestReader = RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . digestFor ( descriptor . version . uncompressedChecksumType ( ) ) ) ) ) ; dataReader = RandomAccessReader . open ( new File ( descriptor . filenameFor ( Component . DATA ) ) ) ; try { storedDigestValue = Long . parseLong ( digestReader . readLine ( ) ) ; } catch ( Exception e ) { close ( ) ; throw new IOException ( <str> + descriptor . filenameFor ( Component . DATA ) ) ; } } public void validate ( ) throws IOException { CheckedInputStream checkedInputStream = new CheckedInputStream ( dataReader , checksum ) ; byte [ ] chunk = new byte [ <int> * <int> ] ; while ( checkedInputStream . read ( chunk ) > <int> ) { } long calculatedDigestValue = checkedInputStream . getChecksum ( ) . getValue ( ) ; if ( storedDigestValue ! = calculatedDigestValue ) { throw new IOException ( <str> + descriptor . filenameFor ( Component . DATA ) ) ; } } public void close ( ) { Throwables . perform ( digestReader : : close , dataReader : : close ) ; } } public static class ChecksumWriter { private final CRC32 incrementalChecksum = new CRC32 ( ) ; private final DataOutput incrementalOut ; private final CRC32 fullChecksum = new CRC32 ( ) ; public ChecksumWriter ( DataOutput incrementalOut ) { this . incrementalOut = incrementalOut ; } public void writeChunkSize ( int length ) { try { incrementalOut . writeInt ( length ) ; } catch ( IOException e ) { throw new IOError ( e ) ; } } public void appendDirect ( ByteBuffer bb , boolean checksumIncrementalResult ) { try { ByteBuffer toAppend = bb . duplicate ( ) ; toAppend . mark ( ) ; incrementalChecksum . update ( toAppend ) ; toAppend . reset ( ) ; int incrementalChecksumValue = ( int ) incrementalChecksum . getValue ( ) ; incrementalOut . writeInt ( incrementalChecksumValue ) ; fullChecksum . update ( toAppend ) ; if ( checksumIncrementalResult ) { ByteBuffer byteBuffer = ByteBuffer . allocate ( <int> ) ; byteBuffer . putInt ( incrementalChecksumValue ) ; assert byteBuffer . arrayOffset ( ) = = <int> ; fullChecksum . update ( byteBuffer . array ( ) , <int> , byteBuffer . array ( ) . length ) ; } incrementalChecksum . reset ( ) ; } catch ( IOException e ) { throw new IOError ( e ) ; } } public void writeFullChecksum ( Descriptor descriptor ) { if ( descriptor . digestComponent = = null ) throw new NullPointerException ( <str> + descriptor . ksname + <str> + descriptor . cfname + <str> + descriptor . baseFilename ( ) ) ; File outFile = new File ( descriptor . filenameFor ( descriptor . digestComponent ) ) ; try ( BufferedWriter out = Files . newBufferedWriter ( outFile . toPath ( ) , Charsets . UTF_8 ) ) { out . write ( String . valueOf ( fullChecksum . getValue ( ) ) ) ; } catch ( IOException e ) { throw new FSWriteError ( e , outFile ) ; } } } } 
