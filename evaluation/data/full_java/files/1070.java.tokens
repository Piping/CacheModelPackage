package org . apache . cassandra . tools . nodetool ; import static java . lang . String . format ; import io . airlift . command . Command ; import io . airlift . command . Option ; import java . text . DecimalFormat ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import org . apache . cassandra . db . compaction . CompactionManagerMBean ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . tools . NodeProbe ; import org . apache . cassandra . tools . NodeTool ; import org . apache . cassandra . tools . NodeTool . NodeToolCmd ; @Command ( name = <str> , description = <str> ) public class CompactionStats extends NodeToolCmd { @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean humanReadable = false ; @Override public void execute ( NodeProbe probe ) { CompactionManagerMBean cm = probe . getCompactionManagerProxy ( ) ; System . out . println ( <str> + probe . getCompactionMetric ( <str> ) ) ; long remainingBytes = <int> ; List < Map < String , String > > compactions = cm . getCompactions ( ) ; if ( ! compactions . isEmpty ( ) ) { int compactionThroughput = probe . getCompactionThroughput ( ) ; List < String [ ] > lines = new ArrayList < > ( ) ; int [ ] columnSizes = new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; addLine ( lines , columnSizes , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; for ( Map < String , String > c : compactions ) { long total = Long . parseLong ( c . get ( <str> ) ) ; long completed = Long . parseLong ( c . get ( <str> ) ) ; String taskType = c . get ( <str> ) ; String keyspace = c . get ( <str> ) ; String columnFamily = c . get ( <str> ) ; String completedStr = humanReadable ? FileUtils . stringifyFileSize ( completed ) : Long . toString ( completed ) ; String totalStr = humanReadable ? FileUtils . stringifyFileSize ( total ) : Long . toString ( total ) ; String unit = c . get ( <str> ) ; String percentComplete = total = = <int> ? <str> : new DecimalFormat ( <str> ) . format ( ( double ) completed / total * <int> ) + <str> ; String id = c . get ( <str> ) ; addLine ( lines , columnSizes , id , taskType , keyspace , columnFamily , completedStr , totalStr , unit , percentComplete ) ; if ( taskType . equals ( OperationType . COMPACTION . toString ( ) ) ) remainingBytes + = total - completed ; } StringBuilder buffer = new StringBuilder ( ) ; for ( int columnSize : columnSizes ) { buffer . append ( <str> ) ; buffer . append ( columnSize + <int> ) ; buffer . append ( <str> ) ; } buffer . append ( <str> ) ; String format = buffer . toString ( ) ; for ( String [ ] line : lines ) { System . out . printf ( format , line [ <int> ] , line [ <int> ] , line [ <int> ] , line [ <int> ] , line [ <int> ] , line [ <int> ] , line [ <int> ] , line [ <int> ] ) ; } String remainingTime = <str> ; if ( compactionThroughput ! = <int> ) { long remainingTimeInSecs = remainingBytes / ( <int> * <int> * compactionThroughput ) ; remainingTime = format ( <str> , remainingTimeInSecs / <int> , ( remainingTimeInSecs % <int> ) / <int> , ( remainingTimeInSecs % <int> ) ) ; } System . out . printf ( <str> , <str> , remainingTime ) ; } } private void addLine ( List < String [ ] > lines , int [ ] columnSizes , String . . . columns ) { lines . add ( columns ) ; for ( int i = <int> ; i < columns . length ; i + + ) { columnSizes [ i ] = Math . max ( columnSizes [ i ] , columns [ i ] . length ( ) ) ; } } } 
