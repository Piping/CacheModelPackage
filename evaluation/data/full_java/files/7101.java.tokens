package org . elasticsearch . search ; import org . apache . lucene . index . * ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . util . BitSet ; import org . apache . lucene . util . Bits ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . index . fielddata . FieldData ; import org . elasticsearch . index . fielddata . NumericDoubleValues ; import org . elasticsearch . index . fielddata . SortedBinaryDocValues ; import org . elasticsearch . index . fielddata . SortedNumericDoubleValues ; import java . io . IOException ; import java . util . Locale ; public enum MultiValueMode implements Writeable < MultiValueMode > { SUM { @Override protected long pick ( SortedNumericDocValues values , long missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { long total = <int> ; for ( int index = <int> ; index < count ; + + index ) { total + = values . valueAt ( index ) ; } return total ; } else { return missingValue ; } } @Override protected long pick ( SortedNumericDocValues values , long missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int totalCount = <int> ; long totalValue = <int> ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; for ( int index = <int> ; index < count ; + + index ) { totalValue + = values . valueAt ( index ) ; } totalCount + = count ; } return totalCount > <int> ? totalValue : missingValue ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { double total = <int> ; for ( int index = <int> ; index < count ; + + index ) { total + = values . valueAt ( index ) ; } return total ; } else { return missingValue ; } } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int totalCount = <int> ; double totalValue = <int> ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; for ( int index = <int> ; index < count ; + + index ) { totalValue + = values . valueAt ( index ) ; } totalCount + = count ; } return totalCount > <int> ? totalValue : missingValue ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected double pick ( UnsortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { double total = <int> ; for ( int index = <int> ; index < count ; + + index ) { total + = values . valueAt ( index ) ; } return total ; } else { return missingValue ; } } } , AVG { @Override protected long pick ( SortedNumericDocValues values , long missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { long total = <int> ; for ( int index = <int> ; index < count ; + + index ) { total + = values . valueAt ( index ) ; } return count > <int> ? Math . round ( ( double ) total / ( double ) count ) : total ; } else { return missingValue ; } } @Override protected long pick ( SortedNumericDocValues values , long missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int totalCount = <int> ; long totalValue = <int> ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; for ( int index = <int> ; index < count ; + + index ) { totalValue + = values . valueAt ( index ) ; } totalCount + = count ; } if ( totalCount < <int> ) { return missingValue ; } return totalCount > <int> ? Math . round ( ( double ) totalValue / ( double ) totalCount ) : totalValue ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { double total = <int> ; for ( int index = <int> ; index < count ; + + index ) { total + = values . valueAt ( index ) ; } return total / count ; } else { return missingValue ; } } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int totalCount = <int> ; double totalValue = <int> ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; for ( int index = <int> ; index < count ; + + index ) { totalValue + = values . valueAt ( index ) ; } totalCount + = count ; } if ( totalCount < <int> ) { return missingValue ; } return totalValue / totalCount ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected double pick ( UnsortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { double total = <int> ; for ( int index = <int> ; index < count ; + + index ) { total + = values . valueAt ( index ) ; } return total / count ; } else { return missingValue ; } } } , MEDIAN { @Override protected long pick ( SortedNumericDocValues values , long missingValue , int doc ) { values . setDocument ( doc ) ; int count = values . count ( ) ; if ( count > <int> ) { if ( count % <int> = = <int> ) { count / = <int> ; return Math . round ( ( values . valueAt ( count - <int> ) + values . valueAt ( count ) ) / <float> ) ; } else { count / = <int> ; return values . valueAt ( count ) ; } } else { return missingValue ; } } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; int count = values . count ( ) ; if ( count > <int> ) { if ( count % <int> = = <int> ) { count / = <int> ; return ( values . valueAt ( count - <int> ) + values . valueAt ( count ) ) / <float> ; } else { count / = <int> ; return values . valueAt ( count ) ; } } else { return missingValue ; } } } , MIN { @Override protected long pick ( SortedNumericDocValues values , long missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; return count > <int> ? values . valueAt ( <int> ) : missingValue ; } @Override protected long pick ( SortedNumericDocValues values , long missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int totalCount = <int> ; long minValue = Long . MAX_VALUE ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { minValue = Math . min ( minValue , values . valueAt ( <int> ) ) ; } totalCount + = count ; } return totalCount > <int> ? minValue : missingValue ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; int count = values . count ( ) ; return count > <int> ? values . valueAt ( <int> ) : missingValue ; } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int totalCount = <int> ; double minValue = Double . MAX_VALUE ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { minValue = Math . min ( minValue , values . valueAt ( <int> ) ) ; } totalCount + = count ; } return totalCount > <int> ? minValue : missingValue ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected BytesRef pick ( SortedBinaryDocValues values , BytesRef missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; return count > <int> ? values . valueAt ( <int> ) : missingValue ; } @Override protected BytesRef pick ( BinaryDocValues values , BytesRefBuilder builder , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { BytesRefBuilder value = null ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { final BytesRef innerValue = values . get ( doc ) ; if ( innerValue ! = null ) { if ( value = = null ) { builder . copyBytes ( innerValue ) ; value = builder ; } else { final BytesRef min = value . get ( ) . compareTo ( innerValue ) < = <int> ? value . get ( ) : innerValue ; if ( min = = innerValue ) { value . copyBytes ( min ) ; } } } } return value = = null ? null : value . get ( ) ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected int pick ( RandomAccessOrds values , int doc ) { values . setDocument ( doc ) ; return values . cardinality ( ) > <int> ? ( int ) values . ordAt ( <int> ) : - <int> ; } @Override protected int pick ( SortedDocValues values , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int ord = - <int> ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { final int innerOrd = values . getOrd ( doc ) ; if ( innerOrd ! = - <int> ) { ord = ord = = - <int> ? innerOrd : Math . min ( ord , innerOrd ) ; } } return ord ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected double pick ( UnsortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; int count = values . count ( ) ; double min = Double . MAX_VALUE ; for ( int index = <int> ; index < count ; + + index ) { min = Math . min ( values . valueAt ( index ) , min ) ; } return count > <int> ? min : missingValue ; } } , MAX { @Override protected long pick ( SortedNumericDocValues values , long missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; return count > <int> ? values . valueAt ( count - <int> ) : missingValue ; } @Override protected long pick ( SortedNumericDocValues values , long missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int totalCount = <int> ; long maxValue = Long . MIN_VALUE ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { maxValue = Math . max ( maxValue , values . valueAt ( count - <int> ) ) ; } totalCount + = count ; } return totalCount > <int> ? maxValue : missingValue ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; return count > <int> ? values . valueAt ( count - <int> ) : missingValue ; } @Override protected double pick ( SortedNumericDoubleValues values , double missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int totalCount = <int> ; double maxValue = Double . MIN_VALUE ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; if ( count > <int> ) { maxValue = Math . max ( maxValue , values . valueAt ( count - <int> ) ) ; } totalCount + = count ; } return totalCount > <int> ? maxValue : missingValue ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected BytesRef pick ( SortedBinaryDocValues values , BytesRef missingValue , int doc ) { values . setDocument ( doc ) ; final int count = values . count ( ) ; return count > <int> ? values . valueAt ( count - <int> ) : missingValue ; } @Override protected BytesRef pick ( BinaryDocValues values , BytesRefBuilder builder , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { BytesRefBuilder value = null ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { final BytesRef innerValue = values . get ( doc ) ; if ( innerValue ! = null ) { if ( value = = null ) { builder . copyBytes ( innerValue ) ; value = builder ; } else { final BytesRef max = value . get ( ) . compareTo ( innerValue ) > <int> ? value . get ( ) : innerValue ; if ( max = = innerValue ) { value . copyBytes ( max ) ; } } } } return value = = null ? null : value . get ( ) ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected int pick ( RandomAccessOrds values , int doc ) { values . setDocument ( doc ) ; final int count = values . cardinality ( ) ; return count > <int> ? ( int ) values . ordAt ( count - <int> ) : - <int> ; } @Override protected int pick ( SortedDocValues values , DocIdSetIterator docItr , int startDoc , int endDoc ) { try { int ord = - <int> ; for ( int doc = startDoc ; doc < endDoc ; doc = docItr . nextDoc ( ) ) { final int innerOrd = values . getOrd ( doc ) ; if ( innerOrd ! = - <int> ) { ord = Math . max ( ord , innerOrd ) ; } } return ord ; } catch ( IOException ioException ) { throw new RuntimeException ( ioException ) ; } } @Override protected double pick ( UnsortedNumericDoubleValues values , double missingValue , int doc ) { values . setDocument ( doc ) ; int count = values . count ( ) ; double max = Double . MIN_VALUE ; for ( int index = <int> ; index < count ; + + index ) { max = Math . max ( values . valueAt ( index ) , max ) ; } return count > <int> ? max : missingValue ; } } ; public static MultiValueMode fromString ( String sortMode ) { try { return valueOf ( sortMode . toUpperCase ( Locale . ROOT ) ) ; } catch ( Throwable t ) { throw new IllegalArgumentException ( <str> + sortMode ) ; } } public NumericDocValues select ( final SortedNumericDocValues values , final long missingValue ) { final NumericDocValues singleton = DocValues . unwrapSingleton ( values ) ; if ( singleton ! = null ) { final Bits docsWithField = DocValues . unwrapSingletonBits ( values ) ; if ( docsWithField = = null | | missingValue = = <int> ) { return singleton ; } else { return new NumericDocValues ( ) { @Override public long get ( int docID ) { final long value = singleton . get ( docID ) ; if ( value = = <int> & & docsWithField . get ( docID ) = = false ) { return missingValue ; } return value ; } } ; } } else { return new NumericDocValues ( ) { @Override public long get ( int docID ) { return pick ( values , missingValue , docID ) ; } } ; } } protected long pick ( SortedNumericDocValues values , long missingValue , int doc ) { throw new IllegalArgumentException ( <str> + this ) ; } public NumericDocValues select ( final SortedNumericDocValues values , final long missingValue , final BitSet rootDocs , final DocIdSetIterator innerDocs , int maxDoc ) throws IOException { if ( rootDocs = = null | | innerDocs = = null ) { return select ( DocValues . emptySortedNumeric ( maxDoc ) , missingValue ) ; } return new NumericDocValues ( ) { int lastSeenRootDoc = <int> ; long lastEmittedValue = missingValue ; @Override public long get ( int rootDoc ) { assert rootDocs . get ( rootDoc ) : <str> ; assert rootDoc > = lastSeenRootDoc : <str> ; if ( rootDoc = = lastSeenRootDoc ) { return lastEmittedValue ; } try { final int prevRootDoc = rootDocs . prevSetBit ( rootDoc - <int> ) ; final int firstNestedDoc ; if ( innerDocs . docID ( ) > prevRootDoc ) { firstNestedDoc = innerDocs . docID ( ) ; } else { firstNestedDoc = innerDocs . advance ( prevRootDoc + <int> ) ; } lastSeenRootDoc = rootDoc ; lastEmittedValue = pick ( values , missingValue , innerDocs , firstNestedDoc , rootDoc ) ; return lastEmittedValue ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } ; } protected long pick ( SortedNumericDocValues values , long missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { throw new IllegalArgumentException ( <str> + this ) ; } public NumericDoubleValues select ( final SortedNumericDoubleValues values , final double missingValue ) { final NumericDoubleValues singleton = FieldData . unwrapSingleton ( values ) ; if ( singleton ! = null ) { final Bits docsWithField = FieldData . unwrapSingletonBits ( values ) ; if ( docsWithField = = null | | missingValue = = <int> ) { return singleton ; } else { return new NumericDoubleValues ( ) { @Override public double get ( int docID ) { final double value = singleton . get ( docID ) ; if ( value = = <int> & & docsWithField . get ( docID ) = = false ) { return missingValue ; } return value ; } } ; } } else { return new NumericDoubleValues ( ) { @Override public double get ( int docID ) { return pick ( values , missingValue , docID ) ; } } ; } } protected double pick ( SortedNumericDoubleValues values , double missingValue , int doc ) { throw new IllegalArgumentException ( <str> + this ) ; } public NumericDoubleValues select ( final SortedNumericDoubleValues values , final double missingValue , final BitSet rootDocs , final DocIdSetIterator innerDocs , int maxDoc ) throws IOException { if ( rootDocs = = null | | innerDocs = = null ) { return select ( FieldData . emptySortedNumericDoubles ( maxDoc ) , missingValue ) ; } return new NumericDoubleValues ( ) { int lastSeenRootDoc = <int> ; double lastEmittedValue = missingValue ; @Override public double get ( int rootDoc ) { assert rootDocs . get ( rootDoc ) : <str> ; assert rootDoc > = lastSeenRootDoc : <str> ; if ( rootDoc = = lastSeenRootDoc ) { return lastEmittedValue ; } try { final int prevRootDoc = rootDocs . prevSetBit ( rootDoc - <int> ) ; final int firstNestedDoc ; if ( innerDocs . docID ( ) > prevRootDoc ) { firstNestedDoc = innerDocs . docID ( ) ; } else { firstNestedDoc = innerDocs . advance ( prevRootDoc + <int> ) ; } lastSeenRootDoc = rootDoc ; lastEmittedValue = pick ( values , missingValue , innerDocs , firstNestedDoc , rootDoc ) ; return lastEmittedValue ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } ; } protected double pick ( SortedNumericDoubleValues values , double missingValue , DocIdSetIterator docItr , int startDoc , int endDoc ) { throw new IllegalArgumentException ( <str> + this ) ; } public BinaryDocValues select ( final SortedBinaryDocValues values , final BytesRef missingValue ) { final BinaryDocValues singleton = FieldData . unwrapSingleton ( values ) ; if ( singleton ! = null ) { final Bits docsWithField = FieldData . unwrapSingletonBits ( values ) ; if ( docsWithField = = null ) { return singleton ; } else { return new BinaryDocValues ( ) { @Override public BytesRef get ( int docID ) { final BytesRef value = singleton . get ( docID ) ; if ( value . length = = <int> & & docsWithField . get ( docID ) = = false ) { return missingValue ; } return value ; } } ; } } else { return new BinaryDocValues ( ) { @Override public BytesRef get ( int docID ) { return pick ( values , missingValue , docID ) ; } } ; } } protected BytesRef pick ( SortedBinaryDocValues values , BytesRef missingValue , int doc ) { throw new IllegalArgumentException ( <str> + this ) ; } public BinaryDocValues select ( final SortedBinaryDocValues values , final BytesRef missingValue , final BitSet rootDocs , final DocIdSetIterator innerDocs , int maxDoc ) throws IOException { if ( rootDocs = = null | | innerDocs = = null ) { return select ( FieldData . emptySortedBinary ( maxDoc ) , missingValue ) ; } final BinaryDocValues selectedValues = select ( values , null ) ; return new BinaryDocValues ( ) { final BytesRefBuilder builder = new BytesRefBuilder ( ) ; int lastSeenRootDoc = <int> ; BytesRef lastEmittedValue = missingValue ; @Override public BytesRef get ( int rootDoc ) { assert rootDocs . get ( rootDoc ) : <str> ; assert rootDoc > = lastSeenRootDoc : <str> ; if ( rootDoc = = lastSeenRootDoc ) { return lastEmittedValue ; } try { final int prevRootDoc = rootDocs . prevSetBit ( rootDoc - <int> ) ; final int firstNestedDoc ; if ( innerDocs . docID ( ) > prevRootDoc ) { firstNestedDoc = innerDocs . docID ( ) ; } else { firstNestedDoc = innerDocs . advance ( prevRootDoc + <int> ) ; } lastSeenRootDoc = rootDoc ; lastEmittedValue = pick ( selectedValues , builder , innerDocs , firstNestedDoc , rootDoc ) ; if ( lastEmittedValue = = null ) { lastEmittedValue = missingValue ; } return lastEmittedValue ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } ; } protected BytesRef pick ( BinaryDocValues values , BytesRefBuilder builder , DocIdSetIterator docItr , int startDoc , int endDoc ) { throw new IllegalArgumentException ( <str> + this ) ; } public SortedDocValues select ( final RandomAccessOrds values ) { if ( values . getValueCount ( ) > = Integer . MAX_VALUE ) { throw new UnsupportedOperationException ( <str> + ( Integer . MAX_VALUE - <int> ) + <str> ) ; } final SortedDocValues singleton = DocValues . unwrapSingleton ( values ) ; if ( singleton ! = null ) { return singleton ; } else { return new SortedDocValues ( ) { @Override public int getOrd ( int docID ) { return pick ( values , docID ) ; } @Override public BytesRef lookupOrd ( int ord ) { return values . lookupOrd ( ord ) ; } @Override public int getValueCount ( ) { return ( int ) values . getValueCount ( ) ; } } ; } } protected int pick ( RandomAccessOrds values , int doc ) { throw new IllegalArgumentException ( <str> + this ) ; } public SortedDocValues select ( final RandomAccessOrds values , final BitSet rootDocs , final DocIdSetIterator innerDocs ) throws IOException { if ( rootDocs = = null | | innerDocs = = null ) { return select ( DocValues . emptySortedSet ( ) ) ; } final SortedDocValues selectedValues = select ( values ) ; return new SortedDocValues ( ) { int lastSeenRootDoc = <int> ; int lastEmittedOrd = - <int> ; @Override public BytesRef lookupOrd ( int ord ) { return selectedValues . lookupOrd ( ord ) ; } @Override public int getValueCount ( ) { return selectedValues . getValueCount ( ) ; } @Override public int getOrd ( int rootDoc ) { assert rootDocs . get ( rootDoc ) : <str> ; assert rootDoc > = lastSeenRootDoc : <str> ; if ( rootDoc = = lastSeenRootDoc ) { return lastEmittedOrd ; } try { final int prevRootDoc = rootDocs . prevSetBit ( rootDoc - <int> ) ; final int firstNestedDoc ; if ( innerDocs . docID ( ) > prevRootDoc ) { firstNestedDoc = innerDocs . docID ( ) ; } else { firstNestedDoc = innerDocs . advance ( prevRootDoc + <int> ) ; } lastSeenRootDoc = rootDoc ; return lastEmittedOrd = pick ( selectedValues , innerDocs , firstNestedDoc , rootDoc ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } ; } protected int pick ( SortedDocValues values , DocIdSetIterator docItr , int startDoc , int endDoc ) { throw new IllegalArgumentException ( <str> + this ) ; } public NumericDoubleValues select ( final UnsortedNumericDoubleValues values , final double missingValue ) { return new NumericDoubleValues ( ) { @Override public double get ( int docID ) { return pick ( values , missingValue , docID ) ; } } ; } protected double pick ( UnsortedNumericDoubleValues values , final double missingValue , int doc ) { throw new IllegalArgumentException ( <str> + this ) ; } public interface UnsortedNumericDoubleValues { int count ( ) ; void setDocument ( int docId ) ; double valueAt ( int index ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( this . ordinal ( ) ) ; } public static MultiValueMode readMultiValueModeFrom ( StreamInput in ) throws IOException { return MultiValueMode . AVG . readFrom ( in ) ; } @Override public MultiValueMode readFrom ( StreamInput in ) throws IOException { int ordinal = in . readVInt ( ) ; if ( ordinal < <int> | | ordinal > = values ( ) . length ) { throw new IOException ( <str> + ordinal + <str> ) ; } return values ( ) [ ordinal ] ; } } 
