package org . elasticsearch . index . query ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . * ; import org . apache . lucene . util . automaton . TooComplexToDeterminizeException ; import org . elasticsearch . common . lucene . all . AllTermQuery ; import org . hamcrest . Matchers ; import org . joda . time . DateTimeZone ; import java . io . IOException ; import java . util . List ; import static org . elasticsearch . index . query . QueryBuilders . queryStringQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertBooleanSubQuery ; import static org . hamcrest . CoreMatchers . either ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . instanceOf ; public class QueryStringQueryBuilderTests extends AbstractQueryTestCase < QueryStringQueryBuilder > { @Override protected QueryStringQueryBuilder doCreateTestQueryBuilder ( ) { int numTerms = randomIntBetween ( <int> , <int> ) ; String query = <str> ; for ( int i = <int> ; i < numTerms ; i + + ) { query + = ( randomBoolean ( ) ? STRING_FIELD_NAME + <str> : <str> ) + randomAsciiOfLengthBetween ( <int> , <int> ) + <str> ; } QueryStringQueryBuilder queryStringQueryBuilder = new QueryStringQueryBuilder ( query ) ; if ( randomBoolean ( ) ) { queryStringQueryBuilder . defaultField ( randomBoolean ( ) ? STRING_FIELD_NAME : randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { int numFields = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numFields ; i + + ) { String fieldName = randomBoolean ( ) ? STRING_FIELD_NAME : randomAsciiOfLengthBetween ( <int> , <int> ) ; if ( randomBoolean ( ) ) { queryStringQueryBuilder . field ( fieldName ) ; } else { queryStringQueryBuilder . field ( fieldName , randomFloat ( ) ) ; } } } if ( randomBoolean ( ) ) { queryStringQueryBuilder . defaultOperator ( randomFrom ( Operator . values ( ) ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . fuzziness ( randomFuzziness ( STRING_FIELD_NAME ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . analyzer ( randomAnalyzer ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . quoteAnalyzer ( randomAnalyzer ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . allowLeadingWildcard ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . analyzeWildcard ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . maxDeterminizedStates ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . lowercaseExpandedTerms ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . autoGeneratePhraseQueries ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . enablePositionIncrements ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . lenient ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . escape ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . phraseSlop ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . fuzzyMaxExpansions ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . fuzzyPrefixLength ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . fuzzyRewrite ( getRandomRewriteMethod ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . rewrite ( getRandomRewriteMethod ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . quoteFieldSuffix ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . tieBreaker ( randomFloat ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . minimumShouldMatch ( randomMinimumShouldMatch ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . useDisMax ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . locale ( randomLocale ( getRandom ( ) ) ) ; } if ( randomBoolean ( ) ) { queryStringQueryBuilder . timeZone ( randomTimeZone ( ) ) ; } return queryStringQueryBuilder ; } @Override protected void doAssertLuceneQuery ( QueryStringQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( <str> . equals ( queryBuilder . queryString ( ) ) ) { assertThat ( query , instanceOf ( MatchNoDocsQuery . class ) ) ; } else { assertThat ( query , either ( instanceOf ( TermQuery . class ) ) . or ( instanceOf ( AllTermQuery . class ) ) . or ( instanceOf ( BooleanQuery . class ) ) . or ( instanceOf ( DisjunctionMaxQuery . class ) ) ) ; } } public void testIllegalArguments ( ) { try { new QueryStringQueryBuilder ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testToQueryMatchAllQuery ( ) throws Exception { Query query = queryStringQuery ( <str> ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( MatchAllDocsQuery . class ) ) ; } public void testToQueryTermQuery ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . defaultField ( STRING_FIELD_NAME ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( TermQuery . class ) ) ; TermQuery termQuery = ( TermQuery ) query ; assertThat ( termQuery . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; } public void testToQueryPhraseQuery ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . defaultField ( STRING_FIELD_NAME ) . phraseSlop ( <int> ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( DisjunctionMaxQuery . class ) ) ; DisjunctionMaxQuery disjunctionMaxQuery = ( DisjunctionMaxQuery ) query ; assertThat ( disjunctionMaxQuery . getDisjuncts ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( disjunctionMaxQuery . getDisjuncts ( ) . get ( <int> ) , instanceOf ( PhraseQuery . class ) ) ; PhraseQuery phraseQuery = ( PhraseQuery ) disjunctionMaxQuery . getDisjuncts ( ) . get ( <int> ) ; assertThat ( phraseQuery . getTerms ( ) . length , equalTo ( <int> ) ) ; assertThat ( phraseQuery . getTerms ( ) [ <int> ] , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( phraseQuery . getTerms ( ) [ <int> ] , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( phraseQuery . getSlop ( ) , equalTo ( <int> ) ) ; } public void testToQueryBoosts ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; QueryShardContext shardContext = createShardContext ( ) ; QueryStringQueryBuilder queryStringQuery = queryStringQuery ( STRING_FIELD_NAME + <str> ) ; Query query = queryStringQuery . toQuery ( shardContext ) ; assertThat ( query , instanceOf ( BoostQuery . class ) ) ; BoostQuery boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; assertThat ( boostQuery . getQuery ( ) , instanceOf ( TermQuery . class ) ) ; assertThat ( ( ( TermQuery ) boostQuery . getQuery ( ) ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; queryStringQuery . boost ( <float> ) ; query = queryStringQuery . toQuery ( shardContext ) ; assertThat ( query , instanceOf ( BoostQuery . class ) ) ; boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; assertThat ( boostQuery . getQuery ( ) , instanceOf ( BoostQuery . class ) ) ; boostQuery = ( BoostQuery ) boostQuery . getQuery ( ) ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; queryStringQuery = queryStringQuery ( <str> + STRING_FIELD_NAME + <str> + STRING_FIELD_NAME + <str> ) ; query = queryStringQuery . toQuery ( shardContext ) ; assertThat ( query , instanceOf ( BoostQuery . class ) ) ; boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; BoostQuery boostQuery1 = assertBooleanSubQuery ( boostQuery . getQuery ( ) , BoostQuery . class , <int> ) ; assertThat ( boostQuery1 . getBoost ( ) , equalTo ( <float> ) ) ; assertThat ( boostQuery1 . getQuery ( ) , instanceOf ( TermQuery . class ) ) ; assertThat ( ( ( TermQuery ) boostQuery1 . getQuery ( ) ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; BoostQuery boostQuery2 = assertBooleanSubQuery ( boostQuery . getQuery ( ) , BoostQuery . class , <int> ) ; assertThat ( boostQuery2 . getBoost ( ) , equalTo ( <float> ) ) ; assertThat ( boostQuery2 . getQuery ( ) , instanceOf ( TermQuery . class ) ) ; assertThat ( ( ( TermQuery ) boostQuery2 . getQuery ( ) ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; queryStringQuery . boost ( <float> ) ; query = queryStringQuery . toQuery ( shardContext ) ; assertThat ( query , instanceOf ( BoostQuery . class ) ) ; boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; } public void testToQueryMultipleTermsBooleanQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . field ( STRING_FIELD_NAME ) . useDisMax ( false ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery bQuery = ( BooleanQuery ) query ; assertThat ( bQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; } public void testToQueryMultipleFieldsBooleanQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . field ( STRING_FIELD_NAME ) . field ( STRING_FIELD_NAME_2 ) . useDisMax ( false ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery bQuery = ( BooleanQuery ) query ; assertThat ( bQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME_2 , <str> ) ) ) ; } public void testToQueryMultipleFieldsDisMaxQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . field ( STRING_FIELD_NAME ) . field ( STRING_FIELD_NAME_2 ) . useDisMax ( true ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( DisjunctionMaxQuery . class ) ) ; DisjunctionMaxQuery disMaxQuery = ( DisjunctionMaxQuery ) query ; List < Query > disjuncts = disMaxQuery . getDisjuncts ( ) ; assertThat ( ( ( TermQuery ) disjuncts . get ( <int> ) ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( ( ( TermQuery ) disjuncts . get ( <int> ) ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME_2 , <str> ) ) ) ; } public void testToQueryFieldsWildcard ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . field ( <str> ) . useDisMax ( false ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery bQuery = ( BooleanQuery ) query ; assertThat ( bQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME_2 , <str> ) ) ) ; } public void testToQueryDisMaxQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . field ( STRING_FIELD_NAME , <float> ) . field ( STRING_FIELD_NAME_2 ) . useDisMax ( true ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( DisjunctionMaxQuery . class ) ) ; DisjunctionMaxQuery disMaxQuery = ( DisjunctionMaxQuery ) query ; List < Query > disjuncts = disMaxQuery . getDisjuncts ( ) ; assertTermOrBoostQuery ( disjuncts . get ( <int> ) , STRING_FIELD_NAME , <str> , <float> ) ; assertTermOrBoostQuery ( disjuncts . get ( <int> ) , STRING_FIELD_NAME_2 , <str> , <float> ) ; } public void testToQueryRegExpQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . defaultField ( STRING_FIELD_NAME ) . maxDeterminizedStates ( <int> ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( RegexpQuery . class ) ) ; RegexpQuery regexpQuery = ( RegexpQuery ) query ; assertTrue ( regexpQuery . toString ( ) . contains ( <str> ) ) ; } public void testToQueryRegExpQueryTooComplex ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; try { queryStringQuery ( <str> ) . defaultField ( STRING_FIELD_NAME ) . toQuery ( createShardContext ( ) ) ; fail ( <str> ) ; } catch ( TooComplexToDeterminizeException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testToQueryNumericRangeQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = queryStringQuery ( <str> ) . defaultField ( INT_FIELD_NAME ) . toQuery ( createShardContext ( ) ) ; NumericRangeQuery fuzzyQuery = ( NumericRangeQuery ) query ; assertThat ( fuzzyQuery . getMin ( ) . longValue ( ) , equalTo ( <int> ) ) ; assertThat ( fuzzyQuery . getMax ( ) . longValue ( ) , equalTo ( <int> ) ) ; } public void testTimezone ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; String queryAsString = <str> + <str> + <str> + <str> + DATE_FIELD_NAME + <str> + <str> + <str> ; QueryBuilder < ? > queryBuilder = parseQuery ( queryAsString ) ; assertThat ( queryBuilder , instanceOf ( QueryStringQueryBuilder . class ) ) ; QueryStringQueryBuilder queryStringQueryBuilder = ( QueryStringQueryBuilder ) queryBuilder ; assertThat ( queryStringQueryBuilder . timeZone ( ) , equalTo ( DateTimeZone . forID ( <str> ) ) ) ; try { queryAsString = <str> + <str> + <str> + <str> + DATE_FIELD_NAME + <str> + <str> + <str> ; parseQuery ( queryAsString ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testToQueryBooleanQueryMultipleBoosts ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; int numBoosts = randomIntBetween ( <int> , <int> ) ; float [ ] boosts = new float [ numBoosts + <int> ] ; String queryStringPrefix = <str> ; String queryStringSuffix = <str> ; for ( int i = <int> ; i < boosts . length - <int> ; i + + ) { float boost = <float> / randomIntBetween ( <int> , <int> ) ; boosts [ i ] = boost ; queryStringPrefix + = <str> ; queryStringSuffix + = <str> + boost ; } String queryString = queryStringPrefix + <str> + queryStringSuffix ; float mainBoost = <float> / randomIntBetween ( <int> , <int> ) ; boosts [ boosts . length - <int> ] = mainBoost ; QueryStringQueryBuilder queryStringQueryBuilder = new QueryStringQueryBuilder ( queryString ) . field ( STRING_FIELD_NAME ) . minimumShouldMatch ( <str> ) . boost ( mainBoost ) ; Query query = queryStringQueryBuilder . toQuery ( createShardContext ( ) ) ; for ( int i = boosts . length - <int> ; i > = <int> ; i - - ) { assertThat ( query , instanceOf ( BoostQuery . class ) ) ; BoostQuery boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( boosts [ i ] ) ) ; query = boostQuery . getQuery ( ) ; } assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery booleanQuery = ( BooleanQuery ) query ; assertThat ( booleanQuery . getMinimumNumberShouldMatch ( ) , equalTo ( <int> ) ) ; assertThat ( booleanQuery . clauses ( ) . get ( <int> ) . getOccur ( ) , equalTo ( BooleanClause . Occur . SHOULD ) ) ; assertThat ( booleanQuery . clauses ( ) . get ( <int> ) . getQuery ( ) , equalTo ( new TermQuery ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ) ; assertThat ( booleanQuery . clauses ( ) . get ( <int> ) . getOccur ( ) , equalTo ( BooleanClause . Occur . SHOULD ) ) ; assertThat ( booleanQuery . clauses ( ) . get ( <int> ) . getQuery ( ) , equalTo ( new TermQuery ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ) ; } public void testToQueryPhraseQueryBoostAndSlop ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; QueryStringQueryBuilder queryStringQueryBuilder = new QueryStringQueryBuilder ( <str> ) . field ( STRING_FIELD_NAME , <float> ) ; Query query = queryStringQueryBuilder . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( DisjunctionMaxQuery . class ) ) ; DisjunctionMaxQuery disjunctionMaxQuery = ( DisjunctionMaxQuery ) query ; assertThat ( disjunctionMaxQuery . getDisjuncts ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( disjunctionMaxQuery . getDisjuncts ( ) . get ( <int> ) , instanceOf ( BoostQuery . class ) ) ; BoostQuery boostQuery = ( BoostQuery ) disjunctionMaxQuery . getDisjuncts ( ) . get ( <int> ) ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; assertThat ( boostQuery . getQuery ( ) , instanceOf ( PhraseQuery . class ) ) ; PhraseQuery phraseQuery = ( PhraseQuery ) boostQuery . getQuery ( ) ; assertThat ( phraseQuery . getSlop ( ) , Matchers . equalTo ( <int> ) ) ; assertThat ( phraseQuery . getTerms ( ) . length , equalTo ( <int> ) ) ; } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; QueryStringQueryBuilder parsed = ( QueryStringQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <str> , parsed . queryString ( ) ) ; assertEquals ( json , <str> , parsed . defaultField ( ) ) ; } } 
