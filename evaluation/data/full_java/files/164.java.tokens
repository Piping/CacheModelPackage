package org . apache . cassandra . cql3 ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . stream . Collectors ; import com . google . common . base . Joiner ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . Term . Raw ; import org . apache . cassandra . cql3 . restrictions . Restriction ; import org . apache . cassandra . cql3 . restrictions . TokenRestriction ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . exceptions . InvalidRequestException ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkContainsNoDuplicates ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkContainsOnly ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; import static org . apache . cassandra . cql3 . statements . RequestValidations . invalidRequest ; public final class TokenRelation extends Relation { private final List < ColumnIdentifier . Raw > entities ; private final Term . Raw value ; public TokenRelation ( List < ColumnIdentifier . Raw > entities , Operator type , Term . Raw value ) { this . entities = entities ; this . relationType = type ; this . value = value ; } @Override public boolean onToken ( ) { return true ; } public Term . Raw getValue ( ) { return value ; } public List < ? extends Term . Raw > getInValues ( ) { return null ; } @Override protected Restriction newEQRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { List < ColumnDefinition > columnDefs = getColumnDefinitions ( cfm ) ; Term term = toTerm ( toReceivers ( cfm , columnDefs ) , value , cfm . ksName , boundNames ) ; return new TokenRestriction . EQRestriction ( cfm , columnDefs , term ) ; } @Override protected Restriction newINRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { throw invalidRequest ( <str> , operator ( ) ) ; } @Override protected Restriction newSliceRestriction ( CFMetaData cfm , VariableSpecifications boundNames , Bound bound , boolean inclusive ) throws InvalidRequestException { List < ColumnDefinition > columnDefs = getColumnDefinitions ( cfm ) ; Term term = toTerm ( toReceivers ( cfm , columnDefs ) , value , cfm . ksName , boundNames ) ; return new TokenRestriction . SliceRestriction ( cfm , columnDefs , bound , inclusive , term ) ; } @Override protected Restriction newContainsRestriction ( CFMetaData cfm , VariableSpecifications boundNames , boolean isKey ) throws InvalidRequestException { throw invalidRequest ( <str> , operator ( ) ) ; } @Override protected Restriction newIsNotRestriction ( CFMetaData cfm , VariableSpecifications boundNames ) throws InvalidRequestException { throw invalidRequest ( <str> , operator ( ) ) ; } @Override protected Term toTerm ( List < ? extends ColumnSpecification > receivers , Raw raw , String keyspace , VariableSpecifications boundNames ) throws InvalidRequestException { Term term = raw . prepare ( keyspace , receivers . get ( <int> ) ) ; term . collectMarkerSpecification ( boundNames ) ; return term ; } public Relation renameIdentifier ( ColumnIdentifier . Raw from , ColumnIdentifier . Raw to ) { if ( ! entities . contains ( from ) ) return this ; List < ColumnIdentifier . Raw > newEntities = entities . stream ( ) . map ( e - > e . equals ( from ) ? to : e ) . collect ( Collectors . toList ( ) ) ; return new TokenRelation ( newEntities , operator ( ) , value ) ; } @Override public String toString ( ) { return String . format ( <str> , Tuples . tupleToString ( entities ) , relationType , value ) ; } private List < ColumnDefinition > getColumnDefinitions ( CFMetaData cfm ) throws InvalidRequestException { List < ColumnDefinition > columnDefs = new ArrayList < > ( ) ; for ( ColumnIdentifier . Raw raw : entities ) { columnDefs . add ( toColumnDefinition ( cfm , raw ) ) ; } return columnDefs ; } private static List < ? extends ColumnSpecification > toReceivers ( CFMetaData cfm , List < ColumnDefinition > columnDefs ) throws InvalidRequestException { if ( ! columnDefs . equals ( cfm . partitionKeyColumns ( ) ) ) { checkTrue ( columnDefs . containsAll ( cfm . partitionKeyColumns ( ) ) , <str> ) ; checkContainsNoDuplicates ( columnDefs , <str> ) ; checkContainsOnly ( columnDefs , cfm . partitionKeyColumns ( ) , <str> ) ; throw invalidRequest ( <str> , Joiner . on ( <str> ) . join ( ColumnDefinition . toIdentifiers ( cfm . partitionKeyColumns ( ) ) ) ) ; } ColumnDefinition firstColumn = columnDefs . get ( <int> ) ; return Collections . singletonList ( new ColumnSpecification ( firstColumn . ksName , firstColumn . cfName , new ColumnIdentifier ( <str> , true ) , cfm . partitioner . getTokenValidator ( ) ) ) ; } } 
