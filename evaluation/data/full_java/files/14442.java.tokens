package org . gradle . model . internal . registry ; import com . google . common . collect . ArrayListMultimap ; import com . google . common . collect . LinkedHashMultimap ; import com . google . common . collect . Multimap ; import org . gradle . model . internal . core . ModelNode ; import org . gradle . model . internal . core . ModelPath ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; class RuleBindings { private final ModelGraph modelGraph ; private final NodeIndex rulesBySubject ; private final NodeIndex rulesByInput ; private final Multimap < ModelPath , Reference > pathReferences = ArrayListMultimap . create ( ) ; private final Multimap < ModelPath , Reference > scopeReferences = ArrayListMultimap . create ( ) ; public RuleBindings ( ModelGraph graph ) { this . modelGraph = graph ; rulesBySubject = new NodeIndex ( <str> ) ; rulesByInput = new NodeIndex ( <str> ) ; } public void nodeCreated ( ModelNodeInternal node ) { for ( Reference reference : pathReferences . get ( node . getPath ( ) ) ) { if ( reference . binding . canBindInState ( node . getState ( ) ) ) { bound ( reference , node ) ; } } } public void nodeDiscovered ( ModelNodeInternal node ) { for ( Reference reference : pathReferences . get ( node . getPath ( ) ) ) { if ( ! reference . binding . isBound ( ) ) { bound ( reference , node ) ; } } addTypeMatches ( node , scopeReferences . get ( node . getPath ( ) ) ) ; addTypeMatches ( node , scopeReferences . get ( node . getPath ( ) . getParent ( ) ) ) ; } private void addTypeMatches ( ModelNodeInternal node , Collection < Reference > references ) { for ( Reference reference : references ) { if ( reference . binding . getPredicate ( ) . matches ( node ) ) { bound ( reference , node ) ; } } } private void bound ( Reference reference , ModelNodeInternal node ) { ModelBinding binding = reference . binding ; binding . onBind ( node ) ; reference . index . put ( new NodeAtState ( node . getPath ( ) , binding . predicate . getState ( ) ) , reference . owner ) ; } public void remove ( ModelNodeInternal node ) { rulesBySubject . nodeRemoved ( node ) ; rulesByInput . nodeRemoved ( node ) ; } public void remove ( ModelNodeInternal node , RuleBinder ruleBinder ) { rulesBySubject . remove ( node , ruleBinder ) ; rulesByInput . remove ( node , ruleBinder ) ; removeReferences ( node , ruleBinder , pathReferences ) ; removeReferences ( node , ruleBinder , scopeReferences ) ; } private void removeReferences ( ModelNodeInternal node , RuleBinder ruleBinder , Multimap < ModelPath , Reference > references ) { Iterator < Reference > iterator = references . get ( node . getPath ( ) ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Reference reference = iterator . next ( ) ; if ( reference . owner . equals ( ruleBinder ) ) { iterator . remove ( ) ; } } } public void add ( RuleBinder ruleBinder ) { addRule ( ruleBinder , rulesBySubject , ruleBinder . getSubjectBinding ( ) ) ; for ( ModelBinding binding : ruleBinder . getInputBindings ( ) ) { addRule ( ruleBinder , rulesByInput , binding ) ; } } private void addRule ( RuleBinder rule , NodeIndex index , ModelBinding binding ) { Reference reference = new Reference ( rule , index , binding ) ; BindingPredicate predicate = binding . getPredicate ( ) ; if ( predicate . getPath ( ) ! = null ) { if ( predicate . getScope ( ) ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } ModelNodeInternal node = modelGraph . find ( predicate . getPath ( ) ) ; if ( node ! = null & & reference . binding . canBindInState ( node . getState ( ) ) ) { bound ( reference , node ) ; } pathReferences . put ( predicate . getPath ( ) , reference ) ; } else if ( predicate . getScope ( ) ! = null ) { for ( ModelNodeInternal node : modelGraph . findAllInScope ( predicate . getScope ( ) ) ) { if ( ! node . isAtLeast ( ModelNode . State . Discovered ) ) { continue ; } if ( binding . getPredicate ( ) . matches ( node ) ) { bound ( reference , node ) ; } } scopeReferences . put ( predicate . getScope ( ) , reference ) ; } else { throw new UnsupportedOperationException ( <str> ) ; } } private static void unbind ( RuleBinder rule , ModelNodeInternal node ) { rule . getSubjectBinding ( ) . onUnbind ( node ) ; for ( ModelBinding binding : rule . getInputBindings ( ) ) { binding . onUnbind ( node ) ; } } public Collection < RuleBinder > getRulesWithSubject ( NodeAtState target ) { return rulesBySubject . get ( target ) ; } public Collection < RuleBinder > getRulesWithInput ( NodeAtState input ) { return rulesByInput . get ( input ) ; } private static class Reference { final ModelBinding binding ; final NodeIndex index ; final RuleBinder owner ; public Reference ( RuleBinder owner , NodeIndex index , ModelBinding binding ) { this . owner = owner ; this . index = index ; this . binding = binding ; } @Override public String toString ( ) { return binding + <str> + index . name ; } } private static class NodeIndex { private final Multimap < NodeAtState , RuleBinder > boundAtState = LinkedHashMultimap . create ( ) ; private final String name ; private NodeIndex ( String name ) { this . name = name ; } public void nodeRemoved ( ModelNodeInternal node ) { for ( ModelNode . State state : ModelNode . State . values ( ) ) { for ( RuleBinder rule : boundAtState . removeAll ( new NodeAtState ( node . getPath ( ) , state ) ) ) { unbind ( rule , node ) ; } } } public void put ( NodeAtState nodeAtState , RuleBinder binder ) { boundAtState . put ( nodeAtState , binder ) ; } public Collection < RuleBinder > get ( NodeAtState nodeAtState ) { Collection < RuleBinder > result = boundAtState . get ( nodeAtState ) ; return result = = null ? Collections . < RuleBinder > emptyList ( ) : result ; } public void remove ( ModelNodeInternal node , RuleBinder ruleBinder ) { unbind ( ruleBinder , node ) ; boundAtState . values ( ) . remove ( ruleBinder ) ; } @Override public String toString ( ) { return name ; } } } 
