package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . DelegatingAnalyzerWrapper ; import org . elasticsearch . common . collect . CopyOnWriteHashMap ; import java . util . AbstractMap ; import java . util . Collection ; import java . util . Map ; import java . util . stream . Stream ; public final class FieldNameAnalyzer extends DelegatingAnalyzerWrapper { private final CopyOnWriteHashMap < String , Analyzer > analyzers ; private final Analyzer defaultAnalyzer ; public FieldNameAnalyzer ( Analyzer defaultAnalyzer ) { this ( new CopyOnWriteHashMap < > ( ) , defaultAnalyzer ) ; } public FieldNameAnalyzer ( Map < String , Analyzer > analyzers , Analyzer defaultAnalyzer ) { super ( Analyzer . PER_FIELD_REUSE_STRATEGY ) ; this . analyzers = CopyOnWriteHashMap . copyOf ( analyzers ) ; this . defaultAnalyzer = defaultAnalyzer ; } public Map < String , Analyzer > analyzers ( ) { return analyzers ; } public Analyzer defaultAnalyzer ( ) { return defaultAnalyzer ; } @Override protected Analyzer getWrappedAnalyzer ( String fieldName ) { Analyzer analyzer = analyzers . get ( fieldName ) ; if ( analyzer ! = null ) { return analyzer ; } throw new IllegalArgumentException ( <str> + fieldName + <str> ) ; } public FieldNameAnalyzer copyAndAddAll ( Stream < ? extends Map . Entry < String , Analyzer > > mappers ) { CopyOnWriteHashMap < String , Analyzer > result = analyzers . copyAndPutAll ( mappers . map ( ( e ) - > { if ( e . getValue ( ) = = null ) { return new AbstractMap . SimpleImmutableEntry < > ( e . getKey ( ) , defaultAnalyzer ) ; } return e ; } ) ) ; return new FieldNameAnalyzer ( result , defaultAnalyzer ) ; } } 
