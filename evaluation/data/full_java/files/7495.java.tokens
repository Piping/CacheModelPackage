package org . elasticsearch . search . highlight ; import org . apache . lucene . search . highlight . SimpleFragmenter ; import org . apache . lucene . search . highlight . SimpleSpanFragmenter ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . QueryBuilder ; import java . io . IOException ; import java . util . Arrays ; import java . util . Map ; import java . util . Objects ; public abstract class AbstractHighlighterBuilder < HB extends AbstractHighlighterBuilder < ? > > { public static final ParseField PRE_TAGS_FIELD = new ParseField ( <str> ) ; public static final ParseField POST_TAGS_FIELD = new ParseField ( <str> ) ; public static final ParseField FIELDS_FIELD = new ParseField ( <str> ) ; public static final ParseField ORDER_FIELD = new ParseField ( <str> ) ; public static final ParseField TAGS_SCHEMA_FIELD = new ParseField ( <str> ) ; public static final ParseField HIGHLIGHT_FILTER_FIELD = new ParseField ( <str> ) ; public static final ParseField FRAGMENT_SIZE_FIELD = new ParseField ( <str> ) ; public static final ParseField FRAGMENT_OFFSET_FIELD = new ParseField ( <str> ) ; public static final ParseField NUMBER_OF_FRAGMENTS_FIELD = new ParseField ( <str> ) ; public static final ParseField ENCODER_FIELD = new ParseField ( <str> ) ; public static final ParseField REQUIRE_FIELD_MATCH_FIELD = new ParseField ( <str> ) ; public static final ParseField BOUNDARY_MAX_SCAN_FIELD = new ParseField ( <str> ) ; public static final ParseField BOUNDARY_CHARS_FIELD = new ParseField ( <str> ) ; public static final ParseField TYPE_FIELD = new ParseField ( <str> ) ; public static final ParseField FRAGMENTER_FIELD = new ParseField ( <str> ) ; public static final ParseField NO_MATCH_SIZE_FIELD = new ParseField ( <str> ) ; public static final ParseField FORCE_SOURCE_FIELD = new ParseField ( <str> ) ; public static final ParseField PHRASE_LIMIT_FIELD = new ParseField ( <str> ) ; public static final ParseField OPTIONS_FIELD = new ParseField ( <str> ) ; public static final ParseField HIGHLIGHT_QUERY_FIELD = new ParseField ( <str> ) ; public static final ParseField MATCHED_FIELDS_FIELD = new ParseField ( <str> ) ; protected String [ ] preTags ; protected String [ ] postTags ; protected Integer fragmentSize ; protected Integer numOfFragments ; protected String highlighterType ; protected String fragmenter ; protected QueryBuilder < ? > highlightQuery ; protected String order ; protected Boolean highlightFilter ; protected Boolean forceSource ; protected Integer boundaryMaxScan ; protected char [ ] boundaryChars ; protected Integer noMatchSize ; protected Integer phraseLimit ; protected Map < String , Object > options ; protected Boolean requireFieldMatch ; @SuppressWarnings ( <str> ) public HB preTags ( String . . . preTags ) { this . preTags = preTags ; return ( HB ) this ; } public String [ ] preTags ( ) { return this . preTags ; } @SuppressWarnings ( <str> ) public HB postTags ( String . . . postTags ) { this . postTags = postTags ; return ( HB ) this ; } public String [ ] postTags ( ) { return this . postTags ; } @SuppressWarnings ( <str> ) public HB fragmentSize ( Integer fragmentSize ) { this . fragmentSize = fragmentSize ; return ( HB ) this ; } public Integer fragmentSize ( ) { return this . fragmentSize ; } @SuppressWarnings ( <str> ) public HB numOfFragments ( Integer numOfFragments ) { this . numOfFragments = numOfFragments ; return ( HB ) this ; } public Integer numOfFragments ( ) { return this . numOfFragments ; } @SuppressWarnings ( <str> ) public HB highlighterType ( String highlighterType ) { this . highlighterType = highlighterType ; return ( HB ) this ; } public String highlighterType ( ) { return this . highlighterType ; } @SuppressWarnings ( <str> ) public HB fragmenter ( String fragmenter ) { this . fragmenter = fragmenter ; return ( HB ) this ; } public String fragmenter ( ) { return this . fragmenter ; } @SuppressWarnings ( <str> ) public HB highlightQuery ( QueryBuilder < ? > highlightQuery ) { this . highlightQuery = highlightQuery ; return ( HB ) this ; } public QueryBuilder < ? > highlightQuery ( ) { return this . highlightQuery ; } @SuppressWarnings ( <str> ) public HB order ( String order ) { this . order = order ; return ( HB ) this ; } public String order ( ) { return this . order ; } @SuppressWarnings ( <str> ) public HB highlightFilter ( Boolean highlightFilter ) { this . highlightFilter = highlightFilter ; return ( HB ) this ; } public Boolean highlightFilter ( ) { return this . highlightFilter ; } @SuppressWarnings ( <str> ) public HB boundaryMaxScan ( Integer boundaryMaxScan ) { this . boundaryMaxScan = boundaryMaxScan ; return ( HB ) this ; } public Integer boundaryMaxScan ( ) { return this . boundaryMaxScan ; } @SuppressWarnings ( <str> ) public HB boundaryChars ( char [ ] boundaryChars ) { this . boundaryChars = boundaryChars ; return ( HB ) this ; } public char [ ] boundaryChars ( ) { return this . boundaryChars ; } @SuppressWarnings ( <str> ) public HB options ( Map < String , Object > options ) { this . options = options ; return ( HB ) this ; } public Map < String , Object > options ( ) { return this . options ; } @SuppressWarnings ( <str> ) public HB requireFieldMatch ( Boolean requireFieldMatch ) { this . requireFieldMatch = requireFieldMatch ; return ( HB ) this ; } public Boolean requireFieldMatch ( ) { return this . requireFieldMatch ; } @SuppressWarnings ( <str> ) public HB noMatchSize ( Integer noMatchSize ) { this . noMatchSize = noMatchSize ; return ( HB ) this ; } public Integer noMatchSize ( ) { return this . noMatchSize ; } @SuppressWarnings ( <str> ) public HB phraseLimit ( Integer phraseLimit ) { this . phraseLimit = phraseLimit ; return ( HB ) this ; } public Integer phraseLimit ( ) { return this . noMatchSize ; } @SuppressWarnings ( <str> ) public HB forceSource ( Boolean forceSource ) { this . forceSource = forceSource ; return ( HB ) this ; } public Boolean forceSource ( ) { return this . forceSource ; } void commonOptionsToXContent ( XContentBuilder builder ) throws IOException { if ( preTags ! = null ) { builder . array ( PRE_TAGS_FIELD . getPreferredName ( ) , preTags ) ; } if ( postTags ! = null ) { builder . array ( POST_TAGS_FIELD . getPreferredName ( ) , postTags ) ; } if ( fragmentSize ! = null ) { builder . field ( FRAGMENT_SIZE_FIELD . getPreferredName ( ) , fragmentSize ) ; } if ( numOfFragments ! = null ) { builder . field ( NUMBER_OF_FRAGMENTS_FIELD . getPreferredName ( ) , numOfFragments ) ; } if ( highlighterType ! = null ) { builder . field ( TYPE_FIELD . getPreferredName ( ) , highlighterType ) ; } if ( fragmenter ! = null ) { builder . field ( FRAGMENTER_FIELD . getPreferredName ( ) , fragmenter ) ; } if ( highlightQuery ! = null ) { builder . field ( HIGHLIGHT_QUERY_FIELD . getPreferredName ( ) , highlightQuery ) ; } if ( order ! = null ) { builder . field ( ORDER_FIELD . getPreferredName ( ) , order ) ; } if ( highlightFilter ! = null ) { builder . field ( HIGHLIGHT_FILTER_FIELD . getPreferredName ( ) , highlightFilter ) ; } if ( boundaryMaxScan ! = null ) { builder . field ( BOUNDARY_MAX_SCAN_FIELD . getPreferredName ( ) , boundaryMaxScan ) ; } if ( boundaryChars ! = null ) { builder . field ( BOUNDARY_CHARS_FIELD . getPreferredName ( ) , new String ( boundaryChars ) ) ; } if ( options ! = null & & options . size ( ) > <int> ) { builder . field ( OPTIONS_FIELD . getPreferredName ( ) , options ) ; } if ( forceSource ! = null ) { builder . field ( FORCE_SOURCE_FIELD . getPreferredName ( ) , forceSource ) ; } if ( requireFieldMatch ! = null ) { builder . field ( REQUIRE_FIELD_MATCH_FIELD . getPreferredName ( ) , requireFieldMatch ) ; } if ( noMatchSize ! = null ) { builder . field ( NO_MATCH_SIZE_FIELD . getPreferredName ( ) , noMatchSize ) ; } if ( phraseLimit ! = null ) { builder . field ( PHRASE_LIMIT_FIELD . getPreferredName ( ) , phraseLimit ) ; } } @Override public final int hashCode ( ) { return Objects . hash ( getClass ( ) , Arrays . hashCode ( preTags ) , Arrays . hashCode ( postTags ) , fragmentSize , numOfFragments , highlighterType , fragmenter , highlightQuery , order , highlightFilter , forceSource , boundaryMaxScan , Arrays . hashCode ( boundaryChars ) , noMatchSize , phraseLimit , options , requireFieldMatch , doHashCode ( ) ) ; } protected abstract int doHashCode ( ) ; @Override public final boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null | | getClass ( ) ! = obj . getClass ( ) ) { return false ; } @SuppressWarnings ( <str> ) HB other = ( HB ) obj ; return Arrays . equals ( preTags , other . preTags ) & & Arrays . equals ( postTags , other . postTags ) & & Objects . equals ( fragmentSize , other . fragmentSize ) & & Objects . equals ( numOfFragments , other . numOfFragments ) & & Objects . equals ( highlighterType , other . highlighterType ) & & Objects . equals ( fragmenter , other . fragmenter ) & & Objects . equals ( highlightQuery , other . highlightQuery ) & & Objects . equals ( order , other . order ) & & Objects . equals ( highlightFilter , other . highlightFilter ) & & Objects . equals ( forceSource , other . forceSource ) & & Objects . equals ( boundaryMaxScan , other . boundaryMaxScan ) & & Arrays . equals ( boundaryChars , other . boundaryChars ) & & Objects . equals ( noMatchSize , other . noMatchSize ) & & Objects . equals ( phraseLimit , other . phraseLimit ) & & Objects . equals ( options , other . options ) & & Objects . equals ( requireFieldMatch , other . requireFieldMatch ) & & doEquals ( other ) ; } protected abstract boolean doEquals ( HB other ) ; @SuppressWarnings ( <str> ) protected HB readOptionsFrom ( StreamInput in ) throws IOException { preTags ( in . readOptionalStringArray ( ) ) ; postTags ( in . readOptionalStringArray ( ) ) ; fragmentSize ( in . readOptionalVInt ( ) ) ; numOfFragments ( in . readOptionalVInt ( ) ) ; highlighterType ( in . readOptionalString ( ) ) ; fragmenter ( in . readOptionalString ( ) ) ; if ( in . readBoolean ( ) ) { highlightQuery ( in . readQuery ( ) ) ; } order ( in . readOptionalString ( ) ) ; highlightFilter ( in . readOptionalBoolean ( ) ) ; forceSource ( in . readOptionalBoolean ( ) ) ; boundaryMaxScan ( in . readOptionalVInt ( ) ) ; if ( in . readBoolean ( ) ) { boundaryChars ( in . readString ( ) . toCharArray ( ) ) ; } noMatchSize ( in . readOptionalVInt ( ) ) ; phraseLimit ( in . readOptionalVInt ( ) ) ; if ( in . readBoolean ( ) ) { options ( in . readMap ( ) ) ; } requireFieldMatch ( in . readOptionalBoolean ( ) ) ; return ( HB ) this ; } protected void writeOptionsTo ( StreamOutput out ) throws IOException { out . writeOptionalStringArray ( preTags ) ; out . writeOptionalStringArray ( postTags ) ; out . writeOptionalVInt ( fragmentSize ) ; out . writeOptionalVInt ( numOfFragments ) ; out . writeOptionalString ( highlighterType ) ; out . writeOptionalString ( fragmenter ) ; boolean hasQuery = highlightQuery ! = null ; out . writeBoolean ( hasQuery ) ; if ( hasQuery ) { out . writeQuery ( highlightQuery ) ; } out . writeOptionalString ( order ) ; out . writeOptionalBoolean ( highlightFilter ) ; out . writeOptionalBoolean ( forceSource ) ; out . writeOptionalVInt ( boundaryMaxScan ) ; boolean hasBounaryChars = boundaryChars ! = null ; out . writeBoolean ( hasBounaryChars ) ; if ( hasBounaryChars ) { out . writeString ( String . valueOf ( boundaryChars ) ) ; } out . writeOptionalVInt ( noMatchSize ) ; out . writeOptionalVInt ( phraseLimit ) ; boolean hasOptions = options ! = null ; out . writeBoolean ( hasOptions ) ; if ( hasOptions ) { out . writeMap ( options ) ; } out . writeOptionalBoolean ( requireFieldMatch ) ; } } 
