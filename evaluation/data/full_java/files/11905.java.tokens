package org . gradle . deployment . internal ; import com . google . common . collect . Maps ; import org . gradle . api . invocation . Gradle ; import org . gradle . internal . Cast ; import org . gradle . internal . concurrent . CompositeStoppable ; import java . util . Map ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DefaultDeploymentRegistry implements DeploymentRegistry { private final Lock lock = new ReentrantLock ( ) ; private final Map < String , DeploymentHandle > handles = Maps . newHashMap ( ) ; private boolean stopped ; @Override public void register ( String id , DeploymentHandle handle ) { lock . lock ( ) ; try { failIfStopped ( ) ; if ( ! handles . containsKey ( id ) ) { handles . put ( id , handle ) ; } else { throw new IllegalStateException ( <str> + id + <str> ) ; } } finally { lock . unlock ( ) ; } } @Override public < T extends DeploymentHandle > T get ( Class < T > handleType , String id ) { lock . lock ( ) ; try { failIfStopped ( ) ; return Cast . cast ( handleType , handles . get ( id ) ) ; } finally { lock . unlock ( ) ; } } @Override public void onNewBuild ( Gradle gradle ) { lock . lock ( ) ; try { for ( DeploymentHandle handle : handles . values ( ) ) { handle . onNewBuild ( gradle ) ; } } finally { lock . unlock ( ) ; } } @Override public void stop ( ) { lock . lock ( ) ; try { CompositeStoppable . stoppable ( handles . values ( ) ) . stop ( ) ; } finally { stopped = true ; handles . clear ( ) ; lock . unlock ( ) ; } } private void failIfStopped ( ) { if ( stopped ) { throw new IllegalStateException ( <str> ) ; } } } 
