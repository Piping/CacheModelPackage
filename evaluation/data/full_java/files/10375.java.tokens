package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Joiner ; import com . google . common . collect . ImmutableSortedMap . Builder ; import com . google . common . collect . testing . ListTestSuiteBuilder ; import com . google . common . collect . testing . MapTestSuiteBuilder ; import com . google . common . collect . testing . NavigableMapTestSuiteBuilder ; import com . google . common . collect . testing . SortedMapInterfaceTest ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . google . SortedMapGenerators . ImmutableSortedMapCopyOfEntriesGenerator ; import com . google . common . collect . testing . google . SortedMapGenerators . ImmutableSortedMapEntryListGenerator ; import com . google . common . collect . testing . google . SortedMapGenerators . ImmutableSortedMapGenerator ; import com . google . common . collect . testing . google . SortedMapGenerators . ImmutableSortedMapKeyListGenerator ; import com . google . common . collect . testing . google . SortedMapGenerators . ImmutableSortedMapValueListGenerator ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . io . Serializable ; import java . util . Collections ; import java . util . Comparator ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Map . Entry ; import java . util . SortedMap ; @GwtCompatible ( emulated = true ) public class ImmutableSortedMapTest extends TestCase { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ImmutableSortedMapTest . class ) ; suite . addTest ( NavigableMapTestSuiteBuilder . using ( new ImmutableSortedMapGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE_INCLUDING_VIEWS , CollectionFeature . KNOWN_ORDER , MapFeature . REJECTS_DUPLICATES_AT_CREATION , MapFeature . ALLOWS_ANY_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MapTestSuiteBuilder . using ( new ImmutableSortedMapCopyOfEntriesGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE_INCLUDING_VIEWS , CollectionFeature . KNOWN_ORDER , MapFeature . REJECTS_DUPLICATES_AT_CREATION , MapFeature . ALLOWS_ANY_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableSortedMapEntryListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableSortedMapKeyListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableSortedMapValueListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; return suite ; } public abstract static class AbstractMapTests < K , V > extends SortedMapInterfaceTest < K , V > { public AbstractMapTests ( ) { super ( false , false , false , false , false ) ; } @Override protected SortedMap < K , V > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ; } private static final Joiner joiner = Joiner . on ( <str> ) ; @Override protected void assertMoreInvariants ( Map < K , V > map ) { for ( Entry < K , V > entry : map . entrySet ( ) ) { assertEquals ( entry . getKey ( ) + <str> + entry . getValue ( ) , entry . toString ( ) ) ; } assertEquals ( <str> + joiner . join ( map . entrySet ( ) ) + <str> , map . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . entrySet ( ) ) + <str> , map . entrySet ( ) . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . keySet ( ) ) + <str> , map . keySet ( ) . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . values ( ) ) + <str> , map . values ( ) . toString ( ) ) ; assertEquals ( Sets . newHashSet ( map . entrySet ( ) ) , map . entrySet ( ) ) ; assertEquals ( Sets . newHashSet ( map . keySet ( ) ) , map . keySet ( ) ) ; } } public static class MapTests extends AbstractMapTests < String , Integer > { @Override protected SortedMap < String , Integer > makeEmptyMap ( ) { return ImmutableSortedMap . of ( ) ; } @Override protected SortedMap < String , Integer > makePopulatedMap ( ) { return ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return - <int> ; } } public static class SingletonMapTests extends AbstractMapTests < String , Integer > { @Override protected SortedMap < String , Integer > makePopulatedMap ( ) { return ImmutableSortedMap . of ( <str> , <int> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return - <int> ; } } @GwtIncompatible ( <str> ) public static class ReserializedMapTests extends AbstractMapTests < String , Integer > { @Override protected SortedMap < String , Integer > makePopulatedMap ( ) { return SerializableTester . reserialize ( ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return - <int> ; } } public static class HeadMapTests extends AbstractMapTests < String , Integer > { @Override protected SortedMap < String , Integer > makePopulatedMap ( ) { return ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) . headMap ( <str> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return <int> ; } } public static class HeadMapInclusiveTests extends AbstractMapTests < String , Integer > { @Override protected SortedMap < String , Integer > makePopulatedMap ( ) { return ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) . headMap ( <str> , true ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return <int> ; } } public static class TailMapTests extends AbstractMapTests < String , Integer > { @Override protected SortedMap < String , Integer > makePopulatedMap ( ) { return ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) . tailMap ( <str> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return <int> ; } } public static class TailExclusiveMapTests extends AbstractMapTests < String , Integer > { @Override protected SortedMap < String , Integer > makePopulatedMap ( ) { return ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) . tailMap ( <str> , false ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return <int> ; } } public static class SubMapTests extends AbstractMapTests < String , Integer > { @Override protected SortedMap < String , Integer > makePopulatedMap ( ) { return ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) . subMap ( <str> , <str> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return <int> ; } } public static class CreationTests extends TestCase { public void testEmptyBuilder ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . build ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , map ) ; } public void testSingletonBuilder ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> ) ; } public void testBuilder ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testBuilder_orderEntriesByValueFails ( ) { ImmutableSortedMap . Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; try { builder . orderEntriesByValue ( Ordering . natural ( ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } public void testBuilder_withImmutableEntry ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . put ( Maps . immutableEntry ( <str> , <int> ) ) . build ( ) ; assertMapEquals ( map , <str> , <int> ) ; } public void testBuilder_withImmutableEntryAndNullContents ( ) { Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; try { builder . put ( Maps . immutableEntry ( <str> , ( Integer ) null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { builder . put ( Maps . immutableEntry ( ( String ) null , <int> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } private static class StringHolder { String string ; } public void testBuilder_withMutableEntry ( ) { ImmutableSortedMap . Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; final StringHolder holder = new StringHolder ( ) ; holder . string = <str> ; Entry < String , Integer > entry = new AbstractMapEntry < String , Integer > ( ) { @Override public String getKey ( ) { return holder . string ; } @Override public Integer getValue ( ) { return <int> ; } } ; builder . put ( entry ) ; holder . string = <str> ; assertMapEquals ( builder . build ( ) , <str> , <int> ) ; } public void testBuilderPutAllWithEmptyMap ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . putAll ( Collections . < String , Integer > emptyMap ( ) ) . build ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , map ) ; } public void testBuilderPutAll ( ) { Map < String , Integer > toPut = new LinkedHashMap < String , Integer > ( ) ; toPut . put ( <str> , <int> ) ; toPut . put ( <str> , <int> ) ; toPut . put ( <str> , <int> ) ; Map < String , Integer > moreToPut = new LinkedHashMap < String , Integer > ( ) ; moreToPut . put ( <str> , <int> ) ; moreToPut . put ( <str> , <int> ) ; ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . putAll ( toPut ) . putAll ( moreToPut ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testBuilderReuse ( ) { Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; ImmutableSortedMap < String , Integer > mapOne = builder . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; ImmutableSortedMap < String , Integer > mapTwo = builder . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( mapOne , <str> , <int> , <str> , <int> ) ; assertMapEquals ( mapTwo , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testBuilderPutNullKey ( ) { Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; try { builder . put ( null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullValue ( ) { Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; try { builder . put ( <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullKeyViaPutAll ( ) { Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; try { builder . putAll ( Collections . < String , Integer > singletonMap ( null , <int> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullValueViaPutAll ( ) { Builder < String , Integer > builder = ImmutableSortedMap . naturalOrder ( ) ; try { builder . putAll ( Collections . < String , Integer > singletonMap ( <str> , null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testPuttingTheSameKeyTwiceThrowsOnBuild ( ) { Builder < String , Integer > builder = ImmutableSortedMap . < String , Integer > naturalOrder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ; try { builder . build ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testOf ( ) { assertMapEquals ( ImmutableSortedMap . of ( <str> , <int> ) , <str> , <int> ) ; assertMapEquals ( ImmutableSortedMap . of ( <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testOfNullKey ( ) { Integer n = null ; try { ImmutableSortedMap . of ( n , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { ImmutableSortedMap . of ( <str> , <int> , null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testOfNullValue ( ) { try { ImmutableSortedMap . of ( <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { ImmutableSortedMap . of ( <str> , <int> , <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testOfWithDuplicateKey ( ) { try { ImmutableSortedMap . of ( <str> , <int> , <str> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCopyOfEmptyMap ( ) { ImmutableSortedMap < String , Integer > copy = ImmutableSortedMap . copyOf ( Collections . < String , Integer > emptyMap ( ) ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , copy ) ; assertSame ( copy , ImmutableSortedMap . copyOf ( copy ) ) ; assertSame ( Ordering . natural ( ) , copy . comparator ( ) ) ; } public void testCopyOfSingletonMap ( ) { ImmutableSortedMap < String , Integer > copy = ImmutableSortedMap . copyOf ( Collections . singletonMap ( <str> , <int> ) ) ; assertMapEquals ( copy , <str> , <int> ) ; assertSame ( copy , ImmutableSortedMap . copyOf ( copy ) ) ; assertSame ( Ordering . natural ( ) , copy . comparator ( ) ) ; } public void testCopyOf ( ) { Map < String , Integer > original = new LinkedHashMap < String , Integer > ( ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; ImmutableSortedMap < String , Integer > copy = ImmutableSortedMap . copyOf ( original ) ; assertMapEquals ( copy , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( copy , ImmutableSortedMap . copyOf ( copy ) ) ; assertSame ( Ordering . natural ( ) , copy . comparator ( ) ) ; } public void testCopyOfExplicitComparator ( ) { Comparator < String > comparator = Ordering . natural ( ) . reverse ( ) ; Map < String , Integer > original = new LinkedHashMap < String , Integer > ( ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; ImmutableSortedMap < String , Integer > copy = ImmutableSortedMap . copyOf ( original , comparator ) ; assertMapEquals ( copy , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( copy , ImmutableSortedMap . copyOf ( copy , comparator ) ) ; assertSame ( comparator , copy . comparator ( ) ) ; } public void testCopyOfImmutableSortedSetDifferentComparator ( ) { Comparator < String > comparator = Ordering . natural ( ) . reverse ( ) ; Map < String , Integer > original = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; ImmutableSortedMap < String , Integer > copy = ImmutableSortedMap . copyOf ( original , comparator ) ; assertMapEquals ( copy , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( copy , ImmutableSortedMap . copyOf ( copy , comparator ) ) ; assertSame ( comparator , copy . comparator ( ) ) ; } public void testCopyOfSortedNatural ( ) { SortedMap < String , Integer > original = Maps . newTreeMap ( ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; ImmutableSortedMap < String , Integer > copy = ImmutableSortedMap . copyOfSorted ( original ) ; assertMapEquals ( copy , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( copy , ImmutableSortedMap . copyOfSorted ( copy ) ) ; assertSame ( Ordering . natural ( ) , copy . comparator ( ) ) ; } public void testCopyOfSortedExplicit ( ) { Comparator < String > comparator = Ordering . natural ( ) . reverse ( ) ; SortedMap < String , Integer > original = Maps . newTreeMap ( comparator ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; ImmutableSortedMap < String , Integer > copy = ImmutableSortedMap . copyOfSorted ( original ) ; assertMapEquals ( copy , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( copy , ImmutableSortedMap . copyOfSorted ( copy ) ) ; assertSame ( comparator , copy . comparator ( ) ) ; } private static class IntegerDiv10 implements Comparable < IntegerDiv10 > { final int value ; IntegerDiv10 ( int value ) { this . value = value ; } @Override public int compareTo ( IntegerDiv10 o ) { return value / <int> - o . value / <int> ; } @Override public String toString ( ) { return Integer . toString ( value ) ; } } public void testCopyOfDuplicateKey ( ) { Map < IntegerDiv10 , String > original = ImmutableMap . of ( new IntegerDiv10 ( <int> ) , <str> , new IntegerDiv10 ( <int> ) , <str> , new IntegerDiv10 ( <int> ) , <str> , new IntegerDiv10 ( <int> ) , <str> , new IntegerDiv10 ( <int> ) , <str> ) ; try { ImmutableSortedMap . copyOf ( original ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testImmutableMapCopyOfImmutableSortedMap ( ) { IntegerDiv10 three = new IntegerDiv10 ( <int> ) ; IntegerDiv10 eleven = new IntegerDiv10 ( <int> ) ; IntegerDiv10 twelve = new IntegerDiv10 ( <int> ) ; IntegerDiv10 twenty = new IntegerDiv10 ( <int> ) ; Map < IntegerDiv10 , String > original = ImmutableSortedMap . of ( three , <str> , eleven , <str> , twenty , <str> ) ; Map < IntegerDiv10 , String > copy = ImmutableMap . copyOf ( original ) ; assertTrue ( original . containsKey ( twelve ) ) ; assertFalse ( copy . containsKey ( twelve ) ) ; } public void testBuilderReverseOrder ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . < String , Integer > reverseOrder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertEquals ( Ordering . natural ( ) . reverse ( ) , map . comparator ( ) ) ; } public void testBuilderComparator ( ) { Comparator < String > comparator = Ordering . natural ( ) . reverse ( ) ; ImmutableSortedMap < String , Integer > map = new ImmutableSortedMap . Builder < String , Integer > ( comparator ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( comparator , map . comparator ( ) ) ; } } public void testNullGet ( ) { ImmutableSortedMap < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> ) ; assertNull ( map . get ( null ) ) ; } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( ImmutableSortedMap . class ) ; tester . testAllPublicInstanceMethods ( ImmutableSortedMap . < String , Integer > naturalOrder ( ) ) ; tester . testAllPublicInstanceMethods ( ImmutableSortedMap . of ( ) ) ; tester . testAllPublicInstanceMethods ( ImmutableSortedMap . of ( <str> , <int> ) ) ; tester . testAllPublicInstanceMethods ( ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; } private static < K , V > void assertMapEquals ( Map < K , V > map , Object . . . alternatingKeysAndValues ) { assertEquals ( map . size ( ) , alternatingKeysAndValues . length / <int> ) ; int i = <int> ; for ( Entry < K , V > entry : map . entrySet ( ) ) { assertEquals ( alternatingKeysAndValues [ i + + ] , entry . getKey ( ) ) ; assertEquals ( alternatingKeysAndValues [ i + + ] , entry . getValue ( ) ) ; } } private static class IntHolder implements Serializable { public int value ; public IntHolder ( int value ) { this . value = value ; } @Override public boolean equals ( Object o ) { return ( o instanceof IntHolder ) & & ( ( IntHolder ) o ) . value = = value ; } @Override public int hashCode ( ) { return value ; } private static final long serialVersionUID = <int> ; } public void testMutableValues ( ) { IntHolder holderA = new IntHolder ( <int> ) ; IntHolder holderB = new IntHolder ( <int> ) ; Map < String , IntHolder > map = ImmutableSortedMap . of ( <str> , holderA , <str> , holderB ) ; holderA . value = <int> ; assertTrue ( map . entrySet ( ) . contains ( Maps . immutableEntry ( <str> , new IntHolder ( <int> ) ) ) ) ; Map < String , Integer > intMap = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> ) ; assertEquals ( intMap . hashCode ( ) , map . entrySet ( ) . hashCode ( ) ) ; assertEquals ( intMap . hashCode ( ) , map . hashCode ( ) ) ; } @GwtIncompatible ( <str> ) public void testViewSerialization ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; SerializableTester . reserializeAndAssert ( map . entrySet ( ) ) ; SerializableTester . reserializeAndAssert ( map . keySet ( ) ) ; assertEquals ( Lists . newArrayList ( map . values ( ) ) , Lists . newArrayList ( SerializableTester . reserialize ( map . values ( ) ) ) ) ; } @SuppressWarnings ( <str> ) public void testHeadMapInclusive ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . headMap ( <str> , true ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testHeadMapExclusive ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . headMap ( <str> , false ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) ) ; } @SuppressWarnings ( <str> ) public void testTailMapInclusive ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . tailMap ( <str> , true ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testTailMapExclusive ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . tailMap ( <str> , false ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) ) ; } @SuppressWarnings ( <str> ) public void testSubMapExclusiveExclusive ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . subMap ( <str> , false , <str> , false ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) ) ; } @SuppressWarnings ( <str> ) public void testSubMapInclusiveExclusive ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . subMap ( <str> , true , <str> , false ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testSubMapExclusiveInclusive ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . subMap ( <str> , false , <str> , true ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testSubMapInclusiveInclusive ( ) { Map < String , Integer > map = ImmutableSortedMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) . subMap ( <str> , true , <str> , true ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } private static class SelfComparableExample implements Comparable < SelfComparableExample > { @Override public int compareTo ( SelfComparableExample o ) { return <int> ; } } public void testBuilderGenerics_SelfComparable ( ) { ImmutableSortedMap . Builder < SelfComparableExample , Object > natural = ImmutableSortedMap . naturalOrder ( ) ; ImmutableSortedMap . Builder < SelfComparableExample , Object > reverse = ImmutableSortedMap . reverseOrder ( ) ; } private static class SuperComparableExample extends SelfComparableExample { } public void testBuilderGenerics_SuperComparable ( ) { ImmutableSortedMap . Builder < SuperComparableExample , Object > natural = ImmutableSortedMap . naturalOrder ( ) ; ImmutableSortedMap . Builder < SuperComparableExample , Object > reverse = ImmutableSortedMap . reverseOrder ( ) ; } } 
