package org . gradle . api . internal . tasks . compile . daemon ; import org . gradle . api . Action ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . tasks . WorkResult ; import org . gradle . internal . UncheckedException ; import org . gradle . language . base . internal . compile . CompileSpec ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . process . internal . WorkerProcessContext ; import java . io . IOException ; import java . io . Serializable ; import java . net . URL ; import java . util . concurrent . CountDownLatch ; public class CompilerDaemonServer implements Action < WorkerProcessContext > , CompilerDaemonServerProtocol , Serializable { private static final Logger LOGGER = Logging . getLogger ( CompilerDaemonServer . class ) ; private volatile CompilerDaemonClientProtocol client ; private volatile CountDownLatch stop ; private final boolean disableUrlCaching ; public CompilerDaemonServer ( boolean disableUrlCaching ) { this . disableUrlCaching = disableUrlCaching ; } public void execute ( WorkerProcessContext context ) { stop = new CountDownLatch ( <int> ) ; if ( disableUrlCaching ) { disableUrlCaching ( ) ; } client = context . getServerConnection ( ) . addOutgoing ( CompilerDaemonClientProtocol . class ) ; context . getServerConnection ( ) . addIncoming ( CompilerDaemonServerProtocol . class , this ) ; context . getServerConnection ( ) . connect ( ) ; try { stop . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } private static void disableUrlCaching ( ) { try { new URL ( <str> ) . openConnection ( ) . setDefaultUseCaches ( false ) ; } catch ( IOException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public < T extends CompileSpec > void execute ( Compiler < T > compiler , T spec ) { try { LOGGER . info ( <str> , compiler ) ; WorkResult result = compiler . execute ( spec ) ; LOGGER . info ( <str> , compiler ) ; client . executed ( new CompileResult ( result . getDidWork ( ) , null ) ) ; } catch ( Throwable t ) { LOGGER . info ( <str> , compiler , t ) ; client . executed ( new CompileResult ( true , t ) ) ; } } public void stop ( ) { stop . countDown ( ) ; } } 
