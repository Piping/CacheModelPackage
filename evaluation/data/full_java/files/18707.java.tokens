package com . badlogic . gdx . tests . gwt ; import java . util . ArrayList ; import java . util . List ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Preferences ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Mesh . VertexDataType ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . BitmapFontCache ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureAtlas ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class GwtTest extends GdxTest { ShaderProgram shader ; Mesh mesh ; Matrix4 matrix = new Matrix4 ( ) ; SpriteBatch batch ; Texture texture ; List < Vector2 > positions ; Sprite sprite ; BitmapFont font ; BitmapFontCache cache ; TextureAtlas atlas ; int numSprites ; @Override public void create ( ) { Preferences pref = Gdx . app . getPreferences ( <str> ) ; boolean resultb = pref . getBoolean ( <str> ) ; int resulti = pref . getInteger ( <str> ) ; shader = new ShaderProgram ( Gdx . files . internal ( <str> ) , Gdx . files . internal ( <str> ) ) ; if ( ! shader . isCompiled ( ) ) throw new GdxRuntimeException ( shader . getLog ( ) ) ; mesh = new Mesh ( VertexDataType . VertexBufferObject , true , <int> , <int> , VertexAttribute . Position ( ) , VertexAttribute . TexCoords ( <int> ) ) ; mesh . setVertices ( new float [ ] { - <float> , - <float> , <int> , <int> , <int> , <float> , - <float> , <int> , <int> , <int> , <float> , <float> , <int> , <int> , <int> , <float> , <float> , <int> , <int> , <int> , - <float> , <float> , <int> , <int> , <int> , - <float> , - <float> , <int> , <int> , <int> } ) ; texture = new Texture ( new Pixmap ( Gdx . files . internal ( <str> ) ) , true ) ; texture . setFilter ( TextureFilter . MipMap , TextureFilter . Linear ) ; String params = Gdx . files . internal ( <str> ) . readString ( ) ; numSprites = Integer . parseInt ( params ) ; batch = new SpriteBatch ( ) ; positions = new ArrayList < Vector2 > ( ) ; for ( int i = <int> ; i < numSprites ; i + + ) { positions . add ( new Vector2 ( MathUtils . random ( ) * Gdx . graphics . getWidth ( ) , MathUtils . random ( ) * Gdx . graphics . getHeight ( ) ) ) ; } sprite = new Sprite ( texture ) ; sprite . setSize ( <int> , <int> ) ; sprite . setOrigin ( <int> , <int> ) ; font = new BitmapFont ( Gdx . files . internal ( <str> ) , false ) ; cache = font . newFontCache ( ) ; cache . setColor ( Color . RED ) ; cache . setText ( <str> , <int> , <int> ) ; atlas = new TextureAtlas ( Gdx . files . internal ( <str> ) ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; texture . bind ( <int> ) ; shader . begin ( ) ; shader . setUniformMatrix ( <str> , matrix ) ; shader . setUniformi ( <str> , <int> ) ; mesh . render ( shader , GL20 . GL_TRIANGLES ) ; shader . end ( ) ; batch . begin ( ) ; batch . draw ( atlas . findRegion ( <str> ) , <int> , <int> ) ; sprite . rotate ( Gdx . graphics . getDeltaTime ( ) * <int> ) ; for ( Vector2 position : positions ) { sprite . setPosition ( position . x , position . y ) ; sprite . draw ( batch ) ; } font . draw ( batch , <str> + Gdx . graphics . getFramesPerSecond ( ) + <str> + Gdx . graphics . getDeltaTime ( ) + <str> + numSprites , <int> , <int> ) ; cache . setPosition ( <int> , <int> ) ; cache . draw ( batch ) ; batch . end ( ) ; } @Override public void resume ( ) { } @Override public void resize ( int width , int height ) { } @Override public void pause ( ) { } @Override public void dispose ( ) { } } 
