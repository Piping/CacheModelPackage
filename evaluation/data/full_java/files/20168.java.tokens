package io . netty . osgitests ; import static org . junit . Assert . assertFalse ; import static org . ops4j . pax . exam . CoreOptions . junitBundles ; import static org . ops4j . pax . exam . CoreOptions . mavenBundle ; import static org . ops4j . pax . exam . CoreOptions . systemProperty ; import static org . ops4j . pax . exam . CoreOptions . wrappedBundle ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . util . Arrays ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import java . util . regex . Pattern ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . ops4j . pax . exam . Configuration ; import org . ops4j . pax . exam . Option ; import org . ops4j . pax . exam . junit . PaxExam ; @RunWith ( PaxExam . class ) public class OsgiBundleTest { private static final Pattern SLASH = Pattern . compile ( <str> , Pattern . LITERAL ) ; private static final String DEPENCIES_LINE = <str> ; private static final String GROUP = <str> ; private static final Collection < String > BUNDLES ; static { final Set < String > artifacts = new HashSet < String > ( ) ; final File f = new File ( <str> ) ; try { final BufferedReader r = new BufferedReader ( new FileReader ( f ) ) ; try { boolean haveDeps = false ; while ( true ) { final String line = r . readLine ( ) ; if ( line = = null ) { break ; } if ( DEPENCIES_LINE . equals ( line ) ) { haveDeps = true ; } else if ( haveDeps & & line . startsWith ( GROUP ) ) { final String [ ] split = SLASH . split ( line ) ; if ( split . length > <int> ) { artifacts . add ( split [ <int> ] ) ; } } } } finally { r . close ( ) ; } } catch ( IOException e ) { throw new ExceptionInInitializerError ( e ) ; } BUNDLES = artifacts ; } @Configuration public final Option [ ] config ( ) { final Collection < Option > options = new ArrayList < Option > ( ) ; options . add ( systemProperty ( <str> ) . value ( <str> ) ) ; options . addAll ( Arrays . asList ( junitBundles ( ) ) ) ; options . add ( mavenBundle ( <str> , <str> ) . versionAsInProject ( ) ) ; options . add ( mavenBundle ( <str> , <str> ) . versionAsInProject ( ) ) ; options . add ( wrappedBundle ( mavenBundle ( <str> , <str> ) . versionAsInProject ( ) ) ) ; for ( String name : BUNDLES ) { options . add ( mavenBundle ( GROUP , name ) . versionAsInProject ( ) ) ; } return options . toArray ( new Option [ <int> ] ) ; } @Test public void testResolvedBundles ( ) { assertFalse ( <str> , BUNDLES . isEmpty ( ) ) ; } } 
