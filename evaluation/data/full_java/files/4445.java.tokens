package org . eclipse . debug . internal . ui . viewers . model . provisional ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class ModelDelta implements IModelDelta { private IModelDelta fParent ; private Object fElement ; private int fFlags ; private ModelDelta [ ] fNodes = EMPTY_NODES ; private List < ModelDelta > fNodesList = null ; private Map < Object , Object > fNodesMap ; private Object fReplacement ; private int fIndex = - <int> ; private int fChildCount = - <int> ; private static final ModelDelta [ ] EMPTY_NODES = new ModelDelta [ <int> ] ; public ModelDelta ( Object element , int flags ) { fElement = element ; fFlags = flags ; } public ModelDelta ( Object element , Object replacement , int flags ) { fElement = element ; fReplacement = replacement ; fFlags = flags ; } public ModelDelta ( Object element , int index , int flags ) { fElement = element ; fIndex = index ; fFlags = flags ; } public ModelDelta ( Object element , int index , int flags , int childCount ) { fElement = element ; fIndex = index ; fFlags = flags ; fChildCount = childCount ; } @Override public Object getElement ( ) { return fElement ; } @Override public int getFlags ( ) { return fFlags ; } public ModelDelta addNode ( Object element , int flags ) { ModelDelta node = new ModelDelta ( element , flags ) ; node . setParent ( this ) ; addDelta ( node ) ; return node ; } public ModelDelta getChildDelta ( Object element ) { if ( fNodesMap = = null ) { mapNodes ( ) ; } Object nodeOrNodes = fNodesMap . get ( element ) ; if ( nodeOrNodes instanceof ModelDelta ) { return ( ModelDelta ) nodeOrNodes ; } else if ( nodeOrNodes instanceof ModelDelta [ ] ) { return ( ( ModelDelta [ ] ) nodeOrNodes ) [ <int> ] ; } return null ; } public ModelDelta getChildDelta ( Object element , int index ) { if ( fNodesMap = = null ) { mapNodes ( ) ; } Object nodeOrNodes = fNodesMap . get ( element ) ; if ( nodeOrNodes instanceof ModelDelta ) { ModelDelta node = ( ModelDelta ) nodeOrNodes ; if ( index = = node . getIndex ( ) ) { return node ; } } else if ( nodeOrNodes instanceof ModelDelta [ ] ) { ModelDelta [ ] nodes = ( ModelDelta [ ] ) nodeOrNodes ; for ( int i = <int> ; i < nodes . length ; i + + ) { if ( index = = nodes [ i ] . getIndex ( ) ) { return nodes [ i ] ; } } } return null ; } private void mapNodes ( ) { if ( fNodesList = = null ) { fNodesMap = new HashMap < Object , Object > ( <int> ) ; return ; } fNodesMap = new HashMap < Object , Object > ( fNodesList . size ( ) * <int> / <int> ) ; for ( int i = <int> ; i < fNodesList . size ( ) ; i + + ) { mapNode ( fNodesList . get ( i ) ) ; } } private void mapNode ( ModelDelta node ) { Object oldValue = fNodesMap . put ( node . getElement ( ) , node ) ; if ( oldValue instanceof ModelDelta ) { ModelDelta [ ] nodes = new ModelDelta [ ] { ( ModelDelta ) oldValue , node } ; fNodesMap . put ( node . getElement ( ) , nodes ) ; } else if ( oldValue instanceof ModelDelta [ ] ) { ModelDelta [ ] oldNodes = ( ModelDelta [ ] ) oldValue ; ModelDelta [ ] newNodes = new ModelDelta [ oldNodes . length + <int> ] ; System . arraycopy ( oldNodes , <int> , newNodes , <int> , oldNodes . length ) ; newNodes [ newNodes . length - <int> ] = node ; fNodesMap . put ( node . getElement ( ) , newNodes ) ; } } public ModelDelta addNode ( Object element , Object replacement , int flags ) { ModelDelta node = new ModelDelta ( element , replacement , flags ) ; node . setParent ( this ) ; addDelta ( node ) ; return node ; } public ModelDelta addNode ( Object element , int index , int flags ) { ModelDelta node = new ModelDelta ( element , index , flags ) ; node . setParent ( this ) ; addDelta ( node ) ; return node ; } public ModelDelta addNode ( Object element , int index , int flags , int numChildren ) { ModelDelta node = new ModelDelta ( element , index , flags , numChildren ) ; node . setParent ( this ) ; addDelta ( node ) ; return node ; } void setParent ( ModelDelta node ) { fParent = node ; } @Override public IModelDelta getParentDelta ( ) { return fParent ; } @Override public Object getReplacementElement ( ) { return fReplacement ; } @Override public int getIndex ( ) { return fIndex ; } @Override public IModelDelta [ ] getChildDeltas ( ) { if ( fNodes = = null ) { fNodes = fNodesList . toArray ( new ModelDelta [ fNodesList . size ( ) ] ) ; } return fNodes ; } private void addDelta ( ModelDelta delta ) { if ( fNodesList = = null ) { fNodesList = new ArrayList < ModelDelta > ( <int> ) ; } fNodesList . add ( delta ) ; fNodes = null ; if ( fNodesMap ! = null ) { mapNode ( delta ) ; } } @Override public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( <str> ) ; appendDetail ( <str> , buf , this ) ; buf . append ( <str> ) ; return buf . toString ( ) ; } private void appendDetail ( String indent , StringBuffer buf , IModelDelta delta ) { buf . append ( indent ) ; buf . append ( <str> ) ; buf . append ( delta . getElement ( ) ) ; buf . append ( <str> ) ; buf . append ( indent ) ; buf . append ( <str> ) ; int flags = delta . getFlags ( ) ; if ( flags = = <int> ) { buf . append ( <str> ) ; } else { if ( ( flags & IModelDelta . ADDED ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . CONTENT ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . COLLAPSE ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . EXPAND ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . INSERTED ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . REMOVED ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . REPLACED ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . SELECT ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . STATE ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . INSTALL ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . UNINSTALL ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . REVEAL ) > <int> ) { buf . append ( <str> ) ; } if ( ( flags & IModelDelta . FORCE ) > <int> ) { buf . append ( <str> ) ; } } buf . append ( <str> ) ; buf . append ( indent ) ; buf . append ( <str> ) ; buf . append ( delta . getIndex ( ) ) ; buf . append ( <str> ) ; buf . append ( delta . getChildCount ( ) ) ; buf . append ( <str> ) ; IModelDelta [ ] nodes = delta . getChildDeltas ( ) ; for ( int i = <int> ; i < nodes . length ; i + + ) { appendDetail ( indent + <str> , buf , nodes [ i ] ) ; } } @Override public int getChildCount ( ) { return fChildCount ; } @Override public void accept ( IModelDeltaVisitor visitor ) { doAccept ( visitor , <int> ) ; } protected void doAccept ( IModelDeltaVisitor visitor , int depth ) { if ( visitor . visit ( this , depth ) ) { IModelDelta [ ] childDeltas = getChildDeltas ( ) ; for ( int i = <int> ; i < childDeltas . length ; i + + ) { ( ( ModelDelta ) childDeltas [ i ] ) . doAccept ( visitor , depth + <int> ) ; } } } public void setElement ( Object element ) { fElement = element ; } public void setFlags ( int flags ) { fFlags = flags ; } public void setIndex ( int index ) { fIndex = index ; } public void setChildCount ( int count ) { fChildCount = count ; } } 
