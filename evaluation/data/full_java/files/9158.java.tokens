package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . CollectPreconditions . checkNonnegative ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . primitives . Ints ; import java . io . InvalidObjectException ; import java . io . ObjectStreamException ; import java . io . Serializable ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) abstract class AbstractMapBasedMultiset < E > extends AbstractMultiset < E > implements Serializable { private transient Map < E , Count > backingMap ; private transient long size ; protected AbstractMapBasedMultiset ( Map < E , Count > backingMap ) { this . backingMap = checkNotNull ( backingMap ) ; this . size = super . size ( ) ; } void setBackingMap ( Map < E , Count > backingMap ) { this . backingMap = backingMap ; } @Override public Set < Multiset . Entry < E > > entrySet ( ) { return super . entrySet ( ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < Map . Entry < E , Count > > backingEntries = backingMap . entrySet ( ) . iterator ( ) ; return new Iterator < Multiset . Entry < E > > ( ) { Map . Entry < E , Count > toRemove ; @Override public boolean hasNext ( ) { return backingEntries . hasNext ( ) ; } @Override public Multiset . Entry < E > next ( ) { final Map . Entry < E , Count > mapEntry = backingEntries . next ( ) ; toRemove = mapEntry ; return new Multisets . AbstractEntry < E > ( ) { @Override public E getElement ( ) { return mapEntry . getKey ( ) ; } @Override public int getCount ( ) { Count count = mapEntry . getValue ( ) ; if ( count = = null | | count . get ( ) = = <int> ) { Count frequency = backingMap . get ( getElement ( ) ) ; if ( frequency ! = null ) { return frequency . get ( ) ; } } return ( count = = null ) ? <int> : count . get ( ) ; } } ; } @Override public void remove ( ) { checkRemove ( toRemove ! = null ) ; size - = toRemove . getValue ( ) . getAndSet ( <int> ) ; backingEntries . remove ( ) ; toRemove = null ; } } ; } @Override public void clear ( ) { for ( Count frequency : backingMap . values ( ) ) { frequency . set ( <int> ) ; } backingMap . clear ( ) ; size = <int> L ; } @Override int distinctElements ( ) { return backingMap . size ( ) ; } @Override public int size ( ) { return Ints . saturatedCast ( size ) ; } @Override public Iterator < E > iterator ( ) { return new MapBasedMultisetIterator ( ) ; } private class MapBasedMultisetIterator implements Iterator < E > { final Iterator < Map . Entry < E , Count > > entryIterator ; Map . Entry < E , Count > currentEntry ; int occurrencesLeft ; boolean canRemove ; MapBasedMultisetIterator ( ) { this . entryIterator = backingMap . entrySet ( ) . iterator ( ) ; } @Override public boolean hasNext ( ) { return occurrencesLeft > <int> | | entryIterator . hasNext ( ) ; } @Override public E next ( ) { if ( occurrencesLeft = = <int> ) { currentEntry = entryIterator . next ( ) ; occurrencesLeft = currentEntry . getValue ( ) . get ( ) ; } occurrencesLeft - - ; canRemove = true ; return currentEntry . getKey ( ) ; } @Override public void remove ( ) { checkRemove ( canRemove ) ; int frequency = currentEntry . getValue ( ) . get ( ) ; if ( frequency < = <int> ) { throw new ConcurrentModificationException ( ) ; } if ( currentEntry . getValue ( ) . addAndGet ( - <int> ) = = <int> ) { entryIterator . remove ( ) ; } size - - ; canRemove = false ; } } @Override public int count ( @Nullable Object element ) { Count frequency = Maps . safeGet ( backingMap , element ) ; return ( frequency = = null ) ? <int> : frequency . get ( ) ; } @Override public int add ( @Nullable E element , int occurrences ) { if ( occurrences = = <int> ) { return count ( element ) ; } checkArgument ( occurrences > <int> , <str> , occurrences ) ; Count frequency = backingMap . get ( element ) ; int oldCount ; if ( frequency = = null ) { oldCount = <int> ; backingMap . put ( element , new Count ( occurrences ) ) ; } else { oldCount = frequency . get ( ) ; long newCount = ( long ) oldCount + ( long ) occurrences ; checkArgument ( newCount < = Integer . MAX_VALUE , <str> , newCount ) ; frequency . getAndAdd ( occurrences ) ; } size + = occurrences ; return oldCount ; } @Override public int remove ( @Nullable Object element , int occurrences ) { if ( occurrences = = <int> ) { return count ( element ) ; } checkArgument ( occurrences > <int> , <str> , occurrences ) ; Count frequency = backingMap . get ( element ) ; if ( frequency = = null ) { return <int> ; } int oldCount = frequency . get ( ) ; int numberRemoved ; if ( oldCount > occurrences ) { numberRemoved = occurrences ; } else { numberRemoved = oldCount ; backingMap . remove ( element ) ; } frequency . addAndGet ( - numberRemoved ) ; size - = numberRemoved ; return oldCount ; } @Override public int setCount ( @Nullable E element , int count ) { checkNonnegative ( count , <str> ) ; Count existingCounter ; int oldCount ; if ( count = = <int> ) { existingCounter = backingMap . remove ( element ) ; oldCount = getAndSet ( existingCounter , count ) ; } else { existingCounter = backingMap . get ( element ) ; oldCount = getAndSet ( existingCounter , count ) ; if ( existingCounter = = null ) { backingMap . put ( element , new Count ( count ) ) ; } } size + = ( count - oldCount ) ; return oldCount ; } private static int getAndSet ( Count i , int count ) { if ( i = = null ) { return <int> ; } return i . getAndSet ( count ) ; } @GwtIncompatible ( <str> ) private void readObjectNoData ( ) throws ObjectStreamException { throw new InvalidObjectException ( <str> ) ; } @GwtIncompatible ( <str> ) private static final long serialVersionUID = - <int> ; } 
