package org . gradle . internal . resource . transport . http ; import org . cyberneko . html . parsers . SAXParser ; import org . gradle . internal . resource . UriResource ; import org . gradle . internal . resource . ResourceException ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . xml . sax . Attributes ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . net . MalformedURLException ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . ArrayList ; import java . util . List ; public class ApacheDirectoryListingParser { private static final Logger LOGGER = LoggerFactory . getLogger ( ApacheDirectoryListingParser . class ) ; public List < String > parse ( URI baseURI , InputStream content , String contentType ) throws Exception { baseURI = addTrailingSlashes ( baseURI ) ; if ( contentType = = null | | ! contentType . startsWith ( <str> ) ) { throw new ResourceException ( baseURI , String . format ( <str> , contentType , baseURI ) ) ; } String contentEncoding = UriResource . extractCharacterEncoding ( contentType , <str> ) ; final Reader htmlText = new InputStreamReader ( content , contentEncoding ) ; final InputSource inputSource = new InputSource ( htmlText ) ; final SAXParser htmlParser = new SAXParser ( ) ; final AnchorListerHandler anchorListerHandler = new AnchorListerHandler ( ) ; htmlParser . setContentHandler ( anchorListerHandler ) ; htmlParser . parse ( inputSource ) ; List < String > hrefs = anchorListerHandler . getHrefs ( ) ; List < URI > uris = resolveURIs ( baseURI , hrefs ) ; return filterNonDirectChilds ( baseURI , uris ) ; } private URI addTrailingSlashes ( URI uri ) throws IOException , URISyntaxException { if ( uri . getPath ( ) = = null ) { uri = new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , <str> , uri . getQuery ( ) , uri . getFragment ( ) ) ; } else if ( ! uri . getPath ( ) . endsWith ( <str> ) & & ! uri . getPath ( ) . endsWith ( <str> ) ) { uri = new URI ( uri . getScheme ( ) , uri . getUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getPath ( ) + <str> , uri . getQuery ( ) , uri . getFragment ( ) ) ; } return uri ; } private List < String > filterNonDirectChilds ( URI baseURI , List < URI > inputURIs ) throws MalformedURLException { final int baseURIPort = baseURI . getPort ( ) ; final String baseURIHost = baseURI . getHost ( ) ; final String baseURIScheme = baseURI . getScheme ( ) ; List < String > uris = new ArrayList < String > ( ) ; final String prefixPath = baseURI . getPath ( ) ; for ( URI parsedURI : inputURIs ) { if ( parsedURI . getHost ( ) ! = null & & ! parsedURI . getHost ( ) . equals ( baseURIHost ) ) { continue ; } if ( parsedURI . getScheme ( ) ! = null & & ! parsedURI . getScheme ( ) . equals ( baseURIScheme ) ) { continue ; } if ( parsedURI . getPort ( ) ! = baseURIPort ) { continue ; } if ( parsedURI . getPath ( ) ! = null & & ! parsedURI . getPath ( ) . startsWith ( prefixPath ) ) { continue ; } String childPathPart = parsedURI . getPath ( ) . substring ( prefixPath . length ( ) , parsedURI . getPath ( ) . length ( ) ) ; if ( childPathPart . startsWith ( <str> ) ) { continue ; } if ( childPathPart . equals ( <str> ) | | childPathPart . split ( <str> ) . length > <int> ) { continue ; } String path = parsedURI . getPath ( ) ; int pos = path . lastIndexOf ( <str> ) ; if ( pos < <int> ) { uris . add ( path ) ; } else if ( pos = = path . length ( ) - <int> ) { int start = path . lastIndexOf ( <str> , pos - <int> ) ; if ( start < <int> ) { uris . add ( path . substring ( <int> , pos ) ) ; } else { uris . add ( path . substring ( start + <int> , pos ) ) ; } } else { uris . add ( path . substring ( pos + <int> ) ) ; } } return uris ; } private List < URI > resolveURIs ( URI baseURI , List < String > hrefs ) { List < URI > uris = new ArrayList < URI > ( ) ; for ( String href : hrefs ) { try { uris . add ( baseURI . resolve ( href ) ) ; } catch ( IllegalArgumentException ex ) { LOGGER . debug ( String . format ( <str> , href ) ) ; } } return uris ; } private class AnchorListerHandler extends DefaultHandler { List < String > hrefs = new ArrayList < String > ( ) ; public List < String > getHrefs ( ) { return hrefs ; } public void startElement ( String uri , String localName , String qName , Attributes atts ) throws SAXException { if ( qName . equalsIgnoreCase ( <str> ) ) { final String href = atts . getValue ( <str> ) ; if ( href ! = null ) { hrefs . add ( href ) ; } } } } } 
