package org . jbox2d . dynamics . contacts ; import org . jbox2d . collision . Manifold ; import org . jbox2d . collision . ManifoldPoint ; import org . jbox2d . collision . WorldManifold ; import org . jbox2d . collision . shapes . Shape ; import org . jbox2d . common . Mat22 ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . Body ; import org . jbox2d . dynamics . Fixture ; import org . jbox2d . dynamics . TimeStep ; import org . jbox2d . dynamics . contacts . ContactVelocityConstraint . VelocityConstraintPoint ; public class ContactSolver { public static final boolean DEBUG_SOLVER = false ; public static final float k_errorTol = <float> ; public static final int INITIAL_NUM_CONSTRAINTS = <int> ; public static final float k_maxConditionNumber = <float> ; public TimeStep m_step ; public Position [ ] m_positions ; public Velocity [ ] m_velocities ; public ContactPositionConstraint [ ] m_positionConstraints ; public ContactVelocityConstraint [ ] m_velocityConstraints ; public Contact [ ] m_contacts ; public int m_count ; public ContactSolver ( ) { m_positionConstraints = new ContactPositionConstraint [ INITIAL_NUM_CONSTRAINTS ] ; m_velocityConstraints = new ContactVelocityConstraint [ INITIAL_NUM_CONSTRAINTS ] ; for ( int i = <int> ; i < INITIAL_NUM_CONSTRAINTS ; i + + ) { m_positionConstraints [ i ] = new ContactPositionConstraint ( ) ; m_velocityConstraints [ i ] = new ContactVelocityConstraint ( ) ; } } public final void init ( ContactSolverDef def ) { m_step = def . step ; m_count = def . count ; if ( m_positionConstraints . length < m_count ) { ContactPositionConstraint [ ] old = m_positionConstraints ; m_positionConstraints = new ContactPositionConstraint [ MathUtils . max ( old . length * <int> , m_count ) ] ; System . arraycopy ( old , <int> , m_positionConstraints , <int> , old . length ) ; for ( int i = old . length ; i < m_positionConstraints . length ; i + + ) { m_positionConstraints [ i ] = new ContactPositionConstraint ( ) ; } } if ( m_velocityConstraints . length < m_count ) { ContactVelocityConstraint [ ] old = m_velocityConstraints ; m_velocityConstraints = new ContactVelocityConstraint [ MathUtils . max ( old . length * <int> , m_count ) ] ; System . arraycopy ( old , <int> , m_velocityConstraints , <int> , old . length ) ; for ( int i = old . length ; i < m_velocityConstraints . length ; i + + ) { m_velocityConstraints [ i ] = new ContactVelocityConstraint ( ) ; } } m_positions = def . positions ; m_velocities = def . velocities ; m_contacts = def . contacts ; for ( int i = <int> ; i < m_count ; + + i ) { final Contact contact = m_contacts [ i ] ; final Fixture fixtureA = contact . m_fixtureA ; final Fixture fixtureB = contact . m_fixtureB ; final Shape shapeA = fixtureA . getShape ( ) ; final Shape shapeB = fixtureB . getShape ( ) ; final float radiusA = shapeA . m_radius ; final float radiusB = shapeB . m_radius ; final Body bodyA = fixtureA . getBody ( ) ; final Body bodyB = fixtureB . getBody ( ) ; final Manifold manifold = contact . getManifold ( ) ; int pointCount = manifold . pointCount ; assert ( pointCount > <int> ) ; ContactVelocityConstraint vc = m_velocityConstraints [ i ] ; vc . friction = contact . m_friction ; vc . restitution = contact . m_restitution ; vc . tangentSpeed = contact . m_tangentSpeed ; vc . indexA = bodyA . m_islandIndex ; vc . indexB = bodyB . m_islandIndex ; vc . invMassA = bodyA . m_invMass ; vc . invMassB = bodyB . m_invMass ; vc . invIA = bodyA . m_invI ; vc . invIB = bodyB . m_invI ; vc . contactIndex = i ; vc . pointCount = pointCount ; vc . K . setZero ( ) ; vc . normalMass . setZero ( ) ; ContactPositionConstraint pc = m_positionConstraints [ i ] ; pc . indexA = bodyA . m_islandIndex ; pc . indexB = bodyB . m_islandIndex ; pc . invMassA = bodyA . m_invMass ; pc . invMassB = bodyB . m_invMass ; pc . localCenterA . set ( bodyA . m_sweep . localCenter ) ; pc . localCenterB . set ( bodyB . m_sweep . localCenter ) ; pc . invIA = bodyA . m_invI ; pc . invIB = bodyB . m_invI ; pc . localNormal . set ( manifold . localNormal ) ; pc . localPoint . set ( manifold . localPoint ) ; pc . pointCount = pointCount ; pc . radiusA = radiusA ; pc . radiusB = radiusB ; pc . type = manifold . type ; for ( int j = <int> ; j < pointCount ; j + + ) { ManifoldPoint cp = manifold . points [ j ] ; VelocityConstraintPoint vcp = vc . points [ j ] ; if ( m_step . warmStarting ) { vcp . normalImpulse = m_step . dtRatio * cp . normalImpulse ; vcp . tangentImpulse = m_step . dtRatio * cp . tangentImpulse ; } else { vcp . normalImpulse = <int> ; vcp . tangentImpulse = <int> ; } vcp . rA . setZero ( ) ; vcp . rB . setZero ( ) ; vcp . normalMass = <int> ; vcp . tangentMass = <int> ; vcp . velocityBias = <int> ; pc . localPoints [ j ] . x = cp . localPoint . x ; pc . localPoints [ j ] . y = cp . localPoint . y ; } } } public void warmStart ( ) { for ( int i = <int> ; i < m_count ; + + i ) { final ContactVelocityConstraint vc = m_velocityConstraints [ i ] ; int indexA = vc . indexA ; int indexB = vc . indexB ; float mA = vc . invMassA ; float iA = vc . invIA ; float mB = vc . invMassB ; float iB = vc . invIB ; int pointCount = vc . pointCount ; Vec2 vA = m_velocities [ indexA ] . v ; float wA = m_velocities [ indexA ] . w ; Vec2 vB = m_velocities [ indexB ] . v ; float wB = m_velocities [ indexB ] . w ; Vec2 normal = vc . normal ; float tangentx = <float> * normal . y ; float tangenty = - <float> * normal . x ; for ( int j = <int> ; j < pointCount ; + + j ) { VelocityConstraintPoint vcp = vc . points [ j ] ; float Px = tangentx * vcp . tangentImpulse + normal . x * vcp . normalImpulse ; float Py = tangenty * vcp . tangentImpulse + normal . y * vcp . normalImpulse ; wA - = iA * ( vcp . rA . x * Py - vcp . rA . y * Px ) ; vA . x - = Px * mA ; vA . y - = Py * mA ; wB + = iB * ( vcp . rB . x * Py - vcp . rB . y * Px ) ; vB . x + = Px * mB ; vB . y + = Py * mB ; } m_velocities [ indexA ] . w = wA ; m_velocities [ indexB ] . w = wB ; } } private final Transform xfA = new Transform ( ) ; private final Transform xfB = new Transform ( ) ; private final WorldManifold worldManifold = new WorldManifold ( ) ; public final void initializeVelocityConstraints ( ) { for ( int i = <int> ; i < m_count ; + + i ) { ContactVelocityConstraint vc = m_velocityConstraints [ i ] ; ContactPositionConstraint pc = m_positionConstraints [ i ] ; float radiusA = pc . radiusA ; float radiusB = pc . radiusB ; Manifold manifold = m_contacts [ vc . contactIndex ] . getManifold ( ) ; int indexA = vc . indexA ; int indexB = vc . indexB ; float mA = vc . invMassA ; float mB = vc . invMassB ; float iA = vc . invIA ; float iB = vc . invIB ; Vec2 localCenterA = pc . localCenterA ; Vec2 localCenterB = pc . localCenterB ; Vec2 cA = m_positions [ indexA ] . c ; float aA = m_positions [ indexA ] . a ; Vec2 vA = m_velocities [ indexA ] . v ; float wA = m_velocities [ indexA ] . w ; Vec2 cB = m_positions [ indexB ] . c ; float aB = m_positions [ indexB ] . a ; Vec2 vB = m_velocities [ indexB ] . v ; float wB = m_velocities [ indexB ] . w ; assert ( manifold . pointCount > <int> ) ; final Rot xfAq = xfA . q ; final Rot xfBq = xfB . q ; xfAq . set ( aA ) ; xfBq . set ( aB ) ; xfA . p . x = cA . x - ( xfAq . c * localCenterA . x - xfAq . s * localCenterA . y ) ; xfA . p . y = cA . y - ( xfAq . s * localCenterA . x + xfAq . c * localCenterA . y ) ; xfB . p . x = cB . x - ( xfBq . c * localCenterB . x - xfBq . s * localCenterB . y ) ; xfB . p . y = cB . y - ( xfBq . s * localCenterB . x + xfBq . c * localCenterB . y ) ; worldManifold . initialize ( manifold , xfA , radiusA , xfB , radiusB ) ; final Vec2 vcnormal = vc . normal ; vcnormal . x = worldManifold . normal . x ; vcnormal . y = worldManifold . normal . y ; int pointCount = vc . pointCount ; for ( int j = <int> ; j < pointCount ; + + j ) { VelocityConstraintPoint vcp = vc . points [ j ] ; Vec2 wmPj = worldManifold . points [ j ] ; final Vec2 vcprA = vcp . rA ; final Vec2 vcprB = vcp . rB ; vcprA . x = wmPj . x - cA . x ; vcprA . y = wmPj . y - cA . y ; vcprB . x = wmPj . x - cB . x ; vcprB . y = wmPj . y - cB . y ; float rnA = vcprA . x * vcnormal . y - vcprA . y * vcnormal . x ; float rnB = vcprB . x * vcnormal . y - vcprB . y * vcnormal . x ; float kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB ; vcp . normalMass = kNormal > <float> ? <float> / kNormal : <float> ; float tangentx = <float> * vcnormal . y ; float tangenty = - <float> * vcnormal . x ; float rtA = vcprA . x * tangenty - vcprA . y * tangentx ; float rtB = vcprB . x * tangenty - vcprB . y * tangentx ; float kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB ; vcp . tangentMass = kTangent > <float> ? <float> / kTangent : <float> ; vcp . velocityBias = <float> ; float tempx = vB . x + - wB * vcprB . y - vA . x - ( - wA * vcprA . y ) ; float tempy = vB . y + wB * vcprB . x - vA . y - ( wA * vcprA . x ) ; float vRel = vcnormal . x * tempx + vcnormal . y * tempy ; if ( vRel < - Settings . velocityThreshold ) { vcp . velocityBias = - vc . restitution * vRel ; } } if ( vc . pointCount = = <int> ) { VelocityConstraintPoint vcp1 = vc . points [ <int> ] ; VelocityConstraintPoint vcp2 = vc . points [ <int> ] ; float rn1A = vcp1 . rA . x * vcnormal . y - vcp1 . rA . y * vcnormal . x ; float rn1B = vcp1 . rB . x * vcnormal . y - vcp1 . rB . y * vcnormal . x ; float rn2A = vcp2 . rA . x * vcnormal . y - vcp2 . rA . y * vcnormal . x ; float rn2B = vcp2 . rB . x * vcnormal . y - vcp2 . rB . y * vcnormal . x ; float k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B ; float k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B ; float k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B ; if ( k11 * k11 < k_maxConditionNumber * ( k11 * k22 - k12 * k12 ) ) { vc . K . ex . x = k11 ; vc . K . ex . y = k12 ; vc . K . ey . x = k12 ; vc . K . ey . y = k22 ; vc . K . invertToOut ( vc . normalMass ) ; } else { vc . pointCount = <int> ; } } } } public final void solveVelocityConstraints ( ) { for ( int i = <int> ; i < m_count ; + + i ) { final ContactVelocityConstraint vc = m_velocityConstraints [ i ] ; int indexA = vc . indexA ; int indexB = vc . indexB ; float mA = vc . invMassA ; float mB = vc . invMassB ; float iA = vc . invIA ; float iB = vc . invIB ; int pointCount = vc . pointCount ; Vec2 vA = m_velocities [ indexA ] . v ; float wA = m_velocities [ indexA ] . w ; Vec2 vB = m_velocities [ indexB ] . v ; float wB = m_velocities [ indexB ] . w ; Vec2 normal = vc . normal ; final float normalx = normal . x ; final float normaly = normal . y ; float tangentx = <float> * vc . normal . y ; float tangenty = - <float> * vc . normal . x ; final float friction = vc . friction ; assert ( pointCount = = <int> | | pointCount = = <int> ) ; for ( int j = <int> ; j < pointCount ; + + j ) { final VelocityConstraintPoint vcp = vc . points [ j ] ; final Vec2 a = vcp . rA ; float dvx = - wB * vcp . rB . y + vB . x - vA . x + wA * a . y ; float dvy = wB * vcp . rB . x + vB . y - vA . y - wA * a . x ; final float vt = dvx * tangentx + dvy * tangenty - vc . tangentSpeed ; float lambda = vcp . tangentMass * ( - vt ) ; final float maxFriction = friction * vcp . normalImpulse ; final float newImpulse = MathUtils . clamp ( vcp . tangentImpulse + lambda , - maxFriction , maxFriction ) ; lambda = newImpulse - vcp . tangentImpulse ; vcp . tangentImpulse = newImpulse ; final float Px = tangentx * lambda ; final float Py = tangenty * lambda ; vA . x - = Px * mA ; vA . y - = Py * mA ; wA - = iA * ( vcp . rA . x * Py - vcp . rA . y * Px ) ; vB . x + = Px * mB ; vB . y + = Py * mB ; wB + = iB * ( vcp . rB . x * Py - vcp . rB . y * Px ) ; } if ( vc . pointCount = = <int> ) { final VelocityConstraintPoint vcp = vc . points [ <int> ] ; float dvx = - wB * vcp . rB . y + vB . x - vA . x + wA * vcp . rA . y ; float dvy = wB * vcp . rB . x + vB . y - vA . y - wA * vcp . rA . x ; final float vn = dvx * normalx + dvy * normaly ; float lambda = - vcp . normalMass * ( vn - vcp . velocityBias ) ; float a = vcp . normalImpulse + lambda ; final float newImpulse = ( a > <float> ? a : <float> ) ; lambda = newImpulse - vcp . normalImpulse ; vcp . normalImpulse = newImpulse ; float Px = normalx * lambda ; float Py = normaly * lambda ; vA . x - = Px * mA ; vA . y - = Py * mA ; wA - = iA * ( vcp . rA . x * Py - vcp . rA . y * Px ) ; vB . x + = Px * mB ; vB . y + = Py * mB ; wB + = iB * ( vcp . rB . x * Py - vcp . rB . y * Px ) ; } else { final VelocityConstraintPoint cp1 = vc . points [ <int> ] ; final VelocityConstraintPoint cp2 = vc . points [ <int> ] ; final Vec2 cp1rA = cp1 . rA ; final Vec2 cp1rB = cp1 . rB ; final Vec2 cp2rA = cp2 . rA ; final Vec2 cp2rB = cp2 . rB ; float ax = cp1 . normalImpulse ; float ay = cp2 . normalImpulse ; assert ( ax > = <float> & & ay > = <float> ) ; float dv1x = - wB * cp1rB . y + vB . x - vA . x + wA * cp1rA . y ; float dv1y = wB * cp1rB . x + vB . y - vA . y - wA * cp1rA . x ; float dv2x = - wB * cp2rB . y + vB . x - vA . x + wA * cp2rA . y ; float dv2y = wB * cp2rB . x + vB . y - vA . y - wA * cp2rA . x ; float vn1 = dv1x * normalx + dv1y * normaly ; float vn2 = dv2x * normalx + dv2y * normaly ; float bx = vn1 - cp1 . velocityBias ; float by = vn2 - cp2 . velocityBias ; Mat22 R = vc . K ; bx - = R . ex . x * ax + R . ey . x * ay ; by - = R . ex . y * ax + R . ey . y * ay ; for ( ; ; ) { Mat22 R1 = vc . normalMass ; float xx = R1 . ex . x * bx + R1 . ey . x * by ; float xy = R1 . ex . y * bx + R1 . ey . y * by ; xx * = - <int> ; xy * = - <int> ; if ( xx > = <float> & & xy > = <float> ) { float dx = xx - ax ; float dy = xy - ay ; float P1x = dx * normalx ; float P1y = dx * normaly ; float P2x = dy * normalx ; float P2y = dy * normaly ; vA . x - = mA * ( P1x + P2x ) ; vA . y - = mA * ( P1y + P2y ) ; vB . x + = mB * ( P1x + P2x ) ; vB . y + = mB * ( P1y + P2y ) ; wA - = iA * ( cp1rA . x * P1y - cp1rA . y * P1x + ( cp2rA . x * P2y - cp2rA . y * P2x ) ) ; wB + = iB * ( cp1rB . x * P1y - cp1rB . y * P1x + ( cp2rB . x * P2y - cp2rB . y * P2x ) ) ; cp1 . normalImpulse = xx ; cp2 . normalImpulse = xy ; if ( DEBUG_SOLVER ) { Vec2 dv1 = vB . add ( Vec2 . cross ( wB , cp1rB ) . subLocal ( vA ) . subLocal ( Vec2 . cross ( wA , cp1rA ) ) ) ; Vec2 dv2 = vB . add ( Vec2 . cross ( wB , cp2rB ) . subLocal ( vA ) . subLocal ( Vec2 . cross ( wA , cp2rA ) ) ) ; vn1 = Vec2 . dot ( dv1 , normal ) ; vn2 = Vec2 . dot ( dv2 , normal ) ; assert ( MathUtils . abs ( vn1 - cp1 . velocityBias ) < k_errorTol ) ; assert ( MathUtils . abs ( vn2 - cp2 . velocityBias ) < k_errorTol ) ; } break ; } xx = - cp1 . normalMass * bx ; xy = <float> ; vn1 = <float> ; vn2 = vc . K . ex . y * xx + by ; if ( xx > = <float> & & vn2 > = <float> ) { float dx = xx - ax ; float dy = xy - ay ; float P1x = normalx * dx ; float P1y = normaly * dx ; float P2x = normalx * dy ; float P2y = normaly * dy ; vA . x - = mA * ( P1x + P2x ) ; vA . y - = mA * ( P1y + P2y ) ; vB . x + = mB * ( P1x + P2x ) ; vB . y + = mB * ( P1y + P2y ) ; wA - = iA * ( cp1rA . x * P1y - cp1rA . y * P1x + ( cp2rA . x * P2y - cp2rA . y * P2x ) ) ; wB + = iB * ( cp1rB . x * P1y - cp1rB . y * P1x + ( cp2rB . x * P2y - cp2rB . y * P2x ) ) ; cp1 . normalImpulse = xx ; cp2 . normalImpulse = xy ; if ( DEBUG_SOLVER ) { Vec2 dv1 = vB . add ( Vec2 . cross ( wB , cp1rB ) . subLocal ( vA ) . subLocal ( Vec2 . cross ( wA , cp1rA ) ) ) ; vn1 = Vec2 . dot ( dv1 , normal ) ; assert ( MathUtils . abs ( vn1 - cp1 . velocityBias ) < k_errorTol ) ; } break ; } xx = <float> ; xy = - cp2 . normalMass * by ; vn1 = vc . K . ey . x * xy + bx ; vn2 = <float> ; if ( xy > = <float> & & vn1 > = <float> ) { float dx = xx - ax ; float dy = xy - ay ; float P1x = normalx * dx ; float P1y = normaly * dx ; float P2x = normalx * dy ; float P2y = normaly * dy ; vA . x - = mA * ( P1x + P2x ) ; vA . y - = mA * ( P1y + P2y ) ; vB . x + = mB * ( P1x + P2x ) ; vB . y + = mB * ( P1y + P2y ) ; wA - = iA * ( cp1rA . x * P1y - cp1rA . y * P1x + ( cp2rA . x * P2y - cp2rA . y * P2x ) ) ; wB + = iB * ( cp1rB . x * P1y - cp1rB . y * P1x + ( cp2rB . x * P2y - cp2rB . y * P2x ) ) ; cp1 . normalImpulse = xx ; cp2 . normalImpulse = xy ; if ( DEBUG_SOLVER ) { Vec2 dv2 = vB . add ( Vec2 . cross ( wB , cp2rB ) . subLocal ( vA ) . subLocal ( Vec2 . cross ( wA , cp2rA ) ) ) ; vn2 = Vec2 . dot ( dv2 , normal ) ; assert ( MathUtils . abs ( vn2 - cp2 . velocityBias ) < k_errorTol ) ; } break ; } xx = <float> ; xy = <float> ; vn1 = bx ; vn2 = by ; if ( vn1 > = <float> & & vn2 > = <float> ) { float dx = xx - ax ; float dy = xy - ay ; float P1x = normalx * dx ; float P1y = normaly * dx ; float P2x = normalx * dy ; float P2y = normaly * dy ; vA . x - = mA * ( P1x + P2x ) ; vA . y - = mA * ( P1y + P2y ) ; vB . x + = mB * ( P1x + P2x ) ; vB . y + = mB * ( P1y + P2y ) ; wA - = iA * ( cp1rA . x * P1y - cp1rA . y * P1x + ( cp2rA . x * P2y - cp2rA . y * P2x ) ) ; wB + = iB * ( cp1rB . x * P1y - cp1rB . y * P1x + ( cp2rB . x * P2y - cp2rB . y * P2x ) ) ; cp1 . normalImpulse = xx ; cp2 . normalImpulse = xy ; break ; } break ; } } m_velocities [ indexA ] . w = wA ; m_velocities [ indexB ] . w = wB ; } } public void storeImpulses ( ) { for ( int i = <int> ; i < m_count ; i + + ) { final ContactVelocityConstraint vc = m_velocityConstraints [ i ] ; final Manifold manifold = m_contacts [ vc . contactIndex ] . getManifold ( ) ; for ( int j = <int> ; j < vc . pointCount ; j + + ) { manifold . points [ j ] . normalImpulse = vc . points [ j ] . normalImpulse ; manifold . points [ j ] . tangentImpulse = vc . points [ j ] . tangentImpulse ; } } } private final PositionSolverManifold psolver = new PositionSolverManifold ( ) ; public final boolean solvePositionConstraints ( ) { float minSeparation = <float> ; for ( int i = <int> ; i < m_count ; + + i ) { ContactPositionConstraint pc = m_positionConstraints [ i ] ; int indexA = pc . indexA ; int indexB = pc . indexB ; float mA = pc . invMassA ; float iA = pc . invIA ; Vec2 localCenterA = pc . localCenterA ; final float localCenterAx = localCenterA . x ; final float localCenterAy = localCenterA . y ; float mB = pc . invMassB ; float iB = pc . invIB ; Vec2 localCenterB = pc . localCenterB ; final float localCenterBx = localCenterB . x ; final float localCenterBy = localCenterB . y ; int pointCount = pc . pointCount ; Vec2 cA = m_positions [ indexA ] . c ; float aA = m_positions [ indexA ] . a ; Vec2 cB = m_positions [ indexB ] . c ; float aB = m_positions [ indexB ] . a ; for ( int j = <int> ; j < pointCount ; + + j ) { final Rot xfAq = xfA . q ; final Rot xfBq = xfB . q ; xfAq . set ( aA ) ; xfBq . set ( aB ) ; xfA . p . x = cA . x - xfAq . c * localCenterAx + xfAq . s * localCenterAy ; xfA . p . y = cA . y - xfAq . s * localCenterAx - xfAq . c * localCenterAy ; xfB . p . x = cB . x - xfBq . c * localCenterBx + xfBq . s * localCenterBy ; xfB . p . y = cB . y - xfBq . s * localCenterBx - xfBq . c * localCenterBy ; final PositionSolverManifold psm = psolver ; psm . initialize ( pc , xfA , xfB , j ) ; final Vec2 normal = psm . normal ; final Vec2 point = psm . point ; final float separation = psm . separation ; float rAx = point . x - cA . x ; float rAy = point . y - cA . y ; float rBx = point . x - cB . x ; float rBy = point . y - cB . y ; minSeparation = MathUtils . min ( minSeparation , separation ) ; final float C = MathUtils . clamp ( Settings . baumgarte * ( separation + Settings . linearSlop ) , - Settings . maxLinearCorrection , <float> ) ; final float rnA = rAx * normal . y - rAy * normal . x ; final float rnB = rBx * normal . y - rBy * normal . x ; final float K = mA + mB + iA * rnA * rnA + iB * rnB * rnB ; final float impulse = K > <float> ? - C / K : <float> ; float Px = normal . x * impulse ; float Py = normal . y * impulse ; cA . x - = Px * mA ; cA . y - = Py * mA ; aA - = iA * ( rAx * Py - rAy * Px ) ; cB . x + = Px * mB ; cB . y + = Py * mB ; aB + = iB * ( rBx * Py - rBy * Px ) ; } m_positions [ indexA ] . a = aA ; m_positions [ indexB ] . a = aB ; } return minSeparation > = - <float> * Settings . linearSlop ; } public boolean solveTOIPositionConstraints ( int toiIndexA , int toiIndexB ) { float minSeparation = <float> ; for ( int i = <int> ; i < m_count ; + + i ) { ContactPositionConstraint pc = m_positionConstraints [ i ] ; int indexA = pc . indexA ; int indexB = pc . indexB ; Vec2 localCenterA = pc . localCenterA ; Vec2 localCenterB = pc . localCenterB ; final float localCenterAx = localCenterA . x ; final float localCenterAy = localCenterA . y ; final float localCenterBx = localCenterB . x ; final float localCenterBy = localCenterB . y ; int pointCount = pc . pointCount ; float mA = <float> ; float iA = <float> ; if ( indexA = = toiIndexA | | indexA = = toiIndexB ) { mA = pc . invMassA ; iA = pc . invIA ; } float mB = <float> ; float iB = <float> ; if ( indexB = = toiIndexA | | indexB = = toiIndexB ) { mB = pc . invMassB ; iB = pc . invIB ; } Vec2 cA = m_positions [ indexA ] . c ; float aA = m_positions [ indexA ] . a ; Vec2 cB = m_positions [ indexB ] . c ; float aB = m_positions [ indexB ] . a ; for ( int j = <int> ; j < pointCount ; + + j ) { final Rot xfAq = xfA . q ; final Rot xfBq = xfB . q ; xfAq . set ( aA ) ; xfBq . set ( aB ) ; xfA . p . x = cA . x - xfAq . c * localCenterAx + xfAq . s * localCenterAy ; xfA . p . y = cA . y - xfAq . s * localCenterAx - xfAq . c * localCenterAy ; xfB . p . x = cB . x - xfBq . c * localCenterBx + xfBq . s * localCenterBy ; xfB . p . y = cB . y - xfBq . s * localCenterBx - xfBq . c * localCenterBy ; final PositionSolverManifold psm = psolver ; psm . initialize ( pc , xfA , xfB , j ) ; Vec2 normal = psm . normal ; Vec2 point = psm . point ; float separation = psm . separation ; float rAx = point . x - cA . x ; float rAy = point . y - cA . y ; float rBx = point . x - cB . x ; float rBy = point . y - cB . y ; minSeparation = MathUtils . min ( minSeparation , separation ) ; float C = MathUtils . clamp ( Settings . toiBaugarte * ( separation + Settings . linearSlop ) , - Settings . maxLinearCorrection , <float> ) ; float rnA = rAx * normal . y - rAy * normal . x ; float rnB = rBx * normal . y - rBy * normal . x ; float K = mA + mB + iA * rnA * rnA + iB * rnB * rnB ; float impulse = K > <float> ? - C / K : <float> ; float Px = normal . x * impulse ; float Py = normal . y * impulse ; cA . x - = Px * mA ; cA . y - = Py * mA ; aA - = iA * ( rAx * Py - rAy * Px ) ; cB . x + = Px * mB ; cB . y + = Py * mB ; aB + = iB * ( rBx * Py - rBy * Px ) ; } m_positions [ indexA ] . a = aA ; m_positions [ indexB ] . a = aB ; } return minSeparation > = - <float> * Settings . linearSlop ; } public static class ContactSolverDef { public TimeStep step ; public Contact [ ] contacts ; public int count ; public Position [ ] positions ; public Velocity [ ] velocities ; } } class PositionSolverManifold { public final Vec2 normal = new Vec2 ( ) ; public final Vec2 point = new Vec2 ( ) ; public float separation ; public void initialize ( ContactPositionConstraint pc , Transform xfA , Transform xfB , int index ) { assert ( pc . pointCount > <int> ) ; final Rot xfAq = xfA . q ; final Rot xfBq = xfB . q ; final Vec2 pcLocalPointsI = pc . localPoints [ index ] ; switch ( pc . type ) { case CIRCLES : { final Vec2 plocalPoint = pc . localPoint ; final Vec2 pLocalPoints0 = pc . localPoints [ <int> ] ; final float pointAx = ( xfAq . c * plocalPoint . x - xfAq . s * plocalPoint . y ) + xfA . p . x ; final float pointAy = ( xfAq . s * plocalPoint . x + xfAq . c * plocalPoint . y ) + xfA . p . y ; final float pointBx = ( xfBq . c * pLocalPoints0 . x - xfBq . s * pLocalPoints0 . y ) + xfB . p . x ; final float pointBy = ( xfBq . s * pLocalPoints0 . x + xfBq . c * pLocalPoints0 . y ) + xfB . p . y ; normal . x = pointBx - pointAx ; normal . y = pointBy - pointAy ; normal . normalize ( ) ; point . x = ( pointAx + pointBx ) * <float> ; point . y = ( pointAy + pointBy ) * <float> ; final float tempx = pointBx - pointAx ; final float tempy = pointBy - pointAy ; separation = tempx * normal . x + tempy * normal . y - pc . radiusA - pc . radiusB ; break ; } case FACE_A : { final Vec2 pcLocalNormal = pc . localNormal ; final Vec2 pcLocalPoint = pc . localPoint ; normal . x = xfAq . c * pcLocalNormal . x - xfAq . s * pcLocalNormal . y ; normal . y = xfAq . s * pcLocalNormal . x + xfAq . c * pcLocalNormal . y ; final float planePointx = ( xfAq . c * pcLocalPoint . x - xfAq . s * pcLocalPoint . y ) + xfA . p . x ; final float planePointy = ( xfAq . s * pcLocalPoint . x + xfAq . c * pcLocalPoint . y ) + xfA . p . y ; final float clipPointx = ( xfBq . c * pcLocalPointsI . x - xfBq . s * pcLocalPointsI . y ) + xfB . p . x ; final float clipPointy = ( xfBq . s * pcLocalPointsI . x + xfBq . c * pcLocalPointsI . y ) + xfB . p . y ; final float tempx = clipPointx - planePointx ; final float tempy = clipPointy - planePointy ; separation = tempx * normal . x + tempy * normal . y - pc . radiusA - pc . radiusB ; point . x = clipPointx ; point . y = clipPointy ; break ; } case FACE_B : { final Vec2 pcLocalNormal = pc . localNormal ; final Vec2 pcLocalPoint = pc . localPoint ; normal . x = xfBq . c * pcLocalNormal . x - xfBq . s * pcLocalNormal . y ; normal . y = xfBq . s * pcLocalNormal . x + xfBq . c * pcLocalNormal . y ; final float planePointx = ( xfBq . c * pcLocalPoint . x - xfBq . s * pcLocalPoint . y ) + xfB . p . x ; final float planePointy = ( xfBq . s * pcLocalPoint . x + xfBq . c * pcLocalPoint . y ) + xfB . p . y ; final float clipPointx = ( xfAq . c * pcLocalPointsI . x - xfAq . s * pcLocalPointsI . y ) + xfA . p . x ; final float clipPointy = ( xfAq . s * pcLocalPointsI . x + xfAq . c * pcLocalPointsI . y ) + xfA . p . y ; final float tempx = clipPointx - planePointx ; final float tempy = clipPointy - planePointy ; separation = tempx * normal . x + tempy * normal . y - pc . radiusA - pc . radiusB ; point . x = clipPointx ; point . y = clipPointy ; normal . x * = - <int> ; normal . y * = - <int> ; } break ; } } } 
