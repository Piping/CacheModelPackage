package org . eclipse . debug . examples . core . pda . model ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . core . model . IStackFrame ; import org . eclipse . debug . core . model . IThread ; import org . eclipse . debug . core . model . IValue ; import org . eclipse . debug . core . model . IVariable ; import org . eclipse . debug . examples . core . pda . protocol . PDADataCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDADropFrameCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAListResult ; import org . eclipse . debug . examples . core . pda . protocol . PDANoSuchLabelEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAPopDataCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAPushDataCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAResumeCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAResumedEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDARunControlEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAStackCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDAStackCommandResult ; import org . eclipse . debug . examples . core . pda . protocol . PDAStepCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDASuspendCommand ; import org . eclipse . debug . examples . core . pda . protocol . PDASuspendedEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAUnimplementedInstructionEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAVMResumedEvent ; import org . eclipse . debug . examples . core . pda . protocol . PDAVMSuspendedEvent ; public class PDAThread extends PDADebugElement implements IThread , IPDAEventListener { private final int fThreadId ; private IBreakpoint fBreakpoint ; private boolean fStepping = false ; private boolean fSuspended = false ; private String fErrorEvent ; private Map < IStackFrame , IVariable [ ] > fVariables = Collections . synchronizedMap ( new HashMap < IStackFrame , IVariable [ ] > ( ) ) ; public PDAThread ( PDADebugTarget target , int threadId ) { super ( target ) ; fThreadId = threadId ; } void start ( ) { fireCreationEvent ( ) ; getPDADebugTarget ( ) . addEventListener ( this ) ; } void exit ( ) { getPDADebugTarget ( ) . removeEventListener ( this ) ; fireTerminateEvent ( ) ; } @Override public IStackFrame [ ] getStackFrames ( ) throws DebugException { if ( isSuspended ( ) ) { PDAStackCommandResult result = ( PDAStackCommandResult ) sendCommand ( new PDAStackCommand ( fThreadId ) ) ; IStackFrame [ ] frames = new IStackFrame [ result . fFrames . length ] ; for ( int i = <int> ; i < result . fFrames . length ; i + + ) { frames [ frames . length - i - <int> ] = new PDAStackFrame ( this , result . fFrames [ i ] , i ) ; } return frames ; } return new IStackFrame [ <int> ] ; } @Override public boolean hasStackFrames ( ) throws DebugException { return isSuspended ( ) ; } @Override public int getPriority ( ) throws DebugException { return <int> ; } @Override public IStackFrame getTopStackFrame ( ) throws DebugException { IStackFrame [ ] frames = getStackFrames ( ) ; if ( frames . length > <int> ) { return frames [ <int> ] ; } return null ; } @Override public String getName ( ) { return <str> ; } @Override public synchronized IBreakpoint [ ] getBreakpoints ( ) { if ( fBreakpoint = = null ) { return new IBreakpoint [ <int> ] ; } return new IBreakpoint [ ] { fBreakpoint } ; } public synchronized void suspendedBy ( IBreakpoint breakpoint ) { fBreakpoint = breakpoint ; suspended ( DebugEvent . BREAKPOINT ) ; } @Override public boolean canResume ( ) { return isSuspended ( ) & & ! getDebugTarget ( ) . isSuspended ( ) ; } @Override public boolean canSuspend ( ) { return ! isSuspended ( ) ; } @Override public boolean isSuspended ( ) { if ( getDebugTarget ( ) . isTerminated ( ) ) { return false ; } if ( getDebugTarget ( ) . isSuspended ( ) ) { return true ; } synchronized ( this ) { return fSuspended ; } } @Override public void resume ( ) throws DebugException { sendCommand ( new PDAResumeCommand ( fThreadId ) ) ; } @Override public void suspend ( ) throws DebugException { sendCommand ( new PDASuspendCommand ( fThreadId ) ) ; } @Override public boolean canStepInto ( ) { return false ; } @Override public boolean canStepOver ( ) { return isSuspended ( ) ; } @Override public boolean canStepReturn ( ) { return false ; } @Override public boolean isStepping ( ) { return fStepping ; } @Override public void stepInto ( ) throws DebugException { } @Override public void stepOver ( ) throws DebugException { sendCommand ( new PDAStepCommand ( fThreadId ) ) ; } @Override public void stepReturn ( ) throws DebugException { } @Override public boolean canTerminate ( ) { return ! isTerminated ( ) ; } @Override public boolean isTerminated ( ) { return getDebugTarget ( ) . isTerminated ( ) ; } @Override public void terminate ( ) throws DebugException { getDebugTarget ( ) . terminate ( ) ; } private synchronized void setStepping ( boolean stepping ) { fStepping = stepping ; } private synchronized void setSuspended ( boolean suspended ) { fSuspended = suspended ; } private synchronized void setError ( String event ) { fErrorEvent = event ; } public Object getError ( ) { return fErrorEvent ; } @Override public void handleEvent ( PDAEvent _event ) { if ( _event instanceof PDARunControlEvent & & fThreadId = = ( ( PDARunControlEvent ) _event ) . fThreadId ) { PDARunControlEvent event = ( PDARunControlEvent ) _event ; fBreakpoint = null ; setStepping ( false ) ; if ( event instanceof PDAResumedEvent | | event instanceof PDAVMResumedEvent ) { setSuspended ( false ) ; if ( <str> . equals ( event . fReason ) ) { setStepping ( true ) ; resumed ( DebugEvent . STEP_OVER ) ; } else if ( <str> . equals ( event . fReason ) ) { resumed ( DebugEvent . CLIENT_REQUEST ) ; } else if ( <str> . equals ( event . fReason ) ) { resumed ( DebugEvent . STEP_RETURN ) ; } } else if ( event instanceof PDASuspendedEvent | | event instanceof PDAVMSuspendedEvent ) { setSuspended ( true ) ; if ( <str> . equals ( event . fReason ) ) { suspended ( DebugEvent . CLIENT_REQUEST ) ; } else if ( <str> . equals ( event . fReason ) ) { suspended ( DebugEvent . STEP_END ) ; } else if ( <str> . equals ( event . fReason ) & & getError ( ) ! = null ) { exceptionHit ( ) ; } else if ( <str> . equals ( event . fReason ) ) { suspended ( DebugEvent . STEP_END ) ; } } else if ( _event instanceof PDANoSuchLabelEvent | | _event instanceof PDAUnimplementedInstructionEvent ) { setError ( event . fMessage ) ; } } } private void resumed ( int detail ) { setError ( null ) ; fVariables . clear ( ) ; fireResumeEvent ( detail ) ; } private void suspended ( int detail ) { fireSuspendEvent ( detail ) ; } private void exceptionHit ( ) { suspended ( DebugEvent . BREAKPOINT ) ; } protected void setVariables ( IStackFrame frame , IVariable [ ] variables ) { synchronized ( fVariables ) { fVariables . put ( frame , variables ) ; } } protected IVariable [ ] getVariables ( IStackFrame frame ) { synchronized ( fVariables ) { IVariable [ ] variables = fVariables . get ( frame ) ; if ( variables = = null ) { return new IVariable [ <int> ] ; } return variables ; } } public void popFrame ( ) throws DebugException { sendCommand ( new PDADropFrameCommand ( fThreadId ) ) ; } public boolean canPopFrame ( ) { try { return getStackFrames ( ) . length > <int> ; } catch ( DebugException e ) { } return false ; } public IValue [ ] getDataStack ( ) throws DebugException { PDAListResult result = ( PDAListResult ) sendCommand ( new PDADataCommand ( fThreadId ) ) ; if ( result . fValues . length > <int> ) { IValue [ ] values = new IValue [ result . fValues . length ] ; for ( int i = <int> ; i < result . fValues . length ; i + + ) { values [ values . length - i - <int> ] = new PDAStackValue ( this , result . fValues [ i ] , i ) ; } return values ; } return new IValue [ <int> ] ; } public boolean canPopData ( ) { try { return ! isTerminated ( ) & & isSuspended ( ) & & getDataStack ( ) . length > <int> ; } catch ( DebugException e ) { } return false ; } public IValue popData ( ) throws DebugException { IValue [ ] dataStack = getDataStack ( ) ; if ( dataStack . length > <int> ) { sendCommand ( new PDAPopDataCommand ( fThreadId ) ) ; return dataStack [ <int> ] ; } requestFailed ( <str> , null ) ; return null ; } public boolean canPushData ( ) { return ! isTerminated ( ) & & isSuspended ( ) ; } public void pushData ( String value ) throws DebugException { sendCommand ( new PDAPushDataCommand ( fThreadId , value ) ) ; } public int getIdentifier ( ) { return fThreadId ; } } 
