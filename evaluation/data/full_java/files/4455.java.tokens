package org . eclipse . debug . internal . ui . viewers . provisional ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . internal . ui . viewers . AsynchronousSchedulingRuleFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; public abstract class AsynchronousContentAdapter implements IAsynchronousContentAdapter { protected static final Object [ ] EMPTY = new Object [ <int> ] ; @Override public void retrieveChildren ( final Object parent , final IPresentationContext context , final IChildrenRequestMonitor result ) { Job job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( ! monitor . isCanceled ( ) ) { computeChildren ( parent , context , result ) ; } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . setRule ( getRetrieveChildrenRule ( parent , context ) ) ; job . schedule ( ) ; } protected ISchedulingRule getRetrieveChildrenRule ( Object parent , IPresentationContext context ) { return AsynchronousSchedulingRuleFactory . getDefault ( ) . newSerialPerObjectRule ( context ) ; } @Override public void isContainer ( final Object element , final IPresentationContext context , final IContainerRequestMonitor result ) { Job job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( ! monitor . isCanceled ( ) ) { computeIsContainer ( element , context , result ) ; } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . setRule ( getIsContainerRule ( element , context ) ) ; job . schedule ( ) ; } protected ISchedulingRule getIsContainerRule ( Object parent , IPresentationContext context ) { return AsynchronousSchedulingRuleFactory . getDefault ( ) . newSerialPerObjectRule ( context ) ; } protected void computeChildren ( Object parent , IPresentationContext context , IChildrenRequestMonitor monitor ) { if ( ! monitor . isCanceled ( ) ) { IStatus status = Status . OK_STATUS ; try { if ( supportsContext ( context ) ) { monitor . addChildren ( getChildren ( parent , context ) ) ; } } catch ( CoreException e ) { status = e . getStatus ( ) ; } monitor . setStatus ( status ) ; monitor . done ( ) ; } } protected void computeIsContainer ( Object parent , IPresentationContext context , IContainerRequestMonitor monitor ) { if ( ! monitor . isCanceled ( ) ) { IStatus status = Status . OK_STATUS ; try { monitor . setIsContainer ( hasChildren ( parent , context ) ) ; } catch ( CoreException e ) { status = e . getStatus ( ) ; } monitor . setStatus ( status ) ; monitor . done ( ) ; } } protected abstract Object [ ] getChildren ( Object parent , IPresentationContext context ) throws CoreException ; protected abstract boolean hasChildren ( Object element , IPresentationContext context ) throws CoreException ; protected boolean supportsContext ( IPresentationContext context ) { return supportsPartId ( context . getId ( ) ) ; } protected abstract boolean supportsPartId ( String id ) ; } 
