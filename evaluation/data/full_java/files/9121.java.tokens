package com . google . common . base ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . annotation . CheckReturnValue ; @GwtCompatible ( emulated = true ) public final class Splitter { private final CharMatcher trimmer ; private final boolean omitEmptyStrings ; private final Strategy strategy ; private final int limit ; private Splitter ( Strategy strategy ) { this ( strategy , false , CharMatcher . NONE , Integer . MAX_VALUE ) ; } private Splitter ( Strategy strategy , boolean omitEmptyStrings , CharMatcher trimmer , int limit ) { this . strategy = strategy ; this . omitEmptyStrings = omitEmptyStrings ; this . trimmer = trimmer ; this . limit = limit ; } @CheckReturnValue public static Splitter on ( char separator ) { return on ( CharMatcher . is ( separator ) ) ; } @CheckReturnValue public static Splitter on ( final CharMatcher separatorMatcher ) { checkNotNull ( separatorMatcher ) ; return new Splitter ( new Strategy ( ) { @Override public SplittingIterator iterator ( Splitter splitter , final CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override int separatorStart ( int start ) { return separatorMatcher . indexIn ( toSplit , start ) ; } @Override int separatorEnd ( int separatorPosition ) { return separatorPosition + <int> ; } } ; } } ) ; } @CheckReturnValue public static Splitter on ( final String separator ) { checkArgument ( separator . length ( ) ! = <int> , <str> ) ; if ( separator . length ( ) = = <int> ) { return Splitter . on ( separator . charAt ( <int> ) ) ; } return new Splitter ( new Strategy ( ) { @Override public SplittingIterator iterator ( Splitter splitter , CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { int separatorLength = separator . length ( ) ; positions: for ( int p = start , last = toSplit . length ( ) - separatorLength ; p < = last ; p + + ) { for ( int i = <int> ; i < separatorLength ; i + + ) { if ( toSplit . charAt ( i + p ) ! = separator . charAt ( i ) ) { continue positions ; } } return p ; } return - <int> ; } @Override public int separatorEnd ( int separatorPosition ) { return separatorPosition + separator . length ( ) ; } } ; } } ) ; } @CheckReturnValue @GwtIncompatible ( <str> ) public static Splitter on ( final Pattern separatorPattern ) { checkNotNull ( separatorPattern ) ; checkArgument ( ! separatorPattern . matcher ( <str> ) . matches ( ) , <str> , separatorPattern ) ; return new Splitter ( new Strategy ( ) { @Override public SplittingIterator iterator ( final Splitter splitter , CharSequence toSplit ) { final Matcher matcher = separatorPattern . matcher ( toSplit ) ; return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { return matcher . find ( start ) ? matcher . start ( ) : - <int> ; } @Override public int separatorEnd ( int separatorPosition ) { return matcher . end ( ) ; } } ; } } ) ; } @CheckReturnValue @GwtIncompatible ( <str> ) public static Splitter onPattern ( String separatorPattern ) { return on ( Pattern . compile ( separatorPattern ) ) ; } @CheckReturnValue public static Splitter fixedLength ( final int length ) { checkArgument ( length > <int> , <str> ) ; return new Splitter ( new Strategy ( ) { @Override public SplittingIterator iterator ( final Splitter splitter , CharSequence toSplit ) { return new SplittingIterator ( splitter , toSplit ) { @Override public int separatorStart ( int start ) { int nextChunkStart = start + length ; return ( nextChunkStart < toSplit . length ( ) ? nextChunkStart : - <int> ) ; } @Override public int separatorEnd ( int separatorPosition ) { return separatorPosition ; } } ; } } ) ; } @CheckReturnValue public Splitter omitEmptyStrings ( ) { return new Splitter ( strategy , true , trimmer , limit ) ; } @CheckReturnValue public Splitter limit ( int limit ) { checkArgument ( limit > <int> , <str> , limit ) ; return new Splitter ( strategy , omitEmptyStrings , trimmer , limit ) ; } @CheckReturnValue public Splitter trimResults ( ) { return trimResults ( CharMatcher . WHITESPACE ) ; } @CheckReturnValue public Splitter trimResults ( CharMatcher trimmer ) { checkNotNull ( trimmer ) ; return new Splitter ( strategy , omitEmptyStrings , trimmer , limit ) ; } @CheckReturnValue public Iterable < String > split ( final CharSequence sequence ) { checkNotNull ( sequence ) ; return new Iterable < String > ( ) { @Override public Iterator < String > iterator ( ) { return splittingIterator ( sequence ) ; } @Override public String toString ( ) { return Joiner . on ( <str> ) . appendTo ( new StringBuilder ( ) . append ( <str> ) , this ) . append ( <str> ) . toString ( ) ; } } ; } private Iterator < String > splittingIterator ( CharSequence sequence ) { return strategy . iterator ( this , sequence ) ; } @CheckReturnValue @Beta public List < String > splitToList ( CharSequence sequence ) { checkNotNull ( sequence ) ; Iterator < String > iterator = splittingIterator ( sequence ) ; List < String > result = new ArrayList < String > ( ) ; while ( iterator . hasNext ( ) ) { result . add ( iterator . next ( ) ) ; } return Collections . unmodifiableList ( result ) ; } @CheckReturnValue @Beta public MapSplitter withKeyValueSeparator ( String separator ) { return withKeyValueSeparator ( on ( separator ) ) ; } @CheckReturnValue @Beta public MapSplitter withKeyValueSeparator ( char separator ) { return withKeyValueSeparator ( on ( separator ) ) ; } @CheckReturnValue @Beta public MapSplitter withKeyValueSeparator ( Splitter keyValueSplitter ) { return new MapSplitter ( this , keyValueSplitter ) ; } @Beta public static final class MapSplitter { private static final String INVALID_ENTRY_MESSAGE = <str> ; private final Splitter outerSplitter ; private final Splitter entrySplitter ; private MapSplitter ( Splitter outerSplitter , Splitter entrySplitter ) { this . outerSplitter = outerSplitter ; this . entrySplitter = checkNotNull ( entrySplitter ) ; } @CheckReturnValue public Map < String , String > split ( CharSequence sequence ) { Map < String , String > map = new LinkedHashMap < String , String > ( ) ; for ( String entry : outerSplitter . split ( sequence ) ) { Iterator < String > entryFields = entrySplitter . splittingIterator ( entry ) ; checkArgument ( entryFields . hasNext ( ) , INVALID_ENTRY_MESSAGE , entry ) ; String key = entryFields . next ( ) ; checkArgument ( ! map . containsKey ( key ) , <str> , key ) ; checkArgument ( entryFields . hasNext ( ) , INVALID_ENTRY_MESSAGE , entry ) ; String value = entryFields . next ( ) ; map . put ( key , value ) ; checkArgument ( ! entryFields . hasNext ( ) , INVALID_ENTRY_MESSAGE , entry ) ; } return Collections . unmodifiableMap ( map ) ; } } private interface Strategy { Iterator < String > iterator ( Splitter splitter , CharSequence toSplit ) ; } private abstract static class SplittingIterator extends AbstractIterator < String > { final CharSequence toSplit ; final CharMatcher trimmer ; final boolean omitEmptyStrings ; abstract int separatorStart ( int start ) ; abstract int separatorEnd ( int separatorPosition ) ; int offset = <int> ; int limit ; protected SplittingIterator ( Splitter splitter , CharSequence toSplit ) { this . trimmer = splitter . trimmer ; this . omitEmptyStrings = splitter . omitEmptyStrings ; this . limit = splitter . limit ; this . toSplit = toSplit ; } @Override protected String computeNext ( ) { int nextStart = offset ; while ( offset ! = - <int> ) { int start = nextStart ; int end ; int separatorPosition = separatorStart ( offset ) ; if ( separatorPosition = = - <int> ) { end = toSplit . length ( ) ; offset = - <int> ; } else { end = separatorPosition ; offset = separatorEnd ( separatorPosition ) ; } if ( offset = = nextStart ) { offset + + ; if ( offset > = toSplit . length ( ) ) { offset = - <int> ; } continue ; } while ( start < end & & trimmer . matches ( toSplit . charAt ( start ) ) ) { start + + ; } while ( end > start & & trimmer . matches ( toSplit . charAt ( end - <int> ) ) ) { end - - ; } if ( omitEmptyStrings & & start = = end ) { nextStart = offset ; continue ; } if ( limit = = <int> ) { end = toSplit . length ( ) ; offset = - <int> ; while ( end > start & & trimmer . matches ( toSplit . charAt ( end - <int> ) ) ) { end - - ; } } else { limit - - ; } return toSplit . subSequence ( start , end ) . toString ( ) ; } return endOfData ( ) ; } } } 
