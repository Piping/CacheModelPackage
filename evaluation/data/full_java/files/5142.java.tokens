package org . elasticsearch . action . admin . indices . mapping . get ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import java . io . IOException ; public class GetMappingsResponse extends ActionResponse { private ImmutableOpenMap < String , ImmutableOpenMap < String , MappingMetaData > > mappings = ImmutableOpenMap . of ( ) ; GetMappingsResponse ( ImmutableOpenMap < String , ImmutableOpenMap < String , MappingMetaData > > mappings ) { this . mappings = mappings ; } GetMappingsResponse ( ) { } public ImmutableOpenMap < String , ImmutableOpenMap < String , MappingMetaData > > mappings ( ) { return mappings ; } public ImmutableOpenMap < String , ImmutableOpenMap < String , MappingMetaData > > getMappings ( ) { return mappings ( ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; int size = in . readVInt ( ) ; ImmutableOpenMap . Builder < String , ImmutableOpenMap < String , MappingMetaData > > indexMapBuilder = ImmutableOpenMap . builder ( ) ; for ( int i = <int> ; i < size ; i + + ) { String key = in . readString ( ) ; int valueSize = in . readVInt ( ) ; ImmutableOpenMap . Builder < String , MappingMetaData > typeMapBuilder = ImmutableOpenMap . builder ( ) ; for ( int j = <int> ; j < valueSize ; j + + ) { typeMapBuilder . put ( in . readString ( ) , MappingMetaData . PROTO . readFrom ( in ) ) ; } indexMapBuilder . put ( key , typeMapBuilder . build ( ) ) ; } mappings = indexMapBuilder . build ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( mappings . size ( ) ) ; for ( ObjectObjectCursor < String , ImmutableOpenMap < String , MappingMetaData > > indexEntry : mappings ) { out . writeString ( indexEntry . key ) ; out . writeVInt ( indexEntry . value . size ( ) ) ; for ( ObjectObjectCursor < String , MappingMetaData > typeEntry : indexEntry . value ) { out . writeString ( typeEntry . key ) ; typeEntry . value . writeTo ( out ) ; } } } } 
