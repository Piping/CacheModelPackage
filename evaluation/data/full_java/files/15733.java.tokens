package org . gradle . api . internal . tasks . testing . detection ; import org . apache . commons . lang . text . StrBuilder ; import org . gradle . api . GradleException ; import org . gradle . api . internal . file . DefaultTemporaryFileProvider ; import org . gradle . api . internal . file . TemporaryFileProvider ; import org . gradle . internal . Factory ; import org . gradle . util . JarUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . io . IOException ; import java . util . * ; public class ClassFileExtractionManager { private static final Logger LOGGER = LoggerFactory . getLogger ( ClassFileExtractionManager . class ) ; private final Map < String , Set < File > > packageJarFilesMappings ; private final Map < String , File > extractedJarClasses ; private final Set < String > unextractableClasses ; private final TemporaryFileProvider tempDirProvider ; public ClassFileExtractionManager ( final Factory < File > tempDirFactory ) { assert tempDirFactory ! = null ; tempDirProvider = new DefaultTemporaryFileProvider ( tempDirFactory ) ; packageJarFilesMappings = new HashMap < String , Set < File > > ( ) ; extractedJarClasses = new HashMap < String , File > ( ) ; unextractableClasses = new TreeSet < String > ( ) ; } public void addLibraryJar ( final File libraryJar ) { new JarFilePackageLister ( ) . listJarPackages ( libraryJar , new JarFilePackageListener ( ) { public void receivePackage ( String packageName ) { Set < File > jarFiles = packageJarFilesMappings . get ( packageName ) ; if ( jarFiles = = null ) { jarFiles = new TreeSet < File > ( ) ; } jarFiles . add ( libraryJar ) ; packageJarFilesMappings . put ( packageName , jarFiles ) ; } } ) ; } public File getLibraryClassFile ( final String className ) { if ( unextractableClasses . contains ( className ) ) { return null ; } else { if ( ! extractedJarClasses . containsKey ( className ) ) { if ( ! extractClassFile ( className ) ) { unextractableClasses . add ( className ) ; } } return extractedJarClasses . get ( className ) ; } } private boolean extractClassFile ( final String className ) { boolean classFileExtracted = false ; final File extractedClassFile = tempFile ( ) ; final String classFileName = new StrBuilder ( ) . append ( className ) . append ( <str> ) . toString ( ) ; final String classNamePackage = classNamePackage ( className ) ; final Set < File > packageJarFiles = packageJarFilesMappings . get ( classNamePackage ) ; File classFileSourceJar = null ; if ( packageJarFiles ! = null & & ! packageJarFiles . isEmpty ( ) ) { final Iterator < File > packageJarFilesIt = packageJarFiles . iterator ( ) ; while ( ! classFileExtracted & & packageJarFilesIt . hasNext ( ) ) { final File jarFile = packageJarFilesIt . next ( ) ; try { classFileExtracted = JarUtil . extractZipEntry ( jarFile , classFileName , extractedClassFile ) ; if ( classFileExtracted ) { classFileSourceJar = jarFile ; } } catch ( IOException e ) { throw new GradleException ( <str> + jarFile + <str> , e ) ; } } if ( classFileExtracted ) { LOGGER . debug ( <str> , className , classFileSourceJar . getName ( ) ) ; extractedJarClasses . put ( className , extractedClassFile ) ; } } return classFileExtracted ; } private String classNamePackage ( final String className ) { final int lastSlashIndex = className . lastIndexOf ( <str> ) ; if ( lastSlashIndex = = - <int> ) { return null ; } else { return className . substring ( <int> , lastSlashIndex + <int> ) ; } } private File tempFile ( ) { return tempDirProvider . createTemporaryFile ( <str> , <str> ) ; } } 
