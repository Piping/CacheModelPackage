package org . elasticsearch . common . rounding ; import org . elasticsearch . test . ESTestCase ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class RoundingTests extends ESTestCase { public void testInterval ( ) { int interval = <int> ; Rounding . Interval rounding = new Rounding . Interval ( interval ) ; int value = <int> ; final long key = rounding . roundKey ( <int> ) ; final long r = rounding . round ( <int> ) ; String message = <str> + value + <str> + interval + <str> + r ; assertEquals ( value / interval , key ) ; assertEquals ( value / interval * interval , r ) ; assertEquals ( message , <int> , r % interval ) ; } public void testIntervalRandom ( ) { final long interval = randomIntBetween ( <int> , <int> ) ; Rounding . Interval rounding = new Rounding . Interval ( interval ) ; for ( int i = <int> ; i < <int> ; + + i ) { long l = Math . max ( randomLong ( ) , Long . MIN_VALUE + interval ) ; final long key = rounding . roundKey ( l ) ; final long r = rounding . round ( l ) ; String message = <str> + l + <str> + interval + <str> + r ; assertEquals ( message , <int> , r % interval ) ; assertThat ( message , r , lessThanOrEqualTo ( l ) ) ; assertThat ( message , r + interval , greaterThan ( l ) ) ; assertEquals ( message , r , key * interval ) ; } } public void testOffsetRounding ( ) { final long interval = <int> ; final long offset = <int> ; Rounding . OffsetRounding rounding = new Rounding . OffsetRounding ( new Rounding . Interval ( interval ) , offset ) ; assertEquals ( - <int> , rounding . roundKey ( <int> ) ) ; assertEquals ( - <int> , rounding . round ( <int> ) ) ; assertEquals ( <int> , rounding . nextRoundingValue ( - <int> ) ) ; assertEquals ( <int> , rounding . roundKey ( <int> ) ) ; assertEquals ( <int> , rounding . round ( <int> ) ) ; assertEquals ( <int> , rounding . nextRoundingValue ( <int> ) ) ; assertEquals ( <int> , rounding . roundKey ( <int> ) ) ; assertEquals ( <int> , rounding . round ( <int> ) ) ; assertEquals ( <int> , rounding . roundKey ( <int> ) ) ; assertEquals ( <int> , rounding . round ( <int> ) ) ; assertEquals ( <int> , rounding . nextRoundingValue ( <int> ) ) ; } public void testOffsetRoundingRandom ( ) { for ( int i = <int> ; i < <int> ; + + i ) { final long interval = randomIntBetween ( <int> , <int> ) ; Rounding . Interval internalRounding = new Rounding . Interval ( interval ) ; final long offset = randomIntBetween ( - <int> , <int> ) ; Rounding . OffsetRounding rounding = new Rounding . OffsetRounding ( internalRounding , offset ) ; long safetyMargin = Math . abs ( interval ) + Math . abs ( offset ) ; long value = Math . max ( randomLong ( ) - safetyMargin , Long . MIN_VALUE + safetyMargin ) ; final long key = rounding . roundKey ( value ) ; final long key_next = rounding . roundKey ( value + interval ) ; final long r_value = rounding . round ( value ) ; final long nextRoundingValue = rounding . nextRoundingValue ( r_value ) ; assertThat ( <str> , r_value , equalTo ( rounding . round ( r_value ) ) ) ; assertThat ( <str> , r_value - offset , lessThanOrEqualTo ( value - offset ) ) ; assertThat ( <str> , key_next - key , equalTo ( <int> ) ) ; assertThat ( <str> , r_value + interval , greaterThan ( value ) ) ; assertThat ( <str> , r_value + interval , equalTo ( nextRoundingValue ) ) ; } } } 
