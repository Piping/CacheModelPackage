package org . elasticsearch . action . admin . cluster . tasks ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . cluster . service . PendingClusterTask ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . common . xcontent . XContentFactory ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; public class PendingClusterTasksResponse extends ActionResponse implements Iterable < PendingClusterTask > , ToXContent { private List < PendingClusterTask > pendingTasks ; PendingClusterTasksResponse ( ) { } PendingClusterTasksResponse ( List < PendingClusterTask > pendingTasks ) { this . pendingTasks = pendingTasks ; } public List < PendingClusterTask > pendingTasks ( ) { return pendingTasks ; } public List < PendingClusterTask > getPendingTasks ( ) { return pendingTasks ( ) ; } @Override public Iterator < PendingClusterTask > iterator ( ) { return pendingTasks . iterator ( ) ; } public String prettyPrint ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( pendingTasks . size ( ) ) . append ( <str> ) ; for ( PendingClusterTask pendingClusterTask : this ) { sb . append ( pendingClusterTask . getInsertOrder ( ) ) . append ( <str> ) . append ( pendingClusterTask . getPriority ( ) ) . append ( <str> ) . append ( pendingClusterTask . getSource ( ) ) . append ( <str> ) . append ( pendingClusterTask . getTimeInQueue ( ) ) . append ( <str> ) ; } return sb . toString ( ) ; } @Override public String toString ( ) { try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; builder . startObject ( ) ; toXContent ( builder , EMPTY_PARAMS ) ; builder . endObject ( ) ; return builder . string ( ) ; } catch ( IOException e ) { return <str> + e . getMessage ( ) + <str> ; } } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startArray ( Fields . TASKS ) ; for ( PendingClusterTask pendingClusterTask : this ) { builder . startObject ( ) ; builder . field ( Fields . INSERT_ORDER , pendingClusterTask . getInsertOrder ( ) ) ; builder . field ( Fields . PRIORITY , pendingClusterTask . getPriority ( ) ) ; builder . field ( Fields . SOURCE , pendingClusterTask . getSource ( ) ) ; builder . field ( Fields . EXECUTING , pendingClusterTask . isExecuting ( ) ) ; builder . field ( Fields . TIME_IN_QUEUE_MILLIS , pendingClusterTask . getTimeInQueueInMillis ( ) ) ; builder . field ( Fields . TIME_IN_QUEUE , pendingClusterTask . getTimeInQueue ( ) ) ; builder . endObject ( ) ; } builder . endArray ( ) ; return builder ; } static final class Fields { static final XContentBuilderString TASKS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString EXECUTING = new XContentBuilderString ( <str> ) ; static final XContentBuilderString INSERT_ORDER = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PRIORITY = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SOURCE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TIME_IN_QUEUE_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TIME_IN_QUEUE = new XContentBuilderString ( <str> ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; int size = in . readVInt ( ) ; pendingTasks = new ArrayList < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { PendingClusterTask task = new PendingClusterTask ( ) ; task . readFrom ( in ) ; pendingTasks . add ( task ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeVInt ( pendingTasks . size ( ) ) ; for ( PendingClusterTask task : pendingTasks ) { task . writeTo ( out ) ; } } } 
