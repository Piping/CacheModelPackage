package org . apache . cassandra . io . sstable ; import java . io . File ; import java . util . * ; import java . util . regex . Pattern ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . CharMatcher ; import com . google . common . base . Objects ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . io . sstable . format . SSTableFormat ; import org . apache . cassandra . io . sstable . format . Version ; import org . apache . cassandra . io . sstable . format . big . BigFormat ; import org . apache . cassandra . io . sstable . metadata . IMetadataSerializer ; import org . apache . cassandra . io . sstable . metadata . LegacyMetadataSerializer ; import org . apache . cassandra . io . sstable . metadata . MetadataSerializer ; import org . apache . cassandra . utils . Pair ; import static org . apache . cassandra . io . sstable . Component . separator ; public class Descriptor { public static String TMP_EXT = <str> ; public final File directory ; public final Version version ; public final String ksname ; public final String cfname ; public final int generation ; public final SSTableFormat . Type formatType ; public final Component digestComponent ; private final int hashCode ; @VisibleForTesting public Descriptor ( File directory , String ksname , String cfname , int generation ) { this ( DatabaseDescriptor . getSSTableFormat ( ) . info . getLatestVersion ( ) , directory , ksname , cfname , generation , DatabaseDescriptor . getSSTableFormat ( ) , null ) ; } public Descriptor ( File directory , String ksname , String cfname , int generation , SSTableFormat . Type formatType ) { this ( formatType . info . getLatestVersion ( ) , directory , ksname , cfname , generation , formatType , Component . digestFor ( BigFormat . latestVersion . uncompressedChecksumType ( ) ) ) ; } @VisibleForTesting public Descriptor ( String version , File directory , String ksname , String cfname , int generation , SSTableFormat . Type formatType ) { this ( formatType . info . getVersion ( version ) , directory , ksname , cfname , generation , formatType , Component . digestFor ( BigFormat . latestVersion . uncompressedChecksumType ( ) ) ) ; } public Descriptor ( Version version , File directory , String ksname , String cfname , int generation , SSTableFormat . Type formatType , Component digestComponent ) { assert version ! = null & & directory ! = null & & ksname ! = null & & cfname ! = null & & formatType . info . getLatestVersion ( ) . getClass ( ) . equals ( version . getClass ( ) ) ; this . version = version ; this . directory = directory ; this . ksname = ksname ; this . cfname = cfname ; this . generation = generation ; this . formatType = formatType ; this . digestComponent = digestComponent ; hashCode = Objects . hashCode ( version , directory , generation , ksname , cfname , formatType ) ; } public Descriptor withGeneration ( int newGeneration ) { return new Descriptor ( version , directory , ksname , cfname , newGeneration , formatType , digestComponent ) ; } public Descriptor withFormatType ( SSTableFormat . Type newType ) { return new Descriptor ( newType . info . getLatestVersion ( ) , directory , ksname , cfname , generation , newType , digestComponent ) ; } public Descriptor withDigestComponent ( Component newDigestComponent ) { return new Descriptor ( version , directory , ksname , cfname , generation , formatType , newDigestComponent ) ; } public String tmpFilenameFor ( Component component ) { return filenameFor ( component ) + TMP_EXT ; } public String filenameFor ( Component component ) { return baseFilename ( ) + separator + component . name ( ) ; } public String baseFilename ( ) { StringBuilder buff = new StringBuilder ( ) ; buff . append ( directory ) . append ( File . separatorChar ) ; appendFileName ( buff ) ; return buff . toString ( ) ; } private void appendFileName ( StringBuilder buff ) { if ( ! version . hasNewFileName ( ) ) { buff . append ( ksname ) . append ( separator ) ; buff . append ( cfname ) . append ( separator ) ; } buff . append ( version ) . append ( separator ) ; buff . append ( generation ) ; if ( formatType ! = SSTableFormat . Type . LEGACY ) buff . append ( separator ) . append ( formatType . name ) ; } public String relativeFilenameFor ( Component component ) { final StringBuilder buff = new StringBuilder ( ) ; appendFileName ( buff ) ; buff . append ( separator ) . append ( component . name ( ) ) ; return buff . toString ( ) ; } public SSTableFormat getFormat ( ) { return formatType . info ; } public List < File > getTemporaryFiles ( ) { List < File > ret = new ArrayList < > ( ) ; File [ ] tmpFiles = directory . listFiles ( ( dir , name ) - > name . endsWith ( Descriptor . TMP_EXT ) ) ; for ( File tmpFile : tmpFiles ) ret . add ( tmpFile ) ; return ret ; } private final static String LEGACY_COMP_IN_PROG_REGEX_STR = <str> ; private final static Pattern LEGACY_COMP_IN_PROG_REGEX = Pattern . compile ( LEGACY_COMP_IN_PROG_REGEX_STR ) ; private final static String LEGACY_TMP_REGEX_STR = <str> ; private final static Pattern LEGACY_TMP_REGEX = Pattern . compile ( LEGACY_TMP_REGEX_STR ) ; public static boolean isLegacyFile ( File file ) { if ( file . isDirectory ( ) ) return file . getParentFile ( ) ! = null & & file . getParentFile ( ) . getName ( ) . equalsIgnoreCase ( <str> ) & & LEGACY_COMP_IN_PROG_REGEX . matcher ( file . getName ( ) ) . matches ( ) ; else return LEGACY_TMP_REGEX . matcher ( file . getName ( ) ) . matches ( ) ; } public static boolean isValidFile ( String fileName ) { return fileName . endsWith ( <str> ) & & ! LEGACY_TMP_REGEX . matcher ( fileName ) . matches ( ) ; } public static Descriptor fromFilename ( String filename ) { File file = new File ( filename ) ; return fromFilename ( file . getParentFile ( ) , file . getName ( ) , false ) . left ; } public static Descriptor fromFilename ( String filename , SSTableFormat . Type formatType ) { return fromFilename ( filename ) . withFormatType ( formatType ) ; } public static Descriptor fromFilename ( String filename , boolean skipComponent ) { File file = new File ( filename ) ; return fromFilename ( file . getParentFile ( ) , file . getName ( ) , skipComponent ) . left ; } public static Pair < Descriptor , String > fromFilename ( File directory , String name ) { return fromFilename ( directory , name , false ) ; } public static Pair < Descriptor , String > fromFilename ( File directory , String name , boolean skipComponent ) { File parentDirectory = directory ! = null ? directory : new File ( <str> ) ; StringTokenizer st = new StringTokenizer ( name , String . valueOf ( separator ) ) ; String nexttok ; Deque < String > tokenStack = new ArrayDeque < > ( ) ; while ( st . hasMoreTokens ( ) ) { tokenStack . push ( st . nextToken ( ) ) ; } String component = skipComponent ? null : tokenStack . pop ( ) ; nexttok = tokenStack . pop ( ) ; SSTableFormat . Type fmt = SSTableFormat . Type . LEGACY ; if ( ! CharMatcher . DIGIT . matchesAllOf ( nexttok ) ) { fmt = SSTableFormat . Type . validate ( nexttok ) ; nexttok = tokenStack . pop ( ) ; } int generation = Integer . parseInt ( nexttok ) ; nexttok = tokenStack . pop ( ) ; Version version = fmt . info . getVersion ( nexttok ) ; if ( ! version . validate ( nexttok ) ) throw new UnsupportedOperationException ( <str> + name + <str> ) ; String ksname , cfname ; if ( version . hasNewFileName ( ) ) { File cfDirectory = parentDirectory ; String indexName = <str> ; if ( cfDirectory . getName ( ) . startsWith ( Directories . SECONDARY_INDEX_NAME_SEPARATOR ) ) { indexName = cfDirectory . getName ( ) ; cfDirectory = cfDirectory . getParentFile ( ) ; } if ( cfDirectory . getName ( ) . equals ( Directories . BACKUPS_SUBDIR ) ) { cfDirectory = cfDirectory . getParentFile ( ) ; } else if ( cfDirectory . getParentFile ( ) . getName ( ) . equals ( Directories . SNAPSHOT_SUBDIR ) ) { cfDirectory = cfDirectory . getParentFile ( ) . getParentFile ( ) ; } cfname = cfDirectory . getName ( ) . split ( <str> ) [ <int> ] + indexName ; ksname = cfDirectory . getParentFile ( ) . getName ( ) ; } else { cfname = tokenStack . pop ( ) ; ksname = tokenStack . pop ( ) ; } assert tokenStack . isEmpty ( ) : <str> + name + <str> + directory ; return Pair . create ( new Descriptor ( version , parentDirectory , ksname , cfname , generation , fmt , Component . digestFor ( version . uncompressedChecksumType ( ) ) ) , component ) ; } public IMetadataSerializer getMetadataSerializer ( ) { if ( version . hasNewStatsFile ( ) ) return new MetadataSerializer ( ) ; else return new LegacyMetadataSerializer ( ) ; } public boolean isCompatible ( ) { return version . isCompatible ( ) ; } @Override public String toString ( ) { return baseFilename ( ) ; } @Override public boolean equals ( Object o ) { if ( o = = this ) return true ; if ( ! ( o instanceof Descriptor ) ) return false ; Descriptor that = ( Descriptor ) o ; return that . directory . equals ( this . directory ) & & that . generation = = this . generation & & that . ksname . equals ( this . ksname ) & & that . cfname . equals ( this . cfname ) & & that . formatType = = this . formatType ; } @Override public int hashCode ( ) { return hashCode ; } } 
