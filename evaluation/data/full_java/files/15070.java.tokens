package org . gradle . nativeplatform . toolchain . internal . msvcpp ; import net . rubygrapefruit . platform . MissingRegistryEntryException ; import net . rubygrapefruit . platform . SystemInfo ; import net . rubygrapefruit . platform . WindowsRegistry ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . nativeplatform . platform . Architecture ; import org . gradle . nativeplatform . platform . internal . Architectures ; import org . gradle . util . GFileUtils ; import org . gradle . util . TreeVisitor ; import org . gradle . util . VersionNumber ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . util . * ; public class DefaultVisualStudioLocator implements VisualStudioLocator { private static final Logger LOGGER = LoggerFactory . getLogger ( DefaultVisualStudioLocator . class ) ; private static final String [ ] REGISTRY_BASEPATHS = { <str> , <str> } ; private static final String REGISTRY_ROOTPATH_VC = <str> ; private static final String PATH_COMMON = <str> ; private static final String PATH_COMMONTOOLS = PATH_COMMON + <str> ; private static final String PATH_COMMONIDE = PATH_COMMON + <str> ; private static final String PATH_BIN = <str> ; private static final String PATH_INCLUDE = <str> ; private static final String COMPILER_FILENAME = <str> ; private static final String ARCHITECTURE_AMD64 = <str> ; private static final String ARCHITECTURE_X86 = <str> ; private static final String ARCHITECTURE_ARM = <str> ; private static final String ARCHITECTURE_IA64 = <str> ; private static final String BINPATH_AMD64_AMD64 = <str> ; private static final String BINPATH_AMD64_ARM = <str> ; private static final String BINPATH_AMD64_X86 = <str> ; private static final String BINPATH_X86_AMD64 = <str> ; private static final String BINPATH_X86_ARM = <str> ; private static final String BINPATH_X86_IA64 = <str> ; private static final String BINPATH_X86_X86 = <str> ; private static final String LIBPATH_AMD64 = <str> ; private static final String LIBPATH_ARM = <str> ; private static final String LIBPATH_IA64 = <str> ; private static final String LIBPATH_X86 = <str> ; private static final String ASSEMBLER_FILENAME_AMD64 = <str> ; private static final String ASSEMBLER_FILENAME_ARM = <str> ; private static final String ASSEMBLER_FILENAME_IA64 = <str> ; private static final String ASSEMBLER_FILENAME_X86 = <str> ; private static final String DEFINE_ARMPARTITIONAVAILABLE = <str> ; private final Map < File , VisualStudioInstall > foundInstalls = new HashMap < File , VisualStudioInstall > ( ) ; private final OperatingSystem os ; private final WindowsRegistry windowsRegistry ; private final SystemInfo systemInfo ; private VisualStudioInstall pathInstall ; private boolean initialised ; public DefaultVisualStudioLocator ( OperatingSystem os , WindowsRegistry windowsRegistry , SystemInfo systemInfo ) { this . os = os ; this . windowsRegistry = windowsRegistry ; this . systemInfo = systemInfo ; } public SearchResult locateVisualStudioInstalls ( File candidate ) { if ( ! initialised ) { locateInstallsInRegistry ( ) ; locateInstallInPath ( ) ; initialised = true ; } if ( candidate ! = null ) { return locateUserSpecifiedInstall ( candidate ) ; } return determineDefaultInstall ( ) ; } private void locateInstallsInRegistry ( ) { for ( String baseKey : REGISTRY_BASEPATHS ) { locateInstallsInRegistry ( baseKey ) ; } } private void locateInstallsInRegistry ( String baseKey ) { List < String > visualCppVersions ; try { visualCppVersions = windowsRegistry . getValueNames ( WindowsRegistry . Key . HKEY_LOCAL_MACHINE , baseKey + REGISTRY_ROOTPATH_VC ) ; } catch ( MissingRegistryEntryException e ) { return ; } for ( String valueName : visualCppVersions ) { if ( ! valueName . matches ( <str> ) ) { continue ; } File visualCppDir = new File ( windowsRegistry . getStringValue ( WindowsRegistry . Key . HKEY_LOCAL_MACHINE , baseKey + REGISTRY_ROOTPATH_VC , valueName ) ) ; visualCppDir = GFileUtils . canonicalise ( visualCppDir ) ; File visualStudioDir = visualCppDir . getParentFile ( ) ; if ( isVisualCpp ( visualCppDir ) & & isVisualStudio ( visualStudioDir ) ) { LOGGER . debug ( <str> , valueName , visualCppDir ) ; VersionNumber version = VersionNumber . parse ( valueName ) ; VisualCppInstall visualCpp = buildVisualCppInstall ( <str> + valueName , visualStudioDir , visualCppDir , version ) ; VisualStudioInstall visualStudio = new VisualStudioInstall ( visualStudioDir , visualCpp ) ; foundInstalls . put ( visualStudioDir , visualStudio ) ; } else { LOGGER . debug ( <str> , visualCppDir ) ; } } } private void locateInstallInPath ( ) { File compilerInPath = os . findInPath ( COMPILER_FILENAME ) ; if ( compilerInPath = = null ) { LOGGER . debug ( <str> ) ; return ; } File visualCppDir = GFileUtils . canonicalise ( compilerInPath . getParentFile ( ) . getParentFile ( ) ) ; if ( ! isVisualCpp ( visualCppDir ) ) { visualCppDir = visualCppDir . getParentFile ( ) ; if ( ! isVisualCpp ( visualCppDir ) ) { LOGGER . debug ( <str> , compilerInPath ) ; return ; } } LOGGER . debug ( <str> , visualCppDir ) ; File visualStudioDir = visualCppDir . getParentFile ( ) ; if ( ! foundInstalls . containsKey ( visualStudioDir ) ) { VisualCppInstall visualCpp = buildVisualCppInstall ( <str> , visualStudioDir , visualCppDir , VersionNumber . UNKNOWN ) ; VisualStudioInstall visualStudio = new VisualStudioInstall ( visualStudioDir , visualCpp ) ; foundInstalls . put ( visualStudioDir , visualStudio ) ; } pathInstall = foundInstalls . get ( visualStudioDir ) ; } private SearchResult locateUserSpecifiedInstall ( File candidate ) { File visualStudioDir = GFileUtils . canonicalise ( candidate ) ; File visualCppDir = new File ( visualStudioDir , <str> ) ; if ( ! isVisualStudio ( visualStudioDir ) | | ! isVisualCpp ( visualCppDir ) ) { LOGGER . debug ( <str> , candidate ) ; return new InstallNotFound ( String . format ( <str> , candidate ) ) ; } if ( ! foundInstalls . containsKey ( visualStudioDir ) ) { VisualCppInstall visualCpp = buildVisualCppInstall ( <str> , visualStudioDir , visualCppDir , VersionNumber . UNKNOWN ) ; VisualStudioInstall visualStudio = new VisualStudioInstall ( visualStudioDir , visualCpp ) ; foundInstalls . put ( visualStudioDir , visualStudio ) ; } return new InstallFound ( foundInstalls . get ( visualStudioDir ) ) ; } private VisualCppInstall buildVisualCppInstall ( String name , File vsPath , File basePath , VersionNumber version ) { boolean isNativeAmd64 = systemInfo . getArchitecture ( ) = = SystemInfo . Architecture . amd64 ; Map < Architecture , List < File > > paths = new HashMap < Architecture , List < File > > ( ) ; Map < Architecture , File > binaryPaths = new HashMap < Architecture , File > ( ) ; Map < Architecture , File > libraryPaths = new HashMap < Architecture , File > ( ) ; Map < Architecture , File > includePaths = new HashMap < Architecture , File > ( ) ; Map < Architecture , String > assemblerFilenames = new HashMap < Architecture , String > ( ) ; Map < Architecture , Map < String , String > > definitions = new HashMap < Architecture , Map < String , String > > ( ) ; Architecture amd64 = Architectures . forInput ( ARCHITECTURE_AMD64 ) ; Architecture x86 = Architectures . forInput ( ARCHITECTURE_X86 ) ; Architecture arm = Architectures . forInput ( ARCHITECTURE_ARM ) ; Architecture ia64 = Architectures . forInput ( ARCHITECTURE_IA64 ) ; File includePath = new File ( basePath , PATH_INCLUDE ) ; File commonTools = new File ( vsPath , PATH_COMMONTOOLS ) ; File commonIde = new File ( vsPath , PATH_COMMONIDE ) ; if ( isNativeAmd64 ) { Architecture [ ] architectures = { amd64 , x86 , arm } ; String [ ] binPaths = { BINPATH_AMD64_AMD64 , BINPATH_AMD64_X86 , BINPATH_AMD64_ARM } ; String [ ] libPaths = { LIBPATH_AMD64 , LIBPATH_X86 , LIBPATH_ARM } ; String [ ] asmFilenames = { ASSEMBLER_FILENAME_AMD64 , ASSEMBLER_FILENAME_X86 , ASSEMBLER_FILENAME_ARM } ; for ( int i = <int> ; i ! = architectures . length ; + + i ) { Architecture architecture = architectures [ i ] ; File binPath = new File ( basePath , binPaths [ i ] ) ; File libPath = new File ( basePath , libPaths [ i ] ) ; if ( binPath . isDirectory ( ) & & libPath . isDirectory ( ) ) { Map < String , String > definitionsList = new LinkedHashMap < String , String > ( ) ; List < File > pathsList = new ArrayList < File > ( ) ; pathsList . add ( commonTools ) ; pathsList . add ( commonIde ) ; if ( architecture ! = amd64 ) { pathsList . add ( new File ( basePath , binPaths [ <int> ] ) ) ; } if ( architecture = = arm ) { definitionsList . put ( DEFINE_ARMPARTITIONAVAILABLE , <str> ) ; } binaryPaths . put ( architecture , binPath ) ; libraryPaths . put ( architecture , libPath ) ; includePaths . put ( architecture , includePath ) ; assemblerFilenames . put ( architecture , asmFilenames [ i ] ) ; paths . put ( architecture , pathsList ) ; definitions . put ( architecture , definitionsList ) ; } } } Architecture [ ] architectures = { x86 , amd64 , ia64 , arm } ; String [ ] binPaths = { BINPATH_X86_X86 , BINPATH_X86_AMD64 , BINPATH_X86_IA64 , BINPATH_X86_ARM } ; String [ ] libPaths = { LIBPATH_X86 , LIBPATH_AMD64 , LIBPATH_IA64 , LIBPATH_ARM } ; String [ ] asmFilenames = { ASSEMBLER_FILENAME_X86 , ASSEMBLER_FILENAME_AMD64 , ASSEMBLER_FILENAME_IA64 , ASSEMBLER_FILENAME_ARM } ; for ( int i = <int> ; i ! = architectures . length ; + + i ) { Architecture architecture = architectures [ i ] ; if ( ! binaryPaths . containsKey ( architecture ) ) { File binPath = new File ( basePath , binPaths [ i ] ) ; File libPath = new File ( basePath , libPaths [ i ] ) ; if ( binPath . isDirectory ( ) & & libPath . isDirectory ( ) ) { Map < String , String > definitionsList = new LinkedHashMap < String , String > ( ) ; List < File > pathsList = new ArrayList < File > ( ) ; pathsList . add ( commonTools ) ; pathsList . add ( commonIde ) ; if ( architecture ! = x86 ) { pathsList . add ( new File ( basePath , binPaths [ <int> ] ) ) ; } if ( architecture = = arm ) { definitionsList . put ( DEFINE_ARMPARTITIONAVAILABLE , <str> ) ; } binaryPaths . put ( architecture , binPath ) ; libraryPaths . put ( architecture , libPath ) ; includePaths . put ( architecture , includePath ) ; assemblerFilenames . put ( architecture , asmFilenames [ i ] ) ; paths . put ( architecture , pathsList ) ; definitions . put ( architecture , definitionsList ) ; } } } return new VisualCppInstall ( name , version , paths , binaryPaths , libraryPaths , includePaths , assemblerFilenames , definitions ) ; } private SearchResult determineDefaultInstall ( ) { if ( pathInstall ! = null ) { return new InstallFound ( pathInstall ) ; } VisualStudioInstall candidate = null ; for ( VisualStudioInstall visualStudio : foundInstalls . values ( ) ) { if ( candidate = = null | | visualStudio . getVersion ( ) . compareTo ( candidate . getVersion ( ) ) > <int> ) { candidate = visualStudio ; } } return candidate = = null ? new InstallNotFound ( <str> ) : new InstallFound ( candidate ) ; } private static boolean isVisualStudio ( File candidate ) { return new File ( candidate , PATH_COMMON ) . isDirectory ( ) & & isVisualCpp ( new File ( candidate , <str> ) ) ; } private static boolean isVisualCpp ( File candidate ) { return new File ( candidate , PATH_BIN + COMPILER_FILENAME ) . isFile ( ) ; } private static class InstallFound implements SearchResult { private final VisualStudioInstall install ; public InstallFound ( VisualStudioInstall install ) { this . install = install ; } public VisualStudioInstall getVisualStudio ( ) { return install ; } public boolean isAvailable ( ) { return true ; } public void explain ( TreeVisitor < ? super String > visitor ) { } } private static class InstallNotFound implements SearchResult { private final String message ; private InstallNotFound ( String message ) { this . message = message ; } public VisualStudioInstall getVisualStudio ( ) { return null ; } public boolean isAvailable ( ) { return false ; } public void explain ( TreeVisitor < ? super String > visitor ) { visitor . node ( message ) ; } } } 
