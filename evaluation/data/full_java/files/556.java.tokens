package org . apache . cassandra . dht . tokenallocator ; import java . util . * ; import com . google . common . collect . HashMultimap ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Maps ; import com . google . common . collect . Multimap ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Token ; class ReplicationAwareTokenAllocator < Unit > implements TokenAllocator < Unit > { final NavigableMap < Token , Unit > sortedTokens ; final Multimap < Unit , Token > unitToTokens ; final ReplicationStrategy < Unit > strategy ; final IPartitioner partitioner ; final int replicas ; ReplicationAwareTokenAllocator ( NavigableMap < Token , Unit > sortedTokens , ReplicationStrategy < Unit > strategy , IPartitioner partitioner ) { this . sortedTokens = sortedTokens ; unitToTokens = HashMultimap . create ( ) ; for ( Map . Entry < Token , Unit > en : sortedTokens . entrySet ( ) ) unitToTokens . put ( en . getValue ( ) , en . getKey ( ) ) ; this . strategy = strategy ; this . replicas = strategy . replicas ( ) ; this . partitioner = partitioner ; } public Collection < Token > addUnit ( Unit newUnit , int numTokens ) { assert ! unitToTokens . containsKey ( newUnit ) ; if ( unitCount ( ) < replicas ) return generateRandomTokens ( newUnit , numTokens ) ; if ( numTokens > sortedTokens . size ( ) ) return generateRandomTokens ( newUnit , numTokens ) ; double optTokenOwnership = optimalTokenOwnership ( numTokens ) ; Map < Object , GroupInfo > groups = Maps . newHashMap ( ) ; Map < Unit , UnitInfo < Unit > > unitInfos = createUnitInfos ( groups ) ; if ( groups . size ( ) < replicas ) { return generateRandomTokens ( newUnit , numTokens ) ; } UnitInfo < Unit > newUnitInfo = new UnitInfo < > ( newUnit , numTokens * optTokenOwnership , groups , strategy ) ; TokenInfo < Unit > tokens = createTokenInfos ( unitInfos , newUnitInfo . group ) ; newUnitInfo . tokenCount = numTokens ; CandidateInfo < Unit > candidates = createCandidates ( tokens , newUnitInfo , optTokenOwnership ) ; PriorityQueue < Weighted < CandidateInfo < Unit > > > improvements = new PriorityQueue < > ( sortedTokens . size ( ) ) ; CandidateInfo < Unit > candidate = candidates ; do { double impr = evaluateImprovement ( candidate , optTokenOwnership , <float> / numTokens ) ; improvements . add ( new Weighted < > ( impr , candidate ) ) ; candidate = candidate . next ; } while ( candidate ! = candidates ) ; CandidateInfo < Unit > bestToken = improvements . remove ( ) . value ; for ( int vn = <int> ; ; + + vn ) { candidates = bestToken . removeFrom ( candidates ) ; confirmCandidate ( bestToken ) ; if ( vn = = numTokens ) break ; while ( true ) { bestToken = improvements . remove ( ) . value ; double impr = evaluateImprovement ( bestToken , optTokenOwnership , ( vn + <float> ) / numTokens ) ; Weighted < CandidateInfo < Unit > > next = improvements . peek ( ) ; if ( next = = null | | impr > = next . weight ) break ; improvements . add ( new Weighted < > ( impr , bestToken ) ) ; } } return ImmutableList . copyOf ( unitToTokens . get ( newUnit ) ) ; } private Collection < Token > generateRandomTokens ( Unit newUnit , int numTokens ) { Set < Token > tokens = new HashSet < > ( numTokens ) ; while ( tokens . size ( ) < numTokens ) { Token token = partitioner . getRandomToken ( ) ; if ( ! sortedTokens . containsKey ( token ) ) { tokens . add ( token ) ; sortedTokens . put ( token , newUnit ) ; unitToTokens . put ( newUnit , token ) ; } } return tokens ; } private Map < Unit , UnitInfo < Unit > > createUnitInfos ( Map < Object , GroupInfo > groups ) { Map < Unit , UnitInfo < Unit > > map = Maps . newHashMap ( ) ; for ( Unit n : sortedTokens . values ( ) ) { UnitInfo < Unit > ni = map . get ( n ) ; if ( ni = = null ) map . put ( n , ni = new UnitInfo < > ( n , <int> , groups , strategy ) ) ; ni . tokenCount + + ; } return map ; } private TokenInfo < Unit > createTokenInfos ( Map < Unit , UnitInfo < Unit > > units , GroupInfo newUnitGroup ) { TokenInfo < Unit > prev = null ; TokenInfo < Unit > first = null ; for ( Map . Entry < Token , Unit > en : sortedTokens . entrySet ( ) ) { Token t = en . getKey ( ) ; UnitInfo < Unit > ni = units . get ( en . getValue ( ) ) ; TokenInfo < Unit > ti = new TokenInfo < > ( t , ni ) ; first = ti . insertAfter ( first , prev ) ; prev = ti ; } TokenInfo < Unit > curr = first ; do { populateTokenInfoAndAdjustUnit ( curr , newUnitGroup ) ; curr = curr . next ; } while ( curr ! = first ) ; return first ; } private CandidateInfo < Unit > createCandidates ( TokenInfo < Unit > tokens , UnitInfo < Unit > newUnitInfo , double initialTokenOwnership ) { TokenInfo < Unit > curr = tokens ; CandidateInfo < Unit > first = null ; CandidateInfo < Unit > prev = null ; do { CandidateInfo < Unit > candidate = new CandidateInfo < Unit > ( partitioner . midpoint ( curr . prev . token , curr . token ) , curr , newUnitInfo ) ; first = candidate . insertAfter ( first , prev ) ; candidate . replicatedOwnership = initialTokenOwnership ; populateCandidate ( candidate ) ; prev = candidate ; curr = curr . next ; } while ( curr ! = tokens ) ; prev . next = first ; return first ; } private void populateCandidate ( CandidateInfo < Unit > candidate ) { populateTokenInfo ( candidate , candidate . owningUnit . group ) ; } private void confirmCandidate ( CandidateInfo < Unit > candidate ) { UnitInfo < Unit > newUnit = candidate . owningUnit ; Token newToken = candidate . token ; sortedTokens . put ( newToken , newUnit . unit ) ; unitToTokens . put ( newUnit . unit , newToken ) ; TokenInfo < Unit > prev = candidate . prevInRing ( ) ; TokenInfo < Unit > newTokenInfo = new TokenInfo < > ( newToken , newUnit ) ; newTokenInfo . replicatedOwnership = candidate . replicatedOwnership ; newTokenInfo . insertAfter ( prev , prev ) ; populateTokenInfoAndAdjustUnit ( newTokenInfo , newUnit . group ) ; ReplicationVisitor replicationVisitor = new ReplicationVisitor ( ) ; assert newTokenInfo . next = = candidate . split ; for ( TokenInfo < Unit > curr = newTokenInfo . next ; ! replicationVisitor . visitedAll ( ) ; curr = curr . next ) { candidate = candidate . next ; populateCandidate ( candidate ) ; if ( ! replicationVisitor . add ( curr . owningUnit . group ) ) continue ; populateTokenInfoAndAdjustUnit ( curr , newUnit . group ) ; } replicationVisitor . clean ( ) ; } private Token populateTokenInfo ( BaseTokenInfo < Unit , ? > token , GroupInfo newUnitGroup ) { GroupInfo tokenGroup = token . owningUnit . group ; PopulateVisitor visitor = new PopulateVisitor ( ) ; Token replicationStart ; Token replicationThreshold = token . token ; GroupInfo currGroup ; for ( TokenInfo < Unit > curr = token . prevInRing ( ) ; ; curr = curr . prev ) { replicationStart = curr . token ; currGroup = curr . owningUnit . group ; if ( ! visitor . add ( currGroup ) ) continue ; if ( visitor . visitedAll ( ) ) break ; replicationThreshold = replicationStart ; if ( currGroup = = tokenGroup ) break ; } if ( newUnitGroup = = tokenGroup ) replicationThreshold = token . token ; else if ( newUnitGroup ! = currGroup & & visitor . seen ( newUnitGroup ) ) replicationThreshold = replicationStart ; visitor . clean ( ) ; token . replicationThreshold = replicationThreshold ; token . replicationStart = replicationStart ; return replicationStart ; } private void populateTokenInfoAndAdjustUnit ( TokenInfo < Unit > populate , GroupInfo newUnitGroup ) { Token replicationStart = populateTokenInfo ( populate , newUnitGroup ) ; double newOwnership = replicationStart . size ( populate . token ) ; double oldOwnership = populate . replicatedOwnership ; populate . replicatedOwnership = newOwnership ; populate . owningUnit . ownership + = newOwnership - oldOwnership ; } private double evaluateImprovement ( CandidateInfo < Unit > candidate , double optTokenOwnership , double newUnitMult ) { double tokenChange = <int> ; UnitInfo < Unit > candidateUnit = candidate . owningUnit ; Token candidateEnd = candidate . token ; UnitAdjustmentTracker < Unit > unitTracker = new UnitAdjustmentTracker < > ( candidateUnit ) ; tokenChange + = applyOwnershipAdjustment ( candidate , candidateUnit , candidate . replicationStart , candidateEnd , optTokenOwnership , unitTracker ) ; ReplicationVisitor replicationVisitor = new ReplicationVisitor ( ) ; for ( TokenInfo < Unit > curr = candidate . split ; ! replicationVisitor . visitedAll ( ) ; curr = curr . next ) { UnitInfo < Unit > currUnit = curr . owningUnit ; if ( ! replicationVisitor . add ( currUnit . group ) ) continue ; Token replicationEnd = curr . token ; Token replicationStart = findUpdatedReplicationStart ( curr , candidate ) ; tokenChange + = applyOwnershipAdjustment ( curr , currUnit , replicationStart , replicationEnd , optTokenOwnership , unitTracker ) ; } replicationVisitor . clean ( ) ; double nodeChange = unitTracker . calculateUnitChange ( newUnitMult , optTokenOwnership ) ; return - ( tokenChange + nodeChange ) ; } private Token findUpdatedReplicationStart ( TokenInfo < Unit > curr , CandidateInfo < Unit > candidate ) { return furtherStartToken ( curr . replicationThreshold , candidate . token , curr . token ) ; } private double applyOwnershipAdjustment ( BaseTokenInfo < Unit , ? > curr , UnitInfo < Unit > currUnit , Token replicationStart , Token replicationEnd , double optTokenOwnership , UnitAdjustmentTracker < Unit > unitTracker ) { double oldOwnership = curr . replicatedOwnership ; double newOwnership = replicationStart . size ( replicationEnd ) ; double tokenCount = currUnit . tokenCount ; assert tokenCount > <int> ; unitTracker . add ( currUnit , newOwnership - oldOwnership ) ; return ( sq ( newOwnership - optTokenOwnership ) - sq ( oldOwnership - optTokenOwnership ) ) / sq ( tokenCount ) ; } private static class UnitAdjustmentTracker < Unit > { UnitInfo < Unit > unitsChain ; UnitAdjustmentTracker ( UnitInfo < Unit > newUnit ) { unitsChain = newUnit ; } void add ( UnitInfo < Unit > currUnit , double diff ) { if ( currUnit . prevUsed = = null ) { assert unitsChain . prevUsed ! = null | | currUnit = = unitsChain ; currUnit . adjustedOwnership = currUnit . ownership + diff ; currUnit . prevUsed = unitsChain ; unitsChain = currUnit ; } else { currUnit . adjustedOwnership + = diff ; } } double calculateUnitChange ( double newUnitMult , double optTokenOwnership ) { double unitChange = <int> ; UnitInfo < Unit > unitsChain = this . unitsChain ; while ( true ) { double newOwnership = unitsChain . adjustedOwnership ; double oldOwnership = unitsChain . ownership ; double tokenCount = unitsChain . tokenCount ; double diff = ( sq ( newOwnership / tokenCount - optTokenOwnership ) - sq ( oldOwnership / tokenCount - optTokenOwnership ) ) ; UnitInfo < Unit > prev = unitsChain . prevUsed ; unitsChain . prevUsed = null ; if ( unitsChain ! = prev ) unitChange + = diff ; else { unitChange + = diff * newUnitMult ; break ; } unitsChain = prev ; } this . unitsChain = unitsChain ; return unitChange ; } } private abstract class GroupVisitor { GroupInfo groupChain = GroupInfo . TERMINATOR ; int seen = <int> ; abstract GroupInfo prevSeen ( GroupInfo group ) ; abstract void setPrevSeen ( GroupInfo group , GroupInfo prevSeen ) ; boolean add ( GroupInfo group ) { if ( prevSeen ( group ) ! = null ) return false ; + + seen ; setPrevSeen ( group , groupChain ) ; groupChain = group ; return true ; } boolean visitedAll ( ) { return seen > = replicas ; } boolean seen ( GroupInfo group ) { return prevSeen ( group ) ! = null ; } void clean ( ) { GroupInfo groupChain = this . groupChain ; while ( groupChain ! = GroupInfo . TERMINATOR ) { GroupInfo prev = prevSeen ( groupChain ) ; setPrevSeen ( groupChain , null ) ; groupChain = prev ; } this . groupChain = GroupInfo . TERMINATOR ; } } private class ReplicationVisitor extends GroupVisitor { GroupInfo prevSeen ( GroupInfo group ) { return group . prevSeen ; } void setPrevSeen ( GroupInfo group , GroupInfo prevSeen ) { group . prevSeen = prevSeen ; } } private class PopulateVisitor extends GroupVisitor { GroupInfo prevSeen ( GroupInfo group ) { return group . prevPopulate ; } void setPrevSeen ( GroupInfo group , GroupInfo prevSeen ) { group . prevPopulate = prevSeen ; } } private Map . Entry < Token , Unit > mapEntryFor ( Token t ) { Map . Entry < Token , Unit > en = sortedTokens . floorEntry ( t ) ; if ( en = = null ) en = sortedTokens . lastEntry ( ) ; return en ; } Unit unitFor ( Token t ) { return mapEntryFor ( t ) . getValue ( ) ; } private double optimalTokenOwnership ( int tokensToAdd ) { return <float> * replicas / ( sortedTokens . size ( ) + tokensToAdd ) ; } private static Token furtherStartToken ( Token t1 , Token t2 , Token towards ) { if ( t1 . equals ( towards ) ) return t2 ; if ( t2 . equals ( towards ) ) return t1 ; return t1 . size ( towards ) > t2 . size ( towards ) ? t1 : t2 ; } private static double sq ( double d ) { return d * d ; } void removeUnit ( Unit n ) { Collection < Token > tokens = unitToTokens . removeAll ( n ) ; sortedTokens . keySet ( ) . removeAll ( tokens ) ; } int unitCount ( ) { return unitToTokens . asMap ( ) . size ( ) ; } public String toString ( ) { return getClass ( ) . getSimpleName ( ) ; } private static < Unit > GroupInfo getGroup ( Unit unit , Map < Object , GroupInfo > groupMap , ReplicationStrategy < Unit > strategy ) { Object groupClass = strategy . getGroup ( unit ) ; GroupInfo group = groupMap . get ( groupClass ) ; if ( group = = null ) groupMap . put ( groupClass , group = new GroupInfo ( groupClass ) ) ; return group ; } private static class GroupInfo { final Object group ; GroupInfo prevSeen = null ; GroupInfo prevPopulate = null ; static GroupInfo TERMINATOR = new GroupInfo ( null ) ; public GroupInfo ( Object group ) { this . group = group ; } public String toString ( ) { return group . toString ( ) + ( prevSeen ! = null ? <str> : <str> ) ; } } static class UnitInfo < Unit > { final Unit unit ; final GroupInfo group ; double ownership ; int tokenCount ; UnitInfo < Unit > prevUsed ; double adjustedOwnership ; private UnitInfo ( Unit unit , GroupInfo group ) { this . unit = unit ; this . group = group ; this . tokenCount = <int> ; } public UnitInfo ( Unit unit , double ownership , Map < Object , GroupInfo > groupMap , ReplicationStrategy < Unit > strategy ) { this ( unit , getGroup ( unit , groupMap , strategy ) ) ; this . ownership = ownership ; } public String toString ( ) { return String . format ( <str> , unit , unit = = group . group ? ( group . prevSeen ! = null ? <str> : <str> ) : <str> + group . toString ( ) , ownership , prevUsed ! = null ? ( prevUsed = = this ? <str> : <str> + prevUsed . toString ( ) ) : <str> ) ; } } private static class CircularList < T extends CircularList < T > > { T prev ; T next ; @SuppressWarnings ( <str> ) T insertAfter ( T head , T unit ) { if ( head = = null ) { return prev = next = ( T ) this ; } assert unit ! = null ; assert unit . next ! = null ; prev = unit ; next = unit . next ; prev . next = ( T ) this ; next . prev = ( T ) this ; return head ; } T removeFrom ( T head ) { next . prev = prev ; prev . next = next ; return this = = head ? ( this = = next ? null : next ) : head ; } } private static class BaseTokenInfo < Unit , T extends BaseTokenInfo < Unit , T > > extends CircularList < T > { final Token token ; final UnitInfo < Unit > owningUnit ; Token replicationStart ; Token replicationThreshold ; double replicatedOwnership = <int> ; public BaseTokenInfo ( Token token , UnitInfo < Unit > owningUnit ) { this . token = token ; this . owningUnit = owningUnit ; } public String toString ( ) { return String . format ( <str> , token , owningUnit ) ; } TokenInfo < Unit > prevInRing ( ) { return null ; } } private static class TokenInfo < Unit > extends BaseTokenInfo < Unit , TokenInfo < Unit > > { public TokenInfo ( Token token , UnitInfo < Unit > owningUnit ) { super ( token , owningUnit ) ; } TokenInfo < Unit > prevInRing ( ) { return prev ; } } private static class CandidateInfo < Unit > extends BaseTokenInfo < Unit , CandidateInfo < Unit > > { final TokenInfo < Unit > split ; public CandidateInfo ( Token token , TokenInfo < Unit > split , UnitInfo < Unit > owningUnit ) { super ( token , owningUnit ) ; this . split = split ; } TokenInfo < Unit > prevInRing ( ) { return split . prev ; } } static void dumpTokens ( String lead , BaseTokenInfo < ? , ? > tokens ) { BaseTokenInfo < ? , ? > token = tokens ; do { System . out . format ( <str> , lead , token , token . replicationStart , token . replicationThreshold , token . replicatedOwnership ) ; token = token . next ; } while ( token ! = null & & token ! = tokens ) ; } static class Weighted < T > implements Comparable < Weighted < T > > { final double weight ; final T value ; public Weighted ( double weight , T value ) { this . weight = weight ; this . value = value ; } @Override public int compareTo ( Weighted < T > o ) { int cmp = Double . compare ( o . weight , this . weight ) ; return cmp ; } @Override public String toString ( ) { return String . format ( <str> , value , weight ) ; } } } 
