package org . apache . cassandra . cql3 . statements ; import java . util . List ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . restrictions . StatementRestrictions ; import org . apache . cassandra . db . Clustering ; import org . apache . cassandra . db . Slice ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . utils . Pair ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkFalse ; import static org . apache . cassandra . cql3 . statements . RequestValidations . checkTrue ; public class DeleteStatement extends ModificationStatement { private DeleteStatement ( int boundTerms , CFMetaData cfm , Operations operations , StatementRestrictions restrictions , Conditions conditions , Attributes attrs ) { super ( StatementType . DELETE , boundTerms , cfm , operations , restrictions , conditions , attrs ) ; } @Override public void addUpdateForKey ( PartitionUpdate update , Clustering clustering , UpdateParameters params ) throws InvalidRequestException { List < Operation > regularDeletions = getRegularOperations ( ) ; List < Operation > staticDeletions = getStaticOperations ( ) ; if ( regularDeletions . isEmpty ( ) & & staticDeletions . isEmpty ( ) ) { if ( clustering . size ( ) = = <int> ) { update . addPartitionDeletion ( params . deletionTime ( ) ) ; } else if ( clustering . size ( ) = = cfm . clusteringColumns ( ) . size ( ) ) { params . newRow ( clustering ) ; params . addRowDeletion ( ) ; update . add ( params . buildRow ( ) ) ; } else { update . add ( params . makeRangeTombstone ( cfm . comparator , clustering ) ) ; } } else { if ( ! regularDeletions . isEmpty ( ) ) { checkFalse ( clustering . size ( ) = = <int> & & cfm . clusteringColumns ( ) . size ( ) ! = <int> , <str> ) ; params . newRow ( clustering ) ; for ( Operation op : regularDeletions ) op . execute ( update . partitionKey ( ) , params ) ; update . add ( params . buildRow ( ) ) ; } if ( ! staticDeletions . isEmpty ( ) ) { params . newRow ( Clustering . STATIC_CLUSTERING ) ; for ( Operation op : staticDeletions ) op . execute ( update . partitionKey ( ) , params ) ; update . add ( params . buildRow ( ) ) ; } } } @Override public void addUpdateForKey ( PartitionUpdate update , Slice slice , UpdateParameters params ) { List < Operation > regularDeletions = getRegularOperations ( ) ; List < Operation > staticDeletions = getStaticOperations ( ) ; checkTrue ( regularDeletions . isEmpty ( ) & & staticDeletions . isEmpty ( ) , <str> ) ; update . add ( params . makeRangeTombstone ( slice ) ) ; } public static class Parsed extends ModificationStatement . Parsed { private final List < Operation . RawDeletion > deletions ; private final WhereClause whereClause ; public Parsed ( CFName name , Attributes . Raw attrs , List < Operation . RawDeletion > deletions , WhereClause whereClause , List < Pair < ColumnIdentifier . Raw , ColumnCondition . Raw > > conditions , boolean ifExists ) { super ( name , StatementType . DELETE , attrs , conditions , false , ifExists ) ; this . deletions = deletions ; this . whereClause = whereClause ; } @Override protected ModificationStatement prepareInternal ( CFMetaData cfm , VariableSpecifications boundNames , Conditions conditions , Attributes attrs ) { Operations operations = new Operations ( type ) ; for ( Operation . RawDeletion deletion : deletions ) { ColumnDefinition def = getColumnDefinition ( cfm , deletion . affectedColumn ( ) ) ; checkFalse ( def . isPrimaryKeyColumn ( ) , <str> , def . name ) ; Operation op = deletion . prepare ( cfm . ksName , def ) ; op . collectMarkerSpecification ( boundNames ) ; operations . add ( op ) ; } StatementRestrictions restrictions = newRestrictions ( cfm , boundNames , operations , whereClause , conditions ) ; DeleteStatement stmt = new DeleteStatement ( boundNames . size ( ) , cfm , operations , restrictions , conditions , attrs ) ; if ( stmt . hasConditions ( ) ) checkTrue ( restrictions . hasAllPKColumnsRestrictedByEqualities ( ) , <str> + <str> ) ; return stmt ; } } } 
