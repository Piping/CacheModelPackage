package org . elasticsearch . plugin . deletebyquery ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . indices . alias . Alias ; import org . elasticsearch . action . deletebyquery . DeleteByQueryAction ; import org . elasticsearch . action . deletebyquery . DeleteByQueryRequestBuilder ; import org . elasticsearch . action . deletebyquery . DeleteByQueryResponse ; import org . elasticsearch . action . deletebyquery . IndexDeleteByQueryResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . index . query . MatchQueryBuilder ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import java . util . Collection ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . ESIntegTestCase . Scope . SUITE ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . nullValue ; @ClusterScope ( scope = SUITE , transportClientRatio = <int> ) public class DeleteByQueryTests extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( DeleteByQueryPlugin . class ) ; } public void testDeleteByQueryWithNoSource ( ) { try { newDeleteByQuery ( ) . get ( ) ; fail ( <str> ) ; } catch ( ActionRequestValidationException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testDeleteByQueryWithNoIndices ( ) throws Exception { DeleteByQueryRequestBuilder delete = newDeleteByQuery ( ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ; delete . setIndicesOptions ( IndicesOptions . fromOptions ( false , true , true , false ) ) ; assertDBQResponse ( delete . get ( ) , <int> L , <int> l , <int> l , <int> l ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByQueryWithOneIndex ( ) throws Exception { final long docs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docs ; i + + ) { index ( <str> , <str> , String . valueOf ( i ) , <str> , <int> ) ; } refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , docs ) ; DeleteByQueryRequestBuilder delete = newDeleteByQuery ( ) . setIndices ( <str> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ; assertDBQResponse ( delete . get ( ) , docs , docs , <int> l , <int> l ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , <int> ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByQueryWithMultipleIndices ( ) throws Exception { final int indices = randomIntBetween ( <int> , <int> ) ; final int docs = randomIntBetween ( <int> , <int> ) * <int> ; long [ ] candidates = new long [ indices ] ; for ( int i = <int> ; i < indices ; i + + ) { candidates [ i ] = randomIntBetween ( <int> , docs ) ; for ( int j = <int> ; j < docs ; j + + ) { boolean candidate = ( j < candidates [ i ] ) ; index ( <str> + i , <str> , String . valueOf ( j ) , <str> , candidate ) ; } } long deletions = <int> ; for ( long i : candidates ) { deletions = deletions + i ; } refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) , docs * indices ) ; for ( int i = <int> ; i < indices ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( <str> + i ) . setSize ( <int> ) . get ( ) , docs ) ; } DeleteByQueryResponse response = newDeleteByQuery ( ) . setIndices ( <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , true ) ) . get ( ) ; refresh ( ) ; assertDBQResponse ( response , deletions , deletions , <int> l , <int> l ) ; assertNotNull ( response . getIndices ( ) ) ; assertThat ( response . getIndices ( ) . length , equalTo ( indices ) ) ; for ( int i = <int> ; i < indices ; i + + ) { String indexName = <str> + i ; IndexDeleteByQueryResponse indexResponse = response . getIndex ( indexName ) ; assertThat ( indexResponse . getFound ( ) , equalTo ( candidates [ i ] ) ) ; assertThat ( indexResponse . getDeleted ( ) , equalTo ( candidates [ i ] ) ) ; assertThat ( indexResponse . getFailed ( ) , equalTo ( <int> L ) ) ; assertThat ( indexResponse . getMissing ( ) , equalTo ( <int> L ) ) ; assertThat ( indexResponse . getIndex ( ) , equalTo ( indexName ) ) ; long remaining = docs - candidates [ i ] ; assertHitCount ( client ( ) . prepareSearch ( indexName ) . setSize ( <int> ) . get ( ) , remaining ) ; } assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) , ( indices * docs ) - deletions ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByQueryWithMissingIndex ( ) throws Exception { client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . setRefresh ( true ) . get ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) , <int> ) ; DeleteByQueryRequestBuilder delete = newDeleteByQuery ( ) . setIndices ( <str> , <str> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ; try { delete . get ( ) ; fail ( <str> ) ; } catch ( IndexNotFoundException e ) { } delete . setIndicesOptions ( IndicesOptions . lenientExpandOpen ( ) ) ; assertDBQResponse ( delete . get ( ) , <int> , <int> , <int> l , <int> l ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , <int> ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByQueryWithTypes ( ) throws Exception { final long docs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docs ; i + + ) { index ( randomFrom ( <str> , <str> , <str> ) , <str> , String . valueOf ( i ) , <str> , <str> ) ; index ( randomFrom ( <str> , <str> , <str> ) , <str> , String . valueOf ( i ) , <str> , <str> ) ; } refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) , docs * <int> ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setTypes ( <str> ) . get ( ) , docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setTypes ( <str> ) . get ( ) , docs ) ; DeleteByQueryRequestBuilder delete = newDeleteByQuery ( ) . setTypes ( <str> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ; assertDBQResponse ( delete . get ( ) , docs , docs , <int> l , <int> l ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) , docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setTypes ( <str> ) . get ( ) , <int> ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setTypes ( <str> ) . get ( ) , docs ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByQueryWithRouting ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . setSettings ( <str> , <int> ) ) ; ensureGreen ( <str> ) ; final int docs = randomIntBetween ( <int> , <int> ) ; logger . info ( <str> , docs ) ; for ( int i = <int> ; i < docs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , String . valueOf ( i ) ) . setRouting ( String . valueOf ( i ) ) . setSource ( <str> , <int> ) . get ( ) ; } refresh ( ) ; logger . info ( <str> , docs ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) , docs ) ; String routing = String . valueOf ( randomIntBetween ( <int> , docs ) ) ; logger . info ( <str> , routing ) ; long expected = client ( ) . prepareSearch ( ) . setSize ( <int> ) . setRouting ( routing ) . get ( ) . getHits ( ) . totalHits ( ) ; logger . info ( <str> , routing ) ; DeleteByQueryRequestBuilder delete = newDeleteByQuery ( ) . setRouting ( routing ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ; assertDBQResponse ( delete . get ( ) , expected , expected , <int> l , <int> l ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . get ( ) , docs - expected ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByFieldQuery ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addAlias ( new Alias ( <str> ) ) ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setRouting ( randomAsciiOfLengthBetween ( <int> , <int> ) ) . setSource ( <str> , <str> ) . get ( ) ; } refresh ( ) ; int n = between ( <int> , numDocs - <int> ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchQuery ( <str> , Integer . toString ( n ) ) ) . get ( ) , <int> ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . get ( ) , numDocs ) ; DeleteByQueryRequestBuilder delete = newDeleteByQuery ( ) . setIndices ( <str> ) . setQuery ( QueryBuilders . matchQuery ( <str> , Integer . toString ( n ) ) ) ; assertDBQResponse ( delete . get ( ) , <int> , <int> , <int> l , <int> l ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . get ( ) , numDocs - <int> ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByQueryWithDateMath ( ) throws Exception { index ( <str> , <str> , <str> , <str> , <str> ) ; ensureGreen ( ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , <int> ) ; DeleteByQueryRequestBuilder delete = newDeleteByQuery ( ) . setIndices ( <str> ) . setQuery ( QueryBuilders . rangeQuery ( <str> ) . to ( <str> ) ) ; assertDBQResponse ( delete . get ( ) , <int> , <int> , <int> l , <int> l ) ; refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , <int> ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByTermQuery ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] indexRequestBuilders = new IndexRequestBuilder [ numDocs + <int> ] ; for ( int i = <int> ; i < numDocs ; i + + ) { indexRequestBuilders [ i ] = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( <str> , <str> ) ; } indexRequestBuilders [ numDocs ] = client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( numDocs ) ) . setSource ( <str> , <str> ) ; indexRandom ( true , indexRequestBuilders ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( ( long ) numDocs + <int> ) ) ; DeleteByQueryResponse delete = newDeleteByQuery ( ) . setIndices ( <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , <str> ) ) . get ( ) ; assertDBQResponse ( delete , numDocs , numDocs , <int> l , <int> l ) ; refresh ( ) ; searchResponse = client ( ) . prepareSearch ( <str> ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertSearchContextsClosed ( ) ; } public void testConcurrentDeleteByQueriesOnDifferentDocs ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; final Thread [ ] threads = new Thread [ scaledRandomIntBetween ( <int> , <int> ) ] ; final long docs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docs ; i + + ) { for ( int j = <int> ; j < threads . length ; j + + ) { index ( <str> , <str> , String . valueOf ( i * <int> + j ) , <str> , j ) ; } } refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , docs * threads . length ) ; final CountDownLatch start = new CountDownLatch ( <int> ) ; final AtomicReference < Throwable > exceptionHolder = new AtomicReference < > ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { final int threadNum = i ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( QueryBuilders . termQuery ( <str> , threadNum ) ) . get ( ) , docs ) ; Runnable r = new Runnable ( ) { @Override public void run ( ) { try { start . await ( ) ; DeleteByQueryResponse rsp = newDeleteByQuery ( ) . setQuery ( QueryBuilders . termQuery ( <str> , threadNum ) ) . get ( ) ; assertDBQResponse ( rsp , docs , docs , <int> L , <int> L ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } catch ( Throwable e ) { exceptionHolder . set ( e ) ; Thread . currentThread ( ) . interrupt ( ) ; } } } ; threads [ i ] = new Thread ( r ) ; threads [ i ] . start ( ) ; } start . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } Throwable assertionError = exceptionHolder . get ( ) ; if ( assertionError ! = null ) { assertionError . printStackTrace ( ) ; } assertThat ( assertionError + <str> , assertionError , nullValue ( ) ) ; refresh ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( QueryBuilders . termQuery ( <str> , i ) ) . get ( ) , <int> ) ; } assertSearchContextsClosed ( ) ; } public void testConcurrentDeleteByQueriesOnSameDocs ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , - <int> ) ) ) ; ensureGreen ( ) ; final long docs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docs ; i + + ) { index ( <str> , <str> , String . valueOf ( i ) , <str> , <str> ) ; } refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , docs ) ; final Thread [ ] threads = new Thread [ scaledRandomIntBetween ( <int> , <int> ) ] ; final CountDownLatch start = new CountDownLatch ( <int> ) ; final AtomicReference < Throwable > exceptionHolder = new AtomicReference < > ( ) ; final MatchQueryBuilder query = QueryBuilders . matchQuery ( <str> , <str> ) ; final AtomicLong deleted = new AtomicLong ( <int> ) ; for ( int i = <int> ; i < threads . length ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . setQuery ( query ) . get ( ) , docs ) ; Runnable r = new Runnable ( ) { @Override public void run ( ) { try { start . await ( ) ; DeleteByQueryResponse rsp = newDeleteByQuery ( ) . setQuery ( query ) . get ( ) ; deleted . addAndGet ( rsp . getTotalDeleted ( ) ) ; assertThat ( rsp . getTotalFound ( ) , equalTo ( docs ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } catch ( Throwable e ) { exceptionHolder . set ( e ) ; Thread . currentThread ( ) . interrupt ( ) ; } } } ; threads [ i ] = new Thread ( r ) ; threads [ i ] . start ( ) ; } start . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } refresh ( ) ; Throwable assertionError = exceptionHolder . get ( ) ; if ( assertionError ! = null ) { assertionError . printStackTrace ( ) ; } assertThat ( assertionError + <str> , assertionError , nullValue ( ) ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , <int> L ) ; assertThat ( deleted . get ( ) , equalTo ( docs ) ) ; assertSearchContextsClosed ( ) ; } public void testDeleteByQueryOnReadOnlyIndex ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; final long docs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < docs ; i + + ) { index ( <str> , <str> , String . valueOf ( i ) , <str> , <int> ) ; } refresh ( ) ; assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , docs ) ; try { enableIndexBlock ( <str> , IndexMetaData . SETTING_READ_ONLY ) ; DeleteByQueryResponse rsp = newDeleteByQuery ( ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . get ( ) ; assertDBQResponse ( rsp , docs , <int> L , docs , <int> L ) ; } finally { disableIndexBlock ( <str> , IndexMetaData . SETTING_READ_ONLY ) ; } assertHitCount ( client ( ) . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) , docs ) ; assertSearchContextsClosed ( ) ; } private DeleteByQueryRequestBuilder newDeleteByQuery ( ) { return new DeleteByQueryRequestBuilder ( client ( ) , DeleteByQueryAction . INSTANCE ) ; } private void assertDBQResponse ( DeleteByQueryResponse response , long found , long deleted , long failed , long missing ) { assertNotNull ( response ) ; assertThat ( response . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( response . getShardFailures ( ) . length , equalTo ( <int> ) ) ; assertThat ( response . getTotalFound ( ) , equalTo ( found ) ) ; assertThat ( response . getTotalDeleted ( ) , equalTo ( deleted ) ) ; assertThat ( response . getTotalFailed ( ) , equalTo ( failed ) ) ; assertThat ( response . getTotalMissing ( ) , equalTo ( missing ) ) ; } private void assertSearchContextsClosed ( ) throws Exception { assertBusy ( new Runnable ( ) { @Override public void run ( ) { NodesStatsResponse nodesStats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . setIndices ( true ) . get ( ) ; for ( NodeStats nodeStat : nodesStats . getNodes ( ) ) { assertThat ( nodeStat . getIndices ( ) . getSearch ( ) . getOpenContexts ( ) , equalTo ( <int> L ) ) ; } } } ) ; } } 
