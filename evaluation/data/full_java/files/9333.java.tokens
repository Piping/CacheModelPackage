package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Function ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . RandomAccess ; import javax . annotation . Nullable ; @GwtCompatible @Beta final class SortedLists { private SortedLists ( ) { } public enum KeyPresentBehavior { ANY_PRESENT { @Override < E > int resultIndex ( Comparator < ? super E > comparator , E key , List < ? extends E > list , int foundIndex ) { return foundIndex ; } } , LAST_PRESENT { @Override < E > int resultIndex ( Comparator < ? super E > comparator , E key , List < ? extends E > list , int foundIndex ) { int lower = foundIndex ; int upper = list . size ( ) - <int> ; while ( lower < upper ) { int middle = ( lower + upper + <int> ) > > > <int> ; int c = comparator . compare ( list . get ( middle ) , key ) ; if ( c > <int> ) { upper = middle - <int> ; } else { lower = middle ; } } return lower ; } } , FIRST_PRESENT { @Override < E > int resultIndex ( Comparator < ? super E > comparator , E key , List < ? extends E > list , int foundIndex ) { int lower = <int> ; int upper = foundIndex ; while ( lower < upper ) { int middle = ( lower + upper ) > > > <int> ; int c = comparator . compare ( list . get ( middle ) , key ) ; if ( c < <int> ) { lower = middle + <int> ; } else { upper = middle ; } } return lower ; } } , FIRST_AFTER { @Override public < E > int resultIndex ( Comparator < ? super E > comparator , E key , List < ? extends E > list , int foundIndex ) { return LAST_PRESENT . resultIndex ( comparator , key , list , foundIndex ) + <int> ; } } , LAST_BEFORE { @Override public < E > int resultIndex ( Comparator < ? super E > comparator , E key , List < ? extends E > list , int foundIndex ) { return FIRST_PRESENT . resultIndex ( comparator , key , list , foundIndex ) - <int> ; } } ; abstract < E > int resultIndex ( Comparator < ? super E > comparator , E key , List < ? extends E > list , int foundIndex ) ; } public enum KeyAbsentBehavior { NEXT_LOWER { @Override int resultIndex ( int higherIndex ) { return higherIndex - <int> ; } } , NEXT_HIGHER { @Override public int resultIndex ( int higherIndex ) { return higherIndex ; } } , INVERTED_INSERTION_INDEX { @Override public int resultIndex ( int higherIndex ) { return ~ higherIndex ; } } ; abstract int resultIndex ( int higherIndex ) ; } public static < E extends Comparable > int binarySearch ( List < ? extends E > list , E e , KeyPresentBehavior presentBehavior , KeyAbsentBehavior absentBehavior ) { checkNotNull ( e ) ; return binarySearch ( list , e , Ordering . natural ( ) , presentBehavior , absentBehavior ) ; } public static < E , K extends Comparable > int binarySearch ( List < E > list , Function < ? super E , K > keyFunction , @Nullable K key , KeyPresentBehavior presentBehavior , KeyAbsentBehavior absentBehavior ) { return binarySearch ( list , keyFunction , key , Ordering . natural ( ) , presentBehavior , absentBehavior ) ; } public static < E , K > int binarySearch ( List < E > list , Function < ? super E , K > keyFunction , @Nullable K key , Comparator < ? super K > keyComparator , KeyPresentBehavior presentBehavior , KeyAbsentBehavior absentBehavior ) { return binarySearch ( Lists . transform ( list , keyFunction ) , key , keyComparator , presentBehavior , absentBehavior ) ; } public static < E > int binarySearch ( List < ? extends E > list , @Nullable E key , Comparator < ? super E > comparator , KeyPresentBehavior presentBehavior , KeyAbsentBehavior absentBehavior ) { checkNotNull ( comparator ) ; checkNotNull ( list ) ; checkNotNull ( presentBehavior ) ; checkNotNull ( absentBehavior ) ; if ( ! ( list instanceof RandomAccess ) ) { list = Lists . newArrayList ( list ) ; } int lower = <int> ; int upper = list . size ( ) - <int> ; while ( lower < = upper ) { int middle = ( lower + upper ) > > > <int> ; int c = comparator . compare ( key , list . get ( middle ) ) ; if ( c < <int> ) { upper = middle - <int> ; } else if ( c > <int> ) { lower = middle + <int> ; } else { return lower + presentBehavior . resultIndex ( comparator , key , list . subList ( lower , upper + <int> ) , middle - lower ) ; } } return absentBehavior . resultIndex ( lower ) ; } } 
