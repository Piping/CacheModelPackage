package org . gradle . nativeplatform . internal . configure ; import org . gradle . api . Action ; import org . gradle . api . Transformer ; import org . gradle . internal . service . ServiceRegistry ; import org . gradle . language . nativeplatform . HeaderExportingSourceSet ; import org . gradle . model . Defaults ; import org . gradle . model . Finalize ; import org . gradle . model . RuleSource ; import org . gradle . nativeplatform . * ; import org . gradle . nativeplatform . internal . TargetedNativeComponentInternal ; import org . gradle . nativeplatform . internal . resolve . NativeDependencyResolver ; import org . gradle . nativeplatform . platform . NativePlatform ; import org . gradle . nativeplatform . platform . internal . NativePlatformInternal ; import org . gradle . nativeplatform . platform . internal . NativePlatforms ; import org . gradle . platform . base . internal . * ; import org . gradle . util . CollectionUtils ; import java . util . Collections ; import java . util . List ; import java . util . Set ; @SuppressWarnings ( <str> ) public class NativeComponentRules extends RuleSource { @Defaults public void applyHeaderSourceSetConventions ( final NativeComponentSpec component ) { component . getSources ( ) . withType ( HeaderExportingSourceSet . class ) . afterEach ( new Action < HeaderExportingSourceSet > ( ) { @Override public void execute ( HeaderExportingSourceSet headerSourceSet ) { if ( headerSourceSet . getExportedHeaders ( ) . getSrcDirs ( ) . isEmpty ( ) ) { headerSourceSet . getExportedHeaders ( ) . srcDir ( String . format ( <str> , component . getName ( ) ) ) ; } headerSourceSet . getImplicitHeaders ( ) . setSrcDirs ( headerSourceSet . getSource ( ) . getSrcDirs ( ) ) ; headerSourceSet . getImplicitHeaders ( ) . include ( <str> ) ; } } ) ; } @Finalize public static void createBinaries ( NativeComponentSpec nativeComponent , PlatformResolvers platforms , BuildTypeContainer buildTypes , FlavorContainer flavors , ServiceRegistry serviceRegistry ) { final NativePlatforms nativePlatforms = serviceRegistry . get ( NativePlatforms . class ) ; final NativeDependencyResolver nativeDependencyResolver = serviceRegistry . get ( NativeDependencyResolver . class ) ; createBinariesImpl ( nativeComponent , platforms , buildTypes , flavors , nativePlatforms , nativeDependencyResolver ) ; } static void createBinariesImpl ( NativeComponentSpec nativeComponent , PlatformResolvers platforms , Set < ? extends BuildType > buildTypes , Set < ? extends Flavor > flavors , NativePlatforms nativePlatforms , NativeDependencyResolver nativeDependencyResolver ) { if ( ! ( nativeComponent instanceof TargetedNativeComponentInternal ) ) { return ; } TargetedNativeComponentInternal targetedComponent = ( TargetedNativeComponentInternal ) nativeComponent ; List < NativePlatform > resolvedPlatforms = resolvePlatforms ( targetedComponent , nativePlatforms , platforms ) ; for ( NativePlatform platform : resolvedPlatforms ) { BinaryNamingScheme namingScheme = DefaultBinaryNamingScheme . component ( nativeComponent . getName ( ) ) ; namingScheme = namingScheme . withVariantDimension ( platform , resolvedPlatforms ) ; executeForEachBuildType ( nativeComponent , ( NativePlatformInternal ) platform , namingScheme , buildTypes , flavors , nativeDependencyResolver ) ; } } private static List < NativePlatform > resolvePlatforms ( TargetedNativeComponentInternal targetedComponent , NativePlatforms nativePlatforms , final PlatformResolvers platforms ) { List < PlatformRequirement > targetPlatforms = targetedComponent . getTargetPlatforms ( ) ; if ( targetPlatforms . isEmpty ( ) ) { PlatformRequirement requirement = DefaultPlatformRequirement . create ( nativePlatforms . getDefaultPlatformName ( ) ) ; targetPlatforms = Collections . singletonList ( requirement ) ; } return CollectionUtils . collect ( targetPlatforms , new Transformer < NativePlatform , PlatformRequirement > ( ) { @Override public NativePlatform transform ( PlatformRequirement platformRequirement ) { return platforms . resolve ( NativePlatform . class , platformRequirement ) ; } } ) ; } private static void executeForEachBuildType ( NativeComponentSpec projectNativeComponent , NativePlatformInternal platform , BinaryNamingScheme namingScheme , Set < ? extends BuildType > allBuildTypes , Set < ? extends Flavor > allFlavors , NativeDependencyResolver nativeDependencyResolver ) { Set < BuildType > targetBuildTypes = ( ( TargetedNativeComponentInternal ) projectNativeComponent ) . chooseBuildTypes ( allBuildTypes ) ; for ( BuildType buildType : targetBuildTypes ) { BinaryNamingScheme namingSchemeWithBuildType = namingScheme . withVariantDimension ( buildType , targetBuildTypes ) ; executeForEachFlavor ( projectNativeComponent , platform , buildType , namingSchemeWithBuildType , allFlavors , nativeDependencyResolver ) ; } } private static void executeForEachFlavor ( NativeComponentSpec projectNativeComponent , NativePlatform platform , BuildType buildType , BinaryNamingScheme namingScheme , Set < ? extends Flavor > allFlavors , NativeDependencyResolver nativeDependencyResolver ) { Set < Flavor > targetFlavors = ( ( TargetedNativeComponentInternal ) projectNativeComponent ) . chooseFlavors ( allFlavors ) ; for ( Flavor flavor : targetFlavors ) { BinaryNamingScheme namingSchemeWithFlavor = namingScheme . withVariantDimension ( flavor , targetFlavors ) ; NativeBinaries . createNativeBinaries ( projectNativeComponent , projectNativeComponent . getBinaries ( ) . withType ( NativeBinarySpec . class ) , nativeDependencyResolver , namingSchemeWithFlavor , platform , buildType , flavor ) ; } } } 
