package io . netty . util ; import io . netty . util . concurrent . FastThreadLocal ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . lang . ref . WeakReference ; import java . util . Arrays ; import java . util . Map ; import java . util . WeakHashMap ; import java . util . concurrent . atomic . AtomicInteger ; public abstract class Recycler < T > { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( Recycler . class ) ; @SuppressWarnings ( <str> ) private static final Handle NOOP_HANDLE = new Handle ( ) { @Override public void recycle ( Object object ) { } } ; private static final AtomicInteger ID_GENERATOR = new AtomicInteger ( Integer . MIN_VALUE ) ; private static final int OWN_THREAD_ID = ID_GENERATOR . getAndIncrement ( ) ; private static final int DEFAULT_INITIAL_MAX_CAPACITY = <int> ; private static final int DEFAULT_MAX_CAPACITY ; private static final int INITIAL_CAPACITY ; static { int maxCapacity = SystemPropertyUtil . getInt ( <str> , DEFAULT_INITIAL_MAX_CAPACITY ) ; if ( maxCapacity < = <int> ) { maxCapacity = <int> ; } DEFAULT_MAX_CAPACITY = maxCapacity ; if ( logger . isDebugEnabled ( ) ) { if ( DEFAULT_MAX_CAPACITY = = <int> ) { logger . debug ( <str> ) ; } else { logger . debug ( <str> , DEFAULT_MAX_CAPACITY ) ; } } INITIAL_CAPACITY = Math . min ( DEFAULT_MAX_CAPACITY , <int> ) ; } private final int maxCapacity ; private final FastThreadLocal < Stack < T > > threadLocal = new FastThreadLocal < Stack < T > > ( ) { @Override protected Stack < T > initialValue ( ) { return new Stack < T > ( Recycler . this , Thread . currentThread ( ) , maxCapacity ) ; } } ; protected Recycler ( ) { this ( DEFAULT_MAX_CAPACITY ) ; } protected Recycler ( int maxCapacity ) { this . maxCapacity = Math . max ( <int> , maxCapacity ) ; } @SuppressWarnings ( <str> ) public final T get ( ) { if ( maxCapacity = = <int> ) { return newObject ( ( Handle < T > ) NOOP_HANDLE ) ; } Stack < T > stack = threadLocal . get ( ) ; DefaultHandle < T > handle = stack . pop ( ) ; if ( handle = = null ) { handle = stack . newHandle ( ) ; handle . value = newObject ( handle ) ; } return ( T ) handle . value ; } public final boolean recycle ( T o , Handle < T > handle ) { if ( handle = = NOOP_HANDLE ) { return false ; } DefaultHandle < T > h = ( DefaultHandle < T > ) handle ; if ( h . stack . parent ! = this ) { return false ; } h . recycle ( o ) ; return true ; } final int threadLocalCapacity ( ) { return threadLocal . get ( ) . elements . length ; } final int threadLocalSize ( ) { return threadLocal . get ( ) . size ; } protected abstract T newObject ( Handle < T > handle ) ; public interface Handle < T > { void recycle ( T object ) ; } static final class DefaultHandle < T > implements Handle < T > { private int lastRecycledId ; private int recycleId ; private Stack < ? > stack ; private Object value ; DefaultHandle ( Stack < ? > stack ) { this . stack = stack ; } @Override public void recycle ( Object object ) { if ( object ! = value ) { throw new IllegalArgumentException ( <str> ) ; } Thread thread = Thread . currentThread ( ) ; if ( thread = = stack . thread ) { stack . push ( this ) ; return ; } Map < Stack < ? > , WeakOrderQueue > delayedRecycled = DELAYED_RECYCLED . get ( ) ; WeakOrderQueue queue = delayedRecycled . get ( stack ) ; if ( queue = = null ) { delayedRecycled . put ( stack , queue = new WeakOrderQueue ( stack , thread ) ) ; } queue . add ( this ) ; } } private static final FastThreadLocal < Map < Stack < ? > , WeakOrderQueue > > DELAYED_RECYCLED = new FastThreadLocal < Map < Stack < ? > , WeakOrderQueue > > ( ) { @Override protected Map < Stack < ? > , WeakOrderQueue > initialValue ( ) { return new WeakHashMap < Stack < ? > , WeakOrderQueue > ( ) ; } } ; private static final class WeakOrderQueue { private static final int LINK_CAPACITY = <int> ; @SuppressWarnings ( <str> ) private static final class Link extends AtomicInteger { private final DefaultHandle < ? > [ ] elements = new DefaultHandle [ LINK_CAPACITY ] ; private int readIndex ; private Link next ; } private Link head , tail ; private WeakOrderQueue next ; private final WeakReference < Thread > owner ; private final int id = ID_GENERATOR . getAndIncrement ( ) ; WeakOrderQueue ( Stack < ? > stack , Thread thread ) { head = tail = new Link ( ) ; owner = new WeakReference < Thread > ( thread ) ; synchronized ( stack ) { next = stack . head ; stack . head = this ; } } void add ( DefaultHandle < ? > handle ) { handle . lastRecycledId = id ; Link tail = this . tail ; int writeIndex ; if ( ( writeIndex = tail . get ( ) ) = = LINK_CAPACITY ) { this . tail = tail = tail . next = new Link ( ) ; writeIndex = tail . get ( ) ; } tail . elements [ writeIndex ] = handle ; handle . stack = null ; tail . lazySet ( writeIndex + <int> ) ; } boolean hasFinalData ( ) { return tail . readIndex ! = tail . get ( ) ; } @SuppressWarnings ( <str> ) boolean transfer ( Stack < ? > dst ) { Link head = this . head ; if ( head = = null ) { return false ; } if ( head . readIndex = = LINK_CAPACITY ) { if ( head . next = = null ) { return false ; } this . head = head = head . next ; } final int srcStart = head . readIndex ; int srcEnd = head . get ( ) ; final int srcSize = srcEnd - srcStart ; if ( srcSize = = <int> ) { return false ; } final int dstSize = dst . size ; final int expectedCapacity = dstSize + srcSize ; if ( expectedCapacity > dst . elements . length ) { final int actualCapacity = dst . increaseCapacity ( expectedCapacity ) ; srcEnd = Math . min ( srcStart + actualCapacity - dstSize , srcEnd ) ; } if ( srcStart ! = srcEnd ) { final DefaultHandle [ ] srcElems = head . elements ; final DefaultHandle [ ] dstElems = dst . elements ; int newDstSize = dstSize ; for ( int i = srcStart ; i < srcEnd ; i + + ) { DefaultHandle element = srcElems [ i ] ; if ( element . recycleId = = <int> ) { element . recycleId = element . lastRecycledId ; } else if ( element . recycleId ! = element . lastRecycledId ) { throw new IllegalStateException ( <str> ) ; } element . stack = dst ; dstElems [ newDstSize + + ] = element ; srcElems [ i ] = null ; } dst . size = newDstSize ; if ( srcEnd = = LINK_CAPACITY & & head . next ! = null ) { this . head = head . next ; } head . readIndex = srcEnd ; return true ; } else { return false ; } } } static final class Stack < T > { final Recycler < T > parent ; final Thread thread ; private DefaultHandle < ? > [ ] elements ; private final int maxCapacity ; private int size ; private volatile WeakOrderQueue head ; private WeakOrderQueue cursor , prev ; Stack ( Recycler < T > parent , Thread thread , int maxCapacity ) { this . parent = parent ; this . thread = thread ; this . maxCapacity = maxCapacity ; elements = new DefaultHandle [ Math . min ( INITIAL_CAPACITY , maxCapacity ) ] ; } int increaseCapacity ( int expectedCapacity ) { int newCapacity = elements . length ; int maxCapacity = this . maxCapacity ; do { newCapacity < < = <int> ; } while ( newCapacity < expectedCapacity & & newCapacity < maxCapacity ) ; newCapacity = Math . min ( newCapacity , maxCapacity ) ; if ( newCapacity ! = elements . length ) { elements = Arrays . copyOf ( elements , newCapacity ) ; } return newCapacity ; } @SuppressWarnings ( { <str> , <str> } ) DefaultHandle < T > pop ( ) { int size = this . size ; if ( size = = <int> ) { if ( ! scavenge ( ) ) { return null ; } size = this . size ; } size - - ; DefaultHandle ret = elements [ size ] ; if ( ret . lastRecycledId ! = ret . recycleId ) { throw new IllegalStateException ( <str> ) ; } ret . recycleId = <int> ; ret . lastRecycledId = <int> ; this . size = size ; return ret ; } boolean scavenge ( ) { if ( scavengeSome ( ) ) { return true ; } prev = null ; cursor = head ; return false ; } boolean scavengeSome ( ) { WeakOrderQueue cursor = this . cursor ; if ( cursor = = null ) { cursor = head ; if ( cursor = = null ) { return false ; } } boolean success = false ; WeakOrderQueue prev = this . prev ; do { if ( cursor . transfer ( this ) ) { success = true ; break ; } WeakOrderQueue next = cursor . next ; if ( cursor . owner . get ( ) = = null ) { if ( cursor . hasFinalData ( ) ) { for ( ; ; ) { if ( cursor . transfer ( this ) ) { success = true ; } else { break ; } } } if ( prev ! = null ) { prev . next = next ; } } else { prev = cursor ; } cursor = next ; } while ( cursor ! = null & & ! success ) ; this . prev = prev ; this . cursor = cursor ; return success ; } void push ( DefaultHandle < ? > item ) { if ( ( item . recycleId | item . lastRecycledId ) ! = <int> ) { throw new IllegalStateException ( <str> ) ; } item . recycleId = item . lastRecycledId = OWN_THREAD_ID ; int size = this . size ; if ( size > = maxCapacity ) { return ; } if ( size = = elements . length ) { elements = Arrays . copyOf ( elements , Math . min ( size < < <int> , maxCapacity ) ) ; } elements [ size ] = item ; this . size = size + <int> ; } DefaultHandle < T > newHandle ( ) { return new DefaultHandle < T > ( this ) ; } } } 
