package org . elasticsearch . index . translog ; import org . apache . lucene . codecs . CodecUtil ; import org . apache . lucene . store . OutputStreamDataOutput ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . IOUtils ; import org . apache . lucene . util . RamUsageEstimator ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . Channels ; import org . elasticsearch . common . util . Callback ; import org . elasticsearch . common . util . concurrent . ReleasableLock ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . FileChannel ; import java . nio . file . * ; import java . util . concurrent . locks . ReadWriteLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; public class TranslogWriter extends TranslogReader { public static final String TRANSLOG_CODEC = <str> ; public static final int VERSION_CHECKSUMS = <int> ; public static final int VERSION_CHECKPOINTS = <int> ; public static final int VERSION = VERSION_CHECKPOINTS ; protected final ShardId shardId ; protected final ReleasableLock readLock ; protected final ReleasableLock writeLock ; protected volatile long lastSyncedOffset ; protected volatile int operationCounter ; protected volatile long writtenOffset ; public TranslogWriter ( ShardId shardId , long generation , ChannelReference channelReference ) throws IOException { super ( generation , channelReference , channelReference . getChannel ( ) . position ( ) ) ; this . shardId = shardId ; ReadWriteLock rwl = new ReentrantReadWriteLock ( ) ; readLock = new ReleasableLock ( rwl . readLock ( ) ) ; writeLock = new ReleasableLock ( rwl . writeLock ( ) ) ; this . writtenOffset = channelReference . getChannel ( ) . position ( ) ; this . lastSyncedOffset = channelReference . getChannel ( ) . position ( ) ; ; } public static TranslogWriter create ( Type type , ShardId shardId , String translogUUID , long fileGeneration , Path file , Callback < ChannelReference > onClose , int bufferSize ) throws IOException { final BytesRef ref = new BytesRef ( translogUUID ) ; final int headerLength = CodecUtil . headerLength ( TRANSLOG_CODEC ) + ref . length + RamUsageEstimator . NUM_BYTES_INT ; final FileChannel channel = FileChannel . open ( file , StandardOpenOption . WRITE , StandardOpenOption . READ , StandardOpenOption . CREATE_NEW ) ; try { final OutputStreamDataOutput out = new OutputStreamDataOutput ( java . nio . channels . Channels . newOutputStream ( channel ) ) ; CodecUtil . writeHeader ( out , TRANSLOG_CODEC , VERSION ) ; out . writeInt ( ref . length ) ; out . writeBytes ( ref . bytes , ref . offset , ref . length ) ; channel . force ( false ) ; writeCheckpoint ( headerLength , <int> , file . getParent ( ) , fileGeneration , StandardOpenOption . WRITE ) ; final TranslogWriter writer = type . create ( shardId , fileGeneration , new ChannelReference ( file , fileGeneration , channel , onClose ) , bufferSize ) ; return writer ; } catch ( Throwable throwable ) { IOUtils . closeWhileHandlingException ( channel ) ; try { Files . delete ( file ) ; } catch ( IOException ex ) { throwable . addSuppressed ( ex ) ; } throw throwable ; } } public enum Type { SIMPLE ( ) { @Override public TranslogWriter create ( ShardId shardId , long generation , ChannelReference channelReference , int bufferSize ) throws IOException { return new TranslogWriter ( shardId , generation , channelReference ) ; } } , BUFFERED ( ) { @Override public TranslogWriter create ( ShardId shardId , long generation , ChannelReference channelReference , int bufferSize ) throws IOException { return new BufferingTranslogWriter ( shardId , generation , channelReference , bufferSize ) ; } } ; public abstract TranslogWriter create ( ShardId shardId , long generation , ChannelReference raf , int bufferSize ) throws IOException ; public static Type fromString ( String type ) { if ( SIMPLE . name ( ) . equalsIgnoreCase ( type ) ) { return SIMPLE ; } else if ( BUFFERED . name ( ) . equalsIgnoreCase ( type ) ) { return BUFFERED ; } throw new IllegalArgumentException ( <str> + type + <str> ) ; } } public Translog . Location add ( BytesReference data ) throws IOException { final long position ; try ( ReleasableLock lock = writeLock . acquire ( ) ) { ensureOpen ( ) ; position = writtenOffset ; data . writeTo ( channel ) ; writtenOffset = writtenOffset + data . length ( ) ; operationCounter = operationCounter + <int> ; } return new Translog . Location ( generation , position , data . length ( ) ) ; } public void updateBufferSize ( int bufferSize ) throws TranslogException { } public void sync ( ) throws IOException { if ( syncNeeded ( ) ) { try ( ReleasableLock lock = writeLock . acquire ( ) ) { lastSyncedOffset = writtenOffset ; checkpoint ( lastSyncedOffset , operationCounter , channelReference ) ; } } } public boolean syncNeeded ( ) { return writtenOffset ! = lastSyncedOffset ; } @Override public int totalOperations ( ) { return operationCounter ; } @Override public long sizeInBytes ( ) { return writtenOffset ; } protected void flush ( ) throws IOException { } public TranslogReader newReaderFromWriter ( ) { ensureOpen ( ) ; channelReference . incRef ( ) ; boolean success = false ; try { TranslogReader reader = new InnerReader ( this . generation , firstOperationOffset , channelReference ) ; success = true ; return reader ; } finally { if ( ! success ) { channelReference . decRef ( ) ; } } } public ImmutableTranslogReader immutableReader ( ) throws TranslogException { if ( channelReference . tryIncRef ( ) ) { try ( ReleasableLock lock = writeLock . acquire ( ) ) { ensureOpen ( ) ; flush ( ) ; ImmutableTranslogReader reader = new ImmutableTranslogReader ( this . generation , channelReference , firstOperationOffset , writtenOffset , operationCounter ) ; channelReference . incRef ( ) ; return reader ; } catch ( Exception e ) { throw new TranslogException ( shardId , <str> , e ) ; } finally { channelReference . decRef ( ) ; } } else { throw new TranslogException ( shardId , <str> + channelReference + <str> ) ; } } boolean assertBytesAtLocation ( Translog . Location location , BytesReference expectedBytes ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( location . size ) ; readBytes ( buffer , location . translogLocation ) ; return new BytesArray ( buffer . array ( ) ) . equals ( expectedBytes ) ; } final class InnerReader extends TranslogReader { public InnerReader ( long generation , long fistOperationOffset , ChannelReference channelReference ) { super ( generation , channelReference , fistOperationOffset ) ; } @Override public long sizeInBytes ( ) { return TranslogWriter . this . sizeInBytes ( ) ; } @Override public int totalOperations ( ) { return TranslogWriter . this . totalOperations ( ) ; } @Override protected void readBytes ( ByteBuffer buffer , long position ) throws IOException { TranslogWriter . this . readBytes ( buffer , position ) ; } } public boolean syncUpTo ( long offset ) throws IOException { if ( lastSyncedOffset < offset ) { sync ( ) ; return true ; } return false ; } @Override protected final void doClose ( ) throws IOException { try ( ReleasableLock lock = writeLock . acquire ( ) ) { sync ( ) ; } finally { super . doClose ( ) ; } } @Override protected void readBytes ( ByteBuffer buffer , long position ) throws IOException { try ( ReleasableLock lock = readLock . acquire ( ) ) { Channels . readFromFileChannelWithEofException ( channel , position , buffer ) ; } } protected synchronized void checkpoint ( long lastSyncPosition , int operationCounter , ChannelReference channelReference ) throws IOException { channelReference . getChannel ( ) . force ( false ) ; writeCheckpoint ( lastSyncPosition , operationCounter , channelReference . getPath ( ) . getParent ( ) , channelReference . getGeneration ( ) , StandardOpenOption . WRITE ) ; } private static void writeCheckpoint ( long syncPosition , int numOperations , Path translogFile , long generation , OpenOption . . . options ) throws IOException { final Path checkpointFile = translogFile . resolve ( Translog . CHECKPOINT_FILE_NAME ) ; Checkpoint checkpoint = new Checkpoint ( syncPosition , numOperations , generation ) ; Checkpoint . write ( checkpointFile , checkpoint , options ) ; } } 
