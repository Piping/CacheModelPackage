package clojure . asm ; final class Frame { static final int DIM = <hex> ; static final int ARRAY_OF = <hex> ; static final int ELEMENT_OF = <hex> ; static final int KIND = <hex> ; static final int TOP_IF_LONG_OR_DOUBLE = <hex> ; static final int VALUE = <hex> ; static final int BASE_KIND = <hex> ; static final int BASE_VALUE = <hex> ; static final int BASE = <hex> ; static final int OBJECT = BASE | <hex> ; static final int UNINITIALIZED = BASE | <hex> ; private static final int LOCAL = <hex> ; private static final int STACK = <hex> ; static final int TOP = BASE | <int> ; static final int BOOLEAN = BASE | <int> ; static final int BYTE = BASE | <int> ; static final int CHAR = BASE | <int> ; static final int SHORT = BASE | <int> ; static final int INTEGER = BASE | <int> ; static final int FLOAT = BASE | <int> ; static final int DOUBLE = BASE | <int> ; static final int LONG = BASE | <int> ; static final int NULL = BASE | <int> ; static final int UNINITIALIZED_THIS = BASE | <int> ; static final int [ ] SIZE ; static { int i ; int [ ] b = new int [ <int> ] ; String s = <str> + <str> + <str> + <str> ; for ( i = <int> ; i < b . length ; + + i ) { b [ i ] = s . charAt ( i ) - <str> ; } SIZE = b ; } Label owner ; int [ ] inputLocals ; int [ ] inputStack ; private int [ ] outputLocals ; private int [ ] outputStack ; private int outputStackTop ; private int initializationCount ; private int [ ] initializations ; private int get ( final int local ) { if ( outputLocals = = null | | local > = outputLocals . length ) { return LOCAL | local ; } else { int type = outputLocals [ local ] ; if ( type = = <int> ) { type = outputLocals [ local ] = LOCAL | local ; } return type ; } } private void set ( final int local , final int type ) { if ( outputLocals = = null ) { outputLocals = new int [ <int> ] ; } int n = outputLocals . length ; if ( local > = n ) { int [ ] t = new int [ Math . max ( local + <int> , <int> * n ) ] ; System . arraycopy ( outputLocals , <int> , t , <int> , n ) ; outputLocals = t ; } outputLocals [ local ] = type ; } private void push ( final int type ) { if ( outputStack = = null ) { outputStack = new int [ <int> ] ; } int n = outputStack . length ; if ( outputStackTop > = n ) { int [ ] t = new int [ Math . max ( outputStackTop + <int> , <int> * n ) ] ; System . arraycopy ( outputStack , <int> , t , <int> , n ) ; outputStack = t ; } outputStack [ outputStackTop + + ] = type ; int top = owner . inputStackTop + outputStackTop ; if ( top > owner . outputStackMax ) { owner . outputStackMax = top ; } } private void push ( final ClassWriter cw , final String desc ) { int type = type ( cw , desc ) ; if ( type ! = <int> ) { push ( type ) ; if ( type = = LONG | | type = = DOUBLE ) { push ( TOP ) ; } } } private static int type ( final ClassWriter cw , final String desc ) { String t ; int index = desc . charAt ( <int> ) = = <str> ? desc . indexOf ( <str> ) + <int> : <int> ; switch ( desc . charAt ( index ) ) { case <str> : return <int> ; case <str> : case <str> : case <str> : case <str> : case <str> : return INTEGER ; case <str> : return FLOAT ; case <str> : return LONG ; case <str> : return DOUBLE ; case <str> : t = desc . substring ( index + <int> , desc . length ( ) - <int> ) ; return OBJECT | cw . addType ( t ) ; default : int data ; int dims = index + <int> ; while ( desc . charAt ( dims ) = = <str> ) { + + dims ; } switch ( desc . charAt ( dims ) ) { case <str> : data = BOOLEAN ; break ; case <str> : data = CHAR ; break ; case <str> : data = BYTE ; break ; case <str> : data = SHORT ; break ; case <str> : data = INTEGER ; break ; case <str> : data = FLOAT ; break ; case <str> : data = LONG ; break ; case <str> : data = DOUBLE ; break ; default : t = desc . substring ( dims + <int> , desc . length ( ) - <int> ) ; data = OBJECT | cw . addType ( t ) ; } return ( dims - index ) < < <int> | data ; } } private int pop ( ) { if ( outputStackTop > <int> ) { return outputStack [ - - outputStackTop ] ; } else { return STACK | - ( - - owner . inputStackTop ) ; } } private void pop ( final int elements ) { if ( outputStackTop > = elements ) { outputStackTop - = elements ; } else { owner . inputStackTop - = elements - outputStackTop ; outputStackTop = <int> ; } } private void pop ( final String desc ) { char c = desc . charAt ( <int> ) ; if ( c = = <str> ) { pop ( ( Type . getArgumentsAndReturnSizes ( desc ) > > <int> ) - <int> ) ; } else if ( c = = <str> | | c = = <str> ) { pop ( <int> ) ; } else { pop ( <int> ) ; } } private void init ( final int var ) { if ( initializations = = null ) { initializations = new int [ <int> ] ; } int n = initializations . length ; if ( initializationCount > = n ) { int [ ] t = new int [ Math . max ( initializationCount + <int> , <int> * n ) ] ; System . arraycopy ( initializations , <int> , t , <int> , n ) ; initializations = t ; } initializations [ initializationCount + + ] = var ; } private int init ( final ClassWriter cw , final int t ) { int s ; if ( t = = UNINITIALIZED_THIS ) { s = OBJECT | cw . addType ( cw . thisName ) ; } else if ( ( t & ( DIM | BASE_KIND ) ) = = UNINITIALIZED ) { String type = cw . typeTable [ t & BASE_VALUE ] . strVal1 ; s = OBJECT | cw . addType ( type ) ; } else { return t ; } for ( int j = <int> ; j < initializationCount ; + + j ) { int u = initializations [ j ] ; int dim = u & DIM ; int kind = u & KIND ; if ( kind = = LOCAL ) { u = dim + inputLocals [ u & VALUE ] ; } else if ( kind = = STACK ) { u = dim + inputStack [ inputStack . length - ( u & VALUE ) ] ; } if ( t = = u ) { return s ; } } return t ; } void initInputFrame ( final ClassWriter cw , final int access , final Type [ ] args , final int maxLocals ) { inputLocals = new int [ maxLocals ] ; inputStack = new int [ <int> ] ; int i = <int> ; if ( ( access & Opcodes . ACC_STATIC ) = = <int> ) { if ( ( access & MethodWriter . ACC_CONSTRUCTOR ) = = <int> ) { inputLocals [ i + + ] = OBJECT | cw . addType ( cw . thisName ) ; } else { inputLocals [ i + + ] = UNINITIALIZED_THIS ; } } for ( int j = <int> ; j < args . length ; + + j ) { int t = type ( cw , args [ j ] . getDescriptor ( ) ) ; inputLocals [ i + + ] = t ; if ( t = = LONG | | t = = DOUBLE ) { inputLocals [ i + + ] = TOP ; } } while ( i < maxLocals ) { inputLocals [ i + + ] = TOP ; } } void execute ( final int opcode , final int arg , final ClassWriter cw , final Item item ) { int t1 , t2 , t3 , t4 ; switch ( opcode ) { case Opcodes . NOP : case Opcodes . INEG : case Opcodes . LNEG : case Opcodes . FNEG : case Opcodes . DNEG : case Opcodes . I2B : case Opcodes . I2C : case Opcodes . I2S : case Opcodes . GOTO : case Opcodes . RETURN : break ; case Opcodes . ACONST_NULL : push ( NULL ) ; break ; case Opcodes . ICONST_M1 : case Opcodes . ICONST_0 : case Opcodes . ICONST_1 : case Opcodes . ICONST_2 : case Opcodes . ICONST_3 : case Opcodes . ICONST_4 : case Opcodes . ICONST_5 : case Opcodes . BIPUSH : case Opcodes . SIPUSH : case Opcodes . ILOAD : push ( INTEGER ) ; break ; case Opcodes . LCONST_0 : case Opcodes . LCONST_1 : case Opcodes . LLOAD : push ( LONG ) ; push ( TOP ) ; break ; case Opcodes . FCONST_0 : case Opcodes . FCONST_1 : case Opcodes . FCONST_2 : case Opcodes . FLOAD : push ( FLOAT ) ; break ; case Opcodes . DCONST_0 : case Opcodes . DCONST_1 : case Opcodes . DLOAD : push ( DOUBLE ) ; push ( TOP ) ; break ; case Opcodes . LDC : switch ( item . type ) { case ClassWriter . INT : push ( INTEGER ) ; break ; case ClassWriter . LONG : push ( LONG ) ; push ( TOP ) ; break ; case ClassWriter . FLOAT : push ( FLOAT ) ; break ; case ClassWriter . DOUBLE : push ( DOUBLE ) ; push ( TOP ) ; break ; case ClassWriter . CLASS : push ( OBJECT | cw . addType ( <str> ) ) ; break ; case ClassWriter . STR : push ( OBJECT | cw . addType ( <str> ) ) ; break ; case ClassWriter . MTYPE : push ( OBJECT | cw . addType ( <str> ) ) ; break ; default : push ( OBJECT | cw . addType ( <str> ) ) ; } break ; case Opcodes . ALOAD : push ( get ( arg ) ) ; break ; case Opcodes . IALOAD : case Opcodes . BALOAD : case Opcodes . CALOAD : case Opcodes . SALOAD : pop ( <int> ) ; push ( INTEGER ) ; break ; case Opcodes . LALOAD : case Opcodes . D2L : pop ( <int> ) ; push ( LONG ) ; push ( TOP ) ; break ; case Opcodes . FALOAD : pop ( <int> ) ; push ( FLOAT ) ; break ; case Opcodes . DALOAD : case Opcodes . L2D : pop ( <int> ) ; push ( DOUBLE ) ; push ( TOP ) ; break ; case Opcodes . AALOAD : pop ( <int> ) ; t1 = pop ( ) ; push ( ELEMENT_OF + t1 ) ; break ; case Opcodes . ISTORE : case Opcodes . FSTORE : case Opcodes . ASTORE : t1 = pop ( ) ; set ( arg , t1 ) ; if ( arg > <int> ) { t2 = get ( arg - <int> ) ; if ( t2 = = LONG | | t2 = = DOUBLE ) { set ( arg - <int> , TOP ) ; } else if ( ( t2 & KIND ) ! = BASE ) { set ( arg - <int> , t2 | TOP_IF_LONG_OR_DOUBLE ) ; } } break ; case Opcodes . LSTORE : case Opcodes . DSTORE : pop ( <int> ) ; t1 = pop ( ) ; set ( arg , t1 ) ; set ( arg + <int> , TOP ) ; if ( arg > <int> ) { t2 = get ( arg - <int> ) ; if ( t2 = = LONG | | t2 = = DOUBLE ) { set ( arg - <int> , TOP ) ; } else if ( ( t2 & KIND ) ! = BASE ) { set ( arg - <int> , t2 | TOP_IF_LONG_OR_DOUBLE ) ; } } break ; case Opcodes . IASTORE : case Opcodes . BASTORE : case Opcodes . CASTORE : case Opcodes . SASTORE : case Opcodes . FASTORE : case Opcodes . AASTORE : pop ( <int> ) ; break ; case Opcodes . LASTORE : case Opcodes . DASTORE : pop ( <int> ) ; break ; case Opcodes . POP : case Opcodes . IFEQ : case Opcodes . IFNE : case Opcodes . IFLT : case Opcodes . IFGE : case Opcodes . IFGT : case Opcodes . IFLE : case Opcodes . IRETURN : case Opcodes . FRETURN : case Opcodes . ARETURN : case Opcodes . TABLESWITCH : case Opcodes . LOOKUPSWITCH : case Opcodes . ATHROW : case Opcodes . MONITORENTER : case Opcodes . MONITOREXIT : case Opcodes . IFNULL : case Opcodes . IFNONNULL : pop ( <int> ) ; break ; case Opcodes . POP2 : case Opcodes . IF_ICMPEQ : case Opcodes . IF_ICMPNE : case Opcodes . IF_ICMPLT : case Opcodes . IF_ICMPGE : case Opcodes . IF_ICMPGT : case Opcodes . IF_ICMPLE : case Opcodes . IF_ACMPEQ : case Opcodes . IF_ACMPNE : case Opcodes . LRETURN : case Opcodes . DRETURN : pop ( <int> ) ; break ; case Opcodes . DUP : t1 = pop ( ) ; push ( t1 ) ; push ( t1 ) ; break ; case Opcodes . DUP_X1 : t1 = pop ( ) ; t2 = pop ( ) ; push ( t1 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . DUP_X2 : t1 = pop ( ) ; t2 = pop ( ) ; t3 = pop ( ) ; push ( t1 ) ; push ( t3 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . DUP2 : t1 = pop ( ) ; t2 = pop ( ) ; push ( t2 ) ; push ( t1 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . DUP2_X1 : t1 = pop ( ) ; t2 = pop ( ) ; t3 = pop ( ) ; push ( t2 ) ; push ( t1 ) ; push ( t3 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . DUP2_X2 : t1 = pop ( ) ; t2 = pop ( ) ; t3 = pop ( ) ; t4 = pop ( ) ; push ( t2 ) ; push ( t1 ) ; push ( t4 ) ; push ( t3 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . SWAP : t1 = pop ( ) ; t2 = pop ( ) ; push ( t1 ) ; push ( t2 ) ; break ; case Opcodes . IADD : case Opcodes . ISUB : case Opcodes . IMUL : case Opcodes . IDIV : case Opcodes . IREM : case Opcodes . IAND : case Opcodes . IOR : case Opcodes . IXOR : case Opcodes . ISHL : case Opcodes . ISHR : case Opcodes . IUSHR : case Opcodes . L2I : case Opcodes . D2I : case Opcodes . FCMPL : case Opcodes . FCMPG : pop ( <int> ) ; push ( INTEGER ) ; break ; case Opcodes . LADD : case Opcodes . LSUB : case Opcodes . LMUL : case Opcodes . LDIV : case Opcodes . LREM : case Opcodes . LAND : case Opcodes . LOR : case Opcodes . LXOR : pop ( <int> ) ; push ( LONG ) ; push ( TOP ) ; break ; case Opcodes . FADD : case Opcodes . FSUB : case Opcodes . FMUL : case Opcodes . FDIV : case Opcodes . FREM : case Opcodes . L2F : case Opcodes . D2F : pop ( <int> ) ; push ( FLOAT ) ; break ; case Opcodes . DADD : case Opcodes . DSUB : case Opcodes . DMUL : case Opcodes . DDIV : case Opcodes . DREM : pop ( <int> ) ; push ( DOUBLE ) ; push ( TOP ) ; break ; case Opcodes . LSHL : case Opcodes . LSHR : case Opcodes . LUSHR : pop ( <int> ) ; push ( LONG ) ; push ( TOP ) ; break ; case Opcodes . IINC : set ( arg , INTEGER ) ; break ; case Opcodes . I2L : case Opcodes . F2L : pop ( <int> ) ; push ( LONG ) ; push ( TOP ) ; break ; case Opcodes . I2F : pop ( <int> ) ; push ( FLOAT ) ; break ; case Opcodes . I2D : case Opcodes . F2D : pop ( <int> ) ; push ( DOUBLE ) ; push ( TOP ) ; break ; case Opcodes . F2I : case Opcodes . ARRAYLENGTH : case Opcodes . INSTANCEOF : pop ( <int> ) ; push ( INTEGER ) ; break ; case Opcodes . LCMP : case Opcodes . DCMPL : case Opcodes . DCMPG : pop ( <int> ) ; push ( INTEGER ) ; break ; case Opcodes . JSR : case Opcodes . RET : throw new RuntimeException ( <str> ) ; case Opcodes . GETSTATIC : push ( cw , item . strVal3 ) ; break ; case Opcodes . PUTSTATIC : pop ( item . strVal3 ) ; break ; case Opcodes . GETFIELD : pop ( <int> ) ; push ( cw , item . strVal3 ) ; break ; case Opcodes . PUTFIELD : pop ( item . strVal3 ) ; pop ( ) ; break ; case Opcodes . INVOKEVIRTUAL : case Opcodes . INVOKESPECIAL : case Opcodes . INVOKESTATIC : case Opcodes . INVOKEINTERFACE : pop ( item . strVal3 ) ; if ( opcode ! = Opcodes . INVOKESTATIC ) { t1 = pop ( ) ; if ( opcode = = Opcodes . INVOKESPECIAL & & item . strVal2 . charAt ( <int> ) = = <str> ) { init ( t1 ) ; } } push ( cw , item . strVal3 ) ; break ; case Opcodes . INVOKEDYNAMIC : pop ( item . strVal2 ) ; push ( cw , item . strVal2 ) ; break ; case Opcodes . NEW : push ( UNINITIALIZED | cw . addUninitializedType ( item . strVal1 , arg ) ) ; break ; case Opcodes . NEWARRAY : pop ( ) ; switch ( arg ) { case Opcodes . T_BOOLEAN : push ( ARRAY_OF | BOOLEAN ) ; break ; case Opcodes . T_CHAR : push ( ARRAY_OF | CHAR ) ; break ; case Opcodes . T_BYTE : push ( ARRAY_OF | BYTE ) ; break ; case Opcodes . T_SHORT : push ( ARRAY_OF | SHORT ) ; break ; case Opcodes . T_INT : push ( ARRAY_OF | INTEGER ) ; break ; case Opcodes . T_FLOAT : push ( ARRAY_OF | FLOAT ) ; break ; case Opcodes . T_DOUBLE : push ( ARRAY_OF | DOUBLE ) ; break ; default : push ( ARRAY_OF | LONG ) ; break ; } break ; case Opcodes . ANEWARRAY : String s = item . strVal1 ; pop ( ) ; if ( s . charAt ( <int> ) = = <str> ) { push ( cw , <str> + s ) ; } else { push ( ARRAY_OF | OBJECT | cw . addType ( s ) ) ; } break ; case Opcodes . CHECKCAST : s = item . strVal1 ; pop ( ) ; if ( s . charAt ( <int> ) = = <str> ) { push ( cw , s ) ; } else { push ( OBJECT | cw . addType ( s ) ) ; } break ; default : pop ( arg ) ; push ( cw , item . strVal1 ) ; break ; } } boolean merge ( final ClassWriter cw , final Frame frame , final int edge ) { boolean changed = false ; int i , s , dim , kind , t ; int nLocal = inputLocals . length ; int nStack = inputStack . length ; if ( frame . inputLocals = = null ) { frame . inputLocals = new int [ nLocal ] ; changed = true ; } for ( i = <int> ; i < nLocal ; + + i ) { if ( outputLocals ! = null & & i < outputLocals . length ) { s = outputLocals [ i ] ; if ( s = = <int> ) { t = inputLocals [ i ] ; } else { dim = s & DIM ; kind = s & KIND ; if ( kind = = BASE ) { t = s ; } else { if ( kind = = LOCAL ) { t = dim + inputLocals [ s & VALUE ] ; } else { t = dim + inputStack [ nStack - ( s & VALUE ) ] ; } if ( ( s & TOP_IF_LONG_OR_DOUBLE ) ! = <int> & & ( t = = LONG | | t = = DOUBLE ) ) { t = TOP ; } } } } else { t = inputLocals [ i ] ; } if ( initializations ! = null ) { t = init ( cw , t ) ; } changed | = merge ( cw , t , frame . inputLocals , i ) ; } if ( edge > <int> ) { for ( i = <int> ; i < nLocal ; + + i ) { t = inputLocals [ i ] ; changed | = merge ( cw , t , frame . inputLocals , i ) ; } if ( frame . inputStack = = null ) { frame . inputStack = new int [ <int> ] ; changed = true ; } changed | = merge ( cw , edge , frame . inputStack , <int> ) ; return changed ; } int nInputStack = inputStack . length + owner . inputStackTop ; if ( frame . inputStack = = null ) { frame . inputStack = new int [ nInputStack + outputStackTop ] ; changed = true ; } for ( i = <int> ; i < nInputStack ; + + i ) { t = inputStack [ i ] ; if ( initializations ! = null ) { t = init ( cw , t ) ; } changed | = merge ( cw , t , frame . inputStack , i ) ; } for ( i = <int> ; i < outputStackTop ; + + i ) { s = outputStack [ i ] ; dim = s & DIM ; kind = s & KIND ; if ( kind = = BASE ) { t = s ; } else { if ( kind = = LOCAL ) { t = dim + inputLocals [ s & VALUE ] ; } else { t = dim + inputStack [ nStack - ( s & VALUE ) ] ; } if ( ( s & TOP_IF_LONG_OR_DOUBLE ) ! = <int> & & ( t = = LONG | | t = = DOUBLE ) ) { t = TOP ; } } if ( initializations ! = null ) { t = init ( cw , t ) ; } changed | = merge ( cw , t , frame . inputStack , nInputStack + i ) ; } return changed ; } private static boolean merge ( final ClassWriter cw , int t , final int [ ] types , final int index ) { int u = types [ index ] ; if ( u = = t ) { return false ; } if ( ( t & ~ DIM ) = = NULL ) { if ( u = = NULL ) { return false ; } t = NULL ; } if ( u = = <int> ) { types [ index ] = t ; return true ; } int v ; if ( ( u & BASE_KIND ) = = OBJECT | | ( u & DIM ) ! = <int> ) { if ( t = = NULL ) { return false ; } else if ( ( t & ( DIM | BASE_KIND ) ) = = ( u & ( DIM | BASE_KIND ) ) ) { if ( ( u & BASE_KIND ) = = OBJECT ) { v = ( t & DIM ) | OBJECT | cw . getMergedType ( t & BASE_VALUE , u & BASE_VALUE ) ; } else { v = OBJECT | cw . addType ( <str> ) ; } } else if ( ( t & BASE_KIND ) = = OBJECT | | ( t & DIM ) ! = <int> ) { v = OBJECT | cw . addType ( <str> ) ; } else { v = TOP ; } } else if ( u = = NULL ) { v = ( t & BASE_KIND ) = = OBJECT | | ( t & DIM ) ! = <int> ? t : TOP ; } else { v = TOP ; } if ( u ! = v ) { types [ index ] = v ; return true ; } return false ; } } 
