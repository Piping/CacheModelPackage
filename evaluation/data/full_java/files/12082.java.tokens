package org . gradle . internal . graph ; import org . gradle . util . GUtil ; import java . util . * ; public class CachingDirectedGraphWalker < N , T > { private final DirectedGraphWithEdgeValues < N , T > graph ; private List < N > startNodes = new LinkedList < N > ( ) ; private Set < NodeDetails < N , T > > strongComponents = new LinkedHashSet < NodeDetails < N , T > > ( ) ; private final Map < N , Set < T > > cachedNodeValues = new HashMap < N , Set < T > > ( ) ; public CachingDirectedGraphWalker ( DirectedGraph < N , T > graph ) { this . graph = new GraphWithEmpyEdges < N , T > ( graph ) ; } public CachingDirectedGraphWalker ( DirectedGraphWithEdgeValues < N , T > graph ) { this . graph = graph ; } public CachingDirectedGraphWalker < N , T > add ( N . . . values ) { add ( Arrays . asList ( values ) ) ; return this ; } public CachingDirectedGraphWalker add ( Iterable < ? extends N > values ) { GUtil . addToCollection ( startNodes , values ) ; return this ; } public Set < T > findValues ( ) { try { return doSearch ( ) ; } finally { startNodes . clear ( ) ; } } public List < Set < N > > findCycles ( ) { findValues ( ) ; List < Set < N > > result = new ArrayList < Set < N > > ( ) ; for ( NodeDetails < N , T > nodeDetails : strongComponents ) { Set < N > componentMembers = new LinkedHashSet < N > ( ) ; for ( NodeDetails < N , T > componentMember : nodeDetails . componentMembers ) { componentMembers . add ( componentMember . node ) ; } result . add ( componentMembers ) ; } return result ; } private Set < T > doSearch ( ) { int componentCount = <int> ; Map < N , NodeDetails < N , T > > seenNodes = new HashMap < N , NodeDetails < N , T > > ( ) ; Map < Integer , NodeDetails < N , T > > components = new HashMap < Integer , NodeDetails < N , T > > ( ) ; LinkedList < N > queue = new LinkedList < N > ( startNodes ) ; while ( ! queue . isEmpty ( ) ) { N node = queue . getFirst ( ) ; NodeDetails < N , T > details = seenNodes . get ( node ) ; if ( details = = null ) { details = new NodeDetails < N , T > ( node , componentCount + + ) ; seenNodes . put ( node , details ) ; components . put ( details . component , details ) ; Set < T > cacheValues = cachedNodeValues . get ( node ) ; if ( cacheValues ! = null ) { details . values = cacheValues ; details . finished = true ; queue . removeFirst ( ) ; continue ; } graph . getNodeValues ( node , details . values , details . successors ) ; for ( N connectedNode : details . successors ) { NodeDetails < N , T > connectedNodeDetails = seenNodes . get ( connectedNode ) ; if ( connectedNodeDetails = = null ) { queue . add ( <int> , connectedNode ) ; } else if ( ! connectedNodeDetails . finished ) { details . stronglyConnected = true ; } } } else { queue . removeFirst ( ) ; if ( cachedNodeValues . containsKey ( node ) ) { continue ; } for ( N connectedNode : details . successors ) { NodeDetails < N , T > connectedNodeDetails = seenNodes . get ( connectedNode ) ; if ( ! connectedNodeDetails . finished ) { int minSeen = Math . min ( details . minSeen , connectedNodeDetails . minSeen ) ; details . minSeen = minSeen ; connectedNodeDetails . minSeen = minSeen ; details . stronglyConnected = true ; } details . values . addAll ( connectedNodeDetails . values ) ; graph . getEdgeValues ( node , connectedNode , details . values ) ; } if ( details . minSeen ! = details . component ) { NodeDetails < N , T > rootDetails = components . get ( details . minSeen ) ; rootDetails . values . addAll ( details . values ) ; details . values . clear ( ) ; rootDetails . componentMembers . addAll ( details . componentMembers ) ; } else { for ( NodeDetails < N , T > componentMember : details . componentMembers ) { cachedNodeValues . put ( componentMember . node , details . values ) ; componentMember . finished = true ; components . remove ( componentMember . component ) ; } if ( details . stronglyConnected ) { strongComponents . add ( details ) ; } } } } Set < T > values = new LinkedHashSet < T > ( ) ; for ( N startNode : startNodes ) { values . addAll ( cachedNodeValues . get ( startNode ) ) ; } return values ; } private static class NodeDetails < N , T > { private final int component ; private final N node ; private Set < T > values = new LinkedHashSet < T > ( ) ; private List < N > successors = new ArrayList < N > ( ) ; private Set < NodeDetails < N , T > > componentMembers = new LinkedHashSet < NodeDetails < N , T > > ( ) ; private int minSeen ; private boolean stronglyConnected ; private boolean finished ; public NodeDetails ( N node , int component ) { this . node = node ; this . component = component ; minSeen = component ; componentMembers . add ( this ) ; } } private static class GraphWithEmpyEdges < N , T > implements DirectedGraphWithEdgeValues < N , T > { private final DirectedGraph < N , T > graph ; public GraphWithEmpyEdges ( DirectedGraph < N , T > graph ) { this . graph = graph ; } public void getEdgeValues ( N from , N to , Collection < T > values ) { } public void getNodeValues ( N node , Collection < ? super T > values , Collection < ? super N > connectedNodes ) { graph . getNodeValues ( node , values , connectedNodes ) ; } } } 
