package org . elasticsearch . index . search . geo ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . geo . RandomGeoGenerator ; import java . io . IOException ; import static org . hamcrest . Matchers . is ; public class GeoPointParsingTests extends ESTestCase { static double TOLERANCE = <float> ; public void testGeoPointReset ( ) throws IOException { double lat = <int> + randomDouble ( ) * <int> ; double lon = <int> + randomDouble ( ) * <int> ; GeoPoint point = new GeoPoint ( <int> , <int> ) ; GeoPoint point2 = new GeoPoint ( <int> , <int> ) ; assertPointsEqual ( point , point2 ) ; assertPointsEqual ( point . reset ( lat , lon ) , point2 . reset ( lat , lon ) ) ; assertPointsEqual ( point . reset ( <int> , <int> ) , point2 . reset ( <int> , <int> ) ) ; assertPointsEqual ( point . resetLat ( lat ) , point2 . reset ( lat , <int> ) ) ; assertPointsEqual ( point . resetLat ( <int> ) , point2 . reset ( <int> , <int> ) ) ; assertPointsEqual ( point . resetLon ( lon ) , point2 . reset ( <int> , lon ) ) ; assertPointsEqual ( point . resetLon ( <int> ) , point2 . reset ( <int> , <int> ) ) ; assertCloseTo ( point . resetFromGeoHash ( GeoHashUtils . stringEncode ( lon , lat ) ) , lat , lon ) ; assertPointsEqual ( point . reset ( <int> , <int> ) , point2 . reset ( <int> , <int> ) ) ; assertPointsEqual ( point . resetFromString ( Double . toString ( lat ) + <str> + Double . toHexString ( lon ) ) , point2 . reset ( lat , lon ) ) ; assertPointsEqual ( point . reset ( <int> , <int> ) , point2 . reset ( <int> , <int> ) ) ; } public void testEqualsHashCodeContract ( ) { final GeoPoint x = RandomGeoGenerator . randomPoint ( random ( ) ) ; final GeoPoint y = new GeoPoint ( x . lat ( ) , x . lon ( ) ) ; final GeoPoint z = new GeoPoint ( y . lat ( ) , y . lon ( ) ) ; final GeoPoint a = new GeoPoint ( x . lat ( ) + randomIntBetween ( <int> , <int> ) , x . lon ( ) + randomIntBetween ( <int> , <int> ) ) ; assertTrue ( x . equals ( x ) ) ; assertTrue ( x . equals ( y ) ) ; assertTrue ( y . equals ( z ) ) ; assertTrue ( x . equals ( z ) ) ; assertFalse ( x . equals ( a ) ) ; assertTrue ( x . hashCode ( ) = = y . hashCode ( ) ) ; assertTrue ( y . hashCode ( ) = = z . hashCode ( ) ) ; assertTrue ( x . hashCode ( ) = = z . hashCode ( ) ) ; assertFalse ( x . hashCode ( ) = = a . hashCode ( ) ) ; } public void testGeoPointParsing ( ) throws IOException { GeoPoint randomPt = RandomGeoGenerator . randomPoint ( random ( ) ) ; GeoPoint point = GeoUtils . parseGeoPoint ( objectLatLon ( randomPt . lat ( ) , randomPt . lon ( ) ) ) ; assertPointsEqual ( point , randomPt ) ; GeoUtils . parseGeoPoint ( arrayLatLon ( randomPt . lat ( ) , randomPt . lon ( ) ) , point ) ; assertPointsEqual ( point , randomPt ) ; GeoUtils . parseGeoPoint ( geohash ( randomPt . lat ( ) , randomPt . lon ( ) ) , point ) ; assertCloseTo ( point , randomPt . lat ( ) , randomPt . lon ( ) ) ; GeoUtils . parseGeoPoint ( stringLatLon ( randomPt . lat ( ) , randomPt . lon ( ) ) , point ) ; assertCloseTo ( point , randomPt . lat ( ) , randomPt . lon ( ) ) ; } public void testInvalidPointEmbeddedObject ( ) throws IOException { XContentBuilder content = JsonXContent . contentBuilder ( ) ; content . startObject ( ) ; content . startObject ( <str> ) ; content . field ( <str> , <int> ) . field ( <str> , <int> ) ; content . endObject ( ) ; content . endObject ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( content . bytes ( ) ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testInvalidPointLatHashMix ( ) throws IOException { XContentBuilder content = JsonXContent . contentBuilder ( ) ; content . startObject ( ) ; content . field ( <str> , <int> ) . field ( <str> , GeoHashUtils . stringEncode ( <float> , <float> ) ) ; content . endObject ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( content . bytes ( ) ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testInvalidPointLonHashMix ( ) throws IOException { XContentBuilder content = JsonXContent . contentBuilder ( ) ; content . startObject ( ) ; content . field ( <str> , <int> ) . field ( <str> , GeoHashUtils . stringEncode ( <float> , <float> ) ) ; content . endObject ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( content . bytes ( ) ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testInvalidField ( ) throws IOException { XContentBuilder content = JsonXContent . contentBuilder ( ) ; content . startObject ( ) ; content . field ( <str> , <int> ) . field ( <str> , <int> ) . field ( <str> , <int> ) ; content . endObject ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( content . bytes ( ) ) ; parser . nextToken ( ) ; try { GeoUtils . parseGeoPoint ( parser ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } private static XContentParser objectLatLon ( double lat , double lon ) throws IOException { XContentBuilder content = JsonXContent . contentBuilder ( ) ; content . startObject ( ) ; content . field ( <str> , lat ) . field ( <str> , lon ) ; content . endObject ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( content . bytes ( ) ) ; parser . nextToken ( ) ; return parser ; } private static XContentParser arrayLatLon ( double lat , double lon ) throws IOException { XContentBuilder content = JsonXContent . contentBuilder ( ) ; content . startArray ( ) . value ( lon ) . value ( lat ) . endArray ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( content . bytes ( ) ) ; parser . nextToken ( ) ; return parser ; } private static XContentParser stringLatLon ( double lat , double lon ) throws IOException { XContentBuilder content = JsonXContent . contentBuilder ( ) ; content . value ( Double . toString ( lat ) + <str> + Double . toString ( lon ) ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( content . bytes ( ) ) ; parser . nextToken ( ) ; return parser ; } private static XContentParser geohash ( double lat , double lon ) throws IOException { XContentBuilder content = JsonXContent . contentBuilder ( ) ; content . value ( GeoHashUtils . stringEncode ( lon , lat ) ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( content . bytes ( ) ) ; parser . nextToken ( ) ; return parser ; } public static void assertPointsEqual ( final GeoPoint point1 , final GeoPoint point2 ) { assertEquals ( point1 , point2 ) ; assertEquals ( point1 . hashCode ( ) , point2 . hashCode ( ) ) ; } public static void assertCloseTo ( final GeoPoint point , final double lat , final double lon ) { assertEquals ( point . lat ( ) , lat , TOLERANCE ) ; assertEquals ( point . lon ( ) , lon , TOLERANCE ) ; } } 
