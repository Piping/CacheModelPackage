package io . netty . handler . ssl ; import org . apache . tomcat . jni . SSL ; import org . apache . tomcat . jni . SSLContext ; import javax . net . ssl . KeyManagerFactory ; import javax . net . ssl . SSLException ; import javax . net . ssl . TrustManager ; import javax . net . ssl . TrustManagerFactory ; import javax . net . ssl . X509ExtendedTrustManager ; import javax . net . ssl . X509TrustManager ; import java . io . File ; import java . security . KeyStore ; import java . security . PrivateKey ; import java . security . cert . X509Certificate ; public final class OpenSslClientContext extends OpenSslContext { private final OpenSslSessionContext sessionContext ; @Deprecated public OpenSslClientContext ( ) throws SSLException { this ( ( File ) null , null , null , null , null , null , null , IdentityCipherSuiteFilter . INSTANCE , null , <int> , <int> ) ; } @Deprecated public OpenSslClientContext ( File certChainFile ) throws SSLException { this ( certChainFile , null ) ; } @Deprecated public OpenSslClientContext ( TrustManagerFactory trustManagerFactory ) throws SSLException { this ( null , trustManagerFactory ) ; } @Deprecated public OpenSslClientContext ( File certChainFile , TrustManagerFactory trustManagerFactory ) throws SSLException { this ( certChainFile , trustManagerFactory , null , null , null , null , null , IdentityCipherSuiteFilter . INSTANCE , null , <int> , <int> ) ; } @Deprecated public OpenSslClientContext ( File certChainFile , TrustManagerFactory trustManagerFactory , Iterable < String > ciphers , ApplicationProtocolConfig apn , long sessionCacheSize , long sessionTimeout ) throws SSLException { this ( certChainFile , trustManagerFactory , null , null , null , null , ciphers , IdentityCipherSuiteFilter . INSTANCE , apn , sessionCacheSize , sessionTimeout ) ; } @Deprecated public OpenSslClientContext ( File certChainFile , TrustManagerFactory trustManagerFactory , Iterable < String > ciphers , CipherSuiteFilter cipherFilter , ApplicationProtocolConfig apn , long sessionCacheSize , long sessionTimeout ) throws SSLException { this ( certChainFile , trustManagerFactory , null , null , null , null , ciphers , cipherFilter , apn , sessionCacheSize , sessionTimeout ) ; } @Deprecated public OpenSslClientContext ( File trustCertChainFile , TrustManagerFactory trustManagerFactory , File keyCertChainFile , File keyFile , String keyPassword , KeyManagerFactory keyManagerFactory , Iterable < String > ciphers , CipherSuiteFilter cipherFilter , ApplicationProtocolConfig apn , long sessionCacheSize , long sessionTimeout ) throws SSLException { super ( ciphers , cipherFilter , apn , sessionCacheSize , sessionTimeout , SSL . SSL_MODE_CLIENT , null , ClientAuth . NONE ) ; boolean success = false ; try { if ( trustCertChainFile ! = null & & ! trustCertChainFile . isFile ( ) ) { throw new IllegalArgumentException ( <str> + trustCertChainFile ) ; } if ( keyCertChainFile ! = null & & ! keyCertChainFile . isFile ( ) ) { throw new IllegalArgumentException ( <str> + keyCertChainFile ) ; } if ( keyFile ! = null & & ! keyFile . isFile ( ) ) { throw new IllegalArgumentException ( <str> + keyFile ) ; } if ( keyFile = = null & & keyCertChainFile ! = null | | keyFile ! = null & & keyCertChainFile = = null ) { throw new IllegalArgumentException ( <str> ) ; } synchronized ( OpenSslContext . class ) { if ( trustCertChainFile ! = null ) { if ( ! SSLContext . setCertificateChainFile ( ctx , trustCertChainFile . getPath ( ) , false ) ) { long error = SSL . getLastErrorNumber ( ) ; if ( OpenSsl . isError ( error ) ) { throw new SSLException ( <str> + trustCertChainFile + <str> + SSL . getErrorString ( error ) + <str> ) ; } } } if ( keyCertChainFile ! = null & & keyFile ! = null ) { try { if ( ! SSLContext . setCertificate ( ctx , keyCertChainFile . getPath ( ) , keyFile . getPath ( ) , keyPassword , SSL . SSL_AIDX_RSA ) ) { long error = SSL . getLastErrorNumber ( ) ; if ( OpenSsl . isError ( error ) ) { throw new SSLException ( <str> + keyCertChainFile + <str> + keyFile + <str> + SSL . getErrorString ( error ) + <str> ) ; } } } catch ( SSLException e ) { throw e ; } catch ( Exception e ) { throw new SSLException ( <str> + keyCertChainFile + <str> + keyFile , e ) ; } } SSLContext . setVerify ( ctx , SSL . SSL_VERIFY_NONE , VERIFY_DEPTH ) ; try { if ( trustCertChainFile ! = null ) { trustManagerFactory = buildTrustManagerFactory ( trustCertChainFile , trustManagerFactory ) ; } else if ( trustManagerFactory = = null ) { trustManagerFactory = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; trustManagerFactory . init ( ( KeyStore ) null ) ; } final X509TrustManager manager = chooseTrustManager ( trustManagerFactory . getTrustManagers ( ) ) ; if ( useExtendedTrustManager ( manager ) ) { final X509ExtendedTrustManager extendedManager = ( X509ExtendedTrustManager ) manager ; SSLContext . setCertVerifyCallback ( ctx , new AbstractCertificateVerifier ( ) { @Override void verify ( OpenSslEngine engine , X509Certificate [ ] peerCerts , String auth ) throws Exception { extendedManager . checkServerTrusted ( peerCerts , auth , engine ) ; } } ) ; } else { SSLContext . setCertVerifyCallback ( ctx , new AbstractCertificateVerifier ( ) { @Override void verify ( OpenSslEngine engine , X509Certificate [ ] peerCerts , String auth ) throws Exception { manager . checkServerTrusted ( peerCerts , auth ) ; } } ) ; } } catch ( Exception e ) { throw new SSLException ( <str> , e ) ; } } sessionContext = new OpenSslClientSessionContext ( ctx ) ; success = true ; } finally { if ( ! success ) { destroy ( ) ; } } } @SuppressWarnings ( <str> ) OpenSslClientContext ( X509Certificate [ ] trustCertChain , TrustManagerFactory trustManagerFactory , X509Certificate [ ] keyCertChain , PrivateKey key , String keyPassword , KeyManagerFactory keyManagerFactory , Iterable < String > ciphers , CipherSuiteFilter cipherFilter , ApplicationProtocolConfig apn , long sessionCacheSize , long sessionTimeout ) throws SSLException { super ( ciphers , cipherFilter , apn , sessionCacheSize , sessionTimeout , SSL . SSL_MODE_CLIENT , keyCertChain , ClientAuth . NONE ) ; boolean success = false ; try { if ( key = = null & & keyCertChain ! = null | | key ! = null & & keyCertChain = = null ) { throw new IllegalArgumentException ( <str> ) ; } synchronized ( OpenSslContext . class ) { if ( trustCertChain ! = null ) { long trustCertChainBio = <int> ; try { trustCertChainBio = toBIO ( trustCertChain ) ; if ( ! SSLContext . setCertificateChainBio ( ctx , trustCertChainBio , false ) ) { long error = SSL . getLastErrorNumber ( ) ; if ( OpenSsl . isError ( error ) ) { throw new SSLException ( <str> + SSL . getErrorString ( error ) ) ; } } } catch ( Exception e ) { throw new SSLException ( <str> , e ) ; } finally { if ( trustCertChainBio ! = <int> ) { SSL . freeBIO ( trustCertChainBio ) ; } } } if ( keyCertChain ! = null & & key ! = null ) { long keyBio = <int> ; long keyCertChainBio = <int> ; try { keyCertChainBio = toBIO ( keyCertChain ) ; keyBio = toBIO ( key ) ; if ( ! SSLContext . setCertificateBio ( ctx , keyCertChainBio , keyBio , keyPassword , SSL . SSL_AIDX_RSA ) ) { long error = SSL . getLastErrorNumber ( ) ; if ( OpenSsl . isError ( error ) ) { throw new SSLException ( <str> + SSL . getErrorString ( error ) ) ; } } } catch ( SSLException e ) { throw e ; } catch ( Exception e ) { throw new SSLException ( <str> , e ) ; } finally { if ( keyBio ! = <int> ) { SSL . freeBIO ( keyBio ) ; } if ( keyCertChainBio ! = <int> ) { SSL . freeBIO ( keyCertChainBio ) ; } } } SSLContext . setVerify ( ctx , SSL . SSL_VERIFY_NONE , VERIFY_DEPTH ) ; try { if ( trustCertChain ! = null ) { trustManagerFactory = buildTrustManagerFactory ( trustCertChain , trustManagerFactory ) ; } else if ( trustManagerFactory = = null ) { trustManagerFactory = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; trustManagerFactory . init ( ( KeyStore ) null ) ; } final X509TrustManager manager = chooseTrustManager ( trustManagerFactory . getTrustManagers ( ) ) ; if ( useExtendedTrustManager ( manager ) ) { final X509ExtendedTrustManager extendedManager = ( X509ExtendedTrustManager ) manager ; SSLContext . setCertVerifyCallback ( ctx , new AbstractCertificateVerifier ( ) { @Override void verify ( OpenSslEngine engine , X509Certificate [ ] peerCerts , String auth ) throws Exception { extendedManager . checkServerTrusted ( peerCerts , auth , engine ) ; } } ) ; } else { SSLContext . setCertVerifyCallback ( ctx , new AbstractCertificateVerifier ( ) { @Override void verify ( OpenSslEngine engine , X509Certificate [ ] peerCerts , String auth ) throws Exception { manager . checkServerTrusted ( peerCerts , auth ) ; } } ) ; } } catch ( Exception e ) { throw new SSLException ( <str> , e ) ; } } sessionContext = new OpenSslClientSessionContext ( ctx ) ; success = true ; } finally { if ( ! success ) { destroy ( ) ; } } } @Override public OpenSslSessionContext sessionContext ( ) { return sessionContext ; } private static final class OpenSslClientSessionContext extends OpenSslSessionContext { private OpenSslClientSessionContext ( long context ) { super ( context ) ; } @Override public void setSessionTimeout ( int seconds ) { if ( seconds < <int> ) { throw new IllegalArgumentException ( ) ; } } @Override public int getSessionTimeout ( ) { return <int> ; } @Override public void setSessionCacheSize ( int size ) { if ( size < <int> ) { throw new IllegalArgumentException ( ) ; } } @Override public int getSessionCacheSize ( ) { return <int> ; } @Override public void setSessionCacheEnabled ( boolean enabled ) { } @Override public boolean isSessionCacheEnabled ( ) { return false ; } } } 
