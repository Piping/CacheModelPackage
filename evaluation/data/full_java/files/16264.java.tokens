package org . gradle . gradleplugin . userinterface . swing . generic . tabs ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . foundation . CommandLineAssistant ; import org . gradle . foundation . ProjectView ; import org . gradle . foundation . TaskView ; import org . gradle . gradleplugin . foundation . GradlePluginLord ; import org . gradle . gradleplugin . foundation . filters . AllowAllProjectAndTaskFilter ; import org . gradle . gradleplugin . foundation . filters . BasicFilterEditor ; import org . gradle . gradleplugin . foundation . filters . BasicProjectAndTaskFilter ; import org . gradle . gradleplugin . foundation . request . ExecutionRequest ; import org . gradle . gradleplugin . foundation . request . RefreshTaskListRequest ; import org . gradle . gradleplugin . foundation . request . Request ; import org . gradle . gradleplugin . foundation . settings . SettingsNode ; import org . gradle . gradleplugin . userinterface . AlternateUIInteraction ; import org . gradle . gradleplugin . userinterface . swing . generic . SwingAddMultipleFavoritesInteraction ; import org . gradle . gradleplugin . userinterface . swing . generic . TaskTreeComponent ; import org . gradle . gradleplugin . userinterface . swing . generic . Utility ; import org . gradle . gradleplugin . userinterface . swing . generic . filter . ProjectAndTaskFilterDialog ; import javax . swing . * ; import javax . swing . event . TreeSelectionEvent ; import javax . swing . event . TreeSelectionListener ; import java . awt . * ; import java . awt . datatransfer . StringSelection ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . io . File ; import java . util . Iterator ; import java . util . List ; public class TaskTreeTab implements GradleTab , GradlePluginLord . GeneralPluginObserver , GradlePluginLord . RequestObserver { private final Logger logger = Logging . getLogger ( TaskTreeTab . class ) ; private static final String SHOW_DESCRIPTION = <str> ; private static final String BLANK_PNG = <str> ; private static final String EXECUTE_PNG = <str> ; private JPanel mainPanel ; private GradlePluginLord gradlePluginLord ; private AlternateUIInteraction alternateUIInteraction ; private TaskTreeComponent treeComponent ; private JPopupMenu popupMenu ; private JMenuItem addToFavoritesMenuItem ; private JMenuItem executeMenuItem ; private JMenuItem executeOnlyThisMenuItem ; private JMenuItem filterOutMenuItem ; private JMenuItem editFileMenuItem ; private JMenuItem copyTaskNameMenuItem ; private JButton refreshButton ; private JButton executeButton ; private JToggleButton toggleFilterButton ; private JButton editFilterButton ; private JCheckBox showDescriptionCheckBox ; private BasicFilterEditor editor ; private boolean isRefreshing ; private Color defaultTreeBackground ; private Color workingBackgroundColor = UIManager . getDefaults ( ) . getColor ( <str> ) ; private JScrollPane treeScrollPane ; private SettingsNode settingsNode ; public TaskTreeTab ( GradlePluginLord gradlePluginLord , SettingsNode settingsNode , AlternateUIInteraction alternateUIInteraction ) { this . gradlePluginLord = gradlePluginLord ; this . settingsNode = settingsNode ; this . alternateUIInteraction = alternateUIInteraction ; gradlePluginLord . addGeneralPluginObserver ( this , true ) ; gradlePluginLord . addRequestObserver ( this , true ) ; initializeFilterEditor ( ) ; } private void initializeFilterEditor ( ) { BasicProjectAndTaskFilter filter = new BasicProjectAndTaskFilter ( ) ; filter . serializeIn ( settingsNode ) ; editor = new BasicFilterEditor ( filter ) ; editor . addFilterEditorObserver ( new BasicFilterEditor . FilterEditorObserver ( ) { public void filterChanged ( ) { editor . createFilter ( ) . serializeOut ( settingsNode ) ; } } , false ) ; } public String getName ( ) { return <str> ; } public Component createComponent ( ) { setupUI ( ) ; enableThingsAppropriately ( ) ; return mainPanel ; } public void aboutToShow ( ) { resetShowDescription ( ) ; refresh ( ) ; } public void setupUI ( ) { mainPanel = new JPanel ( new BorderLayout ( ) ) ; mainPanel . add ( createTopPanel ( ) , BorderLayout . NORTH ) ; mainPanel . add ( createTreePanel ( ) , BorderLayout . CENTER ) ; setupPopupMenu ( ) ; } private Component createTopPanel ( ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; refreshButton = Utility . createButton ( getClass ( ) , <str> , <str> , new AbstractAction ( <str> ) { public void actionPerformed ( ActionEvent e ) { refresh ( ) ; } } ) ; executeButton = Utility . createButton ( getClass ( ) , EXECUTE_PNG , <str> , new AbstractAction ( <str> ) { public void actionPerformed ( ActionEvent e ) { executeSelectedTasks ( ) ; } } ) ; toggleFilterButton = Utility . createToggleButton ( getClass ( ) , <str> , <str> , new AbstractAction ( <str> ) { public void actionPerformed ( ActionEvent e ) { populate ( ) ; } } ) ; toggleFilterButton . setSelected ( true ) ; editFilterButton = Utility . createButton ( getClass ( ) , <str> , <str> , new AbstractAction ( <str> ) { public void actionPerformed ( ActionEvent e ) { configureFilter ( ) ; } } ) ; showDescriptionCheckBox = new JCheckBox ( <str> , true ) ; showDescriptionCheckBox . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { resetShowDescription ( ) ; } } ) ; showDescriptionCheckBox . setSelected ( settingsNode . getValueOfChildAsBoolean ( SHOW_DESCRIPTION , showDescriptionCheckBox . isSelected ( ) ) ) ; panel . add ( refreshButton ) ; panel . add ( Box . createHorizontalStrut ( <int> ) ) ; panel . add ( executeButton ) ; panel . add ( Box . createHorizontalStrut ( <int> ) ) ; panel . add ( toggleFilterButton ) ; panel . add ( Box . createHorizontalStrut ( <int> ) ) ; panel . add ( showDescriptionCheckBox ) ; panel . add ( Box . createHorizontalGlue ( ) ) ; panel . add ( editFilterButton ) ; panel . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; return panel ; } private Component createTreePanel ( ) { treeComponent = new TaskTreeComponent ( gradlePluginLord , new TaskTreeComponent . Interaction ( ) { public void rightClick ( JTree tree , int x , int y ) { enableThingsAppropriately ( ) ; popupMenu . show ( tree , x , y ) ; } public void taskInvoked ( TaskView task , boolean isCtrlKeyDown ) { if ( isCtrlKeyDown ) { gradlePluginLord . addExecutionRequestToQueue ( task , false , <str> ) ; } else { gradlePluginLord . addExecutionRequestToQueue ( task , false ) ; } } public void projectInvoked ( ProjectView project ) { executeDefaultTasksInProject ( project ) ; } } ) ; treeComponent . getTree ( ) . addTreeSelectionListener ( new TreeSelectionListener ( ) { public void valueChanged ( TreeSelectionEvent e ) { enableThingsAppropriately ( ) ; } } ) ; defaultTreeBackground = treeComponent . getTree ( ) . getBackground ( ) ; treeScrollPane = new JScrollPane ( ) ; treeComponent . getTree ( ) . setBackground ( workingBackgroundColor ) ; showTextInViewport ( <str> ) ; return treeScrollPane ; } private void showTextInViewport ( String text ) { treeScrollPane . getViewport ( ) . removeAll ( ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . X_AXIS ) ) ; panel . add ( Box . createHorizontalGlue ( ) ) ; panel . add ( new JLabel ( text ) ) ; panel . add ( Box . createHorizontalGlue ( ) ) ; treeScrollPane . getViewport ( ) . add ( panel ) ; treeScrollPane . revalidate ( ) ; } private void showTreeInViewport ( ) { treeScrollPane . getViewport ( ) . removeAll ( ) ; treeScrollPane . getViewport ( ) . add ( treeComponent . getTree ( ) ) ; treeScrollPane . revalidate ( ) ; } public void executionRequestAdded ( ExecutionRequest request ) { } public void refreshRequestAdded ( RefreshTaskListRequest request ) { isRefreshing = true ; enableThingsAppropriately ( ) ; treeComponent . getTree ( ) . setBackground ( workingBackgroundColor ) ; showTextInViewport ( <str> ) ; } public void aboutToExecuteRequest ( Request request ) { } public void requestExecutionComplete ( Request request , int result , String output ) { if ( request instanceof RefreshTaskListRequest ) { isRefreshing = false ; enableThingsAppropriately ( ) ; if ( result ! = <int> ) { showTextInViewport ( <str> ) ; } } } private void refresh ( ) { gradlePluginLord . addRefreshRequestToQueue ( ) ; } private void populate ( ) { if ( toggleFilterButton . isSelected ( ) ) { treeComponent . populate ( editor . createFilter ( ) ) ; } else { treeComponent . populate ( new AllowAllProjectAndTaskFilter ( ) ) ; } treeComponent . getTree ( ) . setBackground ( defaultTreeBackground ) ; showTreeInViewport ( ) ; } private void executeSelectedTasks ( String . . . additionCommandLineOptions ) { List < TaskView > taskViews = treeComponent . getSelectedTasks ( ) ; String singleCommandLine = CommandLineAssistant . combineTasks ( taskViews , additionCommandLineOptions ) ; if ( singleCommandLine = = null ) { return ; } gradlePluginLord . addExecutionRequestToQueue ( singleCommandLine , singleCommandLine , false ) ; } public void startingProjectsAndTasksReload ( ) { treeComponent . getTree ( ) . setBackground ( workingBackgroundColor ) ; showTextInViewport ( <str> ) ; } public void projectsAndTasksReloaded ( boolean wasSuccessful ) { isRefreshing = false ; enableThingsAppropriately ( ) ; if ( ! wasSuccessful ) { showTextInViewport ( <str> ) ; } else { populate ( ) ; } } private void setupPopupMenu ( ) { popupMenu = new JPopupMenu ( ) ; executeMenuItem = Utility . createMenuItem ( this . getClass ( ) , <str> , EXECUTE_PNG , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { executeSelectedTasks ( ) ; } } ) ; popupMenu . add ( executeMenuItem ) ; executeOnlyThisMenuItem = Utility . createMenuItem ( this . getClass ( ) , <str> , BLANK_PNG , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { executeSelectedTasks ( <str> ) ; } } ) ; popupMenu . add ( executeOnlyThisMenuItem ) ; popupMenu . addSeparator ( ) ; addToFavoritesMenuItem = Utility . createMenuItem ( this . getClass ( ) , <str> , BLANK_PNG , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { addSelectedToFavorites ( ) ; } } ) ; popupMenu . add ( addToFavoritesMenuItem ) ; filterOutMenuItem = Utility . createMenuItem ( this . getClass ( ) , <str> , BLANK_PNG , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { hideSelection ( ) ; } } ) ; popupMenu . add ( filterOutMenuItem ) ; editFileMenuItem = Utility . createMenuItem ( this . getClass ( ) , <str> , BLANK_PNG , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { editSelectedFiles ( ) ; } } ) ; popupMenu . add ( editFileMenuItem ) ; copyTaskNameMenuItem = Utility . createMenuItem ( this . getClass ( ) , <str> , BLANK_PNG , new AbstractAction ( ) { public void actionPerformed ( ActionEvent e ) { copySelectedTaskNames ( ) ; } } ) ; popupMenu . addSeparator ( ) ; popupMenu . add ( copyTaskNameMenuItem ) ; } private void enableThingsAppropriately ( ) { boolean hasSelection = treeComponent . getTree ( ) . getSelectionPath ( ) ! = null ; boolean hasTaskSelection = treeComponent . hasTasksSelected ( ) ; boolean canDoThings = ! isRefreshing & & treeComponent . isPopulated ( ) & & hasSelection ; refreshButton . setEnabled ( ! isRefreshing ) ; addToFavoritesMenuItem . setEnabled ( canDoThings ) ; executeMenuItem . setEnabled ( canDoThings ) ; executeOnlyThisMenuItem . setEnabled ( canDoThings ) ; executeButton . setEnabled ( canDoThings ) ; if ( alternateUIInteraction . doesSupportEditingOpeningFiles ( ) ) { editFileMenuItem . setVisible ( true ) ; boolean hasProjectsSelected = treeComponent . hasProjectsSelected ( ) ; editFileMenuItem . setEnabled ( hasProjectsSelected & & canDoThings ) ; } else { editFileMenuItem . setVisible ( false ) ; } copyTaskNameMenuItem . setVisible ( ! isRefreshing & & hasTaskSelection ) ; } private void addSelectedToFavorites ( ) { List < TaskView > tasks = treeComponent . getSelectedTasks ( ) ; gradlePluginLord . getFavoritesEditor ( ) . addMutlipleFavorites ( tasks , false , new SwingAddMultipleFavoritesInteraction ( SwingUtilities . getWindowAncestor ( mainPanel ) ) ) ; } private void configureFilter ( ) { ProjectAndTaskFilterDialog dialog = new ProjectAndTaskFilterDialog ( SwingUtilities . getWindowAncestor ( mainPanel ) , gradlePluginLord ) ; BasicProjectAndTaskFilter newFilter = dialog . show ( editor . createFilter ( ) ) ; if ( newFilter ! = null ) { editor . initializeFromFilter ( newFilter ) ; populate ( ) ; } } private void hideSelection ( ) { TaskTreeComponent . MultipleSelection multipleSelection = treeComponent . getSelectedProjectsAndTasks ( ) ; if ( ! multipleSelection . projects . isEmpty ( ) | | ! multipleSelection . tasks . isEmpty ( ) ) { editor . hideProjects ( multipleSelection . projects ) ; editor . hideTasks ( multipleSelection . tasks ) ; populate ( ) ; } } private void resetShowDescription ( ) { settingsNode . setValueOfChildAsBoolean ( SHOW_DESCRIPTION , showDescriptionCheckBox . isSelected ( ) ) ; treeComponent . setShowDescription ( showDescriptionCheckBox . isSelected ( ) ) ; } private void editSelectedFiles ( ) { TaskTreeComponent . MultipleSelection tasks = treeComponent . getSelectedProjectsAndTasks ( ) ; Iterator < ProjectView > iterator = tasks . projects . iterator ( ) ; while ( iterator . hasNext ( ) ) { ProjectView projectView = iterator . next ( ) ; File file = projectView . getBuildFile ( ) ; if ( file ! = null ) { alternateUIInteraction . editFile ( file , - <int> ) ; } } } private void executeDefaultTasksInProject ( ProjectView project ) { Iterator < TaskView > iterator = project . getDefaultTasks ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { TaskView task = iterator . next ( ) ; gradlePluginLord . addExecutionRequestToQueue ( task , false ) ; } } private void copySelectedTaskNames ( ) { String names = getSelectedTaskNames ( ) ; if ( names . length ( ) = = <int> ) { return ; } Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) . setContents ( new StringSelection ( names ) , null ) ; } private String getSelectedTaskNames ( ) { List < TaskView > tasks = treeComponent . getSelectedTasks ( ) ; if ( tasks . isEmpty ( ) ) { return null ; } StringBuilder taskString = new StringBuilder ( ) ; Iterator < TaskView > iterator = tasks . iterator ( ) ; while ( iterator . hasNext ( ) ) { TaskView taskView = iterator . next ( ) ; taskString . append ( taskView . getFullTaskName ( ) ) ; if ( iterator . hasNext ( ) ) { taskString . append ( <str> ) ; } } return taskString . toString ( ) ; } } 
