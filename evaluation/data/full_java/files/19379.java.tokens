package io . netty . handler . codec . http2 . hpack ; import io . netty . handler . codec . http2 . hpack . HpackUtil . IndexType ; import java . io . IOException ; import java . io . InputStream ; public final class Decoder { private static final IOException DECOMPRESSION_EXCEPTION = new IOException ( <str> ) ; private static final IOException ILLEGAL_INDEX_VALUE = new IOException ( <str> ) ; private static final IOException INVALID_MAX_DYNAMIC_TABLE_SIZE = new IOException ( <str> ) ; private static final IOException MAX_DYNAMIC_TABLE_SIZE_CHANGE_REQUIRED = new IOException ( <str> ) ; private static final byte [ ] EMPTY = { } ; private final DynamicTable dynamicTable ; private int maxHeaderSize ; private int maxDynamicTableSize ; private int encoderMaxDynamicTableSize ; private boolean maxDynamicTableSizeChangeRequired ; private long headerSize ; private State state ; private IndexType indexType ; private int index ; private boolean huffmanEncoded ; private int skipLength ; private int nameLength ; private int valueLength ; private byte [ ] name ; private enum State { READ_HEADER_REPRESENTATION , READ_MAX_DYNAMIC_TABLE_SIZE , READ_INDEXED_HEADER , READ_INDEXED_HEADER_NAME , READ_LITERAL_HEADER_NAME_LENGTH_PREFIX , READ_LITERAL_HEADER_NAME_LENGTH , READ_LITERAL_HEADER_NAME , SKIP_LITERAL_HEADER_NAME , READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX , READ_LITERAL_HEADER_VALUE_LENGTH , READ_LITERAL_HEADER_VALUE , SKIP_LITERAL_HEADER_VALUE } public Decoder ( int maxHeaderSize , int maxHeaderTableSize ) { dynamicTable = new DynamicTable ( maxHeaderTableSize ) ; this . maxHeaderSize = maxHeaderSize ; maxDynamicTableSize = maxHeaderTableSize ; encoderMaxDynamicTableSize = maxHeaderTableSize ; maxDynamicTableSizeChangeRequired = false ; reset ( ) ; } private void reset ( ) { headerSize = <int> ; state = State . READ_HEADER_REPRESENTATION ; indexType = IndexType . NONE ; } public void decode ( InputStream in , HeaderListener headerListener ) throws IOException { while ( in . available ( ) > <int> ) { switch ( state ) { case READ_HEADER_REPRESENTATION : byte b = ( byte ) in . read ( ) ; if ( maxDynamicTableSizeChangeRequired & & ( b & <hex> ) ! = <hex> ) { throw MAX_DYNAMIC_TABLE_SIZE_CHANGE_REQUIRED ; } if ( b < <int> ) { index = b & <hex> ; if ( index = = <int> ) { throw ILLEGAL_INDEX_VALUE ; } else if ( index = = <hex> ) { state = State . READ_INDEXED_HEADER ; } else { indexHeader ( index , headerListener ) ; } } else if ( ( b & <hex> ) = = <hex> ) { indexType = IndexType . INCREMENTAL ; index = b & <hex> ; if ( index = = <int> ) { state = State . READ_LITERAL_HEADER_NAME_LENGTH_PREFIX ; } else if ( index = = <hex> ) { state = State . READ_INDEXED_HEADER_NAME ; } else { readName ( index ) ; state = State . READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX ; } } else if ( ( b & <hex> ) = = <hex> ) { index = b & <hex> ; if ( index = = <hex> ) { state = State . READ_MAX_DYNAMIC_TABLE_SIZE ; } else { setDynamicTableSize ( index ) ; state = State . READ_HEADER_REPRESENTATION ; } } else { indexType = ( ( b & <hex> ) = = <hex> ) ? IndexType . NEVER : IndexType . NONE ; index = b & <hex> ; if ( index = = <int> ) { state = State . READ_LITERAL_HEADER_NAME_LENGTH_PREFIX ; } else if ( index = = <hex> ) { state = State . READ_INDEXED_HEADER_NAME ; } else { readName ( index ) ; state = State . READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX ; } } break ; case READ_MAX_DYNAMIC_TABLE_SIZE : int maxSize = decodeULE128 ( in ) ; if ( maxSize = = - <int> ) { return ; } if ( maxSize > Integer . MAX_VALUE - index ) { throw DECOMPRESSION_EXCEPTION ; } setDynamicTableSize ( index + maxSize ) ; state = State . READ_HEADER_REPRESENTATION ; break ; case READ_INDEXED_HEADER : int headerIndex = decodeULE128 ( in ) ; if ( headerIndex = = - <int> ) { return ; } if ( headerIndex > Integer . MAX_VALUE - index ) { throw DECOMPRESSION_EXCEPTION ; } indexHeader ( index + headerIndex , headerListener ) ; state = State . READ_HEADER_REPRESENTATION ; break ; case READ_INDEXED_HEADER_NAME : int nameIndex = decodeULE128 ( in ) ; if ( nameIndex = = - <int> ) { return ; } if ( nameIndex > Integer . MAX_VALUE - index ) { throw DECOMPRESSION_EXCEPTION ; } readName ( index + nameIndex ) ; state = State . READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX ; break ; case READ_LITERAL_HEADER_NAME_LENGTH_PREFIX : b = ( byte ) in . read ( ) ; huffmanEncoded = ( b & <hex> ) = = <hex> ; index = b & <hex> ; if ( index = = <hex> ) { state = State . READ_LITERAL_HEADER_NAME_LENGTH ; } else { nameLength = index ; if ( nameLength = = <int> ) { throw DECOMPRESSION_EXCEPTION ; } if ( exceedsMaxHeaderSize ( nameLength ) ) { if ( indexType = = IndexType . NONE ) { name = EMPTY ; skipLength = nameLength ; state = State . SKIP_LITERAL_HEADER_NAME ; break ; } if ( nameLength + HeaderField . HEADER_ENTRY_OVERHEAD > dynamicTable . capacity ( ) ) { dynamicTable . clear ( ) ; name = EMPTY ; skipLength = nameLength ; state = State . SKIP_LITERAL_HEADER_NAME ; break ; } } state = State . READ_LITERAL_HEADER_NAME ; } break ; case READ_LITERAL_HEADER_NAME_LENGTH : nameLength = decodeULE128 ( in ) ; if ( nameLength = = - <int> ) { return ; } if ( nameLength > Integer . MAX_VALUE - index ) { throw DECOMPRESSION_EXCEPTION ; } nameLength + = index ; if ( exceedsMaxHeaderSize ( nameLength ) ) { if ( indexType = = IndexType . NONE ) { name = EMPTY ; skipLength = nameLength ; state = State . SKIP_LITERAL_HEADER_NAME ; break ; } if ( nameLength + HeaderField . HEADER_ENTRY_OVERHEAD > dynamicTable . capacity ( ) ) { dynamicTable . clear ( ) ; name = EMPTY ; skipLength = nameLength ; state = State . SKIP_LITERAL_HEADER_NAME ; break ; } } state = State . READ_LITERAL_HEADER_NAME ; break ; case READ_LITERAL_HEADER_NAME : if ( in . available ( ) < nameLength ) { return ; } name = readStringLiteral ( in , nameLength ) ; state = State . READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX ; break ; case SKIP_LITERAL_HEADER_NAME : skipLength - = in . skip ( skipLength ) ; if ( skipLength = = <int> ) { state = State . READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX ; } break ; case READ_LITERAL_HEADER_VALUE_LENGTH_PREFIX : b = ( byte ) in . read ( ) ; huffmanEncoded = ( b & <hex> ) = = <hex> ; index = b & <hex> ; if ( index = = <hex> ) { state = State . READ_LITERAL_HEADER_VALUE_LENGTH ; } else { valueLength = index ; long newHeaderSize = ( long ) nameLength + ( long ) valueLength ; if ( exceedsMaxHeaderSize ( newHeaderSize ) ) { headerSize = maxHeaderSize + <int> ; if ( indexType = = IndexType . NONE ) { state = State . SKIP_LITERAL_HEADER_VALUE ; break ; } if ( newHeaderSize + HeaderField . HEADER_ENTRY_OVERHEAD > dynamicTable . capacity ( ) ) { dynamicTable . clear ( ) ; state = State . SKIP_LITERAL_HEADER_VALUE ; break ; } } if ( valueLength = = <int> ) { insertHeader ( headerListener , name , EMPTY , indexType ) ; state = State . READ_HEADER_REPRESENTATION ; } else { state = State . READ_LITERAL_HEADER_VALUE ; } } break ; case READ_LITERAL_HEADER_VALUE_LENGTH : valueLength = decodeULE128 ( in ) ; if ( valueLength = = - <int> ) { return ; } if ( valueLength > Integer . MAX_VALUE - index ) { throw DECOMPRESSION_EXCEPTION ; } valueLength + = index ; long newHeaderSize = ( long ) nameLength + ( long ) valueLength ; if ( newHeaderSize + headerSize > maxHeaderSize ) { headerSize = maxHeaderSize + <int> ; if ( indexType = = IndexType . NONE ) { state = State . SKIP_LITERAL_HEADER_VALUE ; break ; } if ( newHeaderSize + HeaderField . HEADER_ENTRY_OVERHEAD > dynamicTable . capacity ( ) ) { dynamicTable . clear ( ) ; state = State . SKIP_LITERAL_HEADER_VALUE ; break ; } } state = State . READ_LITERAL_HEADER_VALUE ; break ; case READ_LITERAL_HEADER_VALUE : if ( in . available ( ) < valueLength ) { return ; } byte [ ] value = readStringLiteral ( in , valueLength ) ; insertHeader ( headerListener , name , value , indexType ) ; state = State . READ_HEADER_REPRESENTATION ; break ; case SKIP_LITERAL_HEADER_VALUE : valueLength - = in . skip ( valueLength ) ; if ( valueLength = = <int> ) { state = State . READ_HEADER_REPRESENTATION ; } break ; default: throw new IllegalStateException ( <str> ) ; } } } public boolean endHeaderBlock ( ) { boolean truncated = headerSize > maxHeaderSize ; reset ( ) ; return truncated ; } public void setMaxHeaderTableSize ( int maxHeaderTableSize ) { maxDynamicTableSize = maxHeaderTableSize ; if ( maxDynamicTableSize < encoderMaxDynamicTableSize ) { maxDynamicTableSizeChangeRequired = true ; dynamicTable . setCapacity ( maxDynamicTableSize ) ; } } public int getMaxHeaderTableSize ( ) { return dynamicTable . capacity ( ) ; } int length ( ) { return dynamicTable . length ( ) ; } int size ( ) { return dynamicTable . size ( ) ; } HeaderField getHeaderField ( int index ) { return dynamicTable . getEntry ( index + <int> ) ; } private void setDynamicTableSize ( int dynamicTableSize ) throws IOException { if ( dynamicTableSize > maxDynamicTableSize ) { throw INVALID_MAX_DYNAMIC_TABLE_SIZE ; } encoderMaxDynamicTableSize = dynamicTableSize ; maxDynamicTableSizeChangeRequired = false ; dynamicTable . setCapacity ( dynamicTableSize ) ; } private void readName ( int index ) throws IOException { if ( index < = StaticTable . length ) { HeaderField headerField = StaticTable . getEntry ( index ) ; name = headerField . name ; } else if ( index - StaticTable . length < = dynamicTable . length ( ) ) { HeaderField headerField = dynamicTable . getEntry ( index - StaticTable . length ) ; name = headerField . name ; } else { throw ILLEGAL_INDEX_VALUE ; } } private void indexHeader ( int index , HeaderListener headerListener ) throws IOException { if ( index < = StaticTable . length ) { HeaderField headerField = StaticTable . getEntry ( index ) ; addHeader ( headerListener , headerField . name , headerField . value , false ) ; } else if ( index - StaticTable . length < = dynamicTable . length ( ) ) { HeaderField headerField = dynamicTable . getEntry ( index - StaticTable . length ) ; addHeader ( headerListener , headerField . name , headerField . value , false ) ; } else { throw ILLEGAL_INDEX_VALUE ; } } private void insertHeader ( HeaderListener headerListener , byte [ ] name , byte [ ] value , IndexType indexType ) { addHeader ( headerListener , name , value , indexType = = IndexType . NEVER ) ; switch ( indexType ) { case NONE : case NEVER : break ; case INCREMENTAL : dynamicTable . add ( new HeaderField ( name , value ) ) ; break ; default: throw new IllegalStateException ( <str> ) ; } } private void addHeader ( HeaderListener headerListener , byte [ ] name , byte [ ] value , boolean sensitive ) { if ( name . length = = <int> ) { throw new AssertionError ( <str> ) ; } long newSize = headerSize + name . length + value . length ; if ( newSize < = maxHeaderSize ) { headerListener . addHeader ( name , value , sensitive ) ; headerSize = ( int ) newSize ; } else { headerSize = maxHeaderSize + <int> ; } } private boolean exceedsMaxHeaderSize ( long size ) { if ( size + headerSize < = maxHeaderSize ) { return false ; } headerSize = maxHeaderSize + <int> ; return true ; } private byte [ ] readStringLiteral ( InputStream in , int length ) throws IOException { byte [ ] buf = new byte [ length ] ; if ( in . read ( buf ) ! = length ) { throw DECOMPRESSION_EXCEPTION ; } if ( huffmanEncoded ) { return Huffman . DECODER . decode ( buf ) ; } else { return buf ; } } private static int decodeULE128 ( InputStream in ) throws IOException { in . mark ( <int> ) ; int result = <int> ; int shift = <int> ; while ( shift < <int> ) { if ( in . available ( ) = = <int> ) { in . reset ( ) ; return - <int> ; } byte b = ( byte ) in . read ( ) ; if ( shift = = <int> & & ( b & <hex> ) ! = <int> ) { break ; } result | = ( b & <hex> ) < < shift ; if ( ( b & <hex> ) = = <int> ) { return result ; } shift + = <int> ; } in . reset ( ) ; throw DECOMPRESSION_EXCEPTION ; } } 
