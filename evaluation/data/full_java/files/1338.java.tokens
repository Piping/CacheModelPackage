package org . apache . cassandra . cache ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . junit . Assert ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . CacheService ; import org . apache . cassandra . utils . ByteBufferUtil ; public class AutoSavingCacheTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , CFMetaData . Builder . create ( KEYSPACE1 , CF_STANDARD1 ) . addPartitionKey ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . build ( ) ) ; } @Test public void testSerializeAndLoadKeyCache ( ) throws Exception { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( CF_STANDARD1 ) ; for ( int i = <int> ; i < <int> ; i + + ) { ColumnDefinition colDef = ColumnDefinition . regularDef ( cfs . metadata , ByteBufferUtil . bytes ( <str> ) , AsciiType . instance ) ; RowUpdateBuilder rowBuilder = new RowUpdateBuilder ( cfs . metadata , System . currentTimeMillis ( ) , <str> ) ; rowBuilder . add ( colDef , <str> ) ; rowBuilder . build ( ) . apply ( ) ; cfs . forceBlockingFlush ( ) ; } Assert . assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) sstable . getPosition ( Util . dk ( <str> ) , SSTableReader . Operator . EQ ) ; AutoSavingCache < KeyCacheKey , RowIndexEntry > keyCache = CacheService . instance . keyCache ; keyCache . submitWrite ( keyCache . size ( ) ) . get ( ) ; keyCache . clear ( ) ; Assert . assertEquals ( <int> , keyCache . size ( ) ) ; keyCache . loadSavedAsync ( ) . get ( ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) Assert . assertNotNull ( keyCache . get ( new KeyCacheKey ( cfs . metadata . ksAndCFName , sstable . descriptor , ByteBufferUtil . bytes ( <str> ) ) ) ) ; } } 
