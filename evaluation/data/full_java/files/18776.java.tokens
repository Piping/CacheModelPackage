package io . netty . buffer ; import io . netty . buffer . PoolArena . SizeClass ; import io . netty . util . Recycler ; import io . netty . util . Recycler . Handle ; import io . netty . util . ThreadDeathWatcher ; import io . netty . util . internal . MathUtil ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . nio . ByteBuffer ; import java . util . Queue ; final class PoolThreadCache { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( PoolThreadCache . class ) ; final PoolArena < byte [ ] > heapArena ; final PoolArena < ByteBuffer > directArena ; private final MemoryRegionCache < byte [ ] > [ ] tinySubPageHeapCaches ; private final MemoryRegionCache < byte [ ] > [ ] smallSubPageHeapCaches ; private final MemoryRegionCache < ByteBuffer > [ ] tinySubPageDirectCaches ; private final MemoryRegionCache < ByteBuffer > [ ] smallSubPageDirectCaches ; private final MemoryRegionCache < byte [ ] > [ ] normalHeapCaches ; private final MemoryRegionCache < ByteBuffer > [ ] normalDirectCaches ; private final int numShiftsNormalDirect ; private final int numShiftsNormalHeap ; private final int freeSweepAllocationThreshold ; private int allocations ; private final Thread thread = Thread . currentThread ( ) ; private final Runnable freeTask = new Runnable ( ) { @Override public void run ( ) { free0 ( ) ; } } ; PoolThreadCache ( PoolArena < byte [ ] > heapArena , PoolArena < ByteBuffer > directArena , int tinyCacheSize , int smallCacheSize , int normalCacheSize , int maxCachedBufferCapacity , int freeSweepAllocationThreshold ) { if ( maxCachedBufferCapacity < <int> ) { throw new IllegalArgumentException ( <str> + maxCachedBufferCapacity + <str> ) ; } if ( freeSweepAllocationThreshold < <int> ) { throw new IllegalArgumentException ( <str> + maxCachedBufferCapacity + <str> ) ; } this . freeSweepAllocationThreshold = freeSweepAllocationThreshold ; this . heapArena = heapArena ; this . directArena = directArena ; if ( directArena ! = null ) { tinySubPageDirectCaches = createSubPageCaches ( tinyCacheSize , PoolArena . numTinySubpagePools , SizeClass . Tiny ) ; smallSubPageDirectCaches = createSubPageCaches ( smallCacheSize , directArena . numSmallSubpagePools , SizeClass . Small ) ; numShiftsNormalDirect = log2 ( directArena . pageSize ) ; normalDirectCaches = createNormalCaches ( normalCacheSize , maxCachedBufferCapacity , directArena ) ; } else { tinySubPageDirectCaches = null ; smallSubPageDirectCaches = null ; normalDirectCaches = null ; numShiftsNormalDirect = - <int> ; } if ( heapArena ! = null ) { tinySubPageHeapCaches = createSubPageCaches ( tinyCacheSize , PoolArena . numTinySubpagePools , SizeClass . Tiny ) ; smallSubPageHeapCaches = createSubPageCaches ( smallCacheSize , heapArena . numSmallSubpagePools , SizeClass . Small ) ; numShiftsNormalHeap = log2 ( heapArena . pageSize ) ; normalHeapCaches = createNormalCaches ( normalCacheSize , maxCachedBufferCapacity , heapArena ) ; } else { tinySubPageHeapCaches = null ; smallSubPageHeapCaches = null ; normalHeapCaches = null ; numShiftsNormalHeap = - <int> ; } ThreadDeathWatcher . watch ( thread , freeTask ) ; } private static < T > MemoryRegionCache < T > [ ] createSubPageCaches ( int cacheSize , int numCaches , SizeClass sizeClass ) { if ( cacheSize > <int> ) { @SuppressWarnings ( <str> ) MemoryRegionCache < T > [ ] cache = new MemoryRegionCache [ numCaches ] ; for ( int i = <int> ; i < cache . length ; i + + ) { cache [ i ] = new SubPageMemoryRegionCache < T > ( cacheSize , sizeClass ) ; } return cache ; } else { return null ; } } private static < T > MemoryRegionCache < T > [ ] createNormalCaches ( int cacheSize , int maxCachedBufferCapacity , PoolArena < T > area ) { if ( cacheSize > <int> ) { int max = Math . min ( area . chunkSize , maxCachedBufferCapacity ) ; int arraySize = Math . max ( <int> , log2 ( max / area . pageSize ) + <int> ) ; @SuppressWarnings ( <str> ) MemoryRegionCache < T > [ ] cache = new MemoryRegionCache [ arraySize ] ; for ( int i = <int> ; i < cache . length ; i + + ) { cache [ i ] = new NormalMemoryRegionCache < T > ( cacheSize ) ; } return cache ; } else { return null ; } } private static int log2 ( int val ) { int res = <int> ; while ( val > <int> ) { val > > = <int> ; res + + ; } return res ; } boolean allocateTiny ( PoolArena < ? > area , PooledByteBuf < ? > buf , int reqCapacity , int normCapacity ) { return allocate ( cacheForTiny ( area , normCapacity ) , buf , reqCapacity ) ; } boolean allocateSmall ( PoolArena < ? > area , PooledByteBuf < ? > buf , int reqCapacity , int normCapacity ) { return allocate ( cacheForSmall ( area , normCapacity ) , buf , reqCapacity ) ; } boolean allocateNormal ( PoolArena < ? > area , PooledByteBuf < ? > buf , int reqCapacity , int normCapacity ) { return allocate ( cacheForNormal ( area , normCapacity ) , buf , reqCapacity ) ; } @SuppressWarnings ( { <str> , <str> } ) private boolean allocate ( MemoryRegionCache < ? > cache , PooledByteBuf buf , int reqCapacity ) { if ( cache = = null ) { return false ; } boolean allocated = cache . allocate ( buf , reqCapacity ) ; if ( + + allocations > = freeSweepAllocationThreshold ) { allocations = <int> ; trim ( ) ; } return allocated ; } @SuppressWarnings ( { <str> , <str> } ) boolean add ( PoolArena < ? > area , PoolChunk chunk , long handle , int normCapacity , SizeClass sizeClass ) { MemoryRegionCache < ? > cache = cache ( area , normCapacity , sizeClass ) ; if ( cache = = null ) { return false ; } return cache . add ( chunk , handle ) ; } private MemoryRegionCache < ? > cache ( PoolArena < ? > area , int normCapacity , SizeClass sizeClass ) { switch ( sizeClass ) { case Normal : return cacheForNormal ( area , normCapacity ) ; case Small : return cacheForSmall ( area , normCapacity ) ; case Tiny : return cacheForTiny ( area , normCapacity ) ; default : throw new Error ( ) ; } } void free ( ) { ThreadDeathWatcher . unwatch ( thread , freeTask ) ; free0 ( ) ; } private void free0 ( ) { int numFreed = free ( tinySubPageDirectCaches ) + free ( smallSubPageDirectCaches ) + free ( normalDirectCaches ) + free ( tinySubPageHeapCaches ) + free ( smallSubPageHeapCaches ) + free ( normalHeapCaches ) ; if ( numFreed > <int> & & logger . isDebugEnabled ( ) ) { logger . debug ( <str> , numFreed , thread . getName ( ) ) ; } } private static int free ( MemoryRegionCache < ? > [ ] caches ) { if ( caches = = null ) { return <int> ; } int numFreed = <int> ; for ( MemoryRegionCache < ? > c : caches ) { numFreed + = free ( c ) ; } return numFreed ; } private static int free ( MemoryRegionCache < ? > cache ) { if ( cache = = null ) { return <int> ; } return cache . free ( ) ; } void trim ( ) { trim ( tinySubPageDirectCaches ) ; trim ( smallSubPageDirectCaches ) ; trim ( normalDirectCaches ) ; trim ( tinySubPageHeapCaches ) ; trim ( smallSubPageHeapCaches ) ; trim ( normalHeapCaches ) ; } private static void trim ( MemoryRegionCache < ? > [ ] caches ) { if ( caches = = null ) { return ; } for ( MemoryRegionCache < ? > c : caches ) { trim ( c ) ; } } private static void trim ( MemoryRegionCache < ? > cache ) { if ( cache = = null ) { return ; } cache . trim ( ) ; } private MemoryRegionCache < ? > cacheForTiny ( PoolArena < ? > area , int normCapacity ) { int idx = PoolArena . tinyIdx ( normCapacity ) ; if ( area . isDirect ( ) ) { return cache ( tinySubPageDirectCaches , idx ) ; } return cache ( tinySubPageHeapCaches , idx ) ; } private MemoryRegionCache < ? > cacheForSmall ( PoolArena < ? > area , int normCapacity ) { int idx = PoolArena . smallIdx ( normCapacity ) ; if ( area . isDirect ( ) ) { return cache ( smallSubPageDirectCaches , idx ) ; } return cache ( smallSubPageHeapCaches , idx ) ; } private MemoryRegionCache < ? > cacheForNormal ( PoolArena < ? > area , int normCapacity ) { if ( area . isDirect ( ) ) { int idx = log2 ( normCapacity > > numShiftsNormalDirect ) ; return cache ( normalDirectCaches , idx ) ; } int idx = log2 ( normCapacity > > numShiftsNormalHeap ) ; return cache ( normalHeapCaches , idx ) ; } private static < T > MemoryRegionCache < T > cache ( MemoryRegionCache < T > [ ] cache , int idx ) { if ( cache = = null | | idx > cache . length - <int> ) { return null ; } return cache [ idx ] ; } private static final class SubPageMemoryRegionCache < T > extends MemoryRegionCache < T > { SubPageMemoryRegionCache ( int size , SizeClass sizeClass ) { super ( size , sizeClass ) ; } @Override protected void initBuf ( PoolChunk < T > chunk , long handle , PooledByteBuf < T > buf , int reqCapacity ) { chunk . initBufWithSubpage ( buf , handle , reqCapacity ) ; } } private static final class NormalMemoryRegionCache < T > extends MemoryRegionCache < T > { NormalMemoryRegionCache ( int size ) { super ( size , SizeClass . Normal ) ; } @Override protected void initBuf ( PoolChunk < T > chunk , long handle , PooledByteBuf < T > buf , int reqCapacity ) { chunk . initBuf ( buf , handle , reqCapacity ) ; } } private abstract static class MemoryRegionCache < T > { private final int size ; private final Queue < Entry < T > > queue ; private final SizeClass sizeClass ; private int allocations ; MemoryRegionCache ( int size , SizeClass sizeClass ) { this . size = MathUtil . findNextPositivePowerOfTwo ( size ) ; queue = PlatformDependent . newFixedMpscQueue ( this . size ) ; this . sizeClass = sizeClass ; } protected abstract void initBuf ( PoolChunk < T > chunk , long handle , PooledByteBuf < T > buf , int reqCapacity ) ; @SuppressWarnings ( <str> ) public final boolean add ( PoolChunk < T > chunk , long handle ) { Entry < T > entry = newEntry ( chunk , handle ) ; boolean queued = queue . offer ( entry ) ; if ( ! queued ) { entry . recycle ( ) ; } return queued ; } public final boolean allocate ( PooledByteBuf < T > buf , int reqCapacity ) { Entry < T > entry = queue . poll ( ) ; if ( entry = = null ) { return false ; } initBuf ( entry . chunk , entry . handle , buf , reqCapacity ) ; entry . recycle ( ) ; + + allocations ; return true ; } public final int free ( ) { return free ( Integer . MAX_VALUE ) ; } private int free ( int max ) { int numFreed = <int> ; for ( ; numFreed < max ; numFreed + + ) { Entry < T > entry = queue . poll ( ) ; if ( entry ! = null ) { freeEntry ( entry ) ; } else { return numFreed ; } } return numFreed ; } public final void trim ( ) { int free = size - allocations ; allocations = <int> ; if ( free > <int> ) { free ( free ) ; } } @SuppressWarnings ( { <str> , <str> } ) private void freeEntry ( Entry entry ) { PoolChunk chunk = entry . chunk ; long handle = entry . handle ; entry . recycle ( ) ; chunk . arena . freeChunk ( chunk , handle , sizeClass ) ; } static final class Entry < T > { final Handle recyclerHandle ; PoolChunk < T > chunk ; long handle = - <int> ; Entry ( Handle recyclerHandle ) { this . recyclerHandle = recyclerHandle ; } void recycle ( ) { chunk = null ; handle = - <int> ; RECYCLER . recycle ( this , recyclerHandle ) ; } } @SuppressWarnings ( <str> ) private static Entry newEntry ( PoolChunk < ? > chunk , long handle ) { Entry entry = RECYCLER . get ( ) ; entry . chunk = chunk ; entry . handle = handle ; return entry ; } @SuppressWarnings ( <str> ) private static final Recycler < Entry > RECYCLER = new Recycler < Entry > ( ) { @Override protected Entry newObject ( Handle handle ) { return new Entry ( handle ) ; } } ; } } 
