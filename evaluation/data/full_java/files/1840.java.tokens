package clojure . lang ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . IOException ; public class Compile { private static final String PATH_PROP = <str> ; private static final String REFLECTION_WARNING_PROP = <str> ; private static final String UNCHECKED_MATH_PROP = <str> ; private static final Var compile_path = RT . var ( <str> , <str> ) ; private static final Var compile = RT . var ( <str> , <str> ) ; private static final Var warn_on_reflection = RT . var ( <str> , <str> ) ; private static final Var unchecked_math = RT . var ( <str> , <str> ) ; public static void main ( String [ ] args ) throws IOException { OutputStreamWriter out = ( OutputStreamWriter ) RT . OUT . deref ( ) ; PrintWriter err = RT . errPrintWriter ( ) ; String path = System . getProperty ( PATH_PROP ) ; int count = args . length ; if ( path = = null ) { err . println ( <str> + PATH_PROP + <str> + <str> ) ; System . exit ( <int> ) ; } boolean warnOnReflection = System . getProperty ( REFLECTION_WARNING_PROP , <str> ) . equals ( <str> ) ; String uncheckedMathProp = System . getProperty ( UNCHECKED_MATH_PROP ) ; Object uncheckedMath = Boolean . FALSE ; if ( <str> . equals ( uncheckedMathProp ) ) uncheckedMath = Boolean . TRUE ; else if ( <str> . equals ( uncheckedMathProp ) ) uncheckedMath = Keyword . intern ( <str> ) ; try { Var . pushThreadBindings ( RT . map ( compile_path , path , warn_on_reflection , warnOnReflection , unchecked_math , uncheckedMath ) ) ; for ( String lib : args ) { out . write ( <str> + lib + <str> + path + <str> ) ; out . flush ( ) ; compile . invoke ( Symbol . intern ( lib ) ) ; } } finally { Var . popThreadBindings ( ) ; try { out . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( err ) ; } } } } 
