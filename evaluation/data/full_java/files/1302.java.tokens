package org . apache . cassandra . concurrent ; import java . util . Map ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import org . cliffc . high_scale_lib . NonBlockingHashMap ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . utils . concurrent . OpOrder ; import static org . junit . Assert . assertTrue ; public class LongOpOrderTest { private static final Logger logger = LoggerFactory . getLogger ( LongOpOrderTest . class ) ; static final int CONSUMERS = <int> ; static final int PRODUCERS = <int> ; static final long RUNTIME = TimeUnit . MINUTES . toMillis ( <int> ) ; static final long REPORT_INTERVAL = TimeUnit . MINUTES . toMillis ( <int> ) ; static final Thread . UncaughtExceptionHandler handler = new Thread . UncaughtExceptionHandler ( ) { @Override public void uncaughtException ( Thread t , Throwable e ) { System . err . println ( t . getName ( ) + <str> + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } } ; final OpOrder order = new OpOrder ( ) ; final AtomicInteger errors = new AtomicInteger ( ) ; class TestOrdering implements Runnable { final int [ ] waitNanos = new int [ <int> < < <int> ] ; volatile State state = new State ( ) ; final ScheduledExecutorService sched ; TestOrdering ( ExecutorService exec , ScheduledExecutorService sched ) { this . sched = sched ; final ThreadLocalRandom rnd = ThreadLocalRandom . current ( ) ; for ( int i = <int> ; i < waitNanos . length ; i + + ) waitNanos [ i ] = rnd . nextInt ( <int> ) ; for ( int i = <int> ; i < PRODUCERS / CONSUMERS ; i + + ) exec . execute ( new Producer ( ) ) ; exec . execute ( this ) ; } @Override public void run ( ) { final long until = System . currentTimeMillis ( ) + RUNTIME ; long lastReport = System . currentTimeMillis ( ) ; long count = <int> ; long opCount = <int> ; while ( true ) { long now = System . currentTimeMillis ( ) ; if ( now > until ) break ; if ( now > lastReport + REPORT_INTERVAL ) { lastReport = now ; logger . info ( String . format ( <str> , Thread . currentThread ( ) . getName ( ) , count , opCount , <int> * ( <int> - ( ( until - now ) / ( double ) RUNTIME ) ) ) ) ; } try { Thread . sleep ( <int> , waitNanos [ ( ( int ) ( count & ( waitNanos . length - <int> ) ) ) ] ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } final State s = state ; s . barrier = order . newBarrier ( ) ; s . replacement = new State ( ) ; s . barrier . issue ( ) ; s . barrier . await ( ) ; s . check ( ) ; opCount + = s . totalCount ( ) ; state = s . replacement ; sched . schedule ( new Runnable ( ) { @Override public void run ( ) { s . check ( ) ; } } , <int> , TimeUnit . SECONDS ) ; count + + ; } } class State { volatile OpOrder . Barrier barrier ; volatile State replacement ; final NonBlockingHashMap < OpOrder . Group , AtomicInteger > count = new NonBlockingHashMap < > ( ) ; int checkCount = - <int> ; boolean accept ( OpOrder . Group opGroup ) { if ( barrier ! = null & & ! barrier . isAfter ( opGroup ) ) return false ; AtomicInteger c ; if ( null = = ( c = count . get ( opGroup ) ) ) { count . putIfAbsent ( opGroup , new AtomicInteger ( ) ) ; c = count . get ( opGroup ) ; } c . incrementAndGet ( ) ; return true ; } int totalCount ( ) { int c = <int> ; for ( AtomicInteger v : count . values ( ) ) c + = v . intValue ( ) ; return c ; } void check ( ) { boolean delete ; if ( checkCount > = <int> ) { if ( checkCount ! = totalCount ( ) ) { errors . incrementAndGet ( ) ; logger . error ( <str> , checkCount , totalCount ( ) ) ; } delete = true ; } else { checkCount = totalCount ( ) ; delete = false ; } for ( Map . Entry < OpOrder . Group , AtomicInteger > e : count . entrySet ( ) ) { if ( e . getKey ( ) . compareTo ( barrier . getSyncPoint ( ) ) > <int> ) { errors . incrementAndGet ( ) ; logger . error ( <str> ) ; } if ( TestOrdering . this . count . get ( e . getKey ( ) ) . intValue ( ) ! = e . getValue ( ) . intValue ( ) ) { errors . incrementAndGet ( ) ; logger . error ( <str> , TestOrdering . this . count . get ( e . getKey ( ) ) . intValue ( ) , e . getValue ( ) . intValue ( ) ) ; } if ( delete ) TestOrdering . this . count . remove ( e . getKey ( ) ) ; } } } final NonBlockingHashMap < OpOrder . Group , AtomicInteger > count = new NonBlockingHashMap < > ( ) ; class Producer implements Runnable { public void run ( ) { while ( true ) { AtomicInteger c ; try ( OpOrder . Group opGroup = order . start ( ) ) { if ( null = = ( c = count . get ( opGroup ) ) ) { count . putIfAbsent ( opGroup , new AtomicInteger ( ) ) ; c = count . get ( opGroup ) ; } c . incrementAndGet ( ) ; State s = state ; while ( ! s . accept ( opGroup ) ) s = s . replacement ; } } } } } @Test public void testOrdering ( ) throws InterruptedException { errors . set ( <int> ) ; Thread . setDefaultUncaughtExceptionHandler ( handler ) ; final ExecutorService exec = Executors . newCachedThreadPool ( new NamedThreadFactory ( <str> ) ) ; final ScheduledExecutorService checker = Executors . newScheduledThreadPool ( <int> , new NamedThreadFactory ( <str> ) ) ; for ( int i = <int> ; i < CONSUMERS ; i + + ) new TestOrdering ( exec , checker ) ; exec . shutdown ( ) ; exec . awaitTermination ( ( long ) ( RUNTIME * <float> ) , TimeUnit . MILLISECONDS ) ; assertTrue ( exec . isShutdown ( ) ) ; assertTrue ( errors . get ( ) = = <int> ) ; } } 
