package org . gradle . foundation . common ; import java . util . * ; public class ListReorderer { public static < T > boolean moveBefore ( List < T > sourceList , T object ) { int previousIndex = sourceList . indexOf ( object ) ; if ( previousIndex < <int> ) { return false ; } sourceList . remove ( object ) ; sourceList . add ( previousIndex - <int> , object ) ; return true ; } public static < T > void moveBefore ( List < T > sourceList , List < T > objectsToMove ) { sortMoveListByRelativeOrder ( sourceList , objectsToMove ) ; List < T > triedToMove = new ArrayList < T > ( ) ; Iterator < T > iterator = objectsToMove . iterator ( ) ; while ( iterator . hasNext ( ) ) { T objectToMove = iterator . next ( ) ; int currentPosition = sourceList . indexOf ( objectToMove ) ; if ( currentPosition > <int> ) { T occupyingObject = sourceList . get ( currentPosition - <int> ) ; if ( currentPosition < sourceList . size ( ) & & ! triedToMove . contains ( occupyingObject ) ) { moveBefore ( sourceList , objectToMove ) ; } } triedToMove . add ( objectToMove ) ; } } public static < T > void moveTo ( List < T > sourceList , List < T > moveList , int index ) { if ( index < <int> | | index > = sourceList . size ( ) ) { return ; } T moveBeforeObject = sourceList . get ( index ) ; if ( moveList . contains ( moveBeforeObject ) ) { List < T > newMoveList = new ArrayList < T > ( moveList ) ; newMoveList . remove ( moveBeforeObject ) ; moveTo ( sourceList , newMoveList , index + <int> ) ; return ; } sourceList . removeAll ( moveList ) ; index = sourceList . indexOf ( moveBeforeObject ) ; if ( index < <int> ) { index = <int> ; } if ( index > sourceList . size ( ) - <int> ) { index = sourceList . size ( ) - <int> ; } sourceList . addAll ( index , moveList ) ; } public static < T > boolean moveToFront ( List < T > sourceList , T object ) { boolean moved = false ; if ( sourceList . remove ( object ) ) { sourceList . add ( <int> , object ) ; moved = true ; } return moved ; } public static < T > void moveToFront ( List < T > sourceList , List < T > objectsToMove ) { sortMoveListByRelativeOrder ( sourceList , objectsToMove ) ; for ( int i = objectsToMove . size ( ) - <int> ; i > = <int> ; i - - ) { T object = objectsToMove . get ( i ) ; if ( sourceList . remove ( object ) ) { sourceList . add ( <int> , object ) ; } } } public static < T > boolean moveAfter ( List < T > sourceList , T object ) { int previousIndex = sourceList . indexOf ( object ) ; if ( previousIndex > = sourceList . size ( ) - <int> | | previousIndex = = - <int> ) { return false ; } sourceList . remove ( object ) ; sourceList . add ( previousIndex + <int> , object ) ; return true ; } public static < T > void moveAfter ( List < T > sourceList , List < T > objectsToMove ) { sortMoveListByRelativeOrder ( sourceList , objectsToMove ) ; List < T > triedToMove = new ArrayList < T > ( ) ; for ( int i = objectsToMove . size ( ) - <int> ; i > = <int> ; i - - ) { T objectToMove = objectsToMove . get ( i ) ; int currentPosition = sourceList . indexOf ( objectToMove ) ; if ( currentPosition < sourceList . size ( ) - <int> ) { T occupyingObject = sourceList . get ( currentPosition + <int> ) ; if ( ! triedToMove . contains ( occupyingObject ) ) { moveAfter ( sourceList , objectToMove ) ; } } triedToMove . add ( objectToMove ) ; } } public static < T > boolean moveToBack ( List < T > sourceList , T object ) { boolean moved = false ; if ( sourceList . remove ( object ) ) { moved = sourceList . add ( object ) ; } return moved ; } public static < T > void moveToBack ( List < T > sourceList , List < T > objectsToMove ) { sortMoveListByRelativeOrder ( sourceList , objectsToMove ) ; for ( int i = <int> ; i < objectsToMove . size ( ) ; i + + ) { T object = objectsToMove . get ( i ) ; if ( sourceList . remove ( object ) ) { sourceList . add ( object ) ; } } } public static < T > void sortMoveListByRelativeOrder ( final List < T > parentList , List < T > childList ) { Collections . sort ( childList , new Comparator < T > ( ) { public int compare ( T o , T o1 ) { int index = parentList . indexOf ( o ) ; int index1 = parentList . indexOf ( o1 ) ; return ( index < index1 ) ? - <int> : ( index > index1 ) ? <int> : <int> ; } } ) ; } public static < T > boolean allElementsInFront ( List < T > sourceList , List < T > checkList ) { if ( ! sourceList . containsAll ( checkList ) ) { return false ; } int sourceIndex = checkList . size ( ) ; for ( int index = <int> ; index < checkList . size ( ) ; index + + ) { T element = checkList . get ( index ) ; int checkIndex = sourceList . indexOf ( element ) ; if ( checkIndex > = sourceIndex ) { return false ; } } return true ; } public static < T > boolean allElementsInBack ( List < T > sourceList , List < T > checkList ) { if ( ! sourceList . containsAll ( checkList ) ) { return false ; } int sourceIndex = sourceList . size ( ) - checkList . size ( ) ; for ( int index = checkList . size ( ) - <int> ; index > = <int> ; index - - ) { T element = checkList . get ( index ) ; int checkIndex = sourceList . indexOf ( element ) ; if ( checkIndex < sourceIndex ) { return false ; } } return true ; } public static < T > int [ ] getIndices ( List < T > sourceList , List < T > objectsToMove ) { int [ ] newIndices = new int [ objectsToMove . size ( ) ] ; for ( int index = <int> ; index < objectsToMove . size ( ) ; index + + ) { T elementToMove = objectsToMove . get ( index ) ; int sourceIndexOfElement = sourceList . indexOf ( elementToMove ) ; newIndices [ index ] = sourceIndexOfElement ; } return newIndices ; } } 
