package io . netty . handler . codec ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandler ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelPipeline ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . ReferenceCounted ; import io . netty . util . internal . RecyclableArrayList ; import io . netty . util . internal . TypeParameterMatcher ; import java . util . List ; public abstract class MessageToMessageDecoder < I > extends ChannelInboundHandlerAdapter { private final TypeParameterMatcher matcher ; protected MessageToMessageDecoder ( ) { matcher = TypeParameterMatcher . find ( this , MessageToMessageDecoder . class , <str> ) ; } protected MessageToMessageDecoder ( Class < ? extends I > inboundMessageType ) { matcher = TypeParameterMatcher . get ( inboundMessageType ) ; } public boolean acceptInboundMessage ( Object msg ) throws Exception { return matcher . match ( msg ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { RecyclableArrayList out = RecyclableArrayList . newInstance ( ) ; try { if ( acceptInboundMessage ( msg ) ) { @SuppressWarnings ( <str> ) I cast = ( I ) msg ; try { decode ( ctx , cast , out ) ; } finally { ReferenceCountUtil . release ( cast ) ; } } else { out . add ( msg ) ; } } catch ( DecoderException e ) { throw e ; } catch ( Exception e ) { throw new DecoderException ( e ) ; } finally { int size = out . size ( ) ; for ( int i = <int> ; i < size ; i + + ) { ctx . fireChannelRead ( out . get ( i ) ) ; } out . recycle ( ) ; } } protected abstract void decode ( ChannelHandlerContext ctx , I msg , List < Object > out ) throws Exception ; } 
