package org . elasticsearch . search . aggregations . pipeline . derivative ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . AggregationStreams ; import org . elasticsearch . search . aggregations . pipeline . InternalSimpleValue ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class InternalDerivative extends InternalSimpleValue implements Derivative { public final static Type TYPE = new Type ( <str> ) ; public final static AggregationStreams . Stream STREAM = new AggregationStreams . Stream ( ) { @Override public InternalDerivative readResult ( StreamInput in ) throws IOException { InternalDerivative result = new InternalDerivative ( ) ; result . readFrom ( in ) ; return result ; } } ; public static void registerStreams ( ) { AggregationStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; } private double normalizationFactor ; InternalDerivative ( ) { } public InternalDerivative ( String name , double value , double normalizationFactor , ValueFormatter formatter , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) { super ( name , value , formatter , pipelineAggregators , metaData ) ; this . normalizationFactor = normalizationFactor ; } @Override public double normalizedValue ( ) { return normalizationFactor > <int> ? ( value ( ) / normalizationFactor ) : value ( ) ; } @Override public Type type ( ) { return TYPE ; } @Override public Object getProperty ( List < String > path ) { if ( path . isEmpty ( ) ) { return this ; } else if ( path . size ( ) = = <int> & & <str> . equals ( path . get ( <int> ) ) ) { return value ( ) ; } else if ( path . size ( ) = = <int> & & <str> . equals ( path . get ( <int> ) ) ) { return normalizedValue ( ) ; } else { throw new IllegalArgumentException ( <str> + getName ( ) + <str> + path ) ; } } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { super . doWriteTo ( out ) ; out . writeDouble ( normalizationFactor ) ; } @Override protected void doReadFrom ( StreamInput in ) throws IOException { super . doReadFrom ( in ) ; normalizationFactor = in . readDouble ( ) ; } @Override public XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { super . doXContentBody ( builder , params ) ; if ( normalizationFactor > <int> ) { boolean hasValue = ! ( Double . isInfinite ( normalizedValue ( ) ) | | Double . isNaN ( normalizedValue ( ) ) ) ; builder . field ( <str> , hasValue ? normalizedValue ( ) : null ) ; if ( hasValue & & ! ( valueFormatter instanceof ValueFormatter . Raw ) ) { builder . field ( <str> , valueFormatter . format ( normalizedValue ( ) ) ) ; } } return builder ; } } 
