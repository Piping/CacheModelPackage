package org . apache . cassandra . db . rows ; import java . io . IOException ; import com . google . common . collect . Collections2 ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; public class UnfilteredSerializer { public static final UnfilteredSerializer serializer = new UnfilteredSerializer ( ) ; private final static int END_OF_PARTITION = <hex> ; private final static int IS_MARKER = <hex> ; private final static int HAS_TIMESTAMP = <hex> ; private final static int HAS_TTL = <hex> ; private final static int HAS_DELETION = <hex> ; private final static int HAS_ALL_COLUMNS = <hex> ; private final static int HAS_COMPLEX_DELETION = <hex> ; private final static int EXTENSION_FLAG = <hex> ; private final static int IS_STATIC = <hex> ; private final static int HAS_SHADOWABLE_DELETION = <hex> ; public void serialize ( Unfiltered unfiltered , SerializationHeader header , DataOutputPlus out , int version ) throws IOException { assert ! header . isForSSTable ( ) ; serialize ( unfiltered , header , out , <int> , version ) ; } public void serialize ( Unfiltered unfiltered , SerializationHeader header , DataOutputPlus out , long previousUnfilteredSize , int version ) throws IOException { if ( unfiltered . kind ( ) = = Unfiltered . Kind . RANGE_TOMBSTONE_MARKER ) { serialize ( ( RangeTombstoneMarker ) unfiltered , header , out , previousUnfilteredSize , version ) ; } else { serialize ( ( Row ) unfiltered , header , out , previousUnfilteredSize , version ) ; } } public void serializeStaticRow ( Row row , SerializationHeader header , DataOutputPlus out , int version ) throws IOException { assert row . isStatic ( ) ; serialize ( row , header , out , <int> , version ) ; } private void serialize ( Row row , SerializationHeader header , DataOutputPlus out , long previousUnfilteredSize , int version ) throws IOException { int flags = <int> ; int extendedFlags = <int> ; boolean isStatic = row . isStatic ( ) ; Columns headerColumns = header . columns ( isStatic ) ; LivenessInfo pkLiveness = row . primaryKeyLivenessInfo ( ) ; Row . Deletion deletion = row . deletion ( ) ; boolean hasComplexDeletion = row . hasComplexDeletion ( ) ; boolean hasAllColumns = ( row . size ( ) = = headerColumns . size ( ) ) ; boolean hasExtendedFlags = hasExtendedFlags ( row ) ; if ( isStatic ) extendedFlags | = IS_STATIC ; if ( ! pkLiveness . isEmpty ( ) ) flags | = HAS_TIMESTAMP ; if ( pkLiveness . isExpiring ( ) ) flags | = HAS_TTL ; if ( ! deletion . isLive ( ) ) { flags | = HAS_DELETION ; if ( deletion . isShadowable ( ) ) extendedFlags | = HAS_SHADOWABLE_DELETION ; } if ( hasComplexDeletion ) flags | = HAS_COMPLEX_DELETION ; if ( hasAllColumns ) flags | = HAS_ALL_COLUMNS ; if ( hasExtendedFlags ) flags | = EXTENSION_FLAG ; out . writeByte ( ( byte ) flags ) ; if ( hasExtendedFlags ) out . writeByte ( ( byte ) extendedFlags ) ; if ( ! isStatic ) Clustering . serializer . serialize ( row . clustering ( ) , out , version , header . clusteringTypes ( ) ) ; if ( header . isForSSTable ( ) ) { out . writeUnsignedVInt ( serializedRowBodySize ( row , header , previousUnfilteredSize , version ) ) ; out . writeUnsignedVInt ( previousUnfilteredSize ) ; } if ( ( flags & HAS_TIMESTAMP ) ! = <int> ) header . writeTimestamp ( pkLiveness . timestamp ( ) , out ) ; if ( ( flags & HAS_TTL ) ! = <int> ) { header . writeTTL ( pkLiveness . ttl ( ) , out ) ; header . writeLocalDeletionTime ( pkLiveness . localExpirationTime ( ) , out ) ; } if ( ( flags & HAS_DELETION ) ! = <int> ) header . writeDeletionTime ( deletion . time ( ) , out ) ; if ( ! hasAllColumns ) Columns . serializer . serializeSubset ( Collections2 . transform ( row , ColumnData : : column ) , headerColumns , out ) ; for ( ColumnData data : row ) { if ( data . column . isSimple ( ) ) Cell . serializer . serialize ( ( Cell ) data , out , pkLiveness , header ) ; else writeComplexColumn ( ( ComplexColumnData ) data , hasComplexDeletion , pkLiveness , header , out ) ; } } private void writeComplexColumn ( ComplexColumnData data , boolean hasComplexDeletion , LivenessInfo rowLiveness , SerializationHeader header , DataOutputPlus out ) throws IOException { if ( hasComplexDeletion ) header . writeDeletionTime ( data . complexDeletion ( ) , out ) ; out . writeUnsignedVInt ( data . cellsCount ( ) ) ; for ( Cell cell : data ) Cell . serializer . serialize ( cell , out , rowLiveness , header ) ; } private void serialize ( RangeTombstoneMarker marker , SerializationHeader header , DataOutputPlus out , long previousUnfilteredSize , int version ) throws IOException { out . writeByte ( ( byte ) IS_MARKER ) ; RangeTombstone . Bound . serializer . serialize ( marker . clustering ( ) , out , version , header . clusteringTypes ( ) ) ; if ( header . isForSSTable ( ) ) { out . writeUnsignedVInt ( serializedMarkerBodySize ( marker , header , previousUnfilteredSize , version ) ) ; out . writeUnsignedVInt ( previousUnfilteredSize ) ; } if ( marker . isBoundary ( ) ) { RangeTombstoneBoundaryMarker bm = ( RangeTombstoneBoundaryMarker ) marker ; header . writeDeletionTime ( bm . endDeletionTime ( ) , out ) ; header . writeDeletionTime ( bm . startDeletionTime ( ) , out ) ; } else { header . writeDeletionTime ( ( ( RangeTombstoneBoundMarker ) marker ) . deletionTime ( ) , out ) ; } } public long serializedSize ( Unfiltered unfiltered , SerializationHeader header , int version ) { assert ! header . isForSSTable ( ) ; return serializedSize ( unfiltered , header , <int> , version ) ; } public long serializedSize ( Unfiltered unfiltered , SerializationHeader header , long previousUnfilteredSize , int version ) { return unfiltered . kind ( ) = = Unfiltered . Kind . RANGE_TOMBSTONE_MARKER ? serializedSize ( ( RangeTombstoneMarker ) unfiltered , header , previousUnfilteredSize , version ) : serializedSize ( ( Row ) unfiltered , header , previousUnfilteredSize , version ) ; } private long serializedSize ( Row row , SerializationHeader header , long previousUnfilteredSize , int version ) { long size = <int> ; if ( hasExtendedFlags ( row ) ) size + = <int> ; if ( ! row . isStatic ( ) ) size + = Clustering . serializer . serializedSize ( row . clustering ( ) , version , header . clusteringTypes ( ) ) ; return size + serializedRowBodySize ( row , header , previousUnfilteredSize , version ) ; } private long serializedRowBodySize ( Row row , SerializationHeader header , long previousUnfilteredSize , int version ) { long size = <int> ; if ( header . isForSSTable ( ) ) size + = TypeSizes . sizeofUnsignedVInt ( previousUnfilteredSize ) ; boolean isStatic = row . isStatic ( ) ; Columns headerColumns = header . columns ( isStatic ) ; LivenessInfo pkLiveness = row . primaryKeyLivenessInfo ( ) ; Row . Deletion deletion = row . deletion ( ) ; boolean hasComplexDeletion = row . hasComplexDeletion ( ) ; boolean hasAllColumns = ( row . size ( ) = = headerColumns . size ( ) ) ; if ( ! pkLiveness . isEmpty ( ) ) size + = header . timestampSerializedSize ( pkLiveness . timestamp ( ) ) ; if ( pkLiveness . isExpiring ( ) ) { size + = header . ttlSerializedSize ( pkLiveness . ttl ( ) ) ; size + = header . localDeletionTimeSerializedSize ( pkLiveness . localExpirationTime ( ) ) ; } if ( ! deletion . isLive ( ) ) size + = header . deletionTimeSerializedSize ( deletion . time ( ) ) ; if ( ! hasAllColumns ) size + = Columns . serializer . serializedSubsetSize ( Collections2 . transform ( row , ColumnData : : column ) , header . columns ( isStatic ) ) ; for ( ColumnData data : row ) { if ( data . column . isSimple ( ) ) size + = Cell . serializer . serializedSize ( ( Cell ) data , pkLiveness , header ) ; else size + = sizeOfComplexColumn ( ( ComplexColumnData ) data , hasComplexDeletion , pkLiveness , header ) ; } return size ; } private long sizeOfComplexColumn ( ComplexColumnData data , boolean hasComplexDeletion , LivenessInfo rowLiveness , SerializationHeader header ) { long size = <int> ; if ( hasComplexDeletion ) size + = header . deletionTimeSerializedSize ( data . complexDeletion ( ) ) ; size + = TypeSizes . sizeofUnsignedVInt ( data . cellsCount ( ) ) ; for ( Cell cell : data ) size + = Cell . serializer . serializedSize ( cell , rowLiveness , header ) ; return size ; } private long serializedSize ( RangeTombstoneMarker marker , SerializationHeader header , long previousUnfilteredSize , int version ) { assert ! header . isForSSTable ( ) ; return <int> + RangeTombstone . Bound . serializer . serializedSize ( marker . clustering ( ) , version , header . clusteringTypes ( ) ) + serializedMarkerBodySize ( marker , header , previousUnfilteredSize , version ) ; } private long serializedMarkerBodySize ( RangeTombstoneMarker marker , SerializationHeader header , long previousUnfilteredSize , int version ) { long size = <int> ; if ( header . isForSSTable ( ) ) size + = TypeSizes . sizeofUnsignedVInt ( previousUnfilteredSize ) ; if ( marker . isBoundary ( ) ) { RangeTombstoneBoundaryMarker bm = ( RangeTombstoneBoundaryMarker ) marker ; size + = header . deletionTimeSerializedSize ( bm . endDeletionTime ( ) ) ; size + = header . deletionTimeSerializedSize ( bm . startDeletionTime ( ) ) ; } else { size + = header . deletionTimeSerializedSize ( ( ( RangeTombstoneBoundMarker ) marker ) . deletionTime ( ) ) ; } return size ; } public void writeEndOfPartition ( DataOutputPlus out ) throws IOException { out . writeByte ( ( byte ) <int> ) ; } public long serializedSizeEndOfPartition ( ) { return <int> ; } public Unfiltered deserialize ( DataInputPlus in , SerializationHeader header , SerializationHelper helper , Row . Builder builder ) throws IOException { assert builder . isSorted ( ) ; int flags = in . readUnsignedByte ( ) ; if ( isEndOfPartition ( flags ) ) return null ; int extendedFlags = readExtendedFlags ( in , flags ) ; if ( kind ( flags ) = = Unfiltered . Kind . RANGE_TOMBSTONE_MARKER ) { RangeTombstone . Bound bound = RangeTombstone . Bound . serializer . deserialize ( in , helper . version , header . clusteringTypes ( ) ) ; return deserializeMarkerBody ( in , header , bound ) ; } else { assert ! isStatic ( extendedFlags ) ; builder . newRow ( Clustering . serializer . deserialize ( in , helper . version , header . clusteringTypes ( ) ) ) ; return deserializeRowBody ( in , header , helper , flags , extendedFlags , builder ) ; } } public Row deserializeStaticRow ( DataInputPlus in , SerializationHeader header , SerializationHelper helper ) throws IOException { int flags = in . readUnsignedByte ( ) ; assert ! isEndOfPartition ( flags ) & & kind ( flags ) = = Unfiltered . Kind . ROW & & isExtended ( flags ) : flags ; int extendedFlags = in . readUnsignedByte ( ) ; Row . Builder builder = BTreeRow . sortedBuilder ( ) ; builder . newRow ( Clustering . STATIC_CLUSTERING ) ; return deserializeRowBody ( in , header , helper , flags , extendedFlags , builder ) ; } public RangeTombstoneMarker deserializeMarkerBody ( DataInputPlus in , SerializationHeader header , RangeTombstone . Bound bound ) throws IOException { if ( header . isForSSTable ( ) ) { in . readUnsignedVInt ( ) ; in . readUnsignedVInt ( ) ; } if ( bound . isBoundary ( ) ) return new RangeTombstoneBoundaryMarker ( bound , header . readDeletionTime ( in ) , header . readDeletionTime ( in ) ) ; else return new RangeTombstoneBoundMarker ( bound , header . readDeletionTime ( in ) ) ; } public Row deserializeRowBody ( DataInputPlus in , SerializationHeader header , SerializationHelper helper , int flags , int extendedFlags , Row . Builder builder ) throws IOException { try { boolean isStatic = isStatic ( extendedFlags ) ; boolean hasTimestamp = ( flags & HAS_TIMESTAMP ) ! = <int> ; boolean hasTTL = ( flags & HAS_TTL ) ! = <int> ; boolean hasDeletion = ( flags & HAS_DELETION ) ! = <int> ; boolean deletionIsShadowable = ( extendedFlags & HAS_SHADOWABLE_DELETION ) ! = <int> ; boolean hasComplexDeletion = ( flags & HAS_COMPLEX_DELETION ) ! = <int> ; boolean hasAllColumns = ( flags & HAS_ALL_COLUMNS ) ! = <int> ; Columns headerColumns = header . columns ( isStatic ) ; if ( header . isForSSTable ( ) ) { in . readUnsignedVInt ( ) ; in . readUnsignedVInt ( ) ; } LivenessInfo rowLiveness = LivenessInfo . EMPTY ; if ( hasTimestamp ) { long timestamp = header . readTimestamp ( in ) ; int ttl = hasTTL ? header . readTTL ( in ) : LivenessInfo . NO_TTL ; int localDeletionTime = hasTTL ? header . readLocalDeletionTime ( in ) : LivenessInfo . NO_EXPIRATION_TIME ; rowLiveness = LivenessInfo . create ( timestamp , ttl , localDeletionTime ) ; } builder . addPrimaryKeyLivenessInfo ( rowLiveness ) ; builder . addRowDeletion ( hasDeletion ? new Row . Deletion ( header . readDeletionTime ( in ) , deletionIsShadowable ) : Row . Deletion . LIVE ) ; Columns columns = hasAllColumns ? headerColumns : Columns . serializer . deserializeSubset ( headerColumns , in ) ; for ( ColumnDefinition column : columns ) { if ( column . isSimple ( ) ) readSimpleColumn ( column , in , header , helper , builder , rowLiveness ) ; else readComplexColumn ( column , in , header , helper , hasComplexDeletion , builder , rowLiveness ) ; } return builder . build ( ) ; } catch ( RuntimeException | AssertionError e ) { throw new IOException ( <str> + in , e ) ; } } private void readSimpleColumn ( ColumnDefinition column , DataInputPlus in , SerializationHeader header , SerializationHelper helper , Row . Builder builder , LivenessInfo rowLiveness ) throws IOException { if ( helper . includes ( column ) ) { Cell cell = Cell . serializer . deserialize ( in , rowLiveness , column , header , helper ) ; if ( ! helper . isDropped ( cell , false ) ) builder . addCell ( cell ) ; } else { Cell . serializer . skip ( in , column , header ) ; } } private void readComplexColumn ( ColumnDefinition column , DataInputPlus in , SerializationHeader header , SerializationHelper helper , boolean hasComplexDeletion , Row . Builder builder , LivenessInfo rowLiveness ) throws IOException { if ( helper . includes ( column ) ) { helper . startOfComplexColumn ( column ) ; if ( hasComplexDeletion ) { DeletionTime complexDeletion = header . readDeletionTime ( in ) ; if ( ! helper . isDroppedComplexDeletion ( complexDeletion ) ) builder . addComplexDeletion ( column , complexDeletion ) ; } int count = ( int ) in . readUnsignedVInt ( ) ; while ( - - count > = <int> ) { Cell cell = Cell . serializer . deserialize ( in , rowLiveness , column , header , helper ) ; if ( helper . includes ( cell . path ( ) ) & & ! helper . isDropped ( cell , true ) ) builder . addCell ( cell ) ; } helper . endOfComplexColumn ( ) ; } else { skipComplexColumn ( in , column , header , hasComplexDeletion ) ; } } public void skipRowBody ( DataInputPlus in ) throws IOException { int rowSize = ( int ) in . readUnsignedVInt ( ) ; in . skipBytesFully ( rowSize ) ; } public void skipStaticRow ( DataInputPlus in , SerializationHeader header , SerializationHelper helper ) throws IOException { int flags = in . readUnsignedByte ( ) ; assert ! isEndOfPartition ( flags ) & & kind ( flags ) = = Unfiltered . Kind . ROW & & isExtended ( flags ) : <str> + flags ; int extendedFlags = in . readUnsignedByte ( ) ; assert isStatic ( extendedFlags ) ; skipRowBody ( in ) ; } public void skipMarkerBody ( DataInputPlus in ) throws IOException { int markerSize = ( int ) in . readUnsignedVInt ( ) ; in . skipBytesFully ( markerSize ) ; } private void skipComplexColumn ( DataInputPlus in , ColumnDefinition column , SerializationHeader header , boolean hasComplexDeletion ) throws IOException { if ( hasComplexDeletion ) header . skipDeletionTime ( in ) ; int count = ( int ) in . readUnsignedVInt ( ) ; while ( - - count > = <int> ) Cell . serializer . skip ( in , column , header ) ; } public static boolean isEndOfPartition ( int flags ) { return ( flags & END_OF_PARTITION ) ! = <int> ; } public static Unfiltered . Kind kind ( int flags ) { return ( flags & IS_MARKER ) ! = <int> ? Unfiltered . Kind . RANGE_TOMBSTONE_MARKER : Unfiltered . Kind . ROW ; } public static boolean isStatic ( int extendedFlags ) { return ( extendedFlags & IS_STATIC ) ! = <int> ; } private static boolean isExtended ( int flags ) { return ( flags & EXTENSION_FLAG ) ! = <int> ; } public static int readExtendedFlags ( DataInputPlus in , int flags ) throws IOException { return isExtended ( flags ) ? in . readUnsignedByte ( ) : <int> ; } public static boolean hasExtendedFlags ( Row row ) { return row . isStatic ( ) | | row . deletion ( ) . isShadowable ( ) ; } } 
