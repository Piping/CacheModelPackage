package com . google . common . math ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . caliper . api . SkipThisScenarioException ; import com . google . common . primitives . Doubles ; import java . util . Random ; public class StatsBenchmark { enum MeanAlgorithm { SIMPLE { @Override double mean ( double [ ] values ) { double sum = <float> ; for ( double value : values ) { sum + = value ; } return sum / values . length ; } } , KAHAN { @Override double mean ( double [ ] values ) { double sum = <float> ; double c = <float> ; for ( double value : values ) { double y = value - c ; double t = sum + y ; c = ( t - sum ) - y ; sum = t ; } return sum / values . length ; } } , KNUTH { @Override double mean ( double [ ] values ) { double mean = values [ <int> ] ; for ( int i = <int> ; i < values . length ; i + + ) { mean = mean + ( values [ i ] - mean ) / ( i + <int> ) ; } return mean ; } } ; abstract double mean ( double [ ] values ) ; } static class MeanAndVariance { private final double mean ; private final double variance ; MeanAndVariance ( double mean , double variance ) { this . mean = mean ; this . variance = variance ; } @Override public int hashCode ( ) { return Doubles . hashCode ( mean ) * <int> + Doubles . hashCode ( variance ) ; } } enum VarianceAlgorithm { DO_NOT_COMPUTE { @Override MeanAndVariance variance ( double [ ] values , MeanAlgorithm meanAlgorithm ) { return new MeanAndVariance ( meanAlgorithm . mean ( values ) , <float> ) ; } } , SIMPLE { @Override MeanAndVariance variance ( double [ ] values , MeanAlgorithm meanAlgorithm ) { double mean = meanAlgorithm . mean ( values ) ; double sumOfSquaresOfDeltas = <float> ; for ( double value : values ) { double delta = value - mean ; sumOfSquaresOfDeltas + = delta * delta ; } return new MeanAndVariance ( mean , sumOfSquaresOfDeltas / values . length ) ; } } , KAHAN { @Override MeanAndVariance variance ( double [ ] values , MeanAlgorithm meanAlgorithm ) { double mean = meanAlgorithm . mean ( values ) ; double sumOfSquaresOfDeltas = <float> ; double c = <float> ; for ( double value : values ) { double delta = value - mean ; double deltaSquared = delta * delta ; double y = deltaSquared - c ; double t = sumOfSquaresOfDeltas + deltaSquared ; c = ( t - sumOfSquaresOfDeltas ) - y ; sumOfSquaresOfDeltas = t ; } return new MeanAndVariance ( mean , sumOfSquaresOfDeltas / values . length ) ; } } , KNUTH { @Override MeanAndVariance variance ( double [ ] values , MeanAlgorithm meanAlgorithm ) { if ( meanAlgorithm ! = MeanAlgorithm . KNUTH ) { throw new SkipThisScenarioException ( ) ; } double mean = values [ <int> ] ; double s = <float> ; for ( int i = <int> ; i < values . length ; i + + ) { double nextMean = mean + ( values [ i ] - mean ) / ( i + <int> ) ; s + = ( values [ i ] - mean ) * ( values [ i ] - nextMean ) ; mean = nextMean ; } return new MeanAndVariance ( mean , s / values . length ) ; } } ; abstract MeanAndVariance variance ( double [ ] values , MeanAlgorithm meanAlgorithm ) ; } @Param ( { <str> , <str> } ) int n ; @Param MeanAlgorithm meanAlgorithm ; @Param VarianceAlgorithm varianceAlgorithm ; private double [ ] [ ] values = new double [ <hex> ] [ ] ; @BeforeExperiment void setUp ( ) { Random rng = new Random ( ) ; for ( int i = <int> ; i < <hex> ; i + + ) { values [ i ] = new double [ n ] ; for ( int j = <int> ; j < n ; j + + ) { values [ i ] [ j ] = rng . nextDouble ( ) ; } } } @Benchmark int meanAndVariance ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { tmp + = varianceAlgorithm . variance ( values [ i & <hex> ] , meanAlgorithm ) . hashCode ( ) ; } return tmp ; } } 
