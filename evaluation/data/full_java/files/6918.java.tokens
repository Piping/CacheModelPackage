package org . elasticsearch . percolator ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . index . IndexableField ; import org . apache . lucene . index . memory . MemoryIndex ; import org . apache . lucene . util . CloseableThreadLocal ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . mapper . ParsedDocument ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import java . io . IOException ; class SingleDocumentPercolatorIndex implements PercolatorIndex { private final CloseableThreadLocal < MemoryIndex > cache ; SingleDocumentPercolatorIndex ( CloseableThreadLocal < MemoryIndex > cache ) { this . cache = cache ; } @Override public void prepare ( PercolateContext context , ParsedDocument parsedDocument ) { MemoryIndex memoryIndex = cache . get ( ) ; for ( IndexableField field : parsedDocument . rootDoc ( ) . getFields ( ) ) { if ( field . fieldType ( ) . indexOptions ( ) = = IndexOptions . NONE & & field . name ( ) . equals ( UidFieldMapper . NAME ) ) { continue ; } try { Analyzer analyzer = context . mapperService ( ) . documentMapper ( parsedDocument . type ( ) ) . mappers ( ) . indexAnalyzer ( ) ; try ( TokenStream tokenStream = field . tokenStream ( analyzer , null ) ) { if ( tokenStream ! = null ) { memoryIndex . addField ( field . name ( ) , tokenStream , field . boost ( ) ) ; } } } catch ( Exception e ) { throw new ElasticsearchException ( <str> + field . name ( ) + <str> , e ) ; } } context . initialize ( new DocEngineSearcher ( memoryIndex ) , parsedDocument ) ; } private class DocEngineSearcher extends Engine . Searcher { private final MemoryIndex memoryIndex ; public DocEngineSearcher ( MemoryIndex memoryIndex ) { super ( <str> , memoryIndex . createSearcher ( ) ) ; this . memoryIndex = memoryIndex ; } @Override public void close ( ) { try { this . reader ( ) . close ( ) ; memoryIndex . reset ( ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> , e ) ; } } } } 
