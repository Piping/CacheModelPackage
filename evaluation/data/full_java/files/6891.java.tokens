package org . elasticsearch . monitor . jvm ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . common . unit . TimeValue ; import java . lang . management . ManagementFactory ; import java . lang . management . ThreadInfo ; import java . lang . management . ThreadMXBean ; import java . util . * ; import java . util . concurrent . TimeUnit ; public class HotThreads { private static final Object mutex = new Object ( ) ; private static final FormatDateTimeFormatter DATE_TIME_FORMATTER = Joda . forPattern ( <str> ) ; private int busiestThreads = <int> ; private TimeValue interval = new TimeValue ( <int> , TimeUnit . MILLISECONDS ) ; private TimeValue threadElementsSnapshotDelay = new TimeValue ( <int> ) ; private int threadElementsSnapshotCount = <int> ; private String type = <str> ; private boolean ignoreIdleThreads = true ; public HotThreads interval ( TimeValue interval ) { this . interval = interval ; return this ; } public HotThreads busiestThreads ( int busiestThreads ) { this . busiestThreads = busiestThreads ; return this ; } public HotThreads ignoreIdleThreads ( boolean ignoreIdleThreads ) { this . ignoreIdleThreads = ignoreIdleThreads ; return this ; } public HotThreads threadElementsSnapshotDelay ( TimeValue threadElementsSnapshotDelay ) { this . threadElementsSnapshotDelay = threadElementsSnapshotDelay ; return this ; } public HotThreads threadElementsSnapshotCount ( int threadElementsSnapshotCount ) { this . threadElementsSnapshotCount = threadElementsSnapshotCount ; return this ; } public HotThreads type ( String type ) { if ( <str> . equals ( type ) | | <str> . equals ( type ) | | <str> . equals ( type ) ) { this . type = type ; } else { throw new IllegalArgumentException ( <str> + type + <str> ) ; } return this ; } public String detect ( ) throws Exception { synchronized ( mutex ) { return innerDetect ( ) ; } } private static boolean isIdleThread ( ThreadInfo threadInfo ) { String threadName = threadInfo . getThreadName ( ) ; if ( threadName . equals ( <str> ) | | threadName . equals ( <str> ) | | threadName . equals ( <str> ) ) { return true ; } for ( StackTraceElement frame : threadInfo . getStackTrace ( ) ) { String className = frame . getClassName ( ) ; String methodName = frame . getMethodName ( ) ; if ( className . equals ( <str> ) & & methodName . equals ( <str> ) ) { return true ; } if ( className . equals ( <str> ) & & methodName . equals ( <str> ) ) { return true ; } if ( className . equals ( <str> ) & & methodName . equals ( <str> ) ) { return true ; } if ( className . equals ( <str> ) & & methodName . equals ( <str> ) ) { return true ; } if ( className . equals ( <str> ) & & methodName . equals ( <str> ) ) { return true ; } } return false ; } private String innerDetect ( ) throws Exception { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; sb . append ( DATE_TIME_FORMATTER . printer ( ) . print ( System . currentTimeMillis ( ) ) ) ; sb . append ( <str> ) ; sb . append ( interval ) ; sb . append ( <str> ) ; sb . append ( busiestThreads ) ; sb . append ( <str> ) ; sb . append ( ignoreIdleThreads ) ; sb . append ( <str> ) ; ThreadMXBean threadBean = ManagementFactory . getThreadMXBean ( ) ; boolean enabledCpu = false ; try { if ( threadBean . isThreadCpuTimeSupported ( ) ) { if ( ! threadBean . isThreadCpuTimeEnabled ( ) ) { enabledCpu = true ; threadBean . setThreadCpuTimeEnabled ( true ) ; } } else { throw new IllegalStateException ( <str> ) ; } Map < Long , MyThreadInfo > threadInfos = new HashMap < > ( ) ; for ( long threadId : threadBean . getAllThreadIds ( ) ) { if ( Thread . currentThread ( ) . getId ( ) = = threadId ) { continue ; } long cpu = threadBean . getThreadCpuTime ( threadId ) ; if ( cpu = = - <int> ) { continue ; } ThreadInfo info = threadBean . getThreadInfo ( threadId , <int> ) ; if ( info = = null ) { continue ; } threadInfos . put ( threadId , new MyThreadInfo ( cpu , info ) ) ; } Thread . sleep ( interval . millis ( ) ) ; for ( long threadId : threadBean . getAllThreadIds ( ) ) { if ( Thread . currentThread ( ) . getId ( ) = = threadId ) { continue ; } long cpu = threadBean . getThreadCpuTime ( threadId ) ; if ( cpu = = - <int> ) { threadInfos . remove ( threadId ) ; continue ; } ThreadInfo info = threadBean . getThreadInfo ( threadId , <int> ) ; if ( info = = null ) { threadInfos . remove ( threadId ) ; continue ; } MyThreadInfo data = threadInfos . get ( threadId ) ; if ( data ! = null ) { data . setDelta ( cpu , info ) ; } else { threadInfos . remove ( threadId ) ; } } List < MyThreadInfo > hotties = new ArrayList < > ( threadInfos . values ( ) ) ; final int busiestThreads = Math . min ( this . busiestThreads , hotties . size ( ) ) ; CollectionUtil . introSort ( hotties , new Comparator < MyThreadInfo > ( ) { @Override public int compare ( MyThreadInfo o1 , MyThreadInfo o2 ) { if ( <str> . equals ( type ) ) { return ( int ) ( o2 . cpuTime - o1 . cpuTime ) ; } else if ( <str> . equals ( type ) ) { return ( int ) ( o2 . waitedTime - o1 . waitedTime ) ; } else if ( <str> . equals ( type ) ) { return ( int ) ( o2 . blockedTime - o1 . blockedTime ) ; } throw new IllegalArgumentException ( ) ; } } ) ; long [ ] ids = new long [ busiestThreads ] ; for ( int i = <int> ; i < busiestThreads ; i + + ) { MyThreadInfo info = hotties . get ( i ) ; ids [ i ] = info . info . getThreadId ( ) ; } ThreadInfo [ ] [ ] allInfos = new ThreadInfo [ threadElementsSnapshotCount ] [ ] ; for ( int j = <int> ; j < threadElementsSnapshotCount ; j + + ) { allInfos [ j ] = threadBean . getThreadInfo ( ids , Integer . MAX_VALUE ) ; Thread . sleep ( threadElementsSnapshotDelay . millis ( ) ) ; } for ( int t = <int> ; t < busiestThreads ; t + + ) { long time = <int> ; if ( <str> . equals ( type ) ) { time = hotties . get ( t ) . cpuTime ; } else if ( <str> . equals ( type ) ) { time = hotties . get ( t ) . waitedTime ; } else if ( <str> . equals ( type ) ) { time = hotties . get ( t ) . blockedTime ; } String threadName = null ; for ( ThreadInfo [ ] info : allInfos ) { if ( info ! = null & & info [ t ] ! = null ) { if ( ignoreIdleThreads & & isIdleThread ( info [ t ] ) ) { info [ t ] = null ; continue ; } threadName = info [ t ] . getThreadName ( ) ; break ; } } if ( threadName = = null ) { continue ; } double percent = ( ( ( double ) time ) / interval . nanos ( ) ) * <int> ; sb . append ( String . format ( Locale . ROOT , <str> , percent , TimeValue . timeValueNanos ( time ) , interval , type , threadName ) ) ; boolean [ ] done = new boolean [ threadElementsSnapshotCount ] ; for ( int i = <int> ; i < threadElementsSnapshotCount ; i + + ) { if ( done [ i ] ) continue ; int maxSim = <int> ; boolean [ ] similars = new boolean [ threadElementsSnapshotCount ] ; for ( int j = i + <int> ; j < threadElementsSnapshotCount ; j + + ) { if ( done [ j ] ) continue ; int similarity = similarity ( allInfos [ i ] [ t ] , allInfos [ j ] [ t ] ) ; if ( similarity > maxSim ) { maxSim = similarity ; similars = new boolean [ threadElementsSnapshotCount ] ; } if ( similarity = = maxSim ) similars [ j ] = true ; } int count = <int> ; for ( int j = i + <int> ; j < threadElementsSnapshotCount ; j + + ) { if ( similars [ j ] ) { done [ j ] = true ; count + + ; } } if ( allInfos [ i ] [ t ] ! = null ) { final StackTraceElement [ ] show = allInfos [ i ] [ t ] . getStackTrace ( ) ; if ( count = = <int> ) { sb . append ( String . format ( Locale . ROOT , <str> ) ) ; for ( int l = <int> ; l < show . length ; l + + ) { sb . append ( String . format ( Locale . ROOT , <str> , show [ l ] ) ) ; } } else { sb . append ( String . format ( Locale . ROOT , <str> , count , threadElementsSnapshotCount , maxSim ) ) ; for ( int l = show . length - maxSim ; l < show . length ; l + + ) { sb . append ( String . format ( Locale . ROOT , <str> , show [ l ] ) ) ; } } } } } return sb . toString ( ) ; } finally { if ( enabledCpu ) { threadBean . setThreadCpuTimeEnabled ( false ) ; } } } private static final StackTraceElement [ ] EMPTY = new StackTraceElement [ <int> ] ; private int similarity ( ThreadInfo threadInfo , ThreadInfo threadInfo0 ) { StackTraceElement [ ] s1 = threadInfo = = null ? EMPTY : threadInfo . getStackTrace ( ) ; StackTraceElement [ ] s2 = threadInfo0 = = null ? EMPTY : threadInfo0 . getStackTrace ( ) ; int i = s1 . length - <int> ; int j = s2 . length - <int> ; int rslt = <int> ; while ( i > = <int> & & j > = <int> & & s1 [ i ] . equals ( s2 [ j ] ) ) { rslt + + ; i - - ; j - - ; } return rslt ; } class MyThreadInfo { long cpuTime ; long blockedCount ; long blockedTime ; long waitedCount ; long waitedTime ; boolean deltaDone ; ThreadInfo info ; MyThreadInfo ( long cpuTime , ThreadInfo info ) { blockedCount = info . getBlockedCount ( ) ; blockedTime = info . getBlockedTime ( ) ; waitedCount = info . getWaitedCount ( ) ; waitedTime = info . getWaitedTime ( ) ; this . cpuTime = cpuTime ; this . info = info ; } void setDelta ( long cpuTime , ThreadInfo info ) { if ( deltaDone ) throw new IllegalStateException ( <str> ) ; blockedCount = info . getBlockedCount ( ) - blockedCount ; blockedTime = info . getBlockedTime ( ) - blockedTime ; waitedCount = info . getWaitedCount ( ) - waitedCount ; waitedTime = info . getWaitedTime ( ) - waitedTime ; this . cpuTime = cpuTime - this . cpuTime ; deltaDone = true ; this . info = info ; } } } 
