package org . elasticsearch . test ; import com . carrotsearch . randomizedtesting . annotations . TestGroup ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . indices . recovery . RecoverySettings ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . junit . listeners . LoggingListener ; import org . elasticsearch . transport . Transport ; import org . elasticsearch . transport . TransportModule ; import java . io . IOException ; import java . lang . annotation . ElementType ; import java . lang . annotation . Inherited ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; import java . util . Random ; import static org . hamcrest . Matchers . is ; @ESBackcompatTestCase.Backwards @ESIntegTestCase.ClusterScope ( minNumDataNodes = <int> , maxNumDataNodes = <int> , scope = ESIntegTestCase . Scope . SUITE , numClientNodes = <int> , transportClientRatio = <float> ) public abstract class ESBackcompatTestCase extends ESIntegTestCase { public static final String TESTS_BACKWARDS_COMPATIBILITY = <str> ; public static final String TESTS_BACKWARDS_COMPATIBILITY_VERSION = <str> ; public static final String TESTS_BACKWARDS_COMPATIBILITY_PATH = <str> ; private static final String TESTS_COMPATIBILITY = <str> ; private static final Version GLOABL_COMPATIBILITY_VERSION = Version . fromString ( compatibilityVersionProperty ( ) ) ; private static Path backwardsCompatibilityPath ( ) { String path = System . getProperty ( TESTS_BACKWARDS_COMPATIBILITY_PATH ) ; if ( path = = null | | path . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + TESTS_BACKWARDS_COMPATIBILITY_PATH ) ; } String version = System . getProperty ( TESTS_BACKWARDS_COMPATIBILITY_VERSION ) ; if ( version = = null | | version . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> + TESTS_BACKWARDS_COMPATIBILITY_VERSION ) ; } if ( Version . fromString ( version ) . before ( Version . CURRENT . minimumCompatibilityVersion ( ) ) ) { throw new IllegalArgumentException ( <str> + <str> + version + <str> + Version . CURRENT . toString ( ) ) ; } Path file = PathUtils . get ( path , <str> + version ) ; if ( ! Files . exists ( file ) ) { throw new IllegalArgumentException ( <str> + file . toAbsolutePath ( ) ) ; } if ( ! Files . isDirectory ( file ) ) { throw new IllegalArgumentException ( <str> + file . toAbsolutePath ( ) ) ; } return file ; } public Version compatibilityVersion ( ) { return compatibilityVersion ( getClass ( ) ) ; } private Version compatibilityVersion ( Class < ? > clazz ) { if ( clazz = = Object . class | | clazz = = ESIntegTestCase . class ) { return globalCompatibilityVersion ( ) ; } CompatibilityVersion annotation = clazz . getAnnotation ( CompatibilityVersion . class ) ; if ( annotation ! = null ) { return Version . smallest ( Version . fromId ( annotation . version ( ) ) , compatibilityVersion ( clazz . getSuperclass ( ) ) ) ; } return compatibilityVersion ( clazz . getSuperclass ( ) ) ; } public static Version globalCompatibilityVersion ( ) { return GLOABL_COMPATIBILITY_VERSION ; } private static String compatibilityVersionProperty ( ) { final String version = System . getProperty ( TESTS_COMPATIBILITY ) ; if ( Strings . hasLength ( version ) ) { return version ; } return System . getProperty ( TESTS_BACKWARDS_COMPATIBILITY_VERSION ) ; } public CompositeTestCluster backwardsCluster ( ) { return ( CompositeTestCluster ) cluster ( ) ; } @Override protected TestCluster buildTestCluster ( Scope scope , long seed ) throws IOException { TestCluster cluster = super . buildTestCluster ( scope , seed ) ; ExternalNode externalNode = new ExternalNode ( backwardsCompatibilityPath ( ) , randomLong ( ) , new NodeConfigurationSource ( ) { @Override public Settings nodeSettings ( int nodeOrdinal ) { return externalNodeSettings ( nodeOrdinal ) ; } @Override public Settings transportClientSettings ( ) { return transportClientSettings ( ) ; } } ) ; return new CompositeTestCluster ( ( InternalTestCluster ) cluster , between ( minExternalNodes ( ) , maxExternalNodes ( ) ) , externalNode ) ; } private Settings addLoggerSettings ( Settings externalNodesSettings ) { TestLogging logging = getClass ( ) . getAnnotation ( TestLogging . class ) ; Map < String , String > loggingLevels = LoggingListener . getLoggersAndLevelsFromAnnotation ( logging ) ; Settings . Builder finalSettings = Settings . settingsBuilder ( ) ; if ( loggingLevels ! = null ) { for ( Map . Entry < String , String > level : loggingLevels . entrySet ( ) ) { finalSettings . put ( <str> + level . getKey ( ) , level . getValue ( ) ) ; } } finalSettings . put ( externalNodesSettings ) ; return finalSettings . build ( ) ; } protected int minExternalNodes ( ) { return <int> ; } protected int maxExternalNodes ( ) { return <int> ; } @Override protected int maximumNumberOfReplicas ( ) { return <int> ; } protected Settings requiredSettings ( ) { return ExternalNode . REQUIRED_SETTINGS ; } @Override protected Settings nodeSettings ( int nodeOrdinal ) { return commonNodeSettings ( nodeOrdinal ) ; } public void assertAllShardsOnNodes ( String index , String pattern ) { ClusterState clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . execute ( ) . actionGet ( ) . getState ( ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { if ( shardRouting . currentNodeId ( ) ! = null & & index . equals ( shardRouting . getIndex ( ) ) ) { String name = clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . name ( ) ; assertThat ( <str> + name , Regex . simpleMatch ( pattern , name ) , is ( true ) ) ; } } } } } protected Settings commonNodeSettings ( int nodeOrdinal ) { Settings . Builder builder = Settings . builder ( ) . put ( requiredSettings ( ) ) ; builder . put ( TransportModule . TRANSPORT_TYPE_KEY , <str> ) ; builder . put ( <str> , <str> ) ; return builder . build ( ) ; } protected Settings externalNodeSettings ( int nodeOrdinal ) { return addLoggerSettings ( commonNodeSettings ( nodeOrdinal ) ) ; } @Inherited @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . TYPE ) @TestGroup ( enabled = false , sysProperty = ESBackcompatTestCase . TESTS_BACKWARDS_COMPATIBILITY ) public @interface Backwards { } @Retention ( RetentionPolicy . RUNTIME ) @Target ( { ElementType . TYPE } ) public @interface CompatibilityVersion { int version ( ) ; } } 
