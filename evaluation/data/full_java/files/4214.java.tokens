package org . eclipse . debug . internal . ui . launchConfigurations ; import java . io . BufferedInputStream ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Set ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . core . resources . IContainer ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . resources . ISaveContext ; import org . eclipse . core . resources . ISaveParticipant ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IConfigurationElement ; import org . eclipse . core . runtime . IExtensionPoint ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . ILaunchConfigurationType ; import org . eclipse . debug . core . ILaunchConfigurationWorkingCopy ; import org . eclipse . debug . core . ILaunchDelegate ; import org . eclipse . debug . core . ILaunchListener ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . debug . internal . core . IConfigurationElementConstants ; import org . eclipse . debug . internal . core . LaunchManager ; import org . eclipse . debug . internal . ui . DebugPluginImages ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . IInternalDebugUIConstants ; import org . eclipse . debug . internal . ui . ILaunchHistoryChangedListener ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . debug . ui . ILaunchConfigurationTab ; import org . eclipse . debug . ui . ILaunchGroup ; import org . eclipse . jface . resource . ImageRegistry ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . IEditorPart ; import org . eclipse . ui . IFileEditorInput ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . activities . IWorkbenchActivitySupport ; import org . eclipse . ui . activities . WorkbenchActivityHelper ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; import org . xml . sax . helpers . DefaultHandler ; public class LaunchConfigurationManager implements ILaunchListener , ISaveParticipant { class ShortcutComparator implements Comparator < LaunchShortcutExtension > { @Override public int compare ( LaunchShortcutExtension a , LaunchShortcutExtension b ) { LaunchShortcutExtension shorcutA = a ; String labelA = shorcutA . getLabel ( ) ; String pathA = shorcutA . getMenuPath ( ) ; LaunchShortcutExtension shortcutB = b ; String labelB = shortcutB . getLabel ( ) ; String pathB = shortcutB . getMenuPath ( ) ; if ( nullOrEqual ( pathA , pathB ) ) { if ( labelA = = labelB ) { return <int> ; } if ( labelA = = null ) { return <int> ; } if ( labelB = = null ) { return - <int> ; } return labelA . compareToIgnoreCase ( labelB ) ; } if ( pathA = = null ) { return <int> ; } if ( pathB = = null ) { return - <int> ; } return pathA . compareToIgnoreCase ( pathB ) ; } private boolean nullOrEqual ( String a , String b ) { if ( a = = null ) { return b = = null ; } return a . equals ( b ) ; } } protected Map < String , LaunchGroupExtension > fLaunchGroups ; protected Map < String , LaunchHistory > fLaunchHistories ; protected List < ILaunchHistoryChangedListener > fLaunchHistoryChangedListeners = new ArrayList < ILaunchHistoryChangedListener > ( <int> ) ; private List < LaunchShortcutExtension > fLaunchShortcuts = null ; private Map < String , List < LaunchShortcutExtension > > fLaunchShortcutsByPerspective = null ; protected ImageRegistry fErrorImages = null ; protected boolean fRestoring = false ; private static final String LAUNCH_CONFIGURATION_HISTORY_FILENAME = <str> ; public void startup ( ) { ILaunchManager launchManager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; launchManager . addLaunchListener ( this ) ; DebugUIPlugin . getDefault ( ) . addSaveParticipant ( this ) ; ILaunch [ ] launches = launchManager . getLaunches ( ) ; for ( int i = <int> ; i < launches . length ; i + + ) { launchAdded ( launches [ i ] ) ; } } public boolean launchModeAvailable ( String mode ) { return ( ( LaunchManager ) DebugPlugin . getDefault ( ) . getLaunchManager ( ) ) . launchModeAvailable ( mode ) ; } public static boolean isVisible ( ILaunchConfiguration launchConfiguration ) { try { return ! ( launchConfiguration . getAttribute ( IDebugUIConstants . ATTR_PRIVATE , false ) ) ; } catch ( CoreException e ) { } return false ; } public static ILaunchConfiguration [ ] filterConfigs ( ILaunchConfiguration [ ] configurations ) { IWorkbenchActivitySupport activitySupport = PlatformUI . getWorkbench ( ) . getActivitySupport ( ) ; if ( activitySupport = = null ) { return configurations ; } List < ILaunchConfiguration > filteredConfigs = new ArrayList < ILaunchConfiguration > ( ) ; ILaunchConfigurationType type = null ; LaunchConfigurationTypeContribution contribution = null ; ILaunchConfiguration configuration = null ; for ( int i = <int> ; i < configurations . length ; i + + ) { configuration = configurations [ i ] ; try { type = configuration . getType ( ) ; contribution = new LaunchConfigurationTypeContribution ( type ) ; if ( DebugUIPlugin . doLaunchConfigurationFiltering ( configuration ) & ! WorkbenchActivityHelper . filterItem ( contribution ) ) { filteredConfigs . add ( configuration ) ; } } catch ( CoreException e ) { DebugUIPlugin . log ( e . getStatus ( ) ) ; } } return filteredConfigs . toArray ( new ILaunchConfiguration [ filteredConfigs . size ( ) ] ) ; } public static ILaunchDelegate [ ] filterLaunchDelegates ( ILaunchConfigurationType type , Set < String > modes ) throws CoreException { IWorkbenchActivitySupport as = PlatformUI . getWorkbench ( ) . getActivitySupport ( ) ; ILaunchDelegate [ ] delegates = type . getDelegates ( modes ) ; if ( as = = null ) { return delegates ; } HashSet < ILaunchDelegate > set = new HashSet < ILaunchDelegate > ( ) ; for ( int i = <int> ; i < delegates . length ; i + + ) { if ( ! WorkbenchActivityHelper . filterItem ( new LaunchDelegateContribution ( delegates [ i ] ) ) ) { set . add ( delegates [ i ] ) ; } } return set . toArray ( new ILaunchDelegate [ set . size ( ) ] ) ; } public void shutdown ( ) { ILaunchManager launchManager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; launchManager . removeLaunchListener ( this ) ; if ( fLaunchHistories ! = null ) { for ( LaunchHistory history : fLaunchHistories . values ( ) ) { history . dispose ( ) ; } } DebugUIPlugin . getDefault ( ) . removeSaveParticipant ( this ) ; } @Override public void launchRemoved ( ILaunch launch ) { } @Override public void launchChanged ( ILaunch launch ) { } @Override public void launchAdded ( final ILaunch launch ) { removeTerminatedLaunches ( launch ) ; } protected void removeTerminatedLaunches ( ILaunch newLaunch ) { if ( DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getBoolean ( IDebugUIConstants . PREF_AUTO_REMOVE_OLD_LAUNCHES ) ) { ILaunchManager lManager = DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; Object [ ] launches = lManager . getLaunches ( ) ; for ( int i = <int> ; i < launches . length ; i + + ) { ILaunch launch = ( ILaunch ) launches [ i ] ; if ( launch ! = newLaunch & & launch . isTerminated ( ) ) { lManager . removeLaunch ( launch ) ; } } } } public ILaunchConfiguration getLastLaunch ( String groupId ) { LaunchHistory history = getLaunchHistory ( groupId ) ; if ( history ! = null ) { return history . getRecentLaunch ( ) ; } return null ; } public ILaunchConfiguration getFilteredLastLaunch ( String groupId ) { LaunchHistory history = getLaunchHistory ( groupId ) ; if ( history ! = null ) { ILaunchConfiguration [ ] filterConfigs = history . getCompleteLaunchHistory ( ) ; if ( filterConfigs . length > <int> ) { return filterConfigs [ <int> ] ; } } return null ; } public void addLaunchHistoryListener ( ILaunchHistoryChangedListener listener ) { if ( ! fLaunchHistoryChangedListeners . contains ( listener ) ) { fLaunchHistoryChangedListeners . add ( listener ) ; } } public void removeLaunchHistoryListener ( ILaunchHistoryChangedListener listener ) { fLaunchHistoryChangedListeners . remove ( listener ) ; } protected void fireLaunchHistoryChanged ( ) { for ( ILaunchHistoryChangedListener listener : fLaunchHistoryChangedListeners ) { listener . launchHistoryChanged ( ) ; } } protected String getHistoryAsXML ( ) throws CoreException , ParserConfigurationException { Document doc = DebugUIPlugin . getDocument ( ) ; Element historyRootElement = doc . createElement ( IConfigurationElementConstants . LAUNCH_HISTORY ) ; doc . appendChild ( historyRootElement ) ; for ( LaunchHistory history : fLaunchHistories . values ( ) ) { Element groupElement = doc . createElement ( IConfigurationElementConstants . LAUNCH_GROUP ) ; groupElement . setAttribute ( IConfigurationElementConstants . ID , history . getLaunchGroup ( ) . getIdentifier ( ) ) ; historyRootElement . appendChild ( groupElement ) ; Element historyElement = doc . createElement ( IConfigurationElementConstants . MRU_HISTORY ) ; groupElement . appendChild ( historyElement ) ; createEntry ( doc , historyElement , history . getCompleteLaunchHistory ( ) ) ; Element favs = doc . createElement ( IConfigurationElementConstants . FAVORITES ) ; groupElement . appendChild ( favs ) ; createEntry ( doc , favs , history . getFavorites ( ) ) ; history . setSaved ( true ) ; } return DebugPlugin . serializeDocument ( doc ) ; } protected void createEntry ( Document doc , Element historyRootElement , ILaunchConfiguration [ ] configurations ) throws CoreException { for ( int i = <int> ; i < configurations . length ; i + + ) { ILaunchConfiguration configuration = configurations [ i ] ; if ( configuration . exists ( ) ) { Element launch = doc . createElement ( IConfigurationElementConstants . LAUNCH ) ; launch . setAttribute ( IConfigurationElementConstants . MEMENTO , configuration . getMemento ( ) ) ; historyRootElement . appendChild ( launch ) ; } } } protected IPath getHistoryFilePath ( ) { return DebugUIPlugin . getDefault ( ) . getStateLocation ( ) . append ( LAUNCH_CONFIGURATION_HISTORY_FILENAME ) ; } protected void persistLaunchHistory ( ) throws IOException , CoreException , ParserConfigurationException { synchronized ( this ) { if ( fLaunchHistories = = null | | fRestoring ) { return ; } } boolean shouldsave = false ; for ( LaunchHistory history : fLaunchHistories . values ( ) ) { shouldsave | = history . needsSaving ( ) ; } if ( shouldsave ) { IPath historyPath = getHistoryFilePath ( ) ; String osHistoryPath = historyPath . toOSString ( ) ; String xml = getHistoryAsXML ( ) ; File file = new File ( osHistoryPath ) ; file . createNewFile ( ) ; try ( FileOutputStream stream = new FileOutputStream ( file ) ) { stream . write ( xml . getBytes ( <str> ) ) ; } } } private void restoreLaunchHistory ( ) { IPath historyPath = getHistoryFilePath ( ) ; String osHistoryPath = historyPath . toOSString ( ) ; File file = new File ( osHistoryPath ) ; if ( ! file . exists ( ) ) { return ; } Element rootHistoryElement = null ; try ( InputStream stream = new BufferedInputStream ( new FileInputStream ( file ) ) ) { try { DocumentBuilder parser = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) ; parser . setErrorHandler ( new DefaultHandler ( ) ) ; rootHistoryElement = parser . parse ( new InputSource ( stream ) ) . getDocumentElement ( ) ; } catch ( SAXException e ) { DebugUIPlugin . log ( e ) ; return ; } catch ( ParserConfigurationException e ) { DebugUIPlugin . log ( e ) ; return ; } } catch ( IOException exception ) { DebugUIPlugin . log ( exception ) ; return ; } if ( ! rootHistoryElement . getNodeName ( ) . equalsIgnoreCase ( IConfigurationElementConstants . LAUNCH_HISTORY ) ) { return ; } LaunchHistory [ ] histories = fLaunchHistories . values ( ) . toArray ( new LaunchHistory [ fLaunchHistories . size ( ) ] ) ; NodeList list = rootHistoryElement . getChildNodes ( ) ; int length = list . getLength ( ) ; Node node = null ; Element entry = null ; for ( int i = <int> ; i < length ; + + i ) { node = list . item ( i ) ; short type = node . getNodeType ( ) ; if ( type = = Node . ELEMENT_NODE ) { entry = ( Element ) node ; if ( entry . getNodeName ( ) . equalsIgnoreCase ( IConfigurationElementConstants . LAUNCH ) ) { createHistoryElement ( entry , histories , false ) ; } else if ( entry . getNodeName ( ) . equalsIgnoreCase ( IConfigurationElementConstants . LAST_LAUNCH ) ) { createHistoryElement ( entry , histories , true ) ; } else if ( entry . getNodeName ( ) . equals ( IConfigurationElementConstants . LAUNCH_GROUP ) ) { String id = entry . getAttribute ( IConfigurationElementConstants . ID ) ; if ( id ! = null ) { LaunchHistory history = getLaunchHistory ( id ) ; if ( history ! = null ) { restoreHistory ( entry , history ) ; } } } } } } private void restoreHistory ( Element groupElement , LaunchHistory history ) { NodeList nodes = groupElement . getChildNodes ( ) ; int length = nodes . getLength ( ) ; for ( int i = <int> ; i < length ; i + + ) { Node node = nodes . item ( i ) ; if ( node . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element element = ( Element ) node ; if ( element . getNodeName ( ) . equals ( IConfigurationElementConstants . MRU_HISTORY ) ) { ILaunchConfiguration [ ] configs = getLaunchConfigurations ( element ) ; for ( int j = <int> ; j < configs . length ; j + + ) { history . addHistory ( configs [ j ] , false ) ; } } else if ( element . getNodeName ( ) . equals ( IConfigurationElementConstants . FAVORITES ) ) { ILaunchConfiguration [ ] favs = getLaunchConfigurations ( element ) ; history . setFavorites ( favs ) ; ILaunchConfiguration [ ] configurations = getLaunchManager ( ) . getLaunchConfigurations ( ) ; for ( int j = <int> ; j < configurations . length ; j + + ) { history . checkFavorites ( configurations [ j ] ) ; } } } } } private ILaunchConfiguration [ ] getLaunchConfigurations ( Element root ) { List < ILaunchConfiguration > configs = new ArrayList < ILaunchConfiguration > ( ) ; NodeList nodes = root . getChildNodes ( ) ; int length = nodes . getLength ( ) ; for ( int i = <int> ; i < length ; i + + ) { Node node = nodes . item ( i ) ; if ( node . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element element = ( Element ) node ; if ( element . getNodeName ( ) . equals ( IConfigurationElementConstants . LAUNCH ) ) { String memento = element . getAttribute ( IConfigurationElementConstants . MEMENTO ) ; if ( memento ! = null ) { try { ILaunchConfiguration configuration = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getLaunchConfiguration ( memento ) ; configuration . getType ( ) ; if ( configuration . exists ( ) ) { configs . add ( configuration ) ; } } catch ( CoreException e ) { } } } } } return configs . toArray ( new ILaunchConfiguration [ configs . size ( ) ] ) ; } private void createHistoryElement ( Element entry , LaunchHistory [ ] histories , boolean prepend ) { String memento = entry . getAttribute ( IConfigurationElementConstants . MEMENTO ) ; String mode = entry . getAttribute ( IConfigurationElementConstants . MODE ) ; try { ILaunchConfiguration launchConfig = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getLaunchConfiguration ( memento ) ; launchConfig . getType ( ) ; if ( launchConfig . exists ( ) ) { LaunchHistory history = null ; for ( int i = <int> ; i < histories . length ; i + + ) { history = histories [ i ] ; if ( history . accepts ( launchConfig ) & & history . getLaunchGroup ( ) . getMode ( ) . equals ( mode ) ) { history . addHistory ( launchConfig , prepend ) ; } } } } catch ( CoreException e ) { } } private synchronized void loadLaunchShortcuts ( ) { if ( fLaunchShortcuts = = null ) { IExtensionPoint extensionPoint = Platform . getExtensionRegistry ( ) . getExtensionPoint ( DebugUIPlugin . getUniqueIdentifier ( ) , IDebugUIConstants . EXTENSION_POINT_LAUNCH_SHORTCUTS ) ; IConfigurationElement [ ] infos = extensionPoint . getConfigurationElements ( ) ; fLaunchShortcuts = new ArrayList < LaunchShortcutExtension > ( infos . length ) ; for ( int i = <int> ; i < infos . length ; i + + ) { fLaunchShortcuts . add ( new LaunchShortcutExtension ( infos [ i ] ) ) ; } Collections . sort ( fLaunchShortcuts , new ShortcutComparator ( ) ) ; } } private synchronized void loadLaunchGroups ( ) { if ( fLaunchGroups = = null ) { IExtensionPoint extensionPoint = Platform . getExtensionRegistry ( ) . getExtensionPoint ( DebugUIPlugin . getUniqueIdentifier ( ) , IDebugUIConstants . EXTENSION_POINT_LAUNCH_GROUPS ) ; IConfigurationElement [ ] infos = extensionPoint . getConfigurationElements ( ) ; fLaunchGroups = new HashMap < String , LaunchGroupExtension > ( infos . length ) ; LaunchGroupExtension ext = null ; for ( int i = <int> ; i < infos . length ; i + + ) { ext = new LaunchGroupExtension ( infos [ i ] ) ; fLaunchGroups . put ( ext . getIdentifier ( ) , ext ) ; } } } public List < LaunchShortcutExtension > getLaunchShortcuts ( ) { if ( fLaunchShortcuts = = null ) { loadLaunchShortcuts ( ) ; } return fLaunchShortcuts ; } public List < LaunchShortcutExtension > getLaunchShortcuts ( IResource resource ) { List < LaunchShortcutExtension > list = new ArrayList < LaunchShortcutExtension > ( ) ; List < LaunchShortcutExtension > sc = getLaunchShortcuts ( ) ; List < IResource > ctxt = new ArrayList < IResource > ( ) ; if ( resource ! = null ) { ctxt . add ( resource ) ; } IEvaluationContext context = DebugUIPlugin . createEvaluationContext ( ctxt ) ; context . addVariable ( <str> , ctxt ) ; for ( LaunchShortcutExtension ext : sc ) { try { if ( ext . evalEnablementExpression ( context , ext . getContextualLaunchEnablementExpression ( ) ) & & ! WorkbenchActivityHelper . filterItem ( ext ) ) { if ( ! list . contains ( ext ) ) { list . add ( ext ) ; } } } catch ( CoreException ce ) { } } return list ; } public String [ ] getApplicableConfigurationTypes ( IResource resource ) { List < String > types = new ArrayList < String > ( ) ; List < LaunchShortcutExtension > exts = getLaunchShortcuts ( ) ; List < IResource > list = new ArrayList < IResource > ( ) ; list . add ( resource ) ; IEvaluationContext context = DebugUIPlugin . createEvaluationContext ( list ) ; context . setAllowPluginActivation ( true ) ; context . addVariable ( <str> , list ) ; HashSet < String > set = new HashSet < String > ( ) ; for ( Iterator < LaunchShortcutExtension > iter = exts . listIterator ( ) ; iter . hasNext ( ) ; ) { LaunchShortcutExtension ext = iter . next ( ) ; try { if ( ext . evalEnablementExpression ( context , ext . getContextualLaunchEnablementExpression ( ) ) ) { set . addAll ( ext . getAssociatedConfigurationTypes ( ) ) ; } } catch ( CoreException ce ) { IStatus status = new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> + ext . getId ( ) + <str> , ce ) ; DebugUIPlugin . log ( status ) ; iter . remove ( ) ; } } LaunchManager lm = ( LaunchManager ) DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; ILaunchConfigurationType type = null ; for ( String id : set ) { type = lm . getLaunchConfigurationType ( id ) ; if ( type ! = null ) { if ( ! types . contains ( type ) & & type . isPublic ( ) & & ! <str> . equals ( type . getCategory ( ) ) ) { types . add ( type . getIdentifier ( ) ) ; } } } return types . toArray ( new String [ types . size ( ) ] ) ; } public ILaunchConfiguration [ ] getApplicableLaunchConfigurations ( String [ ] types , IResource resource ) { ArrayList < ILaunchConfiguration > list = new ArrayList < ILaunchConfiguration > ( ) ; try { if ( resource ! = null ) { String [ ] ctypes = types ; if ( ctypes = = null ) { ctypes = getApplicableConfigurationTypes ( resource ) ; } HashSet < String > typeset = new HashSet < String > ( ctypes . length ) ; for ( int i = <int> ; i < ctypes . length ; i + + ) { typeset . add ( ctypes [ i ] ) ; } ILaunchConfiguration [ ] configurations = filterConfigs ( getLaunchManager ( ) . getLaunchConfigurations ( ) ) ; ILaunchConfiguration configuration = null ; IResource [ ] resrcs = null ; for ( int i = <int> ; i < configurations . length ; i + + ) { configuration = configurations [ i ] ; if ( typeset . contains ( configuration . getType ( ) . getIdentifier ( ) ) & & acceptConfiguration ( configuration ) ) { resrcs = configuration . getMappedResources ( ) ; if ( resrcs ! = null ) { for ( int j = <int> ; j < resrcs . length ; j + + ) { if ( resource . equals ( resrcs [ j ] ) | | resource . getFullPath ( ) . isPrefixOf ( resrcs [ j ] . getFullPath ( ) ) ) { list . add ( configuration ) ; break ; } } } else { list . add ( configuration ) ; } } } } } catch ( CoreException e ) { list . clear ( ) ; DebugPlugin . log ( e ) ; } return list . toArray ( new ILaunchConfiguration [ list . size ( ) ] ) ; } private boolean acceptConfiguration ( ILaunchConfiguration config ) throws CoreException { if ( config ! = null & & ! DebugUITools . isPrivate ( config ) ) { if ( ! <str> . equals ( config . getType ( ) . getCategory ( ) ) ) { return true ; } else { IResource [ ] res = config . getMappedResources ( ) ; if ( res ! = null ) { return true ; } } } return false ; } public List < LaunchShortcutExtension > getLaunchShortcuts ( String category ) { return filterShortcuts ( getLaunchShortcuts ( ) , category ) ; } protected List < LaunchShortcutExtension > filterShortcuts ( List < LaunchShortcutExtension > unfiltered , String category ) { List < LaunchShortcutExtension > filtered = new ArrayList < LaunchShortcutExtension > ( unfiltered . size ( ) ) ; for ( LaunchShortcutExtension extension : unfiltered ) { if ( category = = null ) { if ( extension . getCategory ( ) = = null ) { filtered . add ( extension ) ; } } else if ( category . equals ( extension . getCategory ( ) ) ) { filtered . add ( extension ) ; } } return filtered ; } @Deprecated public List < LaunchShortcutExtension > getLaunchShortcuts ( String perpsective , String category ) { if ( fLaunchShortcutsByPerspective = = null ) { fLaunchShortcutsByPerspective = new HashMap < String , List < LaunchShortcutExtension > > ( <int> ) ; } for ( LaunchShortcutExtension ext : getLaunchShortcuts ( ) ) { for ( String id : ext . getPerspectives ( ) ) { List < LaunchShortcutExtension > list = fLaunchShortcutsByPerspective . get ( id ) ; if ( list = = null ) { list = new ArrayList < LaunchShortcutExtension > ( <int> ) ; fLaunchShortcutsByPerspective . put ( id , list ) ; } list . add ( ext ) ; } } List < LaunchShortcutExtension > list = fLaunchShortcutsByPerspective . get ( perpsective ) ; if ( list = = null ) { return Collections . EMPTY_LIST ; } return filterShortcuts ( list , category ) ; } public ILaunchConfiguration getMRUConfiguration ( List < ILaunchConfiguration > configurations , ILaunchGroup group , IResource resource ) { if ( group ! = null ) { ArrayList < ILaunchConfiguration > candidates = new ArrayList < ILaunchConfiguration > ( ) ; LaunchHistory history = getLaunchHistory ( group . getIdentifier ( ) ) ; if ( history ! = null ) { ILaunchConfiguration [ ] configs = history . getCompleteLaunchHistory ( ) ; for ( int i = <int> ; i < configs . length ; i + + ) { if ( configurations . contains ( configs [ i ] ) ) { if ( resource instanceof IContainer ) { return configs [ i ] ; } else { candidates . add ( configs [ i ] ) ; } } } if ( resource ! = null ) { IResource [ ] res = null ; for ( ILaunchConfiguration config : candidates ) { try { res = config . getMappedResources ( ) ; if ( res ! = null ) { for ( int i = <int> ; i < res . length ; i + + ) { if ( res [ i ] . equals ( resource ) ) { return config ; } } } } catch ( CoreException ce ) { } } } for ( int i = <int> ; i < configs . length ; i + + ) { if ( candidates . contains ( configs [ i ] ) ) { return configs [ i ] ; } } } } return null ; } public ILaunchConfiguration isSharedConfig ( Object receiver ) { if ( receiver instanceof IFile ) { IFile file = ( IFile ) receiver ; String ext = file . getFileExtension ( ) ; if ( ext = = null ) { return null ; } if ( ext . equals ( <str> ) ) { ILaunchConfiguration config = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getLaunchConfiguration ( file ) ; if ( config ! = null & & config . exists ( ) ) { return config ; } } } else if ( receiver instanceof IFileEditorInput ) { IFileEditorInput input = ( IFileEditorInput ) receiver ; return isSharedConfig ( input . getFile ( ) ) ; } else if ( receiver instanceof IEditorPart ) { return isSharedConfig ( ( ( IEditorPart ) receiver ) . getEditorInput ( ) ) ; } else if ( receiver instanceof IAdaptable ) { IFile file = ( ( IAdaptable ) receiver ) . getAdapter ( IFile . class ) ; if ( file ! = null ) { return isSharedConfig ( file ) ; } } return null ; } public Image getErrorTabImage ( ILaunchConfigurationTab tab ) { if ( fErrorImages = = null ) { fErrorImages = new ImageRegistry ( ) ; } String key = tab . getClass ( ) . getName ( ) ; Image image = fErrorImages . get ( key ) ; if ( image = = null ) { Image base = tab . getImage ( ) ; if ( base = = null ) { base = DebugPluginImages . getImage ( IInternalDebugUIConstants . IMG_OVR_TRANSPARENT ) ; } base = new Image ( Display . getCurrent ( ) , base , SWT . IMAGE_COPY ) ; LaunchConfigurationTabImageDescriptor desc = new LaunchConfigurationTabImageDescriptor ( base , LaunchConfigurationTabImageDescriptor . ERROR ) ; image = desc . createImage ( ) ; fErrorImages . put ( key , image ) ; } return image ; } public LaunchGroupExtension getLaunchGroup ( String id ) { if ( fLaunchGroups = = null ) { loadLaunchGroups ( ) ; } return fLaunchGroups . get ( id ) ; } public ILaunchGroup [ ] getLaunchGroups ( ) { if ( fLaunchGroups = = null ) { loadLaunchGroups ( ) ; } return fLaunchGroups . values ( ) . toArray ( new ILaunchGroup [ fLaunchGroups . size ( ) ] ) ; } public LaunchHistory getLaunchHistory ( String id ) { loadLaunchHistories ( ) ; return fLaunchHistories . get ( id ) ; } private LaunchManager getLaunchManager ( ) { return ( LaunchManager ) DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; } private synchronized void loadLaunchHistories ( ) { if ( fLaunchHistories = = null ) { fRestoring = true ; ILaunchGroup [ ] groups = getLaunchGroups ( ) ; fLaunchHistories = new HashMap < String , LaunchHistory > ( groups . length ) ; ILaunchGroup extension = null ; for ( int i = <int> ; i < groups . length ; i + + ) { extension = groups [ i ] ; if ( extension . isPublic ( ) ) { fLaunchHistories . put ( extension . getIdentifier ( ) , new LaunchHistory ( extension ) ) ; } } restoreLaunchHistory ( ) ; fRestoring = false ; } } public LaunchGroupExtension getDefaultLaunchGroup ( String mode ) { if ( mode . equals ( ILaunchManager . DEBUG_MODE ) ) { return getLaunchGroup ( IDebugUIConstants . ID_DEBUG_LAUNCH_GROUP ) ; } return getLaunchGroup ( IDebugUIConstants . ID_RUN_LAUNCH_GROUP ) ; } public ILaunchGroup getLaunchGroup ( ILaunchConfigurationType type , String mode ) { if ( ! type . supportsMode ( mode ) ) { return null ; } String category = type . getCategory ( ) ; ILaunchGroup [ ] groups = getLaunchGroups ( ) ; ILaunchGroup extension = null ; for ( int i = <int> ; i < groups . length ; i + + ) { extension = groups [ i ] ; if ( category = = null ) { if ( extension . getCategory ( ) = = null & & extension . getMode ( ) . equals ( mode ) ) { return extension ; } } else if ( category . equals ( extension . getCategory ( ) ) ) { if ( extension . getMode ( ) . equals ( mode ) ) { return extension ; } } } return null ; } public ILaunchGroup getLaunchGroup ( ILaunchConfigurationType type , Set < String > modeset ) { StringBuffer buff = new StringBuffer ( ) ; for ( Iterator < String > iter = modeset . iterator ( ) ; iter . hasNext ( ) ; ) { buff . append ( iter . next ( ) ) ; if ( iter . hasNext ( ) ) { buff . append ( <str> ) ; } } return getLaunchGroup ( type , buff . toString ( ) ) ; } public static ILaunchConfiguration getSharedTypeConfig ( ILaunchConfigurationType type ) throws CoreException { String id = type . getIdentifier ( ) ; String name = id + <str> ; ILaunchConfiguration shared = null ; ILaunchConfiguration [ ] configurations = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getLaunchConfigurations ( type ) ; ILaunchConfiguration configuration = null ; for ( int i = <int> ; i < configurations . length ; i + + ) { configuration = configurations [ i ] ; if ( configuration . getName ( ) . equals ( name ) ) { shared = configuration ; break ; } } if ( shared = = null ) { ILaunchConfigurationWorkingCopy workingCopy ; workingCopy = type . newInstance ( null , name ) ; workingCopy . setAttribute ( IDebugUIConstants . ATTR_PRIVATE , true ) ; shared = workingCopy . doSave ( ) ; } return shared ; } @Override public void doneSaving ( ISaveContext context ) { } @Override public void prepareToSave ( ISaveContext context ) throws CoreException { } @Override public void rollback ( ISaveContext context ) { } @Override public void saving ( ISaveContext context ) throws CoreException { try { persistLaunchHistory ( ) ; } catch ( IOException e ) { throw new CoreException ( new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> , e ) ) ; } catch ( ParserConfigurationException e ) { throw new CoreException ( new Status ( IStatus . ERROR , DebugUIPlugin . getUniqueIdentifier ( ) , <str> , e ) ) ; } } public void setRecentLaunch ( ILaunch launch ) { ILaunchGroup [ ] groups = DebugUITools . getLaunchGroups ( ) ; int size = groups . length ; for ( int i = <int> ; i < size ; i + + ) { String id = groups [ i ] . getIdentifier ( ) ; LaunchHistory history = getLaunchHistory ( id ) ; if ( history ! = null ) { history . launchAdded ( launch ) ; } } } } 
