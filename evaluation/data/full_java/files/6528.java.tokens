package org . elasticsearch . index . mapper ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . FieldType ; import org . apache . lucene . index . IndexOptions ; import org . elasticsearch . Version ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . mapper . core . TypeParsers ; import org . elasticsearch . index . mapper . internal . AllFieldMapper ; import org . elasticsearch . index . similarity . SimilarityProvider ; import org . elasticsearch . index . similarity . SimilarityService ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . Locale ; import java . util . stream . StreamSupport ; public abstract class FieldMapper extends Mapper { public abstract static class Builder < T extends Builder , Y extends FieldMapper > extends Mapper . Builder < T , Y > { protected final MappedFieldType fieldType ; protected final MappedFieldType defaultFieldType ; private final IndexOptions defaultOptions ; protected boolean omitNormsSet = false ; protected String indexName ; protected Boolean includeInAll ; protected boolean indexOptionsSet = false ; protected boolean docValuesSet = false ; @Nullable protected Settings fieldDataSettings ; protected final MultiFields . Builder multiFieldsBuilder ; protected CopyTo copyTo ; protected Builder ( String name , MappedFieldType fieldType ) { super ( name ) ; this . fieldType = fieldType . clone ( ) ; this . defaultFieldType = fieldType . clone ( ) ; this . defaultOptions = fieldType . indexOptions ( ) ; multiFieldsBuilder = new MultiFields . Builder ( ) ; } public MappedFieldType fieldType ( ) { return fieldType ; } public T index ( boolean index ) { if ( index ) { if ( fieldType . indexOptions ( ) = = IndexOptions . NONE ) { final IndexOptions options = getDefaultIndexOption ( ) ; assert options ! = IndexOptions . NONE : <str> ; fieldType . setIndexOptions ( options ) ; } } else { fieldType . setIndexOptions ( IndexOptions . NONE ) ; } return builder ; } protected IndexOptions getDefaultIndexOption ( ) { return defaultOptions ; } public T store ( boolean store ) { this . fieldType . setStored ( store ) ; return builder ; } public T docValues ( boolean docValues ) { this . fieldType . setHasDocValues ( docValues ) ; this . docValuesSet = true ; return builder ; } public T storeTermVectors ( boolean termVectors ) { if ( termVectors ! = this . fieldType . storeTermVectors ( ) ) { this . fieldType . setStoreTermVectors ( termVectors ) ; } return builder ; } public T storeTermVectorOffsets ( boolean termVectorOffsets ) { if ( termVectorOffsets ) { this . fieldType . setStoreTermVectors ( termVectorOffsets ) ; } this . fieldType . setStoreTermVectorOffsets ( termVectorOffsets ) ; return builder ; } public T storeTermVectorPositions ( boolean termVectorPositions ) { if ( termVectorPositions ) { this . fieldType . setStoreTermVectors ( termVectorPositions ) ; } this . fieldType . setStoreTermVectorPositions ( termVectorPositions ) ; return builder ; } public T storeTermVectorPayloads ( boolean termVectorPayloads ) { if ( termVectorPayloads ) { this . fieldType . setStoreTermVectors ( termVectorPayloads ) ; } this . fieldType . setStoreTermVectorPayloads ( termVectorPayloads ) ; return builder ; } public T tokenized ( boolean tokenized ) { this . fieldType . setTokenized ( tokenized ) ; return builder ; } public T boost ( float boost ) { this . fieldType . setBoost ( boost ) ; return builder ; } public T omitNorms ( boolean omitNorms ) { this . fieldType . setOmitNorms ( omitNorms ) ; this . omitNormsSet = true ; return builder ; } public T indexOptions ( IndexOptions indexOptions ) { this . fieldType . setIndexOptions ( indexOptions ) ; this . indexOptionsSet = true ; return builder ; } public T indexName ( String indexName ) { this . indexName = indexName ; return builder ; } public T indexAnalyzer ( NamedAnalyzer indexAnalyzer ) { this . fieldType . setIndexAnalyzer ( indexAnalyzer ) ; return builder ; } public T searchAnalyzer ( NamedAnalyzer searchAnalyzer ) { this . fieldType . setSearchAnalyzer ( searchAnalyzer ) ; return builder ; } public T includeInAll ( Boolean includeInAll ) { this . includeInAll = includeInAll ; return builder ; } public T similarity ( SimilarityProvider similarity ) { this . fieldType . setSimilarity ( similarity ) ; return builder ; } public T normsLoading ( MappedFieldType . Loading normsLoading ) { this . fieldType . setNormsLoading ( normsLoading ) ; return builder ; } public T fieldDataSettings ( Settings settings ) { this . fieldDataSettings = settings ; return builder ; } public Builder nullValue ( Object nullValue ) { this . fieldType . setNullValue ( nullValue ) ; return this ; } public T multiFieldPathType ( ContentPath . Type pathType ) { multiFieldsBuilder . pathType ( pathType ) ; return builder ; } public T addMultiField ( Mapper . Builder mapperBuilder ) { multiFieldsBuilder . add ( mapperBuilder ) ; return builder ; } public T copyTo ( CopyTo copyTo ) { this . copyTo = copyTo ; return builder ; } protected MappedFieldType . Names buildNames ( BuilderContext context ) { return new MappedFieldType . Names ( buildIndexName ( context ) , buildIndexNameClean ( context ) , buildFullName ( context ) ) ; } protected String buildIndexName ( BuilderContext context ) { if ( context . indexCreatedVersion ( ) . onOrAfter ( Version . V_2_0_0_beta1 ) ) { return buildFullName ( context ) ; } String actualIndexName = indexName = = null ? name : indexName ; return context . path ( ) . pathAsText ( actualIndexName ) ; } protected String buildIndexNameClean ( BuilderContext context ) { if ( context . indexCreatedVersion ( ) . onOrAfter ( Version . V_2_0_0_beta1 ) ) { return buildFullName ( context ) ; } return indexName = = null ? name : indexName ; } protected String buildFullName ( BuilderContext context ) { return context . path ( ) . fullPathAsText ( name ) ; } protected void setupFieldType ( BuilderContext context ) { fieldType . setNames ( buildNames ( context ) ) ; if ( fieldType . indexAnalyzer ( ) = = null & & fieldType . tokenized ( ) = = false & & fieldType . indexOptions ( ) ! = IndexOptions . NONE ) { fieldType . setIndexAnalyzer ( Lucene . KEYWORD_ANALYZER ) ; fieldType . setSearchAnalyzer ( Lucene . KEYWORD_ANALYZER ) ; } if ( fieldDataSettings ! = null ) { Settings settings = Settings . builder ( ) . put ( fieldType . fieldDataType ( ) . getSettings ( ) ) . put ( fieldDataSettings ) . build ( ) ; fieldType . setFieldDataType ( new FieldDataType ( fieldType . fieldDataType ( ) . getType ( ) , settings ) ) ; } boolean defaultDocValues = false ; if ( context . indexCreatedVersion ( ) . onOrAfter ( Version . V_2_0_0_beta1 ) ) { defaultDocValues = fieldType . tokenized ( ) = = false & & fieldType . indexOptions ( ) ! = IndexOptions . NONE ; } boolean fieldDataDocValues = fieldType . fieldDataType ( ) ! = null & & FieldDataType . DOC_VALUES_FORMAT_VALUE . equals ( fieldType . fieldDataType ( ) . getFormat ( context . indexSettings ( ) ) ) ; if ( fieldDataDocValues & & docValuesSet & & fieldType . hasDocValues ( ) = = false ) { defaultDocValues = true ; } defaultFieldType . setHasDocValues ( defaultDocValues ) ; if ( docValuesSet = = false ) { fieldType . setHasDocValues ( defaultDocValues | | fieldDataDocValues ) ; } } } protected MappedFieldTypeReference fieldTypeRef ; protected final MappedFieldType defaultFieldType ; protected final MultiFields multiFields ; protected CopyTo copyTo ; protected final boolean indexCreatedBefore2x ; protected FieldMapper ( String simpleName , MappedFieldType fieldType , MappedFieldType defaultFieldType , Settings indexSettings , MultiFields multiFields , CopyTo copyTo ) { super ( simpleName ) ; assert indexSettings ! = null ; this . indexCreatedBefore2x = Version . indexCreated ( indexSettings ) . before ( Version . V_2_0_0_beta1 ) ; this . fieldTypeRef = new MappedFieldTypeReference ( fieldType ) ; defaultFieldType . freeze ( ) ; this . defaultFieldType = defaultFieldType ; this . multiFields = multiFields ; this . copyTo = copyTo ; } @Override public String name ( ) { return fieldType ( ) . names ( ) . fullName ( ) ; } public MappedFieldType fieldType ( ) { return fieldTypeRef . get ( ) ; } public MappedFieldTypeReference fieldTypeReference ( ) { return fieldTypeRef ; } public void setFieldTypeReference ( MappedFieldTypeReference ref ) { if ( ref . get ( ) . equals ( fieldType ( ) ) = = false ) { throw new IllegalStateException ( <str> ) ; } this . fieldTypeRef = ref ; } public CopyTo copyTo ( ) { return copyTo ; } public Mapper parse ( ParseContext context ) throws IOException { final List < Field > fields = new ArrayList < > ( <int> ) ; try { parseCreateField ( context , fields ) ; for ( Field field : fields ) { if ( ! customBoost ( ) ) { field . setBoost ( fieldType ( ) . boost ( ) ) ; } context . doc ( ) . add ( field ) ; } } catch ( Exception e ) { throw new MapperParsingException ( <str> + fieldType ( ) . names ( ) . fullName ( ) + <str> , e ) ; } multiFields . parse ( this , context ) ; return null ; } protected abstract void parseCreateField ( ParseContext context , List < Field > fields ) throws IOException ; protected boolean customBoost ( ) { return false ; } public Iterator < Mapper > iterator ( ) { if ( multiFields = = null ) { return Collections . emptyIterator ( ) ; } return multiFields . iterator ( ) ; } @Override public void merge ( Mapper mergeWith , MergeResult mergeResult ) { if ( ! this . getClass ( ) . equals ( mergeWith . getClass ( ) ) ) { String mergedType = mergeWith . getClass ( ) . getSimpleName ( ) ; if ( mergeWith instanceof FieldMapper ) { mergedType = ( ( FieldMapper ) mergeWith ) . contentType ( ) ; } mergeResult . addConflict ( <str> + fieldType ( ) . names ( ) . fullName ( ) + <str> + contentType ( ) + <str> + mergedType + <str> ) ; return ; } FieldMapper fieldMergeWith = ( FieldMapper ) mergeWith ; multiFields . merge ( mergeWith , mergeResult ) ; if ( mergeResult . simulate ( ) = = false & & mergeResult . hasConflicts ( ) = = false ) { MappedFieldType fieldType = fieldMergeWith . fieldType ( ) . clone ( ) ; fieldType . freeze ( ) ; fieldTypeRef . set ( fieldType ) ; this . copyTo = fieldMergeWith . copyTo ; } } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( simpleName ( ) ) ; boolean includeDefaults = params . paramAsBoolean ( <str> , false ) ; doXContentBody ( builder , includeDefaults , params ) ; return builder . endObject ( ) ; } protected void doXContentBody ( XContentBuilder builder , boolean includeDefaults , Params params ) throws IOException { builder . field ( <str> , contentType ( ) ) ; if ( indexCreatedBefore2x & & ( includeDefaults | | ! simpleName ( ) . equals ( fieldType ( ) . names ( ) . originalIndexName ( ) ) ) ) { builder . field ( <str> , fieldType ( ) . names ( ) . originalIndexName ( ) ) ; } if ( includeDefaults | | fieldType ( ) . boost ( ) ! = <float> ) { builder . field ( <str> , fieldType ( ) . boost ( ) ) ; } boolean indexed = fieldType ( ) . indexOptions ( ) ! = IndexOptions . NONE ; boolean defaultIndexed = defaultFieldType . indexOptions ( ) ! = IndexOptions . NONE ; if ( includeDefaults | | indexed ! = defaultIndexed | | fieldType ( ) . tokenized ( ) ! = defaultFieldType . tokenized ( ) ) { builder . field ( <str> , indexTokenizeOptionToString ( indexed , fieldType ( ) . tokenized ( ) ) ) ; } if ( includeDefaults | | fieldType ( ) . stored ( ) ! = defaultFieldType . stored ( ) ) { builder . field ( <str> , fieldType ( ) . stored ( ) ) ; } doXContentDocValues ( builder , includeDefaults ) ; if ( includeDefaults | | fieldType ( ) . storeTermVectors ( ) ! = defaultFieldType . storeTermVectors ( ) ) { builder . field ( <str> , termVectorOptionsToString ( fieldType ( ) ) ) ; } if ( includeDefaults | | fieldType ( ) . omitNorms ( ) ! = defaultFieldType . omitNorms ( ) | | fieldType ( ) . normsLoading ( ) ! = null ) { builder . startObject ( <str> ) ; if ( includeDefaults | | fieldType ( ) . omitNorms ( ) ! = defaultFieldType . omitNorms ( ) ) { builder . field ( <str> , ! fieldType ( ) . omitNorms ( ) ) ; } if ( fieldType ( ) . normsLoading ( ) ! = null ) { builder . field ( MappedFieldType . Loading . KEY , fieldType ( ) . normsLoading ( ) ) ; } builder . endObject ( ) ; } if ( indexed & & ( includeDefaults | | fieldType ( ) . indexOptions ( ) ! = defaultFieldType . indexOptions ( ) ) ) { builder . field ( <str> , indexOptionToString ( fieldType ( ) . indexOptions ( ) ) ) ; } doXContentAnalyzers ( builder , includeDefaults ) ; if ( fieldType ( ) . similarity ( ) ! = null ) { builder . field ( <str> , fieldType ( ) . similarity ( ) . name ( ) ) ; } else if ( includeDefaults ) { builder . field ( <str> , SimilarityService . DEFAULT_SIMILARITY ) ; } if ( includeDefaults | | hasCustomFieldDataSettings ( ) ) { builder . field ( <str> , fieldType ( ) . fieldDataType ( ) . getSettings ( ) . getAsMap ( ) ) ; } multiFields . toXContent ( builder , params ) ; if ( copyTo ! = null ) { copyTo . toXContent ( builder , params ) ; } } protected void doXContentAnalyzers ( XContentBuilder builder , boolean includeDefaults ) throws IOException { if ( fieldType ( ) . indexAnalyzer ( ) = = null ) { if ( includeDefaults ) { builder . field ( <str> , <str> ) ; } } else if ( includeDefaults | | fieldType ( ) . indexAnalyzer ( ) . name ( ) . startsWith ( <str> ) = = false & & fieldType ( ) . indexAnalyzer ( ) . name ( ) . equals ( <str> ) = = false ) { builder . field ( <str> , fieldType ( ) . indexAnalyzer ( ) . name ( ) ) ; if ( fieldType ( ) . searchAnalyzer ( ) . name ( ) . equals ( fieldType ( ) . indexAnalyzer ( ) . name ( ) ) = = false ) { builder . field ( <str> , fieldType ( ) . searchAnalyzer ( ) . name ( ) ) ; } } } protected void doXContentDocValues ( XContentBuilder builder , boolean includeDefaults ) throws IOException { if ( includeDefaults | | defaultFieldType . hasDocValues ( ) ! = fieldType ( ) . hasDocValues ( ) ) { builder . field ( <str> , fieldType ( ) . hasDocValues ( ) ) ; } } protected static String indexOptionToString ( IndexOptions indexOption ) { switch ( indexOption ) { case DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS : return TypeParsers . INDEX_OPTIONS_OFFSETS ; case DOCS_AND_FREQS : return TypeParsers . INDEX_OPTIONS_FREQS ; case DOCS_AND_FREQS_AND_POSITIONS : return TypeParsers . INDEX_OPTIONS_POSITIONS ; case DOCS : return TypeParsers . INDEX_OPTIONS_DOCS ; default : throw new IllegalArgumentException ( <str> + indexOption + <str> ) ; } } public static String termVectorOptionsToString ( FieldType fieldType ) { if ( ! fieldType . storeTermVectors ( ) ) { return <str> ; } else if ( ! fieldType . storeTermVectorOffsets ( ) & & ! fieldType . storeTermVectorPositions ( ) ) { return <str> ; } else if ( fieldType . storeTermVectorOffsets ( ) & & ! fieldType . storeTermVectorPositions ( ) ) { return <str> ; } else { StringBuilder builder = new StringBuilder ( <str> ) ; if ( fieldType . storeTermVectorPositions ( ) ) { builder . append ( <str> ) ; } if ( fieldType . storeTermVectorOffsets ( ) ) { builder . append ( <str> ) ; } if ( fieldType . storeTermVectorPayloads ( ) ) { builder . append ( <str> ) ; } return builder . toString ( ) ; } } protected static String indexTokenizeOptionToString ( boolean indexed , boolean tokenized ) { if ( ! indexed ) { return <str> ; } else if ( tokenized ) { return <str> ; } else { return <str> ; } } protected boolean hasCustomFieldDataSettings ( ) { return fieldType ( ) . fieldDataType ( ) ! = null & & fieldType ( ) . fieldDataType ( ) . equals ( defaultFieldType . fieldDataType ( ) ) = = false ; } protected abstract String contentType ( ) ; public static class MultiFields { public static MultiFields empty ( ) { return new MultiFields ( ContentPath . Type . FULL , ImmutableOpenMap . < String , FieldMapper > of ( ) ) ; } public static class Builder { private final ImmutableOpenMap . Builder < String , Mapper . Builder > mapperBuilders = ImmutableOpenMap . builder ( ) ; private ContentPath . Type pathType = ContentPath . Type . FULL ; public Builder pathType ( ContentPath . Type pathType ) { this . pathType = pathType ; return this ; } public Builder add ( Mapper . Builder builder ) { mapperBuilders . put ( builder . name ( ) , builder ) ; return this ; } @SuppressWarnings ( <str> ) public MultiFields build ( FieldMapper . Builder mainFieldBuilder , BuilderContext context ) { if ( pathType = = ContentPath . Type . FULL & & mapperBuilders . isEmpty ( ) ) { return empty ( ) ; } else if ( mapperBuilders . isEmpty ( ) ) { return new MultiFields ( pathType , ImmutableOpenMap . < String , FieldMapper > of ( ) ) ; } else { ContentPath . Type origPathType = context . path ( ) . pathType ( ) ; context . path ( ) . pathType ( pathType ) ; context . path ( ) . add ( mainFieldBuilder . name ( ) ) ; ImmutableOpenMap . Builder mapperBuilders = this . mapperBuilders ; for ( ObjectObjectCursor < String , Mapper . Builder > cursor : this . mapperBuilders ) { String key = cursor . key ; Mapper . Builder value = cursor . value ; Mapper mapper = value . build ( context ) ; assert mapper instanceof FieldMapper ; mapperBuilders . put ( key , mapper ) ; } context . path ( ) . remove ( ) ; context . path ( ) . pathType ( origPathType ) ; ImmutableOpenMap . Builder < String , FieldMapper > mappers = mapperBuilders . cast ( ) ; return new MultiFields ( pathType , mappers . build ( ) ) ; } } } private final ContentPath . Type pathType ; private volatile ImmutableOpenMap < String , FieldMapper > mappers ; public MultiFields ( ContentPath . Type pathType , ImmutableOpenMap < String , FieldMapper > mappers ) { this . pathType = pathType ; this . mappers = mappers ; for ( ObjectCursor < FieldMapper > cursor : mappers . values ( ) ) { FieldMapper mapper = cursor . value ; if ( mapper instanceof AllFieldMapper . IncludeInAll ) { ( ( AllFieldMapper . IncludeInAll ) mapper ) . unsetIncludeInAll ( ) ; } } } public void parse ( FieldMapper mainField , ParseContext context ) throws IOException { if ( mappers . isEmpty ( ) ) { return ; } context = context . createMultiFieldContext ( ) ; ContentPath . Type origPathType = context . path ( ) . pathType ( ) ; context . path ( ) . pathType ( pathType ) ; context . path ( ) . add ( mainField . simpleName ( ) ) ; for ( ObjectCursor < FieldMapper > cursor : mappers . values ( ) ) { cursor . value . parse ( context ) ; } context . path ( ) . remove ( ) ; context . path ( ) . pathType ( origPathType ) ; } public void merge ( Mapper mergeWith , MergeResult mergeResult ) { FieldMapper mergeWithMultiField = ( FieldMapper ) mergeWith ; List < FieldMapper > newFieldMappers = null ; ImmutableOpenMap . Builder < String , FieldMapper > newMappersBuilder = null ; for ( ObjectCursor < FieldMapper > cursor : mergeWithMultiField . multiFields . mappers . values ( ) ) { FieldMapper mergeWithMapper = cursor . value ; Mapper mergeIntoMapper = mappers . get ( mergeWithMapper . simpleName ( ) ) ; if ( mergeIntoMapper = = null ) { if ( ! mergeResult . simulate ( ) ) { if ( mergeWithMapper instanceof AllFieldMapper . IncludeInAll ) { ( ( AllFieldMapper . IncludeInAll ) mergeWithMapper ) . unsetIncludeInAll ( ) ; } if ( newMappersBuilder = = null ) { newMappersBuilder = ImmutableOpenMap . builder ( mappers ) ; } newMappersBuilder . put ( mergeWithMapper . simpleName ( ) , mergeWithMapper ) ; if ( mergeWithMapper instanceof FieldMapper ) { if ( newFieldMappers = = null ) { newFieldMappers = new ArrayList < > ( <int> ) ; } newFieldMappers . add ( mergeWithMapper ) ; } } } else { mergeIntoMapper . merge ( mergeWithMapper , mergeResult ) ; } } if ( newFieldMappers ! = null ) { mergeResult . addFieldMappers ( newFieldMappers ) ; } if ( newMappersBuilder ! = null ) { mappers = newMappersBuilder . build ( ) ; } } public Iterator < Mapper > iterator ( ) { return StreamSupport . stream ( mappers . values ( ) . spliterator ( ) , false ) . map ( ( p ) - > ( Mapper ) p . value ) . iterator ( ) ; } public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { if ( pathType ! = ContentPath . Type . FULL ) { builder . field ( <str> , pathType . name ( ) . toLowerCase ( Locale . ROOT ) ) ; } if ( ! mappers . isEmpty ( ) ) { Mapper [ ] sortedMappers = mappers . values ( ) . toArray ( Mapper . class ) ; Arrays . sort ( sortedMappers , new Comparator < Mapper > ( ) { @Override public int compare ( Mapper o1 , Mapper o2 ) { return o1 . name ( ) . compareTo ( o2 . name ( ) ) ; } } ) ; builder . startObject ( <str> ) ; for ( Mapper mapper : sortedMappers ) { mapper . toXContent ( builder , params ) ; } builder . endObject ( ) ; } return builder ; } } public static class CopyTo { private final List < String > copyToFields ; private CopyTo ( List < String > copyToFields ) { this . copyToFields = copyToFields ; } public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { if ( ! copyToFields . isEmpty ( ) ) { builder . startArray ( <str> ) ; for ( String field : copyToFields ) { builder . value ( field ) ; } builder . endArray ( ) ; } return builder ; } public static class Builder { private final List < String > copyToBuilders = new ArrayList < > ( ) ; public Builder add ( String field ) { copyToBuilders . add ( field ) ; return this ; } public CopyTo build ( ) { return new CopyTo ( Collections . unmodifiableList ( copyToBuilders ) ) ; } } public List < String > copyToFields ( ) { return copyToFields ; } } public boolean isGenerated ( ) { return false ; } } 
