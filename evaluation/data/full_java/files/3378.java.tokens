package org . nd4j . linalg . jcublas . kernel ; import jcuda . Pointer ; import jcuda . Sizeof ; import jcuda . driver . CUfunction ; import jcuda . driver . CUstream ; import jcuda . runtime . JCuda ; import jcuda . runtime . cudaMemcpyKind ; import jcuda . utils . KernelLauncher ; import org . nd4j . linalg . jcublas . SimpleJCublas ; import org . nd4j . linalg . jcublas . buffer . CudaDoubleDataBuffer ; import org . nd4j . linalg . jcublas . buffer . CudaFloatDataBuffer ; import org . nd4j . linalg . jcublas . buffer . JCudaBuffer ; import org . nd4j . linalg . jcublas . context . ContextHolder ; import org . nd4j . linalg . io . ClassPathResource ; import java . io . IOException ; import java . util . Properties ; import java . util . Set ; import java . util . concurrent . ConcurrentSkipListSet ; import static jcuda . driver . JCudaDriver . cuCtxSynchronize ; import static jcuda . driver . JCudaDriver . cuLaunchKernel ; public class KernelFunctions { public final static String NAME_SPACE = <str> ; public final static String DOUBLE = NAME_SPACE + <str> ; public final static String FLOAT = NAME_SPACE + <str> ; public final static String REDUCE = NAME_SPACE + <str> ; public final static String SHARED_MEM_KEY = NAME_SPACE + <str> ; public final static String THREADS_KEY = NAME_SPACE + <str> ; public final static String BLOCKS_KEY = NAME_SPACE + <str> ; public static int SHARED_MEM = <int> ; public static int THREADS = <int> ; public static int BLOCKS = <int> ; private static Set < String > reduceFunctions = new ConcurrentSkipListSet < > ( ) ; private KernelFunctions ( ) { } static { try { register ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public static void register ( ) throws Exception { ClassPathResource res = new ClassPathResource ( <str> , KernelFunctions . class . getClassLoader ( ) ) ; if ( ! res . exists ( ) ) throw new IllegalStateException ( <str> ) ; Properties props = new Properties ( ) ; props . load ( res . getInputStream ( ) ) ; KernelFunctionLoader . getInstance ( ) . load ( ) ; String reduceFunctionsList = props . getProperty ( REDUCE ) ; for ( String function : reduceFunctionsList . split ( <str> ) ) reduceFunctions . add ( function ) ; SHARED_MEM = Integer . parseInt ( props . getProperty ( SHARED_MEM_KEY , <str> ) ) ; THREADS = Integer . parseInt ( props . getProperty ( THREADS_KEY , <str> ) ) ; BLOCKS = Integer . parseInt ( props . getProperty ( BLOCKS_KEY , <str> ) ) ; } public static void invoke ( int blocks , int threadsPerBlock , String functionName , String dataType , Object . . . kernelParameters ) { CUstream stream = ContextHolder . getInstance ( ) . getStream ( ) ; int sharedMemSize = threadsPerBlock * ( dataType . equals ( <str> ) ? Sizeof . FLOAT : Sizeof . DOUBLE ) * <int> ; KernelLauncher launcher = KernelFunctionLoader . launcher ( functionName , dataType ) ; if ( launcher = = null ) throw new IllegalArgumentException ( <str> + functionName + <str> + dataType + <str> ) ; launcher . forFunction ( functionName + <str> + dataType ) . setBlockSize ( threadsPerBlock , <int> , <int> ) . setGridSize ( blocks , <int> , <int> ) . setStream ( stream ) . setSharedMemSize ( sharedMemSize ) . call ( kernelParameters ) ; ContextHolder . syncStream ( ) ; } public static JCudaBuffer alloc ( double [ ] data ) { JCudaBuffer doubleBuffer = new CudaDoubleDataBuffer ( data ) ; return doubleBuffer ; } public static JCudaBuffer alloc ( float [ ] data ) { JCudaBuffer floatBuffer = new CudaFloatDataBuffer ( data ) ; return floatBuffer ; } } 
