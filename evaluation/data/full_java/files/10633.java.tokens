package com . google . common . util . concurrent ; import junit . framework . * ; import java . util . Arrays ; public class AtomicDoubleArrayTest extends JSR166TestCase { private static final double [ ] VALUES = { Double . NEGATIVE_INFINITY , - Double . MAX_VALUE , ( double ) Long . MIN_VALUE , ( double ) Integer . MIN_VALUE , - Math . PI , - <float> , - Double . MIN_VALUE , - <float> , + <float> , Double . MIN_VALUE , <float> , Math . PI , ( double ) Integer . MAX_VALUE , ( double ) Long . MAX_VALUE , Double . MAX_VALUE , Double . POSITIVE_INFINITY , Double . NaN , Float . MAX_VALUE , } ; static boolean bitEquals ( double x , double y ) { return Double . doubleToRawLongBits ( x ) = = Double . doubleToRawLongBits ( y ) ; } static void assertBitEquals ( double x , double y ) { assertEquals ( Double . doubleToRawLongBits ( x ) , Double . doubleToRawLongBits ( y ) ) ; } public void testConstructor ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int i = <int> ; i < SIZE ; i + + ) { assertBitEquals ( <float> , aa . get ( i ) ) ; } } public void testConstructor2NPE ( ) { try { double [ ] a = null ; AtomicDoubleArray aa = new AtomicDoubleArray ( a ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } } public void testConstructor2 ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( VALUES ) ; assertEquals ( VALUES . length , aa . length ( ) ) ; for ( int i = <int> ; i < VALUES . length ; i + + ) { assertBitEquals ( VALUES [ i ] , aa . get ( i ) ) ; } } public void testConstructorEmptyArray ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( new double [ <int> ] ) ; assertEquals ( <int> , aa . length ( ) ) ; try { aa . get ( <int> ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } } public void testConstructorZeroLength ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( <int> ) ; assertEquals ( <int> , aa . length ( ) ) ; try { aa . get ( <int> ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } } public void testIndexing ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int index : new int [ ] { - <int> , SIZE } ) { try { aa . get ( index ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } try { aa . set ( index , <float> ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } try { aa . lazySet ( index , <float> ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } try { aa . compareAndSet ( index , <float> , <float> ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } try { aa . weakCompareAndSet ( index , <float> , <float> ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } try { aa . getAndAdd ( index , <float> ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } try { aa . addAndGet ( index , <float> ) ; shouldThrow ( ) ; } catch ( IndexOutOfBoundsException success ) { } } } public void testGetSet ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( VALUES . length ) ; for ( int i = <int> ; i < VALUES . length ; i + + ) { assertBitEquals ( <float> , aa . get ( i ) ) ; aa . set ( i , VALUES [ i ] ) ; assertBitEquals ( VALUES [ i ] , aa . get ( i ) ) ; aa . set ( i , - <float> ) ; assertBitEquals ( - <float> , aa . get ( i ) ) ; } } public void testGetLazySet ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( VALUES . length ) ; for ( int i = <int> ; i < VALUES . length ; i + + ) { assertBitEquals ( <float> , aa . get ( i ) ) ; aa . lazySet ( i , VALUES [ i ] ) ; assertBitEquals ( VALUES [ i ] , aa . get ( i ) ) ; aa . lazySet ( i , - <float> ) ; assertBitEquals ( - <float> , aa . get ( i ) ) ; } } public void testCompareAndSet ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int i : new int [ ] { <int> , SIZE - <int> } ) { double prev = <float> ; double unused = Math . E + Math . PI ; for ( double x : VALUES ) { assertBitEquals ( prev , aa . get ( i ) ) ; assertFalse ( aa . compareAndSet ( i , unused , x ) ) ; assertBitEquals ( prev , aa . get ( i ) ) ; assertTrue ( aa . compareAndSet ( i , prev , x ) ) ; assertBitEquals ( x , aa . get ( i ) ) ; prev = x ; } } } public void testCompareAndSetInMultipleThreads ( ) throws InterruptedException { final AtomicDoubleArray a = new AtomicDoubleArray ( <int> ) ; a . set ( <int> , <float> ) ; Thread t = newStartedThread ( new CheckedRunnable ( ) { public void realRun ( ) { while ( ! a . compareAndSet ( <int> , <float> , <float> ) ) { Thread . yield ( ) ; } } } ) ; assertTrue ( a . compareAndSet ( <int> , <float> , <float> ) ) ; awaitTermination ( t ) ; assertBitEquals ( <float> , a . get ( <int> ) ) ; } public void testWeakCompareAndSet ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int i : new int [ ] { <int> , SIZE - <int> } ) { double prev = <float> ; double unused = Math . E + Math . PI ; for ( double x : VALUES ) { assertBitEquals ( prev , aa . get ( i ) ) ; assertFalse ( aa . weakCompareAndSet ( i , unused , x ) ) ; assertBitEquals ( prev , aa . get ( i ) ) ; while ( ! aa . weakCompareAndSet ( i , prev , x ) ) { ; } assertBitEquals ( x , aa . get ( i ) ) ; prev = x ; } } } public void testGetAndSet ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int i : new int [ ] { <int> , SIZE - <int> } ) { double prev = <float> ; for ( double x : VALUES ) { assertBitEquals ( prev , aa . getAndSet ( i , x ) ) ; prev = x ; } } } public void testGetAndAdd ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int i : new int [ ] { <int> , SIZE - <int> } ) { for ( double x : VALUES ) { for ( double y : VALUES ) { aa . set ( i , x ) ; double z = aa . getAndAdd ( i , y ) ; assertBitEquals ( x , z ) ; assertBitEquals ( x + y , aa . get ( i ) ) ; } } } } public void testAddAndGet ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int i : new int [ ] { <int> , SIZE - <int> } ) { for ( double x : VALUES ) { for ( double y : VALUES ) { aa . set ( i , x ) ; double z = aa . addAndGet ( i , y ) ; assertBitEquals ( x + y , z ) ; assertBitEquals ( x + y , aa . get ( i ) ) ; } } } } static final long COUNTDOWN = <int> ; class Counter extends CheckedRunnable { final AtomicDoubleArray aa ; volatile long counts ; Counter ( AtomicDoubleArray a ) { aa = a ; } public void realRun ( ) { for ( ; ; ) { boolean done = true ; for ( int i = <int> ; i < aa . length ( ) ; i + + ) { double v = aa . get ( i ) ; assertTrue ( v > = <int> ) ; if ( v ! = <int> ) { done = false ; if ( aa . compareAndSet ( i , v , v - <float> ) ) { + + counts ; } } } if ( done ) { break ; } } } } public void testCountingInMultipleThreads ( ) throws InterruptedException { final AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int i = <int> ; i < SIZE ; i + + ) { aa . set ( i , ( double ) COUNTDOWN ) ; } Counter c1 = new Counter ( aa ) ; Counter c2 = new Counter ( aa ) ; Thread t1 = newStartedThread ( c1 ) ; Thread t2 = newStartedThread ( c2 ) ; awaitTermination ( t1 ) ; awaitTermination ( t2 ) ; assertEquals ( c1 . counts + c2 . counts , SIZE * COUNTDOWN ) ; } public void testSerialization ( ) throws Exception { AtomicDoubleArray x = new AtomicDoubleArray ( SIZE ) ; for ( int i = <int> ; i < SIZE ; i + + ) { x . set ( i , ( double ) - i ) ; } AtomicDoubleArray y = serialClone ( x ) ; assertTrue ( x ! = y ) ; assertEquals ( x . length ( ) , y . length ( ) ) ; for ( int i = <int> ; i < SIZE ; i + + ) { assertBitEquals ( x . get ( i ) , y . get ( i ) ) ; } AtomicDoubleArray a = new AtomicDoubleArray ( VALUES ) ; AtomicDoubleArray b = serialClone ( a ) ; assertFalse ( a . equals ( b ) ) ; assertFalse ( b . equals ( a ) ) ; assertEquals ( a . length ( ) , b . length ( ) ) ; for ( int i = <int> ; i < VALUES . length ; i + + ) { assertBitEquals ( a . get ( i ) , b . get ( i ) ) ; } } public void testToString ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( VALUES ) ; assertEquals ( Arrays . toString ( VALUES ) , aa . toString ( ) ) ; assertEquals ( <str> , new AtomicDoubleArray ( <int> ) . toString ( ) ) ; assertEquals ( <str> , new AtomicDoubleArray ( new double [ <int> ] ) . toString ( ) ) ; } public void testDistinctZeros ( ) { AtomicDoubleArray aa = new AtomicDoubleArray ( SIZE ) ; for ( int i : new int [ ] { <int> , SIZE - <int> } ) { assertFalse ( aa . compareAndSet ( i , - <float> , <float> ) ) ; assertFalse ( aa . weakCompareAndSet ( i , - <float> , <float> ) ) ; assertBitEquals ( + <float> , aa . get ( i ) ) ; assertTrue ( aa . compareAndSet ( i , + <float> , - <float> ) ) ; assertBitEquals ( - <float> , aa . get ( i ) ) ; assertFalse ( aa . compareAndSet ( i , + <float> , <float> ) ) ; assertFalse ( aa . weakCompareAndSet ( i , + <float> , <float> ) ) ; assertBitEquals ( - <float> , aa . get ( i ) ) ; } } } 
