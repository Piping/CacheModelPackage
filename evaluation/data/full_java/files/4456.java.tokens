package org . eclipse . debug . internal . ui . viewers . provisional ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . internal . ui . viewers . AsynchronousSchedulingRuleFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . views . launch . DebugElementHelper ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . ui . progress . UIJob ; public abstract class AsynchronousLabelAdapter implements IAsynchronousLabelAdapter { @Override public void retrieveLabel ( final Object element , final IPresentationContext context , final ILabelRequestMonitor result ) { Job job = null ; if ( requiresUIJob ( element ) ) { job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { computeLabels ( element , context , result ) ; return Status . OK_STATUS ; } } ; } else { job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { computeLabels ( element , context , result ) ; return Status . OK_STATUS ; } } ; } job . setSystem ( true ) ; job . setRule ( getLabelRule ( element , context ) ) ; job . schedule ( ) ; } protected ISchedulingRule getLabelRule ( Object element , IPresentationContext context ) { return AsynchronousSchedulingRuleFactory . getDefault ( ) . newSerialPerObjectRule ( context ) ; } protected boolean requiresUIJob ( Object object ) { return ! DebugElementHelper . requiresUIThread ( object ) ; } protected void computeLabels ( Object element , IPresentationContext context , ILabelRequestMonitor monitor ) { if ( ! monitor . isCanceled ( ) ) { IStatus status = Status . OK_STATUS ; try { monitor . setLabels ( getLabels ( element , context ) ) ; if ( ! monitor . isCanceled ( ) ) { monitor . setImageDescriptors ( getImageDescriptors ( element , context ) ) ; } if ( ! monitor . isCanceled ( ) ) { monitor . setFontDatas ( getFontDatas ( element , context ) ) ; } if ( ! monitor . isCanceled ( ) ) { monitor . setBackgrounds ( getBackgrounds ( element , context ) ) ; } if ( ! monitor . isCanceled ( ) ) { monitor . setForegrounds ( getForegrounds ( element , context ) ) ; } } catch ( CoreException e ) { status = e . getStatus ( ) ; } if ( ! monitor . isCanceled ( ) ) { monitor . setStatus ( status ) ; monitor . done ( ) ; } } } protected abstract String [ ] getLabels ( Object element , IPresentationContext context ) throws CoreException ; protected abstract ImageDescriptor [ ] getImageDescriptors ( Object element , IPresentationContext context ) throws CoreException ; protected abstract FontData [ ] getFontDatas ( Object element , IPresentationContext context ) throws CoreException ; protected abstract RGB [ ] getForegrounds ( Object element , IPresentationContext context ) throws CoreException ; protected abstract RGB [ ] getBackgrounds ( Object element , IPresentationContext context ) throws CoreException ; } 
