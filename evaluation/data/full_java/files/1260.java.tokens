package org . apache . cassandra . utils . btree ; import java . util . Arrays ; import java . util . Comparator ; import static org . apache . cassandra . utils . btree . BTree . * ; class TreeCursor < K > extends NodeCursor < K > { NodeCursor < K > cur ; TreeCursor ( Comparator < ? super K > comparator , Object [ ] node ) { super ( node , null , comparator ) ; } void reset ( boolean start ) { cur = root ( ) ; root ( ) . inChild = false ; root ( ) . position = start ? - <int> : getKeyEnd ( root ( ) . node ) ; } int moveOne ( boolean forwards ) { NodeCursor < K > cur = this . cur ; if ( cur . isLeaf ( ) ) { if ( cur . advanceLeafNode ( forwards ) ) return cur . globalLeafIndex ( ) ; this . cur = cur = moveOutOfLeaf ( forwards , cur , root ( ) ) ; return cur . globalIndex ( ) ; } if ( forwards ) + + cur . position ; cur = cur . descend ( ) ; NodeCursor < K > next ; while ( null ! = ( next = cur . descendToFirstChild ( forwards ) ) ) cur = next ; this . cur = cur ; return cur . globalLeafIndex ( ) ; } boolean seekTo ( K key , boolean forwards , boolean skipOne ) { NodeCursor < K > cur = this . cur ; boolean tryOne = ! skipOne ; if ( ( ! tryOne & cur . isLeaf ( ) ) & & ! ( tryOne = ( cur . advanceLeafNode ( forwards ) | | ( cur = moveOutOfLeaf ( forwards , cur , null ) ) ! = null ) ) ) { this . cur = root ( ) ; return false ; } if ( tryOne ) { K test = cur . value ( ) ; int cmp ; if ( key = = test ) cmp = <int> ; else cmp = comparator . compare ( test , key ) ; if ( forwards ? cmp > = <int> : cmp < = <int> ) { this . cur = cur ; return cmp = = <int> ; } } while ( cur ! = root ( ) ) { NodeCursor < K > bound = cur . boundIterator ( forwards ) ; if ( bound = = null ) break ; int cmpbound = comparator . compare ( bound . bound ( forwards ) , key ) ; if ( forwards ? cmpbound > <int> : cmpbound < <int> ) break ; cur = bound ; cur . safeAdvanceIntoBranchFromChild ( forwards ) ; if ( cmpbound = = <int> ) { this . cur = cur ; return true ; } } boolean match ; while ( ! ( match = cur . seekInNode ( key , forwards ) ) & & ! cur . isLeaf ( ) ) { cur = cur . descend ( ) ; cur . position = forwards ? - <int> : getKeyEnd ( cur . node ) ; } if ( ! match ) cur = ensureValidLocation ( forwards , cur ) ; this . cur = cur ; assert ! cur . inChild ; return match ; } private NodeCursor < K > ensureValidLocation ( boolean forwards , NodeCursor < K > cur ) { assert cur . isLeaf ( ) ; int position = cur . position ; if ( ( position < <int> ) | ( position > = getLeafKeyEnd ( cur . node ) ) ) cur = moveOutOfLeaf ( forwards , cur , root ( ) ) ; return cur ; } private < K > NodeCursor < K > moveOutOfLeaf ( boolean forwards , NodeCursor < K > cur , NodeCursor < K > ifFail ) { while ( true ) { cur = cur . parent ; if ( cur = = null ) { root ( ) . inChild = false ; return ifFail ; } if ( cur . advanceIntoBranchFromChild ( forwards ) ) break ; } cur . inChild = false ; return cur ; } void seekTo ( int index ) { if ( ( index < <int> ) | ( index > = BTree . size ( rootNode ( ) ) ) ) { if ( ( index < - <int> ) | ( index > BTree . size ( rootNode ( ) ) ) ) throw new IndexOutOfBoundsException ( index + <str> + BTree . size ( rootNode ( ) ) + <str> ) ; reset ( index = = - <int> ) ; return ; } NodeCursor < K > cur = this . cur ; cur = root ( ) ; assert cur . nodeOffset = = <int> ; while ( true ) { int relativeIndex = index - cur . nodeOffset ; Object [ ] node = cur . node ; if ( cur . isLeaf ( ) ) { assert relativeIndex < getLeafKeyEnd ( node ) ; cur . position = relativeIndex ; this . cur = cur ; return ; } int [ ] sizeMap = getSizeMap ( node ) ; int boundary = Arrays . binarySearch ( sizeMap , relativeIndex ) ; if ( boundary > = <int> ) { assert boundary < sizeMap . length - <int> ; cur . position = boundary ; cur . inChild = false ; this . cur = cur ; return ; } cur . inChild = true ; cur . position = - <int> - boundary ; cur = cur . descend ( ) ; } } private NodeCursor < K > root ( ) { return this ; } Object [ ] rootNode ( ) { return this . node ; } K currentValue ( ) { return cur . value ( ) ; } } 
