package com . google . common . graph ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . graph . GraphErrorMessageUtils . EDGE_NOT_IN_GRAPH ; import static com . google . common . graph . GraphErrorMessageUtils . NODE_NOT_IN_GRAPH ; import static com . google . common . graph . Graphs . oppositeNode ; import com . google . common . annotations . Beta ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Sets ; import java . util . Collections ; import java . util . Set ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @Beta public final class ImmutableUndirectedGraph < N , E > extends AbstractImmutableGraph < N , E > implements UndirectedGraph < N , E > { private final ImmutableMap < N , ImmutableSet < E > > nodeToIncidentEdges ; private final ImmutableMap < E , ImmutableSet < N > > edgeToIncidentNodes ; private final GraphConfig config ; private ImmutableUndirectedGraph ( Builder < N , E > builder ) { UndirectedGraph < N , E > undirectedGraph = builder . undirectedGraph ; ImmutableMap . Builder < N , ImmutableSet < E > > nodeToEdgesBuilder = ImmutableMap . builder ( ) ; for ( N node : undirectedGraph . nodes ( ) ) { nodeToEdgesBuilder . put ( node , ImmutableSet . copyOf ( undirectedGraph . incidentEdges ( node ) ) ) ; } nodeToIncidentEdges = nodeToEdgesBuilder . build ( ) ; ImmutableMap . Builder < E , ImmutableSet < N > > edgeToNodesBuilder = ImmutableMap . builder ( ) ; for ( E edge : undirectedGraph . edges ( ) ) { edgeToNodesBuilder . put ( edge , ImmutableSet . copyOf ( undirectedGraph . incidentNodes ( edge ) ) ) ; } edgeToIncidentNodes = edgeToNodesBuilder . build ( ) ; config = undirectedGraph . config ( ) ; } @Override public Set < N > nodes ( ) { return nodeToIncidentEdges . keySet ( ) ; } @Override public Set < E > edges ( ) { return edgeToIncidentNodes . keySet ( ) ; } @Override public GraphConfig config ( ) { return config ; } @Override public Set < E > incidentEdges ( Object node ) { checkNotNull ( node , <str> ) ; Set < E > incidentEdges = nodeToIncidentEdges . get ( node ) ; checkArgument ( incidentEdges ! = null , NODE_NOT_IN_GRAPH , node ) ; return incidentEdges ; } @Override public Set < N > incidentNodes ( Object edge ) { checkNotNull ( edge , <str> ) ; Set < N > incidentNodes = edgeToIncidentNodes . get ( edge ) ; checkArgument ( incidentNodes ! = null , EDGE_NOT_IN_GRAPH , edge ) ; return incidentNodes ; } @Override public Set < N > adjacentNodes ( Object node ) { ImmutableSet . Builder < N > adjacentNodesBuilder = ImmutableSet . builder ( ) ; for ( E edge : incidentEdges ( node ) ) { adjacentNodesBuilder . add ( oppositeNode ( this , edge , node ) ) ; } return adjacentNodesBuilder . build ( ) ; } @Override public Set < E > adjacentEdges ( Object edge ) { Set < E > adjacentEdges = Sets . newLinkedHashSet ( ) ; for ( N node : incidentNodes ( edge ) ) { adjacentEdges . addAll ( incidentEdges ( node ) ) ; } adjacentEdges . remove ( edge ) ; return Collections . unmodifiableSet ( adjacentEdges ) ; } @Override public Set < E > edgesConnecting ( Object node1 , Object node2 ) { checkNotNull ( node1 , <str> ) ; checkNotNull ( node2 , <str> ) ; Set < E > incidentEdgesN1 = incidentEdges ( node1 ) ; if ( node1 . equals ( node2 ) ) { Set < E > returnSet = Sets . newLinkedHashSet ( ) ; for ( E edge : incidentEdgesN1 ) { if ( edgeToIncidentNodes . get ( edge ) . size ( ) = = <int> ) { returnSet . add ( edge ) ; } } return Collections . unmodifiableSet ( returnSet ) ; } Set < E > incidentEdgesN2 = incidentEdges ( node2 ) ; return incidentEdgesN1 . size ( ) < = incidentEdgesN2 . size ( ) ? Sets . intersection ( incidentEdgesN1 , incidentEdgesN2 ) . immutableCopy ( ) : Sets . intersection ( incidentEdgesN2 , incidentEdgesN1 ) . immutableCopy ( ) ; } @Override public Set < E > inEdges ( Object node ) { return incidentEdges ( node ) ; } @Override public Set < E > outEdges ( Object node ) { return incidentEdges ( node ) ; } @Override public Set < N > predecessors ( Object node ) { return adjacentNodes ( node ) ; } @Override public Set < N > successors ( Object node ) { return adjacentNodes ( node ) ; } @Override public long degree ( Object node ) { return incidentEdges ( node ) . size ( ) ; } @Override public long inDegree ( Object node ) { return degree ( node ) ; } @Override public long outDegree ( Object node ) { return degree ( node ) ; } @Override public boolean equals ( @Nullable Object object ) { return ( object instanceof UndirectedGraph ) & & Graphs . equal ( this , ( UndirectedGraph ) object ) ; } @Override public int hashCode ( ) { return nodeToIncidentEdges . hashCode ( ) ; } @CheckReturnValue public static < N , E > Builder < N , E > builder ( ) { return new Builder < N , E > ( ) ; } @CheckReturnValue public static < N , E > Builder < N , E > builder ( GraphConfig config ) { return new Builder < N , E > ( config ) ; } @CheckReturnValue public static < N , E > ImmutableUndirectedGraph < N , E > copyOf ( UndirectedGraph < N , E > graph ) { return new Builder < N , E > ( graph ) . build ( ) ; } @Override public String toString ( ) { return String . format ( <str> , config , nodeToIncidentEdges . keySet ( ) , edgeToIncidentNodes ) ; } public static final class Builder < N , E > implements AbstractImmutableGraph . Builder < N , E > { private final UndirectedGraph < N , E > undirectedGraph ; public Builder ( ) { this ( Graphs . < N , E > createUndirected ( ) ) ; } public Builder ( GraphConfig config ) { this ( Graphs . < N , E > createUndirected ( config ) ) ; } private Builder ( UndirectedGraph < N , E > undirectedGraph ) { this . undirectedGraph = checkNotNull ( undirectedGraph , <str> ) ; } @Override public Builder < N , E > addNode ( N node ) { undirectedGraph . addNode ( node ) ; return this ; } @Override public Builder < N , E > addEdge ( E edge , N node1 , N node2 ) { undirectedGraph . addEdge ( edge , node1 , node2 ) ; return this ; } public Builder < N , E > addGraph ( UndirectedGraph < N , E > graph ) { checkArgument ( undirectedGraph . config ( ) . compatibleWith ( graph . config ( ) ) , <str> + <str> , graph . config ( ) , undirectedGraph . config ( ) ) ; for ( N node : graph . nodes ( ) ) { undirectedGraph . addNode ( node ) ; } for ( E edge : graph . edges ( ) ) { Graphs . addEdge ( undirectedGraph , edge , graph . incidentNodes ( edge ) ) ; } return this ; } @Override @CheckReturnValue public ImmutableUndirectedGraph < N , E > build ( ) { return new ImmutableUndirectedGraph < N , E > ( this ) ; } } } 
