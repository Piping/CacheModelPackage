package org . elasticsearch . index . fielddata ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . StringField ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . RandomAccessOrds ; import org . elasticsearch . common . settings . Settings ; import java . util . Random ; import static org . hamcrest . Matchers . equalTo ; public class FilterFieldDataTests extends AbstractFieldDataTestCase { @Override protected FieldDataType getFieldDataType ( ) { return null ; } public void testFilterByFrequency ( ) throws Exception { Random random = getRandom ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { Document d = new Document ( ) ; d . add ( new StringField ( <str> , <str> + i , Field . Store . NO ) ) ; if ( i % <int> = = <int> ) { d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; } if ( i % <int> = = <int> ) { d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; } if ( i % <int> = = <int> ) { d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; } writer . addDocument ( d ) ; } writer . forceMerge ( <int> , true ) ; LeafReaderContext context = refreshReader ( ) ; String [ ] formats = new String [ ] { <str> } ; for ( String format : formats ) { { ifdService . clear ( ) ; FieldDataType fieldDataType = new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , format ) . put ( <str> , <int> ) . put ( <str> , <float> ) . put ( <str> , random . nextBoolean ( ) ? <int> : <float> ) ) ; IndexOrdinalsFieldData fieldData = getForField ( fieldDataType , <str> ) ; AtomicOrdinalsFieldData loadDirect = fieldData . loadDirect ( context ) ; RandomAccessOrds bytesValues = loadDirect . getOrdinalsValues ( ) ; assertThat ( <int> , equalTo ( bytesValues . getValueCount ( ) ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; } { ifdService . clear ( ) ; FieldDataType fieldDataType = new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , format ) . put ( <str> , <int> ) . put ( <str> , random . nextBoolean ( ) ? <int> : <int> d / <float> ) . put ( <str> , <int> ) ) ; IndexOrdinalsFieldData fieldData = getForField ( fieldDataType , <str> ) ; AtomicOrdinalsFieldData loadDirect = fieldData . loadDirect ( context ) ; RandomAccessOrds bytesValues = loadDirect . getOrdinalsValues ( ) ; assertThat ( <int> , equalTo ( bytesValues . getValueCount ( ) ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; } { ifdService . clear ( ) ; FieldDataType fieldDataType = new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , format ) . put ( <str> , <int> ) . put ( <str> , random . nextBoolean ( ) ? <int> : <int> d / <float> ) ) ; IndexOrdinalsFieldData fieldData = getForField ( fieldDataType , <str> ) ; AtomicOrdinalsFieldData loadDirect = fieldData . loadDirect ( context ) ; RandomAccessOrds bytesValues = loadDirect . getOrdinalsValues ( ) ; assertThat ( <int> , equalTo ( bytesValues . getValueCount ( ) ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; } { ifdService . clear ( ) ; FieldDataType fieldDataType = new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , format ) . put ( <str> , <int> ) . put ( <str> , random . nextBoolean ( ) ? <int> : <int> d / <float> ) ) ; IndexOrdinalsFieldData fieldData = getForField ( fieldDataType , <str> ) ; AtomicOrdinalsFieldData loadDirect = fieldData . loadDirect ( context ) ; RandomAccessOrds bytesValues = loadDirect . getOrdinalsValues ( ) ; assertThat ( <int> , equalTo ( bytesValues . getValueCount ( ) ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; } { ifdService . clear ( ) ; FieldDataType fieldDataType = new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , format ) . put ( <str> , <str> ) . put ( <str> , <int> ) . put ( <str> , random . nextBoolean ( ) ? <int> : <float> / <float> ) . put ( <str> , random . nextBoolean ( ) ? <int> : <int> d / <float> ) ) ; IndexOrdinalsFieldData fieldData = getForField ( fieldDataType , <str> ) ; AtomicOrdinalsFieldData loadDirect = fieldData . loadDirect ( context ) ; RandomAccessOrds bytesValues = loadDirect . getOrdinalsValues ( ) ; assertThat ( <int> , equalTo ( bytesValues . getValueCount ( ) ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; } } } public void testFilterByRegExp ( ) throws Exception { int hundred = <int> ; int ten = <int> ; int five = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { Document d = new Document ( ) ; d . add ( new StringField ( <str> , <str> + i , Field . Store . NO ) ) ; if ( i % <int> = = <int> ) { hundred + + ; d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; } if ( i % <int> = = <int> ) { ten + + ; d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; } if ( i % <int> = = <int> ) { five + + ; d . add ( new StringField ( <str> , <str> , Field . Store . NO ) ) ; } writer . addDocument ( d ) ; } logger . debug ( hundred + <str> + ten + <str> + five ) ; writer . forceMerge ( <int> , true ) ; LeafReaderContext context = refreshReader ( ) ; String [ ] formats = new String [ ] { <str> } ; for ( String format : formats ) { { ifdService . clear ( ) ; FieldDataType fieldDataType = new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , format ) . put ( <str> , <str> ) ) ; IndexOrdinalsFieldData fieldData = getForField ( fieldDataType , <str> ) ; AtomicOrdinalsFieldData loadDirect = fieldData . loadDirect ( context ) ; RandomAccessOrds bytesValues = loadDirect . getOrdinalsValues ( ) ; assertThat ( <int> , equalTo ( bytesValues . getValueCount ( ) ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; } { ifdService . clear ( ) ; FieldDataType fieldDataType = new FieldDataType ( <str> , Settings . builder ( ) . put ( <str> , format ) . put ( <str> , <str> ) ) ; IndexOrdinalsFieldData fieldData = getForField ( fieldDataType , <str> ) ; AtomicOrdinalsFieldData loadDirect = fieldData . loadDirect ( context ) ; RandomAccessOrds bytesValues = loadDirect . getOrdinalsValues ( ) ; assertThat ( <int> , equalTo ( bytesValues . getValueCount ( ) ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; assertThat ( bytesValues . lookupOrd ( <int> ) . utf8ToString ( ) , equalTo ( <str> ) ) ; } } } @Override public void testEmpty ( ) throws Exception { assumeTrue ( <str> , false ) ; } } 
