package org . gradle . api . reporting ; import groovy . lang . Closure ; import org . gradle . api . DefaultTask ; import org . gradle . api . Incubating ; import org . gradle . api . NamedDomainObjectSet ; import org . gradle . api . Transformer ; import org . gradle . api . reporting . internal . BuildDashboardGenerator ; import org . gradle . api . reporting . internal . DefaultBuildDashboardReports ; import org . gradle . api . tasks . Input ; import org . gradle . api . tasks . Nested ; import org . gradle . api . tasks . TaskAction ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . util . CollectionUtils ; import javax . inject . Inject ; import java . io . File ; import java . io . Serializable ; import java . util . Arrays ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . Set ; @Incubating public class GenerateBuildDashboard extends DefaultTask implements Reporting < BuildDashboardReports > { private Set < Reporting < ? extends ReportContainer < ? > > > aggregated = new LinkedHashSet < Reporting < ? extends ReportContainer < ? > > > ( ) ; @Nested private final DefaultBuildDashboardReports reports ; public GenerateBuildDashboard ( ) { reports = getInstantiator ( ) . newInstance ( DefaultBuildDashboardReports . class , this ) ; reports . getHtml ( ) . setEnabled ( true ) ; } @Inject protected Instantiator getInstantiator ( ) { throw new UnsupportedOperationException ( ) ; } @Input public Set < ReportState > getInputReports ( ) { Set < ReportState > inputs = new HashSet < ReportState > ( ) ; for ( Report report : getEnabledInputReports ( ) ) { if ( getReports ( ) . contains ( report ) ) { continue ; } inputs . add ( new ReportState ( report . getDisplayName ( ) , report . getDestination ( ) , report . getDestination ( ) . exists ( ) ) ) ; } return inputs ; } private Set < Report > getEnabledInputReports ( ) { Set < NamedDomainObjectSet < ? extends Report > > enabledReportSets = CollectionUtils . collect ( aggregated , new Transformer < NamedDomainObjectSet < ? extends Report > , Reporting < ? extends ReportContainer < ? > > > ( ) { public NamedDomainObjectSet < ? extends Report > transform ( Reporting < ? extends ReportContainer < ? > > reporting ) { return reporting . getReports ( ) . getEnabled ( ) ; } } ) ; return new LinkedHashSet < Report > ( CollectionUtils . flattenCollections ( Report . class , enabledReportSets ) ) ; } public void aggregate ( Reporting < ? extends ReportContainer < ? > > . . . reportings ) { aggregated . addAll ( Arrays . asList ( reportings ) ) ; } public BuildDashboardReports getReports ( ) { return reports ; } public BuildDashboardReports reports ( Closure closure ) { return ( BuildDashboardReports ) reports . configure ( closure ) ; } @TaskAction void run ( ) { if ( getReports ( ) . getHtml ( ) . isEnabled ( ) ) { BuildDashboardGenerator generator = new BuildDashboardGenerator ( ) ; generator . render ( getEnabledInputReports ( ) , reports . getHtml ( ) . getEntryPoint ( ) ) ; } else { setDidWork ( false ) ; } } private static class ReportState implements Serializable { private final String name ; private final File destination ; private final boolean available ; private ReportState ( String name , File destination , boolean available ) { this . name = name ; this . destination = destination ; this . available = available ; } @Override public boolean equals ( Object obj ) { ReportState other = ( ReportState ) obj ; return name . equals ( other . name ) & & destination . equals ( other . destination ) & & available = = other . available ; } @Override public int hashCode ( ) { return name . hashCode ( ) ^ destination . hashCode ( ) ; } } } 
