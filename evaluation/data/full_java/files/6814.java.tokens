package org . elasticsearch . index . translog ; import org . apache . lucene . codecs . CodecUtil ; import org . apache . lucene . index . CorruptIndexException ; import org . apache . lucene . index . IndexFormatTooNewException ; import org . apache . lucene . index . IndexFormatTooOldException ; import org . apache . lucene . store . AlreadyClosedException ; import org . apache . lucene . store . InputStreamDataInput ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . RamUsageEstimator ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . io . stream . ByteBufferStreamInput ; import org . elasticsearch . common . io . stream . InputStreamStreamInput ; import java . io . Closeable ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . channels . Channels ; import java . nio . channels . FileChannel ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . concurrent . atomic . AtomicBoolean ; public abstract class TranslogReader implements Closeable , Comparable < TranslogReader > { public static final int UNKNOWN_OP_COUNT = - <int> ; private static final byte LUCENE_CODEC_HEADER_BYTE = <hex> ; private static final byte UNVERSIONED_TRANSLOG_HEADER_BYTE = <hex> ; protected final long generation ; protected final ChannelReference channelReference ; protected final FileChannel channel ; protected final AtomicBoolean closed = new AtomicBoolean ( false ) ; protected final long firstOperationOffset ; public TranslogReader ( long generation , ChannelReference channelReference , long firstOperationOffset ) { this . generation = generation ; this . channelReference = channelReference ; this . channel = channelReference . getChannel ( ) ; this . firstOperationOffset = firstOperationOffset ; } public long getGeneration ( ) { return this . generation ; } public abstract long sizeInBytes ( ) ; abstract public int totalOperations ( ) ; public final long getFirstOperationOffset ( ) { return firstOperationOffset ; } public Translog . Operation read ( Translog . Location location ) throws IOException { assert location . generation = = generation : <str> + location . generation + <str> + generation + <str> ; ByteBuffer buffer = ByteBuffer . allocate ( location . size ) ; try ( BufferedChecksumStreamInput checksumStreamInput = checksummedStream ( buffer , location . translogLocation , location . size , null ) ) { return read ( checksumStreamInput ) ; } } private final int readSize ( ByteBuffer reusableBuffer , long position ) { assert reusableBuffer . capacity ( ) > = <int> : <str> + reusableBuffer . capacity ( ) + <str> ; try { reusableBuffer . clear ( ) ; reusableBuffer . limit ( <int> ) ; readBytes ( reusableBuffer , position ) ; reusableBuffer . flip ( ) ; final int size = reusableBuffer . getInt ( ) + <int> ; final long maxSize = sizeInBytes ( ) - position ; if ( size < <int> | | size > maxSize ) { throw new TranslogCorruptedException ( <str> + maxSize + <str> + size ) ; } return size ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> + this . channelReference . getPath ( ) , e ) ; } } public Translog . Snapshot newSnapshot ( ) { final ByteBuffer reusableBuffer = ByteBuffer . allocate ( <int> ) ; final int totalOperations = totalOperations ( ) ; channelReference . incRef ( ) ; return newReaderSnapshot ( totalOperations , reusableBuffer ) ; } private final BufferedChecksumStreamInput checksummedStream ( ByteBuffer reusableBuffer , long position , int opSize , BufferedChecksumStreamInput reuse ) throws IOException { final ByteBuffer buffer ; if ( reusableBuffer . capacity ( ) > = opSize ) { buffer = reusableBuffer ; } else { buffer = ByteBuffer . allocate ( opSize ) ; } buffer . clear ( ) ; buffer . limit ( opSize ) ; readBytes ( buffer , position ) ; buffer . flip ( ) ; return new BufferedChecksumStreamInput ( new ByteBufferStreamInput ( buffer ) , reuse ) ; } protected Translog . Operation read ( BufferedChecksumStreamInput inStream ) throws IOException { return Translog . readOperation ( inStream ) ; } abstract protected void readBytes ( ByteBuffer buffer , long position ) throws IOException ; @Override public void close ( ) throws IOException { if ( closed . compareAndSet ( false , true ) ) { doClose ( ) ; } } protected void doClose ( ) throws IOException { channelReference . decRef ( ) ; } protected void ensureOpen ( ) { if ( closed . get ( ) ) { throw new AlreadyClosedException ( <str> + getGeneration ( ) + <str> ) ; } } @Override public String toString ( ) { return <str> + generation + <str> + channelReference . getPath ( ) + <str> ; } @Override public int compareTo ( TranslogReader o ) { return Long . compare ( getGeneration ( ) , o . getGeneration ( ) ) ; } public static ImmutableTranslogReader open ( ChannelReference channelReference , Checkpoint checkpoint , String translogUUID ) throws IOException { final FileChannel channel = channelReference . getChannel ( ) ; final Path path = channelReference . getPath ( ) ; assert channelReference . getGeneration ( ) = = checkpoint . generation : <str> + channelReference . getGeneration ( ) + <str> + checkpoint . generation ; try { if ( checkpoint . offset = = <int> & & checkpoint . numOps = = TranslogReader . UNKNOWN_OP_COUNT ) { return new LegacyTranslogReader ( channelReference . getGeneration ( ) , channelReference , <int> ) ; } InputStreamStreamInput headerStream = new InputStreamStreamInput ( Channels . newInputStream ( channel ) ) ; byte b1 = headerStream . readByte ( ) ; if ( b1 = = LUCENE_CODEC_HEADER_BYTE ) { byte b2 = headerStream . readByte ( ) ; byte b3 = headerStream . readByte ( ) ; byte b4 = headerStream . readByte ( ) ; int header = ( ( b1 & <hex> ) < < <int> ) + ( ( b2 & <hex> ) < < <int> ) + ( ( b3 & <hex> ) < < <int> ) + ( ( b4 & <hex> ) < < <int> ) ; if ( header ! = CodecUtil . CODEC_MAGIC ) { throw new TranslogCorruptedException ( <str> ) ; } int version = CodecUtil . checkHeaderNoMagic ( new InputStreamDataInput ( headerStream ) , TranslogWriter . TRANSLOG_CODEC , <int> , Integer . MAX_VALUE ) ; switch ( version ) { case TranslogWriter . VERSION_CHECKSUMS : assert checkpoint . numOps = = TranslogReader . UNKNOWN_OP_COUNT : <str> + checkpoint . numOps ; assert checkpoint . offset = = Files . size ( path ) : <str> + checkpoint . offset + <str> + Files . size ( path ) + <str> + path ; return new LegacyTranslogReaderBase ( channelReference . getGeneration ( ) , channelReference , CodecUtil . headerLength ( TranslogWriter . TRANSLOG_CODEC ) , checkpoint . offset ) ; case TranslogWriter . VERSION_CHECKPOINTS : assert path . getFileName ( ) . toString ( ) . endsWith ( Translog . TRANSLOG_FILE_SUFFIX ) : <str> + path ; assert checkpoint . numOps > TranslogReader . UNKNOWN_OP_COUNT : <str> + checkpoint . numOps ; assert checkpoint . offset < = channel . size ( ) : <str> + channel . size ( ) + <str> + checkpoint ; int len = headerStream . readInt ( ) ; if ( len > channel . size ( ) ) { throw new TranslogCorruptedException ( <str> ) ; } BytesRef ref = new BytesRef ( len ) ; ref . length = len ; headerStream . read ( ref . bytes , ref . offset , ref . length ) ; BytesRef uuidBytes = new BytesRef ( translogUUID ) ; if ( uuidBytes . bytesEquals ( ref ) = = false ) { throw new TranslogCorruptedException ( <str> + uuidBytes + <str> + ref + <str> ) ; } return new ImmutableTranslogReader ( channelReference . getGeneration ( ) , channelReference , ref . length + CodecUtil . headerLength ( TranslogWriter . TRANSLOG_CODEC ) + RamUsageEstimator . NUM_BYTES_INT , checkpoint . offset , checkpoint . numOps ) ; default : throw new TranslogCorruptedException ( <str> + version + <str> + path ) ; } } else if ( b1 = = UNVERSIONED_TRANSLOG_HEADER_BYTE ) { assert checkpoint . numOps = = TranslogReader . UNKNOWN_OP_COUNT : <str> + checkpoint . numOps ; assert checkpoint . offset = = Files . size ( path ) : <str> + checkpoint . offset + <str> + Files . size ( path ) + <str> + path ; return new LegacyTranslogReader ( channelReference . getGeneration ( ) , channelReference , checkpoint . offset ) ; } else { throw new TranslogCorruptedException ( <str> + Long . toHexString ( b1 ) + <str> ) ; } } catch ( CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException e ) { throw new TranslogCorruptedException ( <str> , e ) ; } } public Path path ( ) { return channelReference . getPath ( ) ; } protected Translog . Snapshot newReaderSnapshot ( int totalOperations , ByteBuffer reusableBuffer ) { return new ReaderSnapshot ( totalOperations , reusableBuffer ) ; } class ReaderSnapshot implements Translog . Snapshot { private final AtomicBoolean closed ; private final int totalOperations ; private final ByteBuffer reusableBuffer ; long position ; int readOperations ; private BufferedChecksumStreamInput reuse ; public ReaderSnapshot ( int totalOperations , ByteBuffer reusableBuffer ) { this . totalOperations = totalOperations ; this . reusableBuffer = reusableBuffer ; closed = new AtomicBoolean ( false ) ; position = firstOperationOffset ; readOperations = <int> ; reuse = null ; } @Override public final int estimatedTotalOperations ( ) { return totalOperations ; } @Override public Translog . Operation next ( ) throws IOException { if ( readOperations < totalOperations ) { assert readOperations < totalOperations : <str> ; return readOperation ( ) ; } else { return null ; } } protected final Translog . Operation readOperation ( ) throws IOException { final int opSize = readSize ( reusableBuffer , position ) ; reuse = checksummedStream ( reusableBuffer , position , opSize , reuse ) ; Translog . Operation op = read ( reuse ) ; position + = opSize ; readOperations + + ; return op ; } @Override public void close ( ) { if ( closed . compareAndSet ( false , true ) ) { channelReference . decRef ( ) ; } } } } 
