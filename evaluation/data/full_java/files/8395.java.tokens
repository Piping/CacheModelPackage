package org . elasticsearch . recovery ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthRequestBuilder ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . action . admin . indices . recovery . RecoveryResponse ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . UnassignedInfo ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . zen . ZenDiscovery ; import org . elasticsearch . indices . recovery . RecoveryState ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> , transportClientRatio = <float> ) public class FullRollingRestartIT extends ESIntegTestCase { protected void assertTimeout ( ClusterHealthRequestBuilder requestBuilder ) { ClusterHealthResponse clusterHealth = requestBuilder . get ( ) ; if ( clusterHealth . isTimedOut ( ) ) { logger . info ( <str> , clusterHealth ) ; fail ( <str> ) ; } } @Override protected int numberOfReplicas ( ) { return <int> ; } public void testFullRollingRestart ( ) throws Exception { Settings settings = Settings . builder ( ) . put ( ZenDiscovery . SETTING_JOIN_TIMEOUT , <str> ) . build ( ) ; internalCluster ( ) . startNode ( settings ) ; createIndex ( <str> ) ; final String healthTimeout = <str> ; for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , Long . toString ( i ) ) . setSource ( MapBuilder . < String , Object > newMapBuilder ( ) . put ( <str> , <str> + i ) . map ( ) ) . execute ( ) . actionGet ( ) ; } flush ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , Long . toString ( i ) ) . setSource ( MapBuilder . < String , Object > newMapBuilder ( ) . put ( <str> , <str> + i ) . map ( ) ) . execute ( ) . actionGet ( ) ; } logger . info ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; assertTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( healthTimeout ) . setWaitForGreenStatus ( ) . setWaitForRelocatingShards ( <int> ) . setWaitForNodes ( <str> ) ) ; logger . info ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , settings ) . get ( ) ; setMinimumMasterNodes ( <int> ) ; assertTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( healthTimeout ) . setWaitForGreenStatus ( ) . setWaitForRelocatingShards ( <int> ) . setWaitForNodes ( <str> ) ) ; logger . info ( <str> ) ; refresh ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) , <int> ) ; } internalCluster ( ) . stopRandomDataNode ( ) ; assertTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( healthTimeout ) . setWaitForGreenStatus ( ) . setWaitForRelocatingShards ( <int> ) . setWaitForNodes ( <str> ) ) ; setMinimumMasterNodes ( <int> ) ; internalCluster ( ) . stopRandomDataNode ( ) ; assertTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( healthTimeout ) . setWaitForGreenStatus ( ) . setWaitForRelocatingShards ( <int> ) . setWaitForNodes ( <str> ) ) ; logger . info ( <str> ) ; refresh ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) , <int> ) ; } internalCluster ( ) . stopRandomDataNode ( ) ; assertTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( healthTimeout ) . setWaitForGreenStatus ( ) . setWaitForRelocatingShards ( <int> ) . setWaitForNodes ( <str> ) ) ; setMinimumMasterNodes ( <int> ) ; internalCluster ( ) . stopRandomDataNode ( ) ; assertTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setTimeout ( healthTimeout ) . setWaitForYellowStatus ( ) . setWaitForRelocatingShards ( <int> ) . setWaitForNodes ( <str> ) ) ; logger . info ( <str> ) ; refresh ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertHitCount ( client ( ) . prepareSearch ( ) . setSize ( <int> ) . setQuery ( matchAllQuery ( ) ) . get ( ) , <int> ) ; } } public void testNoRebalanceOnRollingRestart ( ) throws Exception { internalCluster ( ) . startMasterOnlyNode ( Settings . EMPTY ) ; internalCluster ( ) . startDataOnlyNodesAsync ( <int> ) . get ( ) ; prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <str> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <str> ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , TimeValue . timeValueMinutes ( <int> ) ) ) . get ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , Long . toString ( i ) ) . setSource ( MapBuilder . < String , Object > newMapBuilder ( ) . put ( <str> , <str> + i ) . map ( ) ) . execute ( ) . actionGet ( ) ; } ensureGreen ( ) ; ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; RecoveryResponse recoveryResponse = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( <str> ) . get ( ) ; for ( RecoveryState recoveryState : recoveryResponse . shardRecoveryStates ( ) . get ( <str> ) ) { assertTrue ( <str> + recoveryState . getSourceNode ( ) + <str> + recoveryState . getTargetNode ( ) + <str> + state . prettyPrint ( ) , recoveryState . getType ( ) ! = RecoveryState . Type . RELOCATION ) ; } internalCluster ( ) . restartRandomDataNode ( ) ; ensureGreen ( ) ; ClusterState afterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; recoveryResponse = client ( ) . admin ( ) . indices ( ) . prepareRecoveries ( <str> ) . get ( ) ; for ( RecoveryState recoveryState : recoveryResponse . shardRecoveryStates ( ) . get ( <str> ) ) { assertTrue ( <str> + recoveryState . getSourceNode ( ) + <str> + recoveryState . getTargetNode ( ) + <str> + state . prettyPrint ( ) + <str> + afterState . prettyPrint ( ) , recoveryState . getType ( ) ! = RecoveryState . Type . RELOCATION ) ; } } } 
