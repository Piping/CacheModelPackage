package org . apache . cassandra . config ; import java . security . MessageDigest ; import java . security . NoSuchAlgorithmException ; import java . util . * ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Sets ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . cql3 . functions . * ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . SystemKeyspace ; import org . apache . cassandra . db . commitlog . CommitLog ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . UserType ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . schema . * ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . utils . ConcurrentBiMap ; import org . apache . cassandra . utils . Pair ; import org . cliffc . high_scale_lib . NonBlockingHashMap ; public class Schema { private static final Logger logger = LoggerFactory . getLogger ( Schema . class ) ; public static final Schema instance = new Schema ( ) ; public static final Set < String > SYSTEM_KEYSPACE_NAMES = ImmutableSet . of ( SystemKeyspace . NAME , SchemaKeyspace . NAME ) ; public static final int NAME_LENGTH = <int> ; private final Map < String , KeyspaceMetadata > keyspaces = new NonBlockingHashMap < > ( ) ; private final Map < String , Keyspace > keyspaceInstances = new NonBlockingHashMap < > ( ) ; private final ConcurrentBiMap < Pair < String , String > , UUID > cfIdMap = new ConcurrentBiMap < > ( ) ; private volatile UUID version ; public static final UUID emptyVersion ; static { try { emptyVersion = UUID . nameUUIDFromBytes ( MessageDigest . getInstance ( <str> ) . digest ( ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new AssertionError ( ) ; } } public Schema ( ) { if ( ! Config . isClientMode ( ) ) { load ( SchemaKeyspace . metadata ( ) ) ; load ( SystemKeyspace . metadata ( ) ) ; } } public static boolean isSystemKeyspace ( String keyspaceName ) { return SYSTEM_KEYSPACE_NAMES . contains ( keyspaceName . toLowerCase ( ) ) ; } public Schema loadFromDisk ( ) { return loadFromDisk ( true ) ; } public Schema loadFromDisk ( boolean updateVersion ) { load ( SchemaKeyspace . fetchNonSystemKeyspaces ( ) ) ; if ( updateVersion ) updateVersion ( ) ; return this ; } public Schema load ( Iterable < KeyspaceMetadata > keyspaceDefs ) { keyspaceDefs . forEach ( this : : load ) ; return this ; } public Schema load ( KeyspaceMetadata keyspaceDef ) { keyspaceDef . tables . forEach ( this : : load ) ; keyspaceDef . views . forEach ( this : : load ) ; setKeyspaceMetadata ( keyspaceDef ) ; return this ; } public Keyspace getKeyspaceInstance ( String keyspaceName ) { return keyspaceInstances . get ( keyspaceName ) ; } public ColumnFamilyStore getColumnFamilyStoreIncludingIndexes ( Pair < String , String > ksNameAndCFName ) { String ksName = ksNameAndCFName . left ; String cfName = ksNameAndCFName . right ; Pair < String , String > baseTable ; int indexOfSeparator = cfName . indexOf ( <str> ) ; if ( indexOfSeparator > - <int> ) baseTable = Pair . create ( ksName , cfName . substring ( <int> , indexOfSeparator ) ) ; else baseTable = ksNameAndCFName ; UUID cfId = cfIdMap . get ( baseTable ) ; if ( cfId = = null ) return null ; Keyspace ks = keyspaceInstances . get ( ksName ) ; if ( ks = = null ) return null ; ColumnFamilyStore baseCFS = ks . getColumnFamilyStore ( cfId ) ; if ( indexOfSeparator = = - <int> ) return baseCFS ; if ( baseCFS = = null ) return null ; Index index = baseCFS . indexManager . getIndexByName ( cfName . substring ( indexOfSeparator + <int> , cfName . length ( ) ) ) ; if ( index = = null ) return null ; return index . getBackingTable ( ) . get ( ) ; } public ColumnFamilyStore getColumnFamilyStoreInstance ( UUID cfId ) { Pair < String , String > pair = cfIdMap . inverse ( ) . get ( cfId ) ; if ( pair = = null ) return null ; Keyspace instance = getKeyspaceInstance ( pair . left ) ; if ( instance = = null ) return null ; return instance . getColumnFamilyStore ( cfId ) ; } public void storeKeyspaceInstance ( Keyspace keyspace ) { if ( keyspaceInstances . containsKey ( keyspace . getName ( ) ) ) throw new IllegalArgumentException ( String . format ( <str> , keyspace . getName ( ) ) ) ; keyspaceInstances . put ( keyspace . getName ( ) , keyspace ) ; } public Keyspace removeKeyspaceInstance ( String keyspaceName ) { return keyspaceInstances . remove ( keyspaceName ) ; } public void clearKeyspaceMetadata ( KeyspaceMetadata ksm ) { keyspaces . remove ( ksm . name ) ; } public CFMetaData getCFMetaData ( String keyspaceName , String cfName ) { assert keyspaceName ! = null ; KeyspaceMetadata ksm = keyspaces . get ( keyspaceName ) ; return ksm = = null ? null : ksm . getTableOrViewNullable ( cfName ) ; } public CFMetaData getCFMetaData ( UUID cfId ) { Pair < String , String > cf = getCF ( cfId ) ; return ( cf = = null ) ? null : getCFMetaData ( cf . left , cf . right ) ; } public CFMetaData getCFMetaData ( Descriptor descriptor ) { return getCFMetaData ( descriptor . ksname , descriptor . cfname ) ; } public ViewDefinition getView ( String keyspaceName , String viewName ) { assert keyspaceName ! = null ; KeyspaceMetadata ksm = keyspaces . get ( keyspaceName ) ; return ( ksm = = null ) ? null : ksm . views . getNullable ( viewName ) ; } public KeyspaceMetadata getKSMetaData ( String keyspaceName ) { assert keyspaceName ! = null ; return keyspaces . get ( keyspaceName ) ; } public List < String > getNonSystemKeyspaces ( ) { return ImmutableList . copyOf ( Sets . difference ( keyspaces . keySet ( ) , SYSTEM_KEYSPACE_NAMES ) ) ; } public Iterable < CFMetaData > getTablesAndViews ( String keyspaceName ) { assert keyspaceName ! = null ; KeyspaceMetadata ksm = keyspaces . get ( keyspaceName ) ; assert ksm ! = null ; return ksm . tablesAndViews ( ) ; } public Set < String > getKeyspaces ( ) { return keyspaces . keySet ( ) ; } public Keyspaces getKeyspaces ( Set < String > includedKeyspaceNames ) { Keyspaces . Builder builder = Keyspaces . builder ( ) ; keyspaces . values ( ) . stream ( ) . filter ( k - > includedKeyspaceNames . contains ( k . name ) ) . forEach ( builder : : add ) ; return builder . build ( ) ; } public void setKeyspaceMetadata ( KeyspaceMetadata ksm ) { assert ksm ! = null ; keyspaces . put ( ksm . name , ksm ) ; Keyspace keyspace = getKeyspaceInstance ( ksm . name ) ; if ( keyspace ! = null ) keyspace . setMetadata ( ksm ) ; } public Pair < String , String > getCF ( UUID cfId ) { return cfIdMap . inverse ( ) . get ( cfId ) ; } public boolean hasCF ( Pair < String , String > ksAndCFName ) { return cfIdMap . containsKey ( ksAndCFName ) ; } public UUID getId ( String ksName , String cfName ) { return cfIdMap . get ( Pair . create ( ksName , cfName ) ) ; } public void load ( CFMetaData cfm ) { Pair < String , String > key = Pair . create ( cfm . ksName , cfm . cfName ) ; if ( cfIdMap . containsKey ( key ) ) throw new RuntimeException ( String . format ( <str> , cfm . ksName , cfm . cfName ) ) ; logger . debug ( <str> , cfm ) ; cfIdMap . put ( key , cfm . cfId ) ; } public void load ( ViewDefinition view ) { CFMetaData cfm = view . metadata ; Pair < String , String > key = Pair . create ( cfm . ksName , cfm . cfName ) ; if ( cfIdMap . containsKey ( key ) ) throw new RuntimeException ( String . format ( <str> , cfm . ksName , cfm . cfName ) ) ; logger . debug ( <str> , cfm ) ; cfIdMap . put ( key , cfm . cfId ) ; } public void unload ( CFMetaData cfm ) { cfIdMap . remove ( Pair . create ( cfm . ksName , cfm . cfName ) ) ; } private void unload ( ViewDefinition view ) { cfIdMap . remove ( Pair . create ( view . ksName , view . viewName ) ) ; } public Collection < Function > getFunctions ( FunctionName name ) { if ( ! name . hasKeyspace ( ) ) throw new IllegalArgumentException ( String . format ( <str> , name ) ) ; KeyspaceMetadata ksm = getKSMetaData ( name . keyspace ) ; return ksm = = null ? Collections . emptyList ( ) : ksm . functions . get ( name ) ; } public Optional < Function > findFunction ( FunctionName name , List < AbstractType < ? > > argTypes ) { if ( ! name . hasKeyspace ( ) ) throw new IllegalArgumentException ( String . format ( <str> , name ) ) ; KeyspaceMetadata ksm = getKSMetaData ( name . keyspace ) ; return ksm = = null ? Optional . empty ( ) : ksm . functions . find ( name , argTypes ) ; } public UUID getVersion ( ) { return version ; } public void updateVersion ( ) { version = SchemaKeyspace . calculateSchemaDigest ( ) ; SystemKeyspace . updateSchemaVersion ( version ) ; } public void updateVersionAndAnnounce ( ) { updateVersion ( ) ; MigrationManager . passiveAnnounce ( version ) ; } public synchronized void clear ( ) { for ( String keyspaceName : getNonSystemKeyspaces ( ) ) { KeyspaceMetadata ksm = getKSMetaData ( keyspaceName ) ; ksm . tables . forEach ( this : : unload ) ; ksm . views . forEach ( this : : unload ) ; clearKeyspaceMetadata ( ksm ) ; } updateVersionAndAnnounce ( ) ; } public void addKeyspace ( KeyspaceMetadata ksm ) { assert getKSMetaData ( ksm . name ) = = null ; load ( ksm ) ; Keyspace . open ( ksm . name ) ; MigrationManager . instance . notifyCreateKeyspace ( ksm ) ; } public void updateKeyspace ( String ksName , KeyspaceParams newParams ) { KeyspaceMetadata ksm = update ( ksName , ks - > ks . withSwapped ( newParams ) ) ; MigrationManager . instance . notifyUpdateKeyspace ( ksm ) ; } public void dropKeyspace ( String ksName ) { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( ksName ) ; String snapshotName = Keyspace . getTimestampedSnapshotName ( ksName ) ; CompactionManager . instance . interruptCompactionFor ( ksm . tablesAndViews ( ) , true ) ; Keyspace keyspace = Keyspace . open ( ksm . name ) ; List < UUID > droppedCfs = new ArrayList < > ( ) ; for ( CFMetaData cfm : ksm . tablesAndViews ( ) ) { ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfm . cfName ) ; unload ( cfm ) ; if ( DatabaseDescriptor . isAutoSnapshot ( ) ) cfs . snapshot ( snapshotName ) ; Keyspace . open ( ksm . name ) . dropCf ( cfm . cfId ) ; droppedCfs . add ( cfm . cfId ) ; } Keyspace . clear ( ksm . name ) ; clearKeyspaceMetadata ( ksm ) ; Keyspace . writeOrder . awaitNewBarrier ( ) ; CommitLog . instance . forceRecycleAllSegments ( droppedCfs ) ; MigrationManager . instance . notifyDropKeyspace ( ksm ) ; } public void addTable ( CFMetaData cfm ) { assert getCFMetaData ( cfm . ksName , cfm . cfName ) = = null ; Keyspace . open ( cfm . ksName ) . initCf ( cfm , true ) ; update ( cfm . ksName , ks - > ks . withSwapped ( ks . tables . with ( cfm ) ) ) ; load ( cfm ) ; Keyspace . open ( cfm . ksName ) . initCf ( cfm , true ) ; MigrationManager . instance . notifyCreateColumnFamily ( cfm ) ; } public void updateTable ( CFMetaData table ) { CFMetaData current = getCFMetaData ( table . ksName , table . cfName ) ; assert current ! = null ; boolean changeAffectsStatements = current . apply ( table ) ; Keyspace keyspace = Keyspace . open ( current . ksName ) ; keyspace . getColumnFamilyStore ( current . cfName ) . reload ( ) ; MigrationManager . instance . notifyUpdateColumnFamily ( current , changeAffectsStatements ) ; } public void dropTable ( String ksName , String tableName ) { KeyspaceMetadata oldKsm = getKSMetaData ( ksName ) ; assert oldKsm ! = null ; ColumnFamilyStore cfs = Keyspace . open ( ksName ) . getColumnFamilyStore ( tableName ) ; assert cfs ! = null ; cfs . indexManager . markAllIndexesRemoved ( ) ; CFMetaData cfm = oldKsm . tables . get ( tableName ) . get ( ) ; KeyspaceMetadata newKsm = oldKsm . withSwapped ( oldKsm . tables . without ( tableName ) ) ; unload ( cfm ) ; setKeyspaceMetadata ( newKsm ) ; CompactionManager . instance . interruptCompactionFor ( Collections . singleton ( cfm ) , true ) ; if ( DatabaseDescriptor . isAutoSnapshot ( ) ) cfs . snapshot ( Keyspace . getTimestampedSnapshotName ( cfs . name ) ) ; Keyspace . open ( ksName ) . dropCf ( cfm . cfId ) ; MigrationManager . instance . notifyDropColumnFamily ( cfm ) ; CommitLog . instance . forceRecycleAllSegments ( Collections . singleton ( cfm . cfId ) ) ; } public void addView ( ViewDefinition view ) { assert getCFMetaData ( view . ksName , view . viewName ) = = null ; Keyspace keyspace = Keyspace . open ( view . ksName ) ; keyspace . initCf ( view . metadata , true ) ; update ( view . ksName , ks - > ks . withSwapped ( ks . views . with ( view ) ) ) ; load ( view ) ; keyspace . viewManager . reload ( ) ; MigrationManager . instance . notifyCreateView ( view ) ; } public void updateView ( ViewDefinition view ) { ViewDefinition current = getKSMetaData ( view . ksName ) . views . get ( view . viewName ) . get ( ) ; boolean changeAffectsStatements = current . metadata . apply ( view . metadata ) ; Keyspace keyspace = Keyspace . open ( current . ksName ) ; keyspace . getColumnFamilyStore ( current . viewName ) . reload ( ) ; Keyspace . open ( current . ksName ) . viewManager . update ( current . viewName ) ; MigrationManager . instance . notifyUpdateView ( current , changeAffectsStatements ) ; } public void dropView ( String ksName , String viewName ) { KeyspaceMetadata oldKsm = getKSMetaData ( ksName ) ; assert oldKsm ! = null ; ColumnFamilyStore cfs = Keyspace . open ( ksName ) . getColumnFamilyStore ( viewName ) ; assert cfs ! = null ; cfs . indexManager . markAllIndexesRemoved ( ) ; ViewDefinition view = oldKsm . views . get ( viewName ) . get ( ) ; KeyspaceMetadata newKsm = oldKsm . withSwapped ( oldKsm . views . without ( viewName ) ) ; unload ( view ) ; setKeyspaceMetadata ( newKsm ) ; CompactionManager . instance . interruptCompactionFor ( Collections . singleton ( view . metadata ) , true ) ; if ( DatabaseDescriptor . isAutoSnapshot ( ) ) cfs . snapshot ( Keyspace . getTimestampedSnapshotName ( cfs . name ) ) ; Keyspace . open ( ksName ) . dropCf ( view . metadata . cfId ) ; Keyspace . open ( ksName ) . viewManager . reload ( ) ; MigrationManager . instance . notifyDropView ( view ) ; CommitLog . instance . forceRecycleAllSegments ( Collections . singleton ( view . metadata . cfId ) ) ; } public void addType ( UserType ut ) { update ( ut . keyspace , ks - > ks . withSwapped ( ks . types . with ( ut ) ) ) ; MigrationManager . instance . notifyCreateUserType ( ut ) ; } public void updateType ( UserType ut ) { update ( ut . keyspace , ks - > ks . withSwapped ( ks . types . without ( ut . name ) . with ( ut ) ) ) ; MigrationManager . instance . notifyUpdateUserType ( ut ) ; } public void dropType ( UserType ut ) { update ( ut . keyspace , ks - > ks . withSwapped ( ks . types . without ( ut . name ) ) ) ; MigrationManager . instance . notifyDropUserType ( ut ) ; } public void addFunction ( UDFunction udf ) { update ( udf . name ( ) . keyspace , ks - > ks . withSwapped ( ks . functions . with ( udf ) ) ) ; MigrationManager . instance . notifyCreateFunction ( udf ) ; } public void updateFunction ( UDFunction udf ) { update ( udf . name ( ) . keyspace , ks - > ks . withSwapped ( ks . functions . without ( udf . name ( ) , udf . argTypes ( ) ) . with ( udf ) ) ) ; MigrationManager . instance . notifyUpdateFunction ( udf ) ; } public void dropFunction ( UDFunction udf ) { update ( udf . name ( ) . keyspace , ks - > ks . withSwapped ( ks . functions . without ( udf . name ( ) , udf . argTypes ( ) ) ) ) ; MigrationManager . instance . notifyDropFunction ( udf ) ; } public void addAggregate ( UDAggregate uda ) { update ( uda . name ( ) . keyspace , ks - > ks . withSwapped ( ks . functions . with ( uda ) ) ) ; MigrationManager . instance . notifyCreateAggregate ( uda ) ; } public void updateAggregate ( UDAggregate uda ) { update ( uda . name ( ) . keyspace , ks - > ks . withSwapped ( ks . functions . without ( uda . name ( ) , uda . argTypes ( ) ) . with ( uda ) ) ) ; MigrationManager . instance . notifyUpdateAggregate ( uda ) ; } public void dropAggregate ( UDAggregate uda ) { update ( uda . name ( ) . keyspace , ks - > ks . withSwapped ( ks . functions . without ( uda . name ( ) , uda . argTypes ( ) ) ) ) ; MigrationManager . instance . notifyDropAggregate ( uda ) ; } private synchronized KeyspaceMetadata update ( String keyspaceName , java . util . function . Function < KeyspaceMetadata , KeyspaceMetadata > transformation ) { KeyspaceMetadata current = getKSMetaData ( keyspaceName ) ; if ( current = = null ) throw new IllegalStateException ( String . format ( <str> , keyspaceName ) ) ; KeyspaceMetadata transformed = transformation . apply ( current ) ; setKeyspaceMetadata ( transformed ) ; return transformed ; } } 
