package org . elasticsearch . threadpool ; import org . elasticsearch . action . admin . cluster . node . info . NodeInfo ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . node . Node ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . ESSingleNodeTestCase ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . hamcrest . RegexMatcher ; import org . elasticsearch . threadpool . ThreadPool . Names ; import org . elasticsearch . tribe . TribeIT ; import java . io . IOException ; import java . lang . management . ManagementFactory ; import java . lang . management . ThreadInfo ; import java . lang . management . ThreadMXBean ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . BrokenBarrierException ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . Executor ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . regex . Pattern ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . sameInstance ; @ClusterScope ( scope = Scope . TEST , numDataNodes = <int> , numClientNodes = <int> ) public class SimpleThreadPoolIT extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . settingsBuilder ( ) . build ( ) ; } public void testThreadNames ( ) throws Exception { ThreadMXBean threadBean = ManagementFactory . getThreadMXBean ( ) ; Set < String > preNodeStartThreadNames = new HashSet < > ( ) ; for ( long l : threadBean . getAllThreadIds ( ) ) { ThreadInfo threadInfo = threadBean . getThreadInfo ( l ) ; if ( threadInfo ! = null ) { preNodeStartThreadNames . add ( threadInfo . getThreadName ( ) ) ; } } logger . info ( <str> , preNodeStartThreadNames ) ; String node = internalCluster ( ) . startNode ( ) ; logger . info ( <str> ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < numDocs ; + + i ) { builders [ i ] = client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> + i ) . field ( <str> , new String [ ] { <str> + ( i * <int> ) , <str> + ( i * <int> + <int> ) } ) . field ( <str> , i ) . field ( <str> , new int [ ] { i * <int> , i * <int> + <int> } ) . field ( <str> , i ) . field ( <str> , new double [ ] { i * <int> , i * <int> + <int> } ) . endObject ( ) ) ; } indexRandom ( true , builders ) ; int numSearches = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numSearches ; i + + ) { assertNoFailures ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , <str> + i ) ) . get ( ) ) ; assertNoFailures ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , i ) ) . get ( ) ) ; } Set < String > threadNames = new HashSet < > ( ) ; for ( long l : threadBean . getAllThreadIds ( ) ) { ThreadInfo threadInfo = threadBean . getThreadInfo ( l ) ; if ( threadInfo ! = null ) { threadNames . add ( threadInfo . getThreadName ( ) ) ; } } logger . info ( <str> , threadNames ) ; threadNames . removeAll ( preNodeStartThreadNames ) ; logger . info ( <str> , threadNames ) ; for ( String threadName : threadNames ) { if ( threadName . contains ( <str> + ESSingleNodeTestCase . nodeName ( ) + <str> ) | | threadName . contains ( <str> ) ) { continue ; } String nodePrefix = <str> + Pattern . quote ( InternalTestCluster . TRANSPORT_CLIENT_PREFIX ) + <str> + Pattern . quote ( ESIntegTestCase . SUITE_CLUSTER_NODE_PREFIX ) + <str> + Pattern . quote ( ESIntegTestCase . TEST_CLUSTER_NODE_PREFIX ) + <str> + Pattern . quote ( TribeIT . SECOND_CLUSTER_NODE_PREFIX ) + <str> ; assertThat ( threadName , RegexMatcher . matches ( <str> + nodePrefix + <str> ) ) ; } } public void testUpdatingThreadPoolSettings ( ) throws Exception { internalCluster ( ) . startNodesAsync ( <int> ) . get ( ) ; ThreadPool threadPool = internalCluster ( ) . getDataNodeInstance ( ThreadPool . class ) ; assertThat ( ( ( ThreadPoolExecutor ) threadPool . executor ( Names . SEARCH ) ) . getQueue ( ) . remainingCapacity ( ) , equalTo ( <int> ) ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . build ( ) ) . execute ( ) . actionGet ( ) ; assertThat ( ( ( ThreadPoolExecutor ) threadPool . executor ( Names . SEARCH ) ) . getQueue ( ) . remainingCapacity ( ) , equalTo ( <int> ) ) ; final CyclicBarrier barrier = new CyclicBarrier ( <int> ) ; Executor oldExecutor = threadPool . executor ( Names . SEARCH ) ; threadPool . executor ( Names . SEARCH ) . execute ( ( ) - > { try { barrier . await ( ) ; } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } catch ( BrokenBarrierException ex ) { } } ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( <str> , <int> ) . build ( ) ) . execute ( ) . actionGet ( ) ; assertThat ( threadPool . executor ( Names . SEARCH ) , not ( sameInstance ( oldExecutor ) ) ) ; assertThat ( ( ( ThreadPoolExecutor ) oldExecutor ) . isShutdown ( ) , equalTo ( true ) ) ; assertThat ( ( ( ThreadPoolExecutor ) oldExecutor ) . isTerminating ( ) , equalTo ( true ) ) ; assertThat ( ( ( ThreadPoolExecutor ) oldExecutor ) . isTerminated ( ) , equalTo ( false ) ) ; barrier . await ( <int> , TimeUnit . SECONDS ) ; threadPool . executor ( Names . SEARCH ) . execute ( ( ) - > { try { barrier . await ( ) ; } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; } catch ( BrokenBarrierException ex ) { } } ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; barrier . await ( <int> , TimeUnit . SECONDS ) ; NodesInfoResponse nodesInfoResponse = client ( ) . admin ( ) . cluster ( ) . prepareNodesInfo ( ) . all ( ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { NodeInfo nodeInfo = nodesInfoResponse . getNodes ( ) [ i ] ; boolean found = false ; for ( ThreadPool . Info info : nodeInfo . getThreadPool ( ) ) { if ( info . getName ( ) . equals ( Names . SEARCH ) ) { assertEquals ( info . getThreadPoolType ( ) , ThreadPool . ThreadPoolType . FIXED ) ; found = true ; break ; } } assertThat ( found , equalTo ( true ) ) ; } } public void testThreadPoolLeakingThreadsWithTribeNode ( ) { Settings settings = Settings . builder ( ) . put ( <str> , <str> ) . put ( <str> , createTempDir ( ) ) . put ( <str> , <str> ) . put ( <str> , <str> ) . build ( ) ; try { new Node ( settings ) ; fail ( <str> ) ; } catch ( Throwable t ) { assertThat ( t . getMessage ( ) , containsString ( <str> ) ) ; } } private Map < String , Object > getPoolSettingsThroughJson ( ThreadPoolInfo info , String poolName ) throws IOException { XContentBuilder builder = XContentFactory . jsonBuilder ( ) ; builder . startObject ( ) ; info . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; builder . endObject ( ) ; builder . close ( ) ; Map < String , Object > poolsMap ; try ( XContentParser parser = JsonXContent . jsonXContent . createParser ( builder . string ( ) ) ) { poolsMap = parser . map ( ) ; } return ( Map < String , Object > ) ( ( Map < String , Object > ) poolsMap . get ( <str> ) ) . get ( poolName ) ; } } 
