package org . elasticsearch . http ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . node . service . NodeService ; import org . elasticsearch . rest . BytesRestResponse ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestFilter ; import org . elasticsearch . rest . RestFilterChain ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . RestStatus ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . HashMap ; import java . util . Locale ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . rest . RestStatus . FORBIDDEN ; import static org . elasticsearch . rest . RestStatus . INTERNAL_SERVER_ERROR ; import static org . elasticsearch . rest . RestStatus . NOT_FOUND ; import static org . elasticsearch . rest . RestStatus . OK ; public class HttpServer extends AbstractLifecycleComponent < HttpServer > { private final Environment environment ; private final HttpServerTransport transport ; private final RestController restController ; private final NodeService nodeService ; private final boolean disableSites ; private final PluginSiteFilter pluginSiteFilter = new PluginSiteFilter ( ) ; @Inject public HttpServer ( Settings settings , Environment environment , HttpServerTransport transport , RestController restController , NodeService nodeService ) { super ( settings ) ; this . environment = environment ; this . transport = transport ; this . restController = restController ; this . nodeService = nodeService ; nodeService . setHttpServer ( this ) ; this . disableSites = this . settings . getAsBoolean ( <str> , false ) ; transport . httpServerAdapter ( new Dispatcher ( this ) ) ; } static class Dispatcher implements HttpServerAdapter { private final HttpServer server ; Dispatcher ( HttpServer server ) { this . server = server ; } @Override public void dispatchRequest ( HttpRequest request , HttpChannel channel ) { server . internalDispatchRequest ( request , channel ) ; } } @Override protected void doStart ( ) { transport . start ( ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( <str> , transport . boundAddress ( ) ) ; } nodeService . putAttribute ( <str> , transport . boundAddress ( ) . publishAddress ( ) . toString ( ) ) ; } @Override protected void doStop ( ) { nodeService . removeAttribute ( <str> ) ; transport . stop ( ) ; } @Override protected void doClose ( ) { transport . close ( ) ; } public HttpInfo info ( ) { return transport . info ( ) ; } public HttpStats stats ( ) { return transport . stats ( ) ; } public void internalDispatchRequest ( final HttpRequest request , final HttpChannel channel ) { String rawPath = request . rawPath ( ) ; if ( rawPath . startsWith ( <str> ) ) { RestFilterChain filterChain = restController . filterChain ( pluginSiteFilter ) ; filterChain . continueProcessing ( request , channel ) ; return ; } else if ( rawPath . equals ( <str> ) ) { handleFavicon ( request , channel ) ; return ; } restController . dispatchRequest ( request , channel ) ; } class PluginSiteFilter extends RestFilter { @Override public void process ( RestRequest request , RestChannel channel , RestFilterChain filterChain ) throws IOException { handlePluginSite ( ( HttpRequest ) request , ( HttpChannel ) channel ) ; } } void handleFavicon ( HttpRequest request , HttpChannel channel ) { if ( request . method ( ) = = RestRequest . Method . GET ) { try { try ( InputStream stream = getClass ( ) . getResourceAsStream ( <str> ) ) { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; Streams . copy ( stream , out ) ; BytesRestResponse restResponse = new BytesRestResponse ( RestStatus . OK , <str> , out . toByteArray ( ) ) ; channel . sendResponse ( restResponse ) ; } } catch ( IOException e ) { channel . sendResponse ( new BytesRestResponse ( INTERNAL_SERVER_ERROR ) ) ; } } else { channel . sendResponse ( new BytesRestResponse ( FORBIDDEN ) ) ; } } void handlePluginSite ( HttpRequest request , HttpChannel channel ) throws IOException { if ( disableSites ) { channel . sendResponse ( new BytesRestResponse ( FORBIDDEN ) ) ; return ; } if ( request . method ( ) = = RestRequest . Method . OPTIONS ) { channel . sendResponse ( new BytesRestResponse ( OK ) ) ; return ; } if ( request . method ( ) ! = RestRequest . Method . GET ) { channel . sendResponse ( new BytesRestResponse ( FORBIDDEN ) ) ; return ; } String path = request . rawPath ( ) . substring ( <str> . length ( ) ) ; int i1 = path . indexOf ( <str> ) ; String pluginName ; String sitePath ; if ( i1 = = - <int> ) { pluginName = path ; sitePath = null ; String redirectUrl = request . rawPath ( ) + <str> ; BytesRestResponse restResponse = new BytesRestResponse ( RestStatus . MOVED_PERMANENTLY , <str> , <str> + redirectUrl + <str> ) ; restResponse . addHeader ( <str> , redirectUrl ) ; channel . sendResponse ( restResponse ) ; return ; } else { pluginName = path . substring ( <int> , i1 ) ; sitePath = path . substring ( i1 + <int> ) ; } if ( sitePath . length ( ) = = <int> ) { sitePath = <str> ; } else { while ( sitePath . length ( ) > <int> & & sitePath . charAt ( <int> ) = = <str> ) { sitePath = sitePath . substring ( <int> ) ; } } final Path siteFile = environment . pluginsFile ( ) . resolve ( pluginName ) . resolve ( <str> ) ; final String separator = siteFile . getFileSystem ( ) . getSeparator ( ) ; sitePath = sitePath . replace ( <str> , separator ) ; Path file = siteFile . resolve ( sitePath ) ; if ( ! Files . exists ( file ) | | FileSystemUtils . isHidden ( file ) | | ! file . toAbsolutePath ( ) . normalize ( ) . startsWith ( siteFile . toAbsolutePath ( ) . normalize ( ) ) ) { channel . sendResponse ( new BytesRestResponse ( NOT_FOUND ) ) ; return ; } BasicFileAttributes attributes = Files . readAttributes ( file , BasicFileAttributes . class ) ; if ( ! attributes . isRegularFile ( ) ) { if ( ! attributes . isDirectory ( ) ) { channel . sendResponse ( new BytesRestResponse ( FORBIDDEN ) ) ; return ; } file = file . resolve ( <str> ) ; if ( ! Files . exists ( file ) | | FileSystemUtils . isHidden ( file ) | | ! Files . isRegularFile ( file ) ) { channel . sendResponse ( new BytesRestResponse ( FORBIDDEN ) ) ; return ; } } try { byte [ ] data = Files . readAllBytes ( file ) ; channel . sendResponse ( new BytesRestResponse ( OK , guessMimeType ( sitePath ) , data ) ) ; } catch ( IOException e ) { channel . sendResponse ( new BytesRestResponse ( INTERNAL_SERVER_ERROR ) ) ; } } private String guessMimeType ( String path ) { int lastDot = path . lastIndexOf ( <str> ) ; if ( lastDot = = - <int> ) { return <str> ; } String extension = path . substring ( lastDot + <int> ) . toLowerCase ( Locale . ROOT ) ; String mimeType = DEFAULT_MIME_TYPES . get ( extension ) ; if ( mimeType = = null ) { return <str> ; } return mimeType ; } static { Map < String , String > mimeTypes = new HashMap < > ( ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; mimeTypes . put ( <str> , <str> ) ; DEFAULT_MIME_TYPES = unmodifiableMap ( mimeTypes ) ; } public static final Map < String , String > DEFAULT_MIME_TYPES ; } 
