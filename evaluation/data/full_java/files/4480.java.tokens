package org . eclipse . debug . internal . ui . viewers . update ; import java . util . Iterator ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IMemoryBlockListener ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IMemoryBlockRetrieval ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . provisional . AbstractModelProxy ; import org . eclipse . debug . internal . ui . views . memory . MemoryViewUtil ; import org . eclipse . debug . ui . memory . IMemoryRendering ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . jface . viewers . StructuredSelection ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . ui . progress . UIJob ; public class MemoryRetrievalProxy extends AbstractModelProxy implements IMemoryBlockListener { private IMemoryBlockRetrieval fRetrieval ; public MemoryRetrievalProxy ( IMemoryBlockRetrieval retrieval ) { fRetrieval = retrieval ; } @Override public void memoryBlocksAdded ( IMemoryBlock [ ] memory ) { IMemoryBlock [ ] allMB = DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . getMemoryBlocks ( fRetrieval ) ; int lastIndex = allMB . length - memory . length ; ModelDelta delta = new ModelDelta ( fRetrieval , <int> , IModelDelta . NO_CHANGE , allMB . length ) ; for ( int i = <int> ; i < memory . length ; i + + ) { IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( memory [ i ] ) ; if ( retrieval ! = null ) { if ( retrieval = = fRetrieval ) { delta . addNode ( memory [ i ] , lastIndex + i , IModelDelta . ADDED | IModelDelta . SELECT , <int> ) ; } } } fireModelChanged ( delta ) ; } @Override public void memoryBlocksRemoved ( final IMemoryBlock [ ] memory ) { UIJob job = new UIJob ( <str> ) { @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { ModelDelta delta = new ModelDelta ( fRetrieval , IModelDelta . NO_CHANGE ) ; for ( int i = <int> ; i < memory . length ; i + + ) { IMemoryBlockRetrieval retrieval = MemoryViewUtil . getMemoryBlockRetrieval ( memory [ i ] ) ; if ( retrieval ! = null ) { if ( retrieval = = fRetrieval ) { if ( isMemoryBlockSelected ( getCurrentSelection ( ) , memory [ i ] ) ) { addSelectDeltaNode ( delta ) ; } delta . addNode ( memory [ i ] , IModelDelta . REMOVED ) ; } } } fireModelChanged ( delta ) ; return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } @Override public void init ( IPresentationContext context ) { super . init ( context ) ; DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . addListener ( this ) ; } @Override public void installed ( Viewer viewer ) { super . installed ( viewer ) ; setInitialSelection ( ) ; } protected void setInitialSelection ( ) { IMemoryBlock [ ] allMB = DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . getMemoryBlocks ( fRetrieval ) ; if ( allMB . length > <int> ) { ModelDelta delta = new ModelDelta ( fRetrieval , <int> , IModelDelta . NO_CHANGE , allMB . length ) ; delta . addNode ( allMB [ <int> ] , <int> , IModelDelta . SELECT , <int> ) ; fireModelChanged ( delta ) ; } } @Override public synchronized void dispose ( ) { super . dispose ( ) ; DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . removeListener ( this ) ; } private void addSelectDeltaNode ( ModelDelta delta ) { IMemoryBlock [ ] memoryBlocks = DebugPlugin . getDefault ( ) . getMemoryBlockManager ( ) . getMemoryBlocks ( fRetrieval ) ; if ( memoryBlocks ! = null & & memoryBlocks . length > <int> ) { delta . addNode ( memoryBlocks [ <int> ] , IModelDelta . SELECT ) ; } } private IStructuredSelection getCurrentSelection ( ) { Viewer viewer = getViewer ( ) ; if ( viewer instanceof StructuredViewer ) { StructuredViewer sv = ( StructuredViewer ) viewer ; ISelection selection = sv . getSelection ( ) ; if ( selection instanceof IStructuredSelection ) { return ( IStructuredSelection ) selection ; } } return StructuredSelection . EMPTY ; } private boolean isMemoryBlockSelected ( IStructuredSelection selection , IMemoryBlock memoryBlock ) { if ( ! selection . isEmpty ( ) ) { Iterator < ? > iter = selection . iterator ( ) ; while ( iter . hasNext ( ) ) { Object sel = iter . next ( ) ; if ( sel = = memoryBlock ) { return true ; } if ( sel instanceof IMemoryRendering ) { if ( ( ( IMemoryRendering ) sel ) . getMemoryBlock ( ) = = memoryBlock ) { return true ; } } } } return false ; } } 
