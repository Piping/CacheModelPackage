package org . eclipse . debug . internal . ui . viewers . model ; import java . io . IOException ; import java . io . StringWriter ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementCompareRequest ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementMementoProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementMementoRequest ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDeltaVisitor ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStateUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . jface . viewers . ITreeSelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . ui . IMemento ; import org . eclipse . ui . XMLMemento ; class ViewerStateTracker { static final int STATE_SAVE_SEQUENCE_BEGINS = <int> ; static final int STATE_SAVE_SEQUENCE_COMPLETE = <int> ; static final int STATE_RESTORE_SEQUENCE_BEGINS = <int> ; static final int STATE_RESTORE_SEQUENCE_COMPLETE = <int> ; private final static String ELEMENT_REMOVED = <str> ; interface IElementMementoCollector { public void addRequest ( ElementMementoRequest request ) ; public void requestComplete ( ElementMementoRequest request ) ; public void processReqeusts ( ) ; public void cancel ( ) ; } class LRUMap < K , V > extends LinkedHashMap < K , V > { private static final long serialVersionUID = <int> ; private int fMaxSize ; LRUMap ( int maxSize ) { super ( ) ; fMaxSize = maxSize ; } @Override protected boolean removeEldestEntry ( Entry < K , V > eldest ) { return size ( ) > fMaxSize ; } } private TreeModelContentProvider fContentProvider ; ViewerStateTracker ( TreeModelContentProvider contentProvider ) { fContentProvider = contentProvider ; } private Map < String , ModelDelta > fViewerStates = new LRUMap < String , ModelDelta > ( <int> ) ; private ModelDelta fPendingState = null ; private boolean fInStateRestore = false ; private ListenerList fStateUpdateListeners = new ListenerList ( ) ; protected PendingRevealDelta fPendingSetTopItem = null ; private Set < IElementMementoCollector > fPendingStateSaves = new HashSet < IElementMementoCollector > ( ) ; private Object fQueuedRestore = null ; private static class CompareRequestKey { CompareRequestKey ( TreePath path , IModelDelta delta ) { fPath = path ; fDelta = delta ; } TreePath fPath ; IModelDelta fDelta ; @Override public boolean equals ( Object obj ) { if ( obj instanceof CompareRequestKey ) { CompareRequestKey key = ( CompareRequestKey ) obj ; return key . fDelta . equals ( fDelta ) & & key . fPath . equals ( fPath ) ; } return false ; } @Override public int hashCode ( ) { return fDelta . hashCode ( ) + fPath . hashCode ( ) ; } } private Map < CompareRequestKey , ElementCompareRequest > fCompareRequestsInProgress = new LinkedHashMap < CompareRequestKey , ElementCompareRequest > ( ) ; void dispose ( ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; for ( IElementMementoCollector emc : fPendingStateSaves ) { emc . cancel ( ) ; } fStateUpdateListeners . clear ( ) ; for ( ElementCompareRequest ecr : fCompareRequestsInProgress . values ( ) ) { ecr . cancel ( ) ; } fCompareRequestsInProgress . clear ( ) ; if ( fPendingSetTopItem ! = null ) { fPendingSetTopItem . dispose ( ) ; } } private void startRestoreViewerState ( final Object input ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fPendingState = null ; final IElementMementoProvider defaultProvider = ViewerAdapterService . getMementoProvider ( input ) ; if ( defaultProvider ! = null ) { final ModelDelta delta = new ModelDelta ( input , IModelDelta . NO_CHANGE ) ; final XMLMemento inputMemento = XMLMemento . createWriteRoot ( <str> ) ; final IElementMementoCollector manager = new IElementMementoCollector ( ) { private IElementMementoRequest fRequest ; @Override public void requestComplete ( ElementMementoRequest request ) { if ( fContentProvider . isDisposed ( ) ) { return ; } notifyStateUpdate ( input , TreeModelContentProvider . UPDATE_COMPLETE , request ) ; if ( ! request . isCanceled ( ) & & ( request . getStatus ( ) = = null | | request . getStatus ( ) . isOK ( ) ) ) { XMLMemento keyMemento = ( XMLMemento ) delta . getElement ( ) ; StringWriter writer = new StringWriter ( ) ; try { keyMemento . save ( writer ) ; final String keyMementoString = writer . toString ( ) ; ModelDelta stateDelta = fViewerStates . get ( keyMementoString ) ; if ( stateDelta ! = null ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fRequest + <str> ) ; } fContentProvider . getViewer ( ) . getDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { if ( ! fContentProvider . isDisposed ( ) & & input . equals ( fContentProvider . getViewer ( ) . getInput ( ) ) ) { ModelDelta stateDelta2 = fViewerStates . remove ( keyMementoString ) ; if ( stateDelta2 ! = null ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; DebugUIPlugin . trace ( <str> + stateDelta2 . toString ( ) ) ; notifyStateUpdate ( input , STATE_RESTORE_SEQUENCE_BEGINS , null ) ; } stateDelta2 . setElement ( input ) ; fPendingState = stateDelta2 ; doInitialRestore ( fPendingState ) ; } } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; } } } } ) ; } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fRequest + <str> ) ; } } } catch ( IOException e ) { DebugUIPlugin . log ( e ) ; } } else { notifyStateUpdate ( input , STATE_RESTORE_SEQUENCE_BEGINS , null ) ; } } @Override public void processReqeusts ( ) { notifyStateUpdate ( input , STATE_RESTORE_SEQUENCE_BEGINS , null ) ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fRequest ) ; } notifyStateUpdate ( input , TreeModelContentProvider . UPDATE_BEGINS , fRequest ) ; defaultProvider . encodeElements ( new IElementMementoRequest [ ] { fRequest } ) ; } @Override public void addRequest ( ElementMementoRequest req ) { fRequest = req ; } @Override public void cancel ( ) { } } ; manager . addRequest ( new ElementMementoRequest ( fContentProvider , fContentProvider . getViewer ( ) . getInput ( ) , manager , delta . getElement ( ) , fContentProvider . getViewerTreePath ( delta ) , inputMemento , delta ) ) ; manager . processReqeusts ( ) ; } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; } } } void appendToPendingStateDelta ( final TreePath path ) { if ( fContentProvider . getViewer ( ) = = null ) { return ; } if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + path . getLastSegment ( ) ) ; } final ModelDelta appendDeltaRoot = new ModelDelta ( fContentProvider . getViewer ( ) . getInput ( ) , IModelDelta . NO_CHANGE ) ; ModelDelta delta = appendDeltaRoot ; for ( int i = <int> ; i < path . getSegmentCount ( ) ; i + + ) { delta = delta . addNode ( path . getSegment ( i ) , IModelDelta . NO_CHANGE ) ; } if ( ! fContentProvider . getViewer ( ) . saveElementState ( path , delta , IModelDelta . COLLAPSE | IModelDelta . EXPAND | IModelDelta . SELECT ) ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + path . getLastSegment ( ) + <str> ) ; } return ; } delta . accept ( new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta d , int depth ) { if ( ( d . getFlags ( ) & IModelDelta . EXPAND ) ! = <int> ) { ( ( ModelDelta ) d ) . setFlags ( d . getFlags ( ) | IModelDelta . CONTENT ) ; } return true ; } } ) ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + appendDeltaRoot ) ; } if ( fPendingState ! = null ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fPendingState ) ; } if ( path . getSegmentCount ( ) > <int> ) { fPendingState . accept ( new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta pendingDeltaNode , int depth ) { TreePath pendingDeltaPath = fContentProvider . getViewerTreePath ( pendingDeltaNode ) ; if ( path . startsWith ( pendingDeltaPath , null ) ) { ModelDelta appendDelta = findDeltaForPath ( appendDeltaRoot , pendingDeltaPath ) ; appendDelta . setFlags ( pendingDeltaNode . getFlags ( ) ) ; appendDelta . setChildCount ( pendingDeltaNode . getChildCount ( ) ) ; appendDelta . setIndex ( pendingDeltaNode . getIndex ( ) ) ; return true ; } return false ; } } ) ; } fPendingState . accept ( new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta pendingDeltaNode , int depth ) { if ( pendingDeltaNode . getParentDelta ( ) = = null ) { return true ; } ModelDelta saveDeltaNode = findSubDeltaParent ( appendDeltaRoot , pendingDeltaNode ) ; if ( saveDeltaNode ! = null & & ! isDeltaInParent ( pendingDeltaNode , saveDeltaNode ) & & pendingDeltaNode . getFlags ( ) ! = IModelDelta . NO_CHANGE ) { saveDeltaNode . setChildCount ( pendingDeltaNode . getParentDelta ( ) . getChildCount ( ) ) ; copyIntoDelta ( pendingDeltaNode , saveDeltaNode ) ; } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + pendingDeltaNode . getElement ( ) ) ; } } if ( pendingDeltaNode . getElement ( ) instanceof IMemento ) { return false ; } else { return pendingDeltaNode . getChildCount ( ) > <int> ; } } } ) ; } if ( appendDeltaRoot . getChildDeltas ( ) . length > <int> ) { if ( fPendingState = = null ) { notifyStateUpdate ( appendDeltaRoot . getElement ( ) , STATE_RESTORE_SEQUENCE_BEGINS , null ) ; } fPendingState = appendDeltaRoot ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fPendingState ) ; } } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; } } } protected void saveViewerState ( Object input ) { for ( Iterator < ElementCompareRequest > itr = fCompareRequestsInProgress . values ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { itr . next ( ) . cancel ( ) ; itr . remove ( ) ; } IElementMementoProvider stateProvider = ViewerAdapterService . getMementoProvider ( input ) ; if ( stateProvider ! = null ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + input ) ; } final ModelDelta saveDeltaRoot = new ModelDelta ( input , IModelDelta . NO_CHANGE ) ; buildViewerState ( saveDeltaRoot ) ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + saveDeltaRoot ) ; } if ( fPendingSetTopItem ! = null ) { ModelDelta revealDelta = fPendingSetTopItem . getDelta ( ) ; revealDelta . setFlags ( revealDelta . getFlags ( ) | IModelDelta . REVEAL ) ; fPendingSetTopItem . dispose ( ) ; ModelDelta saveDeltaNode = findSubDeltaParent ( saveDeltaRoot , revealDelta ) ; if ( saveDeltaNode ! = null ) { clearRevealFlag ( saveDeltaRoot ) ; ModelDelta child = saveDeltaNode . getChildDelta ( revealDelta . getElement ( ) , revealDelta . getIndex ( ) ) ; if ( child ! = null ) { child . setFlags ( child . getFlags ( ) | IModelDelta . REVEAL ) ; } else { saveDeltaNode . setChildCount ( revealDelta . getParentDelta ( ) . getChildCount ( ) ) ; copyIntoDelta ( revealDelta , saveDeltaNode ) ; } } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + revealDelta . getElement ( ) ) ; } } } if ( fPendingState ! = null ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fPendingState ) ; } IModelDeltaVisitor pendingStateVisitor = new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta pendingDeltaNode , int depth ) { if ( pendingDeltaNode . getParentDelta ( ) = = null ) { return true ; } ModelDelta saveDeltaNode = findSubDeltaParent ( saveDeltaRoot , pendingDeltaNode ) ; if ( saveDeltaNode ! = null & & ! isDeltaInParent ( pendingDeltaNode , saveDeltaNode ) & & pendingDeltaNode . getFlags ( ) ! = IModelDelta . NO_CHANGE ) { if ( ( pendingDeltaNode . getFlags ( ) & IModelDelta . REVEAL ) ! = <int> ) { clearRevealFlag ( saveDeltaRoot ) ; } saveDeltaNode . setChildCount ( pendingDeltaNode . getParentDelta ( ) . getChildCount ( ) ) ; copyIntoDelta ( pendingDeltaNode , saveDeltaNode ) ; } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + pendingDeltaNode . getElement ( ) ) ; } } if ( pendingDeltaNode . getElement ( ) instanceof IMemento ) { return false ; } else { return pendingDeltaNode . getChildCount ( ) > <int> ; } } } ; fPendingState . accept ( pendingStateVisitor ) ; } if ( saveDeltaRoot . getChildDeltas ( ) . length > <int> ) { encodeDelta ( saveDeltaRoot , stateProvider ) ; } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> ) ; } } } } private void clearRevealFlag ( ModelDelta saveRootDelta ) { IModelDeltaVisitor clearDeltaVisitor = new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta delta , int depth ) { if ( ( delta . getFlags ( ) & IModelDelta . REVEAL ) ! = <int> ) { ( ( ModelDelta ) delta ) . setFlags ( delta . getFlags ( ) & ~ IModelDelta . REVEAL ) ; } return true ; } } ; saveRootDelta . accept ( clearDeltaVisitor ) ; } private ModelDelta findSubDeltaParent ( ModelDelta destinationDeltaRoot , IModelDelta subDelta ) { LinkedList < IModelDelta > deltaPath = new LinkedList < IModelDelta > ( ) ; IModelDelta delta = subDelta ; while ( delta . getParentDelta ( ) ! = null ) { delta = delta . getParentDelta ( ) ; deltaPath . addFirst ( delta ) ; } Iterator < IModelDelta > itr = deltaPath . iterator ( ) ; itr . next ( ) ; ModelDelta saveDelta = destinationDeltaRoot ; while ( saveDelta ! = null & & itr . hasNext ( ) ) { IModelDelta itrDelta = itr . next ( ) ; saveDelta = saveDelta . getChildDelta ( itrDelta . getElement ( ) , itrDelta . getIndex ( ) ) ; } return saveDelta ; } private ModelDelta findDeltaForPath ( ModelDelta root , TreePath path ) { ModelDelta delta = root ; for ( int i = <int> ; i < path . getSegmentCount ( ) ; i + + ) { delta = delta . getChildDelta ( path . getSegment ( i ) ) ; if ( delta = = null ) { return null ; } } return delta ; } private boolean isDeltaInParent ( IModelDelta delta , ModelDelta destParent ) { return destParent . getChildDelta ( delta . getElement ( ) , delta . getIndex ( ) ) ! = null ; } private void copyIntoDelta ( IModelDelta delta , ModelDelta destParent ) { ModelDelta newDelta = destParent . addNode ( delta . getElement ( ) , delta . getIndex ( ) , delta . getFlags ( ) , delta . getChildCount ( ) ) ; for ( int i = <int> ; i < delta . getChildDeltas ( ) . length ; i + + ) { copyIntoDelta ( delta . getChildDeltas ( ) [ i ] , newDelta ) ; } } protected void encodeDelta ( final ModelDelta rootDelta , final IElementMementoProvider defaultProvider ) { final Object input = rootDelta . getElement ( ) ; final XMLMemento inputMemento = XMLMemento . createWriteRoot ( <str> ) ; final XMLMemento childrenMemento = XMLMemento . createWriteRoot ( <str> ) ; final IElementMementoCollector manager = new IElementMementoCollector ( ) { private List < IElementMementoRequest > fRequests = new ArrayList < IElementMementoRequest > ( ) ; private boolean fCanceled = false ; @Override public void requestComplete ( ElementMementoRequest request ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; notifyStateUpdate ( input , TreeModelContentProvider . UPDATE_COMPLETE , request ) ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + request ) ; } if ( ! request . isCanceled ( ) & & ( request . getStatus ( ) = = null | | request . getStatus ( ) . isOK ( ) ) ) { boolean requestsComplted = false ; if ( ! fCanceled ) { fRequests . remove ( request ) ; requestsComplted = fRequests . isEmpty ( ) ; } if ( requestsComplted ) { XMLMemento keyMemento = ( XMLMemento ) rootDelta . getElement ( ) ; StringWriter writer = new StringWriter ( ) ; try { keyMemento . save ( writer ) ; fViewerStates . put ( writer . toString ( ) , rootDelta ) ; } catch ( IOException e ) { DebugUIPlugin . log ( e ) ; } if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + rootDelta ) ; } stateSaveComplete ( input , this ) ; } } else { cancel ( ) ; } } @Override public void cancel ( ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; if ( fCanceled ) { return ; } fCanceled = true ; for ( IElementMementoRequest req : fRequests ) { req . cancel ( ) ; } fRequests . clear ( ) ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + rootDelta . getElement ( ) ) ; } stateSaveComplete ( input , this ) ; } @Override public void processReqeusts ( ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; Map < IElementMementoProvider , List < IElementMementoRequest > > providers = new HashMap < IElementMementoProvider , List < IElementMementoRequest > > ( ) ; for ( IElementMementoRequest request : fRequests ) { notifyStateUpdate ( input , TreeModelContentProvider . UPDATE_BEGINS , request ) ; IElementMementoProvider provider = ViewerAdapterService . getMementoProvider ( request . getElement ( ) ) ; if ( provider = = null ) { provider = defaultProvider ; } List < IElementMementoRequest > reqs = providers . get ( provider ) ; if ( reqs = = null ) { reqs = new ArrayList < IElementMementoRequest > ( ) ; providers . put ( provider , reqs ) ; } reqs . add ( request ) ; } for ( Entry < IElementMementoProvider , List < IElementMementoRequest > > entry : providers . entrySet ( ) ) { IElementMementoProvider provider = entry . getKey ( ) ; List < IElementMementoRequest > reqs = entry . getValue ( ) ; provider . encodeElements ( reqs . toArray ( new IElementMementoRequest [ reqs . size ( ) ] ) ) ; } } @Override public void addRequest ( ElementMementoRequest request ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fRequests . add ( request ) ; } } ; IModelDeltaVisitor visitor = new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta delta , int depth ) { if ( ( delta . getFlags ( ) | IModelDelta . EXPAND ) ! = <int> ) { ( ( ModelDelta ) delta ) . setFlags ( delta . getFlags ( ) | IModelDelta . CONTENT ) ; } if ( delta . getParentDelta ( ) = = null ) { manager . addRequest ( new ElementMementoRequest ( fContentProvider , input , manager , delta . getElement ( ) , fContentProvider . getViewerTreePath ( delta ) , inputMemento , ( ModelDelta ) delta ) ) ; } else { if ( ! ( delta . getElement ( ) instanceof XMLMemento ) ) { manager . addRequest ( new ElementMementoRequest ( fContentProvider , input , manager , delta . getElement ( ) , fContentProvider . getViewerTreePath ( delta ) , childrenMemento . createChild ( <str> ) , ( ModelDelta ) delta ) ) ; } } return true ; } } ; rootDelta . accept ( visitor ) ; stateSaveStarted ( input , manager ) ; manager . processReqeusts ( ) ; } private void stateSaveStarted ( Object input , IElementMementoCollector manager ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; notifyStateUpdate ( input , STATE_SAVE_SEQUENCE_BEGINS , null ) ; fPendingStateSaves . add ( manager ) ; } private void stateSaveComplete ( Object input , IElementMementoCollector manager ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; notifyStateUpdate ( input , STATE_SAVE_SEQUENCE_COMPLETE , null ) ; fPendingStateSaves . remove ( manager ) ; if ( fQueuedRestore ! = null ) { Object temp = fQueuedRestore ; fQueuedRestore = null ; restoreViewerState ( temp ) ; } } private boolean isSavingState ( ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; return ! fPendingStateSaves . isEmpty ( ) ; } protected void restoreViewerState ( final Object input ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; fPendingState = null ; if ( isSavingState ( ) ) { fQueuedRestore = input ; } else { startRestoreViewerState ( input ) ; } } public void cancelRestore ( final TreePath path , final int flags ) { if ( fInStateRestore ) { return ; } if ( ( flags & IModelDelta . REVEAL ) ! = <int> & & fPendingSetTopItem ! = null ) { fPendingSetTopItem . dispose ( ) ; return ; } if ( fPendingState = = null ) { return ; } if ( ( flags & ( IModelDelta . SELECT | IModelDelta . REVEAL ) ) ! = <int> ) { final int mask = flags & ( IModelDelta . SELECT | IModelDelta . REVEAL ) ; fPendingState . accept ( new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta delta , int depth ) { int deltaFlags = delta . getFlags ( ) ; int newFlags = deltaFlags & ~ mask ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { if ( deltaFlags ! = newFlags ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> + Integer . toHexString ( deltaFlags & mask ) + <str> ) ; } } ( ( ModelDelta ) delta ) . setFlags ( newFlags ) ; return true ; } } ) ; } if ( ( flags & ~ ( IModelDelta . SELECT | IModelDelta . REVEAL ) ) ! = <int> ) { final int mask = flags & ~ ( IModelDelta . SELECT | IModelDelta . REVEAL ) ; fPendingState . accept ( new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta delta , int depth ) { if ( depth < path . getSegmentCount ( ) ) { TreePath deltaPath = fContentProvider . getViewerTreePath ( delta ) ; if ( path . startsWith ( deltaPath , null ) ) { return true ; } else { return false ; } } else if ( depth = = path . getSegmentCount ( ) ) { TreePath deltaPath = fContentProvider . getViewerTreePath ( delta ) ; if ( deltaPath . equals ( path ) ) { int deltaFlags = delta . getFlags ( ) ; int newFlags = deltaFlags & ~ mask ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { if ( deltaFlags ! = newFlags ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> + Integer . toHexString ( deltaFlags & mask ) + <str> ) ; } } ( ( ModelDelta ) delta ) . setFlags ( newFlags ) ; if ( ( flags & IModelDelta . EXPAND ) ! = <int> ) { return true ; } } return false ; } else { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { if ( delta . getFlags ( ) ! = IModelDelta . NO_CHANGE ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) + <str> + Integer . toHexString ( delta . getFlags ( ) ) + <str> ) ; } } ( ( ModelDelta ) delta ) . setFlags ( IModelDelta . NO_CHANGE ) ; return true ; } } } ) ; } } void restorePendingStateOnUpdate ( final TreePath path , final int modelIndex , final boolean knowsHasChildren , final boolean knowsChildCount , final boolean checkChildrenRealized ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; if ( fPendingState = = null ) { return ; } IModelDeltaVisitor visitor = new IModelDeltaVisitor ( ) { @Override public boolean visit ( final IModelDelta delta , int depth ) { Object element = delta . getElement ( ) ; Object potentialMatch = depth ! = <int> ? path . getSegment ( depth - <int> ) : fContentProvider . getViewer ( ) . getInput ( ) ; if ( depth = = path . getSegmentCount ( ) ) { if ( element instanceof IMemento ) { IElementMementoProvider provider = ViewerAdapterService . getMementoProvider ( potentialMatch ) ; if ( provider = = null ) { provider = ViewerAdapterService . getMementoProvider ( fContentProvider . getViewer ( ) . getInput ( ) ) ; } if ( provider ! = null ) { CompareRequestKey key = new CompareRequestKey ( path , delta ) ; ElementCompareRequest existingRequest = fCompareRequestsInProgress . get ( key ) ; if ( existingRequest ! = null ) { existingRequest . setKnowsHasChildren ( knowsHasChildren ) ; existingRequest . setKnowsChildCount ( knowsChildCount ) ; existingRequest . setCheckChildrenRealized ( checkChildrenRealized ) ; } else { ElementCompareRequest compareRequest = new ElementCompareRequest ( fContentProvider , fContentProvider . getViewer ( ) . getInput ( ) , potentialMatch , path , ( IMemento ) element , ( ModelDelta ) delta , modelIndex , knowsHasChildren , knowsChildCount , checkChildrenRealized ) ; fCompareRequestsInProgress . put ( key , compareRequest ) ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + compareRequest ) ; } notifyStateUpdate ( element , TreeModelContentProvider . UPDATE_BEGINS , compareRequest ) ; provider . compareElements ( new IElementCompareRequest [ ] { compareRequest } ) ; } } } else if ( element . equals ( potentialMatch ) ) { restorePendingStateNode ( ( ModelDelta ) delta , knowsHasChildren , knowsChildCount , checkChildrenRealized ) ; } return false ; } return element . equals ( potentialMatch ) ; } } ; try { fInStateRestore = true ; fPendingState . accept ( visitor ) ; } finally { fInStateRestore = false ; } checkIfRestoreComplete ( ) ; } void checkIfRestoreComplete ( ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; if ( fPendingState = = null ) { return ; } class CheckState implements IModelDeltaVisitor { private boolean complete = true ; @Override public boolean visit ( IModelDelta delta , int depth ) { int flags = ( delta . getFlags ( ) & ~ IModelDelta . CONTENT ) ; if ( flags ! = IModelDelta . NO_CHANGE ) { IModelDelta parentDelta = delta . getParentDelta ( ) ; if ( parentDelta ! = null & & parentDelta . getFlags ( ) = = IModelDelta . NO_CHANGE ) { TreePath deltaPath = fContentProvider . getViewerTreePath ( delta ) ; if ( ! fContentProvider . areElementUpdatesPending ( deltaPath ) & & ( ! ( delta . getElement ( ) instanceof IMemento ) | | ! areMementoUpdatesPending ( delta ) ) ) { removeDelta ( delta ) ; return false ; } } if ( flags ! = IModelDelta . REVEAL | | ( delta . getElement ( ) instanceof IMemento ) ) { complete = false ; return false ; } } return true ; } public boolean isComplete ( ) { return complete ; } private boolean areMementoUpdatesPending ( IModelDelta delta ) { for ( CompareRequestKey key : fCompareRequestsInProgress . keySet ( ) ) { if ( delta . getElement ( ) . equals ( key . fDelta . getElement ( ) ) ) { return true ; } } return false ; } private void removeDelta ( IModelDelta delta ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + delta . getElement ( ) ) ; } delta . accept ( new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta _visitorDelta , int depth ) { ModelDelta visitorDelta = ( ModelDelta ) _visitorDelta ; visitorDelta . setElement ( ELEMENT_REMOVED ) ; visitorDelta . setFlags ( IModelDelta . NO_CHANGE ) ; return true ; } } ) ; } } CheckState state = new CheckState ( ) ; fPendingState . accept ( state ) ; if ( state . isComplete ( ) ) { if ( fPendingSetTopItem = = null ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fPendingState ) ; } notifyStateUpdate ( fPendingState . getElement ( ) , STATE_RESTORE_SEQUENCE_COMPLETE , null ) ; } fPendingState = null ; } } void restorePendingStateNode ( final ModelDelta delta , boolean knowsHasChildren , boolean knowsChildCount , boolean checkChildrenRealized ) { final TreePath treePath = fContentProvider . getViewerTreePath ( delta ) ; final IInternalTreeModelViewer viewer = fContentProvider . getViewer ( ) ; if ( knowsHasChildren ) { if ( ( delta . getFlags ( ) & IModelDelta . EXPAND ) ! = <int> ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + treePath . getLastSegment ( ) ) ; } viewer . expandToLevel ( treePath , <int> ) ; delta . setFlags ( delta . getFlags ( ) & ~ IModelDelta . EXPAND ) ; } if ( ( delta . getFlags ( ) & IModelDelta . COLLAPSE ) ! = <int> ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + treePath . getLastSegment ( ) ) ; } int autoexpand = fContentProvider . getViewer ( ) . getAutoExpandLevel ( ) ; if ( autoexpand ! = ITreeModelViewer . ALL_LEVELS & & autoexpand < ( treePath . getSegmentCount ( ) + <int> ) ) { fContentProvider . getViewer ( ) . setExpandedState ( treePath , false ) ; } delta . setFlags ( delta . getFlags ( ) & ~ IModelDelta . COLLAPSE ) ; } } if ( ( delta . getFlags ( ) & IModelDelta . SELECT ) ! = <int> ) { delta . setFlags ( delta . getFlags ( ) & ~ IModelDelta . SELECT ) ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + treePath . getLastSegment ( ) ) ; } ITreeSelection currentSelection = ( ITreeSelection ) viewer . getSelection ( ) ; if ( currentSelection = = null | | currentSelection . isEmpty ( ) ) { viewer . setSelection ( new TreeSelection ( treePath ) , false , false ) ; } else { TreePath [ ] currentPaths = currentSelection . getPaths ( ) ; boolean pathInSelection = false ; for ( int i = <int> ; i < currentPaths . length ; i + + ) { if ( currentPaths [ i ] . equals ( treePath ) ) { pathInSelection = true ; break ; } } if ( ! pathInSelection ) { TreePath [ ] newPaths = new TreePath [ currentPaths . length + <int> ] ; System . arraycopy ( currentPaths , <int> , newPaths , <int> , currentPaths . length ) ; newPaths [ newPaths . length - <int> ] = treePath ; viewer . setSelection ( new TreeSelection ( newPaths ) , false , false ) ; } } } if ( ( delta . getFlags ( ) & IModelDelta . REVEAL ) ! = <int> ) { delta . setFlags ( delta . getFlags ( ) & ~ IModelDelta . REVEAL ) ; boolean setTopItem = true ; IModelDelta [ ] childDeltas = delta . getChildDeltas ( ) ; for ( int i = <int> ; i < childDeltas . length ; i + + ) { IModelDelta childDelta = childDeltas [ i ] ; int modelIndex = childDelta . getIndex ( ) ; if ( modelIndex > = <int> & & ( childDelta . getFlags ( ) & IModelDelta . REVEAL ) ! = <int> ) { setTopItem = false ; } } if ( setTopItem ) { Assert . isTrue ( fPendingSetTopItem = = null ) ; fPendingSetTopItem = new PendingRevealDelta ( treePath , delta ) ; viewer . addViewerUpdateListener ( fPendingSetTopItem ) ; } } if ( knowsChildCount ) { int childCount = viewer . getChildCount ( treePath ) ; if ( childCount > = <int> ) { ModelDelta [ ] childDeltas = ( ModelDelta [ ] ) delta . getChildDeltas ( ) ; for ( int i = <int> ; i < childDeltas . length ; i + + ) { ModelDelta childDelta = childDeltas [ i ] ; int modelIndex = childDelta . getIndex ( ) ; if ( modelIndex > = <int> & & ( childDelta . getFlags ( ) & IModelDelta . REVEAL ) ! = <int> ) { if ( modelIndex < childCount ) { fContentProvider . doUpdateElement ( treePath , modelIndex ) ; } else { childDelta . setFlags ( childDelta . getFlags ( ) & ~ IModelDelta . REVEAL ) ; } } } } } if ( ( checkChildrenRealized & & ! fContentProvider . areChildrenUpdatesPending ( treePath ) & & fContentProvider . getViewer ( ) . getElementChildrenRealized ( treePath ) ) | | ( knowsHasChildren & & ! viewer . getHasChildren ( treePath ) ) ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + treePath . getLastSegment ( ) ) ; } delta . setFlags ( delta . getFlags ( ) & ~ IModelDelta . CONTENT ) ; } } private class PendingRevealDelta implements IViewerUpdateListener { private final TreePath fPathToReveal ; private final ModelDelta fRevealDelta ; PendingRevealDelta ( TreePath pathToReveal , ModelDelta revealDelta ) { fPathToReveal = pathToReveal ; fRevealDelta = revealDelta ; } private int fCounter = <int> ; private Object fModelInput = fPendingState . getElement ( ) ; @Override public void viewerUpdatesComplete ( ) { Assert . isTrue ( fContentProvider . getViewer ( ) . getDisplay ( ) . getThread ( ) = = Thread . currentThread ( ) ) ; IInternalTreeModelViewer viewer = fContentProvider . getViewer ( ) ; if ( viewer = = null | | fPendingSetTopItem ! = this ) { return ; } TreePath topPath = viewer . getTopElementPath ( ) ; if ( ! fPathToReveal . equals ( topPath ) ) { TreePath parentPath = fPathToReveal . getParentPath ( ) ; int index = viewer . findElementIndex ( parentPath , fPathToReveal . getLastSegment ( ) ) ; if ( index > = <int> ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fPathToReveal . getLastSegment ( ) ) ; } viewer . reveal ( parentPath , index ) ; } } fCounter + + ; if ( fCounter > <int> | | fPendingState = = null ) { dispose ( ) ; } } @Override public void viewerUpdatesBegin ( ) { } @Override public void updateStarted ( IViewerUpdate update ) { } @Override public void updateComplete ( IViewerUpdate update ) { } public ModelDelta getDelta ( ) { return fRevealDelta ; } public void dispose ( ) { fPendingSetTopItem = null ; IInternalTreeModelViewer viewer = fContentProvider . getViewer ( ) ; if ( viewer = = null ) { return ; } viewer . removeViewerUpdateListener ( this ) ; if ( fPendingState = = null ) { if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + fPendingState ) ; } notifyStateUpdate ( fModelInput , STATE_RESTORE_SEQUENCE_COMPLETE , null ) ; } else { checkIfRestoreComplete ( ) ; } } } protected void doInitialRestore ( ModelDelta delta ) { markRevealDelta ( delta ) ; int count = fContentProvider . getViewer ( ) . getChildCount ( TreePath . EMPTY ) ; for ( int i = <int> ; i < count ; i + + ) { Object data = fContentProvider . getViewer ( ) . getChildElement ( TreePath . EMPTY , i ) ; if ( data ! = null ) { restorePendingStateOnUpdate ( new TreePath ( new Object [ ] { data } ) , i , false , false , false ) ; } } } private ModelDelta markRevealDelta ( ModelDelta rootDelta ) { final ModelDelta [ ] revealDelta = new ModelDelta [ <int> ] ; IModelDeltaVisitor visitor = new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta delta , int depth ) { if ( ( delta . getFlags ( ) & IModelDelta . REVEAL ) ! = <int> ) { revealDelta [ <int> ] = ( ModelDelta ) delta ; } return revealDelta [ <int> ] = = null ; } } ; rootDelta . accept ( visitor ) ; if ( revealDelta [ <int> ] ! = null ) { ModelDelta parentDelta = ( ModelDelta ) revealDelta [ <int> ] . getParentDelta ( ) ; while ( parentDelta . getParentDelta ( ) ! = null ) { revealDelta [ <int> ] = parentDelta ; revealDelta [ <int> ] . setFlags ( revealDelta [ <int> ] . getFlags ( ) | IModelDelta . REVEAL ) ; parentDelta = ( ModelDelta ) parentDelta . getParentDelta ( ) ; } } return revealDelta [ <int> ] ; } private void buildViewerState ( ModelDelta delta ) { IInternalTreeModelViewer viewer = fContentProvider . getViewer ( ) ; viewer . saveElementState ( TreeModelContentProvider . EMPTY_TREE_PATH , delta , IModelDelta . SELECT | IModelDelta . EXPAND ) ; TreePath topElementPath = viewer . getTopElementPath ( ) ; if ( topElementPath ! = null ) { ModelDelta parentDelta = delta ; TreePath parentPath = TreeModelContentProvider . EMPTY_TREE_PATH ; for ( int i = <int> ; i < topElementPath . getSegmentCount ( ) ; i + + ) { Object element = topElementPath . getSegment ( i ) ; int index = viewer . findElementIndex ( parentPath , element ) ; ModelDelta childDelta = parentDelta . getChildDelta ( element ) ; if ( childDelta = = null ) { parentDelta = parentDelta . addNode ( element , index , IModelDelta . NO_CHANGE ) ; } else { parentDelta = childDelta ; } parentPath = parentPath . createChildPath ( element ) ; } parentDelta . setFlags ( parentDelta . getFlags ( ) | IModelDelta . REVEAL ) ; } } void cancelStateSubtreeUpdates ( TreePath path ) { for ( Iterator < CompareRequestKey > itr = fCompareRequestsInProgress . keySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { CompareRequestKey key = itr . next ( ) ; if ( key . fPath . startsWith ( path , null ) ) { ElementCompareRequest compareRequest = fCompareRequestsInProgress . get ( key ) ; compareRequest . cancel ( ) ; itr . remove ( ) ; } } } void compareFinished ( ElementCompareRequest request , ModelDelta delta ) { notifyStateUpdate ( request . getViewerInput ( ) , TreeModelContentProvider . UPDATE_COMPLETE , request ) ; if ( DebugUIPlugin . DEBUG_STATE_SAVE_RESTORE & & DebugUIPlugin . DEBUG_TEST_PRESENTATION_ID ( fContentProvider . getPresentationContext ( ) ) ) { DebugUIPlugin . trace ( <str> + request + <str> + false ) ; } fCompareRequestsInProgress . remove ( new CompareRequestKey ( request . getElementPath ( ) , delta ) ) ; if ( ! request . isCanceled ( ) ) { if ( request . isEqual ( ) ) { delta . setElement ( request . getElement ( ) ) ; restorePendingStateNode ( delta , request . knowsHasChildren ( ) , request . knowChildCount ( ) , request . checkChildrenRealized ( ) ) ; } else if ( request . getModelIndex ( ) ! = - <int> ) { if ( ( delta . getFlags ( ) & IModelDelta . REVEAL ) ! = <int> & & delta . getIndex ( ) = = request . getModelIndex ( ) ) { delta . setFlags ( delta . getFlags ( ) & ~ IModelDelta . REVEAL ) ; } } } checkIfRestoreComplete ( ) ; } void addStateUpdateListener ( IStateUpdateListener listener ) { fStateUpdateListeners . add ( listener ) ; } void removeStateUpdateListener ( IStateUpdateListener listener ) { fStateUpdateListeners . remove ( listener ) ; } void notifyStateUpdate ( final Object input , final int type , final IViewerUpdate update ) { if ( ! fStateUpdateListeners . isEmpty ( ) ) { Object [ ] listeners = fStateUpdateListeners . getListeners ( ) ; for ( int i = <int> ; i < listeners . length ; i + + ) { final IStateUpdateListener listener = ( IStateUpdateListener ) listeners [ i ] ; SafeRunner . run ( new ISafeRunnable ( ) { @Override public void run ( ) throws Exception { switch ( type ) { case STATE_SAVE_SEQUENCE_BEGINS : listener . stateSaveUpdatesBegin ( input ) ; break ; case STATE_SAVE_SEQUENCE_COMPLETE : listener . stateSaveUpdatesComplete ( input ) ; break ; case STATE_RESTORE_SEQUENCE_BEGINS : listener . stateRestoreUpdatesBegin ( input ) ; break ; case STATE_RESTORE_SEQUENCE_COMPLETE : listener . stateRestoreUpdatesComplete ( input ) ; break ; case TreeModelContentProvider . UPDATE_BEGINS : listener . stateUpdateStarted ( input , update ) ; break ; case TreeModelContentProvider . UPDATE_COMPLETE : listener . stateUpdateComplete ( input , update ) ; break ; default : break ; } } @Override public void handleException ( Throwable exception ) { DebugUIPlugin . log ( exception ) ; } } ) ; } } } } 
