package com . google . common . reflect ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . reflect . Constructor ; import java . lang . reflect . Method ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . TypeVariable ; import java . util . Collections ; import javax . annotation . Nullable ; @AndroidIncompatible public class InvokableTest extends TestCase { public void testConstructor_returnType ( ) throws Exception { assertEquals ( Prepender . class , Prepender . constructor ( ) . getReturnType ( ) . getType ( ) ) ; } private static class WithConstructorAndTypeParameter < T > { @SuppressWarnings ( <str> ) < X > WithConstructorAndTypeParameter ( ) { } } public void testConstructor_returnType_hasTypeParameter ( ) throws Exception { @SuppressWarnings ( <str> ) Class < WithConstructorAndTypeParameter > type = WithConstructorAndTypeParameter . class ; @SuppressWarnings ( <str> ) Constructor < WithConstructorAndTypeParameter > constructor = type . getDeclaredConstructor ( ) ; Invokable < ? , ? > factory = Invokable . from ( constructor ) ; assertThat ( factory . getTypeParameters ( ) ) . hasLength ( <int> ) ; assertEquals ( type . getTypeParameters ( ) [ <int> ] , factory . getTypeParameters ( ) [ <int> ] ) ; assertEquals ( constructor . getTypeParameters ( ) [ <int> ] , factory . getTypeParameters ( ) [ <int> ] ) ; ParameterizedType returnType = ( ParameterizedType ) factory . getReturnType ( ) . getType ( ) ; assertEquals ( type , returnType . getRawType ( ) ) ; assertEquals ( ImmutableList . copyOf ( type . getTypeParameters ( ) ) , ImmutableList . copyOf ( returnType . getActualTypeArguments ( ) ) ) ; } public void testConstructor_exceptionTypes ( ) throws Exception { assertEquals ( ImmutableList . of ( TypeToken . of ( NullPointerException . class ) ) , Prepender . constructor ( String . class , int . class ) . getExceptionTypes ( ) ) ; } public void testConstructor_typeParameters ( ) throws Exception { TypeVariable < ? > [ ] variables = Prepender . constructor ( ) . getTypeParameters ( ) ; assertThat ( variables ) . hasLength ( <int> ) ; assertEquals ( <str> , variables [ <int> ] . getName ( ) ) ; } public void testConstructor_parameters ( ) throws Exception { Invokable < ? , Prepender > delegate = Prepender . constructor ( String . class , int . class ) ; ImmutableList < Parameter > parameters = delegate . getParameters ( ) ; assertEquals ( <int> , parameters . size ( ) ) ; assertEquals ( String . class , parameters . get ( <int> ) . getType ( ) . getType ( ) ) ; assertTrue ( parameters . get ( <int> ) . isAnnotationPresent ( NotBlank . class ) ) ; assertEquals ( int . class , parameters . get ( <int> ) . getType ( ) . getType ( ) ) ; assertFalse ( parameters . get ( <int> ) . isAnnotationPresent ( NotBlank . class ) ) ; new EqualsTester ( ) . addEqualityGroup ( parameters . get ( <int> ) ) . addEqualityGroup ( parameters . get ( <int> ) ) . testEquals ( ) ; } public void testConstructor_call ( ) throws Exception { Invokable < ? , Prepender > delegate = Prepender . constructor ( String . class , int . class ) ; Prepender prepender = delegate . invoke ( null , <str> , <int> ) ; assertEquals ( <str> , prepender . prefix ) ; assertEquals ( <int> , prepender . times ) ; } public void testConstructor_returning ( ) throws Exception { Invokable < ? , Prepender > delegate = Prepender . constructor ( String . class , int . class ) . returning ( Prepender . class ) ; Prepender prepender = delegate . invoke ( null , <str> , <int> ) ; assertEquals ( <str> , prepender . prefix ) ; assertEquals ( <int> , prepender . times ) ; } public void testConstructor_invalidReturning ( ) throws Exception { Invokable < ? , Prepender > delegate = Prepender . constructor ( String . class , int . class ) ; try { delegate . returning ( SubPrepender . class ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testStaticMethod_returnType ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , String . class , Iterable . class ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , delegate . getReturnType ( ) ) ; } public void testStaticMethod_exceptionTypes ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , String . class , Iterable . class ) ; assertEquals ( ImmutableList . of ( ) , delegate . getExceptionTypes ( ) ) ; } public void testStaticMethod_typeParameters ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , String . class , Iterable . class ) ; TypeVariable < ? > [ ] variables = delegate . getTypeParameters ( ) ; assertThat ( variables ) . hasLength ( <int> ) ; assertEquals ( <str> , variables [ <int> ] . getName ( ) ) ; } public void testStaticMethod_parameters ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , String . class , Iterable . class ) ; ImmutableList < Parameter > parameters = delegate . getParameters ( ) ; assertEquals ( <int> , parameters . size ( ) ) ; assertEquals ( String . class , parameters . get ( <int> ) . getType ( ) . getType ( ) ) ; assertTrue ( parameters . get ( <int> ) . isAnnotationPresent ( NotBlank . class ) ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , parameters . get ( <int> ) . getType ( ) ) ; assertFalse ( parameters . get ( <int> ) . isAnnotationPresent ( NotBlank . class ) ) ; new EqualsTester ( ) . addEqualityGroup ( parameters . get ( <int> ) ) . addEqualityGroup ( parameters . get ( <int> ) ) . testEquals ( ) ; } public void testStaticMethod_call ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , String . class , Iterable . class ) ; @SuppressWarnings ( <str> ) Iterable < String > result = ( Iterable < String > ) delegate . invoke ( null , <str> , ImmutableList . of ( <str> , <str> ) ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> ) , ImmutableList . copyOf ( result ) ) ; } public void testStaticMethod_returning ( ) throws Exception { Invokable < ? , Iterable < String > > delegate = Prepender . method ( <str> , String . class , Iterable . class ) . returning ( new TypeToken < Iterable < String > > ( ) { } ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , delegate . getReturnType ( ) ) ; Iterable < String > result = delegate . invoke ( null , <str> , ImmutableList . of ( <str> , <str> ) ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> ) , ImmutableList . copyOf ( result ) ) ; } public void testStaticMethod_returningRawType ( ) throws Exception { @SuppressWarnings ( <str> ) Invokable < ? , Iterable > delegate = Prepender . method ( <str> , String . class , Iterable . class ) . returning ( Iterable . class ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , delegate . getReturnType ( ) ) ; @SuppressWarnings ( <str> ) Iterable < String > result = delegate . invoke ( null , <str> , ImmutableList . of ( <str> , <str> ) ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> ) , ImmutableList . copyOf ( result ) ) ; } public void testStaticMethod_invalidReturning ( ) throws Exception { Invokable < ? , Object > delegate = Prepender . method ( <str> , String . class , Iterable . class ) ; try { delegate . returning ( new TypeToken < Iterable < Integer > > ( ) { } ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testInstanceMethod_returnType ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , Iterable . class ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , delegate . getReturnType ( ) ) ; } public void testInstanceMethod_exceptionTypes ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , Iterable . class ) ; assertEquals ( ImmutableList . of ( TypeToken . of ( IllegalArgumentException . class ) , TypeToken . of ( NullPointerException . class ) ) , delegate . getExceptionTypes ( ) ) ; } public void testInstanceMethod_typeParameters ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , Iterable . class ) ; assertThat ( delegate . getTypeParameters ( ) ) . isEmpty ( ) ; } public void testInstanceMethod_parameters ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , Iterable . class ) ; ImmutableList < Parameter > parameters = delegate . getParameters ( ) ; assertEquals ( <int> , parameters . size ( ) ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , parameters . get ( <int> ) . getType ( ) ) ; assertThat ( parameters . get ( <int> ) . getAnnotations ( ) ) . isEmpty ( ) ; new EqualsTester ( ) . addEqualityGroup ( parameters . get ( <int> ) ) . testEquals ( ) ; } public void testInstanceMethod_call ( ) throws Exception { Invokable < Prepender , ? > delegate = Prepender . method ( <str> , Iterable . class ) ; @SuppressWarnings ( <str> ) Iterable < String > result = ( Iterable < String > ) delegate . invoke ( new Prepender ( <str> , <int> ) , ImmutableList . of ( <str> , <str> ) ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> ) , ImmutableList . copyOf ( result ) ) ; } public void testInstanceMethod_returning ( ) throws Exception { Invokable < Prepender , Iterable < String > > delegate = Prepender . method ( <str> , Iterable . class ) . returning ( new TypeToken < Iterable < String > > ( ) { } ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , delegate . getReturnType ( ) ) ; Iterable < String > result = delegate . invoke ( new Prepender ( <str> , <int> ) , ImmutableList . of ( <str> , <str> ) ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> ) , ImmutableList . copyOf ( result ) ) ; } public void testInstanceMethod_returningRawType ( ) throws Exception { @SuppressWarnings ( <str> ) Invokable < Prepender , Iterable > delegate = Prepender . method ( <str> , Iterable . class ) . returning ( Iterable . class ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , delegate . getReturnType ( ) ) ; @SuppressWarnings ( <str> ) Iterable < String > result = delegate . invoke ( new Prepender ( <str> , <int> ) , ImmutableList . of ( <str> , <str> ) ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> ) , ImmutableList . copyOf ( result ) ) ; } public void testInstanceMethod_invalidReturning ( ) throws Exception { Invokable < ? , Object > delegate = Prepender . method ( <str> , Iterable . class ) ; try { delegate . returning ( new TypeToken < Iterable < Integer > > ( ) { } ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testPrivateInstanceMethod_isOverridable ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> ) ; assertTrue ( delegate . isPrivate ( ) ) ; assertFalse ( delegate . isOverridable ( ) ) ; assertFalse ( delegate . isVarArgs ( ) ) ; } public void testPrivateFinalInstanceMethod_isOverridable ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> ) ; assertTrue ( delegate . isPrivate ( ) ) ; assertTrue ( delegate . isFinal ( ) ) ; assertFalse ( delegate . isOverridable ( ) ) ; assertFalse ( delegate . isVarArgs ( ) ) ; } public void testStaticMethod_isOverridable ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> ) ; assertTrue ( delegate . isStatic ( ) ) ; assertFalse ( delegate . isOverridable ( ) ) ; assertFalse ( delegate . isVarArgs ( ) ) ; } public void testStaticFinalMethod_isFinal ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> ) ; assertTrue ( delegate . isStatic ( ) ) ; assertTrue ( delegate . isFinal ( ) ) ; assertFalse ( delegate . isOverridable ( ) ) ; assertFalse ( delegate . isVarArgs ( ) ) ; } static class Foo { } public void testConstructor_isOverridablel ( ) throws Exception { Invokable < ? , ? > delegate = Invokable . from ( Foo . class . getDeclaredConstructor ( ) ) ; assertFalse ( delegate . isOverridable ( ) ) ; assertFalse ( delegate . isVarArgs ( ) ) ; } public void testMethod_isVarArgs ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . method ( <str> , String [ ] . class ) ; assertTrue ( delegate . isVarArgs ( ) ) ; } public void testConstructor_isVarArgs ( ) throws Exception { Invokable < ? , ? > delegate = Prepender . constructor ( String [ ] . class ) ; assertTrue ( delegate . isVarArgs ( ) ) ; } public void testGetOwnerType_constructor ( ) throws Exception { Invokable < String , String > invokable = Invokable . from ( String . class . getConstructor ( ) ) ; assertEquals ( TypeToken . of ( String . class ) , invokable . getOwnerType ( ) ) ; } public void testGetOwnerType_method ( ) throws Exception { Invokable < ? , ? > invokable = Invokable . from ( String . class . getMethod ( <str> ) ) ; assertEquals ( TypeToken . of ( String . class ) , invokable . getOwnerType ( ) ) ; } private static final class FinalClass { @SuppressWarnings ( <str> ) void notFinalMethod ( ) { } } public void testNonFinalMethodInFinalClass_isOverridable ( ) throws Exception { Invokable < ? , ? > delegate = Invokable . from ( FinalClass . class . getDeclaredMethod ( <str> ) ) ; assertFalse ( delegate . isOverridable ( ) ) ; assertFalse ( delegate . isVarArgs ( ) ) ; } private class InnerWithDefaultConstructor { class NestedInner { } } public void testInnerClassDefaultConstructor ( ) { Constructor < ? > constructor = InnerWithDefaultConstructor . class . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } public void testNestedInnerClassDefaultConstructor ( ) { Constructor < ? > constructor = InnerWithDefaultConstructor . NestedInner . class . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } private class InnerWithOneParameterConstructor { @SuppressWarnings ( <str> ) public InnerWithOneParameterConstructor ( String s ) { } } public void testInnerClassWithOneParameterConstructor ( ) { Constructor < ? > constructor = InnerWithOneParameterConstructor . class . getDeclaredConstructors ( ) [ <int> ] ; Invokable < ? , ? > invokable = Invokable . from ( constructor ) ; assertEquals ( <int> , invokable . getParameters ( ) . size ( ) ) ; assertEquals ( TypeToken . of ( String . class ) , invokable . getParameters ( ) . get ( <int> ) . getType ( ) ) ; } private class InnerWithAnnotatedConstructorParameter { @SuppressWarnings ( <str> ) InnerWithAnnotatedConstructorParameter ( @Nullable String s ) { } } public void testInnerClassWithAnnotatedConstructorParameter ( ) { Constructor < ? > constructor = InnerWithAnnotatedConstructorParameter . class . getDeclaredConstructors ( ) [ <int> ] ; Invokable < ? , ? > invokable = Invokable . from ( constructor ) ; assertEquals ( <int> , invokable . getParameters ( ) . size ( ) ) ; assertEquals ( TypeToken . of ( String . class ) , invokable . getParameters ( ) . get ( <int> ) . getType ( ) ) ; } private class InnerWithGenericConstructorParameter { @SuppressWarnings ( <str> ) InnerWithGenericConstructorParameter ( Iterable < String > it , String s ) { } } public void testInnerClassWithGenericConstructorParameter ( ) { Constructor < ? > constructor = InnerWithGenericConstructorParameter . class . getDeclaredConstructors ( ) [ <int> ] ; Invokable < ? , ? > invokable = Invokable . from ( constructor ) ; assertEquals ( <int> , invokable . getParameters ( ) . size ( ) ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , invokable . getParameters ( ) . get ( <int> ) . getType ( ) ) ; assertEquals ( TypeToken . of ( String . class ) , invokable . getParameters ( ) . get ( <int> ) . getType ( ) ) ; } public void testAnonymousClassDefaultConstructor ( ) { final int i = <int> ; final String s = <str> ; Class < ? > anonymous = new Runnable ( ) { @Override public void run ( ) { System . out . println ( s + i ) ; } } . getClass ( ) ; Constructor < ? > constructor = anonymous . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } public void testAnonymousClassWithTwoParametersConstructor ( ) { abstract class Base { @SuppressWarnings ( <str> ) Base ( String s , int i ) { } } Class < ? > anonymous = new Base ( <str> , <int> ) { } . getClass ( ) ; Constructor < ? > constructor = anonymous . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } public void testLocalClassDefaultConstructor ( ) { final int i = <int> ; final String s = <str> ; class LocalWithDefaultConstructor implements Runnable { @Override public void run ( ) { System . out . println ( s + i ) ; } } Constructor < ? > constructor = LocalWithDefaultConstructor . class . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } public void testStaticAnonymousClassDefaultConstructor ( ) throws Exception { doTestStaticAnonymousClassDefaultConstructor ( ) ; } private static void doTestStaticAnonymousClassDefaultConstructor ( ) { final int i = <int> ; final String s = <str> ; Class < ? > anonymous = new Runnable ( ) { @Override public void run ( ) { System . out . println ( s + i ) ; } } . getClass ( ) ; Constructor < ? > constructor = anonymous . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } public void testAnonymousClassInConstructor ( ) { new AnonymousClassInConstructor ( ) ; } private static class AnonymousClassInConstructor { AnonymousClassInConstructor ( ) { final int i = <int> ; final String s = <str> ; Class < ? > anonymous = new Runnable ( ) { @Override public void run ( ) { System . out . println ( s + i ) ; } } . getClass ( ) ; Constructor < ? > constructor = anonymous . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } } public void testLocalClassInInstanceInitializer ( ) { new LocalClassInInstanceInitializer ( ) ; } private static class LocalClassInInstanceInitializer { { class Local { } Constructor < ? > constructor = Local . class . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } } public void testLocalClassInStaticInitializer ( ) { new LocalClassInStaticInitializer ( ) ; } private static class LocalClassInStaticInitializer { static { class Local { } Constructor < ? > constructor = Local . class . getDeclaredConstructors ( ) [ <int> ] ; assertEquals ( <int> , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } } public void testLocalClassWithSeeminglyHiddenThisInStaticInitializer_BUG ( ) { new LocalClassWithSeeminglyHiddenThisInStaticInitializer ( ) ; } private static class LocalClassWithSeeminglyHiddenThisInStaticInitializer { static { class Local { @SuppressWarnings ( <str> ) Local ( LocalClassWithSeeminglyHiddenThisInStaticInitializer outer ) { } } Constructor < ? > constructor = Local . class . getDeclaredConstructors ( ) [ <int> ] ; int miscalculated = <int> ; assertEquals ( miscalculated , Invokable . from ( constructor ) . getParameters ( ) . size ( ) ) ; } } public void testLocalClassWithOneParameterConstructor ( ) throws Exception { final int i = <int> ; final String s = <str> ; class LocalWithOneParameterConstructor { @SuppressWarnings ( <str> ) public LocalWithOneParameterConstructor ( String x ) { System . out . println ( s + i ) ; } } Constructor < ? > constructor = LocalWithOneParameterConstructor . class . getDeclaredConstructors ( ) [ <int> ] ; Invokable < ? , ? > invokable = Invokable . from ( constructor ) ; assertEquals ( <int> , invokable . getParameters ( ) . size ( ) ) ; assertEquals ( TypeToken . of ( String . class ) , invokable . getParameters ( ) . get ( <int> ) . getType ( ) ) ; } public void testLocalClassWithAnnotatedConstructorParameter ( ) throws Exception { class LocalWithAnnotatedConstructorParameter { @SuppressWarnings ( <str> ) LocalWithAnnotatedConstructorParameter ( @Nullable String s ) { } } Constructor < ? > constructor = LocalWithAnnotatedConstructorParameter . class . getDeclaredConstructors ( ) [ <int> ] ; Invokable < ? , ? > invokable = Invokable . from ( constructor ) ; assertEquals ( <int> , invokable . getParameters ( ) . size ( ) ) ; assertEquals ( TypeToken . of ( String . class ) , invokable . getParameters ( ) . get ( <int> ) . getType ( ) ) ; } public void testLocalClassWithGenericConstructorParameter ( ) throws Exception { class LocalWithGenericConstructorParameter { @SuppressWarnings ( <str> ) LocalWithGenericConstructorParameter ( Iterable < String > it , String s ) { } } Constructor < ? > constructor = LocalWithGenericConstructorParameter . class . getDeclaredConstructors ( ) [ <int> ] ; Invokable < ? , ? > invokable = Invokable . from ( constructor ) ; assertEquals ( <int> , invokable . getParameters ( ) . size ( ) ) ; assertEquals ( new TypeToken < Iterable < String > > ( ) { } , invokable . getParameters ( ) . get ( <int> ) . getType ( ) ) ; assertEquals ( TypeToken . of ( String . class ) , invokable . getParameters ( ) . get ( <int> ) . getType ( ) ) ; } public void testEquals ( ) throws Exception { new EqualsTester ( ) . addEqualityGroup ( Prepender . constructor ( ) , Prepender . constructor ( ) ) . addEqualityGroup ( Prepender . constructor ( String . class , int . class ) ) . addEqualityGroup ( Prepender . method ( <str> ) , Prepender . method ( <str> ) ) . addEqualityGroup ( Prepender . method ( <str> ) ) . testEquals ( ) ; } public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( Invokable . class ) ; new NullPointerTester ( ) . testAllPublicInstanceMethods ( Prepender . method ( <str> ) ) ; } @Retention ( RetentionPolicy . RUNTIME ) private @interface NotBlank { } @SuppressWarnings ( <str> ) private static class Prepender { private final String prefix ; private final int times ; Prepender ( @NotBlank String prefix , int times ) throws NullPointerException { this . prefix = prefix ; this . times = times ; } Prepender ( String . . . varargs ) { this ( null , <int> ) ; } private < A > Prepender ( ) { this ( null , <int> ) ; } static < T > Iterable < String > prepend ( @NotBlank String first , Iterable < String > tail ) { return Iterables . concat ( ImmutableList . of ( first ) , tail ) ; } Iterable < String > prepend ( Iterable < String > tail ) throws IllegalArgumentException , NullPointerException { return Iterables . concat ( Collections . nCopies ( times , prefix ) , tail ) ; } static Invokable < ? , Prepender > constructor ( Class < ? > . . . parameterTypes ) throws Exception { Constructor < Prepender > constructor = Prepender . class . getDeclaredConstructor ( parameterTypes ) ; return Invokable . from ( constructor ) ; } static Invokable < Prepender , Object > method ( String name , Class < ? > . . . parameterTypes ) { try { Method method = Prepender . class . getDeclaredMethod ( name , parameterTypes ) ; @SuppressWarnings ( <str> ) Invokable < Prepender , Object > invokable = ( Invokable < Prepender , Object > ) Invokable . from ( method ) ; return invokable ; } catch ( NoSuchMethodException e ) { throw new IllegalArgumentException ( e ) ; } } private void privateMethod ( ) { } private final void privateFinalMethod ( ) { } static void staticMethod ( ) { } static final void staticFinalMethod ( ) { } private void privateVarArgsMethod ( String . . . varargs ) { } } private static class SubPrepender extends Prepender { @SuppressWarnings ( <str> ) public SubPrepender ( ) throws NullPointerException { throw new AssertionError ( ) ; } } } 
