package com . badlogic . gdx . backends . gwt ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Graphics ; import com . badlogic . gdx . graphics . Cursor ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . GL30 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . google . gwt . canvas . client . Canvas ; import com . google . gwt . dom . client . CanvasElement ; import com . google . gwt . user . client . ui . Panel ; import com . google . gwt . webgl . client . WebGLContextAttributes ; import com . google . gwt . webgl . client . WebGLRenderingContext ; public class GwtGraphics implements Graphics { CanvasElement canvas ; WebGLRenderingContext context ; GL20 gl ; String extensions ; float fps = <int> ; long lastTimeStamp = System . currentTimeMillis ( ) ; long frameId = - <int> ; float deltaTime = <int> ; float time = <int> ; int frames ; GwtApplicationConfiguration config ; public GwtGraphics ( Panel root , GwtApplicationConfiguration config ) { Canvas canvasWidget = Canvas . createIfSupported ( ) ; if ( canvasWidget = = null ) throw new GdxRuntimeException ( <str> ) ; canvas = canvasWidget . getCanvasElement ( ) ; root . add ( canvasWidget ) ; canvas . setWidth ( config . width ) ; canvas . setHeight ( config . height ) ; this . config = config ; WebGLContextAttributes attributes = WebGLContextAttributes . create ( ) ; attributes . setAntialias ( config . antialiasing ) ; attributes . setStencil ( config . stencil ) ; attributes . setAlpha ( config . alpha ) ; attributes . setPremultipliedAlpha ( config . premultipliedAlpha ) ; attributes . setPreserveDrawingBuffer ( config . preserveDrawingBuffer ) ; context = WebGLRenderingContext . getContext ( canvas , attributes ) ; context . viewport ( <int> , <int> , config . width , config . height ) ; this . gl = config . useDebugGL ? new GwtGL20Debug ( context ) : new GwtGL20 ( context ) ; } public WebGLRenderingContext getContext ( ) { return context ; } @Override public GL20 getGL20 ( ) { return gl ; } @Override public int getWidth ( ) { return canvas . getWidth ( ) ; } @Override public int getHeight ( ) { return canvas . getHeight ( ) ; } @Override public long getFrameId ( ) { return frameId ; } @Override public float getDeltaTime ( ) { return deltaTime ; } @Override public int getFramesPerSecond ( ) { return ( int ) fps ; } @Override public GraphicsType getType ( ) { return GraphicsType . WebGL ; } @Override public float getPpiX ( ) { return <int> ; } @Override public float getPpiY ( ) { return <int> ; } @Override public float getPpcX ( ) { return <int> / <float> ; } @Override public float getPpcY ( ) { return <int> / <float> ; } @Override public boolean supportsDisplayModeChange ( ) { return supportsFullscreenJSNI ( ) ; } private native boolean supportsFullscreenJSNI ( ) ; @Override public DisplayMode [ ] getDisplayModes ( ) { return new DisplayMode [ ] { new DisplayMode ( getScreenWidthJSNI ( ) , getScreenHeightJSNI ( ) , <int> , <int> ) { } } ; } private native int getScreenWidthJSNI ( ) ; private native int getScreenHeightJSNI ( ) ; private native boolean isFullscreenJSNI ( ) ; private void fullscreenChanged ( ) { if ( ! isFullscreen ( ) ) { canvas . setWidth ( config . width ) ; canvas . setHeight ( config . height ) ; } } private native boolean setFullscreenJSNI ( GwtGraphics graphics , CanvasElement element ) ; private native void exitFullscreen ( ) ; @Override public DisplayMode getDesktopDisplayMode ( ) { return new DisplayMode ( getScreenWidthJSNI ( ) , getScreenHeightJSNI ( ) , <int> , <int> ) { } ; } @Override public boolean setDisplayMode ( DisplayMode displayMode ) { if ( displayMode . width ! = getScreenWidthJSNI ( ) & & displayMode . height ! = getScreenHeightJSNI ( ) ) return false ; return setFullscreenJSNI ( this , canvas ) ; } @Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { if ( fullscreen ) { if ( width ! = getScreenWidthJSNI ( ) & & height ! = getScreenHeightJSNI ( ) ) return false ; return setFullscreenJSNI ( this , canvas ) ; } else { if ( isFullscreenJSNI ( ) ) exitFullscreen ( ) ; canvas . setWidth ( width ) ; canvas . setHeight ( height ) ; return true ; } } @Override public BufferFormat getBufferFormat ( ) { return new BufferFormat ( <int> , <int> , <int> , <int> , <int> , config . stencil ? <int> : <int> , <int> , false ) ; } @Override public boolean supportsExtension ( String extension ) { if ( extensions = = null ) extensions = Gdx . gl . glGetString ( GL20 . GL_EXTENSIONS ) ; return extensions . contains ( extension ) ; } public void update ( ) { long currTimeStamp = System . currentTimeMillis ( ) ; deltaTime = ( currTimeStamp - lastTimeStamp ) / <float> ; lastTimeStamp = currTimeStamp ; time + = deltaTime ; frames + + ; if ( time > <int> ) { this . fps = frames ; time = <int> ; frames = <int> ; } } @Override public void setTitle ( String title ) { } @Override public void setVSync ( boolean vsync ) { } @Override public float getDensity ( ) { return <float> / <int> ; } @Override public void setContinuousRendering ( boolean isContinuous ) { } @Override public boolean isContinuousRendering ( ) { return true ; } @Override public void requestRendering ( ) { } @Override public float getRawDeltaTime ( ) { return getDeltaTime ( ) ; } @Override public boolean isFullscreen ( ) { return isFullscreenJSNI ( ) ; } @Override public boolean isGL30Available ( ) { return false ; } @Override public GL30 getGL30 ( ) { return null ; } @Override public Cursor newCursor ( Pixmap pixmap , int xHotspot , int yHotspot ) { return new GwtCursor ( pixmap , xHotspot , yHotspot ) ; } @Override public void setCursor ( Cursor cursor ) { if ( cursor = = null ) { GwtCursor . resetCursor ( ) ; } else { cursor . setSystemCursor ( ) ; } } } 
