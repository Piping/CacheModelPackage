package io . netty . handler . codec . http . multipart ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . Unpooled ; import io . netty . buffer . UnpooledByteBufAllocator ; import io . netty . handler . codec . DecoderResult ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . DefaultHttpRequest ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import java . util . Arrays ; import static io . netty . util . ReferenceCountUtil . releaseLater ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertTrue ; public class HttpPostRequestDecoderTest { @Test public void testBinaryStreamUploadWithSpace ( ) throws Exception { testBinaryStreamUpload ( true ) ; } @Test public void testBinaryStreamUploadWithoutSpace ( ) throws Exception { testBinaryStreamUpload ( false ) ; } private static void testBinaryStreamUpload ( boolean withSpace ) throws Exception { final String boundary = <str> ; final String contentTypeValue ; if ( withSpace ) { contentTypeValue = <str> + boundary ; } else { contentTypeValue = <str> + boundary ; } final DefaultHttpRequest req = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; req . setDecoderResult ( DecoderResult . SUCCESS ) ; req . headers ( ) . add ( HttpHeaderNames . CONTENT_TYPE , contentTypeValue ) ; req . headers ( ) . add ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory ( false ) ; for ( String data : Arrays . asList ( <str> , <str> , <str> , <str> ) ) { final String body = <str> + boundary + <str> + <str> + <str> + <str> + data + <str> + <str> + boundary + <str> ; final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder ( inMemoryFactory , req ) ; decoder . offer ( releaseLater ( new DefaultHttpContent ( Unpooled . copiedBuffer ( body , CharsetUtil . UTF_8 ) ) ) ) ; decoder . offer ( releaseLater ( new DefaultHttpContent ( Unpooled . EMPTY_BUFFER ) ) ) ; assertTrue ( decoder . hasNext ( ) ) ; MemoryFileUpload upload = ( MemoryFileUpload ) decoder . next ( ) ; assertEquals ( <str> + data . replaceAll ( <str> , <str> ) + <str> + upload + <str> , data , upload . getString ( CharsetUtil . UTF_8 ) ) ; upload . release ( ) ; decoder . destroy ( ) ; } } @Test public void testFullHttpRequestUpload ( ) throws Exception { final String boundary = <str> ; final DefaultFullHttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; req . setDecoderResult ( DecoderResult . SUCCESS ) ; req . headers ( ) . add ( HttpHeaderNames . CONTENT_TYPE , <str> + boundary ) ; req . headers ( ) . add ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory ( false ) ; for ( String data : Arrays . asList ( <str> , <str> , <str> , <str> ) ) { final String body = <str> + boundary + <str> + <str> + <str> + <str> + data + <str> + <str> + boundary + <str> ; req . content ( ) . writeBytes ( body . getBytes ( CharsetUtil . UTF_8 ) ) ; } final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder ( inMemoryFactory , req ) ; assertFalse ( decoder . getBodyHttpDatas ( ) . isEmpty ( ) ) ; decoder . destroy ( ) ; } @Test public void testMultipartCodecWithCRasEndOfAttribute ( ) throws Exception { final String boundary = <str> ; final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory ( false ) ; String extradata = <str> ; String [ ] datas = new String [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) { datas [ i ] = extradata ; for ( int j = <int> ; j < i ; j + + ) { datas [ i ] + = <str> ; } } for ( int i = <int> ; i < <int> ; i + + ) { final DefaultFullHttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; req . setDecoderResult ( DecoderResult . SUCCESS ) ; req . headers ( ) . add ( HttpHeaderNames . CONTENT_TYPE , <str> + boundary ) ; req . headers ( ) . add ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; final String body = <str> + boundary + <str> + <str> + i + <str> + <str> + <str> + datas [ i ] + <str> + <str> + boundary + <str> ; req . content ( ) . writeBytes ( body . getBytes ( CharsetUtil . UTF_8 ) ) ; final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder ( inMemoryFactory , req ) ; assertFalse ( decoder . getBodyHttpDatas ( ) . isEmpty ( ) ) ; InterfaceHttpData httpdata = decoder . getBodyHttpData ( <str> + i ) ; assertNotNull ( httpdata ) ; Attribute attribute = ( Attribute ) httpdata ; byte [ ] datar = attribute . get ( ) ; assertNotNull ( datar ) ; assertEquals ( datas [ i ] . getBytes ( CharsetUtil . UTF_8 ) . length , datar . length ) ; decoder . destroy ( ) ; } } @Test public void testQuotedBoundary ( ) throws Exception { final String boundary = <str> ; final DefaultFullHttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; req . setDecoderResult ( DecoderResult . SUCCESS ) ; req . headers ( ) . add ( HttpHeaderNames . CONTENT_TYPE , <str> + boundary + <str> ) ; req . headers ( ) . add ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory ( false ) ; for ( String data : Arrays . asList ( <str> , <str> , <str> , <str> ) ) { final String body = <str> + boundary + <str> + <str> + <str> + <str> + data + <str> + <str> + boundary + <str> ; req . content ( ) . writeBytes ( body . getBytes ( CharsetUtil . UTF_8 ) ) ; } final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder ( inMemoryFactory , req ) ; assertFalse ( decoder . getBodyHttpDatas ( ) . isEmpty ( ) ) ; decoder . destroy ( ) ; } @Test public void testNoZeroOut ( ) throws Exception { final String boundary = <str> ; final DefaultHttpDataFactory aMemFactory = new DefaultHttpDataFactory ( false ) ; DefaultHttpRequest aRequest = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; aRequest . headers ( ) . set ( HttpHeaderNames . CONTENT_TYPE , <str> + boundary ) ; aRequest . headers ( ) . set ( HttpHeaderNames . TRANSFER_ENCODING , HttpHeaderValues . CHUNKED ) ; HttpPostRequestDecoder aDecoder = new HttpPostRequestDecoder ( aMemFactory , aRequest ) ; final String aData = <str> + <str> + <str> + <str> ; final String body = <str> + boundary + <str> + <str> + <str> + <str> + aData + <str> + <str> + boundary + <str> ; byte [ ] aBytes = body . getBytes ( ) ; int split = <int> ; ByteBufAllocator aAlloc = new UnpooledByteBufAllocator ( true ) ; ByteBuf aSmallBuf = aAlloc . heapBuffer ( split , split ) ; ByteBuf aLargeBuf = aAlloc . heapBuffer ( aBytes . length - split , aBytes . length - split ) ; aSmallBuf . writeBytes ( aBytes , <int> , split ) ; aLargeBuf . writeBytes ( aBytes , split , aBytes . length - split ) ; aDecoder . offer ( releaseLater ( new DefaultHttpContent ( aSmallBuf ) ) ) ; aDecoder . offer ( releaseLater ( new DefaultHttpContent ( aLargeBuf ) ) ) ; aDecoder . offer ( LastHttpContent . EMPTY_LAST_CONTENT ) ; assertTrue ( <str> , aDecoder . hasNext ( ) ) ; InterfaceHttpData aDecodedData = aDecoder . next ( ) ; assertEquals ( InterfaceHttpData . HttpDataType . Attribute , aDecodedData . getHttpDataType ( ) ) ; Attribute aAttr = ( Attribute ) aDecodedData ; assertEquals ( aData , aAttr . getValue ( ) ) ; aDecodedData . release ( ) ; aDecoder . destroy ( ) ; } @Test public void testChunkCorrect ( ) throws Exception { String payload = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; DefaultHttpRequest defaultHttpRequest = new DefaultHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; HttpPostRequestDecoder decoder = new HttpPostRequestDecoder ( defaultHttpRequest ) ; int firstChunk = <int> ; int middleChunk = <int> ; HttpContent part1 = new DefaultHttpContent ( Unpooled . wrappedBuffer ( payload . substring ( <int> , firstChunk ) . getBytes ( ) ) ) ; HttpContent part2 = new DefaultHttpContent ( Unpooled . wrappedBuffer ( payload . substring ( firstChunk , firstChunk + middleChunk ) . getBytes ( ) ) ) ; HttpContent part3 = new DefaultHttpContent ( Unpooled . wrappedBuffer ( payload . substring ( firstChunk + middleChunk , firstChunk + middleChunk * <int> ) . getBytes ( ) ) ) ; HttpContent part4 = new DefaultHttpContent ( Unpooled . wrappedBuffer ( payload . substring ( firstChunk + middleChunk * <int> ) . getBytes ( ) ) ) ; decoder . offer ( part1 ) ; decoder . offer ( part2 ) ; decoder . offer ( part3 ) ; decoder . offer ( part4 ) ; } @Test public void testFilenameContainingSemicolon ( ) throws Exception { final String boundary = <str> ; final DefaultFullHttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; req . headers ( ) . add ( HttpHeaderNames . CONTENT_TYPE , <str> + boundary ) ; final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory ( false ) ; final String data = <str> ; final String filename = <str> ; final String body = <str> + boundary + <str> + <str> + filename + <str> + <str> + <str> + data + <str> + <str> + boundary + <str> ; req . content ( ) . writeBytes ( body . getBytes ( CharsetUtil . UTF_8 . name ( ) ) ) ; final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder ( inMemoryFactory , req ) ; assertFalse ( decoder . getBodyHttpDatas ( ) . isEmpty ( ) ) ; decoder . destroy ( ) ; } @Test public void testFilenameContainingSemicolon2 ( ) throws Exception { final String boundary = <str> ; final DefaultFullHttpRequest req = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_1 , HttpMethod . POST , <str> ) ; req . headers ( ) . add ( HttpHeaderNames . CONTENT_TYPE , <str> + boundary ) ; final DefaultHttpDataFactory inMemoryFactory = new DefaultHttpDataFactory ( false ) ; final String data = <str> ; final String filename = <str> ; final String body = <str> + boundary + <str> + <str> + filename + <str> + <str> + <str> + data + <str> + <str> + boundary + <str> ; req . content ( ) . writeBytes ( body . getBytes ( CharsetUtil . UTF_8 . name ( ) ) ) ; final HttpPostRequestDecoder decoder = new HttpPostRequestDecoder ( inMemoryFactory , req ) ; assertFalse ( decoder . getBodyHttpDatas ( ) . isEmpty ( ) ) ; InterfaceHttpData part1 = decoder . getBodyHttpDatas ( ) . get ( <int> ) ; assertTrue ( part1 instanceof FileUpload ) ; FileUpload fileUpload = ( FileUpload ) part1 ; assertEquals ( <str> , fileUpload . getFilename ( ) ) ; decoder . destroy ( ) ; } } 
