package com . badlogic . gdx . tests . g3d ; import java . nio . ByteBuffer ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . g3d . utils . MeshBuilder ; import com . badlogic . gdx . graphics . g3d . utils . MeshPartBuilder ; import com . badlogic . gdx . graphics . g3d . utils . MeshPartBuilder . VertexInfo ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class HeightField implements Disposable { public final Vector2 uvOffset = new Vector2 ( <int> , <int> ) ; public final Vector2 uvScale = new Vector2 ( <int> , <int> ) ; public final Color color00 = new Color ( Color . WHITE ) ; public final Color color10 = new Color ( Color . WHITE ) ; public final Color color01 = new Color ( Color . WHITE ) ; public final Color color11 = new Color ( Color . WHITE ) ; public final Vector3 corner00 = new Vector3 ( <int> , <int> , <int> ) ; public final Vector3 corner10 = new Vector3 ( <int> , <int> , <int> ) ; public final Vector3 corner01 = new Vector3 ( <int> , <int> , <int> ) ; public final Vector3 corner11 = new Vector3 ( <int> , <int> , <int> ) ; public final Vector3 magnitude = new Vector3 ( <int> , <int> , <int> ) ; public final float [ ] data ; public final int width ; public final int height ; public final boolean smooth ; public final Mesh mesh ; private final float vertices [ ] ; private final int stride ; private final int posPos ; private final int norPos ; private final int uvPos ; private final int colPos ; private final MeshPartBuilder . VertexInfo vertex00 = new MeshPartBuilder . VertexInfo ( ) ; private final MeshPartBuilder . VertexInfo vertex10 = new MeshPartBuilder . VertexInfo ( ) ; private final MeshPartBuilder . VertexInfo vertex01 = new MeshPartBuilder . VertexInfo ( ) ; private final MeshPartBuilder . VertexInfo vertex11 = new MeshPartBuilder . VertexInfo ( ) ; private final Vector3 tmpV1 = new Vector3 ( ) ; private final Vector3 tmpV2 = new Vector3 ( ) ; private final Vector3 tmpV3 = new Vector3 ( ) ; private final Vector3 tmpV4 = new Vector3 ( ) ; private final Vector3 tmpV5 = new Vector3 ( ) ; private final Vector3 tmpV6 = new Vector3 ( ) ; private final Vector3 tmpV7 = new Vector3 ( ) ; private final Vector3 tmpV8 = new Vector3 ( ) ; private final Vector3 tmpV9 = new Vector3 ( ) ; private final Color tmpC = new Color ( ) ; public HeightField ( boolean isStatic , final Pixmap map , boolean smooth , int attributes ) { this ( isStatic , map . getWidth ( ) , map . getHeight ( ) , smooth , attributes ) ; set ( map ) ; } public HeightField ( boolean isStatic , final ByteBuffer colorData , final Pixmap . Format format , int width , int height , boolean smooth , int attributes ) { this ( isStatic , width , height , smooth , attributes ) ; set ( colorData , format ) ; } public HeightField ( boolean isStatic , final float [ ] data , int width , int height , boolean smooth , int attributes ) { this ( isStatic , width , height , smooth , attributes ) ; set ( data ) ; } public HeightField ( boolean isStatic , int width , int height , boolean smooth , int attributes ) { this ( isStatic , width , height , smooth , MeshBuilder . createAttributes ( attributes ) ) ; } public HeightField ( boolean isStatic , int width , int height , boolean smooth , VertexAttributes attributes ) { this . posPos = attributes . getOffset ( Usage . Position , - <int> ) ; this . norPos = attributes . getOffset ( Usage . Normal , - <int> ) ; this . uvPos = attributes . getOffset ( Usage . TextureCoordinates , - <int> ) ; this . colPos = attributes . getOffset ( Usage . ColorUnpacked , - <int> ) ; smooth = smooth | | ( norPos < <int> ) ; this . width = width ; this . height = height ; this . smooth = smooth ; this . data = new float [ width * height ] ; this . stride = attributes . vertexSize / <int> ; final int numVertices = smooth ? width * height : ( width - <int> ) * ( height - <int> ) * <int> ; final int numIndices = ( width - <int> ) * ( height - <int> ) * <int> ; this . mesh = new Mesh ( isStatic , numVertices , numIndices , attributes ) ; this . vertices = new float [ numVertices * stride ] ; setIndices ( ) ; } private void setIndices ( ) { final int w = width - <int> ; final int h = height - <int> ; short indices [ ] = new short [ w * h * <int> ] ; int i = - <int> ; for ( int y = <int> ; y < h ; + + y ) { for ( int x = <int> ; x < w ; + + x ) { final int c00 = smooth ? ( y * width + x ) : ( y * <int> * w + x * <int> ) ; final int c10 = c00 + <int> ; final int c01 = c00 + ( smooth ? width : w * <int> ) ; final int c11 = c10 + ( smooth ? width : w * <int> ) ; indices [ + + i ] = ( short ) c11 ; indices [ + + i ] = ( short ) c10 ; indices [ + + i ] = ( short ) c00 ; indices [ + + i ] = ( short ) c00 ; indices [ + + i ] = ( short ) c01 ; indices [ + + i ] = ( short ) c11 ; } } mesh . setIndices ( indices ) ; } public void update ( ) { if ( smooth ) { if ( norPos < <int> ) updateSimple ( ) ; else updateSmooth ( ) ; } else updateSharp ( ) ; } private void updateSmooth ( ) { for ( int x = <int> ; x < width ; + + x ) { for ( int y = <int> ; y < height ; + + y ) { VertexInfo v = getVertexAt ( vertex00 , x , y ) ; getWeightedNormalAt ( v . normal , x , y ) ; setVertex ( y * width + x , v ) ; } } mesh . setVertices ( vertices ) ; } private void updateSimple ( ) { for ( int x = <int> ; x < width ; + + x ) { for ( int y = <int> ; y < height ; + + y ) { setVertex ( y * width + x , getVertexAt ( vertex00 , x , y ) ) ; } } mesh . setVertices ( vertices ) ; } private void updateSharp ( ) { final int w = width - <int> ; final int h = height - <int> ; for ( int y = <int> ; y < h ; + + y ) { for ( int x = <int> ; x < w ; + + x ) { final int c00 = ( y * <int> * w + x * <int> ) ; final int c10 = c00 + <int> ; final int c01 = c00 + w * <int> ; final int c11 = c10 + w * <int> ; VertexInfo v00 = getVertexAt ( vertex00 , x , y ) ; VertexInfo v10 = getVertexAt ( vertex10 , x + <int> , y ) ; VertexInfo v01 = getVertexAt ( vertex01 , x , y + <int> ) ; VertexInfo v11 = getVertexAt ( vertex11 , x + <int> , y + <int> ) ; v01 . normal . set ( v01 . position ) . sub ( v00 . position ) . nor ( ) . crs ( tmpV1 . set ( v11 . position ) . sub ( v01 . position ) . nor ( ) ) ; v10 . normal . set ( v10 . position ) . sub ( v11 . position ) . nor ( ) . crs ( tmpV1 . set ( v00 . position ) . sub ( v10 . position ) . nor ( ) ) ; v00 . normal . set ( v01 . normal ) . lerp ( v10 . normal , <float> ) ; v11 . normal . set ( v00 . normal ) ; setVertex ( c00 , v00 ) ; setVertex ( c10 , v10 ) ; setVertex ( c01 , v01 ) ; setVertex ( c11 , v11 ) ; } } mesh . setVertices ( vertices ) ; } protected VertexInfo getVertexAt ( final VertexInfo out , int x , int y ) { final float dx = ( float ) x / ( float ) ( width - <int> ) ; final float dy = ( float ) y / ( float ) ( height - <int> ) ; final float a = data [ y * width + x ] ; out . position . set ( corner00 ) . lerp ( corner10 , dx ) . lerp ( tmpV1 . set ( corner01 ) . lerp ( corner11 , dx ) , dy ) ; out . position . add ( tmpV1 . set ( magnitude ) . scl ( a ) ) ; out . color . set ( color00 ) . lerp ( color10 , dx ) . lerp ( tmpC . set ( color01 ) . lerp ( color11 , dx ) , dy ) ; out . uv . set ( dx , dy ) . scl ( uvScale ) . add ( uvOffset ) ; return out ; } public Vector3 getPositionAt ( Vector3 out , int x , int y ) { final float dx = ( float ) x / ( float ) ( width - <int> ) ; final float dy = ( float ) y / ( float ) ( height - <int> ) ; final float a = data [ y * width + x ] ; out . set ( corner00 ) . lerp ( corner10 , dx ) . lerp ( tmpV1 . set ( corner01 ) . lerp ( corner11 , dx ) , dy ) ; out . add ( tmpV1 . set ( magnitude ) . scl ( a ) ) ; return out ; } public Vector3 getWeightedNormalAt ( Vector3 out , int x , int y ) { int faces = <int> ; out . set ( <int> , <int> , <int> ) ; Vector3 center = getPositionAt ( tmpV2 , x , y ) ; Vector3 left = x > <int> ? getPositionAt ( tmpV3 , x - <int> , y ) : null ; Vector3 right = x < ( width - <int> ) ? getPositionAt ( tmpV4 , x + <int> , y ) : null ; Vector3 bottom = y > <int> ? getPositionAt ( tmpV5 , x , y - <int> ) : null ; Vector3 top = y < ( height - <int> ) ? getPositionAt ( tmpV6 , x , y + <int> ) : null ; if ( top ! = null & & left ! = null ) { out . add ( tmpV7 . set ( top ) . sub ( center ) . nor ( ) . crs ( tmpV8 . set ( center ) . sub ( left ) . nor ( ) ) . nor ( ) ) ; faces + + ; } if ( left ! = null & & bottom ! = null ) { out . add ( tmpV7 . set ( left ) . sub ( center ) . nor ( ) . crs ( tmpV8 . set ( center ) . sub ( bottom ) . nor ( ) ) . nor ( ) ) ; faces + + ; } if ( bottom ! = null & & right ! = null ) { out . add ( tmpV7 . set ( bottom ) . sub ( center ) . nor ( ) . crs ( tmpV8 . set ( center ) . sub ( right ) . nor ( ) ) . nor ( ) ) ; faces + + ; } if ( right ! = null & & top ! = null ) { out . add ( tmpV7 . set ( right ) . sub ( center ) . nor ( ) . crs ( tmpV8 . set ( center ) . sub ( top ) . nor ( ) ) . nor ( ) ) ; faces + + ; } if ( faces ! = <int> ) out . scl ( <float> / ( float ) faces ) ; else out . set ( magnitude ) . nor ( ) ; return out ; } protected void setVertex ( int index , VertexInfo info ) { index * = stride ; if ( posPos > = <int> ) { vertices [ index + posPos + <int> ] = info . position . x ; vertices [ index + posPos + <int> ] = info . position . y ; vertices [ index + posPos + <int> ] = info . position . z ; } if ( norPos > = <int> ) { vertices [ index + norPos + <int> ] = info . normal . x ; vertices [ index + norPos + <int> ] = info . normal . y ; vertices [ index + norPos + <int> ] = info . normal . z ; } if ( uvPos > = <int> ) { vertices [ index + uvPos + <int> ] = info . uv . x ; vertices [ index + uvPos + <int> ] = info . uv . y ; } if ( colPos > = <int> ) { vertices [ index + colPos + <int> ] = info . color . r ; vertices [ index + colPos + <int> ] = info . color . g ; vertices [ index + colPos + <int> ] = info . color . b ; vertices [ index + colPos + <int> ] = info . color . a ; } } public void set ( final Pixmap map ) { if ( map . getWidth ( ) ! = width | | map . getHeight ( ) ! = height ) throw new GdxRuntimeException ( <str> ) ; set ( map . getPixels ( ) , map . getFormat ( ) ) ; } public void set ( final ByteBuffer colorData , final Pixmap . Format format ) { set ( heightColorsToMap ( colorData , format , width , height ) ) ; } public void set ( float [ ] data ) { set ( data , <int> ) ; } public void set ( float [ ] data , int offset ) { if ( this . data . length > ( data . length - offset ) ) throw new GdxRuntimeException ( <str> ) ; System . arraycopy ( data , offset , this . data , <int> , this . data . length ) ; update ( ) ; } @Override public void dispose ( ) { mesh . dispose ( ) ; } public static float [ ] heightColorsToMap ( final ByteBuffer data , final Pixmap . Format format , int width , int height ) { final int bytesPerColor = ( format = = Format . RGB888 ? <int> : ( format = = Format . RGBA8888 ? <int> : <int> ) ) ; if ( bytesPerColor = = <int> ) throw new GdxRuntimeException ( <str> ) ; if ( data . remaining ( ) < ( width * height * bytesPerColor ) ) throw new GdxRuntimeException ( <str> ) ; final int startPos = data . position ( ) ; byte [ ] source = null ; int sourceOffset = <int> ; if ( data . hasArray ( ) & & ! data . isReadOnly ( ) ) { source = data . array ( ) ; sourceOffset = data . arrayOffset ( ) + startPos ; } else { source = new byte [ width * height * bytesPerColor ] ; data . get ( source ) ; data . position ( startPos ) ; } float [ ] dest = new float [ width * height ] ; for ( int i = <int> ; i < dest . length ; + + i ) { int v = source [ sourceOffset + i * <int> ] ; v = v < <int> ? <int> + v : v ; dest [ i ] = ( float ) v / <int> f ; } return dest ; } } 
