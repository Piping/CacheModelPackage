package org . elasticsearch . monitor . os ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import java . io . IOException ; public class OsStats implements Streamable , ToXContent { long timestamp ; Cpu cpu = null ; Mem mem = null ; Swap swap = null ; OsStats ( ) { } public long getTimestamp ( ) { return timestamp ; } public Cpu getCpu ( ) { return cpu ; } public Mem getMem ( ) { return mem ; } public Swap getSwap ( ) { return swap ; } static final class Fields { static final XContentBuilderString OS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TIMESTAMP = new XContentBuilderString ( <str> ) ; static final XContentBuilderString CPU = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PERCENT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString LOAD_AVERAGE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MEM = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SWAP = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FREE = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FREE_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString USED = new XContentBuilderString ( <str> ) ; static final XContentBuilderString USED_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FREE_PERCENT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString USED_PERCENT = new XContentBuilderString ( <str> ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . OS ) ; builder . field ( Fields . TIMESTAMP , getTimestamp ( ) ) ; if ( cpu ! = null ) { builder . startObject ( Fields . CPU ) ; builder . field ( Fields . PERCENT , cpu . getPercent ( ) ) ; builder . field ( Fields . LOAD_AVERAGE , cpu . getLoadAverage ( ) ) ; builder . endObject ( ) ; } if ( mem ! = null ) { builder . startObject ( Fields . MEM ) ; builder . byteSizeField ( Fields . TOTAL_IN_BYTES , Fields . TOTAL , mem . getTotal ( ) ) ; builder . byteSizeField ( Fields . FREE_IN_BYTES , Fields . FREE , mem . getFree ( ) ) ; builder . byteSizeField ( Fields . USED_IN_BYTES , Fields . USED , mem . getUsed ( ) ) ; builder . field ( Fields . FREE_PERCENT , mem . getFreePercent ( ) ) ; builder . field ( Fields . USED_PERCENT , mem . getUsedPercent ( ) ) ; builder . endObject ( ) ; } if ( swap ! = null ) { builder . startObject ( Fields . SWAP ) ; builder . byteSizeField ( Fields . TOTAL_IN_BYTES , Fields . TOTAL , swap . getTotal ( ) ) ; builder . byteSizeField ( Fields . FREE_IN_BYTES , Fields . FREE , swap . getFree ( ) ) ; builder . byteSizeField ( Fields . USED_IN_BYTES , Fields . USED , swap . getUsed ( ) ) ; builder . endObject ( ) ; } builder . endObject ( ) ; return builder ; } public static OsStats readOsStats ( StreamInput in ) throws IOException { OsStats stats = new OsStats ( ) ; stats . readFrom ( in ) ; return stats ; } @Override public void readFrom ( StreamInput in ) throws IOException { timestamp = in . readVLong ( ) ; cpu = in . readOptionalStreamable ( Cpu : : new ) ; if ( in . readBoolean ( ) ) { mem = Mem . readMem ( in ) ; } if ( in . readBoolean ( ) ) { swap = Swap . readSwap ( in ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVLong ( timestamp ) ; out . writeOptionalStreamable ( cpu ) ; if ( mem = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; mem . writeTo ( out ) ; } if ( swap = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; swap . writeTo ( out ) ; } } public static class Cpu implements Streamable { short percent = - <int> ; double loadAverage = - <int> ; Cpu ( ) { } public static Cpu readCpu ( StreamInput in ) throws IOException { Cpu cpu = new Cpu ( ) ; cpu . readFrom ( in ) ; return cpu ; } @Override public void readFrom ( StreamInput in ) throws IOException { percent = in . readShort ( ) ; loadAverage = in . readDouble ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeShort ( percent ) ; out . writeDouble ( loadAverage ) ; } public short getPercent ( ) { return percent ; } public double getLoadAverage ( ) { return loadAverage ; } } public static class Swap implements Streamable { long total = - <int> ; long free = - <int> ; public ByteSizeValue getFree ( ) { return new ByteSizeValue ( free ) ; } public ByteSizeValue getUsed ( ) { return new ByteSizeValue ( total - free ) ; } public ByteSizeValue getTotal ( ) { return new ByteSizeValue ( total ) ; } public static Swap readSwap ( StreamInput in ) throws IOException { Swap swap = new Swap ( ) ; swap . readFrom ( in ) ; return swap ; } @Override public void readFrom ( StreamInput in ) throws IOException { total = in . readLong ( ) ; free = in . readLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeLong ( total ) ; out . writeLong ( free ) ; } } public static class Mem implements Streamable { long total = - <int> ; long free = - <int> ; public static Mem readMem ( StreamInput in ) throws IOException { Mem mem = new Mem ( ) ; mem . readFrom ( in ) ; return mem ; } @Override public void readFrom ( StreamInput in ) throws IOException { total = in . readLong ( ) ; free = in . readLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeLong ( total ) ; out . writeLong ( free ) ; } public ByteSizeValue getTotal ( ) { return new ByteSizeValue ( total ) ; } public ByteSizeValue getUsed ( ) { return new ByteSizeValue ( total - free ) ; } public short getUsedPercent ( ) { return calculatePercentage ( getUsed ( ) . bytes ( ) , getTotal ( ) . bytes ( ) ) ; } public ByteSizeValue getFree ( ) { return new ByteSizeValue ( free ) ; } public short getFreePercent ( ) { return calculatePercentage ( getFree ( ) . bytes ( ) , getTotal ( ) . bytes ( ) ) ; } } private static short calculatePercentage ( long used , long max ) { return max < = <int> ? <int> : ( short ) ( Math . round ( ( <int> d * used ) / max ) ) ; } } 
