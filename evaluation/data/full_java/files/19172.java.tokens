package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . CorruptedFrameException ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . nio . ByteOrder ; import java . util . List ; import static io . netty . buffer . ByteBufUtil . readBytes ; public class WebSocket08FrameDecoder extends ByteToMessageDecoder implements WebSocketFrameDecoder { enum State { READING_FIRST , READING_SECOND , READING_SIZE , MASKING_KEY , PAYLOAD , CORRUPT } private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocket08FrameDecoder . class ) ; private static final byte OPCODE_CONT = <hex> ; private static final byte OPCODE_TEXT = <hex> ; private static final byte OPCODE_BINARY = <hex> ; private static final byte OPCODE_CLOSE = <hex> ; private static final byte OPCODE_PING = <hex> ; private static final byte OPCODE_PONG = <hex> ; private final long maxFramePayloadLength ; private final boolean allowExtensions ; private final boolean expectMaskedFrames ; private final boolean allowMaskMismatch ; private int fragmentedFramesCount ; private boolean frameFinalFlag ; private boolean frameMasked ; private int frameRsv ; private int frameOpcode ; private long framePayloadLength ; private byte [ ] maskingKey ; private int framePayloadLen1 ; private boolean receivedClosingHandshake ; private Utf8Validator utf8Validator ; private State state = State . READING_FIRST ; public WebSocket08FrameDecoder ( boolean expectMaskedFrames , boolean allowExtensions , int maxFramePayloadLength ) { this ( expectMaskedFrames , allowExtensions , maxFramePayloadLength , false ) ; } public WebSocket08FrameDecoder ( boolean expectMaskedFrames , boolean allowExtensions , int maxFramePayloadLength , boolean allowMaskMismatch ) { this . expectMaskedFrames = expectMaskedFrames ; this . allowMaskMismatch = allowMaskMismatch ; this . allowExtensions = allowExtensions ; this . maxFramePayloadLength = maxFramePayloadLength ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( receivedClosingHandshake ) { in . skipBytes ( actualReadableBytes ( ) ) ; return ; } switch ( state ) { case READING_FIRST : if ( ! in . isReadable ( ) ) { return ; } framePayloadLength = <int> ; byte b = in . readByte ( ) ; frameFinalFlag = ( b & <hex> ) ! = <int> ; frameRsv = ( b & <hex> ) > > <int> ; frameOpcode = b & <hex> ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , frameOpcode ) ; } state = State . READING_SECOND ; case READING_SECOND : if ( ! in . isReadable ( ) ) { return ; } b = in . readByte ( ) ; frameMasked = ( b & <hex> ) ! = <int> ; framePayloadLen1 = b & <hex> ; if ( frameRsv ! = <int> & & ! allowExtensions ) { protocolViolation ( ctx , <str> + frameRsv ) ; return ; } if ( ! allowMaskMismatch & & expectMaskedFrames ! = frameMasked ) { protocolViolation ( ctx , <str> ) ; return ; } if ( frameOpcode > <int> ) { if ( ! frameFinalFlag ) { protocolViolation ( ctx , <str> ) ; return ; } if ( framePayloadLen1 > <int> ) { protocolViolation ( ctx , <str> ) ; return ; } if ( ! ( frameOpcode = = OPCODE_CLOSE | | frameOpcode = = OPCODE_PING | | frameOpcode = = OPCODE_PONG ) ) { protocolViolation ( ctx , <str> + frameOpcode ) ; return ; } if ( frameOpcode = = <int> & & framePayloadLen1 = = <int> ) { protocolViolation ( ctx , <str> ) ; return ; } } else { if ( ! ( frameOpcode = = OPCODE_CONT | | frameOpcode = = OPCODE_TEXT | | frameOpcode = = OPCODE_BINARY ) ) { protocolViolation ( ctx , <str> + frameOpcode ) ; return ; } if ( fragmentedFramesCount = = <int> & & frameOpcode = = OPCODE_CONT ) { protocolViolation ( ctx , <str> ) ; return ; } if ( fragmentedFramesCount ! = <int> & & frameOpcode ! = OPCODE_CONT & & frameOpcode ! = OPCODE_PING ) { protocolViolation ( ctx , <str> ) ; return ; } } state = State . READING_SIZE ; case READING_SIZE : if ( framePayloadLen1 = = <int> ) { if ( in . readableBytes ( ) < <int> ) { return ; } framePayloadLength = in . readUnsignedShort ( ) ; if ( framePayloadLength < <int> ) { protocolViolation ( ctx , <str> ) ; return ; } } else if ( framePayloadLen1 = = <int> ) { if ( in . readableBytes ( ) < <int> ) { return ; } framePayloadLength = in . readLong ( ) ; if ( framePayloadLength < <int> ) { protocolViolation ( ctx , <str> ) ; return ; } } else { framePayloadLength = framePayloadLen1 ; } if ( framePayloadLength > maxFramePayloadLength ) { protocolViolation ( ctx , <str> + maxFramePayloadLength + <str> ) ; return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , framePayloadLength ) ; } state = State . MASKING_KEY ; case MASKING_KEY : if ( frameMasked ) { if ( in . readableBytes ( ) < <int> ) { return ; } if ( maskingKey = = null ) { maskingKey = new byte [ <int> ] ; } in . readBytes ( maskingKey ) ; } state = State . PAYLOAD ; case PAYLOAD : if ( in . readableBytes ( ) < framePayloadLength ) { return ; } ByteBuf payloadBuffer = null ; try { payloadBuffer = readBytes ( ctx . alloc ( ) , in , toFrameLength ( framePayloadLength ) ) ; state = State . READING_FIRST ; if ( frameMasked ) { unmask ( payloadBuffer ) ; } if ( frameOpcode = = OPCODE_PING ) { out . add ( new PingWebSocketFrame ( frameFinalFlag , frameRsv , payloadBuffer ) ) ; payloadBuffer = null ; return ; } if ( frameOpcode = = OPCODE_PONG ) { out . add ( new PongWebSocketFrame ( frameFinalFlag , frameRsv , payloadBuffer ) ) ; payloadBuffer = null ; return ; } if ( frameOpcode = = OPCODE_CLOSE ) { receivedClosingHandshake = true ; checkCloseFrameBody ( ctx , payloadBuffer ) ; out . add ( new CloseWebSocketFrame ( frameFinalFlag , frameRsv , payloadBuffer ) ) ; payloadBuffer = null ; return ; } if ( frameFinalFlag ) { if ( frameOpcode ! = OPCODE_PING ) { fragmentedFramesCount = <int> ; if ( frameOpcode = = OPCODE_TEXT | | utf8Validator ! = null & & utf8Validator . isChecking ( ) ) { checkUTF8String ( ctx , payloadBuffer ) ; utf8Validator . finish ( ) ; } } } else { if ( fragmentedFramesCount = = <int> ) { if ( frameOpcode = = OPCODE_TEXT ) { checkUTF8String ( ctx , payloadBuffer ) ; } } else { if ( utf8Validator ! = null & & utf8Validator . isChecking ( ) ) { checkUTF8String ( ctx , payloadBuffer ) ; } } fragmentedFramesCount + + ; } if ( frameOpcode = = OPCODE_TEXT ) { out . add ( new TextWebSocketFrame ( frameFinalFlag , frameRsv , payloadBuffer ) ) ; payloadBuffer = null ; return ; } else if ( frameOpcode = = OPCODE_BINARY ) { out . add ( new BinaryWebSocketFrame ( frameFinalFlag , frameRsv , payloadBuffer ) ) ; payloadBuffer = null ; return ; } else if ( frameOpcode = = OPCODE_CONT ) { out . add ( new ContinuationWebSocketFrame ( frameFinalFlag , frameRsv , payloadBuffer ) ) ; payloadBuffer = null ; return ; } else { throw new UnsupportedOperationException ( <str> + frameOpcode ) ; } } finally { if ( payloadBuffer ! = null ) { payloadBuffer . release ( ) ; } } case CORRUPT : if ( in . isReadable ( ) ) { in . readByte ( ) ; } return ; default : throw new Error ( <str> ) ; } } private void unmask ( ByteBuf frame ) { int i = frame . readerIndex ( ) ; int end = frame . writerIndex ( ) ; ByteOrder order = frame . order ( ) ; int intMask = ( ( maskingKey [ <int> ] & <hex> ) < < <int> ) | ( ( maskingKey [ <int> ] & <hex> ) < < <int> ) | ( ( maskingKey [ <int> ] & <hex> ) < < <int> ) | ( maskingKey [ <int> ] & <hex> ) ; if ( order = = ByteOrder . LITTLE_ENDIAN ) { intMask = Integer . reverseBytes ( intMask ) ; } for ( ; i + <int> < end ; i + = <int> ) { int unmasked = frame . getInt ( i ) ^ intMask ; frame . setInt ( i , unmasked ) ; } for ( ; i < end ; i + + ) { frame . setByte ( i , frame . getByte ( i ) ^ maskingKey [ i % <int> ] ) ; } } private void protocolViolation ( ChannelHandlerContext ctx , String reason ) { protocolViolation ( ctx , new CorruptedFrameException ( reason ) ) ; } private void protocolViolation ( ChannelHandlerContext ctx , CorruptedFrameException ex ) { state = State . CORRUPT ; if ( ctx . channel ( ) . isActive ( ) ) { Object closeMessage ; if ( receivedClosingHandshake ) { closeMessage = Unpooled . EMPTY_BUFFER ; } else { closeMessage = new CloseWebSocketFrame ( <int> , null ) ; } ctx . writeAndFlush ( closeMessage ) . addListener ( ChannelFutureListener . CLOSE ) ; } throw ex ; } private static int toFrameLength ( long l ) { if ( l > Integer . MAX_VALUE ) { throw new TooLongFrameException ( <str> + l ) ; } else { return ( int ) l ; } } private void checkUTF8String ( ChannelHandlerContext ctx , ByteBuf buffer ) { try { if ( utf8Validator = = null ) { utf8Validator = new Utf8Validator ( ) ; } utf8Validator . check ( buffer ) ; } catch ( CorruptedFrameException ex ) { protocolViolation ( ctx , ex ) ; } } protected void checkCloseFrameBody ( ChannelHandlerContext ctx , ByteBuf buffer ) { if ( buffer = = null | | ! buffer . isReadable ( ) ) { return ; } if ( buffer . readableBytes ( ) = = <int> ) { protocolViolation ( ctx , <str> ) ; } int idx = buffer . readerIndex ( ) ; buffer . readerIndex ( <int> ) ; int statusCode = buffer . readShort ( ) ; if ( statusCode > = <int> & & statusCode < = <int> | | statusCode > = <int> & & statusCode < = <int> | | statusCode > = <int> & & statusCode < = <int> ) { protocolViolation ( ctx , <str> + statusCode ) ; } if ( buffer . isReadable ( ) ) { try { new Utf8Validator ( ) . check ( buffer ) ; } catch ( CorruptedFrameException ex ) { protocolViolation ( ctx , ex ) ; } } buffer . readerIndex ( idx ) ; } } 
