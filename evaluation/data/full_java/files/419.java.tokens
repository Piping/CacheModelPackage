package org . apache . cassandra . db . lifecycle ; import java . io . File ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . zip . CRC32 ; import org . apache . cassandra . io . sstable . SSTable ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . FBUtilities ; final class LogRecord { public enum Type { UNKNOWN , ADD , REMOVE , COMMIT , ABORT ; public static Type fromPrefix ( String prefix ) { return valueOf ( prefix . toUpperCase ( ) ) ; } public boolean hasFile ( ) { return this = = Type . ADD | | this = = Type . REMOVE ; } public boolean matches ( LogRecord record ) { return this = = record . type ; } public boolean isFinal ( ) { return this = = Type . COMMIT | | this = = Type . ABORT ; } } public final static class Status { Optional < String > error = Optional . empty ( ) ; boolean partial = false ; LogRecord onDiskRecord ; void setError ( String error ) { if ( ! this . error . isPresent ( ) ) this . error = Optional . of ( error ) ; } boolean hasError ( ) { return error . isPresent ( ) ; } } public final Type type ; public final Optional < String > absolutePath ; public final long updateTime ; public final int numFiles ; public final String raw ; public final long checksum ; public final Status status ; static Pattern REGEX = Pattern . compile ( <str> , Pattern . CASE_INSENSITIVE ) ; public static LogRecord make ( String line ) { try { Matcher matcher = REGEX . matcher ( line ) ; if ( ! matcher . matches ( ) ) return new LogRecord ( Type . UNKNOWN , null , <int> , <int> , <int> , line ) . setError ( String . format ( <str> , line ) ) ; Type type = Type . fromPrefix ( matcher . group ( <int> ) ) ; return new LogRecord ( type , matcher . group ( <int> ) , Long . valueOf ( matcher . group ( <int> ) ) , Integer . valueOf ( matcher . group ( <int> ) ) , Long . valueOf ( matcher . group ( <int> ) ) , line ) ; } catch ( Throwable t ) { return new LogRecord ( Type . UNKNOWN , null , <int> , <int> , <int> , line ) . setError ( t ) ; } } public static LogRecord makeCommit ( long updateTime ) { return new LogRecord ( Type . COMMIT , updateTime ) ; } public static LogRecord makeAbort ( long updateTime ) { return new LogRecord ( Type . ABORT , updateTime ) ; } public static LogRecord make ( Type type , SSTable table ) { String absoluteTablePath = FileUtils . getCanonicalPath ( table . descriptor . baseFilename ( ) ) ; return make ( type , getExistingFiles ( absoluteTablePath ) , table . getAllFilePaths ( ) . size ( ) , absoluteTablePath ) ; } public LogRecord withExistingFiles ( ) { return make ( type , getExistingFiles ( ) , <int> , absolutePath . get ( ) ) ; } public static LogRecord make ( Type type , List < File > files , int minFiles , String absolutePath ) { long lastModified = files . stream ( ) . map ( File : : lastModified ) . reduce ( <int> L , Long : : max ) ; return new LogRecord ( type , absolutePath , lastModified , Math . max ( minFiles , files . size ( ) ) ) ; } private LogRecord ( Type type , long updateTime ) { this ( type , null , updateTime , <int> , <int> , null ) ; } private LogRecord ( Type type , String absolutePath , long updateTime , int numFiles ) { this ( type , absolutePath , updateTime , numFiles , <int> , null ) ; } private LogRecord ( Type type , String absolutePath , long updateTime , int numFiles , long checksum , String raw ) { assert ! type . hasFile ( ) | | absolutePath ! = null : <str> ; this . type = type ; this . absolutePath = type . hasFile ( ) ? Optional . of ( absolutePath ) : Optional . < String > empty ( ) ; this . updateTime = type = = Type . REMOVE ? updateTime : <int> ; this . numFiles = type . hasFile ( ) ? numFiles : <int> ; this . status = new Status ( ) ; if ( raw = = null ) { assert checksum = = <int> ; this . checksum = computeChecksum ( ) ; this . raw = format ( ) ; } else { this . checksum = checksum ; this . raw = raw ; } } LogRecord setError ( Throwable t ) { return setError ( t . getMessage ( ) ) ; } LogRecord setError ( String error ) { status . setError ( error ) ; return this ; } String error ( ) { return status . error . orElse ( <str> ) ; } void setPartial ( ) { status . partial = true ; } boolean partial ( ) { return status . partial ; } boolean isValid ( ) { return ! status . hasError ( ) & & type ! = Type . UNKNOWN ; } boolean isInvalid ( ) { return ! isValid ( ) ; } boolean isInvalidOrPartial ( ) { return isInvalid ( ) | | partial ( ) ; } private String format ( ) { return String . format ( <str> , type . toString ( ) , absolutePath ( ) , updateTime , numFiles , checksum ) ; } public List < File > getExistingFiles ( ) { assert absolutePath . isPresent ( ) : <str> ; return getExistingFiles ( absolutePath . get ( ) ) ; } public static List < File > getExistingFiles ( String absoluteFilePath ) { Path path = Paths . get ( absoluteFilePath ) ; File [ ] files = path . getParent ( ) . toFile ( ) . listFiles ( ( dir , name ) - > name . startsWith ( path . getFileName ( ) . toString ( ) ) ) ; return files = = null ? Collections . emptyList ( ) : Arrays . asList ( files ) ; } public boolean isFinal ( ) { return type . isFinal ( ) ; } String fileName ( ) { return absolutePath . isPresent ( ) ? Paths . get ( absolutePath . get ( ) ) . getFileName ( ) . toString ( ) : <str> ; } String absolutePath ( ) { return absolutePath . isPresent ( ) ? absolutePath . get ( ) : <str> ; } @Override public int hashCode ( ) { return Objects . hash ( type , absolutePath , numFiles , updateTime ) ; } @Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof LogRecord ) ) return false ; final LogRecord other = ( LogRecord ) obj ; return type = = other . type & & absolutePath . equals ( other . absolutePath ) & & numFiles = = other . numFiles & & updateTime = = other . updateTime ; } @Override public String toString ( ) { return raw ; } long computeChecksum ( ) { CRC32 crc32 = new CRC32 ( ) ; crc32 . update ( ( absolutePath ( ) ) . getBytes ( FileUtils . CHARSET ) ) ; crc32 . update ( type . toString ( ) . getBytes ( FileUtils . CHARSET ) ) ; FBUtilities . updateChecksumInt ( crc32 , ( int ) updateTime ) ; FBUtilities . updateChecksumInt ( crc32 , ( int ) ( updateTime > > > <int> ) ) ; FBUtilities . updateChecksumInt ( crc32 , numFiles ) ; return crc32 . getValue ( ) & ( Long . MAX_VALUE ) ; } } 
