package org . apache . cassandra . cql3 ; import java . util . Collections ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . InvalidRequestException ; public abstract class Operation { public final ColumnDefinition column ; protected final Term t ; protected Operation ( ColumnDefinition column , Term t ) { assert column ! = null ; this . column = column ; this . t = t ; } public Iterable < Function > getFunctions ( ) { return t ! = null ? t . getFunctions ( ) : Collections . < Function > emptySet ( ) ; } public boolean requiresRead ( ) { return false ; } public void collectMarkerSpecification ( VariableSpecifications boundNames ) { if ( t ! = null ) t . collectMarkerSpecification ( boundNames ) ; } public abstract void execute ( DecoratedKey partitionKey , UpdateParameters params ) throws InvalidRequestException ; public interface RawUpdate { public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException ; public boolean isCompatibleWith ( RawUpdate other ) ; } public interface RawDeletion { public ColumnIdentifier . Raw affectedColumn ( ) ; public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException ; } public static class SetValue implements RawUpdate { private final Term . Raw value ; public SetValue ( Term . Raw value ) { this . value = value ; } public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException { Term v = value . prepare ( keyspace , receiver ) ; if ( receiver . type instanceof CounterColumnType ) throw new InvalidRequestException ( String . format ( <str> , receiver . name ) ) ; if ( ! ( receiver . type . isCollection ( ) ) ) return new Constants . Setter ( receiver , v ) ; switch ( ( ( CollectionType ) receiver . type ) . kind ) { case LIST : return new Lists . Setter ( receiver , v ) ; case SET : return new Sets . Setter ( receiver , v ) ; case MAP : return new Maps . Setter ( receiver , v ) ; } throw new AssertionError ( ) ; } protected String toString ( ColumnSpecification column ) { return String . format ( <str> , column , value ) ; } public boolean isCompatibleWith ( RawUpdate other ) { return false ; } } public static class SetElement implements RawUpdate { private final Term . Raw selector ; private final Term . Raw value ; public SetElement ( Term . Raw selector , Term . Raw value ) { this . selector = selector ; this . value = value ; } public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException { if ( ! ( receiver . type instanceof CollectionType ) ) throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; else if ( ! ( receiver . type . isMultiCell ( ) ) ) throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; switch ( ( ( CollectionType ) receiver . type ) . kind ) { case LIST : Term idx = selector . prepare ( keyspace , Lists . indexSpecOf ( receiver ) ) ; Term lval = value . prepare ( keyspace , Lists . valueSpecOf ( receiver ) ) ; return new Lists . SetterByIndex ( receiver , idx , lval ) ; case SET : throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; case MAP : Term key = selector . prepare ( keyspace , Maps . keySpecOf ( receiver ) ) ; Term mval = value . prepare ( keyspace , Maps . valueSpecOf ( receiver ) ) ; return new Maps . SetterByKey ( receiver , key , mval ) ; } throw new AssertionError ( ) ; } protected String toString ( ColumnSpecification column ) { return String . format ( <str> , column . name , selector , value ) ; } public boolean isCompatibleWith ( RawUpdate other ) { return ! ( other instanceof SetValue ) ; } } public static class Addition implements RawUpdate { private final Term . Raw value ; public Addition ( Term . Raw value ) { this . value = value ; } public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException { Term v = value . prepare ( keyspace , receiver ) ; if ( ! ( receiver . type instanceof CollectionType ) ) { if ( ! ( receiver . type instanceof CounterColumnType ) ) throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; return new Constants . Adder ( receiver , v ) ; } else if ( ! ( receiver . type . isMultiCell ( ) ) ) throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; switch ( ( ( CollectionType ) receiver . type ) . kind ) { case LIST : return new Lists . Appender ( receiver , v ) ; case SET : return new Sets . Adder ( receiver , v ) ; case MAP : return new Maps . Putter ( receiver , v ) ; } throw new AssertionError ( ) ; } protected String toString ( ColumnSpecification column ) { return String . format ( <str> , column . name , column . name , value ) ; } public boolean isCompatibleWith ( RawUpdate other ) { return ! ( other instanceof SetValue ) ; } } public static class Substraction implements RawUpdate { private final Term . Raw value ; public Substraction ( Term . Raw value ) { this . value = value ; } public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException { if ( ! ( receiver . type instanceof CollectionType ) ) { if ( ! ( receiver . type instanceof CounterColumnType ) ) throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; return new Constants . Substracter ( receiver , value . prepare ( keyspace , receiver ) ) ; } else if ( ! ( receiver . type . isMultiCell ( ) ) ) throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; switch ( ( ( CollectionType ) receiver . type ) . kind ) { case LIST : return new Lists . Discarder ( receiver , value . prepare ( keyspace , receiver ) ) ; case SET : return new Sets . Discarder ( receiver , value . prepare ( keyspace , receiver ) ) ; case MAP : ColumnSpecification vr = new ColumnSpecification ( receiver . ksName , receiver . cfName , receiver . name , SetType . getInstance ( ( ( MapType ) receiver . type ) . getKeysType ( ) , false ) ) ; return new Sets . Discarder ( receiver , value . prepare ( keyspace , vr ) ) ; } throw new AssertionError ( ) ; } protected String toString ( ColumnSpecification column ) { return String . format ( <str> , column . name , column . name , value ) ; } public boolean isCompatibleWith ( RawUpdate other ) { return ! ( other instanceof SetValue ) ; } } public static class Prepend implements RawUpdate { private final Term . Raw value ; public Prepend ( Term . Raw value ) { this . value = value ; } public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException { Term v = value . prepare ( keyspace , receiver ) ; if ( ! ( receiver . type instanceof ListType ) ) throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; else if ( ! ( receiver . type . isMultiCell ( ) ) ) throw new InvalidRequestException ( String . format ( <str> , toString ( receiver ) , receiver . name ) ) ; return new Lists . Prepender ( receiver , v ) ; } protected String toString ( ColumnSpecification column ) { return String . format ( <str> , column . name , value , column . name ) ; } public boolean isCompatibleWith ( RawUpdate other ) { return ! ( other instanceof SetValue ) ; } } public static class ColumnDeletion implements RawDeletion { private final ColumnIdentifier . Raw id ; public ColumnDeletion ( ColumnIdentifier . Raw id ) { this . id = id ; } public ColumnIdentifier . Raw affectedColumn ( ) { return id ; } public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException { return new Constants . Deleter ( receiver ) ; } } public static class ElementDeletion implements RawDeletion { private final ColumnIdentifier . Raw id ; private final Term . Raw element ; public ElementDeletion ( ColumnIdentifier . Raw id , Term . Raw element ) { this . id = id ; this . element = element ; } public ColumnIdentifier . Raw affectedColumn ( ) { return id ; } public Operation prepare ( String keyspace , ColumnDefinition receiver ) throws InvalidRequestException { if ( ! ( receiver . type . isCollection ( ) ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name ) ) ; else if ( ! ( receiver . type . isMultiCell ( ) ) ) throw new InvalidRequestException ( String . format ( <str> , receiver . name ) ) ; switch ( ( ( CollectionType ) receiver . type ) . kind ) { case LIST : Term idx = element . prepare ( keyspace , Lists . indexSpecOf ( receiver ) ) ; return new Lists . DiscarderByIndex ( receiver , idx ) ; case SET : Term elt = element . prepare ( keyspace , Sets . valueSpecOf ( receiver ) ) ; return new Sets . ElementDiscarder ( receiver , elt ) ; case MAP : Term key = element . prepare ( keyspace , Maps . keySpecOf ( receiver ) ) ; return new Maps . DiscarderByKey ( receiver , key ) ; } throw new AssertionError ( ) ; } } } 
