package io . netty . channel . nio ; import io . netty . channel . Channel ; import io . netty . channel . ChannelException ; import io . netty . channel . EventLoopException ; import io . netty . channel . SingleThreadEventLoop ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . IOException ; import java . lang . reflect . Field ; import java . nio . channels . CancelledKeyException ; import java . nio . channels . SelectableChannel ; import java . nio . channels . SelectionKey ; import java . nio . channels . Selector ; import java . nio . channels . spi . SelectorProvider ; import java . util . ArrayList ; import java . util . Collection ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . Queue ; import java . util . Set ; import java . util . concurrent . Executor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; public final class NioEventLoop extends SingleThreadEventLoop { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( NioEventLoop . class ) ; private static final int CLEANUP_INTERVAL = <int> ; private static final boolean DISABLE_KEYSET_OPTIMIZATION = SystemPropertyUtil . getBoolean ( <str> , false ) ; private static final int MIN_PREMATURE_SELECTOR_RETURNS = <int> ; private static final int SELECTOR_AUTO_REBUILD_THRESHOLD ; static { String key = <str> ; try { String buglevel = SystemPropertyUtil . get ( key ) ; if ( buglevel = = null ) { System . setProperty ( key , <str> ) ; } } catch ( SecurityException e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , key , e ) ; } } int selectorAutoRebuildThreshold = SystemPropertyUtil . getInt ( <str> , <int> ) ; if ( selectorAutoRebuildThreshold < MIN_PREMATURE_SELECTOR_RETURNS ) { selectorAutoRebuildThreshold = <int> ; } SELECTOR_AUTO_REBUILD_THRESHOLD = selectorAutoRebuildThreshold ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , DISABLE_KEYSET_OPTIMIZATION ) ; logger . debug ( <str> , SELECTOR_AUTO_REBUILD_THRESHOLD ) ; } } Selector selector ; private SelectedSelectionKeySet selectedKeys ; private final SelectorProvider provider ; private final AtomicBoolean wakenUp = new AtomicBoolean ( ) ; private volatile int ioRatio = <int> ; private int cancelledKeys ; private boolean needsToSelectAgain ; NioEventLoop ( NioEventLoopGroup parent , Executor executor , SelectorProvider selectorProvider ) { super ( parent , executor , false ) ; if ( selectorProvider = = null ) { throw new NullPointerException ( <str> ) ; } provider = selectorProvider ; selector = openSelector ( ) ; } private Selector openSelector ( ) { final Selector selector ; try { selector = provider . openSelector ( ) ; } catch ( IOException e ) { throw new ChannelException ( <str> , e ) ; } if ( DISABLE_KEYSET_OPTIMIZATION ) { return selector ; } try { SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet ( ) ; Class < ? > selectorImplClass = Class . forName ( <str> , false , PlatformDependent . getSystemClassLoader ( ) ) ; if ( ! selectorImplClass . isAssignableFrom ( selector . getClass ( ) ) ) { return selector ; } Field selectedKeysField = selectorImplClass . getDeclaredField ( <str> ) ; Field publicSelectedKeysField = selectorImplClass . getDeclaredField ( <str> ) ; selectedKeysField . setAccessible ( true ) ; publicSelectedKeysField . setAccessible ( true ) ; selectedKeysField . set ( selector , selectedKeySet ) ; publicSelectedKeysField . set ( selector , selectedKeySet ) ; selectedKeys = selectedKeySet ; logger . trace ( <str> , selector ) ; } catch ( Throwable t ) { selectedKeys = null ; logger . trace ( <str> , selector , t ) ; } return selector ; } @Override protected Queue < Runnable > newTaskQueue ( ) { return PlatformDependent . newMpscQueue ( ) ; } public void register ( final SelectableChannel ch , final int interestOps , final NioTask < ? > task ) { if ( ch = = null ) { throw new NullPointerException ( <str> ) ; } if ( interestOps = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( ( interestOps & ~ ch . validOps ( ) ) ! = <int> ) { throw new IllegalArgumentException ( <str> + interestOps + <str> + ch . validOps ( ) + <str> ) ; } if ( task = = null ) { throw new NullPointerException ( <str> ) ; } if ( isShutdown ( ) ) { throw new IllegalStateException ( <str> ) ; } try { ch . register ( selector , interestOps , task ) ; } catch ( Exception e ) { throw new EventLoopException ( <str> , e ) ; } } public int getIoRatio ( ) { return ioRatio ; } public void setIoRatio ( int ioRatio ) { if ( ioRatio < = <int> | | ioRatio > <int> ) { throw new IllegalArgumentException ( <str> + ioRatio + <str> ) ; } this . ioRatio = ioRatio ; } public void rebuildSelector ( ) { if ( ! inEventLoop ( ) ) { execute ( new Runnable ( ) { @Override public void run ( ) { rebuildSelector ( ) ; } } ) ; return ; } final Selector oldSelector = selector ; final Selector newSelector ; if ( oldSelector = = null ) { return ; } try { newSelector = openSelector ( ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; return ; } int nChannels = <int> ; for ( ; ; ) { try { for ( SelectionKey key : oldSelector . keys ( ) ) { Object a = key . attachment ( ) ; try { if ( ! key . isValid ( ) | | key . channel ( ) . keyFor ( newSelector ) ! = null ) { continue ; } int interestOps = key . interestOps ( ) ; key . cancel ( ) ; SelectionKey newKey = key . channel ( ) . register ( newSelector , interestOps , a ) ; if ( a instanceof AbstractNioChannel ) { ( ( AbstractNioChannel ) a ) . selectionKey = newKey ; } nChannels + + ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; if ( a instanceof AbstractNioChannel ) { AbstractNioChannel ch = ( AbstractNioChannel ) a ; ch . unsafe ( ) . close ( ch . unsafe ( ) . voidPromise ( ) ) ; } else { @SuppressWarnings ( <str> ) NioTask < SelectableChannel > task = ( NioTask < SelectableChannel > ) a ; invokeChannelUnregistered ( task , key , e ) ; } } } } catch ( ConcurrentModificationException e ) { continue ; } break ; } selector = newSelector ; try { oldSelector . close ( ) ; } catch ( Throwable t ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , t ) ; } } logger . info ( <str> + nChannels + <str> ) ; } @Override protected void run ( ) { for ( ; ; ) { boolean oldWakenUp = wakenUp . getAndSet ( false ) ; try { if ( hasTasks ( ) ) { selectNow ( ) ; } else { select ( oldWakenUp ) ; if ( wakenUp . get ( ) ) { selector . wakeup ( ) ; } } cancelledKeys = <int> ; needsToSelectAgain = false ; final int ioRatio = this . ioRatio ; if ( ioRatio = = <int> ) { processSelectedKeys ( ) ; runAllTasks ( ) ; } else { final long ioStartTime = System . nanoTime ( ) ; processSelectedKeys ( ) ; final long ioTime = System . nanoTime ( ) - ioStartTime ; runAllTasks ( ioTime * ( <int> - ioRatio ) / ioRatio ) ; } if ( isShuttingDown ( ) ) { closeAll ( ) ; if ( confirmShutdown ( ) ) { break ; } } } catch ( Throwable t ) { logger . warn ( <str> , t ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } } private void processSelectedKeys ( ) { if ( selectedKeys ! = null ) { processSelectedKeysOptimized ( selectedKeys . flip ( ) ) ; } else { processSelectedKeysPlain ( selector . selectedKeys ( ) ) ; } } @Override protected void cleanup ( ) { try { selector . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } void cancel ( SelectionKey key ) { key . cancel ( ) ; cancelledKeys + + ; if ( cancelledKeys > = CLEANUP_INTERVAL ) { cancelledKeys = <int> ; needsToSelectAgain = true ; } } @Override protected Runnable pollTask ( ) { Runnable task = super . pollTask ( ) ; if ( needsToSelectAgain ) { selectAgain ( ) ; } return task ; } private void processSelectedKeysPlain ( Set < SelectionKey > selectedKeys ) { if ( selectedKeys . isEmpty ( ) ) { return ; } Iterator < SelectionKey > i = selectedKeys . iterator ( ) ; for ( ; ; ) { final SelectionKey k = i . next ( ) ; final Object a = k . attachment ( ) ; i . remove ( ) ; if ( a instanceof AbstractNioChannel ) { processSelectedKey ( k , ( AbstractNioChannel ) a ) ; } else { @SuppressWarnings ( <str> ) NioTask < SelectableChannel > task = ( NioTask < SelectableChannel > ) a ; processSelectedKey ( k , task ) ; } if ( ! i . hasNext ( ) ) { break ; } if ( needsToSelectAgain ) { selectAgain ( ) ; selectedKeys = selector . selectedKeys ( ) ; if ( selectedKeys . isEmpty ( ) ) { break ; } else { i = selectedKeys . iterator ( ) ; } } } } private void processSelectedKeysOptimized ( SelectionKey [ ] selectedKeys ) { for ( int i = <int> ; ; i + + ) { final SelectionKey k = selectedKeys [ i ] ; if ( k = = null ) { break ; } selectedKeys [ i ] = null ; final Object a = k . attachment ( ) ; if ( a instanceof AbstractNioChannel ) { processSelectedKey ( k , ( AbstractNioChannel ) a ) ; } else { @SuppressWarnings ( <str> ) NioTask < SelectableChannel > task = ( NioTask < SelectableChannel > ) a ; processSelectedKey ( k , task ) ; } if ( needsToSelectAgain ) { for ( ; ; ) { if ( selectedKeys [ i ] = = null ) { break ; } selectedKeys [ i ] = null ; i + + ; } selectAgain ( ) ; selectedKeys = this . selectedKeys . flip ( ) ; i = - <int> ; } } } private static void processSelectedKey ( SelectionKey k , AbstractNioChannel ch ) { final AbstractNioChannel . NioUnsafe unsafe = ch . unsafe ( ) ; if ( ! k . isValid ( ) ) { unsafe . close ( unsafe . voidPromise ( ) ) ; return ; } try { int readyOps = k . readyOps ( ) ; if ( ( readyOps & ( SelectionKey . OP_READ | SelectionKey . OP_ACCEPT ) ) ! = <int> | | readyOps = = <int> ) { unsafe . read ( ) ; if ( ! ch . isOpen ( ) ) { return ; } } if ( ( readyOps & SelectionKey . OP_WRITE ) ! = <int> ) { ch . unsafe ( ) . forceFlush ( ) ; } if ( ( readyOps & SelectionKey . OP_CONNECT ) ! = <int> ) { int ops = k . interestOps ( ) ; ops & = ~ SelectionKey . OP_CONNECT ; k . interestOps ( ops ) ; unsafe . finishConnect ( ) ; } } catch ( CancelledKeyException ignored ) { unsafe . close ( unsafe . voidPromise ( ) ) ; } } private static void processSelectedKey ( SelectionKey k , NioTask < SelectableChannel > task ) { int state = <int> ; try { task . channelReady ( k . channel ( ) , k ) ; state = <int> ; } catch ( Exception e ) { k . cancel ( ) ; invokeChannelUnregistered ( task , k , e ) ; state = <int> ; } finally { switch ( state ) { case <int> : k . cancel ( ) ; invokeChannelUnregistered ( task , k , null ) ; break ; case <int> : if ( ! k . isValid ( ) ) { invokeChannelUnregistered ( task , k , null ) ; } break ; } } } private void closeAll ( ) { selectAgain ( ) ; Set < SelectionKey > keys = selector . keys ( ) ; Collection < AbstractNioChannel > channels = new ArrayList < AbstractNioChannel > ( keys . size ( ) ) ; for ( SelectionKey k : keys ) { Object a = k . attachment ( ) ; if ( a instanceof AbstractNioChannel ) { channels . add ( ( AbstractNioChannel ) a ) ; } else { k . cancel ( ) ; @SuppressWarnings ( <str> ) NioTask < SelectableChannel > task = ( NioTask < SelectableChannel > ) a ; invokeChannelUnregistered ( task , k , null ) ; } } for ( AbstractNioChannel ch : channels ) { ch . unsafe ( ) . close ( ch . unsafe ( ) . voidPromise ( ) ) ; } } private static void invokeChannelUnregistered ( NioTask < SelectableChannel > task , SelectionKey k , Throwable cause ) { try { task . channelUnregistered ( k . channel ( ) , cause ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } } @Override protected void wakeup ( boolean inEventLoop ) { if ( ! inEventLoop & & wakenUp . compareAndSet ( false , true ) ) { selector . wakeup ( ) ; } } void selectNow ( ) throws IOException { try { selector . selectNow ( ) ; } finally { if ( wakenUp . get ( ) ) { selector . wakeup ( ) ; } } } private void select ( boolean oldWakenUp ) throws IOException { Selector selector = this . selector ; try { int selectCnt = <int> ; long currentTimeNanos = System . nanoTime ( ) ; long selectDeadLineNanos = currentTimeNanos + delayNanos ( currentTimeNanos ) ; for ( ; ; ) { long timeoutMillis = ( selectDeadLineNanos - currentTimeNanos + <int> ) / <int> ; if ( timeoutMillis < = <int> ) { if ( selectCnt = = <int> ) { selector . selectNow ( ) ; selectCnt = <int> ; } break ; } int selectedKeys = selector . select ( timeoutMillis ) ; selectCnt + + ; if ( selectedKeys ! = <int> | | oldWakenUp | | wakenUp . get ( ) | | hasTasks ( ) | | hasScheduledTasks ( ) ) { break ; } if ( Thread . interrupted ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + <str> + <str> ) ; } selectCnt = <int> ; break ; } long time = System . nanoTime ( ) ; if ( time - TimeUnit . MILLISECONDS . toNanos ( timeoutMillis ) > = currentTimeNanos ) { selectCnt = <int> ; } else if ( SELECTOR_AUTO_REBUILD_THRESHOLD > <int> & & selectCnt > = SELECTOR_AUTO_REBUILD_THRESHOLD ) { logger . warn ( <str> , selectCnt ) ; rebuildSelector ( ) ; selector = this . selector ; selector . selectNow ( ) ; selectCnt = <int> ; break ; } currentTimeNanos = time ; } if ( selectCnt > MIN_PREMATURE_SELECTOR_RETURNS ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , selectCnt - <int> ) ; } } } catch ( CancelledKeyException e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( CancelledKeyException . class . getSimpleName ( ) + <str> , e ) ; } } } private void selectAgain ( ) { needsToSelectAgain = false ; try { selector . selectNow ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } } 
