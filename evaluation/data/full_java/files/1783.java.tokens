package org . apache . cassandra . stress . util ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; public class Timing { private final Map < String , List < Timer > > timers = new TreeMap < > ( ) ; private volatile TimingIntervals history ; private final int historySampleCount ; private final int reportSampleCount ; private boolean done ; public Timing ( int historySampleCount , int reportSampleCount ) { this . historySampleCount = historySampleCount ; this . reportSampleCount = reportSampleCount ; } public static class TimingResult < E > { public final E extra ; public final TimingIntervals intervals ; public TimingResult ( E extra , TimingIntervals intervals ) { this . extra = extra ; this . intervals = intervals ; } } public < E > TimingResult < E > snap ( Callable < E > call ) throws InterruptedException { int timerCount = <int> ; for ( List < Timer > timersForOperation : timers . values ( ) ) { timerCount + = timersForOperation . size ( ) ; } final CountDownLatch ready = new CountDownLatch ( timerCount ) ; for ( List < Timer > timersForOperation : timers . values ( ) ) { for ( Timer timer : timersForOperation ) { timer . requestReport ( ready ) ; } } E extra ; try { extra = call . call ( ) ; } catch ( Exception e ) { if ( e instanceof InterruptedException ) throw ( InterruptedException ) e ; throw new RuntimeException ( e ) ; } if ( ! ready . await ( <int> , TimeUnit . MINUTES ) ) { throw new RuntimeException ( <str> ) ; } boolean done = true ; Map < String , TimingInterval > intervals = new TreeMap < > ( ) ; for ( Map . Entry < String , List < Timer > > entry : timers . entrySet ( ) ) { List < TimingInterval > operationIntervals = new ArrayList < > ( ) ; for ( Timer timer : entry . getValue ( ) ) { operationIntervals . add ( timer . report ) ; done & = ! timer . running ( ) ; } intervals . put ( entry . getKey ( ) , TimingInterval . merge ( operationIntervals , reportSampleCount , history . get ( entry . getKey ( ) ) . endNanos ( ) ) ) ; } TimingIntervals result = new TimingIntervals ( intervals ) ; this . done = done ; history = history . merge ( result , historySampleCount , history . startNanos ( ) ) ; return new TimingResult < > ( extra , result ) ; } public Timer newTimer ( String opType , int sampleCount ) { final Timer timer = new Timer ( sampleCount ) ; if ( ! timers . containsKey ( opType ) ) timers . put ( opType , new ArrayList < Timer > ( ) ) ; timers . get ( opType ) . add ( timer ) ; return timer ; } public void start ( ) { history = new TimingIntervals ( timers . keySet ( ) ) ; } public boolean done ( ) { return done ; } public TimingIntervals getHistory ( ) { return history ; } } 
