package org . apache . cassandra . repair ; import java . io . IOException ; import java . net . InetAddress ; import java . util . Arrays ; import java . util . Set ; import java . util . UUID ; import java . util . concurrent . ExecutionException ; import com . google . common . collect . Sets ; import org . junit . Test ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Murmur3Partitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . gms . Gossiper ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . UUIDGen ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; public class RepairSessionTest { @Test public void testConviction ( ) throws Exception { InetAddress remote = InetAddress . getByName ( <str> ) ; Gossiper . instance . initializeNodeUnsafe ( remote , UUID . randomUUID ( ) , <int> ) ; UUID parentSessionId = UUIDGen . getTimeUUID ( ) ; UUID sessionId = UUID . randomUUID ( ) ; IPartitioner p = Murmur3Partitioner . instance ; Range < Token > repairRange = new Range < > ( p . getToken ( ByteBufferUtil . bytes ( <int> ) ) , p . getToken ( ByteBufferUtil . bytes ( <int> ) ) ) ; Set < InetAddress > endpoints = Sets . newHashSet ( remote ) ; RepairSession session = new RepairSession ( parentSessionId , sessionId , Arrays . asList ( repairRange ) , <str> , RepairParallelism . SEQUENTIAL , endpoints , ActiveRepairService . UNREPAIRED_SSTABLE , <str> ) ; session . convict ( remote , Double . MAX_VALUE ) ; try { session . get ( ) ; fail ( ) ; } catch ( ExecutionException ex ) { assertEquals ( IOException . class , ex . getCause ( ) . getClass ( ) ) ; } } } 
