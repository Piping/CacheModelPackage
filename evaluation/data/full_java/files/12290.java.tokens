package org . gradle . process . internal . child ; import com . tonicsystems . jarjar . JarJarTask ; import com . tonicsystems . jarjar . Rule ; import org . apache . tools . ant . types . Resource ; import org . apache . tools . ant . types . ResourceCollection ; import org . apache . tools . ant . types . resources . URLResource ; import org . gradle . api . Action ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . internal . ClassPathProvider ; import org . gradle . api . internal . classpath . ModuleRegistry ; import org . gradle . cache . CacheRepository ; import org . gradle . cache . PersistentCache ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . process . internal . launcher . GradleWorkerMain ; import org . gradle . util . AntUtil ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . Closeable ; import java . io . File ; import java . io . IOException ; import java . net . URL ; import java . util . * ; public class WorkerProcessClassPathProvider implements ClassPathProvider , Closeable { private static final Logger LOGGER = LoggerFactory . getLogger ( WorkerProcessClassPathProvider . class ) ; private final CacheRepository cacheRepository ; private final ModuleRegistry moduleRegistry ; private final Object lock = new Object ( ) ; private ClassPath workerClassPath ; private PersistentCache workerClassPathCache ; public WorkerProcessClassPathProvider ( CacheRepository cacheRepository , ModuleRegistry moduleRegistry ) { this . cacheRepository = cacheRepository ; this . moduleRegistry = moduleRegistry ; } public ClassPath findClassPath ( String name ) { if ( name . equals ( <str> ) ) { ClassPath classpath = new DefaultClassPath ( ) ; classpath = classpath . plus ( moduleRegistry . getModule ( <str> ) . getImplementationClasspath ( ) ) ; classpath = classpath . plus ( moduleRegistry . getModule ( <str> ) . getImplementationClasspath ( ) ) ; classpath = classpath . plus ( moduleRegistry . getModule ( <str> ) . getImplementationClasspath ( ) ) ; classpath = classpath . plus ( moduleRegistry . getModule ( <str> ) . getImplementationClasspath ( ) ) ; classpath = classpath . plus ( moduleRegistry . getModule ( <str> ) . getImplementationClasspath ( ) ) ; classpath = classpath . plus ( moduleRegistry . getExternalModule ( <str> ) . getClasspath ( ) ) ; classpath = classpath . plus ( moduleRegistry . getExternalModule ( <str> ) . getClasspath ( ) ) ; classpath = classpath . plus ( moduleRegistry . getExternalModule ( <str> ) . getClasspath ( ) ) ; return classpath ; } if ( name . equals ( <str> ) ) { synchronized ( lock ) { if ( workerClassPath = = null ) { workerClassPathCache = cacheRepository . cache ( <str> ) . withInitializer ( new CacheInitializer ( ) ) . open ( ) ; workerClassPath = new DefaultClassPath ( jarFile ( workerClassPathCache ) ) ; } LOGGER . debug ( <str> , workerClassPath ) ; return workerClassPath ; } } return null ; } public void close ( ) { synchronized ( lock ) { try { if ( workerClassPathCache ! = null ) { workerClassPathCache . close ( ) ; } } finally { workerClassPathCache = null ; workerClassPath = null ; } } } private static File jarFile ( PersistentCache cache ) { return new File ( cache . getBaseDir ( ) , <str> ) ; } private static class CacheInitializer implements Action < PersistentCache > { public void execute ( PersistentCache cache ) { File jarFile = jarFile ( cache ) ; LOGGER . debug ( <str> , jarFile ) ; URL currentClasspath = getClass ( ) . getProtectionDomain ( ) . getCodeSource ( ) . getLocation ( ) ; JarJarTask task = new JarJarTask ( ) ; task . setDestFile ( jarFile ) ; final List < Resource > classResources = new ArrayList < Resource > ( ) ; List < Class < ? > > renamedClasses = Arrays . asList ( GradleWorkerMain . class , BootstrapSecurityManager . class , EncodedStream . EncodedInput . class ) ; List < Class < ? > > classes = new ArrayList < Class < ? > > ( ) ; classes . addAll ( renamedClasses ) ; for ( Class < ? > aClass : classes ) { final String fileName = aClass . getName ( ) . replace ( <str> , <str> ) + <str> ; Enumeration < URL > resources ; try { resources = WorkerProcessClassPathProvider . class . getClassLoader ( ) . getResources ( fileName ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } URL resource = null ; while ( resources . hasMoreElements ( ) ) { URL url = resources . nextElement ( ) ; resource = url ; if ( url . toString ( ) . startsWith ( currentClasspath . toString ( ) ) ) { break ; } } URLResource urlResource = new URLResource ( resource ) { @Override public synchronized String getName ( ) { return fileName ; } } ; classResources . add ( urlResource ) ; } task . add ( new ResourceCollection ( ) { public Iterator iterator ( ) { return classResources . iterator ( ) ; } public int size ( ) { return classResources . size ( ) ; } public boolean isFilesystemOnly ( ) { return true ; } } ) ; Rule rule = new Rule ( ) ; rule . setPattern ( SystemApplicationClassLoaderWorker . class . getName ( ) ) ; rule . setResult ( SystemApplicationClassLoaderWorker . class . getName ( ) ) ; task . addConfiguredRule ( rule ) ; rule = new Rule ( ) ; rule . setPattern ( <str> ) ; rule . setResult ( <str> ) ; task . addConfiguredRule ( rule ) ; AntUtil . execute ( task ) ; } } } 
