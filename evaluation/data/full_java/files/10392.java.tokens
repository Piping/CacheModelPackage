package com . google . common . collect ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Function ; import com . google . common . base . Functions ; import com . google . common . collect . testing . MapInterfaceTest ; import java . util . Collection ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import javax . annotation . Nullable ; @GwtCompatible public class MapsTransformValuesUnmodifiableIteratorTest extends MapInterfaceTest < String , String > { public MapsTransformValuesUnmodifiableIteratorTest ( ) { super ( true , true , false , true , true , false ) ; } private static class UnmodifiableIteratorMap < K , V > extends ForwardingMap < K , V > { final Map < K , V > delegate ; UnmodifiableIteratorMap ( Map < K , V > delegate ) { this . delegate = delegate ; } @Override protected Map < K , V > delegate ( ) { return delegate ; } @Override public Set < K > keySet ( ) { return new ForwardingSet < K > ( ) { @Override protected Set < K > delegate ( ) { return delegate . keySet ( ) ; } @Override public Iterator < K > iterator ( ) { return Iterators . unmodifiableIterator ( delegate . keySet ( ) . iterator ( ) ) ; } @Override public boolean removeAll ( Collection < ? > c ) { return delegate . keySet ( ) . removeAll ( c ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return delegate . keySet ( ) . retainAll ( c ) ; } } ; } @Override public Collection < V > values ( ) { return new ForwardingCollection < V > ( ) { @Override protected Collection < V > delegate ( ) { return delegate . values ( ) ; } @Override public Iterator < V > iterator ( ) { return Iterators . unmodifiableIterator ( delegate . values ( ) . iterator ( ) ) ; } @Override public boolean removeAll ( Collection < ? > c ) { return delegate . values ( ) . removeAll ( c ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return delegate . values ( ) . retainAll ( c ) ; } } ; } @Override public Set < Entry < K , V > > entrySet ( ) { return new ForwardingSet < Entry < K , V > > ( ) { @Override protected Set < Entry < K , V > > delegate ( ) { return delegate . entrySet ( ) ; } @Override public Iterator < Entry < K , V > > iterator ( ) { return Iterators . unmodifiableIterator ( delegate . entrySet ( ) . iterator ( ) ) ; } @Override public boolean removeAll ( Collection < ? > c ) { return delegate . entrySet ( ) . removeAll ( c ) ; } @Override public boolean retainAll ( Collection < ? > c ) { return delegate . entrySet ( ) . retainAll ( c ) ; } } ; } } @Override protected Map < String , String > makeEmptyMap ( ) { Map < String , Integer > underlying = Maps . newHashMap ( ) ; return Maps . transformValues ( new UnmodifiableIteratorMap < String , Integer > ( underlying ) , Functions . toStringFunction ( ) ) ; } @Override protected Map < String , String > makePopulatedMap ( ) { Map < String , Integer > underlying = Maps . newHashMap ( ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; return Maps . transformValues ( new UnmodifiableIteratorMap < String , Integer > ( underlying ) , Functions . toStringFunction ( ) ) ; } @Override protected String getKeyNotInPopulatedMap ( ) throws UnsupportedOperationException { return <str> ; } @Override protected String getValueNotInPopulatedMap ( ) throws UnsupportedOperationException { return <str> ; } private void assertMapsEqual ( Map < ? , ? > expected , Map < ? , ? > map ) { assertEquals ( expected , map ) ; assertEquals ( expected . hashCode ( ) , map . hashCode ( ) ) ; assertEquals ( expected . entrySet ( ) , map . entrySet ( ) ) ; Collection < ? > expectedValues = expected . values ( ) ; Collection < ? > mapValues = map . values ( ) ; assertEquals ( expectedValues . size ( ) , mapValues . size ( ) ) ; assertTrue ( expectedValues . containsAll ( mapValues ) ) ; assertTrue ( mapValues . containsAll ( expectedValues ) ) ; } public void testTransformEmptyMapEquality ( ) { Map < String , String > map = Maps . transformValues ( ImmutableMap . < String , Integer > of ( ) , Functions . toStringFunction ( ) ) ; assertMapsEqual ( Maps . newHashMap ( ) , map ) ; } public void testTransformSingletonMapEquality ( ) { Map < String , String > map = Maps . transformValues ( ImmutableMap . of ( <str> , <int> ) , Functions . toStringFunction ( ) ) ; Map < String , String > expected = ImmutableMap . of ( <str> , <str> ) ; assertMapsEqual ( expected , map ) ; assertEquals ( expected . get ( <str> ) , map . get ( <str> ) ) ; } public void testTransformIdentityFunctionEquality ( ) { Map < String , Integer > underlying = ImmutableMap . of ( <str> , <int> ) ; Map < String , Integer > map = Maps . transformValues ( underlying , Functions . < Integer > identity ( ) ) ; assertMapsEqual ( underlying , map ) ; } public void testTransformPutEntryIsUnsupported ( ) { Map < String , String > map = Maps . transformValues ( ImmutableMap . of ( <str> , <int> ) , Functions . toStringFunction ( ) ) ; try { map . put ( <str> , <str> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } try { map . putAll ( ImmutableMap . of ( <str> , <str> ) ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } try { map . entrySet ( ) . iterator ( ) . next ( ) . setValue ( <str> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testTransformRemoveEntry ( ) { Map < String , Integer > underlying = Maps . newHashMap ( ) ; underlying . put ( <str> , <int> ) ; Map < String , String > map = Maps . transformValues ( underlying , Functions . toStringFunction ( ) ) ; assertEquals ( <str> , map . remove ( <str> ) ) ; assertNull ( map . remove ( <str> ) ) ; } public void testTransformEqualityOfMapsWithNullValues ( ) { Map < String , String > underlying = Maps . newHashMap ( ) ; underlying . put ( <str> , null ) ; underlying . put ( <str> , <str> ) ; Map < String , Boolean > map = Maps . transformValues ( underlying , new Function < String , Boolean > ( ) { @Override public Boolean apply ( @Nullable String from ) { return from = = null ; } } ) ; Map < String , Boolean > expected = ImmutableMap . of ( <str> , true , <str> , false ) ; assertMapsEqual ( expected , map ) ; assertEquals ( expected . get ( <str> ) , map . get ( <str> ) ) ; assertEquals ( expected . containsKey ( <str> ) , map . containsKey ( <str> ) ) ; assertEquals ( expected . get ( <str> ) , map . get ( <str> ) ) ; assertEquals ( expected . containsKey ( <str> ) , map . containsKey ( <str> ) ) ; assertEquals ( expected . get ( <str> ) , map . get ( <str> ) ) ; assertEquals ( expected . containsKey ( <str> ) , map . containsKey ( <str> ) ) ; } public void testTransformReflectsUnderlyingMap ( ) { Map < String , Integer > underlying = Maps . newHashMap ( ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; Map < String , String > map = Maps . transformValues ( underlying , Functions . toStringFunction ( ) ) ; assertEquals ( underlying . size ( ) , map . size ( ) ) ; underlying . put ( <str> , <int> ) ; assertEquals ( underlying . size ( ) , map . size ( ) ) ; assertEquals ( <str> , map . get ( <str> ) ) ; underlying . remove ( <str> ) ; assertEquals ( underlying . size ( ) , map . size ( ) ) ; assertFalse ( map . containsKey ( <str> ) ) ; underlying . clear ( ) ; assertEquals ( underlying . size ( ) , map . size ( ) ) ; } public void testTransformChangesAreReflectedInUnderlyingMap ( ) { Map < String , Integer > underlying = Maps . newLinkedHashMap ( ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; underlying . put ( <str> , <int> ) ; Map < String , String > map = Maps . transformValues ( underlying , Functions . toStringFunction ( ) ) ; map . remove ( <str> ) ; assertFalse ( underlying . containsKey ( <str> ) ) ; Set < String > keys = map . keySet ( ) ; keys . remove ( <str> ) ; assertFalse ( underlying . containsKey ( <str> ) ) ; Iterator < String > keyIterator = keys . iterator ( ) ; keyIterator . next ( ) ; keyIterator . remove ( ) ; assertFalse ( underlying . containsKey ( <str> ) ) ; Collection < String > values = map . values ( ) ; values . remove ( <str> ) ; assertFalse ( underlying . containsKey ( <str> ) ) ; Iterator < String > valueIterator = values . iterator ( ) ; valueIterator . next ( ) ; valueIterator . remove ( ) ; assertFalse ( underlying . containsKey ( <str> ) ) ; Set < Map . Entry < String , String > > entries = map . entrySet ( ) ; Map . Entry < String , String > firstEntry = entries . iterator ( ) . next ( ) ; entries . remove ( firstEntry ) ; assertFalse ( underlying . containsKey ( <str> ) ) ; Iterator < Map . Entry < String , String > > entryIterator = entries . iterator ( ) ; entryIterator . next ( ) ; entryIterator . remove ( ) ; assertFalse ( underlying . containsKey ( <str> ) ) ; assertTrue ( underlying . isEmpty ( ) ) ; assertTrue ( map . isEmpty ( ) ) ; assertTrue ( keys . isEmpty ( ) ) ; assertTrue ( values . isEmpty ( ) ) ; assertTrue ( entries . isEmpty ( ) ) ; } public void testTransformEquals ( ) { Map < String , Integer > underlying = ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; Map < String , Integer > expected = Maps . transformValues ( underlying , Functions . < Integer > identity ( ) ) ; assertMapsEqual ( expected , expected ) ; Map < String , Integer > equalToUnderlying = Maps . newTreeMap ( ) ; equalToUnderlying . putAll ( underlying ) ; Map < String , Integer > map = Maps . transformValues ( equalToUnderlying , Functions . < Integer > identity ( ) ) ; assertMapsEqual ( expected , map ) ; map = Maps . transformValues ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , new Function < Integer , Integer > ( ) { @Override public Integer apply ( Integer from ) { return from - <int> ; } } ) ; assertMapsEqual ( expected , map ) ; } public void testTransformEntrySetContains ( ) { Map < String , Boolean > underlying = Maps . newHashMap ( ) ; underlying . put ( <str> , null ) ; underlying . put ( <str> , true ) ; underlying . put ( null , true ) ; Map < String , Boolean > map = Maps . transformValues ( underlying , new Function < Boolean , Boolean > ( ) { @Override public Boolean apply ( @Nullable Boolean from ) { return ( from = = null ) ? true : null ; } } ) ; Set < Map . Entry < String , Boolean > > entries = map . entrySet ( ) ; assertTrue ( entries . contains ( Maps . immutableEntry ( <str> , true ) ) ) ; assertTrue ( entries . contains ( Maps . immutableEntry ( <str> , ( Boolean ) null ) ) ) ; assertTrue ( entries . contains ( Maps . immutableEntry ( ( String ) null , ( Boolean ) null ) ) ) ; assertFalse ( entries . contains ( Maps . immutableEntry ( <str> , ( Boolean ) null ) ) ) ; assertFalse ( entries . contains ( Maps . immutableEntry ( ( String ) null , true ) ) ) ; } @Override public void testKeySetRemoveAllNullFromEmpty ( ) { try { super . testKeySetRemoveAllNullFromEmpty ( ) ; } catch ( RuntimeException tolerated ) { } } @Override public void testEntrySetRemoveAllNullFromEmpty ( ) { try { super . testEntrySetRemoveAllNullFromEmpty ( ) ; } catch ( RuntimeException tolerated ) { } } } 
