package org . apache . cassandra . db ; import java . util . Collections ; import java . util . concurrent . ExecutionException ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . dht . Bounds ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . exceptions . WriteTimeoutException ; import org . apache . cassandra . service . CacheService ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; public class CounterCacheTest { private static final String KEYSPACE1 = <str> ; private static final String COUNTER1 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; CFMetaData counterTable = CFMetaData . Builder . create ( KEYSPACE1 , COUNTER1 , false , true , true ) . addPartitionKey ( <str> , Int32Type . instance ) . addClusteringColumn ( <str> , Int32Type . instance ) . addRegularColumn ( <str> , CounterColumnType . instance ) . build ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , counterTable ) ; } @AfterClass public static void cleanup ( ) { SchemaLoader . cleanupSavedCaches ( ) ; } @Test public void testReadWrite ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; cfs . truncateBlocking ( ) ; CacheService . instance . invalidateCounterCache ( ) ; Clustering c1 = CBuilder . create ( cfs . metadata . comparator ) . add ( ByteBufferUtil . bytes ( <int> ) ) . build ( ) ; Clustering c2 = CBuilder . create ( cfs . metadata . comparator ) . add ( ByteBufferUtil . bytes ( <int> ) ) . build ( ) ; ColumnDefinition cd = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c1 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c2 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c1 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c2 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; } @Test public void testCounterCacheInvalidate ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; cfs . truncateBlocking ( ) ; CacheService . instance . invalidateCounterCache ( ) ; Clustering c1 = CBuilder . create ( cfs . metadata . comparator ) . add ( ByteBufferUtil . bytes ( <int> ) ) . build ( ) ; Clustering c2 = CBuilder . create ( cfs . metadata . comparator ) . add ( ByteBufferUtil . bytes ( <int> ) ) . build ( ) ; ColumnDefinition cd = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c1 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c2 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c1 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c2 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c1 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; cfs . putCachedCounter ( bytes ( <int> ) , c2 , cd , null , ClockAndCount . create ( <int> , <int> ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; cfs . invalidateCounterCache ( Collections . singleton ( new Bounds < Token > ( cfs . decorateKey ( bytes ( <int> ) ) . getToken ( ) , cfs . decorateKey ( bytes ( <int> ) ) . getToken ( ) ) ) ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertNull ( cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; } @Test public void testSaveLoad ( ) throws ExecutionException , InterruptedException , WriteTimeoutException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; cfs . truncateBlocking ( ) ; CacheService . instance . invalidateCounterCache ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; CacheService . instance . counterCache . submitWrite ( Integer . MAX_VALUE ) . get ( ) ; CacheService . instance . invalidateCounterCache ( ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; CacheService . instance . counterCache . loadSaved ( ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; Clustering c1 = CBuilder . create ( cfs . metadata . comparator ) . add ( ByteBufferUtil . bytes ( <int> ) ) . build ( ) ; Clustering c2 = CBuilder . create ( cfs . metadata . comparator ) . add ( ByteBufferUtil . bytes ( <int> ) ) . build ( ) ; ColumnDefinition cd = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c1 , cd , null ) ) ; assertEquals ( ClockAndCount . create ( <int> , <int> ) , cfs . getCachedCounter ( bytes ( <int> ) , c2 , cd , null ) ) ; } @Test public void testDroppedSaveLoad ( ) throws ExecutionException , InterruptedException , WriteTimeoutException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; cfs . truncateBlocking ( ) ; CacheService . instance . invalidateCounterCache ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; CacheService . instance . counterCache . submitWrite ( Integer . MAX_VALUE ) . get ( ) ; CacheService . instance . invalidateCounterCache ( ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; Keyspace ks = Schema . instance . removeKeyspaceInstance ( KEYSPACE1 ) ; try { CacheService . instance . counterCache . loadSaved ( ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; } finally { Schema . instance . storeKeyspaceInstance ( ks ) ; } } @Test public void testDisabledSaveLoad ( ) throws ExecutionException , InterruptedException , WriteTimeoutException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COUNTER1 ) ; cfs . truncateBlocking ( ) ; CacheService . instance . invalidateCounterCache ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; new CounterMutation ( new RowUpdateBuilder ( cfs . metadata , <int> , bytes ( <int> ) ) . clustering ( <int> ) . add ( <str> , <int> ) . build ( ) , ConsistencyLevel . ONE ) . apply ( ) ; CacheService . instance . counterCache . submitWrite ( Integer . MAX_VALUE ) . get ( ) ; CacheService . instance . invalidateCounterCache ( ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; CacheService . instance . setCounterCacheCapacityInMB ( <int> ) ; try { CacheService . instance . counterCache . loadSaved ( ) ; assertEquals ( <int> , CacheService . instance . counterCache . size ( ) ) ; } finally { CacheService . instance . setCounterCacheCapacityInMB ( <int> ) ; } } } 
