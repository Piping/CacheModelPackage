package com . badlogic . gdx . graphics . glutils ; import java . nio . Buffer ; import java . nio . ByteBuffer ; import java . nio . IntBuffer ; import java . nio . ShortBuffer ; import com . badlogic . gdx . utils . BufferUtils ; public class IndexArray implements IndexData { final static IntBuffer tmpHandle = BufferUtils . newIntBuffer ( <int> ) ; ShortBuffer buffer ; ByteBuffer byteBuffer ; private final boolean empty ; public IndexArray ( int maxIndices ) { empty = maxIndices = = <int> ; if ( empty ) { maxIndices = <int> ; } byteBuffer = BufferUtils . newUnsafeByteBuffer ( maxIndices * <int> ) ; buffer = byteBuffer . asShortBuffer ( ) ; buffer . flip ( ) ; byteBuffer . flip ( ) ; } public int getNumIndices ( ) { return empty ? <int> : buffer . limit ( ) ; } public int getNumMaxIndices ( ) { return empty ? <int> : buffer . capacity ( ) ; } public void setIndices ( short [ ] indices , int offset , int count ) { buffer . clear ( ) ; buffer . put ( indices , offset , count ) ; buffer . flip ( ) ; byteBuffer . position ( <int> ) ; byteBuffer . limit ( count < < <int> ) ; } public void setIndices ( ShortBuffer indices ) { int pos = indices . position ( ) ; buffer . clear ( ) ; buffer . limit ( indices . remaining ( ) ) ; buffer . put ( indices ) ; buffer . flip ( ) ; indices . position ( pos ) ; byteBuffer . position ( <int> ) ; byteBuffer . limit ( buffer . limit ( ) < < <int> ) ; } public ShortBuffer getBuffer ( ) { return buffer ; } public void bind ( ) { } public void unbind ( ) { } public void invalidate ( ) { } public void dispose ( ) { BufferUtils . disposeUnsafeByteBuffer ( byteBuffer ) ; } } 
