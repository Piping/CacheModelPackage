package io . netty . test . udt . util ; import com . google . caliper . Measurement ; import com . google . caliper . MeasurementSet ; import com . google . caliper . Run ; import com . google . caliper . Scenario ; import com . google . caliper . ScenarioResult ; import com . yammer . metrics . core . Gauge ; import com . yammer . metrics . core . Meter ; import com . yammer . metrics . core . MetricsRegistry ; import com . yammer . metrics . core . Timer ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . TimeUnit ; public class CaliperMeasure { public static class SizeGuage extends Gauge < Double > { private volatile Double size = <float> ; @Override public Double value ( ) { return size ; } public void value ( final double size ) { this . size = size ; } } private static final Map < String , Integer > RATE_UNIT = new HashMap < String , Integer > ( ) ; static { RATE_UNIT . put ( <str> , <int> ) ; RATE_UNIT . put ( <str> , <int> ) ; RATE_UNIT . put ( <str> , <int> * <int> ) ; RATE_UNIT . put ( <str> , <int> * <int> * <int> ) ; } private static final Map < String , Integer > TIME_UNIT = new HashMap < String , Integer > ( ) ; static { TIME_UNIT . put ( <str> , <int> ) ; TIME_UNIT . put ( <str> , <int> ) ; TIME_UNIT . put ( <str> , <int> * <int> ) ; TIME_UNIT . put ( <str> , <int> * <int> * <int> ) ; } private static final Map < String , Integer > SIZE_UNIT = new HashMap < String , Integer > ( ) ; static { SIZE_UNIT . put ( <str> , <int> ) ; SIZE_UNIT . put ( <str> , <int> ) ; SIZE_UNIT . put ( <str> , <int> * <int> ) ; SIZE_UNIT . put ( <str> , <int> * <int> * <int> ) ; } private final Map < Long , Measurement > rateMap = new HashMap < Long , Measurement > ( ) ; private final Map < Long , Measurement > timeMap = new HashMap < Long , Measurement > ( ) ; private final Map < Long , Measurement > sizeMap = new HashMap < Long , Measurement > ( ) ; private final MetricsRegistry metrics = new MetricsRegistry ( ) ; private final Meter rate = metrics . newMeter ( getClass ( ) , <str> , <str> , TimeUnit . SECONDS ) ; private final Timer time = metrics . newTimer ( getClass ( ) , <str> , TimeUnit . NANOSECONDS , TimeUnit . SECONDS ) ; private final SizeGuage size = new SizeGuage ( ) ; { metrics . newGauge ( getClass ( ) , <str> , size ) ; } public Meter rate ( ) { return rate ; } public Timer time ( ) { return time ; } public SizeGuage size ( ) { return size ; } private static double filter ( final double value ) { if ( value < = <float> ) { return <float> ; } else { return value ; } } @SuppressWarnings ( <str> ) public void mark ( ) { final double rateValue = filter ( rate . oneMinuteRate ( ) ) ; final double timeValue = filter ( time . mean ( ) ) ; final double sizeValue = filter ( size . value ( ) ) ; if ( rateValue = = <float> & & timeValue = = <float> & & sizeValue = = <float> ) { return ; } final Measurement markRate = new Measurement ( RATE_UNIT , rateValue , rateValue ) ; rateMap . put ( System . nanoTime ( ) , markRate ) ; final Measurement markTime = new Measurement ( TIME_UNIT , timeValue , timeValue ) ; timeMap . put ( System . nanoTime ( ) , markTime ) ; final Measurement markSize = new Measurement ( SIZE_UNIT , sizeValue , sizeValue ) ; sizeMap . put ( System . nanoTime ( ) , markSize ) ; } private final Map < String , String > variables = new HashMap < String , String > ( ) ; public Map < String , String > variables ( ) { return variables ; } private static MeasurementSet measurementSet ( final Map < Long , Measurement > map ) { final Measurement [ ] array = map . values ( ) . toArray ( new Measurement [ map . size ( ) ] ) ; return new MeasurementSet ( array ) ; } public void appendTo ( final Run run ) { final Scenario scenario = new Scenario ( variables ( ) ) ; final MeasurementSet timeSet = measurementSet ( rateMap ) ; final String timeLog = null ; final MeasurementSet instSet = measurementSet ( timeMap ) ; final String instLog = null ; final MeasurementSet heapSet = measurementSet ( sizeMap ) ; final String heapLog = null ; final ScenarioResult scenarioResult = new ScenarioResult ( timeSet , timeLog , instSet , instLog , heapSet , heapLog ) ; final Map < Scenario , ScenarioResult > measurements = run . getMeasurements ( ) ; measurements . put ( scenario , scenarioResult ) ; } public void shutdown ( ) { rate . stop ( ) ; time . stop ( ) ; metrics . shutdown ( ) ; } } 
