package org . elasticsearch . cluster . routing . allocation ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import java . io . IOException ; import java . io . InputStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . HashMap ; import java . util . Map ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; public class BalanceUnbalancedClusterTests extends CatAllocationTestCase { @Override protected Path getCatPath ( ) throws IOException { Path tmp = createTempDir ( ) ; try ( InputStream stream = Files . newInputStream ( getDataPath ( <str> ) ) ) { TestUtil . unzip ( stream , tmp ) ; } return tmp . resolve ( <str> ) ; } @Override protected ClusterState allocateNew ( ClusterState state ) { String index = <str> ; AllocationService strategy = createAllocationService ( settingsBuilder ( ) . build ( ) ) ; MetaData metaData = MetaData . builder ( state . metaData ( ) ) . put ( IndexMetaData . builder ( index ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( state . routingTable ( ) ) . addAsNew ( metaData . index ( index ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( state ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; while ( true ) { if ( routingTable . shardsWithState ( INITIALIZING ) . isEmpty ( ) ) { break ; } routingTable = strategy . applyStartedShards ( clusterState , routingTable . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; } Map < String , Integer > counts = new HashMap < > ( ) ; for ( IndexShardRoutingTable table : routingTable . index ( index ) ) { for ( ShardRouting r : table ) { String s = r . currentNodeId ( ) ; Integer count = counts . get ( s ) ; if ( count = = null ) { count = <int> ; } count + + ; counts . put ( s , count ) ; } } for ( Map . Entry < String , Integer > count : counts . entrySet ( ) ) { assertTrue ( <str> + count . getKey ( ) + <str> + count . getValue ( ) , count . getValue ( ) > = <int> ) ; assertTrue ( <str> + count . getKey ( ) + <str> + count . getValue ( ) , count . getValue ( ) < = <int> ) ; } return clusterState ; } } 
