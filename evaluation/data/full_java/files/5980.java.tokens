package org . elasticsearch . common . lucene . all ; import org . apache . lucene . analysis . payloads . PayloadHelper ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . PostingsEnum ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . TermContext ; import org . apache . lucene . index . TermState ; import org . apache . lucene . index . Terms ; import org . apache . lucene . index . TermsEnum ; import org . apache . lucene . search . CollectionStatistics ; import org . apache . lucene . search . Explanation ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . MatchNoDocsQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Scorer ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . TermStatistics ; import org . apache . lucene . search . Weight ; import org . apache . lucene . search . similarities . Similarity ; import org . apache . lucene . search . similarities . Similarity . SimScorer ; import org . apache . lucene . search . similarities . Similarity . SimWeight ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . ToStringUtils ; import java . io . IOException ; import java . util . Set ; public final class AllTermQuery extends Query { private final Term term ; public AllTermQuery ( Term term ) { this . term = term ; } @Override public Query rewrite ( IndexReader reader ) throws IOException { Query rewritten = super . rewrite ( reader ) ; if ( rewritten ! = this ) { return rewritten ; } boolean fieldExists = false ; boolean hasPayloads = false ; for ( LeafReaderContext context : reader . leaves ( ) ) { final Terms terms = context . reader ( ) . terms ( term . field ( ) ) ; if ( terms ! = null ) { fieldExists = true ; if ( terms . hasPayloads ( ) ) { hasPayloads = true ; break ; } } } if ( fieldExists = = false ) { return new MatchNoDocsQuery ( ) ; } if ( hasPayloads = = false ) { return new TermQuery ( term ) ; } return this ; } @Override public Weight createWeight ( IndexSearcher searcher , boolean needsScores ) throws IOException { if ( needsScores = = false ) { return new TermQuery ( term ) . createWeight ( searcher , needsScores ) ; } final TermContext termStates = TermContext . build ( searcher . getTopReaderContext ( ) , term ) ; final CollectionStatistics collectionStats = searcher . collectionStatistics ( term . field ( ) ) ; final TermStatistics termStats = searcher . termStatistics ( term , termStates ) ; final Similarity similarity = searcher . getSimilarity ( needsScores ) ; final SimWeight stats = similarity . computeWeight ( collectionStats , termStats ) ; return new Weight ( this ) { @Override public final float getValueForNormalization ( ) throws IOException { return stats . getValueForNormalization ( ) ; } @Override public final void normalize ( float norm , float topLevelBoost ) { stats . normalize ( norm , topLevelBoost ) ; } @Override public void extractTerms ( Set < Term > terms ) { terms . add ( term ) ; } @Override public Explanation explain ( LeafReaderContext context , int doc ) throws IOException { AllTermScorer scorer = scorer ( context ) ; if ( scorer ! = null ) { int newDoc = scorer . advance ( doc ) ; if ( newDoc = = doc ) { float score = scorer . score ( ) ; float freq = scorer . freq ( ) ; SimScorer docScorer = similarity . simScorer ( stats , context ) ; Explanation freqExplanation = Explanation . match ( freq , <str> + freq ) ; Explanation termScoreExplanation = docScorer . explain ( doc , freqExplanation ) ; Explanation payloadBoostExplanation = Explanation . match ( scorer . payloadBoost ( ) , <str> + scorer . payloadBoost ( ) ) ; return Explanation . match ( score , <str> + getQuery ( ) + <str> + doc + <str> + similarity . getClass ( ) . getSimpleName ( ) + <str> , termScoreExplanation , payloadBoostExplanation ) ; } } return Explanation . noMatch ( <str> ) ; } @Override public AllTermScorer scorer ( LeafReaderContext context ) throws IOException { final Terms terms = context . reader ( ) . terms ( term . field ( ) ) ; if ( terms = = null ) { return null ; } final TermsEnum termsEnum = terms . iterator ( ) ; if ( termsEnum = = null ) { return null ; } final TermState state = termStates . get ( context . ord ) ; termsEnum . seekExact ( term . bytes ( ) , state ) ; PostingsEnum docs = termsEnum . postings ( null , PostingsEnum . PAYLOADS ) ; assert docs ! = null ; return new AllTermScorer ( this , docs , similarity . simScorer ( stats , context ) ) ; } } ; } private static class AllTermScorer extends Scorer { final PostingsEnum postings ; final Similarity . SimScorer docScorer ; int doc = - <int> ; float payloadBoost ; AllTermScorer ( Weight weight , PostingsEnum postings , Similarity . SimScorer docScorer ) { super ( weight ) ; this . postings = postings ; this . docScorer = docScorer ; } float payloadBoost ( ) throws IOException { if ( doc ! = docID ( ) ) { final int freq = postings . freq ( ) ; payloadBoost = <int> ; for ( int i = <int> ; i < freq ; + + i ) { postings . nextPosition ( ) ; final BytesRef payload = postings . getPayload ( ) ; float boost ; if ( payload = = null ) { boost = <int> ; } else { assert payload . length = = <int> ; boost = PayloadHelper . decodeFloat ( payload . bytes , payload . offset ) ; } payloadBoost + = boost ; } payloadBoost / = freq ; doc = docID ( ) ; } return payloadBoost ; } @Override public float score ( ) throws IOException { return payloadBoost ( ) * docScorer . score ( postings . docID ( ) , postings . freq ( ) ) ; } @Override public int freq ( ) throws IOException { return postings . freq ( ) ; } @Override public int docID ( ) { return postings . docID ( ) ; } @Override public int nextDoc ( ) throws IOException { return postings . nextDoc ( ) ; } @Override public int advance ( int target ) throws IOException { return postings . advance ( target ) ; } @Override public long cost ( ) { return postings . cost ( ) ; } } @Override public String toString ( String field ) { return new TermQuery ( term ) . toString ( field ) + ToStringUtils . boost ( getBoost ( ) ) ; } } 
