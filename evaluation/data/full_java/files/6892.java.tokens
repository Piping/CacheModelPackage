package org . elasticsearch . monitor . jvm ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import java . io . IOException ; import java . lang . management . * ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class JvmInfo implements Streamable , ToXContent { private static JvmInfo INSTANCE ; static { RuntimeMXBean runtimeMXBean = ManagementFactory . getRuntimeMXBean ( ) ; MemoryMXBean memoryMXBean = ManagementFactory . getMemoryMXBean ( ) ; long pid ; String xPid = runtimeMXBean . getName ( ) ; try { xPid = xPid . split ( <str> ) [ <int> ] ; pid = Long . parseLong ( xPid ) ; } catch ( Exception e ) { pid = - <int> ; } JvmInfo info = new JvmInfo ( ) ; info . pid = pid ; info . startTime = runtimeMXBean . getStartTime ( ) ; info . version = System . getProperty ( <str> ) ; info . vmName = runtimeMXBean . getVmName ( ) ; info . vmVendor = runtimeMXBean . getVmVendor ( ) ; info . vmVersion = runtimeMXBean . getVmVersion ( ) ; info . mem = new Mem ( ) ; info . mem . heapInit = memoryMXBean . getHeapMemoryUsage ( ) . getInit ( ) < <int> ? <int> : memoryMXBean . getHeapMemoryUsage ( ) . getInit ( ) ; info . mem . heapMax = memoryMXBean . getHeapMemoryUsage ( ) . getMax ( ) < <int> ? <int> : memoryMXBean . getHeapMemoryUsage ( ) . getMax ( ) ; info . mem . nonHeapInit = memoryMXBean . getNonHeapMemoryUsage ( ) . getInit ( ) < <int> ? <int> : memoryMXBean . getNonHeapMemoryUsage ( ) . getInit ( ) ; info . mem . nonHeapMax = memoryMXBean . getNonHeapMemoryUsage ( ) . getMax ( ) < <int> ? <int> : memoryMXBean . getNonHeapMemoryUsage ( ) . getMax ( ) ; try { Class < ? > vmClass = Class . forName ( <str> ) ; info . mem . directMemoryMax = ( Long ) vmClass . getMethod ( <str> ) . invoke ( null ) ; } catch ( Throwable t ) { } info . inputArguments = runtimeMXBean . getInputArguments ( ) . toArray ( new String [ runtimeMXBean . getInputArguments ( ) . size ( ) ] ) ; try { info . bootClassPath = runtimeMXBean . getBootClassPath ( ) ; } catch ( UnsupportedOperationException e ) { info . bootClassPath = System . getProperty ( <str> ) ; if ( info . bootClassPath = = null ) { info . bootClassPath = <str> ; } } info . classPath = runtimeMXBean . getClassPath ( ) ; info . systemProperties = Collections . unmodifiableMap ( runtimeMXBean . getSystemProperties ( ) ) ; List < GarbageCollectorMXBean > gcMxBeans = ManagementFactory . getGarbageCollectorMXBeans ( ) ; info . gcCollectors = new String [ gcMxBeans . size ( ) ] ; for ( int i = <int> ; i < gcMxBeans . size ( ) ; i + + ) { GarbageCollectorMXBean gcMxBean = gcMxBeans . get ( i ) ; info . gcCollectors [ i ] = gcMxBean . getName ( ) ; } List < MemoryPoolMXBean > memoryPoolMXBeans = ManagementFactory . getMemoryPoolMXBeans ( ) ; info . memoryPools = new String [ memoryPoolMXBeans . size ( ) ] ; for ( int i = <int> ; i < memoryPoolMXBeans . size ( ) ; i + + ) { MemoryPoolMXBean memoryPoolMXBean = memoryPoolMXBeans . get ( i ) ; info . memoryPools [ i ] = memoryPoolMXBean . getName ( ) ; } INSTANCE = info ; } public static JvmInfo jvmInfo ( ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm ! = null ) { sm . checkPermission ( new ManagementPermission ( <str> ) ) ; sm . checkPropertyAccess ( <str> ) ; } return INSTANCE ; } long pid = - <int> ; String version = <str> ; String vmName = <str> ; String vmVersion = <str> ; String vmVendor = <str> ; long startTime = - <int> ; Mem mem ; String [ ] inputArguments ; String bootClassPath ; String classPath ; Map < String , String > systemProperties ; String [ ] gcCollectors = Strings . EMPTY_ARRAY ; String [ ] memoryPools = Strings . EMPTY_ARRAY ; private JvmInfo ( ) { } public long pid ( ) { return this . pid ; } public long getPid ( ) { return pid ; } public String version ( ) { return this . version ; } public String getVersion ( ) { return this . version ; } public int versionAsInteger ( ) { try { int i = <int> ; String sVersion = <str> ; for ( ; i < version . length ( ) ; i + + ) { if ( ! Character . isDigit ( version . charAt ( i ) ) & & version . charAt ( i ) ! = <str> ) { break ; } if ( version . charAt ( i ) ! = <str> ) { sVersion + = version . charAt ( i ) ; } } if ( i = = <int> ) { return - <int> ; } return Integer . parseInt ( sVersion ) ; } catch ( Exception e ) { return - <int> ; } } public int versionUpdatePack ( ) { try { int i = <int> ; String sVersion = <str> ; for ( ; i < version . length ( ) ; i + + ) { if ( ! Character . isDigit ( version . charAt ( i ) ) & & version . charAt ( i ) ! = <str> ) { break ; } if ( version . charAt ( i ) ! = <str> ) { sVersion + = version . charAt ( i ) ; } } if ( i = = <int> ) { return - <int> ; } Integer . parseInt ( sVersion ) ; int from ; if ( version . charAt ( i ) = = <str> ) { from = + + i ; } else if ( version . charAt ( i ) = = <str> & & version . charAt ( i + <int> ) = = <str> ) { i = i + <int> ; from = i ; } else { return - <int> ; } for ( ; i < version . length ( ) ; i + + ) { if ( ! Character . isDigit ( version . charAt ( i ) ) & & version . charAt ( i ) ! = <str> ) { break ; } } if ( from = = i ) { return - <int> ; } return Integer . parseInt ( version . substring ( from , i ) ) ; } catch ( Exception e ) { return - <int> ; } } public String getVmName ( ) { return this . vmName ; } public String getVmVersion ( ) { return this . vmVersion ; } public String getVmVendor ( ) { return this . vmVendor ; } public long getStartTime ( ) { return this . startTime ; } public Mem getMem ( ) { return this . mem ; } public String [ ] getInputArguments ( ) { return this . inputArguments ; } public String getBootClassPath ( ) { return this . bootClassPath ; } public String getClassPath ( ) { return this . classPath ; } public Map < String , String > getSystemProperties ( ) { return this . systemProperties ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( Fields . JVM ) ; builder . field ( Fields . PID , pid ) ; builder . field ( Fields . VERSION , version ) ; builder . field ( Fields . VM_NAME , vmName ) ; builder . field ( Fields . VM_VERSION , vmVersion ) ; builder . field ( Fields . VM_VENDOR , vmVendor ) ; builder . dateValueField ( Fields . START_TIME_IN_MILLIS , Fields . START_TIME , startTime ) ; builder . startObject ( Fields . MEM ) ; builder . byteSizeField ( Fields . HEAP_INIT_IN_BYTES , Fields . HEAP_INIT , mem . heapInit ) ; builder . byteSizeField ( Fields . HEAP_MAX_IN_BYTES , Fields . HEAP_MAX , mem . heapMax ) ; builder . byteSizeField ( Fields . NON_HEAP_INIT_IN_BYTES , Fields . NON_HEAP_INIT , mem . nonHeapInit ) ; builder . byteSizeField ( Fields . NON_HEAP_MAX_IN_BYTES , Fields . NON_HEAP_MAX , mem . nonHeapMax ) ; builder . byteSizeField ( Fields . DIRECT_MAX_IN_BYTES , Fields . DIRECT_MAX , mem . directMemoryMax ) ; builder . endObject ( ) ; builder . field ( Fields . GC_COLLECTORS , gcCollectors ) ; builder . field ( Fields . MEMORY_POOLS , memoryPools ) ; builder . endObject ( ) ; return builder ; } static final class Fields { static final XContentBuilderString JVM = new XContentBuilderString ( <str> ) ; static final XContentBuilderString PID = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VERSION = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VM_NAME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VM_VERSION = new XContentBuilderString ( <str> ) ; static final XContentBuilderString VM_VENDOR = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME = new XContentBuilderString ( <str> ) ; static final XContentBuilderString START_TIME_IN_MILLIS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MEM = new XContentBuilderString ( <str> ) ; static final XContentBuilderString HEAP_INIT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString HEAP_INIT_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString HEAP_MAX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString HEAP_MAX_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NON_HEAP_INIT = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NON_HEAP_INIT_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NON_HEAP_MAX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString NON_HEAP_MAX_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString DIRECT_MAX = new XContentBuilderString ( <str> ) ; static final XContentBuilderString DIRECT_MAX_IN_BYTES = new XContentBuilderString ( <str> ) ; static final XContentBuilderString GC_COLLECTORS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString MEMORY_POOLS = new XContentBuilderString ( <str> ) ; } public static JvmInfo readJvmInfo ( StreamInput in ) throws IOException { JvmInfo jvmInfo = new JvmInfo ( ) ; jvmInfo . readFrom ( in ) ; return jvmInfo ; } @Override public void readFrom ( StreamInput in ) throws IOException { pid = in . readLong ( ) ; version = in . readString ( ) ; vmName = in . readString ( ) ; vmVersion = in . readString ( ) ; vmVendor = in . readString ( ) ; startTime = in . readLong ( ) ; inputArguments = new String [ in . readInt ( ) ] ; for ( int i = <int> ; i < inputArguments . length ; i + + ) { inputArguments [ i ] = in . readString ( ) ; } bootClassPath = in . readString ( ) ; classPath = in . readString ( ) ; systemProperties = new HashMap < > ( ) ; int size = in . readInt ( ) ; for ( int i = <int> ; i < size ; i + + ) { systemProperties . put ( in . readString ( ) , in . readString ( ) ) ; } mem = new Mem ( ) ; mem . readFrom ( in ) ; gcCollectors = in . readStringArray ( ) ; memoryPools = in . readStringArray ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeLong ( pid ) ; out . writeString ( version ) ; out . writeString ( vmName ) ; out . writeString ( vmVersion ) ; out . writeString ( vmVendor ) ; out . writeLong ( startTime ) ; out . writeInt ( inputArguments . length ) ; for ( String inputArgument : inputArguments ) { out . writeString ( inputArgument ) ; } out . writeString ( bootClassPath ) ; out . writeString ( classPath ) ; out . writeInt ( systemProperties . size ( ) ) ; for ( Map . Entry < String , String > entry : systemProperties . entrySet ( ) ) { out . writeString ( entry . getKey ( ) ) ; out . writeString ( entry . getValue ( ) ) ; } mem . writeTo ( out ) ; out . writeStringArray ( gcCollectors ) ; out . writeStringArray ( memoryPools ) ; } public static class Mem implements Streamable { long heapInit = <int> ; long heapMax = <int> ; long nonHeapInit = <int> ; long nonHeapMax = <int> ; long directMemoryMax = <int> ; Mem ( ) { } public ByteSizeValue getHeapInit ( ) { return new ByteSizeValue ( heapInit ) ; } public ByteSizeValue getHeapMax ( ) { return new ByteSizeValue ( heapMax ) ; } public ByteSizeValue getNonHeapInit ( ) { return new ByteSizeValue ( nonHeapInit ) ; } public ByteSizeValue getNonHeapMax ( ) { return new ByteSizeValue ( nonHeapMax ) ; } public ByteSizeValue getDirectMemoryMax ( ) { return new ByteSizeValue ( directMemoryMax ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { heapInit = in . readVLong ( ) ; heapMax = in . readVLong ( ) ; nonHeapInit = in . readVLong ( ) ; nonHeapMax = in . readVLong ( ) ; directMemoryMax = in . readVLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVLong ( heapInit ) ; out . writeVLong ( heapMax ) ; out . writeVLong ( nonHeapInit ) ; out . writeVLong ( nonHeapMax ) ; out . writeVLong ( directMemoryMax ) ; } } } 
