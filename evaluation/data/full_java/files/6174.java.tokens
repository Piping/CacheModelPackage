package org . elasticsearch . discovery . local ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodeService ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingService ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . internal . Nullable ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . discovery . * ; import org . elasticsearch . node . service . NodeService ; import org . elasticsearch . transport . TransportService ; import java . util . HashSet ; import java . util . Queue ; import java . util . Set ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . elasticsearch . cluster . ClusterState . Builder ; public class LocalDiscovery extends AbstractLifecycleComponent < Discovery > implements Discovery { private static final LocalDiscovery [ ] NO_MEMBERS = new LocalDiscovery [ <int> ] ; private final TransportService transportService ; private final ClusterService clusterService ; private final DiscoveryNodeService discoveryNodeService ; private RoutingService routingService ; private final ClusterName clusterName ; private final Version version ; private final DiscoverySettings discoverySettings ; private DiscoveryNode localNode ; private volatile boolean master = false ; private final AtomicBoolean initialStateSent = new AtomicBoolean ( ) ; private final CopyOnWriteArrayList < InitialStateDiscoveryListener > initialStateListeners = new CopyOnWriteArrayList < > ( ) ; private static final ConcurrentMap < ClusterName , ClusterGroup > clusterGroups = ConcurrentCollections . newConcurrentMap ( ) ; private volatile ClusterState lastProcessedClusterState ; @Inject public LocalDiscovery ( Settings settings , ClusterName clusterName , TransportService transportService , ClusterService clusterService , DiscoveryNodeService discoveryNodeService , Version version , DiscoverySettings discoverySettings ) { super ( settings ) ; this . clusterName = clusterName ; this . clusterService = clusterService ; this . transportService = transportService ; this . discoveryNodeService = discoveryNodeService ; this . version = version ; this . discoverySettings = discoverySettings ; } @Override public void setNodeService ( @Nullable NodeService nodeService ) { } @Override public void setRoutingService ( RoutingService routingService ) { this . routingService = routingService ; } @Override protected void doStart ( ) { synchronized ( clusterGroups ) { ClusterGroup clusterGroup = clusterGroups . get ( clusterName ) ; if ( clusterGroup = = null ) { clusterGroup = new ClusterGroup ( ) ; clusterGroups . put ( clusterName , clusterGroup ) ; } logger . debug ( <str> , clusterName ) ; this . localNode = new DiscoveryNode ( settings . get ( <str> ) , DiscoveryService . generateNodeId ( settings ) , transportService . boundAddress ( ) . publishAddress ( ) , discoveryNodeService . buildAttributes ( ) , version ) ; clusterGroup . members ( ) . add ( this ) ; LocalDiscovery firstMaster = null ; for ( LocalDiscovery localDiscovery : clusterGroup . members ( ) ) { if ( localDiscovery . localNode ( ) . masterNode ( ) ) { firstMaster = localDiscovery ; break ; } } if ( firstMaster ! = null & & firstMaster . equals ( this ) ) { master = true ; final LocalDiscovery master = firstMaster ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) { DiscoveryNodes . Builder nodesBuilder = DiscoveryNodes . builder ( ) ; for ( LocalDiscovery discovery : clusterGroups . get ( clusterName ) . members ( ) ) { nodesBuilder . put ( discovery . localNode ) ; } nodesBuilder . localNodeId ( master . localNode ( ) . id ( ) ) . masterNodeId ( master . localNode ( ) . id ( ) ) ; ClusterBlocks . Builder blocks = ClusterBlocks . builder ( ) . blocks ( currentState . blocks ( ) ) . removeGlobalBlock ( discoverySettings . getNoMasterBlock ( ) ) ; return ClusterState . builder ( currentState ) . nodes ( nodesBuilder ) . blocks ( blocks ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { sendInitialStateEventIfNeeded ( ) ; } } ) ; } else if ( firstMaster ! = null ) { final ClusterState masterState = firstMaster . clusterService . state ( ) ; clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) { DiscoveryNodes . Builder nodesBuilder = DiscoveryNodes . builder ( currentState . nodes ( ) ) . put ( localNode ) . localNodeId ( localNode . id ( ) ) ; return ClusterState . builder ( currentState ) . metaData ( masterState . metaData ( ) ) . nodes ( nodesBuilder ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } } ) ; final LocalDiscovery master = firstMaster ; firstMaster . clusterService . submitStateUpdateTask ( <str> + localNode + <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) { DiscoveryNodes . Builder nodesBuilder = DiscoveryNodes . builder ( ) ; for ( LocalDiscovery discovery : clusterGroups . get ( clusterName ) . members ( ) ) { nodesBuilder . put ( discovery . localNode ) ; } nodesBuilder . localNodeId ( master . localNode ( ) . id ( ) ) . masterNodeId ( master . localNode ( ) . id ( ) ) ; return ClusterState . builder ( currentState ) . nodes ( nodesBuilder ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { sendInitialStateEventIfNeeded ( ) ; master . routingService . reroute ( <str> ) ; } } ) ; } } } @Override protected void doStop ( ) { synchronized ( clusterGroups ) { ClusterGroup clusterGroup = clusterGroups . get ( clusterName ) ; if ( clusterGroup = = null ) { logger . warn ( <str> ) ; return ; } clusterGroup . members ( ) . remove ( this ) ; if ( clusterGroup . members ( ) . isEmpty ( ) ) { clusterGroups . remove ( clusterName ) ; return ; } LocalDiscovery firstMaster = null ; for ( LocalDiscovery localDiscovery : clusterGroup . members ( ) ) { if ( localDiscovery . localNode ( ) . masterNode ( ) ) { firstMaster = localDiscovery ; break ; } } if ( firstMaster ! = null ) { if ( master ) { firstMaster . master = true ; } final Set < String > newMembers = new HashSet < > ( ) ; for ( LocalDiscovery discovery : clusterGroup . members ( ) ) { newMembers . add ( discovery . localNode . id ( ) ) ; } final LocalDiscovery master = firstMaster ; master . clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) { DiscoveryNodes newNodes = currentState . nodes ( ) . removeDeadMembers ( newMembers , master . localNode . id ( ) ) ; DiscoveryNodes . Delta delta = newNodes . delta ( currentState . nodes ( ) ) ; if ( delta . added ( ) ) { logger . warn ( <str> ) ; } ClusterState updatedState = ClusterState . builder ( currentState ) . nodes ( newNodes ) . build ( ) ; RoutingAllocation . Result routingResult = master . routingService . getAllocationService ( ) . reroute ( ClusterState . builder ( updatedState ) . build ( ) , <str> ) ; return ClusterState . builder ( updatedState ) . routingResult ( routingResult ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; } } ) ; } } } @Override protected void doClose ( ) { } @Override public DiscoveryNode localNode ( ) { return localNode ; } @Override public void addListener ( InitialStateDiscoveryListener listener ) { this . initialStateListeners . add ( listener ) ; } @Override public void removeListener ( InitialStateDiscoveryListener listener ) { this . initialStateListeners . remove ( listener ) ; } @Override public String nodeDescription ( ) { return clusterName . value ( ) + <str> + localNode . id ( ) ; } @Override public void publish ( ClusterChangedEvent clusterChangedEvent , final Discovery . AckListener ackListener ) { if ( ! master ) { throw new IllegalStateException ( <str> ) ; } LocalDiscovery [ ] members = members ( ) ; if ( members . length > <int> ) { Set < DiscoveryNode > nodesToPublishTo = new HashSet < > ( members . length ) ; for ( LocalDiscovery localDiscovery : members ) { if ( localDiscovery . master ) { continue ; } nodesToPublishTo . add ( localDiscovery . localNode ) ; } publish ( members , clusterChangedEvent , new AckClusterStatePublishResponseHandler ( nodesToPublishTo , ackListener ) ) ; } } @Override public DiscoveryStats stats ( ) { return new DiscoveryStats ( null ) ; } private LocalDiscovery [ ] members ( ) { ClusterGroup clusterGroup = clusterGroups . get ( clusterName ) ; if ( clusterGroup = = null ) { return NO_MEMBERS ; } Queue < LocalDiscovery > members = clusterGroup . members ( ) ; return members . toArray ( new LocalDiscovery [ members . size ( ) ] ) ; } private void publish ( LocalDiscovery [ ] members , ClusterChangedEvent clusterChangedEvent , final BlockingClusterStatePublishResponseHandler publishResponseHandler ) { try { byte [ ] clusterStateBytes = null ; byte [ ] clusterStateDiffBytes = null ; ClusterState clusterState = clusterChangedEvent . state ( ) ; for ( final LocalDiscovery discovery : members ) { if ( discovery . master ) { continue ; } ClusterState newNodeSpecificClusterState = null ; synchronized ( this ) { if ( discovery . lastProcessedClusterState ! = null & & clusterChangedEvent . previousState ( ) . nodes ( ) . nodeExists ( discovery . localNode . id ( ) ) ) { if ( clusterStateDiffBytes = = null ) { Diff diff = clusterState . diff ( clusterChangedEvent . previousState ( ) ) ; BytesStreamOutput os = new BytesStreamOutput ( ) ; diff . writeTo ( os ) ; clusterStateDiffBytes = os . bytes ( ) . toBytes ( ) ; } try { newNodeSpecificClusterState = discovery . lastProcessedClusterState . readDiffFrom ( StreamInput . wrap ( clusterStateDiffBytes ) ) . apply ( discovery . lastProcessedClusterState ) ; logger . trace ( <str> , clusterState . version ( ) , clusterStateDiffBytes . length , discovery . localNode . getName ( ) ) ; } catch ( IncompatibleClusterStateVersionException ex ) { logger . warn ( <str> , ex , clusterState . version ( ) ) ; } } if ( newNodeSpecificClusterState = = null ) { if ( clusterStateBytes = = null ) { clusterStateBytes = Builder . toBytes ( clusterState ) ; } newNodeSpecificClusterState = ClusterState . Builder . fromBytes ( clusterStateBytes , discovery . localNode ) ; } discovery . lastProcessedClusterState = newNodeSpecificClusterState ; } final ClusterState nodeSpecificClusterState = newNodeSpecificClusterState ; nodeSpecificClusterState . status ( ClusterState . ClusterStateStatus . RECEIVED ) ; if ( nodeSpecificClusterState . nodes ( ) . localNode ( ) ! = null ) { assert nodeSpecificClusterState . nodes ( ) . masterNode ( ) ! = null : <str> ; assert ! nodeSpecificClusterState . blocks ( ) . hasGlobalBlock ( discoverySettings . getNoMasterBlock ( ) ) : <str> ; discovery . clusterService . submitStateUpdateTask ( <str> , new ClusterStateUpdateTask ( ) { @Override public boolean runOnlyOnMaster ( ) { return false ; } @Override public ClusterState execute ( ClusterState currentState ) { if ( currentState . supersedes ( nodeSpecificClusterState ) ) { return currentState ; } if ( currentState . blocks ( ) . hasGlobalBlock ( discoverySettings . getNoMasterBlock ( ) ) ) { logger . debug ( <str> , nodeSpecificClusterState . nodes ( ) . masterNodeId ( ) ) ; return nodeSpecificClusterState ; } ClusterState . Builder builder = ClusterState . builder ( nodeSpecificClusterState ) ; if ( nodeSpecificClusterState . routingTable ( ) . version ( ) = = currentState . routingTable ( ) . version ( ) ) { builder . routingTable ( currentState . routingTable ( ) ) ; } if ( nodeSpecificClusterState . metaData ( ) . version ( ) = = currentState . metaData ( ) . version ( ) ) { builder . metaData ( currentState . metaData ( ) ) ; } return builder . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . error ( <str> , t , source ) ; publishResponseHandler . onFailure ( discovery . localNode , t ) ; } @Override public void clusterStateProcessed ( String source , ClusterState oldState , ClusterState newState ) { sendInitialStateEventIfNeeded ( ) ; publishResponseHandler . onResponse ( discovery . localNode ) ; } } ) ; } else { publishResponseHandler . onResponse ( discovery . localNode ) ; } } TimeValue publishTimeout = discoverySettings . getPublishTimeout ( ) ; if ( publishTimeout . millis ( ) > <int> ) { try { boolean awaited = publishResponseHandler . awaitAllNodes ( publishTimeout ) ; if ( ! awaited ) { DiscoveryNode [ ] pendingNodes = publishResponseHandler . pendingNodes ( ) ; if ( pendingNodes . length > <int> ) { logger . warn ( <str> , clusterState . version ( ) , publishTimeout , pendingNodes ) ; } } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } } catch ( Exception e ) { throw new IllegalStateException ( <str> , e ) ; } } private void sendInitialStateEventIfNeeded ( ) { if ( initialStateSent . compareAndSet ( false , true ) ) { for ( InitialStateDiscoveryListener listener : initialStateListeners ) { listener . initialStateProcessed ( ) ; } } } private class ClusterGroup { private Queue < LocalDiscovery > members = ConcurrentCollections . newQueue ( ) ; Queue < LocalDiscovery > members ( ) { return members ; } } } 
