package org . nd4j . linalg . api . rng . distribution ; import java . util . Iterator ; import org . apache . commons . math3 . analysis . UnivariateFunction ; import org . apache . commons . math3 . analysis . solvers . UnivariateSolverUtils ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . exception . NumberIsTooLargeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . util . LocalizedFormats ; import org . apache . commons . math3 . util . FastMath ; import org . nd4j . linalg . api . iter . NdIndexIterator ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . rng . Random ; import org . nd4j . linalg . factory . Nd4j ; public abstract class BaseDistribution implements Distribution { protected Random random ; protected double solverAbsoluteAccuracy ; public BaseDistribution ( Random rng ) { this . random = rng ; } public BaseDistribution ( ) { this ( Nd4j . getRandom ( ) ) ; } public double probability ( double x0 , double x1 ) { if ( x0 > x1 ) { throw new NumberIsTooLargeException ( LocalizedFormats . LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; } return cumulativeProbability ( x1 ) - cumulativeProbability ( x0 ) ; } @Override public double inverseCumulativeProbability ( final double p ) throws OutOfRangeException { if ( p < <float> | | p > <float> ) { throw new OutOfRangeException ( p , <int> , <int> ) ; } double lowerBound = getSupportLowerBound ( ) ; if ( p = = <float> ) { return lowerBound ; } double upperBound = getSupportUpperBound ( ) ; if ( p = = <float> ) { return upperBound ; } final double mu = getNumericalMean ( ) ; final double sig = FastMath . sqrt ( getNumericalVariance ( ) ) ; final boolean chebyshevApplies ; chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sig ) | | Double . isNaN ( sig ) ) ; if ( lowerBound = = Double . NEGATIVE_INFINITY ) { if ( chebyshevApplies ) { lowerBound = mu - sig * FastMath . sqrt ( ( <float> - p ) / p ) ; } else { lowerBound = - <float> ; while ( cumulativeProbability ( lowerBound ) > = p ) { lowerBound * = <float> ; } } } if ( upperBound = = Double . POSITIVE_INFINITY ) { if ( chebyshevApplies ) { upperBound = mu + sig * FastMath . sqrt ( p / ( <float> - p ) ) ; } else { upperBound = <float> ; while ( cumulativeProbability ( upperBound ) < p ) { upperBound * = <float> ; } } } final UnivariateFunction toSolve = new UnivariateFunction ( ) { public double value ( final double x ) { return cumulativeProbability ( x ) - p ; } } ; double x = UnivariateSolverUtils . solve ( toSolve , lowerBound , upperBound , getSolverAbsoluteAccuracy ( ) ) ; if ( ! isSupportConnected ( ) ) { final double dx = getSolverAbsoluteAccuracy ( ) ; if ( x - dx > = getSupportLowerBound ( ) ) { double px = cumulativeProbability ( x ) ; if ( cumulativeProbability ( x - dx ) = = px ) { upperBound = x ; while ( upperBound - lowerBound > dx ) { final double midPoint = <float> * ( lowerBound + upperBound ) ; if ( cumulativeProbability ( midPoint ) < px ) { lowerBound = midPoint ; } else { upperBound = midPoint ; } } return upperBound ; } } } return x ; } protected double getSolverAbsoluteAccuracy ( ) { return solverAbsoluteAccuracy ; } @Override public void reseedRandomGenerator ( long seed ) { random . setSeed ( seed ) ; } @Override public double sample ( ) { return inverseCumulativeProbability ( random . nextDouble ( ) ) ; } @Override public double [ ] sample ( int sampleSize ) { if ( sampleSize < = <int> ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } double [ ] out = new double [ sampleSize ] ; for ( int i = <int> ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ; } @Override public double probability ( double x ) { return <float> ; } @Override public INDArray sample ( int [ ] shape ) { INDArray ret = Nd4j . create ( shape ) ; Iterator < int [ ] > idxIter = new NdIndexIterator ( shape ) ; int len = ret . length ( ) ; for ( int i = <int> ; i < len ; i + + ) { ret . putScalar ( idxIter . next ( ) , sample ( ) ) ; } return ret ; } } 
