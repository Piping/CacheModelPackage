package com . badlogic . gdx . tools . imagepacker ; import java . awt . Color ; import java . awt . Graphics2D ; import java . awt . Rectangle ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import java . util . Arrays ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Map ; import java . util . Random ; import javax . imageio . ImageIO ; public class ImagePacker { static final class Node { public Node leftChild ; public Node rightChild ; public Rectangle rect ; public String leaveName ; public Node ( int x , int y , int width , int height , Node leftChild , Node rightChild , String leaveName ) { this . rect = new Rectangle ( x , y , width , height ) ; this . leftChild = leftChild ; this . rightChild = rightChild ; this . leaveName = leaveName ; } public Node ( ) { rect = new Rectangle ( ) ; } } BufferedImage image ; int padding ; boolean duplicateBorder ; Node root ; Map < String , Rectangle > rects ; public ImagePacker ( int width , int height , int padding , boolean duplicateBorder ) { this . image = new BufferedImage ( width , height , BufferedImage . TYPE_4BYTE_ABGR ) ; this . padding = padding ; this . duplicateBorder = duplicateBorder ; this . root = new Node ( <int> , <int> , width , height , null , null , null ) ; this . rects = new HashMap < String , Rectangle > ( ) ; } public void insertImage ( String name , BufferedImage image ) { if ( rects . containsKey ( name ) ) throw new RuntimeException ( <str> + name + <str> ) ; int borderPixels = padding + ( duplicateBorder ? <int> : <int> ) ; borderPixels < < = <int> ; Rectangle rect = new Rectangle ( <int> , <int> , image . getWidth ( ) + borderPixels , image . getHeight ( ) + borderPixels ) ; Node node = insert ( root , rect ) ; if ( node = = null ) throw new RuntimeException ( <str> ) ; node . leaveName = name ; rect = new Rectangle ( node . rect ) ; rect . width - = borderPixels ; rect . height - = borderPixels ; borderPixels > > = <int> ; rect . x + = borderPixels ; rect . y + = borderPixels ; rects . put ( name , rect ) ; Graphics2D g = this . image . createGraphics ( ) ; g . drawImage ( image , rect . x , rect . y , null ) ; if ( duplicateBorder ) { g . drawImage ( image , rect . x , rect . y - <int> , rect . x + rect . width , rect . y , <int> , <int> , image . getWidth ( ) , <int> , null ) ; g . drawImage ( image , rect . x , rect . y + rect . height , rect . x + rect . width , rect . y + rect . height + <int> , <int> , image . getHeight ( ) - <int> , image . getWidth ( ) , image . getHeight ( ) , null ) ; g . drawImage ( image , rect . x - <int> , rect . y , rect . x , rect . y + rect . height , <int> , <int> , <int> , image . getHeight ( ) , null ) ; g . drawImage ( image , rect . x + rect . width , rect . y , rect . x + rect . width + <int> , rect . y + rect . height , image . getWidth ( ) - <int> , <int> , image . getWidth ( ) , image . getHeight ( ) , null ) ; g . drawImage ( image , rect . x - <int> , rect . y - <int> , rect . x , rect . y , <int> , <int> , <int> , <int> , null ) ; g . drawImage ( image , rect . x + rect . width , rect . y - <int> , rect . x + rect . width + <int> , rect . y , image . getWidth ( ) - <int> , <int> , image . getWidth ( ) , <int> , null ) ; g . drawImage ( image , rect . x - <int> , rect . y + rect . height , rect . x , rect . y + rect . height + <int> , <int> , image . getHeight ( ) - <int> , <int> , image . getHeight ( ) , null ) ; g . drawImage ( image , rect . x + rect . width , rect . y + rect . height , rect . x + rect . width + <int> , rect . y + rect . height + <int> , image . getWidth ( ) - <int> , image . getHeight ( ) - <int> , image . getWidth ( ) , image . getHeight ( ) , null ) ; } g . dispose ( ) ; } private Node insert ( Node node , Rectangle rect ) { if ( node . leaveName = = null & & node . leftChild ! = null & & node . rightChild ! = null ) { Node newNode = null ; newNode = insert ( node . leftChild , rect ) ; if ( newNode = = null ) newNode = insert ( node . rightChild , rect ) ; return newNode ; } else { if ( node . leaveName ! = null ) return null ; if ( node . rect . width = = rect . width & & node . rect . height = = rect . height ) return node ; if ( node . rect . width < rect . width | | node . rect . height < rect . height ) return null ; node . leftChild = new Node ( ) ; node . rightChild = new Node ( ) ; int deltaWidth = node . rect . width - rect . width ; int deltaHeight = node . rect . height - rect . height ; if ( deltaWidth > deltaHeight ) { node . leftChild . rect . x = node . rect . x ; node . leftChild . rect . y = node . rect . y ; node . leftChild . rect . width = rect . width ; node . leftChild . rect . height = node . rect . height ; node . rightChild . rect . x = node . rect . x + rect . width ; node . rightChild . rect . y = node . rect . y ; node . rightChild . rect . width = node . rect . width - rect . width ; node . rightChild . rect . height = node . rect . height ; } else { node . leftChild . rect . x = node . rect . x ; node . leftChild . rect . y = node . rect . y ; node . leftChild . rect . width = node . rect . width ; node . leftChild . rect . height = rect . height ; node . rightChild . rect . x = node . rect . x ; node . rightChild . rect . y = node . rect . y + rect . height ; node . rightChild . rect . width = node . rect . width ; node . rightChild . rect . height = node . rect . height - rect . height ; } return insert ( node . leftChild , rect ) ; } } public BufferedImage getImage ( ) { return image ; } public Map < String , Rectangle > getRects ( ) { return rects ; } public static void main ( String [ ] argv ) throws IOException { Random rand = new Random ( <int> ) ; ImagePacker packer = new ImagePacker ( <int> , <int> , <int> , true ) ; BufferedImage [ ] images = new BufferedImage [ <int> ] ; for ( int i = <int> ; i < images . length ; i + + ) { Color color = new Color ( ( float ) Math . random ( ) , ( float ) Math . random ( ) , ( float ) Math . random ( ) , <int> ) ; images [ i ] = createImage ( rand . nextInt ( <int> ) + <int> , rand . nextInt ( <int> ) + <int> , color ) ; } Arrays . sort ( images , new Comparator < BufferedImage > ( ) { @Override public int compare ( BufferedImage o1 , BufferedImage o2 ) { return o2 . getWidth ( ) * o2 . getHeight ( ) - o1 . getWidth ( ) * o1 . getHeight ( ) ; } } ) ; for ( int i = <int> ; i < images . length ; i + + ) packer . insertImage ( <str> + i , images [ i ] ) ; ImageIO . write ( packer . getImage ( ) , <str> , new File ( <str> ) ) ; } private static BufferedImage createImage ( int width , int height , Color color ) { BufferedImage image = new BufferedImage ( width , height , BufferedImage . TYPE_4BYTE_ABGR ) ; Graphics2D g = image . createGraphics ( ) ; g . setColor ( color ) ; g . fillRect ( <int> , <int> , width , height ) ; g . dispose ( ) ; return image ; } } 
