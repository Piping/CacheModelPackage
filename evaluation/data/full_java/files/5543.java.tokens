package org . elasticsearch . cluster . action . index ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . admin . indices . mapping . put . PutMappingRequestBuilder ; import org . elasticsearch . action . admin . indices . mapping . put . PutMappingResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . IndicesAdminClient ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . Mapping ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . util . concurrent . TimeoutException ; public class MappingUpdatedAction extends AbstractComponent { public static final String INDICES_MAPPING_DYNAMIC_TIMEOUT = <str> ; private IndicesAdminClient client ; private volatile TimeValue dynamicMappingUpdateTimeout ; class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { TimeValue current = MappingUpdatedAction . this . dynamicMappingUpdateTimeout ; TimeValue newValue = settings . getAsTime ( INDICES_MAPPING_DYNAMIC_TIMEOUT , current ) ; if ( ! current . equals ( newValue ) ) { logger . info ( <str> + INDICES_MAPPING_DYNAMIC_TIMEOUT + <str> , current , newValue ) ; MappingUpdatedAction . this . dynamicMappingUpdateTimeout = newValue ; } } } @Inject public MappingUpdatedAction ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; this . dynamicMappingUpdateTimeout = settings . getAsTime ( INDICES_MAPPING_DYNAMIC_TIMEOUT , TimeValue . timeValueSeconds ( <int> ) ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } public void setClient ( Client client ) { this . client = client . admin ( ) . indices ( ) ; } private PutMappingRequestBuilder updateMappingRequest ( String index , String type , Mapping mappingUpdate , final TimeValue timeout ) { if ( type . equals ( MapperService . DEFAULT_MAPPING ) ) { throw new IllegalArgumentException ( <str> ) ; } return client . preparePutMapping ( index ) . setType ( type ) . setSource ( mappingUpdate . toString ( ) ) . setMasterNodeTimeout ( timeout ) . setTimeout ( timeout ) ; } public void updateMappingOnMaster ( String index , String type , Mapping mappingUpdate , final TimeValue timeout , final MappingUpdateListener listener ) { final PutMappingRequestBuilder request = updateMappingRequest ( index , type , mappingUpdate , timeout ) ; if ( listener = = null ) { request . execute ( ) ; } else { final ActionListener < PutMappingResponse > actionListener = new ActionListener < PutMappingResponse > ( ) { @Override public void onResponse ( PutMappingResponse response ) { if ( response . isAcknowledged ( ) ) { listener . onMappingUpdate ( ) ; } else { listener . onFailure ( new TimeoutException ( <str> + timeout + <str> ) ) ; } } @Override public void onFailure ( Throwable e ) { listener . onFailure ( e ) ; } } ; request . execute ( actionListener ) ; } } public void updateMappingOnMasterAsynchronously ( String index , String type , Mapping mappingUpdate ) throws Throwable { updateMappingOnMaster ( index , type , mappingUpdate , dynamicMappingUpdateTimeout , null ) ; } public void updateMappingOnMasterSynchronously ( String index , String type , Mapping mappingUpdate ) throws Throwable { updateMappingOnMasterSynchronously ( index , type , mappingUpdate , dynamicMappingUpdateTimeout ) ; } public void updateMappingOnMasterSynchronously ( String index , String type , Mapping mappingUpdate , TimeValue timeout ) throws Throwable { if ( updateMappingRequest ( index , type , mappingUpdate , timeout ) . get ( ) . isAcknowledged ( ) = = false ) { throw new TimeoutException ( <str> + timeout + <str> ) ; } } public static interface MappingUpdateListener { void onMappingUpdate ( ) ; void onFailure ( Throwable t ) ; } } 
