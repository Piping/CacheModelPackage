package org . elasticsearch . indices ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingHelper ; import org . elasticsearch . cluster . routing . UnassignedInfo ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . NodeServicesProvider ; import org . elasticsearch . index . shard . IndexEventListener ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . indices . recovery . RecoveryState ; import org . elasticsearch . test . ESSingleNodeTestCase ; import java . util . Arrays ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; public class IndicesLifecycleListenerSingleNodeTests extends ESSingleNodeTestCase { public void testCloseDeleteCallback ( ) throws Throwable { IndicesService indicesService = getInstanceFromNode ( IndicesService . class ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , <int> , SETTING_NUMBER_OF_REPLICAS , <int> ) ) ; ensureGreen ( ) ; IndexMetaData metaData = indicesService . indexService ( <str> ) . getMetaData ( ) ; ShardRouting shardRouting = indicesService . indexService ( <str> ) . getShard ( <int> ) . routingEntry ( ) ; final AtomicInteger counter = new AtomicInteger ( <int> ) ; IndexEventListener countingListener = new IndexEventListener ( ) { @Override public void afterIndexClosed ( Index index , Settings indexSettings ) { assertEquals ( counter . get ( ) , <int> ) ; counter . incrementAndGet ( ) ; } @Override public void beforeIndexClosed ( IndexService indexService ) { assertEquals ( counter . get ( ) , <int> ) ; counter . incrementAndGet ( ) ; } @Override public void afterIndexDeleted ( Index index , Settings indexSettings ) { assertEquals ( counter . get ( ) , <int> ) ; counter . incrementAndGet ( ) ; } @Override public void beforeIndexDeleted ( IndexService indexService ) { assertEquals ( counter . get ( ) , <int> ) ; counter . incrementAndGet ( ) ; } @Override public void beforeIndexShardDeleted ( ShardId shardId , Settings indexSettings ) { assertEquals ( counter . get ( ) , <int> ) ; counter . incrementAndGet ( ) ; } @Override public void afterIndexShardDeleted ( ShardId shardId , Settings indexSettings ) { assertEquals ( counter . get ( ) , <int> ) ; counter . incrementAndGet ( ) ; } } ; indicesService . deleteIndex ( <str> , <str> ) ; try { NodeServicesProvider nodeServicesProvider = getInstanceFromNode ( NodeServicesProvider . class ) ; IndexService index = indicesService . createIndex ( nodeServicesProvider , metaData , Arrays . asList ( countingListener ) ) ; ShardRouting newRouting = new ShardRouting ( shardRouting ) ; String nodeId = newRouting . currentNodeId ( ) ; ShardRoutingHelper . moveToUnassigned ( newRouting , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ) ; ShardRoutingHelper . initialize ( newRouting , nodeId ) ; IndexShard shard = index . createShard ( newRouting ) ; shard . updateRoutingEntry ( newRouting , true ) ; final DiscoveryNode localNode = new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; shard . markAsRecovering ( <str> , new RecoveryState ( shard . shardId ( ) , newRouting . primary ( ) , RecoveryState . Type . SNAPSHOT , newRouting . restoreSource ( ) , localNode ) ) ; shard . recoverFromStore ( localNode ) ; newRouting = new ShardRouting ( newRouting ) ; ShardRoutingHelper . moveToStarted ( newRouting ) ; shard . updateRoutingEntry ( newRouting , true ) ; } finally { indicesService . deleteIndex ( <str> , <str> ) ; } assertEquals ( <int> , counter . get ( ) ) ; } } 
