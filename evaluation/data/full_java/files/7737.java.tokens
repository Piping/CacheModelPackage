package org . elasticsearch . action . admin . indices . shards ; import com . carrotsearch . hppc . cursors . IntObjectCursor ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . apache . lucene . index . CorruptIndexException ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . client . Requests ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . common . collect . ImmutableOpenIntMap ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . junit . annotations . TestLogging ; import org . elasticsearch . test . store . MockFSIndexStore ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . function . Predicate ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoTimeout ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST ) public class IndicesShardStoreRequestIT extends ESIntegTestCase { public void testEmpty ( ) { ensureGreen ( ) ; IndicesShardStoresResponse rsp = client ( ) . admin ( ) . indices ( ) . prepareShardStores ( ) . get ( ) ; assertThat ( rsp . getStoreStatuses ( ) . size ( ) , equalTo ( <int> ) ) ; } @TestLogging ( <str> ) public void testBasic ( ) throws Exception { String index = <str> ; internalCluster ( ) . ensureAtLeastNumDataNodes ( <int> ) ; assertAcked ( prepareCreate ( index ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <str> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <str> ) ) ) ; indexRandomData ( index ) ; ensureGreen ( index ) ; IndicesShardStoresResponse response = client ( ) . admin ( ) . indices ( ) . prepareShardStores ( index ) . get ( ) ; assertThat ( response . getStoreStatuses ( ) . size ( ) , equalTo ( <int> ) ) ; response = client ( ) . admin ( ) . indices ( ) . shardStores ( Requests . indicesShardStoresRequest ( index ) . shardStatuses ( <str> ) ) . get ( ) ; assertThat ( response . getStoreStatuses ( ) . containsKey ( index ) , equalTo ( true ) ) ; ImmutableOpenIntMap < List < IndicesShardStoresResponse . StoreStatus > > shardStores = response . getStoreStatuses ( ) . get ( index ) ; assertThat ( shardStores . values ( ) . size ( ) , equalTo ( <int> ) ) ; for ( ObjectCursor < List < IndicesShardStoresResponse . StoreStatus > > shardStoreStatuses : shardStores . values ( ) ) { for ( IndicesShardStoresResponse . StoreStatus storeStatus : shardStoreStatuses . value ) { assertThat ( storeStatus . getVersion ( ) , greaterThan ( - <int> ) ) ; assertThat ( storeStatus . getNode ( ) , notNullValue ( ) ) ; assertThat ( storeStatus . getStoreException ( ) , nullValue ( ) ) ; } } ensureGreen ( index ) ; logger . info ( <str> ) ; disableAllocation ( index ) ; logger . info ( <str> ) ; int num = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) . nodes ( ) . getSize ( ) ; internalCluster ( ) . stopRandomNode ( new IndexNodePredicate ( index ) ) ; assertNoTimeout ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> + ( num - <int> ) ) ) ; ClusterState clusterState = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; List < ShardRouting > unassignedShards = clusterState . routingTable ( ) . index ( index ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) ; response = client ( ) . admin ( ) . indices ( ) . shardStores ( Requests . indicesShardStoresRequest ( index ) ) . get ( ) ; assertThat ( response . getStoreStatuses ( ) . containsKey ( index ) , equalTo ( true ) ) ; ImmutableOpenIntMap < List < IndicesShardStoresResponse . StoreStatus > > shardStoresStatuses = response . getStoreStatuses ( ) . get ( index ) ; assertThat ( shardStoresStatuses . size ( ) , equalTo ( unassignedShards . size ( ) ) ) ; for ( IntObjectCursor < List < IndicesShardStoresResponse . StoreStatus > > storesStatus : shardStoresStatuses ) { assertThat ( <str> , storesStatus . value . size ( ) , equalTo ( <int> ) ) ; assertThat ( <str> , storesStatus . value . get ( <int> ) . getAllocation ( ) , equalTo ( IndicesShardStoresResponse . StoreStatus . Allocation . PRIMARY ) ) ; } logger . info ( <str> ) ; enableAllocation ( index ) ; } public void testIndices ( ) throws Exception { String index1 = <str> ; String index2 = <str> ; internalCluster ( ) . ensureAtLeastNumDataNodes ( <int> ) ; assertAcked ( prepareCreate ( index1 ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <str> ) ) ) ; assertAcked ( prepareCreate ( index2 ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <str> ) ) ) ; indexRandomData ( index1 ) ; indexRandomData ( index2 ) ; ensureGreen ( ) ; IndicesShardStoresResponse response = client ( ) . admin ( ) . indices ( ) . shardStores ( Requests . indicesShardStoresRequest ( ) . shardStatuses ( <str> ) ) . get ( ) ; ImmutableOpenMap < String , ImmutableOpenIntMap < List < IndicesShardStoresResponse . StoreStatus > > > shardStatuses = response . getStoreStatuses ( ) ; assertThat ( shardStatuses . containsKey ( index1 ) , equalTo ( true ) ) ; assertThat ( shardStatuses . containsKey ( index2 ) , equalTo ( true ) ) ; assertThat ( shardStatuses . get ( index1 ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( shardStatuses . get ( index2 ) . size ( ) , equalTo ( <int> ) ) ; response = client ( ) . admin ( ) . indices ( ) . shardStores ( Requests . indicesShardStoresRequest ( index1 ) . shardStatuses ( <str> ) ) . get ( ) ; shardStatuses = response . getStoreStatuses ( ) ; assertThat ( shardStatuses . containsKey ( index1 ) , equalTo ( true ) ) ; assertThat ( shardStatuses . containsKey ( index2 ) , equalTo ( false ) ) ; assertThat ( shardStatuses . get ( index1 ) . size ( ) , equalTo ( <int> ) ) ; } @AwaitsFix ( bugUrl = <str> ) public void testCorruptedShards ( ) throws Exception { String index = <str> ; internalCluster ( ) . ensureAtLeastNumDataNodes ( <int> ) ; assertAcked ( prepareCreate ( index ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <str> ) . put ( MockFSIndexStore . CHECK_INDEX_ON_CLOSE , false ) ) ) ; indexRandomData ( index ) ; ensureGreen ( index ) ; logger . info ( <str> ) ; disableAllocation ( index ) ; logger . info ( <str> ) ; Map < Integer , Set < String > > corruptedShardIDMap = new HashMap < > ( ) ; for ( String node : internalCluster ( ) . nodesInclude ( index ) ) { IndicesService indexServices = internalCluster ( ) . getInstance ( IndicesService . class , node ) ; IndexService indexShards = indexServices . indexServiceSafe ( index ) ; for ( Integer shardId : indexShards . shardIds ( ) ) { IndexShard shard = indexShards . getShard ( shardId ) ; if ( randomBoolean ( ) ) { shard . failShard ( <str> , new CorruptIndexException ( <str> , <str> ) ) ; Set < String > nodes = corruptedShardIDMap . get ( shardId ) ; if ( nodes = = null ) { nodes = new HashSet < > ( ) ; } nodes . add ( node ) ; corruptedShardIDMap . put ( shardId , nodes ) ; } } } IndicesShardStoresResponse rsp = client ( ) . admin ( ) . indices ( ) . prepareShardStores ( index ) . setShardStatuses ( <str> ) . get ( ) ; ImmutableOpenIntMap < List < IndicesShardStoresResponse . StoreStatus > > shardStatuses = rsp . getStoreStatuses ( ) . get ( index ) ; assertNotNull ( shardStatuses ) ; assertThat ( shardStatuses . size ( ) , greaterThan ( <int> ) ) ; for ( IntObjectCursor < List < IndicesShardStoresResponse . StoreStatus > > shardStatus : shardStatuses ) { for ( IndicesShardStoresResponse . StoreStatus status : shardStatus . value ) { if ( corruptedShardIDMap . containsKey ( shardStatus . key ) & & corruptedShardIDMap . get ( shardStatus . key ) . contains ( status . getNode ( ) . name ( ) ) ) { assertThat ( status . getVersion ( ) , greaterThanOrEqualTo ( <int> l ) ) ; assertThat ( status . getStoreException ( ) , notNullValue ( ) ) ; } else { assertThat ( status . getVersion ( ) , greaterThanOrEqualTo ( <int> l ) ) ; assertNull ( status . getStoreException ( ) ) ; } } } logger . info ( <str> ) ; enableAllocation ( index ) ; } private void indexRandomData ( String index ) throws ExecutionException , InterruptedException { int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; IndexRequestBuilder [ ] builders = new IndexRequestBuilder [ numDocs ] ; for ( int i = <int> ; i < builders . length ; i + + ) { builders [ i ] = client ( ) . prepareIndex ( index , <str> ) . setSource ( <str> , <str> ) ; } indexRandom ( true , builders ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . setForce ( true ) . setWaitIfOngoing ( true ) . execute ( ) . actionGet ( ) ; } private final static class IndexNodePredicate implements Predicate < Settings > { private final Set < String > nodesWithShard ; public IndexNodePredicate ( String index ) { this . nodesWithShard = findNodesWithShard ( index ) ; } @Override public boolean test ( Settings settings ) { return nodesWithShard . contains ( settings . get ( <str> ) ) ; } private Set < String > findNodesWithShard ( String index ) { ClusterState state = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; IndexRoutingTable indexRoutingTable = state . routingTable ( ) . index ( index ) ; List < ShardRouting > startedShards = indexRoutingTable . shardsWithState ( ShardRoutingState . STARTED ) ; Set < String > nodesWithShard = new HashSet < > ( ) ; for ( ShardRouting startedShard : startedShards ) { nodesWithShard . add ( state . nodes ( ) . get ( startedShard . currentNodeId ( ) ) . getName ( ) ) ; } return nodesWithShard ; } } } 
