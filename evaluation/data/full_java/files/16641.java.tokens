package org . junit . tests . experimental . theories . internal ; import static org . hamcrest . CoreMatchers . hasItem ; import static org . hamcrest . CoreMatchers . hasItems ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; import java . util . ArrayList ; import java . util . List ; import org . junit . Test ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . DataPoints ; import org . junit . experimental . theories . FromDataPoints ; import org . junit . experimental . theories . ParameterSignature ; import org . junit . experimental . theories . PotentialAssignment ; import org . junit . experimental . theories . PotentialAssignment . CouldNotGenerateValueException ; import org . junit . experimental . theories . internal . SpecificDataPointsSupplier ; import org . junit . runners . model . TestClass ; public class SpecificDataPointsSupplierTest { public static class TestClassWithNamedDataPoints { @DataPoints ( { <str> , <str> } ) public static String [ ] values = new String [ ] { <str> } ; @DataPoints public static String [ ] otherValues = new String [ ] { <str> } ; @DataPoints ( { <str> , <str> } ) public static String [ ] getValues ( ) { return new String [ ] { <str> } ; } @DataPoint ( { <str> , <str> } ) public static String singleValue = <str> ; @DataPoint public static String otherSingleValue = <str> ; @DataPoint ( { <str> , <str> } ) public static String getSingleValue ( ) { return <str> ; } @DataPoint public static String getSingleOtherValue ( ) { return <str> ; } @DataPoints public static String [ ] getOtherValues ( ) { return new String [ ] { <str> } ; } } @Test public void shouldReturnOnlyTheNamedDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( <str> ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( <int> , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItems ( <str> , <str> , <str> , <str> ) ) ; } @Test public void shouldReturnOnlyTheNamedFieldDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( <str> ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( <int> , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( <str> ) ) ; } @Test public void shouldReturnOnlyTheNamedMethodDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( <str> ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( <int> , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( <str> ) ) ; } @Test public void shouldReturnOnlyTheNamedSingleFieldDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( <str> ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( <int> , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( <str> ) ) ; } @Test public void shouldReturnOnlyTheNamedSingleMethodDataPoints ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( <str> ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( <int> , assignedStrings . size ( ) ) ; assertThat ( assignedStrings , hasItem ( <str> ) ) ; } @Test public void shouldReturnNothingIfTheNamedDataPointsAreMissing ( ) throws Throwable { SpecificDataPointsSupplier supplier = new SpecificDataPointsSupplier ( new TestClass ( TestClassWithNamedDataPoints . class ) ) ; List < PotentialAssignment > assignments = supplier . getValueSources ( signature ( <str> ) ) ; List < String > assignedStrings = getStringValuesFromAssignments ( assignments ) ; assertEquals ( <int> , assignedStrings . size ( ) ) ; } private List < String > getStringValuesFromAssignments ( List < PotentialAssignment > assignments ) throws CouldNotGenerateValueException { List < String > stringValues = new ArrayList < String > ( ) ; for ( PotentialAssignment assignment : assignments ) { stringValues . add ( ( String ) assignment . getValue ( ) ) ; } return stringValues ; } private ParameterSignature signature ( String methodName ) throws Exception { return ParameterSignature . signatures ( this . getClass ( ) . getMethod ( methodName , String . class ) ) . get ( <int> ) ; } public void methodWantingAnyString ( String input ) { } public void methodWantingNamedFieldString ( @FromDataPoints ( <str> ) String input ) { } public void methodWantingNamedMethodString ( @FromDataPoints ( <str> ) String input ) { } public void methodWantingNamedSingleFieldString ( @FromDataPoints ( <str> ) String input ) { } public void methodWantingNamedSingleMethodString ( @FromDataPoints ( <str> ) String input ) { } public void methodWantingAllNamedStrings ( @FromDataPoints ( <str> ) String input ) { } public void methodWantingWrongNamedString ( @FromDataPoints ( <str> ) String input ) { } } 
