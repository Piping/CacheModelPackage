package org . elasticsearch . test . engine ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . FilterDirectoryReader ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . search . * ; import org . apache . lucene . util . LuceneTestCase ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . engine . EngineConfig ; import org . elasticsearch . index . engine . EngineException ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . Closeable ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . util . IdentityHashMap ; import java . util . Random ; import java . util . concurrent . atomic . AtomicBoolean ; public final class MockEngineSupport { public static final String WRAP_READER_RATIO = <str> ; public static final String READER_WRAPPER_TYPE = <str> ; public static final String FLUSH_ON_CLOSE_RATIO = <str> ; private final AtomicBoolean closing = new AtomicBoolean ( false ) ; private final ESLogger logger = Loggers . getLogger ( Engine . class ) ; private final ShardId shardId ; private final QueryCache filterCache ; private final QueryCachingPolicy filterCachingPolicy ; private final SearcherCloseable searcherCloseable ; private final MockContext mockContext ; public static class MockContext { private final Random random ; private final boolean wrapReader ; private final Class < ? extends FilterDirectoryReader > wrapper ; private final Settings indexSettings ; private final double flushOnClose ; public MockContext ( Random random , boolean wrapReader , Class < ? extends FilterDirectoryReader > wrapper , Settings indexSettings ) { this . random = random ; this . wrapReader = wrapReader ; this . wrapper = wrapper ; this . indexSettings = indexSettings ; flushOnClose = indexSettings . getAsDouble ( FLUSH_ON_CLOSE_RATIO , <float> ) ; } } public MockEngineSupport ( EngineConfig config , Class < ? extends FilterDirectoryReader > wrapper ) { Settings settings = config . getIndexSettings ( ) . getSettings ( ) ; shardId = config . getShardId ( ) ; filterCache = config . getQueryCache ( ) ; filterCachingPolicy = config . getQueryCachingPolicy ( ) ; final long seed = settings . getAsLong ( ESIntegTestCase . SETTING_INDEX_SEED , <int> l ) ; Random random = new Random ( seed ) ; final double ratio = settings . getAsDouble ( WRAP_READER_RATIO , <float> ) ; boolean wrapReader = random . nextDouble ( ) < ratio ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , this . getClass ( ) . getName ( ) , shardId , seed , wrapReader ) ; } mockContext = new MockContext ( random , wrapReader , wrapper , settings ) ; this . searcherCloseable = new SearcherCloseable ( ) ; LuceneTestCase . closeAfterSuite ( searcherCloseable ) ; } enum CloseAction { FLUSH_AND_CLOSE , CLOSE ; } public CloseAction flushOrClose ( Engine engine , CloseAction originalAction ) throws IOException { if ( closing . compareAndSet ( false , true ) ) { if ( mockContext . flushOnClose > mockContext . random . nextDouble ( ) ) { return CloseAction . FLUSH_AND_CLOSE ; } else { return CloseAction . CLOSE ; } } else { return originalAction ; } } public AssertingIndexSearcher newSearcher ( String source , IndexSearcher searcher , SearcherManager manager ) throws EngineException { IndexReader reader = searcher . getIndexReader ( ) ; IndexReader wrappedReader = reader ; assert reader ! = null ; if ( reader instanceof DirectoryReader & & mockContext . wrapReader ) { wrappedReader = wrapReader ( ( DirectoryReader ) reader ) ; } final AssertingIndexSearcher assertingIndexSearcher = new AssertingIndexSearcher ( mockContext . random , wrappedReader ) ; assertingIndexSearcher . setSimilarity ( searcher . getSimilarity ( true ) ) ; assertingIndexSearcher . setQueryCache ( filterCache ) ; assertingIndexSearcher . setQueryCachingPolicy ( filterCachingPolicy ) ; return assertingIndexSearcher ; } private DirectoryReader wrapReader ( DirectoryReader reader ) { try { Constructor < ? > [ ] constructors = mockContext . wrapper . getConstructors ( ) ; Constructor < ? > nonRandom = null ; for ( Constructor < ? > constructor : constructors ) { Class < ? > [ ] parameterTypes = constructor . getParameterTypes ( ) ; if ( parameterTypes . length > <int> & & parameterTypes [ <int> ] = = DirectoryReader . class ) { if ( parameterTypes . length = = <int> ) { nonRandom = constructor ; } else if ( parameterTypes . length = = <int> & & parameterTypes [ <int> ] = = Settings . class ) { return ( DirectoryReader ) constructor . newInstance ( reader , mockContext . indexSettings ) ; } } } if ( nonRandom ! = null ) { return ( DirectoryReader ) nonRandom . newInstance ( reader ) ; } } catch ( Exception e ) { throw new ElasticsearchException ( <str> , e ) ; } return reader ; } public static abstract class DirectoryReaderWrapper extends FilterDirectoryReader { protected final SubReaderWrapper subReaderWrapper ; public DirectoryReaderWrapper ( DirectoryReader in , SubReaderWrapper subReaderWrapper ) throws IOException { super ( in , subReaderWrapper ) ; this . subReaderWrapper = subReaderWrapper ; } @Override public Object getCoreCacheKey ( ) { return in . getCoreCacheKey ( ) ; } } public Engine . Searcher wrapSearcher ( String source , Engine . Searcher engineSearcher , IndexSearcher searcher , SearcherManager manager ) { final AssertingIndexSearcher assertingIndexSearcher = newSearcher ( source , searcher , manager ) ; assertingIndexSearcher . setSimilarity ( searcher . getSimilarity ( true ) ) ; AssertingSearcher assertingSearcher = new AssertingSearcher ( assertingIndexSearcher , engineSearcher , shardId , logger ) { @Override public void close ( ) { try { searcherCloseable . remove ( this ) ; } finally { super . close ( ) ; } } } ; searcherCloseable . add ( assertingSearcher , engineSearcher . source ( ) ) ; return assertingSearcher ; } private static final class SearcherCloseable implements Closeable { private final IdentityHashMap < AssertingSearcher , RuntimeException > openSearchers = new IdentityHashMap < > ( ) ; @Override public synchronized void close ( ) throws IOException { if ( openSearchers . isEmpty ( ) = = false ) { AssertionError error = new AssertionError ( <str> ) ; for ( RuntimeException ex : openSearchers . values ( ) ) { error . addSuppressed ( ex ) ; } throw error ; } } void add ( AssertingSearcher searcher , String source ) { final RuntimeException ex = new RuntimeException ( <str> + source + <str> ) ; synchronized ( this ) { openSearchers . put ( searcher , ex ) ; } } synchronized void remove ( AssertingSearcher searcher ) { openSearchers . remove ( searcher ) ; } } } 
