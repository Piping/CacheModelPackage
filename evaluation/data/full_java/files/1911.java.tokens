package clojure . lang ; import java . io . Serializable ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . concurrent . atomic . AtomicReference ; public class PersistentHashMap extends APersistentMap implements IEditableCollection , IObj , IMapIterable , IKVReduce { final int count ; final INode root ; final boolean hasNull ; final Object nullValue ; final IPersistentMap _meta ; final public static PersistentHashMap EMPTY = new PersistentHashMap ( <int> , null , false , null ) ; final private static Object NOT_FOUND = new Object ( ) ; static public IPersistentMap create ( Map other ) { ITransientMap ret = EMPTY . asTransient ( ) ; for ( Object o : other . entrySet ( ) ) { Map . Entry e = ( Entry ) o ; ret = ret . assoc ( e . getKey ( ) , e . getValue ( ) ) ; } return ret . persistent ( ) ; } public static PersistentHashMap create ( Object . . . init ) { ITransientMap ret = EMPTY . asTransient ( ) ; for ( int i = <int> ; i < init . length ; i + = <int> ) { ret = ret . assoc ( init [ i ] , init [ i + <int> ] ) ; } return ( PersistentHashMap ) ret . persistent ( ) ; } public static PersistentHashMap createWithCheck ( Object . . . init ) { ITransientMap ret = EMPTY . asTransient ( ) ; for ( int i = <int> ; i < init . length ; i + = <int> ) { ret = ret . assoc ( init [ i ] , init [ i + <int> ] ) ; if ( ret . count ( ) ! = i / <int> + <int> ) throw new IllegalArgumentException ( <str> + init [ i ] ) ; } return ( PersistentHashMap ) ret . persistent ( ) ; } static public PersistentHashMap create ( ISeq items ) { ITransientMap ret = EMPTY . asTransient ( ) ; for ( ; items ! = null ; items = items . next ( ) . next ( ) ) { if ( items . next ( ) = = null ) throw new IllegalArgumentException ( String . format ( <str> , items . first ( ) ) ) ; ret = ret . assoc ( items . first ( ) , RT . second ( items ) ) ; } return ( PersistentHashMap ) ret . persistent ( ) ; } static public PersistentHashMap createWithCheck ( ISeq items ) { ITransientMap ret = EMPTY . asTransient ( ) ; for ( int i = <int> ; items ! = null ; items = items . next ( ) . next ( ) , + + i ) { if ( items . next ( ) = = null ) throw new IllegalArgumentException ( String . format ( <str> , items . first ( ) ) ) ; ret = ret . assoc ( items . first ( ) , RT . second ( items ) ) ; if ( ret . count ( ) ! = i + <int> ) throw new IllegalArgumentException ( <str> + items . first ( ) ) ; } return ( PersistentHashMap ) ret . persistent ( ) ; } public static PersistentHashMap create ( IPersistentMap meta , Object . . . init ) { return create ( init ) . withMeta ( meta ) ; } PersistentHashMap ( int count , INode root , boolean hasNull , Object nullValue ) { this . count = count ; this . root = root ; this . hasNull = hasNull ; this . nullValue = nullValue ; this . _meta = null ; } public PersistentHashMap ( IPersistentMap meta , int count , INode root , boolean hasNull , Object nullValue ) { this . _meta = meta ; this . count = count ; this . root = root ; this . hasNull = hasNull ; this . nullValue = nullValue ; } static int hash ( Object k ) { return Util . hasheq ( k ) ; } public boolean containsKey ( Object key ) { if ( key = = null ) return hasNull ; return ( root ! = null ) ? root . find ( <int> , hash ( key ) , key , NOT_FOUND ) ! = NOT_FOUND : false ; } public IMapEntry entryAt ( Object key ) { if ( key = = null ) return hasNull ? ( IMapEntry ) Tuple . create ( null , nullValue ) : null ; return ( root ! = null ) ? root . find ( <int> , hash ( key ) , key ) : null ; } public IPersistentMap assoc ( Object key , Object val ) { if ( key = = null ) { if ( hasNull & & val = = nullValue ) return this ; return new PersistentHashMap ( meta ( ) , hasNull ? count : count + <int> , root , true , val ) ; } Box addedLeaf = new Box ( null ) ; INode newroot = ( root = = null ? BitmapIndexedNode . EMPTY : root ) . assoc ( <int> , hash ( key ) , key , val , addedLeaf ) ; if ( newroot = = root ) return this ; return new PersistentHashMap ( meta ( ) , addedLeaf . val = = null ? count : count + <int> , newroot , hasNull , nullValue ) ; } public Object valAt ( Object key , Object notFound ) { if ( key = = null ) return hasNull ? nullValue : notFound ; return root ! = null ? root . find ( <int> , hash ( key ) , key , notFound ) : notFound ; } public Object valAt ( Object key ) { return valAt ( key , null ) ; } public IPersistentMap assocEx ( Object key , Object val ) { if ( containsKey ( key ) ) throw Util . runtimeException ( <str> ) ; return assoc ( key , val ) ; } public IPersistentMap without ( Object key ) { if ( key = = null ) return hasNull ? new PersistentHashMap ( meta ( ) , count - <int> , root , false , null ) : this ; if ( root = = null ) return this ; INode newroot = root . without ( <int> , hash ( key ) , key ) ; if ( newroot = = root ) return this ; return new PersistentHashMap ( meta ( ) , count - <int> , newroot , hasNull , nullValue ) ; } static final Iterator EMPTY_ITER = new Iterator ( ) { public boolean hasNext ( ) { return false ; } public Object next ( ) { throw new NoSuchElementException ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; private Iterator iterator ( final IFn f ) { final Iterator rootIter = ( root = = null ) ? EMPTY_ITER : root . iterator ( f ) ; if ( hasNull ) { return new Iterator ( ) { private boolean seen = false ; public boolean hasNext ( ) { if ( ! seen ) return true ; else return rootIter . hasNext ( ) ; } public Object next ( ) { if ( ! seen ) { seen = true ; return f . invoke ( null , nullValue ) ; } else return rootIter . next ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } else return rootIter ; } public Iterator iterator ( ) { return iterator ( APersistentMap . MAKE_ENTRY ) ; } public Iterator keyIterator ( ) { return iterator ( APersistentMap . MAKE_KEY ) ; } public Iterator valIterator ( ) { return iterator ( APersistentMap . MAKE_VAL ) ; } public Object kvreduce ( IFn f , Object init ) { init = hasNull ? f . invoke ( init , null , nullValue ) : init ; if ( RT . isReduced ( init ) ) return ( ( IDeref ) init ) . deref ( ) ; if ( root ! = null ) { init = root . kvreduce ( f , init ) ; if ( RT . isReduced ( init ) ) return ( ( IDeref ) init ) . deref ( ) ; else return init ; } return init ; } public Object fold ( long n , final IFn combinef , final IFn reducef , IFn fjinvoke , final IFn fjtask , final IFn fjfork , final IFn fjjoin ) { Callable top = new Callable ( ) { public Object call ( ) throws Exception { Object ret = combinef . invoke ( ) ; if ( root ! = null ) ret = combinef . invoke ( ret , root . fold ( combinef , reducef , fjtask , fjfork , fjjoin ) ) ; return hasNull ? combinef . invoke ( ret , reducef . invoke ( combinef . invoke ( ) , null , nullValue ) ) : ret ; } } ; return fjinvoke . invoke ( top ) ; } public int count ( ) { return count ; } public ISeq seq ( ) { ISeq s = root ! = null ? root . nodeSeq ( ) : null ; return hasNull ? new Cons ( Tuple . create ( null , nullValue ) , s ) : s ; } public IPersistentCollection empty ( ) { return EMPTY . withMeta ( meta ( ) ) ; } static int mask ( int hash , int shift ) { return ( hash > > > shift ) & <hex> ; } public PersistentHashMap withMeta ( IPersistentMap meta ) { return new PersistentHashMap ( meta , count , root , hasNull , nullValue ) ; } public TransientHashMap asTransient ( ) { return new TransientHashMap ( this ) ; } public IPersistentMap meta ( ) { return _meta ; } static final class TransientHashMap extends ATransientMap { final AtomicReference < Thread > edit ; volatile INode root ; volatile int count ; volatile boolean hasNull ; volatile Object nullValue ; final Box leafFlag = new Box ( null ) ; TransientHashMap ( PersistentHashMap m ) { this ( new AtomicReference < Thread > ( Thread . currentThread ( ) ) , m . root , m . count , m . hasNull , m . nullValue ) ; } TransientHashMap ( AtomicReference < Thread > edit , INode root , int count , boolean hasNull , Object nullValue ) { this . edit = edit ; this . root = root ; this . count = count ; this . hasNull = hasNull ; this . nullValue = nullValue ; } ITransientMap doAssoc ( Object key , Object val ) { if ( key = = null ) { if ( this . nullValue ! = val ) this . nullValue = val ; if ( ! hasNull ) { this . count + + ; this . hasNull = true ; } return this ; } leafFlag . val = null ; INode n = ( root = = null ? BitmapIndexedNode . EMPTY : root ) . assoc ( edit , <int> , hash ( key ) , key , val , leafFlag ) ; if ( n ! = this . root ) this . root = n ; if ( leafFlag . val ! = null ) this . count + + ; return this ; } ITransientMap doWithout ( Object key ) { if ( key = = null ) { if ( ! hasNull ) return this ; hasNull = false ; nullValue = null ; this . count - - ; return this ; } if ( root = = null ) return this ; leafFlag . val = null ; INode n = root . without ( edit , <int> , hash ( key ) , key , leafFlag ) ; if ( n ! = root ) this . root = n ; if ( leafFlag . val ! = null ) this . count - - ; return this ; } IPersistentMap doPersistent ( ) { edit . set ( null ) ; return new PersistentHashMap ( count , root , hasNull , nullValue ) ; } Object doValAt ( Object key , Object notFound ) { if ( key = = null ) if ( hasNull ) return nullValue ; else return notFound ; if ( root = = null ) return notFound ; return root . find ( <int> , hash ( key ) , key , notFound ) ; } int doCount ( ) { return count ; } void ensureEditable ( ) { if ( edit . get ( ) = = null ) throw new IllegalAccessError ( <str> ) ; } } static interface INode extends Serializable { INode assoc ( int shift , int hash , Object key , Object val , Box addedLeaf ) ; INode without ( int shift , int hash , Object key ) ; IMapEntry find ( int shift , int hash , Object key ) ; Object find ( int shift , int hash , Object key , Object notFound ) ; ISeq nodeSeq ( ) ; INode assoc ( AtomicReference < Thread > edit , int shift , int hash , Object key , Object val , Box addedLeaf ) ; INode without ( AtomicReference < Thread > edit , int shift , int hash , Object key , Box removedLeaf ) ; public Object kvreduce ( IFn f , Object init ) ; Object fold ( IFn combinef , IFn reducef , IFn fjtask , IFn fjfork , IFn fjjoin ) ; Iterator iterator ( IFn f ) ; } final static class ArrayNode implements INode { int count ; final INode [ ] array ; final AtomicReference < Thread > edit ; ArrayNode ( AtomicReference < Thread > edit , int count , INode [ ] array ) { this . array = array ; this . edit = edit ; this . count = count ; } public INode assoc ( int shift , int hash , Object key , Object val , Box addedLeaf ) { int idx = mask ( hash , shift ) ; INode node = array [ idx ] ; if ( node = = null ) return new ArrayNode ( null , count + <int> , cloneAndSet ( array , idx , BitmapIndexedNode . EMPTY . assoc ( shift + <int> , hash , key , val , addedLeaf ) ) ) ; INode n = node . assoc ( shift + <int> , hash , key , val , addedLeaf ) ; if ( n = = node ) return this ; return new ArrayNode ( null , count , cloneAndSet ( array , idx , n ) ) ; } public INode without ( int shift , int hash , Object key ) { int idx = mask ( hash , shift ) ; INode node = array [ idx ] ; if ( node = = null ) return this ; INode n = node . without ( shift + <int> , hash , key ) ; if ( n = = node ) return this ; if ( n = = null ) { if ( count < = <int> ) return pack ( null , idx ) ; return new ArrayNode ( null , count - <int> , cloneAndSet ( array , idx , n ) ) ; } else return new ArrayNode ( null , count , cloneAndSet ( array , idx , n ) ) ; } public IMapEntry find ( int shift , int hash , Object key ) { int idx = mask ( hash , shift ) ; INode node = array [ idx ] ; if ( node = = null ) return null ; return node . find ( shift + <int> , hash , key ) ; } public Object find ( int shift , int hash , Object key , Object notFound ) { int idx = mask ( hash , shift ) ; INode node = array [ idx ] ; if ( node = = null ) return notFound ; return node . find ( shift + <int> , hash , key , notFound ) ; } public ISeq nodeSeq ( ) { return Seq . create ( array ) ; } public Iterator iterator ( IFn f ) { return new Iter ( array , f ) ; } public Object kvreduce ( IFn f , Object init ) { for ( INode node : array ) { if ( node ! = null ) { init = node . kvreduce ( f , init ) ; if ( RT . isReduced ( init ) ) return init ; } } return init ; } public Object fold ( final IFn combinef , final IFn reducef , final IFn fjtask , final IFn fjfork , final IFn fjjoin ) { List < Callable > tasks = new ArrayList ( ) ; for ( final INode node : array ) { if ( node ! = null ) { tasks . add ( new Callable ( ) { public Object call ( ) throws Exception { return node . fold ( combinef , reducef , fjtask , fjfork , fjjoin ) ; } } ) ; } } return foldTasks ( tasks , combinef , fjtask , fjfork , fjjoin ) ; } static public Object foldTasks ( List < Callable > tasks , final IFn combinef , final IFn fjtask , final IFn fjfork , final IFn fjjoin ) { if ( tasks . isEmpty ( ) ) return combinef . invoke ( ) ; if ( tasks . size ( ) = = <int> ) { Object ret = null ; try { return tasks . get ( <int> ) . call ( ) ; } catch ( Exception e ) { throw Util . sneakyThrow ( e ) ; } } List < Callable > t1 = tasks . subList ( <int> , tasks . size ( ) / <int> ) ; final List < Callable > t2 = tasks . subList ( tasks . size ( ) / <int> , tasks . size ( ) ) ; Object forked = fjfork . invoke ( fjtask . invoke ( new Callable ( ) { public Object call ( ) throws Exception { return foldTasks ( t2 , combinef , fjtask , fjfork , fjjoin ) ; } } ) ) ; return combinef . invoke ( foldTasks ( t1 , combinef , fjtask , fjfork , fjjoin ) , fjjoin . invoke ( forked ) ) ; } private ArrayNode ensureEditable ( AtomicReference < Thread > edit ) { if ( this . edit = = edit ) return this ; return new ArrayNode ( edit , count , this . array . clone ( ) ) ; } private ArrayNode editAndSet ( AtomicReference < Thread > edit , int i , INode n ) { ArrayNode editable = ensureEditable ( edit ) ; editable . array [ i ] = n ; return editable ; } private INode pack ( AtomicReference < Thread > edit , int idx ) { Object [ ] newArray = new Object [ <int> * ( count - <int> ) ] ; int j = <int> ; int bitmap = <int> ; for ( int i = <int> ; i < idx ; i + + ) if ( array [ i ] ! = null ) { newArray [ j ] = array [ i ] ; bitmap | = <int> < < i ; j + = <int> ; } for ( int i = idx + <int> ; i < array . length ; i + + ) if ( array [ i ] ! = null ) { newArray [ j ] = array [ i ] ; bitmap | = <int> < < i ; j + = <int> ; } return new BitmapIndexedNode ( edit , bitmap , newArray ) ; } public INode assoc ( AtomicReference < Thread > edit , int shift , int hash , Object key , Object val , Box addedLeaf ) { int idx = mask ( hash , shift ) ; INode node = array [ idx ] ; if ( node = = null ) { ArrayNode editable = editAndSet ( edit , idx , BitmapIndexedNode . EMPTY . assoc ( edit , shift + <int> , hash , key , val , addedLeaf ) ) ; editable . count + + ; return editable ; } INode n = node . assoc ( edit , shift + <int> , hash , key , val , addedLeaf ) ; if ( n = = node ) return this ; return editAndSet ( edit , idx , n ) ; } public INode without ( AtomicReference < Thread > edit , int shift , int hash , Object key , Box removedLeaf ) { int idx = mask ( hash , shift ) ; INode node = array [ idx ] ; if ( node = = null ) return this ; INode n = node . without ( edit , shift + <int> , hash , key , removedLeaf ) ; if ( n = = node ) return this ; if ( n = = null ) { if ( count < = <int> ) return pack ( edit , idx ) ; ArrayNode editable = editAndSet ( edit , idx , n ) ; editable . count - - ; return editable ; } return editAndSet ( edit , idx , n ) ; } static class Seq extends ASeq { final INode [ ] nodes ; final int i ; final ISeq s ; static ISeq create ( INode [ ] nodes ) { return create ( null , nodes , <int> , null ) ; } private static ISeq create ( IPersistentMap meta , INode [ ] nodes , int i , ISeq s ) { if ( s ! = null ) return new Seq ( meta , nodes , i , s ) ; for ( int j = i ; j < nodes . length ; j + + ) if ( nodes [ j ] ! = null ) { ISeq ns = nodes [ j ] . nodeSeq ( ) ; if ( ns ! = null ) return new Seq ( meta , nodes , j + <int> , ns ) ; } return null ; } private Seq ( IPersistentMap meta , INode [ ] nodes , int i , ISeq s ) { super ( meta ) ; this . nodes = nodes ; this . i = i ; this . s = s ; } public Obj withMeta ( IPersistentMap meta ) { return new Seq ( meta , nodes , i , s ) ; } public Object first ( ) { return s . first ( ) ; } public ISeq next ( ) { return create ( null , nodes , i , s . next ( ) ) ; } } static class Iter implements Iterator { private final INode [ ] array ; private final IFn f ; private int i = <int> ; private Iterator nestedIter ; private Iter ( INode [ ] array , IFn f ) { this . array = array ; this . f = f ; } public boolean hasNext ( ) { while ( true ) { if ( nestedIter ! = null ) if ( nestedIter . hasNext ( ) ) return true ; else nestedIter = null ; if ( i < array . length ) { INode node = array [ i + + ] ; if ( node ! = null ) nestedIter = node . iterator ( f ) ; } else return false ; } } public Object next ( ) { if ( hasNext ( ) ) return nestedIter . next ( ) ; else throw new NoSuchElementException ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } } final static class BitmapIndexedNode implements INode { static final BitmapIndexedNode EMPTY = new BitmapIndexedNode ( null , <int> , new Object [ <int> ] ) ; int bitmap ; Object [ ] array ; final AtomicReference < Thread > edit ; final int index ( int bit ) { return Integer . bitCount ( bitmap & ( bit - <int> ) ) ; } BitmapIndexedNode ( AtomicReference < Thread > edit , int bitmap , Object [ ] array ) { this . bitmap = bitmap ; this . array = array ; this . edit = edit ; } public INode assoc ( int shift , int hash , Object key , Object val , Box addedLeaf ) { int bit = bitpos ( hash , shift ) ; int idx = index ( bit ) ; if ( ( bitmap & bit ) ! = <int> ) { Object keyOrNull = array [ <int> * idx ] ; Object valOrNode = array [ <int> * idx + <int> ] ; if ( keyOrNull = = null ) { INode n = ( ( INode ) valOrNode ) . assoc ( shift + <int> , hash , key , val , addedLeaf ) ; if ( n = = valOrNode ) return this ; return new BitmapIndexedNode ( null , bitmap , cloneAndSet ( array , <int> * idx + <int> , n ) ) ; } if ( Util . equiv ( key , keyOrNull ) ) { if ( val = = valOrNode ) return this ; return new BitmapIndexedNode ( null , bitmap , cloneAndSet ( array , <int> * idx + <int> , val ) ) ; } addedLeaf . val = addedLeaf ; return new BitmapIndexedNode ( null , bitmap , cloneAndSet ( array , <int> * idx , null , <int> * idx + <int> , createNode ( shift + <int> , keyOrNull , valOrNode , hash , key , val ) ) ) ; } else { int n = Integer . bitCount ( bitmap ) ; if ( n > = <int> ) { INode [ ] nodes = new INode [ <int> ] ; int jdx = mask ( hash , shift ) ; nodes [ jdx ] = EMPTY . assoc ( shift + <int> , hash , key , val , addedLeaf ) ; int j = <int> ; for ( int i = <int> ; i < <int> ; i + + ) if ( ( ( bitmap > > > i ) & <int> ) ! = <int> ) { if ( array [ j ] = = null ) nodes [ i ] = ( INode ) array [ j + <int> ] ; else nodes [ i ] = EMPTY . assoc ( shift + <int> , hash ( array [ j ] ) , array [ j ] , array [ j + <int> ] , addedLeaf ) ; j + = <int> ; } return new ArrayNode ( null , n + <int> , nodes ) ; } else { Object [ ] newArray = new Object [ <int> * ( n + <int> ) ] ; System . arraycopy ( array , <int> , newArray , <int> , <int> * idx ) ; newArray [ <int> * idx ] = key ; addedLeaf . val = addedLeaf ; newArray [ <int> * idx + <int> ] = val ; System . arraycopy ( array , <int> * idx , newArray , <int> * ( idx + <int> ) , <int> * ( n - idx ) ) ; return new BitmapIndexedNode ( null , bitmap | bit , newArray ) ; } } } public INode without ( int shift , int hash , Object key ) { int bit = bitpos ( hash , shift ) ; if ( ( bitmap & bit ) = = <int> ) return this ; int idx = index ( bit ) ; Object keyOrNull = array [ <int> * idx ] ; Object valOrNode = array [ <int> * idx + <int> ] ; if ( keyOrNull = = null ) { INode n = ( ( INode ) valOrNode ) . without ( shift + <int> , hash , key ) ; if ( n = = valOrNode ) return this ; if ( n ! = null ) return new BitmapIndexedNode ( null , bitmap , cloneAndSet ( array , <int> * idx + <int> , n ) ) ; if ( bitmap = = bit ) return null ; return new BitmapIndexedNode ( null , bitmap ^ bit , removePair ( array , idx ) ) ; } if ( Util . equiv ( key , keyOrNull ) ) return new BitmapIndexedNode ( null , bitmap ^ bit , removePair ( array , idx ) ) ; return this ; } public IMapEntry find ( int shift , int hash , Object key ) { int bit = bitpos ( hash , shift ) ; if ( ( bitmap & bit ) = = <int> ) return null ; int idx = index ( bit ) ; Object keyOrNull = array [ <int> * idx ] ; Object valOrNode = array [ <int> * idx + <int> ] ; if ( keyOrNull = = null ) return ( ( INode ) valOrNode ) . find ( shift + <int> , hash , key ) ; if ( Util . equiv ( key , keyOrNull ) ) return ( IMapEntry ) Tuple . create ( keyOrNull , valOrNode ) ; return null ; } public Object find ( int shift , int hash , Object key , Object notFound ) { int bit = bitpos ( hash , shift ) ; if ( ( bitmap & bit ) = = <int> ) return notFound ; int idx = index ( bit ) ; Object keyOrNull = array [ <int> * idx ] ; Object valOrNode = array [ <int> * idx + <int> ] ; if ( keyOrNull = = null ) return ( ( INode ) valOrNode ) . find ( shift + <int> , hash , key , notFound ) ; if ( Util . equiv ( key , keyOrNull ) ) return valOrNode ; return notFound ; } public ISeq nodeSeq ( ) { return NodeSeq . create ( array ) ; } public Iterator iterator ( IFn f ) { return new NodeIter ( array , f ) ; } public Object kvreduce ( IFn f , Object init ) { return NodeSeq . kvreduce ( array , f , init ) ; } public Object fold ( IFn combinef , IFn reducef , IFn fjtask , IFn fjfork , IFn fjjoin ) { return NodeSeq . kvreduce ( array , reducef , combinef . invoke ( ) ) ; } private BitmapIndexedNode ensureEditable ( AtomicReference < Thread > edit ) { if ( this . edit = = edit ) return this ; int n = Integer . bitCount ( bitmap ) ; Object [ ] newArray = new Object [ n > = <int> ? <int> * ( n + <int> ) : <int> ] ; System . arraycopy ( array , <int> , newArray , <int> , <int> * n ) ; return new BitmapIndexedNode ( edit , bitmap , newArray ) ; } private BitmapIndexedNode editAndSet ( AtomicReference < Thread > edit , int i , Object a ) { BitmapIndexedNode editable = ensureEditable ( edit ) ; editable . array [ i ] = a ; return editable ; } private BitmapIndexedNode editAndSet ( AtomicReference < Thread > edit , int i , Object a , int j , Object b ) { BitmapIndexedNode editable = ensureEditable ( edit ) ; editable . array [ i ] = a ; editable . array [ j ] = b ; return editable ; } private BitmapIndexedNode editAndRemovePair ( AtomicReference < Thread > edit , int bit , int i ) { if ( bitmap = = bit ) return null ; BitmapIndexedNode editable = ensureEditable ( edit ) ; editable . bitmap ^ = bit ; System . arraycopy ( editable . array , <int> * ( i + <int> ) , editable . array , <int> * i , editable . array . length - <int> * ( i + <int> ) ) ; editable . array [ editable . array . length - <int> ] = null ; editable . array [ editable . array . length - <int> ] = null ; return editable ; } public INode assoc ( AtomicReference < Thread > edit , int shift , int hash , Object key , Object val , Box addedLeaf ) { int bit = bitpos ( hash , shift ) ; int idx = index ( bit ) ; if ( ( bitmap & bit ) ! = <int> ) { Object keyOrNull = array [ <int> * idx ] ; Object valOrNode = array [ <int> * idx + <int> ] ; if ( keyOrNull = = null ) { INode n = ( ( INode ) valOrNode ) . assoc ( edit , shift + <int> , hash , key , val , addedLeaf ) ; if ( n = = valOrNode ) return this ; return editAndSet ( edit , <int> * idx + <int> , n ) ; } if ( Util . equiv ( key , keyOrNull ) ) { if ( val = = valOrNode ) return this ; return editAndSet ( edit , <int> * idx + <int> , val ) ; } addedLeaf . val = addedLeaf ; return editAndSet ( edit , <int> * idx , null , <int> * idx + <int> , createNode ( edit , shift + <int> , keyOrNull , valOrNode , hash , key , val ) ) ; } else { int n = Integer . bitCount ( bitmap ) ; if ( n * <int> < array . length ) { addedLeaf . val = addedLeaf ; BitmapIndexedNode editable = ensureEditable ( edit ) ; System . arraycopy ( editable . array , <int> * idx , editable . array , <int> * ( idx + <int> ) , <int> * ( n - idx ) ) ; editable . array [ <int> * idx ] = key ; editable . array [ <int> * idx + <int> ] = val ; editable . bitmap | = bit ; return editable ; } if ( n > = <int> ) { INode [ ] nodes = new INode [ <int> ] ; int jdx = mask ( hash , shift ) ; nodes [ jdx ] = EMPTY . assoc ( edit , shift + <int> , hash , key , val , addedLeaf ) ; int j = <int> ; for ( int i = <int> ; i < <int> ; i + + ) if ( ( ( bitmap > > > i ) & <int> ) ! = <int> ) { if ( array [ j ] = = null ) nodes [ i ] = ( INode ) array [ j + <int> ] ; else nodes [ i ] = EMPTY . assoc ( edit , shift + <int> , hash ( array [ j ] ) , array [ j ] , array [ j + <int> ] , addedLeaf ) ; j + = <int> ; } return new ArrayNode ( edit , n + <int> , nodes ) ; } else { Object [ ] newArray = new Object [ <int> * ( n + <int> ) ] ; System . arraycopy ( array , <int> , newArray , <int> , <int> * idx ) ; newArray [ <int> * idx ] = key ; addedLeaf . val = addedLeaf ; newArray [ <int> * idx + <int> ] = val ; System . arraycopy ( array , <int> * idx , newArray , <int> * ( idx + <int> ) , <int> * ( n - idx ) ) ; BitmapIndexedNode editable = ensureEditable ( edit ) ; editable . array = newArray ; editable . bitmap | = bit ; return editable ; } } } public INode without ( AtomicReference < Thread > edit , int shift , int hash , Object key , Box removedLeaf ) { int bit = bitpos ( hash , shift ) ; if ( ( bitmap & bit ) = = <int> ) return this ; int idx = index ( bit ) ; Object keyOrNull = array [ <int> * idx ] ; Object valOrNode = array [ <int> * idx + <int> ] ; if ( keyOrNull = = null ) { INode n = ( ( INode ) valOrNode ) . without ( edit , shift + <int> , hash , key , removedLeaf ) ; if ( n = = valOrNode ) return this ; if ( n ! = null ) return editAndSet ( edit , <int> * idx + <int> , n ) ; if ( bitmap = = bit ) return null ; return editAndRemovePair ( edit , bit , idx ) ; } if ( Util . equiv ( key , keyOrNull ) ) { removedLeaf . val = removedLeaf ; return editAndRemovePair ( edit , bit , idx ) ; } return this ; } } final static class HashCollisionNode implements INode { final int hash ; int count ; Object [ ] array ; final AtomicReference < Thread > edit ; HashCollisionNode ( AtomicReference < Thread > edit , int hash , int count , Object . . . array ) { this . edit = edit ; this . hash = hash ; this . count = count ; this . array = array ; } public INode assoc ( int shift , int hash , Object key , Object val , Box addedLeaf ) { if ( hash = = this . hash ) { int idx = findIndex ( key ) ; if ( idx ! = - <int> ) { if ( array [ idx + <int> ] = = val ) return this ; return new HashCollisionNode ( null , hash , count , cloneAndSet ( array , idx + <int> , val ) ) ; } Object [ ] newArray = new Object [ <int> * ( count + <int> ) ] ; System . arraycopy ( array , <int> , newArray , <int> , <int> * count ) ; newArray [ <int> * count ] = key ; newArray [ <int> * count + <int> ] = val ; addedLeaf . val = addedLeaf ; return new HashCollisionNode ( edit , hash , count + <int> , newArray ) ; } return new BitmapIndexedNode ( null , bitpos ( this . hash , shift ) , new Object [ ] { null , this } ) . assoc ( shift , hash , key , val , addedLeaf ) ; } public INode without ( int shift , int hash , Object key ) { int idx = findIndex ( key ) ; if ( idx = = - <int> ) return this ; if ( count = = <int> ) return null ; return new HashCollisionNode ( null , hash , count - <int> , removePair ( array , idx / <int> ) ) ; } public IMapEntry find ( int shift , int hash , Object key ) { int idx = findIndex ( key ) ; if ( idx < <int> ) return null ; if ( Util . equiv ( key , array [ idx ] ) ) return ( IMapEntry ) Tuple . create ( array [ idx ] , array [ idx + <int> ] ) ; return null ; } public Object find ( int shift , int hash , Object key , Object notFound ) { int idx = findIndex ( key ) ; if ( idx < <int> ) return notFound ; if ( Util . equiv ( key , array [ idx ] ) ) return array [ idx + <int> ] ; return notFound ; } public ISeq nodeSeq ( ) { return NodeSeq . create ( array ) ; } public Iterator iterator ( IFn f ) { return new NodeIter ( array , f ) ; } public Object kvreduce ( IFn f , Object init ) { return NodeSeq . kvreduce ( array , f , init ) ; } public Object fold ( IFn combinef , IFn reducef , IFn fjtask , IFn fjfork , IFn fjjoin ) { return NodeSeq . kvreduce ( array , reducef , combinef . invoke ( ) ) ; } public int findIndex ( Object key ) { for ( int i = <int> ; i < <int> * count ; i + = <int> ) { if ( Util . equiv ( key , array [ i ] ) ) return i ; } return - <int> ; } private HashCollisionNode ensureEditable ( AtomicReference < Thread > edit ) { if ( this . edit = = edit ) return this ; Object [ ] newArray = new Object [ <int> * ( count + <int> ) ] ; System . arraycopy ( array , <int> , newArray , <int> , <int> * count ) ; return new HashCollisionNode ( edit , hash , count , newArray ) ; } private HashCollisionNode ensureEditable ( AtomicReference < Thread > edit , int count , Object [ ] array ) { if ( this . edit = = edit ) { this . array = array ; this . count = count ; return this ; } return new HashCollisionNode ( edit , hash , count , array ) ; } private HashCollisionNode editAndSet ( AtomicReference < Thread > edit , int i , Object a ) { HashCollisionNode editable = ensureEditable ( edit ) ; editable . array [ i ] = a ; return editable ; } private HashCollisionNode editAndSet ( AtomicReference < Thread > edit , int i , Object a , int j , Object b ) { HashCollisionNode editable = ensureEditable ( edit ) ; editable . array [ i ] = a ; editable . array [ j ] = b ; return editable ; } public INode assoc ( AtomicReference < Thread > edit , int shift , int hash , Object key , Object val , Box addedLeaf ) { if ( hash = = this . hash ) { int idx = findIndex ( key ) ; if ( idx ! = - <int> ) { if ( array [ idx + <int> ] = = val ) return this ; return editAndSet ( edit , idx + <int> , val ) ; } if ( array . length > <int> * count ) { addedLeaf . val = addedLeaf ; HashCollisionNode editable = editAndSet ( edit , <int> * count , key , <int> * count + <int> , val ) ; editable . count + + ; return editable ; } Object [ ] newArray = new Object [ array . length + <int> ] ; System . arraycopy ( array , <int> , newArray , <int> , array . length ) ; newArray [ array . length ] = key ; newArray [ array . length + <int> ] = val ; addedLeaf . val = addedLeaf ; return ensureEditable ( edit , count + <int> , newArray ) ; } return new BitmapIndexedNode ( edit , bitpos ( this . hash , shift ) , new Object [ ] { null , this , null , null } ) . assoc ( edit , shift , hash , key , val , addedLeaf ) ; } public INode without ( AtomicReference < Thread > edit , int shift , int hash , Object key , Box removedLeaf ) { int idx = findIndex ( key ) ; if ( idx = = - <int> ) return this ; removedLeaf . val = removedLeaf ; if ( count = = <int> ) return null ; HashCollisionNode editable = ensureEditable ( edit ) ; editable . array [ idx ] = editable . array [ <int> * count - <int> ] ; editable . array [ idx + <int> ] = editable . array [ <int> * count - <int> ] ; editable . array [ <int> * count - <int> ] = editable . array [ <int> * count - <int> ] = null ; editable . count - - ; return editable ; } } private static INode [ ] cloneAndSet ( INode [ ] array , int i , INode a ) { INode [ ] clone = array . clone ( ) ; clone [ i ] = a ; return clone ; } private static Object [ ] cloneAndSet ( Object [ ] array , int i , Object a ) { Object [ ] clone = array . clone ( ) ; clone [ i ] = a ; return clone ; } private static Object [ ] cloneAndSet ( Object [ ] array , int i , Object a , int j , Object b ) { Object [ ] clone = array . clone ( ) ; clone [ i ] = a ; clone [ j ] = b ; return clone ; } private static Object [ ] removePair ( Object [ ] array , int i ) { Object [ ] newArray = new Object [ array . length - <int> ] ; System . arraycopy ( array , <int> , newArray , <int> , <int> * i ) ; System . arraycopy ( array , <int> * ( i + <int> ) , newArray , <int> * i , newArray . length - <int> * i ) ; return newArray ; } private static INode createNode ( int shift , Object key1 , Object val1 , int key2hash , Object key2 , Object val2 ) { int key1hash = hash ( key1 ) ; if ( key1hash = = key2hash ) return new HashCollisionNode ( null , key1hash , <int> , new Object [ ] { key1 , val1 , key2 , val2 } ) ; Box addedLeaf = new Box ( null ) ; AtomicReference < Thread > edit = new AtomicReference < Thread > ( ) ; return BitmapIndexedNode . EMPTY . assoc ( edit , shift , key1hash , key1 , val1 , addedLeaf ) . assoc ( edit , shift , key2hash , key2 , val2 , addedLeaf ) ; } private static INode createNode ( AtomicReference < Thread > edit , int shift , Object key1 , Object val1 , int key2hash , Object key2 , Object val2 ) { int key1hash = hash ( key1 ) ; if ( key1hash = = key2hash ) return new HashCollisionNode ( null , key1hash , <int> , new Object [ ] { key1 , val1 , key2 , val2 } ) ; Box addedLeaf = new Box ( null ) ; return BitmapIndexedNode . EMPTY . assoc ( edit , shift , key1hash , key1 , val1 , addedLeaf ) . assoc ( edit , shift , key2hash , key2 , val2 , addedLeaf ) ; } private static int bitpos ( int hash , int shift ) { return <int> < < mask ( hash , shift ) ; } static final class NodeIter implements Iterator { private static final Object NULL = new Object ( ) ; final Object [ ] array ; final IFn f ; private int i = <int> ; private Object nextEntry = NULL ; private Iterator nextIter ; NodeIter ( Object [ ] array , IFn f ) { this . array = array ; this . f = f ; } private boolean advance ( ) { while ( i < array . length ) { Object key = array [ i ] ; Object nodeOrVal = array [ i + <int> ] ; i + = <int> ; if ( key ! = null ) { nextEntry = f . invoke ( key , nodeOrVal ) ; return true ; } else if ( nodeOrVal ! = null ) { Iterator iter = ( ( INode ) nodeOrVal ) . iterator ( f ) ; if ( iter ! = null & & iter . hasNext ( ) ) { nextIter = iter ; return true ; } } } return false ; } public boolean hasNext ( ) { if ( nextEntry ! = NULL | | nextIter ! = null ) return true ; return advance ( ) ; } public Object next ( ) { Object ret = nextEntry ; if ( ret ! = NULL ) { nextEntry = NULL ; return ret ; } else if ( nextIter ! = null ) { ret = nextIter . next ( ) ; if ( ! nextIter . hasNext ( ) ) nextIter = null ; return ret ; } else if ( advance ( ) ) return next ( ) ; throw new NoSuchElementException ( ) ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } static final class NodeSeq extends ASeq { final Object [ ] array ; final int i ; final ISeq s ; NodeSeq ( Object [ ] array , int i ) { this ( null , array , i , null ) ; } static ISeq create ( Object [ ] array ) { return create ( array , <int> , null ) ; } static public Object kvreduce ( Object [ ] array , IFn f , Object init ) { for ( int i = <int> ; i < array . length ; i + = <int> ) { if ( array [ i ] ! = null ) init = f . invoke ( init , array [ i ] , array [ i + <int> ] ) ; else { INode node = ( INode ) array [ i + <int> ] ; if ( node ! = null ) init = node . kvreduce ( f , init ) ; } if ( RT . isReduced ( init ) ) return init ; } return init ; } private static ISeq create ( Object [ ] array , int i , ISeq s ) { if ( s ! = null ) return new NodeSeq ( null , array , i , s ) ; for ( int j = i ; j < array . length ; j + = <int> ) { if ( array [ j ] ! = null ) return new NodeSeq ( null , array , j , null ) ; INode node = ( INode ) array [ j + <int> ] ; if ( node ! = null ) { ISeq nodeSeq = node . nodeSeq ( ) ; if ( nodeSeq ! = null ) return new NodeSeq ( null , array , j + <int> , nodeSeq ) ; } } return null ; } NodeSeq ( IPersistentMap meta , Object [ ] array , int i , ISeq s ) { super ( meta ) ; this . array = array ; this . i = i ; this . s = s ; } public Obj withMeta ( IPersistentMap meta ) { return new NodeSeq ( meta , array , i , s ) ; } public Object first ( ) { if ( s ! = null ) return s . first ( ) ; return Tuple . create ( array [ i ] , array [ i + <int> ] ) ; } public ISeq next ( ) { if ( s ! = null ) return create ( array , i , s . next ( ) ) ; return create ( array , i + <int> , null ) ; } } } 
