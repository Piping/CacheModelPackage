package com . google . common . collect ; import static com . google . common . util . concurrent . Uninterruptibles . awaitUninterruptibly ; import static java . util . concurrent . TimeUnit . HOURS ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . collect . MapMaker . RemovalNotification ; import com . google . common . collect . MapMakerInternalMapTest . QueuingRemovalListener ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . atomic . AtomicInteger ; @GwtCompatible ( emulated = true ) public class MapMakerTest extends TestCase { @GwtIncompatible ( <str> ) public void testNullParameters ( ) throws Exception { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicInstanceMethods ( new MapMaker ( ) ) ; } @GwtIncompatible ( <str> ) public void testRemovalNotification_clear ( ) throws InterruptedException { final CountDownLatch computingLatch = new CountDownLatch ( <int> ) ; Function < String , String > computingFunction = new DelayingIdentityLoader < String > ( computingLatch ) ; QueuingRemovalListener < String , String > listener = new QueuingRemovalListener < String , String > ( ) ; @SuppressWarnings ( <str> ) final ConcurrentMap < String , String > map = new MapMaker ( ) . concurrencyLevel ( <int> ) . removalListener ( listener ) . makeComputingMap ( computingFunction ) ; map . put ( <str> , <str> ) ; final CountDownLatch computationStarted = new CountDownLatch ( <int> ) ; final CountDownLatch computationComplete = new CountDownLatch ( <int> ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { computationStarted . countDown ( ) ; map . get ( <str> ) ; computationComplete . countDown ( ) ; } } ) . start ( ) ; computationStarted . await ( ) ; map . clear ( ) ; computingLatch . countDown ( ) ; computationComplete . await ( ) ; assertEquals ( <int> , listener . size ( ) ) ; RemovalNotification < String , String > notification = listener . remove ( ) ; assertEquals ( <str> , notification . getKey ( ) ) ; assertEquals ( <str> , notification . getValue ( ) ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( <str> , map . get ( <str> ) ) ; } @GwtIncompatible ( <str> ) public void testRemovalNotification_clear_basher ( ) throws InterruptedException { CountDownLatch computationLatch = new CountDownLatch ( <int> ) ; QueuingRemovalListener < String , String > listener = new QueuingRemovalListener < String , String > ( ) ; @SuppressWarnings ( <str> ) final Map < String , String > map = new MapMaker ( ) . removalListener ( listener ) . concurrencyLevel ( <int> ) . makeComputingMap ( new DelayingIdentityLoader < String > ( computationLatch ) ) ; int nThreads = <int> ; int nTasks = <int> ; int nSeededEntries = <int> ; Set < String > expectedKeys = Sets . newHashSetWithExpectedSize ( nTasks + nSeededEntries ) ; for ( int i = <int> ; i < nSeededEntries ; i + + ) { String s = <str> + i ; map . put ( s , s ) ; expectedKeys . add ( s ) ; } final AtomicInteger computedCount = new AtomicInteger ( ) ; ExecutorService threadPool = Executors . newFixedThreadPool ( nThreads ) ; final CountDownLatch tasksFinished = new CountDownLatch ( nTasks ) ; for ( int i = <int> ; i < nTasks ; i + + ) { final String s = <str> + i ; threadPool . submit ( new Runnable ( ) { @Override public void run ( ) { map . get ( s ) ; computedCount . incrementAndGet ( ) ; tasksFinished . countDown ( ) ; } } ) ; expectedKeys . add ( s ) ; } computationLatch . countDown ( ) ; while ( computedCount . get ( ) < nThreads ) { Thread . yield ( ) ; } map . clear ( ) ; tasksFinished . await ( ) ; Map < String , String > removalNotifications = Maps . newHashMap ( ) ; for ( RemovalNotification < String , String > notification : listener ) { removalNotifications . put ( notification . getKey ( ) , notification . getValue ( ) ) ; assertEquals ( <str> , notification . getKey ( ) , notification . getValue ( ) ) ; } for ( int i = <int> ; i < nSeededEntries ; i + + ) { assertEquals ( <str> + i , removalNotifications . get ( <str> + i ) ) ; } assertEquals ( expectedKeys , Sets . union ( map . keySet ( ) , removalNotifications . keySet ( ) ) ) ; assertTrue ( Sets . intersection ( map . keySet ( ) , removalNotifications . keySet ( ) ) . isEmpty ( ) ) ; } @GwtIncompatible ( <str> ) static final class DelayingIdentityLoader < T > implements Function < T , T > { private final CountDownLatch delayLatch ; DelayingIdentityLoader ( CountDownLatch delayLatch ) { this . delayLatch = delayLatch ; } @Override public T apply ( T key ) { awaitUninterruptibly ( delayLatch ) ; return key ; } } public static class MakerTest extends TestCase { public void testInitialCapacity_negative ( ) { MapMaker maker = new MapMaker ( ) ; try { maker . initialCapacity ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void xtestInitialCapacity_setTwice ( ) { MapMaker maker = new MapMaker ( ) . initialCapacity ( <int> ) ; try { maker . initialCapacity ( <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @SuppressWarnings ( <str> ) public void testExpiration_setTwice ( ) { MapMaker maker = new MapMaker ( ) . expireAfterWrite ( <int> , HOURS ) ; try { maker . expireAfterWrite ( <int> , HOURS ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testMaximumSize_setTwice ( ) { MapMaker maker = new MapMaker ( ) . maximumSize ( <int> ) ; try { maker . maximumSize ( <int> ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testReturnsPlainConcurrentHashMapWhenPossible ( ) { Map < ? , ? > map = new MapMaker ( ) . initialCapacity ( <int> ) . makeMap ( ) ; assertTrue ( map instanceof ConcurrentHashMap ) ; } } public static class MaximumSizeTest extends TestCase { public void testPut_sizeIsZero ( ) { ConcurrentMap < Object , Object > map = new MapMaker ( ) . maximumSize ( <int> ) . makeMap ( ) ; assertEquals ( <int> , map . size ( ) ) ; map . put ( new Object ( ) , new Object ( ) ) ; assertEquals ( <int> , map . size ( ) ) ; } public void testSizeBasedEviction ( ) { int numKeys = <int> ; int mapSize = <int> ; ConcurrentMap < Object , Object > map = new MapMaker ( ) . maximumSize ( mapSize ) . makeMap ( ) ; for ( int i = <int> ; i < numKeys ; i + + ) { map . put ( i , i ) ; } assertEquals ( mapSize , map . size ( ) ) ; for ( int i = numKeys - mapSize ; i < mapSize ; i + + ) { assertTrue ( map . containsKey ( i ) ) ; } } } public static class RecursiveComputationTest extends TestCase { Function < Integer , String > recursiveComputer = new Function < Integer , String > ( ) { @Override public String apply ( Integer key ) { if ( key > <int> ) { return key + <str> + recursiveMap . get ( key - <int> ) ; } else { return <str> ; } } } ; ConcurrentMap < Integer , String > recursiveMap = new MapMaker ( ) . makeComputingMap ( recursiveComputer ) ; public void testRecursiveComputation ( ) { assertEquals ( <str> , recursiveMap . get ( <int> ) ) ; } } public static class ComputingTest extends TestCase { public void testComputerThatReturnsNull ( ) { ConcurrentMap < Integer , String > map = new MapMaker ( ) . makeComputingMap ( new Function < Integer , String > ( ) { @Override public String apply ( Integer key ) { return null ; } } ) ; try { map . get ( <int> ) ; fail ( ) ; } catch ( NullPointerException e ) { } } public void testRuntimeException ( ) { final RuntimeException e = new RuntimeException ( ) ; ConcurrentMap < Object , Object > map = new MapMaker ( ) . makeComputingMap ( new Function < Object , Object > ( ) { @Override public Object apply ( Object from ) { throw e ; } } ) ; try { map . get ( new Object ( ) ) ; fail ( ) ; } catch ( ComputationException ce ) { assertSame ( e , ce . getCause ( ) ) ; } } } } 
