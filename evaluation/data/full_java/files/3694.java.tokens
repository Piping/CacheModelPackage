package org . eclipse . debug . internal . core ; import java . io . IOException ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . Writer ; import java . util . ArrayList ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . eclipse . debug . core . DebugPlugin ; import org . w3c . dom . Attr ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . NamedNodeMap ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . w3c . dom . Text ; import org . xml . sax . InputSource ; import org . xml . sax . SAXException ; public final class XMLMemento { private Document factory ; private Element element ; public static XMLMemento createReadRoot ( Reader reader ) throws Exception { return createReadRoot ( reader , null ) ; } public static XMLMemento createReadRoot ( Reader reader , String baseDir ) throws Exception { String errorMessage = null ; Exception exception = null ; try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder parser = factory . newDocumentBuilder ( ) ; InputSource source = new InputSource ( reader ) ; if ( baseDir ! = null ) { source . setSystemId ( baseDir ) ; } Document document = parser . parse ( source ) ; NodeList list = document . getChildNodes ( ) ; for ( int i = <int> ; i < list . getLength ( ) ; i + + ) { Node node = list . item ( i ) ; if ( node instanceof Element ) { return new XMLMemento ( document , ( Element ) node ) ; } } } catch ( ParserConfigurationException e ) { exception = e ; } catch ( IOException e ) { exception = e ; } catch ( SAXException e ) { exception = e ; } String problemText = null ; if ( exception ! = null ) { problemText = exception . getMessage ( ) ; } if ( problemText = = null | | problemText . length ( ) = = <int> ) { problemText = errorMessage ! = null ? errorMessage : <str> ; } throw new Exception ( problemText , exception ) ; } public static XMLMemento createWriteRoot ( String type ) { Document document ; try { document = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; Element element = document . createElement ( type ) ; document . appendChild ( element ) ; return new XMLMemento ( document , element ) ; } catch ( ParserConfigurationException e ) { throw new Error ( e . getMessage ( ) ) ; } } public XMLMemento ( Document document , Element element ) { super ( ) ; this . factory = document ; this . element = element ; } public XMLMemento createChild ( String type ) { Element child = factory . createElement ( type ) ; element . appendChild ( child ) ; return new XMLMemento ( factory , child ) ; } public XMLMemento createChild ( String type , String id ) { Element child = factory . createElement ( type ) ; child . setAttribute ( IMementoConstants . TAG_ID , id = = null ? <str> : id ) ; element . appendChild ( child ) ; return new XMLMemento ( factory , child ) ; } public XMLMemento copyChild ( XMLMemento child ) { Element childElement = child . element ; Element newElement = ( Element ) factory . importNode ( childElement , true ) ; element . appendChild ( newElement ) ; return new XMLMemento ( factory , newElement ) ; } public XMLMemento getChild ( String type ) { NodeList nodes = element . getChildNodes ( ) ; int size = nodes . getLength ( ) ; if ( size = = <int> ) { return null ; } for ( int nX = <int> ; nX < size ; nX + + ) { Node node = nodes . item ( nX ) ; if ( node instanceof Element ) { Element element1 = ( Element ) node ; if ( element1 . getNodeName ( ) . equals ( type ) ) { return new XMLMemento ( factory , element1 ) ; } } } return null ; } public XMLMemento [ ] getChildren ( String type ) { NodeList nodes = element . getChildNodes ( ) ; int size = nodes . getLength ( ) ; if ( size = = <int> ) { return new XMLMemento [ <int> ] ; } ArrayList < Element > list = new ArrayList < Element > ( size ) ; for ( int nX = <int> ; nX < size ; nX + + ) { Node node = nodes . item ( nX ) ; if ( node instanceof Element ) { Element element1 = ( Element ) node ; if ( element1 . getNodeName ( ) . equals ( type ) ) { list . add ( element1 ) ; } } } size = list . size ( ) ; XMLMemento [ ] results = new XMLMemento [ size ] ; for ( int x = <int> ; x < size ; x + + ) { results [ x ] = new XMLMemento ( factory , list . get ( x ) ) ; } return results ; } public Float getFloat ( String key ) { Attr attr = element . getAttributeNode ( key ) ; if ( attr = = null ) { return null ; } String strValue = attr . getValue ( ) ; try { return new Float ( strValue ) ; } catch ( NumberFormatException e ) { DebugPlugin . logMessage ( <str> + key + <str> + strValue , e ) ; return null ; } } public String getType ( ) { return element . getNodeName ( ) ; } public String getID ( ) { return element . getAttribute ( IMementoConstants . TAG_ID ) ; } public Integer getInteger ( String key ) { Attr attr = element . getAttributeNode ( key ) ; if ( attr = = null ) { return null ; } String strValue = attr . getValue ( ) ; try { return Integer . valueOf ( strValue ) ; } catch ( NumberFormatException e ) { DebugPlugin . logMessage ( <str> + key + <str> + strValue , e ) ; return null ; } } public String getString ( String key ) { Attr attr = element . getAttributeNode ( key ) ; if ( attr = = null ) { return null ; } return attr . getValue ( ) ; } public Boolean getBoolean ( String key ) { Attr attr = element . getAttributeNode ( key ) ; if ( attr = = null ) { return null ; } return Boolean . valueOf ( attr . getValue ( ) ) ; } public String getTextData ( ) { Text textNode = getTextNode ( ) ; if ( textNode ! = null ) { return textNode . getData ( ) ; } return null ; } public String [ ] getAttributeKeys ( ) { NamedNodeMap map = element . getAttributes ( ) ; int size = map . getLength ( ) ; String [ ] attributes = new String [ size ] ; for ( int i = <int> ; i < size ; i + + ) { Node node = map . item ( i ) ; attributes [ i ] = node . getNodeName ( ) ; } return attributes ; } private Text getTextNode ( ) { NodeList nodes = element . getChildNodes ( ) ; int size = nodes . getLength ( ) ; if ( size = = <int> ) { return null ; } for ( int nX = <int> ; nX < size ; nX + + ) { Node node = nodes . item ( nX ) ; if ( node instanceof Text ) { return ( Text ) node ; } } return null ; } private void putElement ( Element element1 , boolean copyText ) { NamedNodeMap nodeMap = element1 . getAttributes ( ) ; int size = nodeMap . getLength ( ) ; for ( int i = <int> ; i < size ; i + + ) { Attr attr = ( Attr ) nodeMap . item ( i ) ; putString ( attr . getName ( ) , attr . getValue ( ) ) ; } NodeList nodes = element1 . getChildNodes ( ) ; size = nodes . getLength ( ) ; boolean needToCopyText = copyText ; for ( int i = <int> ; i < size ; i + + ) { Node node = nodes . item ( i ) ; if ( node instanceof Element ) { XMLMemento child = createChild ( node . getNodeName ( ) ) ; child . putElement ( ( Element ) node , true ) ; } else if ( node instanceof Text & & needToCopyText ) { putTextData ( ( ( Text ) node ) . getData ( ) ) ; needToCopyText = false ; } } } public void putFloat ( String key , float f ) { element . setAttribute ( key , String . valueOf ( f ) ) ; } public void putInteger ( String key , int n ) { element . setAttribute ( key , String . valueOf ( n ) ) ; } public void putMemento ( XMLMemento memento ) { putElement ( memento . element , false ) ; } public void putString ( String key , String value ) { if ( value = = null ) { return ; } element . setAttribute ( key , value ) ; } public void putBoolean ( String key , boolean value ) { element . setAttribute ( key , value ? <str> : <str> ) ; } public void putTextData ( String data ) { Text textNode = getTextNode ( ) ; if ( textNode = = null ) { textNode = factory . createTextNode ( data ) ; element . insertBefore ( textNode , element . getFirstChild ( ) ) ; } else { textNode . setData ( data ) ; } } public void save ( Writer writer ) throws IOException { try ( DOMWriter out = new DOMWriter ( writer ) ) { out . print ( element ) ; } } private static final class DOMWriter extends PrintWriter { private static final String XML_VERSION = <str> ; public DOMWriter ( Writer output ) { super ( output ) ; println ( XML_VERSION ) ; } public void print ( Element element ) { boolean hasChildren = element . hasChildNodes ( ) ; startTag ( element , hasChildren ) ; if ( hasChildren ) { boolean prevWasText = false ; NodeList children = element . getChildNodes ( ) ; for ( int i = <int> ; i < children . getLength ( ) ; i + + ) { Node node = children . item ( i ) ; if ( node instanceof Element ) { if ( ! prevWasText ) { println ( ) ; printTabulation ( ) ; } print ( ( Element ) children . item ( i ) ) ; prevWasText = false ; } else if ( node instanceof Text ) { print ( getEscaped ( node . getNodeValue ( ) ) ) ; prevWasText = true ; } } if ( ! prevWasText ) { println ( ) ; printTabulation ( ) ; } endTag ( element ) ; } } private void printTabulation ( ) { } private void startTag ( Element element , boolean hasChildren ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( <str> ) ; sb . append ( element . getTagName ( ) ) ; NamedNodeMap attributes = element . getAttributes ( ) ; for ( int i = <int> ; i < attributes . getLength ( ) ; i + + ) { Attr attribute = ( Attr ) attributes . item ( i ) ; sb . append ( <str> ) ; sb . append ( attribute . getName ( ) ) ; sb . append ( <str> ) ; sb . append ( getEscaped ( String . valueOf ( attribute . getValue ( ) ) ) ) ; sb . append ( <str> ) ; } sb . append ( hasChildren ? <str> : <str> ) ; print ( sb . toString ( ) ) ; } private void endTag ( Element element ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( <str> ) ; sb . append ( element . getNodeName ( ) ) ; sb . append ( <str> ) ; print ( sb . toString ( ) ) ; } private static void appendEscapedChar ( StringBuffer buffer , char c ) { String replacement = getReplacement ( c ) ; if ( replacement ! = null ) { buffer . append ( <str> ) ; buffer . append ( replacement ) ; buffer . append ( <str> ) ; } else if ( c = = <int> | | c = = <int> | | c = = <int> | | c > = <int> ) { buffer . append ( c ) ; } } private static String getEscaped ( String s ) { StringBuffer result = new StringBuffer ( s . length ( ) + <int> ) ; for ( int i = <int> ; i < s . length ( ) ; + + i ) { appendEscapedChar ( result , s . charAt ( i ) ) ; } return result . toString ( ) ; } private static String getReplacement ( char c ) { switch ( c ) { case <str> : return <str> ; case <str> : return <str> ; case <str> : return <str> ; case <str> : return <str> ; case <str> : return <str> ; case <str> : return <str> ; case <str> : return <str> ; case <str> : return <str> ; default : break ; } return null ; } } } 
