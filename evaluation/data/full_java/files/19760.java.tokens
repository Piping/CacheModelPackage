package io . netty . util ; import org . junit . Test ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; public class ThreadDeathWatcherTest { @Test ( timeout = <int> ) public void testWatch ( ) throws Exception { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final Thread t = new Thread ( ) { @Override public void run ( ) { for ( ; ; ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException ignore ) { break ; } } } } ; final Runnable task = new Runnable ( ) { @Override public void run ( ) { if ( ! t . isAlive ( ) ) { latch . countDown ( ) ; } } } ; try { ThreadDeathWatcher . watch ( t , task ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } t . start ( ) ; ThreadDeathWatcher . watch ( t , task ) ; assertThat ( latch . await ( <int> , TimeUnit . MILLISECONDS ) , is ( false ) ) ; t . interrupt ( ) ; latch . await ( ) ; } @Test ( timeout = <int> ) public void testUnwatch ( ) throws Exception { final AtomicBoolean run = new AtomicBoolean ( ) ; final Thread t = new Thread ( ) { @Override public void run ( ) { for ( ; ; ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException ignore ) { break ; } } } } ; final Runnable task = new Runnable ( ) { @Override public void run ( ) { run . set ( true ) ; } } ; t . start ( ) ; ThreadDeathWatcher . watch ( t , task ) ; ThreadDeathWatcher . unwatch ( t , task ) ; t . interrupt ( ) ; t . join ( ) ; assertThat ( ThreadDeathWatcher . awaitInactivity ( Long . MAX_VALUE , TimeUnit . SECONDS ) , is ( true ) ) ; assertThat ( run . get ( ) , is ( false ) ) ; } } 
