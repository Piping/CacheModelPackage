package org . apache . cassandra . cql3 ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Date ; import java . util . EnumMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . UUID ; import java . util . concurrent . ThreadLocalRandom ; import java . util . regex . Pattern ; import org . junit . Test ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . serializers . * ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . UUIDGen ; import static org . junit . Assert . assertEquals ; public class CQL3TypeLiteralTest { private static final Pattern QUOTE = Pattern . compile ( <str> ) ; static class Value { final String expected ; final CQL3Type cql3Type ; final ByteBuffer value ; Value ( String expected , CQL3Type cql3Type , ByteBuffer value ) { this . expected = expected ; this . cql3Type = cql3Type ; this . value = value ; } } static final Map < CQL3Type . Native , List < Value > > nativeTypeValues = new EnumMap < > ( CQL3Type . Native . class ) ; static void addNativeValue ( String expected , CQL3Type . Native cql3Type , ByteBuffer value ) { List < Value > l = nativeTypeValues . get ( cql3Type ) ; if ( l = = null ) nativeTypeValues . put ( cql3Type , l = new ArrayList < > ( ) ) ; l . add ( new Value ( expected , cql3Type , value ) ) ; } static { for ( int i = <int> ; i < <int> ; i + + ) { String v = randString ( true ) ; addNativeValue ( quote ( v ) , CQL3Type . Native . ASCII , AsciiSerializer . instance . serialize ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . ASCII , AsciiSerializer . instance . serialize ( <str> ) ) ; addNativeValue ( <str> , CQL3Type . Native . ASCII , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . ASCII , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { String v = randString ( false ) ; addNativeValue ( quote ( v ) , CQL3Type . Native . TEXT , UTF8Serializer . instance . serialize ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . TEXT , UTF8Serializer . instance . serialize ( <str> ) ) ; addNativeValue ( <str> , CQL3Type . Native . TEXT , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . TEXT , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { String v = randString ( false ) ; addNativeValue ( quote ( v ) , CQL3Type . Native . VARCHAR , UTF8Serializer . instance . serialize ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . VARCHAR , UTF8Serializer . instance . serialize ( <str> ) ) ; addNativeValue ( <str> , CQL3Type . Native . VARCHAR , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . VARCHAR , null ) ; addNativeValue ( <str> , CQL3Type . Native . BIGINT , LongType . instance . decompose ( <int> L ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { long v = randLong ( ) ; addNativeValue ( Long . toString ( v ) , CQL3Type . Native . BIGINT , LongType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . BIGINT , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . BIGINT , null ) ; addNativeValue ( <str> , CQL3Type . Native . COUNTER , LongType . instance . decompose ( <int> L ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { long v = randLong ( ) ; addNativeValue ( Long . toString ( v ) , CQL3Type . Native . COUNTER , LongType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . COUNTER , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . COUNTER , null ) ; addNativeValue ( <str> , CQL3Type . Native . INT , Int32Type . instance . decompose ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { int v = randInt ( ) ; addNativeValue ( Integer . toString ( v ) , CQL3Type . Native . INT , Int32Type . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . INT , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . INT , null ) ; addNativeValue ( <str> , CQL3Type . Native . SMALLINT , ShortType . instance . decompose ( ( short ) <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { short v = randShort ( ) ; addNativeValue ( Short . toString ( v ) , CQL3Type . Native . SMALLINT , ShortType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . SMALLINT , null ) ; addNativeValue ( <str> , CQL3Type . Native . TINYINT , ByteType . instance . decompose ( ( byte ) <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { byte v = randByte ( ) ; addNativeValue ( Short . toString ( v ) , CQL3Type . Native . TINYINT , ByteType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . TINYINT , null ) ; addNativeValue ( <str> , CQL3Type . Native . FLOAT , FloatType . instance . decompose ( ( float ) <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { float v = randFloat ( ) ; addNativeValue ( Float . toString ( v ) , CQL3Type . Native . FLOAT , FloatType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . FLOAT , FloatType . instance . decompose ( Float . NaN ) ) ; addNativeValue ( <str> , CQL3Type . Native . FLOAT , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . FLOAT , null ) ; addNativeValue ( <str> , CQL3Type . Native . DOUBLE , DoubleType . instance . decompose ( ( double ) <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { double v = randDouble ( ) ; addNativeValue ( Double . toString ( v ) , CQL3Type . Native . DOUBLE , DoubleType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . DOUBLE , DoubleType . instance . decompose ( Double . NaN ) ) ; addNativeValue ( <str> , CQL3Type . Native . DOUBLE , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . DOUBLE , null ) ; addNativeValue ( <str> , CQL3Type . Native . DECIMAL , DecimalType . instance . decompose ( BigDecimal . ZERO ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { BigDecimal v = BigDecimal . valueOf ( randDouble ( ) ) ; addNativeValue ( v . toString ( ) , CQL3Type . Native . DECIMAL , DecimalType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . DECIMAL , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . DECIMAL , null ) ; addNativeValue ( <str> , CQL3Type . Native . VARINT , IntegerType . instance . decompose ( BigInteger . ZERO ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { BigInteger v = BigInteger . valueOf ( randLong ( ) ) ; addNativeValue ( v . toString ( ) , CQL3Type . Native . VARINT , IntegerType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . VARINT , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . VARINT , null ) ; addNativeValue ( <str> , CQL3Type . Native . BOOLEAN , BooleanType . instance . decompose ( false ) ) ; addNativeValue ( <str> , CQL3Type . Native . BOOLEAN , BooleanType . instance . decompose ( true ) ) ; addNativeValue ( <str> , CQL3Type . Native . BOOLEAN , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . BOOLEAN , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { int v = randInt ( ) ; addNativeValue ( SimpleDateSerializer . instance . toString ( v ) , CQL3Type . Native . DATE , SimpleDateSerializer . instance . serialize ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . DATE , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { long v = randLong ( <int> * <int> * <int> * <int> * <int> * <int> ) ; addNativeValue ( TimeSerializer . instance . toString ( v ) , CQL3Type . Native . TIME , TimeSerializer . instance . serialize ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . TIME , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { long v = randLong ( ) ; addNativeValue ( TimestampSerializer . instance . toStringUTC ( new Date ( v ) ) , CQL3Type . Native . TIMESTAMP , TimestampType . instance . fromString ( Long . toString ( v ) ) ) ; } addNativeValue ( <str> , CQL3Type . Native . TIMESTAMP , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . TIMESTAMP , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { UUID v = UUIDGen . getTimeUUID ( randLong ( System . currentTimeMillis ( ) ) ) ; addNativeValue ( v . toString ( ) , CQL3Type . Native . TIMEUUID , TimeUUIDType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . TIMEUUID , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . TIMEUUID , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { UUID v = UUID . randomUUID ( ) ; addNativeValue ( v . toString ( ) , CQL3Type . Native . UUID , UUIDType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . UUID , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . UUID , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { ByteBuffer v = randBytes ( ) ; addNativeValue ( <str> + BytesSerializer . instance . toString ( v ) , CQL3Type . Native . BLOB , BytesType . instance . decompose ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . BLOB , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . BLOB , null ) ; for ( int i = <int> ; i < <int> ; i + + ) { InetAddress v ; try { v = InetAddress . getByAddress ( new byte [ ] { randByte ( ) , randByte ( ) , randByte ( ) , randByte ( ) } ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } addNativeValue ( v . getHostAddress ( ) , CQL3Type . Native . INET , InetAddressSerializer . instance . serialize ( v ) ) ; } addNativeValue ( <str> , CQL3Type . Native . INET , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; addNativeValue ( <str> , CQL3Type . Native . INET , null ) ; } @Test public void testNative ( ) { for ( int version = Server . MIN_SUPPORTED_VERSION ; version < = Server . CURRENT_VERSION ; version + + ) { for ( Map . Entry < CQL3Type . Native , List < Value > > entry : nativeTypeValues . entrySet ( ) ) { for ( Value value : entry . getValue ( ) ) { compareCqlLiteral ( version , value ) ; } } } } @Test public void testCollectionWithNatives ( ) { for ( int version = Server . MIN_SUPPORTED_VERSION ; version < = Server . CURRENT_VERSION ; version + + ) { for ( int n = <int> ; n < <int> ; n + + ) { Value value = generateCollectionValue ( version , randomCollectionType ( <int> ) , true ) ; compareCqlLiteral ( version , value ) ; } } } @Test public void testCollectionNullAndEmpty ( ) { for ( int version = Server . MIN_SUPPORTED_VERSION ; version < = Server . CURRENT_VERSION ; version + + ) { Value value = new Value ( <str> , ListType . getInstance ( UTF8Type . instance , false ) . asCQL3Type ( ) , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , SetType . getInstance ( UTF8Type . instance , false ) . asCQL3Type ( ) , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , MapType . getInstance ( UTF8Type . instance , UTF8Type . instance , false ) . asCQL3Type ( ) , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , ListType . getInstance ( UTF8Type . instance , true ) . asCQL3Type ( ) , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , SetType . getInstance ( UTF8Type . instance , true ) . asCQL3Type ( ) , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , MapType . getInstance ( UTF8Type . instance , UTF8Type . instance , true ) . asCQL3Type ( ) , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , ListType . getInstance ( UTF8Type . instance , false ) . asCQL3Type ( ) , null ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , SetType . getInstance ( UTF8Type . instance , false ) . asCQL3Type ( ) , null ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , MapType . getInstance ( UTF8Type . instance , UTF8Type . instance , false ) . asCQL3Type ( ) , null ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , ListType . getInstance ( UTF8Type . instance , true ) . asCQL3Type ( ) , null ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , SetType . getInstance ( UTF8Type . instance , true ) . asCQL3Type ( ) , null ) ; compareCqlLiteral ( version , value ) ; value = new Value ( <str> , MapType . getInstance ( UTF8Type . instance , UTF8Type . instance , true ) . asCQL3Type ( ) , null ) ; compareCqlLiteral ( version , value ) ; } } @Test public void testTupleWithNatives ( ) { for ( int version = Server . MIN_SUPPORTED_VERSION ; version < = Server . CURRENT_VERSION ; version + + ) { for ( int n = <int> ; n < <int> ; n + + ) { Value value = generateTupleValue ( version , randomTupleType ( <int> ) , true ) ; compareCqlLiteral ( version , value ) ; } } } @Test public void testUserDefinedWithNatives ( ) { for ( int version = Server . MIN_SUPPORTED_VERSION ; version < = Server . CURRENT_VERSION ; version + + ) { for ( int n = <int> ; n < <int> ; n + + ) { Value value = generateUserDefinedValue ( version , randomUserType ( <int> ) , true ) ; compareCqlLiteral ( version , value ) ; } } } @Test public void testNested ( ) { for ( int version = Server . MIN_SUPPORTED_VERSION ; version < = Server . CURRENT_VERSION ; version + + ) { for ( int n = <int> ; n < <int> ; n + + ) { Value value = randomNested ( version ) ; compareCqlLiteral ( version , value ) ; } } } static void compareCqlLiteral ( int version , Value value ) { ByteBuffer buffer = value . value ! = null ? value . value . duplicate ( ) : null ; String msg = <str> + value . cql3Type + <str> + value . cql3Type . getType ( ) + <str> + version + <str> + value . expected + <str> ; try { assertEquals ( msg , value . expected , value . cql3Type . asCQLLiteral ( buffer , version ) ) ; } catch ( RuntimeException e ) { throw new RuntimeException ( msg , e ) ; } } static Value randomNested ( int version ) { AbstractType type = randomNestedType ( <int> ) ; return generateAnyValue ( version , type . asCQL3Type ( ) ) ; } static AbstractType randomNestedType ( int level ) { if ( level = = <int> ) return randomNativeType ( ) ; switch ( randInt ( level = = <int> ? <int> : <int> ) ) { case <int> : return randomCollectionType ( level - <int> ) ; case <int> : return randomTupleType ( level - <int> ) ; case <int> : return randomUserType ( level - <int> ) ; case <int> : return randomNativeType ( ) ; } throw new AssertionError ( ) ; } static Value generateCollectionValue ( int version , CollectionType collectionType , boolean allowNull ) { StringBuilder expected = new StringBuilder ( ) ; ByteBuffer buffer ; if ( allowNull & & randBool ( <float> ) ) { if ( collectionType . isMultiCell ( ) ) { switch ( collectionType . kind ) { case LIST : expected . append ( <str> ) ; break ; case SET : case MAP : expected . append ( <str> ) ; break ; } } else { expected . append ( <str> ) ; } buffer = null ; } else { int size = randInt ( <int> ) ; CQL3Type elements ; CQL3Type values = null ; char bracketOpen ; char bracketClose ; switch ( collectionType . kind ) { case LIST : elements = ( ( ListType ) collectionType ) . getElementsType ( ) . asCQL3Type ( ) ; bracketOpen = <str> ; bracketClose = <str> ; break ; case SET : elements = ( ( SetType ) collectionType ) . getElementsType ( ) . asCQL3Type ( ) ; bracketOpen = <str> ; bracketClose = <str> ; break ; case MAP : elements = ( ( MapType ) collectionType ) . getKeysType ( ) . asCQL3Type ( ) ; values = ( ( MapType ) collectionType ) . getValuesType ( ) . asCQL3Type ( ) ; bracketOpen = <str> ; bracketClose = <str> ; break ; default : throw new AssertionError ( ) ; } expected . append ( bracketOpen ) ; Collection < ByteBuffer > buffers = new ArrayList < > ( ) ; Set < ByteBuffer > added = new HashSet < > ( ) ; for ( int i = <int> ; i < size ; i + + ) { Value el = generateAnyValue ( version , elements ) ; if ( ! added . add ( el . value ) ) continue ; buffers . add ( el . value . duplicate ( ) ) ; if ( expected . length ( ) > <int> ) expected . append ( <str> ) ; el . cql3Type . toCQLLiteral ( el . value , version , expected ) ; if ( collectionType . kind = = CollectionType . Kind . MAP ) { el = generateAnyValue ( version , values ) ; buffers . add ( el . value . duplicate ( ) ) ; expected . append ( <str> ) ; el . cql3Type . toCQLLiteral ( el . value , version , expected ) ; } } expected . append ( bracketClose ) ; buffer = CollectionSerializer . pack ( buffers , added . size ( ) , version ) ; } return new Value ( expected . toString ( ) , collectionType . asCQL3Type ( ) , buffer ) ; } static Value generateAnyValue ( int version , CQL3Type type ) { if ( type instanceof CQL3Type . Native ) return generateNativeValue ( type , false ) ; if ( type instanceof CQL3Type . Tuple ) return generateTupleValue ( version , ( TupleType ) type . getType ( ) , false ) ; if ( type instanceof CQL3Type . UserDefined ) return generateUserDefinedValue ( version , ( UserType ) type . getType ( ) , false ) ; if ( type instanceof CQL3Type . Collection ) return generateCollectionValue ( version , ( CollectionType ) type . getType ( ) , false ) ; throw new AssertionError ( ) ; } static Value generateTupleValue ( int version , TupleType tupleType , boolean allowNull ) { StringBuilder expected = new StringBuilder ( ) ; ByteBuffer buffer ; if ( allowNull & & randBool ( <float> ) ) { expected . append ( <str> ) ; buffer = null ; } else { expected . append ( <str> ) ; int fields = tupleType . size ( ) ; if ( randBool ( <float> ) ) fields = randInt ( fields ) ; ByteBuffer [ ] buffers = new ByteBuffer [ fields ] ; for ( int i = <int> ; i < fields ; i + + ) { AbstractType < ? > fieldType = tupleType . type ( i ) ; if ( i > <int> ) expected . append ( <str> ) ; if ( allowNull & & randBool ( <float> ) ) { expected . append ( <str> ) ; continue ; } Value value = generateAnyValue ( version , fieldType . asCQL3Type ( ) ) ; expected . append ( value . expected ) ; buffers [ i ] = value . value . duplicate ( ) ; } expected . append ( <str> ) ; buffer = TupleType . buildValue ( buffers ) ; } return new Value ( expected . toString ( ) , tupleType . asCQL3Type ( ) , buffer ) ; } static Value generateUserDefinedValue ( int version , UserType userType , boolean allowNull ) { StringBuilder expected = new StringBuilder ( ) ; ByteBuffer buffer ; if ( allowNull & & randBool ( <float> ) ) { expected . append ( <str> ) ; buffer = null ; } else { expected . append ( <str> ) ; int fields = userType . size ( ) ; if ( randBool ( <float> ) ) fields = randInt ( fields ) ; ByteBuffer [ ] buffers = new ByteBuffer [ fields ] ; for ( int i = <int> ; i < fields ; i + + ) { AbstractType < ? > fieldType = userType . type ( i ) ; if ( i > <int> ) expected . append ( <str> ) ; expected . append ( ColumnIdentifier . maybeQuote ( userType . fieldNameAsString ( i ) ) ) ; expected . append ( <str> ) ; if ( randBool ( <float> ) ) { expected . append ( <str> ) ; continue ; } Value value = generateAnyValue ( version , fieldType . asCQL3Type ( ) ) ; expected . append ( value . expected ) ; buffers [ i ] = value . value . duplicate ( ) ; } expected . append ( <str> ) ; buffer = TupleType . buildValue ( buffers ) ; } return new Value ( expected . toString ( ) , userType . asCQL3Type ( ) , buffer ) ; } static Value generateNativeValue ( CQL3Type type , boolean allowNull ) { List < Value > values = nativeTypeValues . get ( type ) ; assert values ! = null : type . toString ( ) + <str> ; while ( true ) { Value v = values . get ( randInt ( values . size ( ) ) ) ; if ( allowNull | | v . value ! = null ) return v ; } } static CollectionType randomCollectionType ( int level ) { CollectionType . Kind kind = CollectionType . Kind . values ( ) [ randInt ( CollectionType . Kind . values ( ) . length ) ] ; switch ( kind ) { case LIST : case SET : return ListType . getInstance ( randomNestedType ( level ) , randBool ( ) ) ; case MAP : return MapType . getInstance ( randomNestedType ( level ) , randomNestedType ( level ) , randBool ( ) ) ; } throw new AssertionError ( ) ; } static TupleType randomTupleType ( int level ) { int typeCount = <int> + randInt ( <int> ) ; List < AbstractType < ? > > types = new ArrayList < > ( ) ; for ( int i = <int> ; i < typeCount ; i + + ) types . add ( randomNestedType ( level ) ) ; return new TupleType ( types ) ; } static UserType randomUserType ( int level ) { int typeCount = <int> + randInt ( <int> ) ; List < ByteBuffer > names = new ArrayList < > ( ) ; List < AbstractType < ? > > types = new ArrayList < > ( ) ; for ( int i = <int> ; i < typeCount ; i + + ) { names . add ( UTF8Type . instance . fromString ( <str> + randLetters ( i ) ) ) ; types . add ( randomNestedType ( level ) ) ; } return new UserType ( <str> , UTF8Type . instance . fromString ( <str> + randInt ( <int> ) ) , names , types ) ; } private static String randLetters ( int len ) { StringBuilder sb = new StringBuilder ( len ) ; while ( len - - > <int> ) { int i = randInt ( <int> ) ; if ( i < <int> ) sb . append ( ( char ) ( <str> + i ) ) ; else sb . append ( ( char ) ( <str> + i - <int> ) ) ; } return sb . toString ( ) ; } static AbstractType randomNativeType ( ) { while ( true ) { CQL3Type . Native t = CQL3Type . Native . values ( ) [ randInt ( CQL3Type . Native . values ( ) . length ) ] ; if ( t ! = CQL3Type . Native . EMPTY ) return t . getType ( ) ; } } static boolean randBool ( ) { return randBool ( <float> ) ; } static boolean randBool ( double probability ) { return ThreadLocalRandom . current ( ) . nextDouble ( ) < probability ; } static long randLong ( ) { return ThreadLocalRandom . current ( ) . nextLong ( ) ; } static long randLong ( long max ) { return ThreadLocalRandom . current ( ) . nextLong ( max ) ; } static int randInt ( ) { return ThreadLocalRandom . current ( ) . nextInt ( ) ; } static int randInt ( int max ) { return ThreadLocalRandom . current ( ) . nextInt ( max ) ; } static short randShort ( ) { return ( short ) ThreadLocalRandom . current ( ) . nextInt ( ) ; } static byte randByte ( ) { return ( byte ) ThreadLocalRandom . current ( ) . nextInt ( ) ; } static double randDouble ( ) { return ThreadLocalRandom . current ( ) . nextDouble ( ) ; } static float randFloat ( ) { return ThreadLocalRandom . current ( ) . nextFloat ( ) ; } static String randString ( boolean ascii ) { int l = randInt ( <int> ) ; StringBuilder sb = new StringBuilder ( l ) ; for ( int i = <int> ; i < l ; i + + ) { if ( randBool ( <float> ) ) sb . append ( <str> ) ; else { char c = ( char ) ( ascii ? randInt ( <int> ) : randShort ( ) ) ; sb . append ( c ) ; } } return UTF8Serializer . instance . deserialize ( UTF8Serializer . instance . serialize ( sb . toString ( ) ) ) ; } static ByteBuffer randBytes ( ) { int l = randInt ( <int> ) ; byte [ ] v = new byte [ l ] ; for ( int i = <int> ; i < l ; i + + ) { v [ i ] = randByte ( ) ; } return ByteBuffer . wrap ( v ) ; } private static String quote ( String v ) { return <str> + QUOTE . matcher ( v ) . replaceAll ( <str> ) + <str> ; } } 
