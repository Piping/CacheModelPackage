package com . google . common . io ; import com . google . common . base . Strings ; import com . google . common . collect . ImmutableList ; import java . io . EOFException ; import java . io . FilterReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringReader ; import java . io . StringWriter ; import java . io . Writer ; import java . util . List ; public class CharStreamsTest extends IoTestCase { private static final String TEXT = <str> ; public void testToString ( ) throws IOException { assertEquals ( TEXT , CharStreams . toString ( new StringReader ( TEXT ) ) ) ; } public void testReadLines ( ) throws IOException { List < String > lines = CharStreams . readLines ( new StringReader ( <str> ) ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> ) , lines ) ; } public void testReadLines_withLineProcessor ( ) throws IOException { String text = <str> ; Reader r = new StringReader ( text ) ; LineProcessor < Integer > alwaysFalse = new LineProcessor < Integer > ( ) { int seen ; @Override public boolean processLine ( String line ) { seen + + ; return false ; } @Override public Integer getResult ( ) { return seen ; } } ; assertEquals ( <str> , <int> , CharStreams . readLines ( r , alwaysFalse ) . intValue ( ) ) ; r = new StringReader ( text ) ; LineProcessor < Integer > alwaysTrue = new LineProcessor < Integer > ( ) { int seen ; @Override public boolean processLine ( String line ) { seen + + ; return true ; } @Override public Integer getResult ( ) { return seen ; } } ; assertEquals ( <str> , <int> , CharStreams . readLines ( r , alwaysTrue ) . intValue ( ) ) ; r = new StringReader ( text ) ; final StringBuilder sb = new StringBuilder ( ) ; LineProcessor < Integer > conditional = new LineProcessor < Integer > ( ) { int seen ; @Override public boolean processLine ( String line ) { seen + + ; sb . append ( line ) ; return seen < <int> ; } @Override public Integer getResult ( ) { return seen ; } } ; assertEquals ( <int> , CharStreams . readLines ( r , conditional ) . intValue ( ) ) ; assertEquals ( <str> , sb . toString ( ) ) ; } public void testSkipFully_EOF ( ) throws IOException { Reader reader = new StringReader ( <str> ) ; try { CharStreams . skipFully ( reader , <int> ) ; fail ( <str> ) ; } catch ( EOFException e ) { } } public void testSkipFully ( ) throws IOException { String testString = <str> ; Reader reader = new StringReader ( testString ) ; assertEquals ( testString . charAt ( <int> ) , reader . read ( ) ) ; CharStreams . skipFully ( reader , <int> ) ; assertEquals ( testString . charAt ( <int> ) , reader . read ( ) ) ; CharStreams . skipFully ( reader , <int> ) ; assertEquals ( testString . charAt ( <int> ) , reader . read ( ) ) ; assertEquals ( - <int> , reader . read ( ) ) ; } public void testAsWriter ( ) { Appendable plainAppendable = new StringBuilder ( ) ; Writer result = CharStreams . asWriter ( plainAppendable ) ; assertNotSame ( plainAppendable , result ) ; assertNotNull ( result ) ; Appendable secretlyAWriter = new StringWriter ( ) ; result = CharStreams . asWriter ( secretlyAWriter ) ; assertSame ( secretlyAWriter , result ) ; } public void testCopy ( ) throws IOException { StringBuilder builder = new StringBuilder ( ) ; long copied = CharStreams . copy ( new StringReader ( ASCII ) , builder ) ; assertEquals ( ASCII , builder . toString ( ) ) ; assertEquals ( ASCII . length ( ) , copied ) ; StringBuilder builder2 = new StringBuilder ( ) ; copied = CharStreams . copy ( new StringReader ( I18N ) , builder2 ) ; assertEquals ( I18N , builder2 . toString ( ) ) ; assertEquals ( I18N . length ( ) , copied ) ; } public void testCopyWithReaderThatDoesNotFillBuffer ( ) throws IOException { String string = Strings . repeat ( <str> , <int> ) ; StringBuilder b = new StringBuilder ( ) ; long copied = CharStreams . copy ( newNonBufferFillingReader ( new StringReader ( string ) ) , b ) ; assertEquals ( string , b . toString ( ) ) ; assertEquals ( string . length ( ) , copied ) ; } public void testNullWriter ( ) throws Exception { Writer nullWriter = CharStreams . nullWriter ( ) ; nullWriter . write ( <str> ) ; String test = <str> ; nullWriter . write ( test ) ; nullWriter . write ( test , <int> , <int> ) ; assertSame ( CharStreams . nullWriter ( ) , CharStreams . nullWriter ( ) ) ; } private static Reader newNonBufferFillingReader ( Reader reader ) { return new FilterReader ( reader ) { @Override public int read ( char [ ] cbuf , int off , int len ) throws IOException { if ( len < = <int> ) { fail ( <str> + len ) ; } return in . read ( cbuf , off , Math . max ( len - <int> , <int> ) ) ; } } ; } } 
