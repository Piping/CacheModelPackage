package org . elasticsearch . index . search ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . index . Term ; import org . apache . lucene . queries . BlendedTermQuery ; import org . apache . lucene . search . * ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . query . AbstractQueryBuilder ; import org . elasticsearch . index . query . MultiMatchQueryBuilder ; import org . elasticsearch . index . query . QueryShardContext ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public class MultiMatchQuery extends MatchQuery { private Float groupTieBreaker = null ; public void setTieBreaker ( float tieBreaker ) { this . groupTieBreaker = tieBreaker ; } public MultiMatchQuery ( QueryShardContext context ) { super ( context ) ; } private Query parseAndApply ( Type type , String fieldName , Object value , String minimumShouldMatch , Float boostValue ) throws IOException { Query query = parse ( type , fieldName , value ) ; if ( query instanceof BooleanQuery ) { query = Queries . applyMinimumShouldMatch ( ( BooleanQuery ) query , minimumShouldMatch ) ; } if ( query ! = null & & boostValue ! = null & & boostValue ! = AbstractQueryBuilder . DEFAULT_BOOST ) { query = new BoostQuery ( query , boostValue ) ; } return query ; } public Query parse ( MultiMatchQueryBuilder . Type type , Map < String , Float > fieldNames , Object value , String minimumShouldMatch ) throws IOException { if ( fieldNames . size ( ) = = <int> ) { Map . Entry < String , Float > fieldBoost = fieldNames . entrySet ( ) . iterator ( ) . next ( ) ; Float boostValue = fieldBoost . getValue ( ) ; return parseAndApply ( type . matchQueryType ( ) , fieldBoost . getKey ( ) , value , minimumShouldMatch , boostValue ) ; } final float tieBreaker = groupTieBreaker = = null ? type . tieBreaker ( ) : groupTieBreaker ; switch ( type ) { case PHRASE : case PHRASE_PREFIX : case BEST_FIELDS : case MOST_FIELDS : queryBuilder = new QueryBuilder ( tieBreaker ) ; break ; case CROSS_FIELDS : queryBuilder = new CrossFieldsQueryBuilder ( tieBreaker ) ; break ; default : throw new IllegalStateException ( <str> + type ) ; } final List < ? extends Query > queries = queryBuilder . buildGroupedQueries ( type , fieldNames , value , minimumShouldMatch ) ; return queryBuilder . combineGrouped ( queries ) ; } private QueryBuilder queryBuilder ; public class QueryBuilder { protected final boolean groupDismax ; protected final float tieBreaker ; public QueryBuilder ( float tieBreaker ) { this ( tieBreaker ! = <float> , tieBreaker ) ; } public QueryBuilder ( boolean groupDismax , float tieBreaker ) { this . groupDismax = groupDismax ; this . tieBreaker = tieBreaker ; } public List < Query > buildGroupedQueries ( MultiMatchQueryBuilder . Type type , Map < String , Float > fieldNames , Object value , String minimumShouldMatch ) throws IOException { List < Query > queries = new ArrayList < > ( ) ; for ( String fieldName : fieldNames . keySet ( ) ) { Float boostValue = fieldNames . get ( fieldName ) ; Query query = parseGroup ( type . matchQueryType ( ) , fieldName , boostValue , value , minimumShouldMatch ) ; if ( query ! = null ) { queries . add ( query ) ; } } return queries ; } public Query parseGroup ( Type type , String field , Float boostValue , Object value , String minimumShouldMatch ) throws IOException { return parseAndApply ( type , field , value , minimumShouldMatch , boostValue ) ; } public Query combineGrouped ( List < ? extends Query > groupQuery ) { if ( groupQuery = = null | | groupQuery . isEmpty ( ) ) { return null ; } if ( groupQuery . size ( ) = = <int> ) { return groupQuery . get ( <int> ) ; } if ( groupDismax ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( tieBreaker ) ; for ( Query query : groupQuery ) { disMaxQuery . add ( query ) ; } return disMaxQuery ; } else { final BooleanQuery . Builder booleanQuery = new BooleanQuery . Builder ( ) ; for ( Query query : groupQuery ) { booleanQuery . add ( query , BooleanClause . Occur . SHOULD ) ; } return booleanQuery . build ( ) ; } } public Query blendTerm ( Term term , MappedFieldType fieldType ) { return MultiMatchQuery . super . blendTermQuery ( term , fieldType ) ; } public boolean forceAnalyzeQueryString ( ) { return false ; } } public class CrossFieldsQueryBuilder extends QueryBuilder { private FieldAndFieldType [ ] blendedFields ; public CrossFieldsQueryBuilder ( float tieBreaker ) { super ( false , tieBreaker ) ; } @Override public List < Query > buildGroupedQueries ( MultiMatchQueryBuilder . Type type , Map < String , Float > fieldNames , Object value , String minimumShouldMatch ) throws IOException { Map < Analyzer , List < FieldAndFieldType > > groups = new HashMap < > ( ) ; List < Tuple < String , Float > > missing = new ArrayList < > ( ) ; for ( Map . Entry < String , Float > entry : fieldNames . entrySet ( ) ) { String name = entry . getKey ( ) ; MappedFieldType fieldType = context . fieldMapper ( name ) ; if ( fieldType ! = null ) { Analyzer actualAnalyzer = getAnalyzer ( fieldType ) ; name = fieldType . names ( ) . indexName ( ) ; if ( ! groups . containsKey ( actualAnalyzer ) ) { groups . put ( actualAnalyzer , new ArrayList < > ( ) ) ; } Float boost = entry . getValue ( ) ; boost = boost = = null ? Float . valueOf ( <float> ) : boost ; groups . get ( actualAnalyzer ) . add ( new FieldAndFieldType ( name , fieldType , boost ) ) ; } else { missing . add ( new Tuple < > ( name , entry . getValue ( ) ) ) ; } } List < Query > queries = new ArrayList < > ( ) ; for ( Tuple < String , Float > tuple : missing ) { Query q = parseGroup ( type . matchQueryType ( ) , tuple . v1 ( ) , tuple . v2 ( ) , value , minimumShouldMatch ) ; if ( q ! = null ) { queries . add ( q ) ; } } for ( List < FieldAndFieldType > group : groups . values ( ) ) { if ( group . size ( ) > <int> ) { blendedFields = new FieldAndFieldType [ group . size ( ) ] ; int i = <int> ; for ( FieldAndFieldType fieldAndFieldType : group ) { blendedFields [ i + + ] = fieldAndFieldType ; } } else { blendedFields = null ; } final FieldAndFieldType fieldAndFieldType = group . get ( <int> ) ; Query q = parseGroup ( type . matchQueryType ( ) , fieldAndFieldType . field , <float> , value , minimumShouldMatch ) ; if ( q ! = null ) { queries . add ( q ) ; } } return queries . isEmpty ( ) ? null : queries ; } @Override public boolean forceAnalyzeQueryString ( ) { return blendedFields ! = null ; } @Override public Query blendTerm ( Term term , MappedFieldType fieldType ) { if ( blendedFields = = null ) { return super . blendTerm ( term , fieldType ) ; } final Term [ ] terms = new Term [ blendedFields . length ] ; float [ ] blendedBoost = new float [ blendedFields . length ] ; for ( int i = <int> ; i < blendedFields . length ; i + + ) { terms [ i ] = blendedFields [ i ] . newTerm ( term . text ( ) ) ; blendedBoost [ i ] = blendedFields [ i ] . boost ; } if ( commonTermsCutoff ! = null ) { return BlendedTermQuery . commonTermsBlendedQuery ( terms , blendedBoost , false , commonTermsCutoff ) ; } if ( tieBreaker = = <float> ) { return BlendedTermQuery . booleanBlendedQuery ( terms , blendedBoost , false ) ; } return BlendedTermQuery . dismaxBlendedQuery ( terms , blendedBoost , tieBreaker ) ; } } @Override protected Query blendTermQuery ( Term term , MappedFieldType fieldType ) { if ( queryBuilder = = null ) { return super . blendTermQuery ( term , fieldType ) ; } return queryBuilder . blendTerm ( term , fieldType ) ; } private static final class FieldAndFieldType { final String field ; final MappedFieldType fieldType ; final float boost ; private FieldAndFieldType ( String field , MappedFieldType fieldType , float boost ) { this . field = field ; this . fieldType = fieldType ; this . boost = boost ; } public Term newTerm ( String value ) { try { final BytesRef bytesRef = fieldType . indexedValueForSearch ( value ) ; return new Term ( field , bytesRef ) ; } catch ( Exception ex ) { } return new Term ( field , value ) ; } } @Override protected boolean forceAnalyzeQueryString ( ) { return this . queryBuilder = = null ? super . forceAnalyzeQueryString ( ) : this . queryBuilder . forceAnalyzeQueryString ( ) ; } } 
