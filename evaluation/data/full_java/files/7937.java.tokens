package org . elasticsearch . common . lucene . index ; import org . apache . lucene . analysis . core . KeywordAnalyzer ; import org . apache . lucene . document . Document ; import org . apache . lucene . document . Field ; import org . apache . lucene . document . StringField ; import org . apache . lucene . document . TextField ; import org . apache . lucene . index . * ; import org . apache . lucene . queries . TermsQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . store . Directory ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . test . ESTestCase ; import org . junit . After ; import org . junit . Before ; import java . util . * ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; public class FreqTermsEnumTests extends ESTestCase { private String [ ] terms ; private IndexWriter iw ; private IndexReader reader ; private Map < String , FreqHolder > referenceAll ; private Map < String , FreqHolder > referenceNotDeleted ; private Map < String , FreqHolder > referenceFilter ; private Query filter ; static class FreqHolder { int docFreq ; long totalTermFreq ; } @Before @Override public void setUp ( ) throws Exception { super . setUp ( ) ; referenceAll = new HashMap < > ( ) ; referenceNotDeleted = new HashMap < > ( ) ; referenceFilter = new HashMap < > ( ) ; Directory dir = newDirectory ( ) ; IndexWriterConfig conf = newIndexWriterConfig ( new KeywordAnalyzer ( ) ) ; if ( frequently ( ) ) { conf . setMergePolicy ( NoMergePolicy . INSTANCE ) ; } iw = new IndexWriter ( dir , conf ) ; terms = new String [ scaledRandomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < terms . length ; i + + ) { terms [ i ] = randomAsciiOfLength ( <int> ) ; } int numberOfDocs = scaledRandomIntBetween ( <int> , <int> ) ; Document [ ] docs = new Document [ numberOfDocs ] ; for ( int i = <int> ; i < numberOfDocs ; i + + ) { Document doc = new Document ( ) ; doc . add ( new StringField ( <str> , Integer . toString ( i ) , Field . Store . YES ) ) ; docs [ i ] = doc ; for ( String term : terms ) { if ( randomBoolean ( ) ) { continue ; } int freq = randomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < freq ; j + + ) { doc . add ( new TextField ( <str> , term , Field . Store . YES ) ) ; } } } for ( int i = <int> ; i < docs . length ; i + + ) { Document doc = docs [ i ] ; iw . addDocument ( doc ) ; if ( rarely ( ) ) { iw . commit ( ) ; } } Set < String > deletedIds = new HashSet < > ( ) ; for ( int i = <int> ; i < docs . length ; i + + ) { Document doc = docs [ i ] ; if ( randomInt ( <int> ) = = <int> ) { Term idTerm = new Term ( <str> , doc . getField ( <str> ) . stringValue ( ) ) ; deletedIds . add ( idTerm . text ( ) ) ; iw . deleteDocuments ( idTerm ) ; } } for ( String term : terms ) { referenceAll . put ( term , new FreqHolder ( ) ) ; referenceFilter . put ( term , new FreqHolder ( ) ) ; referenceNotDeleted . put ( term , new FreqHolder ( ) ) ; } reader = DirectoryReader . open ( iw , true ) ; List < Term > filterTerms = new ArrayList < > ( ) ; for ( int docId = <int> ; docId < reader . maxDoc ( ) ; docId + + ) { Document doc = reader . document ( docId ) ; addFreqs ( doc , referenceAll ) ; if ( ! deletedIds . contains ( doc . getField ( <str> ) . stringValue ( ) ) ) { addFreqs ( doc , referenceNotDeleted ) ; if ( randomBoolean ( ) ) { filterTerms . add ( new Term ( <str> , doc . getField ( <str> ) . stringValue ( ) ) ) ; addFreqs ( doc , referenceFilter ) ; } } } filter = new TermsQuery ( filterTerms ) ; } private void addFreqs ( Document doc , Map < String , FreqHolder > reference ) { Set < String > addedDocFreq = new HashSet < > ( ) ; for ( IndexableField field : doc . getFields ( <str> ) ) { String term = field . stringValue ( ) ; FreqHolder freqHolder = reference . get ( term ) ; if ( ! addedDocFreq . contains ( term ) ) { freqHolder . docFreq + + ; addedDocFreq . add ( term ) ; } freqHolder . totalTermFreq + + ; } } @After @Override public void tearDown ( ) throws Exception { IOUtils . close ( reader , iw , iw . getDirectory ( ) ) ; super . tearDown ( ) ; } public void testAllFreqs ( ) throws Exception { assertAgainstReference ( true , true , null , referenceAll ) ; assertAgainstReference ( true , false , null , referenceAll ) ; assertAgainstReference ( false , true , null , referenceAll ) ; } public void testNonDeletedFreqs ( ) throws Exception { assertAgainstReference ( true , true , Queries . newMatchAllQuery ( ) , referenceNotDeleted ) ; assertAgainstReference ( true , false , Queries . newMatchAllQuery ( ) , referenceNotDeleted ) ; assertAgainstReference ( false , true , Queries . newMatchAllQuery ( ) , referenceNotDeleted ) ; } public void testFilterFreqs ( ) throws Exception { assertAgainstReference ( true , true , filter , referenceFilter ) ; assertAgainstReference ( true , false , filter , referenceFilter ) ; assertAgainstReference ( false , true , filter , referenceFilter ) ; } private void assertAgainstReference ( boolean docFreq , boolean totalTermFreq , Query filter , Map < String , FreqHolder > reference ) throws Exception { FreqTermsEnum freqTermsEnum = new FreqTermsEnum ( reader , <str> , docFreq , totalTermFreq , filter , BigArrays . NON_RECYCLING_INSTANCE ) ; assertAgainstReference ( freqTermsEnum , reference , docFreq , totalTermFreq ) ; } private void assertAgainstReference ( FreqTermsEnum termsEnum , Map < String , FreqHolder > reference , boolean docFreq , boolean totalTermFreq ) throws Exception { int cycles = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < cycles ; i + + ) { List < String > terms = new ArrayList < > ( Arrays . asList ( this . terms ) ) ; Collections . shuffle ( terms , random ( ) ) ; for ( String term : terms ) { if ( ! termsEnum . seekExact ( new BytesRef ( term ) ) ) { assertThat ( <str> + term , reference . get ( term ) . docFreq , is ( <int> ) ) ; continue ; } if ( docFreq ) { assertThat ( <str> + i + <str> + term + <str> , termsEnum . docFreq ( ) , equalTo ( reference . get ( term ) . docFreq ) ) ; } if ( totalTermFreq ) { assertThat ( <str> + i + <str> + term + <str> , termsEnum . totalTermFreq ( ) , equalTo ( reference . get ( term ) . totalTermFreq ) ) ; } } } } } 
