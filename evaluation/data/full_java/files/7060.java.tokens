package org . elasticsearch . rest . action . support ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . ShardOperationFailedException ; import org . elasticsearch . action . support . broadcast . BroadcastResponse ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . index . query . * ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import java . io . IOException ; public class RestActions { public static long parseVersion ( RestRequest request ) { if ( request . hasParam ( <str> ) ) { return request . paramAsLong ( <str> , Versions . MATCH_ANY ) ; } String ifMatch = request . header ( <str> ) ; if ( ifMatch ! = null ) { return Long . parseLong ( ifMatch ) ; } return Versions . MATCH_ANY ; } public static long parseVersion ( RestRequest request , long defaultVersion ) { long version = parseVersion ( request ) ; return ( version = = Versions . MATCH_ANY ) ? defaultVersion : version ; } static final class Fields { static final XContentBuilderString _SHARDS = new XContentBuilderString ( <str> ) ; static final XContentBuilderString TOTAL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString SUCCESSFUL = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FAILED = new XContentBuilderString ( <str> ) ; static final XContentBuilderString FAILURES = new XContentBuilderString ( <str> ) ; } public static void buildBroadcastShardsHeader ( XContentBuilder builder , ToXContent . Params params , BroadcastResponse response ) throws IOException { buildBroadcastShardsHeader ( builder , params , response . getTotalShards ( ) , response . getSuccessfulShards ( ) , response . getFailedShards ( ) , response . getShardFailures ( ) ) ; } public static void buildBroadcastShardsHeader ( XContentBuilder builder , ToXContent . Params params , int total , int successful , int failed , ShardOperationFailedException [ ] shardFailures ) throws IOException { builder . startObject ( Fields . _SHARDS ) ; builder . field ( Fields . TOTAL , total ) ; builder . field ( Fields . SUCCESSFUL , successful ) ; builder . field ( Fields . FAILED , failed ) ; if ( shardFailures ! = null & & shardFailures . length > <int> ) { builder . startArray ( Fields . FAILURES ) ; final boolean group = params . paramAsBoolean ( <str> , true ) ; for ( ShardOperationFailedException shardFailure : group ? ExceptionsHelper . groupBy ( shardFailures ) : shardFailures ) { builder . startObject ( ) ; shardFailure . toXContent ( builder , params ) ; builder . endObject ( ) ; } builder . endArray ( ) ; } builder . endObject ( ) ; } public static QueryBuilder < ? > urlParamsToQueryBuilder ( RestRequest request ) { String queryString = request . param ( <str> ) ; if ( queryString = = null ) { return null ; } QueryStringQueryBuilder queryBuilder = QueryBuilders . queryStringQuery ( queryString ) ; queryBuilder . defaultField ( request . param ( <str> ) ) ; queryBuilder . analyzer ( request . param ( <str> ) ) ; queryBuilder . analyzeWildcard ( request . paramAsBoolean ( <str> , false ) ) ; queryBuilder . lowercaseExpandedTerms ( request . paramAsBoolean ( <str> , true ) ) ; queryBuilder . lenient ( request . paramAsBoolean ( <str> , null ) ) ; String defaultOperator = request . param ( <str> ) ; if ( defaultOperator ! = null ) { queryBuilder . defaultOperator ( Operator . fromString ( defaultOperator ) ) ; } return queryBuilder ; } public static SearchSourceBuilder getRestSearchSource ( BytesReference sourceBytes , IndicesQueriesRegistry queryRegistry , ParseFieldMatcher parseFieldMatcher ) throws IOException { XContentParser parser = XContentFactory . xContent ( sourceBytes ) . createParser ( sourceBytes ) ; QueryParseContext queryParseContext = new QueryParseContext ( queryRegistry ) ; queryParseContext . reset ( parser ) ; queryParseContext . parseFieldMatcher ( parseFieldMatcher ) ; return SearchSourceBuilder . parseSearchSource ( parser , queryParseContext ) ; } public static BytesReference getRestContent ( RestRequest request ) { assert request ! = null ; BytesReference content = request . content ( ) ; if ( ! request . hasContent ( ) ) { String source = request . param ( <str> ) ; if ( source ! = null ) { content = new BytesArray ( source ) ; } } return content ; } public static QueryBuilder < ? > getQueryContent ( BytesReference source , IndicesQueriesRegistry indicesQueriesRegistry , ParseFieldMatcher parseFieldMatcher ) { QueryParseContext context = new QueryParseContext ( indicesQueriesRegistry ) ; try ( XContentParser requestParser = XContentFactory . xContent ( source ) . createParser ( source ) ) { context . reset ( requestParser ) ; context . parseFieldMatcher ( parseFieldMatcher ) ; return context . parseTopLevelQueryBuilder ( ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> , e ) ; } finally { context . reset ( null ) ; } } public static XContentType guessBodyContentType ( final RestRequest request ) { final BytesReference restContent = RestActions . getRestContent ( request ) ; if ( restContent = = null ) { return null ; } return XContentFactory . xContentType ( restContent ) ; } public static boolean hasBodyContent ( final RestRequest request ) { return request . hasContent ( ) | | request . hasParam ( <str> ) ; } } 
