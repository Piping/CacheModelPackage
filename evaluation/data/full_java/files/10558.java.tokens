package com . google . common . math ; import static com . google . common . math . MathTesting . ALL_LONG_CANDIDATES ; import static com . google . common . math . MathTesting . ALL_ROUNDING_MODES ; import static com . google . common . math . MathTesting . ALL_SAFE_ROUNDING_MODES ; import static com . google . common . math . MathTesting . EXPONENTS ; import static com . google . common . math . MathTesting . NEGATIVE_INTEGER_CANDIDATES ; import static com . google . common . math . MathTesting . NEGATIVE_LONG_CANDIDATES ; import static com . google . common . math . MathTesting . NONZERO_LONG_CANDIDATES ; import static com . google . common . math . MathTesting . POSITIVE_INTEGER_CANDIDATES ; import static com . google . common . math . MathTesting . POSITIVE_LONG_CANDIDATES ; import static java . math . BigInteger . valueOf ; import static java . math . RoundingMode . FLOOR ; import static java . math . RoundingMode . UNNECESSARY ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . math . RoundingMode ; @GwtCompatible ( emulated = true ) public class LongMathTest extends TestCase { @GwtIncompatible ( <str> ) public void testConstantMaxPowerOfSqrt2Unsigned ( ) { assertEquals ( BigIntegerMath . sqrt ( BigInteger . ZERO . setBit ( <int> * Long . SIZE - <int> ) , FLOOR ) . longValue ( ) , LongMath . MAX_POWER_OF_SQRT2_UNSIGNED ) ; } @GwtIncompatible ( <str> ) public void testMaxLog10ForLeadingZeros ( ) { for ( int i = <int> ; i < Long . SIZE ; i + + ) { assertEquals ( BigIntegerMath . log10 ( BigInteger . ONE . shiftLeft ( Long . SIZE - i ) , FLOOR ) , LongMath . maxLog10ForLeadingZeros [ i ] ) ; } } @GwtIncompatible ( <str> ) public void testConstantsPowersOf10 ( ) { for ( int i = <int> ; i < LongMath . powersOf10 . length ; i + + ) { assertEquals ( LongMath . checkedPow ( <int> , i ) , LongMath . powersOf10 [ i ] ) ; } try { LongMath . checkedPow ( <int> , LongMath . powersOf10 . length ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } @GwtIncompatible ( <str> ) public void testConstantsHalfPowersOf10 ( ) { for ( int i = <int> ; i < LongMath . halfPowersOf10 . length ; i + + ) { assertEquals ( BigIntegerMath . sqrt ( BigInteger . TEN . pow ( <int> * i + <int> ) , FLOOR ) , BigInteger . valueOf ( LongMath . halfPowersOf10 [ i ] ) ) ; } BigInteger nextBigger = BigIntegerMath . sqrt ( BigInteger . TEN . pow ( <int> * LongMath . halfPowersOf10 . length + <int> ) , FLOOR ) ; assertTrue ( nextBigger . compareTo ( BigInteger . valueOf ( Long . MAX_VALUE ) ) > <int> ) ; } @GwtIncompatible ( <str> ) public void testConstantsSqrtMaxLong ( ) { assertEquals ( LongMath . sqrt ( Long . MAX_VALUE , FLOOR ) , LongMath . FLOOR_SQRT_MAX_LONG ) ; } @GwtIncompatible ( <str> ) public void testConstantsFactorials ( ) { long expected = <int> ; for ( int i = <int> ; i < LongMath . factorials . length ; i + + , expected * = i ) { assertEquals ( expected , LongMath . factorials [ i ] ) ; } try { LongMath . checkedMultiply ( LongMath . factorials [ LongMath . factorials . length - <int> ] , LongMath . factorials . length ) ; fail ( <str> ) ; } catch ( ArithmeticException expect ) { } } @GwtIncompatible ( <str> ) public void testConstantsBiggestBinomials ( ) { for ( int k = <int> ; k < LongMath . biggestBinomials . length ; k + + ) { assertTrue ( fitsInLong ( BigIntegerMath . binomial ( LongMath . biggestBinomials [ k ] , k ) ) ) ; assertTrue ( LongMath . biggestBinomials [ k ] = = Integer . MAX_VALUE | | ! fitsInLong ( BigIntegerMath . binomial ( LongMath . biggestBinomials [ k ] + <int> , k ) ) ) ; } int k = LongMath . biggestBinomials . length ; assertFalse ( fitsInLong ( BigIntegerMath . binomial ( <int> * k , k ) ) ) ; } @GwtIncompatible ( <str> ) public void testConstantsBiggestSimpleBinomials ( ) { for ( int k = <int> ; k < LongMath . biggestSimpleBinomials . length ; k + + ) { assertTrue ( LongMath . biggestSimpleBinomials [ k ] < = LongMath . biggestBinomials [ k ] ) ; simpleBinomial ( LongMath . biggestSimpleBinomials [ k ] , k ) ; if ( LongMath . biggestSimpleBinomials [ k ] < Integer . MAX_VALUE ) { try { simpleBinomial ( LongMath . biggestSimpleBinomials [ k ] + <int> , k ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } try { int k = LongMath . biggestSimpleBinomials . length ; simpleBinomial ( <int> * k , k ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } @AndroidIncompatible public void testLessThanBranchFree ( ) { for ( long x : ALL_LONG_CANDIDATES ) { for ( long y : ALL_LONG_CANDIDATES ) { BigInteger difference = BigInteger . valueOf ( x ) . subtract ( BigInteger . valueOf ( y ) ) ; if ( fitsInLong ( difference ) ) { int expected = ( x < y ) ? <int> : <int> ; int actual = LongMath . lessThanBranchFree ( x , y ) ; assertEquals ( expected , actual ) ; } } } } @GwtIncompatible ( <str> ) private long simpleBinomial ( int n , int k ) { long accum = <int> ; for ( int i = <int> ; i < k ; i + + ) { accum = LongMath . checkedMultiply ( accum , n - i ) ; accum / = i + <int> ; } return accum ; } @GwtIncompatible ( <str> ) public void testIsPowerOfTwo ( ) { for ( long x : ALL_LONG_CANDIDATES ) { BigInteger bigX = BigInteger . valueOf ( x ) ; boolean expected = ( bigX . signum ( ) > <int> ) & & ( bigX . bitCount ( ) = = <int> ) ; assertEquals ( expected , LongMath . isPowerOfTwo ( x ) ) ; } } public void testLog2ZeroAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { LongMath . log2 ( <int> L , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testLog2NegativeAlwaysThrows ( ) { for ( long x : NEGATIVE_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { LongMath . log2 ( x , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } public void testLog2MatchesBigInteger ( ) { for ( long x : POSITIVE_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { assertEquals ( BigIntegerMath . log2 ( valueOf ( x ) , mode ) , LongMath . log2 ( x , mode ) ) ; } } } public void testLog2Exact ( ) { for ( long x : POSITIVE_LONG_CANDIDATES ) { boolean isPowerOf2 = LongMath . isPowerOfTwo ( x ) ; try { assertEquals ( x , <int> < < LongMath . log2 ( x , UNNECESSARY ) ) ; assertTrue ( isPowerOf2 ) ; } catch ( ArithmeticException e ) { assertFalse ( isPowerOf2 ) ; } } } @GwtIncompatible ( <str> ) public void testLog10ZeroAlwaysThrows ( ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { LongMath . log10 ( <int> L , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testLog10NegativeAlwaysThrows ( ) { for ( long x : NEGATIVE_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { LongMath . log10 ( x , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } @GwtIncompatible ( <str> ) public void testLog10MatchesBigInteger ( ) { for ( long x : POSITIVE_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { assertEquals ( BigIntegerMath . log10 ( valueOf ( x ) , mode ) , LongMath . log10 ( x , mode ) ) ; } } } @GwtIncompatible ( <str> ) public void testLog10Exact ( ) { for ( long x : POSITIVE_LONG_CANDIDATES ) { int floor = LongMath . log10 ( x , FLOOR ) ; boolean expectedSuccess = LongMath . pow ( <int> , floor ) = = x ; try { assertEquals ( floor , LongMath . log10 ( x , UNNECESSARY ) ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { if ( expectedSuccess ) { failFormat ( <str> , x , floor ) ; } } } } @GwtIncompatible ( <str> ) public void testLog10TrivialOnPowerOf10 ( ) { long x = <int> ; for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( <int> , LongMath . log10 ( x , mode ) ) ; } } @GwtIncompatible ( <str> ) public void testSqrtNegativeAlwaysThrows ( ) { for ( long x : NEGATIVE_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { LongMath . sqrt ( x , mode ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } @GwtIncompatible ( <str> ) public void testSqrtMatchesBigInteger ( ) { for ( long x : POSITIVE_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { assertEquals ( BigIntegerMath . sqrt ( valueOf ( x ) , mode ) , valueOf ( LongMath . sqrt ( x , mode ) ) ) ; } } } @GwtIncompatible ( <str> ) public void testSqrtExactMatchesFloorOrThrows ( ) { for ( long x : POSITIVE_LONG_CANDIDATES ) { long sqrtFloor = LongMath . sqrt ( x , FLOOR ) ; boolean isPerfectSquare = ( sqrtFloor * sqrtFloor = = x ) ; try { assertEquals ( sqrtFloor , LongMath . sqrt ( x , UNNECESSARY ) ) ; assertTrue ( isPerfectSquare ) ; } catch ( ArithmeticException e ) { assertFalse ( isPerfectSquare ) ; } } } @GwtIncompatible ( <str> ) public void testPow ( ) { for ( long i : ALL_LONG_CANDIDATES ) { for ( int exp : EXPONENTS ) { assertEquals ( LongMath . pow ( i , exp ) , valueOf ( i ) . pow ( exp ) . longValue ( ) ) ; } } } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testDivNonZero ( ) { for ( long p : NONZERO_LONG_CANDIDATES ) { for ( long q : NONZERO_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_SAFE_ROUNDING_MODES ) { long expected = new BigDecimal ( valueOf ( p ) ) . divide ( new BigDecimal ( valueOf ( q ) ) , <int> , mode ) . longValue ( ) ; long actual = LongMath . divide ( p , q , mode ) ; if ( expected ! = actual ) { failFormat ( <str> , p , q , mode , expected , actual ) ; } } } } } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testDivNonZeroExact ( ) { for ( long p : NONZERO_LONG_CANDIDATES ) { for ( long q : NONZERO_LONG_CANDIDATES ) { boolean expectedSuccess = ( p % q ) = = <int> L ; try { assertEquals ( p , LongMath . divide ( p , q , UNNECESSARY ) * q ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { if ( expectedSuccess ) { failFormat ( <str> , p , q ) ; } } } } } @GwtIncompatible ( <str> ) public void testZeroDivIsAlwaysZero ( ) { for ( long q : NONZERO_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { assertEquals ( <int> L , LongMath . divide ( <int> L , q , mode ) ) ; } } } @GwtIncompatible ( <str> ) public void testDivByZeroAlwaysFails ( ) { for ( long p : ALL_LONG_CANDIDATES ) { for ( RoundingMode mode : ALL_ROUNDING_MODES ) { try { LongMath . divide ( p , <int> L , mode ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } } @GwtIncompatible ( <str> ) public void testIntMod ( ) { for ( long x : ALL_LONG_CANDIDATES ) { for ( int m : POSITIVE_INTEGER_CANDIDATES ) { assertEquals ( valueOf ( x ) . mod ( valueOf ( m ) ) . intValue ( ) , LongMath . mod ( x , m ) ) ; } } } @GwtIncompatible ( <str> ) public void testIntModNegativeModulusFails ( ) { for ( long x : ALL_LONG_CANDIDATES ) { for ( int m : NEGATIVE_INTEGER_CANDIDATES ) { try { LongMath . mod ( x , m ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } } @GwtIncompatible ( <str> ) public void testIntModZeroModulusFails ( ) { for ( long x : ALL_LONG_CANDIDATES ) { try { LongMath . mod ( x , <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } @AndroidIncompatible @GwtIncompatible ( <str> ) public void testMod ( ) { for ( long x : ALL_LONG_CANDIDATES ) { for ( long m : POSITIVE_LONG_CANDIDATES ) { assertEquals ( valueOf ( x ) . mod ( valueOf ( m ) ) . longValue ( ) , LongMath . mod ( x , m ) ) ; } } } @GwtIncompatible ( <str> ) public void testModNegativeModulusFails ( ) { for ( long x : ALL_LONG_CANDIDATES ) { for ( long m : NEGATIVE_LONG_CANDIDATES ) { try { LongMath . mod ( x , m ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } } public void testGCDExhaustive ( ) { for ( long a : POSITIVE_LONG_CANDIDATES ) { for ( long b : POSITIVE_LONG_CANDIDATES ) { assertEquals ( valueOf ( a ) . gcd ( valueOf ( b ) ) , valueOf ( LongMath . gcd ( a , b ) ) ) ; } } } @GwtIncompatible ( <str> ) public void testGCDZero ( ) { for ( long a : POSITIVE_LONG_CANDIDATES ) { assertEquals ( a , LongMath . gcd ( a , <int> ) ) ; assertEquals ( a , LongMath . gcd ( <int> , a ) ) ; } assertEquals ( <int> , LongMath . gcd ( <int> , <int> ) ) ; } @GwtIncompatible ( <str> ) public void testGCDNegativePositiveThrows ( ) { for ( long a : NEGATIVE_LONG_CANDIDATES ) { try { LongMath . gcd ( a , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { LongMath . gcd ( <int> , a ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testGCDNegativeZeroThrows ( ) { for ( long a : NEGATIVE_LONG_CANDIDATES ) { try { LongMath . gcd ( a , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { LongMath . gcd ( <int> , a ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @AndroidIncompatible @GwtIncompatible ( <str> ) public void testCheckedAdd ( ) { for ( long a : ALL_LONG_CANDIDATES ) { for ( long b : ALL_LONG_CANDIDATES ) { BigInteger expectedResult = valueOf ( a ) . add ( valueOf ( b ) ) ; boolean expectedSuccess = fitsInLong ( expectedResult ) ; try { assertEquals ( a + b , LongMath . checkedAdd ( a , b ) ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { if ( expectedSuccess ) { failFormat ( <str> , a , b , expectedResult ) ; } } } } } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testCheckedSubtract ( ) { for ( long a : ALL_LONG_CANDIDATES ) { for ( long b : ALL_LONG_CANDIDATES ) { BigInteger expectedResult = valueOf ( a ) . subtract ( valueOf ( b ) ) ; boolean expectedSuccess = fitsInLong ( expectedResult ) ; try { assertEquals ( a - b , LongMath . checkedSubtract ( a , b ) ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { if ( expectedSuccess ) { failFormat ( <str> , a , b , expectedResult ) ; } } } } } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testCheckedMultiply ( ) { boolean isAndroid = System . getProperties ( ) . getProperty ( <str> ) . contains ( <str> ) ; for ( long a : ALL_LONG_CANDIDATES ) { for ( long b : ALL_LONG_CANDIDATES ) { if ( isAndroid & & a = = - <int> & & b = = <int> ) { continue ; } BigInteger expectedResult = valueOf ( a ) . multiply ( valueOf ( b ) ) ; boolean expectedSuccess = fitsInLong ( expectedResult ) ; try { assertEquals ( a * b , LongMath . checkedMultiply ( a , b ) ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { if ( expectedSuccess ) { failFormat ( <str> , a , b , expectedResult ) ; } } } } } @GwtIncompatible ( <str> ) public void testCheckedPow ( ) { for ( long b : ALL_LONG_CANDIDATES ) { for ( int exp : EXPONENTS ) { BigInteger expectedResult = valueOf ( b ) . pow ( exp ) ; boolean expectedSuccess = fitsInLong ( expectedResult ) ; try { assertEquals ( expectedResult . longValue ( ) , LongMath . checkedPow ( b , exp ) ) ; assertTrue ( expectedSuccess ) ; } catch ( ArithmeticException e ) { if ( expectedSuccess ) { failFormat ( <str> , b , exp , expectedResult ) ; } } } } } @GwtIncompatible ( <str> ) public void testFactorial ( ) { for ( int n = <int> ; n < = <int> ; n + + ) { BigInteger expectedBig = BigIntegerMath . factorial ( n ) ; long expectedLong = fitsInLong ( expectedBig ) ? expectedBig . longValue ( ) : Long . MAX_VALUE ; assertEquals ( expectedLong , LongMath . factorial ( n ) ) ; } } @GwtIncompatible ( <str> ) public void testFactorialNegative ( ) { for ( int n : NEGATIVE_INTEGER_CANDIDATES ) { try { LongMath . factorial ( n ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testBinomial ( ) { for ( int n = <int> ; n < = <int> ; n + + ) { for ( int k = <int> ; k < = n ; k + + ) { BigInteger expectedBig = BigIntegerMath . binomial ( n , k ) ; long expectedLong = fitsInLong ( expectedBig ) ? expectedBig . longValue ( ) : Long . MAX_VALUE ; assertEquals ( expectedLong , LongMath . binomial ( n , k ) ) ; } } } @GwtIncompatible ( <str> ) public void testBinomial_exhaustiveNotOverflowing ( ) { for ( int k = <int> ; k < LongMath . biggestBinomials . length ; k + + ) { for ( int n = <int> ; n < = LongMath . biggestBinomials [ k ] ; n + + ) { assertEquals ( BigIntegerMath . binomial ( n , k ) . longValue ( ) , LongMath . binomial ( n , k ) ) ; } } } public void testBinomialOutside ( ) { for ( int n = <int> ; n < = <int> ; n + + ) { try { LongMath . binomial ( n , - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { LongMath . binomial ( n , n + <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testBinomialNegative ( ) { for ( int n : NEGATIVE_INTEGER_CANDIDATES ) { try { LongMath . binomial ( n , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } @GwtIncompatible ( <str> ) public void testSqrtOfPerfectSquareAsDoubleIsPerfect ( ) { for ( long n = <int> ; n < = LongMath . FLOOR_SQRT_MAX_LONG ; n + + ) { long actual = ( long ) Math . sqrt ( n * n ) ; assertTrue ( actual = = n ) ; } } public void testSqrtOfLongIsAtMostFloorSqrtMaxLong ( ) { long sqrtMaxLong = ( long ) Math . sqrt ( Long . MAX_VALUE ) ; assertTrue ( sqrtMaxLong < = LongMath . FLOOR_SQRT_MAX_LONG ) ; } @AndroidIncompatible @GwtIncompatible ( <str> ) public void testMean ( ) { assertMean ( <int> , <int> , <int> ) ; assertMean ( - <int> , - <int> , - <int> ) ; assertMean ( <int> , - <int> , <int> ) ; assertMean ( <int> , - <int> , <int> ) ; assertMean ( ( <int> < < <int> ) - <int> , - <int> , Long . MAX_VALUE ) ; assertMean ( <int> , <int> , <int> ) ; assertMean ( - <int> , - <int> , - <int> ) ; assertMean ( <int> , - <int> , <int> ) ; assertMean ( <int> , Long . MIN_VALUE + <int> , Long . MAX_VALUE ) ; assertMean ( <int> , <int> , <int> ) ; assertMean ( - <int> , - <int> , <int> ) ; assertMean ( - <int> , Long . MIN_VALUE , Long . MAX_VALUE ) ; assertMean ( <int> , <int> , <int> ) ; assertMean ( <int> , <int> , <int> ) ; assertMean ( - <int> , - <int> , - <int> ) ; assertMean ( Long . MIN_VALUE , Long . MIN_VALUE , Long . MIN_VALUE ) ; assertMean ( Long . MAX_VALUE , Long . MAX_VALUE , Long . MAX_VALUE ) ; for ( long x : ALL_LONG_CANDIDATES ) { for ( long y : ALL_LONG_CANDIDATES ) { assertMean ( x , y ) ; } } } private static void assertMean ( long expectedMean , long x , long y ) { assertEquals ( <str> , expectedMean , computeMeanSafely ( x , y ) ) ; assertMean ( x , y ) ; } private static void assertMean ( long x , long y ) { long expectedMean = computeMeanSafely ( x , y ) ; assertEquals ( expectedMean , LongMath . mean ( x , y ) ) ; assertEquals ( <str> , expectedMean , LongMath . mean ( y , x ) ) ; } private static long computeMeanSafely ( long x , long y ) { BigInteger bigX = BigInteger . valueOf ( x ) ; BigInteger bigY = BigInteger . valueOf ( y ) ; BigDecimal bigMean = new BigDecimal ( bigX . add ( bigY ) ) . divide ( BigDecimal . valueOf ( <int> ) , BigDecimal . ROUND_FLOOR ) ; return Long . parseLong ( bigMean . toString ( ) ) ; } private static boolean fitsInLong ( BigInteger big ) { return big . bitLength ( ) < = <int> ; } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . setDefault ( int . class , <int> ) ; tester . setDefault ( long . class , <int> ) ; tester . testAllPublicStaticMethods ( LongMath . class ) ; } @GwtIncompatible ( <str> ) private static void failFormat ( String template , Object . . . args ) { fail ( String . format ( template , args ) ) ; } } 
