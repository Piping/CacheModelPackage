package org . apache . cassandra . cql3 . validation . operations ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . junit . Test ; import org . apache . cassandra . cql3 . CQLTester ; import static org . apache . commons . lang3 . StringUtils . isEmpty ; import static org . junit . Assert . assertEquals ; public class DeleteTest extends CQLTester { @Test public void testRangeDeletion ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( ) ; execute ( <str> , <int> , <int> ) ; flush ( ) ; assertEmpty ( execute ( <str> , <int> , <int> , <int> ) ) ; } @Test public void testDeletion ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> , <str> , <int> , <str> , <str> ) ; execute ( <str> , <str> , <int> , <str> , <str> ) ; assertRows ( execute ( <str> ) , row ( <str> , <int> , <str> , <str> ) , row ( <str> , <int> , <str> , <str> ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <str> , <int> , <str> , <str> ) ) ; createTable ( <str> ) ; execute ( <str> , <str> , <int> , <str> , <str> ) ; execute ( <str> , <str> , <int> , <str> , <str> ) ; assertRows ( execute ( <str> ) , row ( <str> , <int> , <str> , <str> ) , row ( <str> , <int> , <str> , <str> ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <str> , <int> , <str> , <str> ) ) ; } @Test public void testDeleteByCompositePrefix ( ) throws Throwable { createTable ( <str> ) ; int numRows = <int> ; int col1 = <int> ; int col2 = <int> ; int cpr = col1 * col2 ; for ( int i = <int> ; i < numRows ; i + + ) for ( int j = <int> ; j < col1 ; j + + ) for ( int k = <int> ; k < col2 ; k + + ) { int n = ( i * cpr ) + ( j * col2 ) + k ; execute ( <str> , i , j , k , n , n ) ; } for ( int i = <int> ; i < numRows ; i + + ) { Object [ ] [ ] rows = getRows ( execute ( <str> , i ) ) ; for ( int x = i * cpr ; x < ( i + <int> ) * cpr ; x + + ) { assertEquals ( x , rows [ x - i * cpr ] [ <int> ] ) ; assertEquals ( x , rows [ x - i * cpr ] [ <int> ] ) ; } } for ( int i = <int> ; i < numRows ; i + + ) execute ( <str> , i ) ; for ( int i = <int> ; i < numRows ; i + + ) { Object [ ] [ ] rows = getRows ( execute ( <str> , i ) ) ; for ( int x = i * cpr + col1 ; x < ( i + <int> ) * cpr ; x + + ) { assertEquals ( x , rows [ x - i * cpr - col1 ] [ <int> ] ) ; assertEquals ( x , rows [ x - i * cpr - col1 ] [ <int> ] ) ; } } for ( int i = <int> ; i < numRows ; i + + ) { Object [ ] [ ] rows = getRows ( execute ( <str> , i ) ) ; for ( int x = i * cpr + col1 ; x < ( i + <int> ) * cpr ; x + + ) { assertEquals ( x , rows [ x - i * cpr - col1 ] [ <int> ] ) ; assertEquals ( x , rows [ x - i * cpr - col1 ] [ <int> ] ) ; } } } @Test public void testDeleteByCompositePrefixWithCompaction ( ) throws Throwable { createTable ( <str> ) ; for ( int c1 = <int> ; c1 < <int> ; c1 + + ) for ( int c2 = <int> ; c2 < <int> ; c2 + + ) execute ( <str> , c1 , c2 , String . format ( <str> , c1 , c2 ) ) ; flush ( ) ; execute ( <str> ) ; flush ( ) ; compact ( ) ; Object [ ] [ ] rows = getRows ( execute ( <str> ) ) ; int idx = <int> ; for ( int c1 = <int> ; c1 < <int> ; c1 + + ) for ( int c2 = <int> ; c2 < <int> ; c2 + + ) if ( c1 ! = <int> ) assertEquals ( String . format ( <str> , c1 , c2 ) , rows [ idx + + ] [ <int> ] ) ; } @Test public void testRowDeletion ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> , <int> , <int> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> , <int> , <int> ) ; execute ( <str> ) ; assertRowCount ( execute ( <str> ) , <int> ) ; } @Test public void testRowExistence ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> , <int> ) ) ; assertInvalid ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> , null ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , null , null ) ) ; execute ( <str> ) ; assertEmpty ( execute ( <str> ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , null , null ) ) ; } @Test public void testRemoveRangeSlice ( ) throws Throwable { createTable ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , i , i ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; } @Test public void testNoRangeGhost ( ) throws Throwable { createTable ( <str> ) ; for ( int k = <int> ; k < <int> ; k + + ) execute ( <str> , k ) ; Object [ ] [ ] rows = getRows ( execute ( <str> ) ) ; int [ ] ordered = sortIntRows ( rows ) ; for ( int k = <int> ; k < <int> ; k + + ) assertEquals ( k , ordered [ k ] ) ; execute ( <str> ) ; rows = getRows ( execute ( <str> ) ) ; ordered = sortIntRows ( rows ) ; int idx = <int> ; for ( int k = <int> ; k < <int> ; k + + ) if ( k ! = <int> ) assertEquals ( k , ordered [ idx + + ] ) ; createTable ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <str> , <int> , <str> , <str> ) ) ; execute ( <str> ) ; assertEmpty ( execute ( <str> ) ) ; assertEmpty ( execute ( <str> ) ) ; } private int [ ] sortIntRows ( Object [ ] [ ] rows ) { int [ ] ret = new int [ rows . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) ret [ i ] = rows [ i ] [ <int> ] = = null ? Integer . MIN_VALUE : ( Integer ) rows [ i ] [ <int> ] ; Arrays . sort ( ret ) ; return ret ; } @Test public void testRandomDeletions ( ) throws Throwable { createTable ( <str> ) ; int nb_keys = <int> ; int nb_deletes = <int> ; List < Integer > deletions = new ArrayList < > ( nb_keys ) ; for ( int i = <int> ; i < nb_keys ; i + + ) { execute ( <str> , i , i ) ; deletions . add ( i ) ; } Collections . shuffle ( deletions ) ; for ( int i = <int> ; i < nb_deletes ; i + + ) execute ( <str> , deletions . get ( i ) ) ; assertRowCount ( execute ( <str> , ( nb_keys / <int> ) ) , nb_keys / <int> ) ; } @Test public void testDeletedRowCannotBeSelected ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> ) ; flush ( ) ; execute ( <str> ) ; flush ( ) ; assertEmpty ( execute ( <str> ) ) ; } @Test public void testDeleteWithNoClusteringColumns ( ) throws Throwable { testDeleteWithNoClusteringColumns ( false ) ; testDeleteWithNoClusteringColumns ( true ) ; } private void testDeleteWithNoClusteringColumns ( boolean forceFlush ) throws Throwable { for ( String compactOption : new String [ ] { <str> , <str> } ) { createTable ( <str> + <str> + compactOption ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; flush ( forceFlush ) ; execute ( <str> , <int> ) ; flush ( forceFlush ) ; if ( isEmpty ( compactOption ) ) { assertRows ( execute ( <str> , <int> ) , row ( <int> , null ) ) ; } else { assertEmpty ( execute ( <str> , <int> ) ) ; } execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; } } @Test public void testDeleteWithOneClusteringColumns ( ) throws Throwable { testDeleteWithOneClusteringColumns ( false ) ; testDeleteWithOneClusteringColumns ( true ) ; } private void testDeleteWithOneClusteringColumns ( boolean forceFlush ) throws Throwable { for ( String compactOption : new String [ ] { <str> , <str> } ) { createTable ( <str> + <str> + <str> + <str> + compactOption ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; flush ( forceFlush ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; if ( isEmpty ( compactOption ) ) { assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , null ) ) ; } else { assertEmpty ( execute ( <str> , <int> , <int> ) ) ; } execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertEmpty ( execute ( <str> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; String errorMsg = isEmpty ( compactOption ) ? <str> : <str> ; assertInvalidMessage ( errorMsg , <str> , <int> , <int> , <int> ) ; } } @Test public void testDeleteWithTwoClusteringColumns ( ) throws Throwable { testDeleteWithTwoClusteringColumns ( false ) ; testDeleteWithTwoClusteringColumns ( true ) ; } private void testDeleteWithTwoClusteringColumns ( boolean forceFlush ) throws Throwable { for ( String compactOption : new String [ ] { <str> , <str> } ) { createTable ( <str> + <str> + <str> + <str> + <str> + compactOption ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; flush ( forceFlush ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; if ( isEmpty ( compactOption ) ) { assertRows ( execute ( <str> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , null ) ) ; } else { assertEmpty ( execute ( <str> , <int> , <int> , <int> ) ) ; } execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertEmpty ( execute ( <str> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; Object [ ] [ ] rows ; if ( isEmpty ( compactOption ) ) { rows = new Object [ ] [ ] { row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , null ) , row ( <int> , <int> , <int> , null ) , row ( <int> , <int> , <int> , <int> ) } ; } else { rows = new Object [ ] [ ] { row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) } ; } execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , rows ) ; if ( isEmpty ( compactOption ) ) { rows = new Object [ ] [ ] { row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , null ) } ; } else { rows = new Object [ ] [ ] { row ( <int> , <int> , <int> , <int> ) } ; } execute ( <str> , <int> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , rows ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; String errorMsg = isEmpty ( compactOption ) ? <str> : <str> ; assertInvalidMessage ( errorMsg , <str> , <int> , <int> , <int> , <int> ) ; } } @Test public void testDeleteWithRangeAndOneClusteringColumn ( ) throws Throwable { testDeleteWithRangeAndOneClusteringColumn ( false ) ; testDeleteWithRangeAndOneClusteringColumn ( true ) ; } private void testDeleteWithRangeAndOneClusteringColumn ( boolean forceFlush ) throws Throwable { for ( String compactOption : new String [ ] { <str> , <str> } ) { createTable ( <str> + <str> + <str> + <str> + compactOption ) ; int value = <int> ; for ( int partitionKey = <int> ; partitionKey < <int> ; partitionKey + + ) for ( int clustering1 = <int> ; clustering1 < <int> ; clustering1 + + ) execute ( <str> , partitionKey , clustering1 , value + + ) ; flush ( forceFlush ) ; execute ( <str> , <int> ) ; flush ( forceFlush ) ; assertEmpty ( execute ( <str> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> ) ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; } } @Test public void testDeleteWithRangeAndTwoClusteringColumns ( ) throws Throwable { testDeleteWithRangeAndTwoClusteringColumns ( false ) ; testDeleteWithRangeAndTwoClusteringColumns ( true ) ; } private void testDeleteWithRangeAndTwoClusteringColumns ( boolean forceFlush ) throws Throwable { for ( String compactOption : new String [ ] { <str> , <str> } ) { createTable ( <str> + <str> + <str> + <str> + <str> + compactOption ) ; int value = <int> ; for ( int partitionKey = <int> ; partitionKey < <int> ; partitionKey + + ) for ( int clustering1 = <int> ; clustering1 < <int> ; clustering1 + + ) for ( int clustering2 = <int> ; clustering2 < <int> ; clustering2 + + ) { execute ( <str> , partitionKey , clustering1 , clustering2 , value + + ) ; } flush ( forceFlush ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> ) ; flush ( forceFlush ) ; assertEmpty ( execute ( <str> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> , <int> ) , row ( <int> , <int> , <int> , <int> ) ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; } } @Test public void testDeleteWithAStaticColumn ( ) throws Throwable { testDeleteWithAStaticColumn ( false ) ; testDeleteWithAStaticColumn ( true ) ; } private void testDeleteWithAStaticColumn ( boolean forceFlush ) throws Throwable { createTable ( <str> + <str> + <str> + <str> + <str> + <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; flush ( forceFlush ) ; execute ( <str> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> , <int> , <int> ) , row ( new Object [ <int> ] ) , row ( <str> ) ) ; execute ( <str> , <int> , <int> , <int> ) ; flush ( forceFlush ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> , null , null ) , row ( <int> , <int> , <int> , null , <int> ) , row ( <int> , <int> , <int> , null , <int> ) ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; } @Test public void testDeleteWithSecondaryIndices ( ) throws Throwable { testDeleteWithSecondaryIndices ( false ) ; testDeleteWithSecondaryIndices ( true ) ; } private void testDeleteWithSecondaryIndices ( boolean forceFlush ) throws Throwable { createTable ( <str> + <str> + <str> + <str> + <str> ) ; createIndex ( <str> ) ; createIndex ( <str> ) ; createIndex ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; flush ( forceFlush ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; assertInvalidMessage ( <str> , <str> , <int> ) ; } private void flush ( boolean forceFlush ) { if ( forceFlush ) flush ( ) ; } } 
