package org . elasticsearch . search . functionscore ; import org . elasticsearch . Version ; import org . elasticsearch . action . ActionFuture ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . lucene . search . function . CombineFunction ; import org . elasticsearch . common . lucene . search . function . FiltersFunctionScoreQuery ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . query . functionscore . FunctionScoreQueryBuilder ; import org . elasticsearch . search . MultiValueMode ; import org . elasticsearch . search . SearchHits ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . VersionUtils ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import java . util . ArrayList ; import java . util . List ; import java . util . Locale ; import static org . elasticsearch . client . Requests . indexRequest ; import static org . elasticsearch . client . Requests . searchRequest ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . constantScoreQuery ; import static org . elasticsearch . index . query . QueryBuilders . functionScoreQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . index . query . functionscore . ScoreFunctionBuilders . exponentialDecayFunction ; import static org . elasticsearch . index . query . functionscore . ScoreFunctionBuilders . gaussDecayFunction ; import static org . elasticsearch . index . query . functionscore . ScoreFunctionBuilders . linearDecayFunction ; import static org . elasticsearch . search . builder . SearchSourceBuilder . searchSource ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertOrderedSearchHits ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchHits ; import static org . hamcrest . Matchers . anyOf ; import static org . hamcrest . Matchers . closeTo ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . isOneOf ; import static org . hamcrest . Matchers . lessThan ; public class DecayFunctionScoreIT extends ESIntegTestCase { public void testDistanceScoreGeoLinGaussExp ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; List < IndexRequestBuilder > indexBuilders = new ArrayList < > ( ) ; indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) ) ; indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) ) ; int numDummyDocs = <int> ; for ( int i = <int> ; i < = numDummyDocs ; i + + ) { indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( Integer . toString ( i + <int> ) ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> + i ) . field ( <str> , <int> + i ) . endObject ( ) . endObject ( ) ) ) ; } indexRandom ( true , indexBuilders ) ; List < Float > lonlat = new ArrayList < > ( ) ; lonlat . add ( <int> f ) ; lonlat . add ( <int> f ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( constantScoreQuery ( termQuery ( <str> , <str> ) ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( constantScoreQuery ( termQuery ( <str> , <str> ) ) , gaussDecayFunction ( <str> , lonlat , <str> ) ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( constantScoreQuery ( termQuery ( <str> , <str> ) ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( constantScoreQuery ( termQuery ( <str> , <str> ) ) , linearDecayFunction ( <str> , lonlat , <str> ) ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( constantScoreQuery ( termQuery ( <str> , <str> ) ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( constantScoreQuery ( termQuery ( <str> , <str> ) ) , exponentialDecayFunction ( <str> , lonlat , <str> ) ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; } public void testDistanceScoreGeoLinGaussExpWithOffset ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; List < IndexRequestBuilder > indexBuilders = new ArrayList < > ( ) ; indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <float> ) . endObject ( ) ) ) ; indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <float> ) . endObject ( ) ) ) ; int numDummyDocs = <int> ; for ( int i = <int> ; i < numDummyDocs ; i + + ) { indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( Integer . toString ( i + <int> ) ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <float> + i ) . endObject ( ) ) ) ; } indexRandom ( true , indexBuilders ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . size ( numDummyDocs + <int> ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <float> , <float> , <float> ) ) . boostMode ( CombineFunction . REPLACE ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( sh . getAt ( <int> ) . score ( ) , equalTo ( sh . getAt ( <int> ) . score ( ) ) ) ; for ( int i = <int> ; i < numDummyDocs ; i + + ) { assertThat ( sh . getAt ( i + <int> ) . getId ( ) , equalTo ( Integer . toString ( i + <int> ) ) ) ; } response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . size ( numDummyDocs + <int> ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , exponentialDecayFunction ( <str> , <float> , <float> , <float> ) ) . boostMode ( CombineFunction . REPLACE ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( sh . getAt ( <int> ) . score ( ) , equalTo ( sh . getAt ( <int> ) . score ( ) ) ) ; for ( int i = <int> ; i < numDummyDocs ; i + + ) { assertThat ( sh . getAt ( i + <int> ) . getId ( ) , equalTo ( Integer . toString ( i + <int> ) ) ) ; } response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . size ( numDummyDocs + <int> ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , linearDecayFunction ( <str> , <float> , <float> , <float> ) ) . boostMode ( CombineFunction . REPLACE ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( numDummyDocs + <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , anyOf ( equalTo ( <str> ) , equalTo ( <str> ) ) ) ; assertThat ( sh . getAt ( <int> ) . score ( ) , equalTo ( sh . getAt ( <int> ) . score ( ) ) ) ; } public void testBoostModeSettingWorks ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; List < IndexRequestBuilder > indexBuilders = new ArrayList < > ( ) ; indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) ) ; indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) ) ; indexRandom ( true , false , indexBuilders ) ; List < Float > lonlat = new ArrayList < > ( ) ; lonlat . add ( <int> f ) ; lonlat . add ( <int> f ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , lonlat , <str> ) ) . boostMode ( CombineFunction . MULTIPLY ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , isOneOf ( <str> ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , lonlat , <str> ) ) . boostMode ( CombineFunction . REPLACE ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; } public void testParseGeoPoint ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) . setRefresh ( true ) . get ( ) ; GeoPoint point = new GeoPoint ( <int> , <int> ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , point , <str> ) ) . boostMode ( CombineFunction . MULTIPLY ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( double ) sh . getAt ( <int> ) . score ( ) , closeTo ( <float> , <float> ) ) ; float [ ] coords = { <int> , <int> } ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , coords , <str> ) ) . boostMode ( CombineFunction . MULTIPLY ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( double ) sh . getAt ( <int> ) . score ( ) , closeTo ( <float> , <float> ) ) ; } public void testCombineModes ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <float> ) . endObject ( ) ) . setRefresh ( true ) . get ( ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <float> , <float> , null , <float> ) ) . boost ( <float> ) . boostMode ( CombineFunction . MULTIPLY ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( double ) sh . getAt ( <int> ) . score ( ) , closeTo ( <float> , <float> ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <float> , <float> , null , <float> ) ) . boost ( <float> ) . boostMode ( CombineFunction . REPLACE ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( double ) sh . getAt ( <int> ) . score ( ) , closeTo ( <float> , <float> ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <float> , <float> , null , <float> ) ) . boost ( <float> ) . boostMode ( CombineFunction . SUM ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( double ) sh . getAt ( <int> ) . score ( ) , closeTo ( <float> + <float> , <float> ) ) ; logger . info ( <str> , sr . getHits ( ) . getAt ( <int> ) . id ( ) , sr . getHits ( ) . getAt ( <int> ) . explanation ( ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <float> , <float> , null , <float> ) ) . boost ( <float> ) . boostMode ( CombineFunction . AVG ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( double ) sh . getAt ( <int> ) . score ( ) , closeTo ( ( <float> + <float> ) / <int> , <float> ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <float> , <float> , null , <float> ) ) . boost ( <float> ) . boostMode ( CombineFunction . MIN ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( double ) sh . getAt ( <int> ) . score ( ) , closeTo ( <float> , <float> ) ) ; response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <float> , <float> , null , <float> ) ) . boost ( <float> ) . boostMode ( CombineFunction . MAX ) ) ) ) ; sr = response . actionGet ( ) ; sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( double ) sh . getAt ( <int> ) . score ( ) , closeTo ( <float> , <float> ) ) ; } public void testExceptionThrownIfScaleLE0 ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) . actionGet ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) . actionGet ( ) ; refresh ( ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <str> , <str> ) ) ) ) ) ; try { response . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParseDateMath ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , System . currentTimeMillis ( ) ) . endObject ( ) ) ) . actionGet ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , System . currentTimeMillis ( ) - ( <int> * <int> * <int> * <int> ) ) . endObject ( ) ) ) . actionGet ( ) ; refresh ( ) ; SearchResponse sr = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <str> , <str> ) ) ) ) ) . get ( ) ; assertNoFailures ( sr ) ; assertOrderedSearchHits ( sr , <str> , <str> ) ; sr = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , gaussDecayFunction ( <str> , <str> , <str> ) ) ) ) ) . get ( ) ; assertNoFailures ( sr ) ; assertOrderedSearchHits ( sr , <str> , <str> ) ; } public void testValueMissingLin ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) . actionGet ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) . actionGet ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) . actionGet ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) . actionGet ( ) ; refresh ( ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( constantScoreQuery ( termQuery ( <str> , <str> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( linearDecayFunction ( <str> , <str> , <str> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( linearDecayFunction ( <str> , <str> , <str> ) ) } ) . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . MULTIPLY ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; assertNoFailures ( sr ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . hits ( ) . length , equalTo ( <int> ) ) ; double [ ] scores = new double [ <int> ] ; for ( int i = <int> ; i < sh . hits ( ) . length ; i + + ) { scores [ Integer . parseInt ( sh . getAt ( i ) . getId ( ) ) - <int> ] = sh . getAt ( i ) . getScore ( ) ; } assertThat ( scores [ <int> ] , lessThan ( scores [ <int> ] ) ) ; assertThat ( scores [ <int> ] , lessThan ( scores [ <int> ] ) ) ; } public void testDateWithoutOrigin ( ) throws Exception { DateTime dt = new DateTime ( DateTimeZone . UTC ) ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; DateTime docDate = dt . minusDays ( <int> ) ; String docDateString = docDate . getYear ( ) + <str> + String . format ( Locale . ROOT , <str> , docDate . getMonthOfYear ( ) ) + <str> + String . format ( Locale . ROOT , <str> , docDate . getDayOfMonth ( ) ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , docDateString ) . endObject ( ) ) ) . actionGet ( ) ; docDate = dt . minusDays ( <int> ) ; docDateString = docDate . getYear ( ) + <str> + String . format ( Locale . ROOT , <str> , docDate . getMonthOfYear ( ) ) + <str> + String . format ( Locale . ROOT , <str> , docDate . getDayOfMonth ( ) ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , docDateString ) . endObject ( ) ) ) . actionGet ( ) ; docDate = dt . minusDays ( <int> ) ; docDateString = docDate . getYear ( ) + <str> + String . format ( Locale . ROOT , <str> , docDate . getMonthOfYear ( ) ) + <str> + String . format ( Locale . ROOT , <str> , docDate . getDayOfMonth ( ) ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . id ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , docDateString ) . endObject ( ) ) ) . actionGet ( ) ; refresh ( ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( QueryBuilders . matchAllQuery ( ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( linearDecayFunction ( <str> , null , <str> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( gaussDecayFunction ( <str> , null , <str> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( exponentialDecayFunction ( <str> , null , <str> ) ) } ) . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . MULTIPLY ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; assertNoFailures ( sr ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . hits ( ) . length , equalTo ( <int> ) ) ; double [ ] scores = new double [ <int> ] ; for ( int i = <int> ; i < sh . hits ( ) . length ; i + + ) { scores [ Integer . parseInt ( sh . getAt ( i ) . getId ( ) ) - <int> ] = sh . getAt ( i ) . getScore ( ) ; } assertThat ( scores [ <int> ] , lessThan ( scores [ <int> ] ) ) ; assertThat ( scores [ <int> ] , lessThan ( scores [ <int> ] ) ) ; } public void testManyDocsLin ( ) throws Exception { Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_2_0_0 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; XContentBuilder xContentBuilder = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) ; if ( version . before ( Version . V_2_2_0 ) ) { xContentBuilder . field ( <str> , true ) ; } xContentBuilder . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , xContentBuilder . string ( ) ) ) ; ensureYellow ( ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { double lat = <int> + ( int ) ( <float> * ( i ) / ( numDocs ) ) ; double lon = <int> ; int day = ( int ) ( <float> * ( i ) / ( numDocs ) ) + <int> ; String dayString = day < <int> ? <str> + Integer . toString ( day ) : Integer . toString ( day ) ; String date = <str> + dayString ; indexBuilders . add ( client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( Integer . toString ( i ) ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , date ) . field ( <str> , i ) . startObject ( <str> ) . field ( <str> , lat ) . field ( <str> , lon ) . endObject ( ) . endObject ( ) ) ) ; } indexRandom ( true , indexBuilders ) ; List < Float > lonlat = new ArrayList < > ( ) ; lonlat . add ( <int> f ) ; lonlat . add ( <int> f ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . size ( numDocs ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder [ ] { new FunctionScoreQueryBuilder . FilterFunctionBuilder ( linearDecayFunction ( <str> , <str> , <str> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( linearDecayFunction ( <str> , lonlat , <str> ) ) , new FunctionScoreQueryBuilder . FilterFunctionBuilder ( linearDecayFunction ( <str> , numDocs , numDocs / <float> ) ) } ) . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . MULTIPLY ) . boostMode ( CombineFunction . REPLACE ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; assertNoFailures ( sr ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . hits ( ) . length , equalTo ( numDocs ) ) ; double [ ] scores = new double [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { scores [ Integer . parseInt ( sh . getAt ( i ) . getId ( ) ) ] = sh . getAt ( i ) . getScore ( ) ; } for ( int i = <int> ; i < numDocs - <int> ; i + + ) { assertThat ( scores [ i ] , lessThan ( scores [ i + <int> ] ) ) ; } } public void testParsingExceptionIfFieldDoesNotExist ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; int numDocs = <int> ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) ) . actionGet ( ) ; refresh ( ) ; List < Float > lonlat = new ArrayList < > ( ) ; lonlat . add ( <int> f ) ; lonlat . add ( <int> f ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . size ( numDocs ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , linearDecayFunction ( <str> , lonlat , <str> ) ) . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . MULTIPLY ) ) ) ) ; try { response . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testParsingExceptionIfFieldTypeDoesNotMatch ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , Integer . toString ( <int> ) ) . endObject ( ) ) ) . actionGet ( ) ; refresh ( ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( termQuery ( <str> , <str> ) , linearDecayFunction ( <str> , <float> , <float> ) ) . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . MULTIPLY ) ) ) ) ; try { response . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testNoQueryGiven ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; client ( ) . index ( indexRequest ( <str> ) . type ( <str> ) . source ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <float> ) . endObject ( ) ) ) . actionGet ( ) ; refresh ( ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . searchType ( SearchType . QUERY_THEN_FETCH ) . source ( searchSource ( ) . query ( functionScoreQuery ( linearDecayFunction ( <str> , <int> , <float> ) ) . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . MULTIPLY ) ) ) ) ; response . actionGet ( ) ; } public void testMultiFieldOptions ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureYellow ( ) ; IndexRequestBuilder doc1 = client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . startObject ( ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endArray ( ) . endObject ( ) ) ; IndexRequestBuilder doc2 = client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <int> ) . field ( <str> , <int> ) . endObject ( ) . endObject ( ) ) ; indexRandom ( true , doc1 , doc2 ) ; ActionFuture < SearchResponse > response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( constantScoreQuery ( termQuery ( <str> , <str> ) ) ) ) ) ; SearchResponse sr = response . actionGet ( ) ; assertSearchHits ( sr , <str> , <str> ) ; SearchHits sh = sr . getHits ( ) ; assertThat ( sh . getTotalHits ( ) , equalTo ( ( long ) ( <int> ) ) ) ; List < Float > lonlat = new ArrayList < > ( ) ; lonlat . add ( <int> f ) ; lonlat . add ( <int> f ) ; response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( constantScoreQuery ( termQuery ( <str> , <str> ) ) , gaussDecayFunction ( <str> , lonlat , <str> ) . setMultiValueMode ( MultiValueMode . MIN ) ) ) ) ) ; sr = response . actionGet ( ) ; assertSearchHits ( sr , <str> , <str> ) ; sh = sr . getHits ( ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( constantScoreQuery ( termQuery ( <str> , <str> ) ) , gaussDecayFunction ( <str> , lonlat , <str> ) . setMultiValueMode ( MultiValueMode . MAX ) ) ) ) ) ; sr = response . actionGet ( ) ; assertSearchHits ( sr , <str> , <str> ) ; sh = sr . getHits ( ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; doc1 = client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) ) ; doc2 = client ( ) . prepareIndex ( ) . setType ( <str> ) . setId ( <str> ) . setIndex ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <float> ) . endObject ( ) ) ; indexRandom ( true , doc1 , doc2 ) ; response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( constantScoreQuery ( termQuery ( <str> , <str> ) ) , linearDecayFunction ( <str> , <str> , <str> ) . setMultiValueMode ( MultiValueMode . SUM ) ) ) ) ) ; sr = response . actionGet ( ) ; assertSearchHits ( sr , <str> , <str> ) ; sh = sr . getHits ( ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( sh . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( <float> - sh . getAt ( <int> ) . getScore ( ) , closeTo ( ( <float> - sh . getAt ( <int> ) . getScore ( ) ) / <float> , <float> ) ) ; response = client ( ) . search ( searchRequest ( ) . source ( searchSource ( ) . query ( functionScoreQuery ( constantScoreQuery ( termQuery ( <str> , <str> ) ) , linearDecayFunction ( <str> , <str> , <str> ) . setMultiValueMode ( MultiValueMode . AVG ) ) ) ) ) ; sr = response . actionGet ( ) ; assertSearchHits ( sr , <str> , <str> ) ; sh = sr . getHits ( ) ; assertThat ( ( double ) ( sh . getAt ( <int> ) . getScore ( ) ) , closeTo ( ( sh . getAt ( <int> ) . getScore ( ) ) , <float> ) ) ; } } 
