package org . elasticsearch . search . aggregations . bucket . terms ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . util . Comparators ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . bucket . BucketsAggregator ; import org . elasticsearch . search . aggregations . bucket . MultiBucketsAggregation ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregator ; import org . elasticsearch . search . aggregations . bucket . terms . Terms . Bucket ; import org . elasticsearch . search . aggregations . bucket . terms . Terms . Order ; import org . elasticsearch . search . aggregations . metrics . NumericMetricsAggregator ; import org . elasticsearch . search . aggregations . support . AggregationPath ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; class InternalOrder extends Terms . Order { private static final byte COUNT_DESC_ID = <int> ; private static final byte COUNT_ASC_ID = <int> ; private static final byte TERM_DESC_ID = <int> ; private static final byte TERM_ASC_ID = <int> ; public static final InternalOrder COUNT_DESC = new InternalOrder ( COUNT_DESC_ID , <str> , false , new Comparator < Terms . Bucket > ( ) { @Override public int compare ( Terms . Bucket o1 , Terms . Bucket o2 ) { return Long . compare ( o2 . getDocCount ( ) , o1 . getDocCount ( ) ) ; } } ) ; public static final InternalOrder COUNT_ASC = new InternalOrder ( COUNT_ASC_ID , <str> , true , new Comparator < Terms . Bucket > ( ) { @Override public int compare ( Terms . Bucket o1 , Terms . Bucket o2 ) { return Long . compare ( o1 . getDocCount ( ) , o2 . getDocCount ( ) ) ; } } ) ; public static final InternalOrder TERM_DESC = new InternalOrder ( TERM_DESC_ID , <str> , false , new Comparator < Terms . Bucket > ( ) { @Override public int compare ( Terms . Bucket o1 , Terms . Bucket o2 ) { return o2 . compareTerm ( o1 ) ; } } ) ; public static final InternalOrder TERM_ASC = new InternalOrder ( TERM_ASC_ID , <str> , true , new Comparator < Terms . Bucket > ( ) { @Override public int compare ( Terms . Bucket o1 , Terms . Bucket o2 ) { return o1 . compareTerm ( o2 ) ; } } ) ; public static boolean isCountDesc ( Terms . Order order ) { if ( order = = COUNT_DESC ) { return true ; } else if ( order instanceof CompoundOrder ) { CompoundOrder compoundOrder = ( CompoundOrder ) order ; if ( compoundOrder . orderElements . size ( ) = = <int> & & compoundOrder . orderElements . get ( <int> ) = = COUNT_DESC & & compoundOrder . orderElements . get ( <int> ) = = TERM_ASC ) { return true ; } } return false ; } final byte id ; final String key ; final boolean asc ; protected final Comparator < Terms . Bucket > comparator ; InternalOrder ( byte id , String key , boolean asc , Comparator < Terms . Bucket > comparator ) { this . id = id ; this . key = key ; this . asc = asc ; this . comparator = comparator ; } @Override byte id ( ) { return id ; } @Override protected Comparator < Terms . Bucket > comparator ( Aggregator aggregator ) { return comparator ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { return builder . startObject ( ) . field ( key , asc ? <str> : <str> ) . endObject ( ) ; } public static Terms . Order validate ( Terms . Order order , Aggregator termsAggregator ) { if ( order instanceof CompoundOrder ) { for ( Terms . Order innerOrder : ( ( CompoundOrder ) order ) . orderElements ) { validate ( innerOrder , termsAggregator ) ; } return order ; } else if ( ! ( order instanceof Aggregation ) ) { return order ; } AggregationPath path = ( ( Aggregation ) order ) . path ( ) ; path . validate ( termsAggregator ) ; return order ; } static class Aggregation extends InternalOrder { static final byte ID = <int> ; Aggregation ( String key , boolean asc ) { super ( ID , key , asc , new MultiBucketsAggregation . Bucket . SubAggregationComparator < Terms . Bucket > ( key , asc ) ) ; } AggregationPath path ( ) { return ( ( MultiBucketsAggregation . Bucket . SubAggregationComparator ) comparator ) . path ( ) ; } @Override protected Comparator < Terms . Bucket > comparator ( Aggregator termsAggregator ) { if ( termsAggregator = = null ) { return comparator ; } AggregationPath path = path ( ) ; final Aggregator aggregator = path . resolveAggregator ( termsAggregator ) ; final String key = path . lastPathElement ( ) . key ; if ( aggregator instanceof SingleBucketAggregator ) { assert key = = null : <str> ; return new Comparator < Terms . Bucket > ( ) { @Override public int compare ( Terms . Bucket o1 , Terms . Bucket o2 ) { int mul = asc ? <int> : - <int> ; int v1 = ( ( SingleBucketAggregator ) aggregator ) . bucketDocCount ( ( ( InternalTerms . Bucket ) o1 ) . bucketOrd ) ; int v2 = ( ( SingleBucketAggregator ) aggregator ) . bucketDocCount ( ( ( InternalTerms . Bucket ) o2 ) . bucketOrd ) ; return mul * ( v1 - v2 ) ; } } ; } assert ! ( aggregator instanceof BucketsAggregator ) : <str> ; if ( aggregator instanceof NumericMetricsAggregator . MultiValue ) { assert key ! = null : <str> ; return new Comparator < Terms . Bucket > ( ) { @Override public int compare ( Terms . Bucket o1 , Terms . Bucket o2 ) { double v1 = ( ( NumericMetricsAggregator . MultiValue ) aggregator ) . metric ( key , ( ( InternalTerms . Bucket ) o1 ) . bucketOrd ) ; double v2 = ( ( NumericMetricsAggregator . MultiValue ) aggregator ) . metric ( key , ( ( InternalTerms . Bucket ) o2 ) . bucketOrd ) ; return Comparators . compareDiscardNaN ( v1 , v2 , asc ) ; } } ; } return new Comparator < Terms . Bucket > ( ) { @Override public int compare ( Terms . Bucket o1 , Terms . Bucket o2 ) { double v1 = ( ( NumericMetricsAggregator . SingleValue ) aggregator ) . metric ( ( ( InternalTerms . Bucket ) o1 ) . bucketOrd ) ; double v2 = ( ( NumericMetricsAggregator . SingleValue ) aggregator ) . metric ( ( ( InternalTerms . Bucket ) o2 ) . bucketOrd ) ; return Comparators . compareDiscardNaN ( v1 , v2 , asc ) ; } } ; } } static class CompoundOrder extends Terms . Order { static final byte ID = - <int> ; private final List < Terms . Order > orderElements ; public CompoundOrder ( List < Terms . Order > compoundOrder ) { this ( compoundOrder , true ) ; } public CompoundOrder ( List < Terms . Order > compoundOrder , boolean absoluteOrdering ) { this . orderElements = new LinkedList < > ( compoundOrder ) ; Terms . Order lastElement = compoundOrder . get ( compoundOrder . size ( ) - <int> ) ; if ( absoluteOrdering & & ! ( InternalOrder . TERM_ASC = = lastElement | | InternalOrder . TERM_DESC = = lastElement ) ) { this . orderElements . add ( Order . term ( true ) ) ; } } @Override byte id ( ) { return ID ; } List < Terms . Order > orderElements ( ) { return Collections . unmodifiableList ( orderElements ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startArray ( ) ; for ( Terms . Order order : orderElements ) { order . toXContent ( builder , params ) ; } return builder . endArray ( ) ; } @Override protected Comparator < Bucket > comparator ( Aggregator aggregator ) { return new CompoundOrderComparator ( orderElements , aggregator ) ; } public static class CompoundOrderComparator implements Comparator < Terms . Bucket > { private List < Terms . Order > compoundOrder ; private Aggregator aggregator ; public CompoundOrderComparator ( List < Terms . Order > compoundOrder , Aggregator aggregator ) { this . compoundOrder = compoundOrder ; this . aggregator = aggregator ; } @Override public int compare ( Bucket o1 , Bucket o2 ) { int result = <int> ; for ( Iterator < Terms . Order > itr = compoundOrder . iterator ( ) ; itr . hasNext ( ) & & result = = <int> ; ) { result = itr . next ( ) . comparator ( aggregator ) . compare ( o1 , o2 ) ; } return result ; } } } public static class Streams { public static void writeOrder ( Terms . Order order , StreamOutput out ) throws IOException { if ( order instanceof Aggregation ) { out . writeByte ( order . id ( ) ) ; Aggregation aggregationOrder = ( Aggregation ) order ; out . writeBoolean ( ( ( MultiBucketsAggregation . Bucket . SubAggregationComparator ) aggregationOrder . comparator ) . asc ( ) ) ; AggregationPath path = ( ( Aggregation ) order ) . path ( ) ; out . writeString ( path . toString ( ) ) ; } else if ( order instanceof CompoundOrder ) { CompoundOrder compoundOrder = ( CompoundOrder ) order ; out . writeByte ( order . id ( ) ) ; out . writeVInt ( compoundOrder . orderElements . size ( ) ) ; for ( Terms . Order innerOrder : compoundOrder . orderElements ) { Streams . writeOrder ( innerOrder , out ) ; } } else { out . writeByte ( order . id ( ) ) ; } } public static Terms . Order readOrder ( StreamInput in ) throws IOException { return readOrder ( in , true ) ; } public static Terms . Order readOrder ( StreamInput in , boolean absoluteOrder ) throws IOException { byte id = in . readByte ( ) ; switch ( id ) { case COUNT_DESC_ID : return absoluteOrder ? new CompoundOrder ( Collections . singletonList ( ( Terms . Order ) InternalOrder . COUNT_DESC ) ) : InternalOrder . COUNT_DESC ; case COUNT_ASC_ID : return absoluteOrder ? new CompoundOrder ( Collections . singletonList ( ( Terms . Order ) InternalOrder . COUNT_ASC ) ) : InternalOrder . COUNT_ASC ; case TERM_DESC_ID : return InternalOrder . TERM_DESC ; case TERM_ASC_ID : return InternalOrder . TERM_ASC ; case Aggregation . ID : boolean asc = in . readBoolean ( ) ; String key = in . readString ( ) ; return new InternalOrder . Aggregation ( key , asc ) ; case CompoundOrder . ID : int size = in . readVInt ( ) ; List < Terms . Order > compoundOrder = new ArrayList < > ( size ) ; for ( int i = <int> ; i < size ; i + + ) { compoundOrder . add ( Streams . readOrder ( in , false ) ) ; } return new CompoundOrder ( compoundOrder , absoluteOrder ) ; default : throw new RuntimeException ( <str> ) ; } } } } 
