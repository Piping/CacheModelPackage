package io . netty . handler . codec . spdy ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToMessageDecoder ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpMessage ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpResponseStatus ; import io . netty . handler . codec . http . HttpVersion ; import io . netty . handler . codec . spdy . SpdyHttpHeaders . Names ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static io . netty . handler . codec . spdy . SpdyHeaders . HttpNames . * ; public class SpdyHttpDecoder extends MessageToMessageDecoder < SpdyFrame > { private final boolean validateHeaders ; private final int spdyVersion ; private final int maxContentLength ; private final Map < Integer , FullHttpMessage > messageMap ; public SpdyHttpDecoder ( SpdyVersion version , int maxContentLength ) { this ( version , maxContentLength , new HashMap < Integer , FullHttpMessage > ( ) , true ) ; } public SpdyHttpDecoder ( SpdyVersion version , int maxContentLength , boolean validateHeaders ) { this ( version , maxContentLength , new HashMap < Integer , FullHttpMessage > ( ) , validateHeaders ) ; } protected SpdyHttpDecoder ( SpdyVersion version , int maxContentLength , Map < Integer , FullHttpMessage > messageMap ) { this ( version , maxContentLength , messageMap , true ) ; } protected SpdyHttpDecoder ( SpdyVersion version , int maxContentLength , Map < Integer , FullHttpMessage > messageMap , boolean validateHeaders ) { if ( version = = null ) { throw new NullPointerException ( <str> ) ; } if ( maxContentLength < = <int> ) { throw new IllegalArgumentException ( <str> + maxContentLength ) ; } spdyVersion = version . getVersion ( ) ; this . maxContentLength = maxContentLength ; this . messageMap = messageMap ; this . validateHeaders = validateHeaders ; } protected FullHttpMessage putMessage ( int streamId , FullHttpMessage message ) { return messageMap . put ( streamId , message ) ; } protected FullHttpMessage getMessage ( int streamId ) { return messageMap . get ( streamId ) ; } protected FullHttpMessage removeMessage ( int streamId ) { return messageMap . remove ( streamId ) ; } @Override protected void decode ( ChannelHandlerContext ctx , SpdyFrame msg , List < Object > out ) throws Exception { if ( msg instanceof SpdySynStreamFrame ) { SpdySynStreamFrame spdySynStreamFrame = ( SpdySynStreamFrame ) msg ; int streamId = spdySynStreamFrame . streamId ( ) ; if ( SpdyCodecUtil . isServerId ( streamId ) ) { int associatedToStreamId = spdySynStreamFrame . associatedStreamId ( ) ; if ( associatedToStreamId = = <int> ) { SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamId , SpdyStreamStatus . INVALID_STREAM ) ; ctx . writeAndFlush ( spdyRstStreamFrame ) ; return ; } if ( spdySynStreamFrame . isLast ( ) ) { SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamId , SpdyStreamStatus . PROTOCOL_ERROR ) ; ctx . writeAndFlush ( spdyRstStreamFrame ) ; return ; } if ( spdySynStreamFrame . isTruncated ( ) ) { SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamId , SpdyStreamStatus . INTERNAL_ERROR ) ; ctx . writeAndFlush ( spdyRstStreamFrame ) ; return ; } try { FullHttpRequest httpRequestWithEntity = createHttpRequest ( spdyVersion , spdySynStreamFrame ) ; httpRequestWithEntity . headers ( ) . setInt ( Names . STREAM_ID , streamId ) ; httpRequestWithEntity . headers ( ) . setInt ( Names . ASSOCIATED_TO_STREAM_ID , associatedToStreamId ) ; httpRequestWithEntity . headers ( ) . setInt ( Names . PRIORITY , spdySynStreamFrame . priority ( ) ) ; out . add ( httpRequestWithEntity ) ; } catch ( Exception ignored ) { SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamId , SpdyStreamStatus . PROTOCOL_ERROR ) ; ctx . writeAndFlush ( spdyRstStreamFrame ) ; } } else { if ( spdySynStreamFrame . isTruncated ( ) ) { SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame ( streamId ) ; spdySynReplyFrame . setLast ( true ) ; SpdyHeaders frameHeaders = spdySynReplyFrame . headers ( ) ; frameHeaders . setInt ( STATUS , HttpResponseStatus . REQUEST_HEADER_FIELDS_TOO_LARGE . code ( ) ) ; frameHeaders . setObject ( VERSION , HttpVersion . HTTP_1_0 ) ; ctx . writeAndFlush ( spdySynReplyFrame ) ; return ; } try { FullHttpRequest httpRequestWithEntity = createHttpRequest ( spdyVersion , spdySynStreamFrame ) ; httpRequestWithEntity . headers ( ) . setInt ( Names . STREAM_ID , streamId ) ; if ( spdySynStreamFrame . isLast ( ) ) { out . add ( httpRequestWithEntity ) ; } else { putMessage ( streamId , httpRequestWithEntity ) ; } } catch ( Exception e ) { SpdySynReplyFrame spdySynReplyFrame = new DefaultSpdySynReplyFrame ( streamId ) ; spdySynReplyFrame . setLast ( true ) ; SpdyHeaders frameHeaders = spdySynReplyFrame . headers ( ) ; frameHeaders . setInt ( STATUS , HttpResponseStatus . BAD_REQUEST . code ( ) ) ; frameHeaders . setObject ( VERSION , HttpVersion . HTTP_1_0 ) ; ctx . writeAndFlush ( spdySynReplyFrame ) ; } } } else if ( msg instanceof SpdySynReplyFrame ) { SpdySynReplyFrame spdySynReplyFrame = ( SpdySynReplyFrame ) msg ; int streamId = spdySynReplyFrame . streamId ( ) ; if ( spdySynReplyFrame . isTruncated ( ) ) { SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamId , SpdyStreamStatus . INTERNAL_ERROR ) ; ctx . writeAndFlush ( spdyRstStreamFrame ) ; return ; } try { FullHttpResponse httpResponseWithEntity = createHttpResponse ( ctx , spdySynReplyFrame , validateHeaders ) ; httpResponseWithEntity . headers ( ) . setInt ( Names . STREAM_ID , streamId ) ; if ( spdySynReplyFrame . isLast ( ) ) { HttpUtil . setContentLength ( httpResponseWithEntity , <int> ) ; out . add ( httpResponseWithEntity ) ; } else { putMessage ( streamId , httpResponseWithEntity ) ; } } catch ( Exception e ) { SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamId , SpdyStreamStatus . PROTOCOL_ERROR ) ; ctx . writeAndFlush ( spdyRstStreamFrame ) ; } } else if ( msg instanceof SpdyHeadersFrame ) { SpdyHeadersFrame spdyHeadersFrame = ( SpdyHeadersFrame ) msg ; int streamId = spdyHeadersFrame . streamId ( ) ; FullHttpMessage fullHttpMessage = getMessage ( streamId ) ; if ( fullHttpMessage = = null ) { if ( SpdyCodecUtil . isServerId ( streamId ) ) { if ( spdyHeadersFrame . isTruncated ( ) ) { SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamId , SpdyStreamStatus . INTERNAL_ERROR ) ; ctx . writeAndFlush ( spdyRstStreamFrame ) ; return ; } try { fullHttpMessage = createHttpResponse ( ctx , spdyHeadersFrame , validateHeaders ) ; fullHttpMessage . headers ( ) . setInt ( Names . STREAM_ID , streamId ) ; if ( spdyHeadersFrame . isLast ( ) ) { HttpUtil . setContentLength ( fullHttpMessage , <int> ) ; out . add ( fullHttpMessage ) ; } else { putMessage ( streamId , fullHttpMessage ) ; } } catch ( Exception e ) { SpdyRstStreamFrame spdyRstStreamFrame = new DefaultSpdyRstStreamFrame ( streamId , SpdyStreamStatus . PROTOCOL_ERROR ) ; ctx . writeAndFlush ( spdyRstStreamFrame ) ; } } return ; } if ( ! spdyHeadersFrame . isTruncated ( ) ) { for ( Map . Entry < CharSequence , CharSequence > e : spdyHeadersFrame . headers ( ) ) { fullHttpMessage . headers ( ) . add ( e . getKey ( ) , e . getValue ( ) ) ; } } if ( spdyHeadersFrame . isLast ( ) ) { HttpUtil . setContentLength ( fullHttpMessage , fullHttpMessage . content ( ) . readableBytes ( ) ) ; removeMessage ( streamId ) ; out . add ( fullHttpMessage ) ; } } else if ( msg instanceof SpdyDataFrame ) { SpdyDataFrame spdyDataFrame = ( SpdyDataFrame ) msg ; int streamId = spdyDataFrame . streamId ( ) ; FullHttpMessage fullHttpMessage = getMessage ( streamId ) ; if ( fullHttpMessage = = null ) { return ; } ByteBuf content = fullHttpMessage . content ( ) ; if ( content . readableBytes ( ) > maxContentLength - spdyDataFrame . content ( ) . readableBytes ( ) ) { removeMessage ( streamId ) ; throw new TooLongFrameException ( <str> + maxContentLength + <str> ) ; } ByteBuf spdyDataFrameData = spdyDataFrame . content ( ) ; int spdyDataFrameDataLen = spdyDataFrameData . readableBytes ( ) ; content . writeBytes ( spdyDataFrameData , spdyDataFrameData . readerIndex ( ) , spdyDataFrameDataLen ) ; if ( spdyDataFrame . isLast ( ) ) { HttpUtil . setContentLength ( fullHttpMessage , content . readableBytes ( ) ) ; removeMessage ( streamId ) ; out . add ( fullHttpMessage ) ; } } else if ( msg instanceof SpdyRstStreamFrame ) { SpdyRstStreamFrame spdyRstStreamFrame = ( SpdyRstStreamFrame ) msg ; int streamId = spdyRstStreamFrame . streamId ( ) ; removeMessage ( streamId ) ; } } private static FullHttpRequest createHttpRequest ( int spdyVersion , SpdyHeadersFrame requestFrame ) throws Exception { SpdyHeaders headers = requestFrame . headers ( ) ; HttpMethod method = HttpMethod . valueOf ( headers . getAsString ( METHOD ) ) ; String url = headers . getAsString ( PATH ) ; HttpVersion httpVersion = HttpVersion . valueOf ( headers . getAsString ( VERSION ) ) ; headers . remove ( METHOD ) ; headers . remove ( PATH ) ; headers . remove ( VERSION ) ; FullHttpRequest req = new DefaultFullHttpRequest ( httpVersion , method , url ) ; headers . remove ( SCHEME ) ; CharSequence host = headers . get ( HOST ) ; headers . remove ( HOST ) ; req . headers ( ) . set ( HttpHeaderNames . HOST , host ) ; for ( Map . Entry < CharSequence , CharSequence > e : requestFrame . headers ( ) ) { req . headers ( ) . add ( e . getKey ( ) , e . getValue ( ) ) ; } HttpUtil . setKeepAlive ( req , true ) ; req . headers ( ) . remove ( HttpHeaderNames . TRANSFER_ENCODING ) ; return req ; } private static FullHttpResponse createHttpResponse ( ChannelHandlerContext ctx , SpdyHeadersFrame responseFrame , boolean validateHeaders ) throws Exception { SpdyHeaders headers = responseFrame . headers ( ) ; HttpResponseStatus status = HttpResponseStatus . parseLine ( headers . get ( STATUS ) ) ; HttpVersion version = HttpVersion . valueOf ( headers . getAsString ( VERSION ) ) ; headers . remove ( STATUS ) ; headers . remove ( VERSION ) ; FullHttpResponse res = new DefaultFullHttpResponse ( version , status , ctx . alloc ( ) . buffer ( ) , validateHeaders ) ; for ( Map . Entry < CharSequence , CharSequence > e : responseFrame . headers ( ) ) { res . headers ( ) . add ( e . getKey ( ) , e . getValue ( ) ) ; } HttpUtil . setKeepAlive ( res , true ) ; res . headers ( ) . remove ( HttpHeaderNames . TRANSFER_ENCODING ) ; res . headers ( ) . remove ( HttpHeaderNames . TRAILER ) ; return res ; } } 
