package io . netty . util ; import io . netty . util . internal . StringUtil ; import java . net . IDN ; import java . util . LinkedHashMap ; import java . util . Locale ; import java . util . Map ; import java . util . regex . Pattern ; public class DomainNameMapping < V > implements Mapping < String , V > { private static final Pattern DNS_WILDCARD_PATTERN = Pattern . compile ( <str> ) ; private final Map < String , V > map ; private final V defaultValue ; public DomainNameMapping ( V defaultValue ) { this ( <int> , defaultValue ) ; } public DomainNameMapping ( int initialCapacity , V defaultValue ) { if ( defaultValue = = null ) { throw new NullPointerException ( <str> ) ; } map = new LinkedHashMap < String , V > ( initialCapacity ) ; this . defaultValue = defaultValue ; } public DomainNameMapping < V > add ( String hostname , V output ) { if ( hostname = = null ) { throw new NullPointerException ( <str> ) ; } if ( output = = null ) { throw new NullPointerException ( <str> ) ; } map . put ( normalizeHostname ( hostname ) , output ) ; return this ; } private static boolean matches ( String hostNameTemplate , String hostName ) { if ( DNS_WILDCARD_PATTERN . matcher ( hostNameTemplate ) . matches ( ) ) { return hostNameTemplate . substring ( <int> ) . equals ( hostName ) | | hostName . endsWith ( hostNameTemplate . substring ( <int> ) ) ; } else { return hostNameTemplate . equals ( hostName ) ; } } private static String normalizeHostname ( String hostname ) { if ( needsNormalization ( hostname ) ) { hostname = IDN . toASCII ( hostname , IDN . ALLOW_UNASSIGNED ) ; } return hostname . toLowerCase ( Locale . US ) ; } private static boolean needsNormalization ( String hostname ) { final int length = hostname . length ( ) ; for ( int i = <int> ; i < length ; i + + ) { int c = hostname . charAt ( i ) ; if ( c > <hex> ) { return true ; } } return false ; } @Override public V map ( String input ) { if ( input ! = null ) { input = normalizeHostname ( input ) ; for ( Map . Entry < String , V > entry : map . entrySet ( ) ) { if ( matches ( entry . getKey ( ) , input ) ) { return entry . getValue ( ) ; } } } return defaultValue ; } @Override public String toString ( ) { return StringUtil . simpleClassName ( this ) + <str> + defaultValue + <str> + map + <str> ; } } 
