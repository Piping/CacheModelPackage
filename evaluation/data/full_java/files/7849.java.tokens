package org . elasticsearch . cluster . routing . allocation ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterInfo ; import org . elasticsearch . cluster . ClusterInfoService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . command . AllocationCommands ; import org . elasticsearch . cluster . routing . allocation . command . MoveAllocationCommand ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . test . ESAllocationTestCase ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . hamcrest . Matchers . equalTo ; public class ExpectedShardSizeAllocationTests extends ESAllocationTestCase { private final ESLogger logger = Loggers . getLogger ( ExpectedShardSizeAllocationTests . class ) ; public void testInitializingHasExpectedSize ( ) { final long byteSize = randomIntBetween ( <int> , Integer . MAX_VALUE ) ; AllocationService strategy = createAllocationService ( Settings . EMPTY , new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { return new ClusterInfo ( ) { @Override public Long getShardSize ( ShardRouting shardRouting ) { if ( shardRouting . index ( ) . equals ( <str> ) & & shardRouting . shardId ( ) . getId ( ) = = <int> ) { return byteSize ; } return null ; } } ; } @Override public void addListener ( Listener listener ) { } } ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertEquals ( <int> , clusterState . getRoutingNodes ( ) . node ( <str> ) . numberOfShardsWithState ( ShardRoutingState . INITIALIZING ) ) ; assertEquals ( byteSize , clusterState . getRoutingNodes ( ) . getRoutingTable ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . getExpectedShardSize ( ) ) ; logger . info ( <str> ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertEquals ( <int> , clusterState . getRoutingNodes ( ) . node ( <str> ) . numberOfShardsWithState ( ShardRoutingState . STARTED ) ) ; assertEquals ( <int> , clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; assertEquals ( <int> , clusterState . getRoutingNodes ( ) . node ( <str> ) . numberOfShardsWithState ( ShardRoutingState . INITIALIZING ) ) ; assertEquals ( byteSize , clusterState . getRoutingNodes ( ) . getRoutingTable ( ) . shardsWithState ( ShardRoutingState . INITIALIZING ) . get ( <int> ) . getExpectedShardSize ( ) ) ; } public void testExpectedSizeOnMove ( ) { final long byteSize = randomIntBetween ( <int> , Integer . MAX_VALUE ) ; final AllocationService allocation = createAllocationService ( Settings . EMPTY , new ClusterInfoService ( ) { @Override public ClusterInfo getClusterInfo ( ) { return new ClusterInfo ( ) { @Override public Long getShardSize ( ShardRouting shardRouting ) { if ( shardRouting . index ( ) . equals ( <str> ) & & shardRouting . shardId ( ) . getId ( ) = = <int> ) { return byteSize ; } return null ; } } ; } @Override public void addListener ( Listener listener ) { } } ) ; logger . info ( <str> ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; RoutingAllocation . Result rerouteResult = allocation . reroute ( clusterState , <str> ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; logger . info ( <str> ) ; rerouteResult = allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; logger . info ( <str> ) ; String existingNodeId = clusterState . routingTable ( ) . index ( <str> ) . shard ( <int> ) . primaryShard ( ) . currentNodeId ( ) ; String toNodeId ; if ( <str> . equals ( existingNodeId ) ) { toNodeId = <str> ; } else { toNodeId = <str> ; } rerouteResult = allocation . reroute ( clusterState , new AllocationCommands ( new MoveAllocationCommand ( new ShardId ( <str> , <int> ) , existingNodeId , toNodeId ) ) ) ; assertThat ( rerouteResult . changed ( ) , equalTo ( true ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; assertEquals ( clusterState . getRoutingNodes ( ) . node ( existingNodeId ) . get ( <int> ) . state ( ) , ShardRoutingState . RELOCATING ) ; assertEquals ( clusterState . getRoutingNodes ( ) . node ( toNodeId ) . get ( <int> ) . state ( ) , ShardRoutingState . INITIALIZING ) ; assertEquals ( clusterState . getRoutingNodes ( ) . node ( existingNodeId ) . get ( <int> ) . getExpectedShardSize ( ) , byteSize ) ; assertEquals ( clusterState . getRoutingNodes ( ) . node ( toNodeId ) . get ( <int> ) . getExpectedShardSize ( ) , byteSize ) ; logger . info ( <str> ) ; rerouteResult = allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( rerouteResult . routingTable ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( existingNodeId ) . isEmpty ( ) , equalTo ( true ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . node ( toNodeId ) . get ( <int> ) . state ( ) , equalTo ( ShardRoutingState . STARTED ) ) ; assertEquals ( clusterState . getRoutingNodes ( ) . node ( toNodeId ) . get ( <int> ) . getExpectedShardSize ( ) , - <int> ) ; } } 
