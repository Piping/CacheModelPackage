package org . eclipse . debug . internal . ui . viewers . breadcrumb ; import org . eclipse . core . runtime . Assert ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . jface . action . Action ; import org . eclipse . jface . action . ToolBarManager ; import org . eclipse . jface . dialogs . IDialogSettings ; import org . eclipse . jface . resource . CompositeImageDescriptor ; import org . eclipse . jface . util . Geometry ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . swt . SWT ; import org . eclipse . swt . accessibility . AccessibleAdapter ; import org . eclipse . swt . accessibility . AccessibleEvent ; import org . eclipse . swt . events . ControlAdapter ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . events . ControlListener ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . DisposeListener ; import org . eclipse . swt . events . MouseAdapter ; import org . eclipse . swt . events . MouseEvent ; import org . eclipse . swt . events . ShellEvent ; import org . eclipse . swt . events . ShellListener ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . GC ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . ImageData ; import org . eclipse . swt . graphics . Point ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . graphics . Rectangle ; import org . eclipse . swt . layout . GridData ; import org . eclipse . swt . layout . GridLayout ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Monitor ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . swt . widgets . ToolBar ; import org . eclipse . swt . widgets . Widget ; class BreadcrumbItemDropDown implements IBreadcrumbDropDownSite { private static final boolean IS_MAC_WORKAROUND = <str> . equals ( SWT . getPlatform ( ) ) ; private final class AccessibelArrowImage extends CompositeImageDescriptor { private final static int ARROW_SIZE = <int> ; private final boolean fLTR ; public AccessibelArrowImage ( boolean ltr ) { fLTR = ltr ; } @Override protected void drawCompositeImage ( int width , int height ) { Display display = fParentComposite . getDisplay ( ) ; Image image = new Image ( display , ARROW_SIZE , ARROW_SIZE * <int> ) ; GC gc = new GC ( image ) ; Color triangle = createColor ( SWT . COLOR_LIST_FOREGROUND , SWT . COLOR_LIST_BACKGROUND , <int> , display ) ; Color aliasing = createColor ( SWT . COLOR_LIST_FOREGROUND , SWT . COLOR_LIST_BACKGROUND , <int> , display ) ; gc . setBackground ( triangle ) ; if ( fLTR ) { gc . fillPolygon ( new int [ ] { mirror ( <int> ) , <int> , mirror ( ARROW_SIZE ) , ARROW_SIZE , mirror ( <int> ) , ARROW_SIZE * <int> } ) ; } else { gc . fillPolygon ( new int [ ] { ARROW_SIZE , <int> , <int> , ARROW_SIZE , ARROW_SIZE , ARROW_SIZE * <int> } ) ; } gc . setForeground ( aliasing ) ; gc . drawLine ( mirror ( <int> ) , <int> , mirror ( ARROW_SIZE - <int> ) , ARROW_SIZE ) ; gc . drawLine ( mirror ( ARROW_SIZE - <int> ) , ARROW_SIZE , mirror ( <int> ) , ARROW_SIZE * <int> - <int> ) ; gc . dispose ( ) ; triangle . dispose ( ) ; aliasing . dispose ( ) ; ImageData imageData = image . getImageData ( ) ; for ( int y = <int> ; y < ARROW_SIZE ; y + + ) { for ( int x = <int> ; x < y ; x + + ) { imageData . setAlpha ( mirror ( x ) , y , <int> ) ; } } for ( int y = <int> ; y < ARROW_SIZE ; y + + ) { for ( int x = <int> ; x < = y ; x + + ) { imageData . setAlpha ( mirror ( x ) , ARROW_SIZE * <int> - y - <int> , <int> ) ; } } int offset = fLTR ? <int> : - <int> ; drawImage ( imageData , ( width / <int> ) - ( ARROW_SIZE / <int> ) + offset , ( height / <int> ) - ARROW_SIZE - <int> ) ; image . dispose ( ) ; } private int mirror ( int x ) { if ( fLTR ) return x ; return ARROW_SIZE - x - <int> ; } @Override protected Point getSize ( ) { return new Point ( <int> , <int> ) ; } private Color createColor ( int color1 , int color2 , int ratio , Display display ) { RGB rgb1 = display . getSystemColor ( color1 ) . getRGB ( ) ; RGB rgb2 = display . getSystemColor ( color2 ) . getRGB ( ) ; RGB blend = BreadcrumbViewer . blend ( rgb2 , rgb1 , ratio ) ; return new Color ( display , blend ) ; } } private static final int DROP_DOWN_MIN_WIDTH = <int> ; private static final int DROP_DOWN_MAX_WIDTH = <int> ; private static final int DROP_DOWN_DEFAULT_MIN_HEIGHT = <int> ; private static final int DROP_DOWN_DEFAULT_MAX_HEIGHT = <int> ; private static final String DIALOG_SETTINGS = <str> ; private static final String DIALOG_HEIGHT = <str> ; private static final String DIALOG_WIDTH = <str> ; private final BreadcrumbItem fParent ; private final Composite fParentComposite ; private final ToolBar fToolBar ; private boolean fMenuIsShown ; private boolean fEnabled ; private Shell fShell ; private boolean fIsResizingProgrammatically ; private int fCurrentWidth = - <int> ; private int fCurrentHeight = - <int> ; public BreadcrumbItemDropDown ( BreadcrumbItem parent , Composite composite ) { fParent = parent ; fParentComposite = composite ; fMenuIsShown = false ; fEnabled = true ; fToolBar = new ToolBar ( composite , SWT . FLAT ) ; fToolBar . setLayoutData ( new GridData ( SWT . END , SWT . CENTER , false , false ) ) ; fToolBar . getAccessible ( ) . addAccessibleListener ( new AccessibleAdapter ( ) { @Override public void getName ( AccessibleEvent e ) { e . result = BreadcrumbMessages . BreadcrumbItemDropDown_showDropDownMenu_action_toolTip ; } } ) ; ToolBarManager manager = new ToolBarManager ( fToolBar ) ; final Action showDropDownMenuAction = new Action ( null , SWT . NONE ) { @Override public void run ( ) { Shell shell = fParent . getDropDownShell ( ) ; if ( shell ! = null ) return ; shell = fParent . getViewer ( ) . getDropDownShell ( ) ; if ( shell ! = null & & ! shell . isDisposed ( ) ) shell . close ( ) ; showMenu ( ) ; fShell . setFocus ( ) ; } } ; showDropDownMenuAction . setImageDescriptor ( new AccessibelArrowImage ( isLeft ( ) ) ) ; showDropDownMenuAction . setToolTipText ( BreadcrumbMessages . BreadcrumbItemDropDown_showDropDownMenu_action_toolTip ) ; manager . add ( showDropDownMenuAction ) ; manager . update ( true ) ; if ( IS_MAC_WORKAROUND ) { manager . getControl ( ) . addMouseListener ( new MouseAdapter ( ) { @Override public void mouseDown ( MouseEvent e ) { showDropDownMenuAction . run ( ) ; } } ) ; } } public int getWidth ( ) { return fToolBar . computeSize ( SWT . DEFAULT , SWT . DEFAULT ) . x ; } public void setEnabled ( boolean enabled ) { fEnabled = enabled ; fToolBar . setVisible ( enabled ) ; } public boolean isMenuShown ( ) { return fMenuIsShown ; } public Shell getDropDownShell ( ) { if ( ! isMenuShown ( ) ) return null ; return fShell ; } public void showMenu ( ) { if ( DebugUIPlugin . DEBUG_BREADCRUMB ) { DebugUIPlugin . trace ( <str> ) ; } if ( ! fEnabled | | fMenuIsShown ) return ; fMenuIsShown = true ; fShell = new Shell ( fToolBar . getShell ( ) , SWT . RESIZE | SWT . TOOL | SWT . ON_TOP ) ; if ( DebugUIPlugin . DEBUG_BREADCRUMB ) { DebugUIPlugin . trace ( <str> ) ; } fShell . addControlListener ( new ControlAdapter ( ) { @Override public void controlResized ( ControlEvent e ) { if ( fIsResizingProgrammatically ) return ; Point size = fShell . getSize ( ) ; fCurrentWidth = size . x ; fCurrentHeight = size . y ; getDialogSettings ( ) . put ( DIALOG_WIDTH , size . x ) ; getDialogSettings ( ) . put ( DIALOG_HEIGHT , size . y ) ; } } ) ; GridLayout layout = new GridLayout ( <int> , false ) ; layout . marginHeight = <int> ; layout . marginWidth = <int> ; fShell . setLayout ( layout ) ; Composite composite = new Composite ( fShell , SWT . NONE ) ; composite . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; GridLayout gridLayout = new GridLayout ( <int> , false ) ; gridLayout . marginHeight = <int> ; gridLayout . marginWidth = <int> ; composite . setLayout ( gridLayout ) ; TreePath path = fParent . getPath ( ) ; Control control = fParent . getViewer ( ) . createDropDown ( composite , this , path ) ; control . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , true , true ) ) ; setShellBounds ( fShell ) ; fShell . setVisible ( true ) ; installCloser ( fShell ) ; } private void installCloser ( final Shell shell ) { final Listener focusListener = new Listener ( ) { @Override public void handleEvent ( Event event ) { Widget focusElement = event . widget ; boolean isFocusBreadcrumbTreeFocusWidget = focusElement = = shell | | focusElement instanceof Control & & ( ( Control ) focusElement ) . getShell ( ) = = shell ; boolean isFocusWidgetParentShell = focusElement instanceof Control & & ( ( Control ) focusElement ) . getShell ( ) . getParent ( ) = = shell ; switch ( event . type ) { case SWT . FocusIn : if ( DebugUIPlugin . DEBUG_BREADCRUMB ) { DebugUIPlugin . trace ( <str> + isFocusBreadcrumbTreeFocusWidget ) ; } if ( ! isFocusBreadcrumbTreeFocusWidget & & ! isFocusWidgetParentShell ) { if ( DebugUIPlugin . DEBUG_BREADCRUMB ) { DebugUIPlugin . trace ( <str> ) ; } shell . close ( ) ; } break ; case SWT . FocusOut : if ( DebugUIPlugin . DEBUG_BREADCRUMB ) { DebugUIPlugin . trace ( <str> + isFocusBreadcrumbTreeFocusWidget ) ; } if ( event . display . getActiveShell ( ) = = null ) { if ( DebugUIPlugin . DEBUG_BREADCRUMB ) { DebugUIPlugin . trace ( <str> ) ; } shell . close ( ) ; } break ; default: Assert . isTrue ( false ) ; } } } ; final Display display = shell . getDisplay ( ) ; display . addFilter ( SWT . FocusIn , focusListener ) ; display . addFilter ( SWT . FocusOut , focusListener ) ; final ControlListener controlListener = new ControlListener ( ) { @Override public void controlMoved ( ControlEvent e ) { if ( ! shell . isDisposed ( ) ) { shell . close ( ) ; } } @Override public void controlResized ( ControlEvent e ) { if ( ! shell . isDisposed ( ) ) { shell . close ( ) ; } } } ; fToolBar . getShell ( ) . addControlListener ( controlListener ) ; shell . addDisposeListener ( new DisposeListener ( ) { @Override public void widgetDisposed ( DisposeEvent e ) { if ( DebugUIPlugin . DEBUG_BREADCRUMB ) { DebugUIPlugin . trace ( <str> ) ; } display . removeFilter ( SWT . FocusIn , focusListener ) ; display . removeFilter ( SWT . FocusOut , focusListener ) ; if ( ! fToolBar . isDisposed ( ) ) { fToolBar . getShell ( ) . removeControlListener ( controlListener ) ; } } } ) ; shell . addShellListener ( new ShellListener ( ) { @Override public void shellActivated ( ShellEvent e ) { } @Override public void shellClosed ( ShellEvent e ) { if ( DebugUIPlugin . DEBUG_BREADCRUMB ) { DebugUIPlugin . trace ( <str> ) ; } if ( ! fMenuIsShown ) return ; fMenuIsShown = false ; } @Override public void shellDeactivated ( ShellEvent e ) { } @Override public void shellDeiconified ( ShellEvent e ) { } @Override public void shellIconified ( ShellEvent e ) { } } ) ; } private IDialogSettings getDialogSettings ( ) { IDialogSettings javaSettings = DebugUIPlugin . getDefault ( ) . getDialogSettings ( ) ; IDialogSettings settings = javaSettings . getSection ( DIALOG_SETTINGS ) ; if ( settings = = null ) settings = javaSettings . addNewSection ( DIALOG_SETTINGS ) ; return settings ; } private int getMaxWidth ( ) { try { return getDialogSettings ( ) . getInt ( DIALOG_WIDTH ) ; } catch ( NumberFormatException e ) { return DROP_DOWN_MAX_WIDTH ; } } private int getMaxHeight ( ) { try { return getDialogSettings ( ) . getInt ( DIALOG_HEIGHT ) ; } catch ( NumberFormatException e ) { return DROP_DOWN_DEFAULT_MAX_HEIGHT ; } } private void setShellBounds ( Shell shell ) { Rectangle rect = fParentComposite . getBounds ( ) ; Rectangle toolbarBounds = fToolBar . getBounds ( ) ; Point size = shell . computeSize ( SWT . DEFAULT , SWT . DEFAULT , false ) ; int height = Math . max ( Math . min ( size . y , getMaxHeight ( ) ) , DROP_DOWN_DEFAULT_MIN_HEIGHT ) ; int width = Math . max ( getMaxWidth ( ) , DROP_DOWN_MIN_WIDTH ) ; int imageBoundsX = <int> ; if ( fParent . getImage ( ) ! = null ) { imageBoundsX = fParent . getImage ( ) . getImageData ( ) . width ; } Rectangle trim = fShell . computeTrim ( <int> , <int> , width , height ) ; int x = toolbarBounds . x + toolbarBounds . width + <int> + trim . x - imageBoundsX ; if ( ! isLeft ( ) ) x + = width ; int y = rect . y ; if ( isTop ( ) ) y + = rect . height ; else y - = height ; Point pt = new Point ( x , y ) ; pt = fParentComposite . toDisplay ( pt ) ; Rectangle monitor = getClosestMonitor ( shell . getDisplay ( ) , pt ) . getClientArea ( ) ; int overlap = ( pt . x + width ) - ( monitor . x + monitor . width ) ; if ( overlap > <int> ) pt . x - = overlap ; if ( pt . x < monitor . x ) pt . x = monitor . x ; shell . setLocation ( pt ) ; fIsResizingProgrammatically = true ; try { shell . setSize ( width , height ) ; fCurrentWidth = width ; fCurrentHeight = height ; } finally { fIsResizingProgrammatically = false ; } } private static Monitor getClosestMonitor ( Display display , Point point ) { int closest = Integer . MAX_VALUE ; Monitor [ ] monitors = display . getMonitors ( ) ; Monitor result = monitors [ <int> ] ; for ( int i = <int> ; i < monitors . length ; i + + ) { Monitor current = monitors [ i ] ; Rectangle clientArea = current . getClientArea ( ) ; if ( clientArea . contains ( point ) ) return current ; int distance = Geometry . distanceSquared ( Geometry . centerPoint ( clientArea ) , point ) ; if ( distance < closest ) { closest = distance ; result = current ; } } return result ; } private void resizeShell ( final Shell shell ) { int maxHeight = getMaxHeight ( ) ; int maxWidth = getMaxWidth ( ) ; if ( fCurrentHeight > = maxHeight & & fCurrentWidth > = maxWidth ) return ; Point preferedSize = shell . computeSize ( SWT . DEFAULT , SWT . DEFAULT , true ) ; int newWidth ; if ( fCurrentWidth > = DROP_DOWN_MAX_WIDTH ) { newWidth = fCurrentWidth ; } else { newWidth = Math . min ( Math . max ( Math . max ( preferedSize . x , fCurrentWidth ) , DROP_DOWN_MIN_WIDTH ) , maxWidth ) ; } int newHeight ; if ( fCurrentHeight > = maxHeight ) { newHeight = fCurrentHeight ; } else { newHeight = Math . min ( Math . max ( preferedSize . y , fCurrentHeight ) , maxHeight ) ; } if ( newHeight ! = fCurrentHeight | | newWidth ! = fCurrentWidth ) { shell . setRedraw ( false ) ; try { fIsResizingProgrammatically = true ; shell . setSize ( newWidth , newHeight ) ; fCurrentWidth = newWidth ; fCurrentHeight = newHeight ; Point location = shell . getLocation ( ) ; Point newLocation = location ; if ( ! isLeft ( ) ) { newLocation = new Point ( newLocation . x - ( newWidth - fCurrentWidth ) , newLocation . y ) ; } if ( ! isTop ( ) ) { newLocation = new Point ( newLocation . x , newLocation . y - ( newHeight - fCurrentHeight ) ) ; } if ( ! location . equals ( newLocation ) ) { shell . setLocation ( newLocation . x , newLocation . y ) ; } } finally { fIsResizingProgrammatically = false ; shell . setRedraw ( true ) ; } } } private boolean isLeft ( ) { return ( fParentComposite . getStyle ( ) & SWT . RIGHT_TO_LEFT ) = = <int> & & ( fParent . getViewer ( ) . getStyle ( ) & SWT . RIGHT ) = = <int> ; } private boolean isTop ( ) { return ( fParent . getViewer ( ) . getStyle ( ) & SWT . BOTTOM ) = = <int> ; } @Override public void close ( ) { if ( fShell ! = null & & ! fShell . isDisposed ( ) ) { fShell . close ( ) ; } } @Override public void notifySelection ( ISelection selection ) { fParent . getViewer ( ) . fireMenuSelection ( selection ) ; } @Override public void updateSize ( ) { if ( fShell ! = null & & ! fShell . isDisposed ( ) ) { resizeShell ( fShell ) ; } } } 
