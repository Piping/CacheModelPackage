package org . elasticsearch . common . inject . assistedinject ; import org . elasticsearch . common . inject . AbstractModule ; import org . elasticsearch . common . inject . Binder ; import org . elasticsearch . common . inject . Binding ; import org . elasticsearch . common . inject . ConfigurationException ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . Injector ; import org . elasticsearch . common . inject . Key ; import org . elasticsearch . common . inject . Module ; import org . elasticsearch . common . inject . Provider ; import org . elasticsearch . common . inject . ProvisionException ; import org . elasticsearch . common . inject . TypeLiteral ; import org . elasticsearch . common . inject . internal . Errors ; import org . elasticsearch . common . inject . internal . ErrorsException ; import org . elasticsearch . common . inject . spi . Message ; import org . elasticsearch . common . inject . util . Providers ; import java . lang . annotation . Annotation ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . inject . internal . Annotations . getKey ; public final class FactoryProvider2 < F > implements InvocationHandler , Provider < F > { static final Assisted DEFAULT_ANNOTATION = new Assisted ( ) { @Override public String value ( ) { return <str> ; } @Override public Class < ? extends Annotation > annotationType ( ) { return Assisted . class ; } @Override public boolean equals ( Object o ) { return o instanceof Assisted & & ( ( Assisted ) o ) . value ( ) . equals ( <str> ) ; } @Override public int hashCode ( ) { return <int> * <str> . hashCode ( ) ^ <str> . hashCode ( ) ; } @Override public String toString ( ) { return <str> + Assisted . class . getName ( ) + <str> ; } } ; private final Key < ? > producedType ; private final Map < Method , Key < ? > > returnTypesByMethod ; private final Map < Method , List < Key < ? > > > paramTypes ; private Injector injector ; private final F factory ; FactoryProvider2 ( TypeLiteral < F > factoryType , Key < ? > producedType ) { this . producedType = producedType ; Errors errors = new Errors ( ) ; @SuppressWarnings ( <str> ) Class < F > factoryRawType = ( Class ) factoryType . getRawType ( ) ; try { Map < Method , Key < ? > > returnTypesBuilder = new HashMap < > ( ) ; Map < Method , List < Key < ? > > > paramTypesBuilder = new HashMap < > ( ) ; for ( Method method : factoryRawType . getMethods ( ) ) { Key < ? > returnType = getKey ( factoryType . getReturnType ( method ) , method , method . getAnnotations ( ) , errors ) ; returnTypesBuilder . put ( method , returnType ) ; List < TypeLiteral < ? > > params = factoryType . getParameterTypes ( method ) ; Annotation [ ] [ ] paramAnnotations = method . getParameterAnnotations ( ) ; int p = <int> ; List < Key < ? > > keys = new ArrayList < > ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = getKey ( param , method , paramAnnotations [ p + + ] , errors ) ; keys . add ( assistKey ( method , paramKey , errors ) ) ; } paramTypesBuilder . put ( method , Collections . unmodifiableList ( keys ) ) ; } returnTypesByMethod = unmodifiableMap ( returnTypesBuilder ) ; paramTypes = unmodifiableMap ( paramTypesBuilder ) ; } catch ( ErrorsException e ) { throw new ConfigurationException ( e . getErrors ( ) . getMessages ( ) ) ; } factory = factoryRawType . cast ( Proxy . newProxyInstance ( factoryRawType . getClassLoader ( ) , new Class [ ] { factoryRawType } , this ) ) ; } @Override public F get ( ) { return factory ; } private < T > Key < T > assistKey ( Method method , Key < T > key , Errors errors ) throws ErrorsException { if ( key . getAnnotationType ( ) = = null ) { return Key . get ( key . getTypeLiteral ( ) , DEFAULT_ANNOTATION ) ; } else if ( key . getAnnotationType ( ) = = Assisted . class ) { return key ; } else { errors . withSource ( method ) . addMessage ( <str> , key . getAnnotationType ( ) ) ; throw errors . toException ( ) ; } } @Inject public void initialize ( Injector injector ) { if ( this . injector ! = null ) { throw new ConfigurationException ( Collections . singletonList ( new Message ( FactoryProvider2 . class , <str> ) ) ) ; } this . injector = injector ; for ( Method method : returnTypesByMethod . keySet ( ) ) { Object [ ] args = new Object [ method . getParameterTypes ( ) . length ] ; Arrays . fill ( args , <str> ) ; getBindingFromNewInjector ( method , args ) ; } } public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args ) { if ( injector = = null ) { throw new IllegalStateException ( <str> ) ; } final Key < ? > returnType = returnTypesByMethod . get ( method ) ; Module assistedModule = new AbstractModule ( ) { @Override @SuppressWarnings ( <str> ) protected void configure ( ) { Binder binder = binder ( ) . withSource ( method ) ; int p = <int> ; for ( Key < ? > paramKey : paramTypes . get ( method ) ) { binder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p + + ] ) ) ; } if ( producedType ! = null & & ! returnType . equals ( producedType ) ) { binder . bind ( returnType ) . to ( ( Key ) producedType ) ; } else { binder . bind ( returnType ) ; } } } ; Injector forCreate = injector . createChildInjector ( assistedModule ) ; return forCreate . getBinding ( returnType ) ; } @Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { if ( method . getDeclaringClass ( ) = = Object . class ) { return method . invoke ( this , args ) ; } Provider < ? > provider = getBindingFromNewInjector ( method , args ) . getProvider ( ) ; try { return provider . get ( ) ; } catch ( ProvisionException e ) { if ( e . getErrorMessages ( ) . size ( ) = = <int> ) { Message onlyError = e . getErrorMessages ( ) . iterator ( ) . next ( ) ; Throwable cause = onlyError . getCause ( ) ; if ( cause ! = null & & canRethrow ( method , cause ) ) { throw cause ; } } throw e ; } } @Override public String toString ( ) { return factory . getClass ( ) . getInterfaces ( ) [ <int> ] . getName ( ) + <str> + producedType . getTypeLiteral ( ) ; } @Override public boolean equals ( Object o ) { return o = = this | | o = = factory ; } static boolean canRethrow ( Method invoked , Throwable thrown ) { if ( thrown instanceof Error | | thrown instanceof RuntimeException ) { return true ; } for ( Class < ? > declared : invoked . getExceptionTypes ( ) ) { if ( declared . isInstance ( thrown ) ) { return true ; } } return false ; } } 
