package org . elasticsearch . cloud . azure . storage ; import com . microsoft . azure . storage . CloudStorageAccount ; import com . microsoft . azure . storage . LocationMode ; import com . microsoft . azure . storage . StorageException ; import com . microsoft . azure . storage . blob . * ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . blobstore . BlobMetaData ; import org . elasticsearch . common . blobstore . support . PlainBlobMetaData ; import org . elasticsearch . common . collect . MapBuilder ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . repositories . RepositoryException ; import java . io . InputStream ; import java . io . OutputStream ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . Hashtable ; import java . util . Map ; public class AzureStorageServiceImpl extends AbstractLifecycleComponent < AzureStorageServiceImpl > implements AzureStorageService { final AzureStorageSettings primaryStorageSettings ; final Map < String , AzureStorageSettings > secondariesStorageSettings ; final Map < String , CloudBlobClient > clients ; @Inject public AzureStorageServiceImpl ( Settings settings ) { super ( settings ) ; Tuple < AzureStorageSettings , Map < String , AzureStorageSettings > > storageSettings = AzureStorageSettings . parse ( settings ) ; this . primaryStorageSettings = storageSettings . v1 ( ) ; this . secondariesStorageSettings = storageSettings . v2 ( ) ; this . clients = new Hashtable < > ( ) ; } void createClient ( AzureStorageSettings azureStorageSettings ) { try { logger . trace ( <str> , azureStorageSettings . getAccount ( ) , azureStorageSettings . getKey ( ) ) ; String storageConnectionString = <str> + <str> + azureStorageSettings . getAccount ( ) + <str> + <str> + azureStorageSettings . getKey ( ) ; CloudStorageAccount storageAccount = CloudStorageAccount . parse ( storageConnectionString ) ; CloudBlobClient client = storageAccount . createCloudBlobClient ( ) ; this . clients . put ( azureStorageSettings . getAccount ( ) , client ) ; } catch ( Exception e ) { logger . error ( <str> , e . getMessage ( ) ) ; } } CloudBlobClient getSelectedClient ( String account , LocationMode mode ) { logger . trace ( <str> , account , mode . name ( ) ) ; AzureStorageSettings azureStorageSettings = null ; if ( this . primaryStorageSettings = = null | | this . secondariesStorageSettings . isEmpty ( ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( account ! = null ) { azureStorageSettings = this . secondariesStorageSettings . get ( account ) ; } if ( azureStorageSettings = = null ) { if ( account = = null | | primaryStorageSettings . getName ( ) = = null | | account . equals ( primaryStorageSettings . getName ( ) ) ) { azureStorageSettings = primaryStorageSettings ; } } if ( azureStorageSettings = = null ) { throw new IllegalArgumentException ( <str> + account + <str> ) ; } CloudBlobClient client = this . clients . get ( azureStorageSettings . getAccount ( ) ) ; if ( client = = null ) { throw new IllegalArgumentException ( <str> + account + <str> ) ; } client . getDefaultRequestOptions ( ) . setLocationMode ( mode ) ; return client ; } @Override public boolean doesContainerExist ( String account , LocationMode mode , String container ) { try { CloudBlobClient client = this . getSelectedClient ( account , mode ) ; CloudBlobContainer blob_container = client . getContainerReference ( container ) ; return blob_container . exists ( ) ; } catch ( Exception e ) { logger . error ( <str> , container ) ; } return false ; } @Override public void removeContainer ( String account , LocationMode mode , String container ) throws URISyntaxException , StorageException { CloudBlobClient client = this . getSelectedClient ( account , mode ) ; CloudBlobContainer blob_container = client . getContainerReference ( container ) ; logger . trace ( <str> , container ) ; blob_container . deleteIfExists ( ) ; } @Override public void createContainer ( String account , LocationMode mode , String container ) throws URISyntaxException , StorageException { try { CloudBlobClient client = this . getSelectedClient ( account , mode ) ; CloudBlobContainer blob_container = client . getContainerReference ( container ) ; logger . trace ( <str> , container ) ; blob_container . createIfNotExists ( ) ; } catch ( IllegalArgumentException e ) { logger . trace ( <str> , container , e . getMessage ( ) ) ; throw new RepositoryException ( container , e . getMessage ( ) ) ; } } @Override public void deleteFiles ( String account , LocationMode mode , String container , String path ) throws URISyntaxException , StorageException { logger . trace ( <str> , container , path ) ; CloudBlobClient client = this . getSelectedClient ( account , mode ) ; CloudBlobContainer blob_container = client . getContainerReference ( container ) ; if ( blob_container . exists ( ) ) { for ( ListBlobItem blobItem : blob_container . listBlobs ( path ) ) { logger . trace ( <str> , blobItem . getUri ( ) ) ; deleteBlob ( account , mode , container , blobItem . getUri ( ) . toString ( ) ) ; } } } @Override public boolean blobExists ( String account , LocationMode mode , String container , String blob ) throws URISyntaxException , StorageException { CloudBlobClient client = this . getSelectedClient ( account , mode ) ; CloudBlobContainer blob_container = client . getContainerReference ( container ) ; if ( blob_container . exists ( ) ) { CloudBlockBlob azureBlob = blob_container . getBlockBlobReference ( blob ) ; return azureBlob . exists ( ) ; } return false ; } @Override public void deleteBlob ( String account , LocationMode mode , String container , String blob ) throws URISyntaxException , StorageException { logger . trace ( <str> , container , blob ) ; CloudBlobClient client = this . getSelectedClient ( account , mode ) ; CloudBlobContainer blob_container = client . getContainerReference ( container ) ; if ( blob_container . exists ( ) ) { logger . trace ( <str> , container , blob ) ; CloudBlockBlob azureBlob = blob_container . getBlockBlobReference ( blob ) ; azureBlob . delete ( ) ; } } @Override public InputStream getInputStream ( String account , LocationMode mode , String container , String blob ) throws URISyntaxException , StorageException { logger . trace ( <str> , container , blob ) ; CloudBlobClient client = this . getSelectedClient ( account , mode ) ; return client . getContainerReference ( container ) . getBlockBlobReference ( blob ) . openInputStream ( ) ; } @Override public OutputStream getOutputStream ( String account , LocationMode mode , String container , String blob ) throws URISyntaxException , StorageException { logger . trace ( <str> , container , blob ) ; CloudBlobClient client = this . getSelectedClient ( account , mode ) ; return client . getContainerReference ( container ) . getBlockBlobReference ( blob ) . openOutputStream ( ) ; } @Override public Map < String , BlobMetaData > listBlobsByPrefix ( String account , LocationMode mode , String container , String keyPath , String prefix ) throws URISyntaxException , StorageException { logger . debug ( <str> , container , keyPath , prefix ) ; MapBuilder < String , BlobMetaData > blobsBuilder = MapBuilder . newMapBuilder ( ) ; CloudBlobClient client = this . getSelectedClient ( account , mode ) ; CloudBlobContainer blobContainer = client . getContainerReference ( container ) ; if ( blobContainer . exists ( ) ) { for ( ListBlobItem blobItem : blobContainer . listBlobs ( keyPath + ( prefix = = null ? <str> : prefix ) ) ) { URI uri = blobItem . getUri ( ) ; logger . trace ( <str> , uri ) ; String blobPath = uri . getPath ( ) . substring ( <int> + container . length ( ) + <int> ) ; CloudBlockBlob blob = blobContainer . getBlockBlobReference ( blobPath ) ; blob . downloadAttributes ( ) ; BlobProperties properties = blob . getProperties ( ) ; String name = blobPath . substring ( keyPath . length ( ) ) ; logger . trace ( <str> , uri , name , properties . getLength ( ) ) ; blobsBuilder . put ( name , new PlainBlobMetaData ( name , properties . getLength ( ) ) ) ; } } return blobsBuilder . immutableMap ( ) ; } @Override public void moveBlob ( String account , LocationMode mode , String container , String sourceBlob , String targetBlob ) throws URISyntaxException , StorageException { logger . debug ( <str> , container , sourceBlob , targetBlob ) ; CloudBlobClient client = this . getSelectedClient ( account , mode ) ; CloudBlobContainer blob_container = client . getContainerReference ( container ) ; CloudBlockBlob blobSource = blob_container . getBlockBlobReference ( sourceBlob ) ; if ( blobSource . exists ( ) ) { CloudBlockBlob blobTarget = blob_container . getBlockBlobReference ( targetBlob ) ; blobTarget . startCopyFromBlob ( blobSource ) ; blobSource . delete ( ) ; logger . debug ( <str> , container , sourceBlob , targetBlob ) ; } } @Override protected void doStart ( ) throws ElasticsearchException { logger . debug ( <str> ) ; if ( primaryStorageSettings ! = null ) { logger . debug ( <str> , primaryStorageSettings . getAccount ( ) ) ; createClient ( primaryStorageSettings ) ; } for ( Map . Entry < String , AzureStorageSettings > azureStorageSettingsEntry : secondariesStorageSettings . entrySet ( ) ) { logger . debug ( <str> , azureStorageSettingsEntry . getKey ( ) ) ; createClient ( azureStorageSettingsEntry . getValue ( ) ) ; } } @Override protected void doStop ( ) throws ElasticsearchException { logger . debug ( <str> ) ; } @Override protected void doClose ( ) throws ElasticsearchException { } } 
