package org . gradle . api . tasks . diagnostics ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . Action ; import org . gradle . api . Project ; import org . gradle . api . internal . project . ProjectInternal ; import org . gradle . api . tasks . diagnostics . internal . TextReportRenderer ; import org . gradle . initialization . BuildClientMetaData ; import org . gradle . internal . graph . GraphRenderer ; import org . gradle . logging . StyledTextOutput ; import org . gradle . util . CollectionUtils ; import org . gradle . util . GUtil ; import java . io . IOException ; import java . util . List ; import static org . gradle . logging . StyledTextOutput . Style . * ; public class ProjectReportTask extends AbstractReportTask { private TextReportRenderer renderer = new TextReportRenderer ( ) ; @Override protected TextReportRenderer getRenderer ( ) { return renderer ; } @Override protected void generate ( Project project ) throws IOException { BuildClientMetaData metaData = getClientMetaData ( ) ; StyledTextOutput textOutput = getRenderer ( ) . getTextOutput ( ) ; render ( project , new GraphRenderer ( textOutput ) , true , textOutput ) ; if ( project . getChildProjects ( ) . isEmpty ( ) ) { textOutput . withStyle ( Info ) . text ( <str> ) ; textOutput . println ( ) ; } textOutput . println ( ) ; textOutput . text ( <str> ) ; metaData . describeCommand ( textOutput . withStyle ( UserInput ) , String . format ( <str> , ProjectInternal . TASKS_TASK ) ) ; textOutput . println ( ) ; textOutput . text ( <str> ) ; Project exampleProject = project . getChildProjects ( ) . isEmpty ( ) ? project : getChildren ( project ) . get ( <int> ) ; metaData . describeCommand ( textOutput . withStyle ( UserInput ) , exampleProject . absoluteProjectPath ( ProjectInternal . TASKS_TASK ) ) ; textOutput . println ( ) ; if ( project ! = project . getRootProject ( ) ) { textOutput . println ( ) ; textOutput . text ( <str> ) ; metaData . describeCommand ( textOutput . withStyle ( UserInput ) , project . getRootProject ( ) . absoluteProjectPath ( ProjectInternal . PROJECTS_TASK ) ) ; textOutput . println ( ) ; } } private void render ( final Project project , GraphRenderer renderer , boolean lastChild , final StyledTextOutput textOutput ) { renderer . visit ( new Action < StyledTextOutput > ( ) { public void execute ( StyledTextOutput styledTextOutput ) { styledTextOutput . text ( StringUtils . capitalize ( project . toString ( ) ) ) ; if ( GUtil . isTrue ( project . getDescription ( ) ) ) { textOutput . withStyle ( Description ) . format ( <str> , project . getDescription ( ) ) ; } } } , lastChild ) ; renderer . startChildren ( ) ; List < Project > children = getChildren ( project ) ; for ( Project child : children ) { render ( child , renderer , child = = children . get ( children . size ( ) - <int> ) , textOutput ) ; } renderer . completeChildren ( ) ; } private List < Project > getChildren ( Project project ) { return CollectionUtils . sort ( project . getChildProjects ( ) . values ( ) ) ; } } 
