package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . List ; import java . util . SortedSet ; import java . util . TreeSet ; import javax . annotation . Nullable ; public abstract class ImmutableSortedSet < E > extends ForwardingImmutableSet < E > implements SortedSet < E > , SortedIterable < E > { @Deprecated public static < E > ImmutableSortedSet . Builder < E > builder ( ) { throw new UnsupportedOperationException ( ) ; } @SuppressWarnings ( <str> ) private static final Comparator NATURAL_ORDER = Ordering . natural ( ) ; @SuppressWarnings ( <str> ) private static final ImmutableSortedSet < Object > NATURAL_EMPTY_SET = new RegularImmutableSortedSet < Object > ( new TreeSet < Object > ( NATURAL_ORDER ) , false ) ; static < E > ImmutableSortedSet < E > emptySet ( Comparator < ? super E > comparator ) { checkNotNull ( comparator ) ; if ( NATURAL_ORDER . equals ( comparator ) ) { return of ( ) ; } else { return new RegularImmutableSortedSet < E > ( new TreeSet < E > ( comparator ) , false ) ; } } @SuppressWarnings ( <str> ) public static < E > ImmutableSortedSet < E > of ( ) { return ( ImmutableSortedSet < E > ) NATURAL_EMPTY_SET ; } public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E element ) { return ofInternal ( Ordering . natural ( ) , element ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 ) { return ofInternal ( Ordering . natural ( ) , e1 , e2 ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 ) { return ofInternal ( Ordering . natural ( ) , e1 , e2 , e3 ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 ) { return ofInternal ( Ordering . natural ( ) , e1 , e2 , e3 , e4 ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 ) { return ofInternal ( Ordering . natural ( ) , e1 , e2 , e3 , e4 , e5 ) ; } @SuppressWarnings ( <str> ) public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > of ( E e1 , E e2 , E e3 , E e4 , E e5 , E e6 , E . . . remaining ) { int size = remaining . length + <int> ; List < E > all = new ArrayList < E > ( size ) ; Collections . addAll ( all , e1 , e2 , e3 , e4 , e5 , e6 ) ; Collections . addAll ( all , remaining ) ; return ofInternal ( Ordering . natural ( ) , ( E [ ] ) all . toArray ( new Comparable [ <int> ] ) ) ; } private static < E > ImmutableSortedSet < E > ofInternal ( Comparator < ? super E > comparator , E . . . elements ) { checkNotNull ( elements ) ; switch ( elements . length ) { case <int> : return emptySet ( comparator ) ; default : SortedSet < E > delegate = new TreeSet < E > ( comparator ) ; for ( E element : elements ) { checkNotNull ( element ) ; delegate . add ( element ) ; } return new RegularImmutableSortedSet < E > ( delegate , false ) ; } } public static < E > ImmutableSortedSet < E > copyOf ( Collection < ? extends E > elements ) { return copyOfInternal ( ( Ordering < E > ) Ordering . natural ( ) , ( Collection ) elements , false ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Iterable < ? extends E > elements ) { return copyOfInternal ( ( Ordering < E > ) Ordering . natural ( ) , ( Iterable ) elements , false ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Iterator < ? extends E > elements ) { return copyOfInternal ( ( Ordering < E > ) Ordering . natural ( ) , ( Iterator ) elements ) ; } public static < E extends Comparable < ? super E > > ImmutableSortedSet < E > copyOf ( E [ ] elements ) { return ofInternal ( Ordering . natural ( ) , elements ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Comparator < ? super E > comparator , Iterable < ? extends E > elements ) { checkNotNull ( comparator ) ; return copyOfInternal ( comparator , elements , false ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Comparator < ? super E > comparator , Collection < ? extends E > elements ) { checkNotNull ( comparator ) ; return copyOfInternal ( comparator , elements , false ) ; } public static < E > ImmutableSortedSet < E > copyOf ( Comparator < ? super E > comparator , Iterator < ? extends E > elements ) { checkNotNull ( comparator ) ; return copyOfInternal ( comparator , elements ) ; } @SuppressWarnings ( <str> ) public static < E > ImmutableSortedSet < E > copyOfSorted ( SortedSet < E > sortedSet ) { Comparator < ? super E > comparator = sortedSet . comparator ( ) ; if ( comparator = = null ) { comparator = NATURAL_ORDER ; } return copyOfInternal ( comparator , sortedSet . iterator ( ) ) ; } private static < E > ImmutableSortedSet < E > copyOfInternal ( Comparator < ? super E > comparator , Iterable < ? extends E > elements , boolean fromSortedSet ) { checkNotNull ( comparator ) ; boolean hasSameComparator = fromSortedSet | | hasSameComparator ( elements , comparator ) ; if ( hasSameComparator & & ( elements instanceof ImmutableSortedSet ) ) { @SuppressWarnings ( <str> ) ImmutableSortedSet < E > result = ( ImmutableSortedSet < E > ) elements ; boolean isSubset = ( result instanceof RegularImmutableSortedSet ) & & ( ( RegularImmutableSortedSet ) result ) . isSubset ; if ( ! isSubset ) { return result ; } } return copyOfInternal ( comparator , elements . iterator ( ) ) ; } private static < E > ImmutableSortedSet < E > copyOfInternal ( Comparator < ? super E > comparator , Iterator < ? extends E > elements ) { checkNotNull ( comparator ) ; if ( ! elements . hasNext ( ) ) { return emptySet ( comparator ) ; } SortedSet < E > delegate = new TreeSet < E > ( comparator ) ; while ( elements . hasNext ( ) ) { E element = elements . next ( ) ; checkNotNull ( element ) ; delegate . add ( element ) ; } return new RegularImmutableSortedSet < E > ( delegate , false ) ; } private static boolean hasSameComparator ( Iterable < ? > elements , Comparator < ? > comparator ) { if ( elements instanceof SortedSet ) { SortedSet < ? > sortedSet = ( SortedSet < ? > ) elements ; Comparator < ? > comparator2 = sortedSet . comparator ( ) ; return ( comparator2 = = null ) ? comparator = = Ordering . natural ( ) : comparator . equals ( comparator2 ) ; } return false ; } static < E > ImmutableSortedSet < E > unsafeDelegateSortedSet ( SortedSet < E > delegate , boolean isSubset ) { return delegate . isEmpty ( ) ? emptySet ( delegate . comparator ( ) ) : new RegularImmutableSortedSet < E > ( delegate , isSubset ) ; } private Comparator < E > unusedComparatorForSerialization ; private E unusedElementForSerialization ; private transient final SortedSet < E > sortedDelegate ; ImmutableSortedSet ( Comparator < ? super E > comparator ) { this ( Sets . newTreeSet ( comparator ) ) ; } ImmutableSortedSet ( SortedSet < E > sortedDelegate ) { super ( sortedDelegate ) ; this . sortedDelegate = Collections . unmodifiableSortedSet ( sortedDelegate ) ; } public Comparator < ? super E > comparator ( ) { return sortedDelegate . comparator ( ) ; } @Override public UnmodifiableIterator < E > iterator ( ) { return super . iterator ( ) ; } @Override public Object [ ] toArray ( ) { return ObjectArrays . toArrayImpl ( this ) ; } @Override public < T > T [ ] toArray ( T [ ] other ) { return ObjectArrays . toArrayImpl ( this , other ) ; } @Override public boolean contains ( @Nullable Object object ) { try { return object ! = null & & sortedDelegate . contains ( object ) ; } catch ( ClassCastException e ) { return false ; } } @Override public boolean containsAll ( Collection < ? > targets ) { for ( Object target : targets ) { if ( target = = null ) { return false ; } } try { return sortedDelegate . containsAll ( targets ) ; } catch ( ClassCastException e ) { return false ; } } public E first ( ) { return sortedDelegate . first ( ) ; } public ImmutableSortedSet < E > headSet ( E toElement ) { checkNotNull ( toElement ) ; try { return unsafeDelegateSortedSet ( sortedDelegate . headSet ( toElement ) , true ) ; } catch ( IllegalArgumentException e ) { return emptySet ( comparator ( ) ) ; } } E higher ( E e ) { checkNotNull ( e ) ; Iterator < E > iterator = tailSet ( e ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { E higher = iterator . next ( ) ; if ( comparator ( ) . compare ( e , higher ) < <int> ) { return higher ; } } return null ; } ImmutableSortedSet < E > headSet ( E toElement , boolean inclusive ) { checkNotNull ( toElement ) ; if ( inclusive ) { E tmp = higher ( toElement ) ; if ( tmp = = null ) { return this ; } toElement = tmp ; } return headSet ( toElement ) ; } public E last ( ) { return sortedDelegate . last ( ) ; } public ImmutableSortedSet < E > subSet ( E fromElement , E toElement ) { return subSet ( fromElement , true , toElement , false ) ; } ImmutableSortedSet < E > subSet ( E fromElement , boolean fromInclusive , E toElement , boolean toInclusive ) { checkNotNull ( fromElement ) ; checkNotNull ( toElement ) ; int cmp = comparator ( ) . compare ( fromElement , toElement ) ; checkArgument ( cmp < = <int> , <str> , fromElement , toElement ) ; if ( cmp = = <int> & & ! ( fromInclusive & & toInclusive ) ) { return emptySet ( comparator ( ) ) ; } return tailSet ( fromElement , fromInclusive ) . headSet ( toElement , toInclusive ) ; } public ImmutableSortedSet < E > tailSet ( E fromElement ) { checkNotNull ( fromElement ) ; try { return unsafeDelegateSortedSet ( sortedDelegate . tailSet ( fromElement ) , true ) ; } catch ( IllegalArgumentException e ) { return emptySet ( comparator ( ) ) ; } } ImmutableSortedSet < E > tailSet ( E fromElement , boolean inclusive ) { checkNotNull ( fromElement ) ; if ( ! inclusive ) { E tmp = higher ( fromElement ) ; if ( tmp = = null ) { return emptySet ( comparator ( ) ) ; } fromElement = tmp ; } return tailSet ( fromElement ) ; } public static < E > Builder < E > orderedBy ( Comparator < E > comparator ) { return new Builder < E > ( comparator ) ; } public static < E extends Comparable < ? > > Builder < E > reverseOrder ( ) { return new Builder < E > ( Ordering . natural ( ) . reverse ( ) ) ; } public static < E extends Comparable < ? > > Builder < E > naturalOrder ( ) { return new Builder < E > ( Ordering . natural ( ) ) ; } public static final class Builder < E > extends ImmutableSet . Builder < E > { private final Comparator < ? super E > comparator ; public Builder ( Comparator < ? super E > comparator ) { this . comparator = checkNotNull ( comparator ) ; } @Override public Builder < E > add ( E element ) { super . add ( element ) ; return this ; } @Override public Builder < E > add ( E . . . elements ) { super . add ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterable < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public Builder < E > addAll ( Iterator < ? extends E > elements ) { super . addAll ( elements ) ; return this ; } @Override public ImmutableSortedSet < E > build ( ) { return copyOfInternal ( comparator , contents . iterator ( ) ) ; } } } 
