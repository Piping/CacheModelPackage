package org . gradle . util ; import net . jcip . annotations . ThreadSafe ; import java . io . IOException ; import java . net . DatagramSocket ; import java . net . ServerSocket ; import java . util . NoSuchElementException ; import java . util . Random ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; @Deprecated @ThreadSafe public class AvailablePortFinder { private static final int MIN_PRIVATE_PORT = <int> ; private static final int MAX_PRIVATE_PORT = <int> ; private final Lock lock = new ReentrantLock ( ) ; private final int startPort ; private int current ; private static final AvailablePortFinder INSTANCE = new AvailablePortFinder ( ) ; public static AvailablePortFinder createPrivate ( ) { return INSTANCE ; } private AvailablePortFinder ( ) { startPort = new Random ( ) . nextInt ( MAX_PRIVATE_PORT - MIN_PRIVATE_PORT ) + MIN_PRIVATE_PORT ; current = startPort ; } public int getNextAvailable ( ) { DeprecationLogger . nagUserOfDeprecated ( this . getClass ( ) . getSimpleName ( ) ) ; lock . lock ( ) ; try { while ( true ) { if ( current > = MAX_PRIVATE_PORT ) { current = MIN_PRIVATE_PORT ; } else { current + + ; } if ( current = = startPort ) { throw new NoSuchElementException ( <str> ) ; } int candidate = current ; if ( available ( candidate ) ) { return candidate ; } } } finally { lock . unlock ( ) ; } } private boolean available ( int port ) { try { ServerSocket ss = new ServerSocket ( port ) ; try { ss . setReuseAddress ( true ) ; } finally { ss . close ( ) ; } DatagramSocket ds = new DatagramSocket ( port ) ; try { ds . setReuseAddress ( true ) ; } finally { ds . close ( ) ; } return true ; } catch ( IOException e ) { return false ; } } } 
