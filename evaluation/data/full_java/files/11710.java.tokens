package org . gradle . api . internal . tasks . execution ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . internal . changedetection . TaskArtifactState ; import org . gradle . api . internal . changedetection . TaskArtifactStateRepository ; import org . gradle . api . internal . tasks . TaskExecuter ; import org . gradle . api . internal . tasks . TaskExecutionContext ; import org . gradle . api . internal . tasks . TaskStateInternal ; import org . gradle . util . Clock ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . ArrayList ; import java . util . Formatter ; import java . util . List ; public class SkipUpToDateTaskExecuter implements TaskExecuter { private static final Logger LOGGER = LoggerFactory . getLogger ( SkipUpToDateTaskExecuter . class ) ; private final TaskExecuter executer ; private final TaskArtifactStateRepository repository ; public SkipUpToDateTaskExecuter ( TaskArtifactStateRepository repository , TaskExecuter executer ) { this . executer = executer ; this . repository = repository ; } public void execute ( TaskInternal task , TaskStateInternal state , TaskExecutionContext context ) { LOGGER . debug ( <str> , task ) ; Clock clock = new Clock ( ) ; TaskArtifactState taskArtifactState = repository . getStateFor ( task ) ; try { List < String > messages = new ArrayList < String > ( ) ; if ( taskArtifactState . isUpToDate ( messages ) ) { LOGGER . info ( <str> , task , clock . getTime ( ) ) ; state . upToDate ( ) ; return ; } logOutOfDateMessages ( messages , task , clock . getTime ( ) ) ; task . getOutputs ( ) . setHistory ( taskArtifactState . getExecutionHistory ( ) ) ; context . setTaskArtifactState ( taskArtifactState ) ; taskArtifactState . beforeTask ( ) ; try { executer . execute ( task , state , context ) ; if ( state . getFailure ( ) = = null ) { taskArtifactState . afterTask ( ) ; } } finally { task . getOutputs ( ) . setHistory ( null ) ; context . setTaskArtifactState ( null ) ; } } finally { taskArtifactState . finished ( ) ; } } private void logOutOfDateMessages ( List < String > messages , TaskInternal task , String took ) { if ( LOGGER . isInfoEnabled ( ) ) { Formatter formatter = new Formatter ( ) ; formatter . format ( <str> , task , took ) ; for ( String message : messages ) { formatter . format ( <str> , message ) ; } LOGGER . info ( formatter . toString ( ) ) ; } } } 
