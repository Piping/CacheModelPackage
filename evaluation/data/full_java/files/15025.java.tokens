package org . gradle . nativeplatform . toolchain . internal ; import com . google . common . collect . Lists ; import org . apache . commons . io . FileUtils ; import org . apache . commons . io . FilenameUtils ; import org . gradle . api . Transformer ; import org . gradle . api . UncheckedIOException ; import org . gradle . nativeplatform . toolchain . internal . compilespec . CPCHCompileSpec ; import org . gradle . nativeplatform . toolchain . internal . compilespec . CppPCHCompileSpec ; import org . gradle . util . CollectionUtils ; import java . io . File ; import java . io . IOException ; import java . util . List ; public class PCHUtils { public static File generatePCHObjectDirectory ( File tempDir , File prefixHeaderFile , File preCompiledHeaderObjectFile ) { File generatedDir = new File ( tempDir , <str> ) ; generatedDir . mkdirs ( ) ; File generatedHeader = new File ( generatedDir , prefixHeaderFile . getName ( ) ) ; File generatedPCH = new File ( generatedDir , preCompiledHeaderObjectFile . getName ( ) ) ; try { FileUtils . copyFile ( prefixHeaderFile , generatedHeader ) ; FileUtils . copyFile ( preCompiledHeaderObjectFile , generatedPCH ) ; return generatedDir ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public static void generatePCHFile ( List < String > headers , File headerFile ) { if ( ! headerFile . getParentFile ( ) . exists ( ) ) { headerFile . getParentFile ( ) . mkdirs ( ) ; } try { FileUtils . writeLines ( headerFile , CollectionUtils . collect ( headers , new Transformer < String , String > ( ) { @Override public String transform ( String header ) { if ( header . startsWith ( <str> ) ) { return <str> . concat ( header ) ; } else { return <str> . concat ( header ) . concat ( <str> ) ; } } } ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public static < T extends NativeCompileSpec > File generatePCHSourceFile ( T original , File sourceFile ) { File generatedSourceDir = new File ( original . getTempDir ( ) , <str> ) ; generatedSourceDir . mkdirs ( ) ; File generatedSource = new File ( generatedSourceDir , FilenameUtils . removeExtension ( sourceFile . getName ( ) ) . concat ( getSourceFileExtension ( original . getClass ( ) ) ) ) ; File headerFileCopy = new File ( generatedSourceDir , sourceFile . getName ( ) ) ; try { FileUtils . copyFile ( sourceFile , headerFileCopy ) ; FileUtils . writeStringToFile ( generatedSource , <str> . concat ( headerFileCopy . getName ( ) ) . concat ( <str> ) ) ; return generatedSource ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } public static < T extends NativeCompileSpec > Transformer < T , T > getHeaderToSourceFileTransformer ( Class < T > type ) { return new Transformer < T , T > ( ) { @Override public T transform ( T original ) { List < File > newSourceFiles = Lists . newArrayList ( ) ; for ( File sourceFile : original . getSourceFiles ( ) ) { newSourceFiles . add ( generatePCHSourceFile ( original , sourceFile ) ) ; } original . setSourceFiles ( newSourceFiles ) ; return original ; } } ; } private static String getSourceFileExtension ( Class < ? extends NativeCompileSpec > specClass ) { if ( CPCHCompileSpec . class . isAssignableFrom ( specClass ) ) { return <str> ; } if ( CppPCHCompileSpec . class . isAssignableFrom ( specClass ) ) { return <str> ; } throw new IllegalArgumentException ( <str> . concat ( specClass . getSimpleName ( ) ) ) ; } } 
