package org . apache . cassandra . stress . util ; import java . util . Arrays ; import java . util . List ; import java . util . Random ; public final class SampleOfLongs { final long [ ] sample ; final double p ; SampleOfLongs ( long [ ] sample , int p ) { this . sample = sample ; this . p = <int> / ( float ) p ; } SampleOfLongs ( long [ ] sample , double p ) { this . sample = sample ; this . p = p ; } static SampleOfLongs merge ( Random rnd , List < SampleOfLongs > merge , int maxSamples ) { double targetp = <int> ; for ( SampleOfLongs sampleOfLongs : merge ) targetp = Math . min ( targetp , sampleOfLongs . p ) ; int maxLength = <int> ; for ( SampleOfLongs sampleOfLongs : merge ) maxLength + = sampleOfLongs . sample . length * ( targetp / sampleOfLongs . p ) ; if ( maxLength > maxSamples ) { targetp * = maxSamples / ( double ) maxLength ; maxLength = maxSamples ; } long [ ] sample = new long [ maxLength ] ; int count = <int> ; out : for ( SampleOfLongs latencies : merge ) { long [ ] in = latencies . sample ; double p = targetp / latencies . p ; for ( int i = <int> ; i < in . length ; i + + ) { if ( rnd . nextDouble ( ) < p ) { sample [ count + + ] = in [ i ] ; if ( count = = maxLength ) break out ; } } } if ( count ! = maxLength ) sample = Arrays . copyOf ( sample , count ) ; Arrays . sort ( sample ) ; return new SampleOfLongs ( sample , targetp ) ; } public double medianLatency ( ) { if ( sample . length = = <int> ) return <int> ; return sample [ sample . length > > <int> ] * <float> ; } public double rankLatency ( float rank ) { if ( sample . length = = <int> ) return <int> ; int index = ( int ) ( rank * sample . length ) ; if ( index > = sample . length ) index = sample . length - <int> ; return sample [ index ] * <float> ; } } 
