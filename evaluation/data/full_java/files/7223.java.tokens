package org . elasticsearch . search . aggregations . bucket . sampler ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . NumericDocValues ; import org . apache . lucene . search . DiversifiedTopDocsCollector ; import org . apache . lucene . search . DiversifiedTopDocsCollector . ScoreDocKey ; import org . apache . lucene . search . TopDocsCollector ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . util . BytesRefHash ; import org . elasticsearch . index . fielddata . SortedBinaryDocValues ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . bucket . BestDocsDeferringCollector ; import org . elasticsearch . search . aggregations . bucket . DeferringBucketCollector ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class DiversifiedMapSamplerAggregator extends SamplerAggregator { private ValuesSource valuesSource ; private int maxDocsPerValue ; private BytesRefHash bucketOrds ; public DiversifiedMapSamplerAggregator ( String name , int shardSize , AggregatorFactories factories , AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData , ValuesSource valuesSource , int maxDocsPerValue ) throws IOException { super ( name , shardSize , factories , aggregationContext , parent , pipelineAggregators , metaData ) ; this . valuesSource = valuesSource ; this . maxDocsPerValue = maxDocsPerValue ; bucketOrds = new BytesRefHash ( shardSize , aggregationContext . bigArrays ( ) ) ; } @Override protected void doClose ( ) { Releasables . close ( bucketOrds ) ; super . doClose ( ) ; } @Override public DeferringBucketCollector getDeferringCollector ( ) { bdd = new DiverseDocsDeferringCollector ( ) ; return bdd ; } class DiverseDocsDeferringCollector extends BestDocsDeferringCollector { public DiverseDocsDeferringCollector ( ) { super ( shardSize , context . bigArrays ( ) ) ; } @Override protected TopDocsCollector < ScoreDocKey > createTopDocsCollector ( int size ) { return new ValuesDiversifiedTopDocsCollector ( size , maxDocsPerValue ) ; } class ValuesDiversifiedTopDocsCollector extends DiversifiedTopDocsCollector { private SortedBinaryDocValues values ; public ValuesDiversifiedTopDocsCollector ( int numHits , int maxHitsPerKey ) { super ( numHits , maxHitsPerKey ) ; } @Override protected NumericDocValues getKeys ( LeafReaderContext context ) { try { values = valuesSource . bytesValues ( context ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> , e ) ; } return new NumericDocValues ( ) { @Override public long get ( int doc ) { values . setDocument ( doc ) ; final int valuesCount = values . count ( ) ; if ( valuesCount > <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( valuesCount = = <int> ) { final BytesRef bytes = values . valueAt ( <int> ) ; long bucketOrdinal = bucketOrds . add ( bytes ) ; if ( bucketOrdinal < <int> ) { bucketOrdinal = - <int> - bucketOrdinal ; } return bucketOrdinal ; } return <int> ; } } ; } } } } 
