package io . netty . handler . codec . socks ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . socks . SocksAuthResponseDecoder . State ; import java . util . List ; public class SocksAuthResponseDecoder extends ReplayingDecoder < State > { private SocksSubnegotiationVersion version ; private SocksAuthStatus authStatus ; private SocksResponse msg = SocksCommonUtils . UNKNOWN_SOCKS_RESPONSE ; public SocksAuthResponseDecoder ( ) { super ( State . CHECK_PROTOCOL_VERSION ) ; } @Override protected void decode ( ChannelHandlerContext channelHandlerContext , ByteBuf byteBuf , List < Object > out ) throws Exception { switch ( state ( ) ) { case CHECK_PROTOCOL_VERSION : { version = SocksSubnegotiationVersion . valueOf ( byteBuf . readByte ( ) ) ; if ( version ! = SocksSubnegotiationVersion . AUTH_PASSWORD ) { break ; } checkpoint ( State . READ_AUTH_RESPONSE ) ; } case READ_AUTH_RESPONSE : { authStatus = SocksAuthStatus . valueOf ( byteBuf . readByte ( ) ) ; msg = new SocksAuthResponse ( authStatus ) ; } } channelHandlerContext . pipeline ( ) . remove ( this ) ; out . add ( msg ) ; } enum State { CHECK_PROTOCOL_VERSION , READ_AUTH_RESPONSE } } 
