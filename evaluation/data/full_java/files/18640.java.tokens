package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . IntAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . graphics . g3d . model . MeshPart ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . physics . bullet . collision . btAxisSweep3 ; import com . badlogic . gdx . physics . bullet . collision . btCollisionDispatcher ; import com . badlogic . gdx . physics . bullet . collision . btDefaultCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . dynamics . btSequentialImpulseConstraintSolver ; import com . badlogic . gdx . physics . bullet . softbody . btSoftBody ; import com . badlogic . gdx . physics . bullet . softbody . btSoftBodyHelpers ; import com . badlogic . gdx . physics . bullet . softbody . btSoftBodyRigidBodyCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . softbody . btSoftBodyWorldInfo ; import com . badlogic . gdx . physics . bullet . softbody . btSoftRigidDynamicsWorld ; public class SoftBodyTest extends BaseBulletTest { btSoftBodyWorldInfo worldInfo ; btSoftBody softBody ; Texture texture ; Mesh mesh ; Model model ; ModelInstance instance ; Matrix4 tmpM = new Matrix4 ( ) ; @Override public BulletWorld createWorld ( ) { btDefaultCollisionConfiguration collisionConfiguration = new btSoftBodyRigidBodyCollisionConfiguration ( ) ; btCollisionDispatcher dispatcher = new btCollisionDispatcher ( collisionConfiguration ) ; btAxisSweep3 broadphase = new btAxisSweep3 ( tmpV1 . set ( - <int> , - <int> , - <int> ) , tmpV2 . set ( <int> , <int> , <int> ) , <int> ) ; btSequentialImpulseConstraintSolver solver = new btSequentialImpulseConstraintSolver ( ) ; btSoftRigidDynamicsWorld dynamicsWorld = new btSoftRigidDynamicsWorld ( dispatcher , broadphase , solver , collisionConfiguration ) ; worldInfo = new btSoftBodyWorldInfo ( ) ; worldInfo . setBroadphase ( broadphase ) ; worldInfo . setDispatcher ( dispatcher ) ; worldInfo . getSparsesdf ( ) . Initialize ( ) ; return new BulletWorld ( collisionConfiguration , dispatcher , broadphase , solver , dynamicsWorld ) ; } @Override public void create ( ) { super . create ( ) ; world . add ( <str> , <float> , <float> , <float> ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; float x0 = - <float> , y0 = <float> , z0 = - <float> ; float x1 = <float> , y1 = <float> , z1 = <float> ; Vector3 patch00 = new Vector3 ( x0 , y0 , z0 ) ; Vector3 patch10 = new Vector3 ( x1 , y1 , z0 ) ; Vector3 patch01 = new Vector3 ( x0 , y0 , z1 ) ; Vector3 patch11 = new Vector3 ( x1 , y1 , z1 ) ; softBody = btSoftBodyHelpers . CreatePatch ( worldInfo , patch00 , patch10 , patch01 , patch11 , <int> , <int> , <int> , false ) ; softBody . takeOwnership ( ) ; softBody . setTotalMass ( <int> f ) ; ( ( btSoftRigidDynamicsWorld ) ( world . collisionWorld ) ) . addSoftBody ( softBody ) ; final int vertCount = softBody . getNodeCount ( ) ; final int faceCount = softBody . getFaceCount ( ) ; mesh = new Mesh ( false , vertCount , faceCount * <int> , new VertexAttribute ( Usage . Position , <int> , ShaderProgram . POSITION_ATTRIBUTE ) , new VertexAttribute ( Usage . Normal , <int> , ShaderProgram . NORMAL_ATTRIBUTE ) , new VertexAttribute ( Usage . TextureCoordinates , <int> , ShaderProgram . TEXCOORD_ATTRIBUTE + <str> ) ) ; final int vertSize = mesh . getVertexSize ( ) / <int> ; mesh . getVerticesBuffer ( ) . position ( <int> ) ; mesh . getVerticesBuffer ( ) . limit ( vertCount * vertSize ) ; mesh . getIndicesBuffer ( ) . position ( <int> ) ; mesh . getIndicesBuffer ( ) . limit ( faceCount * <int> ) ; softBody . getVertices ( mesh . getVerticesBuffer ( ) , vertCount , mesh . getVertexSize ( ) , <int> ) ; softBody . getIndices ( mesh . getIndicesBuffer ( ) , faceCount ) ; final float [ ] verts = new float [ vertCount * vertSize ] ; final int uvOffset = mesh . getVertexAttribute ( Usage . TextureCoordinates ) . offset / <int> ; final int normalOffset = mesh . getVertexAttribute ( Usage . Normal ) . offset / <int> ; mesh . getVertices ( verts ) ; for ( int i = <int> ; i < vertCount ; i + + ) { verts [ i * vertSize + normalOffset ] = <float> ; verts [ i * vertSize + normalOffset + <int> ] = <float> ; verts [ i * vertSize + normalOffset + <int> ] = <float> ; verts [ i * vertSize + uvOffset ] = ( verts [ i * vertSize ] - x0 ) / ( x1 - x0 ) ; verts [ i * vertSize + uvOffset + <int> ] = ( verts [ i * vertSize + <int> ] - z0 ) / ( z1 - z0 ) ; } mesh . setVertices ( verts ) ; texture = new Texture ( Gdx . files . internal ( <str> ) ) ; ModelBuilder builder = new ModelBuilder ( ) ; builder . begin ( ) ; builder . part ( new MeshPart ( <str> , mesh , <int> , mesh . getNumIndices ( ) , GL20 . GL_TRIANGLES ) , new Material ( TextureAttribute . createDiffuse ( texture ) , ColorAttribute . createSpecular ( Color . WHITE ) , FloatAttribute . createShininess ( <int> f ) , IntAttribute . createCullFace ( <int> ) ) ) ; model = builder . end ( ) ; instance = new ModelInstance ( model ) ; world . add ( new BulletEntity ( instance , null ) ) ; } @Override public void dispose ( ) { ( ( btSoftRigidDynamicsWorld ) ( world . collisionWorld ) ) . removeSoftBody ( softBody ) ; softBody . dispose ( ) ; softBody = null ; super . dispose ( ) ; worldInfo . dispose ( ) ; worldInfo = null ; instance = null ; model . dispose ( ) ; model = null ; mesh = null ; texture . dispose ( ) ; texture = null ; } @Override protected void renderWorld ( ) { softBody . getVertices ( mesh . getVerticesBuffer ( ) , softBody . getNodeCount ( ) , mesh . getVertexSize ( ) , <int> ) ; softBody . getWorldTransform ( instance . transform ) ; super . renderWorld ( ) ; } @Override public boolean tap ( float x , float y , int count , int button ) { shoot ( x , y , <int> f ) ; return true ; } } 
