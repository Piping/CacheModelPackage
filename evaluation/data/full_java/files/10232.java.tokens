package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import java . util . AbstractQueue ; import java . util . Collection ; import java . util . Comparator ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . util . PriorityQueue ; import java . util . Queue ; import java . util . SortedSet ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . TimeUnit ; import javax . annotation . Nullable ; public class MonitorBasedPriorityBlockingQueue < E > extends AbstractQueue < E > implements BlockingQueue < E > { private static final long serialVersionUID = <int> ; final PriorityQueue < E > q ; final Monitor monitor = new Monitor ( true ) ; private final Monitor . Guard notEmpty = new Monitor . Guard ( monitor ) { @Override public boolean isSatisfied ( ) { return ! q . isEmpty ( ) ; } } ; public MonitorBasedPriorityBlockingQueue ( ) { q = new PriorityQueue < E > ( ) ; } public MonitorBasedPriorityBlockingQueue ( int initialCapacity ) { q = new PriorityQueue < E > ( initialCapacity , null ) ; } public MonitorBasedPriorityBlockingQueue ( int initialCapacity , @Nullable Comparator < ? super E > comparator ) { q = new PriorityQueue < E > ( initialCapacity , comparator ) ; } public MonitorBasedPriorityBlockingQueue ( Collection < ? extends E > c ) { q = new PriorityQueue < E > ( c ) ; } @Override public boolean add ( E e ) { return offer ( e ) ; } @Override public boolean offer ( E e ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { boolean ok = q . offer ( e ) ; if ( ! ok ) { throw new AssertionError ( ) ; } return true ; } finally { monitor . leave ( ) ; } } @Override public void put ( E e ) { offer ( e ) ; } @Override public boolean offer ( E e , long timeout , TimeUnit unit ) { checkNotNull ( unit ) ; return offer ( e ) ; } @Override public E poll ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return q . poll ( ) ; } finally { monitor . leave ( ) ; } } @Override public E take ( ) throws InterruptedException { final Monitor monitor = this . monitor ; monitor . enterWhen ( notEmpty ) ; try { return q . poll ( ) ; } finally { monitor . leave ( ) ; } } @Override public E poll ( long timeout , TimeUnit unit ) throws InterruptedException { final Monitor monitor = this . monitor ; if ( monitor . enterWhen ( notEmpty , timeout , unit ) ) { try { return q . poll ( ) ; } finally { monitor . leave ( ) ; } } else { return null ; } } @Override public E peek ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return q . peek ( ) ; } finally { monitor . leave ( ) ; } } public Comparator < ? super E > comparator ( ) { return q . comparator ( ) ; } @Override public int size ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return q . size ( ) ; } finally { monitor . leave ( ) ; } } @Override public int remainingCapacity ( ) { return Integer . MAX_VALUE ; } @Override public boolean remove ( @Nullable Object o ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return q . remove ( o ) ; } finally { monitor . leave ( ) ; } } @Override public boolean contains ( @Nullable Object o ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return q . contains ( o ) ; } finally { monitor . leave ( ) ; } } @Override public Object [ ] toArray ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return q . toArray ( ) ; } finally { monitor . leave ( ) ; } } @Override public String toString ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return q . toString ( ) ; } finally { monitor . leave ( ) ; } } @Override public int drainTo ( Collection < ? super E > c ) { if ( c = = null ) throw new NullPointerException ( ) ; if ( c = = this ) throw new IllegalArgumentException ( ) ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { int n = <int> ; E e ; while ( ( e = q . poll ( ) ) ! = null ) { c . add ( e ) ; + + n ; } return n ; } finally { monitor . leave ( ) ; } } @Override public int drainTo ( Collection < ? super E > c , int maxElements ) { if ( c = = null ) throw new NullPointerException ( ) ; if ( c = = this ) throw new IllegalArgumentException ( ) ; if ( maxElements < = <int> ) return <int> ; final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { int n = <int> ; E e ; while ( n < maxElements & & ( e = q . poll ( ) ) ! = null ) { c . add ( e ) ; + + n ; } return n ; } finally { monitor . leave ( ) ; } } @Override public void clear ( ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { q . clear ( ) ; } finally { monitor . leave ( ) ; } } @Override public < T > T [ ] toArray ( T [ ] a ) { final Monitor monitor = this . monitor ; monitor . enter ( ) ; try { return q . toArray ( a ) ; } finally { monitor . leave ( ) ; } } @Override public Iterator < E > iterator ( ) { return new Itr ( toArray ( ) ) ; } private class Itr implements Iterator < E > { final Object [ ] array ; int cursor ; int lastRet ; Itr ( Object [ ] array ) { lastRet = - <int> ; this . array = array ; } @Override public boolean hasNext ( ) { return cursor < array . length ; } @Override public E next ( ) { if ( cursor > = array . length ) throw new NoSuchElementException ( ) ; lastRet = cursor ; @SuppressWarnings ( <str> ) E e = ( E ) array [ cursor + + ] ; return e ; } @Override public void remove ( ) { if ( lastRet < <int> ) throw new IllegalStateException ( ) ; Object x = array [ lastRet ] ; lastRet = - <int> ; monitor . enter ( ) ; try { for ( Iterator < E > it = q . iterator ( ) ; it . hasNext ( ) ; ) { if ( it . next ( ) = = x ) { it . remove ( ) ; return ; } } } finally { monitor . leave ( ) ; } } } private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { monitor . enter ( ) ; try { s . defaultWriteObject ( ) ; } finally { monitor . leave ( ) ; } } } 
