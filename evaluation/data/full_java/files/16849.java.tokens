package com . badlogic . gdx . graphics ; import java . nio . Buffer ; import java . nio . IntBuffer ; import java . util . HashMap ; import java . util . Map ; import com . badlogic . gdx . backends . gwt . GwtFileHandle ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . google . gwt . canvas . client . Canvas ; import com . google . gwt . canvas . dom . client . CanvasPixelArray ; import com . google . gwt . canvas . dom . client . Context2d ; import com . google . gwt . canvas . dom . client . Context2d . Composite ; import com . google . gwt . dom . client . CanvasElement ; import com . google . gwt . dom . client . ImageElement ; public class Pixmap implements Disposable { public static Map < Integer , Pixmap > pixmaps = new HashMap < Integer , Pixmap > ( ) ; static int nextId = <int> ; public enum Format { Alpha , Intensity , LuminanceAlpha , RGB565 , RGBA4444 , RGB888 , RGBA8888 ; public static int toGlFormat ( Format format ) { if ( format = = Alpha ) return GL20 . GL_ALPHA ; if ( format = = Intensity ) return GL20 . GL_ALPHA ; if ( format = = LuminanceAlpha ) return GL20 . GL_LUMINANCE_ALPHA ; if ( format = = RGB565 ) return GL20 . GL_RGB ; if ( format = = RGB888 ) return GL20 . GL_RGB ; if ( format = = RGBA4444 ) return GL20 . GL_RGBA ; if ( format = = RGBA8888 ) return GL20 . GL_RGBA ; throw new GdxRuntimeException ( <str> + format ) ; } public static int toGlType ( Format format ) { if ( format = = Alpha ) return GL20 . GL_UNSIGNED_BYTE ; if ( format = = Intensity ) return GL20 . GL_UNSIGNED_BYTE ; if ( format = = LuminanceAlpha ) return GL20 . GL_UNSIGNED_BYTE ; if ( format = = RGB565 ) return GL20 . GL_UNSIGNED_SHORT_5_6_5 ; if ( format = = RGB888 ) return GL20 . GL_UNSIGNED_BYTE ; if ( format = = RGBA4444 ) return GL20 . GL_UNSIGNED_SHORT_4_4_4_4 ; if ( format = = RGBA8888 ) return GL20 . GL_UNSIGNED_BYTE ; throw new GdxRuntimeException ( <str> + format ) ; } } public enum Blending { None , SourceOver } public enum Filter { NearestNeighbour , BiLinear } int width ; int height ; Format format ; Canvas canvas ; Context2d context ; int id ; IntBuffer buffer ; int r = <int> , g = <int> , b = <int> ; float a ; String color = make ( r , g , b , a ) ; static String clearColor = make ( <int> , <int> , <int> , <float> ) ; static Blending blending ; CanvasPixelArray pixels ; public Pixmap ( FileHandle file ) { GwtFileHandle gwtFile = ( GwtFileHandle ) file ; ImageElement img = gwtFile . preloader . images . get ( file . path ( ) ) ; if ( img = = null ) throw new GdxRuntimeException ( <str> + file . path ( ) + <str> ) ; create ( img . getWidth ( ) , img . getHeight ( ) , Format . RGBA8888 ) ; context . setGlobalCompositeOperation ( Composite . COPY ) ; context . drawImage ( img , <int> , <int> ) ; context . setGlobalCompositeOperation ( getComposite ( ) ) ; } private static Composite getComposite ( ) { return Composite . SOURCE_OVER ; } public Pixmap ( ImageElement img ) { create ( img . getWidth ( ) , img . getHeight ( ) , Format . RGBA8888 ) ; context . drawImage ( img , <int> , <int> ) ; } public Pixmap ( int width , int height , Format format ) { create ( width , height , format ) ; } private void create ( int width , int height , Format format2 ) { this . width = width ; this . height = height ; this . format = Format . RGBA8888 ; canvas = Canvas . createIfSupported ( ) ; canvas . getCanvasElement ( ) . setWidth ( width ) ; canvas . getCanvasElement ( ) . setHeight ( height ) ; context = canvas . getContext2d ( ) ; context . setGlobalCompositeOperation ( getComposite ( ) ) ; buffer = BufferUtils . newIntBuffer ( <int> ) ; id = nextId + + ; buffer . put ( <int> , id ) ; pixmaps . put ( id , this ) ; } public static String make ( int r2 , int g2 , int b2 , float a2 ) { return <str> + r2 + <str> + g2 + <str> + b2 + <str> + a2 + <str> ; } public static void setBlending ( Blending blending ) { Pixmap . blending = blending ; Composite composite = getComposite ( ) ; for ( Pixmap pixmap : pixmaps . values ( ) ) { pixmap . context . setGlobalCompositeOperation ( composite ) ; } } public static Blending getBlending ( ) { return blending ; } public static void setFilter ( Filter filter ) { } public Format getFormat ( ) { return format ; } public int getGLInternalFormat ( ) { return GL20 . GL_RGBA ; } public int getGLFormat ( ) { return GL20 . GL_RGBA ; } public int getGLType ( ) { return GL20 . GL_UNSIGNED_BYTE ; } public int getWidth ( ) { return width ; } public int getHeight ( ) { return height ; } public Buffer getPixels ( ) { return buffer ; } @Override public void dispose ( ) { pixmaps . remove ( id ) ; } public CanvasElement getCanvasElement ( ) { return canvas . getCanvasElement ( ) ; } public void setColor ( int color ) { r = ( color > > > <int> ) & <hex> ; g = ( color > > > <int> ) & <hex> ; b = ( color > > > <int> ) & <hex> ; a = ( color & <hex> ) / <int> f ; this . color = make ( r , g , b , a ) ; context . setFillStyle ( this . color ) ; context . setStrokeStyle ( this . color ) ; } public void setColor ( float r , float g , float b , float a ) { this . r = ( int ) ( r * <int> ) ; this . g = ( int ) ( g * <int> ) ; this . b = ( int ) ( b * <int> ) ; this . a = a ; color = make ( this . r , this . g , this . b , this . a ) ; context . setFillStyle ( color ) ; context . setStrokeStyle ( this . color ) ; } public void setColor ( Color color ) { setColor ( color . r , color . g , color . b , color . a ) ; } public void fill ( ) { rectangle ( <int> , <int> , getWidth ( ) , getHeight ( ) , DrawType . FILL ) ; } public void drawLine ( int x , int y , int x2 , int y2 ) { line ( x , y , x2 , y2 , DrawType . STROKE ) ; } public void drawRectangle ( int x , int y , int width , int height ) { rectangle ( x , y , width , height , DrawType . STROKE ) ; } public void drawPixmap ( Pixmap pixmap , int x , int y ) { CanvasElement image = pixmap . getCanvasElement ( ) ; image ( image , <int> , <int> , image . getWidth ( ) , image . getHeight ( ) , x , y , image . getWidth ( ) , image . getHeight ( ) ) ; } public void drawPixmap ( Pixmap pixmap , int x , int y , int srcx , int srcy , int srcWidth , int srcHeight ) { CanvasElement image = pixmap . getCanvasElement ( ) ; image ( image , srcx , srcy , srcWidth , srcHeight , x , y , srcWidth , srcHeight ) ; } public void drawPixmap ( Pixmap pixmap , int srcx , int srcy , int srcWidth , int srcHeight , int dstx , int dsty , int dstWidth , int dstHeight ) { image ( pixmap . getCanvasElement ( ) , srcx , srcy , srcWidth , srcHeight , dstx , dsty , dstWidth , dstHeight ) ; } public void fillRectangle ( int x , int y , int width , int height ) { rectangle ( x , y , width , height , DrawType . FILL ) ; } public void drawCircle ( int x , int y , int radius ) { circle ( x , y , radius , DrawType . STROKE ) ; } public void fillCircle ( int x , int y , int radius ) { circle ( x , y , radius , DrawType . FILL ) ; } public void fillTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { triangle ( x1 , y1 , x2 , y2 , x3 , y3 , DrawType . FILL ) ; } public int getPixel ( int x , int y ) { if ( pixels = = null ) pixels = context . getImageData ( <int> , <int> , width , height ) . getData ( ) ; int i = x * <int> + y * width * <int> ; int r = pixels . get ( i + <int> ) & <hex> ; int g = pixels . get ( i + <int> ) & <hex> ; int b = pixels . get ( i + <int> ) & <hex> ; int a = pixels . get ( i + <int> ) & <hex> ; return ( r < < <int> ) | ( g < < <int> ) | ( b < < <int> ) | ( a ) ; } public void drawPixel ( int x , int y ) { rectangle ( x , y , <int> , <int> , DrawType . FILL ) ; } public void drawPixel ( int x , int y , int color ) { setColor ( color ) ; drawPixel ( x , y ) ; } private void circle ( int x , int y , int radius , DrawType drawType ) { if ( blending = = Blending . None ) { context . setFillStyle ( clearColor ) ; context . setStrokeStyle ( clearColor ) ; context . setGlobalCompositeOperation ( <str> ) ; context . beginPath ( ) ; context . arc ( x , y , radius , <int> , <int> * Math . PI , false ) ; fillOrStrokePath ( drawType ) ; context . closePath ( ) ; context . setFillStyle ( color ) ; context . setStrokeStyle ( color ) ; context . setGlobalCompositeOperation ( Composite . SOURCE_OVER ) ; } context . beginPath ( ) ; context . arc ( x , y , radius , <int> , <int> * Math . PI , false ) ; fillOrStrokePath ( drawType ) ; context . closePath ( ) ; pixels = null ; } private void line ( int x , int y , int x2 , int y2 , DrawType drawType ) { if ( blending = = Blending . None ) { context . setFillStyle ( clearColor ) ; context . setStrokeStyle ( clearColor ) ; context . setGlobalCompositeOperation ( <str> ) ; context . beginPath ( ) ; context . moveTo ( x , y ) ; context . lineTo ( x2 , y2 ) ; fillOrStrokePath ( drawType ) ; context . closePath ( ) ; context . setFillStyle ( color ) ; context . setStrokeStyle ( color ) ; context . setGlobalCompositeOperation ( Composite . SOURCE_OVER ) ; } context . beginPath ( ) ; context . moveTo ( x , y ) ; context . lineTo ( x2 , y2 ) ; fillOrStrokePath ( drawType ) ; context . closePath ( ) ; } private void rectangle ( int x , int y , int width , int height , DrawType drawType ) { if ( blending = = Blending . None ) { context . setFillStyle ( clearColor ) ; context . setStrokeStyle ( clearColor ) ; context . setGlobalCompositeOperation ( <str> ) ; context . beginPath ( ) ; context . rect ( x , y , width , height ) ; fillOrStrokePath ( drawType ) ; context . closePath ( ) ; context . setFillStyle ( color ) ; context . setStrokeStyle ( color ) ; context . setGlobalCompositeOperation ( Composite . SOURCE_OVER ) ; } context . beginPath ( ) ; context . rect ( x , y , width , height ) ; fillOrStrokePath ( drawType ) ; context . closePath ( ) ; pixels = null ; } private void triangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , DrawType drawType ) { if ( blending = = Blending . None ) { context . setFillStyle ( clearColor ) ; context . setStrokeStyle ( clearColor ) ; context . setGlobalCompositeOperation ( <str> ) ; context . beginPath ( ) ; context . moveTo ( x1 , y1 ) ; context . lineTo ( x2 , y2 ) ; context . lineTo ( x3 , y3 ) ; context . lineTo ( x1 , y1 ) ; fillOrStrokePath ( drawType ) ; context . closePath ( ) ; context . setFillStyle ( color ) ; context . setStrokeStyle ( color ) ; context . setGlobalCompositeOperation ( Composite . SOURCE_OVER ) ; } context . beginPath ( ) ; context . moveTo ( x1 , y1 ) ; context . lineTo ( x2 , y2 ) ; context . lineTo ( x3 , y3 ) ; context . lineTo ( x1 , y1 ) ; fillOrStrokePath ( drawType ) ; context . closePath ( ) ; pixels = null ; } private void image ( CanvasElement image , int srcX , int srcY , int srcWidth , int srcHeight , int dstX , int dstY , int dstWidth , int dstHeight ) { if ( blending = = Blending . None ) { context . setFillStyle ( clearColor ) ; context . setStrokeStyle ( clearColor ) ; context . setGlobalCompositeOperation ( <str> ) ; context . beginPath ( ) ; context . rect ( dstX , dstY , dstWidth , dstHeight ) ; fillOrStrokePath ( DrawType . FILL ) ; context . closePath ( ) ; context . setFillStyle ( color ) ; context . setStrokeStyle ( color ) ; context . setGlobalCompositeOperation ( Composite . SOURCE_OVER ) ; } context . drawImage ( image , srcX , srcY , srcWidth , srcHeight , dstX , dstY , dstWidth , dstHeight ) ; pixels = null ; } private void fillOrStrokePath ( DrawType drawType ) { switch ( drawType ) { case FILL : context . fill ( ) ; break ; case STROKE : context . stroke ( ) ; break ; } } private enum DrawType { FILL , STROKE } } 
