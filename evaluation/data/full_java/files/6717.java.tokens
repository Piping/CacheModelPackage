package org . elasticsearch . index . query . support ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . fetch . fielddata . FieldDataFieldsParseElement ; import org . elasticsearch . search . fetch . innerhits . InnerHitsSubSearchContext ; import org . elasticsearch . search . fetch . script . ScriptFieldsParseElement ; import org . elasticsearch . search . fetch . source . FetchSourceParseElement ; import org . elasticsearch . search . highlight . HighlighterParseElement ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . internal . SubSearchContext ; import org . elasticsearch . search . sort . SortParseElement ; import java . io . IOException ; public class InnerHitsQueryParserHelper { public static final InnerHitsQueryParserHelper INSTANCE = new InnerHitsQueryParserHelper ( ) ; private static final SortParseElement sortParseElement = new SortParseElement ( ) ; private static final FetchSourceParseElement sourceParseElement = new FetchSourceParseElement ( ) ; private static final HighlighterParseElement highlighterParseElement = new HighlighterParseElement ( ) ; private static final ScriptFieldsParseElement scriptFieldsParseElement = new ScriptFieldsParseElement ( ) ; private static final FieldDataFieldsParseElement fieldDataFieldsParseElement = new FieldDataFieldsParseElement ( ) ; public static InnerHitsSubSearchContext parse ( XContentParser parser ) throws IOException { String fieldName = null ; XContentParser . Token token ; String innerHitName = null ; SubSearchContext subSearchContext = new SubSearchContext ( SearchContext . current ( ) ) ; try { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { fieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( fieldName ) ) { innerHitName = parser . textOrNull ( ) ; } else { parseCommonInnerHitOptions ( parser , token , fieldName , subSearchContext , sortParseElement , sourceParseElement , highlighterParseElement , scriptFieldsParseElement , fieldDataFieldsParseElement ) ; } } else { parseCommonInnerHitOptions ( parser , token , fieldName , subSearchContext , sortParseElement , sourceParseElement , highlighterParseElement , scriptFieldsParseElement , fieldDataFieldsParseElement ) ; } } } catch ( Exception e ) { throw new IOException ( <str> , e ) ; } return new InnerHitsSubSearchContext ( innerHitName , subSearchContext ) ; } public static void parseCommonInnerHitOptions ( XContentParser parser , XContentParser . Token token , String fieldName , SubSearchContext subSearchContext , SortParseElement sortParseElement , FetchSourceParseElement sourceParseElement , HighlighterParseElement highlighterParseElement , ScriptFieldsParseElement scriptFieldsParseElement , FieldDataFieldsParseElement fieldDataFieldsParseElement ) throws Exception { if ( <str> . equals ( fieldName ) ) { sortParseElement . parse ( parser , subSearchContext ) ; } else if ( <str> . equals ( fieldName ) ) { sourceParseElement . parse ( parser , subSearchContext ) ; } else if ( token = = XContentParser . Token . START_OBJECT ) { switch ( fieldName ) { case <str> : highlighterParseElement . parse ( parser , subSearchContext ) ; break ; case <str> : case <str> : scriptFieldsParseElement . parse ( parser , subSearchContext ) ; break ; default : throw new IllegalArgumentException ( <str> + token + <str> + fieldName + <str> ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { switch ( fieldName ) { case <str> : case <str> : fieldDataFieldsParseElement . parse ( parser , subSearchContext ) ; break ; case <str> : boolean added = false ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { String name = parser . text ( ) ; added = true ; subSearchContext . fieldNames ( ) . add ( name ) ; } if ( ! added ) { subSearchContext . emptyFieldNames ( ) ; } break ; default : throw new IllegalArgumentException ( <str> + token + <str> + fieldName + <str> ) ; } } else if ( token . isValue ( ) ) { switch ( fieldName ) { case <str> : subSearchContext . from ( parser . intValue ( ) ) ; break ; case <str> : subSearchContext . size ( parser . intValue ( ) ) ; break ; case <str> : case <str> : subSearchContext . trackScores ( parser . booleanValue ( ) ) ; break ; case <str> : subSearchContext . version ( parser . booleanValue ( ) ) ; break ; case <str> : subSearchContext . explain ( parser . booleanValue ( ) ) ; break ; case <str> : subSearchContext . fieldNames ( ) . add ( parser . text ( ) ) ; break ; default : throw new IllegalArgumentException ( <str> + token + <str> + fieldName + <str> ) ; } } } } 
