package org . apache . cassandra . db ; import java . io . File ; import java . io . IOException ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . util . * ; import org . apache . commons . io . FileUtils ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . dht . ByteOrderedPartitioner . BytesToken ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . CassandraVersion ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class SystemKeyspaceTest { public static final String MIGRATION_SSTABLES_ROOT = <str> ; @BeforeClass public static void prepSnapshotTracker ( ) { if ( FBUtilities . isWindows ( ) ) WindowsFailedSnapshotTracker . deleteOldSnapshots ( ) ; } @Test public void testLocalTokens ( ) { Collection < Token > current = SystemKeyspace . loadTokens ( ) . asMap ( ) . get ( FBUtilities . getLocalAddress ( ) ) ; if ( current ! = null & & ! current . isEmpty ( ) ) SystemKeyspace . updateTokens ( current ) ; List < Token > tokens = new ArrayList < Token > ( ) { { for ( int i = <int> ; i < <int> ; i + + ) add ( new BytesToken ( ByteBufferUtil . bytes ( String . format ( <str> , i ) ) ) ) ; } } ; SystemKeyspace . updateTokens ( tokens ) ; int count = <int> ; for ( Token tok : SystemKeyspace . getSavedTokens ( ) ) assert tokens . get ( count + + ) . equals ( tok ) ; } @Test public void testNonLocalToken ( ) throws UnknownHostException { BytesToken token = new BytesToken ( ByteBufferUtil . bytes ( <str> ) ) ; InetAddress address = InetAddress . getByName ( <str> ) ; SystemKeyspace . updateTokens ( address , Collections . < Token > singletonList ( token ) ) ; assert SystemKeyspace . loadTokens ( ) . get ( address ) . contains ( token ) ; SystemKeyspace . removeEndpoint ( address ) ; assert ! SystemKeyspace . loadTokens ( ) . containsValue ( token ) ; } @Test public void testLocalHostID ( ) { UUID firstId = SystemKeyspace . getLocalHostId ( ) ; UUID secondId = SystemKeyspace . getLocalHostId ( ) ; assert firstId . equals ( secondId ) : String . format ( <str> , firstId . toString ( ) , secondId . toString ( ) ) ; } private void assertDeletedOrDeferred ( int expectedCount ) { if ( FBUtilities . isWindows ( ) ) assertEquals ( expectedCount , getDeferredDeletionCount ( ) ) ; else assertTrue ( getSystemSnapshotFiles ( ) . isEmpty ( ) ) ; } private int getDeferredDeletionCount ( ) { try { Class c = Class . forName ( <str> ) ; LinkedHashSet < String > files = ( LinkedHashSet < String > ) FBUtilities . getProtectedField ( c , <str> ) . get ( c ) ; return files . size ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } @Test public void snapshotSystemKeyspaceIfUpgrading ( ) throws IOException { for ( ColumnFamilyStore cfs : Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStores ( ) ) cfs . clearUnsafe ( ) ; Keyspace . clearSnapshot ( null , SystemKeyspace . NAME ) ; int baseline = getDeferredDeletionCount ( ) ; SystemKeyspace . snapshotOnVersionChange ( ) ; assertDeletedOrDeferred ( baseline ) ; setupReleaseVersion ( getOlderVersionString ( ) ) ; Keyspace . clearSnapshot ( null , SystemKeyspace . NAME ) ; assertDeletedOrDeferred ( baseline ) ; SystemKeyspace . snapshotOnVersionChange ( ) ; assertEquals ( SystemKeyspace . metadata ( ) . tables . size ( ) , getSystemSnapshotFiles ( ) . size ( ) ) ; Keyspace . clearSnapshot ( null , SystemKeyspace . NAME ) ; setupReleaseVersion ( FBUtilities . getReleaseVersionString ( ) ) ; SystemKeyspace . snapshotOnVersionChange ( ) ; assertDeletedOrDeferred ( baseline + <int> ) ; Keyspace . clearSnapshot ( null , SystemKeyspace . NAME ) ; } @Test public void testMigrateEmptyDataDirs ( ) throws IOException { File dataDir = Paths . get ( DatabaseDescriptor . getAllDataFileLocations ( ) [ <int> ] ) . toFile ( ) ; if ( new File ( dataDir , <str> ) . exists ( ) ) FileUtils . deleteDirectory ( new File ( dataDir , <str> ) ) ; assertTrue ( new File ( dataDir , <str> ) . mkdirs ( ) ) ; assertEquals ( <int> , numLegacyFiles ( ) ) ; SystemKeyspace . migrateDataDirs ( ) ; assertEquals ( <int> , numLegacyFiles ( ) ) ; assertTrue ( new File ( dataDir , <str> ) . mkdirs ( ) ) ; assertEquals ( <int> , numLegacyFiles ( ) ) ; SystemKeyspace . migrateDataDirs ( ) ; assertEquals ( <int> , numLegacyFiles ( ) ) ; assertTrue ( new File ( dataDir , <str> ) . createNewFile ( ) ) ; assertEquals ( <int> , numLegacyFiles ( ) ) ; SystemKeyspace . migrateDataDirs ( ) ; assertEquals ( <int> , numLegacyFiles ( ) ) ; } @Test public void testMigrateDataDirs_2_1 ( ) throws IOException { testMigrateDataDirs ( <str> ) ; } @Test public void testMigrateDataDirs_2_2 ( ) throws IOException { testMigrateDataDirs ( <str> ) ; } private void testMigrateDataDirs ( String version ) throws IOException { Path migrationSSTableRoot = Paths . get ( System . getProperty ( MIGRATION_SSTABLES_ROOT ) , version ) ; Path dataDir = Paths . get ( DatabaseDescriptor . getAllDataFileLocations ( ) [ <int> ] ) ; FileUtils . copyDirectory ( migrationSSTableRoot . toFile ( ) , dataDir . toFile ( ) ) ; assertEquals ( <int> , numLegacyFiles ( ) ) ; SystemKeyspace . migrateDataDirs ( ) ; assertEquals ( <int> , numLegacyFiles ( ) ) ; } private static int numLegacyFiles ( ) { int ret = <int> ; Iterable < String > dirs = Arrays . asList ( DatabaseDescriptor . getAllDataFileLocations ( ) ) ; for ( String dataDir : dirs ) { File dir = new File ( dataDir ) ; for ( File ksdir : dir . listFiles ( ( d , n ) - > new File ( d , n ) . isDirectory ( ) ) ) { for ( File cfdir : ksdir . listFiles ( ( d , n ) - > new File ( d , n ) . isDirectory ( ) ) ) { if ( Descriptor . isLegacyFile ( cfdir ) ) { ret + + ; } else { File [ ] legacyFiles = cfdir . listFiles ( ( d , n ) - > Descriptor . isLegacyFile ( new File ( d , n ) ) ) ; ret + = legacyFiles . length ; } } } } return ret ; } private String getOlderVersionString ( ) { String version = FBUtilities . getReleaseVersionString ( ) ; CassandraVersion semver = new CassandraVersion ( version . contains ( <str> ) ? version . substring ( <int> , version . indexOf ( <str> ) ) : version ) ; return ( String . format ( <str> , semver . major - <int> , semver . minor , semver . patch ) ) ; } private Set < String > getSystemSnapshotFiles ( ) { Set < String > snapshottedTableNames = new HashSet < > ( ) ; for ( ColumnFamilyStore cfs : Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStores ( ) ) { if ( ! cfs . getSnapshotDetails ( ) . isEmpty ( ) ) snapshottedTableNames . add ( cfs . getColumnFamilyName ( ) ) ; } return snapshottedTableNames ; } private void setupReleaseVersion ( String version ) { QueryProcessor . executeInternal ( String . format ( <str> + <str> , version , DatabaseDescriptor . getClusterName ( ) ) ) ; String r = readLocalVersion ( ) ; assertEquals ( String . format ( <str> , version , r ) , version , r ) ; } private String readLocalVersion ( ) { UntypedResultSet rs = QueryProcessor . executeInternal ( <str> ) ; return rs . isEmpty ( ) | | ! rs . one ( ) . has ( <str> ) ? null : rs . one ( ) . getString ( <str> ) ; } } 
