package org . elasticsearch . common . inject ; import org . elasticsearch . common . inject . internal . ConstructionContext ; import org . elasticsearch . common . inject . internal . Errors ; import org . elasticsearch . common . inject . internal . ErrorsException ; import org . elasticsearch . common . inject . internal . InternalContext ; import org . elasticsearch . common . inject . spi . InjectionPoint ; import java . lang . reflect . InvocationTargetException ; import java . util . Set ; class ConstructorInjector < T > { private final Set < InjectionPoint > injectableMembers ; private final SingleParameterInjector < ? > [ ] parameterInjectors ; private final ConstructionProxy < T > constructionProxy ; private final MembersInjectorImpl < T > membersInjector ; ConstructorInjector ( Set < InjectionPoint > injectableMembers , ConstructionProxy < T > constructionProxy , SingleParameterInjector < ? > [ ] parameterInjectors , MembersInjectorImpl < T > membersInjector ) throws ErrorsException { this . injectableMembers = injectableMembers ; this . constructionProxy = constructionProxy ; this . parameterInjectors = parameterInjectors ; this . membersInjector = membersInjector ; } public Set < InjectionPoint > getInjectableMembers ( ) { return injectableMembers ; } ConstructionProxy < T > getConstructionProxy ( ) { return constructionProxy ; } Object construct ( Errors errors , InternalContext context , Class < ? > expectedType ) throws ErrorsException { ConstructionContext < T > constructionContext = context . getConstructionContext ( this ) ; if ( constructionContext . isConstructing ( ) ) { return constructionContext . createProxy ( errors , expectedType ) ; } T t = constructionContext . getCurrentReference ( ) ; if ( t ! = null ) { return t ; } try { constructionContext . startConstruction ( ) ; try { Object [ ] parameters = SingleParameterInjector . getAll ( errors , context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; } constructionContext . setCurrentReference ( t ) ; membersInjector . injectMembers ( t , errors , context ) ; membersInjector . notifyListeners ( t , errors ) ; return t ; } catch ( InvocationTargetException userException ) { Throwable cause = userException . getCause ( ) ! = null ? userException . getCause ( ) : userException ; throw errors . withSource ( constructionProxy . getInjectionPoint ( ) ) . errorInjectingConstructor ( cause ) . toException ( ) ; } finally { constructionContext . removeCurrentReference ( ) ; } } } 
