package org . apache . cassandra . stress . settings ; import java . io . Serializable ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import org . apache . cassandra . config . EncryptionOptions ; import org . apache . cassandra . thrift . ITransportFactory ; import org . apache . cassandra . thrift . SSLTransportFactory ; import org . apache . cassandra . thrift . TFramedTransportFactory ; public class SettingsTransport implements Serializable { private final String fqFactoryClass ; private final TOptions options ; private ITransportFactory factory ; public SettingsTransport ( TOptions options ) { this . options = options ; this . fqFactoryClass = options . factory . value ( ) ; try { Class < ? > clazz = Class . forName ( fqFactoryClass ) ; if ( ! ITransportFactory . class . isAssignableFrom ( clazz ) ) throw new IllegalArgumentException ( clazz + <str> ) ; clazz . newInstance ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> + options . factory . value ( ) , e ) ; } } private void configureTransportFactory ( ITransportFactory transportFactory , TOptions options ) { Map < String , String > factoryOptions = new HashMap < > ( ) ; if ( transportFactory . supportedOptions ( ) . contains ( SSLTransportFactory . TRUSTSTORE ) ) factoryOptions . put ( SSLTransportFactory . TRUSTSTORE , options . trustStore . value ( ) ) ; if ( transportFactory . supportedOptions ( ) . contains ( SSLTransportFactory . TRUSTSTORE_PASSWORD ) ) factoryOptions . put ( SSLTransportFactory . TRUSTSTORE_PASSWORD , options . trustStorePw . value ( ) ) ; if ( transportFactory . supportedOptions ( ) . contains ( SSLTransportFactory . PROTOCOL ) ) factoryOptions . put ( SSLTransportFactory . PROTOCOL , options . protocol . value ( ) ) ; if ( transportFactory . supportedOptions ( ) . contains ( SSLTransportFactory . CIPHER_SUITES ) ) factoryOptions . put ( SSLTransportFactory . CIPHER_SUITES , options . ciphers . value ( ) ) ; for ( String optionKey : transportFactory . supportedOptions ( ) ) if ( System . getProperty ( optionKey ) ! = null ) factoryOptions . put ( optionKey , System . getProperty ( optionKey ) ) ; transportFactory . setOptions ( factoryOptions ) ; } public synchronized ITransportFactory getFactory ( ) { if ( factory = = null ) { try { this . factory = ( ITransportFactory ) Class . forName ( fqFactoryClass ) . newInstance ( ) ; configureTransportFactory ( this . factory , this . options ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } return factory ; } public EncryptionOptions . ClientEncryptionOptions getEncryptionOptions ( ) { EncryptionOptions . ClientEncryptionOptions encOptions = new EncryptionOptions . ClientEncryptionOptions ( ) ; if ( options . trustStore . present ( ) ) { encOptions . enabled = true ; encOptions . truststore = options . trustStore . value ( ) ; encOptions . truststore_password = options . trustStorePw . value ( ) ; encOptions . algorithm = options . alg . value ( ) ; encOptions . protocol = options . protocol . value ( ) ; encOptions . cipher_suites = options . ciphers . value ( ) . split ( <str> ) ; } return encOptions ; } static class TOptions extends GroupedOptions implements Serializable { final OptionSimple factory = new OptionSimple ( <str> , <str> , TFramedTransportFactory . class . getName ( ) , <str> , false ) ; final OptionSimple trustStore = new OptionSimple ( <str> , <str> , null , <str> , false ) ; final OptionSimple trustStorePw = new OptionSimple ( <str> , <str> , null , <str> , false ) ; final OptionSimple protocol = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; final OptionSimple alg = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; final OptionSimple storeType = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; final OptionSimple ciphers = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; @Override public List < ? extends Option > options ( ) { return Arrays . asList ( factory , trustStore , trustStorePw , protocol , alg , storeType , ciphers ) ; } } public static SettingsTransport get ( Map < String , String [ ] > clArgs ) { String [ ] params = clArgs . remove ( <str> ) ; if ( params = = null ) return new SettingsTransport ( new TOptions ( ) ) ; GroupedOptions options = GroupedOptions . select ( params , new TOptions ( ) ) ; if ( options = = null ) { printHelp ( ) ; System . out . println ( <str> ) ; System . exit ( <int> ) ; } return new SettingsTransport ( ( TOptions ) options ) ; } public static void printHelp ( ) { GroupedOptions . printOptions ( System . out , <str> , new TOptions ( ) ) ; } public static Runnable helpPrinter ( ) { return new Runnable ( ) { @Override public void run ( ) { printHelp ( ) ; } } ; } } 
