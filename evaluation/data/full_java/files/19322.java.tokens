package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static java . lang . Math . min ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . channel . CoalescingBufferQueue ; import io . netty . handler . codec . http2 . Http2Exception . ClosedStreamCreationException ; import java . util . ArrayDeque ; public class DefaultHttp2ConnectionEncoder implements Http2ConnectionEncoder { private final Http2FrameWriter frameWriter ; private final Http2Connection connection ; private Http2LifecycleManager lifecycleManager ; private final ArrayDeque < Http2Settings > outstandingLocalSettingsQueue = new ArrayDeque < Http2Settings > ( <int> ) ; public DefaultHttp2ConnectionEncoder ( Http2Connection connection , Http2FrameWriter frameWriter ) { this . connection = checkNotNull ( connection , <str> ) ; this . frameWriter = checkNotNull ( frameWriter , <str> ) ; if ( connection . remote ( ) . flowController ( ) = = null ) { connection . remote ( ) . flowController ( new DefaultHttp2RemoteFlowController ( connection ) ) ; } } @Override public void lifecycleManager ( Http2LifecycleManager lifecycleManager ) { this . lifecycleManager = checkNotNull ( lifecycleManager , <str> ) ; } @Override public Http2FrameWriter frameWriter ( ) { return frameWriter ; } @Override public Http2Connection connection ( ) { return connection ; } @Override public final Http2RemoteFlowController flowController ( ) { return connection ( ) . remote ( ) . flowController ( ) ; } @Override public void remoteSettings ( Http2Settings settings ) throws Http2Exception { Boolean pushEnabled = settings . pushEnabled ( ) ; Http2FrameWriter . Configuration config = configuration ( ) ; Http2HeaderTable outboundHeaderTable = config . headerTable ( ) ; Http2FrameSizePolicy outboundFrameSizePolicy = config . frameSizePolicy ( ) ; if ( pushEnabled ! = null ) { if ( ! connection . isServer ( ) & & pushEnabled ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } connection . remote ( ) . allowPushTo ( pushEnabled ) ; } Long maxConcurrentStreams = settings . maxConcurrentStreams ( ) ; if ( maxConcurrentStreams ! = null ) { connection . local ( ) . maxActiveStreams ( ( int ) min ( maxConcurrentStreams , Integer . MAX_VALUE ) ) ; } Long headerTableSize = settings . headerTableSize ( ) ; if ( headerTableSize ! = null ) { outboundHeaderTable . maxHeaderTableSize ( ( int ) min ( headerTableSize , Integer . MAX_VALUE ) ) ; } Integer maxHeaderListSize = settings . maxHeaderListSize ( ) ; if ( maxHeaderListSize ! = null ) { outboundHeaderTable . maxHeaderListSize ( maxHeaderListSize ) ; } Integer maxFrameSize = settings . maxFrameSize ( ) ; if ( maxFrameSize ! = null ) { outboundFrameSizePolicy . maxFrameSize ( maxFrameSize ) ; } Integer initialWindowSize = settings . initialWindowSize ( ) ; if ( initialWindowSize ! = null ) { flowController ( ) . initialWindowSize ( initialWindowSize ) ; } } @Override public ChannelFuture writeData ( final ChannelHandlerContext ctx , final int streamId , ByteBuf data , int padding , final boolean endOfStream , ChannelPromise promise ) { final Http2Stream stream ; try { stream = requireStream ( streamId ) ; switch ( stream . state ( ) ) { case OPEN : case HALF_CLOSED_REMOTE : break ; default : throw new IllegalStateException ( String . format ( <str> , stream . id ( ) , stream . state ( ) ) ) ; } } catch ( Throwable e ) { data . release ( ) ; return promise . setFailure ( e ) ; } flowController ( ) . addFlowControlled ( stream , new FlowControlledData ( stream , data , padding , endOfStream , promise ) ) ; return promise ; } @Override public ChannelFuture writeHeaders ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream , ChannelPromise promise ) { return writeHeaders ( ctx , streamId , headers , <int> , DEFAULT_PRIORITY_WEIGHT , false , padding , endStream , promise ) ; } @Override public ChannelFuture writeHeaders ( final ChannelHandlerContext ctx , final int streamId , final Http2Headers headers , final int streamDependency , final short weight , final boolean exclusive , final int padding , final boolean endOfStream , final ChannelPromise promise ) { try { Http2Stream stream = connection . stream ( streamId ) ; if ( stream = = null ) { stream = connection . local ( ) . createStream ( streamId , endOfStream ) ; } else { switch ( stream . state ( ) ) { case RESERVED_LOCAL : stream . open ( endOfStream ) ; break ; case OPEN : case HALF_CLOSED_REMOTE : break ; default : throw new IllegalStateException ( String . format ( <str> , stream . id ( ) , stream . state ( ) ) ) ; } } flowController ( ) . addFlowControlled ( stream , new FlowControlledHeaders ( stream , headers , streamDependency , weight , exclusive , padding , endOfStream , promise ) ) ; return promise ; } catch ( Http2NoMoreStreamIdsException e ) { lifecycleManager . onError ( ctx , e ) ; return promise . setFailure ( e ) ; } catch ( Throwable e ) { return promise . setFailure ( e ) ; } } @Override public ChannelFuture writePriority ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive , ChannelPromise promise ) { try { Http2Stream stream = connection . stream ( streamId ) ; if ( stream = = null ) { stream = connection . local ( ) . createIdleStream ( streamId ) ; } stream . setPriority ( streamDependency , weight , exclusive ) ; } catch ( ClosedStreamCreationException ignored ) { } catch ( Throwable t ) { return promise . setFailure ( t ) ; } return frameWriter . writePriority ( ctx , streamId , streamDependency , weight , exclusive , promise ) ; } @Override public ChannelFuture writeRstStream ( ChannelHandlerContext ctx , int streamId , long errorCode , ChannelPromise promise ) { return lifecycleManager . resetStream ( ctx , streamId , errorCode , promise ) ; } @Override public ChannelFuture writeSettings ( ChannelHandlerContext ctx , Http2Settings settings , ChannelPromise promise ) { outstandingLocalSettingsQueue . add ( settings ) ; try { Boolean pushEnabled = settings . pushEnabled ( ) ; if ( pushEnabled ! = null & & connection . isServer ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } } catch ( Throwable e ) { return promise . setFailure ( e ) ; } return frameWriter . writeSettings ( ctx , settings , promise ) ; } @Override public ChannelFuture writeSettingsAck ( ChannelHandlerContext ctx , ChannelPromise promise ) { return frameWriter . writeSettingsAck ( ctx , promise ) ; } @Override public ChannelFuture writePing ( ChannelHandlerContext ctx , boolean ack , ByteBuf data , ChannelPromise promise ) { return frameWriter . writePing ( ctx , ack , data , promise ) ; } @Override public ChannelFuture writePushPromise ( ChannelHandlerContext ctx , int streamId , int promisedStreamId , Http2Headers headers , int padding , ChannelPromise promise ) { try { if ( connection . goAwayReceived ( ) ) { throw connectionError ( PROTOCOL_ERROR , <str> ) ; } Http2Stream stream = requireStream ( streamId ) ; connection . local ( ) . reservePushStream ( promisedStreamId , stream ) ; } catch ( Throwable e ) { return promise . setFailure ( e ) ; } return frameWriter . writePushPromise ( ctx , streamId , promisedStreamId , headers , padding , promise ) ; } @Override public ChannelFuture writeGoAway ( ChannelHandlerContext ctx , int lastStreamId , long errorCode , ByteBuf debugData , ChannelPromise promise ) { return lifecycleManager . goAway ( ctx , lastStreamId , errorCode , debugData , promise ) ; } @Override public ChannelFuture writeWindowUpdate ( ChannelHandlerContext ctx , int streamId , int windowSizeIncrement , ChannelPromise promise ) { return promise . setFailure ( new UnsupportedOperationException ( <str> + <str> ) ) ; } @Override public ChannelFuture writeFrame ( ChannelHandlerContext ctx , byte frameType , int streamId , Http2Flags flags , ByteBuf payload , ChannelPromise promise ) { return frameWriter . writeFrame ( ctx , frameType , streamId , flags , payload , promise ) ; } @Override public void close ( ) { frameWriter . close ( ) ; } @Override public Http2Settings pollSentSettings ( ) { return outstandingLocalSettingsQueue . poll ( ) ; } @Override public Configuration configuration ( ) { return frameWriter . configuration ( ) ; } private Http2Stream requireStream ( int streamId ) { Http2Stream stream = connection . stream ( streamId ) ; if ( stream = = null ) { final String message ; if ( connection . streamMayHaveExisted ( streamId ) ) { message = <str> + streamId ; } else { message = <str> + streamId ; } throw new IllegalArgumentException ( message ) ; } return stream ; } private final class FlowControlledData extends FlowControlledBase { private final CoalescingBufferQueue queue ; public FlowControlledData ( Http2Stream stream , ByteBuf buf , int padding , boolean endOfStream , ChannelPromise promise ) { super ( stream , padding , endOfStream , promise ) ; queue = new CoalescingBufferQueue ( promise . channel ( ) ) ; queue . add ( buf , promise ) ; } @Override public int size ( ) { return queue . readableBytes ( ) + padding ; } @Override public void error ( ChannelHandlerContext ctx , Throwable cause ) { queue . releaseAndFailAll ( cause ) ; lifecycleManager . onError ( ctx , cause ) ; promise . tryFailure ( cause ) ; } @Override public void write ( ChannelHandlerContext ctx , int allowedBytes ) { int queuedData = queue . readableBytes ( ) ; if ( ! endOfStream & & ( queuedData = = <int> | | allowedBytes = = <int> ) ) { return ; } int writeableData = min ( queuedData , allowedBytes ) ; ChannelPromise writePromise = ctx . newPromise ( ) . addListener ( this ) ; ByteBuf toWrite = queue . remove ( writeableData , writePromise ) ; int writeablePadding = min ( allowedBytes - writeableData , padding ) ; padding - = writeablePadding ; frameWriter ( ) . writeData ( ctx , stream . id ( ) , toWrite , writeablePadding , endOfStream & & size ( ) = = <int> , writePromise ) ; } @Override public boolean merge ( ChannelHandlerContext ctx , Http2RemoteFlowController . FlowControlled next ) { if ( FlowControlledData . class ! = next . getClass ( ) ) { return false ; } FlowControlledData nextData = ( FlowControlledData ) next ; nextData . queue . copyTo ( queue ) ; padding = Math . max ( padding , nextData . padding ) ; endOfStream = nextData . endOfStream ; return true ; } } private final class FlowControlledHeaders extends FlowControlledBase { private final Http2Headers headers ; private final int streamDependency ; private final short weight ; private final boolean exclusive ; public FlowControlledHeaders ( Http2Stream stream , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endOfStream , ChannelPromise promise ) { super ( stream , padding , endOfStream , promise ) ; this . headers = headers ; this . streamDependency = streamDependency ; this . weight = weight ; this . exclusive = exclusive ; } @Override public int size ( ) { return <int> ; } @Override public void error ( ChannelHandlerContext ctx , Throwable cause ) { if ( ctx ! = null ) { lifecycleManager . onError ( ctx , cause ) ; } promise . tryFailure ( cause ) ; } @Override public void write ( ChannelHandlerContext ctx , int allowedBytes ) { if ( promise . isVoid ( ) ) { promise = ctx . newPromise ( ) ; } promise . addListener ( this ) ; stream . headerSent ( ) ; frameWriter . writeHeaders ( ctx , stream . id ( ) , headers , streamDependency , weight , exclusive , padding , endOfStream , promise ) ; } @Override public boolean merge ( ChannelHandlerContext ctx , Http2RemoteFlowController . FlowControlled next ) { return false ; } } public abstract class FlowControlledBase implements Http2RemoteFlowController . FlowControlled , ChannelFutureListener { protected final Http2Stream stream ; protected ChannelPromise promise ; protected boolean endOfStream ; protected int padding ; public FlowControlledBase ( final Http2Stream stream , int padding , boolean endOfStream , final ChannelPromise promise ) { if ( padding < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . padding = padding ; this . endOfStream = endOfStream ; this . stream = stream ; this . promise = promise ; } @Override public void writeComplete ( ) { if ( endOfStream ) { lifecycleManager . closeStreamLocal ( stream , promise ) ; } } @Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( ! future . isSuccess ( ) ) { error ( flowController ( ) . channelHandlerContext ( ) , future . cause ( ) ) ; } } } } 
