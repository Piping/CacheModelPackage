package org . apache . cassandra . db . lifecycle ; import java . io . File ; import java . io . IOException ; import java . nio . file . DirectoryStream ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . * ; import java . util . function . BiFunction ; import java . util . stream . Collectors ; import java . util . stream . Stream ; import java . util . stream . StreamSupport ; import com . google . common . annotations . VisibleForTesting ; import org . apache . cassandra . db . Directories ; import static org . apache . cassandra . db . Directories . * ; final class LogAwareFileLister { private final Path folder ; private final BiFunction < File , FileType , Boolean > filter ; private final OnTxnErr onTxnErr ; NavigableMap < File , Directories . FileType > files = new TreeMap < > ( ) ; @VisibleForTesting LogAwareFileLister ( Path folder , BiFunction < File , FileType , Boolean > filter , OnTxnErr onTxnErr ) { this . folder = folder ; this . filter = filter ; this . onTxnErr = onTxnErr ; } public List < File > list ( ) { try { return innerList ( ) ; } catch ( Throwable t ) { throw new RuntimeException ( String . format ( <str> , folder ) , t ) ; } } List < File > innerList ( ) throws Throwable { list ( Files . newDirectoryStream ( folder ) ) . stream ( ) . filter ( ( f ) - > ! LogFile . isLogFile ( f ) ) . forEach ( ( f ) - > files . put ( f , FileType . FINAL ) ) ; list ( Files . newDirectoryStream ( folder , <str> + LogFile . EXT ) ) . stream ( ) . filter ( LogFile : : isLogFile ) . forEach ( this : : classifyFiles ) ; return files . entrySet ( ) . stream ( ) . filter ( ( e ) - > filter . apply ( e . getKey ( ) , e . getValue ( ) ) ) . map ( Map . Entry : : getKey ) . collect ( Collectors . toList ( ) ) ; } static List < File > list ( DirectoryStream < Path > stream ) throws IOException { try { return StreamSupport . stream ( stream . spliterator ( ) , false ) . map ( Path : : toFile ) . filter ( ( f ) - > ! f . isDirectory ( ) ) . collect ( Collectors . toList ( ) ) ; } finally { stream . close ( ) ; } } void classifyFiles ( File txnFile ) { LogFile txn = LogFile . make ( txnFile ) ; readTxnLog ( txn ) ; classifyFiles ( txn ) ; files . put ( txnFile , FileType . TXN_LOG ) ; } void readTxnLog ( LogFile txn ) { if ( ! txn . verify ( ) & & onTxnErr = = OnTxnErr . THROW ) throw new LogTransaction . CorruptTransactionLogException ( <str> , txn ) ; } void classifyFiles ( LogFile txnFile ) { Map < LogRecord , Set < File > > oldFiles = txnFile . getFilesOfType ( files . navigableKeySet ( ) , LogRecord . Type . REMOVE ) ; Map < LogRecord , Set < File > > newFiles = txnFile . getFilesOfType ( files . navigableKeySet ( ) , LogRecord . Type . ADD ) ; if ( txnFile . completed ( ) ) { setTemporary ( txnFile , oldFiles . values ( ) , newFiles . values ( ) ) ; return ; } if ( allFilesPresent ( txnFile , oldFiles , newFiles ) ) { setTemporary ( txnFile , oldFiles . values ( ) , newFiles . values ( ) ) ; return ; } if ( ! txnFile . exists ( ) ) return ; readTxnLog ( txnFile ) ; if ( txnFile . completed ( ) ) { setTemporary ( txnFile , oldFiles . values ( ) , newFiles . values ( ) ) ; return ; } throw new RuntimeException ( String . format ( <str> , folder , txnFile ) ) ; } private static boolean allFilesPresent ( LogFile txnFile , Map < LogRecord , Set < File > > oldFiles , Map < LogRecord , Set < File > > newFiles ) { LogRecord lastRecord = txnFile . getLastRecord ( ) ; return ! Stream . concat ( oldFiles . entrySet ( ) . stream ( ) , newFiles . entrySet ( ) . stream ( ) . filter ( ( e ) - > e . getKey ( ) ! = lastRecord ) ) . filter ( ( e ) - > e . getKey ( ) . numFiles > e . getValue ( ) . size ( ) ) . findFirst ( ) . isPresent ( ) ; } private void setTemporary ( LogFile txnFile , Collection < Set < File > > oldFiles , Collection < Set < File > > newFiles ) { Collection < Set < File > > temporary = txnFile . committed ( ) ? oldFiles : newFiles ; temporary . stream ( ) . flatMap ( Set : : stream ) . forEach ( ( f ) - > this . files . put ( f , FileType . TEMPORARY ) ) ; } @VisibleForTesting static Set < File > getTemporaryFiles ( File folder ) { return listFiles ( folder , FileType . TEMPORARY ) ; } @VisibleForTesting static Set < File > getFinalFiles ( File folder ) { return listFiles ( folder , FileType . FINAL ) ; } @VisibleForTesting static Set < File > listFiles ( File folder , FileType . . . types ) { Collection < FileType > match = Arrays . asList ( types ) ; return new LogAwareFileLister ( folder . toPath ( ) , ( file , type ) - > match . contains ( type ) , OnTxnErr . IGNORE ) . list ( ) . stream ( ) . collect ( Collectors . toSet ( ) ) ; } } 
