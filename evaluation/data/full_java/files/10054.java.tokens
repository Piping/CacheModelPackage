package com . google . common . collect . testing . testers ; import static com . google . common . collect . testing . features . CollectionFeature . ALLOWS_NULL_VALUES ; import static com . google . common . collect . testing . features . CollectionFeature . SUPPORTS_REMOVE ; import static com . google . common . collect . testing . features . CollectionSize . ONE ; import static com . google . common . collect . testing . features . CollectionSize . ZERO ; import com . google . common . annotations . GwtCompatible ; import com . google . common . collect . testing . AbstractCollectionTester ; import com . google . common . collect . testing . MinimalCollection ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; @SuppressWarnings ( <str> ) @GwtCompatible public class CollectionRetainAllTester < E > extends AbstractCollectionTester < E > { private class Target { private final Collection < E > toRetain ; private final String description ; private Target ( Collection < E > toRetain , String description ) { this . toRetain = toRetain ; this . description = description ; } @Override public String toString ( ) { return description ; } } private Target empty ; private Target disjoint ; private Target superset ; private Target nonEmptyProperSubset ; private Target sameElements ; private Target partialOverlap ; private Target containsDuplicates ; private Target nullSingleton ; @Override public void setUp ( ) throws Exception { super . setUp ( ) ; empty = new Target ( emptyCollection ( ) , <str> ) ; List < E > disjointList = Arrays . asList ( e3 ( ) , e4 ( ) ) ; disjoint = new Target ( disjointList , <str> ) ; superset = new Target ( MinimalCollection . of ( e0 ( ) , e1 ( ) , e2 ( ) , e3 ( ) , e4 ( ) ) , <str> ) ; nonEmptyProperSubset = new Target ( MinimalCollection . of ( e1 ( ) ) , <str> ) ; sameElements = new Target ( Arrays . asList ( createSamplesArray ( ) ) , <str> ) ; containsDuplicates = new Target ( MinimalCollection . of ( e0 ( ) , e0 ( ) , e3 ( ) , e3 ( ) ) , <str> ) ; partialOverlap = new Target ( MinimalCollection . of ( e2 ( ) , e3 ( ) ) , <str> ) ; nullSingleton = new Target ( Collections . < E > singleton ( null ) , <str> ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testRetainAll_emptyPreviouslyEmpty ( ) { expectReturnsFalse ( empty ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testRetainAll_emptyPreviouslyEmptyUnsupported ( ) { expectReturnsFalseOrThrows ( empty ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRetainAll_emptyPreviouslyNonEmpty ( ) { expectReturnsTrue ( empty ) ; expectContents ( ) ; expectMissing ( e0 ( ) , e1 ( ) , e2 ( ) ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRetainAll_emptyPreviouslyNonEmptyUnsupported ( ) { expectThrows ( empty ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testRetainAll_disjointPreviouslyEmpty ( ) { expectReturnsFalse ( disjoint ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testRetainAll_disjointPreviouslyEmptyUnsupported ( ) { expectReturnsFalseOrThrows ( disjoint ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRetainAll_disjointPreviouslyNonEmpty ( ) { expectReturnsTrue ( disjoint ) ; expectContents ( ) ; expectMissing ( e0 ( ) , e1 ( ) , e2 ( ) ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRetainAll_disjointPreviouslyNonEmptyUnsupported ( ) { expectThrows ( disjoint ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) public void testRetainAll_superset ( ) { expectReturnsFalse ( superset ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) public void testRetainAll_supersetUnsupported ( ) { expectReturnsFalseOrThrows ( superset ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = { ZERO , ONE } ) public void testRetainAll_subset ( ) { expectReturnsTrue ( nonEmptyProperSubset ) ; expectContents ( nonEmptyProperSubset . toRetain ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = { ZERO , ONE } ) public void testRetainAll_subsetUnsupported ( ) { expectThrows ( nonEmptyProperSubset ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) public void testRetainAll_sameElements ( ) { expectReturnsFalse ( sameElements ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) public void testRetainAll_sameElementsUnsupported ( ) { expectReturnsFalseOrThrows ( sameElements ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = { ZERO , ONE } ) public void testRetainAll_partialOverlap ( ) { expectReturnsTrue ( partialOverlap ) ; expectContents ( e2 ( ) ) ; } @CollectionFeature.Require ( absent = SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = { ZERO , ONE } ) public void testRetainAll_partialOverlapUnsupported ( ) { expectThrows ( partialOverlap ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ONE ) public void testRetainAll_containsDuplicatesSizeOne ( ) { expectReturnsFalse ( containsDuplicates ) ; expectContents ( e0 ( ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = { ZERO , ONE } ) public void testRetainAll_containsDuplicatesSizeSeveral ( ) { expectReturnsTrue ( containsDuplicates ) ; expectContents ( e0 ( ) ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testRetainAll_nullSingletonPreviouslyEmpty ( ) { expectReturnsFalse ( nullSingleton ) ; expectUnchanged ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRetainAll_nullSingletonPreviouslyNonEmpty ( ) { expectReturnsTrue ( nullSingleton ) ; expectContents ( ) ; } @CollectionFeature.Require ( { SUPPORTS_REMOVE , ALLOWS_NULL_VALUES } ) @CollectionSize.Require ( ONE ) public void testRetainAll_nullSingletonPreviouslySingletonWithNull ( ) { initCollectionWithNullElement ( ) ; expectReturnsFalse ( nullSingleton ) ; expectContents ( createArrayWithNullElement ( ) ) ; } @CollectionFeature.Require ( { SUPPORTS_REMOVE , ALLOWS_NULL_VALUES } ) @CollectionSize.Require ( absent = { ZERO , ONE } ) public void testRetainAll_nullSingletonPreviouslySeveralWithNull ( ) { initCollectionWithNullElement ( ) ; expectReturnsTrue ( nullSingleton ) ; expectContents ( nullSingleton . toRetain ) ; } @CollectionFeature.Require ( { SUPPORTS_REMOVE , ALLOWS_NULL_VALUES } ) @CollectionSize.Require ( absent = ZERO ) public void testRetainAll_containsNonNullWithNull ( ) { initCollectionWithNullElement ( ) ; expectReturnsTrue ( disjoint ) ; expectContents ( ) ; } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( ZERO ) public void testRetainAll_nullCollectionReferenceEmptySubject ( ) { try { collection . retainAll ( null ) ; } catch ( NullPointerException expected ) { } } @CollectionFeature.Require ( SUPPORTS_REMOVE ) @CollectionSize.Require ( absent = ZERO ) public void testRetainAll_nullCollectionReferenceNonEmptySubject ( ) { try { collection . retainAll ( null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } private void expectReturnsTrue ( Target target ) { String message = Platform . format ( <str> , target ) ; assertTrue ( message , collection . retainAll ( target . toRetain ) ) ; } private void expectReturnsFalse ( Target target ) { String message = Platform . format ( <str> , target ) ; assertFalse ( message , collection . retainAll ( target . toRetain ) ) ; } private void expectThrows ( Target target ) { try { collection . retainAll ( target . toRetain ) ; String message = Platform . format ( <str> , target ) ; fail ( message ) ; } catch ( UnsupportedOperationException expected ) { } } private void expectReturnsFalseOrThrows ( Target target ) { String message = Platform . format ( <str> , target ) ; try { assertFalse ( message , collection . retainAll ( target . toRetain ) ) ; } catch ( UnsupportedOperationException tolerated ) { } } } 
