package org . gradle . api . plugins . jetty ; import org . gradle . api . GradleException ; import org . gradle . api . internal . ConventionTask ; import org . gradle . api . plugins . jetty . internal . ConsoleScanner ; import org . gradle . api . plugins . jetty . internal . JettyPluginServer ; import org . gradle . api . plugins . jetty . internal . JettyPluginWebAppContext ; import org . gradle . api . plugins . jetty . internal . Monitor ; import org . gradle . api . tasks . InputFile ; import org . gradle . api . tasks . InputFiles ; import org . gradle . api . tasks . Optional ; import org . gradle . api . tasks . TaskAction ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . logging . ProgressLogger ; import org . gradle . logging . ProgressLoggerFactory ; import org . mortbay . jetty . Connector ; import org . mortbay . jetty . RequestLog ; import org . mortbay . jetty . Server ; import org . mortbay . jetty . security . UserRealm ; import org . mortbay . util . Scanner ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . net . URLClassLoader ; import java . util . * ; public abstract class AbstractJettyRunTask extends ConventionTask { private static Logger logger = LoggerFactory . getLogger ( AbstractJettyRunTask . class ) ; private Iterable < File > additionalRuntimeJars = new ArrayList < File > ( ) ; private JettyPluginServer server ; private JettyPluginWebAppContext webAppConfig ; private String contextPath ; private File webDefaultXml ; private File overrideWebXml ; private int scanIntervalSeconds ; protected String reload ; private File jettyConfig ; private Integer stopPort ; private String stopKey ; private boolean daemon ; private Integer httpPort ; private Connector [ ] connectors ; private UserRealm [ ] userRealms ; private RequestLog requestLog ; private Scanner scanner = new Scanner ( ) ; protected List < Scanner . Listener > scannerListeners ; protected Thread consoleScanner ; public static final String PORT_SYSPROPERTY = <str> ; public abstract void validateConfiguration ( ) ; public abstract void configureScanner ( ) ; public abstract void applyJettyXml ( ) throws Exception ; public abstract JettyPluginServer createServer ( ) throws Exception ; public abstract void finishConfigurationBeforeStart ( ) throws Exception ; @TaskAction protected void start ( ) { ClassLoader originalClassloader = Server . class . getClassLoader ( ) ; List < File > additionalClasspath = new ArrayList < File > ( ) ; for ( File additionalRuntimeJar : getAdditionalRuntimeJars ( ) ) { additionalClasspath . add ( additionalRuntimeJar ) ; } URLClassLoader jettyClassloader = new URLClassLoader ( new DefaultClassPath ( additionalClasspath ) . getAsURLArray ( ) , originalClassloader ) ; try { Thread . currentThread ( ) . setContextClassLoader ( jettyClassloader ) ; startJetty ( ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( originalClassloader ) ; } } public JettyPluginServer getServer ( ) { return this . server ; } public void setServer ( JettyPluginServer server ) { this . server = server ; } public void setScannerListeners ( List < Scanner . Listener > listeners ) { this . scannerListeners = new ArrayList < Scanner . Listener > ( listeners ) ; } public List < Scanner . Listener > getScannerListeners ( ) { return this . scannerListeners ; } public Scanner getScanner ( ) { return scanner ; } public void startJetty ( ) { logger . info ( <str> + getProject ( ) ) ; validateConfiguration ( ) ; startJettyInternal ( ) ; } public void startJettyInternal ( ) { ProgressLoggerFactory progressLoggerFactory = getServices ( ) . get ( ProgressLoggerFactory . class ) ; ProgressLogger progressLogger = progressLoggerFactory . newOperation ( AbstractJettyRunTask . class ) . start ( <str> , <str> ) ; try { setServer ( createServer ( ) ) ; applyJettyXml ( ) ; JettyPluginServer plugin = getServer ( ) ; Object [ ] configuredConnectors = getConnectors ( ) ; plugin . setConnectors ( configuredConnectors ) ; Object [ ] connectors = plugin . getConnectors ( ) ; if ( connectors = = null | | connectors . length = = <int> ) { configuredConnectors = new Object [ ] { plugin . createDefaultConnector ( getHttpPort ( ) ) } ; plugin . setConnectors ( configuredConnectors ) ; } if ( getRequestLog ( ) ! = null ) { getServer ( ) . setRequestLog ( getRequestLog ( ) ) ; } getServer ( ) . configureHandlers ( ) ; configureWebApplication ( ) ; getServer ( ) . addWebApplication ( webAppConfig ) ; Object [ ] configuredRealms = getUserRealms ( ) ; for ( int i = <int> ; ( configuredRealms ! = null ) & & i < configuredRealms . length ; i + + ) { logger . debug ( configuredRealms [ i ] . getClass ( ) . getName ( ) + <str> + configuredRealms [ i ] . toString ( ) ) ; } plugin . setUserRealms ( configuredRealms ) ; finishConfigurationBeforeStart ( ) ; server . start ( ) ; if ( daemon ) { return ; } if ( getStopPort ( ) ! = null & & getStopPort ( ) > <int> & & getStopKey ( ) ! = null ) { Monitor monitor = new Monitor ( getStopPort ( ) , getStopKey ( ) , ( Server ) server . getProxiedObject ( ) ) ; monitor . start ( ) ; } configureScanner ( ) ; startScanner ( ) ; startConsoleScanner ( ) ; } catch ( Exception e ) { throw new GradleException ( <str> , e ) ; } finally { progressLogger . completed ( ) ; } progressLogger = progressLoggerFactory . newOperation ( AbstractJettyRunTask . class ) . start ( String . format ( <str> , getHttpPort ( ) , getContextPath ( ) ) , String . format ( <str> , getHttpPort ( ) , getContextPath ( ) ) ) ; try { server . join ( ) ; } catch ( Exception e ) { throw new GradleException ( <str> , e ) ; } finally { progressLogger . completed ( ) ; } } public abstract void restartWebApp ( boolean reconfigureScanner ) throws Exception ; public void configureWebApplication ( ) throws Exception { if ( webAppConfig = = null ) { webAppConfig = new JettyPluginWebAppContext ( ) ; } webAppConfig . setContextPath ( getContextPath ( ) . startsWith ( <str> ) ? getContextPath ( ) : <str> + getContextPath ( ) ) ; if ( getTemporaryDir ( ) ! = null ) { webAppConfig . setTempDirectory ( getTemporaryDir ( ) ) ; } if ( getWebDefaultXml ( ) ! = null ) { webAppConfig . setDefaultsDescriptor ( getWebDefaultXml ( ) . getCanonicalPath ( ) ) ; } if ( getOverrideWebXml ( ) ! = null ) { webAppConfig . setOverrideDescriptor ( getOverrideWebXml ( ) . getCanonicalPath ( ) ) ; } Set < String > systemClasses = new LinkedHashSet < String > ( Arrays . asList ( webAppConfig . getSystemClasses ( ) ) ) ; systemClasses . remove ( <str> ) ; systemClasses . remove ( <str> ) ; webAppConfig . setSystemClasses ( systemClasses . toArray ( new String [ systemClasses . size ( ) ] ) ) ; webAppConfig . setParentLoaderPriority ( false ) ; logger . info ( <str> + webAppConfig . getContextPath ( ) ) ; logger . info ( <str> + <str> ) ; logger . info ( <str> + ( webAppConfig . getDefaultsDescriptor ( ) = = null ? <str> : webAppConfig . getDefaultsDescriptor ( ) ) ) ; logger . info ( <str> + ( webAppConfig . getOverrideDescriptor ( ) = = null ? <str> : webAppConfig . getOverrideDescriptor ( ) ) ) ; } private void startScanner ( ) { if ( getScanIntervalSeconds ( ) < = <int> ) { return ; } if ( <str> . equalsIgnoreCase ( reload ) ) { logger . warn ( <str> + scanIntervalSeconds + <str> ) ; return ; } scanner . setReportExistingFilesOnStartup ( false ) ; scanner . setScanInterval ( getScanIntervalSeconds ( ) ) ; scanner . setRecursive ( true ) ; List listeners = getScannerListeners ( ) ; Iterator itor = listeners = = null ? null : listeners . iterator ( ) ; while ( itor ! = null & & itor . hasNext ( ) ) { scanner . addListener ( ( Scanner . Listener ) itor . next ( ) ) ; } logger . info ( <str> + getScanIntervalSeconds ( ) + <str> ) ; scanner . start ( ) ; } protected void startConsoleScanner ( ) { if ( <str> . equalsIgnoreCase ( reload ) ) { logger . info ( <str> ) ; consoleScanner = new ConsoleScanner ( this ) ; consoleScanner . start ( ) ; } } public File findJettyWebXmlFile ( File webInfDir ) { if ( webInfDir = = null ) { return null ; } if ( ! webInfDir . exists ( ) ) { return null ; } File f = new File ( webInfDir , <str> ) ; if ( f . exists ( ) ) { return f ; } f = new File ( webInfDir , <str> ) ; if ( f . exists ( ) ) { return f ; } f = new File ( webInfDir , <str> ) ; if ( f . exists ( ) ) { return f ; } return null ; } @InputFile @Optional public File getWebDefaultXml ( ) { return webDefaultXml ; } public void setWebDefaultXml ( File webDefaultXml ) { this . webDefaultXml = webDefaultXml ; } @InputFile @Optional public File getOverrideWebXml ( ) { return overrideWebXml ; } public void setOverrideWebXml ( File overrideWebXml ) { this . overrideWebXml = overrideWebXml ; } public int getScanIntervalSeconds ( ) { return scanIntervalSeconds ; } public void setScanIntervalSeconds ( int scanIntervalSeconds ) { this . scanIntervalSeconds = scanIntervalSeconds ; } public String getContextPath ( ) { return contextPath ; } public void setContextPath ( String contextPath ) { this . contextPath = contextPath ; } public JettyPluginWebAppContext getWebAppConfig ( ) { return webAppConfig ; } public void setWebAppConfig ( JettyPluginWebAppContext webAppConfig ) { this . webAppConfig = webAppConfig ; } public String getReload ( ) { return reload ; } public void setReload ( String reload ) { this . reload = reload ; } @InputFile @Optional public File getJettyConfig ( ) { return jettyConfig ; } public void setJettyConfig ( File jettyConfig ) { this . jettyConfig = jettyConfig ; } public Integer getStopPort ( ) { return stopPort ; } public void setStopPort ( Integer stopPort ) { this . stopPort = stopPort ; } public String getStopKey ( ) { return stopKey ; } public void setStopKey ( String stopKey ) { this . stopKey = stopKey ; } public boolean isDaemon ( ) { return daemon ; } public void setDaemon ( boolean daemon ) { this . daemon = daemon ; } public Integer getHttpPort ( ) { return httpPort ; } public void setHttpPort ( Integer httpPort ) { this . httpPort = httpPort ; } public Connector [ ] getConnectors ( ) { return connectors ; } public void setConnectors ( Connector [ ] connectors ) { this . connectors = connectors ; } public UserRealm [ ] getUserRealms ( ) { return userRealms ; } public void setUserRealms ( UserRealm [ ] userRealms ) { this . userRealms = userRealms ; } public RequestLog getRequestLog ( ) { return requestLog ; } public void setRequestLog ( RequestLog requestLog ) { this . requestLog = requestLog ; } @InputFiles public Iterable < File > getAdditionalRuntimeJars ( ) { return additionalRuntimeJars ; } public void setAdditionalRuntimeJars ( Iterable < File > additionalRuntimeJars ) { this . additionalRuntimeJars = additionalRuntimeJars ; } } 
