package io . netty . handler . codec ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . embedded . EmbeddedChannel ; import org . junit . Test ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingDeque ; import static io . netty . util . ReferenceCountUtil . * ; import static org . junit . Assert . * ; public class ReplayingDecoderTest { @Test public void testLineProtocol ( ) { EmbeddedChannel ch = new EmbeddedChannel ( new LineDecoder ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; assertEquals ( Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> } ) , ch . readInbound ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . finish ( ) ; assertNull ( ch . readInbound ( ) ) ; } private static final class LineDecoder extends ReplayingDecoder < Void > { LineDecoder ( ) { } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) { ByteBuf msg = in . readBytes ( in . bytesBefore ( ( byte ) <str> ) ) ; out . add ( msg ) ; in . skipBytes ( <int> ) ; } } @Test public void testReplacement ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new BloatedLineDecoder ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> } ) ) ; assertNull ( ch . readInbound ( ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> } ) ) ; assertEquals ( releaseLater ( Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> } ) ) , releaseLater ( ch . readInbound ( ) ) ) ; ch . finish ( ) ; assertNull ( ch . readInbound ( ) ) ; } private static final class BloatedLineDecoder extends ChannelInboundHandlerAdapter { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { ctx . pipeline ( ) . replace ( this , <str> , new LineDecoder ( ) ) ; ctx . pipeline ( ) . fireChannelRead ( msg ) ; } } @Test public void testSingleDecode ( ) throws Exception { LineDecoder decoder = new LineDecoder ( ) ; decoder . setSingleDecode ( true ) ; EmbeddedChannel ch = new EmbeddedChannel ( decoder ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> , <str> } ) ) ; assertEquals ( releaseLater ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) , releaseLater ( ch . readInbound ( ) ) ) ; assertNull ( <str> , ch . readInbound ( ) ) ; ch . read ( ) ; ch . finish ( ) ; assertEquals ( releaseLater ( Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) , releaseLater ( ch . readInbound ( ) ) ) ; assertNull ( ch . readInbound ( ) ) ; } @Test public void testRemoveItself ( ) { EmbeddedChannel channel = new EmbeddedChannel ( new ReplayingDecoder ( ) { private boolean removed ; @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { assertFalse ( removed ) ; in . readByte ( ) ; ctx . pipeline ( ) . remove ( this ) ; removed = true ; } } ) ; ByteBuf buf = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> } ) ; channel . writeInbound ( buf . copy ( ) ) ; ByteBuf b = channel . readInbound ( ) ; assertEquals ( b , buf . skipBytes ( <int> ) ) ; b . release ( ) ; buf . release ( ) ; } @Test public void testRemoveItselfWithReplayError ( ) { EmbeddedChannel channel = new EmbeddedChannel ( new ReplayingDecoder ( ) { private boolean removed ; @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { assertFalse ( removed ) ; ctx . pipeline ( ) . remove ( this ) ; in . readBytes ( <int> ) ; removed = true ; } } ) ; ByteBuf buf = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> } ) ; channel . writeInbound ( buf . copy ( ) ) ; ByteBuf b = channel . readInbound ( ) ; assertEquals ( <str> , b , buf ) ; b . release ( ) ; buf . release ( ) ; } @Test public void testRemoveItselfWriteBuffer ( ) { final ByteBuf buf = Unpooled . buffer ( ) . writeBytes ( new byte [ ] { <str> , <str> , <str> } ) ; EmbeddedChannel channel = new EmbeddedChannel ( new ReplayingDecoder ( ) { private boolean removed ; @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { assertFalse ( removed ) ; in . readByte ( ) ; ctx . pipeline ( ) . remove ( this ) ; buf . writeByte ( <str> ) ; removed = true ; } } ) ; channel . writeInbound ( buf . copy ( ) ) ; ByteBuf b = channel . readInbound ( ) ; assertEquals ( b , Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> } ) ) ; b . release ( ) ; buf . release ( ) ; } @Test public void testFireChannelReadCompleteOnInactive ( ) throws InterruptedException { final BlockingQueue < Integer > queue = new LinkedBlockingDeque < Integer > ( ) ; final ByteBuf buf = releaseLater ( Unpooled . buffer ( ) . writeBytes ( new byte [ ] { <str> , <str> } ) ) ; EmbeddedChannel channel = new EmbeddedChannel ( new ReplayingDecoder < Integer > ( ) { @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { in . skipBytes ( in . readableBytes ( ) ) ; if ( ! ctx . channel ( ) . isActive ( ) ) { out . add ( <str> ) ; } } } , new ChannelInboundHandlerAdapter ( ) { @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { queue . add ( <int> ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { queue . add ( <int> ) ; } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { if ( ! ctx . channel ( ) . isActive ( ) ) { queue . add ( <int> ) ; } } } ) ; assertFalse ( channel . writeInbound ( buf ) ) ; channel . finish ( ) ; assertEquals ( <int> , ( int ) queue . take ( ) ) ; assertEquals ( <int> , ( int ) queue . take ( ) ) ; assertEquals ( <int> , ( int ) queue . take ( ) ) ; assertEquals ( <int> , ( int ) queue . take ( ) ) ; assertTrue ( queue . isEmpty ( ) ) ; } } 
