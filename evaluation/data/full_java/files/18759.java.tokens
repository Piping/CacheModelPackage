package io . netty . buffer ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . RecyclableArrayList ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . ReadOnlyBufferException ; import java . nio . channels . GatheringByteChannel ; import java . nio . channels . ScatteringByteChannel ; import java . util . Collections ; final class FixedCompositeByteBuf extends AbstractReferenceCountedByteBuf { private static final ByteBuf [ ] EMPTY = { Unpooled . EMPTY_BUFFER } ; private final int nioBufferCount ; private final int capacity ; private final ByteBufAllocator allocator ; private final ByteOrder order ; private final Object [ ] buffers ; private final boolean direct ; FixedCompositeByteBuf ( ByteBufAllocator allocator , ByteBuf . . . buffers ) { super ( Integer . MAX_VALUE ) ; if ( buffers . length = = <int> ) { this . buffers = EMPTY ; order = ByteOrder . BIG_ENDIAN ; nioBufferCount = <int> ; capacity = <int> ; direct = buffers [ <int> ] . isDirect ( ) ; } else { ByteBuf b = buffers [ <int> ] ; this . buffers = new Object [ buffers . length ] ; this . buffers [ <int> ] = b ; boolean direct = true ; int nioBufferCount = b . nioBufferCount ( ) ; int capacity = b . readableBytes ( ) ; order = b . order ( ) ; for ( int i = <int> ; i < buffers . length ; i + + ) { b = buffers [ i ] ; if ( buffers [ i ] . order ( ) ! = order ) { throw new IllegalArgumentException ( <str> ) ; } nioBufferCount + = b . nioBufferCount ( ) ; capacity + = b . readableBytes ( ) ; if ( ! b . isDirect ( ) ) { direct = false ; } this . buffers [ i ] = b ; } this . nioBufferCount = nioBufferCount ; this . capacity = capacity ; this . direct = direct ; } setIndex ( <int> , capacity ( ) ) ; this . allocator = allocator ; } @Override public boolean isWritable ( ) { return false ; } @Override public boolean isWritable ( int size ) { return false ; } @Override public ByteBuf discardReadBytes ( ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBuf setBytes ( int index , ByteBuf src , int srcIndex , int length ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBuf setBytes ( int index , byte [ ] src , int srcIndex , int length ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBuf setBytes ( int index , ByteBuffer src ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBuf setByte ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setByte ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBuf setShort ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setShort ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setShortLE ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBuf setMedium ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setMedium ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setMediumLE ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBuf setInt ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setInt ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setIntLE ( int index , int value ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBuf setLong ( int index , long value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setLong ( int index , long value ) { throw new ReadOnlyBufferException ( ) ; } @Override protected void _setLongLE ( int index , long value ) { throw new ReadOnlyBufferException ( ) ; } @Override public int setBytes ( int index , InputStream in , int length ) { throw new ReadOnlyBufferException ( ) ; } @Override public int setBytes ( int index , ScatteringByteChannel in , int length ) { throw new ReadOnlyBufferException ( ) ; } @Override public int capacity ( ) { return capacity ; } @Override public int maxCapacity ( ) { return capacity ; } @Override public ByteBuf capacity ( int newCapacity ) { throw new ReadOnlyBufferException ( ) ; } @Override public ByteBufAllocator alloc ( ) { return allocator ; } @Override public ByteOrder order ( ) { return order ; } @Override public ByteBuf unwrap ( ) { return null ; } @Override public boolean isDirect ( ) { return direct ; } private Component findComponent ( int index ) { int readable = <int> ; for ( int i = <int> ; i < buffers . length ; i + + ) { Component comp = null ; ByteBuf b ; Object obj = buffers [ i ] ; boolean isBuffer ; if ( obj instanceof ByteBuf ) { b = ( ByteBuf ) obj ; isBuffer = true ; } else { comp = ( Component ) obj ; b = comp . buf ; isBuffer = false ; } readable + = b . readableBytes ( ) ; if ( index < readable ) { if ( isBuffer ) { comp = new Component ( i , readable - b . readableBytes ( ) , b ) ; buffers [ i ] = comp ; } return comp ; } } throw new IllegalStateException ( ) ; } private ByteBuf buffer ( int i ) { Object obj = buffers [ i ] ; if ( obj instanceof ByteBuf ) { return ( ByteBuf ) obj ; } return ( ( Component ) obj ) . buf ; } @Override public byte getByte ( int index ) { return _getByte ( index ) ; } @Override protected byte _getByte ( int index ) { Component c = findComponent ( index ) ; return c . buf . getByte ( index - c . offset ) ; } @Override protected short _getShort ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getShort ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( short ) ( ( _getByte ( index ) & <hex> ) < < <int> | _getByte ( index + <int> ) & <hex> ) ; } else { return ( short ) ( _getByte ( index ) & <hex> | ( _getByte ( index + <int> ) & <hex> ) < < <int> ) ; } } @Override protected short _getShortLE ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getShortLE ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( short ) ( _getByte ( index ) & <hex> | ( _getByte ( index + <int> ) & <hex> ) < < <int> ) ; } else { return ( short ) ( ( _getByte ( index ) & <hex> ) < < <int> | _getByte ( index + <int> ) & <hex> ) ; } } @Override protected int _getUnsignedMedium ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getUnsignedMedium ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( _getShort ( index ) & <hex> ) < < <int> | _getByte ( index + <int> ) & <hex> ; } else { return _getShort ( index ) & <hex> | ( _getByte ( index + <int> ) & <hex> ) < < <int> ; } } @Override protected int _getUnsignedMediumLE ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getUnsignedMediumLE ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return _getShortLE ( index ) & <hex> | ( _getByte ( index + <int> ) & <hex> ) < < <int> ; } else { return ( _getShortLE ( index ) & <hex> ) < < <int> | _getByte ( index + <int> ) & <hex> ; } } @Override protected int _getInt ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getInt ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( _getShort ( index ) & <hex> ) < < <int> | _getShort ( index + <int> ) & <hex> ; } else { return _getShort ( index ) & <hex> | ( _getShort ( index + <int> ) & <hex> ) < < <int> ; } } @Override protected int _getIntLE ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getIntLE ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return _getShortLE ( index ) & <hex> | ( _getShortLE ( index + <int> ) & <hex> ) < < <int> ; } else { return ( _getShortLE ( index ) & <hex> ) < < <int> | _getShortLE ( index + <int> ) & <hex> ; } } @Override protected long _getLong ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getLong ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return ( _getInt ( index ) & <hex> ) < < <int> | _getInt ( index + <int> ) & <hex> ; } else { return _getInt ( index ) & <hex> | ( _getInt ( index + <int> ) & <hex> ) < < <int> ; } } @Override protected long _getLongLE ( int index ) { Component c = findComponent ( index ) ; if ( index + <int> < = c . endOffset ) { return c . buf . getLongLE ( index - c . offset ) ; } else if ( order ( ) = = ByteOrder . BIG_ENDIAN ) { return _getIntLE ( index ) & <hex> | ( _getIntLE ( index + <int> ) & <hex> ) < < <int> ; } else { return ( _getIntLE ( index ) & <hex> ) < < <int> | _getIntLE ( index + <int> ) & <hex> ; } } @Override public ByteBuf getBytes ( int index , byte [ ] dst , int dstIndex , int length ) { checkDstIndex ( index , length , dstIndex , dst . length ) ; if ( length = = <int> ) { return this ; } Component c = findComponent ( index ) ; int i = c . index ; int adjustment = c . offset ; ByteBuf s = c . buf ; for ( ; ; ) { int localLength = Math . min ( length , s . readableBytes ( ) - ( index - adjustment ) ) ; s . getBytes ( index - adjustment , dst , dstIndex , localLength ) ; index + = localLength ; dstIndex + = localLength ; length - = localLength ; adjustment + = s . readableBytes ( ) ; if ( length < = <int> ) { break ; } s = buffer ( + + i ) ; } return this ; } @Override public ByteBuf getBytes ( int index , ByteBuffer dst ) { int limit = dst . limit ( ) ; int length = dst . remaining ( ) ; checkIndex ( index , length ) ; if ( length = = <int> ) { return this ; } try { Component c = findComponent ( index ) ; int i = c . index ; int adjustment = c . offset ; ByteBuf s = c . buf ; for ( ; ; ) { int localLength = Math . min ( length , s . readableBytes ( ) - ( index - adjustment ) ) ; dst . limit ( dst . position ( ) + localLength ) ; s . getBytes ( index - adjustment , dst ) ; index + = localLength ; length - = localLength ; adjustment + = s . readableBytes ( ) ; if ( length < = <int> ) { break ; } s = buffer ( + + i ) ; } } finally { dst . limit ( limit ) ; } return this ; } @Override public ByteBuf getBytes ( int index , ByteBuf dst , int dstIndex , int length ) { checkDstIndex ( index , length , dstIndex , dst . capacity ( ) ) ; if ( length = = <int> ) { return this ; } Component c = findComponent ( index ) ; int i = c . index ; int adjustment = c . offset ; ByteBuf s = c . buf ; for ( ; ; ) { int localLength = Math . min ( length , s . readableBytes ( ) - ( index - adjustment ) ) ; s . getBytes ( index - adjustment , dst , dstIndex , localLength ) ; index + = localLength ; dstIndex + = localLength ; length - = localLength ; adjustment + = s . readableBytes ( ) ; if ( length < = <int> ) { break ; } s = buffer ( + + i ) ; } return this ; } @Override public int getBytes ( int index , GatheringByteChannel out , int length ) throws IOException { int count = nioBufferCount ( ) ; if ( count = = <int> ) { return out . write ( internalNioBuffer ( index , length ) ) ; } else { long writtenBytes = out . write ( nioBuffers ( index , length ) ) ; if ( writtenBytes > Integer . MAX_VALUE ) { return Integer . MAX_VALUE ; } else { return ( int ) writtenBytes ; } } } @Override public ByteBuf getBytes ( int index , OutputStream out , int length ) throws IOException { checkIndex ( index , length ) ; if ( length = = <int> ) { return this ; } Component c = findComponent ( index ) ; int i = c . index ; int adjustment = c . offset ; ByteBuf s = c . buf ; for ( ; ; ) { int localLength = Math . min ( length , s . readableBytes ( ) - ( index - adjustment ) ) ; s . getBytes ( index - adjustment , out , localLength ) ; index + = localLength ; length - = localLength ; adjustment + = s . readableBytes ( ) ; if ( length < = <int> ) { break ; } s = buffer ( + + i ) ; } return this ; } @Override public ByteBuf copy ( int index , int length ) { checkIndex ( index , length ) ; boolean release = true ; ByteBuf buf = alloc ( ) . buffer ( length ) ; try { buf . writeBytes ( this , index , length ) ; release = false ; return buf ; } finally { if ( release ) { buf . release ( ) ; } } } @Override public int nioBufferCount ( ) { return nioBufferCount ; } @Override public ByteBuffer nioBuffer ( int index , int length ) { checkIndex ( index , length ) ; if ( buffers . length = = <int> ) { ByteBuf buf = buffer ( <int> ) ; if ( buf . nioBufferCount ( ) = = <int> ) { return buf . nioBuffer ( index , length ) ; } } ByteBuffer merged = ByteBuffer . allocate ( length ) . order ( order ( ) ) ; ByteBuffer [ ] buffers = nioBuffers ( index , length ) ; for ( int i = <int> ; i < buffers . length ; i + + ) { merged . put ( buffers [ i ] ) ; } merged . flip ( ) ; return merged ; } @Override public ByteBuffer internalNioBuffer ( int index , int length ) { if ( buffers . length = = <int> ) { return buffer ( <int> ) . internalNioBuffer ( index , length ) ; } throw new UnsupportedOperationException ( ) ; } @Override public ByteBuffer [ ] nioBuffers ( int index , int length ) { checkIndex ( index , length ) ; if ( length = = <int> ) { return EmptyArrays . EMPTY_BYTE_BUFFERS ; } RecyclableArrayList array = RecyclableArrayList . newInstance ( buffers . length ) ; try { Component c = findComponent ( index ) ; int i = c . index ; int adjustment = c . offset ; ByteBuf s = c . buf ; for ( ; ; ) { int localLength = Math . min ( length , s . readableBytes ( ) - ( index - adjustment ) ) ; switch ( s . nioBufferCount ( ) ) { case <int> : throw new UnsupportedOperationException ( ) ; case <int> : array . add ( s . nioBuffer ( index - adjustment , localLength ) ) ; break ; default : Collections . addAll ( array , s . nioBuffers ( index - adjustment , localLength ) ) ; } index + = localLength ; length - = localLength ; adjustment + = s . readableBytes ( ) ; if ( length < = <int> ) { break ; } s = buffer ( + + i ) ; } return array . toArray ( new ByteBuffer [ array . size ( ) ] ) ; } finally { array . recycle ( ) ; } } @Override public boolean hasArray ( ) { return false ; } @Override public byte [ ] array ( ) { throw new UnsupportedOperationException ( ) ; } @Override public int arrayOffset ( ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean hasMemoryAddress ( ) { return false ; } @Override public long memoryAddress ( ) { throw new UnsupportedOperationException ( ) ; } @Override protected void deallocate ( ) { for ( int i = <int> ; i < buffers . length ; i + + ) { buffer ( i ) . release ( ) ; } } @Override public String toString ( ) { String result = super . toString ( ) ; result = result . substring ( <int> , result . length ( ) - <int> ) ; return result + <str> + buffers . length + <str> ; } private static final class Component { private final int index ; private final int offset ; private final ByteBuf buf ; private final int endOffset ; Component ( int index , int offset , ByteBuf buf ) { this . index = index ; this . offset = offset ; endOffset = offset + buf . readableBytes ( ) ; this . buf = buf ; } } } 
