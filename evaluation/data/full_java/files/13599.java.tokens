package org . gradle . api . internal . tasks . compile . daemon ; import org . gradle . language . base . internal . compile . CompileSpec ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . UncheckedException ; import org . gradle . process . internal . WorkerProcess ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . SynchronousQueue ; class CompilerDaemonClient implements CompilerDaemon , CompilerDaemonClientProtocol , Stoppable { private final DaemonForkOptions forkOptions ; private final WorkerProcess workerProcess ; private final CompilerDaemonServerProtocol server ; private final BlockingQueue < CompileResult > compileResults = new SynchronousQueue < CompileResult > ( ) ; public CompilerDaemonClient ( DaemonForkOptions forkOptions , WorkerProcess workerProcess , CompilerDaemonServerProtocol server ) { this . forkOptions = forkOptions ; this . workerProcess = workerProcess ; this . server = server ; } public < T extends CompileSpec > CompileResult execute ( Compiler < T > compiler , T spec ) { try { server . execute ( compiler , spec ) ; return compileResults . take ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public boolean isCompatibleWith ( DaemonForkOptions required ) { return forkOptions . isCompatibleWith ( required ) ; } public void stop ( ) { server . stop ( ) ; workerProcess . waitForStop ( ) ; } public void executed ( CompileResult result ) { try { compileResults . put ( result ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } 
