package org . elasticsearch . action . search ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . ShardOperationFailedException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . rest . RestStatus ; import java . io . IOException ; import java . util . * ; public class SearchPhaseExecutionException extends ElasticsearchException { private final String phaseName ; private final ShardSearchFailure [ ] shardFailures ; public SearchPhaseExecutionException ( String phaseName , String msg , ShardSearchFailure [ ] shardFailures ) { this ( phaseName , msg , null , shardFailures ) ; } public SearchPhaseExecutionException ( String phaseName , String msg , Throwable cause , ShardSearchFailure [ ] shardFailures ) { super ( msg , deduplicateCause ( cause , shardFailures ) ) ; this . phaseName = phaseName ; this . shardFailures = shardFailures ; } public SearchPhaseExecutionException ( StreamInput in ) throws IOException { super ( in ) ; phaseName = in . readOptionalString ( ) ; int numFailures = in . readVInt ( ) ; shardFailures = new ShardSearchFailure [ numFailures ] ; for ( int i = <int> ; i < numFailures ; i + + ) { shardFailures [ i ] = ShardSearchFailure . readShardSearchFailure ( in ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeOptionalString ( phaseName ) ; out . writeVInt ( shardFailures . length ) ; for ( ShardSearchFailure failure : shardFailures ) { failure . writeTo ( out ) ; } } private static final Throwable deduplicateCause ( Throwable cause , ShardSearchFailure [ ] shardFailures ) { if ( shardFailures = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( cause ! = null ) { for ( ShardSearchFailure failure : shardFailures ) { if ( failure . getCause ( ) = = cause ) { return null ; } } } return cause ; } @Override public RestStatus status ( ) { if ( shardFailures . length = = <int> ) { return RestStatus . SERVICE_UNAVAILABLE ; } RestStatus status = shardFailures [ <int> ] . status ( ) ; if ( shardFailures . length > <int> ) { for ( int i = <int> ; i < shardFailures . length ; i + + ) { if ( shardFailures [ i ] . status ( ) . getStatus ( ) > = <int> ) { status = shardFailures [ i ] . status ( ) ; } } } return status ; } public ShardSearchFailure [ ] shardFailures ( ) { return shardFailures ; } public Throwable getCause ( ) { Throwable cause = super . getCause ( ) ; if ( cause = = null ) { for ( ElasticsearchException rootCause : guessRootCauses ( ) ) { return rootCause ; } } return cause ; } private static String buildMessage ( String phaseName , String msg , ShardSearchFailure [ ] shardFailures ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( phaseName ) . append ( <str> ) . append ( msg ) ; if ( shardFailures ! = null & & shardFailures . length > <int> ) { sb . append ( <str> ) ; for ( ShardSearchFailure shardFailure : shardFailures ) { if ( shardFailure . shard ( ) ! = null ) { sb . append ( <str> ) . append ( shardFailure . shard ( ) ) . append ( <str> ) . append ( shardFailure . reason ( ) ) . append ( <str> ) ; } else { sb . append ( <str> ) . append ( shardFailure . reason ( ) ) . append ( <str> ) ; } } } return sb . toString ( ) ; } @Override protected void innerToXContent ( XContentBuilder builder , Params params ) throws IOException { builder . field ( <str> , phaseName ) ; final boolean group = params . paramAsBoolean ( <str> , true ) ; builder . field ( <str> , group ) ; builder . field ( <str> ) ; builder . startArray ( ) ; ShardOperationFailedException [ ] failures = params . paramAsBoolean ( <str> , true ) ? ExceptionsHelper . groupBy ( shardFailures ) : shardFailures ; for ( ShardOperationFailedException failure : failures ) { builder . startObject ( ) ; failure . toXContent ( builder , params ) ; builder . endObject ( ) ; } builder . endArray ( ) ; super . innerToXContent ( builder , params ) ; } @Override protected void causeToXContent ( XContentBuilder builder , Params params ) throws IOException { if ( super . getCause ( ) ! = null ) { super . causeToXContent ( builder , params ) ; } } @Override public ElasticsearchException [ ] guessRootCauses ( ) { ShardOperationFailedException [ ] failures = ExceptionsHelper . groupBy ( shardFailures ) ; List < ElasticsearchException > rootCauses = new ArrayList < > ( failures . length ) ; for ( ShardOperationFailedException failure : failures ) { ElasticsearchException [ ] guessRootCauses = ElasticsearchException . guessRootCauses ( failure . getCause ( ) ) ; rootCauses . addAll ( Arrays . asList ( guessRootCauses ) ) ; } return rootCauses . toArray ( new ElasticsearchException [ <int> ] ) ; } @Override public String toString ( ) { return buildMessage ( phaseName , getMessage ( ) , shardFailures ) ; } public String getPhaseName ( ) { return phaseName ; } } 
