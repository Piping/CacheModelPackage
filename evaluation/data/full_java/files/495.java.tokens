package org . apache . cassandra . db . rows ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . Objects ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . ObjectSizes ; import org . apache . cassandra . utils . memory . AbstractAllocator ; public abstract class CellPath { public static final CellPath BOTTOM = new EmptyCellPath ( ) ; public static final CellPath TOP = new EmptyCellPath ( ) ; public abstract int size ( ) ; public abstract ByteBuffer get ( int i ) ; public static CellPath create ( ByteBuffer value ) { assert value ! = null ; return new CollectionCellPath ( value ) ; } public int dataSize ( ) { int size = <int> ; for ( int i = <int> ; i < size ( ) ; i + + ) size + = get ( i ) . remaining ( ) ; return size ; } public void digest ( MessageDigest digest ) { for ( int i = <int> ; i < size ( ) ; i + + ) digest . update ( get ( i ) . duplicate ( ) ) ; } public abstract CellPath copy ( AbstractAllocator allocator ) ; public abstract long unsharedHeapSizeExcludingData ( ) ; @Override public final int hashCode ( ) { int result = <int> ; for ( int i = <int> ; i < size ( ) ; i + + ) result + = <int> * Objects . hash ( get ( i ) ) ; return result ; } @Override public final boolean equals ( Object o ) { if ( ! ( o instanceof CellPath ) ) return false ; CellPath that = ( CellPath ) o ; if ( this . size ( ) ! = that . size ( ) ) return false ; for ( int i = <int> ; i < size ( ) ; i + + ) if ( ! Objects . equals ( this . get ( i ) , that . get ( i ) ) ) return false ; return true ; } public interface Serializer { public void serialize ( CellPath path , DataOutputPlus out ) throws IOException ; public CellPath deserialize ( DataInputPlus in ) throws IOException ; public long serializedSize ( CellPath path ) ; public void skip ( DataInputPlus in ) throws IOException ; } private static class CollectionCellPath extends CellPath { private static final long EMPTY_SIZE = ObjectSizes . measure ( new CollectionCellPath ( ByteBufferUtil . EMPTY_BYTE_BUFFER ) ) ; protected final ByteBuffer value ; private CollectionCellPath ( ByteBuffer value ) { this . value = value ; } public int size ( ) { return <int> ; } public ByteBuffer get ( int i ) { assert i = = <int> ; return value ; } public CellPath copy ( AbstractAllocator allocator ) { return new CollectionCellPath ( allocator . clone ( value ) ) ; } public long unsharedHeapSizeExcludingData ( ) { return EMPTY_SIZE + ObjectSizes . sizeOnHeapExcludingData ( value ) ; } } private static class EmptyCellPath extends CellPath { public int size ( ) { return <int> ; } public ByteBuffer get ( int i ) { throw new UnsupportedOperationException ( ) ; } public CellPath copy ( AbstractAllocator allocator ) { return this ; } public long unsharedHeapSizeExcludingData ( ) { return <int> ; } } } 
