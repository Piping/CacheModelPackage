package org . apache . cassandra . db . compaction ; import java . nio . ByteBuffer ; import java . io . * ; import java . util . * ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Throwables ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . io . sstable . * ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . format . SSTableWriter ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . io . util . RandomAccessReader ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . OutputHandler ; import org . apache . cassandra . utils . UUIDGen ; public class Scrubber implements Closeable { private final ColumnFamilyStore cfs ; private final SSTableReader sstable ; private final LifecycleTransaction transaction ; private final File destination ; private final boolean skipCorrupted ; private final boolean isCommutative ; private final boolean isIndex ; private final boolean checkData ; private final long expectedBloomFilterSize ; private final RandomAccessReader dataFile ; private final RandomAccessReader indexFile ; private final ScrubInfo scrubInfo ; private final RowIndexEntry . IndexSerializer rowIndexEntrySerializer ; private final boolean isOffline ; private int goodRows ; private int badRows ; private int emptyRows ; private ByteBuffer currentIndexKey ; private ByteBuffer nextIndexKey ; long currentRowPositionFromIndex ; long nextRowPositionFromIndex ; private final OutputHandler outputHandler ; private static final Comparator < Partition > partitionComparator = new Comparator < Partition > ( ) { public int compare ( Partition r1 , Partition r2 ) { return r1 . partitionKey ( ) . compareTo ( r2 . partitionKey ( ) ) ; } } ; private final SortedSet < Partition > outOfOrder = new TreeSet < > ( partitionComparator ) ; public Scrubber ( ColumnFamilyStore cfs , LifecycleTransaction transaction , boolean skipCorrupted , boolean isOffline , boolean checkData ) throws IOException { this ( cfs , transaction , skipCorrupted , new OutputHandler . LogOutput ( ) , isOffline , checkData ) ; } @SuppressWarnings ( <str> ) public Scrubber ( ColumnFamilyStore cfs , LifecycleTransaction transaction , boolean skipCorrupted , OutputHandler outputHandler , boolean isOffline , boolean checkData ) throws IOException { this . cfs = cfs ; this . transaction = transaction ; this . sstable = transaction . onlyOne ( ) ; this . outputHandler = outputHandler ; this . skipCorrupted = skipCorrupted ; this . isOffline = isOffline ; this . rowIndexEntrySerializer = sstable . descriptor . version . getSSTableFormat ( ) . getIndexSerializer ( sstable . metadata , sstable . descriptor . version , sstable . header ) ; List < SSTableReader > toScrub = Collections . singletonList ( sstable ) ; this . destination = cfs . getDirectories ( ) . getWriteableLocationAsFile ( cfs . getExpectedCompactedFileSize ( toScrub , OperationType . SCRUB ) ) ; if ( destination = = null ) throw new IOException ( <str> ) ; this . isCommutative = cfs . metadata . isCounter ( ) ; boolean hasIndexFile = ( new File ( sstable . descriptor . filenameFor ( Component . PRIMARY_INDEX ) ) ) . exists ( ) ; this . isIndex = cfs . isIndex ( ) ; if ( ! hasIndexFile ) { outputHandler . warn ( <str> + sstable . descriptor . filenameFor ( Component . PRIMARY_INDEX ) ) ; } this . checkData = checkData & & ! this . isIndex ; this . expectedBloomFilterSize = Math . max ( cfs . metadata . params . minIndexInterval , hasIndexFile ? SSTableReader . getApproximateKeyCount ( toScrub ) : <int> ) ; this . dataFile = isOffline ? sstable . openDataReader ( ) : sstable . openDataReader ( CompactionManager . instance . getRateLimiter ( ) ) ; this . indexFile = hasIndexFile ? RandomAccessReader . open ( new File ( sstable . descriptor . filenameFor ( Component . PRIMARY_INDEX ) ) ) : null ; this . scrubInfo = new ScrubInfo ( dataFile , sstable ) ; this . currentRowPositionFromIndex = <int> ; this . nextRowPositionFromIndex = <int> ; } private UnfilteredRowIterator withValidation ( UnfilteredRowIterator iter , String filename ) { return checkData ? UnfilteredRowIterators . withValidation ( iter , filename ) : iter ; } public void scrub ( ) { List < SSTableReader > finished = new ArrayList < > ( ) ; boolean completed = false ; outputHandler . output ( String . format ( <str> , sstable , dataFile . length ( ) ) ) ; try ( SSTableRewriter writer = new SSTableRewriter ( transaction , sstable . maxDataAge , isOffline ) ) { nextIndexKey = indexAvailable ( ) ? ByteBufferUtil . readWithShortLength ( indexFile ) : null ; if ( indexAvailable ( ) ) { long firstRowPositionFromIndex = rowIndexEntrySerializer . deserialize ( indexFile ) . position ; assert firstRowPositionFromIndex = = <int> : firstRowPositionFromIndex ; } writer . switchWriter ( CompactionManager . createWriter ( cfs , destination , expectedBloomFilterSize , sstable . getSSTableMetadata ( ) . repairedAt , sstable , transaction ) ) ; DecoratedKey prevKey = null ; while ( ! dataFile . isEOF ( ) ) { if ( scrubInfo . isStopRequested ( ) ) throw new CompactionInterruptedException ( scrubInfo . getCompactionInfo ( ) ) ; long rowStart = dataFile . getFilePointer ( ) ; outputHandler . debug ( <str> + rowStart ) ; DecoratedKey key = null ; try { key = sstable . decorateKey ( ByteBufferUtil . readWithShortLength ( dataFile ) ) ; } catch ( Throwable th ) { throwIfFatal ( th ) ; } updateIndexKey ( ) ; long dataStart = dataFile . getFilePointer ( ) ; long dataStartFromIndex = - <int> ; long dataSizeFromIndex = - <int> ; if ( currentIndexKey ! = null ) { dataStartFromIndex = currentRowPositionFromIndex + <int> + currentIndexKey . remaining ( ) ; dataSizeFromIndex = nextRowPositionFromIndex - dataStartFromIndex ; } String keyName = key = = null ? <str> : ByteBufferUtil . bytesToHex ( key . getKey ( ) ) ; outputHandler . debug ( String . format ( <str> , keyName , dataSizeFromIndex ) ) ; assert currentIndexKey ! = null | | ! indexAvailable ( ) ; try { if ( key = = null ) throw new IOError ( new IOException ( <str> ) ) ; if ( currentIndexKey ! = null & & ! key . getKey ( ) . equals ( currentIndexKey ) ) { throw new IOError ( new IOException ( String . format ( <str> , <str> , ByteBufferUtil . bytesToHex ( currentIndexKey ) ) ) ) ; } if ( indexFile ! = null & & dataSizeFromIndex > dataFile . length ( ) ) throw new IOError ( new IOException ( <str> + dataSizeFromIndex ) ) ; if ( indexFile ! = null & & dataStart ! = dataStartFromIndex ) outputHandler . warn ( String . format ( <str> , dataStart , dataStartFromIndex ) ) ; try ( UnfilteredRowIterator iterator = withValidation ( new SSTableIdentityIterator ( sstable , dataFile , key ) , dataFile . getPath ( ) ) ) { if ( prevKey ! = null & & prevKey . compareTo ( key ) > <int> ) { saveOutOfOrderRow ( prevKey , key , iterator ) ; continue ; } if ( writer . tryAppend ( iterator ) = = null ) emptyRows + + ; else goodRows + + ; } prevKey = key ; } catch ( Throwable th ) { throwIfFatal ( th ) ; outputHandler . warn ( <str> , th ) ; if ( currentIndexKey ! = null & & ( key = = null | | ! key . getKey ( ) . equals ( currentIndexKey ) | | dataStart ! = dataStartFromIndex ) ) { outputHandler . output ( String . format ( <str> , dataSizeFromIndex , dataStartFromIndex ) ) ; key = sstable . decorateKey ( currentIndexKey ) ; try { dataFile . seek ( dataStartFromIndex ) ; try ( UnfilteredRowIterator iterator = withValidation ( new SSTableIdentityIterator ( sstable , dataFile , key ) , dataFile . getPath ( ) ) ) { if ( prevKey ! = null & & prevKey . compareTo ( key ) > <int> ) { saveOutOfOrderRow ( prevKey , key , iterator ) ; continue ; } if ( writer . tryAppend ( iterator ) = = null ) emptyRows + + ; else goodRows + + ; } prevKey = key ; } catch ( Throwable th2 ) { throwIfFatal ( th2 ) ; throwIfCannotContinue ( key , th2 ) ; outputHandler . warn ( <str> , th2 ) ; badRows + + ; seekToNextRow ( ) ; } } else { throwIfCannotContinue ( key , th ) ; outputHandler . warn ( <str> + dataStart + <str> ) ; badRows + + ; if ( currentIndexKey ! = null ) seekToNextRow ( ) ; } } } if ( ! outOfOrder . isEmpty ( ) ) { long repairedAt = badRows > <int> ? ActiveRepairService . UNREPAIRED_SSTABLE : sstable . getSSTableMetadata ( ) . repairedAt ; SSTableReader newInOrderSstable ; try ( SSTableWriter inOrderWriter = CompactionManager . createWriter ( cfs , destination , expectedBloomFilterSize , repairedAt , sstable , transaction ) ) { for ( Partition partition : outOfOrder ) inOrderWriter . append ( partition . unfilteredIterator ( ) ) ; newInOrderSstable = inOrderWriter . finish ( - <int> , sstable . maxDataAge , true ) ; } transaction . update ( newInOrderSstable , false ) ; finished . add ( newInOrderSstable ) ; outputHandler . warn ( String . format ( <str> , outOfOrder . size ( ) , sstable , newInOrderSstable ) ) ; } finished . addAll ( writer . setRepairedAt ( badRows > <int> ? ActiveRepairService . UNREPAIRED_SSTABLE : sstable . getSSTableMetadata ( ) . repairedAt ) . finish ( ) ) ; completed = true ; } catch ( IOException e ) { throw Throwables . propagate ( e ) ; } finally { if ( transaction . isOffline ( ) ) finished . forEach ( sstable - > sstable . selfRef ( ) . release ( ) ) ; } if ( completed ) { if ( badRows > <int> ) outputHandler . warn ( <str> + sstable + <str> ) ; else outputHandler . output ( <str> + sstable + <str> + emptyRows + <str> ) ; } else { outputHandler . output ( <str> + sstable + <str> + goodRows + <str> + emptyRows + <str> ) ; if ( badRows > <int> ) outputHandler . warn ( <str> + badRows + <str> ) ; } } private void updateIndexKey ( ) { currentIndexKey = nextIndexKey ; currentRowPositionFromIndex = nextRowPositionFromIndex ; try { nextIndexKey = ! indexAvailable ( ) ? null : ByteBufferUtil . readWithShortLength ( indexFile ) ; nextRowPositionFromIndex = ! indexAvailable ( ) ? dataFile . length ( ) : rowIndexEntrySerializer . deserialize ( indexFile ) . position ; } catch ( Throwable th ) { JVMStabilityInspector . inspectThrowable ( th ) ; outputHandler . warn ( <str> , th ) ; nextIndexKey = null ; nextRowPositionFromIndex = dataFile . length ( ) ; } } private boolean indexAvailable ( ) { return indexFile ! = null & & ! indexFile . isEOF ( ) ; } private void seekToNextRow ( ) { while ( nextRowPositionFromIndex < dataFile . length ( ) ) { try { dataFile . seek ( nextRowPositionFromIndex ) ; return ; } catch ( Throwable th ) { throwIfFatal ( th ) ; outputHandler . warn ( String . format ( <str> , nextRowPositionFromIndex ) , th ) ; badRows + + ; } updateIndexKey ( ) ; } } private void saveOutOfOrderRow ( DecoratedKey prevKey , DecoratedKey key , UnfilteredRowIterator iterator ) { outputHandler . warn ( String . format ( <str> , key , prevKey ) ) ; outOfOrder . add ( ImmutableBTreePartition . create ( iterator ) ) ; } private void throwIfFatal ( Throwable th ) { if ( th instanceof Error & & ! ( th instanceof AssertionError | | th instanceof IOError ) ) throw ( Error ) th ; } private void throwIfCannotContinue ( DecoratedKey key , Throwable th ) { if ( isIndex ) { outputHandler . warn ( String . format ( <str> + <str> , key ) ) ; throw new IOError ( th ) ; } if ( isCommutative & & ! skipCorrupted ) { outputHandler . warn ( String . format ( <str> + <str> + <str> + <str> + <str> , key ) ) ; throw new IOError ( th ) ; } } public void close ( ) { FileUtils . closeQuietly ( dataFile ) ; FileUtils . closeQuietly ( indexFile ) ; } public CompactionInfo . Holder getScrubInfo ( ) { return scrubInfo ; } private static class ScrubInfo extends CompactionInfo . Holder { private final RandomAccessReader dataFile ; private final SSTableReader sstable ; private final UUID scrubCompactionId ; public ScrubInfo ( RandomAccessReader dataFile , SSTableReader sstable ) { this . dataFile = dataFile ; this . sstable = sstable ; scrubCompactionId = UUIDGen . getTimeUUID ( ) ; } public CompactionInfo getCompactionInfo ( ) { try { return new CompactionInfo ( sstable . metadata , OperationType . SCRUB , dataFile . getFilePointer ( ) , dataFile . length ( ) , scrubCompactionId ) ; } catch ( Exception e ) { throw new RuntimeException ( ) ; } } } @VisibleForTesting public ScrubResult scrubWithResult ( ) { scrub ( ) ; return new ScrubResult ( this ) ; } public static final class ScrubResult { public final int goodRows ; public final int badRows ; public final int emptyRows ; public ScrubResult ( Scrubber scrubber ) { this . goodRows = scrubber . goodRows ; this . badRows = scrubber . badRows ; this . emptyRows = scrubber . emptyRows ; } } } 
