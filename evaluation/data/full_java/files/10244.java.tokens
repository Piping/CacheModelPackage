package com . google . common . base ; import static com . google . common . base . Functions . toStringFunction ; import com . google . common . annotations . GwtCompatible ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . primitives . Longs ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . util . Iterator ; import java . util . List ; @GwtCompatible public class ConverterTest extends TestCase { private static final Converter < String , Long > STR_TO_LONG = new Converter < String , Long > ( ) { @Override public Long doForward ( String object ) { return Long . valueOf ( object ) ; } @Override public String doBackward ( Long object ) { return String . valueOf ( object ) ; } @Override public String toString ( ) { return <str> ; } } ; private static final Long LONG_VAL = <int> ; private static final String STR_VAL = <str> ; private static final ImmutableList < String > STRINGS = ImmutableList . of ( <str> , <str> ) ; private static final ImmutableList < Long > LONGS = ImmutableList . of ( <int> , <int> ) ; public void testConverter ( ) { assertEquals ( LONG_VAL , STR_TO_LONG . convert ( STR_VAL ) ) ; assertEquals ( STR_VAL , STR_TO_LONG . reverse ( ) . convert ( LONG_VAL ) ) ; Iterable < Long > convertedValues = STR_TO_LONG . convertAll ( STRINGS ) ; assertEquals ( LONGS , ImmutableList . copyOf ( convertedValues ) ) ; } public void testConvertAllIsView ( ) { List < String > mutableList = Lists . newArrayList ( <str> , <str> ) ; Iterable < Long > convertedValues = STR_TO_LONG . convertAll ( mutableList ) ; assertEquals ( ImmutableList . of ( <int> , <int> ) , ImmutableList . copyOf ( convertedValues ) ) ; Iterator < Long > iterator = convertedValues . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; assertEquals ( ImmutableList . of ( <str> ) , mutableList ) ; } public void testReverse ( ) { Converter < Long , String > reverseConverter = STR_TO_LONG . reverse ( ) ; assertEquals ( STR_VAL , reverseConverter . convert ( LONG_VAL ) ) ; assertEquals ( LONG_VAL , reverseConverter . reverse ( ) . convert ( STR_VAL ) ) ; Iterable < String > convertedValues = reverseConverter . convertAll ( LONGS ) ; assertEquals ( STRINGS , ImmutableList . copyOf ( convertedValues ) ) ; assertSame ( STR_TO_LONG , reverseConverter . reverse ( ) ) ; assertEquals ( <str> , reverseConverter . toString ( ) ) ; new EqualsTester ( ) . addEqualityGroup ( STR_TO_LONG , STR_TO_LONG . reverse ( ) . reverse ( ) ) . addEqualityGroup ( STR_TO_LONG . reverse ( ) , STR_TO_LONG . reverse ( ) ) . testEquals ( ) ; } public void testReverseReverse ( ) { Converter < String , Long > converter = STR_TO_LONG ; assertEquals ( converter , converter . reverse ( ) . reverse ( ) ) ; } public void testApply ( ) { assertEquals ( LONG_VAL , STR_TO_LONG . apply ( STR_VAL ) ) ; } private static class StringWrapper { private final String value ; public StringWrapper ( String value ) { this . value = value ; } } public void testAndThen ( ) { Converter < StringWrapper , String > first = new Converter < StringWrapper , String > ( ) { @Override public String doForward ( StringWrapper object ) { return object . value ; } @Override public StringWrapper doBackward ( String object ) { return new StringWrapper ( object ) ; } @Override public String toString ( ) { return <str> ; } } ; Converter < StringWrapper , Long > converter = first . andThen ( STR_TO_LONG ) ; assertEquals ( LONG_VAL , converter . convert ( new StringWrapper ( STR_VAL ) ) ) ; assertEquals ( STR_VAL , converter . reverse ( ) . convert ( LONG_VAL ) . value ) ; assertEquals ( <str> , converter . toString ( ) ) ; assertEquals ( first . andThen ( STR_TO_LONG ) , first . andThen ( STR_TO_LONG ) ) ; } public void testIdentityConverter ( ) { Converter < String , String > stringIdentityConverter = Converter . identity ( ) ; assertSame ( stringIdentityConverter , stringIdentityConverter . reverse ( ) ) ; assertSame ( STR_TO_LONG , stringIdentityConverter . andThen ( STR_TO_LONG ) ) ; assertSame ( STR_VAL , stringIdentityConverter . convert ( STR_VAL ) ) ; assertSame ( STR_VAL , stringIdentityConverter . reverse ( ) . convert ( STR_VAL ) ) ; assertEquals ( <str> , stringIdentityConverter . toString ( ) ) ; assertSame ( Converter . identity ( ) , Converter . identity ( ) ) ; } public void testFrom ( ) { Function < String , Integer > forward = new Function < String , Integer > ( ) { @Override public Integer apply ( String input ) { return Integer . parseInt ( input ) ; } } ; Function < Object , String > backward = toStringFunction ( ) ; Converter < String , Number > converter = Converter . < String , Number > from ( forward , backward ) ; assertNull ( converter . convert ( null ) ) ; assertNull ( converter . reverse ( ) . convert ( null ) ) ; assertEquals ( ( Integer ) <int> , converter . convert ( <str> ) ) ; assertEquals ( <str> , converter . reverse ( ) . convert ( <int> ) ) ; } public void testNullIsPassedThrough ( ) { Converter < String , String > nullsArePassed = sillyConverter ( false ) ; assertEquals ( <str> , nullsArePassed . convert ( <str> ) ) ; assertEquals ( <str> , nullsArePassed . convert ( null ) ) ; assertEquals ( <str> , nullsArePassed . reverse ( ) . convert ( <str> ) ) ; assertEquals ( <str> , nullsArePassed . reverse ( ) . convert ( null ) ) ; } public void testNullIsNotPassedThrough ( ) { Converter < String , String > nullsAreHandled = sillyConverter ( true ) ; assertEquals ( <str> , nullsAreHandled . convert ( <str> ) ) ; assertEquals ( null , nullsAreHandled . convert ( null ) ) ; assertEquals ( <str> , nullsAreHandled . reverse ( ) . convert ( <str> ) ) ; assertEquals ( null , nullsAreHandled . reverse ( ) . convert ( null ) ) ; } private static Converter < String , String > sillyConverter ( final boolean handleNullAutomatically ) { return new Converter < String , String > ( handleNullAutomatically ) { @Override public String doForward ( String string ) { return <str> ; } @Override public String doBackward ( String string ) { return <str> ; } } ; } public void testSerialization_identity ( ) { Converter < String , String > identityConverter = Converter . identity ( ) ; SerializableTester . reserializeAndAssert ( identityConverter ) ; } public void testSerialization_reverse ( ) { Converter < Long , String > reverseConverter = Longs . stringConverter ( ) . reverse ( ) ; SerializableTester . reserializeAndAssert ( reverseConverter ) ; } public void testSerialization_andThen ( ) { Converter < String , Long > converterA = Longs . stringConverter ( ) ; Converter < Long , String > reverseConverter = Longs . stringConverter ( ) . reverse ( ) ; Converter < String , String > composedConverter = converterA . andThen ( reverseConverter ) ; SerializableTester . reserializeAndAssert ( composedConverter ) ; } public void testSerialization_from ( ) { Converter < String , String > dumb = Converter . from ( toStringFunction ( ) , toStringFunction ( ) ) ; SerializableTester . reserializeAndAssert ( dumb ) ; } } 
