package org . apache . cassandra . db ; import java . io . IOException ; import java . util . * ; import com . google . common . annotations . VisibleForTesting ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . io . sstable . IndexHelper ; import org . apache . cassandra . io . sstable . format . SSTableFlushObserver ; import org . apache . cassandra . io . sstable . format . Version ; import org . apache . cassandra . io . util . SequentialWriter ; import org . apache . cassandra . utils . ByteBufferUtil ; public class ColumnIndex { public final long partitionHeaderLength ; public final List < IndexHelper . IndexInfo > columnsIndex ; private static final ColumnIndex EMPTY = new ColumnIndex ( - <int> , Collections . < IndexHelper . IndexInfo > emptyList ( ) ) ; private ColumnIndex ( long partitionHeaderLength , List < IndexHelper . IndexInfo > columnsIndex ) { assert columnsIndex ! = null ; this . partitionHeaderLength = partitionHeaderLength ; this . columnsIndex = columnsIndex ; } public static ColumnIndex writeAndBuildIndex ( UnfilteredRowIterator iterator , SequentialWriter output , SerializationHeader header , Collection < SSTableFlushObserver > observers , Version version ) throws IOException { assert ! iterator . isEmpty ( ) & & version . storeRows ( ) ; Builder builder = new Builder ( iterator , output , header , observers , version . correspondingMessagingVersion ( ) ) ; return builder . build ( ) ; } @VisibleForTesting public static ColumnIndex nothing ( ) { return EMPTY ; } private static class Builder { private final UnfilteredRowIterator iterator ; private final SequentialWriter writer ; private final SerializationHeader header ; private final int version ; private final List < IndexHelper . IndexInfo > columnsIndex = new ArrayList < > ( ) ; private final long initialPosition ; private long headerLength = - <int> ; private long startPosition = - <int> ; private int written ; private long previousRowStart ; private ClusteringPrefix firstClustering ; private ClusteringPrefix lastClustering ; private DeletionTime openMarker ; private final Collection < SSTableFlushObserver > observers ; public Builder ( UnfilteredRowIterator iterator , SequentialWriter writer , SerializationHeader header , Collection < SSTableFlushObserver > observers , int version ) { this . iterator = iterator ; this . writer = writer ; this . header = header ; this . version = version ; this . observers = observers = = null ? Collections . emptyList ( ) : observers ; this . initialPosition = writer . position ( ) ; } private void writePartitionHeader ( UnfilteredRowIterator iterator ) throws IOException { ByteBufferUtil . writeWithShortLength ( iterator . partitionKey ( ) . getKey ( ) , writer ) ; DeletionTime . serializer . serialize ( iterator . partitionLevelDeletion ( ) , writer ) ; if ( header . hasStatic ( ) ) UnfilteredSerializer . serializer . serializeStaticRow ( iterator . staticRow ( ) , header , writer , version ) ; } public ColumnIndex build ( ) throws IOException { writePartitionHeader ( iterator ) ; this . headerLength = writer . position ( ) - initialPosition ; while ( iterator . hasNext ( ) ) add ( iterator . next ( ) ) ; return close ( ) ; } private long currentPosition ( ) { return writer . position ( ) - initialPosition ; } private void addIndexBlock ( ) { IndexHelper . IndexInfo cIndexInfo = new IndexHelper . IndexInfo ( firstClustering , lastClustering , startPosition , currentPosition ( ) - startPosition , openMarker ) ; columnsIndex . add ( cIndexInfo ) ; firstClustering = null ; } private void add ( Unfiltered unfiltered ) throws IOException { long pos = currentPosition ( ) ; if ( firstClustering = = null ) { firstClustering = unfiltered . clustering ( ) ; startPosition = pos ; } UnfilteredSerializer . serializer . serialize ( unfiltered , header , writer , pos - previousRowStart , version ) ; if ( ! observers . isEmpty ( ) & & unfiltered . isRow ( ) ) ( ( Row ) unfiltered ) . stream ( ) . forEach ( cell - > observers . forEach ( ( o ) - > o . nextCell ( cell ) ) ) ; lastClustering = unfiltered . clustering ( ) ; previousRowStart = pos ; + + written ; if ( unfiltered . kind ( ) = = Unfiltered . Kind . RANGE_TOMBSTONE_MARKER ) { RangeTombstoneMarker marker = ( RangeTombstoneMarker ) unfiltered ; openMarker = marker . isOpen ( false ) ? marker . openDeletionTime ( false ) : null ; } if ( currentPosition ( ) - startPosition > = DatabaseDescriptor . getColumnIndexSize ( ) ) addIndexBlock ( ) ; } private ColumnIndex close ( ) throws IOException { UnfilteredSerializer . serializer . writeEndOfPartition ( writer ) ; if ( written = = <int> ) return ColumnIndex . EMPTY ; if ( firstClustering ! = null ) addIndexBlock ( ) ; assert columnsIndex . size ( ) > <int> & & headerLength > = <int> ; return new ColumnIndex ( headerLength , columnsIndex ) ; } } } 
