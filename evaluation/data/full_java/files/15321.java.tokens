package org . gradle . api . tasks . testing ; import org . gradle . api . file . FileCollection ; import org . gradle . api . file . FileTree ; import org . gradle . api . internal . ConventionTask ; import org . gradle . api . internal . file . CompositeFileTree ; import org . gradle . api . internal . file . collections . DefaultFileCollectionResolveContext ; import org . gradle . api . internal . file . collections . DirectoryFileTree ; import org . gradle . api . internal . file . collections . FileTreeAdapter ; import org . gradle . api . internal . file . collections . SimpleFileCollection ; import org . gradle . api . internal . tasks . testing . TestDescriptorInternal ; import org . gradle . api . internal . tasks . testing . TestFramework ; import org . gradle . api . internal . tasks . testing . TestResultProcessor ; import org . gradle . api . internal . tasks . testing . WorkerTestClassProcessorFactory ; import org . gradle . api . internal . tasks . testing . detection . TestExecuter ; import org . gradle . api . internal . tasks . testing . detection . TestFrameworkDetector ; import org . gradle . api . internal . tasks . testing . junit . JUnitTestFramework ; import org . gradle . api . internal . tasks . testing . junit . report . TestReporter ; import org . gradle . api . internal . tasks . testing . junit . result . TestResultsProvider ; import org . gradle . api . tasks . AbstractConventionTaskTest ; import org . gradle . process . internal . WorkerProcessBuilder ; import org . gradle . util . GFileUtils ; import org . hamcrest . Description ; import org . jmock . Expectations ; import org . jmock . api . Action ; import org . jmock . api . Invocation ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . jmock . lib . legacy . ClassImposteriser ; import org . junit . Before ; import org . junit . runner . RunWith ; import java . io . File ; import java . lang . ref . WeakReference ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import static org . gradle . util . Matchers . isEmpty ; import static org . gradle . util . WrapUtil . toLinkedSet ; import static org . gradle . util . WrapUtil . toSet ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; @RunWith ( JMock . class ) public class TestTest extends AbstractConventionTaskTest { static final String TEST_PATTERN_1 = <str> ; static final String TEST_PATTERN_2 = <str> ; static final String TEST_PATTERN_3 = <str> ; private File classesDir ; private File resultsDir ; private File binResultsDir ; private File reportDir ; private JUnit4Mockery context = new JUnit4Mockery ( ) { { setImposteriser ( ClassImposteriser . INSTANCE ) ; } } ; TestFramework testFrameworkMock = context . mock ( TestFramework . class ) ; TestExecuter testExecuterMock = context . mock ( TestExecuter . class ) ; private FileCollection classpathMock = new SimpleFileCollection ( new File ( <str> ) ) ; private Test test ; @Before public void setUp ( ) { classesDir = tmpDir . createDir ( <str> ) ; File classfile = new File ( classesDir , <str> ) ; GFileUtils . touch ( classfile ) ; resultsDir = tmpDir . createDir ( <str> ) ; binResultsDir = tmpDir . createDir ( <str> ) ; reportDir = tmpDir . createDir ( <str> ) ; test = createTask ( Test . class ) ; context . checking ( new Expectations ( ) { { TestFrameworkOptions testOptions = context . mock ( TestFrameworkOptions . class ) ; allowing ( testFrameworkMock ) . getOptions ( ) ; will ( returnValue ( testOptions ) ) ; } } ) ; } public ConventionTask getTask ( ) { return test ; } @org.junit.Test public void testInit ( ) { assertThat ( test . getTestFramework ( ) , instanceOf ( JUnitTestFramework . class ) ) ; assertNull ( test . getTestClassesDir ( ) ) ; assertNull ( test . getClasspath ( ) ) ; assertNull ( test . getReports ( ) . getJunitXml ( ) . getDestination ( ) ) ; assertNull ( test . getReports ( ) . getHtml ( ) . getDestination ( ) ) ; assertThat ( test . getIncludes ( ) , isEmpty ( ) ) ; assertThat ( test . getExcludes ( ) , isEmpty ( ) ) ; assertFalse ( test . getIgnoreFailures ( ) ) ; } @org.junit.Test public void testExecute ( ) { configureTask ( ) ; expectTestsExecuted ( ) ; test . executeTests ( ) ; } @org.junit.Test public void generatesReport ( ) { configureTask ( ) ; expectTestsExecuted ( ) ; final TestReporter testReporter = context . mock ( TestReporter . class ) ; test . setTestReporter ( testReporter ) ; context . checking ( new Expectations ( ) { { one ( testReporter ) . generateReport ( with ( any ( TestResultsProvider . class ) ) , with ( equal ( reportDir ) ) ) ; } } ) ; test . executeTests ( ) ; } @org.junit.Test public void testExecuteWithTestFailuresAndIgnoreFailures ( ) { configureTask ( ) ; test . setIgnoreFailures ( true ) ; expectTestsFail ( ) ; test . executeTests ( ) ; } @org.junit.Test public void testScansForTestClassesInTheTestClassesDir ( ) { configureTask ( ) ; test . include ( <str> ) ; test . exclude ( <str> ) ; FileTree classFiles = test . getCandidateClassFiles ( ) ; assertIsDirectoryTree ( classFiles , toSet ( <str> ) , toSet ( <str> ) ) ; } @org.junit.Test public void testSetsTestFrameworkToNullAfterExecution ( ) { configureTask ( ) ; test . useTestFramework ( new TestFramework ( ) { public TestFrameworkDetector getDetector ( ) { return null ; } public TestFrameworkOptions getOptions ( ) { return null ; } public WorkerTestClassProcessorFactory getProcessorFactory ( ) { return null ; } public org . gradle . api . Action < WorkerProcessBuilder > getWorkerConfigurationAction ( ) { return null ; } } ) ; context . checking ( new Expectations ( ) { { one ( testExecuterMock ) . execute ( with ( sameInstance ( test ) ) , with ( notNullValue ( TestResultProcessor . class ) ) ) ; } } ) ; WeakReference < TestFramework > weakRef = new WeakReference < TestFramework > ( test . getTestFramework ( ) ) ; test . executeTests ( ) ; System . gc ( ) ; assertNull ( weakRef . get ( ) ) ; } @org.junit.Test public void testDisablesParallelExecutionWhenInDebugMode ( ) { configureTask ( ) ; test . setDebug ( true ) ; test . setMaxParallelForks ( <int> ) ; assertEquals ( <int> , test . getMaxParallelForks ( ) ) ; } private void assertIsDirectoryTree ( FileTree classFiles , Set < String > includes , Set < String > excludes ) { assertThat ( classFiles , instanceOf ( CompositeFileTree . class ) ) ; CompositeFileTree files = ( CompositeFileTree ) classFiles ; DefaultFileCollectionResolveContext context = new DefaultFileCollectionResolveContext ( ) ; files . visitContents ( context ) ; List < ? extends FileTree > contents = context . resolveAsFileTrees ( ) ; FileTreeAdapter adapter = ( FileTreeAdapter ) contents . get ( <int> ) ; assertThat ( adapter . getTree ( ) , instanceOf ( DirectoryFileTree . class ) ) ; DirectoryFileTree directoryFileTree = ( DirectoryFileTree ) adapter . getTree ( ) ; assertThat ( directoryFileTree . getDir ( ) , equalTo ( classesDir ) ) ; assertThat ( directoryFileTree . getPatterns ( ) . getIncludes ( ) , equalTo ( includes ) ) ; assertThat ( directoryFileTree . getPatterns ( ) . getExcludes ( ) , equalTo ( excludes ) ) ; } @org.junit.Test public void testIncludes ( ) { assertSame ( test , test . include ( TEST_PATTERN_1 , TEST_PATTERN_2 ) ) ; assertEquals ( toLinkedSet ( TEST_PATTERN_1 , TEST_PATTERN_2 ) , test . getIncludes ( ) ) ; test . include ( TEST_PATTERN_3 ) ; assertEquals ( toLinkedSet ( TEST_PATTERN_1 , TEST_PATTERN_2 , TEST_PATTERN_3 ) , test . getIncludes ( ) ) ; } @org.junit.Test public void testExcludes ( ) { assertSame ( test , test . exclude ( TEST_PATTERN_1 , TEST_PATTERN_2 ) ) ; assertEquals ( toLinkedSet ( TEST_PATTERN_1 , TEST_PATTERN_2 ) , test . getExcludes ( ) ) ; test . exclude ( TEST_PATTERN_3 ) ; assertEquals ( toLinkedSet ( TEST_PATTERN_1 , TEST_PATTERN_2 , TEST_PATTERN_3 ) , test . getExcludes ( ) ) ; } private void expectTestsExecuted ( ) { context . checking ( new Expectations ( ) { { one ( testExecuterMock ) . execute ( with ( sameInstance ( test ) ) , with ( notNullValue ( TestResultProcessor . class ) ) ) ; } } ) ; } private void expectTestsFail ( ) { context . checking ( new Expectations ( ) { { final TestResult result = context . mock ( TestResult . class ) ; allowing ( result ) . getResultType ( ) ; will ( returnValue ( TestResult . ResultType . FAILURE ) ) ; ignoring ( result ) ; final TestDescriptorInternal testDescriptor = context . mock ( TestDescriptorInternal . class ) ; allowing ( testDescriptor ) . getName ( ) ; will ( returnValue ( <str> ) ) ; allowing ( testDescriptor ) . getParent ( ) ; will ( returnValue ( null ) ) ; allowing ( testDescriptor ) . getId ( ) ; will ( returnValue ( <int> ) ) ; ignoring ( testDescriptor ) ; one ( testExecuterMock ) . execute ( with ( sameInstance ( test ) ) , with ( notNullValue ( TestResultProcessor . class ) ) ) ; will ( new Action ( ) { public void describeTo ( Description description ) { description . appendText ( <str> ) ; } public Object invoke ( Invocation invocation ) throws Throwable { return null ; } } ) ; } } ) ; } private void configureTask ( ) { test . useTestFramework ( testFrameworkMock ) ; test . setTestExecuter ( testExecuterMock ) ; test . setTestClassesDir ( classesDir ) ; test . getReports ( ) . getJunitXml ( ) . setDestination ( resultsDir ) ; test . setBinResultsDir ( binResultsDir ) ; test . getReports ( ) . getHtml ( ) . setDestination ( reportDir ) ; test . setClasspath ( classpathMock ) ; test . setTestSrcDirs ( Collections . < File > emptyList ( ) ) ; } } 
