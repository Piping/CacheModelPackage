package org . elasticsearch . action . support . replication ; import com . carrotsearch . hppc . cursors . IntObjectCursor ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ReplicationResponse ; import org . elasticsearch . action . ShardOperationFailedException ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . DefaultShardOperationFailedException ; import org . elasticsearch . action . support . HandledTransportAction ; import org . elasticsearch . action . support . TransportActions ; import org . elasticsearch . action . support . broadcast . BroadcastRequest ; import org . elasticsearch . action . support . broadcast . BroadcastResponse ; import org . elasticsearch . action . support . broadcast . BroadcastShardOperationFailedException ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . CountDown ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . function . Supplier ; public abstract class TransportBroadcastReplicationAction < Request extends BroadcastRequest , Response extends BroadcastResponse , ShardRequest extends ReplicationRequest , ShardResponse extends ReplicationResponse > extends HandledTransportAction < Request , Response > { private final TransportReplicationAction replicatedBroadcastShardAction ; private final ClusterService clusterService ; public TransportBroadcastReplicationAction ( String name , Supplier < Request > request , Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , TransportReplicationAction replicatedBroadcastShardAction ) { super ( settings , name , threadPool , transportService , actionFilters , indexNameExpressionResolver , request ) ; this . replicatedBroadcastShardAction = replicatedBroadcastShardAction ; this . clusterService = clusterService ; } @Override protected void doExecute ( final Request request , final ActionListener < Response > listener ) { final ClusterState clusterState = clusterService . state ( ) ; List < ShardId > shards = shards ( request , clusterState ) ; final CopyOnWriteArrayList < ShardResponse > shardsResponses = new CopyOnWriteArrayList ( ) ; if ( shards . size ( ) = = <int> ) { finishAndNotifyListener ( listener , shardsResponses ) ; } final CountDown responsesCountDown = new CountDown ( shards . size ( ) ) ; for ( final ShardId shardId : shards ) { ActionListener < ShardResponse > shardActionListener = new ActionListener < ShardResponse > ( ) { @Override public void onResponse ( ShardResponse shardResponse ) { shardsResponses . add ( shardResponse ) ; logger . trace ( <str> , actionName , shardId ) ; if ( responsesCountDown . countDown ( ) ) { finishAndNotifyListener ( listener , shardsResponses ) ; } } @Override public void onFailure ( Throwable e ) { logger . trace ( <str> , actionName , shardId ) ; int totalNumCopies = clusterState . getMetaData ( ) . index ( shardId . index ( ) . getName ( ) ) . getNumberOfReplicas ( ) + <int> ; ShardResponse shardResponse = newShardResponse ( ) ; ReplicationResponse . ShardInfo . Failure [ ] failures ; if ( TransportActions . isShardNotAvailableException ( e ) ) { failures = new ReplicationResponse . ShardInfo . Failure [ <int> ] ; } else { ReplicationResponse . ShardInfo . Failure failure = new ReplicationResponse . ShardInfo . Failure ( shardId . index ( ) . name ( ) , shardId . id ( ) , null , e , ExceptionsHelper . status ( e ) , true ) ; failures = new ReplicationResponse . ShardInfo . Failure [ totalNumCopies ] ; Arrays . fill ( failures , failure ) ; } shardResponse . setShardInfo ( new ReplicationResponse . ShardInfo ( totalNumCopies , <int> , failures ) ) ; shardsResponses . add ( shardResponse ) ; if ( responsesCountDown . countDown ( ) ) { finishAndNotifyListener ( listener , shardsResponses ) ; } } } ; shardExecute ( request , shardId , shardActionListener ) ; } } protected void shardExecute ( Request request , ShardId shardId , ActionListener < ShardResponse > shardActionListener ) { replicatedBroadcastShardAction . execute ( newShardRequest ( request , shardId ) , shardActionListener ) ; } protected List < ShardId > shards ( Request request , ClusterState clusterState ) { List < ShardId > shardIds = new ArrayList < > ( ) ; String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( clusterState , request ) ; for ( String index : concreteIndices ) { IndexMetaData indexMetaData = clusterState . metaData ( ) . getIndices ( ) . get ( index ) ; if ( indexMetaData ! = null ) { for ( IntObjectCursor < IndexShardRoutingTable > shardRouting : clusterState . getRoutingTable ( ) . indicesRouting ( ) . get ( index ) . getShards ( ) ) { shardIds . add ( shardRouting . value . shardId ( ) ) ; } } } return shardIds ; } protected abstract ShardResponse newShardResponse ( ) ; protected abstract ShardRequest newShardRequest ( Request request , ShardId shardId ) ; private void finishAndNotifyListener ( ActionListener listener , CopyOnWriteArrayList < ShardResponse > shardsResponses ) { logger . trace ( <str> , actionName ) ; int successfulShards = <int> ; int failedShards = <int> ; int totalNumCopies = <int> ; List < ShardOperationFailedException > shardFailures = null ; for ( int i = <int> ; i < shardsResponses . size ( ) ; i + + ) { ReplicationResponse shardResponse = shardsResponses . get ( i ) ; if ( shardResponse = = null ) { } else { failedShards + = shardResponse . getShardInfo ( ) . getFailed ( ) ; successfulShards + = shardResponse . getShardInfo ( ) . getSuccessful ( ) ; totalNumCopies + = shardResponse . getShardInfo ( ) . getTotal ( ) ; if ( shardFailures = = null ) { shardFailures = new ArrayList < > ( ) ; } for ( ReplicationResponse . ShardInfo . Failure failure : shardResponse . getShardInfo ( ) . getFailures ( ) ) { shardFailures . add ( new DefaultShardOperationFailedException ( new BroadcastShardOperationFailedException ( new ShardId ( failure . index ( ) , failure . shardId ( ) ) , failure . getCause ( ) ) ) ) ; } } } listener . onResponse ( newResponse ( successfulShards , failedShards , totalNumCopies , shardFailures ) ) ; } protected abstract BroadcastResponse newResponse ( int successfulShards , int failedShards , int totalNumCopies , List < ShardOperationFailedException > shardFailures ) ; } 
