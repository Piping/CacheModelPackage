package org . apache . cassandra . transport ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import org . junit . Test ; import io . netty . buffer . ByteBuf ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . db . marshal . LongType ; import static org . junit . Assert . assertEquals ; public class DataTypeTest { @Test public void TestSimpleDataTypeSerialization ( ) { for ( DataType type : DataType . values ( ) ) { if ( isComplexType ( type ) ) continue ; Map < DataType , Object > options = Collections . singletonMap ( type , ( Object ) type . toString ( ) ) ; for ( int version = <int> ; version < <int> ; version + + ) testEncodeDecode ( type , options , version ) ; } } @Test public void TestListDataTypeSerialization ( ) { DataType type = DataType . LIST ; Map < DataType , Object > options = Collections . singletonMap ( type , ( Object ) LongType . instance ) ; for ( int version = <int> ; version < <int> ; version + + ) testEncodeDecode ( type , options , version ) ; } @Test public void TestMapDataTypeSerialization ( ) { DataType type = DataType . MAP ; List < AbstractType > value = new ArrayList < > ( ) ; value . add ( LongType . instance ) ; value . add ( AsciiType . instance ) ; Map < DataType , Object > options = Collections . singletonMap ( type , ( Object ) value ) ; for ( int version = <int> ; version < <int> ; version + + ) testEncodeDecode ( type , options , version ) ; } private void testEncodeDecode ( DataType type , Map < DataType , Object > options , int version ) { ByteBuf dest = type . codec . encode ( options , version ) ; Map < DataType , Object > results = type . codec . decode ( dest , version ) ; for ( DataType key : results . keySet ( ) ) { int ssize = type . serializedValueSize ( results . get ( key ) , version ) ; int esize = version < type . getProtocolVersion ( ) ? <int> + TypeSizes . encodedUTF8Length ( results . get ( key ) . toString ( ) ) : <int> ; switch ( type ) { case LIST : case SET : esize + = <int> ; break ; case MAP : esize + = <int> ; break ; case CUSTOM : esize = <int> ; break ; } assertEquals ( esize , ssize ) ; DataType expected = version < type . getProtocolVersion ( ) ? DataType . CUSTOM : type ; assertEquals ( expected , key ) ; } } private boolean isComplexType ( DataType type ) { return type . getId ( Server . CURRENT_VERSION ) > = <int> ; } } 
