package com . google . common . util . concurrent ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . TestLogHandler ; import com . google . common . util . concurrent . Service . State ; import com . google . common . util . concurrent . ServiceManager . Listener ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executor ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . logging . Formatter ; import java . util . logging . Level ; import java . util . logging . LogRecord ; import java . util . logging . Logger ; public class ServiceManagerTest extends TestCase { private static class NoOpService extends AbstractService { @Override protected void doStart ( ) { notifyStarted ( ) ; } @Override protected void doStop ( ) { notifyStopped ( ) ; } } private static class NoOpDelayedService extends NoOpService { private long delay ; public NoOpDelayedService ( long delay ) { this . delay = delay ; } @Override protected void doStart ( ) { new Thread ( ) { @Override public void run ( ) { Uninterruptibles . sleepUninterruptibly ( delay , TimeUnit . MILLISECONDS ) ; notifyStarted ( ) ; } } . start ( ) ; } @Override protected void doStop ( ) { new Thread ( ) { @Override public void run ( ) { Uninterruptibles . sleepUninterruptibly ( delay , TimeUnit . MILLISECONDS ) ; notifyStopped ( ) ; } } . start ( ) ; } } private static class FailStartService extends NoOpService { @Override protected void doStart ( ) { notifyFailed ( new IllegalStateException ( <str> ) ) ; } } private static class FailRunService extends NoOpService { @Override protected void doStart ( ) { super . doStart ( ) ; notifyFailed ( new IllegalStateException ( <str> ) ) ; } } private static class FailStopService extends NoOpService { @Override protected void doStop ( ) { notifyFailed ( new IllegalStateException ( <str> ) ) ; } } public void testServiceStartupTimes ( ) { Service a = new NoOpDelayedService ( <int> ) ; Service b = new NoOpDelayedService ( <int> ) ; ServiceManager serviceManager = new ServiceManager ( asList ( a , b ) ) ; serviceManager . startAsync ( ) . awaitHealthy ( ) ; ImmutableMap < Service , Long > startupTimes = serviceManager . startupTimes ( ) ; assertEquals ( <int> , startupTimes . size ( ) ) ; assertTrue ( startupTimes . get ( a ) > = <int> ) ; assertTrue ( startupTimes . get ( b ) > = <int> ) ; } public void testServiceStartupTimes_selfStartingServices ( ) { final Service b = new NoOpDelayedService ( <int> ) { @Override protected void doStart ( ) { super . doStart ( ) ; Uninterruptibles . sleepUninterruptibly ( <int> , TimeUnit . MILLISECONDS ) ; } } ; Service a = new NoOpDelayedService ( <int> ) { @Override protected void doStart ( ) { b . startAsync ( ) ; super . doStart ( ) ; } } ; ServiceManager serviceManager = new ServiceManager ( asList ( a , b ) ) ; serviceManager . startAsync ( ) . awaitHealthy ( ) ; ImmutableMap < Service , Long > startupTimes = serviceManager . startupTimes ( ) ; assertEquals ( <int> , startupTimes . size ( ) ) ; assertTrue ( startupTimes . get ( a ) > = <int> ) ; assertThat ( startupTimes . get ( b ) ) . isNotNull ( ) ; } public void testServiceStartStop ( ) { Service a = new NoOpService ( ) ; Service b = new NoOpService ( ) ; ServiceManager manager = new ServiceManager ( asList ( a , b ) ) ; RecordingListener listener = new RecordingListener ( ) ; manager . addListener ( listener ) ; assertState ( manager , Service . State . NEW , a , b ) ; assertFalse ( manager . isHealthy ( ) ) ; manager . startAsync ( ) . awaitHealthy ( ) ; assertState ( manager , Service . State . RUNNING , a , b ) ; assertTrue ( manager . isHealthy ( ) ) ; assertTrue ( listener . healthyCalled ) ; assertFalse ( listener . stoppedCalled ) ; assertTrue ( listener . failedServices . isEmpty ( ) ) ; manager . stopAsync ( ) . awaitStopped ( ) ; assertState ( manager , Service . State . TERMINATED , a , b ) ; assertFalse ( manager . isHealthy ( ) ) ; assertTrue ( listener . stoppedCalled ) ; assertTrue ( listener . failedServices . isEmpty ( ) ) ; } public void testFailStart ( ) throws Exception { Service a = new NoOpService ( ) ; Service b = new FailStartService ( ) ; Service c = new NoOpService ( ) ; Service d = new FailStartService ( ) ; Service e = new NoOpService ( ) ; ServiceManager manager = new ServiceManager ( asList ( a , b , c , d , e ) ) ; RecordingListener listener = new RecordingListener ( ) ; manager . addListener ( listener ) ; assertState ( manager , Service . State . NEW , a , b , c , d , e ) ; try { manager . startAsync ( ) . awaitHealthy ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } assertFalse ( listener . healthyCalled ) ; assertState ( manager , Service . State . RUNNING , a , c , e ) ; assertEquals ( ImmutableSet . of ( b , d ) , listener . failedServices ) ; assertState ( manager , Service . State . FAILED , b , d ) ; assertFalse ( manager . isHealthy ( ) ) ; manager . stopAsync ( ) . awaitStopped ( ) ; assertFalse ( manager . isHealthy ( ) ) ; assertFalse ( listener . healthyCalled ) ; assertTrue ( listener . stoppedCalled ) ; } public void testFailRun ( ) throws Exception { Service a = new NoOpService ( ) ; Service b = new FailRunService ( ) ; ServiceManager manager = new ServiceManager ( asList ( a , b ) ) ; RecordingListener listener = new RecordingListener ( ) ; manager . addListener ( listener ) ; assertState ( manager , Service . State . NEW , a , b ) ; try { manager . startAsync ( ) . awaitHealthy ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } assertTrue ( listener . healthyCalled ) ; assertEquals ( ImmutableSet . of ( b ) , listener . failedServices ) ; manager . stopAsync ( ) . awaitStopped ( ) ; assertState ( manager , Service . State . FAILED , b ) ; assertState ( manager , Service . State . TERMINATED , a ) ; assertTrue ( listener . stoppedCalled ) ; } public void testFailStop ( ) throws Exception { Service a = new NoOpService ( ) ; Service b = new FailStopService ( ) ; Service c = new NoOpService ( ) ; ServiceManager manager = new ServiceManager ( asList ( a , b , c ) ) ; RecordingListener listener = new RecordingListener ( ) ; manager . addListener ( listener ) ; manager . startAsync ( ) . awaitHealthy ( ) ; assertTrue ( listener . healthyCalled ) ; assertFalse ( listener . stoppedCalled ) ; manager . stopAsync ( ) . awaitStopped ( ) ; assertTrue ( listener . stoppedCalled ) ; assertEquals ( ImmutableSet . of ( b ) , listener . failedServices ) ; assertState ( manager , Service . State . FAILED , b ) ; assertState ( manager , Service . State . TERMINATED , a , c ) ; } public void testToString ( ) throws Exception { Service a = new NoOpService ( ) ; Service b = new FailStartService ( ) ; ServiceManager manager = new ServiceManager ( asList ( a , b ) ) ; String toString = manager . toString ( ) ; assertThat ( toString ) . contains ( <str> ) ; assertThat ( toString ) . contains ( <str> ) ; } public void testTimeouts ( ) throws Exception { Service a = new NoOpDelayedService ( <int> ) ; ServiceManager manager = new ServiceManager ( asList ( a ) ) ; manager . startAsync ( ) ; try { manager . awaitHealthy ( <int> , TimeUnit . MILLISECONDS ) ; fail ( ) ; } catch ( TimeoutException expected ) { } manager . awaitHealthy ( <int> , TimeUnit . MILLISECONDS ) ; manager . stopAsync ( ) ; try { manager . awaitStopped ( <int> , TimeUnit . MILLISECONDS ) ; fail ( ) ; } catch ( TimeoutException expected ) { } manager . awaitStopped ( <int> , TimeUnit . MILLISECONDS ) ; } public void testSingleFailedServiceCallsStopped ( ) { Service a = new FailStartService ( ) ; ServiceManager manager = new ServiceManager ( asList ( a ) ) ; RecordingListener listener = new RecordingListener ( ) ; manager . addListener ( listener ) ; try { manager . startAsync ( ) . awaitHealthy ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } assertTrue ( listener . stoppedCalled ) ; } public void testFailStart_singleServiceCallsHealthy ( ) { Service a = new FailStartService ( ) ; ServiceManager manager = new ServiceManager ( asList ( a ) ) ; RecordingListener listener = new RecordingListener ( ) ; manager . addListener ( listener ) ; try { manager . startAsync ( ) . awaitHealthy ( ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } assertFalse ( listener . healthyCalled ) ; } public void testFailStart_stopOthers ( ) throws TimeoutException { Service a = new FailStartService ( ) ; Service b = new NoOpService ( ) ; final ServiceManager manager = new ServiceManager ( asList ( a , b ) ) ; manager . addListener ( new Listener ( ) { @Override public void failure ( Service service ) { manager . stopAsync ( ) ; } } ) ; manager . startAsync ( ) ; manager . awaitStopped ( <int> , TimeUnit . MILLISECONDS ) ; } private static void assertState ( ServiceManager manager , Service . State state , Service . . . services ) { Collection < Service > managerServices = manager . servicesByState ( ) . get ( state ) ; for ( Service service : services ) { assertEquals ( service . toString ( ) , state , service . state ( ) ) ; assertEquals ( service . toString ( ) , service . isRunning ( ) , state = = Service . State . RUNNING ) ; assertTrue ( managerServices + <str> + service , managerServices . contains ( service ) ) ; } } public void testEmptyServiceManager ( ) { Logger logger = Logger . getLogger ( ServiceManager . class . getName ( ) ) ; logger . setLevel ( Level . FINEST ) ; TestLogHandler logHandler = new TestLogHandler ( ) ; logger . addHandler ( logHandler ) ; ServiceManager manager = new ServiceManager ( Arrays . < Service > asList ( ) ) ; RecordingListener listener = new RecordingListener ( ) ; manager . addListener ( listener ) ; manager . startAsync ( ) . awaitHealthy ( ) ; assertTrue ( manager . isHealthy ( ) ) ; assertTrue ( listener . healthyCalled ) ; assertFalse ( listener . stoppedCalled ) ; assertTrue ( listener . failedServices . isEmpty ( ) ) ; manager . stopAsync ( ) . awaitStopped ( ) ; assertFalse ( manager . isHealthy ( ) ) ; assertTrue ( listener . stoppedCalled ) ; assertTrue ( listener . failedServices . isEmpty ( ) ) ; assertEquals ( <str> , manager . toString ( ) ) ; assertTrue ( manager . servicesByState ( ) . isEmpty ( ) ) ; assertTrue ( manager . startupTimes ( ) . isEmpty ( ) ) ; Formatter logFormatter = new Formatter ( ) { @Override public String format ( LogRecord record ) { return formatMessage ( record ) ; } } ; for ( LogRecord record : logHandler . getStoredLogRecords ( ) ) { assertThat ( logFormatter . format ( record ) ) . doesNotContain ( <str> ) ; } } public void testListenerDeadlock ( ) throws InterruptedException { final CountDownLatch failEnter = new CountDownLatch ( <int> ) ; final CountDownLatch failLeave = new CountDownLatch ( <int> ) ; final CountDownLatch afterStarted = new CountDownLatch ( <int> ) ; Service failRunService = new AbstractService ( ) { @Override protected void doStart ( ) { new Thread ( ) { @Override public void run ( ) { notifyStarted ( ) ; Uninterruptibles . awaitUninterruptibly ( afterStarted ) ; notifyFailed ( new Exception ( <str> ) ) ; } } . start ( ) ; } @Override protected void doStop ( ) { notifyStopped ( ) ; } } ; final ServiceManager manager = new ServiceManager ( Arrays . asList ( failRunService , new NoOpService ( ) ) ) ; manager . addListener ( new ServiceManager . Listener ( ) { @Override public void failure ( Service service ) { failEnter . countDown ( ) ; Uninterruptibles . awaitUninterruptibly ( failLeave ) ; } } ) ; manager . startAsync ( ) ; afterStarted . countDown ( ) ; failEnter . await ( ) ; assertFalse ( <str> , manager . isHealthy ( ) ) ; Thread stoppingThread = new Thread ( ) { @Override public void run ( ) { manager . stopAsync ( ) . awaitStopped ( ) ; } } ; stoppingThread . start ( ) ; stoppingThread . join ( <int> ) ; assertFalse ( <str> , stoppingThread . isAlive ( ) ) ; failLeave . countDown ( ) ; } public void testPartiallyConstructedManager ( ) { Logger logger = Logger . getLogger ( <str> ) ; logger . setLevel ( Level . FINEST ) ; TestLogHandler logHandler = new TestLogHandler ( ) ; logger . addHandler ( logHandler ) ; NoOpService service = new NoOpService ( ) ; service . startAsync ( ) ; try { new ServiceManager ( Arrays . asList ( service ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } service . stopAsync ( ) ; assertEquals ( <int> , logHandler . getStoredLogRecords ( ) . size ( ) ) ; } public void testPartiallyConstructedManager_transitionAfterAddListenerBeforeStateIsReady ( ) { final NoOpService service1 = new NoOpService ( ) ; Service service2 = new Service ( ) { final NoOpService delegate = new NoOpService ( ) ; @Override public final void addListener ( Listener listener , Executor executor ) { service1 . startAsync ( ) ; delegate . addListener ( listener , executor ) ; } @Override public final Service startAsync ( ) { return delegate . startAsync ( ) ; } @Override public final Service stopAsync ( ) { return delegate . stopAsync ( ) ; } @Override public final void awaitRunning ( ) { delegate . awaitRunning ( ) ; } @Override public final void awaitRunning ( long timeout , TimeUnit unit ) throws TimeoutException { delegate . awaitRunning ( timeout , unit ) ; } @Override public final void awaitTerminated ( ) { delegate . awaitTerminated ( ) ; } @Override public final void awaitTerminated ( long timeout , TimeUnit unit ) throws TimeoutException { delegate . awaitTerminated ( timeout , unit ) ; } @Override public final boolean isRunning ( ) { return delegate . isRunning ( ) ; } @Override public final State state ( ) { return delegate . state ( ) ; } @Override public final Throwable failureCause ( ) { return delegate . failureCause ( ) ; } } ; try { new ServiceManager ( Arrays . asList ( service1 , service2 ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { assertThat ( expected . getMessage ( ) ) . contains ( <str> ) ; } } public void testTransitionRace ( ) throws TimeoutException { for ( int k = <int> ; k < <int> ; k + + ) { List < Service > services = Lists . newArrayList ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { services . add ( new SnappyShutdownService ( i ) ) ; } ServiceManager manager = new ServiceManager ( services ) ; manager . startAsync ( ) . awaitHealthy ( ) ; manager . stopAsync ( ) . awaitStopped ( <int> , TimeUnit . SECONDS ) ; } } private static class SnappyShutdownService extends AbstractExecutionThreadService { final int index ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; SnappyShutdownService ( int index ) { this . index = index ; } @Override protected void run ( ) throws Exception { latch . await ( ) ; } @Override protected void triggerShutdown ( ) { latch . countDown ( ) ; } @Override protected String serviceName ( ) { return this . getClass ( ) . getSimpleName ( ) + <str> + index + <str> ; } } public void testNulls ( ) { ServiceManager manager = new ServiceManager ( Arrays . < Service > asList ( ) ) ; new NullPointerTester ( ) . setDefault ( ServiceManager . Listener . class , new RecordingListener ( ) ) . testAllPublicInstanceMethods ( manager ) ; } private static final class RecordingListener extends ServiceManager . Listener { volatile boolean healthyCalled ; volatile boolean stoppedCalled ; final Set < Service > failedServices = Sets . newConcurrentHashSet ( ) ; @Override public void healthy ( ) { healthyCalled = true ; } @Override public void stopped ( ) { stoppedCalled = true ; } @Override public void failure ( Service service ) { failedServices . add ( service ) ; } } } 
