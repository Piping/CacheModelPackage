package com . google . common . collect ; import static com . google . common . collect . BoundType . OPEN ; import static com . google . common . collect . testing . Helpers . mapEntry ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . MapTestSuiteBuilder ; import com . google . common . collect . testing . SampleElements ; import com . google . common . collect . testing . TestMapGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . NoSuchElementException ; @GwtIncompatible ( <str> ) public class TreeRangeMapTest extends TestCase { public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( TreeRangeMapTest . class ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestMapGenerator < Range < Integer > , String > ( ) { @Override public SampleElements < Entry < Range < Integer > , String > > samples ( ) { return new SampleElements < Entry < Range < Integer > , String > > ( mapEntry ( Range . singleton ( <int> ) , <str> ) , mapEntry ( Range . closedOpen ( <int> , <int> ) , <str> ) , mapEntry ( Range . atMost ( - <int> ) , <str> ) , mapEntry ( Range . open ( <int> , <int> ) , <str> ) , mapEntry ( Range . closed ( <int> , <int> ) , <str> ) ) ; } @Override public Map < Range < Integer > , String > create ( Object . . . elements ) { RangeMap < Integer , String > rangeMap = TreeRangeMap . create ( ) ; for ( Object o : elements ) { @SuppressWarnings ( <str> ) Entry < Range < Integer > , String > entry = ( Entry < Range < Integer > , String > ) o ; rangeMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return rangeMap . asMapOfRanges ( ) ; } @SuppressWarnings ( <str> ) @Override public Entry < Range < Integer > , String > [ ] createArray ( int length ) { return new Entry [ length ] ; } @Override public Iterable < Entry < Range < Integer > , String > > order ( List < Entry < Range < Integer > , String > > insertionOrder ) { return Range . RANGE_LEX_ORDERING . < Range < Integer > > onKeys ( ) . sortedCopy ( insertionOrder ) ; } @SuppressWarnings ( <str> ) @Override public Range < Integer > [ ] createKeyArray ( int length ) { return new Range [ length ] ; } @Override public String [ ] createValueArray ( int length ) { return new String [ length ] ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , MapFeature . SUPPORTS_REMOVE , MapFeature . ALLOWS_ANY_NULL_QUERIES , CollectionFeature . KNOWN_ORDER , CollectionFeature . SUPPORTS_ITERATOR_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestMapGenerator < Range < Integer > , String > ( ) { @Override public SampleElements < Entry < Range < Integer > , String > > samples ( ) { return new SampleElements < Entry < Range < Integer > , String > > ( mapEntry ( Range . singleton ( <int> ) , <str> ) , mapEntry ( Range . closedOpen ( <int> , <int> ) , <str> ) , mapEntry ( Range . atMost ( - <int> ) , <str> ) , mapEntry ( Range . open ( <int> , <int> ) , <str> ) , mapEntry ( Range . closed ( <int> , <int> ) , <str> ) ) ; } @Override public Map < Range < Integer > , String > create ( Object . . . elements ) { RangeMap < Integer , String > rangeMap = TreeRangeMap . create ( ) ; for ( Object o : elements ) { @SuppressWarnings ( <str> ) Entry < Range < Integer > , String > entry = ( Entry < Range < Integer > , String > ) o ; rangeMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return rangeMap . subRangeMap ( Range . atMost ( <int> ) ) . asMapOfRanges ( ) ; } @SuppressWarnings ( <str> ) @Override public Entry < Range < Integer > , String > [ ] createArray ( int length ) { return new Entry [ length ] ; } @Override public Iterable < Entry < Range < Integer > , String > > order ( List < Entry < Range < Integer > , String > > insertionOrder ) { return Range . RANGE_LEX_ORDERING . < Range < Integer > > onKeys ( ) . sortedCopy ( insertionOrder ) ; } @SuppressWarnings ( <str> ) @Override public Range < Integer > [ ] createKeyArray ( int length ) { return new Range [ length ] ; } @Override public String [ ] createValueArray ( int length ) { return new String [ length ] ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , MapFeature . SUPPORTS_REMOVE , MapFeature . ALLOWS_ANY_NULL_QUERIES , CollectionFeature . KNOWN_ORDER ) . createTestSuite ( ) ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestMapGenerator < Range < Integer > , String > ( ) { @Override public SampleElements < Entry < Range < Integer > , String > > samples ( ) { return new SampleElements < Entry < Range < Integer > , String > > ( mapEntry ( Range . singleton ( <int> ) , <str> ) , mapEntry ( Range . closedOpen ( <int> , <int> ) , <str> ) , mapEntry ( Range . atMost ( - <int> ) , <str> ) , mapEntry ( Range . open ( <int> , <int> ) , <str> ) , mapEntry ( Range . closed ( <int> , <int> ) , <str> ) ) ; } @Override public Map < Range < Integer > , String > create ( Object . . . elements ) { RangeMap < Integer , String > rangeMap = TreeRangeMap . create ( ) ; for ( Object o : elements ) { @SuppressWarnings ( <str> ) Entry < Range < Integer > , String > entry = ( Entry < Range < Integer > , String > ) o ; rangeMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return rangeMap . asDescendingMapOfRanges ( ) ; } @SuppressWarnings ( <str> ) @Override public Entry < Range < Integer > , String > [ ] createArray ( int length ) { return new Entry [ length ] ; } @Override public Iterable < Entry < Range < Integer > , String > > order ( List < Entry < Range < Integer > , String > > insertionOrder ) { return Range . RANGE_LEX_ORDERING . reverse ( ) . < Range < Integer > > onKeys ( ) . sortedCopy ( insertionOrder ) ; } @SuppressWarnings ( <str> ) @Override public Range < Integer > [ ] createKeyArray ( int length ) { return new Range [ length ] ; } @Override public String [ ] createValueArray ( int length ) { return new String [ length ] ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , MapFeature . SUPPORTS_REMOVE , MapFeature . ALLOWS_ANY_NULL_QUERIES , CollectionFeature . KNOWN_ORDER , CollectionFeature . SUPPORTS_ITERATOR_REMOVE ) . createTestSuite ( ) ) ; suite . addTest ( MapTestSuiteBuilder . using ( new TestMapGenerator < Range < Integer > , String > ( ) { @Override public SampleElements < Entry < Range < Integer > , String > > samples ( ) { return new SampleElements < Entry < Range < Integer > , String > > ( mapEntry ( Range . singleton ( <int> ) , <str> ) , mapEntry ( Range . closedOpen ( <int> , <int> ) , <str> ) , mapEntry ( Range . atMost ( - <int> ) , <str> ) , mapEntry ( Range . open ( <int> , <int> ) , <str> ) , mapEntry ( Range . closed ( <int> , <int> ) , <str> ) ) ; } @Override public Map < Range < Integer > , String > create ( Object . . . elements ) { RangeMap < Integer , String > rangeMap = TreeRangeMap . create ( ) ; for ( Object o : elements ) { @SuppressWarnings ( <str> ) Entry < Range < Integer > , String > entry = ( Entry < Range < Integer > , String > ) o ; rangeMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return rangeMap . subRangeMap ( Range . atMost ( <int> ) ) . asDescendingMapOfRanges ( ) ; } @SuppressWarnings ( <str> ) @Override public Entry < Range < Integer > , String > [ ] createArray ( int length ) { return new Entry [ length ] ; } @Override public Iterable < Entry < Range < Integer > , String > > order ( List < Entry < Range < Integer > , String > > insertionOrder ) { return Range . RANGE_LEX_ORDERING . reverse ( ) . < Range < Integer > > onKeys ( ) . sortedCopy ( insertionOrder ) ; } @SuppressWarnings ( <str> ) @Override public Range < Integer > [ ] createKeyArray ( int length ) { return new Range [ length ] ; } @Override public String [ ] createValueArray ( int length ) { return new String [ length ] ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , MapFeature . SUPPORTS_REMOVE , MapFeature . ALLOWS_ANY_NULL_QUERIES , CollectionFeature . KNOWN_ORDER ) . createTestSuite ( ) ) ; return suite ; } private static final ImmutableList < Range < Integer > > RANGES ; private static final int MIN_BOUND = - <int> ; private static final int MAX_BOUND = <int> ; static { ImmutableList . Builder < Range < Integer > > builder = ImmutableList . builder ( ) ; builder . add ( Range . < Integer > all ( ) ) ; for ( int i = MIN_BOUND ; i < = MAX_BOUND ; i + + ) { for ( BoundType type : BoundType . values ( ) ) { builder . add ( Range . upTo ( i , type ) ) ; builder . add ( Range . downTo ( i , type ) ) ; } } for ( int i = MIN_BOUND ; i < = MAX_BOUND ; i + + ) { for ( int j = i ; j < = MAX_BOUND ; j + + ) { for ( BoundType lowerType : BoundType . values ( ) ) { for ( BoundType upperType : BoundType . values ( ) ) { if ( i = = j & lowerType = = OPEN & upperType = = OPEN ) { continue ; } builder . add ( Range . range ( i , lowerType , j , upperType ) ) ; } } } } RANGES = builder . build ( ) ; } public void testSpanSingleRange ( ) { for ( Range < Integer > range : RANGES ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( range , <int> ) ; try { assertEquals ( range , rangeMap . span ( ) ) ; assertFalse ( range . isEmpty ( ) ) ; } catch ( NoSuchElementException e ) { assertTrue ( range . isEmpty ( ) ) ; } } } public void testSpanTwoRanges ( ) { for ( Range < Integer > range1 : RANGES ) { for ( Range < Integer > range2 : RANGES ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( range1 , <int> ) ; rangeMap . put ( range2 , <int> ) ; Range < Integer > expected ; if ( range1 . isEmpty ( ) ) { if ( range2 . isEmpty ( ) ) { expected = null ; } else { expected = range2 ; } } else { if ( range2 . isEmpty ( ) ) { expected = range1 ; } else { expected = range1 . span ( range2 ) ; } } try { assertEquals ( expected , rangeMap . span ( ) ) ; assertNotNull ( expected ) ; } catch ( NoSuchElementException e ) { assertNull ( expected ) ; } } } } public void testAllRangesAlone ( ) { for ( Range < Integer > range : RANGES ) { Map < Integer , Integer > model = Maps . newHashMap ( ) ; putModel ( model , range , <int> ) ; RangeMap < Integer , Integer > test = TreeRangeMap . create ( ) ; test . put ( range , <int> ) ; verify ( model , test ) ; } } public void testAllRangePairs ( ) { for ( Range < Integer > range1 : RANGES ) { for ( Range < Integer > range2 : RANGES ) { Map < Integer , Integer > model = Maps . newHashMap ( ) ; putModel ( model , range1 , <int> ) ; putModel ( model , range2 , <int> ) ; RangeMap < Integer , Integer > test = TreeRangeMap . create ( ) ; test . put ( range1 , <int> ) ; test . put ( range2 , <int> ) ; verify ( model , test ) ; } } } public void testAllRangeTriples ( ) { for ( Range < Integer > range1 : RANGES ) { for ( Range < Integer > range2 : RANGES ) { for ( Range < Integer > range3 : RANGES ) { Map < Integer , Integer > model = Maps . newHashMap ( ) ; putModel ( model , range1 , <int> ) ; putModel ( model , range2 , <int> ) ; putModel ( model , range3 , <int> ) ; RangeMap < Integer , Integer > test = TreeRangeMap . create ( ) ; test . put ( range1 , <int> ) ; test . put ( range2 , <int> ) ; test . put ( range3 , <int> ) ; verify ( model , test ) ; } } } } public void testPutAll ( ) { for ( Range < Integer > range1 : RANGES ) { for ( Range < Integer > range2 : RANGES ) { for ( Range < Integer > range3 : RANGES ) { Map < Integer , Integer > model = Maps . newHashMap ( ) ; putModel ( model , range1 , <int> ) ; putModel ( model , range2 , <int> ) ; putModel ( model , range3 , <int> ) ; RangeMap < Integer , Integer > test = TreeRangeMap . create ( ) ; RangeMap < Integer , Integer > test2 = TreeRangeMap . create ( ) ; test . put ( range1 , <int> ) ; test2 . put ( range2 , <int> ) ; test2 . put ( range3 , <int> ) ; test . putAll ( test2 ) ; verify ( model , test ) ; } } } } public void testPutAndRemove ( ) { for ( Range < Integer > rangeToPut : RANGES ) { for ( Range < Integer > rangeToRemove : RANGES ) { Map < Integer , Integer > model = Maps . newHashMap ( ) ; putModel ( model , rangeToPut , <int> ) ; removeModel ( model , rangeToRemove ) ; RangeMap < Integer , Integer > test = TreeRangeMap . create ( ) ; test . put ( rangeToPut , <int> ) ; test . remove ( rangeToRemove ) ; verify ( model , test ) ; } } } public void testPutTwoAndRemove ( ) { for ( Range < Integer > rangeToPut1 : RANGES ) { for ( Range < Integer > rangeToPut2 : RANGES ) { for ( Range < Integer > rangeToRemove : RANGES ) { Map < Integer , Integer > model = Maps . newHashMap ( ) ; putModel ( model , rangeToPut1 , <int> ) ; putModel ( model , rangeToPut2 , <int> ) ; removeModel ( model , rangeToRemove ) ; RangeMap < Integer , Integer > test = TreeRangeMap . create ( ) ; test . put ( rangeToPut1 , <int> ) ; test . put ( rangeToPut2 , <int> ) ; test . remove ( rangeToRemove ) ; verify ( model , test ) ; } } } } public void testSubRangeMapExhaustive ( ) { for ( Range < Integer > range1 : RANGES ) { for ( Range < Integer > range2 : RANGES ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( range1 , <int> ) ; rangeMap . put ( range2 , <int> ) ; for ( Range < Integer > subRange : RANGES ) { RangeMap < Integer , Integer > expected = TreeRangeMap . create ( ) ; for ( Map . Entry < Range < Integer > , Integer > entry : rangeMap . asMapOfRanges ( ) . entrySet ( ) ) { if ( entry . getKey ( ) . isConnected ( subRange ) ) { expected . put ( entry . getKey ( ) . intersection ( subRange ) , entry . getValue ( ) ) ; } } RangeMap < Integer , Integer > subRangeMap = rangeMap . subRangeMap ( subRange ) ; assertEquals ( expected , subRangeMap ) ; assertEquals ( expected . asMapOfRanges ( ) , subRangeMap . asMapOfRanges ( ) ) ; assertEquals ( expected . asDescendingMapOfRanges ( ) , subRangeMap . asDescendingMapOfRanges ( ) ) ; assertEquals ( ImmutableList . copyOf ( subRangeMap . asMapOfRanges ( ) . entrySet ( ) ) . reverse ( ) , ImmutableList . copyOf ( subRangeMap . asDescendingMapOfRanges ( ) . entrySet ( ) ) ) ; if ( ! expected . asMapOfRanges ( ) . isEmpty ( ) ) { assertEquals ( expected . span ( ) , subRangeMap . span ( ) ) ; } for ( int i = MIN_BOUND ; i < = MAX_BOUND ; i + + ) { assertEquals ( expected . get ( i ) , subRangeMap . get ( i ) ) ; } for ( Range < Integer > query : RANGES ) { assertEquals ( expected . asMapOfRanges ( ) . get ( query ) , subRangeMap . asMapOfRanges ( ) . get ( query ) ) ; } } } } } public void testSubSubRangeMap ( ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( Range . open ( <int> , <int> ) , <int> ) ; rangeMap . put ( Range . closed ( <int> , <int> ) , <int> ) ; rangeMap . put ( Range . closed ( <int> , <int> ) , <int> ) ; RangeMap < Integer , Integer > sub1 = rangeMap . subRangeMap ( Range . closed ( <int> , <int> ) ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , sub1 . asMapOfRanges ( ) ) ; RangeMap < Integer , Integer > sub2 = sub1 . subRangeMap ( Range . open ( <int> , <int> ) ) ; assertEquals ( ImmutableMap . of ( Range . open ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , sub2 . asMapOfRanges ( ) ) ; } public void testSubRangeMapPut ( ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( Range . open ( <int> , <int> ) , <int> ) ; rangeMap . put ( Range . closed ( <int> , <int> ) , <int> ) ; rangeMap . put ( Range . closed ( <int> , <int> ) , <int> ) ; RangeMap < Integer , Integer > sub = rangeMap . subRangeMap ( Range . closed ( <int> , <int> ) ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , sub . asMapOfRanges ( ) ) ; sub . put ( Range . closed ( <int> , <int> ) , <int> ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> , Range . openClosed ( <int> , <int> ) , <int> ) , sub . asMapOfRanges ( ) ) ; assertEquals ( ImmutableMap . of ( Range . open ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> , Range . openClosed ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , rangeMap . asMapOfRanges ( ) ) ; try { sub . put ( Range . open ( <int> , <int> ) , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } sub = sub . subRangeMap ( Range . closedOpen ( <int> , <int> ) ) ; sub . put ( Range . closedOpen ( <int> , <int> ) , <int> ) ; assertEquals ( ImmutableMap . of ( Range . open ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> , Range . openClosed ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , rangeMap . asMapOfRanges ( ) ) ; } public void testSubRangeMapRemove ( ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( Range . open ( <int> , <int> ) , <int> ) ; rangeMap . put ( Range . closed ( <int> , <int> ) , <int> ) ; rangeMap . put ( Range . closed ( <int> , <int> ) , <int> ) ; RangeMap < Integer , Integer > sub = rangeMap . subRangeMap ( Range . closed ( <int> , <int> ) ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , sub . asMapOfRanges ( ) ) ; sub . remove ( Range . closed ( <int> , <int> ) ) ; assertEquals ( ImmutableMap . of ( Range . closedOpen ( <int> , <int> ) , <int> , Range . openClosed ( <int> , <int> ) , <int> ) , sub . asMapOfRanges ( ) ) ; assertEquals ( ImmutableMap . of ( Range . open ( <int> , <int> ) , <int> , Range . openClosed ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , rangeMap . asMapOfRanges ( ) ) ; sub . remove ( Range . closed ( <int> , <int> ) ) ; assertEquals ( ImmutableMap . of ( Range . openClosed ( <int> , <int> ) , <int> ) , sub . asMapOfRanges ( ) ) ; assertEquals ( ImmutableMap . of ( Range . open ( <int> , <int> ) , <int> , Range . openClosed ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , rangeMap . asMapOfRanges ( ) ) ; } public void testSubRangeMapClear ( ) { RangeMap < Integer , Integer > rangeMap = TreeRangeMap . create ( ) ; rangeMap . put ( Range . open ( <int> , <int> ) , <int> ) ; rangeMap . put ( Range . closed ( <int> , <int> ) , <int> ) ; rangeMap . put ( Range . closed ( <int> , <int> ) , <int> ) ; RangeMap < Integer , Integer > sub = rangeMap . subRangeMap ( Range . closed ( <int> , <int> ) ) ; sub . clear ( ) ; assertEquals ( ImmutableMap . of ( Range . open ( <int> , <int> ) , <int> , Range . closed ( <int> , <int> ) , <int> ) , rangeMap . asMapOfRanges ( ) ) ; } private void verify ( Map < Integer , Integer > model , RangeMap < Integer , Integer > test ) { for ( int i = MIN_BOUND - <int> ; i < = MAX_BOUND + <int> ; i + + ) { assertEquals ( model . get ( i ) , test . get ( i ) ) ; Map . Entry < Range < Integer > , Integer > entry = test . getEntry ( i ) ; assertEquals ( model . containsKey ( i ) , entry ! = null ) ; if ( entry ! = null ) { assertTrue ( test . asMapOfRanges ( ) . entrySet ( ) . contains ( entry ) ) ; } } for ( Range < Integer > range : test . asMapOfRanges ( ) . keySet ( ) ) { assertFalse ( range . isEmpty ( ) ) ; } } private static void putModel ( Map < Integer , Integer > model , Range < Integer > range , int value ) { for ( int i = MIN_BOUND - <int> ; i < = MAX_BOUND + <int> ; i + + ) { if ( range . contains ( i ) ) { model . put ( i , value ) ; } } } private static void removeModel ( Map < Integer , Integer > model , Range < Integer > range ) { for ( int i = MIN_BOUND - <int> ; i < = MAX_BOUND + <int> ; i + + ) { if ( range . contains ( i ) ) { model . remove ( i ) ; } } } } 
