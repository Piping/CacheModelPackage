package org . elasticsearch . action . support . replication ; import org . apache . lucene . index . CorruptIndexException ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . ReplicationResponse ; import org . elasticsearch . action . UnavailableShardsException ; import org . elasticsearch . action . WriteConsistencyLevel ; import org . elasticsearch . action . support . ActionFilter ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . PlainActionFuture ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . action . shard . ShardStateAction ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . ShardIterator ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lease . Releasable ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . index . shard . IndexShardNotStartedException ; import org . elasticsearch . index . shard . IndexShardState ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . shard . ShardNotFoundException ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . cluster . TestClusterService ; import org . elasticsearch . test . transport . CapturingTransport ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . action . support . replication . ClusterStateCreationUtils . state ; import static org . elasticsearch . action . support . replication . ClusterStateCreationUtils . stateWithStartedPrimary ; import static org . hamcrest . Matchers . arrayWithSize ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class TransportReplicationActionTests extends ESTestCase { private static ThreadPool threadPool ; private TestClusterService clusterService ; private TransportService transportService ; private CapturingTransport transport ; private Action action ; @BeforeClass public static void beforeClass ( ) { threadPool = new ThreadPool ( <str> ) ; } @Override @Before public void setUp ( ) throws Exception { super . setUp ( ) ; transport = new CapturingTransport ( ) ; clusterService = new TestClusterService ( threadPool ) ; transportService = new TransportService ( transport , threadPool ) ; transportService . start ( ) ; action = new Action ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) ; count . set ( <int> ) ; } @AfterClass public static void afterClass ( ) { ThreadPool . terminate ( threadPool , <int> , TimeUnit . SECONDS ) ; threadPool = null ; } < T > void assertListenerThrows ( String msg , PlainActionFuture < T > listener , Class < ? > klass ) throws InterruptedException { try { listener . get ( ) ; fail ( msg ) ; } catch ( ExecutionException ex ) { assertThat ( ex . getCause ( ) , instanceOf ( klass ) ) ; } } public void testBlocks ( ) throws ExecutionException , InterruptedException { Request request = new Request ( ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; ClusterBlocks . Builder block = ClusterBlocks . builder ( ) . addGlobalBlock ( new ClusterBlock ( <int> , <str> , false , true , RestStatus . SERVICE_UNAVAILABLE , ClusterBlockLevel . ALL ) ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . blocks ( block ) ) ; TransportReplicationAction . ReroutePhase reroutePhase = action . new ReroutePhase ( request , listener ) ; reroutePhase . run ( ) ; assertListenerThrows ( <str> , listener , ClusterBlockException . class ) ; block = ClusterBlocks . builder ( ) . addGlobalBlock ( new ClusterBlock ( <int> , <str> , true , true , RestStatus . SERVICE_UNAVAILABLE , ClusterBlockLevel . ALL ) ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . blocks ( block ) ) ; listener = new PlainActionFuture < > ( ) ; reroutePhase = action . new ReroutePhase ( new Request ( ) . timeout ( <str> ) , listener ) ; reroutePhase . run ( ) ; assertListenerThrows ( <str> , listener , ClusterBlockException . class ) ; listener = new PlainActionFuture < > ( ) ; reroutePhase = action . new ReroutePhase ( new Request ( ) , listener ) ; reroutePhase . run ( ) ; assertFalse ( <str> , listener . isDone ( ) ) ; block = ClusterBlocks . builder ( ) . addGlobalBlock ( new ClusterBlock ( <int> , <str> , false , true , RestStatus . SERVICE_UNAVAILABLE , ClusterBlockLevel . ALL ) ) ; clusterService . setState ( ClusterState . builder ( clusterService . state ( ) ) . blocks ( block ) ) ; assertListenerThrows ( <str> , listener , ClusterBlockException . class ) ; assertIndexShardUninitialized ( ) ; } public void assertIndexShardUninitialized ( ) { assertEquals ( <int> , count . get ( ) ) ; } public void testNotStartedPrimary ( ) throws InterruptedException , ExecutionException { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( state ( index , true , randomBoolean ( ) ? ShardRoutingState . INITIALIZING : ShardRoutingState . UNASSIGNED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; Request request = new Request ( shardId ) . timeout ( <str> ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction . ReroutePhase reroutePhase = action . new ReroutePhase ( request , listener ) ; reroutePhase . run ( ) ; assertListenerThrows ( <str> , listener , UnavailableShardsException . class ) ; request = new Request ( shardId ) ; listener = new PlainActionFuture < > ( ) ; reroutePhase = action . new ReroutePhase ( request , listener ) ; reroutePhase . run ( ) ; assertFalse ( <str> , listener . isDone ( ) ) ; clusterService . setState ( state ( index , true , ShardRoutingState . STARTED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; final IndexShardRoutingTable shardRoutingTable = clusterService . state ( ) . routingTable ( ) . index ( index ) . shard ( shardId . id ( ) ) ; final String primaryNodeId = shardRoutingTable . primaryShard ( ) . currentNodeId ( ) ; final List < CapturingTransport . CapturedRequest > capturedRequests = transport . capturedRequestsByTargetNode ( ) . get ( primaryNodeId ) ; assertThat ( capturedRequests , notNullValue ( ) ) ; assertThat ( capturedRequests . size ( ) , equalTo ( <int> ) ) ; assertThat ( capturedRequests . get ( <int> ) . action , equalTo ( <str> ) ) ; assertIndexShardCounter ( <int> ) ; } public void testUnknownIndexOrShardOnReroute ( ) throws InterruptedException { final String index = <str> ; clusterService . setState ( state ( index , true , randomBoolean ( ) ? ShardRoutingState . INITIALIZING : ShardRoutingState . UNASSIGNED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; Request request = new Request ( new ShardId ( <str> , <int> ) ) . timeout ( <str> ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction . ReroutePhase reroutePhase = action . new ReroutePhase ( request , listener ) ; reroutePhase . run ( ) ; assertListenerThrows ( <str> , listener , IndexNotFoundException . class ) ; request = new Request ( new ShardId ( index , <int> ) ) . timeout ( <str> ) ; listener = new PlainActionFuture < > ( ) ; reroutePhase = action . new ReroutePhase ( request , listener ) ; reroutePhase . run ( ) ; assertListenerThrows ( <str> , listener , ShardNotFoundException . class ) ; } public void testRoutePhaseExecutesRequest ( ) { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( stateWithStartedPrimary ( index , randomBoolean ( ) , <int> ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; final IndexShardRoutingTable shardRoutingTable = clusterService . state ( ) . routingTable ( ) . index ( index ) . shard ( shardId . id ( ) ) ; final String primaryNodeId = shardRoutingTable . primaryShard ( ) . currentNodeId ( ) ; Request request = new Request ( shardId ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction . ReroutePhase reroutePhase = action . new ReroutePhase ( request , listener ) ; reroutePhase . run ( ) ; assertThat ( request . shardId ( ) , equalTo ( shardId ) ) ; logger . info ( <str> , primaryNodeId ) ; final List < CapturingTransport . CapturedRequest > capturedRequests = transport . capturedRequestsByTargetNode ( ) . get ( primaryNodeId ) ; assertThat ( capturedRequests , notNullValue ( ) ) ; assertThat ( capturedRequests . size ( ) , equalTo ( <int> ) ) ; if ( clusterService . state ( ) . nodes ( ) . localNodeId ( ) . equals ( primaryNodeId ) ) { assertThat ( capturedRequests . get ( <int> ) . action , equalTo ( <str> ) ) ; } else { assertThat ( capturedRequests . get ( <int> ) . action , equalTo ( <str> ) ) ; } assertIndexShardUninitialized ( ) ; } public void testPrimaryPhaseExecutesRequest ( ) throws InterruptedException , ExecutionException { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( state ( index , true , ShardRoutingState . STARTED , ShardRoutingState . STARTED ) ) ; Request request = new Request ( shardId ) . timeout ( <str> ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction . PrimaryPhase primaryPhase = action . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; primaryPhase . run ( ) ; assertThat ( <str> , request . processedOnPrimary . get ( ) , equalTo ( true ) ) ; final String replicaNodeId = clusterService . state ( ) . getRoutingTable ( ) . shardRoutingTable ( index , shardId . id ( ) ) . replicaShards ( ) . get ( <int> ) . currentNodeId ( ) ; final List < CapturingTransport . CapturedRequest > requests = transport . capturedRequestsByTargetNode ( ) . get ( replicaNodeId ) ; assertThat ( requests , notNullValue ( ) ) ; assertThat ( requests . size ( ) , equalTo ( <int> ) ) ; assertThat ( <str> , requests . get ( <int> ) . action , equalTo ( <str> ) ) ; } public void testAddedReplicaAfterPrimaryOperation ( ) { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( stateWithStartedPrimary ( index , true , <int> ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; final ClusterState stateWithAddedReplicas = state ( index , true , ShardRoutingState . STARTED , randomBoolean ( ) ? ShardRoutingState . INITIALIZING : ShardRoutingState . STARTED ) ; final Action actionWithAddedReplicaAfterPrimaryOp = new Action ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) { @Override protected Tuple < Response , Request > shardOperationOnPrimary ( MetaData metaData , Request shardRequest ) throws Throwable { final Tuple < Response , Request > operationOnPrimary = super . shardOperationOnPrimary ( metaData , shardRequest ) ; ( ( TestClusterService ) clusterService ) . setState ( stateWithAddedReplicas ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; return operationOnPrimary ; } } ; Request request = new Request ( shardId ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction < Request , Request , Response > . PrimaryPhase primaryPhase = actionWithAddedReplicaAfterPrimaryOp . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; primaryPhase . run ( ) ; assertThat ( <str> , request . processedOnPrimary . get ( ) , equalTo ( true ) ) ; for ( ShardRouting replica : stateWithAddedReplicas . getRoutingTable ( ) . shardRoutingTable ( index , shardId . id ( ) ) . replicaShards ( ) ) { List < CapturingTransport . CapturedRequest > requests = transport . capturedRequestsByTargetNode ( ) . get ( replica . currentNodeId ( ) ) ; assertThat ( requests , notNullValue ( ) ) ; assertThat ( requests . size ( ) , equalTo ( <int> ) ) ; assertThat ( <str> , requests . get ( <int> ) . action , equalTo ( <str> ) ) ; } } public void testRelocatingReplicaAfterPrimaryOperation ( ) { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( state ( index , true , ShardRoutingState . STARTED , randomBoolean ( ) ? ShardRoutingState . INITIALIZING : ShardRoutingState . STARTED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; final ClusterState stateWithRelocatingReplica = state ( index , true , ShardRoutingState . STARTED , ShardRoutingState . RELOCATING ) ; final Action actionWithRelocatingReplicasAfterPrimaryOp = new Action ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) { @Override protected Tuple < Response , Request > shardOperationOnPrimary ( MetaData metaData , Request shardRequest ) throws Throwable { final Tuple < Response , Request > operationOnPrimary = super . shardOperationOnPrimary ( metaData , shardRequest ) ; ( ( TestClusterService ) clusterService ) . setState ( stateWithRelocatingReplica ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; return operationOnPrimary ; } } ; Request request = new Request ( shardId ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction < Request , Request , Response > . PrimaryPhase primaryPhase = actionWithRelocatingReplicasAfterPrimaryOp . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; primaryPhase . run ( ) ; assertThat ( <str> , request . processedOnPrimary . get ( ) , equalTo ( true ) ) ; ShardRouting relocatingReplicaShard = stateWithRelocatingReplica . getRoutingTable ( ) . shardRoutingTable ( index , shardId . id ( ) ) . replicaShards ( ) . get ( <int> ) ; for ( String node : new String [ ] { relocatingReplicaShard . currentNodeId ( ) , relocatingReplicaShard . relocatingNodeId ( ) } ) { List < CapturingTransport . CapturedRequest > requests = transport . capturedRequestsByTargetNode ( ) . get ( node ) ; assertThat ( requests , notNullValue ( ) ) ; assertThat ( requests . size ( ) , equalTo ( <int> ) ) ; assertThat ( <str> , requests . get ( <int> ) . action , equalTo ( <str> ) ) ; } } public void testIndexDeletedAfterPrimaryOperation ( ) { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( state ( index , true , ShardRoutingState . STARTED , ShardRoutingState . STARTED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; final ClusterState stateWithDeletedIndex = state ( index + <str> , true , ShardRoutingState . STARTED , ShardRoutingState . RELOCATING ) ; final Action actionWithDeletedIndexAfterPrimaryOp = new Action ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) { @Override protected Tuple < Response , Request > shardOperationOnPrimary ( MetaData metaData , Request shardRequest ) throws Throwable { final Tuple < Response , Request > operationOnPrimary = super . shardOperationOnPrimary ( metaData , shardRequest ) ; ( ( TestClusterService ) clusterService ) . setState ( stateWithDeletedIndex ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; return operationOnPrimary ; } } ; Request request = new Request ( shardId ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction < Request , Request , Response > . PrimaryPhase primaryPhase = actionWithDeletedIndexAfterPrimaryOp . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; primaryPhase . run ( ) ; assertThat ( <str> , request . processedOnPrimary . get ( ) , equalTo ( true ) ) ; assertThat ( <str> , transport . capturedRequestsByTargetNode ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testWriteConsistency ( ) throws ExecutionException , InterruptedException { action = new ActionWithConsistency ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) ; final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; final int assignedReplicas = randomInt ( <int> ) ; final int unassignedReplicas = randomInt ( <int> ) ; final int totalShards = <int> + assignedReplicas + unassignedReplicas ; final boolean passesWriteConsistency ; Request request = new Request ( shardId ) . consistencyLevel ( randomFrom ( WriteConsistencyLevel . values ( ) ) ) ; switch ( request . consistencyLevel ( ) ) { case ONE : passesWriteConsistency = true ; break ; case DEFAULT : case QUORUM : if ( totalShards < = <int> ) { passesWriteConsistency = true ; } else { passesWriteConsistency = assignedReplicas + <int> > = ( totalShards / <int> ) + <int> ; } break ; case ALL : passesWriteConsistency = unassignedReplicas = = <int> ; break ; default : throw new RuntimeException ( <str> + request . consistencyLevel ( ) + <str> ) ; } ShardRoutingState [ ] replicaStates = new ShardRoutingState [ assignedReplicas + unassignedReplicas ] ; for ( int i = <int> ; i < assignedReplicas ; i + + ) { replicaStates [ i ] = randomFrom ( ShardRoutingState . STARTED , ShardRoutingState . RELOCATING ) ; } for ( int i = assignedReplicas ; i < replicaStates . length ; i + + ) { replicaStates [ i ] = ShardRoutingState . UNASSIGNED ; } clusterService . setState ( state ( index , true , ShardRoutingState . STARTED , replicaStates ) ) ; logger . debug ( <str> , request . consistencyLevel ( ) , <int> + assignedReplicas , <int> + assignedReplicas + unassignedReplicas , passesWriteConsistency ? <str> : <str> , clusterService . state ( ) . prettyPrint ( ) ) ; final IndexShardRoutingTable shardRoutingTable = clusterService . state ( ) . routingTable ( ) . index ( index ) . shard ( shardId . id ( ) ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction . PrimaryPhase primaryPhase = action . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; if ( passesWriteConsistency ) { assertThat ( primaryPhase . checkWriteConsistency ( shardRoutingTable . primaryShard ( ) . shardId ( ) ) , nullValue ( ) ) ; primaryPhase . run ( ) ; assertTrue ( <str> , request . processedOnPrimary . get ( ) ) ; if ( assignedReplicas > <int> ) { assertIndexShardCounter ( <int> ) ; } else { assertIndexShardCounter ( <int> ) ; } } else { assertThat ( primaryPhase . checkWriteConsistency ( shardRoutingTable . primaryShard ( ) . shardId ( ) ) , notNullValue ( ) ) ; primaryPhase . run ( ) ; assertFalse ( <str> , request . processedOnPrimary . get ( ) ) ; assertListenerThrows ( <str> , listener , UnavailableShardsException . class ) ; assertIndexShardUninitialized ( ) ; for ( int i = <int> ; i < replicaStates . length ; i + + ) { replicaStates [ i ] = ShardRoutingState . STARTED ; } clusterService . setState ( state ( index , true , ShardRoutingState . STARTED , replicaStates ) ) ; listener = new PlainActionFuture < > ( ) ; primaryPhase = action . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; primaryPhase . run ( ) ; assertTrue ( <str> , request . processedOnPrimary . get ( ) ) ; assertIndexShardCounter ( <int> ) ; } } public void testReplication ( ) throws ExecutionException , InterruptedException { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( stateWithStartedPrimary ( index , true , randomInt ( <int> ) ) ) ; final IndexShardRoutingTable shardRoutingTable = clusterService . state ( ) . routingTable ( ) . index ( index ) . shard ( shardId . id ( ) ) ; int assignedReplicas = <int> ; int totalShards = <int> ; for ( ShardRouting shard : shardRoutingTable ) { totalShards + + ; if ( shard . primary ( ) = = false & & shard . assignedToNode ( ) ) { assignedReplicas + + ; } if ( shard . relocating ( ) ) { assignedReplicas + + ; totalShards + + ; } } runReplicateTest ( shardRoutingTable , assignedReplicas , totalShards ) ; } public void testReplicationWithShadowIndex ( ) throws ExecutionException , InterruptedException { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; ClusterState state = stateWithStartedPrimary ( index , true , randomInt ( <int> ) ) ; MetaData . Builder metaData = MetaData . builder ( state . metaData ( ) ) ; Settings . Builder settings = Settings . builder ( ) . put ( metaData . get ( index ) . getSettings ( ) ) ; settings . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) ; metaData . put ( IndexMetaData . builder ( metaData . get ( index ) ) . settings ( settings ) ) ; clusterService . setState ( ClusterState . builder ( state ) . metaData ( metaData ) ) ; final IndexShardRoutingTable shardRoutingTable = clusterService . state ( ) . routingTable ( ) . index ( index ) . shard ( shardId . id ( ) ) ; int assignedReplicas = <int> ; int totalShards = <int> ; for ( ShardRouting shard : shardRoutingTable ) { totalShards + + ; if ( shard . primary ( ) & & shard . relocating ( ) ) { assignedReplicas + + ; totalShards + + ; } } runReplicateTest ( shardRoutingTable , assignedReplicas , totalShards ) ; } protected void runReplicateTest ( IndexShardRoutingTable shardRoutingTable , int assignedReplicas , int totalShards ) throws InterruptedException , ExecutionException { final ShardIterator shardIt = shardRoutingTable . shardsIt ( ) ; final ShardId shardId = shardIt . shardId ( ) ; final Request request = new Request ( shardId ) ; final PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; logger . debug ( <str> , assignedReplicas , totalShards , clusterService . state ( ) . prettyPrint ( ) ) ; Releasable reference = getOrCreateIndexShardOperationsCounter ( ) ; assertIndexShardCounter ( <int> ) ; TransportReplicationAction < Request , Request , Response > . ReplicationPhase replicationPhase = action . new ReplicationPhase ( request , new Response ( ) , request . shardId ( ) , createTransportChannel ( listener ) , reference , null ) ; assertThat ( replicationPhase . totalShards ( ) , equalTo ( totalShards ) ) ; assertThat ( replicationPhase . pending ( ) , equalTo ( assignedReplicas ) ) ; replicationPhase . run ( ) ; final CapturingTransport . CapturedRequest [ ] capturedRequests = transport . capturedRequests ( ) ; transport . clear ( ) ; assertThat ( capturedRequests . length , equalTo ( assignedReplicas ) ) ; if ( assignedReplicas > <int> ) { assertThat ( <str> , listener . isDone ( ) , equalTo ( false ) ) ; } int pending = replicationPhase . pending ( ) ; int criticalFailures = <int> ; int successful = <int> ; List < CapturingTransport . CapturedRequest > failures = new ArrayList < > ( ) ; for ( CapturingTransport . CapturedRequest capturedRequest : capturedRequests ) { if ( randomBoolean ( ) ) { Throwable t ; boolean criticalFailure = randomBoolean ( ) ; if ( criticalFailure ) { t = new CorruptIndexException ( <str> , ( String ) null ) ; criticalFailures + + ; } else { t = new IndexShardNotStartedException ( shardId , IndexShardState . RECOVERING ) ; } logger . debug ( <str> , capturedRequest . node , t . getClass ( ) . getSimpleName ( ) ) ; transport . handleResponse ( capturedRequest . requestId , t ) ; if ( criticalFailure ) { CapturingTransport . CapturedRequest [ ] shardFailedRequests = transport . capturedRequests ( ) ; transport . clear ( ) ; assertEquals ( <int> , shardFailedRequests . length ) ; CapturingTransport . CapturedRequest shardFailedRequest = shardFailedRequests [ <int> ] ; failures . add ( shardFailedRequest ) ; transport . handleResponse ( shardFailedRequest . requestId , TransportResponse . Empty . INSTANCE ) ; } } else { successful + + ; transport . handleResponse ( capturedRequest . requestId , TransportResponse . Empty . INSTANCE ) ; } pending - - ; assertThat ( replicationPhase . pending ( ) , equalTo ( pending ) ) ; assertThat ( replicationPhase . successful ( ) , equalTo ( successful ) ) ; } assertThat ( listener . isDone ( ) , equalTo ( true ) ) ; Response response = listener . get ( ) ; final ReplicationResponse . ShardInfo shardInfo = response . getShardInfo ( ) ; assertThat ( shardInfo . getFailed ( ) , equalTo ( criticalFailures ) ) ; assertThat ( shardInfo . getFailures ( ) , arrayWithSize ( criticalFailures ) ) ; assertThat ( shardInfo . getSuccessful ( ) , equalTo ( successful ) ) ; assertThat ( shardInfo . getTotal ( ) , equalTo ( totalShards ) ) ; assertThat ( <str> , failures . size ( ) , equalTo ( criticalFailures ) ) ; for ( CapturingTransport . CapturedRequest capturedRequest : transport . capturedRequests ( ) ) { assertThat ( capturedRequest . action , equalTo ( ShardStateAction . SHARD_FAILED_ACTION_NAME ) ) ; } assertIndexShardCounter ( <int> ) ; } public void testCounterOnPrimary ( ) throws InterruptedException , ExecutionException , IOException { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( state ( index , true , ShardRoutingState . STARTED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; Request request = new Request ( shardId ) . timeout ( <str> ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; action = new ActionWithDelay ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) ; final TransportReplicationAction . PrimaryPhase primaryPhase = action . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; Thread t = new Thread ( ) { @Override public void run ( ) { primaryPhase . run ( ) ; } } ; t . start ( ) ; awaitBusy ( ( ) - > count . get ( ) = = <int> ) ; assertIndexShardCounter ( <int> ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; ( ( ActionWithDelay ) action ) . countDownLatch . countDown ( ) ; t . join ( ) ; listener . get ( ) ; assertIndexShardCounter ( <int> ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; } public void testCounterIncrementedWhileReplicationOngoing ( ) throws InterruptedException , ExecutionException , IOException { final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( state ( index , true , ShardRoutingState . STARTED , ShardRoutingState . STARTED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; Request request = new Request ( shardId ) . timeout ( <str> ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction . PrimaryPhase primaryPhase = action . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; primaryPhase . run ( ) ; assertIndexShardCounter ( <int> ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; transport . handleResponse ( transport . capturedRequests ( ) [ <int> ] . requestId , TransportResponse . Empty . INSTANCE ) ; assertIndexShardCounter ( <int> ) ; transport . clear ( ) ; request = new Request ( shardId ) . timeout ( <str> ) ; primaryPhase = action . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; primaryPhase . run ( ) ; assertIndexShardCounter ( <int> ) ; CapturingTransport . CapturedRequest [ ] replicationRequests = transport . capturedRequests ( ) ; transport . clear ( ) ; assertThat ( replicationRequests . length , equalTo ( <int> ) ) ; transport . handleResponse ( replicationRequests [ <int> ] . requestId , new CorruptIndexException ( <str> , ( String ) null ) ) ; CapturingTransport . CapturedRequest [ ] shardFailedRequests = transport . capturedRequests ( ) ; transport . clear ( ) ; assertEquals ( <int> , shardFailedRequests . length ) ; transport . handleResponse ( shardFailedRequests [ <int> ] . requestId , TransportResponse . Empty . INSTANCE ) ; assertIndexShardCounter ( <int> ) ; } public void testReplicasCounter ( ) throws Exception { final ShardId shardId = new ShardId ( <str> , <int> ) ; clusterService . setState ( state ( shardId . index ( ) . getName ( ) , true , ShardRoutingState . STARTED , ShardRoutingState . STARTED ) ) ; action = new ActionWithDelay ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) ; final Action . ReplicaOperationTransportHandler replicaOperationTransportHandler = action . new ReplicaOperationTransportHandler ( ) ; Thread t = new Thread ( ) { @Override public void run ( ) { try { replicaOperationTransportHandler . messageReceived ( new Request ( ) , createTransportChannel ( new PlainActionFuture < > ( ) ) ) ; } catch ( Exception e ) { } } } ; t . start ( ) ; awaitBusy ( ( ) - > count . get ( ) = = <int> ) ; ( ( ActionWithDelay ) action ) . countDownLatch . countDown ( ) ; t . join ( ) ; assertIndexShardCounter ( <int> ) ; action = new ActionWithExceptions ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) ; final Action . ReplicaOperationTransportHandler replicaOperationTransportHandlerForException = action . new ReplicaOperationTransportHandler ( ) ; try { replicaOperationTransportHandlerForException . messageReceived ( new Request ( shardId ) , createTransportChannel ( new PlainActionFuture < > ( ) ) ) ; fail ( ) ; } catch ( Throwable t2 ) { } assertIndexShardCounter ( <int> ) ; } public void testCounterDecrementedIfShardOperationThrowsException ( ) throws InterruptedException , ExecutionException , IOException { action = new ActionWithExceptions ( Settings . EMPTY , <str> , transportService , clusterService , threadPool ) ; final String index = <str> ; final ShardId shardId = new ShardId ( index , <int> ) ; clusterService . setState ( state ( index , true , ShardRoutingState . STARTED , ShardRoutingState . STARTED ) ) ; logger . debug ( <str> , clusterService . state ( ) . prettyPrint ( ) ) ; Request request = new Request ( shardId ) . timeout ( <str> ) ; PlainActionFuture < Response > listener = new PlainActionFuture < > ( ) ; TransportReplicationAction . PrimaryPhase primaryPhase = action . new PrimaryPhase ( request , createTransportChannel ( listener ) ) ; primaryPhase . run ( ) ; assertThat ( transport . capturedRequests ( ) . length , equalTo ( <int> ) ) ; assertIndexShardCounter ( <int> ) ; } private void assertIndexShardCounter ( int expected ) { assertThat ( count . get ( ) , equalTo ( expected ) ) ; } private final AtomicInteger count = new AtomicInteger ( <int> ) ; private synchronized Releasable getOrCreateIndexShardOperationsCounter ( ) { count . incrementAndGet ( ) ; return new Releasable ( ) { @Override public void close ( ) { count . decrementAndGet ( ) ; } } ; } public static class Request extends ReplicationRequest < Request > { public AtomicBoolean processedOnPrimary = new AtomicBoolean ( ) ; public AtomicInteger processedOnReplicas = new AtomicInteger ( ) ; public Request ( ) { } Request ( ShardId shardId ) { this ( ) ; this . shardId = shardId ; this . index = shardId . getIndex ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; } } static class Response extends ReplicationResponse { } class Action extends TransportReplicationAction < Request , Request , Response > { Action ( Settings settings , String actionName , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { super ( settings , actionName , transportService , clusterService , null , threadPool , new ShardStateAction ( settings , clusterService , transportService , null , null ) , null , new ActionFilters ( new HashSet < ActionFilter > ( ) ) , new IndexNameExpressionResolver ( Settings . EMPTY ) , Request : : new , Request : : new , ThreadPool . Names . SAME ) ; } @Override protected Response newResponseInstance ( ) { return new Response ( ) ; } @Override protected Tuple < Response , Request > shardOperationOnPrimary ( MetaData metaData , Request shardRequest ) throws Throwable { boolean executedBefore = shardRequest . processedOnPrimary . getAndSet ( true ) ; assert executedBefore = = false : <str> ; return new Tuple < > ( new Response ( ) , shardRequest ) ; } @Override protected void shardOperationOnReplica ( Request request ) { request . processedOnReplicas . incrementAndGet ( ) ; } @Override protected boolean checkWriteConsistency ( ) { return false ; } @Override protected boolean resolveIndex ( ) { return false ; } @Override protected Releasable getIndexShardOperationsCounter ( ShardId shardId ) { return getOrCreateIndexShardOperationsCounter ( ) ; } } class ActionWithConsistency extends Action { ActionWithConsistency ( Settings settings , String actionName , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) { super ( settings , actionName , transportService , clusterService , threadPool ) ; } @Override protected boolean checkWriteConsistency ( ) { return true ; } } class ActionWithExceptions extends Action { ActionWithExceptions ( Settings settings , String actionName , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) throws IOException { super ( settings , actionName , transportService , clusterService , threadPool ) ; } @Override protected Tuple < Response , Request > shardOperationOnPrimary ( MetaData metaData , Request shardRequest ) throws Throwable { return throwException ( shardRequest . shardId ( ) ) ; } private Tuple < Response , Request > throwException ( ShardId shardId ) { try { if ( randomBoolean ( ) ) { throw new ElasticsearchException ( <str> ) ; } else { throw new IndexShardNotStartedException ( shardId , IndexShardState . RECOVERING ) ; } } catch ( Exception e ) { logger . info ( <str> , e ) ; throw e ; } } @Override protected void shardOperationOnReplica ( Request shardRequest ) { throwException ( shardRequest . shardId ( ) ) ; } } class ActionWithDelay extends Action { CountDownLatch countDownLatch = new CountDownLatch ( <int> ) ; ActionWithDelay ( Settings settings , String actionName , TransportService transportService , ClusterService clusterService , ThreadPool threadPool ) throws IOException { super ( settings , actionName , transportService , clusterService , threadPool ) ; } @Override protected Tuple < Response , Request > shardOperationOnPrimary ( MetaData metaData , Request shardRequest ) throws Throwable { awaitLatch ( ) ; return new Tuple < > ( new Response ( ) , shardRequest ) ; } private void awaitLatch ( ) throws InterruptedException { countDownLatch . await ( ) ; countDownLatch = new CountDownLatch ( <int> ) ; } @Override protected void shardOperationOnReplica ( Request shardRequest ) { try { awaitLatch ( ) ; } catch ( InterruptedException e ) { } } } public TransportChannel createTransportChannel ( final PlainActionFuture < Response > listener ) { return new TransportChannel ( ) { @Override public String action ( ) { return null ; } @Override public String getProfileName ( ) { return <str> ; } @Override public void sendResponse ( TransportResponse response ) throws IOException { listener . onResponse ( ( ( Response ) response ) ) ; } @Override public void sendResponse ( TransportResponse response , TransportResponseOptions options ) throws IOException { listener . onResponse ( ( ( Response ) response ) ) ; } @Override public void sendResponse ( Throwable error ) throws IOException { listener . onFailure ( error ) ; } } ; } } 
