package io . netty . channel ; import io . netty . util . concurrent . AbstractEventExecutorGroup ; import io . netty . util . concurrent . DefaultPromise ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . FutureListener ; import io . netty . util . concurrent . GlobalEventExecutor ; import io . netty . util . concurrent . Promise ; import io . netty . util . concurrent . ThreadPerTaskExecutor ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . ReadOnlyIterator ; import java . util . Collections ; import java . util . Iterator ; import java . util . Queue ; import java . util . Set ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; public class ThreadPerChannelEventLoopGroup extends AbstractEventExecutorGroup implements EventLoopGroup { private final Object [ ] childArgs ; private final int maxChannels ; final Executor executor ; final Set < EventLoop > activeChildren = Collections . newSetFromMap ( PlatformDependent . < EventLoop , Boolean > newConcurrentHashMap ( ) ) ; private final Set < EventLoop > readOnlyActiveChildren = Collections . unmodifiableSet ( activeChildren ) ; final Queue < EventLoop > idleChildren = new ConcurrentLinkedQueue < EventLoop > ( ) ; private final ChannelException tooManyChannels ; private volatile boolean shuttingDown ; private final Promise < ? > terminationFuture = new DefaultPromise < Void > ( GlobalEventExecutor . INSTANCE ) ; private final FutureListener < Object > childTerminationListener = new FutureListener < Object > ( ) { @Override public void operationComplete ( Future < Object > future ) throws Exception { if ( isTerminated ( ) ) { terminationFuture . trySuccess ( null ) ; } } } ; protected ThreadPerChannelEventLoopGroup ( ) { this ( <int> ) ; } protected ThreadPerChannelEventLoopGroup ( int maxChannels ) { this ( maxChannels , Executors . defaultThreadFactory ( ) ) ; } protected ThreadPerChannelEventLoopGroup ( int maxChannels , ThreadFactory threadFactory , Object . . . args ) { this ( maxChannels , new ThreadPerTaskExecutor ( threadFactory ) , args ) ; } protected ThreadPerChannelEventLoopGroup ( int maxChannels , Executor executor , Object . . . args ) { if ( maxChannels < <int> ) { throw new IllegalArgumentException ( String . format ( <str> , maxChannels ) ) ; } if ( executor = = null ) { throw new NullPointerException ( <str> ) ; } if ( args = = null ) { childArgs = EmptyArrays . EMPTY_OBJECTS ; } else { childArgs = args . clone ( ) ; } this . maxChannels = maxChannels ; this . executor = executor ; tooManyChannels = new ChannelException ( <str> + maxChannels + <str> ) ; tooManyChannels . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } protected EventLoop newChild ( @SuppressWarnings ( <str> ) Object . . . args ) throws Exception { return new ThreadPerChannelEventLoop ( this ) ; } @Override public Iterator < EventExecutor > iterator ( ) { return new ReadOnlyIterator < EventExecutor > ( activeChildren . iterator ( ) ) ; } @Override @SuppressWarnings ( <str> ) public < E extends EventExecutor > Set < E > children ( ) { return ( Set < E > ) readOnlyActiveChildren ; } @Override public EventLoop next ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Future < ? > shutdownGracefully ( long quietPeriod , long timeout , TimeUnit unit ) { shuttingDown = true ; for ( EventLoop l : activeChildren ) { l . shutdownGracefully ( quietPeriod , timeout , unit ) ; } for ( EventLoop l : idleChildren ) { l . shutdownGracefully ( quietPeriod , timeout , unit ) ; } if ( isTerminated ( ) ) { terminationFuture . trySuccess ( null ) ; } return terminationFuture ( ) ; } @Override public Future < ? > terminationFuture ( ) { return terminationFuture ; } @Override @Deprecated public void shutdown ( ) { shuttingDown = true ; for ( EventLoop l : activeChildren ) { l . shutdown ( ) ; } for ( EventLoop l : idleChildren ) { l . shutdown ( ) ; } if ( isTerminated ( ) ) { terminationFuture . trySuccess ( null ) ; } } @Override public boolean isShuttingDown ( ) { for ( EventLoop l : activeChildren ) { if ( ! l . isShuttingDown ( ) ) { return false ; } } for ( EventLoop l : idleChildren ) { if ( ! l . isShuttingDown ( ) ) { return false ; } } return true ; } @Override public boolean isShutdown ( ) { for ( EventLoop l : activeChildren ) { if ( ! l . isShutdown ( ) ) { return false ; } } for ( EventLoop l : idleChildren ) { if ( ! l . isShutdown ( ) ) { return false ; } } return true ; } @Override public boolean isTerminated ( ) { for ( EventLoop l : activeChildren ) { if ( ! l . isTerminated ( ) ) { return false ; } } for ( EventLoop l : idleChildren ) { if ( ! l . isTerminated ( ) ) { return false ; } } return true ; } @Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { long deadline = System . nanoTime ( ) + unit . toNanos ( timeout ) ; for ( EventLoop l : activeChildren ) { for ( ; ; ) { long timeLeft = deadline - System . nanoTime ( ) ; if ( timeLeft < = <int> ) { return isTerminated ( ) ; } if ( l . awaitTermination ( timeLeft , TimeUnit . NANOSECONDS ) ) { break ; } } } for ( EventLoop l : idleChildren ) { for ( ; ; ) { long timeLeft = deadline - System . nanoTime ( ) ; if ( timeLeft < = <int> ) { return isTerminated ( ) ; } if ( l . awaitTermination ( timeLeft , TimeUnit . NANOSECONDS ) ) { break ; } } } return isTerminated ( ) ; } @Override public ChannelFuture register ( Channel channel ) { if ( channel = = null ) { throw new NullPointerException ( <str> ) ; } try { EventLoop l = nextChild ( ) ; return l . register ( channel , new DefaultChannelPromise ( channel , l ) ) ; } catch ( Throwable t ) { return new FailedChannelFuture ( channel , GlobalEventExecutor . INSTANCE , t ) ; } } @Override public ChannelFuture register ( Channel channel , ChannelPromise promise ) { if ( channel = = null ) { throw new NullPointerException ( <str> ) ; } try { return nextChild ( ) . register ( channel , promise ) ; } catch ( Throwable t ) { promise . setFailure ( t ) ; return promise ; } } private EventLoop nextChild ( ) throws Exception { if ( shuttingDown ) { throw new RejectedExecutionException ( <str> ) ; } EventLoop loop = idleChildren . poll ( ) ; if ( loop = = null ) { if ( maxChannels > <int> & & activeChildren . size ( ) > = maxChannels ) { throw tooManyChannels ; } loop = newChild ( childArgs ) ; loop . terminationFuture ( ) . addListener ( childTerminationListener ) ; } activeChildren . add ( loop ) ; return loop ; } } 
