package org . gradle . tooling . internal . consumer . connection ; import org . gradle . tooling . internal . adapter . ProtocolToModelAdapter ; import org . gradle . tooling . internal . consumer . parameters . ConsumerOperationParameters ; import org . gradle . tooling . internal . consumer . versioning . ModelMapping ; import org . gradle . tooling . internal . consumer . versioning . VersionDetails ; import org . gradle . tooling . internal . protocol . BuildResult ; import org . gradle . tooling . internal . protocol . InternalUnsupportedModelException ; import org . gradle . tooling . internal . protocol . ModelBuilder ; import org . gradle . tooling . internal . protocol . ModelIdentifier ; import org . gradle . tooling . model . internal . Exceptions ; public class ModelBuilderBackedModelProducer extends HasCompatibilityMapperAction implements ModelProducer { private final ProtocolToModelAdapter adapter ; private final VersionDetails versionDetails ; private final ModelMapping modelMapping ; private final ModelBuilder builder ; public ModelBuilderBackedModelProducer ( ProtocolToModelAdapter adapter , VersionDetails versionDetails , ModelMapping modelMapping , ModelBuilder builder ) { super ( versionDetails ) ; this . adapter = adapter ; this . versionDetails = versionDetails ; this . modelMapping = modelMapping ; this . builder = builder ; } public < T > T produceModel ( Class < T > type , ConsumerOperationParameters operationParameters ) { if ( ! versionDetails . maySupportModel ( type ) ) { throw Exceptions . unsupportedModel ( type , versionDetails . getVersion ( ) ) ; } final ModelIdentifier modelIdentifier = modelMapping . getModelIdentifierFromModelType ( type ) ; BuildResult < ? > result ; try { result = builder . getModel ( modelIdentifier , operationParameters ) ; } catch ( InternalUnsupportedModelException e ) { throw Exceptions . unknownModel ( type , e ) ; } return adapter . adapt ( type , result . getModel ( ) , getCompatibilityMapperAction ( ) ) ; } } 
