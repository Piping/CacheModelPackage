package org . gradle . foundation . ipc . gradle ; import org . apache . commons . io . IOUtils ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . internal . file . TemporaryFileProvider ; import org . gradle . api . internal . file . TmpDirTemporaryFileProvider ; import org . gradle . api . logging . LogLevel ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . foundation . CommandLineAssistant ; import org . gradle . foundation . ipc . basic . ClientProcess ; import org . gradle . foundation . ipc . basic . ExecutionInfo ; import org . gradle . foundation . ipc . basic . MessageObject ; import org . gradle . foundation . ipc . basic . ProcessLauncherServer ; import org . gradle . initialization . DefaultCommandLineConverter ; import org . gradle . internal . jvm . Jvm ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . logging . ShowStacktrace ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; public abstract class AbstractGradleServerProtocol implements ProcessLauncherServer . Protocol { private static final String INIT_SCRIPT_EXTENSION = <str> ; private final Logger logger = Logging . getLogger ( AbstractGradleServerProtocol . class ) ; private final TemporaryFileProvider temporaryFileProvider = new TmpDirTemporaryFileProvider ( ) ; protected ProcessLauncherServer server ; private boolean continueConnection ; private boolean waitingOnHandshakeCompletion ; private boolean hasCompletedConnection ; private boolean hasReceivedBuildCompleteNotification ; private File currentDirectory ; private File gradleHomeDirectory ; private File customGradleExecutor ; private String commandLine ; private LogLevel logLevel ; private int killGradleServerPort ; private KillGradleClientProtocol killGradleClientProcotol ; private ClientProcess killGradleClient ; protected MessageObject lastMessageReceived ; public boolean continueConnection ( ) { return continueConnection ; } private ShowStacktrace stackTraceLevel ; public AbstractGradleServerProtocol ( File currentDirectory , File gradleHomeDirectory , File customGradleExecutor , String fullCommandLine , LogLevel logLevel , ShowStacktrace stackTraceLevel ) { this . currentDirectory = currentDirectory ; this . gradleHomeDirectory = gradleHomeDirectory ; this . customGradleExecutor = customGradleExecutor ; this . commandLine = fullCommandLine ; this . logLevel = logLevel ; this . stackTraceLevel = stackTraceLevel ; } public void connectionAccepted ( ) { server . sendMessage ( ProtocolConstants . HANDSHAKE_TYPE , ProtocolConstants . HANDSHAKE_SERVER ) ; continueConnection = true ; waitingOnHandshakeCompletion = true ; } public void initialize ( ProcessLauncherServer server ) { this . server = server ; } protected void closeConnection ( ) { this . continueConnection = false ; } public void messageReceived ( MessageObject message ) { lastMessageReceived = message ; if ( waitingOnHandshakeCompletion ) { if ( ProtocolConstants . HANDSHAKE_CLIENT . equalsIgnoreCase ( message . getMessage ( ) ) ) { waitingOnHandshakeCompletion = false ; hasCompletedConnection = true ; if ( message . getData ( ) ! = null ) { killGradleServerPort = ( Integer ) message . getData ( ) ; killGradleClientProcotol = new KillGradleClientProtocol ( ) ; killGradleClient = new ClientProcess ( killGradleClientProcotol ) ; killGradleClient . start ( killGradleServerPort ) ; handShakeCompleted ( ) ; } else { addStatus ( <str> ) ; server . sendMessage ( <str> , <str> ) ; closeConnection ( ) ; } } else { addStatus ( <str> ) ; server . sendMessage ( <str> , <str> ) ; closeConnection ( ) ; } } else { try { handleMessageReceived ( message ) ; } catch ( Throwable e ) { logger . error ( <str> + message , e ) ; } } } protected void handShakeCompleted ( ) { } protected abstract boolean handleMessageReceived ( MessageObject message ) ; public void setHasReceivedBuildCompleteNotification ( ) { this . hasReceivedBuildCompleteNotification = true ; } protected abstract void addStatus ( String status ) ; public class MyExecutionInfo implements ExecutionInfo { public String [ ] commandLineArguments ; public File workingDirectory ; public HashMap < String , String > environmentVariables = new HashMap < String , String > ( ) ; public File initStriptPath ; public String [ ] getCommandLineArguments ( ) { return commandLineArguments ; } public File getWorkingDirectory ( ) { return workingDirectory ; } public HashMap < String , String > getEnvironmentVariables ( ) { return environmentVariables ; } public void setCommandLineArguments ( String [ ] commandLineArguments ) { this . commandLineArguments = commandLineArguments ; } public void setWorkingDirectory ( File workingDirectory ) { this . workingDirectory = workingDirectory ; } public void addEnvironmentVariable ( String name , String value ) { this . environmentVariables . put ( name , value ) ; } public void processExecutionComplete ( ) { if ( initStriptPath ! = null ) { initStriptPath . delete ( ) ; } } } public ExecutionInfo getExecutionInfo ( int serverPort ) { MyExecutionInfo executionInfo = new MyExecutionInfo ( ) ; executionInfo . addEnvironmentVariable ( <str> , Jvm . current ( ) . getJavaHome ( ) . getAbsolutePath ( ) ) ; executionInfo . setWorkingDirectory ( currentDirectory ) ; List < String > executionCommandLine = new ArrayList < String > ( ) ; File gradleExecutableFile = getGradleExecutableFile ( ) ; if ( gradleExecutableFile = = null ) { throw new RuntimeException ( <str> ) ; } if ( ! gradleExecutableFile . exists ( ) ) { throw new RuntimeException ( <str> + gradleExecutableFile ) ; } executionCommandLine . add ( gradleExecutableFile . getAbsolutePath ( ) ) ; executionCommandLine . add ( <str> + ProtocolConstants . PORT_NUMBER_SYSTEM_PROPERTY + <str> + Integer . toString ( serverPort ) ) ; CommandLineAssistant commandLineAssistant = new CommandLineAssistant ( ) ; String [ ] individualCommandLineArguments = CommandLineAssistant . breakUpCommandLine ( commandLine ) ; executionCommandLine . addAll ( Arrays . asList ( individualCommandLineArguments ) ) ; File initStriptPath = getInitScriptFile ( ) ; if ( initStriptPath ! = null ) { executionCommandLine . add ( <str> + DefaultCommandLineConverter . INIT_SCRIPT ) ; executionCommandLine . add ( initStriptPath . getAbsolutePath ( ) ) ; executionInfo . initStriptPath = initStriptPath ; } if ( ! commandLineAssistant . hasLogLevelDefined ( individualCommandLineArguments ) ) { String logLevelText = commandLineAssistant . getLoggingCommandLineConverter ( ) . getLogLevelCommandLine ( logLevel ) ; if ( logLevelText ! = null & & ! <str> . equals ( logLevelText ) ) { executionCommandLine . add ( <str> + logLevelText ) ; } } if ( ! commandLineAssistant . hasShowStacktraceDefined ( individualCommandLineArguments ) ) { String stackTraceLevelText = commandLineAssistant . getLoggingCommandLineConverter ( ) . getShowStacktraceCommandLine ( stackTraceLevel ) ; if ( stackTraceLevelText ! = null ) { executionCommandLine . add ( <str> + stackTraceLevelText ) ; } } executionInfo . setCommandLineArguments ( executionCommandLine . toArray ( new String [ executionCommandLine . size ( ) ] ) ) ; return executionInfo ; } protected File getGradleExecutableFile ( ) { if ( customGradleExecutor ! = null ) { return customGradleExecutor ; } return new File ( gradleHomeDirectory , <str> + File . separator + getDefaultGradleExecutableName ( ) ) ; } private String getDefaultGradleExecutableName ( ) { return OperatingSystem . current ( ) . getScriptName ( <str> ) ; } public void clientCommunicationStopped ( ) { } public void clientExited ( int returnCode , String output ) { server . requestShutdown ( ) ; boolean wasPremature = false ; String message ; if ( ! hasCompletedConnection ) { message = <str> + commandLine + <str> + output ; wasPremature = true ; } else if ( ! hasReceivedBuildCompleteNotification ) { message = output ; wasPremature = true ; } else { message = output ; } reportClientExit ( wasPremature , returnCode , message ) ; } protected abstract void reportClientExit ( boolean wasPremature , int returnCode , String output ) ; public abstract File getInitScriptFile ( ) ; protected File extractInitScriptFile ( Class resourceClass , String resourceName ) { File file = null ; try { file = temporaryFileProvider . createTemporaryFile ( resourceName , INIT_SCRIPT_EXTENSION ) ; } catch ( UncheckedIOException e ) { logger . error ( <str> , e ) ; return null ; } file . deleteOnExit ( ) ; if ( extractResourceAsFile ( resourceClass , resourceName + INIT_SCRIPT_EXTENSION , file ) ) { return file ; } logger . error ( <str> ) ; return null ; } public boolean extractResourceAsFile ( Class resourceClass , String name , File file ) { InputStream stream = resourceClass . getResourceAsStream ( name ) ; if ( stream = = null ) { return false ; } byte [ ] bytes = new byte [ <int> ] ; try { bytes = IOUtils . toByteArray ( stream ) ; } catch ( IOException e ) { logger . error ( <str> , e ) ; return false ; } FileOutputStream fileOutputStream = null ; try { fileOutputStream = new FileOutputStream ( file ) ; try { IOUtils . write ( bytes , fileOutputStream ) ; } finally { fileOutputStream . close ( ) ; } return true ; } catch ( IOException e ) { logger . error ( <str> , e ) ; return false ; } finally { IOUtils . closeQuietly ( fileOutputStream ) ; } } protected File getGradleHomeDirectory ( ) { return gradleHomeDirectory ; } public void readFailureOccurred ( ) { logger . debug ( <str> + lastMessageReceived ) ; } public void aboutToKillProcess ( ) { killGradle ( ) ; } public void killGradle ( ) { if ( killGradleClientProcotol ! = null ) { killGradleClientProcotol . sendKillMessage ( ) ; } } } 
