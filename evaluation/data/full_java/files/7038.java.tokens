package org . elasticsearch . rest . action . count ; import org . elasticsearch . action . search . SearchRequest ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestActions ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestRequest . Method . POST ; import static org . elasticsearch . rest . action . support . RestActions . buildBroadcastShardsHeader ; import static org . elasticsearch . search . internal . SearchContext . DEFAULT_TERMINATE_AFTER ; public class RestCountAction extends BaseRestHandler { private final IndicesQueriesRegistry indicesQueriesRegistry ; @Inject public RestCountAction ( Settings settings , RestController controller , Client client , IndicesQueriesRegistry indicesQueriesRegistry ) { super ( settings , controller , client ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; this . indicesQueriesRegistry = indicesQueriesRegistry ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { SearchRequest countRequest = new SearchRequest ( Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ) ; countRequest . indicesOptions ( IndicesOptions . fromRequest ( request , countRequest . indicesOptions ( ) ) ) ; SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder ( ) . size ( <int> ) ; countRequest . source ( searchSourceBuilder ) ; if ( RestActions . hasBodyContent ( request ) ) { BytesReference restContent = RestActions . getRestContent ( request ) ; searchSourceBuilder . query ( RestActions . getQueryContent ( restContent , indicesQueriesRegistry , parseFieldMatcher ) ) ; } else { QueryBuilder < ? > queryBuilder = RestActions . urlParamsToQueryBuilder ( request ) ; if ( queryBuilder ! = null ) { searchSourceBuilder . query ( queryBuilder ) ; } } countRequest . routing ( request . param ( <str> ) ) ; float minScore = request . paramAsFloat ( <str> , - <float> ) ; if ( minScore ! = - <float> ) { searchSourceBuilder . minScore ( minScore ) ; } countRequest . types ( Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ) ; countRequest . preference ( request . param ( <str> ) ) ; final int terminateAfter = request . paramAsInt ( <str> , DEFAULT_TERMINATE_AFTER ) ; if ( terminateAfter < <int> ) { throw new IllegalArgumentException ( <str> ) ; } else if ( terminateAfter > <int> ) { searchSourceBuilder . terminateAfter ( terminateAfter ) ; } client . search ( countRequest , new RestBuilderListener < SearchResponse > ( channel ) { @Override public RestResponse buildResponse ( SearchResponse response , XContentBuilder builder ) throws Exception { builder . startObject ( ) ; if ( terminateAfter ! = DEFAULT_TERMINATE_AFTER ) { builder . field ( <str> , response . isTerminatedEarly ( ) ) ; } builder . field ( <str> , response . getHits ( ) . totalHits ( ) ) ; buildBroadcastShardsHeader ( builder , request , response . getTotalShards ( ) , response . getSuccessfulShards ( ) , response . getFailedShards ( ) , response . getShardFailures ( ) ) ; builder . endObject ( ) ; return new BytesRestResponse ( response . status ( ) , builder ) ; } } ) ; } } 
