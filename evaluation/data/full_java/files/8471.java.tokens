package org . elasticsearch . search . aggregations . metrics ; import org . apache . lucene . search . Explanation ; import org . apache . lucene . util . ArrayUtil ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . script . MockScriptEngine ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . SearchHitField ; import org . elasticsearch . search . SearchHits ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . search . aggregations . bucket . global . Global ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . nested . Nested ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . TermsAggregatorFactory . ExecutionMode ; import org . elasticsearch . search . aggregations . metrics . max . Max ; import org . elasticsearch . search . aggregations . metrics . tophits . TopHits ; import org . elasticsearch . search . highlight . HighlightBuilder ; import org . elasticsearch . search . highlight . HighlightField ; import org . elasticsearch . search . sort . SortBuilders ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . smileBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . yamlBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchQuery ; import static org . elasticsearch . index . query . QueryBuilders . nestedQuery ; import static org . elasticsearch . search . aggregations . AggregationBuilders . global ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . max ; import static org . elasticsearch . search . aggregations . AggregationBuilders . nested ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . search . aggregations . AggregationBuilders . topHits ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . arrayContaining ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . Matchers . not ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; import static org . hamcrest . Matchers . sameInstance ; @ESIntegTestCase.SuiteScopeTestCase ( ) public class TopHitsIT extends ESIntegTestCase { private static final String TERMS_AGGS_FIELD = <str> ; private static final String SORT_FIELD = <str> ; @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return Collections . singleton ( MockScriptEngine . TestPlugin . class ) ; } public static String randomExecutionHint ( ) { return randomBoolean ( ) ? null : randomFrom ( ExecutionMode . values ( ) ) . toString ( ) ; } static int numArticles ; @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , true ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureGreen ( <str> , <str> , <str> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , Integer . toString ( i ) ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( TERMS_AGGS_FIELD , <str> + ( i / <int> ) ) . field ( SORT_FIELD , i + <int> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) ) ) ; } builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <int> ) . endObject ( ) ) ) ; numArticles = scaledRandomIntBetween ( <int> , <int> ) ; numArticles - = ( numArticles % <int> ) ; for ( int i = <int> ; i < numArticles ; i + + ) { XContentBuilder builder = randomFrom ( jsonBuilder ( ) , yamlBuilder ( ) , smileBuilder ( ) ) ; builder . startObject ( ) . field ( <str> , i ) . startArray ( <str> ) ; for ( int j = <int> ; j < i ; j + + ) { String user = Integer . toString ( j ) ; builder . startObject ( ) . field ( <str> , j ) . field ( <str> , user ) . field ( <str> , <str> ) . endObject ( ) ; } builder . endArray ( ) . endObject ( ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setCreate ( true ) . setSource ( builder ) ) ; } builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . endArray ( ) . endObject ( ) ) ) ; builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <int> ) . field ( <str> , <str> ) . endObject ( ) . endArray ( ) . endObject ( ) ) ) ; indexRandom ( true , builders ) ; ensureSearchable ( ) ; } private String key ( Terms . Bucket bucket ) { return bucket . getKeyAsString ( ) ; } public void testBasics ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( TERMS_AGGS_FIELD ) . subAggregation ( topHits ( <str> ) . addSort ( SortBuilders . fieldSort ( SORT_FIELD ) . order ( SortOrder . DESC ) ) ) ) . get ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; long higestSortValue = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { Terms . Bucket bucket = terms . getBucketByKey ( <str> + i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( key ( bucket ) , equalTo ( <str> + i ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits hits = topHits . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( hits . getHits ( ) . length , equalTo ( <int> ) ) ; higestSortValue + = <int> ; assertThat ( ( Long ) hits . getAt ( <int> ) . sortValues ( ) [ <int> ] , equalTo ( higestSortValue ) ) ; assertThat ( ( Long ) hits . getAt ( <int> ) . sortValues ( ) [ <int> ] , equalTo ( higestSortValue - <int> ) ) ; assertThat ( ( Long ) hits . getAt ( <int> ) . sortValues ( ) [ <int> ] , equalTo ( higestSortValue - <int> ) ) ; assertThat ( hits . getAt ( <int> ) . sourceAsMap ( ) . size ( ) , equalTo ( <int> ) ) ; } } public void testIssue11119 ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . setSize ( <int> ) . setQuery ( matchQuery ( <str> , <str> ) ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( <str> ) . subAggregation ( topHits ( <str> ) ) ) . get ( ) ; assertSearchResponse ( response ) ; assertThat ( response . getHits ( ) . getTotalHits ( ) , equalTo ( <int> ) ) ; assertThat ( response . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; assertThat ( response . getHits ( ) . maxScore ( ) , equalTo ( <float> ) ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( Terms . Bucket bucket : terms . getBuckets ( ) ) { assertThat ( bucket , notNullValue ( ) ) ; TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits hits = topHits . getHits ( ) ; float bestScore = Float . MAX_VALUE ; for ( int h = <int> ; h < hits . getHits ( ) . length ; h + + ) { float score = hits . getAt ( h ) . getScore ( ) ; assertThat ( score , lessThanOrEqualTo ( bestScore ) ) ; assertThat ( score , greaterThan ( <float> ) ) ; bestScore = hits . getAt ( h ) . getScore ( ) ; } } response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . setSize ( <int> ) . setMinScore ( <float> ) . setQuery ( matchQuery ( <str> , <str> ) ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( <str> ) ) . get ( ) ; assertSearchResponse ( response ) ; assertThat ( response . getHits ( ) . getTotalHits ( ) , equalTo ( <int> ) ) ; assertThat ( response . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; assertThat ( response . getHits ( ) . maxScore ( ) , equalTo ( <float> ) ) ; terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testBreadthFirst ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . collectMode ( SubAggCollectionMode . BREADTH_FIRST ) . field ( TERMS_AGGS_FIELD ) . subAggregation ( topHits ( <str> ) . setSize ( <int> ) ) ) . get ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Terms . Bucket bucket = terms . getBucketByKey ( <str> + i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( key ( bucket ) , equalTo ( <str> + i ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits hits = topHits . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( hits . getHits ( ) . length , equalTo ( <int> ) ) ; assertThat ( hits . getAt ( <int> ) . sourceAsMap ( ) . size ( ) , equalTo ( <int> ) ) ; } } public void testBasicsGetProperty ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( global ( <str> ) . subAggregation ( topHits ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( searchResponse ) ; Global global = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( global , notNullValue ( ) ) ; assertThat ( global . getName ( ) , equalTo ( <str> ) ) ; assertThat ( global . getAggregations ( ) , notNullValue ( ) ) ; assertThat ( global . getAggregations ( ) . asMap ( ) . size ( ) , equalTo ( <int> ) ) ; TopHits topHits = global . getAggregations ( ) . get ( <str> ) ; assertThat ( topHits , notNullValue ( ) ) ; assertThat ( topHits . getName ( ) , equalTo ( <str> ) ) ; assertThat ( ( TopHits ) global . getProperty ( <str> ) , sameInstance ( topHits ) ) ; } public void testPagination ( ) throws Exception { int size = randomIntBetween ( <int> , <int> ) ; int from = randomIntBetween ( <int> , <int> ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( TERMS_AGGS_FIELD ) . subAggregation ( topHits ( <str> ) . addSort ( SortBuilders . fieldSort ( SORT_FIELD ) . order ( SortOrder . DESC ) ) . setFrom ( from ) . setSize ( size ) ) ) . get ( ) ; assertSearchResponse ( response ) ; SearchResponse control = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . setFrom ( from ) . setSize ( size ) . setPostFilter ( QueryBuilders . termQuery ( TERMS_AGGS_FIELD , <str> ) ) . addSort ( SORT_FIELD , SortOrder . DESC ) . get ( ) ; assertSearchResponse ( control ) ; SearchHits controlHits = control . getHits ( ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Terms . Bucket bucket = terms . getBucketByKey ( <str> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits hits = topHits . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( controlHits . totalHits ( ) ) ) ; assertThat ( hits . getHits ( ) . length , equalTo ( controlHits . getHits ( ) . length ) ) ; for ( int i = <int> ; i < hits . getHits ( ) . length ; i + + ) { logger . info ( i + <str> + hits . getAt ( i ) . id ( ) + <str> + hits . getAt ( i ) . sortValues ( ) [ <int> ] + <str> + controlHits . getAt ( i ) . id ( ) + <str> + controlHits . getAt ( i ) . sortValues ( ) [ <int> ] + <str> ) ; assertThat ( hits . getAt ( i ) . id ( ) , equalTo ( controlHits . getAt ( i ) . id ( ) ) ) ; assertThat ( hits . getAt ( i ) . sortValues ( ) [ <int> ] , equalTo ( controlHits . getAt ( i ) . sortValues ( ) [ <int> ] ) ) ; } } public void testSortByBucket ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( TERMS_AGGS_FIELD ) . order ( Terms . Order . aggregation ( <str> , false ) ) . subAggregation ( topHits ( <str> ) . addSort ( SortBuilders . fieldSort ( SORT_FIELD ) . order ( SortOrder . DESC ) ) . setTrackScores ( true ) ) . subAggregation ( max ( <str> ) . field ( SORT_FIELD ) ) ) . get ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; long higestSortValue = <int> ; int currentBucket = <int> ; for ( Terms . Bucket bucket : terms . getBuckets ( ) ) { assertThat ( key ( bucket ) , equalTo ( <str> + currentBucket - - ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits hits = topHits . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( hits . getHits ( ) . length , equalTo ( <int> ) ) ; assertThat ( ( Long ) hits . getAt ( <int> ) . sortValues ( ) [ <int> ] , equalTo ( higestSortValue ) ) ; assertThat ( ( Long ) hits . getAt ( <int> ) . sortValues ( ) [ <int> ] , equalTo ( higestSortValue - <int> ) ) ; assertThat ( ( Long ) hits . getAt ( <int> ) . sortValues ( ) [ <int> ] , equalTo ( higestSortValue - <int> ) ) ; Max max = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( max . getValue ( ) , equalTo ( ( ( Long ) higestSortValue ) . doubleValue ( ) ) ) ; higestSortValue - = <int> ; } } public void testFieldCollapsing ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . setSearchType ( SearchType . DFS_QUERY_THEN_FETCH ) . setQuery ( matchQuery ( <str> , <str> ) ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( <str> ) . order ( Terms . Order . aggregation ( <str> , false ) ) . subAggregation ( topHits ( <str> ) . setSize ( <int> ) ) . subAggregation ( max ( <str> ) . field ( <str> ) ) ) . get ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Iterator < Terms . Bucket > bucketIterator = terms . getBuckets ( ) . iterator ( ) ; Terms . Bucket bucket = bucketIterator . next ( ) ; assertThat ( key ( bucket ) , equalTo ( <str> ) ) ; TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits hits = topHits . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( hits . getHits ( ) . length , equalTo ( <int> ) ) ; assertThat ( hits . getAt ( <int> ) . id ( ) , equalTo ( <str> ) ) ; bucket = bucketIterator . next ( ) ; assertThat ( key ( bucket ) , equalTo ( <str> ) ) ; topHits = bucket . getAggregations ( ) . get ( <str> ) ; hits = topHits . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( hits . getHits ( ) . length , equalTo ( <int> ) ) ; assertThat ( hits . getAt ( <int> ) . id ( ) , equalTo ( <str> ) ) ; bucket = bucketIterator . next ( ) ; assertThat ( key ( bucket ) , equalTo ( <str> ) ) ; topHits = bucket . getAggregations ( ) . get ( <str> ) ; hits = topHits . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( hits . getHits ( ) . length , equalTo ( <int> ) ) ; assertThat ( hits . getAt ( <int> ) . id ( ) , equalTo ( <str> ) ) ; } public void testFetchFeatures ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . setQuery ( matchQuery ( <str> , <str> ) . queryName ( <str> ) ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( TERMS_AGGS_FIELD ) . subAggregation ( topHits ( <str> ) . setSize ( <int> ) . highlighter ( new HighlightBuilder ( ) . field ( <str> ) ) . setExplain ( true ) . addField ( <str> ) . addFieldDataField ( <str> ) . addScriptField ( <str> , new Script ( <str> , ScriptService . ScriptType . INLINE , MockScriptEngine . NAME , Collections . emptyMap ( ) ) ) . setFetchSource ( <str> , null ) . setVersion ( true ) ) ) . get ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( Terms . Bucket bucket : terms . getBuckets ( ) ) { TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits hits = topHits . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( hits . getHits ( ) . length , equalTo ( <int> ) ) ; SearchHit hit = hits . getAt ( <int> ) ; HighlightField highlightField = hit . getHighlightFields ( ) . get ( <str> ) ; assertThat ( highlightField . getFragments ( ) . length , equalTo ( <int> ) ) ; assertThat ( highlightField . getFragments ( ) [ <int> ] . string ( ) , equalTo ( <str> ) ) ; Explanation explanation = hit . explanation ( ) ; assertThat ( explanation . toString ( ) , containsString ( <str> ) ) ; long version = hit . version ( ) ; assertThat ( version , equalTo ( <int> ) ) ; assertThat ( hit . matchedQueries ( ) [ <int> ] , equalTo ( <str> ) ) ; SearchHitField field = hit . field ( <str> ) ; assertThat ( field . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( hit . getSource ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; field = hit . field ( <str> ) ; assertThat ( field . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( hit . sourceAsMap ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( hit . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } } public void testInvalidSortField ( ) throws Exception { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( TERMS_AGGS_FIELD ) . subAggregation ( topHits ( <str> ) . addSort ( SortBuilders . fieldSort ( <str> ) . order ( SortOrder . DESC ) ) ) ) . get ( ) ; fail ( ) ; } catch ( SearchPhaseExecutionException e ) { assertThat ( e . toString ( ) , containsString ( <str> ) ) ; } } public void testEmptyIndex ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( topHits ( <str> ) ) . get ( ) ; assertSearchResponse ( response ) ; TopHits hits = response . getAggregations ( ) . get ( <str> ) ; assertThat ( hits , notNullValue ( ) ) ; assertThat ( hits . getName ( ) , equalTo ( <str> ) ) ; assertThat ( hits . getHits ( ) . totalHits ( ) , equalTo ( <int> l ) ) ; } public void testTrackScores ( ) throws Exception { boolean [ ] trackScores = new boolean [ ] { true , false } ; for ( boolean trackScore : trackScores ) { logger . info ( <str> + trackScore ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . setQuery ( matchQuery ( <str> , <str> ) ) . addAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( topHits ( <str> ) . setTrackScores ( trackScore ) . setSize ( <int> ) . addSort ( <str> , SortOrder . DESC ) ) ) . get ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; Terms . Bucket bucket = terms . getBucketByKey ( <str> ) ; assertThat ( key ( bucket ) , equalTo ( <str> ) ) ; TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits hits = topHits . getHits ( ) ; assertThat ( hits . getMaxScore ( ) , trackScore ? not ( equalTo ( Float . NaN ) ) : equalTo ( Float . NaN ) ) ; assertThat ( hits . getAt ( <int> ) . score ( ) , trackScore ? not ( equalTo ( Float . NaN ) ) : equalTo ( Float . NaN ) ) ; bucket = terms . getBucketByKey ( <str> ) ; assertThat ( key ( bucket ) , equalTo ( <str> ) ) ; topHits = bucket . getAggregations ( ) . get ( <str> ) ; hits = topHits . getHits ( ) ; assertThat ( hits . getMaxScore ( ) , trackScore ? not ( equalTo ( Float . NaN ) ) : equalTo ( Float . NaN ) ) ; assertThat ( hits . getAt ( <int> ) . score ( ) , trackScore ? not ( equalTo ( Float . NaN ) ) : equalTo ( Float . NaN ) ) ; bucket = terms . getBucketByKey ( <str> ) ; assertThat ( key ( bucket ) , equalTo ( <str> ) ) ; topHits = bucket . getAggregations ( ) . get ( <str> ) ; hits = topHits . getHits ( ) ; assertThat ( hits . getMaxScore ( ) , trackScore ? not ( equalTo ( Float . NaN ) ) : equalTo ( Float . NaN ) ) ; assertThat ( hits . getAt ( <int> ) . score ( ) , trackScore ? not ( equalTo ( Float . NaN ) ) : equalTo ( Float . NaN ) ) ; } } public void testTopHitsInNestedSimple ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchQuery ( <str> , <str> ) ) . addAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( terms ( <str> ) . field ( <str> ) . subAggregation ( topHits ( <str> ) . addSort ( <str> , SortOrder . ASC ) ) ) ) . get ( ) ; Nested nested = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( nested . getDocCount ( ) , equalTo ( <int> ) ) ; Terms terms = nested . getAggregations ( ) . get ( <str> ) ; Terms . Bucket bucket = terms . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; TopHits topHits = bucket . getAggregations ( ) . get ( <str> ) ; SearchHits searchHits = topHits . getHits ( ) ; assertThat ( searchHits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchHits . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( searchHits . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) searchHits . getAt ( <int> ) . getSource ( ) . get ( <str> ) , equalTo ( <int> ) ) ; bucket = terms . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; topHits = bucket . getAggregations ( ) . get ( <str> ) ; searchHits = topHits . getHits ( ) ; assertThat ( searchHits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchHits . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( searchHits . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) searchHits . getAt ( <int> ) . getSource ( ) . get ( <str> ) , equalTo ( <int> ) ) ; assertThat ( searchHits . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( searchHits . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) searchHits . getAt ( <int> ) . getSource ( ) . get ( <str> ) , equalTo ( <int> ) ) ; bucket = terms . getBucketByKey ( <str> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; topHits = bucket . getAggregations ( ) . get ( <str> ) ; searchHits = topHits . getHits ( ) ; assertThat ( searchHits . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchHits . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( searchHits . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) searchHits . getAt ( <int> ) . getSource ( ) . get ( <str> ) , equalTo ( <int> ) ) ; } public void testTopHitsInSecondLayerNested ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchQuery ( <str> , <str> ) ) . addAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( topHits ( <str> ) . addSort ( <str> , SortOrder . ASC ) . addSort ( <str> , SortOrder . DESC ) . setSize ( <int> ) ) ) . subAggregation ( topHits ( <str> ) . addSort ( <str> , SortOrder . DESC ) . setSize ( <int> ) ) ) . get ( ) ; assertNoFailures ( searchResponse ) ; Nested toComments = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( toComments . getDocCount ( ) , equalTo ( <int> ) ) ; TopHits topComments = toComments . getAggregations ( ) . get ( <str> ) ; assertThat ( topComments . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( topComments . getHits ( ) . getHits ( ) . length , equalTo ( <int> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) , nullValue ( ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) , nullValue ( ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) , nullValue ( ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topComments . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) , nullValue ( ) ) ; Nested toReviewers = toComments . getAggregations ( ) . get ( <str> ) ; assertThat ( toReviewers . getDocCount ( ) , equalTo ( <int> ) ) ; TopHits topReviewers = toReviewers . getAggregations ( ) . get ( <str> ) ; assertThat ( topReviewers . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getHits ( ) . length , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( String ) topReviewers . getHits ( ) . getAt ( <int> ) . sourceAsMap ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( String ) topReviewers . getHits ( ) . getAt ( <int> ) . sourceAsMap ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( String ) topReviewers . getHits ( ) . getAt ( <int> ) . sourceAsMap ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( String ) topReviewers . getHits ( ) . getAt ( <int> ) . sourceAsMap ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( String ) topReviewers . getHits ( ) . getAt ( <int> ) . sourceAsMap ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( String ) topReviewers . getHits ( ) . getAt ( <int> ) . sourceAsMap ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getId ( ) , equalTo ( <str> ) ) ; assertThat ( ( String ) topReviewers . getHits ( ) . getAt ( <int> ) . sourceAsMap ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( topReviewers . getHits ( ) . getAt ( <int> ) . getNestedIdentity ( ) . getChild ( ) . getOffset ( ) , equalTo ( <int> ) ) ; } public void testNestedFetchFeatures ( ) { String hlType = randomFrom ( <str> , <str> , <str> ) ; HighlightBuilder . Field hlField = new HighlightBuilder . Field ( <str> ) . highlightQuery ( matchQuery ( <str> , <str> ) ) . forceSource ( randomBoolean ( ) ) . highlighterType ( hlType ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( nestedQuery ( <str> , matchQuery ( <str> , <str> ) . queryName ( <str> ) ) ) . addAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( topHits ( <str> ) . setSize ( <int> ) . highlighter ( new HighlightBuilder ( ) . field ( hlField ) ) . setExplain ( true ) . addFieldDataField ( <str> ) . addScriptField ( <str> , new Script ( <str> , ScriptService . ScriptType . INLINE , MockScriptEngine . NAME , Collections . emptyMap ( ) ) ) . setFetchSource ( <str> , null ) . setVersion ( true ) . addSort ( <str> , SortOrder . ASC ) ) ) . get ( ) ; assertHitCount ( searchResponse , <int> ) ; Nested nested = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( nested . getDocCount ( ) , equalTo ( <int> ) ) ; SearchHits hits = ( ( TopHits ) nested . getAggregations ( ) . get ( <str> ) ) . getHits ( ) ; assertThat ( hits . totalHits ( ) , equalTo ( <int> ) ) ; SearchHit searchHit = hits . getAt ( <int> ) ; assertThat ( searchHit . getId ( ) , equalTo ( <str> ) ) ; assertThat ( searchHit . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( searchHit . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; HighlightField highlightField = searchHit . getHighlightFields ( ) . get ( <str> ) ; assertThat ( highlightField . getFragments ( ) . length , equalTo ( <int> ) ) ; assertThat ( highlightField . getFragments ( ) [ <int> ] . string ( ) , equalTo ( <str> ) ) ; Explanation explanation = searchHit . explanation ( ) ; assertFalse ( explanation . isMatch ( ) ) ; long version = searchHit . version ( ) ; assertThat ( version , equalTo ( <int> ) ) ; assertThat ( searchHit . matchedQueries ( ) , arrayContaining ( <str> ) ) ; SearchHitField field = searchHit . field ( <str> ) ; assertThat ( field . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; field = searchHit . field ( <str> ) ; assertThat ( field . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( searchHit . sourceAsMap ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( searchHit . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } public void testTopHitsInNested ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( <str> ) . interval ( <int> ) . order ( Histogram . Order . aggregation ( <str> , true ) ) . subAggregation ( nested ( <str> ) . path ( <str> ) . subAggregation ( topHits ( <str> ) . highlighter ( new HighlightBuilder ( ) . field ( new HighlightBuilder . Field ( <str> ) . highlightQuery ( matchQuery ( <str> , <str> ) ) ) ) . addSort ( <str> , SortOrder . ASC ) ) ) ) . get ( ) ; Histogram histogram = searchResponse . getAggregations ( ) . get ( <str> ) ; for ( int i = <int> ; i < numArticles ; i + = <int> ) { Histogram . Bucket bucket = histogram . getBuckets ( ) . get ( i / <int> ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; long numNestedDocs = <int> + ( <int> * i ) ; Nested nested = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( nested . getDocCount ( ) , equalTo ( numNestedDocs ) ) ; TopHits hits = nested . getAggregations ( ) . get ( <str> ) ; SearchHits searchHits = hits . getHits ( ) ; assertThat ( searchHits . totalHits ( ) , equalTo ( numNestedDocs ) ) ; for ( int j = <int> ; j < <int> ; j + + ) { assertThat ( searchHits . getAt ( j ) . getNestedIdentity ( ) . getField ( ) . string ( ) , equalTo ( <str> ) ) ; assertThat ( searchHits . getAt ( j ) . getNestedIdentity ( ) . getOffset ( ) , equalTo ( <int> ) ) ; assertThat ( ( Integer ) searchHits . getAt ( j ) . sourceAsMap ( ) . get ( <str> ) , equalTo ( <int> ) ) ; HighlightField highlightField = searchHits . getAt ( j ) . getHighlightFields ( ) . get ( <str> ) ; assertThat ( highlightField . getFragments ( ) . length , equalTo ( <int> ) ) ; assertThat ( highlightField . getFragments ( ) [ <int> ] . string ( ) , equalTo ( <str> ) ) ; } } } public void testDontExplode ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( terms ( <str> ) . executionHint ( randomExecutionHint ( ) ) . field ( TERMS_AGGS_FIELD ) . subAggregation ( topHits ( <str> ) . setSize ( ArrayUtil . MAX_ARRAY_LENGTH - <int> ) . addSort ( SortBuilders . fieldSort ( SORT_FIELD ) . order ( SortOrder . DESC ) ) ) ) . get ( ) ; assertNoFailures ( response ) ; } } 
