package org . gradle . messaging . actor . internal ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . internal . concurrent . ThreadSafe ; import org . gradle . messaging . actor . Actor ; import org . gradle . messaging . actor . ActorFactory ; import org . gradle . messaging . dispatch . * ; import org . slf4j . LoggerFactory ; import java . util . IdentityHashMap ; import java . util . Map ; public class DefaultActorFactory implements ActorFactory , Stoppable { private final Map < Object , NonBlockingActor > nonBlockingActors = new IdentityHashMap < Object , NonBlockingActor > ( ) ; private final Map < Object , BlockingActor > blockingActors = new IdentityHashMap < Object , BlockingActor > ( ) ; private final Object lock = new Object ( ) ; private final ExecutorFactory executorFactory ; public DefaultActorFactory ( ExecutorFactory executorFactory ) { this . executorFactory = executorFactory ; } public void stop ( ) { synchronized ( lock ) { try { CompositeStoppable . stoppable ( nonBlockingActors . values ( ) ) . add ( blockingActors . values ( ) ) . stop ( ) ; } finally { nonBlockingActors . clear ( ) ; } } } public Actor createActor ( Object target ) { if ( target instanceof NonBlockingActor ) { return ( NonBlockingActor ) target ; } synchronized ( lock ) { if ( blockingActors . containsKey ( target ) ) { throw new UnsupportedOperationException ( <str> ) ; } NonBlockingActor actor = nonBlockingActors . get ( target ) ; if ( actor = = null ) { actor = new NonBlockingActor ( target ) ; nonBlockingActors . put ( target , actor ) ; } return actor ; } } public Actor createBlockingActor ( Object target ) { synchronized ( lock ) { if ( nonBlockingActors . containsKey ( target ) ) { throw new UnsupportedOperationException ( <str> ) ; } BlockingActor actor = blockingActors . get ( target ) ; if ( actor = = null ) { actor = new BlockingActor ( target ) ; blockingActors . put ( target , actor ) ; } return actor ; } } private void stopped ( NonBlockingActor actor ) { synchronized ( lock ) { nonBlockingActors . values ( ) . remove ( actor ) ; } } private void stopped ( BlockingActor actor ) { synchronized ( lock ) { blockingActors . values ( ) . remove ( actor ) ; } } private class BlockingActor implements Actor { private final Dispatch < MethodInvocation > dispatch ; private final Object lock = new Object ( ) ; private boolean stopped ; public BlockingActor ( Object target ) { dispatch = new ReflectionDispatch ( target ) ; } public < T > T getProxy ( Class < T > type ) { return new ProxyDispatchAdapter < T > ( this , type , ThreadSafe . class ) . getSource ( ) ; } public void stop ( ) throws DispatchException { synchronized ( lock ) { stopped = true ; } stopped ( this ) ; } public void dispatch ( MethodInvocation message ) { synchronized ( lock ) { if ( stopped ) { throw new IllegalStateException ( <str> ) ; } dispatch . dispatch ( message ) ; } } } private class NonBlockingActor implements Actor { private final Dispatch < MethodInvocation > dispatch ; private final StoppableExecutor executor ; private final ExceptionTrackingFailureHandler failureHandler ; public NonBlockingActor ( Object targetObject ) { executor = executorFactory . create ( String . format ( <str> , targetObject ) ) ; failureHandler = new ExceptionTrackingFailureHandler ( LoggerFactory . getLogger ( NonBlockingActor . class ) ) ; dispatch = new AsyncDispatch < MethodInvocation > ( executor , new FailureHandlingDispatch < MethodInvocation > ( new ReflectionDispatch ( targetObject ) , failureHandler ) ) ; } public < T > T getProxy ( Class < T > type ) { return new ProxyDispatchAdapter < T > ( this , type , ThreadSafe . class ) . getSource ( ) ; } public void stop ( ) { try { CompositeStoppable . stoppable ( dispatch , executor , failureHandler ) . stop ( ) ; } finally { stopped ( this ) ; } } public void dispatch ( MethodInvocation message ) { dispatch . dispatch ( message ) ; } } } 
