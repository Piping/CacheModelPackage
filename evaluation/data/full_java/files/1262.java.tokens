package org . apache . cassandra . utils . concurrent ; import java . util . Iterator ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public class Accumulator < E > implements Iterable < E > { private volatile int nextIndex ; private volatile int presentCount ; private final Object [ ] values ; private static final AtomicIntegerFieldUpdater < Accumulator > nextIndexUpdater = AtomicIntegerFieldUpdater . newUpdater ( Accumulator . class , <str> ) ; private static final AtomicIntegerFieldUpdater < Accumulator > presentCountUpdater = AtomicIntegerFieldUpdater . newUpdater ( Accumulator . class , <str> ) ; public Accumulator ( int size ) { values = new Object [ size ] ; } public void add ( E item ) { int insertPos ; while ( true ) { insertPos = nextIndex ; if ( insertPos > = values . length ) throw new IllegalStateException ( ) ; if ( nextIndexUpdater . compareAndSet ( this , insertPos , insertPos + <int> ) ) break ; } values [ insertPos ] = item ; boolean volatileWrite = false ; while ( true ) { int cur = presentCount ; if ( cur ! = insertPos & & ( cur = = values . length | | values [ cur ] = = null ) ) { if ( ! volatileWrite & & cur < insertPos & & ! presentCountUpdater . compareAndSet ( this , cur , cur ) ) { volatileWrite = true ; continue ; } return ; } presentCountUpdater . compareAndSet ( this , cur , cur + <int> ) ; volatileWrite = true ; } } public boolean isEmpty ( ) { return presentCount = = <int> ; } public int size ( ) { return presentCount ; } public int capacity ( ) { return values . length ; } public Iterator < E > iterator ( ) { return new Iterator < E > ( ) { int p = <int> ; public boolean hasNext ( ) { return p < presentCount ; } public E next ( ) { return ( E ) values [ p + + ] ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } public E get ( int i ) { if ( i > = presentCount ) throw new IndexOutOfBoundsException ( ) ; return ( E ) values [ i ] ; } } 
