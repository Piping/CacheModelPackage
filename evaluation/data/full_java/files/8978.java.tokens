package org . elasticsearch . test . cluster ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . OperationRouting ; import org . elasticsearch . cluster . routing . allocation . decider . AwarenessAllocationDecider ; import org . elasticsearch . cluster . service . PendingClusterTask ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . Lifecycle ; import org . elasticsearch . common . component . LifecycleListener ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . common . util . concurrent . FutureUtils ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . * ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . ScheduledFuture ; public class TestClusterService implements ClusterService { volatile ClusterState state ; private final List < ClusterStateListener > listeners = new CopyOnWriteArrayList < > ( ) ; private final Queue < NotifyTimeout > onGoingTimeouts = ConcurrentCollections . newQueue ( ) ; private final ThreadPool threadPool ; private final ESLogger logger = Loggers . getLogger ( getClass ( ) , Settings . EMPTY ) ; private final OperationRouting operationRouting = new OperationRouting ( Settings . Builder . EMPTY_SETTINGS , new AwarenessAllocationDecider ( ) ) ; public TestClusterService ( ) { this ( ClusterState . builder ( new ClusterName ( <str> ) ) . build ( ) ) ; } public TestClusterService ( ThreadPool threadPool ) { this ( ClusterState . builder ( new ClusterName ( <str> ) ) . build ( ) , threadPool ) ; } public TestClusterService ( ClusterState state ) { this ( state , null ) ; } public TestClusterService ( ClusterState state , @Nullable ThreadPool threadPool ) { if ( state . getNodes ( ) . size ( ) = = <int> ) { state = ClusterState . builder ( state ) . nodes ( DiscoveryNodes . builder ( ) . put ( new DiscoveryNode ( <str> , DummyTransportAddress . INSTANCE , Version . CURRENT ) ) . localNodeId ( <str> ) ) . build ( ) ; } assert state . getNodes ( ) . localNode ( ) ! = null ; this . state = state ; this . threadPool = threadPool ; } synchronized public ClusterState setState ( ClusterState state ) { assert state . getNodes ( ) . localNode ( ) ! = null ; state = ClusterState . builder ( state ) . version ( this . state . version ( ) + <int> ) . build ( ) ; return setStateAndNotifyListeners ( state ) ; } private ClusterState setStateAndNotifyListeners ( ClusterState state ) { ClusterChangedEvent event = new ClusterChangedEvent ( <str> , state , this . state ) ; this . state = state ; for ( ClusterStateListener listener : listeners ) { listener . clusterChanged ( event ) ; } return state ; } public ClusterState setState ( ClusterState . Builder state ) { return setState ( state . build ( ) ) ; } @Override public DiscoveryNode localNode ( ) { return state . getNodes ( ) . localNode ( ) ; } @Override public ClusterState state ( ) { return state ; } @Override public void addInitialStateBlock ( ClusterBlock block ) throws IllegalStateException { throw new UnsupportedOperationException ( ) ; } @Override public void removeInitialStateBlock ( ClusterBlock block ) throws IllegalStateException { throw new UnsupportedOperationException ( ) ; } @Override public OperationRouting operationRouting ( ) { return operationRouting ; } @Override public void addFirst ( ClusterStateListener listener ) { listeners . add ( <int> , listener ) ; } @Override public void addLast ( ClusterStateListener listener ) { listeners . add ( listener ) ; } @Override public void add ( ClusterStateListener listener ) { listeners . add ( listener ) ; } @Override public void remove ( ClusterStateListener listener ) { listeners . remove ( listener ) ; for ( Iterator < NotifyTimeout > it = onGoingTimeouts . iterator ( ) ; it . hasNext ( ) ; ) { NotifyTimeout timeout = it . next ( ) ; if ( timeout . listener . equals ( listener ) ) { timeout . cancel ( ) ; it . remove ( ) ; } } } @Override public void add ( LocalNodeMasterListener listener ) { throw new UnsupportedOperationException ( ) ; } @Override public void remove ( LocalNodeMasterListener listener ) { throw new UnsupportedOperationException ( ) ; } @Override public void add ( final TimeValue timeout , final TimeoutClusterStateListener listener ) { if ( threadPool = = null ) { throw new UnsupportedOperationException ( <str> ) ; } NotifyTimeout notifyTimeout = new NotifyTimeout ( listener , timeout ) ; notifyTimeout . future = threadPool . schedule ( timeout , ThreadPool . Names . GENERIC , notifyTimeout ) ; onGoingTimeouts . add ( notifyTimeout ) ; listeners . add ( listener ) ; listener . postAdded ( ) ; } @Override public void submitStateUpdateTask ( String source , ClusterStateUpdateTask updateTask ) { submitStateUpdateTask ( source , null , updateTask , updateTask , updateTask ) ; } @Override synchronized public < T > void submitStateUpdateTask ( String source , T task , ClusterStateTaskConfig config , ClusterStateTaskExecutor < T > executor , ClusterStateTaskListener listener ) { logger . debug ( <str> , source ) ; if ( state ( ) . nodes ( ) . localNodeMaster ( ) = = false & & executor . runOnlyOnMaster ( ) ) { listener . onNoLongerMaster ( source ) ; logger . debug ( <str> , source ) ; return ; } ClusterStateTaskExecutor . BatchResult < T > batchResult ; ClusterState previousClusterState = state ; try { batchResult = executor . execute ( previousClusterState , Arrays . asList ( task ) ) ; } catch ( Exception e ) { batchResult = ClusterStateTaskExecutor . BatchResult . < T > builder ( ) . failure ( task , e ) . build ( previousClusterState ) ; } batchResult . executionResults . get ( task ) . handle ( ( ) - > { } , ex - > listener . onFailure ( source , new ElasticsearchException ( <str> + source + <str> , ex ) ) ) ; setStateAndNotifyListeners ( batchResult . resultingState ) ; listener . clusterStateProcessed ( source , previousClusterState , batchResult . resultingState ) ; logger . debug ( <str> , source ) ; } @Override public TimeValue getMaxTaskWaitTime ( ) { throw new UnsupportedOperationException ( ) ; } @Override public List < PendingClusterTask > pendingTasks ( ) { throw new UnsupportedOperationException ( ) ; } @Override public int numberOfPendingTasks ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Lifecycle . State lifecycleState ( ) { throw new UnsupportedOperationException ( ) ; } @Override public void addLifecycleListener ( LifecycleListener listener ) { throw new UnsupportedOperationException ( ) ; } @Override public void removeLifecycleListener ( LifecycleListener listener ) { throw new UnsupportedOperationException ( ) ; } @Override public ClusterService start ( ) throws ElasticsearchException { throw new UnsupportedOperationException ( ) ; } @Override public ClusterService stop ( ) throws ElasticsearchException { throw new UnsupportedOperationException ( ) ; } @Override public void close ( ) throws ElasticsearchException { throw new UnsupportedOperationException ( ) ; } class NotifyTimeout implements Runnable { final TimeoutClusterStateListener listener ; final TimeValue timeout ; volatile ScheduledFuture future ; NotifyTimeout ( TimeoutClusterStateListener listener , TimeValue timeout ) { this . listener = listener ; this . timeout = timeout ; } public void cancel ( ) { FutureUtils . cancel ( future ) ; } @Override public void run ( ) { if ( future ! = null & & future . isCancelled ( ) ) { return ; } listener . onTimeout ( this . timeout ) ; } } } 
