package org . gradle . internal . resource . transport . http ; import org . apache . commons . lang . StringUtils ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . regex . Pattern ; public abstract class JavaSystemPropertiesProxySettings implements HttpProxySettings { private static final Logger LOGGER = LoggerFactory . getLogger ( JavaSystemPropertiesProxySettings . class ) ; private final HttpProxy proxy ; private final List < Pattern > nonProxyHosts ; private final String propertyPrefix ; private final int defaultPort ; public JavaSystemPropertiesProxySettings ( String propertyPrefix , int defaultPort ) { this ( propertyPrefix , defaultPort , System . getProperty ( propertyPrefix + <str> ) , System . getProperty ( propertyPrefix + <str> ) , System . getProperty ( propertyPrefix + <str> ) , System . getProperty ( propertyPrefix + <str> ) , System . getProperty ( propertyPrefix + <str> ) ) ; } JavaSystemPropertiesProxySettings ( String propertyPrefix , int defaultPort , String proxyHost , String proxyPortString , String proxyUser , String proxyPassword , String nonProxyHostsString ) { this . propertyPrefix = propertyPrefix ; this . defaultPort = defaultPort ; if ( StringUtils . isBlank ( proxyHost ) ) { this . proxy = null ; } else { this . proxy = new HttpProxy ( proxyHost , initProxyPort ( proxyPortString ) , proxyUser , proxyPassword ) ; } this . nonProxyHosts = initNonProxyHosts ( nonProxyHostsString ) ; } private int initProxyPort ( String proxyPortString ) { if ( StringUtils . isBlank ( proxyPortString ) ) { return defaultPort ; } try { return Integer . parseInt ( proxyPortString ) ; } catch ( NumberFormatException e ) { String key = propertyPrefix + <str> ; LOGGER . warn ( <str> , key , System . getProperty ( key ) , defaultPort ) ; return defaultPort ; } } private List < Pattern > initNonProxyHosts ( String nonProxyHostsString ) { if ( StringUtils . isBlank ( nonProxyHostsString ) ) { return Collections . emptyList ( ) ; } LOGGER . debug ( <str> , nonProxyHostsString ) ; List < Pattern > patterns = new ArrayList < Pattern > ( ) ; for ( String nonProxyHost : nonProxyHostsString . split ( <str> ) ) { patterns . add ( createHostMatcher ( nonProxyHost ) ) ; } return patterns ; } private Pattern createHostMatcher ( String nonProxyHost ) { if ( nonProxyHost . startsWith ( <str> ) ) { return Pattern . compile ( <str> + Pattern . quote ( nonProxyHost . substring ( <int> ) ) ) ; } if ( nonProxyHost . endsWith ( <str> ) ) { return Pattern . compile ( Pattern . quote ( nonProxyHost . substring ( <int> , nonProxyHost . length ( ) - <int> ) ) + <str> ) ; } return Pattern . compile ( Pattern . quote ( nonProxyHost ) ) ; } public HttpProxySettings . HttpProxy getProxy ( ) { return proxy ; } public HttpProxySettings . HttpProxy getProxy ( String host ) { if ( proxy = = null | | isNonProxyHost ( host ) ) { return null ; } return proxy ; } private boolean isNonProxyHost ( String host ) { for ( Pattern nonProxyHost : nonProxyHosts ) { if ( nonProxyHost . matcher ( host ) . matches ( ) ) { return true ; } } return false ; } public String getPropertyPrefix ( ) { return propertyPrefix ; } public int getDefaultPort ( ) { return defaultPort ; } } 
