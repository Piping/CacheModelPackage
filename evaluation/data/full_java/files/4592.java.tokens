package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IMemoryBlockExtension ; import org . eclipse . debug . core . model . MemoryByte ; import org . eclipse . debug . internal . ui . DebugUIMessages ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . internal . ui . memory . provisional . AbstractAsyncTableRendering ; import org . eclipse . debug . internal . ui . views . memory . MemoryViewUtil ; import org . eclipse . debug . ui . memory . MemoryRenderingElement ; import org . eclipse . jface . viewers . ICellModifier ; import org . eclipse . swt . widgets . TableItem ; public class AsyncTableRenderingCellModifier implements ICellModifier { private AbstractAsyncTableRendering fRendering ; private boolean fMBSupportsValueModification = false ; private ICellModifier fCustomModifier ; public AsyncTableRenderingCellModifier ( AbstractAsyncTableRendering rendering , ICellModifier customModifier ) { fRendering = rendering ; fCustomModifier = customModifier ; Job job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { fMBSupportsValueModification = fRendering . getMemoryBlock ( ) . supportsValueModification ( ) ; return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } @Override public boolean canModify ( Object element , String property ) { boolean canModify = true ; try { if ( ! ( element instanceof MemorySegment ) ) return false ; if ( ! isValueModificationSupported ( ) ) { return false ; } MemorySegment line = ( MemorySegment ) element ; if ( TableRenderingLine . P_ADDRESS . equals ( property ) ) { return false ; } int addressableSize = getAddressableSize ( ) ; int offset = Integer . valueOf ( property , <int> ) . intValue ( ) * addressableSize ; MemoryByte [ ] bytes = line . getBytes ( offset , fRendering . getBytesPerColumn ( ) ) ; if ( fCustomModifier ! = null ) { BigInteger address = line . getAddress ( ) . add ( BigInteger . valueOf ( offset ) ) ; MemoryRenderingElement mElement = new MemoryRenderingElement ( fRendering , address , bytes ) ; return fCustomModifier . canModify ( mElement , null ) ; } for ( int i = <int> ; i < bytes . length ; i + + ) { if ( ! bytes [ i ] . isWritable ( ) ) { canModify = false ; } } return canModify ; } catch ( NumberFormatException e ) { canModify = false ; return canModify ; } } private int getAddressableSize ( ) { int addressableSize = fRendering . getAddressableSize ( ) ; if ( addressableSize < <int> ) addressableSize = <int> ; return addressableSize ; } @Override public Object getValue ( Object element , String property ) { if ( ! ( element instanceof MemorySegment ) ) return null ; MemorySegment line = ( MemorySegment ) element ; try { if ( TableRenderingLine . P_ADDRESS . equals ( property ) ) return line . getAddress ( ) ; int offsetToLineBuffer = Integer . valueOf ( property , <int> ) . intValue ( ) * getAddressableSize ( ) ; MemoryByte [ ] memory = line . getBytes ( offsetToLineBuffer , fRendering . getBytesPerColumn ( ) ) ; int offsetFromLineAddress = Integer . valueOf ( property , <int> ) . intValue ( ) ; BigInteger address = line . getAddress ( ) . add ( BigInteger . valueOf ( offsetFromLineAddress ) ) ; if ( fCustomModifier ! = null ) { MemoryRenderingElement mElement = new MemoryRenderingElement ( fRendering , address , memory ) ; return fCustomModifier . getValue ( mElement , null ) ; } return fRendering . getString ( fRendering . getRenderingId ( ) , address , memory ) ; } catch ( NumberFormatException e ) { return <str> ; } } @Override public void modify ( Object element , final String property , final Object value ) { MemorySegment segment = null ; if ( element instanceof TableItem ) { Object data = ( ( TableItem ) element ) . getData ( ) ; if ( data ! = null & & data instanceof MemorySegment ) segment = ( MemorySegment ) data ; } else if ( element instanceof MemorySegment ) { segment = ( MemorySegment ) element ; } if ( segment = = null ) return ; final MemorySegment line = segment ; Job job = new Job ( <str> ) { @Override protected IStatus run ( IProgressMonitor monitor ) { try { final IMemoryBlock memoryBlk = fRendering . getMemoryBlock ( ) ; int offsetFromLineAddress = Integer . valueOf ( property , <int> ) . intValue ( ) ; final BigInteger offsetFromMBBase = getOffset ( memoryBlk , line . getAddress ( ) , offsetFromLineAddress ) ; int offsetToLineBuffer = Integer . valueOf ( property , <int> ) . intValue ( ) * getAddressableSize ( ) ; MemoryByte [ ] oldArray = line . getBytes ( offsetToLineBuffer , fRendering . getBytesPerColumn ( ) ) ; BigInteger address = line . getAddress ( ) ; address = address . add ( BigInteger . valueOf ( offsetFromLineAddress ) ) ; if ( fCustomModifier ! = null ) { MemoryRenderingElement mElement = new MemoryRenderingElement ( fRendering , address , oldArray ) ; fCustomModifier . modify ( mElement , null , value ) ; return Status . OK_STATUS ; } if ( ! ( value instanceof String ) ) { DebugUIPlugin . logErrorMessage ( <str> ) ; return Status . OK_STATUS ; } byte [ ] bytes = null ; String oldValue = ( String ) getValue ( line , property ) ; if ( ! oldValue . equals ( value ) ) { bytes = fRendering . getBytes ( fRendering . getRenderingId ( ) , address , oldArray , ( String ) value ) ; if ( bytes = = null ) return Status . OK_STATUS ; if ( bytes . length = = <int> ) return Status . OK_STATUS ; if ( bytes . length < = oldArray . length ) { boolean changed = false ; for ( int i = <int> ; i < bytes . length ; i + + ) { if ( bytes [ i ] ! = oldArray [ i ] . getValue ( ) ) { changed = true ; break ; } } if ( ! changed ) return Status . OK_STATUS ; } } else { return Status . OK_STATUS ; } final byte [ ] newByteValues = bytes ; if ( memoryBlk instanceof IMemoryBlockExtension ) ( ( IMemoryBlockExtension ) memoryBlk ) . setValue ( offsetFromMBBase , newByteValues ) ; else memoryBlk . setValue ( offsetFromMBBase . longValue ( ) , newByteValues ) ; } catch ( DebugException e ) { MemoryViewUtil . openError ( DebugUIMessages . MemoryViewCellModifier_failure_title , DebugUIMessages . MemoryViewCellModifier_failed , e ) ; } catch ( NumberFormatException e ) { MemoryViewUtil . openError ( DebugUIMessages . MemoryViewCellModifier_failure_title , DebugUIMessages . MemoryViewCellModifier_failed + <str> + DebugUIMessages . MemoryViewCellModifier_data_is_invalid , null ) ; } return Status . OK_STATUS ; } } ; job . setSystem ( true ) ; job . schedule ( ) ; } private BigInteger getOffset ( IMemoryBlock memory , BigInteger lineAddress , int lineOffset ) throws DebugException { BigInteger memoryAddr ; if ( memory instanceof IMemoryBlockExtension ) { memoryAddr = ( ( IMemoryBlockExtension ) memory ) . getBigBaseAddress ( ) ; } else { memoryAddr = BigInteger . valueOf ( memory . getStartAddress ( ) ) ; } if ( memoryAddr = = null ) memoryAddr = new BigInteger ( <str> ) ; return lineAddress . subtract ( memoryAddr ) . add ( BigInteger . valueOf ( lineOffset ) ) ; } private boolean isValueModificationSupported ( ) { return fMBSupportsValueModification ; } } 
