package io . netty . handler . codec . http ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . compression . ZlibCodecFactory ; import io . netty . handler . codec . compression . ZlibWrapper ; import io . netty . util . internal . StringUtil ; public class HttpContentCompressor extends HttpContentEncoder { private final int compressionLevel ; private final int windowBits ; private final int memLevel ; public HttpContentCompressor ( ) { this ( <int> ) ; } public HttpContentCompressor ( int compressionLevel ) { this ( compressionLevel , <int> , <int> ) ; } public HttpContentCompressor ( int compressionLevel , int windowBits , int memLevel ) { if ( compressionLevel < <int> | | compressionLevel > <int> ) { throw new IllegalArgumentException ( <str> + compressionLevel + <str> ) ; } if ( windowBits < <int> | | windowBits > <int> ) { throw new IllegalArgumentException ( <str> + windowBits + <str> ) ; } if ( memLevel < <int> | | memLevel > <int> ) { throw new IllegalArgumentException ( <str> + memLevel + <str> ) ; } this . compressionLevel = compressionLevel ; this . windowBits = windowBits ; this . memLevel = memLevel ; } @Override protected Result beginEncode ( HttpResponse headers , String acceptEncoding ) throws Exception { String contentEncoding = headers . headers ( ) . get ( HttpHeaderNames . CONTENT_ENCODING ) ; if ( contentEncoding ! = null & & ! HttpHeaderValues . IDENTITY . contentEqualsIgnoreCase ( contentEncoding ) ) { return null ; } ZlibWrapper wrapper = determineWrapper ( acceptEncoding ) ; if ( wrapper = = null ) { return null ; } String targetContentEncoding ; switch ( wrapper ) { case GZIP : targetContentEncoding = <str> ; break ; case ZLIB : targetContentEncoding = <str> ; break ; default : throw new Error ( ) ; } return new Result ( targetContentEncoding , new EmbeddedChannel ( ZlibCodecFactory . newZlibEncoder ( wrapper , compressionLevel , windowBits , memLevel ) ) ) ; } @SuppressWarnings ( <str> ) protected ZlibWrapper determineWrapper ( String acceptEncoding ) { float starQ = - <float> ; float gzipQ = - <float> ; float deflateQ = - <float> ; for ( String encoding : StringUtil . split ( acceptEncoding , <str> ) ) { float q = <float> ; int equalsPos = encoding . indexOf ( <str> ) ; if ( equalsPos ! = - <int> ) { try { q = Float . valueOf ( encoding . substring ( equalsPos + <int> ) ) ; } catch ( NumberFormatException e ) { q = <float> ; } } if ( encoding . contains ( <str> ) ) { starQ = q ; } else if ( encoding . contains ( <str> ) & & q > gzipQ ) { gzipQ = q ; } else if ( encoding . contains ( <str> ) & & q > deflateQ ) { deflateQ = q ; } } if ( gzipQ > <float> | | deflateQ > <float> ) { if ( gzipQ > = deflateQ ) { return ZlibWrapper . GZIP ; } else { return ZlibWrapper . ZLIB ; } } if ( starQ > <float> ) { if ( gzipQ = = - <float> ) { return ZlibWrapper . GZIP ; } if ( deflateQ = = - <float> ) { return ZlibWrapper . ZLIB ; } } return null ; } } 
