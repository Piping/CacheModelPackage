package org . eclipse . debug . internal . ui . viewers ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . jface . viewers . TreePath ; public class ModelNode { private Object fElement ; private boolean fIsContainer ; private ModelNode fParent ; private ModelNode [ ] fChildren ; private boolean fDisposed ; public ModelNode ( ModelNode parent , Object element ) { fParent = parent ; fElement = element ; } public synchronized Object getElement ( ) { return fElement ; } public synchronized void remap ( Object element ) { fElement = element ; } public ModelNode getParentNode ( ) { return fParent ; } public synchronized boolean isContainer ( ) { return fIsContainer ; } public synchronized ModelNode [ ] getChildrenNodes ( ) { return fChildren ; } public synchronized boolean isDisposed ( ) { return fDisposed ; } public synchronized void dispose ( ) { fDisposed = true ; ModelNode [ ] childrenNodes = getChildrenNodes ( ) ; if ( childrenNodes ! = null ) { for ( int i = <int> ; i < childrenNodes . length ; i + + ) { childrenNodes [ i ] . dispose ( ) ; } } } public synchronized boolean correspondsTo ( TreePath path ) { int index = path . getSegmentCount ( ) - <int> ; ModelNode node = this ; while ( index > = <int> & & node ! = null ) { Object pathElement = path . getSegment ( index ) ; if ( pathElement . equals ( node . getElement ( ) ) ) { index - - ; node = node . getParentNode ( ) ; } else { return false ; } } return index = = - <int> ; } public synchronized TreePath getTreePath ( ) { List < Object > path = new ArrayList < Object > ( ) ; ModelNode node = this ; while ( node ! = null ) { path . add ( <int> , node . getElement ( ) ) ; node = node . getParentNode ( ) ; } return new TreePath ( path . toArray ( ) ) ; } public synchronized void addChild ( ModelNode child ) { if ( fChildren = = null ) { fChildren = new ModelNode [ ] { child } ; } else { ModelNode [ ] kids = new ModelNode [ fChildren . length + <int> ] ; System . arraycopy ( fChildren , <int> , kids , <int> , fChildren . length ) ; kids [ fChildren . length ] = child ; fChildren = kids ; } } public synchronized void removeChild ( ModelNode child ) { if ( fChildren ! = null ) { for ( int i = <int> ; i < fChildren . length ; i + + ) { ModelNode kid = fChildren [ i ] ; if ( child = = kid ) { ModelNode [ ] newNodes = new ModelNode [ fChildren . length - <int> ] ; System . arraycopy ( fChildren , <int> , newNodes , <int> , i ) ; if ( i < newNodes . length ) { System . arraycopy ( fChildren , i + <int> , newNodes , i , newNodes . length - i ) ; } fChildren = newNodes ; return ; } } } } public synchronized void setChildren ( ModelNode [ ] children ) { if ( children ! = null & & children . length = = <int> ) { fChildren = null ; setIsContainer ( false ) ; } else { fChildren = children ; } } public synchronized int getChildCount ( ) { if ( fChildren = = null ) { if ( isContainer ( ) ) { return <int> ; } return <int> ; } return fChildren . length ; } public synchronized int getChildIndex ( ModelNode child ) { if ( fChildren ! = null ) { for ( int i = <int> ; i < fChildren . length ; i + + ) { if ( child = = fChildren [ i ] ) { return i ; } } } return - <int> ; } public synchronized void setIsContainer ( boolean container ) { fIsContainer = container ; } @Override public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ; if ( isDisposed ( ) ) { buf . append ( <str> ) ; } if ( isContainer ( ) ) { buf . append ( <str> ) ; } buf . append ( getElement ( ) ) ; return buf . toString ( ) ; } } 
