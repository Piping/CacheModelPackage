package org . apache . cassandra . utils ; import java . util . * ; import java . util . concurrent . ThreadLocalRandom ; import com . google . common . collect . Iterables ; import org . junit . Test ; import junit . framework . Assert ; import org . apache . cassandra . utils . btree . BTree ; import org . apache . cassandra . utils . btree . UpdateFunction ; import static org . junit . Assert . * ; public class BTreeTest { static Integer [ ] ints = new Integer [ <int> ] ; static { System . setProperty ( <str> , <str> ) ; for ( int i = <int> ; i < ints . length ; i + + ) ints [ i ] = new Integer ( i ) ; } static final UpdateFunction < Integer , Integer > updateF = new UpdateFunction < Integer , Integer > ( ) { public Integer apply ( Integer replacing , Integer update ) { return ints [ update ] ; } public boolean abortEarly ( ) { return false ; } public void allocated ( long heapSize ) { } public Integer apply ( Integer integer ) { return ints [ integer ] ; } } ; private static final UpdateFunction < Integer , Integer > noOp = new UpdateFunction < Integer , Integer > ( ) { public Integer apply ( Integer replacing , Integer update ) { return update ; } public boolean abortEarly ( ) { return false ; } public void allocated ( long heapSize ) { } public Integer apply ( Integer k ) { return k ; } } ; private static List < Integer > seq ( int count ) { List < Integer > r = new ArrayList < > ( ) ; for ( int i = <int> ; i < count ; i + + ) r . add ( i ) ; return r ; } private static List < Integer > rand ( int count ) { Random rand = ThreadLocalRandom . current ( ) ; List < Integer > r = seq ( count ) ; for ( int i = <int> ; i < count - <int> ; i + + ) { int swap = i + rand . nextInt ( count - i ) ; Integer tmp = r . get ( i ) ; r . set ( i , r . get ( swap ) ) ; r . set ( swap , tmp ) ; } return r ; } private static final Comparator < Integer > CMP = new Comparator < Integer > ( ) { public int compare ( Integer o1 , Integer o2 ) { return Integer . compare ( o1 , o2 ) ; } } ; @Test public void testBuilding_UpdateFunctionReplacement ( ) { for ( int i = <int> ; i < <int> ; i + + ) checkResult ( i , BTree . build ( seq ( i ) , updateF ) ) ; } @Test public void testUpdate_UpdateFunctionReplacement ( ) { for ( int i = <int> ; i < <int> ; i + + ) checkResult ( i , BTree . update ( BTree . build ( seq ( i ) , noOp ) , CMP , seq ( i ) , updateF ) ) ; } @Test public void testUpdate_UpdateFunctionCallBack ( ) { Object [ ] btree = new Object [ <int> ] ; CallsMonitor monitor = new CallsMonitor ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( <int> ) , monitor ) ; assertArrayEquals ( new Object [ ] { <int> } , btree ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; monitor . clear ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( <int> ) , monitor ) ; assertArrayEquals ( new Object [ ] { <int> , <int> , null } , btree ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; monitor . clear ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( <int> ) , monitor ) ; assertArrayEquals ( new Object [ ] { <int> , <int> , null } , btree ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; monitor . clear ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( <int> , <int> ) , monitor ) ; assertArrayEquals ( new Object [ ] { <int> , <int> , <int> , <int> , null } , btree ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; monitor . clear ( ) ; btree = BTree . update ( btree , CMP , Arrays . asList ( <int> , <int> ) , monitor ) ; assertArrayEquals ( new Object [ ] { <int> , new Object [ ] { <int> , <int> , null } , new Object [ ] { <int> , <int> , null } , new int [ ] { <int> , <int> } } , btree ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; } @Test public void testBuilding_UpdateFunctionCallBack ( ) { CallsMonitor monitor = new CallsMonitor ( ) ; Object [ ] btree = BTree . build ( Arrays . asList ( <int> ) , monitor ) ; assertArrayEquals ( new Object [ ] { <int> } , btree ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; monitor . clear ( ) ; btree = BTree . build ( Arrays . asList ( <int> , <int> ) , monitor ) ; assertArrayEquals ( new Object [ ] { <int> , <int> , null } , btree ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; monitor . clear ( ) ; btree = BTree . build ( Arrays . asList ( <int> , <int> , <int> ) , monitor ) ; assertArrayEquals ( new Object [ ] { <int> , <int> , <int> } , btree ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; assertEquals ( <int> , monitor . getNumberOfCalls ( <int> ) ) ; } @Test public void testBuilder_QuickResolver ( ) { BTree . Builder . QuickResolver < Accumulator > resolver = ( a , b ) - > new Accumulator ( a . base , a . sum + b . sum ) ; for ( int count = <int> ; count < <int> ; count + + ) { BTree . Builder < Accumulator > builder ; List < Accumulator > sorted = resolverInput ( count , false ) ; builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; builder . setQuickResolver ( resolver ) ; for ( Accumulator i : sorted ) builder . add ( i ) ; checkResolverOutput ( count , builder . build ( ) , BTree . Dir . ASC ) ; builder . reuse ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { for ( Accumulator j : resolverInput ( count , true ) ) builder . add ( j ) ; checkResolverOutput ( count , builder . build ( ) , BTree . Dir . ASC ) ; builder . reuse ( ) ; } for ( List < Accumulator > add : splitResolverInput ( count ) ) { if ( ThreadLocalRandom . current ( ) . nextBoolean ( ) ) builder . addAll ( add ) ; else builder . addAll ( new TreeSet < > ( add ) ) ; } checkResolverOutput ( count , builder . build ( ) , BTree . Dir . ASC ) ; builder . reuse ( ) ; } } private static class Accumulator extends Number implements Comparable < Accumulator > { final int base ; final int sum ; private Accumulator ( int base , int sum ) { this . base = base ; this . sum = sum ; } public int compareTo ( Accumulator that ) { return Integer . compare ( base , that . base ) ; } public int intValue ( ) { return sum ; } public long longValue ( ) { return sum ; } public float floatValue ( ) { return sum ; } public double doubleValue ( ) { return sum ; } } @Test public void testBuilder_ResolverAndReverse ( ) { BTree . Builder . Resolver resolver = ( array , lb , ub ) - > { int sum = <int> ; for ( int i = lb ; i < ub ; i + + ) sum + = ( ( Accumulator ) array [ i ] ) . sum ; return new Accumulator ( ( ( Accumulator ) array [ lb ] ) . base , sum ) ; } ; for ( int count = <int> ; count < <int> ; count + + ) { BTree . Builder < Accumulator > builder ; List < Accumulator > sorted = resolverInput ( count , false ) ; builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; builder . auto ( false ) ; for ( Accumulator i : sorted ) builder . add ( i ) ; Assert . assertTrue ( Iterables . elementsEqual ( sorted , BTree . iterable ( builder . build ( ) ) ) ) ; checkResolverOutput ( count , builder . resolve ( resolver ) . build ( ) , BTree . Dir . ASC ) ; builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; builder . auto ( false ) ; for ( int i = <int> ; i < <int> ; i + + ) { for ( Accumulator j : resolverInput ( count , true ) ) builder . add ( j ) ; checkResolverOutput ( count , builder . sort ( ) . resolve ( resolver ) . build ( ) , BTree . Dir . ASC ) ; builder . reuse ( ) ; for ( Accumulator j : resolverInput ( count , true ) ) builder . add ( j ) ; checkResolverOutput ( count , builder . sort ( ) . reverse ( ) . resolve ( resolver ) . build ( ) , BTree . Dir . DESC ) ; builder . reuse ( ) ; } } } private static List < Accumulator > resolverInput ( int count , boolean shuffled ) { List < Accumulator > result = new ArrayList < > ( ) ; for ( int i = <int> ; i < = count ; i + + ) for ( int j = <int> ; j < i ; j + + ) result . add ( new Accumulator ( i , i ) ) ; if ( shuffled ) { ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; for ( int i = <int> ; i < result . size ( ) ; i + + ) { int swapWith = random . nextInt ( i , result . size ( ) ) ; Accumulator t = result . get ( swapWith ) ; result . set ( swapWith , result . get ( i ) ) ; result . set ( i , t ) ; } } return result ; } private static List < List < Accumulator > > splitResolverInput ( int count ) { List < Accumulator > all = resolverInput ( count , false ) ; List < List < Accumulator > > result = new ArrayList < > ( ) ; while ( ! all . isEmpty ( ) ) { List < Accumulator > is = new ArrayList < > ( ) ; int prev = - <int> ; for ( Accumulator i : new ArrayList < > ( all ) ) { if ( i . base = = prev ) continue ; is . add ( i ) ; all . remove ( i ) ; prev = i . base ; } result . add ( is ) ; } return result ; } private static void checkResolverOutput ( int count , Object [ ] btree , BTree . Dir dir ) { int i = <int> ; for ( Accumulator current : BTree . < Accumulator > iterable ( btree , dir ) ) { Assert . assertEquals ( i * i , current . sum ) ; i + + ; } Assert . assertEquals ( i , count + <int> ) ; } private static void checkResult ( int count , Object [ ] btree ) { Iterator < Integer > iter = BTree . slice ( btree , CMP , BTree . Dir . ASC ) ; int i = <int> ; while ( iter . hasNext ( ) ) assertEquals ( iter . next ( ) , ints [ i + + ] ) ; assertEquals ( count , i ) ; } @Test public void testClearOnAbort ( ) { Object [ ] btree = BTree . build ( seq ( <int> ) , noOp ) ; Object [ ] copy = Arrays . copyOf ( btree , btree . length ) ; BTree . update ( btree , CMP , seq ( <int> ) , new AbortAfterX ( <int> ) ) ; assertArrayEquals ( copy , btree ) ; btree = BTree . update ( btree , CMP , seq ( <int> ) , noOp ) ; assertTrue ( BTree . isWellFormed ( btree , CMP ) ) ; } private static final class AbortAfterX implements UpdateFunction < Integer , Integer > { int counter ; final int abortAfter ; private AbortAfterX ( int abortAfter ) { this . abortAfter = abortAfter ; } public Integer apply ( Integer replacing , Integer update ) { return update ; } public boolean abortEarly ( ) { return counter + + > abortAfter ; } public void allocated ( long heapSize ) { } public Integer apply ( Integer v ) { return v ; } } public static final class CallsMonitor implements UpdateFunction < Integer , Integer > { private int [ ] numberOfCalls = new int [ <int> ] ; public Integer apply ( Integer replacing , Integer update ) { numberOfCalls [ update ] = numberOfCalls [ update ] + <int> ; return update ; } public boolean abortEarly ( ) { return false ; } public void allocated ( long heapSize ) { } public Integer apply ( Integer integer ) { numberOfCalls [ integer ] = numberOfCalls [ integer ] + <int> ; return integer ; } public int getNumberOfCalls ( Integer key ) { return numberOfCalls [ key ] ; } public void clear ( ) { Arrays . fill ( numberOfCalls , <int> ) ; } } ; } 
