package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import net . jpountz . lz4 . LZ4Exception ; import net . jpountz . lz4 . LZ4Factory ; import net . jpountz . lz4 . LZ4FastDecompressor ; import net . jpountz . xxhash . XXHashFactory ; import java . util . List ; import java . util . zip . Checksum ; import static io . netty . handler . codec . compression . Lz4Constants . * ; public class Lz4FrameDecoder extends ByteToMessageDecoder { private enum State { INIT_BLOCK , DECOMPRESS_DATA , FINISHED , CORRUPTED } private State currentState = State . INIT_BLOCK ; private LZ4FastDecompressor decompressor ; private Checksum checksum ; private int blockType ; private int compressedLength ; private int decompressedLength ; private int currentChecksum ; public Lz4FrameDecoder ( ) { this ( false ) ; } public Lz4FrameDecoder ( boolean validateChecksums ) { this ( LZ4Factory . fastestInstance ( ) , validateChecksums ) ; } public Lz4FrameDecoder ( LZ4Factory factory , boolean validateChecksums ) { this ( factory , validateChecksums ? XXHashFactory . fastestInstance ( ) . newStreamingHash32 ( DEFAULT_SEED ) . asChecksum ( ) : null ) ; } public Lz4FrameDecoder ( LZ4Factory factory , Checksum checksum ) { if ( factory = = null ) { throw new NullPointerException ( <str> ) ; } decompressor = factory . fastDecompressor ( ) ; this . checksum = checksum ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { try { switch ( currentState ) { case INIT_BLOCK : if ( in . readableBytes ( ) < HEADER_LENGTH ) { break ; } final long magic = in . readLong ( ) ; if ( magic ! = MAGIC_NUMBER ) { throw new DecompressionException ( <str> ) ; } final int token = in . readByte ( ) ; final int compressionLevel = ( token & <hex> ) + COMPRESSION_LEVEL_BASE ; int blockType = token & <hex> ; int compressedLength = Integer . reverseBytes ( in . readInt ( ) ) ; if ( compressedLength < <int> | | compressedLength > MAX_BLOCK_SIZE ) { throw new DecompressionException ( String . format ( <str> , compressedLength , MAX_BLOCK_SIZE ) ) ; } int decompressedLength = Integer . reverseBytes ( in . readInt ( ) ) ; final int maxDecompressedLength = <int> < < compressionLevel ; if ( decompressedLength < <int> | | decompressedLength > maxDecompressedLength ) { throw new DecompressionException ( String . format ( <str> , decompressedLength , maxDecompressedLength ) ) ; } if ( decompressedLength = = <int> & & compressedLength ! = <int> | | decompressedLength ! = <int> & & compressedLength = = <int> | | blockType = = BLOCK_TYPE_NON_COMPRESSED & & decompressedLength ! = compressedLength ) { throw new DecompressionException ( String . format ( <str> , compressedLength , decompressedLength ) ) ; } int currentChecksum = Integer . reverseBytes ( in . readInt ( ) ) ; if ( decompressedLength = = <int> & & compressedLength = = <int> ) { if ( currentChecksum ! = <int> ) { throw new DecompressionException ( <str> ) ; } currentState = State . FINISHED ; decompressor = null ; checksum = null ; break ; } this . blockType = blockType ; this . compressedLength = compressedLength ; this . decompressedLength = decompressedLength ; this . currentChecksum = currentChecksum ; currentState = State . DECOMPRESS_DATA ; case DECOMPRESS_DATA : blockType = this . blockType ; compressedLength = this . compressedLength ; decompressedLength = this . decompressedLength ; currentChecksum = this . currentChecksum ; if ( in . readableBytes ( ) < compressedLength ) { break ; } final int idx = in . readerIndex ( ) ; ByteBuf uncompressed = ctx . alloc ( ) . heapBuffer ( decompressedLength , decompressedLength ) ; final byte [ ] dest = uncompressed . array ( ) ; final int destOff = uncompressed . arrayOffset ( ) + uncompressed . writerIndex ( ) ; boolean success = false ; try { switch ( blockType ) { case BLOCK_TYPE_NON_COMPRESSED : { in . getBytes ( idx , dest , destOff , decompressedLength ) ; break ; } case BLOCK_TYPE_COMPRESSED : { final byte [ ] src ; final int srcOff ; if ( in . hasArray ( ) ) { src = in . array ( ) ; srcOff = in . arrayOffset ( ) + idx ; } else { src = new byte [ compressedLength ] ; in . getBytes ( idx , src ) ; srcOff = <int> ; } try { final int readBytes = decompressor . decompress ( src , srcOff , dest , destOff , decompressedLength ) ; if ( compressedLength ! = readBytes ) { throw new DecompressionException ( String . format ( <str> , compressedLength , readBytes ) ) ; } } catch ( LZ4Exception e ) { throw new DecompressionException ( e ) ; } break ; } default : throw new DecompressionException ( String . format ( <str> , blockType , BLOCK_TYPE_NON_COMPRESSED , BLOCK_TYPE_COMPRESSED ) ) ; } final Checksum checksum = this . checksum ; if ( checksum ! = null ) { checksum . reset ( ) ; checksum . update ( dest , destOff , decompressedLength ) ; final int checksumResult = ( int ) checksum . getValue ( ) ; if ( checksumResult ! = currentChecksum ) { throw new DecompressionException ( String . format ( <str> , checksumResult , currentChecksum ) ) ; } } uncompressed . writerIndex ( uncompressed . writerIndex ( ) + decompressedLength ) ; out . add ( uncompressed ) ; in . skipBytes ( compressedLength ) ; currentState = State . INIT_BLOCK ; success = true ; } finally { if ( ! success ) { uncompressed . release ( ) ; } } break ; case FINISHED : case CORRUPTED : in . skipBytes ( in . readableBytes ( ) ) ; break ; default : throw new IllegalStateException ( ) ; } } catch ( Exception e ) { currentState = State . CORRUPTED ; throw e ; } } public boolean isClosed ( ) { return currentState = = State . FINISHED ; } } 
