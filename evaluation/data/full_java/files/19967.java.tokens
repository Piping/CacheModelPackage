package io . netty . handler . ssl ; import io . netty . buffer . ByteBufAllocator ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import javax . crypto . NoSuchPaddingException ; import javax . net . ssl . KeyManagerFactory ; import javax . net . ssl . SSLContext ; import javax . net . ssl . SSLEngine ; import javax . net . ssl . SSLSessionContext ; import java . io . File ; import java . io . IOException ; import java . security . InvalidAlgorithmParameterException ; import java . security . KeyException ; import java . security . KeyStore ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . PrivateKey ; import java . security . Security ; import java . security . UnrecoverableKeyException ; import java . security . cert . CertificateException ; import java . security . cert . X509Certificate ; import java . security . spec . InvalidKeySpecException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import static io . netty . util . internal . ObjectUtil . * ; public abstract class JdkSslContext extends SslContext { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( JdkSslContext . class ) ; static final String PROTOCOL = <str> ; static final String [ ] PROTOCOLS ; static final List < String > DEFAULT_CIPHERS ; static final Set < String > SUPPORTED_CIPHERS ; static { SSLContext context ; int i ; try { context = SSLContext . getInstance ( PROTOCOL ) ; context . init ( null , null , null ) ; } catch ( Exception e ) { throw new Error ( <str> , e ) ; } SSLEngine engine = context . createSSLEngine ( ) ; final String [ ] supportedProtocols = engine . getSupportedProtocols ( ) ; Set < String > supportedProtocolsSet = new HashSet < String > ( supportedProtocols . length ) ; for ( i = <int> ; i < supportedProtocols . length ; + + i ) { supportedProtocolsSet . add ( supportedProtocols [ i ] ) ; } List < String > protocols = new ArrayList < String > ( ) ; addIfSupported ( supportedProtocolsSet , protocols , <str> , <str> , <str> ) ; if ( ! protocols . isEmpty ( ) ) { PROTOCOLS = protocols . toArray ( new String [ protocols . size ( ) ] ) ; } else { PROTOCOLS = engine . getEnabledProtocols ( ) ; } final String [ ] supportedCiphers = engine . getSupportedCipherSuites ( ) ; SUPPORTED_CIPHERS = new HashSet < String > ( supportedCiphers . length ) ; for ( i = <int> ; i < supportedCiphers . length ; + + i ) { SUPPORTED_CIPHERS . add ( supportedCiphers [ i ] ) ; } List < String > ciphers = new ArrayList < String > ( ) ; addIfSupported ( SUPPORTED_CIPHERS , ciphers , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; if ( ciphers . isEmpty ( ) ) { for ( String cipher : engine . getEnabledCipherSuites ( ) ) { if ( cipher . contains ( <str> ) ) { continue ; } ciphers . add ( cipher ) ; } } DEFAULT_CIPHERS = Collections . unmodifiableList ( ciphers ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , Arrays . asList ( PROTOCOLS ) ) ; logger . debug ( <str> , DEFAULT_CIPHERS ) ; } } private static void addIfSupported ( Set < String > supported , List < String > enabled , String . . . names ) { for ( String n : names ) { if ( supported . contains ( n ) ) { enabled . add ( n ) ; } } } private final String [ ] cipherSuites ; private final List < String > unmodifiableCipherSuites ; private final JdkApplicationProtocolNegotiator apn ; private final ClientAuth clientAuth ; JdkSslContext ( Iterable < String > ciphers , CipherSuiteFilter cipherFilter , JdkApplicationProtocolNegotiator apn , ClientAuth clientAuth ) { this . apn = checkNotNull ( apn , <str> ) ; this . clientAuth = checkNotNull ( clientAuth , <str> ) ; cipherSuites = checkNotNull ( cipherFilter , <str> ) . filterCipherSuites ( ciphers , DEFAULT_CIPHERS , SUPPORTED_CIPHERS ) ; unmodifiableCipherSuites = Collections . unmodifiableList ( Arrays . asList ( cipherSuites ) ) ; } public abstract SSLContext context ( ) ; @Override public final SSLSessionContext sessionContext ( ) { if ( isServer ( ) ) { return context ( ) . getServerSessionContext ( ) ; } else { return context ( ) . getClientSessionContext ( ) ; } } @Override public final List < String > cipherSuites ( ) { return unmodifiableCipherSuites ; } @Override public final long sessionCacheSize ( ) { return sessionContext ( ) . getSessionCacheSize ( ) ; } @Override public final long sessionTimeout ( ) { return sessionContext ( ) . getSessionTimeout ( ) ; } @Override public final SSLEngine newEngine ( ByteBufAllocator alloc ) { return configureAndWrapEngine ( context ( ) . createSSLEngine ( ) ) ; } @Override public final SSLEngine newEngine ( ByteBufAllocator alloc , String peerHost , int peerPort ) { return configureAndWrapEngine ( context ( ) . createSSLEngine ( peerHost , peerPort ) ) ; } private SSLEngine configureAndWrapEngine ( SSLEngine engine ) { engine . setEnabledCipherSuites ( cipherSuites ) ; engine . setEnabledProtocols ( PROTOCOLS ) ; engine . setUseClientMode ( isClient ( ) ) ; if ( isServer ( ) ) { switch ( clientAuth ) { case OPTIONAL : engine . setWantClientAuth ( true ) ; break ; case REQUIRE : engine . setNeedClientAuth ( true ) ; break ; } } return apn . wrapperFactory ( ) . wrapSslEngine ( engine , apn , isServer ( ) ) ; } @Override public JdkApplicationProtocolNegotiator applicationProtocolNegotiator ( ) { return apn ; } static JdkApplicationProtocolNegotiator toNegotiator ( ApplicationProtocolConfig config , boolean isServer ) { if ( config = = null ) { return JdkDefaultApplicationProtocolNegotiator . INSTANCE ; } switch ( config . protocol ( ) ) { case NONE : return JdkDefaultApplicationProtocolNegotiator . INSTANCE ; case ALPN : if ( isServer ) { switch ( config . selectorFailureBehavior ( ) ) { case FATAL_ALERT : return new JdkAlpnApplicationProtocolNegotiator ( true , config . supportedProtocols ( ) ) ; case NO_ADVERTISE : return new JdkAlpnApplicationProtocolNegotiator ( false , config . supportedProtocols ( ) ) ; default : throw new UnsupportedOperationException ( new StringBuilder ( <str> ) . append ( config . selectorFailureBehavior ( ) ) . append ( <str> ) . toString ( ) ) ; } } else { switch ( config . selectedListenerFailureBehavior ( ) ) { case ACCEPT : return new JdkAlpnApplicationProtocolNegotiator ( false , config . supportedProtocols ( ) ) ; case FATAL_ALERT : return new JdkAlpnApplicationProtocolNegotiator ( true , config . supportedProtocols ( ) ) ; default : throw new UnsupportedOperationException ( new StringBuilder ( <str> ) . append ( config . selectedListenerFailureBehavior ( ) ) . append ( <str> ) . toString ( ) ) ; } } case NPN : if ( isServer ) { switch ( config . selectedListenerFailureBehavior ( ) ) { case ACCEPT : return new JdkNpnApplicationProtocolNegotiator ( false , config . supportedProtocols ( ) ) ; case FATAL_ALERT : return new JdkNpnApplicationProtocolNegotiator ( true , config . supportedProtocols ( ) ) ; default : throw new UnsupportedOperationException ( new StringBuilder ( <str> ) . append ( config . selectedListenerFailureBehavior ( ) ) . append ( <str> ) . toString ( ) ) ; } } else { switch ( config . selectorFailureBehavior ( ) ) { case FATAL_ALERT : return new JdkNpnApplicationProtocolNegotiator ( true , config . supportedProtocols ( ) ) ; case NO_ADVERTISE : return new JdkNpnApplicationProtocolNegotiator ( false , config . supportedProtocols ( ) ) ; default : throw new UnsupportedOperationException ( new StringBuilder ( <str> ) . append ( config . selectorFailureBehavior ( ) ) . append ( <str> ) . toString ( ) ) ; } } default : throw new UnsupportedOperationException ( new StringBuilder ( <str> ) . append ( config . protocol ( ) ) . append ( <str> ) . toString ( ) ) ; } } @Deprecated protected static KeyManagerFactory buildKeyManagerFactory ( File certChainFile , File keyFile , String keyPassword , KeyManagerFactory kmf ) throws UnrecoverableKeyException , KeyStoreException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeySpecException , InvalidAlgorithmParameterException , CertificateException , KeyException , IOException { String algorithm = Security . getProperty ( <str> ) ; if ( algorithm = = null ) { algorithm = <str> ; } return buildKeyManagerFactory ( certChainFile , algorithm , keyFile , keyPassword , kmf ) ; } static KeyManagerFactory buildKeyManagerFactory ( X509Certificate [ ] certChain , PrivateKey key , String keyPassword , KeyManagerFactory kmf ) throws UnrecoverableKeyException , KeyStoreException , NoSuchAlgorithmException , CertificateException , IOException { String algorithm = Security . getProperty ( <str> ) ; if ( algorithm = = null ) { algorithm = <str> ; } return buildKeyManagerFactory ( certChain , algorithm , key , keyPassword , kmf ) ; } @Deprecated protected static KeyManagerFactory buildKeyManagerFactory ( File certChainFile , String keyAlgorithm , File keyFile , String keyPassword , KeyManagerFactory kmf ) throws KeyStoreException , NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeySpecException , InvalidAlgorithmParameterException , IOException , CertificateException , KeyException , UnrecoverableKeyException { return buildKeyManagerFactory ( toX509Certificates ( certChainFile ) , keyAlgorithm , toPrivateKey ( keyFile , keyPassword ) , keyPassword , kmf ) ; } static KeyManagerFactory buildKeyManagerFactory ( X509Certificate [ ] certChainFile , String keyAlgorithm , PrivateKey key , String keyPassword , KeyManagerFactory kmf ) throws KeyStoreException , NoSuchAlgorithmException , IOException , CertificateException , UnrecoverableKeyException { char [ ] keyPasswordChars = keyPassword = = null ? EmptyArrays . EMPTY_CHARS : keyPassword . toCharArray ( ) ; KeyStore ks = buildKeyStore ( certChainFile , key , keyPasswordChars ) ; if ( kmf = = null ) { kmf = KeyManagerFactory . getInstance ( keyAlgorithm ) ; } kmf . init ( ks , keyPasswordChars ) ; return kmf ; } } 
