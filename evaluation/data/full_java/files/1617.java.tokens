package org . apache . cassandra . service ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . * ; import com . google . common . collect . HashMultimap ; import com . google . common . collect . Multimap ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . Util . PartitionerSwitcher ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . SystemKeyspace ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . RandomPartitioner ; import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . gms . ApplicationState ; import org . apache . cassandra . gms . Gossiper ; import org . apache . cassandra . gms . VersionedValue ; import org . apache . cassandra . locator . AbstractReplicationStrategy ; import org . apache . cassandra . locator . SimpleSnitch ; import org . apache . cassandra . locator . TokenMetadata ; import org . apache . cassandra . schema . KeyspaceMetadata ; import static org . junit . Assert . * ; public class LeaveAndBootstrapTest { private static final IPartitioner partitioner = RandomPartitioner . instance ; private static PartitionerSwitcher partitionerSwitcher ; private static final String KEYSPACE1 = <str> ; private static final String KEYSPACE2 = <str> ; private static final String KEYSPACE3 = <str> ; private static final String KEYSPACE4 = <str> ; @BeforeClass public static void defineSchema ( ) throws Exception { partitionerSwitcher = Util . switchPartitioner ( partitioner ) ; SchemaLoader . loadSchema ( ) ; SchemaLoader . schemaDefinition ( <str> ) ; } @AfterClass public static void tearDown ( ) { partitionerSwitcher . close ( ) ; } @Test public void newTestWriteEndpointsDuringLeave ( ) throws Exception { StorageService ss = StorageService . instance ; final int RING_SIZE = <int> ; final int LEAVING_NODE = <int> ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; tmd . clearUnsafe ( ) ; IPartitioner partitioner = RandomPartitioner . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , RING_SIZE ) ; Map < Token , List < InetAddress > > expectedEndpoints = new HashMap < Token , List < InetAddress > > ( ) ; for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) { for ( Token token : keyTokens ) { List < InetAddress > endpoints = new ArrayList < InetAddress > ( ) ; Iterator < Token > tokenIter = TokenMetadata . ringIterator ( tmd . sortedTokens ( ) , token , false ) ; while ( tokenIter . hasNext ( ) ) { endpoints . add ( tmd . getEndpoint ( tokenIter . next ( ) ) ) ; } expectedEndpoints . put ( token , endpoints ) ; } } ss . onChange ( hosts . get ( LEAVING_NODE ) , ApplicationState . STATUS , valueFactory . leaving ( Collections . singleton ( endpointTokens . get ( LEAVING_NODE ) ) ) ) ; assertTrue ( tmd . isLeaving ( hosts . get ( LEAVING_NODE ) ) ) ; Thread . sleep ( <int> ) ; PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; AbstractReplicationStrategy strategy ; for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) { strategy = getStrategy ( keyspaceName , tmd ) ; for ( Token token : keyTokens ) { int replicationFactor = strategy . getReplicationFactor ( ) ; HashSet < InetAddress > actual = new HashSet < InetAddress > ( tmd . getWriteEndpoints ( token , keyspaceName , strategy . calculateNaturalEndpoints ( token , tmd . cloneOnlyTokenMap ( ) ) ) ) ; HashSet < InetAddress > expected = new HashSet < InetAddress > ( ) ; for ( int i = <int> ; i < replicationFactor ; i + + ) { expected . add ( expectedEndpoints . get ( token ) . get ( i ) ) ; } if ( expected . contains ( hosts . get ( LEAVING_NODE ) ) ) expected . add ( expectedEndpoints . get ( token ) . get ( replicationFactor ) ) ; assertEquals ( <str> , expected , actual ) ; } } } @Test public void testSimultaneousMove ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; final int RING_SIZE = <int> ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; tmd . clearUnsafe ( ) ; IPartitioner partitioner = RandomPartitioner . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , RING_SIZE ) ; final int [ ] LEAVING = new int [ ] { <int> , <int> , <int> } ; for ( int leaving : LEAVING ) ss . onChange ( hosts . get ( leaving ) , ApplicationState . STATUS , valueFactory . leaving ( Collections . singleton ( endpointTokens . get ( leaving ) ) ) ) ; InetAddress boot1 = InetAddress . getByName ( <str> ) ; Gossiper . instance . initializeNodeUnsafe ( boot1 , UUID . randomUUID ( ) , <int> ) ; Gossiper . instance . injectApplicationState ( boot1 , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( boot1 , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; InetAddress boot2 = InetAddress . getByName ( <str> ) ; Gossiper . instance . initializeNodeUnsafe ( boot2 , UUID . randomUUID ( ) , <int> ) ; Gossiper . instance . injectApplicationState ( boot2 , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( boot2 , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; Collection < InetAddress > endpoints = null ; Map < String , AbstractReplicationStrategy > keyspaceStrategyMap = new HashMap < String , AbstractReplicationStrategy > ( ) ; for ( int i = <int> ; i < = <int> ; i + + ) { keyspaceStrategyMap . put ( <str> + i , getStrategy ( <str> + i , tmd ) ) ; } Map < String , Multimap < Token , InetAddress > > expectedEndpoints = new HashMap < String , Multimap < Token , InetAddress > > ( ) ; expectedEndpoints . put ( KEYSPACE1 , HashMultimap . < Token , InetAddress > create ( ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . put ( KEYSPACE2 , HashMultimap . < Token , InetAddress > create ( ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . put ( KEYSPACE3 , HashMultimap . < Token , InetAddress > create ( ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . put ( KEYSPACE4 , HashMultimap . < Token , InetAddress > create ( ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; for ( Map . Entry < String , AbstractReplicationStrategy > keyspaceStrategy : keyspaceStrategyMap . entrySet ( ) ) { String keyspaceName = keyspaceStrategy . getKey ( ) ; AbstractReplicationStrategy strategy = keyspaceStrategy . getValue ( ) ; for ( int i = <int> ; i < keyTokens . size ( ) ; i + + ) { endpoints = tmd . getWriteEndpoints ( keyTokens . get ( i ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( i ) ) ) ; assertEquals ( expectedEndpoints . get ( keyspaceName ) . get ( keyTokens . get ( i ) ) . size ( ) , endpoints . size ( ) ) ; assertTrue ( expectedEndpoints . get ( keyspaceName ) . get ( keyTokens . get ( i ) ) . containsAll ( endpoints ) ) ; } if ( strategy . getReplicationFactor ( ) ! = <int> ) continue ; for ( int i = <int> ; i < <int> ; + + i ) { endpoints = tmd . getWriteEndpoints ( keyTokens . get ( i ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( i ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; } endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; } ss . onChange ( hosts . get ( LEAVING [ <int> ] ) , ApplicationState . STATUS , valueFactory . left ( Collections . singleton ( endpointTokens . get ( LEAVING [ <int> ] ) ) , Gossiper . computeExpireTime ( ) ) ) ; ss . onChange ( hosts . get ( LEAVING [ <int> ] ) , ApplicationState . STATUS , valueFactory . left ( Collections . singleton ( endpointTokens . get ( LEAVING [ <int> ] ) ) , Gossiper . computeExpireTime ( ) ) ) ; ss . onChange ( boot1 , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . get ( new BigIntegerToken ( <str> ) ) . removeAll ( makeAddrs ( <str> ) ) ; PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; for ( Map . Entry < String , AbstractReplicationStrategy > keyspaceStrategy : keyspaceStrategyMap . entrySet ( ) ) { String keyspaceName = keyspaceStrategy . getKey ( ) ; AbstractReplicationStrategy strategy = keyspaceStrategy . getValue ( ) ; for ( int i = <int> ; i < keyTokens . size ( ) ; i + + ) { endpoints = tmd . getWriteEndpoints ( keyTokens . get ( i ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( i ) ) ) ; assertEquals ( expectedEndpoints . get ( keyspaceName ) . get ( keyTokens . get ( i ) ) . size ( ) , endpoints . size ( ) ) ; assertTrue ( expectedEndpoints . get ( keyspaceName ) . get ( keyTokens . get ( i ) ) . containsAll ( endpoints ) ) ; } if ( strategy . getReplicationFactor ( ) ! = <int> ) continue ; for ( int i = <int> ; i < <int> ; + + i ) { endpoints = tmd . getWriteEndpoints ( keyTokens . get ( i ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( i ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; } endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; } } @Test public void testStateJumpToBootstrap ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; tmd . clearUnsafe ( ) ; IPartitioner partitioner = RandomPartitioner . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , <int> ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . leaving ( Collections . singleton ( endpointTokens . get ( <int> ) ) ) ) ; assertTrue ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertTrue ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertTrue ( tmd . getBootstrapTokens ( ) . isEmpty ( ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; assertFalse ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertFalse ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertEquals ( hosts . get ( <int> ) , tmd . getBootstrapTokens ( ) . get ( keyTokens . get ( <int> ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; assertFalse ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertFalse ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertEquals ( hosts . get ( <int> ) , tmd . getBootstrapTokens ( ) . get ( keyTokens . get ( <int> ) ) ) ; assertEquals ( hosts . get ( <int> ) , tmd . getBootstrapTokens ( ) . get ( keyTokens . get ( <int> ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; assertFalse ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertFalse ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertEquals ( hosts . get ( <int> ) , tmd . getBootstrapTokens ( ) . get ( keyTokens . get ( <int> ) ) ) ; assertNull ( tmd . getBootstrapTokens ( ) . get ( keyTokens . get ( <int> ) ) ) ; assertEquals ( hosts . get ( <int> ) , tmd . getBootstrapTokens ( ) . get ( keyTokens . get ( <int> ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; assertTrue ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertFalse ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertEquals ( keyTokens . get ( <int> ) , tmd . getToken ( hosts . get ( <int> ) ) ) ; assertTrue ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertFalse ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertEquals ( keyTokens . get ( <int> ) , tmd . getToken ( hosts . get ( <int> ) ) ) ; assertTrue ( tmd . getBootstrapTokens ( ) . isEmpty ( ) ) ; } @Test public void testStateJumpToNormal ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; tmd . clearUnsafe ( ) ; IPartitioner partitioner = RandomPartitioner . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , <int> ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . leaving ( Collections . singleton ( endpointTokens . get ( <int> ) ) ) ) ; assertTrue ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertEquals ( endpointTokens . get ( <int> ) , tmd . getToken ( hosts . get ( <int> ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; assertTrue ( tmd . getLeavingEndpoints ( ) . isEmpty ( ) ) ; assertEquals ( keyTokens . get ( <int> ) , tmd . getToken ( hosts . get ( <int> ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . leaving ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . left ( Collections . singleton ( keyTokens . get ( <int> ) ) , Gossiper . computeExpireTime ( ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; assertTrue ( tmd . getBootstrapTokens ( ) . isEmpty ( ) ) ; assertTrue ( tmd . getLeavingEndpoints ( ) . isEmpty ( ) ) ; assertEquals ( keyTokens . get ( <int> ) , tmd . getToken ( hosts . get ( <int> ) ) ) ; } @Test public void testStateJumpToLeaving ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; tmd . clearUnsafe ( ) ; IPartitioner partitioner = RandomPartitioner . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , <int> ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . leaving ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; assertEquals ( keyTokens . get ( <int> ) , tmd . getToken ( hosts . get ( <int> ) ) ) ; assertTrue ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertNull ( tmd . getEndpoint ( endpointTokens . get ( <int> ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; assertFalse ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertEquals ( <int> , tmd . getBootstrapTokens ( ) . size ( ) ) ; assertEquals ( hosts . get ( <int> ) , tmd . getBootstrapTokens ( ) . get ( keyTokens . get ( <int> ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . leaving ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; assertEquals ( hosts . get ( <int> ) , tmd . getEndpoint ( keyTokens . get ( <int> ) ) ) ; assertTrue ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; assertTrue ( tmd . getBootstrapTokens ( ) . isEmpty ( ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . left ( Collections . singleton ( keyTokens . get ( <int> ) ) , Gossiper . computeExpireTime ( ) ) ) ; assertFalse ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertFalse ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; } @Test public void testStateJumpToLeft ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; tmd . clearUnsafe ( ) ; IPartitioner partitioner = RandomPartitioner . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , <int> ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . left ( Collections . singleton ( endpointTokens . get ( <int> ) ) , Gossiper . computeExpireTime ( ) ) ) ; assertFalse ( tmd . isMember ( hosts . get ( <int> ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; assertFalse ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertEquals ( <int> , tmd . getBootstrapTokens ( ) . size ( ) ) ; assertEquals ( hosts . get ( <int> ) , tmd . getBootstrapTokens ( ) . get ( keyTokens . get ( <int> ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . left ( Collections . singleton ( keyTokens . get ( <int> ) ) , Gossiper . computeExpireTime ( ) ) ) ; assertTrue ( tmd . getBootstrapTokens ( ) . size ( ) = = <int> ) ; assertFalse ( tmd . isMember ( hosts . get ( <int> ) ) ) ; assertFalse ( tmd . isLeaving ( hosts . get ( <int> ) ) ) ; } @Test public void testStateChangeOnRemovedNode ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < > ( ) ; List < InetAddress > hosts = new ArrayList < > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , new ArrayList < Token > ( ) , hosts , new ArrayList < UUID > ( ) , <int> ) ; InetAddress toRemove = hosts . get ( <int> ) ; SystemKeyspace . updatePeerInfo ( toRemove , <str> , <str> ) ; SystemKeyspace . updatePeerInfo ( toRemove , <str> , <str> ) ; assertEquals ( <str> , SystemKeyspace . loadDcRackInfo ( ) . get ( toRemove ) . get ( <str> ) ) ; Gossiper . instance . injectApplicationState ( toRemove , ApplicationState . STATUS , valueFactory . left ( Collections . singleton ( endpointTokens . get ( <int> ) ) , Gossiper . computeExpireTime ( ) ) ) ; assertTrue ( Gossiper . instance . isDeadState ( Gossiper . instance . getEndpointStateForEndpoint ( hosts . get ( <int> ) ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . RACK , valueFactory . rack ( <str> ) ) ; assertEquals ( <str> , SystemKeyspace . loadDcRackInfo ( ) . get ( toRemove ) . get ( <str> ) ) ; } @Test public void testRemovingStatusForNonMember ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; Util . createInitialRing ( ss , partitioner , new ArrayList < Token > ( ) , new ArrayList < Token > ( ) , new ArrayList < InetAddress > ( ) , new ArrayList < UUID > ( ) , <int> ) ; ss . onChange ( InetAddress . getByName ( <str> ) , ApplicationState . STATUS , valueFactory . removingNonlocal ( UUID . randomUUID ( ) ) ) ; } private static Collection < InetAddress > makeAddrs ( String . . . hosts ) throws UnknownHostException { ArrayList < InetAddress > addrs = new ArrayList < InetAddress > ( hosts . length ) ; for ( String host : hosts ) addrs . add ( InetAddress . getByName ( host ) ) ; return addrs ; } private AbstractReplicationStrategy getStrategy ( String keyspaceName , TokenMetadata tmd ) { KeyspaceMetadata ksmd = Schema . instance . getKSMetaData ( keyspaceName ) ; return AbstractReplicationStrategy . createReplicationStrategy ( keyspaceName , ksmd . params . replication . klass , tmd , new SimpleSnitch ( ) , ksmd . params . replication . options ) ; } } 
