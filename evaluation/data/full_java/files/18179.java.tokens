package com . badlogic . gdx . math ; public class CatmullRomSpline < T extends Vector < T > > implements Path < T > { public static < T extends Vector < T > > T calculate ( final T out , final float t , final T [ ] points , final boolean continuous , final T tmp ) { final int n = continuous ? points . length : points . length - <int> ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return calculate ( out , i , u , points , continuous , tmp ) ; } public static < T extends Vector < T > > T calculate ( final T out , final int i , final float u , final T [ ] points , final boolean continuous , final T tmp ) { final int n = points . length ; final float u2 = u * u ; final float u3 = u2 * u ; out . set ( points [ i ] ) . scl ( <float> * u3 - <float> * u2 + <float> ) ; if ( continuous | | i > <int> ) out . add ( tmp . set ( points [ ( n + i - <int> ) % n ] ) . scl ( - <float> * u3 + u2 - <float> * u ) ) ; if ( continuous | | i < ( n - <int> ) ) out . add ( tmp . set ( points [ ( i + <int> ) % n ] ) . scl ( - <float> * u3 + <float> * u2 + <float> * u ) ) ; if ( continuous | | i < ( n - <int> ) ) out . add ( tmp . set ( points [ ( i + <int> ) % n ] ) . scl ( <float> * u3 - <float> * u2 ) ) ; return out ; } public static < T extends Vector < T > > T derivative ( final T out , final float t , final T [ ] points , final boolean continuous , final T tmp ) { final int n = continuous ? points . length : points . length - <int> ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return derivative ( out , i , u , points , continuous , tmp ) ; } public static < T extends Vector < T > > T derivative ( final T out , final int i , final float u , final T [ ] points , final boolean continuous , final T tmp ) { final int n = points . length ; final float u2 = u * u ; out . set ( points [ i ] ) . scl ( - u * <int> + u2 * <float> ) ; if ( continuous | | i > <int> ) out . add ( tmp . set ( points [ ( n + i - <int> ) % n ] ) . scl ( - <float> + u * <int> - u2 * <float> ) ) ; if ( continuous | | i < ( n - <int> ) ) out . add ( tmp . set ( points [ ( i + <int> ) % n ] ) . scl ( <float> + u * <int> - u2 * <float> ) ) ; if ( continuous | | i < ( n - <int> ) ) out . add ( tmp . set ( points [ ( i + <int> ) % n ] ) . scl ( - u + u2 * <float> ) ) ; return out ; } public T [ ] controlPoints ; public boolean continuous ; public int spanCount ; private T tmp ; private T tmp2 ; private T tmp3 ; public CatmullRomSpline ( ) { } public CatmullRomSpline ( final T [ ] controlPoints , final boolean continuous ) { set ( controlPoints , continuous ) ; } public CatmullRomSpline set ( final T [ ] controlPoints , final boolean continuous ) { if ( tmp = = null ) tmp = controlPoints [ <int> ] . cpy ( ) ; if ( tmp2 = = null ) tmp2 = controlPoints [ <int> ] . cpy ( ) ; if ( tmp3 = = null ) tmp3 = controlPoints [ <int> ] . cpy ( ) ; this . controlPoints = controlPoints ; this . continuous = continuous ; this . spanCount = continuous ? controlPoints . length : controlPoints . length - <int> ; return this ; } @Override public T valueAt ( T out , float t ) { final int n = spanCount ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return valueAt ( out , i , u ) ; } public T valueAt ( final T out , final int span , final float u ) { return calculate ( out , continuous ? span : ( span + <int> ) , u , controlPoints , continuous , tmp ) ; } @Override public T derivativeAt ( T out , float t ) { final int n = spanCount ; float u = t * n ; int i = ( t > = <float> ) ? ( n - <int> ) : ( int ) u ; u - = i ; return derivativeAt ( out , i , u ) ; } public T derivativeAt ( final T out , final int span , final float u ) { return derivative ( out , continuous ? span : ( span + <int> ) , u , controlPoints , continuous , tmp ) ; } public int nearest ( final T in ) { return nearest ( in , <int> , spanCount ) ; } public int nearest ( final T in , int start , final int count ) { while ( start < <int> ) start + = spanCount ; int result = start % spanCount ; float dst = in . dst2 ( controlPoints [ result ] ) ; for ( int i = <int> ; i < count ; i + + ) { final int idx = ( start + i ) % spanCount ; final float d = in . dst2 ( controlPoints [ idx ] ) ; if ( d < dst ) { dst = d ; result = idx ; } } return result ; } @Override public float approximate ( T v ) { return approximate ( v , nearest ( v ) ) ; } public float approximate ( final T in , int start , final int count ) { return approximate ( in , nearest ( in , start , count ) ) ; } public float approximate ( final T in , final int near ) { int n = near ; final T nearest = controlPoints [ n ] ; final T previous = controlPoints [ n > <int> ? n - <int> : spanCount - <int> ] ; final T next = controlPoints [ ( n + <int> ) % spanCount ] ; final float dstPrev2 = in . dst2 ( previous ) ; final float dstNext2 = in . dst2 ( next ) ; T P1 , P2 , P3 ; if ( dstNext2 < dstPrev2 ) { P1 = nearest ; P2 = next ; P3 = in ; } else { P1 = previous ; P2 = nearest ; P3 = in ; n = n > <int> ? n - <int> : spanCount - <int> ; } float L1Sqr = P1 . dst2 ( P2 ) ; float L2Sqr = P3 . dst2 ( P2 ) ; float L3Sqr = P3 . dst2 ( P1 ) ; float L1 = ( float ) Math . sqrt ( L1Sqr ) ; float s = ( L2Sqr + L1Sqr - L3Sqr ) / ( <float> * L1 ) ; float u = MathUtils . clamp ( ( L1 - s ) / L1 , <float> , <float> ) ; return ( n + u ) / spanCount ; } @Override public float locate ( T v ) { return approximate ( v ) ; } @Override public float approxLength ( int samples ) { float tempLength = <int> ; for ( int i = <int> ; i < samples ; + + i ) { tmp2 . set ( tmp3 ) ; valueAt ( tmp3 , ( i ) / ( ( float ) samples - <int> ) ) ; if ( i > <int> ) tempLength + = tmp2 . dst ( tmp3 ) ; } return tempLength ; } } 
