package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . CollectPreconditions . checkEntryNotNull ; import static com . google . common . collect . Maps . keyOrNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . collect . ImmutableMap . Builder ; import com . google . j2objc . annotations . WeakOuter ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Map ; import java . util . NavigableMap ; import java . util . SortedMap ; import java . util . TreeMap ; import javax . annotation . Nullable ; @GwtCompatible ( serializable = true , emulated = true ) public final class ImmutableSortedMap < K , V > extends ImmutableSortedMapFauxverideShim < K , V > implements NavigableMap < K , V > { private static final Comparator < Comparable > NATURAL_ORDER = Ordering . natural ( ) ; private static final ImmutableSortedMap < Comparable , Object > NATURAL_EMPTY_MAP = new ImmutableSortedMap < Comparable , Object > ( ImmutableSortedSet . emptySet ( Ordering . natural ( ) ) , ImmutableList . < Object > of ( ) ) ; static < K , V > ImmutableSortedMap < K , V > emptyMap ( Comparator < ? super K > comparator ) { if ( Ordering . natural ( ) . equals ( comparator ) ) { return of ( ) ; } else { return new ImmutableSortedMap < K , V > ( ImmutableSortedSet . emptySet ( comparator ) , ImmutableList . < V > of ( ) ) ; } } @SuppressWarnings ( <str> ) public static < K , V > ImmutableSortedMap < K , V > of ( ) { return ( ImmutableSortedMap < K , V > ) NATURAL_EMPTY_MAP ; } public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 ) { return of ( Ordering . natural ( ) , k1 , v1 ) ; } private static < K , V > ImmutableSortedMap < K , V > of ( Comparator < ? super K > comparator , K k1 , V v1 ) { return new ImmutableSortedMap < K , V > ( new RegularImmutableSortedSet < K > ( ImmutableList . of ( k1 ) , checkNotNull ( comparator ) ) , ImmutableList . of ( v1 ) ) ; } private static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > ofEntries ( ImmutableMapEntry < K , V > . . . entries ) { return fromEntries ( Ordering . natural ( ) , false , entries , entries . length ) ; } @SuppressWarnings ( <str> ) public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 ) { return ofEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) ) ; } @SuppressWarnings ( <str> ) public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 ) { return ofEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) ) ; } @SuppressWarnings ( <str> ) public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 ) { return ofEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) ) ; } @SuppressWarnings ( <str> ) public static < K extends Comparable < ? super K > , V > ImmutableSortedMap < K , V > of ( K k1 , V v1 , K k2 , V v2 , K k3 , V v3 , K k4 , V v4 , K k5 , V v5 ) { return ofEntries ( entryOf ( k1 , v1 ) , entryOf ( k2 , v2 ) , entryOf ( k3 , v3 ) , entryOf ( k4 , v4 ) , entryOf ( k5 , v5 ) ) ; } public static < K , V > ImmutableSortedMap < K , V > copyOf ( Map < ? extends K , ? extends V > map ) { @SuppressWarnings ( <str> ) Ordering < K > naturalOrder = ( Ordering < K > ) NATURAL_ORDER ; return copyOfInternal ( map , naturalOrder ) ; } public static < K , V > ImmutableSortedMap < K , V > copyOf ( Map < ? extends K , ? extends V > map , Comparator < ? super K > comparator ) { return copyOfInternal ( map , checkNotNull ( comparator ) ) ; } @Beta public static < K , V > ImmutableSortedMap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { @SuppressWarnings ( <str> ) Ordering < K > naturalOrder = ( Ordering < K > ) NATURAL_ORDER ; return copyOf ( entries , naturalOrder ) ; } @Beta public static < K , V > ImmutableSortedMap < K , V > copyOf ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries , Comparator < ? super K > comparator ) { return fromEntries ( checkNotNull ( comparator ) , false , entries ) ; } @SuppressWarnings ( <str> ) public static < K , V > ImmutableSortedMap < K , V > copyOfSorted ( SortedMap < K , ? extends V > map ) { Comparator < ? super K > comparator = map . comparator ( ) ; if ( comparator = = null ) { comparator = ( Comparator < ? super K > ) NATURAL_ORDER ; } if ( map instanceof ImmutableSortedMap ) { @SuppressWarnings ( <str> ) ImmutableSortedMap < K , V > kvMap = ( ImmutableSortedMap < K , V > ) map ; if ( ! kvMap . isPartialView ( ) ) { return kvMap ; } } return fromEntries ( comparator , true , map . entrySet ( ) ) ; } private static < K , V > ImmutableSortedMap < K , V > copyOfInternal ( Map < ? extends K , ? extends V > map , Comparator < ? super K > comparator ) { boolean sameComparator = false ; if ( map instanceof SortedMap ) { SortedMap < ? , ? > sortedMap = ( SortedMap < ? , ? > ) map ; Comparator < ? > comparator2 = sortedMap . comparator ( ) ; sameComparator = ( comparator2 = = null ) ? comparator = = NATURAL_ORDER : comparator . equals ( comparator2 ) ; } if ( sameComparator & & ( map instanceof ImmutableSortedMap ) ) { @SuppressWarnings ( <str> ) ImmutableSortedMap < K , V > kvMap = ( ImmutableSortedMap < K , V > ) map ; if ( ! kvMap . isPartialView ( ) ) { return kvMap ; } } return fromEntries ( comparator , sameComparator , map . entrySet ( ) ) ; } private static < K , V > ImmutableSortedMap < K , V > fromEntries ( Comparator < ? super K > comparator , boolean sameComparator , Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { @SuppressWarnings ( <str> ) Entry < K , V > [ ] entryArray = ( Entry [ ] ) Iterables . toArray ( entries , EMPTY_ENTRY_ARRAY ) ; return fromEntries ( comparator , sameComparator , entryArray , entryArray . length ) ; } private static < K , V > ImmutableSortedMap < K , V > fromEntries ( Comparator < ? super K > comparator , boolean sameComparator , Entry < K , V > [ ] entryArray , int size ) { switch ( size ) { case <int> : return emptyMap ( comparator ) ; case <int> : return ImmutableSortedMap . < K , V > of ( comparator , entryArray [ <int> ] . getKey ( ) , entryArray [ <int> ] . getValue ( ) ) ; default : Object [ ] keys = new Object [ size ] ; Object [ ] values = new Object [ size ] ; if ( sameComparator ) { for ( int i = <int> ; i < size ; i + + ) { Object key = entryArray [ i ] . getKey ( ) ; Object value = entryArray [ i ] . getValue ( ) ; checkEntryNotNull ( key , value ) ; keys [ i ] = key ; values [ i ] = value ; } } else { Arrays . sort ( entryArray , <int> , size , Ordering . from ( comparator ) . < K > onKeys ( ) ) ; K prevKey = entryArray [ <int> ] . getKey ( ) ; keys [ <int> ] = prevKey ; values [ <int> ] = entryArray [ <int> ] . getValue ( ) ; for ( int i = <int> ; i < size ; i + + ) { K key = entryArray [ i ] . getKey ( ) ; V value = entryArray [ i ] . getValue ( ) ; checkEntryNotNull ( key , value ) ; keys [ i ] = key ; values [ i ] = value ; checkNoConflict ( comparator . compare ( prevKey , key ) ! = <int> , <str> , entryArray [ i - <int> ] , entryArray [ i ] ) ; prevKey = key ; } } return new ImmutableSortedMap < K , V > ( new RegularImmutableSortedSet < K > ( new RegularImmutableList < K > ( keys ) , comparator ) , new RegularImmutableList < V > ( values ) ) ; } } public static < K extends Comparable < ? > , V > Builder < K , V > naturalOrder ( ) { return new Builder < K , V > ( Ordering . natural ( ) ) ; } public static < K , V > Builder < K , V > orderedBy ( Comparator < K > comparator ) { return new Builder < K , V > ( comparator ) ; } public static < K extends Comparable < ? > , V > Builder < K , V > reverseOrder ( ) { return new Builder < K , V > ( Ordering . natural ( ) . reverse ( ) ) ; } public static class Builder < K , V > extends ImmutableMap . Builder < K , V > { private final Comparator < ? super K > comparator ; @SuppressWarnings ( <str> ) public Builder ( Comparator < ? super K > comparator ) { this . comparator = checkNotNull ( comparator ) ; } @Override public Builder < K , V > put ( K key , V value ) { super . put ( key , value ) ; return this ; } @Override public Builder < K , V > put ( Entry < ? extends K , ? extends V > entry ) { super . put ( entry ) ; return this ; } @Override public Builder < K , V > putAll ( Map < ? extends K , ? extends V > map ) { super . putAll ( map ) ; return this ; } @Beta @Override public Builder < K , V > putAll ( Iterable < ? extends Entry < ? extends K , ? extends V > > entries ) { super . putAll ( entries ) ; return this ; } @Beta @Override @Deprecated public Builder < K , V > orderEntriesByValue ( Comparator < ? super V > valueComparator ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public ImmutableSortedMap < K , V > build ( ) { switch ( size ) { case <int> : return emptyMap ( comparator ) ; case <int> : return of ( comparator , entries [ <int> ] . getKey ( ) , entries [ <int> ] . getValue ( ) ) ; default : return fromEntries ( comparator , false , entries , size ) ; } } } private final transient RegularImmutableSortedSet < K > keySet ; private final transient ImmutableList < V > valueList ; private transient ImmutableSortedMap < K , V > descendingMap ; ImmutableSortedMap ( RegularImmutableSortedSet < K > keySet , ImmutableList < V > valueList ) { this ( keySet , valueList , null ) ; } ImmutableSortedMap ( RegularImmutableSortedSet < K > keySet , ImmutableList < V > valueList , ImmutableSortedMap < K , V > descendingMap ) { this . keySet = keySet ; this . valueList = valueList ; this . descendingMap = descendingMap ; } @Override public int size ( ) { return valueList . size ( ) ; } @Override public V get ( @Nullable Object key ) { int index = keySet . indexOf ( key ) ; return ( index = = - <int> ) ? null : valueList . get ( index ) ; } @Override boolean isPartialView ( ) { return keySet . isPartialView ( ) | | valueList . isPartialView ( ) ; } @Override public ImmutableSet < Entry < K , V > > entrySet ( ) { return super . entrySet ( ) ; } @Override ImmutableSet < Entry < K , V > > createEntrySet ( ) { @WeakOuter class EntrySet extends ImmutableMapEntrySet < K , V > { @Override public UnmodifiableIterator < Entry < K , V > > iterator ( ) { return asList ( ) . iterator ( ) ; } @Override ImmutableList < Entry < K , V > > createAsList ( ) { return new ImmutableAsList < Entry < K , V > > ( ) { @Override public Entry < K , V > get ( int index ) { return Maps . immutableEntry ( keySet . asList ( ) . get ( index ) , valueList . get ( index ) ) ; } @Override ImmutableCollection < Entry < K , V > > delegateCollection ( ) { return EntrySet . this ; } } ; } @Override ImmutableMap < K , V > map ( ) { return ImmutableSortedMap . this ; } } return isEmpty ( ) ? ImmutableSet . < Entry < K , V > > of ( ) : new EntrySet ( ) ; } @Override public ImmutableSortedSet < K > keySet ( ) { return keySet ; } @Override public ImmutableCollection < V > values ( ) { return valueList ; } @Override public Comparator < ? super K > comparator ( ) { return keySet ( ) . comparator ( ) ; } @Override public K firstKey ( ) { return keySet ( ) . first ( ) ; } @Override public K lastKey ( ) { return keySet ( ) . last ( ) ; } private ImmutableSortedMap < K , V > getSubMap ( int fromIndex , int toIndex ) { if ( fromIndex = = <int> & & toIndex = = size ( ) ) { return this ; } else if ( fromIndex = = toIndex ) { return emptyMap ( comparator ( ) ) ; } else { return new ImmutableSortedMap < K , V > ( keySet . getSubSet ( fromIndex , toIndex ) , valueList . subList ( fromIndex , toIndex ) ) ; } } @Override public ImmutableSortedMap < K , V > headMap ( K toKey ) { return headMap ( toKey , false ) ; } @Override public ImmutableSortedMap < K , V > headMap ( K toKey , boolean inclusive ) { return getSubMap ( <int> , keySet . headIndex ( checkNotNull ( toKey ) , inclusive ) ) ; } @Override public ImmutableSortedMap < K , V > subMap ( K fromKey , K toKey ) { return subMap ( fromKey , true , toKey , false ) ; } @Override public ImmutableSortedMap < K , V > subMap ( K fromKey , boolean fromInclusive , K toKey , boolean toInclusive ) { checkNotNull ( fromKey ) ; checkNotNull ( toKey ) ; checkArgument ( comparator ( ) . compare ( fromKey , toKey ) < = <int> , <str> , fromKey , toKey ) ; return headMap ( toKey , toInclusive ) . tailMap ( fromKey , fromInclusive ) ; } @Override public ImmutableSortedMap < K , V > tailMap ( K fromKey ) { return tailMap ( fromKey , true ) ; } @Override public ImmutableSortedMap < K , V > tailMap ( K fromKey , boolean inclusive ) { return getSubMap ( keySet . tailIndex ( checkNotNull ( fromKey ) , inclusive ) , size ( ) ) ; } @Override public Entry < K , V > lowerEntry ( K key ) { return headMap ( key , false ) . lastEntry ( ) ; } @Override public K lowerKey ( K key ) { return keyOrNull ( lowerEntry ( key ) ) ; } @Override public Entry < K , V > floorEntry ( K key ) { return headMap ( key , true ) . lastEntry ( ) ; } @Override public K floorKey ( K key ) { return keyOrNull ( floorEntry ( key ) ) ; } @Override public Entry < K , V > ceilingEntry ( K key ) { return tailMap ( key , true ) . firstEntry ( ) ; } @Override public K ceilingKey ( K key ) { return keyOrNull ( ceilingEntry ( key ) ) ; } @Override public Entry < K , V > higherEntry ( K key ) { return tailMap ( key , false ) . firstEntry ( ) ; } @Override public K higherKey ( K key ) { return keyOrNull ( higherEntry ( key ) ) ; } @Override public Entry < K , V > firstEntry ( ) { return isEmpty ( ) ? null : entrySet ( ) . asList ( ) . get ( <int> ) ; } @Override public Entry < K , V > lastEntry ( ) { return isEmpty ( ) ? null : entrySet ( ) . asList ( ) . get ( size ( ) - <int> ) ; } @Deprecated @Override public final Entry < K , V > pollFirstEntry ( ) { throw new UnsupportedOperationException ( ) ; } @Deprecated @Override public final Entry < K , V > pollLastEntry ( ) { throw new UnsupportedOperationException ( ) ; } @Override public ImmutableSortedMap < K , V > descendingMap ( ) { ImmutableSortedMap < K , V > result = descendingMap ; if ( result = = null ) { if ( isEmpty ( ) ) { return result = emptyMap ( Ordering . from ( comparator ( ) ) . reverse ( ) ) ; } else { return result = new ImmutableSortedMap < K , V > ( ( RegularImmutableSortedSet < K > ) keySet . descendingSet ( ) , valueList . reverse ( ) , this ) ; } } return result ; } @Override public ImmutableSortedSet < K > navigableKeySet ( ) { return keySet ; } @Override public ImmutableSortedSet < K > descendingKeySet ( ) { return keySet . descendingSet ( ) ; } private static class SerializedForm extends ImmutableMap . SerializedForm { private final Comparator < Object > comparator ; @SuppressWarnings ( <str> ) SerializedForm ( ImmutableSortedMap < ? , ? > sortedMap ) { super ( sortedMap ) ; comparator = ( Comparator < Object > ) sortedMap . comparator ( ) ; } @Override Object readResolve ( ) { Builder < Object , Object > builder = new Builder < Object , Object > ( comparator ) ; return createMap ( builder ) ; } private static final long serialVersionUID = <int> ; } @Override Object writeReplace ( ) { return new SerializedForm ( this ) ; } private static final long serialVersionUID = <int> ; } 
