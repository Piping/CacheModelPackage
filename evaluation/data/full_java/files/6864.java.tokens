package org . elasticsearch . indices . recovery ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . IndexShardClosedException ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Predicate ; public class RecoveriesCollection { private final ConcurrentMap < Long , RecoveryStatus > onGoingRecoveries = ConcurrentCollections . newConcurrentMap ( ) ; final private ESLogger logger ; final private ThreadPool threadPool ; public RecoveriesCollection ( ESLogger logger , ThreadPool threadPool ) { this . logger = logger ; this . threadPool = threadPool ; } public long startRecovery ( IndexShard indexShard , DiscoveryNode sourceNode , RecoveryTarget . RecoveryListener listener , TimeValue activityTimeout ) { RecoveryStatus status = new RecoveryStatus ( indexShard , sourceNode , listener ) ; RecoveryStatus existingStatus = onGoingRecoveries . putIfAbsent ( status . recoveryId ( ) , status ) ; assert existingStatus = = null : <str> ; logger . trace ( <str> , indexShard . shardId ( ) , sourceNode , status . recoveryId ( ) ) ; threadPool . schedule ( activityTimeout , ThreadPool . Names . GENERIC , new RecoveryMonitor ( status . recoveryId ( ) , status . lastAccessTime ( ) , activityTimeout ) ) ; return status . recoveryId ( ) ; } public StatusRef getStatus ( long id ) { RecoveryStatus status = onGoingRecoveries . get ( id ) ; if ( status ! = null & & status . tryIncRef ( ) ) { return new StatusRef ( status ) ; } return null ; } public StatusRef getStatusSafe ( long id , ShardId shardId ) { StatusRef statusRef = getStatus ( id ) ; if ( statusRef = = null ) { throw new IndexShardClosedException ( shardId ) ; } assert statusRef . status ( ) . shardId ( ) . equals ( shardId ) ; return statusRef ; } public boolean cancelRecovery ( long id , String reason ) { RecoveryStatus removed = onGoingRecoveries . remove ( id ) ; boolean cancelled = false ; if ( removed ! = null ) { logger . trace ( <str> , removed . shardId ( ) , removed . sourceNode ( ) , removed . recoveryId ( ) , reason ) ; removed . cancel ( reason ) ; cancelled = true ; } return cancelled ; } public void failRecovery ( long id , RecoveryFailedException e , boolean sendShardFailure ) { RecoveryStatus removed = onGoingRecoveries . remove ( id ) ; if ( removed ! = null ) { logger . trace ( <str> , removed . shardId ( ) , removed . sourceNode ( ) , removed . recoveryId ( ) , sendShardFailure ) ; removed . fail ( e , sendShardFailure ) ; } } public void markRecoveryAsDone ( long id ) { RecoveryStatus removed = onGoingRecoveries . remove ( id ) ; if ( removed ! = null ) { logger . trace ( <str> , removed . shardId ( ) , removed . sourceNode ( ) , removed . recoveryId ( ) ) ; removed . markAsDone ( ) ; } } public int size ( ) { return onGoingRecoveries . size ( ) ; } public boolean cancelRecoveriesForShard ( ShardId shardId , String reason ) { return cancelRecoveriesForShard ( shardId , reason , status - > true ) ; } public boolean cancelRecoveriesForShard ( ShardId shardId , String reason , Predicate < RecoveryStatus > shouldCancel ) { boolean cancelled = false ; for ( RecoveryStatus status : onGoingRecoveries . values ( ) ) { if ( status . shardId ( ) . equals ( shardId ) ) { boolean cancel = false ; if ( status . tryIncRef ( ) ) { try { cancel = shouldCancel . test ( status ) ; } finally { status . decRef ( ) ; } } if ( cancel & & cancelRecovery ( status . recoveryId ( ) , reason ) ) { cancelled = true ; } } } return cancelled ; } public static class StatusRef implements AutoCloseable { private final RecoveryStatus status ; private final AtomicBoolean closed = new AtomicBoolean ( false ) ; public StatusRef ( RecoveryStatus status ) { this . status = status ; this . status . setLastAccessTime ( ) ; } @Override public void close ( ) { if ( closed . compareAndSet ( false , true ) ) { status . decRef ( ) ; } } public RecoveryStatus status ( ) { return status ; } } private class RecoveryMonitor extends AbstractRunnable { private final long recoveryId ; private final TimeValue checkInterval ; private long lastSeenAccessTime ; private RecoveryMonitor ( long recoveryId , long lastSeenAccessTime , TimeValue checkInterval ) { this . recoveryId = recoveryId ; this . checkInterval = checkInterval ; this . lastSeenAccessTime = lastSeenAccessTime ; } @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t , recoveryId ) ; } @Override protected void doRun ( ) throws Exception { RecoveryStatus status = onGoingRecoveries . get ( recoveryId ) ; if ( status = = null ) { logger . trace ( <str> , recoveryId ) ; return ; } long accessTime = status . lastAccessTime ( ) ; if ( accessTime = = lastSeenAccessTime ) { String message = <str> + checkInterval + <str> ; failRecovery ( recoveryId , new RecoveryFailedException ( status . state ( ) , message , new ElasticsearchTimeoutException ( message ) ) , true ) ; return ; } lastSeenAccessTime = accessTime ; logger . trace ( <str> , lastSeenAccessTime ) ; threadPool . schedule ( checkInterval , ThreadPool . Names . GENERIC , this ) ; } } } 
