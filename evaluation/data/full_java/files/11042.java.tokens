package org . gradle . cli ; import java . io . * ; import java . util . * ; import java . util . regex . Pattern ; public class CommandLineParser { private static final Pattern OPTION_NAME_PATTERN = Pattern . compile ( <str> ) ; private Map < String , CommandLineOption > optionsByString = new HashMap < String , CommandLineOption > ( ) ; private boolean allowMixedOptions ; private boolean allowUnknownOptions ; private final PrintWriter deprecationPrinter ; public CommandLineParser ( ) { this ( new OutputStreamWriter ( System . out ) ) ; } public CommandLineParser ( Writer deprecationPrinter ) { this . deprecationPrinter = new PrintWriter ( deprecationPrinter , true ) ; } public ParsedCommandLine parse ( String . . . commandLine ) throws CommandLineArgumentException { return parse ( Arrays . asList ( commandLine ) ) ; } public ParsedCommandLine parse ( Iterable < String > commandLine ) throws CommandLineArgumentException { ParsedCommandLine parsedCommandLine = new ParsedCommandLine ( new HashSet < CommandLineOption > ( optionsByString . values ( ) ) ) ; ParserState parseState = new BeforeFirstSubCommand ( parsedCommandLine ) ; for ( String arg : commandLine ) { if ( parseState . maybeStartOption ( arg ) ) { if ( arg . equals ( <str> ) ) { parseState = new AfterOptions ( parsedCommandLine ) ; } else if ( arg . matches ( <str> ) ) { OptionParserState parsedOption = parseState . onStartOption ( arg , arg . substring ( <int> ) ) ; parseState = parsedOption . onStartNextArg ( ) ; } else if ( arg . matches ( <str> ) ) { int endArg = arg . indexOf ( <str> ) ; OptionParserState parsedOption = parseState . onStartOption ( arg , arg . substring ( <int> , endArg ) ) ; parseState = parsedOption . onArgument ( arg . substring ( endArg + <int> ) ) ; } else if ( arg . matches ( <str> ) ) { OptionParserState parsedOption = parseState . onStartOption ( arg , arg . substring ( <int> , <int> ) ) ; parseState = parsedOption . onArgument ( arg . substring ( <int> ) ) ; } else { assert arg . matches ( <str> ) ; String option = arg . substring ( <int> ) ; if ( optionsByString . containsKey ( option ) ) { OptionParserState parsedOption = parseState . onStartOption ( arg , option ) ; parseState = parsedOption . onStartNextArg ( ) ; } else { String option1 = arg . substring ( <int> , <int> ) ; OptionParserState parsedOption ; if ( optionsByString . containsKey ( option1 ) ) { parsedOption = parseState . onStartOption ( <str> + option1 , option1 ) ; if ( parsedOption . getHasArgument ( ) ) { parseState = parsedOption . onArgument ( arg . substring ( <int> ) ) ; } else { parseState = parsedOption . onComplete ( ) ; for ( int i = <int> ; i < arg . length ( ) ; i + + ) { String optionStr = arg . substring ( i , i + <int> ) ; parsedOption = parseState . onStartOption ( <str> + optionStr , optionStr ) ; parseState = parsedOption . onComplete ( ) ; } } } else { if ( allowUnknownOptions ) { parsedOption = parseState . onStartOption ( arg , option ) ; parseState = parsedOption . onComplete ( ) ; } else { parsedOption = parseState . onStartOption ( <str> + option1 , option1 ) ; parseState = parsedOption . onComplete ( ) ; } } } } } else { parseState = parseState . onNonOption ( arg ) ; } } parseState . onCommandLineEnd ( ) ; return parsedCommandLine ; } public CommandLineParser allowMixedSubcommandsAndOptions ( ) { allowMixedOptions = true ; return this ; } public CommandLineParser allowUnknownOptions ( ) { allowUnknownOptions = true ; return this ; } public CommandLineParser allowOneOf ( String . . . options ) { Set < CommandLineOption > commandLineOptions = new HashSet < CommandLineOption > ( ) ; for ( String option : options ) { commandLineOptions . add ( optionsByString . get ( option ) ) ; } for ( CommandLineOption commandLineOption : commandLineOptions ) { commandLineOption . groupWith ( commandLineOptions ) ; } return this ; } public void printUsage ( Appendable out ) { Formatter formatter = new Formatter ( out ) ; Set < CommandLineOption > orderedOptions = new TreeSet < CommandLineOption > ( new OptionComparator ( ) ) ; orderedOptions . addAll ( optionsByString . values ( ) ) ; Map < String , String > lines = new LinkedHashMap < String , String > ( ) ; for ( CommandLineOption option : orderedOptions ) { Set < String > orderedOptionStrings = new TreeSet < String > ( new OptionStringComparator ( ) ) ; orderedOptionStrings . addAll ( option . getOptions ( ) ) ; List < String > prefixedStrings = new ArrayList < String > ( ) ; for ( String optionString : orderedOptionStrings ) { if ( optionString . length ( ) = = <int> ) { prefixedStrings . add ( <str> + optionString ) ; } else { prefixedStrings . add ( <str> + optionString ) ; } } String key = join ( prefixedStrings , <str> ) ; String value = option . getDescription ( ) ; if ( value = = null | | value . length ( ) = = <int> ) { value = <str> ; } lines . put ( key , value ) ; } int max = <int> ; for ( String optionStr : lines . keySet ( ) ) { max = Math . max ( max , optionStr . length ( ) ) ; } for ( Map . Entry < String , String > entry : lines . entrySet ( ) ) { if ( entry . getValue ( ) . length ( ) = = <int> ) { formatter . format ( <str> , entry . getKey ( ) ) ; } else { formatter . format ( <str> + max + <str> , entry . getKey ( ) , entry . getValue ( ) ) ; } } formatter . flush ( ) ; } private static String join ( Collection < ? > things , String separator ) { StringBuffer buffer = new StringBuffer ( ) ; boolean first = true ; if ( separator = = null ) { separator = <str> ; } for ( Object thing : things ) { if ( ! first ) { buffer . append ( separator ) ; } buffer . append ( thing . toString ( ) ) ; first = false ; } return buffer . toString ( ) ; } public CommandLineOption option ( String . . . options ) { for ( String option : options ) { if ( optionsByString . containsKey ( option ) ) { throw new IllegalArgumentException ( String . format ( <str> , option ) ) ; } if ( option . startsWith ( <str> ) ) { throw new IllegalArgumentException ( String . format ( <str> , option ) ) ; } if ( ! OPTION_NAME_PATTERN . matcher ( option ) . matches ( ) ) { throw new IllegalArgumentException ( String . format ( <str> , option ) ) ; } } CommandLineOption option = new CommandLineOption ( Arrays . asList ( options ) ) ; for ( String optionStr : option . getOptions ( ) ) { optionsByString . put ( optionStr , option ) ; } return option ; } private static class OptionString { private final String arg ; private final String option ; private OptionString ( String arg , String option ) { this . arg = arg ; this . option = option ; } public String getDisplayName ( ) { return arg . startsWith ( <str> ) ? <str> + option : <str> + option ; } @Override public String toString ( ) { return getDisplayName ( ) ; } } private static abstract class ParserState { public abstract boolean maybeStartOption ( String arg ) ; boolean isOption ( String arg ) { return arg . matches ( <str> ) ; } public abstract OptionParserState onStartOption ( String arg , String option ) ; public abstract ParserState onNonOption ( String arg ) ; public void onCommandLineEnd ( ) { } } private abstract class OptionAwareParserState extends ParserState { protected final ParsedCommandLine commandLine ; protected OptionAwareParserState ( ParsedCommandLine commandLine ) { this . commandLine = commandLine ; } @Override public boolean maybeStartOption ( String arg ) { return isOption ( arg ) ; } @Override public ParserState onNonOption ( String arg ) { commandLine . addExtraValue ( arg ) ; return allowMixedOptions ? new AfterFirstSubCommand ( commandLine ) : new AfterOptions ( commandLine ) ; } } private class BeforeFirstSubCommand extends OptionAwareParserState { private BeforeFirstSubCommand ( ParsedCommandLine commandLine ) { super ( commandLine ) ; } @Override public OptionParserState onStartOption ( String arg , String option ) { OptionString optionString = new OptionString ( arg , option ) ; CommandLineOption commandLineOption = optionsByString . get ( option ) ; if ( commandLineOption = = null ) { if ( allowUnknownOptions ) { return new UnknownOptionParserState ( arg , commandLine , this ) ; } else { throw new CommandLineArgumentException ( String . format ( <str> , optionString ) ) ; } } return new KnownOptionParserState ( optionString , commandLineOption , commandLine , this ) ; } } private class AfterFirstSubCommand extends OptionAwareParserState { private AfterFirstSubCommand ( ParsedCommandLine commandLine ) { super ( commandLine ) ; } @Override public OptionParserState onStartOption ( String arg , String option ) { CommandLineOption commandLineOption = optionsByString . get ( option ) ; if ( commandLineOption = = null ) { return new UnknownOptionParserState ( arg , commandLine , this ) ; } return new KnownOptionParserState ( new OptionString ( arg , option ) , commandLineOption , commandLine , this ) ; } } private static class AfterOptions extends ParserState { private final ParsedCommandLine commandLine ; private AfterOptions ( ParsedCommandLine commandLine ) { this . commandLine = commandLine ; } @Override public boolean maybeStartOption ( String arg ) { return false ; } @Override public OptionParserState onStartOption ( String arg , String option ) { return new UnknownOptionParserState ( arg , commandLine , this ) ; } @Override public ParserState onNonOption ( String arg ) { commandLine . addExtraValue ( arg ) ; return this ; } } private static class MissingOptionArgState extends ParserState { private final OptionParserState option ; private MissingOptionArgState ( OptionParserState option ) { this . option = option ; } @Override public boolean maybeStartOption ( String arg ) { return isOption ( arg ) ; } @Override public OptionParserState onStartOption ( String arg , String option ) { return this . option . onComplete ( ) . onStartOption ( arg , option ) ; } @Override public ParserState onNonOption ( String arg ) { return option . onArgument ( arg ) ; } @Override public void onCommandLineEnd ( ) { option . onComplete ( ) ; } } private static abstract class OptionParserState { public abstract ParserState onStartNextArg ( ) ; public abstract ParserState onArgument ( String argument ) ; public abstract boolean getHasArgument ( ) ; public abstract ParserState onComplete ( ) ; } private class KnownOptionParserState extends OptionParserState { private final OptionString optionString ; private final CommandLineOption option ; private final ParsedCommandLine commandLine ; private final ParserState state ; private final List < String > values = new ArrayList < String > ( ) ; private KnownOptionParserState ( OptionString optionString , CommandLineOption option , ParsedCommandLine commandLine , ParserState state ) { this . optionString = optionString ; this . option = option ; this . commandLine = commandLine ; this . state = state ; } @Override public ParserState onArgument ( String argument ) { if ( ! getHasArgument ( ) ) { throw new CommandLineArgumentException ( String . format ( <str> , optionString ) ) ; } if ( argument . length ( ) = = <int> ) { throw new CommandLineArgumentException ( String . format ( <str> , optionString ) ) ; } values . add ( argument ) ; return onComplete ( ) ; } @Override public ParserState onStartNextArg ( ) { if ( option . getAllowsArguments ( ) & & values . isEmpty ( ) ) { return new MissingOptionArgState ( this ) ; } return onComplete ( ) ; } @Override public boolean getHasArgument ( ) { return option . getAllowsArguments ( ) ; } @Override public ParserState onComplete ( ) { if ( getHasArgument ( ) & & values . isEmpty ( ) ) { throw new CommandLineArgumentException ( String . format ( <str> , optionString ) ) ; } ParsedCommandLineOption parsedOption = commandLine . addOption ( optionString . option , option ) ; if ( values . size ( ) + parsedOption . getValues ( ) . size ( ) > <int> & & ! option . getAllowsMultipleArguments ( ) ) { throw new CommandLineArgumentException ( String . format ( <str> , optionString ) ) ; } for ( String value : values ) { parsedOption . addArgument ( value ) ; } if ( option . getDeprecationWarning ( ) ! = null ) { deprecationPrinter . println ( <str> + optionString + <str> + option . getDeprecationWarning ( ) ) ; } for ( CommandLineOption otherOption : option . getGroupWith ( ) ) { commandLine . removeOption ( otherOption ) ; } return state ; } } private static class UnknownOptionParserState extends OptionParserState { private final ParserState state ; private final String arg ; private final ParsedCommandLine commandLine ; private UnknownOptionParserState ( String arg , ParsedCommandLine commandLine , ParserState state ) { this . arg = arg ; this . commandLine = commandLine ; this . state = state ; } @Override public boolean getHasArgument ( ) { return true ; } @Override public ParserState onStartNextArg ( ) { return onComplete ( ) ; } @Override public ParserState onArgument ( String argument ) { return onComplete ( ) ; } @Override public ParserState onComplete ( ) { commandLine . addExtraValue ( arg ) ; return state ; } } private static final class OptionComparator implements Comparator < CommandLineOption > { public int compare ( CommandLineOption option1 , CommandLineOption option2 ) { String min1 = Collections . min ( option1 . getOptions ( ) , new OptionStringComparator ( ) ) ; String min2 = Collections . min ( option2 . getOptions ( ) , new OptionStringComparator ( ) ) ; return new CaseInsensitiveStringComparator ( ) . compare ( min1 , min2 ) ; } } private static final class CaseInsensitiveStringComparator implements Comparator < String > { public int compare ( String option1 , String option2 ) { int diff = option1 . compareToIgnoreCase ( option2 ) ; if ( diff ! = <int> ) { return diff ; } return option1 . compareTo ( option2 ) ; } } private static final class OptionStringComparator implements Comparator < String > { public int compare ( String option1 , String option2 ) { boolean short1 = option1 . length ( ) = = <int> ; boolean short2 = option2 . length ( ) = = <int> ; if ( short1 & & ! short2 ) { return - <int> ; } if ( ! short1 & & short2 ) { return <int> ; } return new CaseInsensitiveStringComparator ( ) . compare ( option1 , option2 ) ; } } } 
