package io . netty . handler . codec . http2 ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultEventLoopGroup ; import io . netty . channel . local . LocalAddress ; import io . netty . channel . local . LocalChannel ; import io . netty . channel . local . LocalServerChannel ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . DefaultHttpContent ; import io . netty . handler . codec . http . DefaultHttpRequest ; import io . netty . handler . codec . http . DefaultLastHttpContent ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . handler . codec . http . LastHttpContent ; import io . netty . handler . codec . http2 . Http2TestUtil . FrameCountDown ; import io . netty . util . AsciiString ; import io . netty . util . concurrent . Future ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import static io . netty . handler . codec . http . HttpMethod . CONNECT ; import static io . netty . handler . codec . http . HttpMethod . GET ; import static io . netty . handler . codec . http . HttpMethod . OPTIONS ; import static io . netty . handler . codec . http . HttpMethod . POST ; import static io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; import static io . netty . handler . codec . http2 . Http2TestUtil . of ; import static io . netty . util . CharsetUtil . UTF_8 ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyBoolean ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyShort ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . verify ; public class HttpToHttp2ConnectionHandlerTest { private static final int WAIT_TIME_SECONDS = <int> ; @Mock private Http2FrameListener clientListener ; @Mock private Http2FrameListener serverListener ; private ServerBootstrap sb ; private Bootstrap cb ; private Channel serverChannel ; private Channel clientChannel ; private CountDownLatch requestLatch ; private CountDownLatch serverSettingsAckLatch ; private CountDownLatch trailersLatch ; private FrameCountDown serverFrameCountDown ; @Before public void setup ( ) throws Exception { MockitoAnnotations . initMocks ( this ) ; } @After public void teardown ( ) throws Exception { if ( clientChannel ! = null ) { clientChannel . close ( ) . sync ( ) ; clientChannel = null ; } if ( serverChannel ! = null ) { serverChannel . close ( ) . sync ( ) ; serverChannel = null ; } Future < ? > serverGroup = sb . group ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; Future < ? > serverChildGroup = sb . childGroup ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; Future < ? > clientGroup = cb . group ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; serverGroup . sync ( ) ; serverChildGroup . sync ( ) ; clientGroup . sync ( ) ; } @Test public void testHeadersOnlyRequest ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testMultipleCookieEntriesAreCombined ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; httpHeaders . set ( HttpHeaderNames . COOKIE , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . add ( HttpHeaderNames . COOKIE , <str> ) . add ( HttpHeaderNames . COOKIE , <str> ) . add ( HttpHeaderNames . COOKIE , <str> ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testOriginFormRequestTargetHandled ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testOriginFormRequestTargetHandledFromUrlencodedUri ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testAbsoluteFormRequestTargetHandledFromHeaders ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . PATH . text ( ) , <str> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testAbsoluteFormRequestTargetHandledFromRequestTargetUri ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testAuthorityFormRequestTargetHandled ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , CONNECT , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testAsterikFormRequestTargetHandled ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , OPTIONS , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testHostIPv6FormRequestTargetHandled ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testHostFormRequestTargetHandled ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testHostIPv4FormRequestTargetHandled ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . set ( HttpConversionUtil . ExtensionHeaderNames . SCHEME . text ( ) , <str> ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; verifyHeadersOnly ( http2Headers , writePromise , clientChannel . writeAndFlush ( request , writePromise ) ) ; } @Test public void testNoSchemeRequestTargetHandled ( ) throws Exception { bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , GET , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_ID . text ( ) , <int> ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; ChannelPromise writePromise = newPromise ( ) ; ChannelFuture writeFuture = clientChannel . writeAndFlush ( request , writePromise ) ; assertTrue ( writePromise . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writePromise . isDone ( ) ) ; assertFalse ( writePromise . isSuccess ( ) ) ; assertTrue ( writeFuture . isDone ( ) ) ; assertFalse ( writeFuture . isSuccess ( ) ) ; } @Test public void testRequestWithBody ( ) throws Exception { final String text = <str> ; final List < String > receivedBuffers = Collections . synchronizedList ( new ArrayList < String > ( ) ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock in ) throws Throwable { receivedBuffers . add ( ( ( ByteBuf ) in . getArguments ( ) [ <int> ] ) . toString ( UTF_8 ) ) ; return null ; } } ) . when ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , any ( ByteBuf . class ) , eq ( <int> ) , eq ( true ) ) ; bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , POST , <str> , Unpooled . copiedBuffer ( text , UTF_8 ) ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; ChannelFuture writeFuture = clientChannel . writeAndFlush ( request , writePromise ) ; assertTrue ( writePromise . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writePromise . isSuccess ( ) ) ; assertTrue ( writeFuture . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writeFuture . isSuccess ( ) ) ; awaitRequests ( ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( http2Headers ) , eq ( <int> ) , anyShort ( ) , anyBoolean ( ) , eq ( <int> ) , eq ( false ) ) ; verify ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , any ( ByteBuf . class ) , eq ( <int> ) , eq ( true ) ) ; assertEquals ( <int> , receivedBuffers . size ( ) ) ; assertEquals ( text , receivedBuffers . get ( <int> ) ) ; } @Test public void testRequestWithBodyAndTrailingHeaders ( ) throws Exception { final String text = <str> ; final List < String > receivedBuffers = Collections . synchronizedList ( new ArrayList < String > ( ) ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock in ) throws Throwable { receivedBuffers . add ( ( ( ByteBuf ) in . getArguments ( ) [ <int> ] ) . toString ( UTF_8 ) ) ; return null ; } } ) . when ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , any ( ByteBuf . class ) , eq ( <int> ) , eq ( false ) ) ; bootstrapEnv ( <int> , <int> , <int> ) ; final FullHttpRequest request = new DefaultFullHttpRequest ( HTTP_1_1 , POST , <str> , Unpooled . copiedBuffer ( text , UTF_8 ) ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) ; request . trailingHeaders ( ) . add ( of ( <str> ) , of ( <str> ) ) ; final Http2Headers http2TrailingHeaders = new DefaultHttp2Headers ( ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; ChannelFuture writeFuture = clientChannel . writeAndFlush ( request , writePromise ) ; assertTrue ( writePromise . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writePromise . isSuccess ( ) ) ; assertTrue ( writeFuture . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writeFuture . isSuccess ( ) ) ; awaitRequests ( ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( http2Headers ) , eq ( <int> ) , anyShort ( ) , anyBoolean ( ) , eq ( <int> ) , eq ( false ) ) ; verify ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , any ( ByteBuf . class ) , eq ( <int> ) , eq ( false ) ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( http2TrailingHeaders ) , eq ( <int> ) , anyShort ( ) , anyBoolean ( ) , eq ( <int> ) , eq ( true ) ) ; assertEquals ( <int> , receivedBuffers . size ( ) ) ; assertEquals ( text , receivedBuffers . get ( <int> ) ) ; } @Test public void testChunkedRequestWithBodyAndTrailingHeaders ( ) throws Exception { final String text = <str> ; final String text2 = <str> ; final List < String > receivedBuffers = Collections . synchronizedList ( new ArrayList < String > ( ) ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock in ) throws Throwable { receivedBuffers . add ( ( ( ByteBuf ) in . getArguments ( ) [ <int> ] ) . toString ( UTF_8 ) ) ; return null ; } } ) . when ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , any ( ByteBuf . class ) , eq ( <int> ) , eq ( false ) ) ; bootstrapEnv ( <int> , <int> , <int> ) ; final HttpRequest request = new DefaultHttpRequest ( HTTP_1_1 , POST , <str> ) ; final HttpHeaders httpHeaders = request . headers ( ) ; httpHeaders . set ( HttpHeaderNames . HOST , <str> ) ; httpHeaders . add ( HttpHeaderNames . TRANSFER_ENCODING , <str> ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; httpHeaders . add ( of ( <str> ) , of ( <str> ) ) ; final Http2Headers http2Headers = new DefaultHttp2Headers ( ) . method ( new AsciiString ( <str> ) ) . path ( new AsciiString ( <str> ) ) . authority ( new AsciiString ( <str> ) ) . scheme ( new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) ; final DefaultHttpContent httpContent = new DefaultHttpContent ( Unpooled . copiedBuffer ( text , UTF_8 ) ) ; final LastHttpContent lastHttpContent = new DefaultLastHttpContent ( Unpooled . copiedBuffer ( text2 , UTF_8 ) ) ; lastHttpContent . trailingHeaders ( ) . add ( of ( <str> ) , of ( <str> ) ) ; final Http2Headers http2TrailingHeaders = new DefaultHttp2Headers ( ) . add ( new AsciiString ( <str> ) , new AsciiString ( <str> ) ) ; ChannelPromise writePromise = newPromise ( ) ; ChannelFuture writeFuture = clientChannel . write ( request , writePromise ) ; ChannelPromise contentPromise = newPromise ( ) ; ChannelFuture contentFuture = clientChannel . write ( httpContent , contentPromise ) ; ChannelPromise lastContentPromise = newPromise ( ) ; ChannelFuture lastContentFuture = clientChannel . write ( lastHttpContent , lastContentPromise ) ; clientChannel . flush ( ) ; assertTrue ( writePromise . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writePromise . isSuccess ( ) ) ; assertTrue ( writeFuture . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writeFuture . isSuccess ( ) ) ; assertTrue ( contentPromise . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( contentPromise . isSuccess ( ) ) ; assertTrue ( contentFuture . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( contentFuture . isSuccess ( ) ) ; assertTrue ( lastContentPromise . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( lastContentPromise . isSuccess ( ) ) ; assertTrue ( lastContentFuture . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( lastContentFuture . isSuccess ( ) ) ; awaitRequests ( ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( http2Headers ) , eq ( <int> ) , anyShort ( ) , anyBoolean ( ) , eq ( <int> ) , eq ( false ) ) ; verify ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , any ( ByteBuf . class ) , eq ( <int> ) , eq ( false ) ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( http2TrailingHeaders ) , eq ( <int> ) , anyShort ( ) , anyBoolean ( ) , eq ( <int> ) , eq ( true ) ) ; assertEquals ( <int> , receivedBuffers . size ( ) ) ; assertEquals ( text + text2 , receivedBuffers . get ( <int> ) ) ; } private void bootstrapEnv ( int requestCountDown , int serverSettingsAckCount , int trailersCount ) throws Exception { requestLatch = new CountDownLatch ( requestCountDown ) ; serverSettingsAckLatch = new CountDownLatch ( serverSettingsAckCount ) ; trailersLatch = trailersCount = = <int> ? null : new CountDownLatch ( trailersCount ) ; sb = new ServerBootstrap ( ) ; cb = new Bootstrap ( ) ; sb . group ( new DefaultEventLoopGroup ( ) ) ; sb . channel ( LocalServerChannel . class ) ; sb . childHandler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; serverFrameCountDown = new FrameCountDown ( serverListener , serverSettingsAckLatch , requestLatch , null , trailersLatch ) ; p . addLast ( new HttpToHttp2ConnectionHandler . Builder ( ) . server ( true ) . frameListener ( serverFrameCountDown ) . build ( ) ) ; } } ) ; cb . group ( new DefaultEventLoopGroup ( ) ) ; cb . channel ( LocalChannel . class ) ; cb . handler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; HttpToHttp2ConnectionHandler handler = new HttpToHttp2ConnectionHandler . Builder ( ) . server ( false ) . frameListener ( clientListener ) . gracefulShutdownTimeoutMillis ( <int> ) . build ( ) ; p . addLast ( handler ) ; } } ) ; serverChannel = sb . bind ( new LocalAddress ( <str> ) ) . sync ( ) . channel ( ) ; ChannelFuture ccf = cb . connect ( serverChannel . localAddress ( ) ) ; assertTrue ( ccf . awaitUninterruptibly ( ) . isSuccess ( ) ) ; clientChannel = ccf . channel ( ) ; } private void verifyHeadersOnly ( Http2Headers expected , ChannelPromise writePromise , ChannelFuture writeFuture ) throws Exception { assertTrue ( writePromise . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writePromise . isSuccess ( ) ) ; assertTrue ( writeFuture . awaitUninterruptibly ( WAIT_TIME_SECONDS , SECONDS ) ) ; assertTrue ( writeFuture . isSuccess ( ) ) ; awaitRequests ( ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( expected ) , eq ( <int> ) , anyShort ( ) , anyBoolean ( ) , eq ( <int> ) , eq ( true ) ) ; verify ( serverListener , never ( ) ) . onDataRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( ByteBuf . class ) , anyInt ( ) , anyBoolean ( ) ) ; } private void awaitRequests ( ) throws Exception { assertTrue ( requestLatch . await ( WAIT_TIME_SECONDS , SECONDS ) ) ; if ( trailersLatch ! = null ) { assertTrue ( trailersLatch . await ( WAIT_TIME_SECONDS , SECONDS ) ) ; } assertTrue ( serverSettingsAckLatch . await ( WAIT_TIME_SECONDS , SECONDS ) ) ; } private ChannelHandlerContext ctx ( ) { return clientChannel . pipeline ( ) . firstContext ( ) ; } private ChannelPromise newPromise ( ) { return ctx ( ) . newPromise ( ) ; } } 
