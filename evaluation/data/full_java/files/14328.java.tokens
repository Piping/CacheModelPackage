package org . gradle . model . internal . inspect ; import org . gradle . api . Named ; import org . gradle . internal . typeconversion . TypeConverter ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . core . rule . describe . ModelRuleDescriptor ; import org . gradle . model . internal . manage . instance . ManagedProxyFactory ; import org . gradle . model . internal . manage . projection . ManagedModelProjection ; import org . gradle . model . internal . manage . schema . * ; import org . gradle . model . internal . type . ModelType ; import java . util . Collection ; public abstract class AbstractManagedModelInitializer < T > implements NodeInitializer { protected final StructSchema < T > schema ; public AbstractManagedModelInitializer ( StructSchema < T > schema ) { this . schema = schema ; } protected void addPropertyLinks ( MutableModelNode modelNode , NodeInitializerRegistry nodeInitializerRegistry , ManagedProxyFactory proxyFactory , Collection < ModelProperty < ? > > properties , TypeConverter typeConverter ) { for ( ModelProperty < ? > property : properties ) { addPropertyLink ( modelNode , property , nodeInitializerRegistry , proxyFactory , typeConverter ) ; } if ( isANamedType ( ) ) { ModelProperty < ? > nameProperty = schema . getProperty ( <str> ) ; if ( nameProperty ! = null & & nameProperty . getStateManagementType ( ) . equals ( ModelProperty . StateManagementType . MANAGED ) & & properties . contains ( nameProperty ) ) { MutableModelNode nameLink = modelNode . getLink ( <str> ) ; if ( nameLink = = null ) { throw new IllegalStateException ( <str> + modelNode . getPath ( ) ) ; } nameLink . setPrivateData ( ModelType . of ( String . class ) , modelNode . getPath ( ) . getName ( ) ) ; } } } private < P > void addPropertyLink ( MutableModelNode modelNode , ModelProperty < P > property , NodeInitializerRegistry nodeInitializerRegistry , ManagedProxyFactory proxyFactory , TypeConverter typeConverter ) { if ( ! property . getStateManagementType ( ) . equals ( ModelProperty . StateManagementType . MANAGED ) ) { return ; } ModelType < P > propertyType = property . getType ( ) ; ModelSchema < P > propertySchema = property . getSchema ( ) ; validateProperty ( propertySchema , property , nodeInitializerRegistry ) ; ModelRuleDescriptor descriptor = modelNode . getDescriptor ( ) ; ModelPath childPath = modelNode . getPath ( ) . child ( property . getName ( ) ) ; if ( propertySchema instanceof ManagedImplSchema ) { if ( ! property . isWritable ( ) ) { ModelRegistration registration = ModelRegistrations . of ( childPath , nodeInitializerRegistry . getNodeInitializer ( NodeInitializerContext . forProperty ( propertySchema . getType ( ) , property , schema . getType ( ) ) ) ) . descriptor ( descriptor ) . build ( ) ; modelNode . addLink ( registration ) ; } else { if ( propertySchema instanceof ScalarCollectionSchema ) { ModelRegistration registration = ModelRegistrations . of ( childPath , nodeInitializerRegistry . getNodeInitializer ( NodeInitializerContext . forProperty ( propertySchema . getType ( ) , property , schema . getType ( ) ) ) ) . descriptor ( descriptor ) . build ( ) ; modelNode . addLink ( registration ) ; } else { ManagedImplStructSchema < P > structSchema = ( ManagedImplStructSchema < P > ) propertySchema ; ModelProjection projection = new ManagedModelProjection < P > ( structSchema , null , proxyFactory , typeConverter ) ; ModelRegistration registration = ModelRegistrations . of ( childPath ) . withProjection ( projection ) . descriptor ( descriptor ) . build ( ) ; modelNode . addReference ( registration ) ; } } } else { ModelProjection projection = new UnmanagedModelProjection < P > ( propertyType , true , true ) ; ModelRegistrations . Builder registrationBuilder ; if ( shouldHaveANodeInitializer ( property , propertySchema ) ) { registrationBuilder = ModelRegistrations . of ( childPath , nodeInitializerRegistry . getNodeInitializer ( NodeInitializerContext . forProperty ( propertyType , property , schema . getType ( ) ) ) ) ; } else { registrationBuilder = ModelRegistrations . of ( childPath ) ; } registrationBuilder . withProjection ( projection ) . descriptor ( descriptor ) ; modelNode . addLink ( registrationBuilder . build ( ) ) ; } } private < P > void validateProperty ( ModelSchema < P > propertySchema , ModelProperty < P > property , NodeInitializerRegistry nodeInitializerRegistry ) { if ( propertySchema instanceof ManagedImplSchema ) { if ( ! property . isWritable ( ) ) { if ( isCollectionOfManagedTypes ( propertySchema ) ) { CollectionSchema < P , ? > propertyCollectionsSchema = ( CollectionSchema < P , ? > ) propertySchema ; ModelType < ? > elementType = propertyCollectionsSchema . getElementType ( ) ; nodeInitializerRegistry . ensureHasInitializer ( NodeInitializerContext . forProperty ( elementType , property , schema . getType ( ) ) ) ; } if ( property . isDeclaredAsHavingUnmanagedType ( ) ) { throw new UnmanagedPropertyMissingSetterException ( property ) ; } } } else if ( ! shouldHaveANodeInitializer ( property , propertySchema ) & & ! property . isWritable ( ) & & ! isNamePropertyOfANamedType ( property ) ) { throw new ReadonlyImmutableManagedPropertyException ( schema . getType ( ) , property . getName ( ) , property . getType ( ) ) ; } } private < P > boolean isCollectionOfManagedTypes ( ModelSchema < P > propertySchema ) { return propertySchema instanceof CollectionSchema & & ! ( propertySchema instanceof ScalarCollectionSchema ) ; } private < P > boolean isNamePropertyOfANamedType ( ModelProperty < P > property ) { return isANamedType ( ) & & <str> . equals ( property . getName ( ) ) ; } public boolean isANamedType ( ) { return Named . class . isAssignableFrom ( schema . getType ( ) . getRawClass ( ) ) ; } private < P > boolean shouldHaveANodeInitializer ( ModelProperty < P > property , ModelSchema < P > propertySchema ) { return ! ( propertySchema instanceof ScalarValueSchema ) & & ! property . isDeclaredAsHavingUnmanagedType ( ) ; } } 
