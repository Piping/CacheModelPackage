package org . elasticsearch . common . compress ; import org . apache . lucene . store . IndexInput ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . compress . deflate . DeflateCompressor ; import org . elasticsearch . common . io . Streams ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentType ; import org . jboss . netty . buffer . ChannelBuffer ; import java . io . IOException ; public class CompressorFactory { private static final Compressor [ ] compressors ; private static volatile Compressor defaultCompressor ; static { compressors = new Compressor [ ] { new DeflateCompressor ( ) } ; defaultCompressor = new DeflateCompressor ( ) ; } public static void setDefaultCompressor ( Compressor defaultCompressor ) { CompressorFactory . defaultCompressor = defaultCompressor ; } public static Compressor defaultCompressor ( ) { return defaultCompressor ; } public static boolean isCompressed ( BytesReference bytes ) { return compressor ( bytes ) ! = null ; } @Deprecated public static boolean isCompressed ( IndexInput in ) throws IOException { return compressor ( in ) ! = null ; } @Nullable public static Compressor compressor ( BytesReference bytes ) { for ( Compressor compressor : compressors ) { if ( compressor . isCompressed ( bytes ) ) { assert XContentFactory . xContentType ( bytes ) = = null ; return compressor ; } } XContentType contentType = XContentFactory . xContentType ( bytes ) ; if ( contentType = = null ) { if ( isAncient ( bytes ) ) { throw new IllegalStateException ( <str> ) ; } throw new NotXContentException ( <str> ) ; } return null ; } private static boolean isAncient ( BytesReference bytes ) { return bytes . length ( ) > = <int> & & bytes . get ( <int> ) = = <str> & & bytes . get ( <int> ) = = <str> & & ( bytes . get ( <int> ) = = <int> | | bytes . get ( <int> ) = = <int> ) ; } public static Compressor compressor ( ChannelBuffer buffer ) { for ( Compressor compressor : compressors ) { if ( compressor . isCompressed ( buffer ) ) { return compressor ; } } throw new NotCompressedException ( ) ; } @Deprecated @Nullable public static Compressor compressor ( IndexInput in ) throws IOException { for ( Compressor compressor : compressors ) { if ( compressor . isCompressed ( in ) ) { return compressor ; } } return null ; } public static BytesReference uncompressIfNeeded ( BytesReference bytes ) throws IOException { Compressor compressor = compressor ( bytes ) ; BytesReference uncompressed ; if ( compressor ! = null ) { uncompressed = uncompress ( bytes , compressor ) ; } else { uncompressed = bytes ; } return uncompressed ; } public static BytesReference uncompress ( BytesReference bytes ) throws IOException { Compressor compressor = compressor ( bytes ) ; if ( compressor = = null ) { throw new NotCompressedException ( ) ; } return uncompress ( bytes , compressor ) ; } private static BytesReference uncompress ( BytesReference bytes , Compressor compressor ) throws IOException { StreamInput compressed = compressor . streamInput ( bytes . streamInput ( ) ) ; BytesStreamOutput bStream = new BytesStreamOutput ( ) ; Streams . copy ( compressed , bStream ) ; compressed . close ( ) ; return bStream . bytes ( ) ; } } 
