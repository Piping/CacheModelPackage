package org . apache . cassandra . db . partitions ; import java . util . * ; import java . security . MessageDigest ; import org . apache . cassandra . db . EmptyIterators ; import org . apache . cassandra . db . transform . MorePartitions ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . utils . AbstractIterator ; import org . apache . cassandra . db . SinglePartitionReadCommand ; import org . apache . cassandra . db . rows . * ; public abstract class PartitionIterators { private PartitionIterators ( ) { } @SuppressWarnings ( <str> ) public static RowIterator getOnlyElement ( final PartitionIterator iter , SinglePartitionReadCommand command ) { RowIterator toReturn = iter . hasNext ( ) ? iter . next ( ) : EmptyIterators . row ( command . metadata ( ) , command . partitionKey ( ) , command . clusteringIndexFilter ( ) . isReversed ( ) ) ; class Close extends Transformation { public void onPartitionClose ( ) { boolean hadNext = iter . hasNext ( ) ; iter . close ( ) ; assert ! hadNext ; } } return Transformation . apply ( toReturn , new Close ( ) ) ; } @SuppressWarnings ( <str> ) public static PartitionIterator concat ( final List < PartitionIterator > iterators ) { if ( iterators . size ( ) = = <int> ) return iterators . get ( <int> ) ; class Extend implements MorePartitions < PartitionIterator > { int i = <int> ; public PartitionIterator moreContents ( ) { if ( i > = iterators . size ( ) ) return null ; return iterators . get ( i + + ) ; } } return MorePartitions . extend ( iterators . get ( <int> ) , new Extend ( ) ) ; } public static void digest ( PartitionIterator iterator , MessageDigest digest ) { while ( iterator . hasNext ( ) ) { try ( RowIterator partition = iterator . next ( ) ) { RowIterators . digest ( partition , digest ) ; } } } public static PartitionIterator singletonIterator ( RowIterator iterator ) { return new SingletonPartitionIterator ( iterator ) ; } public static void consume ( PartitionIterator iterator ) { while ( iterator . hasNext ( ) ) { try ( RowIterator partition = iterator . next ( ) ) { while ( partition . hasNext ( ) ) partition . next ( ) ; } } } @SuppressWarnings ( <str> ) public static PartitionIterator loggingIterator ( PartitionIterator iterator , final String id ) { class Logger extends Transformation < RowIterator > { public RowIterator applyToPartition ( RowIterator partition ) { return RowIterators . loggingIterator ( partition , id ) ; } } return Transformation . apply ( iterator , new Logger ( ) ) ; } private static class SingletonPartitionIterator extends AbstractIterator < RowIterator > implements PartitionIterator { private final RowIterator iterator ; private boolean returned ; private SingletonPartitionIterator ( RowIterator iterator ) { this . iterator = iterator ; } protected RowIterator computeNext ( ) { if ( returned ) return endOfData ( ) ; returned = true ; return iterator ; } public void close ( ) { iterator . close ( ) ; } } } 
