package org . elasticsearch . cloud . aws ; import com . amazonaws . AmazonClientException ; import com . amazonaws . AmazonWebServiceRequest ; import com . amazonaws . ClientConfiguration ; import com . amazonaws . Protocol ; import com . amazonaws . auth . * ; import com . amazonaws . internal . StaticCredentialsProvider ; import com . amazonaws . retry . RetryPolicy ; import com . amazonaws . services . ec2 . AmazonEC2 ; import com . amazonaws . services . ec2 . AmazonEC2Client ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . cloud . aws . network . Ec2NameResolver ; import org . elasticsearch . cloud . aws . node . Ec2CustomNodeAttributes ; import org . elasticsearch . cluster . node . DiscoveryNodeService ; import org . elasticsearch . common . Randomness ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import java . util . Locale ; import java . util . Random ; public class AwsEc2ServiceImpl extends AbstractLifecycleComponent < AwsEc2Service > implements AwsEc2Service { public static final String EC2_METADATA_URL = <str> ; private AmazonEC2Client client ; @Inject public AwsEc2ServiceImpl ( Settings settings , SettingsFilter settingsFilter , NetworkService networkService , DiscoveryNodeService discoveryNodeService ) { super ( settings ) ; settingsFilter . addFilter ( CLOUD_AWS . KEY ) ; settingsFilter . addFilter ( CLOUD_AWS . SECRET ) ; settingsFilter . addFilter ( CLOUD_AWS . PROXY_PASSWORD ) ; settingsFilter . addFilter ( CLOUD_EC2 . KEY ) ; settingsFilter . addFilter ( CLOUD_EC2 . SECRET ) ; settingsFilter . addFilter ( CLOUD_EC2 . PROXY_PASSWORD ) ; networkService . addCustomNameResolver ( new Ec2NameResolver ( settings ) ) ; discoveryNodeService . addCustomAttributeProvider ( new Ec2CustomNodeAttributes ( settings ) ) ; } public synchronized AmazonEC2 client ( ) { if ( client ! = null ) { return client ; } ClientConfiguration clientConfiguration = new ClientConfiguration ( ) ; clientConfiguration . setResponseMetadataCacheSize ( <int> ) ; String protocol = settings . get ( CLOUD_EC2 . PROTOCOL , settings . get ( CLOUD_AWS . PROTOCOL , <str> ) ) . toLowerCase ( Locale . ROOT ) ; if ( <str> . equals ( protocol ) ) { clientConfiguration . setProtocol ( Protocol . HTTP ) ; } else if ( <str> . equals ( protocol ) ) { clientConfiguration . setProtocol ( Protocol . HTTPS ) ; } else { throw new IllegalArgumentException ( <str> + protocol + <str> ) ; } String account = settings . get ( CLOUD_EC2 . KEY , settings . get ( CLOUD_AWS . KEY ) ) ; String key = settings . get ( CLOUD_EC2 . SECRET , settings . get ( CLOUD_AWS . SECRET ) ) ; String proxyHost = settings . get ( CLOUD_AWS . PROXY_HOST , settings . get ( CLOUD_AWS . DEPRECATED_PROXY_HOST ) ) ; proxyHost = settings . get ( CLOUD_EC2 . PROXY_HOST , settings . get ( CLOUD_EC2 . DEPRECATED_PROXY_HOST , proxyHost ) ) ; if ( proxyHost ! = null ) { String portString = settings . get ( CLOUD_AWS . PROXY_PORT , settings . get ( CLOUD_AWS . DEPRECATED_PROXY_PORT , <str> ) ) ; portString = settings . get ( CLOUD_EC2 . PROXY_PORT , settings . get ( CLOUD_EC2 . DEPRECATED_PROXY_PORT , portString ) ) ; Integer proxyPort ; try { proxyPort = Integer . parseInt ( portString , <int> ) ; } catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( <str> + portString + <str> , ex ) ; } String proxyUsername = settings . get ( CLOUD_EC2 . PROXY_USERNAME , settings . get ( CLOUD_AWS . PROXY_USERNAME ) ) ; String proxyPassword = settings . get ( CLOUD_EC2 . PROXY_PASSWORD , settings . get ( CLOUD_AWS . PROXY_PASSWORD ) ) ; clientConfiguration . withProxyHost ( proxyHost ) . withProxyPort ( proxyPort ) . withProxyUsername ( proxyUsername ) . withProxyPassword ( proxyPassword ) ; } String awsSigner = settings . get ( CLOUD_EC2 . SIGNER , settings . get ( CLOUD_AWS . SIGNER ) ) ; if ( awsSigner ! = null ) { logger . debug ( <str> , awsSigner ) ; try { AwsSigner . configureSigner ( awsSigner , clientConfiguration ) ; } catch ( IllegalArgumentException e ) { logger . warn ( <str> , CLOUD_EC2 . SIGNER , CLOUD_AWS . SIGNER , awsSigner ) ; } } final Random rand = Randomness . get ( ) ; RetryPolicy retryPolicy = new RetryPolicy ( RetryPolicy . RetryCondition . NO_RETRY_CONDITION , new RetryPolicy . BackoffStrategy ( ) { @Override public long delayBeforeNextRetry ( AmazonWebServiceRequest originalRequest , AmazonClientException exception , int retriesAttempted ) { logger . warn ( <str> , exception ) ; return <int> * ( long ) ( <int> d * Math . pow ( <int> , ( ( double ) retriesAttempted ) / <float> ) * ( <float> + rand . nextDouble ( ) ) ) ; } } , <int> , false ) ; clientConfiguration . setRetryPolicy ( retryPolicy ) ; AWSCredentialsProvider credentials ; if ( account = = null & & key = = null ) { credentials = new AWSCredentialsProviderChain ( new EnvironmentVariableCredentialsProvider ( ) , new SystemPropertiesCredentialsProvider ( ) , new InstanceProfileCredentialsProvider ( ) ) ; } else { credentials = new AWSCredentialsProviderChain ( new StaticCredentialsProvider ( new BasicAWSCredentials ( account , key ) ) ) ; } this . client = new AmazonEC2Client ( credentials , clientConfiguration ) ; if ( settings . get ( CLOUD_EC2 . ENDPOINT ) ! = null ) { String endpoint = settings . get ( CLOUD_EC2 . ENDPOINT ) ; logger . debug ( <str> , endpoint ) ; client . setEndpoint ( endpoint ) ; } else if ( settings . get ( CLOUD_AWS . REGION ) ! = null ) { String region = settings . get ( CLOUD_AWS . REGION ) . toLowerCase ( Locale . ROOT ) ; String endpoint ; if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else if ( region . equals ( <str> ) | | region . equals ( <str> ) ) { endpoint = <str> ; } else { throw new IllegalArgumentException ( <str> + region + <str> ) ; } logger . debug ( <str> , region , endpoint ) ; client . setEndpoint ( endpoint ) ; } return this . client ; } @Override protected void doStart ( ) throws ElasticsearchException { } @Override protected void doStop ( ) throws ElasticsearchException { } @Override protected void doClose ( ) throws ElasticsearchException { if ( client ! = null ) { client . shutdown ( ) ; } } } 
