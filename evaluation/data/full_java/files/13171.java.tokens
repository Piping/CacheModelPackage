package org . gradle . plugins . ide . internal . tooling ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import com . google . common . collect . Sets ; import org . gradle . api . GradleException ; import org . gradle . api . Project ; import org . gradle . api . Task ; import org . gradle . api . internal . project . ProjectTaskLister ; import org . gradle . api . internal . tasks . PublicTaskSpecification ; import org . gradle . tooling . internal . consumer . converters . TaskNameComparator ; import org . gradle . plugins . ide . internal . tooling . model . DefaultBuildInvocations ; import org . gradle . plugins . ide . internal . tooling . model . LaunchableGradleTask ; import org . gradle . plugins . ide . internal . tooling . model . LaunchableGradleTaskSelector ; import org . gradle . tooling . model . internal . ProjectSensitiveToolingModelBuilder ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import java . util . Set ; import static org . gradle . plugins . ide . internal . tooling . ToolingModelBuilderSupport . buildFromTask ; public class BuildInvocationsBuilder extends ProjectSensitiveToolingModelBuilder { private final ProjectTaskLister taskLister ; private final TaskNameComparator taskNameComparator ; public BuildInvocationsBuilder ( ProjectTaskLister taskLister ) { this . taskLister = taskLister ; this . taskNameComparator = new TaskNameComparator ( ) ; } public boolean canBuild ( String modelName ) { return modelName . equals ( <str> ) ; } public DefaultBuildInvocations buildAll ( String modelName , Project project , boolean implicitProject ) { return buildAll ( modelName , implicitProject ? project . getRootProject ( ) : project ) ; } @SuppressWarnings ( <str> ) public DefaultBuildInvocations buildAll ( String modelName , Project project ) { if ( ! canBuild ( modelName ) ) { throw new GradleException ( <str> + modelName ) ; } List < LaunchableGradleTaskSelector > selectors = Lists . newArrayList ( ) ; Map < String , LaunchableGradleTaskSelector > selectorsByName = Maps . newTreeMap ( Ordering . natural ( ) ) ; Set < String > visibleTasks = Sets . newLinkedHashSet ( ) ; findTasks ( project , selectorsByName , visibleTasks ) ; for ( String selectorName : selectorsByName . keySet ( ) ) { LaunchableGradleTaskSelector selector = selectorsByName . get ( selectorName ) ; selectors . add ( selector . setName ( selectorName ) . setTaskName ( selectorName ) . setProjectPath ( project . getPath ( ) ) . setDisplayName ( String . format ( <str> , selectorName , project . toString ( ) ) ) . setPublic ( visibleTasks . contains ( selectorName ) ) ) ; } List < LaunchableGradleTask > projectTasks = tasks ( project ) ; return new DefaultBuildInvocations ( ) . setSelectors ( selectors ) . setTasks ( projectTasks ) ; } private List < LaunchableGradleTask > tasks ( Project project ) { List < LaunchableGradleTask > tasks = Lists . newArrayList ( ) ; for ( Task task : taskLister . listProjectTasks ( project ) ) { tasks . add ( buildFromTask ( new LaunchableGradleTask ( ) , task ) ) ; } return tasks ; } private void findTasks ( Project project , Map < String , LaunchableGradleTaskSelector > taskSelectors , Collection < String > visibleTasks ) { for ( Project child : project . getChildProjects ( ) . values ( ) ) { findTasks ( child , taskSelectors , visibleTasks ) ; } for ( Task task : taskLister . listProjectTasks ( project ) ) { if ( ! taskSelectors . containsKey ( task . getName ( ) ) ) { LaunchableGradleTaskSelector taskSelector = new LaunchableGradleTaskSelector ( ) . setDescription ( task . getDescription ( ) ) . setProjectPath ( task . getPath ( ) ) ; taskSelectors . put ( task . getName ( ) , taskSelector ) ; } else { LaunchableGradleTaskSelector taskSelector = taskSelectors . get ( task . getName ( ) ) ; if ( hasPathWithLowerOrdering ( task , taskSelector ) ) { taskSelector . setDescription ( task . getDescription ( ) ) . setProjectPath ( task . getPath ( ) ) ; } } if ( PublicTaskSpecification . INSTANCE . isSatisfiedBy ( task ) ) { visibleTasks . add ( task . getName ( ) ) ; } } } private boolean hasPathWithLowerOrdering ( Task task , LaunchableGradleTaskSelector referenceTaskSelector ) { return taskNameComparator . compare ( task . getPath ( ) , referenceTaskSelector . getProjectPath ( ) ) < <int> ; } } 
