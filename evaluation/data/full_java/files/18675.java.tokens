package com . badlogic . gdx . tests . g3d ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Attribute ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . Shader ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . model . Node ; import com . badlogic . gdx . graphics . g3d . shaders . BaseShader ; import com . badlogic . gdx . graphics . g3d . utils . BaseShaderProvider ; import com . badlogic . gdx . graphics . g3d . utils . CameraInputController ; import com . badlogic . gdx . graphics . g3d . utils . DefaultShaderProvider ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . graphics . g3d . utils . RenderContext ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class ShaderTest extends GdxTest { public static class TestAttribute extends Attribute { public final static String Alias = <str> ; public final static long ID = register ( Alias ) ; public float value ; protected TestAttribute ( final float value ) { super ( ID ) ; this . value = value ; } @Override public Attribute copy ( ) { return new TestAttribute ( value ) ; } @Override protected boolean equals ( Attribute other ) { return ( ( TestAttribute ) other ) . value = = value ; } @Override public int compareTo ( Attribute o ) { if ( type ! = o . type ) return type < o . type ? - <int> : <int> ; float otherValue = ( ( TestAttribute ) o ) . value ; return MathUtils . isEqual ( value , otherValue ) ? <int> : ( value < otherValue ? - <int> : <int> ) ; } } public static class TestShader extends BaseShader { public final static String vertexShader = <str> + <str> + <str> + <str> + <str> + <str> ; public final static String fragmentShader = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; protected final int u_projTrans = register ( new Uniform ( <str> ) ) ; protected final int u_worldTrans = register ( new Uniform ( <str> ) ) ; protected final int u_test = register ( new Uniform ( <str> ) ) ; protected final int u_color = register ( new Uniform ( <str> ) ) ; protected final ShaderProgram program ; private boolean withColor ; public TestShader ( Renderable renderable ) { super ( ) ; withColor = renderable . material . has ( ColorAttribute . Diffuse ) ; if ( withColor ) Gdx . app . log ( <str> , <str> ) ; else Gdx . app . log ( <str> , <str> ) ; String prefix = withColor ? <str> : <str> ; program = new ShaderProgram ( vertexShader , prefix + fragmentShader ) ; if ( ! program . isCompiled ( ) ) throw new GdxRuntimeException ( <str> + program . getLog ( ) ) ; String log = program . getLog ( ) ; if ( log . length ( ) > <int> ) Gdx . app . error ( <str> , <str> + log ) ; } @Override public void init ( ) { super . init ( program , null ) ; } @Override public int compareTo ( Shader other ) { return <int> ; } @Override public boolean canRender ( Renderable instance ) { return instance . material . has ( TestAttribute . ID ) & & ( instance . material . has ( ColorAttribute . Diffuse ) = = withColor ) ; } @Override public void begin ( Camera camera , RenderContext context ) { program . begin ( ) ; context . setDepthTest ( GL20 . GL_LEQUAL , <float> , <float> ) ; context . setDepthMask ( true ) ; set ( u_projTrans , camera . combined ) ; } @Override public void render ( Renderable renderable ) { set ( u_worldTrans , renderable . worldTransform ) ; TestAttribute testAttr = ( TestAttribute ) renderable . material . get ( TestAttribute . ID ) ; set ( u_test , testAttr . value ) ; if ( withColor ) { ColorAttribute colorAttr = ( ColorAttribute ) renderable . material . get ( ColorAttribute . Diffuse ) ; set ( u_color , colorAttr . color ) ; } renderable . meshPart . render ( program ) ; } @Override public void end ( ) { program . end ( ) ; } @Override public void dispose ( ) { super . dispose ( ) ; program . dispose ( ) ; } } public PerspectiveCamera cam ; public CameraInputController camController ; public ModelBatch modelBatch ; public Model model ; public Array < ModelInstance > instances = new Array < ModelInstance > ( ) ; public TestAttribute testAttribute1 , testAttribute2 ; @Override public void create ( ) { modelBatch = new ModelBatch ( new DefaultShaderProvider ( ) { @Override protected Shader createShader ( Renderable renderable ) { if ( renderable . material . has ( TestAttribute . ID ) ) return new TestShader ( renderable ) ; return super . createShader ( renderable ) ; } } ) ; cam = new PerspectiveCamera ( <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; cam . position . set ( <float> , <float> , <int> f ) ; cam . lookAt ( <int> , <int> , <int> ) ; cam . near = <float> ; cam . far = <int> f ; cam . update ( ) ; camController = new CameraInputController ( cam ) ; Gdx . input . setInputProcessor ( camController ) ; Material testMaterial1 = new Material ( <str> , new TestAttribute ( <float> ) ) ; Material redMaterial = new Material ( <str> , ColorAttribute . createDiffuse ( Color . RED ) ) ; Material testMaterial2 = new Material ( <str> , new TestAttribute ( <float> ) , ColorAttribute . createDiffuse ( Color . BLUE ) ) ; ModelBuilder builder = new ModelBuilder ( ) ; Node node ; builder . begin ( ) ; node = builder . node ( ) ; node . id = <str> ; node . translation . set ( - <int> , <float> , <float> ) ; builder . part ( <str> , GL20 . GL_TRIANGLES , Usage . Position , testMaterial1 ) . cone ( <int> , <int> , <int> , <int> ) ; node = builder . node ( ) ; node . id = <str> ; builder . part ( <str> , GL20 . GL_TRIANGLES , Usage . Position , redMaterial ) . sphere ( <int> , <int> , <int> , <int> , <int> ) ; node = builder . node ( ) ; node . id = <str> ; node . translation . set ( <int> , <float> , <float> ) ; builder . part ( <str> , GL20 . GL_TRIANGLES , Usage . Position , testMaterial2 ) . cone ( <int> , <int> , <int> , <int> ) ; model = builder . end ( ) ; ModelInstance modelInstance ; modelInstance = new ModelInstance ( model ) ; testAttribute1 = ( TestAttribute ) modelInstance . getMaterial ( <str> ) . get ( TestAttribute . ID ) ; testAttribute2 = ( TestAttribute ) modelInstance . getMaterial ( <str> ) . get ( TestAttribute . ID ) ; instances . add ( modelInstance ) ; } private float counter ; @Override public void render ( ) { counter = ( counter + Gdx . graphics . getDeltaTime ( ) ) % <float> ; testAttribute1 . value = Math . abs ( <float> - counter ) ; testAttribute2 . value = <float> - testAttribute1 . value ; camController . update ( ) ; Gdx . gl . glViewport ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; modelBatch . begin ( cam ) ; modelBatch . render ( instances ) ; modelBatch . end ( ) ; } @Override public void dispose ( ) { modelBatch . dispose ( ) ; model . dispose ( ) ; } } 
