package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . NANOSECONDS ; import static junit . framework . Assert . fail ; import com . google . common . testing . TearDown ; import com . google . common . testing . TearDownAccepter ; import java . util . concurrent . TimeUnit ; import java . util . logging . Logger ; final class InterruptionUtil { private static final Logger logger = Logger . getLogger ( InterruptionUtil . class . getName ( ) ) ; private static final class Interruptenator implements Runnable { private final long everyMillis ; private final Thread interruptee ; private volatile boolean shouldStop = false ; Interruptenator ( Thread interruptee , long everyMillis ) { this . everyMillis = everyMillis ; this . interruptee = interruptee ; } @Override public void run ( ) { while ( true ) { try { Thread . sleep ( everyMillis ) ; } catch ( InterruptedException e ) { } if ( shouldStop ) { break ; } interruptee . interrupt ( ) ; } } void stopInterrupting ( ) { shouldStop = true ; } } static void requestInterruptIn ( final long time , final TimeUnit unit ) { checkNotNull ( unit ) ; final Thread interruptee = Thread . currentThread ( ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { try { unit . sleep ( time ) ; } catch ( InterruptedException wontHappen ) { throw new AssertionError ( wontHappen ) ; } interruptee . interrupt ( ) ; } } ) . start ( ) ; } static void repeatedlyInterruptTestThread ( long interruptPeriodMillis , TearDownAccepter tearDownAccepter ) { final Interruptenator interruptingTask = new Interruptenator ( Thread . currentThread ( ) , interruptPeriodMillis ) ; final Thread interruptingThread = new Thread ( interruptingTask ) ; interruptingThread . start ( ) ; tearDownAccepter . addTearDown ( new TearDown ( ) { @Override public void tearDown ( ) throws Exception { interruptingTask . stopInterrupting ( ) ; interruptingThread . interrupt ( ) ; joinUninterruptibly ( interruptingThread , <int> , MILLISECONDS ) ; Thread . interrupted ( ) ; if ( interruptingThread . isAlive ( ) ) { logger . severe ( <str> ) ; fail ( ) ; } } } ) ; } private static void joinUninterruptibly ( Thread thread , long timeout , TimeUnit unit ) { boolean interrupted = false ; try { long remainingNanos = unit . toNanos ( timeout ) ; long end = System . nanoTime ( ) + remainingNanos ; while ( true ) { try { NANOSECONDS . timedJoin ( thread , remainingNanos ) ; return ; } catch ( InterruptedException e ) { interrupted = true ; remainingNanos = end - System . nanoTime ( ) ; } } } finally { if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } } 
