package org . elasticsearch . index . shard ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . FilterDirectoryReader ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . LeafReader ; import org . apache . lucene . search . IndexSearcher ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . lucene . index . ElasticsearchDirectoryReader ; import org . elasticsearch . index . engine . Engine ; import java . io . IOException ; public class IndexSearcherWrapper { protected DirectoryReader wrap ( DirectoryReader reader ) throws IOException { return reader ; } protected IndexSearcher wrap ( IndexSearcher searcher ) throws IOException { return searcher ; } public final Engine . Searcher wrap ( Engine . Searcher engineSearcher ) throws IOException { final ElasticsearchDirectoryReader elasticsearchDirectoryReader = ElasticsearchDirectoryReader . getElasticsearchDirectoryReader ( engineSearcher . getDirectoryReader ( ) ) ; if ( elasticsearchDirectoryReader = = null ) { throw new IllegalStateException ( <str> ) ; } NonClosingReaderWrapper nonClosingReaderWrapper = new NonClosingReaderWrapper ( engineSearcher . getDirectoryReader ( ) ) ; DirectoryReader reader = wrap ( nonClosingReaderWrapper ) ; if ( reader ! = nonClosingReaderWrapper ) { if ( reader . getCoreCacheKey ( ) ! = elasticsearchDirectoryReader . getCoreCacheKey ( ) ) { throw new IllegalStateException ( <str> + <str> ) ; } if ( ElasticsearchDirectoryReader . getElasticsearchDirectoryReader ( reader ) ! = elasticsearchDirectoryReader ) { throw new IllegalStateException ( <str> ) ; } } final IndexSearcher origIndexSearcher = engineSearcher . searcher ( ) ; final IndexSearcher innerIndexSearcher = new IndexSearcher ( reader ) ; innerIndexSearcher . setQueryCache ( origIndexSearcher . getQueryCache ( ) ) ; innerIndexSearcher . setQueryCachingPolicy ( origIndexSearcher . getQueryCachingPolicy ( ) ) ; innerIndexSearcher . setSimilarity ( origIndexSearcher . getSimilarity ( true ) ) ; final IndexSearcher indexSearcher = wrap ( innerIndexSearcher ) ; if ( reader = = nonClosingReaderWrapper & & indexSearcher = = innerIndexSearcher ) { return engineSearcher ; } else { return new Engine . Searcher ( engineSearcher . source ( ) , indexSearcher ) { @Override public void close ( ) throws ElasticsearchException { try { reader ( ) . close ( ) ; } catch ( IOException e ) { throw new ElasticsearchException ( <str> , e ) ; } finally { engineSearcher . close ( ) ; } } } ; } } private static final class NonClosingReaderWrapper extends FilterDirectoryReader { private NonClosingReaderWrapper ( DirectoryReader in ) throws IOException { super ( in , new SubReaderWrapper ( ) { @Override public LeafReader wrap ( LeafReader reader ) { return reader ; } } ) ; } @Override protected DirectoryReader doWrapDirectoryReader ( DirectoryReader in ) throws IOException { return new NonClosingReaderWrapper ( in ) ; } @Override protected void doClose ( ) throws IOException { } @Override public Object getCoreCacheKey ( ) { return in . getCoreCacheKey ( ) ; } } } 
