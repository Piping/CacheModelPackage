package org . elasticsearch . common ; import java . nio . charset . Charset ; import java . util . Locale ; public class Base64 { public final static int NO_OPTIONS = <int> ; public final static int ENCODE = <int> ; public final static int DECODE = <int> ; public final static int GZIP = <int> ; public final static int DONT_GUNZIP = <int> ; public final static int DO_BREAK_LINES = <int> ; public final static int URL_SAFE = <int> ; public final static int ORDERED = <int> ; private final static int MAX_LINE_LENGTH = <int> ; private final static byte EQUALS_SIGN = ( byte ) <str> ; private final static byte NEW_LINE = ( byte ) <str> ; public final static Charset PREFERRED_ENCODING = Charset . forName ( <str> ) ; private final static byte WHITE_SPACE_ENC = - <int> ; private final static byte EQUALS_SIGN_ENC = - <int> ; private final static byte [ ] _STANDARD_ALPHABET = { ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> } ; private final static byte [ ] _STANDARD_DECODABET = { - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> } ; private final static byte [ ] _URL_SAFE_ALPHABET = { ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> } ; private final static byte [ ] _URL_SAFE_DECODABET = { - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> } ; private final static byte [ ] _ORDERED_ALPHABET = { ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> , ( byte ) <str> } ; private final static byte [ ] _ORDERED_DECODABET = { - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , <int> , - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> } ; private final static byte [ ] getAlphabet ( int options ) { if ( ( options & URL_SAFE ) = = URL_SAFE ) { return _URL_SAFE_ALPHABET ; } else if ( ( options & ORDERED ) = = ORDERED ) { return _ORDERED_ALPHABET ; } else { return _STANDARD_ALPHABET ; } } private final static byte [ ] getDecodabet ( int options ) { if ( ( options & URL_SAFE ) = = URL_SAFE ) { return _URL_SAFE_DECODABET ; } else if ( ( options & ORDERED ) = = ORDERED ) { return _ORDERED_DECODABET ; } else { return _STANDARD_DECODABET ; } } private Base64 ( ) { } private static byte [ ] encode3to4 ( byte [ ] b4 , byte [ ] threeBytes , int numSigBytes , int options ) { encode3to4 ( threeBytes , <int> , numSigBytes , b4 , <int> , options ) ; return b4 ; } private static byte [ ] encode3to4 ( byte [ ] source , int srcOffset , int numSigBytes , byte [ ] destination , int destOffset , int options ) { byte [ ] ALPHABET = getAlphabet ( options ) ; int inBuff = ( numSigBytes > <int> ? ( ( source [ srcOffset ] < < <int> ) > > > <int> ) : <int> ) | ( numSigBytes > <int> ? ( ( source [ srcOffset + <int> ] < < <int> ) > > > <int> ) : <int> ) | ( numSigBytes > <int> ? ( ( source [ srcOffset + <int> ] < < <int> ) > > > <int> ) : <int> ) ; switch ( numSigBytes ) { case <int> : destination [ destOffset ] = ALPHABET [ ( inBuff > > > <int> ) ] ; destination [ destOffset + <int> ] = ALPHABET [ ( inBuff > > > <int> ) & <hex> ] ; destination [ destOffset + <int> ] = ALPHABET [ ( inBuff > > > <int> ) & <hex> ] ; destination [ destOffset + <int> ] = ALPHABET [ ( inBuff ) & <hex> ] ; return destination ; case <int> : destination [ destOffset ] = ALPHABET [ ( inBuff > > > <int> ) ] ; destination [ destOffset + <int> ] = ALPHABET [ ( inBuff > > > <int> ) & <hex> ] ; destination [ destOffset + <int> ] = ALPHABET [ ( inBuff > > > <int> ) & <hex> ] ; destination [ destOffset + <int> ] = EQUALS_SIGN ; return destination ; case <int> : destination [ destOffset ] = ALPHABET [ ( inBuff > > > <int> ) ] ; destination [ destOffset + <int> ] = ALPHABET [ ( inBuff > > > <int> ) & <hex> ] ; destination [ destOffset + <int> ] = EQUALS_SIGN ; destination [ destOffset + <int> ] = EQUALS_SIGN ; return destination ; default: return destination ; } } public static void encode ( java . nio . ByteBuffer raw , java . nio . ByteBuffer encoded ) { byte [ ] raw3 = new byte [ <int> ] ; byte [ ] enc4 = new byte [ <int> ] ; while ( raw . hasRemaining ( ) ) { int rem = Math . min ( <int> , raw . remaining ( ) ) ; raw . get ( raw3 , <int> , rem ) ; Base64 . encode3to4 ( enc4 , raw3 , rem , Base64 . NO_OPTIONS ) ; encoded . put ( enc4 ) ; } } public static void encode ( java . nio . ByteBuffer raw , java . nio . CharBuffer encoded ) { byte [ ] raw3 = new byte [ <int> ] ; byte [ ] enc4 = new byte [ <int> ] ; while ( raw . hasRemaining ( ) ) { int rem = Math . min ( <int> , raw . remaining ( ) ) ; raw . get ( raw3 , <int> , rem ) ; Base64 . encode3to4 ( enc4 , raw3 , rem , Base64 . NO_OPTIONS ) ; for ( int i = <int> ; i < <int> ; i + + ) { encoded . put ( ( char ) ( enc4 [ i ] & <hex> ) ) ; } } } public static String encodeBytes ( byte [ ] source ) { String encoded = null ; try { encoded = encodeBytes ( source , <int> , source . length , NO_OPTIONS ) ; } catch ( java . io . IOException ex ) { throw new IllegalStateException ( ex ) ; } assert encoded ! = null ; return encoded ; } public static String encodeBytes ( byte [ ] source , int options ) throws java . io . IOException { return encodeBytes ( source , <int> , source . length , options ) ; } public static String encodeBytes ( byte [ ] source , int off , int len ) { String encoded = null ; try { encoded = encodeBytes ( source , off , len , NO_OPTIONS ) ; } catch ( java . io . IOException ex ) { throw new IllegalStateException ( ex ) ; } assert encoded ! = null ; return encoded ; } public static String encodeBytes ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { byte [ ] encoded = encodeBytesToBytes ( source , off , len , options ) ; return new String ( encoded , PREFERRED_ENCODING ) ; } public static byte [ ] encodeBytesToBytes ( byte [ ] source ) { byte [ ] encoded = null ; try { encoded = encodeBytesToBytes ( source , <int> , source . length , Base64 . NO_OPTIONS ) ; } catch ( java . io . IOException ex ) { throw new IllegalStateException ( <str> , ex ) ; } return encoded ; } public static byte [ ] encodeBytesToBytes ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { if ( source = = null ) { throw new NullPointerException ( <str> ) ; } if ( off < <int> ) { throw new IllegalArgumentException ( <str> + off ) ; } if ( len < <int> ) { throw new IllegalArgumentException ( <str> + len ) ; } if ( off + len > source . length ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , off , len , source . length ) ) ; } if ( ( options & GZIP ) ! = <int> ) { java . io . ByteArrayOutputStream baos = null ; java . util . zip . GZIPOutputStream gzos = null ; Base64 . OutputStream b64os = null ; try { baos = new java . io . ByteArrayOutputStream ( ) ; b64os = new Base64 . OutputStream ( baos , ENCODE | options ) ; gzos = new java . util . zip . GZIPOutputStream ( b64os ) ; gzos . write ( source , off , len ) ; gzos . close ( ) ; } catch ( java . io . IOException e ) { throw e ; } finally { try { gzos . close ( ) ; } catch ( Exception e ) { } try { b64os . close ( ) ; } catch ( Exception e ) { } try { baos . close ( ) ; } catch ( Exception e ) { } } return baos . toByteArray ( ) ; } else { boolean breakLines = ( options & DO_BREAK_LINES ) ! = <int> ; int encLen = ( len / <int> ) * <int> + ( len % <int> > <int> ? <int> : <int> ) ; if ( breakLines ) { encLen + = encLen / MAX_LINE_LENGTH ; } byte [ ] outBuff = new byte [ encLen ] ; int d = <int> ; int e = <int> ; int len2 = len - <int> ; int lineLength = <int> ; for ( ; d < len2 ; d + = <int> , e + = <int> ) { encode3to4 ( source , d + off , <int> , outBuff , e , options ) ; lineLength + = <int> ; if ( breakLines & & lineLength > = MAX_LINE_LENGTH ) { outBuff [ e + <int> ] = NEW_LINE ; e + + ; lineLength = <int> ; } } if ( d < len ) { encode3to4 ( source , d + off , len - d , outBuff , e , options ) ; e + = <int> ; } if ( e < = outBuff . length - <int> ) { byte [ ] finalOut = new byte [ e ] ; System . arraycopy ( outBuff , <int> , finalOut , <int> , e ) ; return finalOut ; } else { return outBuff ; } } } private static int decode4to3 ( byte [ ] source , int srcOffset , byte [ ] destination , int destOffset , int options ) { if ( source = = null ) { throw new NullPointerException ( <str> ) ; } if ( destination = = null ) { throw new NullPointerException ( <str> ) ; } if ( srcOffset < <int> | | srcOffset + <int> > = source . length ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , source . length , srcOffset ) ) ; } if ( destOffset < <int> | | destOffset + <int> > = destination . length ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , destination . length , destOffset ) ) ; } byte [ ] DECODABET = getDecodabet ( options ) ; if ( source [ srcOffset + <int> ] = = EQUALS_SIGN ) { int outBuff = ( ( DECODABET [ source [ srcOffset ] ] & <hex> ) < < <int> ) | ( ( DECODABET [ source [ srcOffset + <int> ] ] & <hex> ) < < <int> ) ; destination [ destOffset ] = ( byte ) ( outBuff > > > <int> ) ; return <int> ; } else if ( source [ srcOffset + <int> ] = = EQUALS_SIGN ) { int outBuff = ( ( DECODABET [ source [ srcOffset ] ] & <hex> ) < < <int> ) | ( ( DECODABET [ source [ srcOffset + <int> ] ] & <hex> ) < < <int> ) | ( ( DECODABET [ source [ srcOffset + <int> ] ] & <hex> ) < < <int> ) ; destination [ destOffset ] = ( byte ) ( outBuff > > > <int> ) ; destination [ destOffset + <int> ] = ( byte ) ( outBuff > > > <int> ) ; return <int> ; } else { int outBuff = ( ( DECODABET [ source [ srcOffset ] ] & <hex> ) < < <int> ) | ( ( DECODABET [ source [ srcOffset + <int> ] ] & <hex> ) < < <int> ) | ( ( DECODABET [ source [ srcOffset + <int> ] ] & <hex> ) < < <int> ) | ( ( DECODABET [ source [ srcOffset + <int> ] ] & <hex> ) ) ; destination [ destOffset ] = ( byte ) ( outBuff > > <int> ) ; destination [ destOffset + <int> ] = ( byte ) ( outBuff > > <int> ) ; destination [ destOffset + <int> ] = ( byte ) ( outBuff ) ; return <int> ; } } public static byte [ ] decode ( byte [ ] source ) throws java . io . IOException { byte [ ] decoded = null ; decoded = decode ( source , <int> , source . length , Base64 . NO_OPTIONS ) ; return decoded ; } public static byte [ ] decode ( byte [ ] source , int off , int len , int options ) throws java . io . IOException { if ( source = = null ) { throw new NullPointerException ( <str> ) ; } if ( off < <int> | | off + len > source . length ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , source . length , off , len ) ) ; } if ( len = = <int> ) { return new byte [ <int> ] ; } else if ( len < <int> ) { throw new IllegalArgumentException ( <str> + len ) ; } byte [ ] DECODABET = getDecodabet ( options ) ; int len34 = len * <int> / <int> ; byte [ ] outBuff = new byte [ len34 ] ; int outBuffPosn = <int> ; byte [ ] b4 = new byte [ <int> ] ; int b4Posn = <int> ; int i = <int> ; byte sbiDecode = <int> ; for ( i = off ; i < off + len ; i + + ) { sbiDecode = DECODABET [ source [ i ] & <hex> ] ; if ( sbiDecode > = WHITE_SPACE_ENC ) { if ( sbiDecode > = EQUALS_SIGN_ENC ) { b4 [ b4Posn + + ] = source [ i ] ; if ( b4Posn > <int> ) { outBuffPosn + = decode4to3 ( b4 , <int> , outBuff , outBuffPosn , options ) ; b4Posn = <int> ; if ( source [ i ] = = EQUALS_SIGN ) { if ( i + <int> < len + off ) { throw new java . io . IOException ( String . format ( Locale . ROOT , <str> , i ) ) ; } break ; } } else { if ( source [ i ] = = EQUALS_SIGN & & len + off > i & & source [ i + <int> ] ! = EQUALS_SIGN ) { throw new java . io . IOException ( String . format ( Locale . ROOT , <str> , i ) ) ; } } } } else { throw new java . io . IOException ( String . format ( Locale . ROOT , <str> , ( ( int ) source [ i ] ) & <hex> , i ) ) ; } } byte [ ] out = new byte [ outBuffPosn ] ; System . arraycopy ( outBuff , <int> , out , <int> , outBuffPosn ) ; return out ; } public static byte [ ] decode ( String s ) throws java . io . IOException { return decode ( s , NO_OPTIONS ) ; } public static byte [ ] decode ( String s , int options ) throws java . io . IOException { if ( s = = null ) { throw new NullPointerException ( <str> ) ; } byte [ ] bytes = s . getBytes ( PREFERRED_ENCODING ) ; bytes = decode ( bytes , <int> , bytes . length , options ) ; boolean dontGunzip = ( options & DONT_GUNZIP ) ! = <int> ; if ( ( bytes ! = null ) & & ( bytes . length > = <int> ) & & ( ! dontGunzip ) ) { int head = ( ( int ) bytes [ <int> ] & <hex> ) | ( ( bytes [ <int> ] < < <int> ) & <hex> ) ; if ( java . util . zip . GZIPInputStream . GZIP_MAGIC = = head ) { java . io . ByteArrayInputStream bais = null ; java . util . zip . GZIPInputStream gzis = null ; java . io . ByteArrayOutputStream baos = null ; byte [ ] buffer = new byte [ <int> ] ; int length = <int> ; try { baos = new java . io . ByteArrayOutputStream ( ) ; bais = new java . io . ByteArrayInputStream ( bytes ) ; gzis = new java . util . zip . GZIPInputStream ( bais ) ; while ( ( length = gzis . read ( buffer ) ) > = <int> ) { baos . write ( buffer , <int> , length ) ; } bytes = baos . toByteArray ( ) ; } catch ( java . io . IOException e ) { } finally { try { baos . close ( ) ; } catch ( Exception e ) { } try { gzis . close ( ) ; } catch ( Exception e ) { } try { bais . close ( ) ; } catch ( Exception e ) { } } } } return bytes ; } public static class InputStream extends java . io . FilterInputStream { private boolean encode ; private int position ; private byte [ ] buffer ; private int bufferLength ; private int numSigBytes ; private int lineLength ; private boolean breakLines ; private int options ; private byte [ ] decodabet ; public InputStream ( java . io . InputStream in ) { this ( in , DECODE ) ; } public InputStream ( java . io . InputStream in , int options ) { super ( in ) ; this . options = options ; this . breakLines = ( options & DO_BREAK_LINES ) > <int> ; this . encode = ( options & ENCODE ) > <int> ; this . bufferLength = encode ? <int> : <int> ; this . buffer = new byte [ bufferLength ] ; this . position = - <int> ; this . lineLength = <int> ; this . decodabet = getDecodabet ( options ) ; } @Override public int read ( ) throws java . io . IOException { if ( position < <int> ) { if ( encode ) { byte [ ] b3 = new byte [ <int> ] ; int numBinaryBytes = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { int b = in . read ( ) ; if ( b > = <int> ) { b3 [ i ] = ( byte ) b ; numBinaryBytes + + ; } else { break ; } } if ( numBinaryBytes > <int> ) { encode3to4 ( b3 , <int> , numBinaryBytes , buffer , <int> , options ) ; position = <int> ; numSigBytes = <int> ; } else { return - <int> ; } } else { byte [ ] b4 = new byte [ <int> ] ; int i = <int> ; for ( i = <int> ; i < <int> ; i + + ) { int b = <int> ; do { b = in . read ( ) ; } while ( b > = <int> & & decodabet [ b & <hex> ] < = WHITE_SPACE_ENC ) ; if ( b < <int> ) { break ; } b4 [ i ] = ( byte ) b ; } if ( i = = <int> ) { numSigBytes = decode4to3 ( b4 , <int> , buffer , <int> , options ) ; position = <int> ; } else if ( i = = <int> ) { return - <int> ; } else { throw new java . io . IOException ( <str> ) ; } } } if ( position > = <int> ) { if ( position > = numSigBytes ) { return - <int> ; } if ( encode & & breakLines & & lineLength > = MAX_LINE_LENGTH ) { lineLength = <int> ; return <str> ; } else { lineLength + + ; int b = buffer [ position + + ] ; if ( position > = bufferLength ) { position = - <int> ; } return b & <hex> ; } } else { throw new java . io . IOException ( <str> ) ; } } @Override public int read ( byte [ ] dest , int off , int len ) throws java . io . IOException { int i ; int b ; for ( i = <int> ; i < len ; i + + ) { b = read ( ) ; if ( b > = <int> ) { dest [ off + i ] = ( byte ) b ; } else if ( i = = <int> ) { return - <int> ; } else { break ; } } return i ; } } public static class OutputStream extends java . io . FilterOutputStream { private boolean encode ; private int position ; private byte [ ] buffer ; private int bufferLength ; private int lineLength ; private boolean breakLines ; private byte [ ] b4 ; private boolean suspendEncoding ; private int options ; private byte [ ] decodabet ; public OutputStream ( java . io . OutputStream out ) { this ( out , ENCODE ) ; } public OutputStream ( java . io . OutputStream out , int options ) { super ( out ) ; this . breakLines = ( options & DO_BREAK_LINES ) ! = <int> ; this . encode = ( options & ENCODE ) ! = <int> ; this . bufferLength = encode ? <int> : <int> ; this . buffer = new byte [ bufferLength ] ; this . position = <int> ; this . lineLength = <int> ; this . suspendEncoding = false ; this . b4 = new byte [ <int> ] ; this . options = options ; this . decodabet = getDecodabet ( options ) ; } @Override public void write ( int theByte ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theByte ) ; return ; } if ( encode ) { buffer [ position + + ] = ( byte ) theByte ; if ( position > = bufferLength ) { this . out . write ( encode3to4 ( b4 , buffer , bufferLength , options ) ) ; lineLength + = <int> ; if ( breakLines & & lineLength > = MAX_LINE_LENGTH ) { this . out . write ( NEW_LINE ) ; lineLength = <int> ; } position = <int> ; } } else { if ( decodabet [ theByte & <hex> ] > WHITE_SPACE_ENC ) { buffer [ position + + ] = ( byte ) theByte ; if ( position > = bufferLength ) { int len = Base64 . decode4to3 ( buffer , <int> , b4 , <int> , options ) ; out . write ( b4 , <int> , len ) ; position = <int> ; } } else if ( decodabet [ theByte & <hex> ] ! = WHITE_SPACE_ENC ) { throw new java . io . IOException ( <str> ) ; } } } @Override public void write ( byte [ ] theBytes , int off , int len ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( theBytes , off , len ) ; return ; } for ( int i = <int> ; i < len ; i + + ) { write ( theBytes [ off + i ] ) ; } } public void flushBase64 ( ) throws java . io . IOException { if ( position > <int> ) { if ( encode ) { out . write ( encode3to4 ( b4 , buffer , position , options ) ) ; position = <int> ; } else { throw new java . io . IOException ( <str> ) ; } } } @Override public void close ( ) throws java . io . IOException { flushBase64 ( ) ; super . close ( ) ; buffer = null ; out = null ; } public void suspendEncoding ( ) throws java . io . IOException { flushBase64 ( ) ; this . suspendEncoding = true ; } public void resumeEncoding ( ) { this . suspendEncoding = false ; } } } 
