package org . elasticsearch . bootstrap ; import org . elasticsearch . Version ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . nio . file . FileVisitResult ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . SimpleFileVisitor ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . Arrays ; import java . util . Enumeration ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . Manifest ; public class JarHell { private JarHell ( ) { } @SuppressForbidden ( reason = <str> ) public static void main ( String args [ ] ) throws Exception { System . out . println ( <str> ) ; checkJarHell ( ) ; System . out . println ( <str> ) ; } public static void checkJarHell ( ) throws Exception { ClassLoader loader = JarHell . class . getClassLoader ( ) ; ESLogger logger = Loggers . getLogger ( JarHell . class ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , System . getProperty ( <str> ) ) ; logger . debug ( <str> , System . getProperty ( <str> ) ) ; if ( loader instanceof URLClassLoader ) { logger . debug ( <str> , Arrays . toString ( ( ( URLClassLoader ) loader ) . getURLs ( ) ) ) ; } } checkJarHell ( parseClassPath ( ) ) ; } public static URL [ ] parseClassPath ( ) { return parseClassPath ( System . getProperty ( <str> ) ) ; } @SuppressForbidden ( reason = <str> ) static URL [ ] parseClassPath ( String classPath ) { String pathSeparator = System . getProperty ( <str> ) ; String fileSeparator = System . getProperty ( <str> ) ; String elements [ ] = classPath . split ( pathSeparator ) ; URL urlElements [ ] = new URL [ elements . length ] ; for ( int i = <int> ; i < elements . length ; i + + ) { String element = elements [ i ] ; if ( element . isEmpty ( ) ) { throw new IllegalStateException ( <str> + classPath + <str> ) ; } if ( element . startsWith ( <str> ) & & <str> . equals ( fileSeparator ) ) { element = element . replace ( <str> , <str> ) ; if ( element . length ( ) > = <int> & & element . charAt ( <int> ) = = <str> ) { element = element . substring ( <int> ) ; } } try { urlElements [ i ] = PathUtils . get ( element ) . toUri ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( e ) ; } } return urlElements ; } @SuppressForbidden ( reason = <str> ) public static void checkJarHell ( URL urls [ ] ) throws Exception { ESLogger logger = Loggers . getLogger ( JarHell . class ) ; String javaHome = System . getProperty ( <str> ) ; logger . debug ( <str> , javaHome ) ; final Map < String , Path > clazzes = new HashMap < > ( <int> ) ; Set < Path > seenJars = new HashSet < > ( ) ; for ( final URL url : urls ) { final Path path = PathUtils . get ( url . toURI ( ) ) ; if ( path . startsWith ( javaHome ) ) { logger . debug ( <str> , path ) ; continue ; } if ( path . toString ( ) . endsWith ( <str> ) ) { if ( ! seenJars . add ( path ) ) { logger . debug ( <str> , path ) ; continue ; } logger . debug ( <str> , path ) ; try ( JarFile file = new JarFile ( path . toString ( ) ) ) { Manifest manifest = file . getManifest ( ) ; if ( manifest ! = null ) { checkManifest ( manifest , path ) ; } Enumeration < JarEntry > elements = file . entries ( ) ; while ( elements . hasMoreElements ( ) ) { String entry = elements . nextElement ( ) . getName ( ) ; if ( entry . endsWith ( <str> ) ) { entry = entry . replace ( <str> , <str> ) . substring ( <int> , entry . length ( ) - <int> ) ; checkClass ( clazzes , entry , path ) ; } } } } else { logger . debug ( <str> , path ) ; final Path root = PathUtils . get ( url . toURI ( ) ) ; final String sep = root . getFileSystem ( ) . getSeparator ( ) ; Files . walkFileTree ( root , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { String entry = root . relativize ( file ) . toString ( ) ; if ( entry . endsWith ( <str> ) ) { entry = entry . replace ( sep , <str> ) . substring ( <int> , entry . length ( ) - <int> ) ; checkClass ( clazzes , entry , path ) ; } return super . visitFile ( file , attrs ) ; } } ) ; } } } static void checkManifest ( Manifest manifest , Path jar ) { String targetVersion = manifest . getMainAttributes ( ) . getValue ( <str> ) ; if ( targetVersion ! = null ) { checkVersionFormat ( targetVersion ) ; checkJavaVersion ( jar . toString ( ) , targetVersion ) ; } String systemESVersion = Version . CURRENT . toString ( ) ; String targetESVersion = manifest . getMainAttributes ( ) . getValue ( <str> ) ; if ( targetESVersion ! = null & & targetESVersion . equals ( systemESVersion ) = = false ) { throw new IllegalStateException ( jar + <str> + targetESVersion + <str> + systemESVersion ) ; } } public static void checkVersionFormat ( String targetVersion ) { if ( ! JavaVersion . isValid ( targetVersion ) ) { throw new IllegalStateException ( String . format ( Locale . ROOT , <str> , targetVersion ) ) ; } } public static void checkJavaVersion ( String resource , String targetVersion ) { JavaVersion version = JavaVersion . parse ( targetVersion ) ; if ( JavaVersion . current ( ) . compareTo ( version ) < <int> ) { throw new IllegalStateException ( String . format ( Locale . ROOT , <str> , resource , targetVersion , JavaVersion . current ( ) . toString ( ) ) ) ; } } static void checkClass ( Map < String , Path > clazzes , String clazz , Path jarpath ) { Path previous = clazzes . put ( clazz , jarpath ) ; if ( previous ! = null ) { if ( previous . equals ( jarpath ) ) { if ( clazz . startsWith ( <str> ) ) { return ; } throw new IllegalStateException ( <str> + System . lineSeparator ( ) + <str> + clazz + System . lineSeparator ( ) + <str> + jarpath + <str> ) ; } else { if ( clazz . startsWith ( <str> ) ) { return ; } if ( clazz . equals ( <str> ) ) { return ; } throw new IllegalStateException ( <str> + System . lineSeparator ( ) + <str> + clazz + System . lineSeparator ( ) + <str> + previous + System . lineSeparator ( ) + <str> + jarpath ) ; } } } } 
