package io . netty . handler . codec . http2 ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . compression . ZlibCodecFactory ; import io . netty . handler . codec . compression . ZlibWrapper ; import static io . netty . handler . codec . http . HttpHeaderNames . CONTENT_ENCODING ; import static io . netty . handler . codec . http . HttpHeaderNames . CONTENT_LENGTH ; import static io . netty . handler . codec . http . HttpHeaderValues . DEFLATE ; import static io . netty . handler . codec . http . HttpHeaderValues . GZIP ; import static io . netty . handler . codec . http . HttpHeaderValues . IDENTITY ; import static io . netty . handler . codec . http . HttpHeaderValues . X_DEFLATE ; import static io . netty . handler . codec . http . HttpHeaderValues . X_GZIP ; import static io . netty . handler . codec . http2 . Http2Error . INTERNAL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . streamError ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public class DelegatingDecompressorFrameListener extends Http2FrameListenerDecorator { private final Http2Connection connection ; private final boolean strict ; private boolean flowControllerInitialized ; final Http2Connection . PropertyKey propertyKey ; public DelegatingDecompressorFrameListener ( Http2Connection connection , Http2FrameListener listener ) { this ( connection , listener , true ) ; } public DelegatingDecompressorFrameListener ( Http2Connection connection , Http2FrameListener listener , boolean strict ) { super ( listener ) ; this . connection = connection ; this . strict = strict ; propertyKey = connection . newKey ( ) ; connection . addListener ( new Http2ConnectionAdapter ( ) { @Override public void onStreamRemoved ( Http2Stream stream ) { final Http2Decompressor decompressor = decompressor ( stream ) ; if ( decompressor ! = null ) { cleanup ( stream , decompressor ) ; } } } ) ; } @Override public int onDataRead ( ChannelHandlerContext ctx , int streamId , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { final Http2Stream stream = connection . stream ( streamId ) ; final Http2Decompressor decompressor = decompressor ( stream ) ; if ( decompressor = = null ) { return listener . onDataRead ( ctx , streamId , data , padding , endOfStream ) ; } final EmbeddedChannel channel = decompressor . decompressor ( ) ; final int compressedBytes = data . readableBytes ( ) + padding ; int processedBytes = <int> ; decompressor . incrementCompressedBytes ( compressedBytes ) ; try { channel . writeInbound ( data . retain ( ) ) ; ByteBuf buf = nextReadableBuf ( channel ) ; if ( buf = = null & & endOfStream & & channel . finish ( ) ) { buf = nextReadableBuf ( channel ) ; } if ( buf = = null ) { if ( endOfStream ) { listener . onDataRead ( ctx , streamId , Unpooled . EMPTY_BUFFER , padding , true ) ; } decompressor . incrementDecompressedByes ( compressedBytes ) ; processedBytes = compressedBytes ; } else { try { decompressor . incrementDecompressedByes ( padding ) ; for ( ; ; ) { ByteBuf nextBuf = nextReadableBuf ( channel ) ; boolean decompressedEndOfStream = nextBuf = = null & & endOfStream ; if ( decompressedEndOfStream & & channel . finish ( ) ) { nextBuf = nextReadableBuf ( channel ) ; decompressedEndOfStream = nextBuf = = null ; } decompressor . incrementDecompressedByes ( buf . readableBytes ( ) ) ; processedBytes + = listener . onDataRead ( ctx , streamId , buf , padding , decompressedEndOfStream ) ; if ( nextBuf = = null ) { break ; } padding = <int> ; buf . release ( ) ; buf = nextBuf ; } } finally { buf . release ( ) ; } } decompressor . incrementProcessedBytes ( processedBytes ) ; return processedBytes ; } catch ( Http2Exception e ) { decompressor . incrementProcessedBytes ( compressedBytes ) ; throw e ; } catch ( Throwable t ) { decompressor . incrementProcessedBytes ( compressedBytes ) ; throw streamError ( stream . id ( ) , INTERNAL_ERROR , t , <str> , stream . id ( ) ) ; } } @Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int padding , boolean endStream ) throws Http2Exception { initDecompressor ( streamId , headers , endStream ) ; listener . onHeadersRead ( ctx , streamId , headers , padding , endStream ) ; } @Override public void onHeadersRead ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , int streamDependency , short weight , boolean exclusive , int padding , boolean endStream ) throws Http2Exception { initDecompressor ( streamId , headers , endStream ) ; listener . onHeadersRead ( ctx , streamId , headers , streamDependency , weight , exclusive , padding , endStream ) ; } protected EmbeddedChannel newContentDecompressor ( CharSequence contentEncoding ) throws Http2Exception { if ( GZIP . contentEqualsIgnoreCase ( contentEncoding ) | | X_GZIP . contentEqualsIgnoreCase ( contentEncoding ) ) { return new EmbeddedChannel ( ZlibCodecFactory . newZlibDecoder ( ZlibWrapper . GZIP ) ) ; } if ( DEFLATE . contentEqualsIgnoreCase ( contentEncoding ) | | X_DEFLATE . contentEqualsIgnoreCase ( contentEncoding ) ) { final ZlibWrapper wrapper = strict ? ZlibWrapper . ZLIB : ZlibWrapper . ZLIB_OR_NONE ; return new EmbeddedChannel ( ZlibCodecFactory . newZlibDecoder ( wrapper ) ) ; } return null ; } protected CharSequence getTargetContentEncoding ( @SuppressWarnings ( <str> ) CharSequence contentEncoding ) throws Http2Exception { return IDENTITY ; } private void initDecompressor ( int streamId , Http2Headers headers , boolean endOfStream ) throws Http2Exception { final Http2Stream stream = connection . stream ( streamId ) ; if ( stream = = null ) { return ; } Http2Decompressor decompressor = decompressor ( stream ) ; if ( decompressor = = null & & ! endOfStream ) { CharSequence contentEncoding = headers . get ( CONTENT_ENCODING ) ; if ( contentEncoding = = null ) { contentEncoding = IDENTITY ; } final EmbeddedChannel channel = newContentDecompressor ( contentEncoding ) ; if ( channel ! = null ) { decompressor = new Http2Decompressor ( channel ) ; stream . setProperty ( propertyKey , decompressor ) ; CharSequence targetContentEncoding = getTargetContentEncoding ( contentEncoding ) ; if ( IDENTITY . contentEqualsIgnoreCase ( targetContentEncoding ) ) { headers . remove ( CONTENT_ENCODING ) ; } else { headers . set ( CONTENT_ENCODING , targetContentEncoding ) ; } } } if ( decompressor ! = null ) { headers . remove ( CONTENT_LENGTH ) ; if ( ! flowControllerInitialized ) { flowControllerInitialized = true ; connection . local ( ) . flowController ( new ConsumedBytesConverter ( connection . local ( ) . flowController ( ) ) ) ; } } } Http2Decompressor decompressor ( Http2Stream stream ) { return stream = = null ? null : ( Http2Decompressor ) stream . getProperty ( propertyKey ) ; } private void cleanup ( Http2Stream stream , Http2Decompressor decompressor ) { final EmbeddedChannel channel = decompressor . decompressor ( ) ; if ( channel . finish ( ) ) { for ( ; ; ) { final ByteBuf buf = channel . readInbound ( ) ; if ( buf = = null ) { break ; } buf . release ( ) ; } } decompressor = stream . removeProperty ( propertyKey ) ; } private static ByteBuf nextReadableBuf ( EmbeddedChannel decompressor ) { for ( ; ; ) { final ByteBuf buf = decompressor . readInbound ( ) ; if ( buf = = null ) { return null ; } if ( ! buf . isReadable ( ) ) { buf . release ( ) ; continue ; } return buf ; } } private final class ConsumedBytesConverter implements Http2LocalFlowController { private final Http2LocalFlowController flowController ; ConsumedBytesConverter ( Http2LocalFlowController flowController ) { this . flowController = checkNotNull ( flowController , <str> ) ; } @Override public Http2LocalFlowController frameWriter ( Http2FrameWriter frameWriter ) { return flowController . frameWriter ( frameWriter ) ; } @Override public void channelHandlerContext ( ChannelHandlerContext ctx ) throws Http2Exception { flowController . channelHandlerContext ( ctx ) ; } @Override public void initialWindowSize ( int newWindowSize ) throws Http2Exception { flowController . initialWindowSize ( newWindowSize ) ; } @Override public int initialWindowSize ( ) { return flowController . initialWindowSize ( ) ; } @Override public int windowSize ( Http2Stream stream ) { return flowController . windowSize ( stream ) ; } @Override public int initialWindowSize ( Http2Stream stream ) { return flowController . initialWindowSize ( stream ) ; } @Override public void incrementWindowSize ( Http2Stream stream , int delta ) throws Http2Exception { flowController . incrementWindowSize ( stream , delta ) ; } @Override public void receiveFlowControlledFrame ( Http2Stream stream , ByteBuf data , int padding , boolean endOfStream ) throws Http2Exception { flowController . receiveFlowControlledFrame ( stream , data , padding , endOfStream ) ; } @Override public boolean consumeBytes ( Http2Stream stream , int numBytes ) throws Http2Exception { Http2Decompressor decompressor = decompressor ( stream ) ; Http2Decompressor copy = null ; try { if ( decompressor ! = null ) { copy = new Http2Decompressor ( decompressor ) ; numBytes = decompressor . consumeProcessedBytes ( numBytes ) ; } return flowController . consumeBytes ( stream , numBytes ) ; } catch ( Http2Exception e ) { if ( copy ! = null ) { stream . setProperty ( propertyKey , copy ) ; } throw e ; } catch ( Throwable t ) { if ( copy ! = null ) { stream . setProperty ( propertyKey , copy ) ; } throw new Http2Exception ( INTERNAL_ERROR , <str> , t ) ; } } @Override public int unconsumedBytes ( Http2Stream stream ) { return flowController . unconsumedBytes ( stream ) ; } } private static final class Http2Decompressor { private final EmbeddedChannel decompressor ; private int processed ; private int compressed ; private int decompressed ; Http2Decompressor ( Http2Decompressor rhs ) { this ( rhs . decompressor ) ; processed = rhs . processed ; compressed = rhs . compressed ; decompressed = rhs . decompressed ; } Http2Decompressor ( EmbeddedChannel decompressor ) { this . decompressor = decompressor ; } EmbeddedChannel decompressor ( ) { return decompressor ; } void incrementProcessedBytes ( int delta ) { if ( processed + delta < <int> ) { throw new IllegalArgumentException ( <str> ) ; } processed + = delta ; } void incrementCompressedBytes ( int delta ) { if ( compressed + delta < <int> ) { throw new IllegalArgumentException ( <str> ) ; } compressed + = delta ; } void incrementDecompressedByes ( int delta ) { if ( decompressed + delta < <int> ) { throw new IllegalArgumentException ( <str> ) ; } decompressed + = delta ; } int consumeProcessedBytes ( int processedBytes ) { incrementProcessedBytes ( - processedBytes ) ; double consumedRatio = processedBytes / ( double ) decompressed ; int consumedCompressed = Math . min ( compressed , ( int ) Math . ceil ( compressed * consumedRatio ) ) ; incrementDecompressedByes ( - Math . min ( decompressed , ( int ) Math . ceil ( decompressed * consumedRatio ) ) ) ; incrementCompressedBytes ( - consumedCompressed ) ; return consumedCompressed ; } } } 
