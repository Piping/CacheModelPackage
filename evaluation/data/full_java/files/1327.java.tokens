package org . apache . cassandra ; import java . io . File ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . util . * ; import java . util . concurrent . atomic . AtomicInteger ; import com . google . common . collect . ImmutableSet ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . dht . Murmur3Partitioner ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . IndexSummary ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; import org . apache . cassandra . io . sstable . metadata . MetadataType ; import org . apache . cassandra . io . sstable . metadata . StatsMetadata ; import org . apache . cassandra . io . util . BufferedSegmentedFile ; import org . apache . cassandra . io . util . ChannelProxy ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . io . util . Memory ; import org . apache . cassandra . io . util . RandomAccessReader ; import org . apache . cassandra . io . util . SegmentedFile ; import org . apache . cassandra . schema . CachingParams ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . AlwaysPresentFilter ; import org . apache . cassandra . utils . ByteBufferUtil ; public class MockSchema { static { Memory offsets = Memory . allocate ( <int> ) ; offsets . setInt ( <int> , <int> ) ; indexSummary = new IndexSummary ( Murmur3Partitioner . instance , offsets , <int> , Memory . allocate ( <int> ) , <int> , <int> , <int> , <int> ) ; } private static final AtomicInteger id = new AtomicInteger ( ) ; public static final Keyspace ks = Keyspace . mockKS ( KeyspaceMetadata . create ( <str> , KeyspaceParams . simpleTransient ( <int> ) ) ) ; public static final IndexSummary indexSummary ; private static final SegmentedFile segmentedFile = new BufferedSegmentedFile ( new ChannelProxy ( temp ( <str> ) ) , RandomAccessReader . DEFAULT_BUFFER_SIZE , <int> ) ; public static Memtable memtable ( ColumnFamilyStore cfs ) { return new Memtable ( cfs . metadata ) ; } public static SSTableReader sstable ( int generation , ColumnFamilyStore cfs ) { return sstable ( generation , false , cfs ) ; } public static SSTableReader sstable ( int generation , boolean keepRef , ColumnFamilyStore cfs ) { return sstable ( generation , <int> , keepRef , cfs ) ; } public static SSTableReader sstable ( int generation , int size , ColumnFamilyStore cfs ) { return sstable ( generation , size , false , cfs ) ; } public static SSTableReader sstable ( int generation , int size , boolean keepRef , ColumnFamilyStore cfs ) { Descriptor descriptor = new Descriptor ( cfs . getDirectories ( ) . getDirectoryForNewSSTables ( ) , cfs . keyspace . getName ( ) , cfs . getColumnFamilyName ( ) , generation ) ; Set < Component > components = ImmutableSet . of ( Component . DATA , Component . PRIMARY_INDEX , Component . FILTER , Component . TOC ) ; for ( Component component : components ) { File file = new File ( descriptor . filenameFor ( component ) ) ; try { file . createNewFile ( ) ; } catch ( IOException e ) { } } if ( size > <int> ) { try { File file = new File ( descriptor . filenameFor ( Component . DATA ) ) ; try ( RandomAccessFile raf = new RandomAccessFile ( file , <str> ) ) { raf . setLength ( size ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } SerializationHeader header = SerializationHeader . make ( cfs . metadata , Collections . emptyList ( ) ) ; StatsMetadata metadata = ( StatsMetadata ) new MetadataCollector ( cfs . metadata . comparator ) . finalizeMetadata ( cfs . metadata . partitioner . getClass ( ) . getCanonicalName ( ) , <float> , - <int> , header ) . get ( MetadataType . STATS ) ; SSTableReader reader = SSTableReader . internalOpen ( descriptor , components , cfs . metadata , segmentedFile . sharedCopy ( ) , segmentedFile . sharedCopy ( ) , indexSummary . sharedCopy ( ) , new AlwaysPresentFilter ( ) , <int> , metadata , SSTableReader . OpenReason . NORMAL , header ) ; reader . first = reader . last = readerBounds ( generation ) ; if ( ! keepRef ) reader . selfRef ( ) . release ( ) ; return reader ; } public static ColumnFamilyStore newCFS ( ) { return newCFS ( ks . getName ( ) ) ; } public static ColumnFamilyStore newCFS ( String ksname ) { String cfname = <str> + ( id . incrementAndGet ( ) ) ; CFMetaData metadata = newCFMetaData ( ksname , cfname ) ; return new ColumnFamilyStore ( ks , cfname , <int> , metadata , new Directories ( metadata ) , false , false ) ; } public static CFMetaData newCFMetaData ( String ksname , String cfname ) { CFMetaData metadata = CFMetaData . Builder . create ( ksname , cfname ) . addPartitionKey ( <str> , UTF8Type . instance ) . addClusteringColumn ( <str> , UTF8Type . instance ) . addRegularColumn ( <str> , UTF8Type . instance ) . withPartitioner ( Murmur3Partitioner . instance ) . build ( ) ; metadata . caching ( CachingParams . CACHE_NOTHING ) ; return metadata ; } public static BufferDecoratedKey readerBounds ( int generation ) { return new BufferDecoratedKey ( new Murmur3Partitioner . LongToken ( generation ) , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; } private static File temp ( String id ) { try { File file = File . createTempFile ( id , <str> ) ; file . deleteOnExit ( ) ; return file ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } public static void cleanup ( ) { for ( String dirName : DatabaseDescriptor . getAllDataFileLocations ( ) ) { File dir = new File ( dirName ) ; if ( ! dir . exists ( ) ) continue ; String [ ] children = dir . list ( ) ; for ( String child : children ) FileUtils . deleteRecursive ( new File ( dir , child ) ) ; } } } 
