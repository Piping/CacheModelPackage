package org . elasticsearch . search . aggregations . bucket ; import com . carrotsearch . hppc . ObjectIntHashMap ; import com . carrotsearch . hppc . ObjectIntMap ; import com . carrotsearch . hppc . cursors . ObjectIntCursor ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . Version ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . GeoBoundingBoxQueryBuilder ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . search . aggregations . bucket . filter . Filter ; import org . elasticsearch . search . aggregations . bucket . geogrid . GeoHashGrid ; import org . elasticsearch . search . aggregations . bucket . geogrid . GeoHashGrid . Bucket ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . VersionUtils ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Random ; import java . util . Set ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . geohashGrid ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; @ESIntegTestCase.SuiteScopeTestCase public class GeoHashGridIT extends ESIntegTestCase { private Version version = VersionUtils . randomVersionBetween ( random ( ) , Version . V_1_0_0 , Version . CURRENT ) ; static ObjectIntMap < String > expectedDocCountsForGeoHash = null ; static ObjectIntMap < String > multiValuedExpectedDocCountsForGeoHash = null ; static int numDocs = <int> ; static String smallestGeoHash = null ; private static IndexRequestBuilder indexCity ( String index , String name , List < String > latLon ) throws Exception { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . field ( <str> , name ) ; if ( latLon ! = null ) { source = source . field ( <str> , latLon ) ; } source = source . endObject ( ) ; return client ( ) . prepareIndex ( index , <str> ) . setSource ( source ) ; } private static IndexRequestBuilder indexCity ( String index , String name , String latLon ) throws Exception { return indexCity ( index , name , Arrays . < String > asList ( latLon ) ) ; } @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; Settings settings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; List < IndexRequestBuilder > cities = new ArrayList < > ( ) ; Random random = getRandom ( ) ; expectedDocCountsForGeoHash = new ObjectIntHashMap < > ( numDocs * <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { double lat = ( <int> d * random . nextDouble ( ) ) - <int> d ; double lng = ( <int> d * random . nextDouble ( ) ) - <int> d ; String randomGeoHash = GeoHashUtils . stringEncode ( lng , lat , GeoHashUtils . PRECISION ) ; cities . add ( indexCity ( <str> , randomGeoHash , lat + <str> + lng ) ) ; expectedDocCountsForGeoHash . put ( randomGeoHash , expectedDocCountsForGeoHash . getOrDefault ( randomGeoHash , <int> ) + <int> ) ; for ( int precision = GeoHashUtils . PRECISION - <int> ; precision > <int> ; precision - - ) { String hash = GeoHashUtils . stringEncode ( lng , lat , precision ) ; if ( ( smallestGeoHash = = null ) | | ( hash . length ( ) < smallestGeoHash . length ( ) ) ) { smallestGeoHash = hash ; } expectedDocCountsForGeoHash . put ( hash , expectedDocCountsForGeoHash . getOrDefault ( hash , <int> ) + <int> ) ; } } indexRandom ( true , cities ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; cities = new ArrayList < > ( ) ; multiValuedExpectedDocCountsForGeoHash = new ObjectIntHashMap < > ( numDocs * <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { final int numPoints = random . nextInt ( <int> ) ; List < String > points = new ArrayList < > ( ) ; Set < String > geoHashes = new HashSet < > ( ) ; for ( int j = <int> ; j < numPoints ; + + j ) { double lat = ( <int> d * random . nextDouble ( ) ) - <int> d ; double lng = ( <int> d * random . nextDouble ( ) ) - <int> d ; points . add ( lat + <str> + lng ) ; for ( int precision = GeoHashUtils . PRECISION ; precision > <int> ; precision - - ) { final String geoHash = GeoHashUtils . stringEncode ( lng , lat , precision ) ; geoHashes . add ( geoHash ) ; } } cities . add ( indexCity ( <str> , Integer . toString ( i ) , points ) ) ; for ( String hash : geoHashes ) { multiValuedExpectedDocCountsForGeoHash . put ( hash , multiValuedExpectedDocCountsForGeoHash . getOrDefault ( hash , <int> ) + <int> ) ; } } indexRandom ( true , cities ) ; ensureSearchable ( ) ; } public void testSimple ( ) throws Exception { for ( int precision = <int> ; precision < = GeoHashUtils . PRECISION ; precision + + ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( geohashGrid ( <str> ) . field ( <str> ) . precision ( precision ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; GeoHashGrid geoGrid = response . getAggregations ( ) . get ( <str> ) ; List < Bucket > buckets = geoGrid . getBuckets ( ) ; Object [ ] propertiesKeys = ( Object [ ] ) geoGrid . getProperty ( <str> ) ; Object [ ] propertiesDocCounts = ( Object [ ] ) geoGrid . getProperty ( <str> ) ; for ( int i = <int> ; i < buckets . size ( ) ; i + + ) { GeoHashGrid . Bucket cell = buckets . get ( i ) ; String geohash = cell . getKeyAsString ( ) ; long bucketCount = cell . getDocCount ( ) ; int expectedBucketCount = expectedDocCountsForGeoHash . get ( geohash ) ; assertNotSame ( bucketCount , <int> ) ; assertEquals ( <str> + geohash + <str> , expectedBucketCount , bucketCount ) ; GeoPoint geoPoint = ( GeoPoint ) propertiesKeys [ i ] ; assertThat ( GeoHashUtils . stringEncode ( geoPoint . lon ( ) , geoPoint . lat ( ) , precision ) , equalTo ( geohash ) ) ; assertThat ( ( long ) propertiesDocCounts [ i ] , equalTo ( bucketCount ) ) ; } } } public void testMultivalued ( ) throws Exception { for ( int precision = <int> ; precision < = GeoHashUtils . PRECISION ; precision + + ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( geohashGrid ( <str> ) . field ( <str> ) . precision ( precision ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; GeoHashGrid geoGrid = response . getAggregations ( ) . get ( <str> ) ; for ( GeoHashGrid . Bucket cell : geoGrid . getBuckets ( ) ) { String geohash = cell . getKeyAsString ( ) ; long bucketCount = cell . getDocCount ( ) ; int expectedBucketCount = multiValuedExpectedDocCountsForGeoHash . get ( geohash ) ; assertNotSame ( bucketCount , <int> ) ; assertEquals ( <str> + geohash + <str> , expectedBucketCount , bucketCount ) ; } } } public void testFiltered ( ) throws Exception { GeoBoundingBoxQueryBuilder bbox = new GeoBoundingBoxQueryBuilder ( <str> ) ; bbox . setCorners ( smallestGeoHash , smallestGeoHash ) . queryName ( <str> ) ; for ( int precision = <int> ; precision < = GeoHashUtils . PRECISION ; precision + + ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( AggregationBuilders . filter ( <str> ) . filter ( bbox ) . subAggregation ( geohashGrid ( <str> ) . field ( <str> ) . precision ( precision ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Filter filter = response . getAggregations ( ) . get ( <str> ) ; GeoHashGrid geoGrid = filter . getAggregations ( ) . get ( <str> ) ; for ( GeoHashGrid . Bucket cell : geoGrid . getBuckets ( ) ) { String geohash = cell . getKeyAsString ( ) ; long bucketCount = cell . getDocCount ( ) ; int expectedBucketCount = expectedDocCountsForGeoHash . get ( geohash ) ; assertNotSame ( bucketCount , <int> ) ; assertTrue ( <str> , geohash . startsWith ( smallestGeoHash ) ) ; assertEquals ( <str> + geohash + <str> , expectedBucketCount , bucketCount ) ; } } } public void testUnmapped ( ) throws Exception { for ( int precision = <int> ; precision < = GeoHashUtils . PRECISION ; precision + + ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( geohashGrid ( <str> ) . field ( <str> ) . precision ( precision ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; GeoHashGrid geoGrid = response . getAggregations ( ) . get ( <str> ) ; assertThat ( geoGrid . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } } public void testPartiallyUnmapped ( ) throws Exception { for ( int precision = <int> ; precision < = GeoHashUtils . PRECISION ; precision + + ) { SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . addAggregation ( geohashGrid ( <str> ) . field ( <str> ) . precision ( precision ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; GeoHashGrid geoGrid = response . getAggregations ( ) . get ( <str> ) ; for ( GeoHashGrid . Bucket cell : geoGrid . getBuckets ( ) ) { String geohash = cell . getKeyAsString ( ) ; long bucketCount = cell . getDocCount ( ) ; int expectedBucketCount = expectedDocCountsForGeoHash . get ( geohash ) ; assertNotSame ( bucketCount , <int> ) ; assertEquals ( <str> + geohash + <str> , expectedBucketCount , bucketCount ) ; } } } public void testTopMatch ( ) throws Exception { for ( int precision = <int> ; precision < = GeoHashUtils . PRECISION ; precision + + ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( geohashGrid ( <str> ) . field ( <str> ) . size ( <int> ) . shardSize ( <int> ) . precision ( precision ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; GeoHashGrid geoGrid = response . getAggregations ( ) . get ( <str> ) ; assertThat ( geoGrid . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( GeoHashGrid . Bucket cell : geoGrid . getBuckets ( ) ) { String geohash = cell . getKeyAsString ( ) ; long bucketCount = cell . getDocCount ( ) ; int expectedBucketCount = <int> ; for ( ObjectIntCursor < String > cursor : expectedDocCountsForGeoHash ) { if ( cursor . key . length ( ) = = precision ) { expectedBucketCount = Math . max ( expectedBucketCount , cursor . value ) ; } } assertNotSame ( bucketCount , <int> ) ; assertEquals ( <str> + geohash + <str> , expectedBucketCount , bucketCount ) ; } } } public void testSizeIsZero ( ) { for ( int precision = <int> ; precision < = GeoHashUtils . PRECISION ; precision + + ) { final int size = randomBoolean ( ) ? <int> : randomIntBetween ( <int> , Integer . MAX_VALUE ) ; final int shardSize = randomBoolean ( ) ? - <int> : <int> ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( geohashGrid ( <str> ) . field ( <str> ) . size ( size ) . shardSize ( shardSize ) . precision ( precision ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; GeoHashGrid geoGrid = response . getAggregations ( ) . get ( <str> ) ; assertThat ( geoGrid . getBuckets ( ) . size ( ) , greaterThanOrEqualTo ( <int> ) ) ; } } } 
