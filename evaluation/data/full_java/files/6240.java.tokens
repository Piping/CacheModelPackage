package org . elasticsearch . index ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . cluster . metadata . AliasMetaData ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . env . ShardLock ; import org . elasticsearch . index . analysis . AnalysisRegistry ; import org . elasticsearch . index . analysis . AnalysisService ; import org . elasticsearch . index . cache . IndexCache ; import org . elasticsearch . index . cache . bitset . BitsetFilterCache ; import org . elasticsearch . index . cache . query . QueryCache ; import org . elasticsearch . index . engine . EngineFactory ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . fielddata . IndexFieldDataCache ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . query . ParsedQuery ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . index . shard . * ; import org . elasticsearch . index . similarity . SimilarityService ; import org . elasticsearch . index . store . IndexStore ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . indices . AliasFilterParsingException ; import org . elasticsearch . indices . InvalidAliasNameException ; import org . elasticsearch . indices . mapper . MapperRegistry ; import java . io . Closeable ; import java . io . IOException ; import java . nio . file . Path ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . collect . MapBuilder . newMapBuilder ; public final class IndexService extends AbstractIndexComponent implements IndexComponent , Iterable < IndexShard > { private final IndexEventListener eventListener ; private final AnalysisService analysisService ; private final IndexFieldDataService indexFieldData ; private final BitsetFilterCache bitsetFilterCache ; private final NodeEnvironment nodeEnv ; private final ShardStoreDeleter shardStoreDeleter ; private final NodeServicesProvider nodeServicesProvider ; private final IndexStore indexStore ; private final IndexSearcherWrapper searcherWrapper ; private final IndexCache indexCache ; private final MapperService mapperService ; private final SimilarityService similarityService ; private final EngineFactory engineFactory ; private volatile Map < Integer , IndexShard > shards = emptyMap ( ) ; private final AtomicBoolean closed = new AtomicBoolean ( false ) ; private final AtomicBoolean deleted = new AtomicBoolean ( false ) ; private final IndexSettings indexSettings ; @Inject public IndexService ( IndexSettings indexSettings , NodeEnvironment nodeEnv , SimilarityService similarityService , ShardStoreDeleter shardStoreDeleter , AnalysisRegistry registry , @Nullable EngineFactory engineFactory , NodeServicesProvider nodeServicesProvider , QueryCache queryCache , IndexStore indexStore , IndexEventListener eventListener , IndexModule . IndexSearcherWrapperFactory wrapperFactory , MapperRegistry mapperRegistry ) throws IOException { super ( indexSettings ) ; this . indexSettings = indexSettings ; this . analysisService = registry . build ( indexSettings ) ; this . similarityService = similarityService ; this . mapperService = new MapperService ( indexSettings , analysisService , similarityService , mapperRegistry ) ; this . indexFieldData = new IndexFieldDataService ( indexSettings , nodeServicesProvider . getIndicesFieldDataCache ( ) , nodeServicesProvider . getCircuitBreakerService ( ) , mapperService ) ; this . shardStoreDeleter = shardStoreDeleter ; this . eventListener = eventListener ; this . nodeEnv = nodeEnv ; this . nodeServicesProvider = nodeServicesProvider ; this . indexStore = indexStore ; indexFieldData . setListener ( new FieldDataCacheListener ( this ) ) ; this . bitsetFilterCache = new BitsetFilterCache ( indexSettings , nodeServicesProvider . getWarmer ( ) , new BitsetCacheListener ( this ) ) ; this . indexCache = new IndexCache ( indexSettings , queryCache , bitsetFilterCache ) ; this . engineFactory = engineFactory ; this . searcherWrapper = wrapperFactory . newWrapper ( this ) ; } public int numberOfShards ( ) { return shards . size ( ) ; } public IndexEventListener getIndexEventListener ( ) { return this . eventListener ; } @Override public Iterator < IndexShard > iterator ( ) { return shards . values ( ) . iterator ( ) ; } public boolean hasShard ( int shardId ) { return shards . containsKey ( shardId ) ; } @Nullable public IndexShard getShardOrNull ( int shardId ) { return shards . get ( shardId ) ; } public IndexShard getShard ( int shardId ) { IndexShard indexShard = getShardOrNull ( shardId ) ; if ( indexShard = = null ) { throw new ShardNotFoundException ( new ShardId ( index ( ) , shardId ) ) ; } return indexShard ; } public Set < Integer > shardIds ( ) { return shards . keySet ( ) ; } public IndexCache cache ( ) { return indexCache ; } public IndexFieldDataService fieldData ( ) { return indexFieldData ; } public AnalysisService analysisService ( ) { return this . analysisService ; } public MapperService mapperService ( ) { return mapperService ; } public SimilarityService similarityService ( ) { return similarityService ; } public synchronized void close ( final String reason , boolean delete ) throws IOException { if ( closed . compareAndSet ( false , true ) ) { deleted . compareAndSet ( false , delete ) ; try { final Set < Integer > shardIds = shardIds ( ) ; for ( final int shardId : shardIds ) { try { removeShard ( shardId , reason ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } } } finally { IOUtils . close ( bitsetFilterCache , indexCache , mapperService , indexFieldData , analysisService ) ; } } } public String indexUUID ( ) { return indexSettings . getUUID ( ) ; } private long getAvgShardSizeInBytes ( ) throws IOException { long sum = <int> ; int count = <int> ; for ( IndexShard indexShard : this ) { sum + = indexShard . store ( ) . stats ( ) . sizeInBytes ( ) ; count + + ; } if ( count = = <int> ) { return - <int> ; } else { return sum / count ; } } public synchronized IndexShard createShard ( ShardRouting routing ) throws IOException { final boolean primary = routing . primary ( ) ; if ( closed . get ( ) ) { throw new IllegalStateException ( <str> + routing . shardId ( ) + <str> ) ; } final Settings indexSettings = this . indexSettings . getSettings ( ) ; final ShardId shardId = routing . shardId ( ) ; boolean success = false ; Store store = null ; IndexShard indexShard = null ; final ShardLock lock = nodeEnv . shardLock ( shardId , TimeUnit . SECONDS . toMillis ( <int> ) ) ; try { eventListener . beforeIndexShardCreated ( shardId , indexSettings ) ; ShardPath path ; try { path = ShardPath . loadShardPath ( logger , nodeEnv , shardId , this . indexSettings ) ; } catch ( IllegalStateException ex ) { logger . warn ( <str> , shardId ) ; try { ShardPath . deleteLeftoverShardDirectory ( logger , nodeEnv , lock , this . indexSettings ) ; path = ShardPath . loadShardPath ( logger , nodeEnv , shardId , this . indexSettings ) ; } catch ( Throwable t ) { t . addSuppressed ( ex ) ; throw t ; } } if ( path = = null ) { Map < Path , Integer > dataPathToShardCount = new HashMap < > ( ) ; for ( IndexShard shard : this ) { Path dataPath = shard . shardPath ( ) . getRootStatePath ( ) ; Integer curCount = dataPathToShardCount . get ( dataPath ) ; if ( curCount = = null ) { curCount = <int> ; } dataPathToShardCount . put ( dataPath , curCount + <int> ) ; } path = ShardPath . selectNewPathForShard ( nodeEnv , shardId , this . indexSettings , routing . getExpectedShardSize ( ) = = ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ? getAvgShardSizeInBytes ( ) : routing . getExpectedShardSize ( ) , dataPathToShardCount ) ; logger . debug ( <str> , shardId , path ) ; } else { logger . debug ( <str> , shardId , path ) ; } if ( shards . containsKey ( shardId . id ( ) ) ) { throw new IndexShardAlreadyExistsException ( shardId + <str> ) ; } logger . debug ( <str> , shardId ) ; final boolean canDeleteShardContent = IndexMetaData . isOnSharedFilesystem ( indexSettings ) = = false | | ( primary & & IndexMetaData . isOnSharedFilesystem ( indexSettings ) ) ; store = new Store ( shardId , this . indexSettings , indexStore . newDirectoryService ( path ) , lock , new StoreCloseListener ( shardId , canDeleteShardContent , ( ) - > nodeServicesProvider . getIndicesQueryCache ( ) . onClose ( shardId ) ) ) ; if ( useShadowEngine ( primary , indexSettings ) ) { indexShard = new ShadowIndexShard ( shardId , this . indexSettings , path , store , indexCache , mapperService , similarityService , indexFieldData , engineFactory , eventListener , searcherWrapper , nodeServicesProvider ) ; } else { indexShard = new IndexShard ( shardId , this . indexSettings , path , store , indexCache , mapperService , similarityService , indexFieldData , engineFactory , eventListener , searcherWrapper , nodeServicesProvider ) ; } eventListener . indexShardStateChanged ( indexShard , null , indexShard . state ( ) , <str> ) ; eventListener . afterIndexShardCreated ( indexShard ) ; indexShard . updateRoutingEntry ( routing , true ) ; shards = newMapBuilder ( shards ) . put ( shardId . id ( ) , indexShard ) . immutableMap ( ) ; success = true ; return indexShard ; } finally { if ( success = = false ) { IOUtils . closeWhileHandlingException ( lock ) ; closeShard ( <str> , shardId , indexShard , store , eventListener ) ; } } } static boolean useShadowEngine ( boolean primary , Settings indexSettings ) { return primary = = false & & IndexMetaData . isIndexUsingShadowReplicas ( indexSettings ) ; } public synchronized void removeShard ( int shardId , String reason ) { final ShardId sId = new ShardId ( index ( ) , shardId ) ; final IndexShard indexShard ; if ( shards . containsKey ( shardId ) = = false ) { return ; } logger . debug ( <str> , shardId , reason ) ; HashMap < Integer , IndexShard > newShards = new HashMap < > ( shards ) ; indexShard = newShards . remove ( shardId ) ; shards = unmodifiableMap ( newShards ) ; closeShard ( reason , sId , indexShard , indexShard . store ( ) , indexShard . getIndexEventListener ( ) ) ; logger . debug ( <str> , shardId , reason ) ; } private void closeShard ( String reason , ShardId sId , IndexShard indexShard , Store store , IndexEventListener listener ) { final int shardId = sId . id ( ) ; final Settings indexSettings = this . getIndexSettings ( ) . getSettings ( ) ; try { try { listener . beforeIndexShardClosed ( sId , indexShard , indexSettings ) ; } finally { if ( indexShard ! = null ) { try { final boolean flushEngine = deleted . get ( ) = = false & & closed . get ( ) ; indexShard . close ( reason , flushEngine ) ; } catch ( Throwable e ) { logger . debug ( <str> , e , shardId ) ; } } listener . afterIndexShardClosed ( sId , indexShard , indexSettings ) ; } } finally { try { store . close ( ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , shardId , reason ) ; } } } private void onShardClose ( ShardLock lock , boolean ownsShard ) { if ( deleted . get ( ) ) { try { if ( ownsShard ) { try { eventListener . beforeIndexShardDeleted ( lock . getShardId ( ) , indexSettings . getSettings ( ) ) ; } finally { shardStoreDeleter . deleteShardStore ( <str> , lock , indexSettings ) ; eventListener . afterIndexShardDeleted ( lock . getShardId ( ) , indexSettings . getSettings ( ) ) ; } } } catch ( IOException e ) { shardStoreDeleter . addPendingDelete ( lock . getShardId ( ) , indexSettings ) ; logger . debug ( <str> , e , lock . getShardId ( ) . id ( ) ) ; } } } public NodeServicesProvider getIndexServices ( ) { return nodeServicesProvider ; } public IndexSettings getIndexSettings ( ) { return indexSettings ; } public QueryShardContext getQueryShardContext ( ) { return new QueryShardContext ( indexSettings , nodeServicesProvider . getClient ( ) , indexCache . bitsetFilterCache ( ) , indexFieldData , mapperService ( ) , similarityService ( ) , nodeServicesProvider . getScriptService ( ) , nodeServicesProvider . getIndicesQueriesRegistry ( ) ) ; } private class StoreCloseListener implements Store . OnClose { private final ShardId shardId ; private final boolean ownsShard ; private final Closeable [ ] toClose ; public StoreCloseListener ( ShardId shardId , boolean ownsShard , Closeable . . . toClose ) { this . shardId = shardId ; this . ownsShard = ownsShard ; this . toClose = toClose ; } @Override public void handle ( ShardLock lock ) { try { assert lock . getShardId ( ) . equals ( shardId ) : <str> + shardId + <str> + lock . getShardId ( ) ; onShardClose ( lock , ownsShard ) ; } finally { try { IOUtils . close ( toClose ) ; } catch ( IOException ex ) { logger . debug ( <str> , ex ) ; } } } } private static final class BitsetCacheListener implements BitsetFilterCache . Listener { final IndexService indexService ; private BitsetCacheListener ( IndexService indexService ) { this . indexService = indexService ; } @Override public void onCache ( ShardId shardId , Accountable accountable ) { if ( shardId ! = null ) { final IndexShard shard = indexService . getShardOrNull ( shardId . id ( ) ) ; if ( shard ! = null ) { long ramBytesUsed = accountable ! = null ? accountable . ramBytesUsed ( ) : <int> l ; shard . shardBitsetFilterCache ( ) . onCached ( ramBytesUsed ) ; } } } @Override public void onRemoval ( ShardId shardId , Accountable accountable ) { if ( shardId ! = null ) { final IndexShard shard = indexService . getShardOrNull ( shardId . id ( ) ) ; if ( shard ! = null ) { long ramBytesUsed = accountable ! = null ? accountable . ramBytesUsed ( ) : <int> l ; shard . shardBitsetFilterCache ( ) . onRemoval ( ramBytesUsed ) ; } } } } private final class FieldDataCacheListener implements IndexFieldDataCache . Listener { final IndexService indexService ; public FieldDataCacheListener ( IndexService indexService ) { this . indexService = indexService ; } @Override public void onCache ( ShardId shardId , MappedFieldType . Names fieldNames , FieldDataType fieldDataType , Accountable ramUsage ) { if ( shardId ! = null ) { final IndexShard shard = indexService . getShardOrNull ( shardId . id ( ) ) ; if ( shard ! = null ) { shard . fieldData ( ) . onCache ( shardId , fieldNames , fieldDataType , ramUsage ) ; } } } @Override public void onRemoval ( ShardId shardId , MappedFieldType . Names fieldNames , FieldDataType fieldDataType , boolean wasEvicted , long sizeInBytes ) { if ( shardId ! = null ) { final IndexShard shard = indexService . getShardOrNull ( shardId . id ( ) ) ; if ( shard ! = null ) { shard . fieldData ( ) . onRemoval ( shardId , fieldNames , fieldDataType , wasEvicted , sizeInBytes ) ; } } } } public Query aliasFilter ( QueryShardContext context , String . . . aliasNames ) { if ( aliasNames = = null | | aliasNames . length = = <int> ) { return null ; } final ImmutableOpenMap < String , AliasMetaData > aliases = indexSettings . getIndexMetaData ( ) . getAliases ( ) ; if ( aliasNames . length = = <int> ) { AliasMetaData alias = aliases . get ( aliasNames [ <int> ] ) ; if ( alias = = null ) { throw new InvalidAliasNameException ( index ( ) , aliasNames [ <int> ] , <str> ) ; } return parse ( alias , context ) ; } else { BooleanQuery . Builder combined = new BooleanQuery . Builder ( ) ; for ( String aliasName : aliasNames ) { AliasMetaData alias = aliases . get ( aliasName ) ; if ( alias = = null ) { throw new InvalidAliasNameException ( indexSettings . getIndex ( ) , aliasNames [ <int> ] , <str> ) ; } Query parsedFilter = parse ( alias , context ) ; if ( parsedFilter ! = null ) { combined . add ( parsedFilter , BooleanClause . Occur . SHOULD ) ; } else { return null ; } } return combined . build ( ) ; } } private Query parse ( AliasMetaData alias , QueryShardContext parseContext ) { if ( alias . filter ( ) = = null ) { return null ; } try { byte [ ] filterSource = alias . filter ( ) . uncompressed ( ) ; try ( XContentParser parser = XContentFactory . xContent ( filterSource ) . createParser ( filterSource ) ) { ParsedQuery parsedFilter = parseContext . parseInnerFilter ( parser ) ; return parsedFilter = = null ? null : parsedFilter . query ( ) ; } } catch ( IOException ex ) { throw new AliasFilterParsingException ( parseContext . index ( ) , alias . getAlias ( ) , <str> , ex ) ; } } public IndexMetaData getMetaData ( ) { return indexSettings . getIndexMetaData ( ) ; } public synchronized void updateMetaData ( final IndexMetaData metadata ) { if ( indexSettings . updateIndexMetaData ( metadata ) ) { final Settings settings = indexSettings . getSettings ( ) ; for ( final IndexShard shard : this . shards . values ( ) ) { try { shard . onRefreshSettings ( settings ) ; } catch ( Exception e ) { logger . warn ( <str> , e , shard . shardId ( ) . id ( ) ) ; } } try { indexStore . onRefreshSettings ( settings ) ; } catch ( Exception e ) { logger . warn ( <str> , e ) ; } } } public interface ShardStoreDeleter { void deleteShardStore ( String reason , ShardLock lock , IndexSettings indexSettings ) throws IOException ; void addPendingDelete ( ShardId shardId , IndexSettings indexSettings ) ; } final EngineFactory getEngineFactory ( ) { return engineFactory ; } final IndexSearcherWrapper getSearcherWrapper ( ) { return searcherWrapper ; } final IndexStore getIndexStore ( ) { return indexStore ; } } 
