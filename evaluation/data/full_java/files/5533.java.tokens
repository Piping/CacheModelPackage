package org . elasticsearch . cluster ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . LatchedActionListener ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsRequest ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . admin . cluster . node . stats . TransportNodesStatsAction ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsRequest ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsResponse ; import org . elasticsearch . action . admin . indices . stats . ShardStats ; import org . elasticsearch . action . admin . indices . stats . TransportIndicesStatsAction ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . decider . DiskThresholdDecider ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . EsRejectedExecutionException ; import org . elasticsearch . monitor . fs . FsInfo ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . ReceiveTimeoutTransportException ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; public class InternalClusterInfoService extends AbstractComponent implements ClusterInfoService , LocalNodeMasterListener , ClusterStateListener { public static final String INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL = <str> ; public static final String INTERNAL_CLUSTER_INFO_TIMEOUT = <str> ; private volatile TimeValue updateFrequency ; private volatile ImmutableOpenMap < String , DiskUsage > leastAvailableSpaceUsages ; private volatile ImmutableOpenMap < String , DiskUsage > mostAvailableSpaceUsages ; private volatile ImmutableOpenMap < ShardRouting , String > shardRoutingToDataPath ; private volatile ImmutableOpenMap < String , Long > shardSizes ; private volatile boolean isMaster = false ; private volatile boolean enabled ; private volatile TimeValue fetchTimeout ; private final TransportNodesStatsAction transportNodesStatsAction ; private final TransportIndicesStatsAction transportIndicesStatsAction ; private final ClusterService clusterService ; private final ThreadPool threadPool ; private final List < Listener > listeners = new CopyOnWriteArrayList < > ( ) ; @Inject public InternalClusterInfoService ( Settings settings , NodeSettingsService nodeSettingsService , TransportNodesStatsAction transportNodesStatsAction , TransportIndicesStatsAction transportIndicesStatsAction , ClusterService clusterService , ThreadPool threadPool ) { super ( settings ) ; this . leastAvailableSpaceUsages = ImmutableOpenMap . of ( ) ; this . mostAvailableSpaceUsages = ImmutableOpenMap . of ( ) ; this . shardRoutingToDataPath = ImmutableOpenMap . of ( ) ; this . shardSizes = ImmutableOpenMap . of ( ) ; this . transportNodesStatsAction = transportNodesStatsAction ; this . transportIndicesStatsAction = transportIndicesStatsAction ; this . clusterService = clusterService ; this . threadPool = threadPool ; this . updateFrequency = settings . getAsTime ( INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL , TimeValue . timeValueSeconds ( <int> ) ) ; this . fetchTimeout = settings . getAsTime ( INTERNAL_CLUSTER_INFO_TIMEOUT , TimeValue . timeValueSeconds ( <int> ) ) ; this . enabled = settings . getAsBoolean ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , true ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; this . clusterService . add ( ( LocalNodeMasterListener ) this ) ; this . clusterService . add ( ( ClusterStateListener ) this ) ; } class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { TimeValue newUpdateFrequency = settings . getAsTime ( INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL , null ) ; Boolean newEnabled = settings . getAsBoolean ( DiskThresholdDecider . CLUSTER_ROUTING_ALLOCATION_DISK_THRESHOLD_ENABLED , null ) ; if ( newUpdateFrequency ! = null ) { if ( newUpdateFrequency . getMillis ( ) < TimeValue . timeValueSeconds ( <int> ) . getMillis ( ) ) { logger . warn ( <str> , INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL , newUpdateFrequency ) ; throw new IllegalStateException ( <str> + INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL + <str> ) ; } else { logger . info ( <str> , INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL , updateFrequency , newUpdateFrequency ) ; InternalClusterInfoService . this . updateFrequency = newUpdateFrequency ; } } TimeValue newFetchTimeout = settings . getAsTime ( INTERNAL_CLUSTER_INFO_TIMEOUT , null ) ; if ( newFetchTimeout ! = null ) { logger . info ( <str> , INTERNAL_CLUSTER_INFO_TIMEOUT , fetchTimeout , newFetchTimeout ) ; InternalClusterInfoService . this . fetchTimeout = newFetchTimeout ; } if ( newEnabled ! = null ) { InternalClusterInfoService . this . enabled = newEnabled ; } } } @Override public void onMaster ( ) { this . isMaster = true ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } try { threadPool . schedule ( updateFrequency , executorName ( ) , new SubmitReschedulingClusterInfoUpdatedJob ( ) ) ; if ( clusterService . state ( ) . getNodes ( ) . getDataNodes ( ) . size ( ) > <int> ) { threadPool . executor ( executorName ( ) ) . execute ( ( ) - > maybeRefresh ( ) ) ; } } catch ( EsRejectedExecutionException ex ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , ex ) ; } } } @Override public void offMaster ( ) { this . isMaster = false ; } @Override public String executorName ( ) { return ThreadPool . Names . MANAGEMENT ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { if ( ! this . enabled ) { return ; } boolean dataNodeAdded = false ; for ( DiscoveryNode addedNode : event . nodesDelta ( ) . addedNodes ( ) ) { if ( addedNode . dataNode ( ) ) { dataNodeAdded = true ; break ; } } if ( this . isMaster & & dataNodeAdded & & clusterService . state ( ) . getNodes ( ) . getDataNodes ( ) . size ( ) > <int> ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> ) ; } threadPool . executor ( executorName ( ) ) . execute ( ( ) - > maybeRefresh ( ) ) ; } if ( this . isMaster & & event . nodesRemoved ( ) ) { for ( DiscoveryNode removedNode : event . nodesDelta ( ) . removedNodes ( ) ) { if ( removedNode . dataNode ( ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , removedNode . getId ( ) ) ; } if ( leastAvailableSpaceUsages . containsKey ( removedNode . getId ( ) ) ) { ImmutableOpenMap . Builder < String , DiskUsage > newMaxUsages = ImmutableOpenMap . builder ( leastAvailableSpaceUsages ) ; newMaxUsages . remove ( removedNode . getId ( ) ) ; leastAvailableSpaceUsages = newMaxUsages . build ( ) ; } if ( mostAvailableSpaceUsages . containsKey ( removedNode . getId ( ) ) ) { ImmutableOpenMap . Builder < String , DiskUsage > newMinUsages = ImmutableOpenMap . builder ( mostAvailableSpaceUsages ) ; newMinUsages . remove ( removedNode . getId ( ) ) ; mostAvailableSpaceUsages = newMinUsages . build ( ) ; } } } } } @Override public ClusterInfo getClusterInfo ( ) { return new ClusterInfo ( leastAvailableSpaceUsages , mostAvailableSpaceUsages , shardSizes , shardRoutingToDataPath ) ; } @Override public void addListener ( Listener listener ) { this . listeners . add ( listener ) ; } public class SubmitReschedulingClusterInfoUpdatedJob implements Runnable { @Override public void run ( ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } try { threadPool . executor ( executorName ( ) ) . execute ( ( ) - > { try { maybeRefresh ( ) ; } finally { if ( isMaster ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , updateFrequency . toString ( ) ) ; } try { threadPool . schedule ( updateFrequency , executorName ( ) , this ) ; } catch ( EsRejectedExecutionException ex ) { logger . debug ( <str> , ex ) ; } } } } ) ; } catch ( EsRejectedExecutionException ex ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , ex ) ; } } } } protected CountDownLatch updateNodeStats ( final ActionListener < NodesStatsResponse > listener ) { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest ( <str> ) ; nodesStatsRequest . clear ( ) ; nodesStatsRequest . fs ( true ) ; nodesStatsRequest . timeout ( fetchTimeout ) ; transportNodesStatsAction . execute ( nodesStatsRequest , new LatchedActionListener < > ( listener , latch ) ) ; return latch ; } protected CountDownLatch updateIndicesStats ( final ActionListener < IndicesStatsResponse > listener ) { final CountDownLatch latch = new CountDownLatch ( <int> ) ; final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest ( ) ; indicesStatsRequest . clear ( ) ; indicesStatsRequest . store ( true ) ; transportIndicesStatsAction . execute ( indicesStatsRequest , new LatchedActionListener < > ( listener , latch ) ) ; return latch ; } private final void maybeRefresh ( ) { if ( enabled ) { refresh ( ) ; } else { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } } } public final ClusterInfo refresh ( ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } final CountDownLatch nodeLatch = updateNodeStats ( new ActionListener < NodesStatsResponse > ( ) { @Override public void onResponse ( NodesStatsResponse nodeStatses ) { ImmutableOpenMap . Builder < String , DiskUsage > newLeastAvaiableUsages = ImmutableOpenMap . builder ( ) ; ImmutableOpenMap . Builder < String , DiskUsage > newMostAvaiableUsages = ImmutableOpenMap . builder ( ) ; fillDiskUsagePerNode ( logger , nodeStatses . getNodes ( ) , newLeastAvaiableUsages , newMostAvaiableUsages ) ; leastAvailableSpaceUsages = newLeastAvaiableUsages . build ( ) ; mostAvailableSpaceUsages = newMostAvaiableUsages . build ( ) ; } @Override public void onFailure ( Throwable e ) { if ( e instanceof ReceiveTimeoutTransportException ) { logger . error ( <str> , e . getMessage ( ) ) ; } else { if ( e instanceof ClusterBlockException ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , e ) ; } } else { logger . warn ( <str> , e ) ; } leastAvailableSpaceUsages = ImmutableOpenMap . of ( ) ; mostAvailableSpaceUsages = ImmutableOpenMap . of ( ) ; } } } ) ; final CountDownLatch indicesLatch = updateIndicesStats ( new ActionListener < IndicesStatsResponse > ( ) { @Override public void onResponse ( IndicesStatsResponse indicesStatsResponse ) { ShardStats [ ] stats = indicesStatsResponse . getShards ( ) ; ImmutableOpenMap . Builder < String , Long > newShardSizes = ImmutableOpenMap . builder ( ) ; ImmutableOpenMap . Builder < ShardRouting , String > newShardRoutingToDataPath = ImmutableOpenMap . builder ( ) ; buildShardLevelInfo ( logger , stats , newShardSizes , newShardRoutingToDataPath ) ; shardSizes = newShardSizes . build ( ) ; shardRoutingToDataPath = newShardRoutingToDataPath . build ( ) ; } @Override public void onFailure ( Throwable e ) { if ( e instanceof ReceiveTimeoutTransportException ) { logger . error ( <str> , e . getMessage ( ) ) ; } else { if ( e instanceof ClusterBlockException ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , e ) ; } } else { logger . warn ( <str> , e ) ; } shardSizes = ImmutableOpenMap . of ( ) ; shardRoutingToDataPath = ImmutableOpenMap . of ( ) ; } } } ) ; try { nodeLatch . await ( fetchTimeout . getMillis ( ) , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; logger . warn ( <str> , fetchTimeout ) ; } try { indicesLatch . await ( fetchTimeout . getMillis ( ) , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; logger . warn ( <str> , fetchTimeout ) ; } ClusterInfo clusterInfo = getClusterInfo ( ) ; for ( Listener l : listeners ) { try { l . onNewInfo ( clusterInfo ) ; } catch ( Exception e ) { logger . info ( <str> , e ) ; } } return clusterInfo ; } static void buildShardLevelInfo ( ESLogger logger , ShardStats [ ] stats , ImmutableOpenMap . Builder < String , Long > newShardSizes , ImmutableOpenMap . Builder < ShardRouting , String > newShardRoutingToDataPath ) { for ( ShardStats s : stats ) { newShardRoutingToDataPath . put ( s . getShardRouting ( ) , s . getDataPath ( ) ) ; long size = s . getStats ( ) . getStore ( ) . sizeInBytes ( ) ; String sid = ClusterInfo . shardIdentifierFromRouting ( s . getShardRouting ( ) ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , sid , size ) ; } newShardSizes . put ( sid , size ) ; } } static void fillDiskUsagePerNode ( ESLogger logger , NodeStats [ ] nodeStatsArray , ImmutableOpenMap . Builder < String , DiskUsage > newLeastAvaiableUsages , ImmutableOpenMap . Builder < String , DiskUsage > newMostAvaiableUsages ) { for ( NodeStats nodeStats : nodeStatsArray ) { if ( nodeStats . getFs ( ) = = null ) { logger . warn ( <str> , nodeStats . getNode ( ) . name ( ) ) ; } else { FsInfo . Path leastAvailablePath = null ; FsInfo . Path mostAvailablePath = null ; for ( FsInfo . Path info : nodeStats . getFs ( ) ) { if ( leastAvailablePath = = null ) { assert mostAvailablePath = = null ; mostAvailablePath = leastAvailablePath = info ; } else if ( leastAvailablePath . getAvailable ( ) . bytes ( ) > info . getAvailable ( ) . bytes ( ) ) { leastAvailablePath = info ; } else if ( mostAvailablePath . getAvailable ( ) . bytes ( ) < info . getAvailable ( ) . bytes ( ) ) { mostAvailablePath = info ; } } String nodeId = nodeStats . getNode ( ) . id ( ) ; String nodeName = nodeStats . getNode ( ) . getName ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , nodeId , mostAvailablePath . getTotal ( ) , leastAvailablePath . getAvailable ( ) , leastAvailablePath . getTotal ( ) , leastAvailablePath . getAvailable ( ) ) ; } newLeastAvaiableUsages . put ( nodeId , new DiskUsage ( nodeId , nodeName , leastAvailablePath . getPath ( ) , leastAvailablePath . getTotal ( ) . bytes ( ) , leastAvailablePath . getAvailable ( ) . bytes ( ) ) ) ; newMostAvaiableUsages . put ( nodeId , new DiskUsage ( nodeId , nodeName , mostAvailablePath . getPath ( ) , mostAvailablePath . getTotal ( ) . bytes ( ) , mostAvailablePath . getAvailable ( ) . bytes ( ) ) ) ; } } } } 
