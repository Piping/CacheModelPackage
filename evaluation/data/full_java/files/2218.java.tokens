package org . nd4j . linalg . indexing ; import com . google . common . primitives . Ints ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . util . ArrayUtil ; import org . nd4j . linalg . api . shape . Shape ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; public class ShapeOffsetResolution implements Serializable { private INDArray arr ; private int [ ] offsets , shapes , strides ; private int offset = - <int> ; public ShapeOffsetResolution ( INDArray arr ) { this . arr = arr ; } public boolean tryShortCircuit ( INDArrayIndex . . . indexes ) { int pointIndex = <int> ; int interval = <int> ; int newAxis = <int> ; int numAll = <int> ; int numSpecified = <int> ; for ( int i = <int> ; i < indexes . length ; i + + ) { if ( indexes [ i ] instanceof PointIndex ) { pointIndex + + ; } if ( indexes [ i ] instanceof SpecifiedIndex ) numSpecified + + ; else if ( indexes [ i ] instanceof IntervalIndex & & ! ( indexes [ i ] instanceof NDArrayIndexAll ) ) interval + + ; else if ( indexes [ i ] instanceof NewAxis ) newAxis + + ; else if ( indexes [ i ] instanceof NDArrayIndexAll ) numAll + + ; } if ( numSpecified < <int> & & interval < <int> & & newAxis < <int> & & pointIndex > <int> & & numAll > <int> ) { int minDimensions = Math . max ( arr . rank ( ) - pointIndex , <int> ) ; int [ ] shape = new int [ minDimensions ] ; Arrays . fill ( shape , <int> ) ; int [ ] stride = new int [ minDimensions ] ; Arrays . fill ( stride , arr . elementStride ( ) ) ; int [ ] offsets = new int [ minDimensions ] ; int offset = <int> ; int currIndex = <int> ; int arrIndex = <int> ; for ( int i = <int> ; i < indexes . length ; i + + ) { if ( indexes [ i ] instanceof NDArrayIndexAll ) { shape [ currIndex ] = arr . size ( arrIndex ) ; stride [ currIndex ] = arr . stride ( arrIndex ) ; currIndex + + ; arrIndex + + ; } else { offset + = indexes [ i ] . offset ( ) * arr . stride ( i ) ; arrIndex + + ; } } if ( arr . isMatrix ( ) & & indexes [ <int> ] instanceof PointIndex ) { shape = ArrayUtil . reverseCopy ( shape ) ; stride = ArrayUtil . reverseCopy ( stride ) ; } this . strides = stride ; this . shapes = shape ; this . offsets = offsets ; this . offset = offset ; return true ; } else if ( numSpecified < <int> & & interval > <int> & & newAxis < <int> & & pointIndex < <int> & & numAll > <int> ) { int minDimensions = Math . max ( arr . rank ( ) , <int> ) ; int [ ] shape = new int [ minDimensions ] ; Arrays . fill ( shape , <int> ) ; int [ ] stride = new int [ minDimensions ] ; Arrays . fill ( stride , arr . elementStride ( ) ) ; int [ ] offsets = new int [ minDimensions ] ; for ( int i = <int> ; i < shape . length ; i + + ) { if ( indexes [ i ] instanceof NDArrayIndexAll ) { shape [ i ] = arr . size ( i ) ; stride [ i ] = arr . stride ( i ) ; offsets [ i ] = indexes [ i ] . offset ( ) ; } else if ( indexes [ i ] instanceof IntervalIndex ) { shape [ i ] = indexes [ i ] . length ( ) ; stride [ i ] = indexes [ i ] . stride ( ) * arr . stride ( i ) ; offsets [ i ] = indexes [ i ] . offset ( ) ; } } this . shapes = shape ; this . strides = stride ; this . offsets = offsets ; this . offset = <int> ; for ( int i = <int> ; i < indexes . length ; i + + ) { offset + = offsets [ i ] * ( stride [ i ] / indexes [ i ] . stride ( ) ) ; } return true ; } else if ( numSpecified < <int> & & interval < <int> & & newAxis < <int> & & pointIndex < <int> & & numAll > <int> ) { int minDimensions = Math . max ( arr . rank ( ) , <int> ) + newAxis ; int [ ] shape = new int [ minDimensions ] ; Arrays . fill ( shape , <int> ) ; int [ ] stride = new int [ minDimensions ] ; Arrays . fill ( stride , arr . elementStride ( ) ) ; int [ ] offsets = new int [ minDimensions ] ; int prependNewAxes = <int> ; boolean allFirst = false ; int shapeAxis = <int> ; for ( int i = <int> ; i < indexes . length ; i + + ) { if ( indexes [ i ] instanceof NewAxis ) { if ( allFirst ) { shape [ i ] = <int> ; stride [ i ] = <int> ; } else { prependNewAxes + + ; } } else { if ( i = = <int> ) allFirst = true ; shape [ i ] = arr . size ( shapeAxis + prependNewAxes ) ; stride [ i ] = arr . stride ( shapeAxis + prependNewAxes ) ; shapeAxis + + ; } } this . shapes = shape ; this . strides = stride ; this . offsets = offsets ; return true ; } return false ; } public void exec ( INDArrayIndex . . . indexes ) { indexes = NDArrayIndex . resolve ( arr . shape ( ) , indexes ) ; if ( tryShortCircuit ( indexes ) ) { return ; } int [ ] shape = arr . shape ( ) ; int numIntervals = <int> ; int newAxesPrepend = <int> ; boolean encounteredAll = false ; List < Integer > oneDimensionWithAllEncountered = new ArrayList < > ( ) ; List < Integer > accumShape = new ArrayList < > ( ) ; List < Integer > accumStrides = new ArrayList < > ( ) ; List < Integer > accumOffsets = new ArrayList < > ( ) ; List < Integer > intervalStrides = new ArrayList < > ( ) ; List < Integer > pointStrides = new ArrayList < > ( ) ; List < Integer > pointOffsets = new ArrayList < > ( ) ; int numPointIndexes = <int> ; int shapeIndex = <int> ; int strideIndex = <int> ; List < Integer > prependNewAxes = new ArrayList < > ( ) ; for ( int i = <int> ; i < indexes . length ; i + + ) { INDArrayIndex idx = indexes [ i ] ; if ( idx instanceof NDArrayIndexAll ) { encounteredAll = true ; if ( i < arr . rank ( ) & & arr . size ( i ) = = <int> ) oneDimensionWithAllEncountered . add ( i ) ; } if ( idx instanceof PointIndex ) { pointOffsets . add ( idx . offset ( ) ) ; pointStrides . add ( arr . stride ( strideIndex ) ) ; numPointIndexes + + ; shapeIndex + + ; strideIndex + + ; continue ; } else if ( idx instanceof NewAxis ) { if ( encounteredAll ) { prependNewAxes . add ( i ) ; } else newAxesPrepend + + ; continue ; } else if ( idx instanceof IntervalIndex & & ! ( idx instanceof NDArrayIndexAll ) | | idx instanceof SpecifiedIndex ) { if ( idx instanceof IntervalIndex ) { accumStrides . add ( arr . stride ( strideIndex ) * idx . stride ( ) ) ; intervalStrides . add ( idx . stride ( ) ) ; numIntervals + + ; } else accumStrides . add ( arr . stride ( strideIndex ) ) ; accumShape . add ( idx . length ( ) ) ; if ( idx instanceof IntervalIndex ) { accumOffsets . add ( idx . offset ( ) ) ; } else accumOffsets . add ( idx . offset ( ) ) ; shapeIndex + + ; strideIndex + + ; continue ; } accumShape . add ( shape [ shapeIndex + + ] ) ; accumStrides . add ( arr . stride ( strideIndex + + ) ) ; accumOffsets . add ( idx . offset ( ) ) ; } while ( shapeIndex < shape . length ) { if ( Shape . isVector ( shape ) ) { accumShape . add ( <int> ) ; shapeIndex + + ; } else accumShape . add ( shape [ shapeIndex + + ] ) ; } int delta = ( shape . length < = <int> ? shape . length : shape . length - numPointIndexes ) ; boolean needsFilledIn = accumShape . size ( ) ! = accumStrides . size ( ) & & accumOffsets . size ( ) ! = accumShape . size ( ) ; while ( accumOffsets . size ( ) < delta & & needsFilledIn ) accumOffsets . add ( <int> ) ; while ( accumShape . size ( ) < <int> ) { if ( Shape . isRowVectorShape ( arr . shape ( ) ) ) accumShape . add ( <int> , <int> ) ; else accumShape . add ( <int> ) ; } while ( strideIndex < accumShape . size ( ) ) { accumStrides . add ( arr . stride ( strideIndex + + ) ) ; } if ( newAxesPrepend > <int> ) { for ( int i = <int> ; i < newAxesPrepend ; i + + ) { accumShape . add ( <int> , <int> ) ; accumStrides . add ( <int> , <int> ) ; accumOffsets . add ( <int> , <int> ) ; } } int numAdded = <int> ; for ( int i = <int> ; i < prependNewAxes . size ( ) ; i + + ) { accumShape . add ( prependNewAxes . get ( i ) - numAdded , <int> ) ; accumStrides . add ( prependNewAxes . get ( i ) - numAdded , <int> ) ; numAdded + + ; } int trailingZeroRemove = accumOffsets . size ( ) - <int> ; while ( accumOffsets . size ( ) > accumShape . size ( ) ) { if ( accumOffsets . get ( trailingZeroRemove ) = = <int> ) accumOffsets . remove ( accumOffsets . size ( ) - <int> ) ; trailingZeroRemove - - ; } if ( accumStrides . size ( ) < accumOffsets . size ( ) ) accumStrides . addAll ( pointStrides ) ; while ( accumOffsets . size ( ) < accumShape . size ( ) ) { if ( Shape . isRowVectorShape ( arr . shape ( ) ) ) accumOffsets . add ( <int> , <int> ) ; else accumOffsets . add ( <int> ) ; } if ( Shape . isMatrix ( shape ) ) { if ( indexes [ <int> ] instanceof PointIndex & & indexes [ <int> ] instanceof NDArrayIndexAll ) Collections . reverse ( accumShape ) ; } this . shapes = Ints . toArray ( accumShape ) ; boolean isColumnVector = Shape . isColumnVectorShape ( this . shapes ) ; while ( accumStrides . size ( ) < accumOffsets . size ( ) ) { if ( ! isColumnVector ) accumStrides . add ( <int> , arr . elementStride ( ) ) ; else accumStrides . add ( arr . elementStride ( ) ) ; } this . strides = Ints . toArray ( accumStrides ) ; this . offsets = Ints . toArray ( accumOffsets ) ; if ( numPointIndexes > <int> & & ! pointStrides . isEmpty ( ) ) { if ( newAxesPrepend > = <int> ) { while ( pointStrides . size ( ) < accumOffsets . size ( ) ) { pointStrides . add ( <int> ) ; } for ( int i = <int> ; i < accumStrides . size ( ) ; i + + ) { if ( accumStrides . get ( i ) = = <int> ) pointStrides . set ( i , <int> ) ; } } while ( pointOffsets . size ( ) < pointStrides . size ( ) ) { pointOffsets . add ( <int> ) ; } if ( arr . isRowVector ( ) & & ! intervalStrides . isEmpty ( ) & & pointOffsets . get ( <int> ) = = <int> ) this . offset = indexes [ <int> ] . offset ( ) ; else this . offset = ArrayUtil . dotProduct ( pointOffsets , pointStrides ) ; } else if ( numIntervals > <int> & & arr . rank ( ) > <int> ) { if ( encounteredAll & & arr . size ( <int> ) ! = <int> ) this . offset = ArrayUtil . dotProduct ( accumOffsets , accumStrides ) ; else this . offset = ArrayUtil . dotProduct ( accumOffsets , accumStrides ) / numIntervals ; } else this . offset = ArrayUtil . calcOffset ( accumShape , accumOffsets , accumStrides ) ; } public INDArray getArr ( ) { return arr ; } public void setArr ( INDArray arr ) { this . arr = arr ; } public int [ ] getOffsets ( ) { return offsets ; } public void setOffsets ( int [ ] offsets ) { this . offsets = offsets ; } public int [ ] getShapes ( ) { return shapes ; } public void setShapes ( int [ ] shapes ) { this . shapes = shapes ; } public int [ ] getStrides ( ) { return strides ; } public void setStrides ( int [ ] strides ) { this . strides = strides ; } public int getOffset ( ) { return offset ; } public void setOffset ( int offset ) { this . offset = offset ; } } 
