package org . apache . cassandra . db . lifecycle ; import java . io . File ; import java . io . IOException ; import java . nio . file . Files ; import java . nio . file . NoSuchFileException ; import java . util . * ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . TimeUnit ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . util . concurrent . Runnables ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . SystemKeyspace ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . db . lifecycle . LogRecord . Type ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . SSTable ; import org . apache . cassandra . io . sstable . SnapshotDeletingTask ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . * ; import org . apache . cassandra . utils . concurrent . Ref ; import org . apache . cassandra . utils . concurrent . RefCounted ; import org . apache . cassandra . utils . concurrent . Transactional ; class LogTransaction extends Transactional . AbstractTransactional implements Transactional { private static final Logger logger = LoggerFactory . getLogger ( LogTransaction . class ) ; public static final class CorruptTransactionLogException extends RuntimeException { public final LogFile txnFile ; public CorruptTransactionLogException ( String message , LogFile txnFile ) { super ( message ) ; this . txnFile = txnFile ; } } private final Tracker tracker ; private final LogFile txnFile ; private final Ref < LogTransaction > selfRef ; private static final Queue < Runnable > failedDeletions = new ConcurrentLinkedQueue < > ( ) ; LogTransaction ( OperationType opType ) { this ( opType , null ) ; } LogTransaction ( OperationType opType , Tracker tracker ) { this . tracker = tracker ; this . txnFile = new LogFile ( opType , UUIDGen . getTimeUUID ( ) ) ; this . selfRef = new Ref < > ( this , new TransactionTidier ( txnFile ) ) ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , txnFile . id ( ) ) ; } void trackNew ( SSTable table ) { txnFile . add ( Type . ADD , table ) ; } void untrackNew ( SSTable table ) { txnFile . remove ( Type . ADD , table ) ; } SSTableTidier obsoleted ( SSTableReader reader ) { if ( txnFile . contains ( Type . ADD , reader ) ) { if ( txnFile . contains ( Type . REMOVE , reader ) ) throw new IllegalArgumentException ( ) ; return new SSTableTidier ( reader , true , this ) ; } txnFile . add ( Type . REMOVE , reader ) ; if ( tracker ! = null ) tracker . notifyDeleting ( reader ) ; return new SSTableTidier ( reader , false , this ) ; } OperationType type ( ) { return txnFile . type ( ) ; } UUID id ( ) { return txnFile . id ( ) ; } @VisibleForTesting LogFile txnFile ( ) { return txnFile ; } @VisibleForTesting List < File > logFiles ( ) { return txnFile . getFiles ( ) ; } @VisibleForTesting List < String > logFilePaths ( ) { return txnFile . getFilePaths ( ) ; } static void delete ( File file ) { try { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , file ) ; Files . delete ( file . toPath ( ) ) ; } catch ( NoSuchFileException e ) { logger . error ( <str> , file ) ; } catch ( IOException e ) { logger . error ( <str> , file , e ) ; throw new RuntimeException ( e ) ; } } private static class TransactionTidier implements RefCounted . Tidy , Runnable { private final LogFile data ; TransactionTidier ( LogFile data ) { this . data = data ; } public void tidy ( ) throws Exception { run ( ) ; } public String name ( ) { return data . toString ( ) ; } public void run ( ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , name ( ) ) ; if ( ! data . completed ( ) ) { logger . error ( <str> , data ) ; Throwable err = Throwables . perform ( ( Throwable ) null , data : : abort ) ; if ( err ! = null ) logger . error ( <str> , data , err ) ; } Throwable err = data . removeUnfinishedLeftovers ( null ) ; if ( err ! = null ) { logger . info ( <str> , name ( ) , err ) ; failedDeletions . add ( this ) ; } else { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , name ( ) ) ; data . close ( ) ; } } } static class Obsoletion { final SSTableReader reader ; final SSTableTidier tidier ; Obsoletion ( SSTableReader reader , SSTableTidier tidier ) { this . reader = reader ; this . tidier = tidier ; } } public static class SSTableTidier implements Runnable { private final Descriptor desc ; private final long sizeOnDisk ; private final Tracker tracker ; private final boolean wasNew ; private final Ref < LogTransaction > parentRef ; public SSTableTidier ( SSTableReader referent , boolean wasNew , LogTransaction parent ) { this . desc = referent . descriptor ; this . sizeOnDisk = referent . bytesOnDisk ( ) ; this . tracker = parent . tracker ; this . wasNew = wasNew ; this . parentRef = parent . selfRef . tryRef ( ) ; } public void run ( ) { SystemKeyspace . clearSSTableReadMeter ( desc . ksname , desc . cfname , desc . generation ) ; try { File datafile = new File ( desc . filenameFor ( Component . DATA ) ) ; delete ( datafile ) ; SSTable . delete ( desc , SSTable . discoverComponentsFor ( desc ) ) ; } catch ( Throwable t ) { logger . error ( <str> , desc ) ; failedDeletions . add ( this ) ; return ; } if ( tracker ! = null & & tracker . cfstore ! = null & & ! wasNew ) tracker . cfstore . metric . totalDiskSpaceUsed . dec ( sizeOnDisk ) ; parentRef . release ( ) ; } public void abort ( ) { parentRef . release ( ) ; } } static void rescheduleFailedDeletions ( ) { Runnable task ; while ( null ! = ( task = failedDeletions . poll ( ) ) ) ScheduledExecutors . nonPeriodicTasks . submit ( task ) ; SnapshotDeletingTask . rescheduleFailedTasks ( ) ; } static void waitForDeletions ( ) { FBUtilities . waitOnFuture ( ScheduledExecutors . nonPeriodicTasks . schedule ( Runnables . doNothing ( ) , <int> , TimeUnit . MILLISECONDS ) ) ; } @VisibleForTesting Throwable complete ( Throwable accumulate ) { try { accumulate = selfRef . ensureReleased ( accumulate ) ; return accumulate ; } catch ( Throwable t ) { logger . error ( <str> , id ( ) , t ) ; return Throwables . merge ( accumulate , t ) ; } } protected Throwable doCommit ( Throwable accumulate ) { return complete ( Throwables . perform ( accumulate , txnFile : : commit ) ) ; } protected Throwable doAbort ( Throwable accumulate ) { return complete ( Throwables . perform ( accumulate , txnFile : : abort ) ) ; } protected void doPrepare ( ) { } static void removeUnfinishedLeftovers ( CFMetaData metadata ) { removeUnfinishedLeftovers ( new Directories ( metadata ) . getCFDirectories ( ) ) ; } @VisibleForTesting static void removeUnfinishedLeftovers ( List < File > folders ) { LogFilesByName logFiles = new LogFilesByName ( ) ; folders . forEach ( logFiles : : list ) ; logFiles . removeUnfinishedLeftovers ( ) ; } private static final class LogFilesByName { Map < String , List < File > > files = new HashMap < > ( ) ; void list ( File folder ) { Arrays . stream ( folder . listFiles ( LogFile : : isLogFile ) ) . forEach ( this : : add ) ; } void add ( File file ) { List < File > filesByName = files . get ( file . getName ( ) ) ; if ( filesByName = = null ) { filesByName = new ArrayList < > ( ) ; files . put ( file . getName ( ) , filesByName ) ; } filesByName . add ( file ) ; } void removeUnfinishedLeftovers ( ) { files . forEach ( LogFilesByName : : removeUnfinishedLeftovers ) ; } static void removeUnfinishedLeftovers ( String name , List < File > logFiles ) { LogFile txn = LogFile . make ( name , logFiles ) ; try { if ( txn . verify ( ) ) { Throwable failure = txn . removeUnfinishedLeftovers ( null ) ; if ( failure ! = null ) logger . error ( <str> , txn , failure ) ; } else { logger . error ( <str> , txn ) ; } } finally { txn . close ( ) ; } } } } 
