package io . netty . buffer ; final class PoolChunk < T > implements PoolChunkMetric { final PoolArena < T > arena ; final T memory ; final boolean unpooled ; private final byte [ ] memoryMap ; private final byte [ ] depthMap ; private final PoolSubpage < T > [ ] subpages ; private final int subpageOverflowMask ; private final int pageSize ; private final int pageShifts ; private final int maxOrder ; private final int chunkSize ; private final int log2ChunkSize ; private final int maxSubpageAllocs ; private final byte unusable ; private int freeBytes ; PoolChunkList < T > parent ; PoolChunk < T > prev ; PoolChunk < T > next ; PoolChunk ( PoolArena < T > arena , T memory , int pageSize , int maxOrder , int pageShifts , int chunkSize ) { unpooled = false ; this . arena = arena ; this . memory = memory ; this . pageSize = pageSize ; this . pageShifts = pageShifts ; this . maxOrder = maxOrder ; this . chunkSize = chunkSize ; unusable = ( byte ) ( maxOrder + <int> ) ; log2ChunkSize = log2 ( chunkSize ) ; subpageOverflowMask = ~ ( pageSize - <int> ) ; freeBytes = chunkSize ; assert maxOrder < <int> : <str> + maxOrder ; maxSubpageAllocs = <int> < < maxOrder ; memoryMap = new byte [ maxSubpageAllocs < < <int> ] ; depthMap = new byte [ memoryMap . length ] ; int memoryMapIndex = <int> ; for ( int d = <int> ; d < = maxOrder ; + + d ) { int depth = <int> < < d ; for ( int p = <int> ; p < depth ; + + p ) { memoryMap [ memoryMapIndex ] = ( byte ) d ; depthMap [ memoryMapIndex ] = ( byte ) d ; memoryMapIndex + + ; } } subpages = newSubpageArray ( maxSubpageAllocs ) ; } PoolChunk ( PoolArena < T > arena , T memory , int size ) { unpooled = true ; this . arena = arena ; this . memory = memory ; memoryMap = null ; depthMap = null ; subpages = null ; subpageOverflowMask = <int> ; pageSize = <int> ; pageShifts = <int> ; maxOrder = <int> ; unusable = ( byte ) ( maxOrder + <int> ) ; chunkSize = size ; log2ChunkSize = log2 ( chunkSize ) ; maxSubpageAllocs = <int> ; } @SuppressWarnings ( <str> ) private PoolSubpage < T > [ ] newSubpageArray ( int size ) { return new PoolSubpage [ size ] ; } @Override public int usage ( ) { final int freeBytes = this . freeBytes ; if ( freeBytes = = <int> ) { return <int> ; } int freePercentage = ( int ) ( freeBytes * <int> / chunkSize ) ; if ( freePercentage = = <int> ) { return <int> ; } return <int> - freePercentage ; } long allocate ( int normCapacity ) { if ( ( normCapacity & subpageOverflowMask ) ! = <int> ) { return allocateRun ( normCapacity ) ; } else { return allocateSubpage ( normCapacity ) ; } } private void updateParentsAlloc ( int id ) { while ( id > <int> ) { int parentId = id > > > <int> ; byte val1 = value ( id ) ; byte val2 = value ( id ^ <int> ) ; byte val = val1 < val2 ? val1 : val2 ; setValue ( parentId , val ) ; id = parentId ; } } private void updateParentsFree ( int id ) { int logChild = depth ( id ) + <int> ; while ( id > <int> ) { int parentId = id > > > <int> ; byte val1 = value ( id ) ; byte val2 = value ( id ^ <int> ) ; logChild - = <int> ; if ( val1 = = logChild & & val2 = = logChild ) { setValue ( parentId , ( byte ) ( logChild - <int> ) ) ; } else { byte val = val1 < val2 ? val1 : val2 ; setValue ( parentId , val ) ; } id = parentId ; } } private int allocateNode ( int d ) { int id = <int> ; int initial = - ( <int> < < d ) ; byte val = value ( id ) ; if ( val > d ) { return - <int> ; } while ( val < d | | ( id & initial ) = = <int> ) { id < < = <int> ; val = value ( id ) ; if ( val > d ) { id ^ = <int> ; val = value ( id ) ; } } byte value = value ( id ) ; assert value = = d & & ( id & initial ) = = <int> < < d : String . format ( <str> , value , id & initial , d ) ; setValue ( id , unusable ) ; updateParentsAlloc ( id ) ; return id ; } private long allocateRun ( int normCapacity ) { int d = maxOrder - ( log2 ( normCapacity ) - pageShifts ) ; int id = allocateNode ( d ) ; if ( id < <int> ) { return id ; } freeBytes - = runLength ( id ) ; return id ; } private long allocateSubpage ( int normCapacity ) { PoolSubpage < T > head = arena . findSubpagePoolHead ( normCapacity ) ; synchronized ( head ) { int d = maxOrder ; int id = allocateNode ( d ) ; if ( id < <int> ) { return id ; } final PoolSubpage < T > [ ] subpages = this . subpages ; final int pageSize = this . pageSize ; freeBytes - = pageSize ; int subpageIdx = subpageIdx ( id ) ; PoolSubpage < T > subpage = subpages [ subpageIdx ] ; if ( subpage = = null ) { subpage = new PoolSubpage < T > ( head , this , id , runOffset ( id ) , pageSize , normCapacity ) ; subpages [ subpageIdx ] = subpage ; } else { subpage . init ( head , normCapacity ) ; } return subpage . allocate ( ) ; } } void free ( long handle ) { int memoryMapIdx = ( int ) handle ; int bitmapIdx = ( int ) ( handle > > > Integer . SIZE ) ; if ( bitmapIdx ! = <int> ) { PoolSubpage < T > subpage = subpages [ subpageIdx ( memoryMapIdx ) ] ; assert subpage ! = null & & subpage . doNotDestroy ; PoolSubpage < T > head = arena . findSubpagePoolHead ( subpage . elemSize ) ; synchronized ( head ) { if ( subpage . free ( head , bitmapIdx & <hex> ) ) { return ; } } } freeBytes + = runLength ( memoryMapIdx ) ; setValue ( memoryMapIdx , depth ( memoryMapIdx ) ) ; updateParentsFree ( memoryMapIdx ) ; } void initBuf ( PooledByteBuf < T > buf , long handle , int reqCapacity ) { int memoryMapIdx = ( int ) handle ; int bitmapIdx = ( int ) ( handle > > > Integer . SIZE ) ; if ( bitmapIdx = = <int> ) { byte val = value ( memoryMapIdx ) ; assert val = = unusable : String . valueOf ( val ) ; buf . init ( this , handle , runOffset ( memoryMapIdx ) , reqCapacity , runLength ( memoryMapIdx ) , arena . parent . threadCache ( ) ) ; } else { initBufWithSubpage ( buf , handle , bitmapIdx , reqCapacity ) ; } } void initBufWithSubpage ( PooledByteBuf < T > buf , long handle , int reqCapacity ) { initBufWithSubpage ( buf , handle , ( int ) ( handle > > > Integer . SIZE ) , reqCapacity ) ; } private void initBufWithSubpage ( PooledByteBuf < T > buf , long handle , int bitmapIdx , int reqCapacity ) { assert bitmapIdx ! = <int> ; int memoryMapIdx = ( int ) handle ; PoolSubpage < T > subpage = subpages [ subpageIdx ( memoryMapIdx ) ] ; assert subpage . doNotDestroy ; assert reqCapacity < = subpage . elemSize ; buf . init ( this , handle , runOffset ( memoryMapIdx ) + ( bitmapIdx & <hex> ) * subpage . elemSize , reqCapacity , subpage . elemSize , arena . parent . threadCache ( ) ) ; } private byte value ( int id ) { return memoryMap [ id ] ; } private void setValue ( int id , byte val ) { memoryMap [ id ] = val ; } private byte depth ( int id ) { return depthMap [ id ] ; } private static int log2 ( int val ) { return Integer . SIZE - <int> - Integer . numberOfLeadingZeros ( val ) ; } private int runLength ( int id ) { return <int> < < log2ChunkSize - depth ( id ) ; } private int runOffset ( int id ) { int shift = id ^ <int> < < depth ( id ) ; return shift * runLength ( id ) ; } private int subpageIdx ( int memoryMapIdx ) { return memoryMapIdx ^ maxSubpageAllocs ; } @Override public int chunkSize ( ) { return chunkSize ; } @Override public int freeBytes ( ) { return freeBytes ; } @Override public String toString ( ) { return new StringBuilder ( ) . append ( <str> ) . append ( Integer . toHexString ( System . identityHashCode ( this ) ) ) . append ( <str> ) . append ( usage ( ) ) . append ( <str> ) . append ( chunkSize - freeBytes ) . append ( <str> ) . append ( chunkSize ) . append ( <str> ) . toString ( ) ; } } 
