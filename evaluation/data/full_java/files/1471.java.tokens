package org . apache . cassandra . db . commitlog ; import static junit . framework . Assert . assertTrue ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; import static org . junit . Assert . assertEquals ; import java . io . ByteArrayOutputStream ; import java . io . DataOutputStream ; import java . io . File ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . util . HashMap ; import java . util . Map ; import java . util . UUID ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutionException ; import java . util . zip . CRC32 ; import java . util . zip . Checksum ; import com . google . common . collect . ImmutableMap ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . Mutation ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . db . marshal . BytesType ; import org . junit . * ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . Config . CommitFailurePolicy ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . config . ParameterizedClass ; import org . apache . cassandra . db . commitlog . CommitLog ; import org . apache . cassandra . db . commitlog . CommitLogDescriptor ; import org . apache . cassandra . db . commitlog . ReplayPosition ; import org . apache . cassandra . db . commitlog . CommitLogSegment ; import org . apache . cassandra . db . commitlog . CommitLogReplayer . CommitLogReplayException ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . JVMStabilityInspector ; import org . apache . cassandra . utils . KillerForTests ; import org . apache . cassandra . utils . vint . VIntCoding ; public class CommitLogTest { private static final String KEYSPACE1 = <str> ; private static final String KEYSPACE2 = <str> ; private static final String STANDARD1 = <str> ; private static final String STANDARD2 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , STANDARD1 , <int> , AsciiType . instance , BytesType . instance ) , SchemaLoader . standardCFMD ( KEYSPACE1 , STANDARD2 , <int> , AsciiType . instance , BytesType . instance ) ) ; SchemaLoader . createKeyspace ( KEYSPACE2 , KeyspaceParams . simpleTransient ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , STANDARD1 , <int> , AsciiType . instance , BytesType . instance ) , SchemaLoader . standardCFMD ( KEYSPACE1 , STANDARD2 , <int> , AsciiType . instance , BytesType . instance ) ) ; CompactionManager . instance . disableAutoCompaction ( ) ; } @Test public void testRecoveryWithEmptyLog ( ) throws Exception { runExpecting ( ( ) - > { CommitLog . instance . recover ( new File [ ] { tmpFile ( CommitLogDescriptor . current_version ) } ) ; return null ; } , CommitLogReplayException . class ) ; } @Test public void testRecoveryWithEmptyLog20 ( ) throws Exception { CommitLog . instance . recover ( new File [ ] { tmpFile ( CommitLogDescriptor . VERSION_20 ) } ) ; } @Test public void testRecoveryWithZeroLog ( ) throws Exception { testRecovery ( new byte [ <int> ] , null ) ; } @Test public void testRecoveryWithShortLog ( ) throws Exception { testRecoveryWithBadSizeArgument ( <int> , <int> ) ; } @Test public void testRecoveryWithShortSize ( ) throws Exception { runExpecting ( ( ) - > { testRecovery ( new byte [ <int> ] , CommitLogDescriptor . VERSION_20 ) ; return null ; } , CommitLogReplayException . class ) ; } @Test public void testRecoveryWithShortCheckSum ( ) throws Exception { byte [ ] data = new byte [ <int> ] ; data [ <int> ] = <int> ; testRecovery ( data , CommitLogReplayException . class ) ; } @Test public void testRecoveryWithShortMutationSize ( ) throws Exception { testRecoveryWithBadSizeArgument ( <int> , <int> ) ; } private void testRecoveryWithGarbageLog ( ) throws Exception { byte [ ] garbage = new byte [ <int> ] ; ( new java . util . Random ( ) ) . nextBytes ( garbage ) ; testRecovery ( garbage , CommitLogDescriptor . current_version ) ; } @Test public void testRecoveryWithGarbageLog_fail ( ) throws Exception { runExpecting ( ( ) - > { testRecoveryWithGarbageLog ( ) ; return null ; } , CommitLogReplayException . class ) ; } @Test public void testRecoveryWithGarbageLog_ignoredByProperty ( ) throws Exception { try { System . setProperty ( CommitLogReplayer . IGNORE_REPLAY_ERRORS_PROPERTY , <str> ) ; testRecoveryWithGarbageLog ( ) ; } finally { System . clearProperty ( CommitLogReplayer . IGNORE_REPLAY_ERRORS_PROPERTY ) ; } } @Test public void testRecoveryWithBadSizeChecksum ( ) throws Exception { Checksum checksum = new CRC32 ( ) ; checksum . update ( <int> ) ; testRecoveryWithBadSizeArgument ( <int> , <int> , ~ checksum . getValue ( ) ) ; } @Test public void testRecoveryWithNegativeSizeArgument ( ) throws Exception { testRecoveryWithBadSizeArgument ( - <int> , <int> ) ; } @Test public void testDontDeleteIfDirty ( ) throws Exception { CommitLog . instance . resetUnsafe ( true ) ; ColumnFamilyStore cfs1 = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STANDARD1 ) ; ColumnFamilyStore cfs2 = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STANDARD2 ) ; Mutation m = new RowUpdateBuilder ( cfs1 . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBuffer . allocate ( DatabaseDescriptor . getCommitLogSegmentSize ( ) / <int> ) ) . build ( ) ; CommitLog . instance . add ( m ) ; CommitLog . instance . add ( m ) ; CommitLog . instance . add ( m ) ; CommitLog . instance . add ( m ) ; CommitLog . instance . add ( m ) ; Mutation m2 = new RowUpdateBuilder ( cfs2 . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBuffer . allocate ( <int> ) ) . build ( ) ; CommitLog . instance . add ( m2 ) ; assert CommitLog . instance . activeSegments ( ) = = <int> : <str> + CommitLog . instance . activeSegments ( ) ; UUID cfid2 = m2 . getColumnFamilyIds ( ) . iterator ( ) . next ( ) ; CommitLog . instance . discardCompletedSegments ( cfid2 , CommitLog . instance . getContext ( ) ) ; assert CommitLog . instance . activeSegments ( ) = = <int> : <str> + CommitLog . instance . activeSegments ( ) ; } @Test public void testDeleteIfNotDirty ( ) throws Exception { DatabaseDescriptor . getCommitLogSegmentSize ( ) ; CommitLog . instance . resetUnsafe ( true ) ; ColumnFamilyStore cfs1 = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STANDARD1 ) ; ColumnFamilyStore cfs2 = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STANDARD2 ) ; Mutation rm = new RowUpdateBuilder ( cfs1 . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBuffer . allocate ( ( DatabaseDescriptor . getCommitLogSegmentSize ( ) / <int> ) - <int> ) ) . build ( ) ; CommitLog . instance . add ( rm ) ; CommitLog . instance . add ( rm ) ; assert CommitLog . instance . activeSegments ( ) = = <int> : <str> + CommitLog . instance . activeSegments ( ) ; UUID cfid1 = rm . getColumnFamilyIds ( ) . iterator ( ) . next ( ) ; CommitLog . instance . sync ( true ) ; CommitLog . instance . discardCompletedSegments ( cfid1 , CommitLog . instance . getContext ( ) ) ; assert CommitLog . instance . activeSegments ( ) = = <int> : <str> + CommitLog . instance . activeSegments ( ) ; Mutation rm2 = new RowUpdateBuilder ( cfs2 . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBuffer . allocate ( DatabaseDescriptor . getMaxMutationSize ( ) - <int> ) ) . build ( ) ; CommitLog . instance . add ( rm2 ) ; CommitLog . instance . add ( rm2 ) ; CommitLog . instance . add ( rm2 ) ; assert CommitLog . instance . activeSegments ( ) = = <int> : <str> + CommitLog . instance . activeSegments ( ) ; UUID cfid2 = rm2 . getColumnFamilyIds ( ) . iterator ( ) . next ( ) ; CommitLog . instance . discardCompletedSegments ( cfid2 , CommitLog . instance . getContext ( ) ) ; assert CommitLog . instance . activeSegments ( ) = = <int> : <str> + CommitLog . instance . activeSegments ( ) ; } private static int getMaxRecordDataSize ( String keyspace , ByteBuffer key , String cfName , String colName ) { ColumnFamilyStore cfs = Keyspace . open ( keyspace ) . getColumnFamilyStore ( cfName ) ; int allocSize = <int> ; Mutation rm = new RowUpdateBuilder ( cfs . metadata , <int> , key ) . clustering ( colName ) . add ( <str> , ByteBuffer . allocate ( allocSize ) ) . build ( ) ; int max = DatabaseDescriptor . getMaxMutationSize ( ) ; max - = CommitLogSegment . ENTRY_OVERHEAD_SIZE ; int mutationOverhead = ( int ) Mutation . serializer . serializedSize ( rm , MessagingService . current_version ) - ( VIntCoding . computeVIntSize ( allocSize ) + allocSize ) ; max - = mutationOverhead ; int sizeOfMax = VIntCoding . computeVIntSize ( max ) ; max - = sizeOfMax ; assert VIntCoding . computeVIntSize ( max ) = = sizeOfMax ; return max ; } private static int getMaxRecordDataSize ( ) { return getMaxRecordDataSize ( KEYSPACE1 , bytes ( <str> ) , STANDARD1 , <str> ) ; } @Test public void testEqualRecordLimit ( ) throws Exception { CommitLog . instance . resetUnsafe ( true ) ; ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STANDARD1 ) ; Mutation rm = new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBuffer . allocate ( getMaxRecordDataSize ( ) ) ) . build ( ) ; CommitLog . instance . add ( rm ) ; } @Test public void testExceedRecordLimit ( ) throws Exception { CommitLog . instance . resetUnsafe ( true ) ; ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STANDARD1 ) ; try { Mutation rm = new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBuffer . allocate ( <int> + getMaxRecordDataSize ( ) ) ) . build ( ) ; CommitLog . instance . add ( rm ) ; throw new AssertionError ( <str> ) ; } catch ( IllegalArgumentException e ) { } } protected void testRecoveryWithBadSizeArgument ( int size , int dataSize ) throws Exception { Checksum checksum = new CRC32 ( ) ; checksum . update ( size ) ; testRecoveryWithBadSizeArgument ( size , dataSize , checksum . getValue ( ) ) ; } protected void testRecoveryWithBadSizeArgument ( int size , int dataSize , long checksum ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; DataOutputStream dout = new DataOutputStream ( out ) ; dout . writeInt ( size ) ; dout . writeLong ( checksum ) ; dout . write ( new byte [ dataSize ] ) ; dout . close ( ) ; testRecovery ( out . toByteArray ( ) , CommitLogReplayException . class ) ; } protected File tmpFile ( int version ) throws IOException { File logFile = File . createTempFile ( <str> + version + <str> , <str> ) ; logFile . deleteOnExit ( ) ; assert logFile . length ( ) = = <int> ; return logFile ; } protected Void testRecovery ( byte [ ] logData , int version ) throws Exception { File logFile = tmpFile ( version ) ; try ( OutputStream lout = new FileOutputStream ( logFile ) ) { lout . write ( logData ) ; CommitLog . instance . recover ( logFile . getPath ( ) ) ; } return null ; } protected Void testRecovery ( CommitLogDescriptor desc , byte [ ] logData ) throws Exception { File logFile = tmpFile ( desc . version ) ; CommitLogDescriptor fromFile = CommitLogDescriptor . fromFileName ( logFile . getName ( ) ) ; desc = new CommitLogDescriptor ( desc . version , fromFile . id , desc . compression ) ; ByteBuffer buf = ByteBuffer . allocate ( <int> ) ; CommitLogDescriptor . writeHeader ( buf , desc ) ; try ( OutputStream lout = new FileOutputStream ( logFile ) ) { lout . write ( buf . array ( ) , <int> , buf . position ( ) ) ; lout . write ( logData ) ; CommitLog . instance . recover ( logFile . getPath ( ) ) ; } return null ; } @Test public void testRecoveryWithIdMismatch ( ) throws Exception { CommitLogDescriptor desc = new CommitLogDescriptor ( <int> , null ) ; File logFile = tmpFile ( desc . version ) ; ByteBuffer buf = ByteBuffer . allocate ( <int> ) ; CommitLogDescriptor . writeHeader ( buf , desc ) ; try ( OutputStream lout = new FileOutputStream ( logFile ) ) { lout . write ( buf . array ( ) , <int> , buf . position ( ) ) ; runExpecting ( ( ) - > { CommitLog . instance . recover ( logFile . getPath ( ) ) ; return null ; } , CommitLogReplayException . class ) ; } } @Test public void testRecoveryWithBadCompressor ( ) throws Exception { CommitLogDescriptor desc = new CommitLogDescriptor ( <int> , new ParameterizedClass ( <str> , null ) ) ; runExpecting ( ( ) - > { testRecovery ( desc , new byte [ <int> ] ) ; return null ; } , CommitLogReplayException . class ) ; } protected void runExpecting ( Callable < Void > r , Class < ? > expected ) { JVMStabilityInspector . Killer originalKiller ; KillerForTests killerForTests ; killerForTests = new KillerForTests ( ) ; originalKiller = JVMStabilityInspector . replaceKiller ( killerForTests ) ; Throwable caught = null ; try { r . call ( ) ; } catch ( Throwable t ) { if ( expected ! = t . getClass ( ) ) throw new AssertionError ( <str> + expected + <str> + t , t ) ; caught = t ; } if ( expected ! = null & & caught = = null ) Assert . fail ( <str> + expected + <str> ) ; JVMStabilityInspector . replaceKiller ( originalKiller ) ; assertEquals ( <str> , expected ! = null , killerForTests . wasKilled ( ) ) ; } protected void testRecovery ( final byte [ ] logData , Class < ? > expected ) throws Exception { runExpecting ( ( ) - > testRecovery ( logData , CommitLogDescriptor . VERSION_20 ) , expected ) ; runExpecting ( ( ) - > testRecovery ( new CommitLogDescriptor ( <int> , null ) , logData ) , expected ) ; } @Test public void testVersions ( ) { Assert . assertTrue ( CommitLogDescriptor . isValid ( <str> ) ) ; Assert . assertTrue ( CommitLogDescriptor . isValid ( <str> ) ) ; Assert . assertFalse ( CommitLogDescriptor . isValid ( <str> ) ) ; Assert . assertFalse ( CommitLogDescriptor . isValid ( <str> ) ) ; Assert . assertFalse ( CommitLogDescriptor . isValid ( <str> ) ) ; assertEquals ( <int> , CommitLogDescriptor . fromFileName ( <str> ) . id ) ; assertEquals ( MessagingService . current_version , new CommitLogDescriptor ( <int> , null ) . getMessagingVersion ( ) ) ; String newCLName = <str> + CommitLogDescriptor . current_version + <str> ; assertEquals ( MessagingService . current_version , CommitLogDescriptor . fromFileName ( newCLName ) . getMessagingVersion ( ) ) ; } @Test public void testTruncateWithoutSnapshot ( ) throws ExecutionException , InterruptedException , IOException { boolean originalState = DatabaseDescriptor . isAutoSnapshot ( ) ; try { CommitLog . instance . resetUnsafe ( true ) ; boolean prev = DatabaseDescriptor . isAutoSnapshot ( ) ; DatabaseDescriptor . setAutoSnapshot ( false ) ; ColumnFamilyStore cfs1 = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STANDARD1 ) ; ColumnFamilyStore cfs2 = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( STANDARD2 ) ; new RowUpdateBuilder ( cfs1 . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBuffer . allocate ( <int> ) ) . build ( ) . applyUnsafe ( ) ; cfs1 . truncateBlocking ( ) ; DatabaseDescriptor . setAutoSnapshot ( prev ) ; Mutation m2 = new RowUpdateBuilder ( cfs2 . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBuffer . allocate ( DatabaseDescriptor . getCommitLogSegmentSize ( ) / <int> ) ) . build ( ) ; for ( int i = <int> ; i < <int> ; i + + ) CommitLog . instance . add ( m2 ) ; assertEquals ( <int> , CommitLog . instance . activeSegments ( ) ) ; ReplayPosition position = CommitLog . instance . getContext ( ) ; for ( Keyspace ks : Keyspace . system ( ) ) for ( ColumnFamilyStore syscfs : ks . getColumnFamilyStores ( ) ) CommitLog . instance . discardCompletedSegments ( syscfs . metadata . cfId , position ) ; CommitLog . instance . discardCompletedSegments ( cfs2 . metadata . cfId , position ) ; assertEquals ( <int> , CommitLog . instance . activeSegments ( ) ) ; } finally { DatabaseDescriptor . setAutoSnapshot ( originalState ) ; } } @Test public void testTruncateWithoutSnapshotNonDurable ( ) throws IOException { CommitLog . instance . resetUnsafe ( true ) ; boolean originalState = DatabaseDescriptor . getAutoSnapshot ( ) ; try { DatabaseDescriptor . setAutoSnapshot ( false ) ; Keyspace notDurableKs = Keyspace . open ( KEYSPACE2 ) ; Assert . assertFalse ( notDurableKs . getMetadata ( ) . params . durableWrites ) ; ColumnFamilyStore cfs = notDurableKs . getColumnFamilyStore ( <str> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . bytes ( <str> ) ) . build ( ) . applyUnsafe ( ) ; assertTrue ( Util . getOnlyRow ( Util . cmd ( cfs ) . columns ( <str> ) . build ( ) ) . cells ( ) . iterator ( ) . next ( ) . value ( ) . equals ( ByteBufferUtil . bytes ( <str> ) ) ) ; cfs . truncateBlocking ( ) ; Util . assertEmpty ( Util . cmd ( cfs ) . columns ( <str> ) . build ( ) ) ; } finally { DatabaseDescriptor . setAutoSnapshot ( originalState ) ; } } private void testDescriptorPersistence ( CommitLogDescriptor desc ) throws IOException { ByteBuffer buf = ByteBuffer . allocate ( <int> ) ; CommitLogDescriptor . writeHeader ( buf , desc ) ; buf . putDouble ( <float> ) ; buf . flip ( ) ; DataInputBuffer input = new DataInputBuffer ( buf , false ) ; CommitLogDescriptor read = CommitLogDescriptor . readHeader ( input ) ; Assert . assertEquals ( <str> , desc , read ) ; } @Test public void testDescriptorPersistence ( ) throws IOException { testDescriptorPersistence ( new CommitLogDescriptor ( <int> , null ) ) ; testDescriptorPersistence ( new CommitLogDescriptor ( CommitLogDescriptor . VERSION_21 , <int> , null ) ) ; testDescriptorPersistence ( new CommitLogDescriptor ( CommitLogDescriptor . VERSION_30 , <int> , null ) ) ; testDescriptorPersistence ( new CommitLogDescriptor ( CommitLogDescriptor . VERSION_30 , <int> , new ParameterizedClass ( <str> , null ) ) ) ; testDescriptorPersistence ( new CommitLogDescriptor ( CommitLogDescriptor . VERSION_30 , <int> , new ParameterizedClass ( <str> , ImmutableMap . of ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ) ) ; } @Test public void testDescriptorInvalidParametersSize ( ) throws IOException { Map < String , String > params = new HashMap < > ( ) ; for ( int i = <int> ; i < <int> ; + + i ) params . put ( <str> + i , Integer . toString ( i , <int> ) ) ; try { CommitLogDescriptor desc = new CommitLogDescriptor ( CommitLogDescriptor . VERSION_30 , <int> , new ParameterizedClass ( <str> , params ) ) ; ByteBuffer buf = ByteBuffer . allocate ( <int> ) ; CommitLogDescriptor . writeHeader ( buf , desc ) ; Assert . fail ( <str> ) ; } catch ( ConfigurationException e ) { } } } 
