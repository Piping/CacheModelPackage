package org . elasticsearch . search . suggest ; import com . carrotsearch . randomizedtesting . generators . RandomStrings ; import org . apache . lucene . util . LuceneTestCase . SuppressCodecs ; import org . apache . lucene . util . GeoHashUtils ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . suggest . SuggestResponse ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . suggest . CompletionSuggestSearchIT . CompletionMappingBuilder ; import org . elasticsearch . search . suggest . completion . CompletionSuggestionBuilder ; import org . elasticsearch . search . suggest . completion . context . * ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . * ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; @SuppressCodecs ( <str> ) public class ContextCompletionSuggestSearchIT extends ESIntegTestCase { private final String INDEX = RandomStrings . randomAsciiOfLength ( getRandom ( ) , <int> ) . toLowerCase ( Locale . ROOT ) ; private final String TYPE = RandomStrings . randomAsciiOfLength ( getRandom ( ) , <int> ) . toLowerCase ( Locale . ROOT ) ; private final String FIELD = RandomStrings . randomAsciiOfLength ( getRandom ( ) , <int> ) . toLowerCase ( Locale . ROOT ) ; @Override protected int numberOfReplicas ( ) { return <int> ; } public void testContextPrefix ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; boolean addAnotherContext = randomBoolean ( ) ; if ( addAnotherContext ) { map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; } final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . endObject ( ) . field ( <str> , <str> + i % <int> ) ; if ( addAnotherContext ) { source . field ( <str> , <str> + i % <int> ) ; } source . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testContextRegex ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; boolean addAnotherContext = randomBoolean ( ) ; if ( addAnotherContext ) { map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; } final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i + <str> ) . field ( <str> , i + <int> ) . endObject ( ) . field ( <str> , <str> + i % <int> ) ; if ( addAnotherContext ) { source . field ( <str> , <str> + i % <int> ) ; } source . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . regex ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testContextFuzzy ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; boolean addAnotherContext = randomBoolean ( ) ; if ( addAnotherContext ) { map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; } final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . endObject ( ) . field ( <str> , <str> + i % <int> ) ; if ( addAnotherContext ) { source . field ( <str> , <str> + i % <int> ) ; } source . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> , Fuzziness . ONE ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testSingleContextFiltering ( ) throws Exception { CategoryContextMapping contextMapping = ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ; LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < String , ContextMapping > ( Collections . singletonMap ( <str> , contextMapping ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . endObject ( ) . field ( <str> , <str> + i % <int> ) . endObject ( ) ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testSingleContextBoosting ( ) throws Exception { CategoryContextMapping contextMapping = ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ; LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < String , ContextMapping > ( Collections . singletonMap ( <str> , contextMapping ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . endObject ( ) . field ( <str> , <str> + i % <int> ) . endObject ( ) ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testSingleContextMultipleContexts ( ) throws Exception { CategoryContextMapping contextMapping = ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ; LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < String , ContextMapping > ( Collections . singletonMap ( <str> , contextMapping ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < String > contexts = Arrays . asList ( <str> , <str> , <str> , <str> ) ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . endObject ( ) . field ( <str> , contexts ) . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testMultiContextFiltering ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . endObject ( ) . field ( <str> , <str> + i % <int> ) . field ( <str> , <str> + i % <int> ) . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder catFilterSuggest = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; catFilterSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; assertSuggestions ( <str> , catFilterSuggest , <str> , <str> , <str> , <str> , <str> ) ; CompletionSuggestionBuilder typeFilterSuggest = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; typeFilterSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; assertSuggestions ( <str> , typeFilterSuggest , <str> , <str> , <str> , <str> , <str> ) ; CompletionSuggestionBuilder multiContextFilterSuggest = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; if ( randomBoolean ( ) ) { multiContextFilterSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; multiContextFilterSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; } else { multiContextFilterSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; multiContextFilterSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; } assertSuggestions ( <str> , multiContextFilterSuggest , <str> , <str> ) ; } @AwaitsFix ( bugUrl = <str> ) public void testMultiContextBoosting ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . endObject ( ) . field ( <str> , <str> + i % <int> ) . field ( <str> , <str> + i % <int> ) . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder catBoostSuggest = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; catBoostSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; assertSuggestions ( <str> , catBoostSuggest , <str> , <str> , <str> , <str> , <str> ) ; CompletionSuggestionBuilder typeBoostSuggest = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; typeBoostSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) ) ; assertSuggestions ( <str> , typeBoostSuggest , <str> , <str> , <str> , <str> , <str> ) ; CompletionSuggestionBuilder multiContextBoostSuggest = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; if ( randomBoolean ( ) ) { multiContextBoostSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) ) ; multiContextBoostSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; } else { multiContextBoostSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . build ( ) ) ; multiContextBoostSuggest . categoryContexts ( <str> , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) , CategoryQueryContext . builder ( ) . setCategory ( <str> ) . setBoost ( <int> ) . build ( ) ) ; } assertSuggestions ( <str> , multiContextBoostSuggest , <str> , <str> , <str> , <str> , <str> ) ; } public void testMissingContextValue ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; map . put ( <str> , ContextBuilder . category ( <str> ) . field ( <str> ) . build ( ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . endObject ( ) ; if ( randomBoolean ( ) ) { source . field ( <str> , <str> + i % <int> ) ; } if ( randomBoolean ( ) ) { source . field ( <str> , <str> + i % <int> ) ; } source . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testSeveralContexts ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; final int numContexts = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numContexts ; i + + ) { map . put ( <str> + i , ContextBuilder . category ( <str> + i ) . field ( <str> + i ) . build ( ) ) ; } final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , numDocs - i ) . endObject ( ) ; for ( int c = <int> ; c < numContexts ; c + + ) { source . field ( <str> + c , <str> + c + i % <int> ) ; } source . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testSimpleGeoPrefix ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . geo ( <str> ) . build ( ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . startObject ( <str> ) . field ( <str> , GeoHashUtils . stringEncode ( <float> , <float> ) ) . endObject ( ) . endObject ( ) . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testGeoFiltering ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . geo ( <str> ) . build ( ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; GeoPoint [ ] geoPoints = new GeoPoint [ ] { new GeoPoint ( <str> ) , new GeoPoint ( <str> ) } ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . startObject ( <str> ) . field ( <str> , ( i % <int> = = <int> ) ? geoPoints [ <int> ] . getGeohash ( ) : geoPoints [ <int> ] . getGeohash ( ) ) . endObject ( ) . endObject ( ) . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; CompletionSuggestionBuilder geoFilteringPrefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) . geoContexts ( <str> , GeoQueryContext . builder ( ) . setGeoPoint ( new GeoPoint ( geoPoints [ <int> ] ) ) . build ( ) ) ; assertSuggestions ( <str> , geoFilteringPrefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testGeoBoosting ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . geo ( <str> ) . build ( ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; GeoPoint [ ] geoPoints = new GeoPoint [ ] { new GeoPoint ( <str> ) , new GeoPoint ( <str> ) } ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . startObject ( <str> ) . field ( <str> , ( i % <int> = = <int> ) ? geoPoints [ <int> ] . getGeohash ( ) : geoPoints [ <int> ] . getGeohash ( ) ) . endObject ( ) . endObject ( ) . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; GeoQueryContext context1 = GeoQueryContext . builder ( ) . setGeoPoint ( geoPoints [ <int> ] ) . setBoost ( <int> ) . build ( ) ; GeoQueryContext context2 = GeoQueryContext . builder ( ) . setGeoPoint ( geoPoints [ <int> ] ) . build ( ) ; CompletionSuggestionBuilder geoBoostingPrefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) . geoContexts ( <str> , context1 , context2 ) ; assertSuggestions ( <str> , geoBoostingPrefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testGeoPointContext ( ) throws Exception { LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . geo ( <str> ) . build ( ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <float> ) . field ( <str> , <float> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) . geoContexts ( <str> , GeoQueryContext . builder ( ) . setGeoPoint ( new GeoPoint ( <float> , <float> ) ) . build ( ) ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testGeoNeighbours ( ) throws Exception { String geohash = <str> ; List < String > neighbours = new ArrayList < > ( ) ; neighbours . add ( <str> ) ; neighbours . add ( <str> ) ; neighbours . add ( <str> ) ; neighbours . add ( <str> ) ; neighbours . add ( <str> ) ; neighbours . add ( <str> ) ; neighbours . add ( <str> ) ; neighbours . add ( <str> ) ; LinkedHashMap < String , ContextMapping > map = new LinkedHashMap < > ( ) ; map . put ( <str> , ContextBuilder . geo ( <str> ) . precision ( <int> ) . build ( ) ) ; final CompletionMappingBuilder mapping = new CompletionMappingBuilder ( ) . context ( map ) ; createIndexAndMapping ( mapping ) ; int numDocs = <int> ; List < IndexRequestBuilder > indexRequestBuilders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder source = jsonBuilder ( ) . startObject ( ) . startObject ( FIELD ) . field ( <str> , <str> + i ) . field ( <str> , i + <int> ) . startObject ( <str> ) . field ( <str> , randomFrom ( neighbours ) ) . endObject ( ) . endObject ( ) . endObject ( ) ; indexRequestBuilders . add ( client ( ) . prepareIndex ( INDEX , TYPE , <str> + i ) . setSource ( source ) ) ; } indexRandom ( true , indexRequestBuilders ) ; ensureYellow ( INDEX ) ; CompletionSuggestionBuilder prefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) ; assertSuggestions ( <str> , prefix , <str> , <str> , <str> , <str> , <str> ) ; CompletionSuggestionBuilder geoNeighbourPrefix = SuggestBuilders . completionSuggestion ( <str> ) . field ( FIELD ) . prefix ( <str> ) . geoContexts ( <str> , GeoQueryContext . builder ( ) . setGeoPoint ( GeoPoint . fromGeohash ( geohash ) ) . build ( ) ) ; assertSuggestions ( <str> , geoNeighbourPrefix , <str> , <str> , <str> , <str> , <str> ) ; } public void testGeoField ( ) throws Exception { XContentBuilder mapping = jsonBuilder ( ) ; mapping . startObject ( ) ; mapping . startObject ( TYPE ) ; mapping . startObject ( <str> ) ; mapping . startObject ( <str> ) ; mapping . field ( <str> , <str> ) ; mapping . endObject ( ) ; mapping . startObject ( FIELD ) ; mapping . field ( <str> , <str> ) ; mapping . field ( <str> , <str> ) ; mapping . startArray ( <str> ) ; mapping . startObject ( ) ; mapping . field ( <str> , <str> ) ; mapping . field ( <str> , <str> ) ; mapping . field ( <str> , <str> ) ; mapping . field ( <str> , <int> ) ; mapping . endObject ( ) ; mapping . endArray ( ) ; mapping . endObject ( ) ; mapping . endObject ( ) ; mapping . endObject ( ) ; mapping . endObject ( ) ; assertAcked ( prepareCreate ( INDEX ) . addMapping ( TYPE , mapping ) ) ; ensureYellow ( ) ; XContentBuilder source1 = jsonBuilder ( ) . startObject ( ) . latlon ( <str> , <float> , <float> ) . startObject ( FIELD ) . array ( <str> , <str> ) . endObject ( ) . endObject ( ) ; client ( ) . prepareIndex ( INDEX , TYPE , <str> ) . setSource ( source1 ) . execute ( ) . actionGet ( ) ; XContentBuilder source2 = jsonBuilder ( ) . startObject ( ) . latlon ( <str> , <float> , <float> ) . startObject ( FIELD ) . array ( <str> , <str> ) . endObject ( ) . endObject ( ) ; client ( ) . prepareIndex ( INDEX , TYPE , <str> ) . setSource ( source2 ) . execute ( ) . actionGet ( ) ; refresh ( ) ; String suggestionName = randomAsciiOfLength ( <int> ) ; CompletionSuggestionBuilder context = SuggestBuilders . completionSuggestion ( suggestionName ) . field ( FIELD ) . text ( <str> ) . size ( <int> ) . geoContexts ( <str> , GeoQueryContext . builder ( ) . setGeoPoint ( new GeoPoint ( <float> , <float> ) ) . build ( ) ) ; SuggestResponse suggestResponse = client ( ) . prepareSuggest ( INDEX ) . addSuggestion ( context ) . get ( ) ; assertEquals ( suggestResponse . getSuggest ( ) . size ( ) , <int> ) ; assertEquals ( <str> , suggestResponse . getSuggest ( ) . getSuggestion ( suggestionName ) . iterator ( ) . next ( ) . getOptions ( ) . iterator ( ) . next ( ) . getText ( ) . string ( ) ) ; } public void assertSuggestions ( String suggestionName , SuggestBuilder . SuggestionBuilder suggestBuilder , String . . . suggestions ) { SuggestResponse suggestResponse = client ( ) . prepareSuggest ( INDEX ) . addSuggestion ( suggestBuilder ) . execute ( ) . actionGet ( ) ; CompletionSuggestSearchIT . assertSuggestions ( suggestResponse , suggestionName , suggestions ) ; } private void createIndexAndMapping ( CompletionMappingBuilder completionMappingBuilder ) throws IOException { createIndexAndMappingAndSettings ( Settings . EMPTY , completionMappingBuilder ) ; } private void createIndexAndMappingAndSettings ( Settings settings , CompletionMappingBuilder completionMappingBuilder ) throws IOException { XContentBuilder mapping = jsonBuilder ( ) . startObject ( ) . startObject ( TYPE ) . startObject ( <str> ) . startObject ( FIELD ) . field ( <str> , <str> ) . field ( <str> , completionMappingBuilder . indexAnalyzer ) . field ( <str> , completionMappingBuilder . searchAnalyzer ) . field ( <str> , completionMappingBuilder . preserveSeparators ) . field ( <str> , completionMappingBuilder . preservePositionIncrements ) ; if ( completionMappingBuilder . contextMappings ! = null ) { mapping = mapping . startArray ( <str> ) ; for ( Map . Entry < String , ContextMapping > contextMapping : completionMappingBuilder . contextMappings . entrySet ( ) ) { mapping = mapping . startObject ( ) . field ( <str> , contextMapping . getValue ( ) . name ( ) ) . field ( <str> , contextMapping . getValue ( ) . type ( ) . name ( ) ) ; switch ( contextMapping . getValue ( ) . type ( ) ) { case CATEGORY : final String fieldName = ( ( CategoryContextMapping ) contextMapping . getValue ( ) ) . getFieldName ( ) ; if ( fieldName ! = null ) { mapping = mapping . field ( <str> , fieldName ) ; } break ; case GEO : final String name = ( ( GeoContextMapping ) contextMapping . getValue ( ) ) . getFieldName ( ) ; mapping = mapping . field ( <str> , ( ( GeoContextMapping ) contextMapping . getValue ( ) ) . getPrecision ( ) ) ; if ( name ! = null ) { mapping . field ( <str> , name ) ; } break ; } mapping = mapping . endObject ( ) ; } mapping = mapping . endArray ( ) ; } mapping = mapping . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( INDEX ) . setSettings ( Settings . settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( settings ) ) . addMapping ( TYPE , mapping ) . get ( ) ) ; ensureYellow ( ) ; } } 
