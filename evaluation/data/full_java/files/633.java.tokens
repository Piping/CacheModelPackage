package org . apache . cassandra . hints ; import java . io . File ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . Collections ; import java . util . UUID ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Supplier ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . metrics . HintedHandoffMetrics ; import org . apache . cassandra . metrics . StorageMetrics ; import org . apache . cassandra . service . StorageService ; import static com . google . common . collect . Iterables . transform ; import static com . google . common . collect . Iterables . size ; public final class HintsService implements HintsServiceMBean { private static final Logger logger = LoggerFactory . getLogger ( HintsService . class ) ; public static final HintsService instance = new HintsService ( ) ; private static final String MBEAN_NAME = <str> ; private static final int MIN_BUFFER_SIZE = <int> < < <int> ; private final HintsCatalog catalog ; private final HintsWriteExecutor writeExecutor ; private final HintsBufferPool bufferPool ; private final HintsDispatchExecutor dispatchExecutor ; private final AtomicBoolean isDispatchPaused ; private volatile boolean isShutDown = false ; private final ScheduledFuture triggerFlushingFuture ; private volatile ScheduledFuture triggerDispatchFuture ; public final HintedHandoffMetrics metrics ; private HintsService ( ) { File hintsDirectory = DatabaseDescriptor . getHintsDirectory ( ) ; int maxDeliveryThreads = DatabaseDescriptor . getMaxHintsDeliveryThreads ( ) ; catalog = HintsCatalog . load ( hintsDirectory ) ; writeExecutor = new HintsWriteExecutor ( catalog ) ; int bufferSize = Math . max ( DatabaseDescriptor . getMaxMutationSize ( ) * <int> , MIN_BUFFER_SIZE ) ; bufferPool = new HintsBufferPool ( bufferSize , writeExecutor : : flushBuffer ) ; isDispatchPaused = new AtomicBoolean ( true ) ; dispatchExecutor = new HintsDispatchExecutor ( hintsDirectory , maxDeliveryThreads , isDispatchPaused ) ; int flushPeriod = DatabaseDescriptor . getHintsFlushPeriodInMS ( ) ; triggerFlushingFuture = ScheduledExecutors . optionalTasks . scheduleWithFixedDelay ( ( ) - > writeExecutor . flushBufferPool ( bufferPool ) , flushPeriod , flushPeriod , TimeUnit . MILLISECONDS ) ; metrics = new HintedHandoffMetrics ( ) ; } public void registerMBean ( ) { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . registerMBean ( this , new ObjectName ( MBEAN_NAME ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public void write ( Iterable < UUID > hostIds , Hint hint ) { if ( isShutDown ) throw new IllegalStateException ( <str> ) ; catalog . maybeLoadStores ( hostIds ) ; if ( hint . isLive ( ) ) bufferPool . write ( hostIds , hint ) ; StorageMetrics . totalHints . inc ( size ( hostIds ) ) ; } public void write ( UUID hostId , Hint hint ) { write ( Collections . singleton ( hostId ) , hint ) ; } public void flushAndFsyncBlockingly ( Iterable < UUID > hostIds ) { Iterable < HintsStore > stores = transform ( hostIds , catalog : : get ) ; writeExecutor . flushBufferPool ( bufferPool , stores ) ; writeExecutor . fsyncWritersBlockingly ( stores ) ; } public synchronized void startDispatch ( ) { if ( isShutDown ) throw new IllegalStateException ( <str> ) ; isDispatchPaused . set ( false ) ; HintsDispatchTrigger trigger = new HintsDispatchTrigger ( catalog , writeExecutor , dispatchExecutor , isDispatchPaused ) ; triggerDispatchFuture = ScheduledExecutors . scheduledTasks . scheduleWithFixedDelay ( trigger , <int> , <int> , TimeUnit . SECONDS ) ; } public void pauseDispatch ( ) { logger . info ( <str> ) ; isDispatchPaused . set ( true ) ; } public void resumeDispatch ( ) { logger . info ( <str> ) ; isDispatchPaused . set ( false ) ; } public synchronized void shutdownBlocking ( ) { if ( isShutDown ) throw new IllegalStateException ( <str> ) ; isShutDown = true ; if ( triggerDispatchFuture ! = null ) triggerDispatchFuture . cancel ( false ) ; pauseDispatch ( ) ; triggerFlushingFuture . cancel ( false ) ; writeExecutor . flushBufferPool ( bufferPool ) ; writeExecutor . closeAllWriters ( ) ; dispatchExecutor . shutdownBlocking ( ) ; writeExecutor . shutdownBlocking ( ) ; } public void deleteAllHints ( ) { catalog . deleteAllHints ( ) ; } public void deleteAllHintsForEndpoint ( String address ) { InetAddress target ; try { target = InetAddress . getByName ( address ) ; } catch ( UnknownHostException e ) { throw new IllegalArgumentException ( e ) ; } deleteAllHintsForEndpoint ( target ) ; } public void deleteAllHintsForEndpoint ( InetAddress target ) { UUID hostId = StorageService . instance . getHostIdForEndpoint ( target ) ; if ( hostId = = null ) throw new IllegalArgumentException ( <str> + target ) ; catalog . deleteAllHints ( hostId ) ; } public void excise ( UUID hostId ) { HintsStore store = catalog . get ( hostId ) ; if ( store = = null ) return ; Future flushFuture = writeExecutor . flushBufferPool ( bufferPool , Collections . singleton ( store ) ) ; Future closeFuture = writeExecutor . closeWriter ( store ) ; try { flushFuture . get ( ) ; closeFuture . get ( ) ; } catch ( InterruptedException | ExecutionException e ) { throw new RuntimeException ( e ) ; } dispatchExecutor . completeDispatchBlockingly ( store ) ; catalog . exciseStore ( hostId ) ; } public Future transferHints ( Supplier < UUID > hostIdSupplier ) { Future flushFuture = writeExecutor . flushBufferPool ( bufferPool ) ; Future closeFuture = writeExecutor . closeAllWriters ( ) ; try { flushFuture . get ( ) ; closeFuture . get ( ) ; } catch ( InterruptedException | ExecutionException e ) { throw new RuntimeException ( e ) ; } resumeDispatch ( ) ; catalog . stores ( ) . forEach ( dispatchExecutor : : completeDispatchBlockingly ) ; return dispatchExecutor . transfer ( catalog , hostIdSupplier ) ; } } 
