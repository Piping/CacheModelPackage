package io . netty . handler . codec . socks ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . socks . SocksCmdRequestDecoder . State ; import io . netty . util . CharsetUtil ; import java . util . List ; public class SocksCmdRequestDecoder extends ReplayingDecoder < State > { private SocksProtocolVersion version ; private int fieldLength ; private SocksCmdType cmdType ; private SocksAddressType addressType ; @SuppressWarnings ( <str> ) private byte reserved ; private String host ; private int port ; private SocksRequest msg = SocksCommonUtils . UNKNOWN_SOCKS_REQUEST ; public SocksCmdRequestDecoder ( ) { super ( State . CHECK_PROTOCOL_VERSION ) ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf byteBuf , List < Object > out ) throws Exception { switch ( state ( ) ) { case CHECK_PROTOCOL_VERSION : { version = SocksProtocolVersion . valueOf ( byteBuf . readByte ( ) ) ; if ( version ! = SocksProtocolVersion . SOCKS5 ) { break ; } checkpoint ( State . READ_CMD_HEADER ) ; } case READ_CMD_HEADER : { cmdType = SocksCmdType . valueOf ( byteBuf . readByte ( ) ) ; reserved = byteBuf . readByte ( ) ; addressType = SocksAddressType . valueOf ( byteBuf . readByte ( ) ) ; checkpoint ( State . READ_CMD_ADDRESS ) ; } case READ_CMD_ADDRESS : { switch ( addressType ) { case IPv4 : { host = SocksCommonUtils . intToIp ( byteBuf . readInt ( ) ) ; port = byteBuf . readUnsignedShort ( ) ; msg = new SocksCmdRequest ( cmdType , addressType , host , port ) ; break ; } case DOMAIN : { fieldLength = byteBuf . readByte ( ) ; host = byteBuf . readBytes ( fieldLength ) . toString ( CharsetUtil . US_ASCII ) ; port = byteBuf . readUnsignedShort ( ) ; msg = new SocksCmdRequest ( cmdType , addressType , host , port ) ; break ; } case IPv6 : { host = SocksCommonUtils . ipv6toStr ( byteBuf . readBytes ( <int> ) . array ( ) ) ; port = byteBuf . readUnsignedShort ( ) ; msg = new SocksCmdRequest ( cmdType , addressType , host , port ) ; break ; } case UNKNOWN : break ; } } } ctx . pipeline ( ) . remove ( this ) ; out . add ( msg ) ; } enum State { CHECK_PROTOCOL_VERSION , READ_CMD_HEADER , READ_CMD_ADDRESS } } 
