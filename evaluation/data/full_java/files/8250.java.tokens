package org . elasticsearch . index . query ; import org . apache . lucene . index . Term ; import org . apache . lucene . queries . ExtendedCommonTermsQuery ; import org . apache . lucene . search . * ; import org . elasticsearch . common . lucene . all . AllTermQuery ; import org . elasticsearch . common . lucene . search . MultiPhrasePrefixQuery ; import org . elasticsearch . index . search . MatchQuery ; import java . io . IOException ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . index . query . QueryBuilders . multiMatchQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertBooleanSubQuery ; import static org . hamcrest . CoreMatchers . either ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; public class MultiMatchQueryBuilderTests extends AbstractQueryTestCase < MultiMatchQueryBuilder > { @Override protected MultiMatchQueryBuilder doCreateTestQueryBuilder ( ) { String fieldName = randomFrom ( STRING_FIELD_NAME , INT_FIELD_NAME , DOUBLE_FIELD_NAME , BOOLEAN_FIELD_NAME , DATE_FIELD_NAME ) ; if ( fieldName . equals ( DATE_FIELD_NAME ) ) { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; } Object value ; if ( fieldName . equals ( STRING_FIELD_NAME ) ) { value = getRandomQueryText ( ) ; } else { value = getRandomValueForFieldName ( fieldName ) ; } MultiMatchQueryBuilder query = new MultiMatchQueryBuilder ( value , fieldName ) ; if ( randomBoolean ( ) ) { query . field ( fieldName , randomFloat ( ) * <int> ) ; } if ( randomBoolean ( ) ) { query . type ( randomFrom ( MultiMatchQueryBuilder . Type . values ( ) ) ) ; } if ( randomBoolean ( ) ) { query . operator ( randomFrom ( Operator . values ( ) ) ) ; } if ( randomBoolean ( ) ) { query . analyzer ( randomAnalyzer ( ) ) ; } if ( randomBoolean ( ) ) { query . slop ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { query . fuzziness ( randomFuzziness ( fieldName ) ) ; } if ( randomBoolean ( ) ) { query . prefixLength ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { query . maxExpansions ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { query . minimumShouldMatch ( randomMinimumShouldMatch ( ) ) ; } if ( randomBoolean ( ) ) { query . fuzzyRewrite ( getRandomRewriteMethod ( ) ) ; } if ( randomBoolean ( ) ) { query . useDisMax ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { query . tieBreaker ( randomFloat ( ) ) ; } if ( randomBoolean ( ) ) { query . lenient ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { query . cutoffFrequency ( ( float ) <int> / randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { query . zeroTermsQuery ( randomFrom ( MatchQuery . ZeroTermsQuery . values ( ) ) ) ; } return query ; } @Override protected Map < String , MultiMatchQueryBuilder > getAlternateVersions ( ) { Map < String , MultiMatchQueryBuilder > alternateVersions = new HashMap < > ( ) ; String query = <str> + <str> + <str> + <str> + <str> + <str> ; alternateVersions . put ( query , new MultiMatchQueryBuilder ( <str> , <str> ) ) ; return alternateVersions ; } @Override protected void doAssertLuceneQuery ( MultiMatchQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { assertThat ( query , either ( instanceOf ( BoostQuery . class ) ) . or ( instanceOf ( TermQuery . class ) ) . or ( instanceOf ( AllTermQuery . class ) ) . or ( instanceOf ( BooleanQuery . class ) ) . or ( instanceOf ( DisjunctionMaxQuery . class ) ) . or ( instanceOf ( FuzzyQuery . class ) ) . or ( instanceOf ( MultiPhrasePrefixQuery . class ) ) . or ( instanceOf ( MatchAllDocsQuery . class ) ) . or ( instanceOf ( ExtendedCommonTermsQuery . class ) ) . or ( instanceOf ( MatchNoDocsQuery . class ) ) . or ( instanceOf ( PhraseQuery . class ) ) ) ; } public void testIllegaArguments ( ) { try { new MultiMatchQueryBuilder ( null , <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { new MultiMatchQueryBuilder ( <str> , ( String [ ] ) null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { new MultiMatchQueryBuilder ( <str> , new String [ ] { <str> } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { new MultiMatchQueryBuilder ( <str> , <str> ) . type ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testToQueryBoost ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; QueryShardContext shardContext = createShardContext ( ) ; MultiMatchQueryBuilder multiMatchQueryBuilder = new MultiMatchQueryBuilder ( <str> ) ; multiMatchQueryBuilder . field ( STRING_FIELD_NAME , <float> ) ; Query query = multiMatchQueryBuilder . toQuery ( shardContext ) ; assertTermOrBoostQuery ( query , STRING_FIELD_NAME , <str> , <float> ) ; multiMatchQueryBuilder = new MultiMatchQueryBuilder ( <str> ) ; multiMatchQueryBuilder . field ( STRING_FIELD_NAME , <float> ) ; multiMatchQueryBuilder . boost ( <float> ) ; query = multiMatchQueryBuilder . toQuery ( shardContext ) ; assertThat ( query , instanceOf ( BoostQuery . class ) ) ; BoostQuery boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; assertTermOrBoostQuery ( boostQuery . getQuery ( ) , STRING_FIELD_NAME , <str> , <float> ) ; } public void testToQueryMultipleTermsBooleanQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = multiMatchQuery ( <str> ) . field ( STRING_FIELD_NAME ) . useDisMax ( false ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery bQuery = ( BooleanQuery ) query ; assertThat ( bQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; } public void testToQueryMultipleFieldsBooleanQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = multiMatchQuery ( <str> ) . field ( STRING_FIELD_NAME ) . field ( STRING_FIELD_NAME_2 ) . useDisMax ( false ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery bQuery = ( BooleanQuery ) query ; assertThat ( bQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME_2 , <str> ) ) ) ; } public void testToQueryMultipleFieldsDisMaxQuery ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = multiMatchQuery ( <str> ) . field ( STRING_FIELD_NAME ) . field ( STRING_FIELD_NAME_2 ) . useDisMax ( true ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( DisjunctionMaxQuery . class ) ) ; DisjunctionMaxQuery disMaxQuery = ( DisjunctionMaxQuery ) query ; List < Query > disjuncts = disMaxQuery . getDisjuncts ( ) ; assertThat ( disjuncts . get ( <int> ) , instanceOf ( TermQuery . class ) ) ; assertThat ( ( ( TermQuery ) disjuncts . get ( <int> ) ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( disjuncts . get ( <int> ) , instanceOf ( TermQuery . class ) ) ; assertThat ( ( ( TermQuery ) disjuncts . get ( <int> ) ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME_2 , <str> ) ) ) ; } public void testToQueryFieldsWildcard ( ) throws Exception { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; Query query = multiMatchQuery ( <str> ) . field ( <str> ) . useDisMax ( false ) . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery bQuery = ( BooleanQuery ) query ; assertThat ( bQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME , <str> ) ) ) ; assertThat ( assertBooleanSubQuery ( query , TermQuery . class , <int> ) . getTerm ( ) , equalTo ( new Term ( STRING_FIELD_NAME_2 , <str> ) ) ) ; } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; MultiMatchQueryBuilder parsed = ( MultiMatchQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <str> , parsed . value ( ) ) ; assertEquals ( json , <int> , parsed . fields ( ) . size ( ) ) ; assertEquals ( json , MultiMatchQueryBuilder . Type . MOST_FIELDS , parsed . type ( ) ) ; assertEquals ( json , Operator . OR , parsed . operator ( ) ) ; } } 
