package org . elasticsearch . plugins ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . * ; import org . elasticsearch . bootstrap . JarHell ; import org . elasticsearch . common . Randomness ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . cli . Terminal ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . http . client . HttpDownloadHelper ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . env . Environment ; import org . elasticsearch . plugins . PluginsService . Bundle ; import java . io . IOException ; import java . io . OutputStream ; import java . net . MalformedURLException ; import java . net . URL ; import java . nio . file . * ; import java . nio . file . attribute . * ; import java . util . * ; import java . util . stream . StreamSupport ; import java . util . zip . ZipEntry ; import java . util . zip . ZipInputStream ; import static java . util . Collections . unmodifiableSet ; import static org . elasticsearch . common . Strings . hasLength ; import static org . elasticsearch . common . cli . Terminal . Verbosity . VERBOSE ; import static org . elasticsearch . common . io . FileSystemUtils . moveFilesWithoutOverwriting ; import static org . elasticsearch . common . util . set . Sets . newHashSet ; public class PluginManager { public static final String PROPERTY_SUPPORT_STAGING_URLS = <str> ; public enum OutputMode { DEFAULT , SILENT , VERBOSE } private static final Set < String > BLACKLIST = unmodifiableSet ( newHashSet ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; static final Set < String > MODULES = unmodifiableSet ( newHashSet ( <str> , <str> ) ) ; static final Set < String > OFFICIAL_PLUGINS = unmodifiableSet ( newHashSet ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; private final Environment environment ; private URL url ; private OutputMode outputMode ; private TimeValue timeout ; public PluginManager ( Environment environment , URL url , OutputMode outputMode , TimeValue timeout ) { this . environment = environment ; this . url = url ; this . outputMode = outputMode ; this . timeout = timeout ; } public void downloadAndExtract ( String name , Terminal terminal , boolean batch ) throws IOException { if ( name = = null & & url = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( ! Files . exists ( environment . pluginsFile ( ) ) ) { terminal . println ( <str> , environment . pluginsFile ( ) ) ; Files . createDirectory ( environment . pluginsFile ( ) ) ; } if ( ! Environment . isWritable ( environment . pluginsFile ( ) ) ) { throw new IOException ( <str> + environment . pluginsFile ( ) + <str> ) ; } PluginHandle pluginHandle ; if ( name ! = null ) { pluginHandle = PluginHandle . parse ( name ) ; checkForForbiddenName ( pluginHandle . name ) ; } else { pluginHandle = new PluginHandle ( <str> + Randomness . get ( ) . nextInt ( ) , null , null ) ; } Path pluginFile = download ( pluginHandle , terminal ) ; extract ( pluginHandle , terminal , pluginFile , batch ) ; } private Path download ( PluginHandle pluginHandle , Terminal terminal ) throws IOException { Path pluginFile = pluginHandle . newDistroFile ( environment ) ; HttpDownloadHelper downloadHelper = new HttpDownloadHelper ( ) ; boolean downloaded = false ; boolean verified = false ; HttpDownloadHelper . DownloadProgress progress ; if ( outputMode = = OutputMode . SILENT ) { progress = new HttpDownloadHelper . NullProgress ( ) ; } else { progress = new HttpDownloadHelper . VerboseProgress ( terminal . writer ( ) ) ; } if ( url ! = null ) { URL pluginUrl = url ; boolean isSecureProcotol = <str> . equalsIgnoreCase ( pluginUrl . getProtocol ( ) ) ; boolean isAuthInfoSet = ! Strings . isNullOrEmpty ( pluginUrl . getUserInfo ( ) ) ; if ( isAuthInfoSet & & ! isSecureProcotol ) { throw new IOException ( <str> ) ; } terminal . println ( <str> , pluginUrl . toExternalForm ( ) ) ; try { downloadHelper . download ( pluginUrl , pluginFile , progress , this . timeout ) ; downloaded = true ; terminal . println ( <str> , pluginUrl . toExternalForm ( ) ) ; Tuple < URL , Path > sha1Info = pluginHandle . newChecksumUrlAndFile ( environment , pluginUrl , <str> ) ; verified = downloadHelper . downloadAndVerifyChecksum ( sha1Info . v1 ( ) , pluginFile , sha1Info . v2 ( ) , progress , this . timeout , HttpDownloadHelper . SHA1_CHECKSUM ) ; Tuple < URL , Path > md5Info = pluginHandle . newChecksumUrlAndFile ( environment , pluginUrl , <str> ) ; verified = verified | | downloadHelper . downloadAndVerifyChecksum ( md5Info . v1 ( ) , pluginFile , md5Info . v2 ( ) , progress , this . timeout , HttpDownloadHelper . MD5_CHECKSUM ) ; } catch ( ElasticsearchTimeoutException | ElasticsearchCorruptionException e ) { throw e ; } catch ( Exception e ) { terminal . println ( <str> , ExceptionsHelper . detailedMessage ( e ) ) ; } } else { if ( PluginHandle . isOfficialPlugin ( pluginHandle . name , pluginHandle . user , pluginHandle . version ) ) { checkForOfficialPlugins ( pluginHandle . name ) ; } } if ( ! downloaded & & url = = null ) { for ( URL url : pluginHandle . urls ( ) ) { terminal . println ( <str> , url . toExternalForm ( ) ) ; try { downloadHelper . download ( url , pluginFile , progress , this . timeout ) ; downloaded = true ; terminal . println ( <str> , url . toExternalForm ( ) ) ; Tuple < URL , Path > sha1Info = pluginHandle . newChecksumUrlAndFile ( environment , url , <str> ) ; verified = downloadHelper . downloadAndVerifyChecksum ( sha1Info . v1 ( ) , pluginFile , sha1Info . v2 ( ) , progress , this . timeout , HttpDownloadHelper . SHA1_CHECKSUM ) ; Tuple < URL , Path > md5Info = pluginHandle . newChecksumUrlAndFile ( environment , url , <str> ) ; verified = verified | | downloadHelper . downloadAndVerifyChecksum ( md5Info . v1 ( ) , pluginFile , md5Info . v2 ( ) , progress , this . timeout , HttpDownloadHelper . MD5_CHECKSUM ) ; break ; } catch ( ElasticsearchTimeoutException | ElasticsearchCorruptionException e ) { throw e ; } catch ( Exception e ) { terminal . println ( VERBOSE , <str> , ExceptionsHelper . detailedMessage ( e ) ) ; } } } if ( ! downloaded ) { IOUtils . deleteFilesIgnoringExceptions ( pluginFile ) ; throw new IOException ( <str> ) ; } if ( verified = = false ) { terminal . println ( <str> ) ; } return pluginFile ; } private void extract ( PluginHandle pluginHandle , Terminal terminal , Path pluginFile , boolean batch ) throws IOException { Path tmp = Files . createTempDirectory ( environment . tmpFile ( ) , null ) ; Path root = tmp . resolve ( pluginHandle . name ) ; unzipPlugin ( pluginFile , root ) ; root = findPluginRoot ( root ) ; PluginInfo info = PluginInfo . readFromProperties ( root ) ; terminal . println ( VERBOSE , <str> , info ) ; if ( MODULES . contains ( info . getName ( ) ) ) { throw new IOException ( <str> + info . getName ( ) + <str> ) ; } pluginHandle = new PluginHandle ( info . getName ( ) , pluginHandle . version , pluginHandle . user ) ; final Path extractLocation = pluginHandle . extractedDir ( environment ) ; if ( Files . exists ( extractLocation ) ) { throw new IOException ( <str> + extractLocation . toAbsolutePath ( ) + <str> + pluginHandle . name + <str> ) ; } if ( info . isJvm ( ) ) { jarHellCheck ( root , info . isIsolated ( ) ) ; } Path policy = root . resolve ( PluginInfo . ES_PLUGIN_POLICY ) ; if ( Files . exists ( policy ) ) { PluginSecurity . readPolicy ( policy , terminal , environment , batch ) ; } FileSystemUtils . copyDirectoryRecursively ( root , extractLocation ) ; terminal . println ( <str> , pluginHandle . name , extractLocation . toAbsolutePath ( ) ) ; tryToDeletePath ( terminal , tmp , pluginFile ) ; Path sourcePluginBinDirectory = extractLocation . resolve ( <str> ) ; Path destPluginBinDirectory = pluginHandle . binDir ( environment ) ; boolean needToCopyBinDirectory = Files . exists ( sourcePluginBinDirectory ) ; if ( needToCopyBinDirectory ) { if ( Files . exists ( destPluginBinDirectory ) & & ! Files . isDirectory ( destPluginBinDirectory ) ) { tryToDeletePath ( terminal , extractLocation ) ; throw new IOException ( <str> + destPluginBinDirectory + <str> ) ; } try { copyBinDirectory ( sourcePluginBinDirectory , destPluginBinDirectory , pluginHandle . name , terminal ) ; } catch ( IOException e ) { terminal . printError ( <str> , sourcePluginBinDirectory , destPluginBinDirectory , ExceptionsHelper . detailedMessage ( e ) ) ; tryToDeletePath ( terminal , extractLocation , pluginHandle . binDir ( environment ) ) ; throw e ; } } Path sourceConfigDirectory = extractLocation . resolve ( <str> ) ; Path destConfigDirectory = pluginHandle . configDir ( environment ) ; boolean needToCopyConfigDirectory = Files . exists ( sourceConfigDirectory ) ; if ( needToCopyConfigDirectory ) { if ( Files . exists ( destConfigDirectory ) & & ! Files . isDirectory ( destConfigDirectory ) ) { tryToDeletePath ( terminal , extractLocation , destPluginBinDirectory ) ; throw new IOException ( <str> + destConfigDirectory + <str> ) ; } try { terminal . println ( VERBOSE , <str> , destConfigDirectory . toAbsolutePath ( ) ) ; moveFilesWithoutOverwriting ( sourceConfigDirectory , destConfigDirectory , <str> ) ; if ( Environment . getFileStore ( destConfigDirectory ) . supportsFileAttributeView ( PosixFileAttributeView . class ) ) { PosixFileAttributes parentDirAttributes = Files . getFileAttributeView ( destConfigDirectory . getParent ( ) , PosixFileAttributeView . class ) . readAttributes ( ) ; Set < PosixFilePermission > baseFilePermissions = new HashSet < > ( ) ; for ( PosixFilePermission posixFilePermission : parentDirAttributes . permissions ( ) ) { switch ( posixFilePermission ) { case OWNER_EXECUTE : case GROUP_EXECUTE : case OTHERS_EXECUTE : break ; default : baseFilePermissions . add ( posixFilePermission ) ; } } Files . walkFileTree ( destConfigDirectory , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( attrs . isRegularFile ( ) ) { Set < PosixFilePermission > newFilePermissions = new HashSet < > ( baseFilePermissions ) ; Set < PosixFilePermission > currentFilePermissions = Files . getPosixFilePermissions ( file ) ; for ( PosixFilePermission posixFilePermission : currentFilePermissions ) { switch ( posixFilePermission ) { case OWNER_EXECUTE : case GROUP_EXECUTE : case OTHERS_EXECUTE : newFilePermissions . add ( posixFilePermission ) ; } } setPosixFileAttributes ( file , parentDirAttributes . owner ( ) , parentDirAttributes . group ( ) , newFilePermissions ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { setPosixFileAttributes ( dir , parentDirAttributes . owner ( ) , parentDirAttributes . group ( ) , parentDirAttributes . permissions ( ) ) ; return FileVisitResult . CONTINUE ; } } ) ; } else { terminal . println ( VERBOSE , <str> ) ; } terminal . println ( VERBOSE , <str> , pluginHandle . name , destConfigDirectory . toAbsolutePath ( ) ) ; } catch ( IOException e ) { terminal . printError ( <str> , sourceConfigDirectory , destConfigDirectory , ExceptionsHelper . detailedMessage ( e ) ) ; tryToDeletePath ( terminal , extractLocation , destPluginBinDirectory , destConfigDirectory ) ; throw e ; } } } private static void setPosixFileAttributes ( Path path , UserPrincipal owner , GroupPrincipal group , Set < PosixFilePermission > permissions ) throws IOException { PosixFileAttributeView fileAttributeView = Files . getFileAttributeView ( path , PosixFileAttributeView . class ) ; fileAttributeView . setOwner ( owner ) ; fileAttributeView . setGroup ( group ) ; fileAttributeView . setPermissions ( permissions ) ; } static void tryToDeletePath ( Terminal terminal , Path . . . paths ) { for ( Path path : paths ) { try { IOUtils . rm ( path ) ; } catch ( IOException e ) { terminal . printError ( e ) ; } } } private void copyBinDirectory ( Path sourcePluginBinDirectory , Path destPluginBinDirectory , String pluginName , Terminal terminal ) throws IOException { boolean canCopyFromSource = Files . exists ( sourcePluginBinDirectory ) & & Files . isReadable ( sourcePluginBinDirectory ) & & Files . isDirectory ( sourcePluginBinDirectory ) ; if ( canCopyFromSource ) { terminal . println ( VERBOSE , <str> , destPluginBinDirectory . toAbsolutePath ( ) ) ; if ( Files . exists ( destPluginBinDirectory ) ) { IOUtils . rm ( destPluginBinDirectory ) ; } try { Files . createDirectories ( destPluginBinDirectory . getParent ( ) ) ; FileSystemUtils . move ( sourcePluginBinDirectory , destPluginBinDirectory ) ; } catch ( IOException e ) { throw new IOException ( <str> + sourcePluginBinDirectory + <str> + destPluginBinDirectory + <str> , e ) ; } if ( Environment . getFileStore ( destPluginBinDirectory ) . supportsFileAttributeView ( PosixFileAttributeView . class ) ) { PosixFileAttributes parentDirAttributes = Files . getFileAttributeView ( destPluginBinDirectory . getParent ( ) , PosixFileAttributeView . class ) . readAttributes ( ) ; Set < PosixFilePermission > filePermissions = new HashSet < > ( ) ; for ( PosixFilePermission posixFilePermission : parentDirAttributes . permissions ( ) ) { switch ( posixFilePermission ) { case OWNER_EXECUTE : case GROUP_EXECUTE : case OTHERS_EXECUTE : break ; default : filePermissions . add ( posixFilePermission ) ; } } filePermissions . add ( PosixFilePermission . OWNER_EXECUTE ) ; filePermissions . add ( PosixFilePermission . GROUP_EXECUTE ) ; filePermissions . add ( PosixFilePermission . OTHERS_EXECUTE ) ; Files . walkFileTree ( destPluginBinDirectory , new SimpleFileVisitor < Path > ( ) { @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( attrs . isRegularFile ( ) ) { setPosixFileAttributes ( file , parentDirAttributes . owner ( ) , parentDirAttributes . group ( ) , filePermissions ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { setPosixFileAttributes ( dir , parentDirAttributes . owner ( ) , parentDirAttributes . group ( ) , parentDirAttributes . permissions ( ) ) ; return FileVisitResult . CONTINUE ; } } ) ; } else { terminal . println ( VERBOSE , <str> ) ; } terminal . println ( VERBOSE , <str> , pluginName , destPluginBinDirectory . toAbsolutePath ( ) ) ; } } private Path findPluginRoot ( Path dir ) throws IOException { if ( Files . exists ( dir . resolve ( PluginInfo . ES_PLUGIN_PROPERTIES ) ) ) { return dir ; } else { final Path [ ] topLevelFiles = FileSystemUtils . files ( dir ) ; if ( topLevelFiles . length = = <int> & & Files . isDirectory ( topLevelFiles [ <int> ] ) ) { Path subdir = topLevelFiles [ <int> ] ; if ( Files . exists ( subdir . resolve ( PluginInfo . ES_PLUGIN_PROPERTIES ) ) ) { return subdir ; } } } throw new RuntimeException ( <str> + PluginInfo . ES_PLUGIN_PROPERTIES + <str> ) ; } private void jarHellCheck ( Path candidate , boolean isolated ) throws IOException { final List < URL > jars = new ArrayList < > ( ) ; jars . addAll ( Arrays . asList ( JarHell . parseClassPath ( ) ) ) ; List < Bundle > bundles = PluginsService . getPluginBundles ( environment . pluginsFile ( ) ) ; if ( isolated = = false ) { jars . addAll ( bundles . get ( <int> ) . urls ) ; } Path pluginJars [ ] = FileSystemUtils . files ( candidate , <str> ) ; for ( Path jar : pluginJars ) { jars . add ( jar . toUri ( ) . toURL ( ) ) ; } try { JarHell . checkJarHell ( jars . toArray ( new URL [ jars . size ( ) ] ) ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } private void unzipPlugin ( Path zip , Path target ) throws IOException { Files . createDirectories ( target ) ; try ( ZipInputStream zipInput = new ZipInputStream ( Files . newInputStream ( zip ) ) ) { ZipEntry entry ; byte [ ] buffer = new byte [ <int> ] ; while ( ( entry = zipInput . getNextEntry ( ) ) ! = null ) { Path targetFile = target . resolve ( entry . getName ( ) ) ; Files . createDirectories ( targetFile . getParent ( ) ) ; if ( entry . isDirectory ( ) = = false ) { try ( OutputStream out = Files . newOutputStream ( targetFile ) ) { int len ; while ( ( len = zipInput . read ( buffer ) ) > = <int> ) { out . write ( buffer , <int> , len ) ; } } } zipInput . closeEntry ( ) ; } } } public void removePlugin ( String name , Terminal terminal ) throws IOException { if ( name = = null ) { throw new IllegalArgumentException ( <str> ) ; } PluginHandle pluginHandle = PluginHandle . parse ( name ) ; boolean removed = false ; checkForForbiddenName ( pluginHandle . name ) ; Path pluginToDelete = pluginHandle . extractedDir ( environment ) ; if ( Files . exists ( pluginToDelete ) ) { terminal . println ( VERBOSE , <str> , pluginToDelete ) ; try { IOUtils . rm ( pluginToDelete ) ; } catch ( IOException ex ) { throw new IOException ( <str> + pluginHandle . name + <str> + pluginToDelete . toString ( ) , ex ) ; } removed = true ; } Path binLocation = pluginHandle . binDir ( environment ) ; if ( Files . exists ( binLocation ) ) { terminal . println ( VERBOSE , <str> , binLocation ) ; try { IOUtils . rm ( binLocation ) ; } catch ( IOException ex ) { throw new IOException ( <str> + pluginHandle . name + <str> + binLocation . toString ( ) , ex ) ; } removed = true ; } if ( removed ) { terminal . println ( <str> , name ) ; } else { terminal . println ( <str> , name ) ; } } static void checkForForbiddenName ( String name ) { if ( ! hasLength ( name ) | | BLACKLIST . contains ( name . toLowerCase ( Locale . ROOT ) ) ) { throw new IllegalArgumentException ( <str> + name ) ; } } protected static void checkForOfficialPlugins ( String name ) { if ( ! OFFICIAL_PLUGINS . contains ( name ) ) { throw new IllegalArgumentException ( name + <str> + name + <str> ) ; } } public Path [ ] getListInstalledPlugins ( ) throws IOException { if ( ! Files . exists ( environment . pluginsFile ( ) ) ) { return new Path [ <int> ] ; } try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( environment . pluginsFile ( ) ) ) { return StreamSupport . stream ( stream . spliterator ( ) , false ) . toArray ( length - > new Path [ length ] ) ; } } public void listInstalledPlugins ( Terminal terminal ) throws IOException { Path [ ] plugins = getListInstalledPlugins ( ) ; terminal . println ( <str> , environment . pluginsFile ( ) . toAbsolutePath ( ) ) ; if ( plugins = = null | | plugins . length = = <int> ) { terminal . println ( <str> ) ; } else { for ( Path plugin : plugins ) { terminal . println ( <str> + plugin . getFileName ( ) ) ; } } } static class PluginHandle { final String version ; final String user ; final String name ; PluginHandle ( String name , String version , String user ) { this . version = version ; this . user = user ; this . name = name ; } List < URL > urls ( ) { List < URL > urls = new ArrayList < > ( ) ; if ( version ! = null ) { if ( user = = null ) { if ( ! Strings . isNullOrEmpty ( System . getProperty ( PROPERTY_SUPPORT_STAGING_URLS ) ) ) { addUrl ( urls , String . format ( Locale . ROOT , <str> , version , Build . CURRENT . shortHash ( ) , name , version , name , version ) ) ; } addUrl ( urls , String . format ( Locale . ROOT , <str> , name , version , name , version ) ) ; } else { addUrl ( urls , String . format ( Locale . ROOT , <str> , user , name , version ) ) ; addUrl ( urls , String . format ( Locale . ROOT , <str> , user . replace ( <str> , <str> ) , name , version ) ) ; addUrl ( urls , String . format ( Locale . ROOT , <str> , user . replace ( <str> , <str> ) , name , version ) ) ; addUrl ( urls , String . format ( Locale . ROOT , <str> , user , name , version ) ) ; } } if ( user ! = null ) { addUrl ( urls , String . format ( Locale . ROOT , <str> , user , name ) ) ; } return urls ; } private static void addUrl ( List < URL > urls , String url ) { try { urls . add ( new URL ( url ) ) ; } catch ( MalformedURLException e ) { } } Path newDistroFile ( Environment env ) throws IOException { return Files . createTempFile ( env . tmpFile ( ) , name , <str> ) ; } Tuple < URL , Path > newChecksumUrlAndFile ( Environment env , URL originalUrl , String suffix ) throws IOException { URL newUrl = new URL ( originalUrl . toString ( ) + <str> + suffix ) ; return new Tuple < > ( newUrl , Files . createTempFile ( env . tmpFile ( ) , name , <str> + suffix ) ) ; } Path extractedDir ( Environment env ) { return env . pluginsFile ( ) . resolve ( name ) ; } Path binDir ( Environment env ) { return env . binFile ( ) . resolve ( name ) ; } Path configDir ( Environment env ) { return env . configFile ( ) . resolve ( name ) ; } static PluginHandle parse ( String name ) { String [ ] elements = name . split ( <str> ) ; String repo = elements [ <int> ] ; String user = null ; String version = null ; if ( elements . length > <int> ) { user = elements [ <int> ] ; repo = elements [ <int> ] ; if ( elements . length > <int> ) { version = elements [ <int> ] ; } } if ( isOfficialPlugin ( repo , user , version ) ) { return new PluginHandle ( repo , Version . CURRENT . number ( ) , null ) ; } return new PluginHandle ( repo , version , user ) ; } static boolean isOfficialPlugin ( String repo , String user , String version ) { return version = = null & & user = = null & & ! Strings . isNullOrEmpty ( repo ) ; } } } 
