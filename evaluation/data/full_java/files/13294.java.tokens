package org . gradle . test . fixtures . server . http ; import junit . framework . AssertionFailedError ; import org . gradle . api . UncheckedIOException ; import org . gradle . internal . os . OperatingSystem ; import org . junit . rules . ExternalResource ; import java . io . IOException ; import java . io . OutputStream ; import java . net . InetSocketAddress ; import java . net . URI ; import java . net . URISyntaxException ; import java . nio . channels . * ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; public class CyclicBarrierHttpServer extends ExternalResource { private ExecutorService executor ; private ServerSocketChannel serverSocket ; private final Object lock = new Object ( ) ; private boolean connected ; private boolean released ; private boolean stopped ; @Override protected void before ( ) { start ( ) ; } @Override protected void after ( ) { stop ( ) ; } void start ( ) { try { serverSocket = ServerSocketChannel . open ( ) ; serverSocket . socket ( ) . bind ( new InetSocketAddress ( <int> ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } executor = Executors . newCachedThreadPool ( ) ; executor . execute ( new Runnable ( ) { public void run ( ) { int i = <int> ; while ( true ) { try { SocketChannel connection ; try { connection = serverSocket . accept ( ) ; } catch ( AsynchronousCloseException e ) { return ; } catch ( ClosedChannelException e ) { return ; } try { OutputStream outputStream = Channels . newOutputStream ( connection ) ; System . out . println ( <str> + ( + + i ) ) ; handleConnection ( outputStream ) ; outputStream . flush ( ) ; } finally { connection . close ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } } private void handleConnection ( OutputStream outputStream ) throws IOException { System . out . println ( <str> ) ; synchronized ( lock ) { if ( connected ) { System . out . println ( <str> ) ; outputStream . write ( <str> . getBytes ( ) ) ; return ; } System . out . println ( <str> ) ; connected = true ; lock . notifyAll ( ) ; long expiry = monotonicClockMillis ( ) + <int> ; while ( ! released & & ! stopped ) { long delay = expiry - monotonicClockMillis ( ) ; if ( delay < = <int> ) { System . out . println ( <str> ) ; outputStream . write ( <str> . getBytes ( ) ) ; return ; } try { lock . wait ( delay ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } if ( stopped ) { System . out . println ( <str> ) ; outputStream . write ( <str> . getBytes ( ) ) ; return ; } connected = false ; released = false ; lock . notifyAll ( ) ; } System . out . println ( <str> ) ; outputStream . write ( <str> . getBytes ( ) ) ; } } ) ; } void stop ( ) { System . out . println ( <str> ) ; synchronized ( lock ) { stopped = true ; lock . notifyAll ( ) ; } try { serverSocket . close ( ) ; executor . shutdown ( ) ; executor . awaitTermination ( <int> , TimeUnit . SECONDS ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public URI getUri ( ) { int port = serverSocket . socket ( ) . getLocalPort ( ) ; if ( port < = <int> ) { throw new IllegalStateException ( String . format ( <str> , port ) ) ; } try { return new URI ( String . format ( <str> , port ) ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } } public void waitFor ( ) { long expiry = monotonicClockMillis ( ) + <int> ; synchronized ( lock ) { while ( ! connected & & ! stopped ) { long delay = expiry - monotonicClockMillis ( ) ; if ( delay < = <int> ) { throw new AssertionFailedError ( String . format ( <str> , getUri ( ) ) ) ; } System . out . println ( <str> ) ; try { lock . wait ( delay ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } if ( stopped ) { throw new AssertionFailedError ( String . format ( <str> , getUri ( ) ) ) ; } System . out . println ( <str> ) ; } } private long monotonicClockMillis ( ) { return System . nanoTime ( ) / <int> ; } public void release ( ) { if ( OperatingSystem . current ( ) . isWindows ( ) ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } synchronized ( lock ) { released = true ; lock . notifyAll ( ) ; } } public void sync ( ) { synchronized ( lock ) { waitFor ( ) ; release ( ) ; } } public void waitForDisconnect ( ) { long expiry = monotonicClockMillis ( ) + <int> ; synchronized ( lock ) { while ( released & & connected & & ! stopped ) { long delay = expiry - monotonicClockMillis ( ) ; if ( delay < = <int> ) { throw new AssertionFailedError ( String . format ( <str> , getUri ( ) ) ) ; } System . out . println ( <str> ) ; try { lock . wait ( delay ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } } if ( stopped ) { throw new AssertionFailedError ( String . format ( <str> , getUri ( ) ) ) ; } System . out . println ( <str> ) ; } } } 
