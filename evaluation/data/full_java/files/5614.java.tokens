package org . elasticsearch . cluster . routing . allocation . allocator ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . IntroSorter ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . FailedRerouteAllocation ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . StartedRerouteAllocation ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDeciders ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . cluster . routing . allocation . decider . Decision . Type ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . gateway . PriorityComparator ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . IdentityHashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . function . Predicate ; import static org . elasticsearch . cluster . routing . ShardRoutingState . RELOCATING ; public class BalancedShardsAllocator extends AbstractComponent implements ShardsAllocator { public static final String SETTING_THRESHOLD = <str> ; public static final String SETTING_INDEX_BALANCE_FACTOR = <str> ; public static final String SETTING_SHARD_BALANCE_FACTOR = <str> ; private static final float DEFAULT_INDEX_BALANCE_FACTOR = <float> ; private static final float DEFAULT_SHARD_BALANCE_FACTOR = <float> ; class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { final float indexBalance = settings . getAsFloat ( SETTING_INDEX_BALANCE_FACTOR , weightFunction . indexBalance ) ; final float shardBalance = settings . getAsFloat ( SETTING_SHARD_BALANCE_FACTOR , weightFunction . shardBalance ) ; float threshold = settings . getAsFloat ( SETTING_THRESHOLD , BalancedShardsAllocator . this . threshold ) ; if ( threshold < = <float> ) { throw new IllegalArgumentException ( <str> + threshold ) ; } BalancedShardsAllocator . this . threshold = threshold ; BalancedShardsAllocator . this . weightFunction = new WeightFunction ( indexBalance , shardBalance ) ; } } private volatile WeightFunction weightFunction = new WeightFunction ( DEFAULT_INDEX_BALANCE_FACTOR , DEFAULT_SHARD_BALANCE_FACTOR ) ; private volatile float threshold = <float> ; public BalancedShardsAllocator ( Settings settings ) { this ( settings , new NodeSettingsService ( settings ) ) ; } @Inject public BalancedShardsAllocator ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; ApplySettings applySettings = new ApplySettings ( ) ; applySettings . onRefreshSettings ( settings ) ; nodeSettingsService . addListener ( applySettings ) ; } @Override public void applyStartedShards ( StartedRerouteAllocation allocation ) { } @Override public void applyFailedShards ( FailedRerouteAllocation allocation ) { } @Override public boolean allocateUnassigned ( RoutingAllocation allocation ) { final Balancer balancer = new Balancer ( logger , allocation , weightFunction , threshold ) ; return balancer . allocateUnassigned ( ) ; } @Override public boolean rebalance ( RoutingAllocation allocation ) { final Balancer balancer = new Balancer ( logger , allocation , weightFunction , threshold ) ; return balancer . balance ( ) ; } @Override public boolean move ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { final Balancer balancer = new Balancer ( logger , allocation , weightFunction , threshold ) ; return balancer . move ( shardRouting , node ) ; } public float getThreshold ( ) { return threshold ; } public float getIndexBalance ( ) { return weightFunction . indexBalance ; } public float getShardBalance ( ) { return weightFunction . shardBalance ; } public static class WeightFunction { private final float indexBalance ; private final float shardBalance ; private final float [ ] theta ; public WeightFunction ( float indexBalance , float shardBalance ) { float sum = indexBalance + shardBalance ; if ( sum < = <float> ) { throw new IllegalArgumentException ( <str> + sum ) ; } theta = new float [ ] { shardBalance / sum , indexBalance / sum } ; this . indexBalance = indexBalance ; this . shardBalance = shardBalance ; } public float weight ( Operation operation , Balancer balancer , ModelNode node , String index ) { final float weightShard = ( node . numShards ( ) - balancer . avgShardsPerNode ( ) ) ; final float weightIndex = ( node . numShards ( index ) - balancer . avgShardsPerNode ( index ) ) ; assert theta ! = null ; return theta [ <int> ] * weightShard + theta [ <int> ] * weightIndex ; } } public static enum Operation { BALANCE , ALLOCATE , MOVE } public static class Balancer { private final ESLogger logger ; private final Map < String , ModelNode > nodes = new HashMap < > ( ) ; private final HashSet < String > indices = new HashSet < > ( ) ; private final RoutingAllocation allocation ; private final RoutingNodes routingNodes ; private final WeightFunction weight ; private final float threshold ; private final MetaData metaData ; private final Predicate < ShardRouting > assignedFilter = shard - > shard . assignedToNode ( ) ; public Balancer ( ESLogger logger , RoutingAllocation allocation , WeightFunction weight , float threshold ) { this . logger = logger ; this . allocation = allocation ; this . weight = weight ; this . threshold = threshold ; this . routingNodes = allocation . routingNodes ( ) ; for ( RoutingNode node : routingNodes ) { nodes . put ( node . nodeId ( ) , new ModelNode ( node . nodeId ( ) ) ) ; } metaData = routingNodes . metaData ( ) ; } private ModelNode [ ] nodesArray ( ) { return nodes . values ( ) . toArray ( new ModelNode [ nodes . size ( ) ] ) ; } public float avgShardsPerNode ( String index ) { return ( ( float ) metaData . index ( index ) . getTotalNumberOfShards ( ) ) / nodes . size ( ) ; } public float avgShardsPerNode ( ) { return ( ( float ) metaData . totalNumberOfShards ( ) ) / nodes . size ( ) ; } public float avgPrimariesPerNode ( ) { return ( ( float ) metaData . numberOfShards ( ) ) / nodes . size ( ) ; } private NodeSorter newNodeSorter ( ) { return new NodeSorter ( nodesArray ( ) , weight , this ) ; } private boolean initialize ( RoutingNodes routing , RoutingNodes . UnassignedShards unassigned ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } for ( ObjectCursor < String > index : allocation . routingTable ( ) . indicesRouting ( ) . keys ( ) ) { indices . add ( index . value ) ; } buildModelFromAssigned ( routing . shards ( assignedFilter ) ) ; return allocateUnassigned ( unassigned ) ; } private static float absDelta ( float lower , float higher ) { assert higher > = lower : higher + <str> + lower + <str> ; return Math . abs ( higher - lower ) ; } private static boolean lessThan ( float delta , float threshold ) { return delta < = ( threshold + <float> ) ; } final boolean allocateUnassigned ( ) { return balance ( true ) ; } public boolean balance ( ) { return balance ( false ) ; } private boolean balance ( boolean onlyAssign ) { if ( this . nodes . isEmpty ( ) ) { return false ; } if ( logger . isTraceEnabled ( ) ) { if ( onlyAssign ) { logger . trace ( <str> ) ; } else { logger . trace ( <str> ) ; } } final RoutingNodes . UnassignedShards unassigned = routingNodes . unassigned ( ) ; boolean changed = initialize ( routingNodes , unassigned ) ; if ( onlyAssign = = false & & changed = = false & & allocation . deciders ( ) . canRebalance ( allocation ) . type ( ) = = Type . YES ) { NodeSorter sorter = newNodeSorter ( ) ; if ( nodes . size ( ) > <int> ) { for ( String index : buildWeightOrderedIndidces ( Operation . BALANCE , sorter ) ) { sorter . reset ( Operation . BALANCE , index ) ; final float [ ] weights = sorter . weights ; final ModelNode [ ] modelNodes = sorter . modelNodes ; int lowIdx = <int> ; int highIdx = weights . length - <int> ; while ( true ) { final ModelNode minNode = modelNodes [ lowIdx ] ; final ModelNode maxNode = modelNodes [ highIdx ] ; advance_range : if ( maxNode . numShards ( index ) > <int> ) { final float delta = absDelta ( weights [ lowIdx ] , weights [ highIdx ] ) ; if ( lessThan ( delta , threshold ) ) { if ( lowIdx > <int> & & highIdx - <int> > <int> & & ( absDelta ( weights [ <int> ] , weights [ highIdx - <int> ] ) > threshold ) ) { break advance_range ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , index , maxNode . getNodeId ( ) , weights [ highIdx ] , minNode . getNodeId ( ) , weights [ lowIdx ] , delta ) ; } break ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , maxNode . getNodeId ( ) , weights [ highIdx ] , minNode . getNodeId ( ) , weights [ lowIdx ] , delta ) ; } if ( tryRelocateShard ( Operation . BALANCE , minNode , maxNode , index , delta ) ) { weights [ lowIdx ] = sorter . weight ( Operation . BALANCE , modelNodes [ lowIdx ] ) ; weights [ highIdx ] = sorter . weight ( Operation . BALANCE , modelNodes [ highIdx ] ) ; sorter . sort ( <int> , weights . length ) ; lowIdx = <int> ; highIdx = weights . length - <int> ; changed = true ; continue ; } } if ( lowIdx < highIdx - <int> ) { lowIdx + + ; } else if ( lowIdx > <int> ) { lowIdx = <int> ; highIdx - - ; } else { break ; } } } } } return changed ; } private String [ ] buildWeightOrderedIndidces ( Operation operation , NodeSorter sorter ) { final String [ ] indices = this . indices . toArray ( new String [ this . indices . size ( ) ] ) ; final float [ ] deltas = new float [ indices . length ] ; for ( int i = <int> ; i < deltas . length ; i + + ) { sorter . reset ( operation , indices [ i ] ) ; deltas [ i ] = sorter . delta ( ) ; } new IntroSorter ( ) { float pivotWeight ; @Override protected void swap ( int i , int j ) { final String tmpIdx = indices [ i ] ; indices [ i ] = indices [ j ] ; indices [ j ] = tmpIdx ; final float tmpDelta = deltas [ i ] ; deltas [ i ] = deltas [ j ] ; deltas [ j ] = tmpDelta ; } @Override protected int compare ( int i , int j ) { return Float . compare ( deltas [ j ] , deltas [ i ] ) ; } @Override protected void setPivot ( int i ) { pivotWeight = deltas [ i ] ; } @Override protected int comparePivot ( int j ) { return Float . compare ( deltas [ j ] , pivotWeight ) ; } } . sort ( <int> , deltas . length ) ; return indices ; } public boolean move ( ShardRouting shard , RoutingNode node ) { if ( nodes . isEmpty ( ) | | ! shard . started ( ) ) { return false ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shard , node ) ; } final RoutingNodes . UnassignedShards unassigned = routingNodes . unassigned ( ) ; boolean changed = initialize ( routingNodes , unassigned ) ; if ( ! changed ) { final ModelNode sourceNode = nodes . get ( node . nodeId ( ) ) ; assert sourceNode ! = null ; final NodeSorter sorter = newNodeSorter ( ) ; sorter . reset ( Operation . MOVE , shard . getIndex ( ) ) ; final ModelNode [ ] nodes = sorter . modelNodes ; assert sourceNode . containsShard ( shard ) ; for ( ModelNode currentNode : nodes ) { if ( currentNode . getNodeId ( ) . equals ( node . nodeId ( ) ) ) { continue ; } RoutingNode target = routingNodes . node ( currentNode . getNodeId ( ) ) ; Decision allocationDecision = allocation . deciders ( ) . canAllocate ( shard , target , allocation ) ; Decision rebalanceDecision = allocation . deciders ( ) . canRebalance ( shard , allocation ) ; Decision decision = new Decision . Multi ( ) . add ( allocationDecision ) . add ( rebalanceDecision ) ; if ( decision . type ( ) = = Type . YES ) { sourceNode . removeShard ( shard ) ; ShardRouting targetRelocatingShard = routingNodes . relocate ( shard , target . nodeId ( ) , allocation . clusterInfo ( ) . getShardSize ( shard , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ) ; currentNode . addShard ( targetRelocatingShard , decision ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shard , currentNode . getNodeId ( ) ) ; } changed = true ; break ; } } } return changed ; } private void buildModelFromAssigned ( Iterable < ShardRouting > shards ) { for ( ShardRouting shard : shards ) { assert shard . assignedToNode ( ) ; if ( shard . state ( ) = = RELOCATING ) { continue ; } ModelNode node = nodes . get ( shard . currentNodeId ( ) ) ; assert node ! = null ; node . addShard ( shard , Decision . single ( Type . YES , <str> , node . getNodeId ( ) ) ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shard , node . getNodeId ( ) ) ; } } } private boolean allocateUnassigned ( RoutingNodes . UnassignedShards unassigned ) { assert ! nodes . isEmpty ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> ) ; } if ( unassigned . isEmpty ( ) ) { return false ; } boolean changed = false ; final AllocationDeciders deciders = allocation . deciders ( ) ; final PriorityComparator secondaryComparator = PriorityComparator . getAllocationComparator ( allocation ) ; final Comparator < ShardRouting > comparator = new Comparator < ShardRouting > ( ) { @Override public int compare ( ShardRouting o1 , ShardRouting o2 ) { if ( o1 . primary ( ) ^ o2 . primary ( ) ) { return o1 . primary ( ) ? - <int> : o2 . primary ( ) ? <int> : <int> ; } final int indexCmp ; if ( ( indexCmp = o1 . index ( ) . compareTo ( o2 . index ( ) ) ) = = <int> ) { return o1 . getId ( ) - o2 . getId ( ) ; } final int secondary = secondaryComparator . compare ( o1 , o2 ) ; return secondary = = <int> ? indexCmp : secondary ; } } ; ShardRouting [ ] primary = unassigned . drain ( ) ; ShardRouting [ ] secondary = new ShardRouting [ primary . length ] ; int secondaryLength = <int> ; int primaryLength = primary . length ; ArrayUtil . timSort ( primary , comparator ) ; final Set < ModelNode > throttledNodes = Collections . newSetFromMap ( new IdentityHashMap < ModelNode , Boolean > ( ) ) ; do { for ( int i = <int> ; i < primaryLength ; i + + ) { ShardRouting shard = primary [ i ] ; if ( ! shard . primary ( ) ) { boolean drop = deciders . canAllocate ( shard , allocation ) . type ( ) = = Type . NO ; if ( drop ) { unassigned . ignoreShard ( shard ) ; while ( i < primaryLength - <int> & & comparator . compare ( primary [ i ] , primary [ i + <int> ] ) = = <int> ) { unassigned . ignoreShard ( primary [ + + i ] ) ; } continue ; } else { while ( i < primaryLength - <int> & & comparator . compare ( primary [ i ] , primary [ i + <int> ] ) = = <int> ) { secondary [ secondaryLength + + ] = primary [ + + i ] ; } } } assert ! shard . assignedToNode ( ) : shard ; float minWeight = Float . POSITIVE_INFINITY ; ModelNode minNode = null ; Decision decision = null ; if ( throttledNodes . size ( ) < nodes . size ( ) ) { for ( ModelNode node : nodes . values ( ) ) { if ( throttledNodes . contains ( node ) ) { continue ; } if ( ! node . containsShard ( shard ) ) { node . addShard ( shard , Decision . ALWAYS ) ; float currentWeight = weight . weight ( Operation . ALLOCATE , this , node , shard . index ( ) ) ; Decision removed = node . removeShard ( shard ) ; assert removed ! = null ; if ( currentWeight < = minWeight ) { Decision currentDecision = deciders . canAllocate ( shard , routingNodes . node ( node . getNodeId ( ) ) , allocation ) ; NOUPDATE : if ( currentDecision . type ( ) = = Type . YES | | currentDecision . type ( ) = = Type . THROTTLE ) { if ( currentWeight = = minWeight ) { if ( currentDecision . type ( ) = = decision . type ( ) ) { final int repId = shard . id ( ) ; final int nodeHigh = node . highestPrimary ( shard . index ( ) ) ; final int minNodeHigh = minNode . highestPrimary ( shard . index ( ) ) ; if ( ( ( ( nodeHigh > repId & & minNodeHigh > repId ) | | ( nodeHigh < repId & & minNodeHigh < repId ) ) & & ( nodeHigh < minNodeHigh ) ) | | ( nodeHigh > minNodeHigh & & nodeHigh > repId & & minNodeHigh < repId ) ) { minNode = node ; minWeight = currentWeight ; decision = currentDecision ; } else { break NOUPDATE ; } } else if ( currentDecision . type ( ) ! = Type . YES ) { break NOUPDATE ; } } minNode = node ; minWeight = currentWeight ; decision = currentDecision ; } } } } } assert decision ! = null & & minNode ! = null | | decision = = null & & minNode = = null ; if ( minNode ! = null ) { minNode . addShard ( shard , decision ) ; if ( decision . type ( ) = = Type . YES ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shard , minNode . getNodeId ( ) ) ; } routingNodes . initialize ( shard , routingNodes . node ( minNode . getNodeId ( ) ) . nodeId ( ) , allocation . clusterInfo ( ) . getShardSize ( shard , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ) ; changed = true ; continue ; } else { final RoutingNode node = routingNodes . node ( minNode . getNodeId ( ) ) ; if ( deciders . canAllocate ( node , allocation ) . type ( ) ! = Type . YES ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , node , decision . type ( ) ) ; } throttledNodes . add ( minNode ) ; } } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shard , decision . type ( ) ) ; } } else if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , shard ) ; } unassigned . ignoreShard ( shard ) ; if ( ! shard . primary ( ) ) { while ( secondaryLength > <int> & & comparator . compare ( shard , secondary [ secondaryLength - <int> ] ) = = <int> ) { unassigned . ignoreShard ( secondary [ - - secondaryLength ] ) ; } } } primaryLength = secondaryLength ; ShardRouting [ ] tmp = primary ; primary = secondary ; secondary = tmp ; secondaryLength = <int> ; } while ( primaryLength > <int> ) ; return changed ; } private boolean tryRelocateShard ( Operation operation , ModelNode minNode , ModelNode maxNode , String idx , float minCost ) { final ModelIndex index = maxNode . getIndex ( idx ) ; Decision decision = null ; if ( index ! = null ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , idx , maxNode . getNodeId ( ) , minNode . getNodeId ( ) ) ; } final RoutingNode node = routingNodes . node ( minNode . getNodeId ( ) ) ; ShardRouting candidate = null ; final AllocationDeciders deciders = allocation . deciders ( ) ; final ArrayList < ShardRouting > shards = new ArrayList < > ( index . getAllShards ( ) ) ; for ( ShardRouting shard : shards ) { if ( shard . started ( ) ) { Decision allocationDecision = deciders . canAllocate ( shard , node , allocation ) ; Decision rebalanceDecision = deciders . canRebalance ( shard , allocation ) ; if ( ( ( allocationDecision . type ( ) = = Type . YES ) | | ( allocationDecision . type ( ) = = Type . THROTTLE ) ) & & ( ( rebalanceDecision . type ( ) = = Type . YES ) | | ( rebalanceDecision . type ( ) = = Type . THROTTLE ) ) ) { Decision srcDecision ; if ( ( srcDecision = maxNode . removeShard ( shard ) ) ! = null ) { minNode . addShard ( shard , srcDecision ) ; final float delta = weight . weight ( operation , this , minNode , idx ) - weight . weight ( operation , this , maxNode , idx ) ; if ( delta < minCost | | ( candidate ! = null & & delta = = minCost & & candidate . id ( ) > shard . id ( ) ) ) { minCost = delta ; candidate = shard ; decision = new Decision . Multi ( ) . add ( allocationDecision ) . add ( rebalanceDecision ) ; } minNode . removeShard ( shard ) ; maxNode . addShard ( shard , srcDecision ) ; } } } } if ( candidate ! = null ) { maxNode . removeShard ( candidate ) ; minNode . addShard ( candidate , decision ) ; if ( decision . type ( ) = = Type . YES ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , candidate , maxNode . getNodeId ( ) , minNode . getNodeId ( ) ) ; } if ( candidate . started ( ) ) { RoutingNode lowRoutingNode = routingNodes . node ( minNode . getNodeId ( ) ) ; routingNodes . relocate ( candidate , lowRoutingNode . nodeId ( ) , allocation . clusterInfo ( ) . getShardSize ( candidate , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ) ; } else { routingNodes . initialize ( candidate , routingNodes . node ( minNode . getNodeId ( ) ) . nodeId ( ) , allocation . clusterInfo ( ) . getShardSize ( candidate , ShardRouting . UNAVAILABLE_EXPECTED_SHARD_SIZE ) ) ; } return true ; } } } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , maxNode . getNodeId ( ) , minNode . getNodeId ( ) , decision = = null ? <str> : decision . type ( ) . name ( ) ) ; } return false ; } } static class ModelNode implements Iterable < ModelIndex > { private final String id ; private final Map < String , ModelIndex > indices = new HashMap < > ( ) ; private int numShards = - <int> ; public ModelNode ( String id ) { this . id = id ; } public ModelIndex getIndex ( String indexId ) { return indices . get ( indexId ) ; } public String getNodeId ( ) { return id ; } public int numShards ( ) { if ( numShards = = - <int> ) { int sum = <int> ; for ( ModelIndex index : indices . values ( ) ) { sum + = index . numShards ( ) ; } numShards = sum ; } return numShards ; } public int numShards ( String idx ) { ModelIndex index = indices . get ( idx ) ; return index = = null ? <int> : index . numShards ( ) ; } public Collection < ShardRouting > shards ( ) { Collection < ShardRouting > result = new ArrayList < > ( ) ; for ( ModelIndex index : indices . values ( ) ) { result . addAll ( index . getAllShards ( ) ) ; } return result ; } public int highestPrimary ( String index ) { ModelIndex idx = indices . get ( index ) ; if ( idx ! = null ) { return idx . highestPrimary ( ) ; } return - <int> ; } public void addShard ( ShardRouting shard , Decision decision ) { numShards = - <int> ; ModelIndex index = indices . get ( shard . index ( ) ) ; if ( index = = null ) { index = new ModelIndex ( shard . index ( ) ) ; indices . put ( index . getIndexId ( ) , index ) ; } index . addShard ( shard , decision ) ; } public Decision removeShard ( ShardRouting shard ) { numShards = - <int> ; ModelIndex index = indices . get ( shard . index ( ) ) ; Decision removed = null ; if ( index ! = null ) { removed = index . removeShard ( shard ) ; if ( removed ! = null & & index . numShards ( ) = = <int> ) { indices . remove ( shard . index ( ) ) ; } } return removed ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( id ) . append ( <str> ) ; return sb . toString ( ) ; } @Override public Iterator < ModelIndex > iterator ( ) { return indices . values ( ) . iterator ( ) ; } public boolean containsShard ( ShardRouting shard ) { ModelIndex index = getIndex ( shard . getIndex ( ) ) ; return index = = null ? false : index . containsShard ( shard ) ; } } static final class ModelIndex { private final String id ; private final Map < ShardRouting , Decision > shards = new HashMap < > ( ) ; private int numPrimaries = - <int> ; private int highestPrimary = - <int> ; public ModelIndex ( String id ) { this . id = id ; } public int highestPrimary ( ) { if ( highestPrimary = = - <int> ) { int maxId = - <int> ; for ( ShardRouting shard : shards . keySet ( ) ) { if ( shard . primary ( ) ) { maxId = Math . max ( maxId , shard . id ( ) ) ; } } return highestPrimary = maxId ; } return highestPrimary ; } public String getIndexId ( ) { return id ; } public Decision getDecicion ( ShardRouting shard ) { return shards . get ( shard ) ; } public int numShards ( ) { return shards . size ( ) ; } public Collection < ShardRouting > getAllShards ( ) { return shards . keySet ( ) ; } public int numPrimaries ( ) { if ( numPrimaries = = - <int> ) { int num = <int> ; for ( ShardRouting shard : shards . keySet ( ) ) { if ( shard . primary ( ) ) { num + + ; } } return numPrimaries = num ; } return numPrimaries ; } public Decision removeShard ( ShardRouting shard ) { highestPrimary = numPrimaries = - <int> ; return shards . remove ( shard ) ; } public void addShard ( ShardRouting shard , Decision decision ) { highestPrimary = numPrimaries = - <int> ; assert decision ! = null ; assert ! shards . containsKey ( shard ) : <str> + shards . get ( shard ) + <str> + shard ; shards . put ( shard , decision ) ; } public boolean containsShard ( ShardRouting shard ) { return shards . containsKey ( shard ) ; } } static final class NodeSorter extends IntroSorter { final ModelNode [ ] modelNodes ; final float [ ] weights ; private final WeightFunction function ; private String index ; private final Balancer balancer ; private float pivotWeight ; public NodeSorter ( ModelNode [ ] modelNodes , WeightFunction function , Balancer balancer ) { this . function = function ; this . balancer = balancer ; this . modelNodes = modelNodes ; weights = new float [ modelNodes . length ] ; } public void reset ( Operation operation , String index ) { this . index = index ; for ( int i = <int> ; i < weights . length ; i + + ) { weights [ i ] = weight ( operation , modelNodes [ i ] ) ; } sort ( <int> , modelNodes . length ) ; } public float weight ( Operation operation , ModelNode node ) { return function . weight ( operation , balancer , node , index ) ; } @Override protected void swap ( int i , int j ) { final ModelNode tmpNode = modelNodes [ i ] ; modelNodes [ i ] = modelNodes [ j ] ; modelNodes [ j ] = tmpNode ; final float tmpWeight = weights [ i ] ; weights [ i ] = weights [ j ] ; weights [ j ] = tmpWeight ; } @Override protected int compare ( int i , int j ) { return Float . compare ( weights [ i ] , weights [ j ] ) ; } @Override protected void setPivot ( int i ) { pivotWeight = weights [ i ] ; } @Override protected int comparePivot ( int j ) { return Float . compare ( pivotWeight , weights [ j ] ) ; } public float delta ( ) { return weights [ weights . length - <int> ] - weights [ <int> ] ; } } } 
