package io . netty . util . concurrent ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . util . Queue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . Executors ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; public final class GlobalEventExecutor extends AbstractScheduledEventExecutor { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( GlobalEventExecutor . class ) ; private static final long SCHEDULE_QUIET_PERIOD_INTERVAL = TimeUnit . SECONDS . toNanos ( <int> ) ; public static final GlobalEventExecutor INSTANCE = new GlobalEventExecutor ( ) ; final BlockingQueue < Runnable > taskQueue = new LinkedBlockingQueue < Runnable > ( ) ; final ScheduledFutureTask < Void > quietPeriodTask = new ScheduledFutureTask < Void > ( this , Executors . < Void > callable ( new Runnable ( ) { @Override public void run ( ) { } } , null ) , ScheduledFutureTask . deadlineNanos ( SCHEDULE_QUIET_PERIOD_INTERVAL ) , - SCHEDULE_QUIET_PERIOD_INTERVAL ) ; private final ThreadFactory threadFactory = new DefaultThreadFactory ( getClass ( ) ) ; private final TaskRunner taskRunner = new TaskRunner ( ) ; private final AtomicBoolean started = new AtomicBoolean ( ) ; volatile Thread thread ; private final Future < ? > terminationFuture = new FailedFuture < Object > ( this , new UnsupportedOperationException ( ) ) ; private GlobalEventExecutor ( ) { scheduledTaskQueue ( ) . add ( quietPeriodTask ) ; } Runnable takeTask ( ) { BlockingQueue < Runnable > taskQueue = this . taskQueue ; for ( ; ; ) { ScheduledFutureTask < ? > scheduledTask = peekScheduledTask ( ) ; if ( scheduledTask = = null ) { Runnable task = null ; try { task = taskQueue . take ( ) ; } catch ( InterruptedException e ) { } return task ; } else { long delayNanos = scheduledTask . delayNanos ( ) ; Runnable task ; if ( delayNanos > <int> ) { try { task = taskQueue . poll ( delayNanos , TimeUnit . NANOSECONDS ) ; } catch ( InterruptedException e ) { return null ; } } else { task = taskQueue . poll ( ) ; } if ( task = = null ) { fetchFromScheduledTaskQueue ( ) ; task = taskQueue . poll ( ) ; } if ( task ! = null ) { return task ; } } } } private void fetchFromScheduledTaskQueue ( ) { if ( hasScheduledTasks ( ) ) { long nanoTime = AbstractScheduledEventExecutor . nanoTime ( ) ; for ( ; ; ) { Runnable scheduledTask = pollScheduledTask ( nanoTime ) ; if ( scheduledTask = = null ) { break ; } taskQueue . add ( scheduledTask ) ; } } } public int pendingTasks ( ) { return taskQueue . size ( ) ; } private void addTask ( Runnable task ) { if ( task = = null ) { throw new NullPointerException ( <str> ) ; } taskQueue . add ( task ) ; } @Override public boolean inEventLoop ( Thread thread ) { return thread = = this . thread ; } @Override public Future < ? > shutdownGracefully ( long quietPeriod , long timeout , TimeUnit unit ) { return terminationFuture ( ) ; } @Override public Future < ? > terminationFuture ( ) { return terminationFuture ; } @Override @Deprecated public void shutdown ( ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean isShuttingDown ( ) { return false ; } @Override public boolean isShutdown ( ) { return false ; } @Override public boolean isTerminated ( ) { return false ; } @Override public boolean awaitTermination ( long timeout , TimeUnit unit ) { return false ; } public boolean awaitInactivity ( long timeout , TimeUnit unit ) throws InterruptedException { if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } final Thread thread = this . thread ; if ( thread = = null ) { throw new IllegalStateException ( <str> ) ; } thread . join ( unit . toMillis ( timeout ) ) ; return ! thread . isAlive ( ) ; } @Override public void execute ( Runnable task ) { if ( task = = null ) { throw new NullPointerException ( <str> ) ; } addTask ( task ) ; if ( ! inEventLoop ( ) ) { startThread ( ) ; } } private void startThread ( ) { if ( started . compareAndSet ( false , true ) ) { Thread t = threadFactory . newThread ( taskRunner ) ; thread = t ; t . start ( ) ; } } final class TaskRunner implements Runnable { @Override public void run ( ) { for ( ; ; ) { Runnable task = takeTask ( ) ; if ( task ! = null ) { try { task . run ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } if ( task ! = quietPeriodTask ) { continue ; } } Queue < ScheduledFutureTask < ? > > scheduledTaskQueue = GlobalEventExecutor . this . scheduledTaskQueue ; if ( taskQueue . isEmpty ( ) & & ( scheduledTaskQueue = = null | | scheduledTaskQueue . size ( ) = = <int> ) ) { boolean stopped = started . compareAndSet ( true , false ) ; assert stopped ; if ( taskQueue . isEmpty ( ) & & ( scheduledTaskQueue = = null | | scheduledTaskQueue . size ( ) = = <int> ) ) { break ; } if ( ! started . compareAndSet ( false , true ) ) { break ; } } } } } } 
