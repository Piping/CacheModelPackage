package org . elasticsearch . common . lucene . search . function ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . Explanation ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . Scorer ; import org . apache . lucene . search . Weight ; import org . apache . lucene . util . Bits ; import org . apache . lucene . util . ToStringUtils ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . lucene . Lucene ; import java . io . IOException ; import java . util . * ; public class FiltersFunctionScoreQuery extends Query { public static class FilterFunction { public final Query filter ; public final ScoreFunction function ; public FilterFunction ( Query filter , ScoreFunction function ) { this . filter = filter ; this . function = function ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } FilterFunction that = ( FilterFunction ) o ; return Objects . equals ( this . filter , that . filter ) & & Objects . equals ( this . function , that . function ) ; } @Override public int hashCode ( ) { return Objects . hash ( super . hashCode ( ) , filter , function ) ; } } public enum ScoreMode implements Writeable < ScoreMode > { FIRST , AVG , MAX , SUM , MIN , MULTIPLY ; @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( this . ordinal ( ) ) ; } @Override public ScoreMode readFrom ( StreamInput in ) throws IOException { int ordinal = in . readVInt ( ) ; if ( ordinal < <int> | | ordinal > = values ( ) . length ) { throw new IOException ( <str> + ordinal + <str> ) ; } return values ( ) [ ordinal ] ; } public static ScoreMode readScoreModeFrom ( StreamInput in ) throws IOException { return ScoreMode . MULTIPLY . readFrom ( in ) ; } public static ScoreMode fromString ( String scoreMode ) { return valueOf ( scoreMode . toUpperCase ( Locale . ROOT ) ) ; } } Query subQuery ; final FilterFunction [ ] filterFunctions ; final ScoreMode scoreMode ; final float maxBoost ; private final Float minScore ; final protected CombineFunction combineFunction ; public FiltersFunctionScoreQuery ( Query subQuery , ScoreMode scoreMode , FilterFunction [ ] filterFunctions , float maxBoost , Float minScore , CombineFunction combineFunction ) { this . subQuery = subQuery ; this . scoreMode = scoreMode ; this . filterFunctions = filterFunctions ; this . maxBoost = maxBoost ; this . combineFunction = combineFunction ; this . minScore = minScore ; } public Query getSubQuery ( ) { return subQuery ; } public FilterFunction [ ] getFilterFunctions ( ) { return filterFunctions ; } @Override public Query rewrite ( IndexReader reader ) throws IOException { Query rewritten = super . rewrite ( reader ) ; if ( rewritten ! = this ) { return rewritten ; } Query newQ = subQuery . rewrite ( reader ) ; if ( newQ = = subQuery ) return this ; FiltersFunctionScoreQuery bq = ( FiltersFunctionScoreQuery ) this . clone ( ) ; bq . subQuery = newQ ; return bq ; } @Override public Weight createWeight ( IndexSearcher searcher , boolean needsScores ) throws IOException { if ( needsScores = = false ) { return subQuery . createWeight ( searcher , needsScores ) ; } boolean subQueryNeedsScores = combineFunction ! = CombineFunction . REPLACE ; Weight [ ] filterWeights = new Weight [ filterFunctions . length ] ; for ( int i = <int> ; i < filterFunctions . length ; + + i ) { subQueryNeedsScores | = filterFunctions [ i ] . function . needsScores ( ) ; filterWeights [ i ] = searcher . createNormalizedWeight ( filterFunctions [ i ] . filter , false ) ; } Weight subQueryWeight = subQuery . createWeight ( searcher , subQueryNeedsScores ) ; return new CustomBoostFactorWeight ( this , subQueryWeight , filterWeights , subQueryNeedsScores ) ; } class CustomBoostFactorWeight extends Weight { final Weight subQueryWeight ; final Weight [ ] filterWeights ; final boolean needsScores ; public CustomBoostFactorWeight ( Query parent , Weight subQueryWeight , Weight [ ] filterWeights , boolean needsScores ) throws IOException { super ( parent ) ; this . subQueryWeight = subQueryWeight ; this . filterWeights = filterWeights ; this . needsScores = needsScores ; } @Override public void extractTerms ( Set < Term > terms ) { subQueryWeight . extractTerms ( terms ) ; } @Override public float getValueForNormalization ( ) throws IOException { return subQueryWeight . getValueForNormalization ( ) ; } @Override public void normalize ( float norm , float boost ) { subQueryWeight . normalize ( norm , boost ) ; } @Override public Scorer scorer ( LeafReaderContext context ) throws IOException { Scorer subQueryScorer = subQueryWeight . scorer ( context ) ; if ( subQueryScorer = = null ) { return null ; } final LeafScoreFunction [ ] functions = new LeafScoreFunction [ filterFunctions . length ] ; final Bits [ ] docSets = new Bits [ filterFunctions . length ] ; for ( int i = <int> ; i < filterFunctions . length ; i + + ) { FilterFunction filterFunction = filterFunctions [ i ] ; functions [ i ] = filterFunction . function . getLeafScoreFunction ( context ) ; Scorer filterScorer = filterWeights [ i ] . scorer ( context ) ; docSets [ i ] = Lucene . asSequentialAccessBits ( context . reader ( ) . maxDoc ( ) , filterScorer ) ; } return new FiltersFunctionFactorScorer ( this , subQueryScorer , scoreMode , filterFunctions , maxBoost , functions , docSets , combineFunction , minScore , needsScores ) ; } @Override public Explanation explain ( LeafReaderContext context , int doc ) throws IOException { Explanation subQueryExpl = subQueryWeight . explain ( context , doc ) ; if ( ! subQueryExpl . isMatch ( ) ) { return subQueryExpl ; } List < Explanation > filterExplanations = new ArrayList < > ( ) ; for ( int i = <int> ; i < filterFunctions . length ; + + i ) { Bits docSet = Lucene . asSequentialAccessBits ( context . reader ( ) . maxDoc ( ) , filterWeights [ i ] . scorer ( context ) ) ; if ( docSet . get ( doc ) ) { FilterFunction filterFunction = filterFunctions [ i ] ; Explanation functionExplanation = filterFunction . function . getLeafScoreFunction ( context ) . explainScore ( doc , subQueryExpl ) ; double factor = functionExplanation . getValue ( ) ; float sc = CombineFunction . toFloat ( factor ) ; Explanation filterExplanation = Explanation . match ( sc , <str> , Explanation . match ( <float> , <str> + filterFunction . filter . toString ( ) ) , functionExplanation ) ; filterExplanations . add ( filterExplanation ) ; } } if ( filterExplanations . size ( ) = = <int> ) { return subQueryExpl ; } FiltersFunctionFactorScorer scorer = ( FiltersFunctionFactorScorer ) scorer ( context ) ; int actualDoc = scorer . advance ( doc ) ; assert ( actualDoc = = doc ) ; double score = scorer . computeScore ( doc , subQueryExpl . getValue ( ) ) ; Explanation factorExplanation = Explanation . match ( CombineFunction . toFloat ( score ) , <str> + scoreMode . toString ( ) . toLowerCase ( Locale . ROOT ) + <str> , filterExplanations ) ; return combineFunction . explain ( subQueryExpl , factorExplanation , maxBoost ) ; } } static class FiltersFunctionFactorScorer extends CustomBoostFactorScorer { private final FilterFunction [ ] filterFunctions ; private final ScoreMode scoreMode ; private final LeafScoreFunction [ ] functions ; private final Bits [ ] docSets ; private final boolean needsScores ; private FiltersFunctionFactorScorer ( CustomBoostFactorWeight w , Scorer scorer , ScoreMode scoreMode , FilterFunction [ ] filterFunctions , float maxBoost , LeafScoreFunction [ ] functions , Bits [ ] docSets , CombineFunction scoreCombiner , Float minScore , boolean needsScores ) throws IOException { super ( w , scorer , maxBoost , scoreCombiner , minScore ) ; this . scoreMode = scoreMode ; this . filterFunctions = filterFunctions ; this . functions = functions ; this . docSets = docSets ; this . needsScores = needsScores ; } @Override public float innerScore ( ) throws IOException { int docId = scorer . docID ( ) ; float subQueryScore = needsScores ? scorer . score ( ) : <float> ; double factor = computeScore ( docId , subQueryScore ) ; return scoreCombiner . combine ( subQueryScore , factor , maxBoost ) ; } protected double computeScore ( int docId , float subQueryScore ) { double factor = <float> ; switch ( scoreMode ) { case FIRST : for ( int i = <int> ; i < filterFunctions . length ; i + + ) { if ( docSets [ i ] . get ( docId ) ) { factor = functions [ i ] . score ( docId , subQueryScore ) ; break ; } } break ; case MAX : double maxFactor = Double . NEGATIVE_INFINITY ; for ( int i = <int> ; i < filterFunctions . length ; i + + ) { if ( docSets [ i ] . get ( docId ) ) { maxFactor = Math . max ( functions [ i ] . score ( docId , subQueryScore ) , maxFactor ) ; } } if ( maxFactor ! = Float . NEGATIVE_INFINITY ) { factor = maxFactor ; } break ; case MIN : double minFactor = Double . POSITIVE_INFINITY ; for ( int i = <int> ; i < filterFunctions . length ; i + + ) { if ( docSets [ i ] . get ( docId ) ) { minFactor = Math . min ( functions [ i ] . score ( docId , subQueryScore ) , minFactor ) ; } } if ( minFactor ! = Float . POSITIVE_INFINITY ) { factor = minFactor ; } break ; case MULTIPLY : for ( int i = <int> ; i < filterFunctions . length ; i + + ) { if ( docSets [ i ] . get ( docId ) ) { factor * = functions [ i ] . score ( docId , subQueryScore ) ; } } break ; default : double totalFactor = <float> ; double weightSum = <int> ; for ( int i = <int> ; i < filterFunctions . length ; i + + ) { if ( docSets [ i ] . get ( docId ) ) { totalFactor + = functions [ i ] . score ( docId , subQueryScore ) ; if ( filterFunctions [ i ] . function instanceof WeightFactorFunction ) { weightSum + = ( ( WeightFactorFunction ) filterFunctions [ i ] . function ) . getWeight ( ) ; } else { weightSum + = <float> ; } } } if ( weightSum ! = <int> ) { factor = totalFactor ; if ( scoreMode = = ScoreMode . AVG ) { factor / = weightSum ; } } break ; } return factor ; } } @Override public String toString ( String field ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( subQuery . toString ( field ) ) . append ( <str> ) ; for ( FilterFunction filterFunction : filterFunctions ) { sb . append ( <str> ) . append ( filterFunction . filter ) . append ( <str> ) . append ( filterFunction . function ) . append ( <str> ) ; } sb . append ( <str> ) ; sb . append ( ToStringUtils . boost ( getBoost ( ) ) ) ; return sb . toString ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( super . equals ( o ) = = false ) { return false ; } FiltersFunctionScoreQuery other = ( FiltersFunctionScoreQuery ) o ; return Objects . equals ( this . subQuery , other . subQuery ) & & this . maxBoost = = other . maxBoost & & Objects . equals ( this . combineFunction , other . combineFunction ) & & Objects . equals ( this . minScore , other . minScore ) & & Arrays . equals ( this . filterFunctions , other . filterFunctions ) ; } @Override public int hashCode ( ) { return Objects . hash ( super . hashCode ( ) , subQuery , maxBoost , combineFunction , minScore , filterFunctions ) ; } } 
