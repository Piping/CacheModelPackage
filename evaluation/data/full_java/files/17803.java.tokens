package com . badlogic . gdx . tools . distancefield ; import java . awt . Color ; import java . awt . image . BufferedImage ; import java . io . File ; import java . io . IOException ; import javax . imageio . ImageIO ; public class DistanceFieldGenerator { private Color color = Color . white ; private int downscale = <int> ; private float spread = <int> ; public Color getColor ( ) { return color ; } public void setColor ( Color color ) { this . color = color ; } public int getDownscale ( ) { return downscale ; } public void setDownscale ( int downscale ) { if ( downscale < = <int> ) throw new IllegalArgumentException ( <str> ) ; this . downscale = downscale ; } public float getSpread ( ) { return spread ; } public void setSpread ( float spread ) { if ( spread < = <int> ) throw new IllegalArgumentException ( <str> ) ; this . spread = spread ; } private static int squareDist ( final int x1 , final int y1 , final int x2 , final int y2 ) { final int dx = x1 - x2 ; final int dy = y1 - y2 ; return dx * dx + dy * dy ; } public BufferedImage generateDistanceField ( BufferedImage inImage ) { final int inWidth = inImage . getWidth ( ) ; final int inHeight = inImage . getHeight ( ) ; final int outWidth = inWidth / downscale ; final int outHeight = inHeight / downscale ; final BufferedImage outImage = new BufferedImage ( outWidth , outHeight , BufferedImage . TYPE_4BYTE_ABGR ) ; final boolean [ ] [ ] bitmap = new boolean [ inHeight ] [ inWidth ] ; for ( int y = <int> ; y < inHeight ; + + y ) { for ( int x = <int> ; x < inWidth ; + + x ) { bitmap [ y ] [ x ] = isInside ( inImage . getRGB ( x , y ) ) ; } } for ( int y = <int> ; y < outHeight ; + + y ) { for ( int x = <int> ; x < outWidth ; + + x ) { int centerX = ( x * downscale ) + ( downscale / <int> ) ; int centerY = ( y * downscale ) + ( downscale / <int> ) ; float signedDistance = findSignedDistance ( centerX , centerY , bitmap ) ; outImage . setRGB ( x , y , distanceToRGB ( signedDistance ) ) ; } } return outImage ; } private boolean isInside ( int rgb ) { return ( rgb & <hex> ) ! = <int> & & ( rgb & <hex> ) ! = <int> ; } private int distanceToRGB ( float signedDistance ) { float alpha = <float> + <float> * ( signedDistance / spread ) ; alpha = Math . min ( <int> , Math . max ( <int> , alpha ) ) ; int alphaByte = ( int ) ( alpha * <hex> ) ; return ( alphaByte < < <int> ) | ( color . getRGB ( ) & <hex> ) ; } private float findSignedDistance ( final int centerX , final int centerY , boolean [ ] [ ] bitmap ) { final int width = bitmap [ <int> ] . length ; final int height = bitmap . length ; final boolean base = bitmap [ centerY ] [ centerX ] ; final int delta = ( int ) Math . ceil ( spread ) ; final int startX = Math . max ( <int> , centerX - delta ) ; final int endX = Math . min ( width - <int> , centerX + delta ) ; final int startY = Math . max ( <int> , centerY - delta ) ; final int endY = Math . min ( height - <int> , centerY + delta ) ; int closestSquareDist = delta * delta ; for ( int y = startY ; y < = endY ; + + y ) { for ( int x = startX ; x < = endX ; + + x ) { if ( base ! = bitmap [ y ] [ x ] ) { final int squareDist = squareDist ( centerX , centerY , x , y ) ; if ( squareDist < closestSquareDist ) { closestSquareDist = squareDist ; } } } } float closestDist = ( float ) Math . sqrt ( closestSquareDist ) ; return ( base ? <int> : - <int> ) * Math . min ( closestDist , spread ) ; } private static void usage ( ) { System . out . println ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; } private static class CommandLineArgumentException extends IllegalArgumentException { public CommandLineArgumentException ( String message ) { super ( message ) ; } } public static void main ( String [ ] args ) { try { run ( args ) ; } catch ( CommandLineArgumentException e ) { System . err . println ( <str> + e . getMessage ( ) + <str> ) ; usage ( ) ; System . exit ( <int> ) ; } } private static void run ( String [ ] args ) { DistanceFieldGenerator generator = new DistanceFieldGenerator ( ) ; String inputFile = null ; String outputFile = null ; int i = <int> ; try { for ( ; i < args . length ; + + i ) { String arg = args [ i ] ; if ( arg . startsWith ( <str> ) ) { if ( <str> . equals ( arg ) ) { usage ( ) ; System . exit ( <int> ) ; } else if ( <str> . equals ( arg ) ) { + + i ; generator . setColor ( new Color ( Integer . parseInt ( args [ i ] , <int> ) ) ) ; } else if ( <str> . equals ( arg ) ) { + + i ; generator . setDownscale ( Integer . parseInt ( args [ i ] ) ) ; } else if ( <str> . equals ( arg ) ) { + + i ; generator . setSpread ( Float . parseFloat ( args [ i ] ) ) ; } else { throw new CommandLineArgumentException ( <str> + arg ) ; } } else { if ( inputFile = = null ) { inputFile = arg ; } else if ( outputFile = = null ) { outputFile = arg ; } else { throw new CommandLineArgumentException ( <str> ) ; } } } } catch ( IndexOutOfBoundsException e ) { throw new CommandLineArgumentException ( <str> + args [ args . length - <int> ] + <str> ) ; } catch ( NumberFormatException e ) { throw new CommandLineArgumentException ( args [ i ] + <str> ) ; } if ( inputFile = = null ) { throw new CommandLineArgumentException ( <str> ) ; } if ( outputFile = = null ) { throw new CommandLineArgumentException ( <str> ) ; } String outputFormat = outputFile . substring ( outputFile . lastIndexOf ( <str> ) + <int> ) ; boolean exists ; if ( ! ImageIO . getImageWritersByFormatName ( outputFormat ) . hasNext ( ) ) { throw new RuntimeException ( <str> + outputFormat + <str> ) ; } BufferedImage input = null ; try { input = ImageIO . read ( new File ( inputFile ) ) ; } catch ( IOException e ) { System . err . println ( <str> + e . getMessage ( ) ) ; } BufferedImage output = generator . generateDistanceField ( input ) ; try { ImageIO . write ( output , outputFormat , new File ( outputFile ) ) ; } catch ( IOException e ) { System . err . println ( <str> + e . getMessage ( ) ) ; } } } 
