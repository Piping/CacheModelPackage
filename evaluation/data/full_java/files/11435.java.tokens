package org . gradle . api . internal . classpath ; import org . gradle . api . UncheckedIOException ; import org . gradle . util . CollectionUtils ; import java . io . File ; import java . io . IOException ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . jar . JarFile ; import java . util . jar . Manifest ; import java . util . zip . ZipException ; public class ManifestUtil { private static final String [ ] EMPTY = new String [ <int> ] ; public static String createManifestClasspath ( File jarFile , Collection < File > classpath ) { List < String > paths = new ArrayList < String > ( classpath . size ( ) ) ; for ( File file : classpath ) { String path = constructRelativeClasspathUri ( jarFile , file ) ; paths . add ( path ) ; } return CollectionUtils . join ( <str> , paths ) ; } private static String constructRelativeClasspathUri ( File jarFile , File file ) { URI jarFileUri = jarFile . getParentFile ( ) . toURI ( ) ; URI fileUri = file . toURI ( ) ; URI relativeUri = jarFileUri . relativize ( fileUri ) ; return relativeUri . getRawPath ( ) ; } public static List < URI > parseManifestClasspath ( File jarFile ) { List < URI > manifestClasspath = new ArrayList < URI > ( ) ; for ( String value : readManifestClasspathString ( jarFile ) ) { try { URI uri = new URI ( value ) ; uri = jarFile . toURI ( ) . resolve ( uri ) ; manifestClasspath . add ( uri ) ; } catch ( URISyntaxException e ) { throw new UncheckedIOException ( e ) ; } } return manifestClasspath ; } private static String [ ] readManifestClasspathString ( File classpathFile ) { try { Manifest manifest = findManifest ( classpathFile ) ; if ( manifest = = null ) { return EMPTY ; } String classpathEntry = manifest . getMainAttributes ( ) . getValue ( <str> ) ; if ( classpathEntry = = null | | classpathEntry . trim ( ) . length ( ) = = <int> ) { return EMPTY ; } return classpathEntry . split ( <str> ) ; } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } private static Manifest findManifest ( File possibleJarFile ) throws IOException { if ( ! possibleJarFile . exists ( ) | | ! possibleJarFile . isFile ( ) ) { return null ; } JarFile jarFile ; try { jarFile = new JarFile ( possibleJarFile ) ; } catch ( ZipException e ) { return null ; } try { return jarFile . getManifest ( ) ; } finally { jarFile . close ( ) ; } } } 
