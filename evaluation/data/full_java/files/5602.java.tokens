package org . elasticsearch . cluster . routing ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . shard . ShardId ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; public final class ShardRouting implements Streamable , ToXContent { public static final long UNAVAILABLE_EXPECTED_SHARD_SIZE = - <int> ; private String index ; private int shardId ; private String currentNodeId ; private String relocatingNodeId ; private boolean primary ; private ShardRoutingState state ; private long version ; private RestoreSource restoreSource ; private UnassignedInfo unassignedInfo ; private AllocationId allocationId ; private final transient List < ShardRouting > asList ; private transient ShardId shardIdentifier ; private boolean frozen = false ; private long expectedShardSize = UNAVAILABLE_EXPECTED_SHARD_SIZE ; private ShardRouting ( ) { this . asList = Collections . singletonList ( this ) ; } public ShardRouting ( ShardRouting copy ) { this ( copy , copy . version ( ) ) ; } public ShardRouting ( ShardRouting copy , long version ) { this ( copy . index ( ) , copy . id ( ) , copy . currentNodeId ( ) , copy . relocatingNodeId ( ) , copy . restoreSource ( ) , copy . primary ( ) , copy . state ( ) , version , copy . unassignedInfo ( ) , copy . allocationId ( ) , true , copy . getExpectedShardSize ( ) ) ; } ShardRouting ( String index , int shardId , String currentNodeId , String relocatingNodeId , RestoreSource restoreSource , boolean primary , ShardRoutingState state , long version , UnassignedInfo unassignedInfo , AllocationId allocationId , boolean internal , long expectedShardSize ) { this . index = index ; this . shardId = shardId ; this . currentNodeId = currentNodeId ; this . relocatingNodeId = relocatingNodeId ; this . primary = primary ; this . state = state ; this . asList = Collections . singletonList ( this ) ; this . version = version ; this . restoreSource = restoreSource ; this . unassignedInfo = unassignedInfo ; this . allocationId = allocationId ; this . expectedShardSize = expectedShardSize ; assert expectedShardSize = = UNAVAILABLE_EXPECTED_SHARD_SIZE | | state = = ShardRoutingState . INITIALIZING | | state = = ShardRoutingState . RELOCATING : expectedShardSize + <str> + state ; assert expectedShardSize > = <int> | | state ! = ShardRoutingState . INITIALIZING | | state ! = ShardRoutingState . RELOCATING : expectedShardSize + <str> + state ; assert ! ( state = = ShardRoutingState . UNASSIGNED & & unassignedInfo = = null ) : <str> ; if ( ! internal ) { assert state = = ShardRoutingState . UNASSIGNED ; assert currentNodeId = = null ; assert relocatingNodeId = = null ; assert allocationId = = null ; } } public static ShardRouting newUnassigned ( String index , int shardId , RestoreSource restoreSource , boolean primary , UnassignedInfo unassignedInfo ) { return new ShardRouting ( index , shardId , null , null , restoreSource , primary , ShardRoutingState . UNASSIGNED , <int> , unassignedInfo , null , true , UNAVAILABLE_EXPECTED_SHARD_SIZE ) ; } public String index ( ) { return this . index ; } public String getIndex ( ) { return index ( ) ; } public int id ( ) { return this . shardId ; } public int getId ( ) { return id ( ) ; } public long version ( ) { return this . version ; } public boolean unassigned ( ) { return state = = ShardRoutingState . UNASSIGNED ; } public boolean initializing ( ) { return state = = ShardRoutingState . INITIALIZING ; } public boolean active ( ) { return started ( ) | | relocating ( ) ; } public boolean started ( ) { return state = = ShardRoutingState . STARTED ; } public boolean relocating ( ) { return state = = ShardRoutingState . RELOCATING ; } public boolean assignedToNode ( ) { return currentNodeId ! = null ; } public String currentNodeId ( ) { return this . currentNodeId ; } public String relocatingNodeId ( ) { return this . relocatingNodeId ; } public ShardRouting buildTargetRelocatingShard ( ) { assert relocating ( ) ; return new ShardRouting ( index , shardId , relocatingNodeId , currentNodeId , restoreSource , primary , ShardRoutingState . INITIALIZING , version , unassignedInfo , AllocationId . newTargetRelocation ( allocationId ) , true , expectedShardSize ) ; } public RestoreSource restoreSource ( ) { return restoreSource ; } @Nullable public UnassignedInfo unassignedInfo ( ) { return unassignedInfo ; } @Nullable public AllocationId allocationId ( ) { return this . allocationId ; } public boolean primary ( ) { return this . primary ; } public ShardRoutingState state ( ) { return this . state ; } public ShardId shardId ( ) { if ( shardIdentifier ! = null ) { return shardIdentifier ; } shardIdentifier = new ShardId ( index , shardId ) ; return shardIdentifier ; } public boolean allocatedPostIndexCreate ( ) { if ( active ( ) ) { return true ; } if ( unassignedInfo . getReason ( ) = = UnassignedInfo . Reason . INDEX_CREATED ) { return false ; } return true ; } public ShardIterator shardsIt ( ) { return new PlainShardIterator ( shardId ( ) , asList ) ; } public static ShardRouting readShardRoutingEntry ( StreamInput in ) throws IOException { ShardRouting entry = new ShardRouting ( ) ; entry . readFrom ( in ) ; return entry ; } public static ShardRouting readShardRoutingEntry ( StreamInput in , String index , int shardId ) throws IOException { ShardRouting entry = new ShardRouting ( ) ; entry . readFrom ( in , index , shardId ) ; return entry ; } public void readFrom ( StreamInput in , String index , int shardId ) throws IOException { this . index = index ; this . shardId = shardId ; readFromThin ( in ) ; } public void readFromThin ( StreamInput in ) throws IOException { version = in . readLong ( ) ; if ( in . readBoolean ( ) ) { currentNodeId = in . readString ( ) ; } if ( in . readBoolean ( ) ) { relocatingNodeId = in . readString ( ) ; } primary = in . readBoolean ( ) ; state = ShardRoutingState . fromValue ( in . readByte ( ) ) ; restoreSource = RestoreSource . readOptionalRestoreSource ( in ) ; if ( in . readBoolean ( ) ) { unassignedInfo = new UnassignedInfo ( in ) ; } if ( in . readBoolean ( ) ) { allocationId = new AllocationId ( in ) ; } if ( relocating ( ) | | initializing ( ) ) { expectedShardSize = in . readLong ( ) ; } else { expectedShardSize = UNAVAILABLE_EXPECTED_SHARD_SIZE ; } freeze ( ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { readFrom ( in , in . readString ( ) , in . readVInt ( ) ) ; } public void writeToThin ( StreamOutput out ) throws IOException { out . writeLong ( version ) ; if ( currentNodeId ! = null ) { out . writeBoolean ( true ) ; out . writeString ( currentNodeId ) ; } else { out . writeBoolean ( false ) ; } if ( relocatingNodeId ! = null ) { out . writeBoolean ( true ) ; out . writeString ( relocatingNodeId ) ; } else { out . writeBoolean ( false ) ; } out . writeBoolean ( primary ) ; out . writeByte ( state . value ( ) ) ; if ( restoreSource ! = null ) { out . writeBoolean ( true ) ; restoreSource . writeTo ( out ) ; } else { out . writeBoolean ( false ) ; } if ( unassignedInfo ! = null ) { out . writeBoolean ( true ) ; unassignedInfo . writeTo ( out ) ; } else { out . writeBoolean ( false ) ; } if ( allocationId ! = null ) { out . writeBoolean ( true ) ; allocationId . writeTo ( out ) ; } else { out . writeBoolean ( false ) ; } if ( relocating ( ) | | initializing ( ) ) { out . writeLong ( expectedShardSize ) ; } } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( index ) ; out . writeVInt ( shardId ) ; writeToThin ( out ) ; } public void updateUnassignedInfo ( UnassignedInfo unassignedInfo ) { ensureNotFrozen ( ) ; assert this . unassignedInfo ! = null : <str> ; this . unassignedInfo = unassignedInfo ; } void moveToUnassigned ( UnassignedInfo unassignedInfo ) { ensureNotFrozen ( ) ; version + + ; assert state ! = ShardRoutingState . UNASSIGNED : this ; state = ShardRoutingState . UNASSIGNED ; currentNodeId = null ; relocatingNodeId = null ; this . unassignedInfo = unassignedInfo ; allocationId = null ; expectedShardSize = UNAVAILABLE_EXPECTED_SHARD_SIZE ; } void initialize ( String nodeId , long expectedShardSize ) { ensureNotFrozen ( ) ; version + + ; assert state = = ShardRoutingState . UNASSIGNED : this ; assert relocatingNodeId = = null : this ; state = ShardRoutingState . INITIALIZING ; currentNodeId = nodeId ; allocationId = AllocationId . newInitializing ( ) ; this . expectedShardSize = expectedShardSize ; } void relocate ( String relocatingNodeId , long expectedShardSize ) { ensureNotFrozen ( ) ; version + + ; assert state = = ShardRoutingState . STARTED : <str> + this ; state = ShardRoutingState . RELOCATING ; this . relocatingNodeId = relocatingNodeId ; this . allocationId = AllocationId . newRelocation ( allocationId ) ; this . expectedShardSize = expectedShardSize ; } void cancelRelocation ( ) { ensureNotFrozen ( ) ; version + + ; assert state = = ShardRoutingState . RELOCATING : this ; assert assignedToNode ( ) : this ; assert relocatingNodeId ! = null : this ; expectedShardSize = UNAVAILABLE_EXPECTED_SHARD_SIZE ; state = ShardRoutingState . STARTED ; relocatingNodeId = null ; allocationId = AllocationId . cancelRelocation ( allocationId ) ; } void reinitializeShard ( ) { ensureNotFrozen ( ) ; assert state = = ShardRoutingState . STARTED ; version + + ; state = ShardRoutingState . INITIALIZING ; allocationId = AllocationId . newInitializing ( ) ; this . unassignedInfo = new UnassignedInfo ( UnassignedInfo . Reason . REINITIALIZED , null ) ; } void moveToStarted ( ) { ensureNotFrozen ( ) ; version + + ; assert state = = ShardRoutingState . INITIALIZING : <str> + this ; relocatingNodeId = null ; restoreSource = null ; unassignedInfo = null ; if ( allocationId . getRelocationId ( ) ! = null ) { allocationId = AllocationId . finishRelocation ( allocationId ) ; } expectedShardSize = UNAVAILABLE_EXPECTED_SHARD_SIZE ; state = ShardRoutingState . STARTED ; } void moveToPrimary ( ) { ensureNotFrozen ( ) ; version + + ; if ( primary ) { throw new IllegalShardRoutingStateException ( this , <str> ) ; } primary = true ; } void moveFromPrimary ( ) { ensureNotFrozen ( ) ; version + + ; if ( ! primary ) { throw new IllegalShardRoutingStateException ( this , <str> ) ; } primary = false ; } public boolean isSameShard ( ShardRouting other ) { return index . equals ( other . index ) & & shardId = = other . shardId ; } public boolean isSameAllocation ( ShardRouting other ) { boolean b = this . allocationId ! = null & & other . allocationId ! = null & & this . allocationId . getId ( ) . equals ( other . allocationId . getId ( ) ) ; assert b = = false | | this . currentNodeId . equals ( other . currentNodeId ) : <str> + this + <str> + other + <str> ; return b ; } public boolean isRelocationTarget ( ) { return state = = ShardRoutingState . INITIALIZING & & relocatingNodeId ! = null ; } public boolean isRelocationTargetOf ( ShardRouting other ) { boolean b = this . allocationId ! = null & & other . allocationId ! = null & & this . state = = ShardRoutingState . INITIALIZING & & this . allocationId . getId ( ) . equals ( other . allocationId . getRelocationId ( ) ) ; assert b = = false | | other . state = = ShardRoutingState . RELOCATING : <str> + this + <str> + other + <str> ; assert b = = false | | other . allocationId . getId ( ) . equals ( this . allocationId . getRelocationId ( ) ) : <str> + this + <str> + other + <str> ; assert b = = false | | other . currentNodeId ( ) . equals ( this . relocatingNodeId ) : <str> + this + <str> + other + <str> ; assert b = = false | | this . currentNodeId ( ) . equals ( other . relocatingNodeId ) : <str> + this + <str> + other + <str> ; assert b = = false | | isSameShard ( other ) : <str> + this + <str> + other + <str> ; assert b = = false | | this . primary = = other . primary : <str> + this + <str> + other + <str> ; return b ; } public boolean isRelocationSourceOf ( ShardRouting other ) { boolean b = this . allocationId ! = null & & other . allocationId ! = null & & other . state = = ShardRoutingState . INITIALIZING & & other . allocationId . getId ( ) . equals ( this . allocationId . getRelocationId ( ) ) ; assert b = = false | | this . state = = ShardRoutingState . RELOCATING : <str> + this + <str> + other + <str> ; assert b = = false | | this . allocationId . getId ( ) . equals ( other . allocationId . getRelocationId ( ) ) : <str> + this + <str> + other + <str> ; assert b = = false | | this . currentNodeId ( ) . equals ( other . relocatingNodeId ) : <str> + this + <str> + other + <str> ; assert b = = false | | other . currentNodeId ( ) . equals ( this . relocatingNodeId ) : <str> + this + <str> + other + <str> ; assert b = = false | | isSameShard ( other ) : <str> + this + <str> + other + <str> ; assert b = = false | | this . primary = = other . primary : <str> + this + <str> + other + <str> ; return b ; } public boolean equalsIgnoringMetaData ( ShardRouting other ) { if ( primary ! = other . primary ) { return false ; } if ( shardId ! = other . shardId ) { return false ; } if ( currentNodeId ! = null ? ! currentNodeId . equals ( other . currentNodeId ) : other . currentNodeId ! = null ) { return false ; } if ( index ! = null ? ! index . equals ( other . index ) : other . index ! = null ) { return false ; } if ( relocatingNodeId ! = null ? ! relocatingNodeId . equals ( other . relocatingNodeId ) : other . relocatingNodeId ! = null ) { return false ; } if ( allocationId ! = null ? ! allocationId . equals ( other . allocationId ) : other . allocationId ! = null ) { return false ; } if ( state ! = other . state ) { return false ; } if ( restoreSource ! = null ? ! restoreSource . equals ( other . restoreSource ) : other . restoreSource ! = null ) { return false ; } return true ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | ! ( o instanceof ShardRouting ) ) { return false ; } ShardRouting that = ( ShardRouting ) o ; if ( version ! = that . version ) { return false ; } if ( unassignedInfo ! = null ? ! unassignedInfo . equals ( that . unassignedInfo ) : that . unassignedInfo ! = null ) { return false ; } return equalsIgnoringMetaData ( that ) ; } private long hashVersion = version - <int> ; private int hashCode = <int> ; @Override public int hashCode ( ) { if ( hashVersion = = version ) { return hashCode ; } int result = index ! = null ? index . hashCode ( ) : <int> ; result = <int> * result + shardId ; result = <int> * result + ( currentNodeId ! = null ? currentNodeId . hashCode ( ) : <int> ) ; result = <int> * result + ( relocatingNodeId ! = null ? relocatingNodeId . hashCode ( ) : <int> ) ; result = <int> * result + ( primary ? <int> : <int> ) ; result = <int> * result + ( state ! = null ? state . hashCode ( ) : <int> ) ; result = <int> * result + Long . hashCode ( version ) ; result = <int> * result + ( restoreSource ! = null ? restoreSource . hashCode ( ) : <int> ) ; result = <int> * result + ( allocationId ! = null ? allocationId . hashCode ( ) : <int> ) ; result = <int> * result + ( unassignedInfo ! = null ? unassignedInfo . hashCode ( ) : <int> ) ; return hashCode = result ; } @Override public String toString ( ) { return shortSummary ( ) ; } public String shortSummary ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( index ) . append ( <str> ) . append ( <str> ) . append ( shardId ) . append ( <str> ) ; sb . append ( <str> ) . append ( currentNodeId ) . append ( <str> ) ; if ( relocatingNodeId ! = null ) { sb . append ( <str> ) . append ( relocatingNodeId ) . append ( <str> ) ; } if ( primary ) { sb . append ( <str> ) ; } else { sb . append ( <str> ) ; } sb . append ( <str> ) . append ( version ) . append ( <str> ) ; if ( this . restoreSource ! = null ) { sb . append ( <str> + restoreSource + <str> ) ; } sb . append ( <str> ) . append ( state ) . append ( <str> ) ; if ( allocationId ! = null ) { sb . append ( <str> ) . append ( allocationId ) ; } if ( this . unassignedInfo ! = null ) { sb . append ( <str> ) . append ( unassignedInfo . toString ( ) ) ; } if ( expectedShardSize ! = UNAVAILABLE_EXPECTED_SHARD_SIZE ) { sb . append ( <str> ) . append ( expectedShardSize ) . append ( <str> ) ; } return sb . toString ( ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) . field ( <str> , state ( ) ) . field ( <str> , primary ( ) ) . field ( <str> , currentNodeId ( ) ) . field ( <str> , relocatingNodeId ( ) ) . field ( <str> , shardId ( ) . id ( ) ) . field ( <str> , shardId ( ) . index ( ) . name ( ) ) . field ( <str> , version ) ; if ( expectedShardSize ! = UNAVAILABLE_EXPECTED_SHARD_SIZE ) { builder . field ( <str> , expectedShardSize ) ; } if ( restoreSource ( ) ! = null ) { builder . field ( <str> ) ; restoreSource ( ) . toXContent ( builder , params ) ; } if ( allocationId ! = null ) { builder . field ( <str> ) ; allocationId . toXContent ( builder , params ) ; } if ( unassignedInfo ! = null ) { unassignedInfo . toXContent ( builder , params ) ; } return builder . endObject ( ) ; } private void ensureNotFrozen ( ) { if ( frozen ) { throw new IllegalStateException ( <str> ) ; } } void freeze ( ) { frozen = true ; } boolean isFrozen ( ) { return frozen ; } public long getExpectedShardSize ( ) { return expectedShardSize ; } } 
