package org . elasticsearch . index . query ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . BytesRefs ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . internal . TypeFieldMapper ; import java . io . IOException ; import java . util . Objects ; public class TypeQueryBuilder extends AbstractQueryBuilder < TypeQueryBuilder > { public static final String NAME = <str> ; private final BytesRef type ; static final TypeQueryBuilder PROTOTYPE = new TypeQueryBuilder ( <str> ) ; public TypeQueryBuilder ( String type ) { if ( type = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . type = BytesRefs . toBytesRef ( type ) ; } TypeQueryBuilder ( BytesRef type ) { if ( type = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . type = type ; } public String type ( ) { return BytesRefs . toString ( this . type ) ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . field ( TypeQueryParser . VALUE_FIELD . getPreferredName ( ) , type . utf8ToString ( ) ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override public String getWriteableName ( ) { return NAME ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { Query filter ; DocumentMapper documentMapper = context . getMapperService ( ) . documentMapper ( type . utf8ToString ( ) ) ; if ( documentMapper = = null ) { filter = new TermQuery ( new Term ( TypeFieldMapper . NAME , type ) ) ; } else { filter = documentMapper . typeFilter ( ) ; } return filter ; } @Override protected TypeQueryBuilder doReadFrom ( StreamInput in ) throws IOException { return new TypeQueryBuilder ( in . readBytesRef ( ) ) ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeBytesRef ( type ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( type ) ; } @Override protected boolean doEquals ( TypeQueryBuilder other ) { return Objects . equals ( type , other . type ) ; } } 
