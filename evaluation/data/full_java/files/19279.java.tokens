package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . CharsetUtil ; import org . junit . Test ; import static org . hamcrest . CoreMatchers . * ; import static org . junit . Assert . * ; public class HttpServerCodecTest { @Test public void testUnfinishedChunkedHttpRequestIsLastFlag ( ) throws Exception { int maxChunkSize = <int> ; HttpServerCodec httpServerCodec = new HttpServerCodec ( <int> , <int> , maxChunkSize ) ; EmbeddedChannel decoderEmbedder = new EmbeddedChannel ( httpServerCodec ) ; int totalContentLength = maxChunkSize * <int> ; decoderEmbedder . writeInbound ( Unpooled . copiedBuffer ( <str> + <str> + totalContentLength + <str> + <str> , CharsetUtil . UTF_8 ) ) ; int offeredContentLength = ( int ) ( maxChunkSize * <float> ) ; decoderEmbedder . writeInbound ( prepareDataChunk ( offeredContentLength ) ) ; decoderEmbedder . finish ( ) ; HttpMessage httpMessage = decoderEmbedder . readInbound ( ) ; assertNotNull ( httpMessage ) ; boolean empty = true ; int totalBytesPolled = <int> ; for ( ; ; ) { HttpContent httpChunk = decoderEmbedder . readInbound ( ) ; if ( httpChunk = = null ) { break ; } empty = false ; totalBytesPolled + = httpChunk . content ( ) . readableBytes ( ) ; assertFalse ( httpChunk instanceof LastHttpContent ) ; httpChunk . release ( ) ; } assertFalse ( empty ) ; assertEquals ( offeredContentLength , totalBytesPolled ) ; } @Test public void test100Continue ( ) throws Exception { EmbeddedChannel ch = new EmbeddedChannel ( new HttpServerCodec ( ) , new HttpObjectAggregator ( <int> ) ) ; ch . writeInbound ( Unpooled . copiedBuffer ( <str> + <str> + <str> , CharsetUtil . UTF_8 ) ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; ByteBuf continueResponse = ch . readOutbound ( ) ; assertThat ( continueResponse . toString ( CharsetUtil . UTF_8 ) , is ( <str> ) ) ; continueResponse . release ( ) ; assertThat ( ch . readOutbound ( ) , is ( nullValue ( ) ) ) ; ch . writeInbound ( Unpooled . wrappedBuffer ( new byte [ ] { <int> } ) ) ; FullHttpRequest req = ch . readInbound ( ) ; assertThat ( req . headers ( ) . get ( HttpHeaderNames . CONTENT_LENGTH ) , is ( <str> ) ) ; assertThat ( req . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( req . content ( ) . readByte ( ) , is ( ( byte ) <int> ) ) ; req . release ( ) ; assertThat ( ch . readInbound ( ) , is ( nullValue ( ) ) ) ; FullHttpResponse res = new DefaultFullHttpResponse ( HttpVersion . HTTP_1_1 , HttpResponseStatus . CREATED ) ; res . content ( ) . writeBytes ( <str> . getBytes ( CharsetUtil . UTF_8 ) ) ; res . headers ( ) . setInt ( HttpHeaderNames . CONTENT_LENGTH , <int> ) ; ch . writeOutbound ( res ) ; ByteBuf encodedRes = ch . readOutbound ( ) ; assertThat ( encodedRes . toString ( CharsetUtil . UTF_8 ) , is ( <str> + HttpHeaderNames . CONTENT_LENGTH + <str> ) ) ; encodedRes . release ( ) ; ch . finish ( ) ; } private static ByteBuf prepareDataChunk ( int size ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = <int> ; i < size ; + + i ) { sb . append ( <str> ) ; } return Unpooled . copiedBuffer ( sb . toString ( ) , CharsetUtil . UTF_8 ) ; } } 
