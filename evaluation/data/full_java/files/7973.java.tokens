package org . elasticsearch . common . unit ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . xcontent . XContent ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . hamcrest . CoreMatchers . anyOf ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . sameInstance ; import static org . hamcrest . number . IsCloseTo . closeTo ; public class FuzzinessTests extends ESTestCase { public void testNumerics ( ) { String [ ] options = new String [ ] { <str> , <str> , <str> } ; assertThat ( Fuzziness . build ( randomFrom ( options ) ) . asByte ( ) , equalTo ( ( byte ) <int> ) ) ; assertThat ( Fuzziness . build ( randomFrom ( options ) ) . asInt ( ) , equalTo ( <int> ) ) ; assertThat ( Fuzziness . build ( randomFrom ( options ) ) . asFloat ( ) , equalTo ( <float> ) ) ; assertThat ( Fuzziness . build ( randomFrom ( options ) ) . asDouble ( ) , equalTo ( <float> ) ) ; assertThat ( Fuzziness . build ( randomFrom ( options ) ) . asLong ( ) , equalTo ( <int> ) ) ; assertThat ( Fuzziness . build ( randomFrom ( options ) ) . asShort ( ) , equalTo ( ( short ) <int> ) ) ; } public void testParseFromXContent ( ) throws IOException { final int iters = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { { XContent xcontent = XContentType . JSON . xContent ( ) ; float floatValue = randomFloat ( ) ; String json = jsonBuilder ( ) . startObject ( ) . field ( Fuzziness . X_FIELD_NAME , floatValue ) . endObject ( ) . string ( ) ; XContentParser parser = xcontent . createParser ( json ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . START_OBJECT ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . FIELD_NAME ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . VALUE_NUMBER ) ) ; Fuzziness parse = Fuzziness . parse ( parser ) ; assertThat ( parse . asFloat ( ) , equalTo ( floatValue ) ) ; assertThat ( parse . asDouble ( ) , closeTo ( floatValue , <float> ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . END_OBJECT ) ) ; } { XContent xcontent = XContentType . JSON . xContent ( ) ; Integer intValue = frequently ( ) ? randomIntBetween ( <int> , <int> ) : randomIntBetween ( <int> , <int> ) ; Float floatRep = randomFloat ( ) ; Number value = intValue ; if ( randomBoolean ( ) ) { value = new Float ( floatRep + = intValue ) ; } String json = jsonBuilder ( ) . startObject ( ) . field ( Fuzziness . X_FIELD_NAME , randomBoolean ( ) ? value . toString ( ) : value ) . endObject ( ) . string ( ) ; XContentParser parser = xcontent . createParser ( json ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . START_OBJECT ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . FIELD_NAME ) ) ; assertThat ( parser . nextToken ( ) , anyOf ( equalTo ( XContentParser . Token . VALUE_NUMBER ) , equalTo ( XContentParser . Token . VALUE_STRING ) ) ) ; Fuzziness parse = Fuzziness . parse ( parser ) ; assertThat ( parse . asInt ( ) , equalTo ( value . intValue ( ) ) ) ; assertThat ( ( int ) parse . asShort ( ) , equalTo ( value . intValue ( ) ) ) ; assertThat ( ( int ) parse . asByte ( ) , equalTo ( value . intValue ( ) ) ) ; assertThat ( parse . asLong ( ) , equalTo ( value . longValue ( ) ) ) ; if ( value . intValue ( ) > = <int> ) { assertThat ( parse . asDistance ( ) , equalTo ( Math . min ( <int> , value . intValue ( ) ) ) ) ; } assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . END_OBJECT ) ) ; if ( intValue . equals ( value ) ) { switch ( intValue ) { case <int> : assertThat ( parse , sameInstance ( Fuzziness . ONE ) ) ; break ; case <int> : assertThat ( parse , sameInstance ( Fuzziness . TWO ) ) ; break ; case <int> : assertThat ( parse , sameInstance ( Fuzziness . ZERO ) ) ; break ; default : break ; } } } { XContent xcontent = XContentType . JSON . xContent ( ) ; String json = jsonBuilder ( ) . startObject ( ) . field ( Fuzziness . X_FIELD_NAME , randomBoolean ( ) ? <str> : <str> ) . endObject ( ) . string ( ) ; if ( randomBoolean ( ) ) { json = Fuzziness . AUTO . toXContent ( jsonBuilder ( ) . startObject ( ) , null ) . endObject ( ) . string ( ) ; } XContentParser parser = xcontent . createParser ( json ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . START_OBJECT ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . FIELD_NAME ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . VALUE_STRING ) ) ; Fuzziness parse = Fuzziness . parse ( parser ) ; assertThat ( parse , sameInstance ( Fuzziness . AUTO ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . END_OBJECT ) ) ; } { String [ ] values = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> } ; String actual = randomIntBetween ( <int> , <int> ) + randomFrom ( values ) ; XContent xcontent = XContentType . JSON . xContent ( ) ; String json = jsonBuilder ( ) . startObject ( ) . field ( Fuzziness . X_FIELD_NAME , actual ) . endObject ( ) . string ( ) ; XContentParser parser = xcontent . createParser ( json ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . START_OBJECT ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . FIELD_NAME ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . VALUE_STRING ) ) ; Fuzziness parse = Fuzziness . parse ( parser ) ; assertThat ( parse . asTimeValue ( ) , equalTo ( TimeValue . parseTimeValue ( actual , null , <str> ) ) ) ; assertThat ( parser . nextToken ( ) , equalTo ( XContentParser . Token . END_OBJECT ) ) ; } } } public void testAuto ( ) { assertThat ( Fuzziness . AUTO . asByte ( ) , equalTo ( ( byte ) <int> ) ) ; assertThat ( Fuzziness . AUTO . asInt ( ) , equalTo ( <int> ) ) ; assertThat ( Fuzziness . AUTO . asFloat ( ) , equalTo ( <float> ) ) ; assertThat ( Fuzziness . AUTO . asDouble ( ) , equalTo ( <float> ) ) ; assertThat ( Fuzziness . AUTO . asLong ( ) , equalTo ( <int> ) ) ; assertThat ( Fuzziness . AUTO . asShort ( ) , equalTo ( ( short ) <int> ) ) ; assertThat ( Fuzziness . AUTO . asTimeValue ( ) , equalTo ( TimeValue . parseTimeValue ( <str> , TimeValue . timeValueMillis ( <int> ) , <str> ) ) ) ; } public void testAsDistance ( ) { final int iters = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { Integer integer = Integer . valueOf ( randomIntBetween ( <int> , <int> ) ) ; String value = <str> + ( randomBoolean ( ) ? integer . intValue ( ) : integer . floatValue ( ) ) ; assertThat ( Fuzziness . build ( value ) . asDistance ( ) , equalTo ( Math . min ( <int> , integer . intValue ( ) ) ) ) ; } } public void testSerialization ( ) throws IOException { Fuzziness fuzziness = Fuzziness . AUTO ; Fuzziness deserializedFuzziness = doSerializeRoundtrip ( fuzziness ) ; assertEquals ( fuzziness , deserializedFuzziness ) ; fuzziness = Fuzziness . fromEdits ( randomIntBetween ( <int> , <int> ) ) ; deserializedFuzziness = doSerializeRoundtrip ( fuzziness ) ; assertEquals ( fuzziness , deserializedFuzziness ) ; } public void testSerializationAuto ( ) throws IOException { Fuzziness fuzziness = Fuzziness . AUTO ; Fuzziness deserializedFuzziness = doSerializeRoundtrip ( fuzziness ) ; assertEquals ( fuzziness , deserializedFuzziness ) ; assertEquals ( fuzziness . asInt ( ) , deserializedFuzziness . asInt ( ) ) ; } private static Fuzziness doSerializeRoundtrip ( Fuzziness in ) throws IOException { BytesStreamOutput output = new BytesStreamOutput ( ) ; in . writeTo ( output ) ; StreamInput streamInput = StreamInput . wrap ( output . bytes ( ) ) ; return Fuzziness . readFuzzinessFrom ( streamInput ) ; } } 
