package com . badlogic . gdx . setup ; import java . io . * ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . swing . JOptionPane ; import com . badlogic . gdx . setup . DependencyBank . ProjectDependency ; import com . badlogic . gdx . setup . DependencyBank . ProjectType ; import com . badlogic . gdx . setup . Executor . CharCallback ; public class GdxSetup { public static boolean isSdkLocationValid ( String sdkLocation ) { return new File ( sdkLocation , <str> ) . exists ( ) & & new File ( sdkLocation , <str> ) . exists ( ) ; } public static boolean isEmptyDirectory ( String destination ) { if ( new File ( destination ) . exists ( ) ) { return new File ( destination ) . list ( ) . length = = <int> ; } else { return true ; } } public static boolean isSdkUpToDate ( String sdkLocation ) { File buildTools = new File ( sdkLocation , <str> ) ; if ( ! buildTools . exists ( ) ) { JOptionPane . showMessageDialog ( null , <str> + DependencyBank . buildToolsVersion ) ; return false ; } File apis = new File ( sdkLocation , <str> ) ; if ( ! apis . exists ( ) ) { JOptionPane . showMessageDialog ( null , <str> + DependencyBank . androidAPILevel ) ; return false ; } String newestLocalTool = getLatestTools ( buildTools ) ; int [ ] localToolVersion = convertTools ( newestLocalTool ) ; int [ ] targetToolVersion = convertTools ( DependencyBank . buildToolsVersion ) ; if ( compareVersions ( targetToolVersion , localToolVersion ) ) { int value = JOptionPane . showConfirmDialog ( null , <str> , <str> , JOptionPane . YES_NO_OPTION ) ; if ( value ! = <int> ) { JOptionPane . showMessageDialog ( null , <str> + DependencyBank . buildToolsVersion ) ; } else { DependencyBank . buildToolsVersion = newestLocalTool ; } } else { if ( ! versionsEqual ( localToolVersion , targetToolVersion ) ) { JOptionPane . showMessageDialog ( null , <str> + DependencyBank . buildToolsVersion ) ; return false ; } } int newestLocalApi = getLatestApi ( apis ) ; if ( newestLocalApi > Integer . valueOf ( DependencyBank . androidAPILevel ) ) { int value = JOptionPane . showConfirmDialog ( null , <str> , <str> , JOptionPane . YES_NO_OPTION ) ; if ( value ! = <int> ) { JOptionPane . showMessageDialog ( null , <str> + DependencyBank . androidAPILevel ) ; } else { DependencyBank . androidAPILevel = String . valueOf ( newestLocalApi ) ; } } else { if ( newestLocalApi ! = Integer . valueOf ( DependencyBank . androidAPILevel ) ) { JOptionPane . showMessageDialog ( null , <str> + DependencyBank . androidAPILevel ) ; return false ; } } return true ; } private static int getLatestApi ( File apis ) { int apiLevel = <int> ; for ( File api : apis . listFiles ( ) ) { int level = readAPIVersion ( api ) ; if ( level > apiLevel ) apiLevel = level ; } return apiLevel ; } private static String getLatestTools ( File buildTools ) { String version = null ; int [ ] versionSplit = new int [ <int> ] ; int [ ] testSplit = new int [ <int> ] ; for ( File toolsVersion : buildTools . listFiles ( ) ) { if ( version = = null ) { version = readBuildToolsVersion ( toolsVersion ) ; versionSplit = convertTools ( version ) ; continue ; } testSplit = convertTools ( readBuildToolsVersion ( toolsVersion ) ) ; if ( compareVersions ( versionSplit , testSplit ) ) { version = readBuildToolsVersion ( toolsVersion ) ; versionSplit = convertTools ( version ) ; } } if ( version ! = null ) { return version ; } else { return <str> ; } } private static int readAPIVersion ( File parentFile ) { File properties = new File ( parentFile , <str> ) ; FileReader reader ; BufferedReader buffer ; try { reader = new FileReader ( properties ) ; buffer = new BufferedReader ( reader ) ; String line = null ; while ( ( line = buffer . readLine ( ) ) ! = null ) { if ( line . contains ( <str> ) ) { String versionString = line . split ( <str> ) [ <int> ] ; int apiLevel = Integer . parseInt ( versionString ) ; buffer . close ( ) ; reader . close ( ) ; return apiLevel ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( NumberFormatException e ) { e . printStackTrace ( ) ; } return <int> ; } private static String readBuildToolsVersion ( File parentFile ) { File properties = new File ( parentFile , <str> ) ; FileReader reader ; BufferedReader buffer ; try { reader = new FileReader ( properties ) ; buffer = new BufferedReader ( reader ) ; String line = null ; while ( ( line = buffer . readLine ( ) ) ! = null ) { if ( line . contains ( <str> ) ) { String versionString = line . split ( <str> ) [ <int> ] ; int count = versionString . split ( <str> ) . length ; for ( int i = <int> ; i < <int> - count ; i + + ) { versionString + = <str> ; } buffer . close ( ) ; reader . close ( ) ; return versionString ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return <str> ; } private static boolean versionsEqual ( int [ ] testVersion , int [ ] targetVersion ) { for ( int i = <int> ; i < <int> ; i + + ) { if ( testVersion [ i ] ! = targetVersion [ i ] ) return false ; } return true ; } private static boolean compareVersions ( int [ ] version , int [ ] testVersion ) { if ( testVersion [ <int> ] > version [ <int> ] ) { return true ; } else if ( testVersion [ <int> ] = = version [ <int> ] ) { if ( testVersion [ <int> ] > version [ <int> ] ) { return true ; } else if ( testVersion [ <int> ] = = version [ <int> ] ) { return testVersion [ <int> ] > version [ <int> ] ; } } return false ; } private static int [ ] convertTools ( String toolsVersion ) { String [ ] stringSplit = toolsVersion . split ( <str> ) ; int [ ] versionSplit = new int [ <int> ] ; if ( stringSplit . length = = <int> ) { try { versionSplit [ <int> ] = Integer . parseInt ( stringSplit [ <int> ] ) ; versionSplit [ <int> ] = Integer . parseInt ( stringSplit [ <int> ] ) ; versionSplit [ <int> ] = Integer . parseInt ( stringSplit [ <int> ] ) ; return versionSplit ; } catch ( NumberFormatException nfe ) { return new int [ ] { <int> , <int> , <int> } ; } } else { return new int [ ] { <int> , <int> , <int> } ; } } public void build ( ProjectBuilder builder , String outputDir , String appName , String packageName , String mainClass , String sdkLocation , CharCallback callback , List < String > gradleArgs ) { Project project = new Project ( ) ; String packageDir = packageName . replace ( <str> , <str> ) ; String sdkPath = sdkLocation . replace ( <str> , <str> ) ; if ( ! isSdkLocationValid ( sdkLocation ) ) { System . out . println ( <str> + sdkLocation + <str> ) ; } project . files . add ( new ProjectFile ( <str> , <str> , false ) ) ; project . files . add ( new TemporaryProjectFile ( builder . settingsFile , <str> , false ) ) ; project . files . add ( new TemporaryProjectFile ( builder . buildFile , <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> ) ) ; project . files . add ( new ProjectFile ( <str> ) ) ; project . files . add ( new ProjectFile ( <str> , <str> + packageDir + <str> + mainClass + <str> , true ) ) ; if ( builder . modules . contains ( ProjectType . HTML ) ) { project . files . add ( new ProjectFile ( <str> , <str> + mainClass + <str> , true ) ) ; } if ( builder . modules . contains ( ProjectType . DESKTOP ) ) { project . files . add ( new ProjectFile ( <str> ) ) ; project . files . add ( new ProjectFile ( <str> , <str> + packageDir + <str> , true ) ) ; } String assetPath = builder . modules . contains ( ProjectType . ANDROID ) ? <str> : <str> ; project . files . add ( new ProjectFile ( <str> , assetPath + <str> , false ) ) ; if ( builder . modules . contains ( ProjectType . ANDROID ) ) { project . files . add ( new ProjectFile ( <str> ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , <str> + packageDir + <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> ) ) ; project . files . add ( new ProjectFile ( <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , true ) ) ; } if ( builder . modules . contains ( ProjectType . HTML ) ) { project . files . add ( new ProjectFile ( <str> ) ) ; project . files . add ( new ProjectFile ( <str> , <str> + packageDir + <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> , <str> + packageDir + <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> , <str> + packageDir + <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> , <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> , <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , <str> , true ) ) ; } if ( builder . modules . contains ( ProjectType . IOS ) ) { project . files . add ( new ProjectFile ( <str> , <str> + packageDir + <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> , true ) ) ; project . files . add ( new ProjectFile ( <str> , false ) ) ; project . files . add ( new ProjectFile ( <str> ) ) ; project . files . add ( new ProjectFile ( <str> , true ) ) ; } Map < String , String > values = new HashMap < String , String > ( ) ; values . put ( <str> , appName ) ; values . put ( <str> , appName . replace ( <str> , <str> ) ) ; values . put ( <str> , packageName ) ; values . put ( <str> , packageDir ) ; values . put ( <str> , mainClass ) ; values . put ( <str> , sdkPath ) ; values . put ( <str> , assetPath ) ; values . put ( <str> , DependencyBank . buildToolsVersion ) ; values . put ( <str> , DependencyBank . androidAPILevel ) ; values . put ( <str> , DependencyBank . gwtVersion ) ; if ( builder . modules . contains ( ProjectType . HTML ) ) { values . put ( <str> , parseGwtInherits ( builder ) ) ; } copyAndReplace ( outputDir , project , values ) ; builder . cleanUp ( ) ; new File ( outputDir , <str> ) . setExecutable ( true ) ; Executor . execute ( new File ( outputDir ) , <str> , <str> , <str> + parseGradleArgs ( builder . modules , gradleArgs ) , callback ) ; } private void copyAndReplace ( String outputDir , Project project , Map < String , String > values ) { File out = new File ( outputDir ) ; if ( ! out . exists ( ) & & ! out . mkdirs ( ) ) { throw new RuntimeException ( <str> + out . getAbsolutePath ( ) + <str> ) ; } for ( ProjectFile file : project . files ) { copyFile ( file , out , values ) ; } } private byte [ ] readResource ( String resource , String path ) { InputStream in = null ; try { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <int> * <int> ] ; in = GdxSetup . class . getResourceAsStream ( path + resource ) ; if ( in = = null ) throw new RuntimeException ( <str> + resource + <str> ) ; int read = <int> ; while ( ( read = in . read ( buffer ) ) > <int> ) { bytes . write ( buffer , <int> , read ) ; } return bytes . toByteArray ( ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> + resource + <str> , e ) ; } finally { if ( in ! = null ) try { in . close ( ) ; } catch ( IOException e ) { } } } private byte [ ] readResource ( File file ) { InputStream in = null ; try { ByteArrayOutputStream bytes = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ <int> * <int> ] ; in = new FileInputStream ( file ) ; if ( in = = null ) throw new RuntimeException ( <str> + file . getAbsoluteFile ( ) + <str> ) ; int read = <int> ; while ( ( read = in . read ( buffer ) ) > <int> ) { bytes . write ( buffer , <int> , read ) ; } return bytes . toByteArray ( ) ; } catch ( Throwable e ) { throw new RuntimeException ( <str> + file . getAbsoluteFile ( ) + <str> , e ) ; } finally { if ( in ! = null ) try { in . close ( ) ; } catch ( IOException e ) { } } } private String readResourceAsString ( String resource , String path ) { try { return new String ( readResource ( resource , path ) , <str> ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } private String readResourceAsString ( File file ) { try { return new String ( readResource ( file ) , <str> ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } private void writeFile ( File outFile , byte [ ] bytes ) { OutputStream out = null ; try { out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; out . write ( bytes ) ; } catch ( IOException e ) { throw new RuntimeException ( <str> + outFile . getAbsolutePath ( ) + <str> , e ) ; } finally { if ( out ! = null ) try { out . close ( ) ; } catch ( IOException e ) { } } } private void writeFile ( File outFile , String text ) { try { writeFile ( outFile , text . getBytes ( <str> ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } } private void copyFile ( ProjectFile file , File out , Map < String , String > values ) { File outFile = new File ( out , file . outputName ) ; if ( ! outFile . getParentFile ( ) . exists ( ) & & ! outFile . getParentFile ( ) . mkdirs ( ) ) { throw new RuntimeException ( <str> + outFile . getAbsolutePath ( ) + <str> ) ; } boolean isTemp = file instanceof TemporaryProjectFile ? true : false ; if ( file . isTemplate ) { String txt ; if ( isTemp ) { txt = readResourceAsString ( ( ( TemporaryProjectFile ) file ) . file ) ; } else { txt = readResourceAsString ( file . resourceName , file . resourceLoc ) ; } txt = replace ( txt , values ) ; writeFile ( outFile , txt ) ; } else { if ( isTemp ) { writeFile ( outFile , readResource ( ( ( TemporaryProjectFile ) file ) . file ) ) ; } else { writeFile ( outFile , readResource ( file . resourceName , file . resourceLoc ) ) ; } } } private String replace ( String txt , Map < String , String > values ) { for ( String key : values . keySet ( ) ) { String value = values . get ( key ) ; txt = txt . replace ( key , value ) ; } return txt ; } private static void printHelp ( ) { System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; System . out . println ( <str> ) ; } private static Map < String , String > parseArgs ( String [ ] args ) { if ( args . length % <int> ! = <int> ) { printHelp ( ) ; System . exit ( - <int> ) ; } Map < String , String > params = new HashMap < String , String > ( ) ; for ( int i = <int> ; i < args . length ; i + = <int> ) { String param = args [ i ] . replace ( <str> , <str> ) ; String value = args [ i + <int> ] ; params . put ( param , value ) ; } return params ; } private String parseGwtInherits ( ProjectBuilder builder ) { String parsed = <str> ; for ( Dependency dep : builder . dependencies ) { if ( dep . getGwtInherits ( ) ! = null ) { for ( String inherit : dep . getGwtInherits ( ) ) { parsed + = <str> + inherit + <str> ; } } } return parsed ; } private String parseGradleArgs ( List < ProjectType > modules , List < String > args ) { String argString = <str> ; if ( args = = null ) return argString ; for ( String argument : args ) { if ( argument . equals ( <str> ) & & ! modules . contains ( ProjectType . DESKTOP ) ) continue ; argString + = <str> + argument ; } return argString ; } private boolean containsDependency ( List < Dependency > dependencyList , ProjectDependency projectDependency ) { for ( Dependency dep : dependencyList ) { if ( dep . getName ( ) . equals ( projectDependency . name ( ) ) ) { return true ; } } return false ; } public static void main ( String [ ] args ) throws IOException { Map < String , String > params = parseArgs ( args ) ; if ( ! params . containsKey ( <str> ) | | ! params . containsKey ( <str> ) | | ! params . containsKey ( <str> ) | | ! params . containsKey ( <str> ) | | ( ( ! params . containsKey ( <str> ) & & System . getenv ( <str> ) = = null ) ) ) { new GdxSetupUI ( ) ; printHelp ( ) ; } else { String sdkLocation = <str> ; if ( System . getenv ( <str> ) ! = null & & ! params . containsKey ( <str> ) ) { sdkLocation = System . getenv ( <str> ) ; } else { sdkLocation = params . get ( <str> ) ; } DependencyBank bank = new DependencyBank ( ) ; ProjectBuilder builder = new ProjectBuilder ( bank ) ; List < ProjectType > projects = new ArrayList < ProjectType > ( ) ; projects . add ( ProjectType . CORE ) ; projects . add ( ProjectType . DESKTOP ) ; projects . add ( ProjectType . ANDROID ) ; projects . add ( ProjectType . IOS ) ; projects . add ( ProjectType . HTML ) ; List < Dependency > dependencies = new ArrayList < Dependency > ( ) ; dependencies . add ( bank . getDependency ( ProjectDependency . GDX ) ) ; builder . buildProject ( projects , dependencies ) ; builder . build ( ) ; new GdxSetup ( ) . build ( builder , params . get ( <str> ) , params . get ( <str> ) , params . get ( <str> ) , params . get ( <str> ) , sdkLocation , new CharCallback ( ) { @Override public void character ( char c ) { System . out . print ( c ) ; } } , null ) ; } } } 
