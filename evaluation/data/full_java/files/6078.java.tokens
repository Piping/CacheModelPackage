package org . elasticsearch . common . util ; import com . carrotsearch . hppc . BitMixer ; import org . elasticsearch . common . lease . Releasable ; abstract class AbstractPagedHashMap implements Releasable { static final float DEFAULT_MAX_LOAD_FACTOR = <float> ; static long hash ( long value ) { return BitMixer . mix64 ( value ) ; } static long hash ( double value ) { return hash ( Double . doubleToLongBits ( value ) ) ; } final BigArrays bigArrays ; final float maxLoadFactor ; long size , maxSize ; long mask ; AbstractPagedHashMap ( long capacity , float maxLoadFactor , BigArrays bigArrays ) { if ( capacity < <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( maxLoadFactor < = <int> | | maxLoadFactor > = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . bigArrays = bigArrays ; this . maxLoadFactor = maxLoadFactor ; long buckets = <int> + ( long ) ( capacity / maxLoadFactor ) ; buckets = Math . max ( <int> , Long . highestOneBit ( buckets - <int> ) < < <int> ) ; assert buckets = = Long . highestOneBit ( buckets ) ; maxSize = ( long ) ( buckets * maxLoadFactor ) ; assert maxSize > = capacity ; size = <int> ; mask = buckets - <int> ; } public long capacity ( ) { return mask + <int> ; } public long size ( ) { return size ; } static long slot ( long hash , long mask ) { return hash & mask ; } static long nextSlot ( long curSlot , long mask ) { return ( curSlot + <int> ) & mask ; } protected abstract void resize ( long capacity ) ; protected abstract boolean used ( long bucket ) ; protected abstract void removeAndAdd ( long index ) ; protected final void grow ( ) { assert size = = maxSize ; final long prevSize = size ; final long buckets = capacity ( ) ; final long newBuckets = buckets < < <int> ; assert newBuckets = = Long . highestOneBit ( newBuckets ) : newBuckets ; resize ( newBuckets ) ; mask = newBuckets - <int> ; for ( long i = <int> ; i < buckets ; + + i ) { if ( used ( i ) ) { removeAndAdd ( i ) ; } } for ( long i = buckets ; i < newBuckets ; + + i ) { if ( used ( i ) ) { removeAndAdd ( i ) ; } else { break ; } } assert size = = prevSize ; maxSize = ( long ) ( newBuckets * maxLoadFactor ) ; assert size < maxSize ; } } 
