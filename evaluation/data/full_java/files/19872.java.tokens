package io . netty . example . sctp ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . sctp . SctpChannel ; import io . netty . channel . sctp . nio . NioSctpServerChannel ; import io . netty . handler . logging . LogLevel ; import io . netty . handler . logging . LoggingHandler ; public final class SctpEchoServer { static final int PORT = Integer . parseInt ( System . getProperty ( <str> , <str> ) ) ; public static void main ( String [ ] args ) throws Exception { EventLoopGroup bossGroup = new NioEventLoopGroup ( <int> ) ; EventLoopGroup workerGroup = new NioEventLoopGroup ( ) ; try { ServerBootstrap b = new ServerBootstrap ( ) ; b . group ( bossGroup , workerGroup ) . channel ( NioSctpServerChannel . class ) . option ( ChannelOption . SO_BACKLOG , <int> ) . handler ( new LoggingHandler ( LogLevel . INFO ) ) . childHandler ( new ChannelInitializer < SctpChannel > ( ) { @Override public void initChannel ( SctpChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new SctpEchoServerHandler ( ) ) ; } } ) ; ChannelFuture f = b . bind ( PORT ) . sync ( ) ; f . channel ( ) . closeFuture ( ) . sync ( ) ; } finally { bossGroup . shutdownGracefully ( ) ; workerGroup . shutdownGracefully ( ) ; } } } 
