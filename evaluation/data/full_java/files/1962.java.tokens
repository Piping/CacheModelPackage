package org . nd4j . linalg . api . blas . params ; import lombok . Data ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . iter . NdIndexIterator ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . NDArrayFactory ; import org . nd4j . linalg . factory . Nd4j ; import java . util . Iterator ; public @Data class GemvParameters { private int m , n , lda , incx , incy ; private INDArray a , x , y ; private char aOrdering = <str> ; public GemvParameters ( INDArray a , INDArray x , INDArray y ) { a = copyIfNecessary ( a ) ; x = copyIfNecessaryVector ( x ) ; this . a = a ; this . x = x ; this . y = y ; if ( a . ordering ( ) = = <str> & & a . isMatrix ( ) ) { this . m = a . rows ( ) ; this . n = a . columns ( ) ; this . lda = a . rows ( ) ; } else if ( a . ordering ( ) = = <str> & & a . isMatrix ( ) ) { this . m = a . columns ( ) ; this . n = a . rows ( ) ; this . lda = a . columns ( ) ; aOrdering = <str> ; } else { this . m = a . rows ( ) ; this . n = a . columns ( ) ; this . lda = a . size ( <int> ) ; } if ( x . isColumnVector ( ) ) { incx = x . stride ( <int> ) ; } else { incx = x . stride ( <int> ) ; } this . incy = y . elementStride ( ) ; if ( x instanceof IComplexNDArray ) this . incx / = <int> ; if ( y instanceof IComplexNDArray ) this . incy / = <int> ; } private INDArray copyIfNecessary ( INDArray arr ) { if ( arr . ordering ( ) = = <str> & & ( arr . stride ( <int> ) ! = arr . size ( <int> ) | | arr . stride ( <int> ) ! = <int> ) ) return arr . dup ( ) ; else if ( arr . ordering ( ) = = <str> & & ( arr . stride ( <int> ) ! = <int> | | arr . stride ( <int> ) ! = arr . size ( <int> ) ) ) return arr . dup ( ) ; return arr ; } private INDArray copyIfNecessaryVector ( INDArray vec ) { if ( vec . offset ( ) ! = <int> ) return vec . dup ( ) ; return vec ; } } 
