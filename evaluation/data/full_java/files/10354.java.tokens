package com . google . common . collect ; import com . google . common . base . Function ; import com . google . common . base . Joiner ; import junit . framework . TestCase ; import java . lang . reflect . Array ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Set ; public abstract class ForwardingTestCase extends TestCase { private final List < String > calls = new ArrayList < String > ( ) ; private void called ( String id ) { calls . add ( id ) ; } protected String getCalls ( ) { return calls . toString ( ) ; } protected boolean isCalled ( ) { return ! calls . isEmpty ( ) ; } @SuppressWarnings ( <str> ) protected < T > T createProxyInstance ( Class < T > c ) { InvocationHandler handler = new InvocationHandler ( ) { @Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { called ( asString ( method ) ) ; return getDefaultValue ( method . getReturnType ( ) ) ; } } ; return ( T ) Proxy . newProxyInstance ( c . getClassLoader ( ) , new Class [ ] { c } , handler ) ; } private static final Joiner COMMA_JOINER = Joiner . on ( <str> ) ; private String asString ( Method method ) { String methodName = method . getName ( ) ; Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length = = <int> ) { return methodName ; } Iterable < String > parameterNames = Iterables . transform ( Arrays . asList ( parameterTypes ) , new Function < Class < ? > , String > ( ) { @Override public String apply ( Class < ? > from ) { return from . getSimpleName ( ) ; } } ) ; return methodName + <str> + COMMA_JOINER . join ( parameterNames ) + <str> ; } private static Object getDefaultValue ( Class < ? > returnType ) { if ( returnType = = boolean . class | | returnType = = Boolean . class ) { return Boolean . FALSE ; } else if ( returnType = = int . class | | returnType = = Integer . class ) { return <int> ; } else if ( ( returnType = = Set . class ) | | ( returnType = = Collection . class ) ) { return Collections . emptySet ( ) ; } else if ( returnType = = Iterator . class ) { return Iterators . emptyModifiableIterator ( ) ; } else if ( returnType . isArray ( ) ) { return Array . newInstance ( returnType . getComponentType ( ) , <int> ) ; } else if ( <str> . equals ( returnType . getCanonicalName ( ) ) | | ( <str> . equals ( returnType . getCanonicalName ( ) ) ) ) { InvocationHandler handler = new InvocationHandler ( ) { @Override public Object invoke ( Object proxy , Method method , Object [ ] args ) { if ( <str> . equals ( method . getName ( ) ) | | <str> . equals ( method . getName ( ) ) ) { return getDefaultValue ( method . getReturnType ( ) ) ; } throw new IllegalStateException ( <str> + method + <str> + proxy ) ; } } ; return Proxy . newProxyInstance ( returnType . getClassLoader ( ) , new Class [ ] { returnType } , handler ) ; } else { return null ; } } protected static < T > void callAllPublicMethods ( Class < T > theClass , T object ) throws InvocationTargetException { for ( Method method : theClass . getMethods ( ) ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; Object [ ] parameters = new Object [ parameterTypes . length ] ; for ( int i = <int> ; i < parameterTypes . length ; i + + ) { parameters [ i ] = getDefaultValue ( parameterTypes [ i ] ) ; } try { try { method . invoke ( object , parameters ) ; } catch ( InvocationTargetException ex ) { try { throw ex . getCause ( ) ; } catch ( UnsupportedOperationException unsupported ) { } } } catch ( Throwable cause ) { throw new InvocationTargetException ( cause , method + <str> + Arrays . toString ( parameters ) ) ; } } } } 
