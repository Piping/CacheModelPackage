package org . elasticsearch . common . cli ; import org . apache . commons . cli . CommandLine ; import org . apache . commons . cli . CommandLineParser ; import org . apache . commons . cli . DefaultParser ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import java . io . IOException ; import java . util . Locale ; import static org . elasticsearch . common . settings . Settings . Builder . EMPTY_SETTINGS ; public abstract class CliTool { public static enum ExitStatus { OK ( <int> ) , OK_AND_EXIT ( <int> ) , USAGE ( <int> ) , DATA_ERROR ( <int> ) , NO_INPUT ( <int> ) , NO_USER ( <int> ) , NO_HOST ( <int> ) , UNAVAILABLE ( <int> ) , CODE_ERROR ( <int> ) , CANT_CREATE ( <int> ) , IO_ERROR ( <int> ) , TEMP_FAILURE ( <int> ) , PROTOCOL ( <int> ) , NOPERM ( <int> ) , CONFIG ( <int> ) ; final int status ; private ExitStatus ( int status ) { this . status = status ; } public int status ( ) { return status ; } public static ExitStatus fromStatus ( int status ) { for ( ExitStatus exitStatus : values ( ) ) { if ( exitStatus . status ( ) = = status ) { return exitStatus ; } } return null ; } } protected final Terminal terminal ; protected final Environment env ; protected final Settings settings ; private final CliToolConfig config ; protected CliTool ( CliToolConfig config ) { this ( config , Terminal . DEFAULT ) ; } protected CliTool ( CliToolConfig config , Terminal terminal ) { if ( config . cmds ( ) . size ( ) = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . config = config ; this . terminal = terminal ; env = InternalSettingsPreparer . prepareEnvironment ( EMPTY_SETTINGS , terminal ) ; settings = env . settings ( ) ; } public final ExitStatus execute ( String . . . args ) { if ( ! config . isSingle ( ) & & args . length > <int> & & ( args [ <int> ] . equals ( <str> ) | | args [ <int> ] . equals ( <str> ) ) ) { config . printUsage ( terminal ) ; return ExitStatus . OK_AND_EXIT ; } CliToolConfig . Cmd cmd ; if ( config . isSingle ( ) ) { cmd = config . single ( ) ; } else { if ( args . length = = <int> ) { terminal . printError ( <str> ) ; config . printUsage ( terminal ) ; return ExitStatus . USAGE ; } String cmdName = args [ <int> ] ; cmd = config . cmd ( cmdName ) ; if ( cmd = = null ) { terminal . printError ( <str> , cmdName ) ; return ExitStatus . USAGE ; } if ( args . length = = <int> ) { args = new String [ <int> ] ; } else { String [ ] cmdArgs = new String [ args . length - <int> ] ; System . arraycopy ( args , <int> , cmdArgs , <int> , cmdArgs . length ) ; args = cmdArgs ; } } Command command = null ; try { command = parse ( cmd , args ) ; return command . execute ( settings , env ) ; } catch ( IOException ioe ) { terminal . printError ( ioe ) ; return ExitStatus . IO_ERROR ; } catch ( IllegalArgumentException ilae ) { terminal . printError ( ilae ) ; return ExitStatus . USAGE ; } catch ( Throwable t ) { terminal . printError ( t ) ; if ( command = = null ) { return ExitStatus . USAGE ; } return ExitStatus . CODE_ERROR ; } } public Command parse ( String cmdName , String [ ] args ) throws Exception { CliToolConfig . Cmd cmd = config . cmd ( cmdName ) ; return parse ( cmd , args ) ; } public Command parse ( CliToolConfig . Cmd cmd , String [ ] args ) throws Exception { CommandLineParser parser = new DefaultParser ( ) ; CommandLine cli = parser . parse ( CliToolConfig . OptionsSource . HELP . options ( ) , args , true ) ; if ( cli . hasOption ( <str> ) ) { return helpCmd ( cmd ) ; } cli = parser . parse ( cmd . options ( ) , args , cmd . isStopAtNonOption ( ) ) ; Terminal . Verbosity verbosity = Terminal . Verbosity . resolve ( cli ) ; terminal . verbosity ( verbosity ) ; return parse ( cmd . name ( ) , cli ) ; } protected Command . Help helpCmd ( CliToolConfig . Cmd cmd ) { return new Command . Help ( cmd , terminal ) ; } protected static Command . Exit exitCmd ( ExitStatus status ) { return new Command . Exit ( null , status , null ) ; } protected static Command . Exit exitCmd ( ExitStatus status , Terminal terminal , String msg , Object . . . args ) { return new Command . Exit ( String . format ( Locale . ROOT , msg , args ) , status , terminal ) ; } protected abstract Command parse ( String cmdName , CommandLine cli ) throws Exception ; public static abstract class Command { protected final Terminal terminal ; protected Command ( Terminal terminal ) { this . terminal = terminal ; } public abstract ExitStatus execute ( Settings settings , Environment env ) throws Exception ; public static class Help extends Command { private final CliToolConfig . Cmd cmd ; private Help ( CliToolConfig . Cmd cmd , Terminal terminal ) { super ( terminal ) ; this . cmd = cmd ; } @Override public ExitStatus execute ( Settings settings , Environment env ) throws Exception { cmd . printUsage ( terminal ) ; return ExitStatus . OK_AND_EXIT ; } } public static class Exit extends Command { private final String msg ; private final ExitStatus status ; private Exit ( String msg , ExitStatus status , Terminal terminal ) { super ( terminal ) ; this . msg = msg ; this . status = status ; } @Override public ExitStatus execute ( Settings settings , Environment env ) throws Exception { if ( msg ! = null ) { if ( status ! = ExitStatus . OK ) { terminal . printError ( msg ) ; } else { terminal . println ( msg ) ; } } return status ; } public ExitStatus status ( ) { return status ; } } } } 
