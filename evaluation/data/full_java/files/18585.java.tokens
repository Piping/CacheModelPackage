package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . Interpolation ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . tests . utils . GdxTest ; public class Vector2dTest extends GdxTest { private static final float DURATION = <float> ; private ShapeRenderer renderer ; private OrthographicCamera camera ; private Vector2 rotating = new Vector2 ( Vector2 . X ) ; private Vector2 scalingX = new Vector2 ( Vector2 . Y ) ; private Vector2 scalingY = new Vector2 ( Vector2 . X ) ; private Vector2 lerping1 = new Vector2 ( Vector2 . X ) ; private Vector2 lerpTarget = new Vector2 ( Vector2 . Y ) ; private Vector2 sum = new Vector2 ( ) . add ( Vector2 . X ) . add ( Vector2 . Y ) . nor ( ) ; private Vector2 mash = new Vector2 ( Vector2 . Y ) ; private Interpolation interpolator = Interpolation . swing ; private Vector2 lerping2 = new Vector2 ( Vector2 . X ) ; private Vector2 lerpStart2 = new Vector2 ( Vector2 . X ) ; private Vector2 lerpTarget2 = new Vector2 ( Vector2 . Y ) ; private float timePassed = <int> ; private final long start = System . currentTimeMillis ( ) ; @Override public void create ( ) { renderer = new ShapeRenderer ( ) ; } private void renderVectorAt ( float x , float y , Vector2 v ) { renderer . line ( x , y , x + v . x , y + v . y ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <int> , <int> , <int> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; renderer . setProjectionMatrix ( camera . combined ) ; renderer . begin ( ShapeType . Filled ) ; renderer . setColor ( <float> , <int> , <int> , <float> ) ; renderer . circle ( - <int> + lerpTarget . x , <int> + lerpTarget . y , <float> , <int> ) ; renderer . circle ( - <int> + lerpTarget2 . x , <int> + lerpTarget2 . y , <float> , <int> ) ; renderer . end ( ) ; renderer . begin ( ShapeType . Line ) ; renderer . setColor ( Color . RED ) ; renderVectorAt ( <int> , <int> , Vector2 . X ) ; renderer . setColor ( Color . GREEN ) ; renderVectorAt ( <int> , <int> , Vector2 . Y ) ; renderer . setColor ( Color . YELLOW ) ; renderVectorAt ( <int> , <int> , sum ) ; final float changeRate = Gdx . graphics . getDeltaTime ( ) ; renderer . setColor ( Color . WHITE ) ; renderVectorAt ( <int> , <int> , rotating ) ; rotating . rotate ( <int> * changeRate ) ; renderVectorAt ( <int> , - <int> , scalingX ) ; scalingX . set ( <int> , MathUtils . sin ( ( System . currentTimeMillis ( ) - start ) / <float> ) ) ; renderVectorAt ( <int> , - <int> , scalingY ) ; scalingY . set ( MathUtils . cos ( ( System . currentTimeMillis ( ) - start ) / <float> ) , <int> ) ; renderVectorAt ( - <int> , <int> , lerping1 ) ; lerping1 . lerp ( lerpTarget , <float> ) ; if ( lerping1 . epsilonEquals ( lerpTarget , <float> ) ) { lerpTarget . set ( - <float> + MathUtils . random ( <float> ) , - <float> + MathUtils . random ( <float> ) ) . nor ( ) ; } timePassed + = Gdx . graphics . getDeltaTime ( ) ; renderVectorAt ( - <int> , <int> , lerping2 ) ; lerping2 . set ( lerpStart2 ) ; lerping2 . interpolate ( lerpTarget2 , MathUtils . clamp ( timePassed / DURATION , <int> , <int> ) , interpolator ) ; if ( lerping2 . epsilonEquals ( lerpTarget2 , <float> ) ) { lerpTarget2 . set ( - <float> + MathUtils . random ( <float> ) , - <float> + MathUtils . random ( <float> ) ) . nor ( ) ; lerpStart2 . set ( lerping2 ) ; timePassed = <int> ; } renderVectorAt ( - <int> , - <int> , mash ) ; mash . set ( <int> , <int> ) . add ( rotating ) . add ( scalingX ) . add ( scalingY ) . add ( lerping1 ) ; renderer . end ( ) ; } @Override public void resize ( int width , int height ) { float ratio = ( ( float ) Gdx . graphics . getWidth ( ) / ( float ) Gdx . graphics . getHeight ( ) ) ; int h = <int> ; int w = ( int ) ( h * ratio ) ; camera = new OrthographicCamera ( w , h ) ; } } 
