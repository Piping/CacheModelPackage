package org . apache . cassandra . transport ; import java . util . ArrayList ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . EnumSet ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . UUID ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import io . netty . buffer . ByteBuf ; import io . netty . channel . * ; import io . netty . handler . codec . MessageToMessageDecoder ; import io . netty . handler . codec . MessageToMessageEncoder ; import com . google . common . base . Predicate ; import com . google . common . collect . ImmutableSet ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . service . ClientWarn ; import org . apache . cassandra . transport . messages . * ; import org . apache . cassandra . service . QueryState ; import org . apache . cassandra . utils . JVMStabilityInspector ; public abstract class Message { protected static final Logger logger = LoggerFactory . getLogger ( Message . class ) ; private static final Set < String > ioExceptionsAtDebugLevel = ImmutableSet . < String > builder ( ) . add ( <str> ) . add ( <str> ) . add ( <str> ) . build ( ) ; public interface Codec < M extends Message > extends CBCodec < M > { } public enum Direction { REQUEST , RESPONSE ; public static Direction extractFromVersion ( int versionWithDirection ) { return ( versionWithDirection & <hex> ) = = <int> ? REQUEST : RESPONSE ; } public int addToVersion ( int rawVersion ) { return this = = REQUEST ? ( rawVersion & <hex> ) : ( rawVersion | <hex> ) ; } } public enum Type { ERROR ( <int> , Direction . RESPONSE , ErrorMessage . codec ) , STARTUP ( <int> , Direction . REQUEST , StartupMessage . codec ) , READY ( <int> , Direction . RESPONSE , ReadyMessage . codec ) , AUTHENTICATE ( <int> , Direction . RESPONSE , AuthenticateMessage . codec ) , CREDENTIALS ( <int> , Direction . REQUEST , CredentialsMessage . codec ) , OPTIONS ( <int> , Direction . REQUEST , OptionsMessage . codec ) , SUPPORTED ( <int> , Direction . RESPONSE , SupportedMessage . codec ) , QUERY ( <int> , Direction . REQUEST , QueryMessage . codec ) , RESULT ( <int> , Direction . RESPONSE , ResultMessage . codec ) , PREPARE ( <int> , Direction . REQUEST , PrepareMessage . codec ) , EXECUTE ( <int> , Direction . REQUEST , ExecuteMessage . codec ) , REGISTER ( <int> , Direction . REQUEST , RegisterMessage . codec ) , EVENT ( <int> , Direction . RESPONSE , EventMessage . codec ) , BATCH ( <int> , Direction . REQUEST , BatchMessage . codec ) , AUTH_CHALLENGE ( <int> , Direction . RESPONSE , AuthChallenge . codec ) , AUTH_RESPONSE ( <int> , Direction . REQUEST , AuthResponse . codec ) , AUTH_SUCCESS ( <int> , Direction . RESPONSE , AuthSuccess . codec ) ; public final int opcode ; public final Direction direction ; public final Codec < ? > codec ; private static final Type [ ] opcodeIdx ; static { int maxOpcode = - <int> ; for ( Type type : Type . values ( ) ) maxOpcode = Math . max ( maxOpcode , type . opcode ) ; opcodeIdx = new Type [ maxOpcode + <int> ] ; for ( Type type : Type . values ( ) ) { if ( opcodeIdx [ type . opcode ] ! = null ) throw new IllegalStateException ( <str> ) ; opcodeIdx [ type . opcode ] = type ; } } private Type ( int opcode , Direction direction , Codec < ? > codec ) { this . opcode = opcode ; this . direction = direction ; this . codec = codec ; } public static Type fromOpcode ( int opcode , Direction direction ) { if ( opcode > = opcodeIdx . length ) throw new ProtocolException ( String . format ( <str> , opcode ) ) ; Type t = opcodeIdx [ opcode ] ; if ( t = = null ) throw new ProtocolException ( String . format ( <str> , opcode ) ) ; if ( t . direction ! = direction ) throw new ProtocolException ( String . format ( <str> , t . direction , direction , opcode , t ) ) ; return t ; } } public final Type type ; protected Connection connection ; private int streamId ; private Frame sourceFrame ; private Map < String , ByteBuffer > customPayload ; protected Message ( Type type ) { this . type = type ; } public void attach ( Connection connection ) { this . connection = connection ; } public Connection connection ( ) { return connection ; } public Message setStreamId ( int streamId ) { this . streamId = streamId ; return this ; } public int getStreamId ( ) { return streamId ; } public void setSourceFrame ( Frame sourceFrame ) { this . sourceFrame = sourceFrame ; } public Frame getSourceFrame ( ) { return sourceFrame ; } public Map < String , ByteBuffer > getCustomPayload ( ) { return customPayload ; } public void setCustomPayload ( Map < String , ByteBuffer > customPayload ) { this . customPayload = customPayload ; } public static abstract class Request extends Message { protected boolean tracingRequested ; protected Request ( Type type ) { super ( type ) ; if ( type . direction ! = Direction . REQUEST ) throw new IllegalArgumentException ( ) ; } public abstract Response execute ( QueryState queryState ) ; public void setTracingRequested ( ) { this . tracingRequested = true ; } public boolean isTracingRequested ( ) { return tracingRequested ; } } public static abstract class Response extends Message { protected UUID tracingId ; protected List < String > warnings ; protected Response ( Type type ) { super ( type ) ; if ( type . direction ! = Direction . RESPONSE ) throw new IllegalArgumentException ( ) ; } public Message setTracingId ( UUID tracingId ) { this . tracingId = tracingId ; return this ; } public UUID getTracingId ( ) { return tracingId ; } public Message setWarnings ( List < String > warnings ) { this . warnings = warnings ; return this ; } public List < String > getWarnings ( ) { return warnings ; } } @ChannelHandler.Sharable public static class ProtocolDecoder extends MessageToMessageDecoder < Frame > { public void decode ( ChannelHandlerContext ctx , Frame frame , List results ) { boolean isRequest = frame . header . type . direction = = Direction . REQUEST ; boolean isTracing = frame . header . flags . contains ( Frame . Header . Flag . TRACING ) ; boolean isCustomPayload = frame . header . flags . contains ( Frame . Header . Flag . CUSTOM_PAYLOAD ) ; boolean hasWarning = frame . header . flags . contains ( Frame . Header . Flag . WARNING ) ; UUID tracingId = isRequest | | ! isTracing ? null : CBUtil . readUUID ( frame . body ) ; List < String > warnings = isRequest | | ! hasWarning ? null : CBUtil . readStringList ( frame . body ) ; Map < String , ByteBuffer > customPayload = ! isCustomPayload ? null : CBUtil . readBytesMap ( frame . body ) ; try { if ( isCustomPayload & & frame . header . version < Server . VERSION_4 ) throw new ProtocolException ( <str> ) ; Message message = frame . header . type . codec . decode ( frame . body , frame . header . version ) ; message . setStreamId ( frame . header . streamId ) ; message . setSourceFrame ( frame ) ; message . setCustomPayload ( customPayload ) ; if ( isRequest ) { assert message instanceof Request ; Request req = ( Request ) message ; Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; req . attach ( connection ) ; if ( isTracing ) req . setTracingRequested ( ) ; } else { assert message instanceof Response ; if ( isTracing ) ( ( Response ) message ) . setTracingId ( tracingId ) ; if ( hasWarning ) ( ( Response ) message ) . setWarnings ( warnings ) ; } results . add ( message ) ; } catch ( Throwable ex ) { frame . release ( ) ; throw ErrorMessage . wrap ( ex , frame . header . streamId ) ; } } } @ChannelHandler.Sharable public static class ProtocolEncoder extends MessageToMessageEncoder < Message > { public void encode ( ChannelHandlerContext ctx , Message message , List results ) { Connection connection = ctx . channel ( ) . attr ( Connection . attributeKey ) . get ( ) ; int version = connection = = null ? Server . CURRENT_VERSION : connection . getVersion ( ) ; EnumSet < Frame . Header . Flag > flags = EnumSet . noneOf ( Frame . Header . Flag . class ) ; Codec < Message > codec = ( Codec < Message > ) message . type . codec ; try { int messageSize = codec . encodedSize ( message , version ) ; ByteBuf body ; if ( message instanceof Response ) { UUID tracingId = ( ( Response ) message ) . getTracingId ( ) ; Map < String , ByteBuffer > customPayload = message . getCustomPayload ( ) ; if ( tracingId ! = null ) messageSize + = CBUtil . sizeOfUUID ( tracingId ) ; List < String > warnings = ( ( Response ) message ) . getWarnings ( ) ; if ( warnings ! = null ) { if ( version < Server . VERSION_4 ) throw new ProtocolException ( <str> ) ; messageSize + = CBUtil . sizeOfStringList ( warnings ) ; } if ( customPayload ! = null ) { if ( version < Server . VERSION_4 ) throw new ProtocolException ( <str> ) ; messageSize + = CBUtil . sizeOfBytesMap ( customPayload ) ; } body = CBUtil . allocator . buffer ( messageSize ) ; if ( tracingId ! = null ) { CBUtil . writeUUID ( tracingId , body ) ; flags . add ( Frame . Header . Flag . TRACING ) ; } if ( warnings ! = null ) { CBUtil . writeStringList ( warnings , body ) ; flags . add ( Frame . Header . Flag . WARNING ) ; } if ( customPayload ! = null ) { CBUtil . writeBytesMap ( customPayload , body ) ; flags . add ( Frame . Header . Flag . CUSTOM_PAYLOAD ) ; } } else { assert message instanceof Request ; if ( ( ( Request ) message ) . isTracingRequested ( ) ) flags . add ( Frame . Header . Flag . TRACING ) ; Map < String , ByteBuffer > payload = message . getCustomPayload ( ) ; if ( payload ! = null ) messageSize + = CBUtil . sizeOfBytesMap ( payload ) ; body = CBUtil . allocator . buffer ( messageSize ) ; if ( payload ! = null ) { CBUtil . writeBytesMap ( payload , body ) ; flags . add ( Frame . Header . Flag . CUSTOM_PAYLOAD ) ; } } try { codec . encode ( message , body , version ) ; } catch ( Throwable e ) { body . release ( ) ; throw e ; } results . add ( Frame . create ( message . type , message . getStreamId ( ) , version , flags , body ) ) ; } catch ( Throwable e ) { throw ErrorMessage . wrap ( e , message . getStreamId ( ) ) ; } } } @ChannelHandler.Sharable public static class Dispatcher extends SimpleChannelInboundHandler < Request > { private static class FlushItem { final ChannelHandlerContext ctx ; final Object response ; final Frame sourceFrame ; private FlushItem ( ChannelHandlerContext ctx , Object response , Frame sourceFrame ) { this . ctx = ctx ; this . sourceFrame = sourceFrame ; this . response = response ; } } private static final class Flusher implements Runnable { final EventLoop eventLoop ; final ConcurrentLinkedQueue < FlushItem > queued = new ConcurrentLinkedQueue < > ( ) ; final AtomicBoolean running = new AtomicBoolean ( false ) ; final HashSet < ChannelHandlerContext > channels = new HashSet < > ( ) ; final List < FlushItem > flushed = new ArrayList < > ( ) ; int runsSinceFlush = <int> ; int runsWithNoWork = <int> ; private Flusher ( EventLoop eventLoop ) { this . eventLoop = eventLoop ; } void start ( ) { if ( ! running . get ( ) & & running . compareAndSet ( false , true ) ) { this . eventLoop . execute ( this ) ; } } public void run ( ) { boolean doneWork = false ; FlushItem flush ; while ( null ! = ( flush = queued . poll ( ) ) ) { channels . add ( flush . ctx ) ; flush . ctx . write ( flush . response , flush . ctx . voidPromise ( ) ) ; flushed . add ( flush ) ; doneWork = true ; } runsSinceFlush + + ; if ( ! doneWork | | runsSinceFlush > <int> | | flushed . size ( ) > <int> ) { for ( ChannelHandlerContext channel : channels ) channel . flush ( ) ; for ( FlushItem item : flushed ) item . sourceFrame . release ( ) ; channels . clear ( ) ; flushed . clear ( ) ; runsSinceFlush = <int> ; } if ( doneWork ) { runsWithNoWork = <int> ; } else { if ( + + runsWithNoWork > <int> ) { running . set ( false ) ; if ( queued . isEmpty ( ) | | ! running . compareAndSet ( false , true ) ) return ; } } eventLoop . schedule ( this , <int> , TimeUnit . NANOSECONDS ) ; } } private static final ConcurrentMap < EventLoop , Flusher > flusherLookup = new ConcurrentHashMap < > ( ) ; public Dispatcher ( ) { super ( false ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , Request request ) { final Response response ; final ServerConnection connection ; try { assert request . connection ( ) instanceof ServerConnection ; connection = ( ServerConnection ) request . connection ( ) ; if ( connection . getVersion ( ) > = Server . VERSION_4 ) ClientWarn . captureWarnings ( ) ; QueryState qstate = connection . validateNewMessage ( request . type , connection . getVersion ( ) , request . getStreamId ( ) ) ; logger . trace ( <str> , request , connection . getVersion ( ) ) ; response = request . execute ( qstate ) ; response . setStreamId ( request . getStreamId ( ) ) ; response . setWarnings ( ClientWarn . getWarnings ( ) ) ; response . attach ( connection ) ; connection . applyStateTransition ( request . type , response . type ) ; } catch ( Throwable t ) { JVMStabilityInspector . inspectThrowable ( t ) ; UnexpectedChannelExceptionHandler handler = new UnexpectedChannelExceptionHandler ( ctx . channel ( ) , true ) ; flush ( new FlushItem ( ctx , ErrorMessage . fromException ( t , handler ) . setStreamId ( request . getStreamId ( ) ) , request . getSourceFrame ( ) ) ) ; return ; } finally { ClientWarn . resetWarnings ( ) ; } logger . trace ( <str> , response , connection . getVersion ( ) ) ; flush ( new FlushItem ( ctx , response , request . getSourceFrame ( ) ) ) ; } private void flush ( FlushItem item ) { EventLoop loop = item . ctx . channel ( ) . eventLoop ( ) ; Flusher flusher = flusherLookup . get ( loop ) ; if ( flusher = = null ) { Flusher alt = flusherLookup . putIfAbsent ( loop , flusher = new Flusher ( loop ) ) ; if ( alt ! = null ) flusher = alt ; } flusher . queued . add ( item ) ; flusher . start ( ) ; } @Override public void exceptionCaught ( final ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( ctx . channel ( ) . isOpen ( ) ) { UnexpectedChannelExceptionHandler handler = new UnexpectedChannelExceptionHandler ( ctx . channel ( ) , false ) ; ChannelFuture future = ctx . writeAndFlush ( ErrorMessage . fromException ( cause , handler ) ) ; if ( cause instanceof ProtocolException ) { future . addListener ( new ChannelFutureListener ( ) { public void operationComplete ( ChannelFuture future ) { ctx . close ( ) ; } } ) ; } } } } static final class UnexpectedChannelExceptionHandler implements Predicate < Throwable > { private final Channel channel ; private final boolean alwaysLogAtError ; UnexpectedChannelExceptionHandler ( Channel channel , boolean alwaysLogAtError ) { this . channel = channel ; this . alwaysLogAtError = alwaysLogAtError ; } @Override public boolean apply ( Throwable exception ) { String message ; try { message = <str> + channel ; } catch ( Exception ignore ) { message = <str> ; } if ( ! alwaysLogAtError & & exception instanceof IOException ) { if ( ioExceptionsAtDebugLevel . contains ( exception . getMessage ( ) ) ) { logger . trace ( message , exception ) ; } else { logger . info ( message , exception ) ; } } else { logger . error ( message , exception ) ; } return true ; } } } 
