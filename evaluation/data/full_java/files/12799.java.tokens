package org . gradle . api . internal . notations ; import org . gradle . api . artifacts . ProjectDependency ; import org . gradle . api . internal . artifacts . DefaultProjectDependencyFactory ; import org . gradle . api . internal . artifacts . dsl . dependencies . ProjectFinder ; import org . gradle . api . tasks . Optional ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . typeconversion . MapKey ; import org . gradle . internal . typeconversion . MapNotationConverter ; import org . gradle . internal . typeconversion . NotationParserBuilder ; import java . util . Map ; public class ProjectDependencyFactory { private final DefaultProjectDependencyFactory factory ; public ProjectDependencyFactory ( DefaultProjectDependencyFactory factory ) { this . factory = factory ; } public ProjectDependency createFromMap ( ProjectFinder projectFinder , Map < ? extends String , ? > map ) { return NotationParserBuilder . toType ( ProjectDependency . class ) . converter ( new ProjectDependencyMapNotationConverter ( projectFinder , factory ) ) . toComposite ( ) . parseNotation ( map ) ; } static class ProjectDependencyMapNotationConverter extends MapNotationConverter < ProjectDependency > { private final ProjectFinder projectFinder ; private final DefaultProjectDependencyFactory factory ; public ProjectDependencyMapNotationConverter ( ProjectFinder projectFinder , DefaultProjectDependencyFactory factory ) { this . projectFinder = projectFinder ; this . factory = factory ; } protected ProjectDependency parseMap ( @MapKey ( <str> ) String path , @Optional @MapKey ( <str> ) String configuration ) { return factory . create ( projectFinder . getProject ( path ) , configuration ) ; } @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) . example ( <str> ) ; } } } 
