package org . apache . cassandra . utils . concurrent ; import java . util . Iterator ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import java . util . concurrent . locks . LockSupport ; import com . codahale . metrics . Timer ; public final class WaitQueue { private static final int CANCELLED = - <int> ; private static final int SIGNALLED = <int> ; private static final int NOT_SET = <int> ; private static final AtomicIntegerFieldUpdater signalledUpdater = AtomicIntegerFieldUpdater . newUpdater ( RegisteredSignal . class , <str> ) ; private final ConcurrentLinkedQueue < RegisteredSignal > queue = new ConcurrentLinkedQueue < > ( ) ; public Signal register ( ) { RegisteredSignal signal = new RegisteredSignal ( ) ; queue . add ( signal ) ; return signal ; } public Signal register ( Timer . Context context ) { assert context ! = null ; RegisteredSignal signal = new TimedSignal ( context ) ; queue . add ( signal ) ; return signal ; } public boolean signal ( ) { if ( ! hasWaiters ( ) ) return false ; while ( true ) { RegisteredSignal s = queue . poll ( ) ; if ( s = = null | | s . signal ( ) ! = null ) return s ! = null ; } } public void signalAll ( ) { if ( ! hasWaiters ( ) ) return ; int i = <int> , s = <int> ; Thread randomThread = null ; Iterator < RegisteredSignal > iter = queue . iterator ( ) ; while ( iter . hasNext ( ) ) { RegisteredSignal signal = iter . next ( ) ; Thread signalled = signal . signal ( ) ; if ( signalled ! = null ) { if ( signalled = = randomThread ) break ; if ( + + i = = s ) { randomThread = signalled ; s < < = <int> ; } } iter . remove ( ) ; } } private void cleanUpCancelled ( ) { Iterator < RegisteredSignal > iter = queue . iterator ( ) ; while ( iter . hasNext ( ) ) { RegisteredSignal s = iter . next ( ) ; if ( s . isCancelled ( ) ) iter . remove ( ) ; } } public boolean hasWaiters ( ) { return ! queue . isEmpty ( ) ; } public int getWaiting ( ) { if ( ! hasWaiters ( ) ) return <int> ; Iterator < RegisteredSignal > iter = queue . iterator ( ) ; int count = <int> ; while ( iter . hasNext ( ) ) { Signal next = iter . next ( ) ; if ( ! next . isCancelled ( ) ) count + + ; } return count ; } public static interface Signal { public boolean isSignalled ( ) ; public boolean isCancelled ( ) ; public boolean isSet ( ) ; public boolean checkAndClear ( ) ; public abstract void cancel ( ) ; public void awaitUninterruptibly ( ) ; public void await ( ) throws InterruptedException ; public boolean awaitUntil ( long nanos ) throws InterruptedException ; } public static abstract class AbstractSignal implements Signal { public void awaitUninterruptibly ( ) { boolean interrupted = false ; while ( ! isSignalled ( ) ) { if ( Thread . interrupted ( ) ) interrupted = true ; LockSupport . park ( ) ; } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; checkAndClear ( ) ; } public void await ( ) throws InterruptedException { while ( ! isSignalled ( ) ) { checkInterrupted ( ) ; LockSupport . park ( ) ; } checkAndClear ( ) ; } public boolean awaitUntil ( long until ) throws InterruptedException { long now ; while ( until > ( now = System . nanoTime ( ) ) & & ! isSignalled ( ) ) { checkInterrupted ( ) ; long delta = until - now ; LockSupport . parkNanos ( delta ) ; } return checkAndClear ( ) ; } private void checkInterrupted ( ) throws InterruptedException { if ( Thread . interrupted ( ) ) { cancel ( ) ; throw new InterruptedException ( ) ; } } } private class RegisteredSignal extends AbstractSignal { private volatile Thread thread = Thread . currentThread ( ) ; volatile int state ; public boolean isSignalled ( ) { return state = = SIGNALLED ; } public boolean isCancelled ( ) { return state = = CANCELLED ; } public boolean isSet ( ) { return state ! = NOT_SET ; } private Thread signal ( ) { if ( ! isSet ( ) & & signalledUpdater . compareAndSet ( this , NOT_SET , SIGNALLED ) ) { Thread thread = this . thread ; LockSupport . unpark ( thread ) ; this . thread = null ; return thread ; } return null ; } public boolean checkAndClear ( ) { if ( ! isSet ( ) & & signalledUpdater . compareAndSet ( this , NOT_SET , CANCELLED ) ) { thread = null ; cleanUpCancelled ( ) ; return false ; } return true ; } public void cancel ( ) { if ( isCancelled ( ) ) return ; if ( ! signalledUpdater . compareAndSet ( this , NOT_SET , CANCELLED ) ) { state = CANCELLED ; WaitQueue . this . signal ( ) ; } thread = null ; cleanUpCancelled ( ) ; } } private final class TimedSignal extends RegisteredSignal { private final Timer . Context context ; private TimedSignal ( Timer . Context context ) { this . context = context ; } @Override public boolean checkAndClear ( ) { context . stop ( ) ; return super . checkAndClear ( ) ; } @Override public void cancel ( ) { if ( ! isCancelled ( ) ) { context . stop ( ) ; super . cancel ( ) ; } } } private abstract static class MultiSignal extends AbstractSignal { final Signal [ ] signals ; protected MultiSignal ( Signal [ ] signals ) { this . signals = signals ; } public boolean isCancelled ( ) { for ( Signal signal : signals ) if ( ! signal . isCancelled ( ) ) return false ; return true ; } public boolean checkAndClear ( ) { for ( Signal signal : signals ) signal . checkAndClear ( ) ; return isSignalled ( ) ; } public void cancel ( ) { for ( Signal signal : signals ) signal . cancel ( ) ; } } private static class AnySignal extends MultiSignal { protected AnySignal ( Signal . . . signals ) { super ( signals ) ; } public boolean isSignalled ( ) { for ( Signal signal : signals ) if ( signal . isSignalled ( ) ) return true ; return false ; } public boolean isSet ( ) { for ( Signal signal : signals ) if ( signal . isSet ( ) ) return true ; return false ; } } private static class AllSignal extends MultiSignal { protected AllSignal ( Signal . . . signals ) { super ( signals ) ; } public boolean isSignalled ( ) { for ( Signal signal : signals ) if ( ! signal . isSignalled ( ) ) return false ; return true ; } public boolean isSet ( ) { for ( Signal signal : signals ) if ( ! signal . isSet ( ) ) return false ; return true ; } } public static Signal any ( Signal . . . signals ) { return new AnySignal ( signals ) ; } public static Signal all ( Signal . . . signals ) { return new AllSignal ( signals ) ; } } 
