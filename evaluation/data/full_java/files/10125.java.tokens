package com . google . common . testing ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . base . Converter ; import com . google . common . base . Objects ; import com . google . common . collect . ClassToInstanceMap ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . MutableClassToInstanceMap ; import com . google . common . reflect . Invokable ; import com . google . common . reflect . Parameter ; import com . google . common . reflect . Reflection ; import com . google . common . reflect . TypeToken ; import junit . framework . Assert ; import junit . framework . AssertionFailedError ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Member ; import java . lang . reflect . Method ; import java . lang . reflect . Modifier ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . Arrays ; import java . util . List ; import java . util . concurrent . ConcurrentMap ; import javax . annotation . Nullable ; @Beta public final class NullPointerTester { private final ClassToInstanceMap < Object > defaults = MutableClassToInstanceMap . create ( ) ; private final List < Member > ignoredMembers = Lists . newArrayList ( ) ; private ExceptionTypePolicy policy = ExceptionTypePolicy . NPE_OR_UOE ; public < T > NullPointerTester setDefault ( Class < T > type , T value ) { defaults . putInstance ( type , checkNotNull ( value ) ) ; return this ; } public NullPointerTester ignore ( Method method ) { ignoredMembers . add ( checkNotNull ( method ) ) ; return this ; } public void testConstructors ( Class < ? > c , Visibility minimalVisibility ) { for ( Constructor < ? > constructor : c . getDeclaredConstructors ( ) ) { if ( minimalVisibility . isVisible ( constructor ) & & ! isIgnored ( constructor ) ) { testConstructor ( constructor ) ; } } } public void testAllPublicConstructors ( Class < ? > c ) { testConstructors ( c , Visibility . PUBLIC ) ; } public void testStaticMethods ( Class < ? > c , Visibility minimalVisibility ) { for ( Method method : minimalVisibility . getStaticMethods ( c ) ) { if ( ! isIgnored ( method ) ) { testMethod ( null , method ) ; } } } public void testAllPublicStaticMethods ( Class < ? > c ) { testStaticMethods ( c , Visibility . PUBLIC ) ; } public void testInstanceMethods ( Object instance , Visibility minimalVisibility ) { for ( Method method : getInstanceMethodsToTest ( instance . getClass ( ) , minimalVisibility ) ) { testMethod ( instance , method ) ; } } ImmutableList < Method > getInstanceMethodsToTest ( Class < ? > c , Visibility minimalVisibility ) { ImmutableList . Builder < Method > builder = ImmutableList . builder ( ) ; for ( Method method : minimalVisibility . getInstanceMethods ( c ) ) { if ( ! isIgnored ( method ) ) { builder . add ( method ) ; } } return builder . build ( ) ; } public void testAllPublicInstanceMethods ( Object instance ) { testInstanceMethods ( instance , Visibility . PUBLIC ) ; } public void testMethod ( @Nullable Object instance , Method method ) { Class < ? > [ ] types = method . getParameterTypes ( ) ; for ( int nullIndex = <int> ; nullIndex < types . length ; nullIndex + + ) { testMethodParameter ( instance , method , nullIndex ) ; } } public void testConstructor ( Constructor < ? > ctor ) { Class < ? > declaringClass = ctor . getDeclaringClass ( ) ; checkArgument ( Modifier . isStatic ( declaringClass . getModifiers ( ) ) | | declaringClass . getEnclosingClass ( ) = = null , <str> , declaringClass . getName ( ) ) ; Class < ? > [ ] types = ctor . getParameterTypes ( ) ; for ( int nullIndex = <int> ; nullIndex < types . length ; nullIndex + + ) { testConstructorParameter ( ctor , nullIndex ) ; } } public void testMethodParameter ( @Nullable final Object instance , final Method method , int paramIndex ) { method . setAccessible ( true ) ; testParameter ( instance , invokable ( instance , method ) , paramIndex , method . getDeclaringClass ( ) ) ; } public void testConstructorParameter ( Constructor < ? > ctor , int paramIndex ) { ctor . setAccessible ( true ) ; testParameter ( null , Invokable . from ( ctor ) , paramIndex , ctor . getDeclaringClass ( ) ) ; } public enum Visibility { PACKAGE { @Override boolean isVisible ( int modifiers ) { return ! Modifier . isPrivate ( modifiers ) ; } } , PROTECTED { @Override boolean isVisible ( int modifiers ) { return Modifier . isPublic ( modifiers ) | | Modifier . isProtected ( modifiers ) ; } } , PUBLIC { @Override boolean isVisible ( int modifiers ) { return Modifier . isPublic ( modifiers ) ; } } ; abstract boolean isVisible ( int modifiers ) ; final boolean isVisible ( Member member ) { return isVisible ( member . getModifiers ( ) ) ; } final Iterable < Method > getStaticMethods ( Class < ? > cls ) { ImmutableList . Builder < Method > builder = ImmutableList . builder ( ) ; for ( Method method : getVisibleMethods ( cls ) ) { if ( Invokable . from ( method ) . isStatic ( ) ) { builder . add ( method ) ; } } return builder . build ( ) ; } final Iterable < Method > getInstanceMethods ( Class < ? > cls ) { ConcurrentMap < Signature , Method > map = Maps . newConcurrentMap ( ) ; for ( Method method : getVisibleMethods ( cls ) ) { if ( ! Invokable . from ( method ) . isStatic ( ) ) { map . putIfAbsent ( new Signature ( method ) , method ) ; } } return map . values ( ) ; } private ImmutableList < Method > getVisibleMethods ( Class < ? > cls ) { String visiblePackage = Reflection . getPackageName ( cls ) ; ImmutableList . Builder < Method > builder = ImmutableList . builder ( ) ; for ( Class < ? > type : TypeToken . of ( cls ) . getTypes ( ) . classes ( ) . rawTypes ( ) ) { if ( ! Reflection . getPackageName ( type ) . equals ( visiblePackage ) ) { break ; } for ( Method method : type . getDeclaredMethods ( ) ) { if ( ! method . isSynthetic ( ) & & isVisible ( method ) ) { builder . add ( method ) ; } } } return builder . build ( ) ; } } private static final class Signature { private final String name ; private final ImmutableList < Class < ? > > parameterTypes ; Signature ( Method method ) { this ( method . getName ( ) , ImmutableList . copyOf ( method . getParameterTypes ( ) ) ) ; } Signature ( String name , ImmutableList < Class < ? > > parameterTypes ) { this . name = name ; this . parameterTypes = parameterTypes ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof Signature ) { Signature that = ( Signature ) obj ; return name . equals ( that . name ) & & parameterTypes . equals ( that . parameterTypes ) ; } return false ; } @Override public int hashCode ( ) { return Objects . hashCode ( name , parameterTypes ) ; } } private void testParameter ( Object instance , Invokable < ? , ? > invokable , int paramIndex , Class < ? > testedClass ) { if ( isPrimitiveOrNullable ( invokable . getParameters ( ) . get ( paramIndex ) ) ) { return ; } Object [ ] params = buildParamList ( invokable , paramIndex ) ; try { @SuppressWarnings ( <str> ) Invokable < Object , ? > unsafe = ( Invokable < Object , ? > ) invokable ; unsafe . invoke ( instance , params ) ; Assert . fail ( <str> + paramIndex + <str> + invokable + Arrays . toString ( params ) + <str> + testedClass ) ; } catch ( InvocationTargetException e ) { Throwable cause = e . getCause ( ) ; if ( policy . isExpectedType ( cause ) ) { return ; } AssertionFailedError error = new AssertionFailedError ( <str> + invokable + <str> + cause ) ; error . initCause ( cause ) ; throw error ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } private Object [ ] buildParamList ( Invokable < ? , ? > invokable , int indexOfParamToSetToNull ) { ImmutableList < Parameter > params = invokable . getParameters ( ) ; Object [ ] args = new Object [ params . size ( ) ] ; for ( int i = <int> ; i < args . length ; i + + ) { Parameter param = params . get ( i ) ; if ( i ! = indexOfParamToSetToNull ) { args [ i ] = getDefaultValue ( param . getType ( ) ) ; Assert . assertTrue ( <str> + param . getType ( ) + <str> , args [ i ] ! = null | | isNullable ( param ) ) ; } } return args ; } private < T > T getDefaultValue ( TypeToken < T > type ) { @SuppressWarnings ( <str> ) T defaultValue = ( T ) defaults . getInstance ( type . getRawType ( ) ) ; if ( defaultValue ! = null ) { return defaultValue ; } @SuppressWarnings ( <str> ) T arbitrary = ( T ) ArbitraryInstances . get ( type . getRawType ( ) ) ; if ( arbitrary ! = null ) { return arbitrary ; } if ( type . getRawType ( ) = = Class . class ) { @SuppressWarnings ( <str> ) T defaultClass = ( T ) getFirstTypeParameter ( type . getType ( ) ) . getRawType ( ) ; return defaultClass ; } if ( type . getRawType ( ) = = TypeToken . class ) { @SuppressWarnings ( <str> ) T defaultType = ( T ) getFirstTypeParameter ( type . getType ( ) ) ; return defaultType ; } if ( type . getRawType ( ) = = Converter . class ) { TypeToken < ? > convertFromType = type . resolveType ( Converter . class . getTypeParameters ( ) [ <int> ] ) ; TypeToken < ? > convertToType = type . resolveType ( Converter . class . getTypeParameters ( ) [ <int> ] ) ; @SuppressWarnings ( <str> ) T defaultConverter = ( T ) defaultConverter ( convertFromType , convertToType ) ; return defaultConverter ; } if ( type . getRawType ( ) . isInterface ( ) ) { return newDefaultReturningProxy ( type ) ; } return null ; } private < F , T > Converter < F , T > defaultConverter ( final TypeToken < F > convertFromType , final TypeToken < T > convertToType ) { return new Converter < F , T > ( ) { @Override protected T doForward ( F a ) { return doConvert ( convertToType ) ; } @Override protected F doBackward ( T b ) { return doConvert ( convertFromType ) ; } private < S > S doConvert ( TypeToken < S > type ) { return checkNotNull ( getDefaultValue ( type ) ) ; } } ; } private static TypeToken < ? > getFirstTypeParameter ( Type type ) { if ( type instanceof ParameterizedType ) { return TypeToken . of ( ( ( ParameterizedType ) type ) . getActualTypeArguments ( ) [ <int> ] ) ; } else { return TypeToken . of ( Object . class ) ; } } private < T > T newDefaultReturningProxy ( final TypeToken < T > type ) { return new DummyProxy ( ) { @Override < R > R dummyReturnValue ( TypeToken < R > returnType ) { return getDefaultValue ( returnType ) ; } } . newProxy ( type ) ; } private static Invokable < ? , ? > invokable ( @Nullable Object instance , Method method ) { if ( instance = = null ) { return Invokable . from ( method ) ; } else { return TypeToken . of ( instance . getClass ( ) ) . method ( method ) ; } } static boolean isPrimitiveOrNullable ( Parameter param ) { return param . getType ( ) . getRawType ( ) . isPrimitive ( ) | | isNullable ( param ) ; } private static boolean isNullable ( Parameter param ) { return param . isAnnotationPresent ( Nullable . class ) ; } private boolean isIgnored ( Member member ) { return member . isSynthetic ( ) | | ignoredMembers . contains ( member ) ; } private enum ExceptionTypePolicy { NPE_OR_UOE ( ) { @Override public boolean isExpectedType ( Throwable cause ) { return cause instanceof NullPointerException | | cause instanceof UnsupportedOperationException ; } } , NPE_IAE_OR_UOE ( ) { @Override public boolean isExpectedType ( Throwable cause ) { return cause instanceof NullPointerException | | cause instanceof IllegalArgumentException | | cause instanceof UnsupportedOperationException ; } } ; public abstract boolean isExpectedType ( Throwable cause ) ; } } 
