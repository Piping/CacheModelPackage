package com . badlogic . gdx . graphics . glutils ; import java . io . BufferedInputStream ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . nio . ByteBuffer ; import java . util . zip . GZIPInputStream ; import java . util . zip . GZIPOutputStream ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . StreamUtils ; public class ETC1 { public static int PKM_HEADER_SIZE = <int> ; public static int ETC1_RGB8_OES = <hex> ; public final static class ETC1Data implements Disposable { public final int width ; public final int height ; public final ByteBuffer compressedData ; public final int dataOffset ; public ETC1Data ( int width , int height , ByteBuffer compressedData , int dataOffset ) { this . width = width ; this . height = height ; this . compressedData = compressedData ; this . dataOffset = dataOffset ; checkNPOT ( ) ; } public ETC1Data ( FileHandle pkmFile ) { byte [ ] buffer = new byte [ <int> * <int> ] ; DataInputStream in = null ; try { in = new DataInputStream ( new BufferedInputStream ( new GZIPInputStream ( pkmFile . read ( ) ) ) ) ; int fileSize = in . readInt ( ) ; compressedData = BufferUtils . newUnsafeByteBuffer ( fileSize ) ; int readBytes = <int> ; while ( ( readBytes = in . read ( buffer ) ) ! = - <int> ) { compressedData . put ( buffer , <int> , readBytes ) ; } compressedData . position ( <int> ) ; compressedData . limit ( compressedData . capacity ( ) ) ; } catch ( Exception e ) { throw new GdxRuntimeException ( <str> + pkmFile + <str> , e ) ; } finally { StreamUtils . closeQuietly ( in ) ; } width = getWidthPKM ( compressedData , <int> ) ; height = getHeightPKM ( compressedData , <int> ) ; dataOffset = PKM_HEADER_SIZE ; compressedData . position ( dataOffset ) ; checkNPOT ( ) ; } private void checkNPOT ( ) { if ( ! MathUtils . isPowerOfTwo ( width ) | | ! MathUtils . isPowerOfTwo ( height ) ) { Gdx . app . debug ( <str> , <str> ) ; } } public boolean hasPKMHeader ( ) { return dataOffset = = <int> ; } public void write ( FileHandle file ) { DataOutputStream write = null ; byte [ ] buffer = new byte [ <int> * <int> ] ; int writtenBytes = <int> ; compressedData . position ( <int> ) ; compressedData . limit ( compressedData . capacity ( ) ) ; try { write = new DataOutputStream ( new GZIPOutputStream ( file . write ( false ) ) ) ; write . writeInt ( compressedData . capacity ( ) ) ; while ( writtenBytes ! = compressedData . capacity ( ) ) { int bytesToWrite = Math . min ( compressedData . remaining ( ) , buffer . length ) ; compressedData . get ( buffer , <int> , bytesToWrite ) ; write . write ( buffer , <int> , bytesToWrite ) ; writtenBytes + = bytesToWrite ; } } catch ( Exception e ) { throw new GdxRuntimeException ( <str> + file + <str> , e ) ; } finally { StreamUtils . closeQuietly ( write ) ; } compressedData . position ( dataOffset ) ; compressedData . limit ( compressedData . capacity ( ) ) ; } public void dispose ( ) { BufferUtils . disposeUnsafeByteBuffer ( compressedData ) ; } public String toString ( ) { if ( hasPKMHeader ( ) ) { return ( ETC1 . isValidPKM ( compressedData , <int> ) ? <str> : <str> ) + <str> + ETC1 . getWidthPKM ( compressedData , <int> ) + <str> + ETC1 . getHeightPKM ( compressedData , <int> ) + <str> + ( compressedData . capacity ( ) - ETC1 . PKM_HEADER_SIZE ) ; } else { return <str> + width + <str> + height + <str> + ( compressedData . capacity ( ) - ETC1 . PKM_HEADER_SIZE ) ; } } } private static int getPixelSize ( Format format ) { if ( format = = Format . RGB565 ) return <int> ; if ( format = = Format . RGB888 ) return <int> ; throw new GdxRuntimeException ( <str> ) ; } public static ETC1Data encodeImage ( Pixmap pixmap ) { int pixelSize = getPixelSize ( pixmap . getFormat ( ) ) ; ByteBuffer compressedData = encodeImage ( pixmap . getPixels ( ) , <int> , pixmap . getWidth ( ) , pixmap . getHeight ( ) , pixelSize ) ; BufferUtils . newUnsafeByteBuffer ( compressedData ) ; return new ETC1Data ( pixmap . getWidth ( ) , pixmap . getHeight ( ) , compressedData , <int> ) ; } public static ETC1Data encodeImagePKM ( Pixmap pixmap ) { int pixelSize = getPixelSize ( pixmap . getFormat ( ) ) ; ByteBuffer compressedData = encodeImagePKM ( pixmap . getPixels ( ) , <int> , pixmap . getWidth ( ) , pixmap . getHeight ( ) , pixelSize ) ; BufferUtils . newUnsafeByteBuffer ( compressedData ) ; return new ETC1Data ( pixmap . getWidth ( ) , pixmap . getHeight ( ) , compressedData , <int> ) ; } public static Pixmap decodeImage ( ETC1Data etc1Data , Format format ) { int dataOffset = <int> ; int width = <int> ; int height = <int> ; if ( etc1Data . hasPKMHeader ( ) ) { dataOffset = <int> ; width = ETC1 . getWidthPKM ( etc1Data . compressedData , <int> ) ; height = ETC1 . getHeightPKM ( etc1Data . compressedData , <int> ) ; } else { dataOffset = <int> ; width = etc1Data . width ; height = etc1Data . height ; } int pixelSize = getPixelSize ( format ) ; Pixmap pixmap = new Pixmap ( width , height , format ) ; decodeImage ( etc1Data . compressedData , dataOffset , pixmap . getPixels ( ) , <int> , width , height , pixelSize ) ; return pixmap ; } public static native int getCompressedDataSize ( int width , int height ) ; public static native void formatHeader ( ByteBuffer header , int offset , int width , int height ) ; static native int getWidthPKM ( ByteBuffer header , int offset ) ; static native int getHeightPKM ( ByteBuffer header , int offset ) ; static native boolean isValidPKM ( ByteBuffer header , int offset ) ; private static native void decodeImage ( ByteBuffer compressedData , int offset , ByteBuffer decodedData , int offsetDec , int width , int height , int pixelSize ) ; private static native ByteBuffer encodeImage ( ByteBuffer imageData , int offset , int width , int height , int pixelSize ) ; private static native ByteBuffer encodeImagePKM ( ByteBuffer imageData , int offset , int width , int height , int pixelSize ) ; } 
