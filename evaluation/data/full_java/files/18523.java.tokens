package com . badlogic . gdx . tests ; import com . badlogic . gdx . Files ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputProcessor ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . g2d . Sprite ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . tests . utils . GdxTest ; public class PixmapBlendingTest extends GdxTest { private SpriteBatch spriteBatch ; private Texture text ; private Sprite logoSprite , test3 , test4 ; private Pixmap pixD , pixS1 , pixS2 ; InputProcessor inputProcessor ; @Override public void create ( ) { if ( spriteBatch ! = null ) return ; spriteBatch = new SpriteBatch ( ) ; Matrix4 transform = new Matrix4 ( ) ; transform . setToTranslation ( <int> , Gdx . graphics . getHeight ( ) , <int> ) ; transform . mul ( new Matrix4 ( ) . setToScaling ( <int> , - <int> , <int> ) ) ; spriteBatch . setTransformMatrix ( transform ) ; pixS1 = new Pixmap ( Gdx . files . getFileHandle ( <str> , Files . FileType . Internal ) ) ; pixS2 = new Pixmap ( Gdx . files . getFileHandle ( <str> , Files . FileType . Internal ) ) ; pixD = new Pixmap ( <int> , <int> , Pixmap . Format . RGBA8888 ) ; pixD . drawPixmap ( pixS1 , <int> , <int> , <int> , <int> , <int> , <int> ) ; pixD . drawPixmap ( pixS2 , <int> , <int> , <int> , <int> , <int> , <int> ) ; logoSprite = new Sprite ( new Texture ( pixD ) ) ; logoSprite . flip ( false , true ) ; pixS1 . dispose ( ) ; pixS2 . dispose ( ) ; pixD . dispose ( ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <int> , <int> , <int> , <int> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; spriteBatch . begin ( ) ; logoSprite . draw ( spriteBatch ) ; spriteBatch . end ( ) ; } public boolean needsGL20 ( ) { return false ; } } 
