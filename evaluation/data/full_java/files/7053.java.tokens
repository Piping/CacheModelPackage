package org . elasticsearch . rest . action . search ; import org . elasticsearch . action . search . ClearScrollRequest ; import org . elasticsearch . action . search . ClearScrollResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestActions ; import org . elasticsearch . rest . action . support . RestStatusToXContentListener ; import java . io . IOException ; import java . util . Arrays ; import static org . elasticsearch . rest . RestRequest . Method . DELETE ; public class RestClearScrollAction extends BaseRestHandler { @Inject public RestClearScrollAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( DELETE , <str> , this ) ; controller . registerHandler ( DELETE , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { String scrollIds = request . param ( <str> ) ; ClearScrollRequest clearRequest = new ClearScrollRequest ( ) ; clearRequest . setScrollIds ( Arrays . asList ( splitScrollIds ( scrollIds ) ) ) ; if ( RestActions . hasBodyContent ( request ) ) { XContentType type = RestActions . guessBodyContentType ( request ) ; if ( type = = null ) { scrollIds = RestActions . getRestContent ( request ) . toUtf8 ( ) ; clearRequest . setScrollIds ( Arrays . asList ( splitScrollIds ( scrollIds ) ) ) ; } else { clearRequest . setScrollIds ( null ) ; buildFromContent ( RestActions . getRestContent ( request ) , clearRequest ) ; } } client . clearScroll ( clearRequest , new RestStatusToXContentListener < ClearScrollResponse > ( channel ) ) ; } public static String [ ] splitScrollIds ( String scrollIds ) { if ( scrollIds = = null ) { return Strings . EMPTY_ARRAY ; } return Strings . splitStringByCommaToArray ( scrollIds ) ; } public static void buildFromContent ( BytesReference content , ClearScrollRequest clearScrollRequest ) { try ( XContentParser parser = XContentHelper . createParser ( content ) ) { if ( parser . nextToken ( ) ! = XContentParser . Token . START_OBJECT ) { throw new IllegalArgumentException ( <str> ) ; } else { XContentParser . Token token ; String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( <str> . equals ( currentFieldName ) & & token = = XContentParser . Token . START_ARRAY ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { if ( token . isValue ( ) = = false ) { throw new IllegalArgumentException ( <str> ) ; } clearScrollRequest . addScrollId ( parser . text ( ) ) ; } } else { throw new IllegalArgumentException ( <str> + currentFieldName + <str> + token + <str> ) ; } } } } catch ( IOException e ) { throw new IllegalArgumentException ( <str> , e ) ; } } } 
