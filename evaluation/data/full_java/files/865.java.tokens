package org . apache . cassandra . repair . messages ; import java . util . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . repair . RepairParallelism ; import org . apache . cassandra . tools . nodetool . Repair ; import org . apache . cassandra . utils . FBUtilities ; public class RepairOption { public static final String PARALLELISM_KEY = <str> ; public static final String PRIMARY_RANGE_KEY = <str> ; public static final String INCREMENTAL_KEY = <str> ; public static final String JOB_THREADS_KEY = <str> ; public static final String RANGES_KEY = <str> ; public static final String COLUMNFAMILIES_KEY = <str> ; public static final String DATACENTERS_KEY = <str> ; public static final String HOSTS_KEY = <str> ; public static final String TRACE_KEY = <str> ; public static final int MAX_JOB_THREADS = <int> ; private static final Logger logger = LoggerFactory . getLogger ( RepairOption . class ) ; public static RepairOption parse ( Map < String , String > options , IPartitioner partitioner ) { RepairParallelism parallelism = RepairParallelism . fromName ( options . get ( PARALLELISM_KEY ) ) ; boolean primaryRange = Boolean . parseBoolean ( options . get ( PRIMARY_RANGE_KEY ) ) ; boolean incremental = Boolean . parseBoolean ( options . get ( INCREMENTAL_KEY ) ) ; boolean trace = Boolean . parseBoolean ( options . get ( TRACE_KEY ) ) ; int jobThreads = <int> ; if ( options . containsKey ( JOB_THREADS_KEY ) ) { try { jobThreads = Integer . parseInt ( options . get ( JOB_THREADS_KEY ) ) ; } catch ( NumberFormatException ignore ) { } } String rangesStr = options . get ( RANGES_KEY ) ; Set < Range < Token > > ranges = new HashSet < > ( ) ; if ( rangesStr ! = null ) { if ( incremental ) logger . warn ( <str> + <str> + <str> ) ; StringTokenizer tokenizer = new StringTokenizer ( rangesStr , <str> ) ; while ( tokenizer . hasMoreTokens ( ) ) { String [ ] rangeStr = tokenizer . nextToken ( ) . split ( <str> , <int> ) ; if ( rangeStr . length < <int> ) { continue ; } Token parsedBeginToken = partitioner . getTokenFactory ( ) . fromString ( rangeStr [ <int> ] . trim ( ) ) ; Token parsedEndToken = partitioner . getTokenFactory ( ) . fromString ( rangeStr [ <int> ] . trim ( ) ) ; ranges . add ( new Range < > ( parsedBeginToken , parsedEndToken ) ) ; } } RepairOption option = new RepairOption ( parallelism , primaryRange , incremental , trace , jobThreads , ranges , ! ranges . isEmpty ( ) ) ; String dataCentersStr = options . get ( DATACENTERS_KEY ) ; Collection < String > dataCenters = new HashSet < > ( ) ; if ( dataCentersStr ! = null ) { StringTokenizer tokenizer = new StringTokenizer ( dataCentersStr , <str> ) ; while ( tokenizer . hasMoreTokens ( ) ) { dataCenters . add ( tokenizer . nextToken ( ) . trim ( ) ) ; } option . getDataCenters ( ) . addAll ( dataCenters ) ; } String hostsStr = options . get ( HOSTS_KEY ) ; Collection < String > hosts = new HashSet < > ( ) ; if ( hostsStr ! = null ) { StringTokenizer tokenizer = new StringTokenizer ( hostsStr , <str> ) ; while ( tokenizer . hasMoreTokens ( ) ) { hosts . add ( tokenizer . nextToken ( ) . trim ( ) ) ; } option . getHosts ( ) . addAll ( hosts ) ; } String cfStr = options . get ( COLUMNFAMILIES_KEY ) ; if ( cfStr ! = null ) { Collection < String > columnFamilies = new HashSet < > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( cfStr , <str> ) ; while ( tokenizer . hasMoreTokens ( ) ) { columnFamilies . add ( tokenizer . nextToken ( ) . trim ( ) ) ; } option . getColumnFamilies ( ) . addAll ( columnFamilies ) ; } if ( jobThreads > MAX_JOB_THREADS ) { throw new IllegalArgumentException ( <str> + MAX_JOB_THREADS ) ; } if ( primaryRange & & ( ! dataCenters . isEmpty ( ) | | ! hosts . isEmpty ( ) ) ) { throw new IllegalArgumentException ( <str> ) ; } return option ; } private final RepairParallelism parallelism ; private final boolean primaryRange ; private final boolean incremental ; private final boolean trace ; private final int jobThreads ; private final boolean isSubrangeRepair ; private final Collection < String > columnFamilies = new HashSet < > ( ) ; private final Collection < String > dataCenters = new HashSet < > ( ) ; private final Collection < String > hosts = new HashSet < > ( ) ; private final Collection < Range < Token > > ranges = new HashSet < > ( ) ; public RepairOption ( RepairParallelism parallelism , boolean primaryRange , boolean incremental , boolean trace , int jobThreads , Collection < Range < Token > > ranges , boolean isSubrangeRepair ) { if ( FBUtilities . isWindows ( ) & & ( DatabaseDescriptor . getDiskAccessMode ( ) ! = Config . DiskAccessMode . standard | | DatabaseDescriptor . getIndexAccessMode ( ) ! = Config . DiskAccessMode . standard ) & & parallelism = = RepairParallelism . SEQUENTIAL ) { logger . warn ( <str> ) ; this . parallelism = RepairParallelism . PARALLEL ; } else this . parallelism = parallelism ; this . primaryRange = primaryRange ; this . incremental = incremental ; this . trace = trace ; this . jobThreads = jobThreads ; this . ranges . addAll ( ranges ) ; this . isSubrangeRepair = isSubrangeRepair ; } public RepairParallelism getParallelism ( ) { return parallelism ; } public boolean isPrimaryRange ( ) { return primaryRange ; } public boolean isIncremental ( ) { return incremental ; } public boolean isTraced ( ) { return trace ; } public int getJobThreads ( ) { return jobThreads ; } public Collection < String > getColumnFamilies ( ) { return columnFamilies ; } public Collection < Range < Token > > getRanges ( ) { return ranges ; } public Collection < String > getDataCenters ( ) { return dataCenters ; } public Collection < String > getHosts ( ) { return hosts ; } public boolean isGlobal ( ) { return dataCenters . isEmpty ( ) & & hosts . isEmpty ( ) & & ! isSubrangeRepair ( ) ; } public boolean isSubrangeRepair ( ) { return isSubrangeRepair ; } @Override public String toString ( ) { return <str> + <str> + parallelism + <str> + primaryRange + <str> + incremental + <str> + jobThreads + <str> + columnFamilies + <str> + dataCenters + <str> + hosts + <str> + ranges . size ( ) + <str> ; } } 
