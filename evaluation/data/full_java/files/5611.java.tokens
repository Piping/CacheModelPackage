package org . elasticsearch . cluster . routing . allocation ; import org . elasticsearch . cluster . ClusterInfo ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . allocation . decider . AllocationDeciders ; import org . elasticsearch . cluster . routing . allocation . decider . Decision ; import org . elasticsearch . index . shard . ShardId ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import static java . util . Collections . emptySet ; import static java . util . Collections . unmodifiableSet ; public class RoutingAllocation { public static class Result { private final boolean changed ; private final RoutingTable routingTable ; private final MetaData metaData ; private RoutingExplanations explanations = new RoutingExplanations ( ) ; public Result ( boolean changed , RoutingTable routingTable , MetaData metaData ) { this . changed = changed ; this . routingTable = routingTable ; this . metaData = metaData ; } public Result ( boolean changed , RoutingTable routingTable , MetaData metaData , RoutingExplanations explanations ) { this . changed = changed ; this . routingTable = routingTable ; this . metaData = metaData ; this . explanations = explanations ; } public boolean changed ( ) { return this . changed ; } public MetaData metaData ( ) { return metaData ; } public RoutingTable routingTable ( ) { return routingTable ; } public RoutingExplanations explanations ( ) { return explanations ; } } private final AllocationDeciders deciders ; private final RoutingNodes routingNodes ; private final DiscoveryNodes nodes ; private final AllocationExplanation explanation = new AllocationExplanation ( ) ; private final ClusterInfo clusterInfo ; private Map < ShardId , Set < String > > ignoredShardToNodes = null ; private boolean ignoreDisable = false ; private boolean debugDecision = false ; private boolean hasPendingAsyncFetch = false ; private final long currentNanoTime ; public RoutingAllocation ( AllocationDeciders deciders , RoutingNodes routingNodes , DiscoveryNodes nodes , ClusterInfo clusterInfo , long currentNanoTime ) { this . deciders = deciders ; this . routingNodes = routingNodes ; this . nodes = nodes ; this . clusterInfo = clusterInfo ; this . currentNanoTime = currentNanoTime ; } public long getCurrentNanoTime ( ) { return currentNanoTime ; } public AllocationDeciders deciders ( ) { return this . deciders ; } public RoutingTable routingTable ( ) { return routingNodes . routingTable ( ) ; } public RoutingNodes routingNodes ( ) { return routingNodes ; } public MetaData metaData ( ) { return routingNodes . metaData ( ) ; } public DiscoveryNodes nodes ( ) { return nodes ; } public ClusterInfo clusterInfo ( ) { return clusterInfo ; } public AllocationExplanation explanation ( ) { return explanation ; } public void ignoreDisable ( boolean ignoreDisable ) { this . ignoreDisable = ignoreDisable ; } public boolean ignoreDisable ( ) { return this . ignoreDisable ; } public void debugDecision ( boolean debug ) { this . debugDecision = debug ; } public boolean debugDecision ( ) { return this . debugDecision ; } public void addIgnoreShardForNode ( ShardId shardId , String nodeId ) { if ( ignoredShardToNodes = = null ) { ignoredShardToNodes = new HashMap < > ( ) ; } Set < String > nodes = ignoredShardToNodes . get ( shardId ) ; if ( nodes = = null ) { nodes = new HashSet < > ( ) ; ignoredShardToNodes . put ( shardId , nodes ) ; } nodes . add ( nodeId ) ; } public boolean shouldIgnoreShardForNode ( ShardId shardId , String nodeId ) { if ( ignoredShardToNodes = = null ) { return false ; } Set < String > nodes = ignoredShardToNodes . get ( shardId ) ; return nodes ! = null & & nodes . contains ( nodeId ) ; } public Set < String > getIgnoreNodes ( ShardId shardId ) { if ( ignoredShardToNodes = = null ) { return emptySet ( ) ; } Set < String > ignore = ignoredShardToNodes . get ( shardId ) ; if ( ignore = = null ) { return emptySet ( ) ; } return unmodifiableSet ( new HashSet < > ( ignore ) ) ; } public Decision decision ( Decision decision , String deciderLabel , String reason , Object . . . params ) { if ( debugDecision ( ) ) { return Decision . single ( decision . type ( ) , deciderLabel , reason , params ) ; } else { return decision ; } } public boolean hasPendingAsyncFetch ( ) { return hasPendingAsyncFetch ; } public void setHasPendingAsyncFetch ( ) { this . hasPendingAsyncFetch = true ; } } 
