package com . google . common . collect ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . common . base . Optional ; import com . google . common . primitives . Ints ; import java . util . List ; import java . util . Random ; public class BinaryTreeTraverserBenchmark { private static class BinaryNode { final int x ; final Optional < BinaryNode > left ; final Optional < BinaryNode > right ; BinaryNode ( int x , Optional < BinaryNode > left , Optional < BinaryNode > right ) { this . x = x ; this . left = left ; this . right = right ; } } enum Topology { BALANCED { @Override Optional < BinaryNode > createTree ( int size , Random rng ) { if ( size = = <int> ) { return Optional . absent ( ) ; } else { int leftChildSize = ( size - <int> ) / <int> ; int rightChildSize = size - <int> - leftChildSize ; return Optional . of ( new BinaryNode ( rng . nextInt ( ) , createTree ( leftChildSize , rng ) , createTree ( rightChildSize , rng ) ) ) ; } } } , ALL_LEFT { @Override Optional < BinaryNode > createTree ( int size , Random rng ) { Optional < BinaryNode > root = Optional . absent ( ) ; for ( int i = <int> ; i < size ; i + + ) { root = Optional . of ( new BinaryNode ( rng . nextInt ( ) , root , Optional . < BinaryNode > absent ( ) ) ) ; } return root ; } } , ALL_RIGHT { @Override Optional < BinaryNode > createTree ( int size , Random rng ) { Optional < BinaryNode > root = Optional . absent ( ) ; for ( int i = <int> ; i < size ; i + + ) { root = Optional . of ( new BinaryNode ( rng . nextInt ( ) , Optional . < BinaryNode > absent ( ) , root ) ) ; } return root ; } } , RANDOM { @Override Optional < BinaryNode > createTree ( int size , Random rng ) { int [ ] keys = new int [ size ] ; for ( int i = <int> ; i < size ; i + + ) { keys [ i ] = rng . nextInt ( ) ; } return createTreap ( Ints . asList ( keys ) ) ; } private Optional < BinaryNode > createTreap ( List < Integer > keys ) { if ( keys . isEmpty ( ) ) { return Optional . absent ( ) ; } int minIndex = <int> ; for ( int i = <int> ; i < keys . size ( ) ; i + + ) { if ( keys . get ( i ) < keys . get ( minIndex ) ) { minIndex = i ; } } Optional < BinaryNode > leftChild = createTreap ( keys . subList ( <int> , minIndex ) ) ; Optional < BinaryNode > rightChild = createTreap ( keys . subList ( minIndex + <int> , keys . size ( ) ) ) ; return Optional . of ( new BinaryNode ( keys . get ( minIndex ) , leftChild , rightChild ) ) ; } } ; abstract Optional < BinaryNode > createTree ( int size , Random rng ) ; } private static final BinaryTreeTraverser < BinaryNode > BINARY_VIEWER = new BinaryTreeTraverser < BinaryNode > ( ) { @Override public Optional < BinaryNode > leftChild ( BinaryNode node ) { return node . left ; } @Override public Optional < BinaryNode > rightChild ( BinaryNode node ) { return node . right ; } } ; private static final TreeTraverser < BinaryNode > VIEWER = new TreeTraverser < BinaryNode > ( ) { @Override public Iterable < BinaryNode > children ( BinaryNode root ) { return BINARY_VIEWER . children ( root ) ; } } ; enum Traversal { PRE_ORDER { @Override < T > Iterable < T > view ( T root , TreeTraverser < T > viewer ) { return viewer . preOrderTraversal ( root ) ; } } , POST_ORDER { @Override < T > Iterable < T > view ( T root , TreeTraverser < T > viewer ) { return viewer . postOrderTraversal ( root ) ; } } , BREADTH_FIRST { @Override < T > Iterable < T > view ( T root , TreeTraverser < T > viewer ) { return viewer . breadthFirstTraversal ( root ) ; } } ; abstract < T > Iterable < T > view ( T root , TreeTraverser < T > viewer ) ; } private Iterable < BinaryNode > view ; @Param Topology topology ; @Param ( { <str> , <str> , <str> , <str> } ) int size ; @Param Traversal traversal ; @Param boolean useBinaryTraverser ; @Param ( { <str> } ) SpecialRandom rng ; @BeforeExperiment void setUp ( ) { this . view = traversal . view ( topology . createTree ( size , rng ) . get ( ) , useBinaryTraverser ? BINARY_VIEWER : VIEWER ) ; } @Benchmark int traversal ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { for ( BinaryNode node : view ) { tmp + = node . x ; } } return tmp ; } } 
