package org . apache . cassandra . index ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . stream . Collectors ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import org . junit . Test ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . cql3 . restrictions . IndexRestrictions ; import org . apache . cassandra . cql3 . statements . IndexTarget ; import org . apache . cassandra . cql3 . statements . ModificationStatement ; import org . apache . cassandra . cql3 . statements . SelectStatement ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . ReadCommand ; import org . apache . cassandra . db . ReadExecutionController ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . Int32Type ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . schema . IndexMetadata ; import org . apache . cassandra . schema . Indexes ; import org . apache . cassandra . utils . FBUtilities ; import static org . apache . cassandra . Util . throwAssert ; import static org . apache . cassandra . cql3 . statements . IndexTarget . CUSTOM_INDEX_OPTION_NAME ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class CustomIndexTest extends CQLTester { @Test public void testInsertsOnCfsBackedIndex ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; } @Test public void indexControlsIfIncludedInBuildOnNewSSTables ( ) throws Throwable { createTable ( <str> ) ; String toInclude = <str> ; String toExclude = <str> ; createIndex ( String . format ( <str> , toInclude , IndexIncludedInBuild . class . getName ( ) ) ) ; createIndex ( String . format ( <str> , toExclude , IndexExcludedFromBuild . class . getName ( ) ) ) ; execute ( <str> , <int> , <int> ) ; execute ( <str> , <int> , <int> ) ; execute ( <str> , <int> , <int> ) ; flush ( ) ; SecondaryIndexManager indexManager = getCurrentColumnFamilyStore ( ) . indexManager ; IndexIncludedInBuild included = ( IndexIncludedInBuild ) indexManager . getIndexByName ( toInclude ) ; included . reset ( ) ; assertTrue ( included . rowsInserted . isEmpty ( ) ) ; IndexExcludedFromBuild excluded = ( IndexExcludedFromBuild ) indexManager . getIndexByName ( toExclude ) ; excluded . reset ( ) ; assertTrue ( excluded . rowsInserted . isEmpty ( ) ) ; indexManager . buildAllIndexesBlocking ( getCurrentColumnFamilyStore ( ) . getLiveSSTables ( ) ) ; assertEquals ( <int> , included . rowsInserted . size ( ) ) ; assertTrue ( excluded . rowsInserted . isEmpty ( ) ) ; } @Test public void indexReceivesWriteTimeDeletionsCorrectly ( ) throws Throwable { createTable ( <str> ) ; String indexName = <str> ; createIndex ( String . format ( <str> , indexName , StubIndex . class . getName ( ) ) ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> , <int> ) ; SecondaryIndexManager indexManager = getCurrentColumnFamilyStore ( ) . indexManager ; StubIndex index = ( StubIndex ) indexManager . getIndexByName ( indexName ) ; assertEquals ( <int> , index . rowsInserted . size ( ) ) ; assertTrue ( index . partitionDeletions . isEmpty ( ) ) ; assertTrue ( index . rangeTombstones . isEmpty ( ) ) ; execute ( <str> ) ; assertTrue ( index . partitionDeletions . isEmpty ( ) ) ; assertEquals ( <int> , index . rangeTombstones . size ( ) ) ; execute ( <str> ) ; assertEquals ( <int> , index . partitionDeletions . size ( ) ) ; assertEquals ( <int> , index . rangeTombstones . size ( ) ) ; } @Test public void nonCustomIndexesRequireExactlyOneTargetColumn ( ) throws Throwable { createTable ( <str> ) ; assertInvalidMessage ( <str> , <str> ) ; assertInvalidMessage ( <str> , <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertIndexCreated ( <str> , <str> , <str> ) ; } @Test public void rejectDuplicateColumnsInTargetList ( ) throws Throwable { createTable ( <str> ) ; assertInvalidMessage ( <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; } @Test public void requireFullQualifierForFrozenCollectionTargets ( ) throws Throwable { createTable ( <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> + <str> , String . format ( <str> , StubIndex . class . getName ( ) ) ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; } @Test public void defaultIndexNameContainsTargetColumns ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertEquals ( <int> , getCurrentColumnFamilyStore ( ) . metadata . getIndexes ( ) . size ( ) ) ; assertIndexCreated ( currentTable ( ) + <str> , <str> , <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertEquals ( <int> , getCurrentColumnFamilyStore ( ) . metadata . getIndexes ( ) . size ( ) ) ; assertIndexCreated ( currentTable ( ) + <str> , <str> , <str> , <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertEquals ( <int> , getCurrentColumnFamilyStore ( ) . metadata . getIndexes ( ) . size ( ) ) ; assertIndexCreated ( currentTable ( ) + <str> , <str> , <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertEquals ( <int> , getCurrentColumnFamilyStore ( ) . metadata . getIndexes ( ) . size ( ) ) ; Map < String , String > options = new HashMap < > ( ) ; options . put ( <str> , <str> ) ; assertIndexCreated ( currentTable ( ) + <str> , options , <str> , <str> ) ; } @Test public void createMultiColumnIndexes ( ) throws Throwable { createTable ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; testCreateIndex ( <str> , <str> , <str> ) ; testCreateIndex ( <str> , <str> , <str> ) ; testCreateIndex ( <str> , <str> , <str> ) ; testCreateIndex ( <str> , <str> , <str> ) ; testCreateIndex ( <str> , <str> , <str> ) ; testCreateIndex ( <str> , <str> , <str> ) ; testCreateIndex ( <str> , <str> , <str> , <str> ) ; testCreateIndex ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; createIndex ( String . format ( <str> + <str> + <str> , StubIndex . class . getName ( ) ) ) ; assertIndexCreated ( <str> , new HashMap < > ( ) , ImmutableList . of ( indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . FULL ) , indexTarget ( <str> , IndexTarget . Type . FULL ) , indexTarget ( <str> , IndexTarget . Type . FULL ) ) ) ; createIndex ( String . format ( <str> + <str> + <str> , StubIndex . class . getName ( ) ) ) ; assertIndexCreated ( <str> , new HashMap < > ( ) , ImmutableList . of ( indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . KEYS ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . FULL ) , indexTarget ( <str> , IndexTarget . Type . FULL ) , indexTarget ( <str> , IndexTarget . Type . FULL ) ) ) ; } @Test public void createMultiColumnIndexIncludingUserTypeColumn ( ) throws Throwable { String myType = KEYSPACE + <str> + createType ( <str> ) ; createTable ( <str> + myType + <str> ) ; testCreateIndex ( <str> , <str> , <str> ) ; Indexes indexes = getCurrentColumnFamilyStore ( ) . metadata . getIndexes ( ) ; IndexMetadata expected = IndexMetadata . fromIndexTargets ( getCurrentColumnFamilyStore ( ) . metadata , ImmutableList . of ( indexTarget ( <str> , IndexTarget . Type . VALUES ) , indexTarget ( <str> , IndexTarget . Type . VALUES ) ) , <str> , IndexMetadata . Kind . CUSTOM , ImmutableMap . of ( CUSTOM_INDEX_OPTION_NAME , StubIndex . class . getName ( ) ) ) ; IndexMetadata actual = indexes . get ( <str> ) . orElseThrow ( throwAssert ( <str> ) ) ; assertEquals ( expected , actual ) ; } @Test public void createIndexWithoutTargets ( ) throws Throwable { createTable ( <str> ) ; assertInvalidMessage ( <str> , <str> ) ; assertInvalidSyntax ( <str> , StubIndex . class . getName ( ) ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertIndexCreated ( <str> , new HashMap < > ( ) ) ; } @Test public void testCustomIndexExpressionSyntax ( ) throws Throwable { Object [ ] row = row ( <int> , <int> , <int> , <int> ) ; createTable ( <str> ) ; execute ( <str> , row ) ; assertInvalidMessage ( String . format ( IndexRestrictions . INDEX_NOT_FOUND , <str> , keyspace ( ) , currentTable ( ) ) , <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( String . format ( IndexRestrictions . INDEX_NOT_FOUND , <str> , keyspace ( ) , currentTable ( ) ) , <str> ) ; assertRows ( execute ( <str> ) , row ) ; assertRows ( execute ( <str> ) , row ) ; assertRows ( execute ( <str> ) , row ) ; assertInvalidMessage ( IndexRestrictions . MULTIPLE_EXPRESSIONS , <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( IndexRestrictions . MULTIPLE_EXPRESSIONS , <str> ) ; assertInvalidMessage ( SelectStatement . REQUIRES_ALLOW_FILTERING_MESSAGE , <str> ) ; assertRows ( execute ( <str> ) , row ) ; } @Test public void customIndexDoesntSupportCustomExpressions ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , NoCustomExpressionsIndex . class . getName ( ) ) ) ; assertInvalidMessage ( String . format ( IndexRestrictions . CUSTOM_EXPRESSION_NOT_SUPPORTED , <str> ) , <str> ) ; } @Test public void customIndexRejectsExpressionSyntax ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , ExpressionRejectingIndex . class . getName ( ) ) ) ; assertInvalidMessage ( <str> , <str> ) ; } @Test public void customExpressionsMustTargetCustomIndex ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; assertInvalidMessage ( String . format ( IndexRestrictions . NON_CUSTOM_INDEX_IN_EXPRESSION , <str> ) , <str> ) ; } @Test public void customExpressionsDisallowedInModifications ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; assertInvalidMessage ( ModificationStatement . CUSTOM_EXPRESSIONS_NOT_ALLOWED , <str> ) ; assertInvalidMessage ( ModificationStatement . CUSTOM_EXPRESSIONS_NOT_ALLOWED , <str> ) ; } @Test public void indexSelectionPrefersMostSelectiveIndex ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , SettableSelectivityIndex . class . getName ( ) ) ) ; createIndex ( String . format ( <str> , SettableSelectivityIndex . class . getName ( ) ) ) ; SettableSelectivityIndex moreSelective = ( SettableSelectivityIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( <str> ) ; SettableSelectivityIndex lessSelective = ( SettableSelectivityIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( <str> ) ; assertEquals ( <int> , moreSelective . searchersProvided ) ; assertEquals ( <int> , lessSelective . searchersProvided ) ; moreSelective . setEstimatedResultRows ( <int> ) ; lessSelective . setEstimatedResultRows ( <int> ) ; execute ( <str> ) ; assertEquals ( <int> , moreSelective . searchersProvided ) ; assertEquals ( <int> , lessSelective . searchersProvided ) ; moreSelective . setEstimatedResultRows ( <int> ) ; execute ( <str> ) ; assertEquals ( <int> , moreSelective . searchersProvided ) ; assertEquals ( <int> , lessSelective . searchersProvided ) ; } @Test public void customExpressionForcesIndexSelection ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , SettableSelectivityIndex . class . getName ( ) ) ) ; createIndex ( String . format ( <str> , SettableSelectivityIndex . class . getName ( ) ) ) ; SettableSelectivityIndex moreSelective = ( SettableSelectivityIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( <str> ) ; SettableSelectivityIndex lessSelective = ( SettableSelectivityIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( <str> ) ; assertEquals ( <int> , moreSelective . searchersProvided ) ; assertEquals ( <int> , lessSelective . searchersProvided ) ; moreSelective . setEstimatedResultRows ( <int> ) ; lessSelective . setEstimatedResultRows ( <int> ) ; execute ( <str> ) ; assertEquals ( <int> , moreSelective . searchersProvided ) ; assertEquals ( <int> , lessSelective . searchersProvided ) ; execute ( <str> ) ; assertEquals ( <int> , moreSelective . searchersProvided ) ; assertEquals ( <int> , lessSelective . searchersProvided ) ; } @Test public void testCustomExpressionValueType ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , Int32ExpressionIndex . class . getName ( ) ) ) ; createIndex ( String . format ( <str> , UTF8ExpressionIndex . class . getName ( ) ) ) ; execute ( <str> ) ; assertInvalidMessage ( <str> , <str> ) ; execute ( <str> ) ; assertInvalidMessage ( <str> , <str> ) ; } @Test public void reloadIndexMetadataOnBaseCfsReload ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , CountMetadataReloadsIndex . class . getName ( ) ) ) ; ColumnFamilyStore cfs = getCurrentColumnFamilyStore ( ) ; CountMetadataReloadsIndex index = ( CountMetadataReloadsIndex ) cfs . indexManager . getIndexByName ( <str> ) ; assertEquals ( <int> , index . reloads . get ( ) ) ; cfs . reload ( ) ; assertEquals ( <int> , index . reloads . get ( ) ) ; } @Test public void notifyIndexersOfPartitionAndRowRemovalDuringCleanup ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; ColumnFamilyStore cfs = getCurrentColumnFamilyStore ( ) ; StubIndex index = ( StubIndex ) cfs . indexManager . getIndexByName ( <str> ) ; execute ( <str> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> ) ; assertEquals ( <int> , index . rowsInserted . size ( ) ) ; assertEquals ( <int> , index . partitionDeletions . size ( ) ) ; ReadCommand cmd = Util . cmd ( cfs , <int> ) . build ( ) ; try ( ReadExecutionController executionController = cmd . executionController ( ) ; UnfilteredPartitionIterator iterator = cmd . executeLocally ( executionController ) ) { assertTrue ( iterator . hasNext ( ) ) ; cfs . indexManager . deletePartition ( iterator . next ( ) , FBUtilities . nowInSeconds ( ) ) ; } assertEquals ( <int> , index . partitionDeletions . size ( ) ) ; assertEquals ( <int> , index . rowsDeleted . size ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) assertEquals ( index . rowsDeleted . get ( i ) . clustering ( ) , index . rowsInserted . get ( i ) . clustering ( ) ) ; } private void testCreateIndex ( String indexName , String . . . targetColumnNames ) throws Throwable { createIndex ( String . format ( <str> , indexName , Arrays . stream ( targetColumnNames ) . collect ( Collectors . joining ( <str> ) ) , StubIndex . class . getName ( ) ) ) ; assertIndexCreated ( indexName , targetColumnNames ) ; } private void assertIndexCreated ( String name , String . . . targetColumnNames ) { assertIndexCreated ( name , new HashMap < > ( ) , targetColumnNames ) ; } private void assertIndexCreated ( String name , Map < String , String > options , String . . . targetColumnNames ) { List < IndexTarget > targets = Arrays . stream ( targetColumnNames ) . map ( s - > new IndexTarget ( ColumnIdentifier . getInterned ( s , true ) , IndexTarget . Type . VALUES ) ) . collect ( Collectors . toList ( ) ) ; assertIndexCreated ( name , options , targets ) ; } private void assertIndexCreated ( String name , Map < String , String > options , List < IndexTarget > targets ) { options . put ( CUSTOM_INDEX_OPTION_NAME , StubIndex . class . getName ( ) ) ; CFMetaData cfm = getCurrentColumnFamilyStore ( ) . metadata ; IndexMetadata expected = IndexMetadata . fromIndexTargets ( cfm , targets , name , IndexMetadata . Kind . CUSTOM , options ) ; Indexes indexes = getCurrentColumnFamilyStore ( ) . metadata . getIndexes ( ) ; for ( IndexMetadata actual : indexes ) if ( actual . equals ( expected ) ) return ; fail ( String . format ( <str> , expected ) ) ; } private static IndexTarget indexTarget ( String name , IndexTarget . Type type ) { return new IndexTarget ( ColumnIdentifier . getInterned ( name , true ) , type ) ; } public static final class CountMetadataReloadsIndex extends StubIndex { private final AtomicInteger reloads = new AtomicInteger ( <int> ) ; public CountMetadataReloadsIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) { super ( baseCfs , metadata ) ; } public void reset ( ) { super . reset ( ) ; reloads . set ( <int> ) ; } public Callable < ? > getMetadataReloadTask ( IndexMetadata indexMetadata ) { return reloads : : incrementAndGet ; } } public static final class IndexIncludedInBuild extends StubIndex { public IndexIncludedInBuild ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) { super ( baseCfs , metadata ) ; } public boolean shouldBuildBlocking ( ) { return true ; } } public static final class UTF8ExpressionIndex extends StubIndex { public UTF8ExpressionIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) { super ( baseCfs , metadata ) ; } public AbstractType < ? > customExpressionValueType ( ) { return UTF8Type . instance ; } } public static final class Int32ExpressionIndex extends StubIndex { public Int32ExpressionIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) { super ( baseCfs , metadata ) ; } public AbstractType < ? > customExpressionValueType ( ) { return Int32Type . instance ; } } public static final class SettableSelectivityIndex extends StubIndex { private int searchersProvided = <int> ; private long estimatedResultRows = <int> ; public SettableSelectivityIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) { super ( baseCfs , metadata ) ; } public void setEstimatedResultRows ( long estimate ) { estimatedResultRows = estimate ; } public long getEstimatedResultRows ( ) { return estimatedResultRows ; } public Searcher searcherFor ( ReadCommand command ) { searchersProvided + + ; return super . searcherFor ( command ) ; } } public static final class IndexExcludedFromBuild extends StubIndex { public IndexExcludedFromBuild ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) { super ( baseCfs , metadata ) ; } public boolean shouldBuildBlocking ( ) { return false ; } } public static final class NoCustomExpressionsIndex extends StubIndex { public NoCustomExpressionsIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) { super ( baseCfs , metadata ) ; } public AbstractType < ? > customExpressionValueType ( ) { return null ; } } public static final class ExpressionRejectingIndex extends StubIndex { public ExpressionRejectingIndex ( ColumnFamilyStore baseCfs , IndexMetadata metadata ) { super ( baseCfs , metadata ) ; } public Searcher searcherFor ( ReadCommand command ) throws InvalidRequestException { throw new InvalidRequestException ( <str> ) ; } } } 
