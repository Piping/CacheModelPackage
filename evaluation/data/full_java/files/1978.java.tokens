package org . nd4j . linalg . api . complex ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . Indices ; import org . nd4j . linalg . api . shape . Shape ; import java . util . ArrayList ; import java . util . List ; public class LinearViewComplexNDArray extends BaseComplexNDArray { private IComplexNDArray wrapped ; private List < INDArray > vectors ; public LinearViewComplexNDArray ( IComplexNDArray wrapped ) { if ( wrapped . getLeadingOnes ( ) > <int> | | wrapped . getTrailingOnes ( ) > <int> ) { wrapped = Nd4j . createComplex ( wrapped . data ( ) , Shape . squeeze ( wrapped . shape ( ) ) ) ; } this . wrapped = wrapped ; this . shape = new int [ ] { <int> , wrapped . length ( ) } ; this . data = wrapped . data ( ) ; this . offset = wrapped . offset ( ) ; this . ordering = wrapped . ordering ( ) ; this . length = wrapped . length ( ) ; vectors = new ArrayList < > ( ) ; collectRows ( wrapped ) ; } protected void collectRows ( INDArray slice ) { if ( slice . isRowVector ( ) ) { vectors . add ( slice ) ; } else if ( slice . isMatrix ( ) ) { for ( int i = <int> ; i < slice . rows ( ) ; i + + ) vectors . add ( slice . getRow ( i ) ) ; } else for ( int i = <int> ; i < slice . slices ( ) ; i + + ) collectRows ( slice . slice ( i ) ) ; } @Override public boolean isCleanedUp ( ) { return wrapped . isCleanedUp ( ) ; } @Override public void cleanup ( ) { wrapped . cleanup ( ) ; } @Override public void resetLinearView ( ) { } @Override public int secondaryStride ( ) { return wrapped . secondaryStride ( ) ; } @Override public int majorStride ( ) { return wrapped . majorStride ( ) ; } @Override public IComplexNDArray linearView ( ) { return this ; } @Override public IComplexNDArray linearViewColumnOrder ( ) { return this ; } @Override public int vectorsAlongDimension ( int dimension ) { if ( dimension > <int> ) throw new IllegalArgumentException ( <str> ) ; return <int> ; } @Override public IComplexNDArray vectorAlongDimension ( int index , int dimension ) { if ( dimension = = <int> | | dimension = = <int> & & index = = <int> ) return this ; throw new IllegalArgumentException ( <str> ) ; } @Override public IComplexNumber getComplex ( int i ) { if ( wrapped . isVector ( ) ) return wrapped . getComplex ( i ) ; int vectorSize = wrapped . size ( - <int> ) ; int vectorIdx = Indices . rowNumber ( i , wrapped ) ; IComplexNDArray currVector = ( IComplexNDArray ) vectors . get ( vectorIdx ) ; int offset = vectorSize * vectorIdx ; int idx = i - offset ; return currVector . getComplex ( idx ) ; } @Override public IComplexNDArray putScalar ( int i , double value ) { int vectorSize = wrapped . size ( - <int> ) ; int vectorIdx = Indices . rowNumber ( i , wrapped ) ; INDArray currVector = vectors . get ( vectorIdx ) ; int offset = vectorSize * vectorIdx ; int idx = i - offset ; currVector . putScalar ( idx , value ) ; return this ; } @Override public IComplexNDArray putScalar ( int i , IComplexNumber value ) { int vectorSize = wrapped . size ( - <int> ) ; int vectorIdx = Indices . rowNumber ( i , wrapped ) ; IComplexNDArray currVector = ( IComplexNDArray ) vectors . get ( vectorIdx ) ; int offset = vectorSize * vectorIdx ; int idx = i - offset ; currVector . putScalar ( idx , value ) ; return this ; } @Override public int length ( ) { return wrapped . length ( ) ; } @Override public double getDouble ( int i ) { if ( wrapped . isVector ( ) ) return wrapped . getDouble ( i ) ; int vectorSize = wrapped . size ( - <int> ) ; int vectorIdx = Indices . rowNumber ( i , wrapped ) ; INDArray currVector = vectors . get ( vectorIdx ) ; int offset = vectorSize * vectorIdx ; int idx = i - offset ; return currVector . getDouble ( idx ) ; } @Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( <str> ) ; for ( int i = <int> ; i < wrapped . length ( ) ; i + + ) { sb . append ( getComplex ( i ) ) ; if ( i < wrapped . length ( ) - <int> ) { sb . append ( <str> ) ; } } sb . append ( <str> ) ; return sb . toString ( ) ; } } 
