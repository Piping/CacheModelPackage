package org . elasticsearch . discovery ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . AbstractRunnable ; import org . elasticsearch . test . ESTestCase ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . CyclicBarrier ; import static org . hamcrest . Matchers . * ; public class BlockingClusterStatePublishResponseHandlerTests extends ESTestCase { static private class PublishResponder extends AbstractRunnable { final boolean fail ; final DiscoveryNode node ; final CyclicBarrier barrier ; final ESLogger logger ; final BlockingClusterStatePublishResponseHandler handler ; public PublishResponder ( boolean fail , DiscoveryNode node , CyclicBarrier barrier , ESLogger logger , BlockingClusterStatePublishResponseHandler handler ) { this . fail = fail ; this . node = node ; this . barrier = barrier ; this . logger = logger ; this . handler = handler ; } @Override public void onFailure ( Throwable t ) { logger . error ( <str> , t ) ; } @Override protected void doRun ( ) throws Exception { barrier . await ( ) ; if ( fail ) { handler . onFailure ( node , new Exception ( <str> ) ) ; } else { handler . onResponse ( node ) ; } } } public void testConcurrentAccess ( ) throws InterruptedException { int nodeCount = scaledRandomIntBetween ( <int> , <int> ) ; DiscoveryNode [ ] allNodes = new DiscoveryNode [ nodeCount ] ; for ( int i = <int> ; i < nodeCount ; i + + ) { DiscoveryNode node = new DiscoveryNode ( <str> + i , DummyTransportAddress . INSTANCE , Version . CURRENT ) ; allNodes [ i ] = node ; } BlockingClusterStatePublishResponseHandler handler = new BlockingClusterStatePublishResponseHandler ( new HashSet < > ( Arrays . asList ( allNodes ) ) ) ; int firstRound = randomIntBetween ( <int> , nodeCount - <int> ) ; Thread [ ] threads = new Thread [ firstRound ] ; CyclicBarrier barrier = new CyclicBarrier ( firstRound ) ; Set < DiscoveryNode > completedNodes = new HashSet < > ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { completedNodes . add ( allNodes [ i ] ) ; threads [ i ] = new Thread ( new PublishResponder ( randomBoolean ( ) , allNodes [ i ] , barrier , logger , handler ) ) ; threads [ i ] . start ( ) ; } for ( Thread t : threads ) { t . join ( ) ; } assertFalse ( <str> , handler . awaitAllNodes ( new TimeValue ( <int> ) ) ) ; Set < DiscoveryNode > pendingNodes = new HashSet < > ( Arrays . asList ( handler . pendingNodes ( ) ) ) ; assertThat ( completedNodes , not ( contains ( pendingNodes . toArray ( new DiscoveryNode [ <int> ] ) ) ) ) ; assertThat ( completedNodes . size ( ) + pendingNodes . size ( ) , equalTo ( allNodes . length ) ) ; int secondRound = allNodes . length - firstRound ; threads = new Thread [ secondRound ] ; barrier = new CyclicBarrier ( secondRound ) ; for ( int i = <int> ; i < threads . length ; i + + ) { threads [ i ] = new Thread ( new PublishResponder ( randomBoolean ( ) , allNodes [ firstRound + i ] , barrier , logger , handler ) ) ; threads [ i ] . start ( ) ; } for ( Thread t : threads ) { t . join ( ) ; } assertTrue ( <str> , handler . awaitAllNodes ( new TimeValue ( <int> ) ) ) ; assertThat ( handler . pendingNodes ( ) , arrayWithSize ( <int> ) ) ; } } 
