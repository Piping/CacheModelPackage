package io . netty . handler . codec . http2 ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . netty . channel . socket . nio . NioSocketChannel ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http2 . Http2TestUtil . Http2Runnable ; import io . netty . util . AsciiString ; import io . netty . util . CharsetUtil ; import io . netty . util . NetUtil ; import io . netty . util . concurrent . Future ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import java . io . ByteArrayOutputStream ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . util . Random ; import java . util . concurrent . CountDownLatch ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT ; import static io . netty . handler . codec . http2 . Http2TestUtil . runInChannel ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyBoolean ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Matchers . anyShort ; import static org . mockito . Matchers . eq ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . verify ; public class DataCompressionHttp2Test { private static final AsciiString GET = new AsciiString ( <str> ) ; private static final AsciiString POST = new AsciiString ( <str> ) ; private static final AsciiString PATH = new AsciiString ( <str> ) ; @Mock private Http2FrameListener serverListener ; @Mock private Http2FrameListener clientListener ; private Http2ConnectionEncoder clientEncoder ; private ServerBootstrap sb ; private Bootstrap cb ; private Channel serverChannel ; private Channel clientChannel ; private CountDownLatch serverLatch ; private Http2Connection serverConnection ; private Http2Connection clientConnection ; private Http2ConnectionHandler clientHandler ; private ByteArrayOutputStream serverOut ; @Before public void setup ( ) throws InterruptedException , Http2Exception { MockitoAnnotations . initMocks ( this ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock invocation ) throws Throwable { if ( invocation . getArgumentAt ( <int> , Boolean . class ) ) { serverConnection . stream ( invocation . getArgumentAt ( <int> , Integer . class ) ) . close ( ) ; } return null ; } } ) . when ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( Http2Headers . class ) , anyInt ( ) , anyBoolean ( ) ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock invocation ) throws Throwable { if ( invocation . getArgumentAt ( <int> , Boolean . class ) ) { serverConnection . stream ( invocation . getArgumentAt ( <int> , Integer . class ) ) . close ( ) ; } return null ; } } ) . when ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( Http2Headers . class ) , anyInt ( ) , anyShort ( ) , anyBoolean ( ) , anyInt ( ) , anyBoolean ( ) ) ; } @After public void cleaup ( ) throws IOException { serverOut . close ( ) ; } @After public void teardown ( ) throws InterruptedException { if ( clientChannel ! = null ) { clientChannel . close ( ) . sync ( ) ; clientChannel = null ; } if ( serverChannel ! = null ) { serverChannel . close ( ) . sync ( ) ; serverChannel = null ; } Future < ? > serverGroup = sb . group ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; Future < ? > serverChildGroup = sb . childGroup ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; Future < ? > clientGroup = cb . group ( ) . shutdownGracefully ( <int> , <int> , MILLISECONDS ) ; serverGroup . sync ( ) ; serverChildGroup . sync ( ) ; clientGroup . sync ( ) ; } @Test public void justHeadersNoData ( ) throws Exception { bootstrapEnv ( <int> ) ; final Http2Headers headers = new DefaultHttp2Headers ( ) . method ( GET ) . path ( PATH ) . set ( HttpHeaderNames . CONTENT_ENCODING , HttpHeaderValues . GZIP ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { clientEncoder . writeHeaders ( ctxClient ( ) , <int> , headers , <int> , true , newPromiseClient ( ) ) ; clientHandler . flush ( ctxClient ( ) ) ; } } ) ; awaitServer ( ) ; verify ( serverListener ) . onHeadersRead ( any ( ChannelHandlerContext . class ) , eq ( <int> ) , eq ( headers ) , eq ( <int> ) , eq ( DEFAULT_PRIORITY_WEIGHT ) , eq ( false ) , eq ( <int> ) , eq ( true ) ) ; } @Test public void gzipEncodingSingleEmptyMessage ( ) throws Exception { final String text = <str> ; final ByteBuf data = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; bootstrapEnv ( data . readableBytes ( ) ) ; try { final Http2Headers headers = new DefaultHttp2Headers ( ) . method ( POST ) . path ( PATH ) . set ( HttpHeaderNames . CONTENT_ENCODING , HttpHeaderValues . GZIP ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { clientEncoder . writeHeaders ( ctxClient ( ) , <int> , headers , <int> , false , newPromiseClient ( ) ) ; clientEncoder . writeData ( ctxClient ( ) , <int> , data . retain ( ) , <int> , true , newPromiseClient ( ) ) ; clientHandler . flush ( ctxClient ( ) ) ; } } ) ; awaitServer ( ) ; assertEquals ( text , serverOut . toString ( CharsetUtil . UTF_8 . name ( ) ) ) ; } finally { data . release ( ) ; } } @Test public void gzipEncodingSingleMessage ( ) throws Exception { final String text = <str> ; final ByteBuf data = Unpooled . copiedBuffer ( text . getBytes ( ) ) ; bootstrapEnv ( data . readableBytes ( ) ) ; try { final Http2Headers headers = new DefaultHttp2Headers ( ) . method ( POST ) . path ( PATH ) . set ( HttpHeaderNames . CONTENT_ENCODING , HttpHeaderValues . GZIP ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { clientEncoder . writeHeaders ( ctxClient ( ) , <int> , headers , <int> , false , newPromiseClient ( ) ) ; clientEncoder . writeData ( ctxClient ( ) , <int> , data . retain ( ) , <int> , true , newPromiseClient ( ) ) ; clientHandler . flush ( ctxClient ( ) ) ; } } ) ; awaitServer ( ) ; assertEquals ( text , serverOut . toString ( CharsetUtil . UTF_8 . name ( ) ) ) ; } finally { data . release ( ) ; } } @Test public void gzipEncodingMultipleMessages ( ) throws Exception { final String text1 = <str> ; final String text2 = <str> ; final ByteBuf data1 = Unpooled . copiedBuffer ( text1 . getBytes ( ) ) ; final ByteBuf data2 = Unpooled . copiedBuffer ( text2 . getBytes ( ) ) ; bootstrapEnv ( data1 . readableBytes ( ) + data2 . readableBytes ( ) ) ; try { final Http2Headers headers = new DefaultHttp2Headers ( ) . method ( POST ) . path ( PATH ) . set ( HttpHeaderNames . CONTENT_ENCODING , HttpHeaderValues . GZIP ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { clientEncoder . writeHeaders ( ctxClient ( ) , <int> , headers , <int> , false , newPromiseClient ( ) ) ; clientEncoder . writeData ( ctxClient ( ) , <int> , data1 . retain ( ) , <int> , false , newPromiseClient ( ) ) ; clientEncoder . writeData ( ctxClient ( ) , <int> , data2 . retain ( ) , <int> , true , newPromiseClient ( ) ) ; clientHandler . flush ( ctxClient ( ) ) ; } } ) ; awaitServer ( ) ; assertEquals ( text1 + text2 , serverOut . toString ( CharsetUtil . UTF_8 . name ( ) ) ) ; } finally { data1 . release ( ) ; data2 . release ( ) ; } } @Test public void deflateEncodingWriteLargeMessage ( ) throws Exception { final int BUFFER_SIZE = <int> < < <int> ; final byte [ ] bytes = new byte [ BUFFER_SIZE ] ; new Random ( ) . nextBytes ( bytes ) ; bootstrapEnv ( BUFFER_SIZE ) ; final ByteBuf data = Unpooled . wrappedBuffer ( bytes ) ; try { final Http2Headers headers = new DefaultHttp2Headers ( ) . method ( POST ) . path ( PATH ) . set ( HttpHeaderNames . CONTENT_ENCODING , HttpHeaderValues . DEFLATE ) ; runInChannel ( clientChannel , new Http2Runnable ( ) { @Override public void run ( ) throws Http2Exception { clientEncoder . writeHeaders ( ctxClient ( ) , <int> , headers , <int> , false , newPromiseClient ( ) ) ; clientEncoder . writeData ( ctxClient ( ) , <int> , data . retain ( ) , <int> , true , newPromiseClient ( ) ) ; clientHandler . flush ( ctxClient ( ) ) ; } } ) ; awaitServer ( ) ; assertEquals ( data . resetReaderIndex ( ) . toString ( CharsetUtil . UTF_8 ) , serverOut . toString ( CharsetUtil . UTF_8 . name ( ) ) ) ; } finally { data . release ( ) ; } } private void bootstrapEnv ( int serverOutSize ) throws Exception { serverOut = new ByteArrayOutputStream ( serverOutSize ) ; serverLatch = new CountDownLatch ( <int> ) ; sb = new ServerBootstrap ( ) ; cb = new Bootstrap ( ) ; serverConnection = new DefaultHttp2Connection ( true ) ; clientConnection = new DefaultHttp2Connection ( false ) ; serverConnection . addListener ( new Http2ConnectionAdapter ( ) { @Override public void onStreamClosed ( Http2Stream stream ) { serverLatch . countDown ( ) ; } } ) ; doAnswer ( new Answer < Integer > ( ) { @Override public Integer answer ( InvocationOnMock in ) throws Throwable { ByteBuf buf = ( ByteBuf ) in . getArguments ( ) [ <int> ] ; int padding = ( Integer ) in . getArguments ( ) [ <int> ] ; int processedBytes = buf . readableBytes ( ) + padding ; buf . readBytes ( serverOut , buf . readableBytes ( ) ) ; if ( in . getArgumentAt ( <int> , Boolean . class ) ) { serverConnection . stream ( in . getArgumentAt ( <int> , Integer . class ) ) . close ( ) ; } return processedBytes ; } } ) . when ( serverListener ) . onDataRead ( any ( ChannelHandlerContext . class ) , anyInt ( ) , any ( ByteBuf . class ) , anyInt ( ) , anyBoolean ( ) ) ; final CountDownLatch serverChannelLatch = new CountDownLatch ( <int> ) ; sb . group ( new NioEventLoopGroup ( ) , new NioEventLoopGroup ( ) ) ; sb . channel ( NioServerSocketChannel . class ) ; sb . childHandler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; Http2FrameWriter frameWriter = new DefaultHttp2FrameWriter ( ) ; serverConnection . remote ( ) . flowController ( new DefaultHttp2RemoteFlowController ( serverConnection ) ) ; serverConnection . local ( ) . flowController ( new DefaultHttp2LocalFlowController ( serverConnection ) . frameWriter ( frameWriter ) ) ; Http2ConnectionEncoder encoder = new CompressorHttp2ConnectionEncoder ( new DefaultHttp2ConnectionEncoder ( serverConnection , frameWriter ) ) ; Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder ( serverConnection , encoder , new DefaultHttp2FrameReader ( ) ) ; Http2ConnectionHandler connectionHandler = new Http2ConnectionHandler . Builder ( ) . frameListener ( new DelegatingDecompressorFrameListener ( serverConnection , serverListener ) ) . build ( decoder , encoder ) ; p . addLast ( connectionHandler ) ; serverChannelLatch . countDown ( ) ; } } ) ; cb . group ( new NioEventLoopGroup ( ) ) ; cb . channel ( NioSocketChannel . class ) ; cb . handler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ChannelPipeline p = ch . pipeline ( ) ; Http2FrameWriter frameWriter = new DefaultHttp2FrameWriter ( ) ; clientConnection . remote ( ) . flowController ( new DefaultHttp2RemoteFlowController ( clientConnection ) ) ; clientConnection . local ( ) . flowController ( new DefaultHttp2LocalFlowController ( clientConnection ) . frameWriter ( frameWriter ) ) ; clientEncoder = new CompressorHttp2ConnectionEncoder ( new DefaultHttp2ConnectionEncoder ( clientConnection , frameWriter ) ) ; Http2ConnectionDecoder decoder = new DefaultHttp2ConnectionDecoder ( clientConnection , clientEncoder , new DefaultHttp2FrameReader ( ) ) ; clientHandler = new Http2ConnectionHandler . Builder ( ) . frameListener ( new DelegatingDecompressorFrameListener ( clientConnection , clientListener ) ) . gracefulShutdownTimeoutMillis ( <int> ) . build ( decoder , clientEncoder ) ; p . addLast ( clientHandler ) ; } } ) ; serverChannel = sb . bind ( new InetSocketAddress ( <int> ) ) . sync ( ) . channel ( ) ; int port = ( ( InetSocketAddress ) serverChannel . localAddress ( ) ) . getPort ( ) ; ChannelFuture ccf = cb . connect ( new InetSocketAddress ( NetUtil . LOCALHOST , port ) ) ; assertTrue ( ccf . awaitUninterruptibly ( ) . isSuccess ( ) ) ; clientChannel = ccf . channel ( ) ; assertTrue ( serverChannelLatch . await ( <int> , SECONDS ) ) ; } private void awaitServer ( ) throws Exception { assertTrue ( serverLatch . await ( <int> , SECONDS ) ) ; serverOut . flush ( ) ; } private ChannelHandlerContext ctxClient ( ) { return clientChannel . pipeline ( ) . firstContext ( ) ; } private ChannelPromise newPromiseClient ( ) { return ctxClient ( ) . newPromise ( ) ; } } 
