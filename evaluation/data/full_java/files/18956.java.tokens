package io . netty . handler . codec . xml ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . CorruptedFrameException ; import io . netty . handler . codec . TooLongFrameException ; import java . util . List ; public class XmlFrameDecoder extends ByteToMessageDecoder { private final int maxFrameLength ; public XmlFrameDecoder ( int maxFrameLength ) { if ( maxFrameLength < <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . maxFrameLength = maxFrameLength ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { boolean openingBracketFound = false ; boolean atLeastOneXmlElementFound = false ; boolean inCDATASection = false ; long openBracketsCount = <int> ; int length = <int> ; int leadingWhiteSpaceCount = <int> ; final int bufferLength = in . writerIndex ( ) ; if ( bufferLength > maxFrameLength ) { in . skipBytes ( in . readableBytes ( ) ) ; fail ( bufferLength ) ; return ; } for ( int i = in . readerIndex ( ) ; i < bufferLength ; i + + ) { final byte readByte = in . getByte ( i ) ; if ( ! openingBracketFound & & Character . isWhitespace ( readByte ) ) { leadingWhiteSpaceCount + + ; } else if ( ! openingBracketFound & & readByte ! = <str> ) { fail ( ctx ) ; in . skipBytes ( in . readableBytes ( ) ) ; return ; } else if ( ! inCDATASection & & readByte = = <str> ) { openingBracketFound = true ; if ( i < bufferLength - <int> ) { final byte peekAheadByte = in . getByte ( i + <int> ) ; if ( peekAheadByte = = <str> ) { int peekFurtherAheadIndex = i + <int> ; while ( peekFurtherAheadIndex < = bufferLength - <int> ) { if ( in . getByte ( peekFurtherAheadIndex ) = = <str> ) { openBracketsCount - - ; break ; } peekFurtherAheadIndex + + ; } } else if ( isValidStartCharForXmlElement ( peekAheadByte ) ) { atLeastOneXmlElementFound = true ; openBracketsCount + + ; } else if ( peekAheadByte = = <str> ) { if ( isCommentBlockStart ( in , i ) ) { openBracketsCount + + ; } else if ( isCDATABlockStart ( in , i ) ) { openBracketsCount + + ; inCDATASection = true ; } } else if ( peekAheadByte = = <str> ) { openBracketsCount + + ; } } } else if ( ! inCDATASection & & readByte = = <str> ) { if ( i < bufferLength - <int> & & in . getByte ( i + <int> ) = = <str> ) { openBracketsCount - - ; } } else if ( readByte = = <str> ) { length = i + <int> ; if ( i - <int> > - <int> ) { final byte peekBehindByte = in . getByte ( i - <int> ) ; if ( ! inCDATASection ) { if ( peekBehindByte = = <str> ) { openBracketsCount - - ; } else if ( peekBehindByte = = <str> & & i - <int> > - <int> & & in . getByte ( i - <int> ) = = <str> ) { openBracketsCount - - ; } } else if ( peekBehindByte = = <str> & & i - <int> > - <int> & & in . getByte ( i - <int> ) = = <str> ) { openBracketsCount - - ; inCDATASection = false ; } } if ( atLeastOneXmlElementFound & & openBracketsCount = = <int> ) { break ; } } } final int readerIndex = in . readerIndex ( ) ; int xmlElementLength = length - readerIndex ; if ( openBracketsCount = = <int> & & xmlElementLength > <int> ) { if ( readerIndex + xmlElementLength > = bufferLength ) { xmlElementLength = in . readableBytes ( ) ; } final ByteBuf frame = extractFrame ( in , readerIndex + leadingWhiteSpaceCount , xmlElementLength - leadingWhiteSpaceCount ) ; in . skipBytes ( xmlElementLength ) ; out . add ( frame ) ; } } private void fail ( long frameLength ) { if ( frameLength > <int> ) { throw new TooLongFrameException ( <str> + maxFrameLength + <str> + frameLength + <str> ) ; } else { throw new TooLongFrameException ( <str> + maxFrameLength + <str> ) ; } } private static void fail ( ChannelHandlerContext ctx ) { ctx . fireExceptionCaught ( new CorruptedFrameException ( <str> ) ) ; } private static ByteBuf extractFrame ( ByteBuf buffer , int index , int length ) { return buffer . copy ( index , length ) ; } private static boolean isValidStartCharForXmlElement ( final byte b ) { return b > = <str> & & b < = <str> | | b > = <str> & & b < = <str> | | b = = <str> | | b = = <str> ; } private static boolean isCommentBlockStart ( final ByteBuf in , final int i ) { return i < in . writerIndex ( ) - <int> & & in . getByte ( i + <int> ) = = <str> & & in . getByte ( i + <int> ) = = <str> ; } private static boolean isCDATABlockStart ( final ByteBuf in , final int i ) { return i < in . writerIndex ( ) - <int> & & in . getByte ( i + <int> ) = = <str> & & in . getByte ( i + <int> ) = = <str> & & in . getByte ( i + <int> ) = = <str> & & in . getByte ( i + <int> ) = = <str> & & in . getByte ( i + <int> ) = = <str> & & in . getByte ( i + <int> ) = = <str> & & in . getByte ( i + <int> ) = = <str> ; } } 
