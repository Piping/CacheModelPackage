package org . eclipse . debug . internal . core ; import java . io . BufferedInputStream ; import java . io . IOException ; import java . io . InputStream ; import org . eclipse . core . runtime . ISafeRunnable ; import org . eclipse . core . runtime . ListenerList ; import org . eclipse . core . runtime . SafeRunner ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IStreamListener ; import org . eclipse . debug . core . model . IFlushableStreamMonitor ; public class OutputStreamMonitor implements IFlushableStreamMonitor { private InputStream fStream ; private ListenerList fListeners = new ListenerList ( ) ; private boolean fBuffered = true ; private StringBuffer fContents ; private Thread fThread ; private static final int BUFFER_SIZE = <int> ; private boolean fKilled = false ; private long lastSleep ; private String fEncoding ; public OutputStreamMonitor ( InputStream stream , String encoding ) { fStream = new BufferedInputStream ( stream , <int> ) ; fEncoding = encoding ; fContents = new StringBuffer ( ) ; } @Override public synchronized void addListener ( IStreamListener listener ) { fListeners . add ( listener ) ; } protected void close ( ) { if ( fThread ! = null ) { Thread thread = fThread ; fThread = null ; try { thread . join ( ) ; } catch ( InterruptedException ie ) { } fListeners = new ListenerList ( ) ; } } private void fireStreamAppended ( String text ) { getNotifier ( ) . notifyAppend ( text ) ; } @Override public synchronized String getContents ( ) { return fContents . toString ( ) ; } private void read ( ) { lastSleep = System . currentTimeMillis ( ) ; long currentTime = lastSleep ; byte [ ] bytes = new byte [ BUFFER_SIZE ] ; int read = <int> ; while ( read > = <int> ) { try { if ( fKilled ) { break ; } read = fStream . read ( bytes ) ; if ( read > <int> ) { String text ; if ( fEncoding ! = null ) { text = new String ( bytes , <int> , read , fEncoding ) ; } else { text = new String ( bytes , <int> , read ) ; } synchronized ( this ) { if ( isBuffered ( ) ) { fContents . append ( text ) ; } fireStreamAppended ( text ) ; } } } catch ( IOException ioe ) { if ( ! fKilled ) { DebugPlugin . log ( ioe ) ; } return ; } catch ( NullPointerException e ) { if ( ! fKilled & & fThread ! = null ) { DebugPlugin . log ( e ) ; } return ; } currentTime = System . currentTimeMillis ( ) ; if ( currentTime - lastSleep > <int> ) { lastSleep = currentTime ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } try { fStream . close ( ) ; } catch ( IOException e ) { DebugPlugin . log ( e ) ; } } protected void kill ( ) { fKilled = true ; } @Override public synchronized void removeListener ( IStreamListener listener ) { fListeners . remove ( listener ) ; } protected void startMonitoring ( ) { if ( fThread = = null ) { fThread = new Thread ( new Runnable ( ) { @Override public void run ( ) { read ( ) ; } } , DebugCoreMessages . OutputStreamMonitor_label ) ; fThread . setDaemon ( true ) ; fThread . setPriority ( Thread . MIN_PRIORITY ) ; fThread . start ( ) ; } } @Override public synchronized void setBuffered ( boolean buffer ) { fBuffered = buffer ; } @Override public synchronized void flushContents ( ) { fContents . setLength ( <int> ) ; } @Override public synchronized boolean isBuffered ( ) { return fBuffered ; } private ContentNotifier getNotifier ( ) { return new ContentNotifier ( ) ; } class ContentNotifier implements ISafeRunnable { private IStreamListener fListener ; private String fText ; @Override public void handleException ( Throwable exception ) { DebugPlugin . log ( exception ) ; } @Override public void run ( ) throws Exception { fListener . streamAppended ( fText , OutputStreamMonitor . this ) ; } public void notifyAppend ( String text ) { if ( text = = null ) { return ; } fText = text ; Object [ ] copiedListeners = fListeners . getListeners ( ) ; for ( int i = <int> ; i < copiedListeners . length ; i + + ) { fListener = ( IStreamListener ) copiedListeners [ i ] ; SafeRunner . run ( this ) ; } fListener = null ; fText = null ; } } } 
