package com . badlogic . gdx . utils ; import java . util . Iterator ; import java . util . NoSuchElementException ; import com . badlogic . gdx . utils . Array . ArrayIterable ; import com . badlogic . gdx . utils . reflect . ArrayReflection ; public class Queue < T > implements Iterable < T > { protected T [ ] values ; protected int head = <int> ; protected int tail = <int> ; public int size = <int> ; private QueueIterable iterable ; public Queue ( ) { this ( <int> ) ; } public Queue ( int initialSize ) { this . values = ( T [ ] ) new Object [ initialSize ] ; } public Queue ( int initialSize , Class < T > type ) { this . values = ( T [ ] ) ArrayReflection . newInstance ( type , initialSize ) ; } public void addLast ( T object ) { T [ ] values = this . values ; if ( size = = values . length ) { resize ( values . length < < <int> ) ; values = this . values ; } values [ tail + + ] = object ; if ( tail = = values . length ) { tail = <int> ; } size + + ; } public void addFirst ( T object ) { T [ ] values = this . values ; if ( size = = values . length ) { resize ( values . length < < <int> ) ; values = this . values ; } int head = this . head ; head - - ; if ( head = = - <int> ) { head = values . length - <int> ; } values [ head ] = object ; this . head = head ; this . size + + ; } public void ensureCapacity ( int additional ) { final int needed = size + additional ; if ( values . length < needed ) { resize ( needed ) ; } } protected void resize ( int newSize ) { final T [ ] values = this . values ; final int head = this . head ; final int tail = this . tail ; @SuppressWarnings ( <str> ) final T [ ] newArray = ( T [ ] ) ArrayReflection . newInstance ( values . getClass ( ) . getComponentType ( ) , newSize ) ; if ( head < tail ) { System . arraycopy ( values , head , newArray , <int> , tail - head ) ; } else if ( size > <int> ) { final int rest = values . length - head ; System . arraycopy ( values , head , newArray , <int> , rest ) ; System . arraycopy ( values , <int> , newArray , rest , tail ) ; } this . values = newArray ; this . head = <int> ; this . tail = size ; } public T removeFirst ( ) { if ( size = = <int> ) { throw new NoSuchElementException ( <str> ) ; } final T [ ] values = this . values ; final T result = values [ head ] ; values [ head ] = null ; head + + ; if ( head = = values . length ) { head = <int> ; } size - - ; return result ; } public T removeLast ( ) { if ( size = = <int> ) { throw new NoSuchElementException ( <str> ) ; } final T [ ] values = this . values ; int tail = this . tail ; tail - - ; if ( tail = = - <int> ) { tail = values . length - <int> ; } final T result = values [ tail ] ; values [ tail ] = null ; this . tail = tail ; size - - ; return result ; } public int indexOf ( T value , boolean identity ) { if ( size = = <int> ) return - <int> ; T [ ] values = this . values ; int head = this . head , tail = this . tail ; if ( identity | | value = = null ) { if ( head < tail ) { for ( int i = head , n = tail ; i < n ; i + + ) if ( values [ i ] = = value ) return i ; } else { for ( int i = head , n = values . length ; i < n ; i + + ) if ( values [ i ] = = value ) return i - head ; for ( int i = <int> , n = tail ; i < n ; i + + ) if ( values [ i ] = = value ) return i + values . length - head ; } } else { if ( head < tail ) { for ( int i = head , n = tail ; i < n ; i + + ) if ( value . equals ( values [ i ] ) ) return i ; } else { for ( int i = head , n = values . length ; i < n ; i + + ) if ( value . equals ( values [ i ] ) ) return i - head ; for ( int i = <int> , n = tail ; i < n ; i + + ) if ( value . equals ( values [ i ] ) ) return i + values . length - head ; } } return - <int> ; } public boolean removeValue ( T value , boolean identity ) { int index = indexOf ( value , identity ) ; if ( index = = - <int> ) return false ; removeIndex ( index ) ; return true ; } public T removeIndex ( int index ) { if ( index < <int> ) throw new IndexOutOfBoundsException ( <str> + index ) ; if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; T [ ] values = this . values ; int head = this . head , tail = this . tail ; index + = head ; T value ; if ( head < tail ) { value = ( T ) values [ index ] ; System . arraycopy ( values , index + <int> , values , index , tail - index ) ; values [ tail ] = null ; this . tail - - ; } else if ( index > = values . length ) { index - = values . length ; value = ( T ) values [ index ] ; System . arraycopy ( values , index + <int> , values , index , tail - index ) ; this . tail - - ; } else { value = ( T ) values [ index ] ; System . arraycopy ( values , head , values , head + <int> , index - head ) ; values [ head ] = null ; this . head + + ; } size - - ; return value ; } public T first ( ) { if ( size = = <int> ) { throw new NoSuchElementException ( <str> ) ; } return values [ head ] ; } public T last ( ) { if ( size = = <int> ) { throw new NoSuchElementException ( <str> ) ; } final T [ ] values = this . values ; int tail = this . tail ; tail - - ; if ( tail = = - <int> ) { tail = values . length - <int> ; } return values [ tail ] ; } public T get ( int index ) { if ( index < <int> ) throw new IndexOutOfBoundsException ( <str> + index ) ; if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; final T [ ] values = this . values ; int i = head + index ; if ( i > = values . length ) { i - = values . length ; } return values [ i ] ; } public void clear ( ) { if ( size = = <int> ) return ; final T [ ] values = this . values ; final int head = this . head ; final int tail = this . tail ; if ( head < tail ) { for ( int i = head ; i < tail ; i + + ) { values [ i ] = null ; } } else { for ( int i = head ; i < values . length ; i + + ) { values [ i ] = null ; } for ( int i = <int> ; i < tail ; i + + ) { values [ i ] = null ; } } this . head = <int> ; this . tail = <int> ; this . size = <int> ; } public Iterator < T > iterator ( ) { if ( iterable = = null ) iterable = new QueueIterable ( this ) ; return iterable . iterator ( ) ; } public String toString ( ) { if ( size = = <int> ) { return <str> ; } final T [ ] values = this . values ; final int head = this . head ; final int tail = this . tail ; StringBuilder sb = new StringBuilder ( <int> ) ; sb . append ( <str> ) ; sb . append ( values [ head ] ) ; for ( int i = ( head + <int> ) % values . length ; i ! = tail ; i = ( i + <int> ) % values . length ) { sb . append ( <str> ) . append ( values [ i ] ) ; } sb . append ( <str> ) ; return sb . toString ( ) ; } public int hashCode ( ) { final int size = this . size ; final T [ ] values = this . values ; final int backingLength = values . length ; int index = this . head ; int hash = size + <int> ; for ( int s = <int> ; s < size ; s + + ) { final T value = values [ index ] ; hash * = <int> ; if ( value ! = null ) hash + = value . hashCode ( ) ; index + + ; if ( index = = backingLength ) index = <int> ; } return hash ; } public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | ! ( o instanceof Queue ) ) return false ; Queue < ? > q = ( Queue < ? > ) o ; final int size = this . size ; if ( q . size ! = size ) return false ; final T [ ] myValues = this . values ; final int myBackingLength = myValues . length ; final Object [ ] itsValues = q . values ; final int itsBackingLength = itsValues . length ; int myIndex = head ; int itsIndex = q . head ; for ( int s = <int> ; s < size ; s + + ) { T myValue = myValues [ myIndex ] ; Object itsValue = itsValues [ itsIndex ] ; if ( ! ( myValue = = null ? itsValue = = null : myValue . equals ( itsValue ) ) ) return false ; myIndex + + ; itsIndex + + ; if ( myIndex = = myBackingLength ) myIndex = <int> ; if ( itsIndex = = itsBackingLength ) itsIndex = <int> ; } return true ; } static public class QueueIterator < T > implements Iterator < T > , Iterable < T > { private final Queue < T > queue ; private final boolean allowRemove ; int index ; boolean valid = true ; public QueueIterator ( Queue < T > queue ) { this ( queue , true ) ; } public QueueIterator ( Queue < T > queue , boolean allowRemove ) { this . queue = queue ; this . allowRemove = allowRemove ; } public boolean hasNext ( ) { if ( ! valid ) { throw new GdxRuntimeException ( <str> ) ; } return index < queue . size ; } public T next ( ) { if ( index > = queue . size ) throw new NoSuchElementException ( String . valueOf ( index ) ) ; if ( ! valid ) { throw new GdxRuntimeException ( <str> ) ; } return queue . get ( index + + ) ; } public void remove ( ) { if ( ! allowRemove ) throw new GdxRuntimeException ( <str> ) ; index - - ; queue . removeIndex ( index ) ; } public void reset ( ) { index = <int> ; } public Iterator < T > iterator ( ) { return this ; } } static public class QueueIterable < T > implements Iterable < T > { private final Queue < T > queue ; private final boolean allowRemove ; private QueueIterator iterator1 , iterator2 ; public QueueIterable ( Queue < T > queue ) { this ( queue , true ) ; } public QueueIterable ( Queue < T > queue , boolean allowRemove ) { this . queue = queue ; this . allowRemove = allowRemove ; } public Iterator < T > iterator ( ) { if ( iterator1 = = null ) { iterator1 = new QueueIterator ( queue , allowRemove ) ; iterator2 = new QueueIterator ( queue , allowRemove ) ; } if ( ! iterator1 . valid ) { iterator1 . index = <int> ; iterator1 . valid = true ; iterator2 . valid = false ; return iterator1 ; } iterator2 . index = <int> ; iterator2 . valid = true ; iterator1 . valid = false ; return iterator2 ; } } } 
