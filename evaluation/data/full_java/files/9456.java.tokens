package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static java . lang . Double . MAX_EXPONENT ; import static java . lang . Double . MIN_EXPONENT ; import static java . lang . Double . POSITIVE_INFINITY ; import static java . lang . Double . doubleToRawLongBits ; import static java . lang . Double . isNaN ; import static java . lang . Double . longBitsToDouble ; import static java . lang . Math . getExponent ; import java . math . BigInteger ; final class DoubleUtils { private DoubleUtils ( ) { } static double nextDown ( double d ) { return - Math . nextUp ( - d ) ; } static final long SIGNIFICAND_MASK = <hex> ; static final long EXPONENT_MASK = <hex> ; static final long SIGN_MASK = <hex> ; static final int SIGNIFICAND_BITS = <int> ; static final int EXPONENT_BIAS = <int> ; static final long IMPLICIT_BIT = SIGNIFICAND_MASK + <int> ; static long getSignificand ( double d ) { checkArgument ( isFinite ( d ) , <str> ) ; int exponent = getExponent ( d ) ; long bits = doubleToRawLongBits ( d ) ; bits & = SIGNIFICAND_MASK ; return ( exponent = = MIN_EXPONENT - <int> ) ? bits < < <int> : bits | IMPLICIT_BIT ; } static boolean isFinite ( double d ) { return getExponent ( d ) < = MAX_EXPONENT ; } static boolean isNormal ( double d ) { return getExponent ( d ) > = MIN_EXPONENT ; } static double scaleNormalize ( double x ) { long significand = doubleToRawLongBits ( x ) & SIGNIFICAND_MASK ; return longBitsToDouble ( significand | ONE_BITS ) ; } static double bigToDouble ( BigInteger x ) { BigInteger absX = x . abs ( ) ; int exponent = absX . bitLength ( ) - <int> ; if ( exponent < Long . SIZE - <int> ) { return x . longValue ( ) ; } else if ( exponent > MAX_EXPONENT ) { return x . signum ( ) * POSITIVE_INFINITY ; } int shift = exponent - SIGNIFICAND_BITS - <int> ; long twiceSignifFloor = absX . shiftRight ( shift ) . longValue ( ) ; long signifFloor = twiceSignifFloor > > <int> ; signifFloor & = SIGNIFICAND_MASK ; boolean increment = ( twiceSignifFloor & <int> ) ! = <int> & & ( ( signifFloor & <int> ) ! = <int> | | absX . getLowestSetBit ( ) < shift ) ; long signifRounded = increment ? signifFloor + <int> : signifFloor ; long bits = ( long ) ( ( exponent + EXPONENT_BIAS ) ) < < SIGNIFICAND_BITS ; bits + = signifRounded ; bits | = x . signum ( ) & SIGN_MASK ; return longBitsToDouble ( bits ) ; } static double ensureNonNegative ( double value ) { checkArgument ( ! isNaN ( value ) ) ; if ( value > <float> ) { return value ; } else { return <float> ; } } private static final long ONE_BITS = doubleToRawLongBits ( <float> ) ; } 
