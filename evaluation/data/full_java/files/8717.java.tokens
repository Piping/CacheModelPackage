package org . elasticsearch . discovery . azure ; import com . microsoft . windowsazure . management . compute . models . * ; import org . elasticsearch . Version ; import org . elasticsearch . cloud . azure . AzureServiceDisableException ; import org . elasticsearch . cloud . azure . AzureServiceRemoteException ; import org . elasticsearch . cloud . azure . management . AzureComputeService ; import org . elasticsearch . cloud . azure . management . AzureComputeService . Discovery ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . network . NetworkAddress ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . zen . ping . unicast . UnicastHostsProvider ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . util . ArrayList ; import java . util . Locale ; import java . util . List ; public class AzureUnicastHostsProvider extends AbstractComponent implements UnicastHostsProvider { public enum HostType { PRIVATE_IP ( <str> ) , PUBLIC_IP ( <str> ) ; private String type ; HostType ( String type ) { this . type = type ; } public static HostType fromString ( String type ) { for ( HostType hostType : values ( ) ) { if ( hostType . type . equalsIgnoreCase ( type ) ) { return hostType ; } } return null ; } } public enum Deployment { PRODUCTION ( <str> , DeploymentSlot . Production ) , STAGING ( <str> , DeploymentSlot . Staging ) ; private String deployment ; private DeploymentSlot slot ; Deployment ( String deployment , DeploymentSlot slot ) { this . deployment = deployment ; this . slot = slot ; } public static Deployment fromString ( String string ) { for ( Deployment deployment : values ( ) ) { if ( deployment . deployment . equalsIgnoreCase ( string ) ) { return deployment ; } } return null ; } } private final AzureComputeService azureComputeService ; private TransportService transportService ; private NetworkService networkService ; private final Version version ; private final TimeValue refreshInterval ; private long lastRefresh ; private List < DiscoveryNode > cachedDiscoNodes ; private final HostType hostType ; private final String publicEndpointName ; private final String deploymentName ; private final DeploymentSlot deploymentSlot ; @Inject public AzureUnicastHostsProvider ( Settings settings , AzureComputeService azureComputeService , TransportService transportService , NetworkService networkService , Version version ) { super ( settings ) ; this . azureComputeService = azureComputeService ; this . transportService = transportService ; this . networkService = networkService ; this . version = version ; this . refreshInterval = settings . getAsTime ( Discovery . REFRESH , TimeValue . timeValueSeconds ( <int> ) ) ; String strHostType = settings . get ( Discovery . HOST_TYPE , HostType . PRIVATE_IP . name ( ) ) . toUpperCase ( Locale . ROOT ) ; HostType tmpHostType = HostType . fromString ( strHostType ) ; if ( tmpHostType = = null ) { logger . warn ( <str> , Discovery . HOST_TYPE , strHostType , HostType . PRIVATE_IP . name ( ) . toLowerCase ( Locale . ROOT ) ) ; tmpHostType = HostType . PRIVATE_IP ; } this . hostType = tmpHostType ; this . publicEndpointName = settings . get ( Discovery . ENDPOINT_NAME , <str> ) ; this . deploymentName = settings . get ( Discovery . DEPLOYMENT_NAME ) ; String strDeployment = settings . get ( Discovery . DEPLOYMENT_SLOT , Deployment . PRODUCTION . deployment ) ; Deployment tmpDeployment = Deployment . fromString ( strDeployment ) ; if ( tmpDeployment = = null ) { logger . warn ( <str> , Discovery . DEPLOYMENT_SLOT , strDeployment , Deployment . PRODUCTION . deployment ) ; tmpDeployment = Deployment . PRODUCTION ; } this . deploymentSlot = tmpDeployment . slot ; } @Override public List < DiscoveryNode > buildDynamicNodes ( ) { if ( refreshInterval . millis ( ) ! = <int> ) { if ( cachedDiscoNodes ! = null & & ( refreshInterval . millis ( ) < <int> | | ( System . currentTimeMillis ( ) - lastRefresh ) < refreshInterval . millis ( ) ) ) { logger . trace ( <str> ) ; return cachedDiscoNodes ; } lastRefresh = System . currentTimeMillis ( ) ; } logger . debug ( <str> ) ; cachedDiscoNodes = new ArrayList < > ( ) ; HostedServiceGetDetailedResponse detailed ; try { detailed = azureComputeService . getServiceDetails ( ) ; } catch ( AzureServiceDisableException e ) { logger . debug ( <str> ) ; return cachedDiscoNodes ; } catch ( AzureServiceRemoteException e ) { logger . warn ( <str> , e . getMessage ( ) ) ; logger . trace ( <str> , e ) ; return cachedDiscoNodes ; } InetAddress ipAddress = null ; try { ipAddress = networkService . resolvePublishHostAddresses ( null ) ; logger . trace ( <str> , ipAddress ) ; } catch ( IOException e ) { logger . trace ( <str> , e ) ; } for ( HostedServiceGetDetailedResponse . Deployment deployment : detailed . getDeployments ( ) ) { if ( deployment . getDeploymentSlot ( ) ! = deploymentSlot ) { logger . debug ( <str> , deployment . getDeploymentSlot ( ) , deployment . getName ( ) , deploymentSlot ) ; continue ; } if ( deploymentName ! = null & & ! deploymentName . equals ( deployment . getName ( ) ) ) { logger . debug ( <str> , deployment . getName ( ) , deploymentName ) ; continue ; } if ( deployment . getStatus ( ) ! = DeploymentStatus . Starting & & deployment . getStatus ( ) ! = DeploymentStatus . Deploying & & deployment . getStatus ( ) ! = DeploymentStatus . Running ) { logger . debug ( <str> , deployment . getName ( ) , deployment . getStatus ( ) ) ; continue ; } for ( RoleInstance instance : deployment . getRoleInstances ( ) ) { String networkAddress = null ; switch ( hostType ) { case PRIVATE_IP : InetAddress privateIp = instance . getIPAddress ( ) ; if ( privateIp ! = null ) { if ( privateIp . equals ( ipAddress ) ) { logger . trace ( <str> , NetworkAddress . format ( ipAddress ) ) ; } networkAddress = NetworkAddress . formatAddress ( privateIp ) ; } else { logger . trace ( <str> , instance . getInstanceName ( ) ) ; } break ; case PUBLIC_IP : for ( InstanceEndpoint endpoint : instance . getInstanceEndpoints ( ) ) { if ( ! publicEndpointName . equals ( endpoint . getName ( ) ) ) { logger . trace ( <str> , endpoint . getName ( ) , publicEndpointName ) ; continue ; } networkAddress = NetworkAddress . formatAddress ( new InetSocketAddress ( endpoint . getVirtualIPAddress ( ) , endpoint . getPort ( ) ) ) ; } if ( networkAddress = = null ) { logger . trace ( <str> , instance . getInstanceName ( ) ) ; } break ; default : logger . warn ( <str> , hostType ) ; return cachedDiscoNodes ; } if ( networkAddress = = null ) { logger . warn ( <str> , instance . getInstanceName ( ) ) ; continue ; } try { TransportAddress [ ] addresses = transportService . addressesFromString ( networkAddress , <int> ) ; for ( TransportAddress address : addresses ) { logger . trace ( <str> , networkAddress , address ) ; cachedDiscoNodes . add ( new DiscoveryNode ( <str> + instance . getInstanceName ( ) , address , version . minimumCompatibilityVersion ( ) ) ) ; } } catch ( Exception e ) { logger . warn ( <str> , networkAddress , e . getMessage ( ) ) ; } } } logger . debug ( <str> , cachedDiscoNodes . size ( ) ) ; return cachedDiscoNodes ; } } 
