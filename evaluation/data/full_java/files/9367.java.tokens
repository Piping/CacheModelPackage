package com . google . common . escape ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; @Beta @GwtCompatible public abstract class UnicodeEscaper extends Escaper { private static final int DEST_PAD = <int> ; protected UnicodeEscaper ( ) { } protected abstract char [ ] escape ( int cp ) ; protected int nextEscapeIndex ( CharSequence csq , int start , int end ) { int index = start ; while ( index < end ) { int cp = codePointAt ( csq , index , end ) ; if ( cp < <int> | | escape ( cp ) ! = null ) { break ; } index + = Character . isSupplementaryCodePoint ( cp ) ? <int> : <int> ; } return index ; } @Override public String escape ( String string ) { checkNotNull ( string ) ; int end = string . length ( ) ; int index = nextEscapeIndex ( string , <int> , end ) ; return index = = end ? string : escapeSlow ( string , index ) ; } protected final String escapeSlow ( String s , int index ) { int end = s . length ( ) ; char [ ] dest = Platform . charBufferFromThreadLocal ( ) ; int destIndex = <int> ; int unescapedChunkStart = <int> ; while ( index < end ) { int cp = codePointAt ( s , index , end ) ; if ( cp < <int> ) { throw new IllegalArgumentException ( <str> ) ; } char [ ] escaped = escape ( cp ) ; int nextIndex = index + ( Character . isSupplementaryCodePoint ( cp ) ? <int> : <int> ) ; if ( escaped ! = null ) { int charsSkipped = index - unescapedChunkStart ; int sizeNeeded = destIndex + charsSkipped + escaped . length ; if ( dest . length < sizeNeeded ) { int destLength = sizeNeeded + ( end - index ) + DEST_PAD ; dest = growBuffer ( dest , destIndex , destLength ) ; } if ( charsSkipped > <int> ) { s . getChars ( unescapedChunkStart , index , dest , destIndex ) ; destIndex + = charsSkipped ; } if ( escaped . length > <int> ) { System . arraycopy ( escaped , <int> , dest , destIndex , escaped . length ) ; destIndex + = escaped . length ; } unescapedChunkStart = nextIndex ; } index = nextEscapeIndex ( s , nextIndex , end ) ; } int charsSkipped = end - unescapedChunkStart ; if ( charsSkipped > <int> ) { int endIndex = destIndex + charsSkipped ; if ( dest . length < endIndex ) { dest = growBuffer ( dest , destIndex , endIndex ) ; } s . getChars ( unescapedChunkStart , end , dest , destIndex ) ; destIndex = endIndex ; } return new String ( dest , <int> , destIndex ) ; } protected static int codePointAt ( CharSequence seq , int index , int end ) { checkNotNull ( seq ) ; if ( index < end ) { char c1 = seq . charAt ( index + + ) ; if ( c1 < Character . MIN_HIGH_SURROGATE | | c1 > Character . MAX_LOW_SURROGATE ) { return c1 ; } else if ( c1 < = Character . MAX_HIGH_SURROGATE ) { if ( index = = end ) { return - c1 ; } char c2 = seq . charAt ( index ) ; if ( Character . isLowSurrogate ( c2 ) ) { return Character . toCodePoint ( c1 , c2 ) ; } throw new IllegalArgumentException ( <str> + c2 + <str> + ( int ) c2 + <str> + index + <str> + seq + <str> ) ; } else { throw new IllegalArgumentException ( <str> + c1 + <str> + ( int ) c1 + <str> + ( index - <int> ) + <str> + seq + <str> ) ; } } throw new IndexOutOfBoundsException ( <str> ) ; } private static char [ ] growBuffer ( char [ ] dest , int index , int size ) { char [ ] copy = new char [ size ] ; if ( index > <int> ) { System . arraycopy ( dest , <int> , copy , <int> , index ) ; } return copy ; } } 
