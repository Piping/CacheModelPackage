package org . elasticsearch . common . util ; import org . apache . lucene . index . CheckIndex ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . store . Directory ; import org . apache . lucene . store . Lock ; import org . apache . lucene . store . LockObtainFailedException ; import org . apache . lucene . store . SimpleFSDirectory ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . io . FileSystemUtils ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . env . ShardLock ; import org . elasticsearch . gateway . MetaDataStateFormat ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . shard . ShardPath ; import org . elasticsearch . index . shard . ShardStateMetaData ; import java . io . IOException ; import java . io . PrintStream ; import java . nio . charset . StandardCharsets ; import java . nio . file . * ; import java . nio . file . attribute . BasicFileAttributes ; import java . util . * ; public class MultiDataPathUpgrader { private final NodeEnvironment nodeEnvironment ; private final ESLogger logger = Loggers . getLogger ( getClass ( ) ) ; public MultiDataPathUpgrader ( NodeEnvironment nodeEnvironment ) { this . nodeEnvironment = nodeEnvironment ; } public void upgrade ( ShardId shard , ShardPath targetPath ) throws IOException { final Path [ ] paths = nodeEnvironment . availableShardPaths ( shard ) ; if ( isTargetPathConfigured ( paths , targetPath ) = = false ) { throw new IllegalArgumentException ( <str> ) ; } assert needsUpgrading ( shard ) : <str> ; logger . info ( <str> , shard , targetPath . getDataPath ( ) ) ; final ShardStateMetaData loaded = ShardStateMetaData . FORMAT . loadLatestState ( logger , paths ) ; if ( loaded = = null ) { throw new IllegalStateException ( shard + <str> + Arrays . toString ( paths ) + <str> ) ; } logger . info ( <str> , shard , loaded ) ; ShardStateMetaData . FORMAT . write ( loaded , loaded . version , targetPath . getShardStatePath ( ) ) ; Files . createDirectories ( targetPath . resolveIndex ( ) ) ; try ( SimpleFSDirectory directory = new SimpleFSDirectory ( targetPath . resolveIndex ( ) ) ) { try ( final Lock lock = directory . obtainLock ( IndexWriter . WRITE_LOCK_NAME ) ) { upgradeFiles ( shard , targetPath , targetPath . resolveIndex ( ) , ShardPath . INDEX_FOLDER_NAME , paths ) ; } catch ( LockObtainFailedException ex ) { throw new IllegalStateException ( <str> + targetPath . resolveIndex ( ) , ex ) ; } } upgradeFiles ( shard , targetPath , targetPath . resolveTranslog ( ) , ShardPath . TRANSLOG_FOLDER_NAME , paths ) ; logger . info ( <str> , shard ) ; for ( Path path : paths ) { if ( path . equals ( targetPath . getShardStatePath ( ) ) = = false ) { logger . info ( <str> , shard , path ) ; IOUtils . rm ( path ) ; } } if ( FileSystemUtils . files ( targetPath . resolveIndex ( ) ) . length = = <int> ) { throw new IllegalStateException ( <str> + targetPath . resolveIndex ( ) + <str> ) ; } if ( FileSystemUtils . files ( targetPath . resolveTranslog ( ) ) . length = = <int> ) { throw new IllegalStateException ( <str> + targetPath . resolveTranslog ( ) + <str> ) ; } } public void checkIndex ( ShardPath targetPath ) throws IOException { BytesStreamOutput os = new BytesStreamOutput ( ) ; PrintStream out = new PrintStream ( os , false , StandardCharsets . UTF_8 . name ( ) ) ; try ( Directory directory = new SimpleFSDirectory ( targetPath . resolveIndex ( ) ) ; final CheckIndex checkIndex = new CheckIndex ( directory ) ) { checkIndex . setInfoStream ( out ) ; CheckIndex . Status status = checkIndex . checkIndex ( ) ; out . flush ( ) ; if ( ! status . clean ) { logger . warn ( <str> , new String ( os . bytes ( ) . toBytes ( ) , StandardCharsets . UTF_8 ) ) ; throw new IllegalStateException ( <str> ) ; } } } public boolean needsUpgrading ( ShardId shard ) { final Path [ ] paths = nodeEnvironment . availableShardPaths ( shard ) ; if ( paths . length > <int> ) { int numPathsExist = <int> ; for ( Path path : paths ) { if ( Files . exists ( path . resolve ( MetaDataStateFormat . STATE_DIR_NAME ) ) ) { numPathsExist + + ; if ( numPathsExist > <int> ) { return true ; } } } } return false ; } public ShardPath pickShardPath ( ShardId shard ) throws IOException { if ( needsUpgrading ( shard ) = = false ) { throw new IllegalStateException ( <str> ) ; } final NodeEnvironment . NodePath [ ] paths = nodeEnvironment . nodePaths ( ) ; for ( NodeEnvironment . NodePath path : paths ) { Files . createDirectories ( path . resolve ( shard ) ) ; } final ShardFileInfo [ ] shardFileInfo = getShardFileInfo ( shard , paths ) ; long totalBytesUsedByShard = <int> ; long leastUsableSpace = Long . MAX_VALUE ; long mostUsableSpace = Long . MIN_VALUE ; assert shardFileInfo . length = = nodeEnvironment . availableShardPaths ( shard ) . length ; for ( ShardFileInfo info : shardFileInfo ) { totalBytesUsedByShard + = info . spaceUsedByShard ; leastUsableSpace = Math . min ( leastUsableSpace , info . usableSpace + info . spaceUsedByShard ) ; mostUsableSpace = Math . max ( mostUsableSpace , info . usableSpace + info . spaceUsedByShard ) ; } if ( mostUsableSpace < totalBytesUsedByShard ) { throw new IllegalStateException ( <str> + new ByteSizeValue ( mostUsableSpace ) + <str> + new ByteSizeValue ( totalBytesUsedByShard ) ) ; } ShardFileInfo target = shardFileInfo [ <int> ] ; if ( leastUsableSpace > = ( <int> * totalBytesUsedByShard ) ) { for ( ShardFileInfo info : shardFileInfo ) { if ( info . spaceUsedByShard > target . spaceUsedByShard ) { target = info ; } } } else { for ( ShardFileInfo info : shardFileInfo ) { if ( info . usableSpace > target . usableSpace ) { target = info ; } } } return new ShardPath ( false , target . path , target . path , IndexMetaData . INDEX_UUID_NA_VALUE , shard ) ; } private ShardFileInfo [ ] getShardFileInfo ( ShardId shard , NodeEnvironment . NodePath [ ] paths ) throws IOException { final ShardFileInfo [ ] info = new ShardFileInfo [ paths . length ] ; for ( int i = <int> ; i < info . length ; i + + ) { Path path = paths [ i ] . resolve ( shard ) ; final long usabelSpace = getUsabelSpace ( paths [ i ] ) ; info [ i ] = new ShardFileInfo ( path , usabelSpace , getSpaceUsedByShard ( path ) ) ; } return info ; } protected long getSpaceUsedByShard ( Path path ) throws IOException { final long [ ] spaceUsedByShard = new long [ ] { <int> } ; if ( Files . exists ( path ) ) { Files . walkFileTree ( path , new FileVisitor < Path > ( ) { @Override public FileVisitResult preVisitDirectory ( Path dir , BasicFileAttributes attrs ) throws IOException { return FileVisitResult . CONTINUE ; } @Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( attrs . isRegularFile ( ) ) { spaceUsedByShard [ <int> ] + = attrs . size ( ) ; } return FileVisitResult . CONTINUE ; } @Override public FileVisitResult visitFileFailed ( Path file , IOException exc ) throws IOException { return FileVisitResult . CONTINUE ; } @Override public FileVisitResult postVisitDirectory ( Path dir , IOException exc ) throws IOException { return FileVisitResult . CONTINUE ; } } ) ; } return spaceUsedByShard [ <int> ] ; } protected long getUsabelSpace ( NodeEnvironment . NodePath path ) throws IOException { FileStore fileStore = path . fileStore ; return fileStore . getUsableSpace ( ) ; } static class ShardFileInfo { final Path path ; final long usableSpace ; final long spaceUsedByShard ; ShardFileInfo ( Path path , long usableSpace , long spaceUsedByShard ) { this . path = path ; this . usableSpace = usableSpace ; this . spaceUsedByShard = spaceUsedByShard ; } } private void upgradeFiles ( ShardId shard , ShardPath targetPath , final Path targetDir , String folderName , Path [ ] paths ) throws IOException { List < Path > movedFiles = new ArrayList < > ( ) ; for ( Path path : paths ) { if ( path . equals ( targetPath . getDataPath ( ) ) = = false ) { final Path sourceDir = path . resolve ( folderName ) ; if ( Files . exists ( sourceDir ) ) { logger . info ( <str> , shard , folderName , sourceDir , targetDir ) ; try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( sourceDir ) ) { Files . createDirectories ( targetDir ) ; for ( Path file : stream ) { if ( IndexWriter . WRITE_LOCK_NAME . equals ( file . getFileName ( ) . toString ( ) ) | | Files . isDirectory ( file ) ) { continue ; } logger . info ( <str> , shard , file . getFileName ( ) , Files . size ( file ) ) ; final Path targetFile = targetDir . resolve ( file . getFileName ( ) ) ; final Path targetTempFile = Files . createTempFile ( targetDir , <str> , <str> + file . getFileName ( ) . toString ( ) ) ; Files . copy ( file , targetTempFile , StandardCopyOption . COPY_ATTRIBUTES , StandardCopyOption . REPLACE_EXISTING ) ; Files . move ( targetTempFile , targetFile , StandardCopyOption . ATOMIC_MOVE ) ; Files . delete ( file ) ; movedFiles . add ( targetFile ) ; } } } } } if ( movedFiles . isEmpty ( ) = = false ) { logger . info ( <str> , shard ) ; for ( Path moved : movedFiles ) { logger . info ( <str> , shard , moved . getFileName ( ) ) ; IOUtils . fsync ( moved , false ) ; } logger . info ( <str> , shard , targetDir ) ; IOUtils . fsync ( targetDir , true ) ; } } private boolean isTargetPathConfigured ( final Path [ ] paths , ShardPath targetPath ) { for ( Path path : paths ) { if ( path . equals ( targetPath . getDataPath ( ) ) ) { return true ; } } return false ; } public static void upgradeMultiDataPath ( NodeEnvironment nodeEnv , ESLogger logger ) throws IOException { if ( nodeEnv . nodeDataPaths ( ) . length > <int> ) { final MultiDataPathUpgrader upgrader = new MultiDataPathUpgrader ( nodeEnv ) ; final Set < String > allIndices = nodeEnv . findAllIndices ( ) ; for ( String index : allIndices ) { for ( ShardId shardId : findAllShardIds ( nodeEnv . indexPaths ( new Index ( index ) ) ) ) { try ( ShardLock lock = nodeEnv . shardLock ( shardId , <int> ) ) { if ( upgrader . needsUpgrading ( shardId ) ) { final ShardPath shardPath = upgrader . pickShardPath ( shardId ) ; upgrader . upgrade ( shardId , shardPath ) ; if ( Files . exists ( shardPath . resolveIndex ( ) ) ) { upgrader . checkIndex ( shardPath ) ; } } else { logger . debug ( <str> ) ; } } } } } } private static Set < ShardId > findAllShardIds ( Path . . . locations ) throws IOException { final Set < ShardId > shardIds = new HashSet < > ( ) ; for ( final Path location : locations ) { if ( Files . isDirectory ( location ) ) { shardIds . addAll ( findAllShardsForIndex ( location ) ) ; } } return shardIds ; } private static Set < ShardId > findAllShardsForIndex ( Path indexPath ) throws IOException { Set < ShardId > shardIds = new HashSet < > ( ) ; if ( Files . isDirectory ( indexPath ) ) { try ( DirectoryStream < Path > stream = Files . newDirectoryStream ( indexPath ) ) { String currentIndex = indexPath . getFileName ( ) . toString ( ) ; for ( Path shardPath : stream ) { String fileName = shardPath . getFileName ( ) . toString ( ) ; if ( Files . isDirectory ( shardPath ) & & fileName . chars ( ) . allMatch ( Character : : isDigit ) ) { int shardId = Integer . parseInt ( fileName ) ; ShardId id = new ShardId ( currentIndex , shardId ) ; shardIds . add ( id ) ; } } } } return shardIds ; } } 
