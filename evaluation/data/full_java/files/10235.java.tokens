package com . google . common . util . concurrent ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . caliper . api . VmOptions ; import com . google . common . util . concurrent . AbstractFutureBenchmarks . Facade ; import com . google . common . util . concurrent . AbstractFutureBenchmarks . Impl ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; @VmOptions ( { <str> , <str> } ) public class SingleThreadAbstractFutureBenchmark { @Param Impl impl ; private final Exception exception = new Exception ( ) ; private Facade < ? > notDoneFuture ; @BeforeExperiment void setUp ( ) throws Exception { notDoneFuture = impl . newFacade ( ) ; } @Benchmark public long timeComplete_Normal ( int reps ) throws Exception { long r = <int> ; List < Facade < Integer > > list = new ArrayList < Facade < Integer > > ( reps ) ; for ( int i = <int> ; i < reps ; i + + ) { final Facade < Integer > localFuture = impl . newFacade ( ) ; list . add ( localFuture ) ; localFuture . set ( i ) ; } for ( int i = <int> ; i < reps ; i + + ) { r + = list . get ( i ) . get ( ) ; } return r ; } @Benchmark public long timeComplete_Failure ( int reps ) throws Exception { long r = <int> ; List < Facade < Integer > > list = new ArrayList < Facade < Integer > > ( reps ) ; for ( int i = <int> ; i < reps ; i + + ) { final Facade < Integer > localFuture = impl . newFacade ( ) ; list . add ( localFuture ) ; localFuture . setException ( exception ) ; } for ( int i = <int> ; i < reps ; i + + ) { Facade < Integer > facade = list . get ( i ) ; try { facade . get ( ) ; r + + ; } catch ( ExecutionException e ) { r + = <int> ; } } return r ; } @Benchmark public long timeComplete_Cancel ( int reps ) throws Exception { long r = <int> ; List < Facade < Integer > > list = new ArrayList < Facade < Integer > > ( reps ) ; for ( int i = <int> ; i < reps ; i + + ) { final Facade < Integer > localFuture = impl . newFacade ( ) ; list . add ( localFuture ) ; localFuture . cancel ( false ) ; } for ( int i = <int> ; i < reps ; i + + ) { Facade < Integer > facade = list . get ( i ) ; try { facade . get ( ) ; r + + ; } catch ( CancellationException e ) { r + = <int> ; } } return r ; } @Benchmark public long timeGetWith0Timeout ( long reps ) throws Exception { Facade < ? > f = notDoneFuture ; long r = <int> ; for ( int i = <int> ; i < reps ; i + + ) { try { f . get ( <int> , TimeUnit . SECONDS ) ; r + = <int> ; } catch ( TimeoutException e ) { r + = <int> ; } } return r ; } @Benchmark public long timeGetWithSmallTimeout ( long reps ) throws Exception { Facade < ? > f = notDoneFuture ; long r = <int> ; for ( int i = <int> ; i < reps ; i + + ) { try { f . get ( <int> , TimeUnit . NANOSECONDS ) ; r + = <int> ; } catch ( TimeoutException e ) { r + = <int> ; } } return r ; } } 
