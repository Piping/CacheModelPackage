package com . google . common . hash ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import com . google . common . annotations . Beta ; import com . google . common . base . Preconditions ; import com . google . common . primitives . Ints ; import com . google . common . primitives . UnsignedInts ; import java . io . Serializable ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @Beta public abstract class HashCode { HashCode ( ) { } @CheckReturnValue public abstract int bits ( ) ; @CheckReturnValue public abstract int asInt ( ) ; @CheckReturnValue public abstract long asLong ( ) ; @CheckReturnValue public abstract long padToLong ( ) ; @CheckReturnValue public abstract byte [ ] asBytes ( ) ; public int writeBytesTo ( byte [ ] dest , int offset , int maxLength ) { maxLength = Ints . min ( maxLength , bits ( ) / <int> ) ; Preconditions . checkPositionIndexes ( offset , offset + maxLength , dest . length ) ; writeBytesToImpl ( dest , offset , maxLength ) ; return maxLength ; } abstract void writeBytesToImpl ( byte [ ] dest , int offset , int maxLength ) ; byte [ ] getBytesInternal ( ) { return asBytes ( ) ; } abstract boolean equalsSameBits ( HashCode that ) ; @CheckReturnValue public static HashCode fromInt ( int hash ) { return new IntHashCode ( hash ) ; } private static final class IntHashCode extends HashCode implements Serializable { final int hash ; IntHashCode ( int hash ) { this . hash = hash ; } @Override public int bits ( ) { return <int> ; } @Override public byte [ ] asBytes ( ) { return new byte [ ] { ( byte ) hash , ( byte ) ( hash > > <int> ) , ( byte ) ( hash > > <int> ) , ( byte ) ( hash > > <int> ) } ; } @Override public int asInt ( ) { return hash ; } @Override public long asLong ( ) { throw new IllegalStateException ( <str> ) ; } @Override public long padToLong ( ) { return UnsignedInts . toLong ( hash ) ; } @Override void writeBytesToImpl ( byte [ ] dest , int offset , int maxLength ) { for ( int i = <int> ; i < maxLength ; i + + ) { dest [ offset + i ] = ( byte ) ( hash > > ( i * <int> ) ) ; } } @Override boolean equalsSameBits ( HashCode that ) { return hash = = that . asInt ( ) ; } private static final long serialVersionUID = <int> ; } @CheckReturnValue public static HashCode fromLong ( long hash ) { return new LongHashCode ( hash ) ; } private static final class LongHashCode extends HashCode implements Serializable { final long hash ; LongHashCode ( long hash ) { this . hash = hash ; } @Override public int bits ( ) { return <int> ; } @Override public byte [ ] asBytes ( ) { return new byte [ ] { ( byte ) hash , ( byte ) ( hash > > <int> ) , ( byte ) ( hash > > <int> ) , ( byte ) ( hash > > <int> ) , ( byte ) ( hash > > <int> ) , ( byte ) ( hash > > <int> ) , ( byte ) ( hash > > <int> ) , ( byte ) ( hash > > <int> ) } ; } @Override public int asInt ( ) { return ( int ) hash ; } @Override public long asLong ( ) { return hash ; } @Override public long padToLong ( ) { return hash ; } @Override void writeBytesToImpl ( byte [ ] dest , int offset , int maxLength ) { for ( int i = <int> ; i < maxLength ; i + + ) { dest [ offset + i ] = ( byte ) ( hash > > ( i * <int> ) ) ; } } @Override boolean equalsSameBits ( HashCode that ) { return hash = = that . asLong ( ) ; } private static final long serialVersionUID = <int> ; } @CheckReturnValue public static HashCode fromBytes ( byte [ ] bytes ) { checkArgument ( bytes . length > = <int> , <str> ) ; return fromBytesNoCopy ( bytes . clone ( ) ) ; } static HashCode fromBytesNoCopy ( byte [ ] bytes ) { return new BytesHashCode ( bytes ) ; } private static final class BytesHashCode extends HashCode implements Serializable { final byte [ ] bytes ; BytesHashCode ( byte [ ] bytes ) { this . bytes = checkNotNull ( bytes ) ; } @Override public int bits ( ) { return bytes . length * <int> ; } @Override public byte [ ] asBytes ( ) { return bytes . clone ( ) ; } @Override public int asInt ( ) { checkState ( bytes . length > = <int> , <str> , bytes . length ) ; return ( bytes [ <int> ] & <hex> ) | ( ( bytes [ <int> ] & <hex> ) < < <int> ) | ( ( bytes [ <int> ] & <hex> ) < < <int> ) | ( ( bytes [ <int> ] & <hex> ) < < <int> ) ; } @Override public long asLong ( ) { checkState ( bytes . length > = <int> , <str> , bytes . length ) ; return padToLong ( ) ; } @Override public long padToLong ( ) { long retVal = ( bytes [ <int> ] & <hex> ) ; for ( int i = <int> ; i < Math . min ( bytes . length , <int> ) ; i + + ) { retVal | = ( bytes [ i ] & <hex> ) < < ( i * <int> ) ; } return retVal ; } @Override void writeBytesToImpl ( byte [ ] dest , int offset , int maxLength ) { System . arraycopy ( bytes , <int> , dest , offset , maxLength ) ; } @Override byte [ ] getBytesInternal ( ) { return bytes ; } @Override boolean equalsSameBits ( HashCode that ) { if ( this . bytes . length ! = that . getBytesInternal ( ) . length ) { return false ; } boolean areEqual = true ; for ( int i = <int> ; i < this . bytes . length ; i + + ) { areEqual & = ( this . bytes [ i ] = = that . getBytesInternal ( ) [ i ] ) ; } return areEqual ; } private static final long serialVersionUID = <int> ; } @CheckReturnValue public static HashCode fromString ( String string ) { checkArgument ( string . length ( ) > = <int> , <str> , string ) ; checkArgument ( string . length ( ) % <int> = = <int> , <str> , string ) ; byte [ ] bytes = new byte [ string . length ( ) / <int> ] ; for ( int i = <int> ; i < string . length ( ) ; i + = <int> ) { int ch1 = decode ( string . charAt ( i ) ) < < <int> ; int ch2 = decode ( string . charAt ( i + <int> ) ) ; bytes [ i / <int> ] = ( byte ) ( ch1 + ch2 ) ; } return fromBytesNoCopy ( bytes ) ; } private static int decode ( char ch ) { if ( ch > = <str> & & ch < = <str> ) { return ch - <str> ; } if ( ch > = <str> & & ch < = <str> ) { return ch - <str> + <int> ; } throw new IllegalArgumentException ( <str> + ch ) ; } @Override public final boolean equals ( @Nullable Object object ) { if ( object instanceof HashCode ) { HashCode that = ( HashCode ) object ; return bits ( ) = = that . bits ( ) & & equalsSameBits ( that ) ; } return false ; } @Override public final int hashCode ( ) { if ( bits ( ) > = <int> ) { return asInt ( ) ; } byte [ ] bytes = getBytesInternal ( ) ; int val = ( bytes [ <int> ] & <hex> ) ; for ( int i = <int> ; i < bytes . length ; i + + ) { val | = ( ( bytes [ i ] & <hex> ) < < ( i * <int> ) ) ; } return val ; } @Override public final String toString ( ) { byte [ ] bytes = getBytesInternal ( ) ; StringBuilder sb = new StringBuilder ( <int> * bytes . length ) ; for ( byte b : bytes ) { sb . append ( hexDigits [ ( b > > <int> ) & <hex> ] ) . append ( hexDigits [ b & <hex> ] ) ; } return sb . toString ( ) ; } private static final char [ ] hexDigits = <str> . toCharArray ( ) ; } 
