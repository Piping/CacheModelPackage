package org . apache . cassandra . utils ; import java . io . IOException ; import java . io . RandomAccessFile ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . util . StringTokenizer ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import org . apache . cassandra . concurrent . DebuggableScheduledThreadPoolExecutor ; import org . apache . cassandra . gms . ApplicationState ; import org . apache . cassandra . gms . EndpointState ; import org . apache . cassandra . gms . Gossiper ; import org . apache . cassandra . gms . VersionedValue ; import org . apache . cassandra . service . StorageService ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import com . google . common . util . concurrent . AtomicDouble ; public class BackgroundActivityMonitor { private static final Logger logger = LoggerFactory . getLogger ( BackgroundActivityMonitor . class ) ; public static final int USER_INDEX = <int> ; public static final int NICE_INDEX = <int> ; public static final int SYS_INDEX = <int> ; public static final int IDLE_INDEX = <int> ; public static final int IOWAIT_INDEX = <int> ; public static final int IRQ_INDEX = <int> ; public static final int SOFTIRQ_INDEX = <int> ; private static final int NUM_CPUS = Runtime . getRuntime ( ) . availableProcessors ( ) ; private static final String PROC_STAT_PATH = <str> ; private final AtomicDouble compaction_severity = new AtomicDouble ( ) ; private final AtomicDouble manual_severity = new AtomicDouble ( ) ; private final ScheduledExecutorService reportThread = new DebuggableScheduledThreadPoolExecutor ( <str> ) ; private RandomAccessFile statsFile ; private long [ ] lastReading ; public BackgroundActivityMonitor ( ) { try { statsFile = new RandomAccessFile ( PROC_STAT_PATH , <str> ) ; lastReading = readAndCompute ( ) ; } catch ( IOException ex ) { if ( FBUtilities . hasProcFS ( ) ) logger . warn ( <str> ) ; statsFile = null ; } reportThread . scheduleAtFixedRate ( new BackgroundActivityReporter ( ) , <int> , <int> , TimeUnit . SECONDS ) ; } private long [ ] readAndCompute ( ) throws IOException { statsFile . seek ( <int> ) ; StringTokenizer tokenizer = new StringTokenizer ( statsFile . readLine ( ) ) ; String name = tokenizer . nextToken ( ) ; assert name . equalsIgnoreCase ( <str> ) ; long [ ] returned = new long [ tokenizer . countTokens ( ) ] ; for ( int i = <int> ; i < returned . length ; i + + ) returned [ i ] = Long . parseLong ( tokenizer . nextToken ( ) ) ; return returned ; } private float compareAtIndex ( long [ ] reading1 , long [ ] reading2 , int index ) { long total1 = <int> , total2 = <int> ; for ( int i = <int> ; i < = SOFTIRQ_INDEX ; i + + ) { total1 + = reading1 [ i ] ; total2 + = reading2 [ i ] ; } float totalDiff = total2 - total1 ; long intrested1 = reading1 [ index ] , intrested2 = reading2 [ index ] ; float diff = intrested2 - intrested1 ; if ( diff = = <int> ) return <float> ; return ( diff / totalDiff ) * <int> ; } public void incrCompactionSeverity ( double sev ) { compaction_severity . addAndGet ( sev ) ; } public void incrManualSeverity ( double sev ) { manual_severity . addAndGet ( sev ) ; } public double getIOWait ( ) throws IOException { if ( statsFile = = null ) return - <float> ; long [ ] newComp = readAndCompute ( ) ; double value = compareAtIndex ( lastReading , newComp , IOWAIT_INDEX ) ; lastReading = newComp ; return value ; } public double getNormalizedLoadAvg ( ) { double avg = ManagementFactory . getOperatingSystemMXBean ( ) . getSystemLoadAverage ( ) ; return avg / NUM_CPUS ; } public double getSeverity ( InetAddress endpoint ) { VersionedValue event ; EndpointState state = Gossiper . instance . getEndpointStateForEndpoint ( endpoint ) ; if ( state ! = null & & ( event = state . getApplicationState ( ApplicationState . SEVERITY ) ) ! = null ) return Double . parseDouble ( event . value ) ; return <float> ; } public class BackgroundActivityReporter implements Runnable { public void run ( ) { double report = - <int> ; try { report = getIOWait ( ) ; } catch ( IOException e ) { if ( FBUtilities . hasProcFS ( ) ) logger . warn ( <str> ) ; } if ( report = = - <float> ) report = compaction_severity . get ( ) ; if ( ! Gossiper . instance . isEnabled ( ) ) return ; report + = manual_severity . get ( ) ; VersionedValue updated = StorageService . instance . valueFactory . severity ( report ) ; Gossiper . instance . addLocalApplicationState ( ApplicationState . SEVERITY , updated ) ; } } } 
