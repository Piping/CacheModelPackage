package org . apache . cassandra . dht ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . Random ; import org . junit . Before ; import org . junit . Test ; import org . apache . cassandra . service . StorageService ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; public abstract class PartitionerTestCase { protected IPartitioner partitioner ; public abstract void initPartitioner ( ) ; @Before public void clean ( ) { initPartitioner ( ) ; } public Token tok ( byte [ ] key ) { return partitioner . getToken ( ByteBuffer . wrap ( key ) ) ; } public Token tok ( String key ) { return tok ( key . getBytes ( ) ) ; } public void assertMidpoint ( Token left , Token right , int depth ) { Random rand = new Random ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertMidpoint ( left , right , rand , depth ) ; } } private void assertMidpoint ( Token left , Token right , Random rand , int depth ) { Token mid = partitioner . midpoint ( left , right ) ; assert new Range < Token > ( left , right ) . contains ( mid ) : <str> + left + <str> + right + <str> + mid ; if ( depth < <int> ) return ; if ( rand . nextBoolean ( ) ) assertMidpoint ( left , mid , rand , depth - <int> ) ; else assertMidpoint ( mid , right , rand , depth - <int> ) ; } @Test public void testMidpoint ( ) { assertMidpoint ( tok ( <str> ) , tok ( <str> ) , <int> ) ; assertMidpoint ( tok ( <str> ) , tok ( <str> ) , <int> ) ; } @Test public void testMidpointMinimum ( ) { midpointMinimumTestCase ( ) ; } protected void midpointMinimumTestCase ( ) { Token mintoken = partitioner . getMinimumToken ( ) ; assert mintoken . compareTo ( partitioner . midpoint ( mintoken , mintoken ) ) ! = <int> ; assertMidpoint ( mintoken , tok ( <str> ) , <int> ) ; assertMidpoint ( mintoken , tok ( <str> ) , <int> ) ; assertMidpoint ( mintoken , mintoken , <int> ) ; assertMidpoint ( tok ( <str> ) , mintoken , <int> ) ; } @Test public void testMidpointWrapping ( ) { assertMidpoint ( tok ( <str> ) , tok ( <str> ) , <int> ) ; assertMidpoint ( tok ( <str> ) , tok ( <str> ) , <int> ) ; } @Test public void testTokenFactoryBytes ( ) { Token . TokenFactory factory = partitioner . getTokenFactory ( ) ; assert tok ( <str> ) . compareTo ( factory . fromByteArray ( factory . toByteArray ( tok ( <str> ) ) ) ) = = <int> ; } @Test public void testTokenFactoryStrings ( ) { Token . TokenFactory factory = partitioner . getTokenFactory ( ) ; assert tok ( <str> ) . compareTo ( factory . fromString ( factory . toString ( tok ( <str> ) ) ) ) = = <int> ; } @Test public void testDescribeOwnership ( ) { StorageService . instance . getKeyspaces ( ) ; try { testDescribeOwnershipWith ( <int> ) ; fail ( ) ; } catch ( RuntimeException e ) { } testDescribeOwnershipWith ( <int> ) ; testDescribeOwnershipWith ( <int> ) ; testDescribeOwnershipWith ( <int> ) ; } private void testDescribeOwnershipWith ( int numTokens ) { List < Token > tokens = new ArrayList < Token > ( ) ; while ( tokens . size ( ) < numTokens ) { Token randomToken = partitioner . getRandomToken ( ) ; if ( ! tokens . contains ( randomToken ) ) tokens . add ( randomToken ) ; } Collections . sort ( tokens ) ; Map < Token , Float > owns = partitioner . describeOwnership ( tokens ) ; float totalOwnership = <int> ; for ( float ownership : owns . values ( ) ) totalOwnership + = ownership ; assertEquals ( <float> , totalOwnership , <float> ) ; } } 
