package org . elasticsearch . index . query ; import com . carrotsearch . randomizedtesting . generators . CodepointSetGenerator ; import com . fasterxml . jackson . core . JsonParseException ; import com . fasterxml . jackson . core . io . JsonStringEncoder ; import org . apache . lucene . search . BoostQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . search . spans . SpanBoostQuery ; import org . apache . lucene . util . Accountable ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . mapping . put . PutMappingRequest ; import org . elasticsearch . action . get . GetRequest ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . action . support . PlainActionFuture ; import org . elasticsearch . action . termvectors . MultiTermVectorsRequest ; import org . elasticsearch . action . termvectors . MultiTermVectorsResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . inject . AbstractModule ; import org . elasticsearch . common . inject . Injector ; import org . elasticsearch . common . inject . ModulesBuilder ; import org . elasticsearch . common . inject . multibindings . Multibinder ; import org . elasticsearch . common . inject . util . Providers ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . NamedWriteableAwareStreamInput ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . SettingsFilter ; import org . elasticsearch . common . settings . SettingsModule ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . EnvironmentModule ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . analysis . AnalysisRegistry ; import org . elasticsearch . index . analysis . AnalysisService ; import org . elasticsearch . index . cache . bitset . BitsetFilterCache ; import org . elasticsearch . index . fielddata . IndexFieldDataService ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . query . functionscore . ScoreFunctionParser ; import org . elasticsearch . index . query . functionscore . ScoreFunctionParserMapper ; import org . elasticsearch . index . query . support . QueryParsers ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . similarity . SimilarityService ; import org . elasticsearch . indices . IndicesModule ; import org . elasticsearch . indices . IndicesWarmer ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import org . elasticsearch . indices . breaker . NoneCircuitBreakerService ; import org . elasticsearch . indices . fielddata . cache . IndicesFieldDataCache ; import org . elasticsearch . indices . mapper . MapperRegistry ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . script . * ; import org . elasticsearch . script . Script . ScriptParseException ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import org . elasticsearch . test . TestSearchContext ; import org . elasticsearch . test . VersionUtils ; import org . elasticsearch . test . cluster . TestClusterService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . threadpool . ThreadPoolModule ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import org . junit . After ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import java . io . IOException ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . util . * ; import java . util . concurrent . ExecutionException ; import static org . hamcrest . Matchers . * ; public abstract class AbstractQueryTestCase < QB extends AbstractQueryBuilder < QB > > extends ESTestCase { private static final GeohashGenerator geohashGenerator = new GeohashGenerator ( ) ; protected static final String STRING_FIELD_NAME = <str> ; protected static final String STRING_FIELD_NAME_2 = <str> ; protected static final String INT_FIELD_NAME = <str> ; protected static final String DOUBLE_FIELD_NAME = <str> ; protected static final String BOOLEAN_FIELD_NAME = <str> ; protected static final String DATE_FIELD_NAME = <str> ; protected static final String OBJECT_FIELD_NAME = <str> ; protected static final String GEO_POINT_FIELD_NAME = <str> ; protected static final String GEO_SHAPE_FIELD_NAME = <str> ; protected static final String [ ] MAPPED_FIELD_NAMES = new String [ ] { STRING_FIELD_NAME , INT_FIELD_NAME , DOUBLE_FIELD_NAME , BOOLEAN_FIELD_NAME , DATE_FIELD_NAME , OBJECT_FIELD_NAME , GEO_POINT_FIELD_NAME , GEO_SHAPE_FIELD_NAME } ; protected static final String [ ] MAPPED_LEAF_FIELD_NAMES = new String [ ] { STRING_FIELD_NAME , INT_FIELD_NAME , DOUBLE_FIELD_NAME , BOOLEAN_FIELD_NAME , DATE_FIELD_NAME , GEO_POINT_FIELD_NAME } ; private static final int NUMBER_OF_TESTQUERIES = <int> ; private static Injector injector ; private static IndicesQueriesRegistry indicesQueriesRegistry ; private static QueryShardContext queryShardContext ; private static IndexFieldDataService indexFieldDataService ; private static int queryNameId = <int> ; protected static QueryShardContext queryShardContext ( ) { return queryShardContext ; } protected static IndexFieldDataService indexFieldDataService ( ) { return indexFieldDataService ; } private static Index index ; protected static Index getIndex ( ) { return index ; } private static String [ ] currentTypes ; protected static String [ ] getCurrentTypes ( ) { return currentTypes ; } private static NamedWriteableRegistry namedWriteableRegistry ; private static String [ ] randomTypes ; private static ClientInvocationHandler clientInvocationHandler = new ClientInvocationHandler ( ) ; @BeforeClass public static void init ( ) throws IOException { Version version = randomBoolean ( ) ? Version . CURRENT : VersionUtils . randomVersionBetween ( random ( ) , Version . V_2_0_0_beta1 , Version . CURRENT ) ; Settings settings = Settings . settingsBuilder ( ) . put ( <str> , AbstractQueryTestCase . class . toString ( ) ) . put ( <str> , createTempDir ( ) ) . put ( ScriptService . SCRIPT_AUTO_RELOAD_ENABLED_SETTING , false ) . build ( ) ; Settings indexSettings = Settings . settingsBuilder ( ) . put ( IndexMetaData . SETTING_VERSION_CREATED , version ) . build ( ) ; index = new Index ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; IndexSettings idxSettings = IndexSettingsModule . newIndexSettings ( index , indexSettings ) ; final TestClusterService clusterService = new TestClusterService ( ) ; clusterService . setState ( new ClusterState . Builder ( clusterService . state ( ) ) . metaData ( new MetaData . Builder ( ) . put ( new IndexMetaData . Builder ( index . name ( ) ) . settings ( indexSettings ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) ) ) ; final Client proxy = ( Client ) Proxy . newProxyInstance ( Client . class . getClassLoader ( ) , new Class [ ] { Client . class } , clientInvocationHandler ) ; injector = new ModulesBuilder ( ) . add ( new EnvironmentModule ( new Environment ( settings ) ) , new SettingsModule ( settings , new SettingsFilter ( settings ) ) , new ThreadPoolModule ( new ThreadPool ( settings ) ) , new IndicesModule ( ) { @Override public void configure ( ) { bindQueryParsersExtension ( ) ; bindMapperExtension ( ) ; } } , new ScriptModule ( settings ) { @Override protected void configure ( ) { Settings settings = Settings . builder ( ) . put ( <str> , createTempDir ( ) ) . put ( ScriptService . SCRIPT_AUTO_RELOAD_ENABLED_SETTING , false ) . build ( ) ; MockScriptEngine mockScriptEngine = new MockScriptEngine ( ) ; Multibinder < ScriptEngineService > multibinder = Multibinder . newSetBinder ( binder ( ) , ScriptEngineService . class ) ; multibinder . addBinding ( ) . toInstance ( mockScriptEngine ) ; Set < ScriptEngineService > engines = new HashSet < > ( ) ; engines . add ( mockScriptEngine ) ; List < ScriptContext . Plugin > customContexts = new ArrayList < > ( ) ; bind ( ScriptContextRegistry . class ) . toInstance ( new ScriptContextRegistry ( customContexts ) ) ; try { ScriptService scriptService = new ScriptService ( settings , new Environment ( settings ) , engines , null , new ScriptContextRegistry ( customContexts ) ) ; bind ( ScriptService . class ) . toInstance ( scriptService ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } } , new IndexSettingsModule ( index , indexSettings ) , new AbstractModule ( ) { @Override protected void configure ( ) { bind ( Client . class ) . toInstance ( proxy ) ; Multibinder . newSetBinder ( binder ( ) , ScoreFunctionParser . class ) ; bind ( ScoreFunctionParserMapper . class ) . asEagerSingleton ( ) ; bind ( ClusterService . class ) . toProvider ( Providers . of ( clusterService ) ) ; bind ( CircuitBreakerService . class ) . to ( NoneCircuitBreakerService . class ) ; bind ( NamedWriteableRegistry . class ) . asEagerSingleton ( ) ; } } ) . createInjector ( ) ; AnalysisService analysisService = new AnalysisRegistry ( null , new Environment ( settings ) ) . build ( idxSettings ) ; ScriptService scriptService = injector . getInstance ( ScriptService . class ) ; SimilarityService similarityService = new SimilarityService ( idxSettings , Collections . emptyMap ( ) ) ; MapperRegistry mapperRegistry = injector . getInstance ( MapperRegistry . class ) ; MapperService mapperService = new MapperService ( idxSettings , analysisService , similarityService , mapperRegistry ) ; indexFieldDataService = new IndexFieldDataService ( idxSettings , injector . getInstance ( IndicesFieldDataCache . class ) , injector . getInstance ( CircuitBreakerService . class ) , mapperService ) ; BitsetFilterCache bitsetFilterCache = new BitsetFilterCache ( idxSettings , new IndicesWarmer ( idxSettings . getNodeSettings ( ) , null ) , new BitsetFilterCache . Listener ( ) { @Override public void onCache ( ShardId shardId , Accountable accountable ) { } @Override public void onRemoval ( ShardId shardId , Accountable accountable ) { } } ) ; indicesQueriesRegistry = injector . getInstance ( IndicesQueriesRegistry . class ) ; queryShardContext = new QueryShardContext ( idxSettings , proxy , bitsetFilterCache , indexFieldDataService , mapperService , similarityService , scriptService , indicesQueriesRegistry ) ; currentTypes = new String [ randomIntBetween ( <int> , <int> ) ] ; for ( int i = <int> ; i < currentTypes . length ; i + + ) { String type = randomAsciiOfLengthBetween ( <int> , <int> ) ; mapperService . merge ( type , new CompressedXContent ( PutMappingRequest . buildFromSimplifiedDef ( type , STRING_FIELD_NAME , <str> , STRING_FIELD_NAME_2 , <str> , INT_FIELD_NAME , <str> , DOUBLE_FIELD_NAME , <str> , BOOLEAN_FIELD_NAME , <str> , DATE_FIELD_NAME , <str> , OBJECT_FIELD_NAME , <str> , GEO_POINT_FIELD_NAME , <str> , GEO_SHAPE_FIELD_NAME , <str> ) . string ( ) ) , false , false ) ; mapperService . merge ( type , new CompressedXContent ( <str> + OBJECT_FIELD_NAME + <str> + <str> + DATE_FIELD_NAME + <str> + INT_FIELD_NAME + <str> ) , false , false ) ; currentTypes [ i ] = type ; } namedWriteableRegistry = injector . getInstance ( NamedWriteableRegistry . class ) ; } @AfterClass public static void afterClass ( ) throws Exception { terminate ( injector . getInstance ( ThreadPool . class ) ) ; injector = null ; index = null ; queryShardContext = null ; currentTypes = null ; namedWriteableRegistry = null ; randomTypes = null ; indicesQueriesRegistry = null ; indexFieldDataService = null ; } @Before public void beforeTest ( ) { clientInvocationHandler . delegate = this ; randomTypes = getRandomTypes ( ) ; } protected void setSearchContext ( String [ ] types ) { TestSearchContext testSearchContext = new TestSearchContext ( ) ; testSearchContext . setTypes ( types ) ; SearchContext . setCurrent ( testSearchContext ) ; } @After public void afterTest ( ) { clientInvocationHandler . delegate = null ; QueryShardContext . removeTypes ( ) ; SearchContext . removeCurrent ( ) ; } protected final QB createTestQueryBuilder ( ) { QB query = doCreateTestQueryBuilder ( ) ; if ( supportsBoostAndQueryName ( ) ) { if ( randomBoolean ( ) ) { query . boost ( <float> / randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { query . queryName ( createUniqueRandomName ( ) ) ; } } return query ; } private static String createUniqueRandomName ( ) { String queryName = randomAsciiOfLengthBetween ( <int> , <int> ) + queryNameId ; queryNameId + + ; return queryName ; } protected abstract QB doCreateTestQueryBuilder ( ) ; public void testFromXContent ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTQUERIES ; runs + + ) { QB testQuery = createTestQueryBuilder ( ) ; XContentBuilder builder = toXContent ( testQuery , randomFrom ( XContentType . values ( ) ) ) ; assertParsedQuery ( builder . bytes ( ) , testQuery ) ; for ( Map . Entry < String , QB > alternateVersion : getAlternateVersions ( ) . entrySet ( ) ) { String queryAsString = alternateVersion . getKey ( ) ; assertParsedQuery ( new BytesArray ( queryAsString ) , alternateVersion . getValue ( ) , ParseFieldMatcher . EMPTY ) ; } } } protected static XContentBuilder toXContent ( QueryBuilder < ? > query , XContentType contentType ) throws IOException { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; if ( randomBoolean ( ) ) { builder . prettyPrint ( ) ; } query . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; return builder ; } public void testUnknownField ( ) throws IOException { String marker = <str> ; QB testQuery ; do { testQuery = createTestQueryBuilder ( ) ; } while ( testQuery . toString ( ) . contains ( marker ) ) ; testQuery . queryName ( marker ) ; String queryAsString = testQuery . toString ( ) . replace ( <str> + marker + <str> , <str> + marker + <str> ) ; try { parseQuery ( queryAsString ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testUnknownObjectException ( ) throws IOException { String validQuery = createTestQueryBuilder ( ) . toString ( ) ; assertThat ( validQuery , containsString ( <str> ) ) ; for ( int insertionPosition = <int> ; insertionPosition < validQuery . length ( ) ; insertionPosition + + ) { if ( validQuery . charAt ( insertionPosition ) = = <str> ) { String testQuery = validQuery . substring ( <int> , insertionPosition ) + <str> + validQuery . substring ( insertionPosition ) + <str> ; try { parseQuery ( testQuery ) ; fail ( <str> + testQuery ) ; } catch ( ParsingException | ScriptParseException | ElasticsearchParseException e ) { } catch ( JsonParseException e ) { } } } } protected Map < String , QB > getAlternateVersions ( ) { return Collections . emptyMap ( ) ; } protected final void assertParsedQuery ( String queryAsString , QueryBuilder < ? > expectedQuery ) throws IOException { assertParsedQuery ( queryAsString , expectedQuery , ParseFieldMatcher . STRICT ) ; } protected final void assertParsedQuery ( String queryAsString , QueryBuilder < ? > expectedQuery , ParseFieldMatcher matcher ) throws IOException { QueryBuilder < ? > newQuery = parseQuery ( queryAsString , matcher ) ; assertNotSame ( newQuery , expectedQuery ) ; assertEquals ( expectedQuery , newQuery ) ; assertEquals ( expectedQuery . hashCode ( ) , newQuery . hashCode ( ) ) ; } protected final void assertParsedQuery ( BytesReference queryAsBytes , QueryBuilder < ? > expectedQuery ) throws IOException { assertParsedQuery ( queryAsBytes , expectedQuery , ParseFieldMatcher . STRICT ) ; } protected final void assertParsedQuery ( BytesReference queryAsBytes , QueryBuilder < ? > expectedQuery , ParseFieldMatcher matcher ) throws IOException { QueryBuilder < ? > newQuery = parseQuery ( queryAsBytes , matcher ) ; assertNotSame ( newQuery , expectedQuery ) ; assertEquals ( expectedQuery , newQuery ) ; assertEquals ( expectedQuery . hashCode ( ) , newQuery . hashCode ( ) ) ; } protected final QueryBuilder < ? > parseQuery ( String queryAsString ) throws IOException { return parseQuery ( queryAsString , ParseFieldMatcher . STRICT ) ; } protected final QueryBuilder < ? > parseQuery ( String queryAsString , ParseFieldMatcher matcher ) throws IOException { XContentParser parser = XContentFactory . xContent ( queryAsString ) . createParser ( queryAsString ) ; return parseQuery ( parser , matcher ) ; } protected final QueryBuilder < ? > parseQuery ( BytesReference queryAsBytes ) throws IOException { return parseQuery ( queryAsBytes , ParseFieldMatcher . STRICT ) ; } protected final QueryBuilder < ? > parseQuery ( BytesReference queryAsBytes , ParseFieldMatcher matcher ) throws IOException { XContentParser parser = XContentFactory . xContent ( queryAsBytes ) . createParser ( queryAsBytes ) ; return parseQuery ( parser , matcher ) ; } private QueryBuilder < ? > parseQuery ( XContentParser parser , ParseFieldMatcher matcher ) throws IOException { QueryParseContext context = createParseContext ( ) ; context . reset ( parser ) ; context . parseFieldMatcher ( matcher ) ; QueryBuilder parseInnerQueryBuilder = context . parseInnerQueryBuilder ( ) ; assertTrue ( parser . nextToken ( ) = = null ) ; return parseInnerQueryBuilder ; } public void testToQuery ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTQUERIES ; runs + + ) { QueryShardContext context = createShardContext ( ) ; context . setAllowUnmappedFields ( true ) ; QB firstQuery = createTestQueryBuilder ( ) ; QB controlQuery = copyQuery ( firstQuery ) ; setSearchContext ( randomTypes ) ; Query firstLuceneQuery = firstQuery . toQuery ( context ) ; assertLuceneQuery ( firstQuery , firstLuceneQuery , context ) ; SearchContext . removeCurrent ( ) ; assertTrue ( <str> + firstQuery + <str> + controlQuery , firstQuery . equals ( controlQuery ) ) ; assertTrue ( <str> + firstQuery + <str> + controlQuery , controlQuery . equals ( firstQuery ) ) ; assertThat ( <str> + firstQuery + <str> + controlQuery , controlQuery . hashCode ( ) , equalTo ( firstQuery . hashCode ( ) ) ) ; QB secondQuery = copyQuery ( firstQuery ) ; if ( randomBoolean ( ) ) { secondQuery . queryName ( secondQuery . queryName ( ) = = null ? randomAsciiOfLengthBetween ( <int> , <int> ) : secondQuery . queryName ( ) + randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } setSearchContext ( randomTypes ) ; Query secondLuceneQuery = secondQuery . toQuery ( context ) ; assertLuceneQuery ( secondQuery , secondLuceneQuery , context ) ; SearchContext . removeCurrent ( ) ; assertThat ( <str> , secondLuceneQuery , equalTo ( firstLuceneQuery ) ) ; if ( firstLuceneQuery ! = null & & supportsBoostAndQueryName ( ) ) { secondQuery . boost ( firstQuery . boost ( ) + <float> + randomFloat ( ) ) ; setSearchContext ( randomTypes ) ; Query thirdLuceneQuery = secondQuery . toQuery ( context ) ; SearchContext . removeCurrent ( ) ; assertThat ( <str> , firstLuceneQuery , not ( equalTo ( thirdLuceneQuery ) ) ) ; } } } protected boolean supportsBoostAndQueryName ( ) { return true ; } protected final void assertLuceneQuery ( QB queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( queryBuilder . queryName ( ) ! = null ) { Query namedQuery = context . copyNamedQueries ( ) . get ( queryBuilder . queryName ( ) ) ; assertThat ( namedQuery , equalTo ( query ) ) ; } if ( query ! = null ) { if ( queryBuilder . boost ( ) ! = AbstractQueryBuilder . DEFAULT_BOOST ) { assertThat ( query , either ( instanceOf ( BoostQuery . class ) ) . or ( instanceOf ( SpanBoostQuery . class ) ) ) ; if ( query instanceof SpanBoostQuery ) { SpanBoostQuery spanBoostQuery = ( SpanBoostQuery ) query ; assertThat ( spanBoostQuery . getBoost ( ) , equalTo ( queryBuilder . boost ( ) ) ) ; query = spanBoostQuery . getQuery ( ) ; } else { BoostQuery boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( queryBuilder . boost ( ) ) ) ; query = boostQuery . getQuery ( ) ; } } } doAssertLuceneQuery ( queryBuilder , query , context ) ; } protected abstract void doAssertLuceneQuery ( QB queryBuilder , Query query , QueryShardContext context ) throws IOException ; protected static void assertTermOrBoostQuery ( Query query , String field , String value , float fieldBoost ) { if ( fieldBoost ! = AbstractQueryBuilder . DEFAULT_BOOST ) { assertThat ( query , instanceOf ( BoostQuery . class ) ) ; BoostQuery boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( fieldBoost ) ) ; query = boostQuery . getQuery ( ) ; } assertTermQuery ( query , field , value ) ; } protected static void assertTermQuery ( Query query , String field , String value ) { assertThat ( query , instanceOf ( TermQuery . class ) ) ; TermQuery termQuery = ( TermQuery ) query ; assertThat ( termQuery . getTerm ( ) . field ( ) , equalTo ( field ) ) ; assertThat ( termQuery . getTerm ( ) . text ( ) . toLowerCase ( Locale . ROOT ) , equalTo ( value . toLowerCase ( Locale . ROOT ) ) ) ; } public void testSerialization ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTQUERIES ; runs + + ) { QB testQuery = createTestQueryBuilder ( ) ; assertSerialization ( testQuery ) ; } } @SuppressWarnings ( <str> ) protected QB assertSerialization ( QB testQuery ) throws IOException { try ( BytesStreamOutput output = new BytesStreamOutput ( ) ) { testQuery . writeTo ( output ) ; try ( StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( output . bytes ( ) ) , namedWriteableRegistry ) ) { QueryBuilder < ? > prototype = queryParser ( testQuery . getName ( ) ) . getBuilderPrototype ( ) ; QueryBuilder deserializedQuery = prototype . readFrom ( in ) ; assertEquals ( deserializedQuery , testQuery ) ; assertEquals ( deserializedQuery . hashCode ( ) , testQuery . hashCode ( ) ) ; assertNotSame ( deserializedQuery , testQuery ) ; return ( QB ) deserializedQuery ; } } } public void testEqualsAndHashcode ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTQUERIES ; runs + + ) { QB firstQuery = createTestQueryBuilder ( ) ; assertFalse ( <str> , firstQuery . equals ( null ) ) ; assertFalse ( <str> , firstQuery . equals ( <str> ) ) ; assertTrue ( <str> , firstQuery . equals ( firstQuery ) ) ; assertThat ( <str> , firstQuery . hashCode ( ) , equalTo ( firstQuery . hashCode ( ) ) ) ; QB secondQuery = copyQuery ( firstQuery ) ; assertTrue ( <str> , secondQuery . equals ( secondQuery ) ) ; assertTrue ( <str> , firstQuery . equals ( secondQuery ) ) ; assertTrue ( <str> , secondQuery . equals ( firstQuery ) ) ; assertThat ( <str> , secondQuery . hashCode ( ) , equalTo ( firstQuery . hashCode ( ) ) ) ; QB thirdQuery = copyQuery ( secondQuery ) ; assertTrue ( <str> , thirdQuery . equals ( thirdQuery ) ) ; assertTrue ( <str> , secondQuery . equals ( thirdQuery ) ) ; assertThat ( <str> , secondQuery . hashCode ( ) , equalTo ( thirdQuery . hashCode ( ) ) ) ; assertTrue ( <str> , firstQuery . equals ( thirdQuery ) ) ; assertThat ( <str> , firstQuery . hashCode ( ) , equalTo ( thirdQuery . hashCode ( ) ) ) ; assertTrue ( <str> , thirdQuery . equals ( secondQuery ) ) ; assertTrue ( <str> , thirdQuery . equals ( firstQuery ) ) ; if ( randomBoolean ( ) ) { secondQuery . queryName ( secondQuery . queryName ( ) = = null ? randomAsciiOfLengthBetween ( <int> , <int> ) : secondQuery . queryName ( ) + randomAsciiOfLengthBetween ( <int> , <int> ) ) ; } else { secondQuery . boost ( firstQuery . boost ( ) + <float> + randomFloat ( ) ) ; } assertThat ( <str> , secondQuery , not ( equalTo ( firstQuery ) ) ) ; } } private QueryParser < ? > queryParser ( String queryId ) { return indicesQueriesRegistry . queryParsers ( ) . get ( queryId ) ; } protected QB copyQuery ( QB query ) throws IOException { try ( BytesStreamOutput output = new BytesStreamOutput ( ) ) { query . writeTo ( output ) ; try ( StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( output . bytes ( ) ) , namedWriteableRegistry ) ) { QueryBuilder < ? > prototype = queryParser ( query . getName ( ) ) . getBuilderPrototype ( ) ; @SuppressWarnings ( <str> ) QB secondQuery = ( QB ) prototype . readFrom ( in ) ; return secondQuery ; } } } protected static QueryShardContext createShardContext ( ) { QueryShardContext queryCreationContext = new QueryShardContext ( queryShardContext ) ; queryCreationContext . reset ( ) ; queryCreationContext . parseFieldMatcher ( ParseFieldMatcher . STRICT ) ; return queryCreationContext ; } protected static QueryParseContext createParseContext ( ) { QueryParseContext queryParseContext = new QueryParseContext ( indicesQueriesRegistry ) ; queryParseContext . reset ( null ) ; queryParseContext . parseFieldMatcher ( ParseFieldMatcher . STRICT ) ; return queryParseContext ; } protected static Object getRandomValueForFieldName ( String fieldName ) { Object value ; switch ( fieldName ) { case STRING_FIELD_NAME : if ( rarely ( ) ) { JsonStringEncoder encoder = JsonStringEncoder . getInstance ( ) ; value = new String ( encoder . quoteAsString ( randomUnicodeOfLength ( <int> ) ) ) ; } else { value = randomAsciiOfLengthBetween ( <int> , <int> ) ; } break ; case INT_FIELD_NAME : value = randomIntBetween ( <int> , <int> ) ; break ; case DOUBLE_FIELD_NAME : value = randomDouble ( ) * <int> ; break ; case BOOLEAN_FIELD_NAME : value = randomBoolean ( ) ; break ; case DATE_FIELD_NAME : value = new DateTime ( System . currentTimeMillis ( ) , DateTimeZone . UTC ) . toString ( ) ; break ; default : value = randomAsciiOfLengthBetween ( <int> , <int> ) ; } return value ; } protected static String getRandomQueryText ( ) { int terms = randomIntBetween ( <int> , <int> ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = <int> ; i < terms ; i + + ) { builder . append ( randomAsciiOfLengthBetween ( <int> , <int> ) + <str> ) ; } return builder . toString ( ) . trim ( ) ; } protected String getRandomFieldName ( ) { if ( currentTypes = = null | | currentTypes . length = = <int> | | randomBoolean ( ) ) { return randomAsciiOfLengthBetween ( <int> , <int> ) ; } return randomFrom ( MAPPED_LEAF_FIELD_NAMES ) ; } protected Tuple < String , Object > getRandomFieldNameAndValue ( ) { String fieldName = getRandomFieldName ( ) ; return new Tuple < > ( fieldName , getRandomValueForFieldName ( fieldName ) ) ; } protected static String getRandomRewriteMethod ( ) { String rewrite ; if ( randomBoolean ( ) ) { rewrite = randomFrom ( QueryParsers . CONSTANT_SCORE , QueryParsers . SCORING_BOOLEAN , QueryParsers . CONSTANT_SCORE_BOOLEAN ) . getPreferredName ( ) ; } else { rewrite = randomFrom ( QueryParsers . TOP_TERMS , QueryParsers . TOP_TERMS_BOOST , QueryParsers . TOP_TERMS_BLENDED_FREQS ) . getPreferredName ( ) + <str> ; } return rewrite ; } protected String [ ] getRandomTypes ( ) { String [ ] types ; if ( currentTypes . length > <int> & & randomBoolean ( ) ) { int numberOfQueryTypes = randomIntBetween ( <int> , currentTypes . length ) ; types = new String [ numberOfQueryTypes ] ; for ( int i = <int> ; i < numberOfQueryTypes ; i + + ) { types [ i ] = randomFrom ( currentTypes ) ; } } else { if ( randomBoolean ( ) ) { types = new String [ ] { MetaData . ALL } ; } else { types = new String [ <int> ] ; } } return types ; } protected String getRandomType ( ) { return ( currentTypes . length = = <int> ) ? MetaData . ALL : randomFrom ( currentTypes ) ; } public static String randomGeohash ( int minPrecision , int maxPrecision ) { return geohashGenerator . ofStringLength ( getRandom ( ) , minPrecision , maxPrecision ) ; } public static class GeohashGenerator extends CodepointSetGenerator { private final static char [ ] ASCII_SET = <str> . toCharArray ( ) ; public GeohashGenerator ( ) { super ( ASCII_SET ) ; } } protected static Fuzziness randomFuzziness ( String fieldName ) { if ( randomBoolean ( ) ) { return Fuzziness . fromEdits ( randomIntBetween ( <int> , <int> ) ) ; } if ( randomBoolean ( ) ) { return Fuzziness . AUTO ; } switch ( fieldName ) { case INT_FIELD_NAME : return Fuzziness . build ( randomIntBetween ( <int> , <int> ) ) ; case DOUBLE_FIELD_NAME : return Fuzziness . build ( <int> + randomFloat ( ) * <int> ) ; case DATE_FIELD_NAME : return Fuzziness . build ( randomTimeValue ( ) ) ; default : return Fuzziness . AUTO ; } } protected static boolean isNumericFieldName ( String fieldName ) { return INT_FIELD_NAME . equals ( fieldName ) | | DOUBLE_FIELD_NAME . equals ( fieldName ) ; } protected static String randomAnalyzer ( ) { return randomFrom ( <str> , <str> , <str> , <str> ) ; } protected static String randomMinimumShouldMatch ( ) { return randomFrom ( <str> , <str> , <str> , <str> , <str> , <str> ) ; } protected static String randomTimeZone ( ) { return randomFrom ( TIMEZONE_IDS ) ; } private static final List < String > TIMEZONE_IDS = new ArrayList < > ( DateTimeZone . getAvailableIDs ( ) ) ; private static class ClientInvocationHandler implements InvocationHandler { AbstractQueryTestCase delegate ; @Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { if ( method . equals ( Client . class . getMethod ( <str> , GetRequest . class ) ) ) { return new PlainActionFuture < GetResponse > ( ) { @Override public GetResponse get ( ) throws InterruptedException , ExecutionException { return delegate . executeGet ( ( GetRequest ) args [ <int> ] ) ; } } ; } else if ( method . equals ( Client . class . getMethod ( <str> , MultiTermVectorsRequest . class ) ) ) { return new PlainActionFuture < MultiTermVectorsResponse > ( ) { @Override public MultiTermVectorsResponse get ( ) throws InterruptedException , ExecutionException { return delegate . executeMultiTermVectors ( ( MultiTermVectorsRequest ) args [ <int> ] ) ; } } ; } else if ( method . equals ( Object . class . getMethod ( <str> ) ) ) { return <str> ; } throw new UnsupportedOperationException ( <str> + method ) ; } } protected GetResponse executeGet ( GetRequest getRequest ) { throw new UnsupportedOperationException ( <str> ) ; } protected MultiTermVectorsResponse executeMultiTermVectors ( MultiTermVectorsRequest mtvRequest ) { throw new UnsupportedOperationException ( <str> ) ; } public static void checkGeneratedJson ( String expected , QueryBuilder < ? > source ) throws IOException { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; source . toXContent ( builder , ToXContent . EMPTY_PARAMS ) ; assertEquals ( msg ( expected , builder . string ( ) ) , expected . replaceAll ( <str> , <str> ) , builder . string ( ) . replaceAll ( <str> , <str> ) ) ; } private static String msg ( String left , String right ) { int size = Math . min ( left . length ( ) , right . length ( ) ) ; StringBuilder builder = new StringBuilder ( <str> + left . length ( ) + <str> + right . length ( ) ) ; builder . append ( <str> ) ; for ( int i = <int> ; i < size ; i + + ) { if ( left . charAt ( i ) = = right . charAt ( i ) ) { builder . append ( left . charAt ( i ) ) ; } else { builder . append ( <str> ) . append ( <str> ) . append ( i ) . append ( <str> ) . append ( left . charAt ( i ) ) . append ( <str> ) . append ( right . charAt ( i ) ) . append ( <str> ) . append ( ( int ) left . charAt ( i ) ) . append ( <str> ) . append ( ( int ) right . charAt ( i ) ) . append ( <str> ) ; return builder . toString ( ) ; } } if ( left . length ( ) ! = right . length ( ) ) { int leftEnd = Math . max ( size , left . length ( ) ) - <int> ; int rightEnd = Math . max ( size , right . length ( ) ) - <int> ; builder . append ( <str> ) . append ( <str> ) . append ( size ) . append ( <str> ) . append ( left . charAt ( leftEnd ) ) . append ( <str> ) . append ( right . charAt ( rightEnd ) ) . append ( <str> ) . append ( ( int ) left . charAt ( leftEnd ) ) . append ( <str> ) . append ( ( int ) right . charAt ( rightEnd ) ) . append ( <str> ) ; return builder . toString ( ) ; } return <str> ; } } 
