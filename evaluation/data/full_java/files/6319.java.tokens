package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . DelegatingAnalyzerWrapper ; import java . util . Objects ; public class NamedAnalyzer extends DelegatingAnalyzerWrapper { private final String name ; private final AnalyzerScope scope ; private final Analyzer analyzer ; private final int positionIncrementGap ; public NamedAnalyzer ( NamedAnalyzer analyzer , int positionIncrementGap ) { this ( analyzer . name ( ) , analyzer . scope ( ) , analyzer . analyzer ( ) , positionIncrementGap ) ; } public NamedAnalyzer ( String name , Analyzer analyzer ) { this ( name , AnalyzerScope . INDEX , analyzer ) ; } public NamedAnalyzer ( String name , AnalyzerScope scope , Analyzer analyzer ) { this ( name , scope , analyzer , Integer . MIN_VALUE ) ; } public NamedAnalyzer ( String name , AnalyzerScope scope , Analyzer analyzer , int positionIncrementGap ) { super ( ERROR_STRATEGY ) ; this . name = name ; this . scope = scope ; this . analyzer = analyzer ; this . positionIncrementGap = positionIncrementGap ; } public String name ( ) { return this . name ; } public AnalyzerScope scope ( ) { return this . scope ; } public Analyzer analyzer ( ) { return this . analyzer ; } @Override protected Analyzer getWrappedAnalyzer ( String fieldName ) { return this . analyzer ; } @Override public int getPositionIncrementGap ( String fieldName ) { if ( positionIncrementGap ! = Integer . MIN_VALUE ) { return positionIncrementGap ; } return super . getPositionIncrementGap ( fieldName ) ; } @Override public String toString ( ) { return <str> + name + <str> + analyzer + <str> ; } static final ReuseStrategy ERROR_STRATEGY = new Analyzer . ReuseStrategy ( ) { @Override public TokenStreamComponents getReusableComponents ( Analyzer a , String f ) { throw new IllegalStateException ( <str> ) ; } @Override public void setReusableComponents ( Analyzer a , String f , TokenStreamComponents c ) { throw new IllegalStateException ( <str> ) ; } } ; @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof NamedAnalyzer ) ) return false ; NamedAnalyzer that = ( NamedAnalyzer ) o ; return Objects . equals ( name , that . name ) ; } @Override public int hashCode ( ) { return Objects . hash ( name ) ; } } 
