package org . junit . tests . experimental . theories . runner ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; import static org . junit . Assume . assumeTrue ; import java . util . ArrayList ; import java . util . List ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . junit . experimental . runners . Enclosed ; import org . junit . experimental . theories . DataPoint ; import org . junit . experimental . theories . Theories ; import org . junit . experimental . theories . Theory ; import org . junit . runner . RunWith ; @RunWith ( Enclosed . class ) public class SuccessfulWithDataPointFields { @RunWith ( Theories . class ) public static class HasATwoParameterTheory { @DataPoint public static int ONE = <int> ; @Theory public void allIntsAreEqual ( int x , int y ) { assertThat ( x , is ( y ) ) ; } } @RunWith ( Theories . class ) public static class BeforeAndAfterOnSameInstance { @DataPoint public static String A = <str> ; private int befores = <int> ; @Before public void incrementBefore ( ) { befores + + ; } @Theory public void stringsAreOK ( String string ) { assertTrue ( befores = = <int> ) ; } } @RunWith ( Theories . class ) public static class NewObjectEachTime { @DataPoint public static String A = <str> ; @DataPoint public static String B = <str> ; private List < String > list = new ArrayList < String > ( ) ; @Theory public void addToEmptyList ( String string ) { list . add ( string ) ; assertThat ( list . size ( ) , is ( <int> ) ) ; } } @RunWith ( Theories . class ) public static class PositiveInts { @DataPoint public static final int ONE = <int> ; private int x ; public PositiveInts ( int x ) { assumeTrue ( x > <int> ) ; this . x = x ; } @Theory public void haveAPostiveSquare ( ) { assertTrue ( x * x > <int> ) ; } } @RunWith ( Theories . class ) public static class PositiveIntsWithNegativeField { @DataPoint public static final int ONE = <int> ; @DataPoint public static final int NEGONE = - <int> ; private int x ; public PositiveIntsWithNegativeField ( int x ) { assumeTrue ( x > <int> ) ; this . x = x ; } @Theory public void haveAPostiveSquare ( ) { assertTrue ( x > <int> ) ; } } @RunWith ( Theories . class ) public static class PositiveIntsWithMethodParams { @DataPoint public static final int ONE = <int> ; private int x ; public PositiveIntsWithMethodParams ( int x ) { assumeTrue ( x > <int> ) ; this . x = x ; } @Theory public void haveAPostiveSquare ( int y ) { assumeTrue ( y > <int> ) ; assertTrue ( x * y > <int> ) ; } } @RunWith ( Theories . class ) public static class DifferentTypesInConstructor { @DataPoint public static final int ONE = <int> ; @DataPoint public static final String A = <str> ; public DifferentTypesInConstructor ( int x ) { } @Theory public void yesIndeed ( String a ) { } } @RunWith ( Theories . class ) public static class BeforeAndAfterEachTime { public static int befores = <int> ; @DataPoint public static String A = <str> ; @DataPoint public static String B = <str> ; @Before public void incrementBefore ( ) { befores + + ; } @BeforeClass public static void resetCalls ( ) { befores = <int> ; } @Theory public void stringsAreOK ( String string ) { } @AfterClass public static void calledTwice ( ) { assertEquals ( <int> , befores ) ; } } @RunWith ( Theories . class ) public static class OneTestTwoAnnotations { public static int tests = <int> ; @DataPoint public static String A = <str> ; @BeforeClass public static void resetCalls ( ) { tests = <int> ; } @Theory @Test public void stringsAreOK ( String string ) { tests + + ; } @AfterClass public static void calledTwice ( ) { assertEquals ( <int> , tests ) ; } } @RunWith ( Theories . class ) static public class StaticPublicNonDataPoints { @DataPoint public static int ZERO = <int> ; public static int ONE = <int> ; @Theory public void onlyAnnotatedFields ( int i ) { assertTrue ( i = = <int> ) ; } } } 
