package org . gradle . tooling . internal . provider . runner ; import org . gradle . api . execution . internal . InternalTaskExecutionListener ; import org . gradle . api . execution . internal . TaskOperationInternal ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . internal . tasks . TaskStateInternal ; import org . gradle . initialization . BuildEventConsumer ; import org . gradle . internal . progress . OperationResult ; import org . gradle . internal . progress . OperationStartEvent ; import org . gradle . tooling . internal . provider . BuildClientSubscriptions ; import org . gradle . tooling . internal . provider . events . * ; import java . util . Collections ; class ClientForwardingTaskListener implements InternalTaskExecutionListener { private final BuildEventConsumer eventConsumer ; private final BuildClientSubscriptions clientSubscriptions ; ClientForwardingTaskListener ( BuildEventConsumer eventConsumer , BuildClientSubscriptions clientSubscriptions ) { this . eventConsumer = eventConsumer ; this . clientSubscriptions = clientSubscriptions ; } @Override public void beforeExecute ( TaskOperationInternal taskOperation , OperationStartEvent startEvent ) { eventConsumer . dispatch ( new DefaultTaskStartedProgressEvent ( startEvent . getStartTime ( ) , toTaskDescriptor ( taskOperation ) ) ) ; } @Override public void afterExecute ( TaskOperationInternal taskOperation , OperationResult result ) { eventConsumer . dispatch ( new DefaultTaskFinishedProgressEvent ( result . getEndTime ( ) , toTaskDescriptor ( taskOperation ) , toTaskResult ( taskOperation . getTask ( ) , result ) ) ) ; } private DefaultTaskDescriptor toTaskDescriptor ( TaskOperationInternal taskOperation ) { TaskInternal task = taskOperation . getTask ( ) ; Object id = taskOperation . getId ( ) ; String displayName = String . format ( <str> , task . getPath ( ) ) ; String taskPath = task . getPath ( ) ; Object parentId = getParentId ( taskOperation ) ; return new DefaultTaskDescriptor ( id , taskPath , displayName , parentId ) ; } private Object getParentId ( TaskOperationInternal taskOperation ) { return clientSubscriptions . isSendBuildProgressEvents ( ) ? taskOperation . getParentId ( ) : null ; } private static AbstractTaskResult toTaskResult ( TaskInternal task , OperationResult result ) { TaskStateInternal state = task . getState ( ) ; long startTime = result . getStartTime ( ) ; long endTime = result . getEndTime ( ) ; if ( state . getUpToDate ( ) ) { return new DefaultTaskSuccessResult ( startTime , endTime , true ) ; } else if ( state . getSkipped ( ) ) { return new DefaultTaskSkippedResult ( startTime , endTime , state . getSkipMessage ( ) ) ; } else { Throwable failure = state . getFailure ( ) ; if ( failure = = null ) { return new DefaultTaskSuccessResult ( startTime , endTime , false ) ; } else { return new DefaultTaskFailureResult ( startTime , endTime , Collections . singletonList ( DefaultFailure . fromThrowable ( failure ) ) ) ; } } } } 
