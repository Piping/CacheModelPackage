package com . badlogic . gdx . jnigen . parsing ; import com . github . javaparser . JavaParser ; import com . github . javaparser . ast . CompilationUnit ; import com . github . javaparser . ast . body . BodyDeclaration ; import com . github . javaparser . ast . body . ClassOrInterfaceDeclaration ; import com . github . javaparser . ast . body . EnumDeclaration ; import com . github . javaparser . ast . body . MethodDeclaration ; import com . github . javaparser . ast . body . ModifierSet ; import com . github . javaparser . ast . body . Parameter ; import com . github . javaparser . ast . body . TypeDeclaration ; import java . io . ByteArrayInputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Stack ; public class RobustJavaMethodParser implements JavaMethodParser { private static final String JNI_MANUAL = <str> ; private static final Map < String , ArgumentType > plainOldDataTypes ; private static final Map < String , ArgumentType > arrayTypes ; private static final Map < String , ArgumentType > bufferTypes ; static { plainOldDataTypes = new HashMap < String , ArgumentType > ( ) ; plainOldDataTypes . put ( <str> , ArgumentType . Boolean ) ; plainOldDataTypes . put ( <str> , ArgumentType . Byte ) ; plainOldDataTypes . put ( <str> , ArgumentType . Char ) ; plainOldDataTypes . put ( <str> , ArgumentType . Short ) ; plainOldDataTypes . put ( <str> , ArgumentType . Integer ) ; plainOldDataTypes . put ( <str> , ArgumentType . Long ) ; plainOldDataTypes . put ( <str> , ArgumentType . Float ) ; plainOldDataTypes . put ( <str> , ArgumentType . Double ) ; arrayTypes = new HashMap < String , ArgumentType > ( ) ; arrayTypes . put ( <str> , ArgumentType . BooleanArray ) ; arrayTypes . put ( <str> , ArgumentType . ByteArray ) ; arrayTypes . put ( <str> , ArgumentType . CharArray ) ; arrayTypes . put ( <str> , ArgumentType . ShortArray ) ; arrayTypes . put ( <str> , ArgumentType . IntegerArray ) ; arrayTypes . put ( <str> , ArgumentType . LongArray ) ; arrayTypes . put ( <str> , ArgumentType . FloatArray ) ; arrayTypes . put ( <str> , ArgumentType . DoubleArray ) ; bufferTypes = new HashMap < String , ArgumentType > ( ) ; bufferTypes . put ( <str> , ArgumentType . Buffer ) ; bufferTypes . put ( <str> , ArgumentType . ByteBuffer ) ; bufferTypes . put ( <str> , ArgumentType . CharBuffer ) ; bufferTypes . put ( <str> , ArgumentType . ShortBuffer ) ; bufferTypes . put ( <str> , ArgumentType . IntBuffer ) ; bufferTypes . put ( <str> , ArgumentType . LongBuffer ) ; bufferTypes . put ( <str> , ArgumentType . FloatBuffer ) ; bufferTypes . put ( <str> , ArgumentType . DoubleBuffer ) ; } Stack < TypeDeclaration > classStack = new Stack < TypeDeclaration > ( ) ; @Override public ArrayList < JavaSegment > parse ( String classFile ) throws Exception { CompilationUnit unit = JavaParser . parse ( new ByteArrayInputStream ( classFile . getBytes ( ) ) ) ; ArrayList < JavaMethod > methods = new ArrayList < JavaMethod > ( ) ; getJavaMethods ( methods , getOuterClass ( unit ) ) ; ArrayList < JniSection > methodBodies = getNativeCodeBodies ( classFile ) ; ArrayList < JniSection > sections = getJniSections ( classFile ) ; alignMethodBodies ( methods , methodBodies ) ; ArrayList < JavaSegment > segments = sortMethodsAndSections ( methods , sections ) ; return segments ; } private ArrayList < JavaSegment > sortMethodsAndSections ( ArrayList < JavaMethod > methods , ArrayList < JniSection > sections ) { ArrayList < JavaSegment > segments = new ArrayList < JavaSegment > ( ) ; segments . addAll ( methods ) ; segments . addAll ( sections ) ; Collections . sort ( segments , new Comparator < JavaSegment > ( ) { @Override public int compare ( JavaSegment o1 , JavaSegment o2 ) { return o1 . getStartIndex ( ) - o2 . getStartIndex ( ) ; } } ) ; return segments ; } private void alignMethodBodies ( ArrayList < JavaMethod > methods , ArrayList < JniSection > methodBodies ) { for ( JavaMethod method : methods ) { for ( JniSection section : methodBodies ) { if ( method . getEndIndex ( ) = = section . getStartIndex ( ) ) { if ( section . getNativeCode ( ) . startsWith ( JNI_MANUAL ) ) { section . setNativeCode ( section . getNativeCode ( ) . substring ( JNI_MANUAL . length ( ) ) ) ; method . setManual ( true ) ; } method . setNativeCode ( section . getNativeCode ( ) ) ; break ; } } } } private void getJavaMethods ( ArrayList < JavaMethod > methods , TypeDeclaration type ) { classStack . push ( type ) ; if ( type . getMembers ( ) ! = null ) { for ( BodyDeclaration member : type . getMembers ( ) ) { if ( member instanceof ClassOrInterfaceDeclaration | | member instanceof EnumDeclaration ) { getJavaMethods ( methods , ( TypeDeclaration ) member ) ; } else { if ( member instanceof MethodDeclaration ) { MethodDeclaration method = ( MethodDeclaration ) member ; if ( ! ModifierSet . hasModifier ( ( ( MethodDeclaration ) member ) . getModifiers ( ) , ModifierSet . NATIVE ) ) continue ; methods . add ( createMethod ( method ) ) ; } } } } classStack . pop ( ) ; } private JavaMethod createMethod ( MethodDeclaration method ) { String className = classStack . peek ( ) . getName ( ) ; String name = method . getName ( ) ; boolean isStatic = ModifierSet . hasModifier ( method . getModifiers ( ) , ModifierSet . STATIC ) ; String returnType = method . getType ( ) . toString ( ) ; ArrayList < Argument > arguments = new ArrayList < Argument > ( ) ; if ( method . getParameters ( ) ! = null ) { for ( Parameter parameter : method . getParameters ( ) ) { arguments . add ( new Argument ( getArgumentType ( parameter ) , parameter . getId ( ) . getName ( ) ) ) ; } } return new JavaMethod ( className , name , isStatic , returnType , null , arguments , method . getBeginLine ( ) , method . getEndLine ( ) ) ; } private ArgumentType getArgumentType ( Parameter parameter ) { String [ ] typeTokens = parameter . getType ( ) . toString ( ) . split ( <str> ) ; String type = typeTokens [ typeTokens . length - <int> ] ; int arrayDim = <int> ; for ( int i = <int> ; i < type . length ( ) ; i + + ) { if ( type . charAt ( i ) = = <str> ) arrayDim + + ; } type = type . replace ( <str> , <str> ) . replace ( <str> , <str> ) ; if ( arrayDim > = <int> ) { if ( arrayDim > <int> ) return ArgumentType . ObjectArray ; ArgumentType arrayType = arrayTypes . get ( type ) ; if ( arrayType = = null ) { return ArgumentType . ObjectArray ; } return arrayType ; } if ( plainOldDataTypes . containsKey ( type ) ) return plainOldDataTypes . get ( type ) ; if ( bufferTypes . containsKey ( type ) ) return bufferTypes . get ( type ) ; if ( type . equals ( <str> ) ) return ArgumentType . String ; return ArgumentType . Object ; } private TypeDeclaration getOuterClass ( CompilationUnit unit ) { for ( TypeDeclaration type : unit . getTypes ( ) ) { if ( type instanceof ClassOrInterfaceDeclaration | | type instanceof EnumDeclaration ) return type ; } throw new RuntimeException ( <str> ) ; } private ArrayList < JniSection > getJniSections ( String classFile ) { ArrayList < JniSection > sections = getComments ( classFile ) ; Iterator < JniSection > iter = sections . iterator ( ) ; while ( iter . hasNext ( ) ) { JniSection section = iter . next ( ) ; if ( ! section . getNativeCode ( ) . startsWith ( <str> ) ) { iter . remove ( ) ; } else { section . setNativeCode ( section . getNativeCode ( ) . substring ( <int> ) ) ; } } return sections ; } private ArrayList < JniSection > getNativeCodeBodies ( String classFile ) { ArrayList < JniSection > sections = getComments ( classFile ) ; Iterator < JniSection > iter = sections . iterator ( ) ; while ( iter . hasNext ( ) ) { JniSection section = iter . next ( ) ; if ( section . getNativeCode ( ) . startsWith ( <str> ) ) iter . remove ( ) ; if ( section . getNativeCode ( ) . startsWith ( <str> ) ) iter . remove ( ) ; } return sections ; } private ArrayList < JniSection > getComments ( String classFile ) { ArrayList < JniSection > sections = new ArrayList < JniSection > ( ) ; boolean inComment = false ; int start = <int> ; int startLine = <int> ; int line = <int> ; for ( int i = <int> ; i < classFile . length ( ) - <int> ; i + + ) { char c1 = classFile . charAt ( i ) ; char c2 = classFile . charAt ( i + <int> ) ; char c3 = classFile . charAt ( i + <int> ) ; if ( c1 = = <str> ) line + + ; if ( ! inComment ) { if ( c1 = = <str> & & c2 = = <str> & & c3 ! = <str> ) { inComment = true ; start = i ; startLine = line ; } } else { if ( c1 = = <str> & & c2 = = <str> ) { sections . add ( new JniSection ( classFile . substring ( start + <int> , i ) , startLine , line ) ) ; inComment = false ; } } } return sections ; } } 
