package org . apache . cassandra . tools . nodetool ; import io . airlift . command . Arguments ; import io . airlift . command . Command ; import io . airlift . command . Option ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import javax . management . InstanceNotFoundException ; import org . apache . cassandra . db . ColumnFamilyStoreMBean ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . metrics . CassandraMetricsRegistry ; import org . apache . cassandra . tools . NodeProbe ; import org . apache . cassandra . tools . NodeTool . NodeToolCmd ; @Command ( name = <str> , description = <str> ) public class TableStats extends NodeToolCmd { @Arguments ( usage = <str> , description = <str> ) private List < String > tableNames = new ArrayList < > ( ) ; @Option ( name = <str> , description = <str> ) private boolean ignore = false ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean humanReadable = false ; @Override public void execute ( NodeProbe probe ) { TableStats . OptionFilter filter = new OptionFilter ( ignore , tableNames ) ; Map < String , List < ColumnFamilyStoreMBean > > tableStoreMap = new HashMap < > ( ) ; Iterator < Map . Entry < String , ColumnFamilyStoreMBean > > tables = probe . getColumnFamilyStoreMBeanProxies ( ) ; while ( tables . hasNext ( ) ) { Map . Entry < String , ColumnFamilyStoreMBean > entry = tables . next ( ) ; String keyspaceName = entry . getKey ( ) ; ColumnFamilyStoreMBean tableProxy = entry . getValue ( ) ; if ( ! tableStoreMap . containsKey ( keyspaceName ) & & filter . isColumnFamilyIncluded ( entry . getKey ( ) , tableProxy . getColumnFamilyName ( ) ) ) { List < ColumnFamilyStoreMBean > columnFamilies = new ArrayList < > ( ) ; columnFamilies . add ( tableProxy ) ; tableStoreMap . put ( keyspaceName , columnFamilies ) ; } else if ( filter . isColumnFamilyIncluded ( entry . getKey ( ) , tableProxy . getColumnFamilyName ( ) ) ) { tableStoreMap . get ( keyspaceName ) . add ( tableProxy ) ; } } filter . verifyKeyspaces ( probe . getKeyspaces ( ) ) ; filter . verifyColumnFamilies ( ) ; for ( Map . Entry < String , List < ColumnFamilyStoreMBean > > entry : tableStoreMap . entrySet ( ) ) { String keyspaceName = entry . getKey ( ) ; List < ColumnFamilyStoreMBean > columnFamilies = entry . getValue ( ) ; long keyspaceReadCount = <int> ; long keyspaceWriteCount = <int> ; int keyspacePendingFlushes = <int> ; double keyspaceTotalReadTime = <float> ; double keyspaceTotalWriteTime = <float> ; System . out . println ( <str> + keyspaceName ) ; for ( ColumnFamilyStoreMBean table : columnFamilies ) { String tableName = table . getColumnFamilyName ( ) ; long writeCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) . getCount ( ) ; long readCount = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) . getCount ( ) ; if ( readCount > <int> ) { keyspaceReadCount + = readCount ; keyspaceTotalReadTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; } if ( writeCount > <int> ) { keyspaceWriteCount + = writeCount ; keyspaceTotalWriteTime + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; } keyspacePendingFlushes + = ( long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; } double keyspaceReadLatency = keyspaceReadCount > <int> ? keyspaceTotalReadTime / keyspaceReadCount / <int> : Double . NaN ; double keyspaceWriteLatency = keyspaceWriteCount > <int> ? keyspaceTotalWriteTime / keyspaceWriteCount / <int> : Double . NaN ; System . out . println ( <str> + keyspaceReadCount ) ; System . out . println ( <str> + String . format ( <str> , keyspaceReadLatency ) + <str> ) ; System . out . println ( <str> + keyspaceWriteCount ) ; System . out . println ( <str> + String . format ( <str> , keyspaceWriteLatency ) + <str> ) ; System . out . println ( <str> + keyspacePendingFlushes ) ; for ( ColumnFamilyStoreMBean table : columnFamilies ) { String tableName = table . getColumnFamilyName ( ) ; if ( tableName . contains ( <str> ) ) System . out . println ( <str> + tableName ) ; else System . out . println ( <str> + tableName ) ; System . out . println ( <str> + probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) ; int [ ] leveledSStables = table . getSSTableCountPerLevel ( ) ; if ( leveledSStables ! = null ) { System . out . print ( <str> ) ; for ( int level = <int> ; level < leveledSStables . length ; level + + ) { int count = leveledSStables [ level ] ; System . out . print ( count ) ; long maxCount = <int> ; if ( level > <int> ) maxCount = ( long ) Math . pow ( <int> , level ) ; if ( count > maxCount ) System . out . print ( <str> + maxCount ) ; if ( level < leveledSStables . length - <int> ) System . out . print ( <str> ) ; else System . out . println ( <str> ) ; } } Long memtableOffHeapSize = null ; Long bloomFilterOffHeapSize = null ; Long indexSummaryOffHeapSize = null ; Long compressionMetadataOffHeapSize = null ; Long offHeapSize = null ; try { memtableOffHeapSize = ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; bloomFilterOffHeapSize = ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; indexSummaryOffHeapSize = ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; compressionMetadataOffHeapSize = ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; offHeapSize = memtableOffHeapSize + bloomFilterOffHeapSize + indexSummaryOffHeapSize + compressionMetadataOffHeapSize ; } catch ( RuntimeException e ) { if ( ! ( e . getCause ( ) instanceof InstanceNotFoundException ) ) throw e ; } System . out . println ( <str> + format ( ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) , humanReadable ) ) ; System . out . println ( <str> + format ( ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) , humanReadable ) ) ; System . out . println ( <str> + format ( ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) , humanReadable ) ) ; if ( offHeapSize ! = null ) System . out . println ( <str> + format ( offHeapSize , humanReadable ) ) ; System . out . println ( <str> + probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) ; System . out . println ( <str> + probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) ; System . out . println ( <str> + probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) ; System . out . println ( <str> + format ( ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) , humanReadable ) ) ; if ( memtableOffHeapSize ! = null ) System . out . println ( <str> + format ( memtableOffHeapSize , humanReadable ) ) ; System . out . println ( <str> + probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) ; System . out . println ( <str> + ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) . getCount ( ) ) ; double localReadLatency = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) . getMean ( ) / <int> ; double localRLatency = localReadLatency > <int> ? localReadLatency : Double . NaN ; System . out . printf ( <str> , localRLatency ) ; System . out . println ( <str> + ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) . getCount ( ) ) ; double localWriteLatency = ( ( CassandraMetricsRegistry . JmxTimerMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) . getMean ( ) / <int> ; double localWLatency = localWriteLatency > <int> ? localWriteLatency : Double . NaN ; System . out . printf ( <str> , localWLatency ) ; System . out . println ( <str> + probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) ; System . out . println ( <str> + probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) ; System . out . printf ( <str> , String . format ( <str> , probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ) ) ; System . out . println ( <str> + format ( ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) , humanReadable ) ) ; if ( bloomFilterOffHeapSize ! = null ) System . out . println ( <str> + format ( bloomFilterOffHeapSize , humanReadable ) ) ; if ( indexSummaryOffHeapSize ! = null ) System . out . println ( <str> + format ( indexSummaryOffHeapSize , humanReadable ) ) ; if ( compressionMetadataOffHeapSize ! = null ) System . out . println ( <str> + format ( compressionMetadataOffHeapSize , humanReadable ) ) ; System . out . println ( <str> + format ( ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) , humanReadable ) ) ; System . out . println ( <str> + format ( ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) , humanReadable ) ) ; System . out . println ( <str> + format ( ( Long ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) , humanReadable ) ) ; CassandraMetricsRegistry . JmxHistogramMBean histogram = ( CassandraMetricsRegistry . JmxHistogramMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; System . out . println ( <str> + histogram . getMean ( ) ) ; System . out . println ( <str> + histogram . getMax ( ) ) ; histogram = ( CassandraMetricsRegistry . JmxHistogramMBean ) probe . getColumnFamilyMetric ( keyspaceName , tableName , <str> ) ; System . out . println ( <str> + histogram . getMean ( ) ) ; System . out . println ( <str> + histogram . getMax ( ) ) ; System . out . println ( <str> ) ; } System . out . println ( <str> ) ; } } private String format ( long bytes , boolean humanReadable ) { return humanReadable ? FileUtils . stringifyFileSize ( bytes ) : Long . toString ( bytes ) ; } private static class OptionFilter { private Map < String , List < String > > filter = new HashMap < > ( ) ; private Map < String , List < String > > verifier = new HashMap < > ( ) ; private List < String > filterList = new ArrayList < > ( ) ; private boolean ignoreMode ; public OptionFilter ( boolean ignoreMode , List < String > filterList ) { this . filterList . addAll ( filterList ) ; this . ignoreMode = ignoreMode ; for ( String s : filterList ) { String [ ] keyValues = s . split ( <str> , <int> ) ; if ( ! filter . containsKey ( keyValues [ <int> ] ) ) { filter . put ( keyValues [ <int> ] , new ArrayList < String > ( ) ) ; verifier . put ( keyValues [ <int> ] , new ArrayList < String > ( ) ) ; if ( keyValues . length = = <int> ) { filter . get ( keyValues [ <int> ] ) . add ( keyValues [ <int> ] ) ; verifier . get ( keyValues [ <int> ] ) . add ( keyValues [ <int> ] ) ; } } else { if ( keyValues . length = = <int> ) { filter . get ( keyValues [ <int> ] ) . add ( keyValues [ <int> ] ) ; verifier . get ( keyValues [ <int> ] ) . add ( keyValues [ <int> ] ) ; } } } } public boolean isColumnFamilyIncluded ( String keyspace , String columnFamily ) { if ( filterList . isEmpty ( ) ) return ! ignoreMode ; List < String > tables = filter . get ( keyspace ) ; if ( tables = = null ) return ignoreMode ; else if ( tables . size ( ) = = <int> ) return ! ignoreMode ; verifier . get ( keyspace ) . remove ( columnFamily ) ; return ignoreMode ^ tables . contains ( columnFamily ) ; } public void verifyKeyspaces ( List < String > keyspaces ) { for ( String ks : verifier . keySet ( ) ) if ( ! keyspaces . contains ( ks ) ) throw new IllegalArgumentException ( <str> + ks ) ; } public void verifyColumnFamilies ( ) { for ( String ks : filter . keySet ( ) ) if ( verifier . get ( ks ) . size ( ) > <int> ) throw new IllegalArgumentException ( <str> + verifier . get ( ks ) + <str> + ks ) ; } } } 
