package com . google . common . collect ; import static com . google . common . collect . testing . IteratorFeature . UNMODIFIABLE ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . IteratorTester ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import java . util . Iterator ; import java . util . NoSuchElementException ; @GwtCompatible ( emulated = true ) public class AbstractSequentialIteratorTest extends TestCase { @GwtIncompatible ( <str> ) public void testDoublerExhaustive ( ) { new IteratorTester < Integer > ( <int> , UNMODIFIABLE , ImmutableList . of ( <int> , <int> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < Integer > newTargetIterator ( ) { return newDoubler ( <int> , <int> ) ; } } . test ( ) ; } public void testDoubler ( ) { Iterable < Integer > doubled = new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { return newDoubler ( <int> , <int> ) ; } } ; assertThat ( doubled ) . containsExactly ( <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testSampleCode ( ) { Iterable < Integer > actual = new Iterable < Integer > ( ) { @Override public Iterator < Integer > iterator ( ) { Iterator < Integer > powersOfTwo = new AbstractSequentialIterator < Integer > ( <int> ) { protected Integer computeNext ( Integer previous ) { return ( previous = = <int> < < <int> ) ? null : previous * <int> ; } } ; return powersOfTwo ; } } ; assertThat ( actual ) . containsExactly ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testEmpty ( ) { Iterator < Object > empty = newEmpty ( ) ; assertFalse ( empty . hasNext ( ) ) ; try { empty . next ( ) ; fail ( ) ; } catch ( NoSuchElementException expected ) { } try { empty . remove ( ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testBroken ( ) { Iterator < Object > broken = newBroken ( ) ; assertTrue ( broken . hasNext ( ) ) ; try { broken . next ( ) ; fail ( ) ; } catch ( MyException expected ) { } try { broken . next ( ) ; fail ( ) ; } catch ( MyException expected ) { } } private static Iterator < Integer > newDoubler ( int first , final int last ) { return new AbstractSequentialIterator < Integer > ( first ) { @Override protected Integer computeNext ( Integer previous ) { return ( previous = = last ) ? null : previous * <int> ; } } ; } private static < T > Iterator < T > newEmpty ( ) { return new AbstractSequentialIterator < T > ( null ) { @Override protected T computeNext ( T previous ) { throw new AssertionFailedError ( ) ; } } ; } private static Iterator < Object > newBroken ( ) { return new AbstractSequentialIterator < Object > ( <str> ) { @Override protected Object computeNext ( Object previous ) { throw new MyException ( ) ; } } ; } private static class MyException extends RuntimeException { } } 
