package org . gradle . api . internal ; import groovy . lang . Closure ; import groovy . lang . MissingPropertyException ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . internal . plugins . DefaultConvention ; import org . gradle . api . plugins . Convention ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . reflect . JavaReflectionUtil ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . Callable ; public class ConventionAwareHelper implements ConventionMapping , HasConvention { private final Convention _convention ; private final IConventionAware _source ; private final Map < String , MappedPropertyImpl > _mappings = new HashMap < String , MappedPropertyImpl > ( ) ; public ConventionAwareHelper ( IConventionAware source ) { this ( source , new DefaultConvention ( ) ) ; } public ConventionAwareHelper ( IConventionAware source , Convention convention ) { this . _source = source ; this . _convention = convention ; } private static interface Value < T > { T getValue ( Convention convention , IConventionAware conventionAwareObject ) ; } private MappedProperty map ( String propertyName , Value < ? > value ) { if ( ! JavaReflectionUtil . propertyExists ( _source , propertyName ) ) { throw new InvalidUserDataException ( <str> + propertyName ) ; } MappedPropertyImpl mappedProperty = new MappedPropertyImpl ( value ) ; _mappings . put ( propertyName , mappedProperty ) ; return mappedProperty ; } public MappedProperty map ( String propertyName , final Closure < ? > value ) { return map ( propertyName , new Value < Object > ( ) { public Object getValue ( Convention convention , IConventionAware conventionAwareObject ) { switch ( value . getMaximumNumberOfParameters ( ) ) { case <int> : return value . call ( ) ; case <int> : return value . call ( convention ) ; default : return value . call ( convention , conventionAwareObject ) ; } } } ) ; } public MappedProperty map ( String propertyName , final Callable < ? > value ) { return map ( propertyName , new Value < Object > ( ) { public Object getValue ( Convention convention , IConventionAware conventionAwareObject ) { try { return value . call ( ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } ) ; } public void propertyMissing ( String name , Object value ) { if ( value instanceof Closure ) { map ( name , ( Closure ) value ) ; } else { throw new MissingPropertyException ( name , getClass ( ) ) ; } } public < T > T getConventionValue ( T actualValue , String propertyName , boolean isExplicitValue ) { if ( isExplicitValue ) { return actualValue ; } Object returnValue = actualValue ; if ( _mappings . containsKey ( propertyName ) ) { boolean useMapping = true ; if ( actualValue instanceof Collection & & ! ( ( Collection < ? > ) actualValue ) . isEmpty ( ) ) { useMapping = false ; } else if ( actualValue instanceof Map & & ! ( ( Map < ? , ? > ) actualValue ) . isEmpty ( ) ) { useMapping = false ; } if ( useMapping ) { returnValue = _mappings . get ( propertyName ) . getValue ( _convention , _source ) ; } } return ( T ) returnValue ; } public Convention getConvention ( ) { return _convention ; } private static class MappedPropertyImpl implements MappedProperty { private final Value < ? > value ; private boolean haveValue ; private boolean cache ; private Object cachedValue ; private MappedPropertyImpl ( Value < ? > value ) { this . value = value ; } public Object getValue ( Convention convention , IConventionAware conventionAwareObject ) { if ( ! cache ) { return value . getValue ( convention , conventionAwareObject ) ; } if ( ! haveValue ) { cachedValue = value . getValue ( convention , conventionAwareObject ) ; haveValue = true ; } return cachedValue ; } public void cache ( ) { cache = true ; cachedValue = null ; } } } 
