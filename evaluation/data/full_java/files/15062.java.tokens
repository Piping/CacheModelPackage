package org . gradle . nativeplatform . toolchain . internal . gcc . version ; import com . google . common . base . Joiner ; import org . gradle . api . UncheckedIOException ; import org . gradle . nativeplatform . platform . internal . ArchitectureInternal ; import org . gradle . nativeplatform . platform . internal . Architectures ; import org . gradle . nativeplatform . platform . internal . DefaultNativePlatform ; import org . gradle . process . ExecResult ; import org . gradle . process . internal . ExecAction ; import org . gradle . process . internal . ExecActionFactory ; import org . gradle . util . TreeVisitor ; import org . gradle . util . VersionNumber ; import java . io . * ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class GccVersionDeterminer implements CompilerMetaDataProvider { private static final Pattern DEFINE_PATTERN = Pattern . compile ( <str> ) ; private final ExecActionFactory execActionFactory ; private final boolean clang ; public static GccVersionDeterminer forGcc ( ExecActionFactory execActionFactory ) { return new GccVersionDeterminer ( execActionFactory , false ) ; } public static GccVersionDeterminer forClang ( ExecActionFactory execActionFactory ) { return new GccVersionDeterminer ( execActionFactory , true ) ; } GccVersionDeterminer ( ExecActionFactory execActionFactory , boolean expectClang ) { this . execActionFactory = execActionFactory ; this . clang = expectClang ; } public GccVersionResult getGccMetaData ( File gccBinary , List < String > args ) { List < String > allArgs = new ArrayList < String > ( args ) ; allArgs . add ( <str> ) ; allArgs . add ( <str> ) ; allArgs . add ( <str> ) ; String output = transform ( gccBinary , allArgs ) ; if ( output = = null ) { return new BrokenResult ( String . format ( <str> , getDescription ( ) , gccBinary . getName ( ) , Joiner . on ( <str> ) . join ( allArgs ) ) ) ; } return transform ( output , gccBinary ) ; } private String getDescription ( ) { return clang ? <str> : <str> ; } private String transform ( File gccBinary , List < String > args ) { ExecAction exec = execActionFactory . newExecAction ( ) ; exec . executable ( gccBinary . getAbsolutePath ( ) ) ; exec . setWorkingDir ( gccBinary . getParentFile ( ) ) ; exec . args ( args ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; exec . setStandardOutput ( baos ) ; exec . setErrorOutput ( new ByteArrayOutputStream ( ) ) ; exec . setIgnoreExitValue ( true ) ; ExecResult result = exec . execute ( ) ; int exitValue = result . getExitValue ( ) ; if ( exitValue = = <int> ) { return new String ( baos . toByteArray ( ) ) ; } else { return null ; } } private GccVersionResult transform ( String output , File gccBinary ) { BufferedReader reader = new BufferedReader ( new StringReader ( output ) ) ; String line ; Map < String , String > defines = new HashMap < String , String > ( ) ; try { while ( ( line = reader . readLine ( ) ) ! = null ) { Matcher matcher = DEFINE_PATTERN . matcher ( line ) ; if ( ! matcher . matches ( ) ) { return new BrokenResult ( String . format ( <str> , getDescription ( ) , gccBinary . getName ( ) ) ) ; } defines . put ( matcher . group ( <int> ) , matcher . group ( <int> ) ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } if ( ! defines . containsKey ( <str> ) ) { return new BrokenResult ( String . format ( <str> , getDescription ( ) , gccBinary . getName ( ) ) ) ; } int major ; int minor ; int patch ; if ( clang ) { if ( ! defines . containsKey ( <str> ) ) { return new BrokenResult ( String . format ( <str> , gccBinary . getName ( ) ) ) ; } major = toInt ( defines . get ( <str> ) ) ; minor = toInt ( defines . get ( <str> ) ) ; patch = toInt ( defines . get ( <str> ) ) ; } else { if ( defines . containsKey ( <str> ) ) { return new BrokenResult ( String . format ( <str> , gccBinary . getName ( ) ) ) ; } major = toInt ( defines . get ( <str> ) ) ; minor = toInt ( defines . get ( <str> ) ) ; patch = toInt ( defines . get ( <str> ) ) ; } final ArchitectureInternal architecture = determineArchitecture ( defines ) ; return new DefaultGccVersionResult ( new VersionNumber ( major , minor , patch , null ) , architecture , clang ) ; } private ArchitectureInternal determineArchitecture ( Map < String , String > defines ) { boolean i386 = defines . containsKey ( <str> ) ; boolean amd64 = defines . containsKey ( <str> ) ; final ArchitectureInternal architecture ; if ( i386 ) { architecture = Architectures . forInput ( <str> ) ; } else if ( amd64 ) { architecture = Architectures . forInput ( <str> ) ; } else { architecture = DefaultNativePlatform . getCurrentArchitecture ( ) ; } return architecture ; } private int toInt ( String value ) { if ( value = = null ) { return <int> ; } try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException e ) { return <int> ; } } private static class DefaultGccVersionResult implements GccVersionResult { private final VersionNumber scrapedVersion ; private final ArchitectureInternal architecture ; private final boolean clang ; public DefaultGccVersionResult ( VersionNumber scrapedVersion , ArchitectureInternal architecture , boolean clang ) { this . scrapedVersion = scrapedVersion ; this . architecture = architecture ; this . clang = clang ; } public VersionNumber getVersion ( ) { return scrapedVersion ; } public boolean isClang ( ) { return clang ; } public ArchitectureInternal getDefaultArchitecture ( ) { return architecture ; } public boolean isAvailable ( ) { return true ; } public void explain ( TreeVisitor < ? super String > visitor ) { } } private static class BrokenResult implements GccVersionResult { private final String message ; private BrokenResult ( String message ) { this . message = message ; } public VersionNumber getVersion ( ) { throw new UnsupportedOperationException ( ) ; } public boolean isClang ( ) { throw new UnsupportedOperationException ( ) ; } public ArchitectureInternal getDefaultArchitecture ( ) { throw new UnsupportedOperationException ( ) ; } public boolean isAvailable ( ) { return false ; } public void explain ( TreeVisitor < ? super String > visitor ) { visitor . node ( message ) ; } } } 
