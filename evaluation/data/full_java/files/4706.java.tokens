package org . eclipse . debug . ui . actions ; import java . util . Map ; import java . util . WeakHashMap ; import org . eclipse . core . commands . AbstractHandler ; import org . eclipse . core . commands . ExecutionEvent ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . commands . HandlerEvent ; import org . eclipse . core . expressions . IEvaluationContext ; import org . eclipse . debug . core . IRequest ; import org . eclipse . debug . internal . ui . commands . actions . DebugCommandService ; import org . eclipse . debug . internal . ui . commands . actions . ICommandParticipant ; import org . eclipse . debug . internal . ui . commands . actions . IEnabledTarget ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . contexts . DebugContextEvent ; import org . eclipse . debug . ui . contexts . IDebugContextListener ; import org . eclipse . debug . ui . contexts . IDebugContextService ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . IStructuredSelection ; import org . eclipse . ui . ISources ; import org . eclipse . ui . IWindowListener ; import org . eclipse . ui . IWorkbenchWindow ; import org . eclipse . ui . PlatformUI ; import org . eclipse . ui . handlers . HandlerUtil ; public abstract class DebugCommandHandler extends AbstractHandler { private class EnabledTarget implements IEnabledTarget , IDebugContextListener { boolean fEnabled = getInitialEnablement ( ) ; IWorkbenchWindow fWindow ; EnabledTarget ( IWorkbenchWindow window ) { fWindow = window ; } void init ( ) { DebugCommandService . getService ( fWindow ) . updateCommand ( getCommandType ( ) , this ) ; getContextService ( fWindow ) . addDebugContextListener ( this ) ; } @Override public void setEnabled ( boolean enabled ) { boolean oldEnabled = fEnabled ; fEnabled = enabled ; if ( fEnabled ! = oldEnabled & & fCurrentEnabledTarget = = this ) { fireHandlerChanged ( new HandlerEvent ( DebugCommandHandler . this , true , false ) ) ; } } @Override public void debugContextChanged ( DebugContextEvent event ) { DebugCommandService . getService ( fWindow ) . postUpdateCommand ( getCommandType ( ) , this ) ; } void dispose ( ) { if ( isDisposed ( ) ) { return ; } getContextService ( fWindow ) . removeDebugContextListener ( this ) ; fWindow = null ; } boolean isDisposed ( ) { return fWindow = = null ; } } private IWindowListener fWindowListener = new IWindowListener ( ) { @Override public void windowOpened ( IWorkbenchWindow w ) { } @Override public void windowDeactivated ( IWorkbenchWindow w ) { } @Override public void windowClosed ( IWorkbenchWindow w ) { EnabledTarget enabledTarget = fEnabledTargetsMap . get ( w ) ; if ( enabledTarget ! = null ) { enabledTarget . dispose ( ) ; } } @Override public void windowActivated ( IWorkbenchWindow w ) { fCurrentEnabledTarget = fEnabledTargetsMap . get ( w ) ; fireHandlerChanged ( new HandlerEvent ( DebugCommandHandler . this , true , false ) ) ; } } ; private Map < IWorkbenchWindow , EnabledTarget > fEnabledTargetsMap = new WeakHashMap < IWorkbenchWindow , EnabledTarget > ( ) ; private EnabledTarget fCurrentEnabledTarget = null ; public DebugCommandHandler ( ) { super ( ) ; PlatformUI . getWorkbench ( ) . addWindowListener ( fWindowListener ) ; } @Override public void setEnabled ( Object evaluationContext ) { fCurrentEnabledTarget = null ; if ( ! ( evaluationContext instanceof IEvaluationContext ) ) { return ; } IEvaluationContext context = ( IEvaluationContext ) evaluationContext ; Object _window = context . getVariable ( ISources . ACTIVE_WORKBENCH_WINDOW_NAME ) ; if ( _window instanceof IWorkbenchWindow ) { IWorkbenchWindow window = ( IWorkbenchWindow ) _window ; fCurrentEnabledTarget = getEnabledTarget ( window ) ; } } @Override public boolean isEnabled ( ) { if ( fCurrentEnabledTarget = = null ) { return false ; } return fCurrentEnabledTarget . fEnabled ; } private EnabledTarget getEnabledTarget ( IWorkbenchWindow window ) { EnabledTarget target = fEnabledTargetsMap . get ( window ) ; if ( target = = null ) { target = new EnabledTarget ( window ) ; fEnabledTargetsMap . put ( window , target ) ; target . init ( ) ; } return target ; } @Override public Object execute ( ExecutionEvent event ) throws ExecutionException { IWorkbenchWindow window = HandlerUtil . getActiveWorkbenchWindow ( event ) ; if ( window = = null ) { throw new ExecutionException ( <str> ) ; } fCurrentEnabledTarget = getEnabledTarget ( window ) ; ISelection selection = getContextService ( window ) . getActiveContext ( ) ; if ( selection instanceof IStructuredSelection & & isEnabled ( ) ) { IStructuredSelection ss = ( IStructuredSelection ) selection ; boolean enabledAfterExecute = execute ( window , ss . toArray ( ) ) ; fCurrentEnabledTarget . setEnabled ( enabledAfterExecute ) ; } return null ; } private IDebugContextService getContextService ( IWorkbenchWindow window ) { return DebugUITools . getDebugContextManager ( ) . getContextService ( window ) ; } private boolean execute ( IWorkbenchWindow window , final Object [ ] targets ) { DebugCommandService service = DebugCommandService . getService ( window ) ; return service . executeCommand ( getCommandType ( ) , targets , new ICommandParticipant ( ) { @Override public void requestDone ( org . eclipse . debug . core . IRequest request ) { DebugCommandHandler . this . postExecute ( request , targets ) ; } } ) ; } protected void postExecute ( IRequest request , Object [ ] targets ) { } abstract protected Class < ? > getCommandType ( ) ; protected boolean getInitialEnablement ( ) { return false ; } @Override public void dispose ( ) { PlatformUI . getWorkbench ( ) . removeWindowListener ( fWindowListener ) ; for ( EnabledTarget target : fEnabledTargetsMap . values ( ) ) { if ( ! target . isDisposed ( ) ) { target . dispose ( ) ; } } fEnabledTargetsMap . clear ( ) ; fCurrentEnabledTarget = null ; } } 
