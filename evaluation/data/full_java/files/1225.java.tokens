package org . apache . cassandra . utils ; import java . io . FileNotFoundException ; import java . net . SocketException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . io . FSError ; import org . apache . cassandra . io . sstable . CorruptSSTableException ; import org . apache . cassandra . service . CassandraDaemon ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . thrift . Cassandra ; public final class JVMStabilityInspector { private static final Logger logger = LoggerFactory . getLogger ( JVMStabilityInspector . class ) ; private static Killer killer = new Killer ( ) ; private JVMStabilityInspector ( ) { } public static void inspectThrowable ( Throwable t ) { boolean isUnstable = false ; if ( t instanceof OutOfMemoryError ) isUnstable = true ; if ( DatabaseDescriptor . getDiskFailurePolicy ( ) = = Config . DiskFailurePolicy . die ) if ( t instanceof FSError | | t instanceof CorruptSSTableException ) isUnstable = true ; if ( t instanceof FileNotFoundException | | t instanceof SocketException ) if ( t . getMessage ( ) . contains ( <str> ) ) isUnstable = true ; if ( isUnstable ) killer . killCurrentJVM ( t ) ; if ( t . getCause ( ) ! = null ) inspectThrowable ( t . getCause ( ) ) ; } public static void inspectCommitLogThrowable ( Throwable t ) { if ( ! StorageService . instance . isSetupCompleted ( ) ) { logger . error ( <str> , t ) ; killer . killCurrentJVM ( t , true ) ; } else if ( DatabaseDescriptor . getCommitFailurePolicy ( ) = = Config . CommitFailurePolicy . die ) killer . killCurrentJVM ( t ) ; else inspectThrowable ( t ) ; } public static void killCurrentJVM ( Throwable t , boolean quiet ) { killer . killCurrentJVM ( t , quiet ) ; } public static void userFunctionTimeout ( Throwable t ) { switch ( DatabaseDescriptor . getUserFunctionTimeoutPolicy ( ) ) { case die : ScheduledExecutors . nonPeriodicTasks . schedule ( ( ) - > killer . killCurrentJVM ( t ) , <int> , TimeUnit . MILLISECONDS ) ; break ; case die_immediate : killer . killCurrentJVM ( t ) ; break ; case ignore : logger . error ( t . getMessage ( ) ) ; break ; } } @VisibleForTesting public static Killer replaceKiller ( Killer newKiller ) { Killer oldKiller = JVMStabilityInspector . killer ; JVMStabilityInspector . killer = newKiller ; return oldKiller ; } @VisibleForTesting public static class Killer { private final AtomicBoolean killing = new AtomicBoolean ( ) ; protected void killCurrentJVM ( Throwable t ) { killCurrentJVM ( t , false ) ; } protected void killCurrentJVM ( Throwable t , boolean quiet ) { if ( ! quiet ) { t . printStackTrace ( System . err ) ; logger . error ( <str> , t ) ; } if ( killing . compareAndSet ( false , true ) ) { StorageService . instance . removeShutdownHook ( ) ; System . exit ( <int> ) ; } } } } 
