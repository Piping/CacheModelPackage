package org . junit . tests . internal . runners . statements ; import static java . lang . Long . MAX_VALUE ; import static java . lang . Math . atan ; import static java . lang . System . currentTimeMillis ; import static java . lang . Thread . sleep ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static org . hamcrest . core . Is . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . junit . internal . runners . statements . FailOnTimeout . builder ; import java . util . concurrent . TimeUnit ; import org . junit . Rule ; import org . junit . Test ; import org . junit . internal . runners . statements . FailOnTimeout ; import org . junit . rules . ExpectedException ; import org . junit . runners . model . Statement ; import org . junit . runners . model . TestTimedOutException ; public class FailOnTimeoutTest { private static final long TIMEOUT = <int> ; private static final long DURATION_THAT_EXCEEDS_TIMEOUT = <int> * <int> * <int> ; @Rule public final ExpectedException thrown = ExpectedException . none ( ) ; private final TestStatement statement = new TestStatement ( ) ; private final FailOnTimeout failOnTimeout = builder ( ) . withTimeout ( TIMEOUT , MILLISECONDS ) . build ( statement ) ; @Test public void throwsTestTimedOutException ( ) throws Throwable { thrown . expect ( TestTimedOutException . class ) ; evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; } @Test public void throwExceptionWithNiceMessageOnTimeout ( ) throws Throwable { thrown . expectMessage ( <str> ) ; evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; } @Test public void sendUpExceptionThrownByStatement ( ) throws Throwable { RuntimeException exception = new RuntimeException ( ) ; thrown . expect ( is ( exception ) ) ; evaluateWithException ( exception ) ; } @Test public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime ( ) throws Throwable { thrown . expect ( TestTimedOutException . class ) ; evaluateWithWaitDuration ( <int> ) ; evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; } @Test public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException ( ) throws Throwable { thrown . expectMessage ( <str> ) ; try { evaluateWithException ( new RuntimeException ( ) ) ; } catch ( Throwable expected ) { } evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; } @Test public void throwsExceptionWithTimeoutValueAndTimeUnitSet ( ) throws Throwable { try { evaluateWithWaitDuration ( DURATION_THAT_EXCEEDS_TIMEOUT ) ; fail ( <str> ) ; } catch ( TestTimedOutException e ) { assertEquals ( TIMEOUT , e . getTimeout ( ) ) ; assertEquals ( TimeUnit . MILLISECONDS , e . getTimeUnit ( ) ) ; } } private void evaluateWithException ( Exception exception ) throws Throwable { statement . nextException = exception ; statement . waitDuration = <int> ; failOnTimeout . evaluate ( ) ; } private void evaluateWithWaitDuration ( long waitDuration ) throws Throwable { statement . nextException = null ; statement . waitDuration = waitDuration ; failOnTimeout . evaluate ( ) ; } private static final class TestStatement extends Statement { long waitDuration ; Exception nextException ; @Override public void evaluate ( ) throws Throwable { sleep ( waitDuration ) ; if ( nextException ! = null ) { throw nextException ; } } } @Test public void stopEndlessStatement ( ) throws Throwable { InfiniteLoopStatement infiniteLoop = new InfiniteLoopStatement ( ) ; FailOnTimeout infiniteLoopTimeout = builder ( ) . withTimeout ( TIMEOUT , MILLISECONDS ) . build ( infiniteLoop ) ; try { infiniteLoopTimeout . evaluate ( ) ; } catch ( Exception timeoutException ) { sleep ( <int> ) ; int firstCount = InfiniteLoopStatement . COUNT ; sleep ( <int> ) ; assertTrue ( <str> , firstCount = = InfiniteLoopStatement . COUNT ) ; } } private static final class InfiniteLoopStatement extends Statement { private static int COUNT = <int> ; @Override public void evaluate ( ) throws Throwable { while ( true ) { sleep ( <int> ) ; + + COUNT ; } } } @Test public void stackTraceContainsRealCauseOfTimeout ( ) throws Throwable { StuckStatement stuck = new StuckStatement ( ) ; FailOnTimeout stuckTimeout = builder ( ) . withTimeout ( TIMEOUT , MILLISECONDS ) . build ( stuck ) ; try { stuckTimeout . evaluate ( ) ; fail ( <str> ) ; } catch ( Exception timeoutException ) { StackTraceElement [ ] stackTrace = timeoutException . getStackTrace ( ) ; boolean stackTraceContainsTheRealCauseOfTheTimeout = false ; boolean stackTraceContainsOtherThanTheRealCauseOfTheTimeout = false ; for ( StackTraceElement element : stackTrace ) { String methodName = element . getMethodName ( ) ; if ( <str> . equals ( methodName ) ) { stackTraceContainsTheRealCauseOfTheTimeout = true ; } if ( <str> . equals ( methodName ) ) { stackTraceContainsOtherThanTheRealCauseOfTheTimeout = true ; } } assertTrue ( <str> , stackTraceContainsTheRealCauseOfTheTimeout ) ; assertFalse ( <str> , stackTraceContainsOtherThanTheRealCauseOfTheTimeout ) ; } } private static final class StuckStatement extends Statement { @Override public void evaluate ( ) throws Throwable { try { theRealCauseOfTheTimeout ( ) ; } catch ( InterruptedException e ) { } finally { notTheRealCauseOfTheTimeout ( ) ; } } private void theRealCauseOfTheTimeout ( ) throws InterruptedException { sleep ( MAX_VALUE ) ; } private void notTheRealCauseOfTheTimeout ( ) { for ( long now = currentTimeMillis ( ) , eta = now + <int> ; now < eta ; now = currentTimeMillis ( ) ) { atan ( now ) ; } } } } 
