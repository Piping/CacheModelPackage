package io . netty . handler . ssl ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPipeline ; import io . netty . util . internal . ObjectUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; public abstract class ApplicationProtocolNegotiationHandler extends ChannelInboundHandlerAdapter { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ApplicationProtocolNegotiationHandler . class ) ; private final String fallbackProtocol ; private SslHandler sslHandler ; protected ApplicationProtocolNegotiationHandler ( String fallbackProtocol ) { this . fallbackProtocol = ObjectUtil . checkNotNull ( fallbackProtocol , <str> ) ; } @Override public void handlerAdded ( ChannelHandlerContext ctx ) throws Exception { final SslHandler sslHandler = ctx . pipeline ( ) . get ( SslHandler . class ) ; if ( sslHandler = = null ) { throw new IllegalStateException ( <str> ) ; } this . sslHandler = sslHandler ; } @Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { if ( evt instanceof SslHandshakeCompletionEvent ) { ctx . pipeline ( ) . remove ( this ) ; SslHandshakeCompletionEvent handshakeEvent = ( SslHandshakeCompletionEvent ) evt ; if ( handshakeEvent . isSuccess ( ) ) { String protocol = sslHandler . applicationProtocol ( ) ; configurePipeline ( ctx , protocol ! = null ? protocol : fallbackProtocol ) ; } else { handshakeFailure ( ctx , handshakeEvent . cause ( ) ) ; } } ctx . fireUserEventTriggered ( evt ) ; } protected abstract void configurePipeline ( ChannelHandlerContext ctx , String protocol ) throws Exception ; protected void handshakeFailure ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { logger . warn ( <str> , ctx . channel ( ) , cause ) ; ctx . close ( ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { logger . warn ( <str> , ctx . channel ( ) , cause ) ; ctx . close ( ) ; } } 
