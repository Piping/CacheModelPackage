package com . google . common . util . concurrent ; import static com . google . common . truth . Truth . assertThat ; import static com . google . common . util . concurrent . Futures . immediateFuture ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import static com . google . common . util . concurrent . Runnables . doNothing ; import static com . google . common . util . concurrent . TestPlatform . verifyGetOnPendingFuture ; import static com . google . common . util . concurrent . TestPlatform . verifyTimedGetOnPendingFuture ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . annotations . GwtCompatible ; import com . google . common . util . concurrent . AbstractFuture . TrustedFuture ; import junit . framework . TestCase ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeoutException ; @GwtCompatible abstract class AbstractAbstractFutureTest extends TestCase { private TestedFuture < Integer > future ; private AbstractFuture < Integer > delegate ; abstract AbstractFuture < Integer > newDelegate ( ) ; @Override protected void setUp ( ) { future = TestedFuture . create ( ) ; delegate = newDelegate ( ) ; } public void testPending ( ) { assertPending ( future ) ; } public void testSuccessful ( ) throws Exception { assertThat ( future . set ( <int> ) ) . isTrue ( ) ; assertSuccessful ( future , <int> ) ; } public void testFailed ( ) throws Exception { Exception cause = new Exception ( ) ; assertThat ( future . setException ( cause ) ) . isTrue ( ) ; assertFailed ( future , cause ) ; } public void testCanceled ( ) throws Exception { assertThat ( future . cancel ( false ) ) . isTrue ( ) ; assertCancelled ( future , false ) ; } public void testInterrupted ( ) throws Exception { assertThat ( future . cancel ( true ) ) . isTrue ( ) ; assertCancelled ( future , true ) ; } public void testSetFuturePending ( ) throws Exception { assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; assertSetAsynchronously ( future ) ; } public void testSetFutureThenCancel ( ) throws Exception { assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; assertThat ( future . cancel ( false ) ) . isTrue ( ) ; assertCancelled ( future , false ) ; assertCancelled ( delegate , false ) ; } public void testSetFutureThenInterrupt ( ) throws Exception { assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; assertThat ( future . cancel ( true ) ) . isTrue ( ) ; assertCancelled ( future , true ) ; assertCancelled ( delegate , true ) ; } public void testSetFutureDelegateAlreadySuccessful ( ) throws Exception { delegate . set ( <int> ) ; assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; assertSuccessful ( future , <int> ) ; } public void testSetFutureDelegateLaterSuccessful ( ) throws Exception { assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; delegate . set ( <int> ) ; assertSuccessful ( future , <int> ) ; } public void testSetFutureDelegateAlreadyCancelled ( ) throws Exception { delegate . cancel ( false ) ; assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; assertCancelled ( future , false ) ; } public void testSetFutureDelegateLaterCancelled ( ) throws Exception { assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; delegate . cancel ( false ) ; assertCancelled ( future , false ) ; } public void testSetFutureDelegateAlreadyInterrupted ( ) throws Exception { delegate . cancel ( true ) ; assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; assertCancelled ( future , delegate instanceof TrustedFuture ) ; } public void testSetFutureDelegateLaterInterrupted ( ) throws Exception { assertThat ( future . setFuture ( delegate ) ) . isTrue ( ) ; delegate . cancel ( true ) ; assertCancelled ( future , delegate instanceof TrustedFuture ) ; } public void testListenLaterSuccessful ( ) { CountingRunnable listener = new CountingRunnable ( ) ; future . addListener ( listener , directExecutor ( ) ) ; listener . assertNotRun ( ) ; future . set ( <int> ) ; listener . assertRun ( ) ; } public void testListenLaterFailed ( ) { CountingRunnable listener = new CountingRunnable ( ) ; future . addListener ( listener , directExecutor ( ) ) ; listener . assertNotRun ( ) ; future . setException ( new Exception ( ) ) ; listener . assertRun ( ) ; } public void testListenLaterCancelled ( ) { CountingRunnable listener = new CountingRunnable ( ) ; future . addListener ( listener , directExecutor ( ) ) ; listener . assertNotRun ( ) ; future . cancel ( false ) ; listener . assertRun ( ) ; } public void testListenLaterInterrupted ( ) { CountingRunnable listener = new CountingRunnable ( ) ; future . addListener ( listener , directExecutor ( ) ) ; listener . assertNotRun ( ) ; future . cancel ( true ) ; listener . assertRun ( ) ; } public void testListenLaterSetAsynchronously ( ) { CountingRunnable listener = new CountingRunnable ( ) ; future . addListener ( listener , directExecutor ( ) ) ; listener . assertNotRun ( ) ; future . setFuture ( delegate ) ; listener . assertNotRun ( ) ; } public void testListenLaterSetAsynchronouslyLaterDelegateSuccessful ( ) { CountingRunnable before = new CountingRunnable ( ) ; CountingRunnable inBetween = new CountingRunnable ( ) ; CountingRunnable after = new CountingRunnable ( ) ; future . addListener ( before , directExecutor ( ) ) ; future . setFuture ( delegate ) ; future . addListener ( inBetween , directExecutor ( ) ) ; delegate . set ( <int> ) ; future . addListener ( after , directExecutor ( ) ) ; before . assertRun ( ) ; inBetween . assertRun ( ) ; after . assertRun ( ) ; } public void testListenLaterSetAsynchronouslyLaterDelegateFailed ( ) { CountingRunnable before = new CountingRunnable ( ) ; CountingRunnable inBetween = new CountingRunnable ( ) ; CountingRunnable after = new CountingRunnable ( ) ; future . addListener ( before , directExecutor ( ) ) ; future . setFuture ( delegate ) ; future . addListener ( inBetween , directExecutor ( ) ) ; delegate . setException ( new Exception ( ) ) ; future . addListener ( after , directExecutor ( ) ) ; before . assertRun ( ) ; inBetween . assertRun ( ) ; after . assertRun ( ) ; } public void testListenLaterSetAsynchronouslyLaterDelegateCancelled ( ) { CountingRunnable before = new CountingRunnable ( ) ; CountingRunnable inBetween = new CountingRunnable ( ) ; CountingRunnable after = new CountingRunnable ( ) ; future . addListener ( before , directExecutor ( ) ) ; future . setFuture ( delegate ) ; future . addListener ( inBetween , directExecutor ( ) ) ; delegate . cancel ( false ) ; future . addListener ( after , directExecutor ( ) ) ; before . assertRun ( ) ; inBetween . assertRun ( ) ; after . assertRun ( ) ; } public void testListenLaterSetAsynchronouslyLaterDelegateInterrupted ( ) { CountingRunnable before = new CountingRunnable ( ) ; CountingRunnable inBetween = new CountingRunnable ( ) ; CountingRunnable after = new CountingRunnable ( ) ; future . addListener ( before , directExecutor ( ) ) ; future . setFuture ( delegate ) ; future . addListener ( inBetween , directExecutor ( ) ) ; delegate . cancel ( true ) ; future . addListener ( after , directExecutor ( ) ) ; before . assertRun ( ) ; inBetween . assertRun ( ) ; after . assertRun ( ) ; } public void testListenLaterSetAsynchronouslyLaterSelfCancelled ( ) { CountingRunnable before = new CountingRunnable ( ) ; CountingRunnable inBetween = new CountingRunnable ( ) ; CountingRunnable after = new CountingRunnable ( ) ; future . addListener ( before , directExecutor ( ) ) ; future . setFuture ( delegate ) ; future . addListener ( inBetween , directExecutor ( ) ) ; future . cancel ( false ) ; future . addListener ( after , directExecutor ( ) ) ; before . assertRun ( ) ; inBetween . assertRun ( ) ; after . assertRun ( ) ; } public void testListenLaterSetAsynchronouslyLaterSelfInterrupted ( ) { CountingRunnable before = new CountingRunnable ( ) ; CountingRunnable inBetween = new CountingRunnable ( ) ; CountingRunnable after = new CountingRunnable ( ) ; future . addListener ( before , directExecutor ( ) ) ; future . setFuture ( delegate ) ; future . addListener ( inBetween , directExecutor ( ) ) ; future . cancel ( true ) ; future . addListener ( after , directExecutor ( ) ) ; before . assertRun ( ) ; inBetween . assertRun ( ) ; after . assertRun ( ) ; } public void testMisbehavingListenerAlreadyDone ( ) { class BadRunnableException extends RuntimeException { } Runnable bad = new Runnable ( ) { @Override public void run ( ) { throw new BadRunnableException ( ) ; } } ; future . set ( <int> ) ; future . addListener ( bad , directExecutor ( ) ) ; } public void testMisbehavingListenerLaterDone ( ) { class BadRunnableException extends RuntimeException { } CountingRunnable before = new CountingRunnable ( ) ; Runnable bad = new Runnable ( ) { @Override public void run ( ) { throw new BadRunnableException ( ) ; } } ; CountingRunnable after = new CountingRunnable ( ) ; future . addListener ( before , directExecutor ( ) ) ; future . addListener ( bad , directExecutor ( ) ) ; future . addListener ( after , directExecutor ( ) ) ; future . set ( <int> ) ; before . assertRun ( ) ; after . assertRun ( ) ; } public void testNullListener ( ) { try { future . addListener ( null , directExecutor ( ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testNullExecutor ( ) { try { future . addListener ( doNothing ( ) , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testNullTimeUnit ( ) throws Exception { future . set ( <int> ) ; try { future . get ( <int> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testSetNull ( ) throws Exception { future . set ( null ) ; assertSuccessful ( future , null ) ; } public void testSetExceptionNull ( ) throws Exception { try { future . setException ( null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } assertThat ( future . isDone ( ) ) . isFalse ( ) ; assertThat ( future . set ( <int> ) ) . isTrue ( ) ; assertSuccessful ( future , <int> ) ; } public void testSetFutureNull ( ) throws Exception { try { future . setFuture ( null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } assertThat ( future . isDone ( ) ) . isFalse ( ) ; assertThat ( future . set ( <int> ) ) . isTrue ( ) ; assertSuccessful ( future , <int> ) ; } private static class TestedFuture < V > extends AbstractFuture < V > { private static < V > TestedFuture < V > create ( ) { return new TestedFuture < V > ( ) ; } } private static final class CountingRunnable implements Runnable { int count ; @Override public void run ( ) { count + + ; } void assertNotRun ( ) { assertEquals ( <int> , count ) ; } void assertRun ( ) { assertEquals ( <int> , count ) ; } } private static void assertSetAsynchronously ( AbstractFuture < Integer > future ) { assertCannotSet ( future ) ; assertPending ( future ) ; } private static void assertPending ( AbstractFuture < Integer > future ) { assertThat ( future . isDone ( ) ) . isFalse ( ) ; assertThat ( future . isCancelled ( ) ) . isFalse ( ) ; CountingRunnable listener = new CountingRunnable ( ) ; future . addListener ( listener , directExecutor ( ) ) ; listener . assertNotRun ( ) ; verifyGetOnPendingFuture ( future ) ; verifyTimedGetOnPendingFuture ( future ) ; } private static void assertSuccessful ( AbstractFuture < Integer > future , Integer expectedResult ) throws InterruptedException , TimeoutException , ExecutionException { assertDone ( future ) ; assertThat ( future . isCancelled ( ) ) . isFalse ( ) ; assertThat ( future . get ( ) ) . isEqualTo ( expectedResult ) ; assertThat ( future . get ( <int> , SECONDS ) ) . isEqualTo ( expectedResult ) ; assertThat ( future . get ( - <int> , SECONDS ) ) . isEqualTo ( expectedResult ) ; } private static void assertFailed ( AbstractFuture < Integer > future , Throwable expectedException ) throws InterruptedException , TimeoutException { assertDone ( future ) ; assertThat ( future . isCancelled ( ) ) . isFalse ( ) ; try { future . get ( ) ; fail ( ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) ) . isSameAs ( expectedException ) ; } try { future . get ( <int> , SECONDS ) ; fail ( ) ; } catch ( ExecutionException e ) { assertThat ( e . getCause ( ) ) . isSameAs ( expectedException ) ; } } private static void assertCancelled ( AbstractFuture < Integer > future , boolean expectWasInterrupted ) throws InterruptedException , TimeoutException , ExecutionException { assertDone ( future ) ; assertThat ( future . isCancelled ( ) ) . isTrue ( ) ; assertThat ( future . wasInterrupted ( ) ) . isEqualTo ( expectWasInterrupted ) ; try { future . get ( ) ; fail ( ) ; } catch ( CancellationException expected ) { } try { future . get ( <int> , SECONDS ) ; fail ( ) ; } catch ( CancellationException expected ) { } } private static void assertDone ( AbstractFuture < Integer > future ) { CountingRunnable listener = new CountingRunnable ( ) ; future . addListener ( listener , directExecutor ( ) ) ; listener . assertRun ( ) ; assertThat ( future . isDone ( ) ) . isTrue ( ) ; assertCannotSet ( future ) ; assertCannotCancel ( future ) ; } private static void assertCannotSet ( AbstractFuture < Integer > future ) { assertThat ( future . set ( <int> ) ) . isFalse ( ) ; assertThat ( future . setException ( new IndexOutOfBoundsException ( ) ) ) . isFalse ( ) ; assertThat ( future . setFuture ( new AbstractFuture < Integer > ( ) { } ) ) . isFalse ( ) ; assertThat ( future . setFuture ( immediateFuture ( <int> ) ) ) . isFalse ( ) ; } private static void assertCannotCancel ( AbstractFuture < Integer > future ) { assertThat ( future . cancel ( true ) ) . isFalse ( ) ; assertThat ( future . cancel ( false ) ) . isFalse ( ) ; } } 
