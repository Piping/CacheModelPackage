package org . elasticsearch . index ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . lucene . uid . Versions ; import java . io . IOException ; public enum VersionType implements Writeable < VersionType > { INTERNAL ( ( byte ) <int> ) { @Override public boolean isVersionConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) { return isVersionConflict ( currentVersion , expectedVersion , deleted ) ; } @Override public String explainConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) { if ( expectedVersion = = Versions . MATCH_DELETED ) { return <str> + currentVersion + <str> ; } return <str> + currentVersion + <str> + expectedVersion + <str> ; } @Override public boolean isVersionConflictForReads ( long currentVersion , long expectedVersion ) { return isVersionConflict ( currentVersion , expectedVersion , false ) ; } @Override public String explainConflictForReads ( long currentVersion , long expectedVersion ) { return <str> + currentVersion + <str> + expectedVersion + <str> ; } private boolean isVersionConflict ( long currentVersion , long expectedVersion , boolean deleted ) { if ( currentVersion = = Versions . NOT_SET ) { return false ; } if ( expectedVersion = = Versions . MATCH_ANY ) { return false ; } if ( expectedVersion = = Versions . MATCH_DELETED ) { return deleted = = false ; } if ( currentVersion ! = expectedVersion ) { return true ; } return false ; } @Override public long updateVersion ( long currentVersion , long expectedVersion ) { return ( currentVersion = = Versions . NOT_SET | | currentVersion = = Versions . NOT_FOUND ) ? <int> : currentVersion + <int> ; } @Override public boolean validateVersionForWrites ( long version ) { return version > <int> L | | version = = Versions . MATCH_ANY | | version = = Versions . MATCH_DELETED ; } @Override public boolean validateVersionForReads ( long version ) { return version > <int> L | | version = = Versions . MATCH_ANY ; } @Override public VersionType versionTypeForReplicationAndRecovery ( ) { return EXTERNAL ; } } , EXTERNAL ( ( byte ) <int> ) { @Override public boolean isVersionConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) { if ( currentVersion = = Versions . NOT_SET ) { return false ; } if ( currentVersion = = Versions . NOT_FOUND ) { return false ; } if ( expectedVersion = = Versions . MATCH_ANY ) { return true ; } if ( currentVersion > = expectedVersion ) { return true ; } return false ; } @Override public String explainConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) { return <str> + currentVersion + <str> + expectedVersion + <str> ; } @Override public boolean isVersionConflictForReads ( long currentVersion , long expectedVersion ) { if ( currentVersion = = Versions . NOT_SET ) { return false ; } if ( expectedVersion = = Versions . MATCH_ANY ) { return false ; } if ( currentVersion = = Versions . NOT_FOUND ) { return true ; } if ( currentVersion ! = expectedVersion ) { return true ; } return false ; } @Override public String explainConflictForReads ( long currentVersion , long expectedVersion ) { return <str> + currentVersion + <str> + expectedVersion + <str> ; } @Override public long updateVersion ( long currentVersion , long expectedVersion ) { return expectedVersion ; } @Override public boolean validateVersionForWrites ( long version ) { return version > = <int> L ; } @Override public boolean validateVersionForReads ( long version ) { return version > = <int> L | | version = = Versions . MATCH_ANY ; } } , EXTERNAL_GTE ( ( byte ) <int> ) { @Override public boolean isVersionConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) { if ( currentVersion = = Versions . NOT_SET ) { return false ; } if ( currentVersion = = Versions . NOT_FOUND ) { return false ; } if ( expectedVersion = = Versions . MATCH_ANY ) { return true ; } if ( currentVersion > expectedVersion ) { return true ; } return false ; } @Override public String explainConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) { return <str> + currentVersion + <str> + expectedVersion + <str> ; } @Override public boolean isVersionConflictForReads ( long currentVersion , long expectedVersion ) { if ( currentVersion = = Versions . NOT_SET ) { return false ; } if ( expectedVersion = = Versions . MATCH_ANY ) { return false ; } if ( currentVersion = = Versions . NOT_FOUND ) { return true ; } if ( currentVersion ! = expectedVersion ) { return true ; } return false ; } @Override public String explainConflictForReads ( long currentVersion , long expectedVersion ) { return <str> + currentVersion + <str> + expectedVersion + <str> ; } @Override public long updateVersion ( long currentVersion , long expectedVersion ) { return expectedVersion ; } @Override public boolean validateVersionForWrites ( long version ) { return version > = <int> L ; } @Override public boolean validateVersionForReads ( long version ) { return version > = <int> L | | version = = Versions . MATCH_ANY ; } } , FORCE ( ( byte ) <int> ) { @Override public boolean isVersionConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) { if ( currentVersion = = Versions . NOT_SET ) { return false ; } if ( currentVersion = = Versions . NOT_FOUND ) { return false ; } if ( expectedVersion = = Versions . MATCH_ANY ) { throw new IllegalStateException ( <str> ) ; } return false ; } @Override public String explainConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) { throw new AssertionError ( <str> ) ; } @Override public boolean isVersionConflictForReads ( long currentVersion , long expectedVersion ) { return false ; } @Override public String explainConflictForReads ( long currentVersion , long expectedVersion ) { throw new AssertionError ( <str> ) ; } @Override public long updateVersion ( long currentVersion , long expectedVersion ) { return expectedVersion ; } @Override public boolean validateVersionForWrites ( long version ) { return version > = <int> L ; } @Override public boolean validateVersionForReads ( long version ) { return version > = <int> L | | version = = Versions . MATCH_ANY ; } } ; private final byte value ; private static final VersionType PROTOTYPE = INTERNAL ; VersionType ( byte value ) { this . value = value ; } public byte getValue ( ) { return value ; } public abstract boolean isVersionConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) ; public abstract String explainConflictForWrites ( long currentVersion , long expectedVersion , boolean deleted ) ; public abstract boolean isVersionConflictForReads ( long currentVersion , long expectedVersion ) ; public abstract String explainConflictForReads ( long currentVersion , long expectedVersion ) ; public abstract long updateVersion ( long currentVersion , long expectedVersion ) ; public abstract boolean validateVersionForWrites ( long version ) ; public abstract boolean validateVersionForReads ( long version ) ; public VersionType versionTypeForReplicationAndRecovery ( ) { return this ; } public static VersionType fromString ( String versionType ) { if ( <str> . equals ( versionType ) ) { return INTERNAL ; } else if ( <str> . equals ( versionType ) ) { return EXTERNAL ; } else if ( <str> . equals ( versionType ) ) { return EXTERNAL ; } else if ( <str> . equals ( versionType ) ) { return EXTERNAL_GTE ; } else if ( <str> . equals ( versionType ) ) { return FORCE ; } throw new IllegalArgumentException ( <str> + versionType + <str> ) ; } public static VersionType fromString ( String versionType , VersionType defaultVersionType ) { if ( versionType = = null ) { return defaultVersionType ; } return fromString ( versionType ) ; } public static VersionType fromValue ( byte value ) { if ( value = = <int> ) { return INTERNAL ; } else if ( value = = <int> ) { return EXTERNAL ; } else if ( value = = <int> ) { return EXTERNAL_GTE ; } else if ( value = = <int> ) { return FORCE ; } throw new IllegalArgumentException ( <str> + value + <str> ) ; } @Override public VersionType readFrom ( StreamInput in ) throws IOException { int ordinal = in . readVInt ( ) ; assert ( ordinal = = <int> | | ordinal = = <int> | | ordinal = = <int> | | ordinal = = <int> ) ; return VersionType . values ( ) [ ordinal ] ; } public static VersionType readVersionTypeFrom ( StreamInput in ) throws IOException { return PROTOTYPE . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeVInt ( ordinal ( ) ) ; } } 
