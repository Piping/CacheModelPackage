package io . netty . channel . nio ; import java . nio . channels . SelectionKey ; import java . util . AbstractSet ; import java . util . Iterator ; final class SelectedSelectionKeySet extends AbstractSet < SelectionKey > { private SelectionKey [ ] keysA ; private int keysASize ; private SelectionKey [ ] keysB ; private int keysBSize ; private boolean isA = true ; SelectedSelectionKeySet ( ) { keysA = new SelectionKey [ <int> ] ; keysB = keysA . clone ( ) ; } @Override public boolean add ( SelectionKey o ) { if ( o = = null ) { return false ; } if ( isA ) { int size = keysASize ; keysA [ size + + ] = o ; keysASize = size ; if ( size = = keysA . length ) { doubleCapacityA ( ) ; } } else { int size = keysBSize ; keysB [ size + + ] = o ; keysBSize = size ; if ( size = = keysB . length ) { doubleCapacityB ( ) ; } } return true ; } private void doubleCapacityA ( ) { SelectionKey [ ] newKeysA = new SelectionKey [ keysA . length < < <int> ] ; System . arraycopy ( keysA , <int> , newKeysA , <int> , keysASize ) ; keysA = newKeysA ; } private void doubleCapacityB ( ) { SelectionKey [ ] newKeysB = new SelectionKey [ keysB . length < < <int> ] ; System . arraycopy ( keysB , <int> , newKeysB , <int> , keysBSize ) ; keysB = newKeysB ; } SelectionKey [ ] flip ( ) { if ( isA ) { isA = false ; keysA [ keysASize ] = null ; keysBSize = <int> ; return keysA ; } else { isA = true ; keysB [ keysBSize ] = null ; keysASize = <int> ; return keysB ; } } @Override public int size ( ) { if ( isA ) { return keysASize ; } else { return keysBSize ; } } @Override public boolean remove ( Object o ) { return false ; } @Override public boolean contains ( Object o ) { return false ; } @Override public Iterator < SelectionKey > iterator ( ) { throw new UnsupportedOperationException ( ) ; } } 
