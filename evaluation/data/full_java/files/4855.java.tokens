package org . eclipse . ui . externaltools . internal . model ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . widgets . Display ; import org . eclipse . core . runtime . Assert ; import org . eclipse . jface . resource . ImageDescriptor ; public class ImageDescriptorRegistry { private Map < ImageDescriptor , Image > fRegistry = Collections . synchronizedMap ( new HashMap < ImageDescriptor , Image > ( <int> ) ) ; private Display fDisplay ; public ImageDescriptorRegistry ( ) { this ( ExternalToolsPlugin . getStandardDisplay ( ) ) ; } public ImageDescriptorRegistry ( Display display ) { fDisplay = display ; Assert . isNotNull ( fDisplay ) ; hookDisplay ( ) ; } public Image get ( ImageDescriptor descriptor ) { Image result = fRegistry . get ( descriptor ! = null ? descriptor : ImageDescriptor . getMissingImageDescriptor ( ) ) ; if ( result ! = null ) { return result ; } Assert . isTrue ( fDisplay = = ExternalToolsPlugin . getStandardDisplay ( ) , ExternalToolsModelMessages . ImageDescriptorRegistry_Allocating_image_for_wrong_display_1 ) ; result = descriptor ! = null ? descriptor . createImage ( ) : ImageDescriptor . getMissingImageDescriptor ( ) . createImage ( ) ; if ( result ! = null ) { fRegistry . put ( descriptor , result ) ; } return result ; } public void dispose ( ) { for ( Image image : fRegistry . values ( ) ) { image . dispose ( ) ; } fRegistry . clear ( ) ; } private void hookDisplay ( ) { fDisplay . asyncExec ( new Runnable ( ) { @Override public void run ( ) { fDisplay . disposeExec ( new Runnable ( ) { @Override public void run ( ) { dispose ( ) ; } } ) ; } } ) ; } } 
