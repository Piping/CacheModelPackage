package com . google . common . base ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import static java . lang . Character . MAX_SURROGATE ; import static java . lang . Character . MIN_SURROGATE ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import javax . annotation . CheckReturnValue ; @Beta @GwtCompatible public final class Utf8 { @CheckReturnValue public static int encodedLength ( CharSequence sequence ) { int utf16Length = sequence . length ( ) ; int utf8Length = utf16Length ; int i = <int> ; while ( i < utf16Length & & sequence . charAt ( i ) < <hex> ) { i + + ; } for ( ; i < utf16Length ; i + + ) { char c = sequence . charAt ( i ) ; if ( c < <hex> ) { utf8Length + = ( ( <hex> - c ) > > > <int> ) ; } else { utf8Length + = encodedLengthGeneral ( sequence , i ) ; break ; } } if ( utf8Length < utf16Length ) { throw new IllegalArgumentException ( <str> + ( utf8Length + ( <int> < < <int> ) ) ) ; } return utf8Length ; } private static int encodedLengthGeneral ( CharSequence sequence , int start ) { int utf16Length = sequence . length ( ) ; int utf8Length = <int> ; for ( int i = start ; i < utf16Length ; i + + ) { char c = sequence . charAt ( i ) ; if ( c < <hex> ) { utf8Length + = ( <hex> - c ) > > > <int> ; } else { utf8Length + = <int> ; if ( MIN_SURROGATE < = c & & c < = MAX_SURROGATE ) { if ( Character . codePointAt ( sequence , i ) = = c ) { throw new IllegalArgumentException ( unpairedSurrogateMsg ( i ) ) ; } i + + ; } } } return utf8Length ; } @CheckReturnValue public static boolean isWellFormed ( byte [ ] bytes ) { return isWellFormed ( bytes , <int> , bytes . length ) ; } @CheckReturnValue public static boolean isWellFormed ( byte [ ] bytes , int off , int len ) { int end = off + len ; checkPositionIndexes ( off , end , bytes . length ) ; for ( int i = off ; i < end ; i + + ) { if ( bytes [ i ] < <int> ) { return isWellFormedSlowPath ( bytes , i , end ) ; } } return true ; } private static boolean isWellFormedSlowPath ( byte [ ] bytes , int off , int end ) { int index = off ; while ( true ) { int byte1 ; do { if ( index > = end ) { return true ; } } while ( ( byte1 = bytes [ index + + ] ) > = <int> ) ; if ( byte1 < ( byte ) <hex> ) { if ( index = = end ) { return false ; } if ( byte1 < ( byte ) <hex> | | bytes [ index + + ] > ( byte ) <hex> ) { return false ; } } else if ( byte1 < ( byte ) <hex> ) { if ( index + <int> > = end ) { return false ; } int byte2 = bytes [ index + + ] ; if ( byte2 > ( byte ) <hex> | | ( byte1 = = ( byte ) <hex> & & byte2 < ( byte ) <hex> ) | | ( byte1 = = ( byte ) <hex> & & ( byte ) <hex> < = byte2 ) | | bytes [ index + + ] > ( byte ) <hex> ) { return false ; } } else { if ( index + <int> > = end ) { return false ; } int byte2 = bytes [ index + + ] ; if ( byte2 > ( byte ) <hex> | | ( ( ( byte1 < < <int> ) + ( byte2 - ( byte ) <hex> ) ) > > <int> ) ! = <int> | | bytes [ index + + ] > ( byte ) <hex> | | bytes [ index + + ] > ( byte ) <hex> ) { return false ; } } } } private static String unpairedSurrogateMsg ( int i ) { return <str> + i ; } private Utf8 ( ) { } } 
