package io . netty . handler . codec . http . cors ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . http . DefaultFullHttpRequest ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpRequest ; import io . netty . handler . codec . http . HttpMethod ; import io . netty . handler . codec . http . HttpResponse ; import org . junit . Test ; import java . util . Arrays ; import java . util . concurrent . Callable ; import static io . netty . handler . codec . http . HttpHeaderNames . ACCESS_CONTROL_ALLOW_CREDENTIALS ; import static io . netty . handler . codec . http . HttpHeaderNames . ACCESS_CONTROL_ALLOW_HEADERS ; import static io . netty . handler . codec . http . HttpHeaderNames . ACCESS_CONTROL_ALLOW_METHODS ; import static io . netty . handler . codec . http . HttpHeaderNames . ACCESS_CONTROL_ALLOW_ORIGIN ; import static io . netty . handler . codec . http . HttpHeaderNames . ACCESS_CONTROL_EXPOSE_HEADERS ; import static io . netty . handler . codec . http . HttpHeaderNames . ACCESS_CONTROL_REQUEST_HEADERS ; import static io . netty . handler . codec . http . HttpHeaderNames . ACCESS_CONTROL_REQUEST_METHOD ; import static io . netty . handler . codec . http . HttpHeaderNames . CONTENT_LENGTH ; import static io . netty . handler . codec . http . HttpHeaderNames . DATE ; import static io . netty . handler . codec . http . HttpHeaderNames . ORIGIN ; import static io . netty . handler . codec . http . HttpHeaderNames . VARY ; import static io . netty . handler . codec . http . HttpHeadersTestUtils . of ; import static io . netty . handler . codec . http . HttpMethod . DELETE ; import static io . netty . handler . codec . http . HttpMethod . GET ; import static io . netty . handler . codec . http . HttpMethod . OPTIONS ; import static io . netty . handler . codec . http . HttpResponseStatus . FORBIDDEN ; import static io . netty . handler . codec . http . HttpResponseStatus . OK ; import static io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; import static org . hamcrest . CoreMatchers . containsString ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . notNullValue ; import static org . hamcrest . CoreMatchers . nullValue ; import static org . hamcrest . MatcherAssert . assertThat ; public class CorsHandlerTest { @Test public void nonCorsRequest ( ) { final HttpResponse response = simpleRequest ( CorsConfig . withAnyOrigin ( ) . build ( ) , null ) ; assertThat ( response . headers ( ) . contains ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( false ) ) ; } @Test public void simpleRequestWithAnyOrigin ( ) { final HttpResponse response = simpleRequest ( CorsConfig . withAnyOrigin ( ) . build ( ) , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( <str> ) ) ; } @Test public void simpleRequestWithOrigin ( ) { final String origin = <str> ; final HttpResponse response = simpleRequest ( CorsConfig . withOrigin ( origin ) . build ( ) , origin ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( origin ) ) ; } @Test public void simpleRequestWithOrigins ( ) { final String origin1 = <str> ; final String origin2 = <str> ; final String [ ] origins = { origin1 , origin2 } ; final HttpResponse response1 = simpleRequest ( CorsConfig . withOrigins ( origins ) . build ( ) , origin1 ) ; assertThat ( response1 . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( origin1 ) ) ; final HttpResponse response2 = simpleRequest ( CorsConfig . withOrigins ( origins ) . build ( ) , origin2 ) ; assertThat ( response2 . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( origin2 ) ) ; } @Test public void simpleRequestWithNoMatchingOrigin ( ) { final String origin = <str> ; final HttpResponse response = simpleRequest ( CorsConfig . withOrigins ( <str> ) . build ( ) , origin ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( nullValue ( ) ) ) ; } @Test public void preflightDeleteRequestWithCustomHeaders ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . allowedRequestMethods ( GET , DELETE ) . build ( ) ; final HttpResponse response = preflightRequest ( config , <str> , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_METHODS ) , containsString ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_METHODS ) , containsString ( <str> ) ) ; assertThat ( response . headers ( ) . get ( VARY ) , equalTo ( ORIGIN . toString ( ) ) ) ; } @Test public void preflightGetRequestWithCustomHeaders ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . allowedRequestMethods ( OPTIONS , GET , DELETE ) . allowedRequestHeaders ( <str> , <str> ) . build ( ) ; final HttpResponse response = preflightRequest ( config , <str> , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_METHODS ) , containsString ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_METHODS ) , containsString ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_HEADERS ) , containsString ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_HEADERS ) , containsString ( <str> ) ) ; assertThat ( response . headers ( ) . get ( VARY ) , equalTo ( ORIGIN . toString ( ) ) ) ; } @Test public void preflightRequestWithDefaultHeaders ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . build ( ) ; final HttpResponse response = preflightRequest ( config , <str> , <str> ) ; assertThat ( response . headers ( ) . get ( CONTENT_LENGTH ) , is ( <str> ) ) ; assertThat ( response . headers ( ) . get ( DATE ) , is ( notNullValue ( ) ) ) ; assertThat ( response . headers ( ) . get ( VARY ) , equalTo ( ORIGIN . toString ( ) ) ) ; } @Test public void preflightRequestWithCustomHeader ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . preflightResponseHeader ( <str> , <str> ) . build ( ) ; final HttpResponse response = preflightRequest ( config , <str> , <str> ) ; assertThat ( response . headers ( ) . get ( of ( <str> ) ) , equalTo ( <str> ) ) ; assertThat ( response . headers ( ) . get ( VARY ) , equalTo ( ORIGIN . toString ( ) ) ) ; } @Test public void preflightRequestWithCustomHeaders ( ) { final String headerName = <str> ; final String value1 = <str> ; final String value2 = <str> ; final CorsConfig config = CorsConfig . withOrigin ( <str> ) . preflightResponseHeader ( headerName , value1 , value2 ) . build ( ) ; final HttpResponse response = preflightRequest ( config , <str> , <str> ) ; assertValues ( response , headerName , value1 , value2 ) ; assertThat ( response . headers ( ) . get ( VARY ) , equalTo ( ORIGIN . toString ( ) ) ) ; } @Test public void preflightRequestWithCustomHeadersIterable ( ) { final String headerName = <str> ; final String value1 = <str> ; final String value2 = <str> ; final CorsConfig config = CorsConfig . withOrigin ( <str> ) . preflightResponseHeader ( headerName , Arrays . asList ( value1 , value2 ) ) . build ( ) ; final HttpResponse response = preflightRequest ( config , <str> , <str> ) ; assertValues ( response , headerName , value1 , value2 ) ; assertThat ( response . headers ( ) . get ( VARY ) , equalTo ( ORIGIN . toString ( ) ) ) ; } @Test public void preflightRequestWithValueGenerator ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . preflightResponseHeader ( <str> , new Callable < String > ( ) { @Override public String call ( ) throws Exception { return <str> ; } } ) . build ( ) ; final HttpResponse response = preflightRequest ( config , <str> , <str> ) ; assertThat ( response . headers ( ) . get ( of ( <str> ) ) , equalTo ( <str> ) ) ; assertThat ( response . headers ( ) . get ( VARY ) , equalTo ( ORIGIN . toString ( ) ) ) ; } @Test public void preflightRequestWithNullOrigin ( ) { final String origin = <str> ; final CorsConfig config = CorsConfig . withOrigin ( origin ) . allowNullOrigin ( ) . allowCredentials ( ) . build ( ) ; final HttpResponse response = preflightRequest ( config , origin , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( equalTo ( <str> ) ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_CREDENTIALS ) , is ( nullValue ( ) ) ) ; } @Test public void preflightRequestAllowCredentials ( ) { final String origin = <str> ; final CorsConfig config = CorsConfig . withOrigin ( origin ) . allowCredentials ( ) . build ( ) ; final HttpResponse response = preflightRequest ( config , origin , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_CREDENTIALS ) , is ( equalTo ( <str> ) ) ) ; } @Test public void preflightRequestDoNotAllowCredentials ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . build ( ) ; final HttpResponse response = preflightRequest ( config , <str> , <str> ) ; assertThat ( response . headers ( ) . contains ( ACCESS_CONTROL_ALLOW_CREDENTIALS ) , is ( false ) ) ; } @Test public void simpleRequestCustomHeaders ( ) { final CorsConfig config = CorsConfig . withAnyOrigin ( ) . exposeHeaders ( <str> , <str> ) . build ( ) ; final HttpResponse response = simpleRequest ( config , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , equalTo ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_EXPOSE_HEADERS ) , containsString ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_EXPOSE_HEADERS ) , containsString ( <str> ) ) ; } @Test public void simpleRequestAllowCredentials ( ) { final CorsConfig config = CorsConfig . withAnyOrigin ( ) . allowCredentials ( ) . build ( ) ; final HttpResponse response = simpleRequest ( config , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_CREDENTIALS ) , equalTo ( <str> ) ) ; } @Test public void simpleRequestDoNotAllowCredentials ( ) { final CorsConfig config = CorsConfig . withAnyOrigin ( ) . build ( ) ; final HttpResponse response = simpleRequest ( config , <str> ) ; assertThat ( response . headers ( ) . contains ( ACCESS_CONTROL_ALLOW_CREDENTIALS ) , is ( false ) ) ; } @Test public void anyOriginAndAllowCredentialsShouldEchoRequestOrigin ( ) { final CorsConfig config = CorsConfig . withAnyOrigin ( ) . allowCredentials ( ) . build ( ) ; final HttpResponse response = simpleRequest ( config , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_CREDENTIALS ) , equalTo ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , equalTo ( <str> ) ) ; assertThat ( response . headers ( ) . get ( VARY ) , equalTo ( ORIGIN . toString ( ) ) ) ; } @Test public void simpleRequestExposeHeaders ( ) { final CorsConfig config = CorsConfig . withAnyOrigin ( ) . exposeHeaders ( <str> , <str> ) . build ( ) ; final HttpResponse response = simpleRequest ( config , <str> ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_EXPOSE_HEADERS ) , containsString ( <str> ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_EXPOSE_HEADERS ) , containsString ( <str> ) ) ; } @Test public void simpleRequestShortCurcuit ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . shortCurcuit ( ) . build ( ) ; final HttpResponse response = simpleRequest ( config , <str> ) ; assertThat ( response . status ( ) , is ( FORBIDDEN ) ) ; } @Test public void simpleRequestNoShortCurcuit ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . build ( ) ; final HttpResponse response = simpleRequest ( config , <str> ) ; assertThat ( response . status ( ) , is ( OK ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( nullValue ( ) ) ) ; } @Test public void shortCurcuitNonCorsRequest ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . shortCurcuit ( ) . build ( ) ; final HttpResponse response = simpleRequest ( config , null ) ; assertThat ( response . status ( ) , is ( OK ) ) ; assertThat ( response . headers ( ) . get ( ACCESS_CONTROL_ALLOW_ORIGIN ) , is ( nullValue ( ) ) ) ; } @Test public void preflightRequestShouldReleaseRequest ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . preflightResponseHeader ( <str> , Arrays . asList ( <str> , <str> ) ) . build ( ) ; final EmbeddedChannel channel = new EmbeddedChannel ( new CorsHandler ( config ) ) ; final FullHttpRequest request = optionsRequest ( <str> , <str> ) ; channel . writeInbound ( request ) ; assertThat ( request . refCnt ( ) , is ( <int> ) ) ; } @Test public void forbiddenShouldReleaseRequest ( ) { final CorsConfig config = CorsConfig . withOrigin ( <str> ) . shortCurcuit ( ) . build ( ) ; final EmbeddedChannel channel = new EmbeddedChannel ( new CorsHandler ( config ) , new EchoHandler ( ) ) ; final FullHttpRequest request = createHttpRequest ( GET ) ; request . headers ( ) . set ( ORIGIN , <str> ) ; channel . writeInbound ( request ) ; assertThat ( request . refCnt ( ) , is ( <int> ) ) ; } private static HttpResponse simpleRequest ( final CorsConfig config , final String origin ) { return simpleRequest ( config , origin , null ) ; } private static HttpResponse simpleRequest ( final CorsConfig config , final String origin , final String requestHeaders ) { return simpleRequest ( config , origin , requestHeaders , GET ) ; } private static HttpResponse simpleRequest ( final CorsConfig config , final String origin , final String requestHeaders , final HttpMethod method ) { final EmbeddedChannel channel = new EmbeddedChannel ( new CorsHandler ( config ) , new EchoHandler ( ) ) ; final FullHttpRequest httpRequest = createHttpRequest ( method ) ; if ( origin ! = null ) { httpRequest . headers ( ) . set ( ORIGIN , origin ) ; } if ( requestHeaders ! = null ) { httpRequest . headers ( ) . set ( ACCESS_CONTROL_REQUEST_HEADERS , requestHeaders ) ; } channel . writeInbound ( httpRequest ) ; return ( HttpResponse ) channel . readOutbound ( ) ; } private static HttpResponse preflightRequest ( final CorsConfig config , final String origin , final String requestHeaders ) { final EmbeddedChannel channel = new EmbeddedChannel ( new CorsHandler ( config ) ) ; channel . writeInbound ( optionsRequest ( origin , requestHeaders ) ) ; return ( HttpResponse ) channel . readOutbound ( ) ; } private static FullHttpRequest optionsRequest ( final String origin , final String requestHeaders ) { final FullHttpRequest httpRequest = createHttpRequest ( OPTIONS ) ; httpRequest . headers ( ) . set ( ORIGIN , origin ) ; httpRequest . headers ( ) . set ( ACCESS_CONTROL_REQUEST_METHOD , httpRequest . method ( ) . toString ( ) ) ; httpRequest . headers ( ) . set ( ACCESS_CONTROL_REQUEST_HEADERS , requestHeaders ) ; return httpRequest ; } private static FullHttpRequest createHttpRequest ( HttpMethod method ) { return new DefaultFullHttpRequest ( HTTP_1_1 , method , <str> ) ; } private static class EchoHandler extends SimpleChannelInboundHandler < Object > { @Override public void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { ctx . writeAndFlush ( new DefaultFullHttpResponse ( HTTP_1_1 , OK , true , true ) ) ; } } private static void assertValues ( final HttpResponse response , final String headerName , final String . . . values ) { final String header = response . headers ( ) . get ( of ( headerName ) ) ; for ( String value : values ) { assertThat ( header , containsString ( value ) ) ; } } } 
