package org . elasticsearch . script . groovy ; import groovy . lang . Binding ; import groovy . lang . GroovyClassLoader ; import groovy . lang . GroovyCodeSource ; import groovy . lang . Script ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . Scorer ; import org . codehaus . groovy . ast . ClassCodeExpressionTransformer ; import org . codehaus . groovy . ast . ClassNode ; import org . codehaus . groovy . ast . expr . ConstantExpression ; import org . codehaus . groovy . ast . expr . Expression ; import org . codehaus . groovy . classgen . GeneratorContext ; import org . codehaus . groovy . control . CompilationFailedException ; import org . codehaus . groovy . control . CompilePhase ; import org . codehaus . groovy . control . CompilerConfiguration ; import org . codehaus . groovy . control . SourceUnit ; import org . codehaus . groovy . control . customizers . CompilationCustomizer ; import org . codehaus . groovy . control . customizers . ImportCustomizer ; import org . elasticsearch . SpecialPermission ; import org . elasticsearch . bootstrap . BootstrapInfo ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . hash . MessageDigests ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . script . * ; import org . elasticsearch . search . lookup . LeafSearchLookup ; import org . elasticsearch . search . lookup . SearchLookup ; import java . io . IOException ; import java . math . BigDecimal ; import java . nio . charset . StandardCharsets ; import java . security . AccessControlContext ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . HashMap ; import java . util . Map ; public class GroovyScriptEngineService extends AbstractComponent implements ScriptEngineService { public static final String NAME = <str> ; public static final String GROOVY_INDY_SETTING_NAME = <str> ; private final GroovyClassLoader loader ; @Inject public GroovyScriptEngineService ( Settings settings ) { super ( settings ) ; ImportCustomizer imports = new ImportCustomizer ( ) ; imports . addStarImports ( <str> ) ; imports . addStaticStars ( <str> ) ; CompilerConfiguration config = new CompilerConfiguration ( ) ; config . addCompilationCustomizers ( imports ) ; config . addCompilationCustomizers ( new GroovyBigDecimalTransformer ( CompilePhase . CONVERSION ) ) ; config . getOptimizationOptions ( ) . put ( GROOVY_INDY_SETTING_NAME , true ) ; final SecurityManager sm = System . getSecurityManager ( ) ; if ( sm ! = null ) { sm . checkPermission ( new SpecialPermission ( ) ) ; } this . loader = AccessController . doPrivileged ( new PrivilegedAction < GroovyClassLoader > ( ) { @Override public GroovyClassLoader run ( ) { final AccessControlContext engineContext = AccessController . getContext ( ) ; return new GroovyClassLoader ( new ClassLoader ( getClass ( ) . getClassLoader ( ) ) { @Override protected Class < ? > loadClass ( String name , boolean resolve ) throws ClassNotFoundException { if ( sm ! = null ) { try { engineContext . checkPermission ( new ClassPermission ( name ) ) ; } catch ( SecurityException e ) { throw new ClassNotFoundException ( name , e ) ; } } return super . loadClass ( name , resolve ) ; } } , config ) ; } } ) ; } @Override public void close ( ) { loader . clearCache ( ) ; SecurityManager sm = System . getSecurityManager ( ) ; if ( sm ! = null ) { sm . checkPermission ( new SpecialPermission ( ) ) ; } AccessController . doPrivileged ( new PrivilegedAction < Void > ( ) { @Override public Void run ( ) { try { loader . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } return null ; } } ) ; } @Override public void scriptRemoved ( @Nullable CompiledScript script ) { if ( script = = null | | NAME . equals ( script . lang ( ) ) ) { loader . clearCache ( ) ; } } @Override public String [ ] types ( ) { return new String [ ] { NAME } ; } @Override public String [ ] extensions ( ) { return new String [ ] { NAME } ; } @Override public boolean sandboxed ( ) { return false ; } @Override public Object compile ( String script ) { try { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm ! = null ) { sm . checkPermission ( new SpecialPermission ( ) ) ; } String fake = MessageDigests . toHexString ( MessageDigests . sha1 ( ) . digest ( script . getBytes ( StandardCharsets . UTF_8 ) ) ) ; return AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { public Class < ? > run ( ) { GroovyCodeSource gcs = new GroovyCodeSource ( script , fake , BootstrapInfo . UNTRUSTED_CODEBASE ) ; gcs . setCachable ( false ) ; return loader . parseClass ( gcs ) ; } } ) ; } catch ( Throwable e ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , e ) ; } throw new ScriptException ( <str> , e ) ; } } @SuppressWarnings ( <str> ) private Script createScript ( Object compiledScript , Map < String , Object > vars ) throws InstantiationException , IllegalAccessException { Class scriptClass = ( Class ) compiledScript ; Script scriptObject = ( Script ) scriptClass . newInstance ( ) ; Binding binding = new Binding ( ) ; binding . getVariables ( ) . putAll ( vars ) ; scriptObject . setBinding ( binding ) ; return scriptObject ; } @SuppressWarnings ( { <str> } ) @Override public ExecutableScript executable ( CompiledScript compiledScript , Map < String , Object > vars ) { try { Map < String , Object > allVars = new HashMap < > ( ) ; if ( vars ! = null ) { allVars . putAll ( vars ) ; } return new GroovyScript ( compiledScript , createScript ( compiledScript . compiled ( ) , allVars ) , this . logger ) ; } catch ( Exception e ) { throw new ScriptException ( <str> + compiledScript , e ) ; } } @SuppressWarnings ( { <str> } ) @Override public SearchScript search ( final CompiledScript compiledScript , final SearchLookup lookup , @Nullable final Map < String , Object > vars ) { return new SearchScript ( ) { @Override public LeafSearchScript getLeafSearchScript ( LeafReaderContext context ) throws IOException { final LeafSearchLookup leafLookup = lookup . getLeafSearchLookup ( context ) ; Map < String , Object > allVars = new HashMap < > ( ) ; allVars . putAll ( leafLookup . asMap ( ) ) ; if ( vars ! = null ) { allVars . putAll ( vars ) ; } Script scriptObject ; try { scriptObject = createScript ( compiledScript . compiled ( ) , allVars ) ; } catch ( InstantiationException | IllegalAccessException e ) { throw new ScriptException ( <str> + compiledScript , e ) ; } return new GroovyScript ( compiledScript , scriptObject , leafLookup , logger ) ; } @Override public boolean needsScores ( ) { return true ; } } ; } public static final class GroovyScript implements ExecutableScript , LeafSearchScript { private final CompiledScript compiledScript ; private final Script script ; private final LeafSearchLookup lookup ; private final Map < String , Object > variables ; private final ESLogger logger ; public GroovyScript ( CompiledScript compiledScript , Script script , ESLogger logger ) { this ( compiledScript , script , null , logger ) ; } @SuppressWarnings ( <str> ) public GroovyScript ( CompiledScript compiledScript , Script script , @Nullable LeafSearchLookup lookup , ESLogger logger ) { this . compiledScript = compiledScript ; this . script = script ; this . lookup = lookup ; this . logger = logger ; this . variables = script . getBinding ( ) . getVariables ( ) ; } @Override public void setScorer ( Scorer scorer ) { this . variables . put ( <str> , new ScoreAccessor ( scorer ) ) ; } @Override public void setDocument ( int doc ) { if ( lookup ! = null ) { lookup . setDocument ( doc ) ; } } @SuppressWarnings ( { <str> } ) @Override public void setNextVar ( String name , Object value ) { variables . put ( name , value ) ; } @Override public void setSource ( Map < String , Object > source ) { if ( lookup ! = null ) { lookup . source ( ) . setSource ( source ) ; } } @Override public Object run ( ) { try { return AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { @Override public Object run ( ) { return script . run ( ) ; } } ) ; } catch ( Throwable e ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> + compiledScript , e ) ; } throw new ScriptException ( <str> + compiledScript , e ) ; } } @Override public float runAsFloat ( ) { return ( ( Number ) run ( ) ) . floatValue ( ) ; } @Override public long runAsLong ( ) { return ( ( Number ) run ( ) ) . longValue ( ) ; } @Override public double runAsDouble ( ) { return ( ( Number ) run ( ) ) . doubleValue ( ) ; } @Override public Object unwrap ( Object value ) { return value ; } } private class GroovyBigDecimalTransformer extends CompilationCustomizer { private GroovyBigDecimalTransformer ( CompilePhase phase ) { super ( phase ) ; } @Override public void call ( final SourceUnit source , final GeneratorContext context , final ClassNode classNode ) throws CompilationFailedException { new BigDecimalExpressionTransformer ( source ) . visitClass ( classNode ) ; } } private class BigDecimalExpressionTransformer extends ClassCodeExpressionTransformer { private final SourceUnit source ; private BigDecimalExpressionTransformer ( SourceUnit source ) { this . source = source ; } @Override protected SourceUnit getSourceUnit ( ) { return this . source ; } @Override public Expression transform ( Expression expr ) { Expression newExpr = expr ; if ( expr instanceof ConstantExpression ) { ConstantExpression constExpr = ( ConstantExpression ) expr ; Object val = constExpr . getValue ( ) ; if ( val ! = null & & val instanceof BigDecimal ) { newExpr = new ConstantExpression ( ( ( BigDecimal ) val ) . doubleValue ( ) ) ; } } return super . transform ( newExpr ) ; } } } 
