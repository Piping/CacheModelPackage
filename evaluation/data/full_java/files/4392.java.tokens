package org . eclipse . debug . internal . ui . viewers . model ; import java . util . Collection ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ICheckUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IColumnPresentation ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IColumnPresentation2 ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IColumnPresentationFactory ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementEditor ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelChangedListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelSelectionPolicy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStateUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . PresentationContext ; import org . eclipse . jface . resource . ImageDescriptor ; import org . eclipse . jface . viewers . CellEditor ; import org . eclipse . jface . viewers . IBasicPropertyConstants ; import org . eclipse . jface . viewers . ICellModifier ; import org . eclipse . jface . viewers . IContentProvider ; import org . eclipse . jface . viewers . ILazyTreePathContentProvider ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . jface . viewers . TreeViewer ; import org . eclipse . jface . viewers . ViewerLabel ; import org . eclipse . swt . SWT ; import org . eclipse . swt . events . ControlEvent ; import org . eclipse . swt . events . ControlListener ; import org . eclipse . swt . events . DisposeEvent ; import org . eclipse . swt . events . PaintEvent ; import org . eclipse . swt . events . PaintListener ; import org . eclipse . swt . events . SelectionEvent ; import org . eclipse . swt . events . TreeEvent ; import org . eclipse . swt . graphics . Color ; import org . eclipse . swt . graphics . Font ; import org . eclipse . swt . graphics . FontData ; import org . eclipse . swt . graphics . Image ; import org . eclipse . swt . graphics . RGB ; import org . eclipse . swt . widgets . Composite ; import org . eclipse . swt . widgets . Control ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Event ; import org . eclipse . swt . widgets . Item ; import org . eclipse . swt . widgets . Listener ; import org . eclipse . swt . widgets . Tree ; import org . eclipse . swt . widgets . TreeColumn ; import org . eclipse . swt . widgets . TreeItem ; import org . eclipse . swt . widgets . Widget ; import org . eclipse . ui . IMemento ; @SuppressWarnings ( <str> ) public class InternalTreeModelViewer extends TreeViewer implements IInternalTreeModelViewer , org . eclipse . debug . internal . ui . viewers . model . ITreeModelViewer { private final IPresentationContext fContext ; private IColumnPresentation fColumnPresentation = null ; private final Map < String , String [ ] > fVisibleColumns = new HashMap < String , String [ ] > ( ) ; private final Map < Object , Integer > fColumnSizes = new HashMap < Object , Integer > ( ) ; private final Map < String , int [ ] > fColumnOrder = new HashMap < String , int [ ] > ( ) ; private final Map < String , Boolean > fShowColumns = new HashMap < String , Boolean > ( ) ; private static final String TREE_PATH_KEY = <str> ; private static final String COLUMN_SIZES = <str> ; private static final String COLUMN_ORDER = <str> ; private static final String VISIBLE_COLUMNS = <str> ; private static final String SHOW_COLUMNS = <str> ; private static final String SIZE = <str> ; private static final String COLUMN = <str> ; private boolean fInserting = false ; private boolean fNotifyUnmap = true ; class ColumnListener implements ControlListener { @Override public void controlMoved ( ControlEvent e ) { persistColumnOrder ( ) ; } @Override public void controlResized ( ControlEvent e ) { persistColumnSizes ( ) ; } } private final ColumnListener fListener = new ColumnListener ( ) ; class CellModifierProxy implements ICellModifier { private ICellModifier fModifier ; @Override public boolean canModify ( Object element , String property ) { IElementEditor editor = ViewerAdapterService . getElementEditor ( element ) ; if ( editor ! = null ) { fModifier = editor . getCellModifier ( getPresentationContext ( ) , element ) ; if ( fModifier ! = null ) { if ( fModifier . canModify ( element , property ) ) { CellEditor cellEditor = editor . getCellEditor ( getPresentationContext ( ) , property , element , ( Composite ) getControl ( ) ) ; if ( cellEditor ! = null ) { disposeCellEditors ( ) ; CellEditor [ ] newEditors = new CellEditor [ getVisibleColumns ( ) . length ] ; for ( int i = <int> ; i < newEditors . length ; i + + ) { newEditors [ i ] = cellEditor ; } setCellEditors ( newEditors ) ; return true ; } } } } return false ; } @Override public Object getValue ( Object element , String property ) { if ( fModifier ! = null ) { return fModifier . getValue ( element , property ) ; } return null ; } @Override public void modify ( Object element , String property , Object value ) { if ( fModifier ! = null ) { if ( element instanceof Item ) { element = ( ( Item ) element ) . getData ( ) ; } fModifier . modify ( element , property , value ) ; } } protected void clear ( ) { fModifier = null ; disposeCellEditors ( ) ; setCellEditors ( null ) ; } protected void disposeCellEditors ( ) { CellEditor [ ] cellEditors = getCellEditors ( ) ; if ( cellEditors ! = null ) { for ( int i = <int> ; i < cellEditors . length ; i + + ) { CellEditor editor = cellEditors [ i ] ; if ( editor ! = null ) { editor . dispose ( ) ; } } } } } private final CellModifierProxy fCellModifier ; public InternalTreeModelViewer ( Composite parent , int style , IPresentationContext context ) { super ( parent , style ) ; if ( ( style & SWT . VIRTUAL ) = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } setUseHashlookup ( true ) ; fCellModifier = new CellModifierProxy ( ) ; fContext = context ; setContentProvider ( createContentProvider ( ) ) ; setLabelProvider ( createLabelProvider ( ) ) ; if ( ( style & SWT . POP_UP ) ! = <int> ) { ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . setModelDeltaMask ( ~ ITreeModelContentProvider . CONTROL_MODEL_DELTA_FLAGS ) ; } if ( ( style & SWT . CHECK ) ! = <int> ) { context . setProperty ( ICheckUpdate . PROP_CHECK , Boolean . TRUE ) ; } } protected ITreeModelContentProvider createContentProvider ( ) { return new TreeModelContentProvider ( ) ; } protected ITreeModelLabelProvider createLabelProvider ( ) { return new TreeModelLabelProvider ( this ) ; } @Override protected void hookControl ( Control control ) { Tree treeControl = ( Tree ) control ; treeControl . addListener ( SWT . SetData , new Listener ( ) { @Override public void handleEvent ( Event event ) { TreeItem item = ( TreeItem ) event . item ; preserveItem ( item ) ; } } ) ; super . hookControl ( control ) ; } private void preserveItem ( TreeItem item ) { Object [ ] labels = ( Object [ ] ) item . getData ( PREV_LABEL_KEY ) ; if ( labels ! = null ) { for ( int i = <int> ; i < labels . length ; i + + ) { if ( labels [ i ] ! = null ) { item . setText ( i , ( String ) labels [ i ] ) ; } } } Object [ ] images = ( Object [ ] ) item . getData ( PREV_IMAGE_KEY ) ; if ( images ! = null ) { for ( int i = <int> ; i < images . length ; i + + ) { item . setImage ( i , ( Image ) images [ i ] ) ; } } Object [ ] fonts = ( Object [ ] ) item . getData ( PREV_FONT_KEY ) ; if ( fonts ! = null ) { for ( int i = <int> ; i < fonts . length ; i + + ) { item . setFont ( i , ( Font ) fonts [ i ] ) ; } } Object [ ] foregrounds = ( Object [ ] ) item . getData ( PREV_FOREGROUND_KEY ) ; if ( foregrounds ! = null ) { for ( int i = <int> ; i < foregrounds . length ; i + + ) { item . setForeground ( i , ( Color ) foregrounds [ i ] ) ; } } Object [ ] backgrounds = ( Object [ ] ) item . getData ( PREV_BACKGROUND_KEY ) ; if ( backgrounds ! = null ) { for ( int i = <int> ; i < backgrounds . length ; i + + ) { item . setBackground ( i , ( Color ) backgrounds [ i ] ) ; } } Boolean checked = ( Boolean ) item . getData ( PREV_CHECKED_KEY ) ; if ( checked ! = null ) { item . setChecked ( checked . booleanValue ( ) ) ; } Boolean grayed = ( Boolean ) item . getData ( PREV_GRAYED_KEY ) ; if ( grayed ! = null ) { item . setGrayed ( grayed . booleanValue ( ) ) ; } } @Override protected void handleInvalidSelection ( ISelection selection , ISelection newSelection ) { IModelSelectionPolicy selectionPolicy = ViewerAdapterService . getSelectionPolicy ( selection , getPresentationContext ( ) ) ; if ( selectionPolicy ! = null ) { while ( ! selection . equals ( newSelection ) ) { ISelection temp = newSelection ; selection = selectionPolicy . replaceInvalidSelection ( selection , newSelection ) ; if ( selection = = null ) { selection = TreeSelection . EMPTY ; } if ( ! temp . equals ( selection ) ) { setSelectionToWidget ( selection , false ) ; newSelection = getSelection ( ) ; } else { break ; } } } super . handleInvalidSelection ( selection , newSelection ) ; } @Override protected void handleDispose ( DisposeEvent event ) { if ( fColumnPresentation ! = null ) { fColumnPresentation . dispose ( ) ; } fCellModifier . clear ( ) ; super . handleDispose ( event ) ; } @Override public IPresentationContext getPresentationContext ( ) { return fContext ; } @Override protected void unmapElement ( Object element , Widget widget ) { if ( fNotifyUnmap ) { ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . unmapPath ( ( TreePath ) widget . getData ( TREE_PATH_KEY ) ) ; } super . unmapElement ( element , widget ) ; } @Override protected void associate ( Object element , Item item ) { Object data = item . getData ( ) ; if ( data ! = null & & data ! = element & & equals ( data , element ) ) { try { fNotifyUnmap = false ; super . associate ( element , item ) ; } finally { fNotifyUnmap = true ; } } else { super . associate ( element , item ) ; } } @Override protected void mapElement ( Object element , Widget widget ) { super . mapElement ( element , widget ) ; if ( widget instanceof Item ) { widget . setData ( TREE_PATH_KEY , getTreePathFromItem ( ( Item ) widget ) ) ; } else { widget . setData ( TREE_PATH_KEY , TreeModelContentProvider . EMPTY_TREE_PATH ) ; } } @Override public void insert ( Object parentElementOrTreePath , Object element , int position ) { try { fInserting = true ; super . insert ( parentElementOrTreePath , element , position ) ; } finally { fInserting = false ; } } @Override protected boolean hasFilters ( ) { if ( fInserting ) { return false ; } return super . hasFilters ( ) ; } @Override protected void unmapAllElements ( ) { if ( getControl ( ) . isDisposed ( ) ) { unmapAllElements ( ) ; } } @Override protected void inputChanged ( Object input , Object oldInput ) { fCellModifier . clear ( ) ; super . unmapAllElements ( ) ; ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . postInputChanged ( this , oldInput , input ) ; super . inputChanged ( input , oldInput ) ; resetColumns ( input ) ; } protected void resetColumns ( Object input ) { if ( input ! = null ) { IColumnPresentationFactory factory = ViewerAdapterService . getColumnPresentationFactory ( input ) ; PresentationContext context = ( PresentationContext ) getPresentationContext ( ) ; String type = null ; if ( factory ! = null ) { type = factory . getColumnPresentationId ( context , input ) ; } if ( type ! = null & & factory ! = null ) { if ( fColumnPresentation ! = null ) { if ( ! fColumnPresentation . getId ( ) . equals ( type ) ) { fColumnPresentation . dispose ( ) ; fColumnPresentation = null ; } } if ( fColumnPresentation = = null ) { fColumnPresentation = factory . createColumnPresentation ( context , input ) ; if ( fColumnPresentation ! = null ) { fColumnPresentation . init ( context ) ; configureColumns ( ) ; } } } else { if ( fColumnPresentation ! = null ) { fColumnPresentation . dispose ( ) ; fColumnPresentation = null ; configureColumns ( ) ; } } } } protected void configureColumns ( ) { if ( fColumnPresentation ! = null ) { IColumnPresentation build = null ; if ( isShowColumns ( fColumnPresentation . getId ( ) ) ) { build = fColumnPresentation ; } buildColumns ( build ) ; } else { buildColumns ( null ) ; } } public void setShowColumns ( boolean show ) { if ( show ) { if ( ! isShowColumns ( ) ) { fShowColumns . remove ( fColumnPresentation . getId ( ) ) ; } } else { if ( isShowColumns ( ) ) { fShowColumns . put ( fColumnPresentation . getId ( ) , Boolean . FALSE ) ; } } refreshColumns ( ) ; } public void resetColumnSizes ( String [ ] columnIds ) { for ( int i = <int> ; i < columnIds . length ; i + + ) { fColumnSizes . remove ( columnIds [ i ] ) ; } } public void setVisibleColumns ( String [ ] ids ) { if ( ids ! = null & & ids . length = = <int> ) { ids = null ; } IColumnPresentation presentation = getColumnPresentation ( ) ; if ( presentation ! = null ) { fColumnOrder . remove ( presentation . getId ( ) ) ; fVisibleColumns . remove ( presentation . getId ( ) ) ; if ( ids ! = null ) { String [ ] columns = presentation . getInitialColumns ( ) ; if ( columns . length = = ids . length ) { for ( int i = <int> ; i < columns . length ; i + + ) { if ( ! ids [ i ] . equals ( columns [ i ] ) ) { fVisibleColumns . put ( presentation . getId ( ) , ids ) ; break ; } } } else { fVisibleColumns . put ( presentation . getId ( ) , ids ) ; } } PresentationContext presentationContext = ( PresentationContext ) getPresentationContext ( ) ; presentationContext . setColumns ( getVisibleColumns ( ) ) ; refreshColumns ( ) ; } } @Override protected void internalRefresh ( Object element , boolean updateLabels ) { ITreeModelContentProvider contentProvider = ( ITreeModelContentProvider ) getContentProvider ( ) ; if ( element = = null ) { internalRefresh ( getControl ( ) , getRoot ( ) , true , updateLabels ) ; contentProvider . preserveState ( TreePath . EMPTY ) ; } else { Widget [ ] items = findItems ( element ) ; if ( items . length ! = <int> ) { for ( int i = <int> ; i < items . length ; i + + ) { if ( items [ i ] instanceof TreeItem ) { contentProvider . preserveState ( getTreePathFromItem ( ( TreeItem ) items [ i ] ) ) ; } else { contentProvider . preserveState ( TreePath . EMPTY ) ; } } } } super . internalRefresh ( element , updateLabels ) ; } protected void refreshColumns ( ) { configureColumns ( ) ; refresh ( ) ; } public boolean isShowColumns ( ) { if ( fColumnPresentation ! = null ) { return isShowColumns ( fColumnPresentation . getId ( ) ) ; } return false ; } public boolean canToggleColumns ( ) { return fColumnPresentation ! = null & & fColumnPresentation . isOptional ( ) ; } protected boolean isShowColumns ( String columnPresentationId ) { Boolean bool = fShowColumns . get ( columnPresentationId ) ; if ( bool = = null ) { return true ; } return bool . booleanValue ( ) ; } protected void buildColumns ( IColumnPresentation presentation ) { Tree tree = getTree ( ) ; final TreeColumn [ ] columns = tree . getColumns ( ) ; String [ ] visibleColumnIds = getVisibleColumns ( ) ; for ( int i = <int> ; i < columns . length ; i + + ) { columns [ i ] . removeControlListener ( fListener ) ; } for ( int i = <int> ; i < columns . length ; i + + ) { columns [ i ] . dispose ( ) ; } PresentationContext presentationContext = ( PresentationContext ) getPresentationContext ( ) ; if ( presentation ! = null ) { for ( int i = <int> ; i < visibleColumnIds . length ; i + + ) { String id = visibleColumnIds [ i ] ; String header = presentation . getHeader ( id ) ; TreeColumn column = new TreeColumn ( tree , SWT . LEFT , i ) ; column . setMoveable ( true ) ; column . setText ( header ) ; column . setWidth ( <int> ) ; ImageDescriptor image = presentation . getImageDescriptor ( id ) ; if ( image ! = null ) { column . setImage ( ( ( ITreeModelLabelProvider ) getLabelProvider ( ) ) . getImage ( image ) ) ; } column . setData ( id ) ; } int [ ] order = fColumnOrder . get ( presentation . getId ( ) ) ; if ( order ! = null ) { tree . setColumnOrder ( order ) ; } tree . setHeaderVisible ( true ) ; tree . setLinesVisible ( true ) ; presentationContext . setColumns ( visibleColumnIds ) ; setColumnProperties ( visibleColumnIds ) ; setCellModifier ( fCellModifier ) ; } else { tree . setHeaderVisible ( false ) ; tree . setLinesVisible ( false ) ; presentationContext . setColumns ( null ) ; setCellModifier ( null ) ; setColumnProperties ( null ) ; } int treeWidgetWidth = tree . getSize ( ) . x ; int avg = treeWidgetWidth ; if ( visibleColumnIds ! = null ) { avg / = visibleColumnIds . length ; } if ( avg = = <int> ) { tree . addPaintListener ( new PaintListener ( ) { @Override public void paintControl ( PaintEvent e ) { Tree tree2 = getTree ( ) ; String [ ] visibleColumns = getVisibleColumns ( ) ; if ( visibleColumns ! = null ) { int treeWidgetWidth1 = tree2 . getSize ( ) . x ; int avg1 = treeWidgetWidth1 / visibleColumns . length ; initColumns ( avg1 , treeWidgetWidth1 , visibleColumns ) ; } tree2 . removePaintListener ( this ) ; } } ) ; } else { initColumns ( avg , treeWidgetWidth , visibleColumnIds ) ; } } private void initColumns ( int widthHint , int treeWidgetWidth , String [ ] visibleColumnIds ) { TreeColumn [ ] columns = getTree ( ) . getColumns ( ) ; for ( int i = <int> ; i < columns . length ; i + + ) { TreeColumn treeColumn = columns [ i ] ; Object colData = treeColumn . getData ( ) ; String columnId = colData instanceof String ? ( String ) colData : null ; Integer width = fColumnSizes . get ( colData ) ; if ( width = = null ) { int ans = getInitialColumnWidth ( columnId , treeWidgetWidth , visibleColumnIds ) ; if ( ans = = - <int> ) { treeColumn . setWidth ( widthHint ) ; } else { treeColumn . setWidth ( ans ) ; } } else { treeColumn . setWidth ( width . intValue ( ) ) ; } treeColumn . addControlListener ( fListener ) ; } } public IColumnPresentation getColumnPresentation ( ) { return fColumnPresentation ; } @Override public String [ ] getVisibleColumns ( ) { if ( isShowColumns ( ) ) { IColumnPresentation presentation = getColumnPresentation ( ) ; if ( presentation ! = null ) { String [ ] columns = fVisibleColumns . get ( presentation . getId ( ) ) ; if ( columns = = null ) { return presentation . getInitialColumns ( ) ; } else { String [ ] available = presentation . getAvailableColumns ( ) ; for ( int i = <int> ; i < columns . length ; i + + ) { boolean columnAvailable = false ; for ( int j = <int> ; j < available . length ; j + + ) { if ( columns [ i ] . equals ( available [ j ] ) ) { columnAvailable = true ; } } if ( ! columnAvailable | | presentation . getHeader ( columns [ i ] ) = = null ) { fVisibleColumns . remove ( presentation . getId ( ) ) ; fColumnOrder . remove ( presentation . getId ( ) ) ; fColumnSizes . remove ( presentation . getId ( ) ) ; return presentation . getInitialColumns ( ) ; } } } return columns ; } } return null ; } public int getInitialColumnWidth ( String columnId , int treeWidgetWidth , String [ ] visibleColumnIds ) { if ( isShowColumns ( ) ) { IColumnPresentation presentation = getColumnPresentation ( ) ; if ( presentation instanceof IColumnPresentation2 ) { int ans = ( ( IColumnPresentation2 ) presentation ) . getInitialColumnWidth ( columnId , treeWidgetWidth , visibleColumnIds ) ; return ans ; } } return - <int> ; } protected void persistColumnSizes ( ) { Tree tree = getTree ( ) ; TreeColumn [ ] columns = tree . getColumns ( ) ; for ( int i = <int> ; i < columns . length ; i + + ) { TreeColumn treeColumn = columns [ i ] ; Object id = treeColumn . getData ( ) ; fColumnSizes . put ( id , Integer . valueOf ( treeColumn . getWidth ( ) ) ) ; } } protected void persistColumnOrder ( ) { IColumnPresentation presentation = getColumnPresentation ( ) ; if ( presentation ! = null ) { Tree tree = getTree ( ) ; int [ ] order = tree . getColumnOrder ( ) ; if ( order . length > <int> ) { for ( int i = <int> ; i < order . length ; i + + ) { if ( i ! = order [ i ] ) { fColumnOrder . put ( presentation . getId ( ) , order ) ; return ; } } } fColumnOrder . remove ( presentation . getId ( ) ) ; } } public void saveState ( IMemento memento ) { if ( ! fColumnSizes . isEmpty ( ) ) { for ( Entry < Object , Integer > entry : fColumnSizes . entrySet ( ) ) { IMemento sizes = memento . createChild ( COLUMN_SIZES , ( String ) entry . getKey ( ) ) ; sizes . putInteger ( SIZE , entry . getValue ( ) . intValue ( ) ) ; } } if ( ! fShowColumns . isEmpty ( ) ) { for ( Entry < String , Boolean > entry : fShowColumns . entrySet ( ) ) { IMemento sizes = memento . createChild ( SHOW_COLUMNS , entry . getKey ( ) ) ; sizes . putString ( SHOW_COLUMNS , entry . getValue ( ) . toString ( ) ) ; } } if ( ! fVisibleColumns . isEmpty ( ) ) { for ( Entry < String , String [ ] > entry : fVisibleColumns . entrySet ( ) ) { String id = entry . getKey ( ) ; IMemento visible = memento . createChild ( VISIBLE_COLUMNS , id ) ; String [ ] columns = entry . getValue ( ) ; visible . putInteger ( SIZE , columns . length ) ; for ( int i = <int> ; i < columns . length ; i + + ) { visible . putString ( COLUMN + Integer . toString ( i ) , columns [ i ] ) ; } } } if ( ! fColumnOrder . isEmpty ( ) ) { for ( Entry < String , int [ ] > entry : fColumnOrder . entrySet ( ) ) { String id = entry . getKey ( ) ; IMemento orderMemento = memento . createChild ( COLUMN_ORDER , id ) ; int [ ] order = entry . getValue ( ) ; orderMemento . putInteger ( SIZE , order . length ) ; for ( int i = <int> ; i < order . length ; i + + ) { orderMemento . putInteger ( COLUMN + Integer . toString ( i ) , order [ i ] ) ; } } } IPresentationContext context = getPresentationContext ( ) ; if ( context instanceof PresentationContext ) { PresentationContext pc = ( PresentationContext ) context ; pc . saveProperites ( memento ) ; } } public void initState ( IMemento memento ) { IMemento [ ] mementos = memento . getChildren ( COLUMN_SIZES ) ; for ( int i = <int> ; i < mementos . length ; i + + ) { IMemento child = mementos [ i ] ; String id = child . getID ( ) ; Integer size = child . getInteger ( SIZE ) ; if ( size ! = null ) { fColumnSizes . put ( id , size ) ; } } mementos = memento . getChildren ( SHOW_COLUMNS ) ; for ( int i = <int> ; i < mementos . length ; i + + ) { IMemento child = mementos [ i ] ; String id = child . getID ( ) ; Boolean bool = Boolean . valueOf ( child . getString ( SHOW_COLUMNS ) ) ; if ( ! bool . booleanValue ( ) ) { fShowColumns . put ( id , bool ) ; } } mementos = memento . getChildren ( VISIBLE_COLUMNS ) ; for ( int i = <int> ; i < mementos . length ; i + + ) { IMemento child = mementos [ i ] ; String id = child . getID ( ) ; Integer integer = child . getInteger ( SIZE ) ; if ( integer ! = null ) { int length = integer . intValue ( ) ; String [ ] columns = new String [ length ] ; for ( int j = <int> ; j < length ; j + + ) { columns [ j ] = child . getString ( COLUMN + Integer . toString ( j ) ) ; } fVisibleColumns . put ( id , columns ) ; } } mementos = memento . getChildren ( COLUMN_ORDER ) ; for ( int i = <int> ; i < mementos . length ; i + + ) { IMemento child = mementos [ i ] ; String id = child . getID ( ) ; Integer integer = child . getInteger ( SIZE ) ; if ( integer ! = null ) { int length = integer . intValue ( ) ; int [ ] order = new int [ length ] ; for ( int j = <int> ; j < length ; j + + ) { order [ j ] = child . getInteger ( COLUMN + Integer . toString ( j ) ) . intValue ( ) ; } fColumnOrder . put ( id , order ) ; } } IPresentationContext context = getPresentationContext ( ) ; if ( context instanceof PresentationContext ) { PresentationContext pc = ( PresentationContext ) context ; pc . initProperties ( memento ) ; } } @Override public boolean overrideSelection ( ISelection current , ISelection candidate ) { IModelSelectionPolicy selectionPolicy = ViewerAdapterService . getSelectionPolicy ( current , getPresentationContext ( ) ) ; if ( selectionPolicy = = null ) { return true ; } if ( selectionPolicy . contains ( candidate , getPresentationContext ( ) ) ) { return selectionPolicy . overrides ( current , candidate , getPresentationContext ( ) ) ; } return ! selectionPolicy . isSticky ( current , getPresentationContext ( ) ) ; } @Override public void setSelection ( ISelection selection , boolean reveal ) { if ( ! overrideSelection ( getSelection ( ) , selection ) ) { return ; } super . setSelection ( selection , reveal ) ; } @Override public void setSelection ( ISelection selection , boolean reveal , boolean force ) { trySelection ( selection , reveal , force ) ; } @Override public boolean trySelection ( ISelection selection , boolean reveal , boolean force ) { if ( force | | overrideSelection ( getSelection ( ) , selection ) ) { super . setSelection ( selection , reveal ) ; return true ; } return false ; } @Override public void addViewerUpdateListener ( IViewerUpdateListener listener ) { ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . addViewerUpdateListener ( listener ) ; } @Override public void removeViewerUpdateListener ( IViewerUpdateListener listener ) { ITreeModelContentProvider cp = ( ITreeModelContentProvider ) getContentProvider ( ) ; if ( cp ! = null ) { cp . removeViewerUpdateListener ( listener ) ; } } @Override public void addModelChangedListener ( IModelChangedListener listener ) { ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . addModelChangedListener ( listener ) ; } @Override public void removeModelChangedListener ( IModelChangedListener listener ) { ITreeModelContentProvider cp = ( ITreeModelContentProvider ) getContentProvider ( ) ; if ( cp ! = null ) { cp . removeModelChangedListener ( listener ) ; } } @Override public void addStateUpdateListener ( IStateUpdateListener listener ) { ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . addStateUpdateListener ( listener ) ; } @Override public void removeStateUpdateListener ( IStateUpdateListener listener ) { ITreeModelContentProvider cp = ( ITreeModelContentProvider ) getContentProvider ( ) ; if ( cp ! = null ) { cp . removeStateUpdateListener ( listener ) ; } } @Override protected void doUpdateItem ( final Item item , Object element ) { if ( ! ( item instanceof TreeItem ) ) { return ; } TreeItem treeItem = ( TreeItem ) item ; if ( treeItem . isDisposed ( ) ) { unmapElement ( element , treeItem ) ; return ; } if ( ! ( ( ITreeModelLabelProvider ) getLabelProvider ( ) ) . update ( getTreePathFromItem ( item ) ) ) { if ( element instanceof String ) { item . setData ( PREV_LABEL_KEY , new String [ ] { ( String ) element } ) ; } } if ( item . isDisposed ( ) ) { unmapElement ( element , item ) ; } } @Override public void addLabelUpdateListener ( ILabelUpdateListener listener ) { ( ( ITreeModelLabelProvider ) getLabelProvider ( ) ) . addLabelUpdateListener ( listener ) ; } @Override public void removeLabelUpdateListener ( ILabelUpdateListener listener ) { if ( ! getControl ( ) . isDisposed ( ) ) { ( ( ITreeModelLabelProvider ) getLabelProvider ( ) ) . removeLabelUpdateListener ( listener ) ; } } public Widget findItem ( TreePath path ) { if ( path . getSegmentCount ( ) = = <int> ) { return getTree ( ) ; } Widget [ ] items = super . findItems ( path . getLastSegment ( ) ) ; if ( items . length = = <int> ) { return items [ <int> ] ; } for ( int i = <int> ; i < items . length ; i + + ) { if ( getTreePathFromItem ( ( Item ) items [ i ] ) . equals ( path ) ) { return items [ i ] ; } } return null ; } @Override public Item [ ] getChildren ( Widget widget ) { return super . getChildren ( widget ) ; } @Override protected TreePath getTreePathFromItem ( Item item ) { return super . getTreePathFromItem ( item ) ; } @Override protected void internalRefreshStruct ( Widget widget , Object element , boolean updateLabels ) { if ( widget instanceof Tree ) { ( ( Tree ) widget ) . clearAll ( true ) ; } else if ( widget instanceof TreeItem ) { ( ( TreeItem ) widget ) . clearAll ( true ) ; } int index = <int> ; Widget parent = null ; if ( widget instanceof TreeItem ) { TreeItem treeItem = ( TreeItem ) widget ; parent = treeItem . getParentItem ( ) ; if ( parent = = null ) { parent = treeItem . getParent ( ) ; } if ( parent instanceof Tree ) { index = ( ( Tree ) parent ) . indexOf ( treeItem ) ; } else { index = ( ( TreeItem ) parent ) . indexOf ( treeItem ) ; } } virtualRefreshExpandedItems ( parent , widget , element , index ) ; } private void virtualRefreshExpandedItems ( Widget parent , Widget widget , Object element , int index ) { if ( widget instanceof Tree ) { if ( element = = null ) { ( ( Tree ) widget ) . setItemCount ( <int> ) ; return ; } virtualLazyUpdateChildCount ( widget , getChildren ( widget ) . length ) ; } else if ( ( ( TreeItem ) widget ) . getExpanded ( ) ) { preserveItem ( ( TreeItem ) widget ) ; virtualLazyUpdateWidget ( parent , index ) ; } else { return ; } Item [ ] items = getChildren ( widget ) ; for ( int i = <int> ; i < items . length ; i + + ) { Item item = items [ i ] ; Object data = item . getData ( ) ; virtualRefreshExpandedItems ( widget , item , data , i ) ; } } private void virtualLazyUpdateChildCount ( Widget widget , int currentChildCount ) { TreePath treePath ; if ( widget instanceof Item ) { treePath = getTreePathFromItem ( ( Item ) widget ) ; } else { treePath = TreePath . EMPTY ; } ( ( ILazyTreePathContentProvider ) getContentProvider ( ) ) . updateChildCount ( treePath , currentChildCount ) ; } private void virtualLazyUpdateWidget ( Widget widget , int index ) { TreePath treePath ; if ( widget instanceof Item ) { if ( widget . getData ( ) = = null ) { return ; } treePath = getTreePathFromItem ( ( Item ) widget ) ; } else { treePath = TreePath . EMPTY ; } ( ( ILazyTreePathContentProvider ) getContentProvider ( ) ) . updateElement ( treePath , index ) ; } @Override protected void createChildren ( Widget widget ) { Object element = widget . getData ( ) ; if ( element = = null & & widget instanceof TreeItem ) { virtualMaterializeItem ( ( TreeItem ) widget ) ; element = widget . getData ( ) ; } if ( element = = null ) { return ; } Item [ ] children = getChildren ( widget ) ; if ( children . length = = <int> & & children [ <int> ] . getData ( ) = = null ) { virtualLazyUpdateChildCount ( widget , children . length ) ; children = getChildren ( widget ) ; } return ; } private void virtualMaterializeItem ( TreeItem treeItem ) { if ( treeItem . getData ( ) ! = null ) { return ; } int index ; Widget parent = treeItem . getParentItem ( ) ; if ( parent = = null ) { parent = treeItem . getParent ( ) ; } Object parentElement = parent . getData ( ) ; if ( parentElement ! = null ) { if ( parent instanceof Tree ) { index = ( ( Tree ) parent ) . indexOf ( treeItem ) ; } else { index = ( ( TreeItem ) parent ) . indexOf ( treeItem ) ; } virtualLazyUpdateWidget ( parent , index ) ; } } @Override public void autoExpand ( TreePath elementPath ) { int level = getAutoExpandLevel ( ) ; if ( level > <int> | | level = = ITreeModelViewer . ALL_LEVELS ) { if ( level = = ITreeModelViewer . ALL_LEVELS | | level > = elementPath . getSegmentCount ( ) ) { expandToLevel ( elementPath , <int> ) ; } } } @Override public int findElementIndex ( TreePath parentPath , Object element ) { Widget parentItem = findItem ( parentPath ) ; if ( parentItem ! = null ) { Item [ ] children = getChildren ( parentItem ) ; for ( int i = <int> ; i < children . length ; i + + ) { Item item = children [ i ] ; Object data = item . getData ( ) ; if ( ( element ! = null & & element . equals ( data ) ) | | ( element = = null & & data = = null ) ) { return i ; } } } return - <int> ; } @Override public boolean getElementChildrenRealized ( TreePath parentPath ) { Widget parentItem = findItem ( parentPath ) ; if ( parentItem ! = null ) { Item [ ] children = getChildren ( parentItem ) ; for ( int i = <int> ; i < children . length ; i + + ) { if ( children [ i ] . getData ( ) = = null ) { return false ; } } } return true ; } @Override public Display getDisplay ( ) { Control control = getControl ( ) ; if ( control ! = null ) { return control . getDisplay ( ) ; } return null ; } protected static final String [ ] STATE_PROPERTIES = new String [ ] { IBasicPropertyConstants . P_TEXT , IBasicPropertyConstants . P_IMAGE } ; @Override public void update ( Object element ) { update ( element , STATE_PROPERTIES ) ; } static String PREV_LABEL_KEY = <str> ; static String PREV_IMAGE_KEY = <str> ; static String PREV_FONT_KEY = <str> ; static String PREV_FOREGROUND_KEY = <str> ; static String PREV_BACKGROUND_KEY = <str> ; static String PREV_CHECKED_KEY = <str> ; static String PREV_GRAYED_KEY = <str> ; @Override public void setElementData ( TreePath path , int numColumns , String [ ] labels , ImageDescriptor [ ] imageDescriptors , FontData [ ] fontDatas , RGB [ ] _foregrounds , RGB [ ] _backgrounds ) { Widget widget = findItem ( path ) ; String [ ] columnIds = getVisibleColumns ( ) ; if ( widget ! = null & & widget instanceof TreeItem & & ! widget . isDisposed ( ) ) { TreeItem item = ( TreeItem ) widget ; for ( int i = <int> ; i < numColumns ; i + + ) { item . setText ( i , ( labels [ i ] = = null ? IInternalDebugCoreConstants . EMPTY_STRING : labels [ i ] ) ) ; } item . setData ( PREV_LABEL_KEY , labels ) ; if ( imageDescriptors = = null ) { for ( int i = <int> ; i < numColumns ; i + + ) { item . setImage ( i , null ) ; } item . setData ( PREV_IMAGE_KEY , null ) ; } else { Image [ ] images = new Image [ imageDescriptors . length ] ; for ( int i = <int> ; i < imageDescriptors . length ; i + + ) { images [ i ] = ( ( ITreeModelLabelProvider ) getLabelProvider ( ) ) . getImage ( imageDescriptors [ i ] ) ; } if ( columnIds = = null ) { item . setImage ( images [ <int> ] ) ; } else { item . setImage ( images ) ; } item . setData ( PREV_IMAGE_KEY , images ) ; } if ( _foregrounds = = null ) { for ( int i = <int> ; i < numColumns ; i + + ) { item . setForeground ( i , null ) ; } item . setData ( PREV_FOREGROUND_KEY , null ) ; } else { Color [ ] foregrounds = new Color [ _foregrounds . length ] ; for ( int i = <int> ; i < foregrounds . length ; i + + ) { foregrounds [ i ] = ( ( ITreeModelLabelProvider ) getLabelProvider ( ) ) . getColor ( _foregrounds [ i ] ) ; } if ( columnIds = = null ) { item . setForeground ( <int> , foregrounds [ <int> ] ) ; } else { for ( int i = <int> ; i < foregrounds . length ; i + + ) { item . setForeground ( i , foregrounds [ i ] ) ; } } item . setData ( PREV_FOREGROUND_KEY , foregrounds ) ; } if ( _backgrounds = = null ) { for ( int i = <int> ; i < numColumns ; i + + ) { item . setBackground ( i , null ) ; } item . setData ( PREV_BACKGROUND_KEY , null ) ; } else { Color [ ] backgrounds = new Color [ _backgrounds . length ] ; for ( int i = <int> ; i < backgrounds . length ; i + + ) { backgrounds [ i ] = ( ( ITreeModelLabelProvider ) getLabelProvider ( ) ) . getColor ( _backgrounds [ i ] ) ; } if ( columnIds = = null ) { item . setBackground ( <int> , backgrounds [ <int> ] ) ; } else { for ( int i = <int> ; i < backgrounds . length ; i + + ) { item . setBackground ( i , backgrounds [ i ] ) ; } } item . setData ( PREV_BACKGROUND_KEY , backgrounds ) ; } if ( fontDatas = = null ) { for ( int i = <int> ; i < numColumns ; i + + ) { item . setFont ( i , null ) ; } item . setData ( PREV_FONT_KEY , null ) ; } else { Font [ ] fonts = new Font [ fontDatas . length ] ; for ( int i = <int> ; i < fontDatas . length ; i + + ) { fonts [ i ] = ( ( ITreeModelLabelProvider ) getLabelProvider ( ) ) . getFont ( fontDatas [ i ] ) ; } if ( columnIds = = null ) { item . setFont ( <int> , fonts [ <int> ] ) ; } else { for ( int i = <int> ; i < fonts . length ; i + + ) { item . setFont ( i , fonts [ i ] ) ; } } item . setData ( PREV_FONT_KEY , fonts ) ; } } } @Override public ViewerLabel getElementLabel ( TreePath path , String columnId ) { if ( path . getSegmentCount ( ) = = <int> ) { return null ; } int columnIdx = - <int> ; String [ ] visibleColumns = getVisibleColumns ( ) ; if ( columnId ! = null & & visibleColumns ! = null ) { int i = <int> ; for ( i = <int> ; i < visibleColumns . length ; i + + ) { if ( columnId . equals ( getVisibleColumns ( ) [ i ] ) ) { columnIdx = i ; break ; } } if ( i = = visibleColumns . length ) { return null ; } } else { columnIdx = <int> ; } TreeItem item = ( TreeItem ) findItem ( path ) ; if ( item ! = null ) { ViewerLabel label = new ViewerLabel ( item . getText ( columnIdx ) , item . getImage ( columnIdx ) ) ; label . setFont ( item . getFont ( columnIdx ) ) ; label . setBackground ( item . getBackground ( columnIdx ) ) ; label . setForeground ( item . getForeground ( columnIdx ) ) ; return label ; } return null ; } @Override public void reveal ( TreePath path , int index ) { Widget item = findItem ( path ) ; TreeItem [ ] children = null ; if ( item instanceof TreeItem ) { children = ( ( TreeItem ) item ) . getItems ( ) ; } else if ( item instanceof Tree ) { children = ( ( Tree ) item ) . getItems ( ) ; } if ( children ! = null & & index < children . length ) { getTree ( ) . setTopItem ( children [ index ] ) ; } } @Override public int getChildCount ( TreePath path ) { if ( path . getSegmentCount ( ) = = <int> ) { return ( ( Tree ) getControl ( ) ) . getItemCount ( ) ; } else { Widget [ ] items = internalFindItems ( path ) ; if ( items . length > <int> ) { if ( items [ <int> ] instanceof TreeItem ) { return ( ( TreeItem ) items [ <int> ] ) . getItemCount ( ) ; } } } return - <int> ; } @Override public Object getChildElement ( TreePath path , int index ) { TreeItem childItem = null ; if ( path . getSegmentCount ( ) = = <int> ) { Tree tree = ( Tree ) getControl ( ) ; try { childItem = tree . getItem ( index ) ; } catch ( IllegalArgumentException e ) { } } else { try { Widget [ ] items = internalFindItems ( path ) ; if ( items . length > <int> ) { if ( items [ <int> ] instanceof TreeItem ) { childItem = ( ( TreeItem ) items [ <int> ] ) . getItem ( index ) ; } } } catch ( IllegalArgumentException e ) { } } if ( childItem ! = null ) { return childItem . getData ( ) ; } return null ; } @Override public TreePath getTopElementPath ( ) { TreeItem topItem = ( ( Tree ) getControl ( ) ) . getTopItem ( ) ; if ( topItem ! = null & & topItem . getData ( ) ! = null ) { return getTreePathFromItem ( topItem ) ; } return null ; } @Override public boolean saveElementState ( TreePath path , ModelDelta delta , int flagsToSave ) { Tree tree = ( Tree ) getControl ( ) ; TreeItem [ ] selection = tree . getSelection ( ) ; Set < TreeItem > set = new HashSet < TreeItem > ( ) ; for ( int i = <int> ; i < selection . length ; i + + ) { set . add ( selection [ i ] ) ; } TreeItem [ ] items = null ; Widget w = internalGetWidgetToSelect ( path ) ; if ( w instanceof Tree ) { delta . setChildCount ( ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . viewToModelCount ( path , tree . getItemCount ( ) ) ) ; if ( ( flagsToSave & IModelDelta . EXPAND ) ! = <int> ) { delta . setFlags ( delta . getFlags ( ) | IModelDelta . EXPAND ) ; } items = tree . getItems ( ) ; } else if ( w instanceof TreeItem ) { TreeItem item = ( TreeItem ) w ; if ( item . getExpanded ( ) ) { int itemCount = item . getData ( ) ! = null ? item . getItemCount ( ) : - <int> ; delta . setChildCount ( ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . viewToModelCount ( path , itemCount ) ) ; if ( ( flagsToSave & IModelDelta . EXPAND ) ! = <int> ) { delta . setFlags ( delta . getFlags ( ) | IModelDelta . EXPAND ) ; } } else if ( ( flagsToSave & IModelDelta . COLLAPSE ) ! = <int> ) { delta . setFlags ( delta . getFlags ( ) | IModelDelta . COLLAPSE ) ; } if ( set . contains ( item ) & & ( flagsToSave & IModelDelta . SELECT ) ! = <int> ) { delta . setFlags ( delta . getFlags ( ) | IModelDelta . SELECT ) ; } items = ( ( TreeItem ) w ) . getItems ( ) ; } if ( items ! = null & & items . length ! = <int> ) { for ( int i = <int> ; i < items . length ; i + + ) { doSaveElementState ( path , delta , items [ i ] , set , i , flagsToSave ) ; } return true ; } else { return false ; } } private void doSaveElementState ( TreePath parentPath , ModelDelta delta , TreeItem item , Collection < TreeItem > set , int index , int flagsToSave ) { Object element = item . getData ( ) ; if ( element ! = null ) { boolean expanded = item . getExpanded ( ) ; boolean selected = set . contains ( item ) ; int flags = IModelDelta . NO_CHANGE ; if ( expanded & & ( flagsToSave & IModelDelta . EXPAND ) ! = <int> ) { flags = flags | IModelDelta . EXPAND ; } if ( ! expanded & & ( flagsToSave & IModelDelta . COLLAPSE ) ! = <int> ) { flags = flags | IModelDelta . COLLAPSE ; } if ( selected & & ( flagsToSave & IModelDelta . SELECT ) ! = <int> ) { flags = flags | IModelDelta . SELECT ; } if ( expanded | | flags ! = IModelDelta . NO_CHANGE ) { int modelIndex = ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . viewToModelIndex ( parentPath , index ) ; TreePath elementPath = parentPath . createChildPath ( element ) ; ModelDelta childDelta = delta . addNode ( element , modelIndex , flags , - <int> ) ; if ( expanded ) { int itemCount = item . getItemCount ( ) ; int numChildren = ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . viewToModelCount ( elementPath , itemCount ) ; childDelta . setChildCount ( numChildren ) ; TreeItem [ ] items = item . getItems ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { doSaveElementState ( elementPath , childDelta , items [ i ] , set , i , flagsToSave ) ; } } } } } @Override public void updateViewer ( IModelDelta delta ) { ( ( ITreeModelContentProvider ) getContentProvider ( ) ) . updateModel ( delta , ITreeModelContentProvider . ALL_MODEL_DELTA_FLAGS ) ; } @Override public void setElementChecked ( TreePath path , boolean checked , boolean grayed ) { Widget widget = findItem ( path ) ; if ( widget ! = null & & widget instanceof TreeItem & & ! widget . isDisposed ( ) ) { TreeItem item = ( TreeItem ) widget ; item . setChecked ( checked ) ; item . setGrayed ( grayed ) ; item . setData ( PREV_CHECKED_KEY , checked ? Boolean . TRUE : Boolean . FALSE ) ; item . setData ( PREV_GRAYED_KEY , grayed ? Boolean . TRUE : Boolean . FALSE ) ; } } @Override public boolean getElementChecked ( TreePath path ) { Widget widget = findItem ( path ) ; if ( widget ! = null & & widget instanceof TreeItem & & ! widget . isDisposed ( ) ) { TreeItem item = ( TreeItem ) widget ; return item . getChecked ( ) ; } return false ; } @Override public boolean getElementGrayed ( TreePath path ) { Widget widget = findItem ( path ) ; if ( widget ! = null & & widget instanceof TreeItem & & ! widget . isDisposed ( ) ) { TreeItem item = ( TreeItem ) widget ; return item . getGrayed ( ) ; } return false ; } @Override public boolean getHasChildren ( Object elementOrTreePath ) { if ( elementOrTreePath instanceof TreePath & & ( ( TreePath ) elementOrTreePath ) . getSegmentCount ( ) = = <int> ) { return getTree ( ) . getItemCount ( ) > <int> ; } Widget [ ] items = internalFindItems ( elementOrTreePath ) ; if ( items ! = null & & items . length > <int> ) { if ( items [ <int> ] instanceof TreeItem ) { return ( ( TreeItem ) items [ <int> ] ) . getItemCount ( ) > <int> ; } else { return ( ( Tree ) items [ <int> ] ) . getItemCount ( ) > <int> ; } } return false ; } @Override public TreePath [ ] getElementPaths ( Object element ) { Widget [ ] items = internalFindItems ( element ) ; TreePath [ ] paths = new TreePath [ items . length ] ; for ( int i = <int> ; i < items . length ; i + + ) { if ( items [ i ] instanceof Tree ) { paths [ i ] = TreePath . EMPTY ; } else { paths [ i ] = getTreePathFromItem ( ( Item ) items [ i ] ) ; } } return paths ; } @Override protected void handleSelect ( SelectionEvent event ) { super . handleSelect ( event ) ; TreeItem item = ( TreeItem ) event . item ; if ( item ! = null ) { Object element = item . getData ( ) ; IContentProvider contentProvider = getContentProvider ( ) ; if ( element ! = null & & contentProvider instanceof TreeModelContentProvider ) { TreePath path = getTreePathFromItem ( item ) ; if ( event . detail = = SWT . CHECK ) { boolean checked = item . getChecked ( ) ; boolean accepted = ( ( ITreeModelContentProvider ) contentProvider ) . setChecked ( path , checked ) ; if ( ! accepted ) { item . setChecked ( ! checked ) ; } else { item . setData ( PREV_CHECKED_KEY , Boolean . valueOf ( checked ) ) ; } } else { ( ( TreeModelContentProvider ) contentProvider ) . cancelRestore ( path , IModelDelta . SELECT | IModelDelta . REVEAL ) ; } } } } @Override protected void handleTreeExpand ( TreeEvent event ) { super . handleTreeExpand ( event ) ; IContentProvider contentProvider = getContentProvider ( ) ; if ( contentProvider instanceof TreeModelContentProvider & & event . item . getData ( ) ! = null ) { TreePath path = getTreePathFromItem ( ( TreeItem ) event . item ) ; ( ( TreeModelContentProvider ) contentProvider ) . cancelRestore ( path , IModelDelta . COLLAPSE ) ; } } @Override protected void handleTreeCollapse ( TreeEvent event ) { super . handleTreeCollapse ( event ) ; IContentProvider contentProvider = getContentProvider ( ) ; if ( contentProvider instanceof TreeModelContentProvider & & event . item . getData ( ) ! = null ) { TreePath path = getTreePathFromItem ( ( TreeItem ) event . item ) ; ( ( TreeModelContentProvider ) contentProvider ) . cancelRestore ( path , IModelDelta . EXPAND ) ; } } @Override public void clearSelectionQuiet ( ) { getTree ( ) . setSelection ( new TreeItem [ <int> ] ) ; } } 
