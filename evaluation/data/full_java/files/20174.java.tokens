package io . netty . bootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandler ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . ServerChannel ; import io . netty . util . AttributeKey ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Map . Entry ; import java . util . concurrent . TimeUnit ; public class ServerBootstrap extends AbstractBootstrap < ServerBootstrap , ServerChannel > { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ServerBootstrap . class ) ; private final Map < ChannelOption < ? > , Object > childOptions = new LinkedHashMap < ChannelOption < ? > , Object > ( ) ; private final Map < AttributeKey < ? > , Object > childAttrs = new LinkedHashMap < AttributeKey < ? > , Object > ( ) ; private volatile EventLoopGroup childGroup ; private volatile ChannelHandler childHandler ; public ServerBootstrap ( ) { } private ServerBootstrap ( ServerBootstrap bootstrap ) { super ( bootstrap ) ; childGroup = bootstrap . childGroup ; childHandler = bootstrap . childHandler ; synchronized ( bootstrap . childOptions ) { childOptions . putAll ( bootstrap . childOptions ) ; } synchronized ( bootstrap . childAttrs ) { childAttrs . putAll ( bootstrap . childAttrs ) ; } } @Override public ServerBootstrap group ( EventLoopGroup group ) { return group ( group , group ) ; } public ServerBootstrap group ( EventLoopGroup parentGroup , EventLoopGroup childGroup ) { super . group ( parentGroup ) ; if ( childGroup = = null ) { throw new NullPointerException ( <str> ) ; } if ( this . childGroup ! = null ) { throw new IllegalStateException ( <str> ) ; } this . childGroup = childGroup ; return this ; } public < T > ServerBootstrap childOption ( ChannelOption < T > childOption , T value ) { if ( childOption = = null ) { throw new NullPointerException ( <str> ) ; } if ( value = = null ) { synchronized ( childOptions ) { childOptions . remove ( childOption ) ; } } else { synchronized ( childOptions ) { childOptions . put ( childOption , value ) ; } } return this ; } public < T > ServerBootstrap childAttr ( AttributeKey < T > childKey , T value ) { if ( childKey = = null ) { throw new NullPointerException ( <str> ) ; } if ( value = = null ) { childAttrs . remove ( childKey ) ; } else { childAttrs . put ( childKey , value ) ; } return this ; } public ServerBootstrap childHandler ( ChannelHandler childHandler ) { if ( childHandler = = null ) { throw new NullPointerException ( <str> ) ; } this . childHandler = childHandler ; return this ; } public EventLoopGroup childGroup ( ) { return childGroup ; } @Override void init ( Channel channel ) throws Exception { final Map < ChannelOption < ? > , Object > options = options ( ) ; synchronized ( options ) { channel . config ( ) . setOptions ( options ) ; } final Map < AttributeKey < ? > , Object > attrs = attrs ( ) ; synchronized ( attrs ) { for ( Entry < AttributeKey < ? > , Object > e : attrs . entrySet ( ) ) { @SuppressWarnings ( <str> ) AttributeKey < Object > key = ( AttributeKey < Object > ) e . getKey ( ) ; channel . attr ( key ) . set ( e . getValue ( ) ) ; } } ChannelPipeline p = channel . pipeline ( ) ; final EventLoopGroup currentChildGroup = childGroup ; final ChannelHandler currentChildHandler = childHandler ; final Entry < ChannelOption < ? > , Object > [ ] currentChildOptions ; final Entry < AttributeKey < ? > , Object > [ ] currentChildAttrs ; synchronized ( childOptions ) { currentChildOptions = childOptions . entrySet ( ) . toArray ( newOptionArray ( childOptions . size ( ) ) ) ; } synchronized ( childAttrs ) { currentChildAttrs = childAttrs . entrySet ( ) . toArray ( newAttrArray ( childAttrs . size ( ) ) ) ; } p . addLast ( new ChannelInitializer < Channel > ( ) { @Override public void initChannel ( Channel ch ) throws Exception { ChannelPipeline pipeline = ch . pipeline ( ) ; ChannelHandler handler = handler ( ) ; if ( handler ! = null ) { pipeline . addLast ( handler ) ; } pipeline . addLast ( new ServerBootstrapAcceptor ( currentChildGroup , currentChildHandler , currentChildOptions , currentChildAttrs ) ) ; } } ) ; } @Override public ServerBootstrap validate ( ) { super . validate ( ) ; if ( childHandler = = null ) { throw new IllegalStateException ( <str> ) ; } if ( childGroup = = null ) { logger . warn ( <str> ) ; childGroup = group ( ) ; } return this ; } @SuppressWarnings ( <str> ) private static Entry < ChannelOption < ? > , Object > [ ] newOptionArray ( int size ) { return new Entry [ size ] ; } @SuppressWarnings ( <str> ) private static Entry < AttributeKey < ? > , Object > [ ] newAttrArray ( int size ) { return new Entry [ size ] ; } private static class ServerBootstrapAcceptor extends ChannelInboundHandlerAdapter { private final EventLoopGroup childGroup ; private final ChannelHandler childHandler ; private final Entry < ChannelOption < ? > , Object > [ ] childOptions ; private final Entry < AttributeKey < ? > , Object > [ ] childAttrs ; ServerBootstrapAcceptor ( EventLoopGroup childGroup , ChannelHandler childHandler , Entry < ChannelOption < ? > , Object > [ ] childOptions , Entry < AttributeKey < ? > , Object > [ ] childAttrs ) { this . childGroup = childGroup ; this . childHandler = childHandler ; this . childOptions = childOptions ; this . childAttrs = childAttrs ; } @Override @SuppressWarnings ( <str> ) public void channelRead ( ChannelHandlerContext ctx , Object msg ) { final Channel child = ( Channel ) msg ; child . pipeline ( ) . addLast ( childHandler ) ; for ( Entry < ChannelOption < ? > , Object > e : childOptions ) { try { if ( ! child . config ( ) . setOption ( ( ChannelOption < Object > ) e . getKey ( ) , e . getValue ( ) ) ) { logger . warn ( <str> + e ) ; } } catch ( Throwable t ) { logger . warn ( <str> + child , t ) ; } } for ( Entry < AttributeKey < ? > , Object > e : childAttrs ) { child . attr ( ( AttributeKey < Object > ) e . getKey ( ) ) . set ( e . getValue ( ) ) ; } try { childGroup . register ( child ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( ! future . isSuccess ( ) ) { forceClose ( child , future . cause ( ) ) ; } } } ) ; } catch ( Throwable t ) { forceClose ( child , t ) ; } } private static void forceClose ( Channel child , Throwable t ) { child . unsafe ( ) . closeForcibly ( ) ; logger . warn ( <str> + child , t ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { final ChannelConfig config = ctx . channel ( ) . config ( ) ; if ( config . isAutoRead ( ) ) { config . setAutoRead ( false ) ; ctx . channel ( ) . eventLoop ( ) . schedule ( new OneTimeTask ( ) { @Override public void run ( ) { config . setAutoRead ( true ) ; } } , <int> , TimeUnit . SECONDS ) ; } ctx . fireExceptionCaught ( cause ) ; } } @Override @SuppressWarnings ( <str> ) public ServerBootstrap clone ( ) { return new ServerBootstrap ( this ) ; } @Override public String toString ( ) { StringBuilder buf = new StringBuilder ( super . toString ( ) ) ; buf . setLength ( buf . length ( ) - <int> ) ; buf . append ( <str> ) ; if ( childGroup ! = null ) { buf . append ( <str> ) ; buf . append ( StringUtil . simpleClassName ( childGroup ) ) ; buf . append ( <str> ) ; } synchronized ( childOptions ) { if ( ! childOptions . isEmpty ( ) ) { buf . append ( <str> ) ; buf . append ( childOptions ) ; buf . append ( <str> ) ; } } synchronized ( childAttrs ) { if ( ! childAttrs . isEmpty ( ) ) { buf . append ( <str> ) ; buf . append ( childAttrs ) ; buf . append ( <str> ) ; } } if ( childHandler ! = null ) { buf . append ( <str> ) ; buf . append ( childHandler ) ; buf . append ( <str> ) ; } if ( buf . charAt ( buf . length ( ) - <int> ) = = <str> ) { buf . append ( <str> ) ; } else { buf . setCharAt ( buf . length ( ) - <int> , <str> ) ; buf . setLength ( buf . length ( ) - <int> ) ; } return buf . toString ( ) ; } } 
