package io . netty . test . udt . util ; import com . barchart . udt . SocketUDT ; import com . barchart . udt . StatusUDT ; import io . netty . util . internal . ThreadLocalRandom ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . File ; import java . net . InetAddress ; import java . net . InetSocketAddress ; import java . net . ServerSocket ; import java . nio . IntBuffer ; import java . util . HashSet ; import java . util . Random ; import java . util . Set ; import java . util . TreeSet ; import java . util . regex . Pattern ; public final class UnitHelp { private static final InternalLogger log = InternalLoggerFactory . getInstance ( UnitHelp . class ) ; private static final Pattern SPACES = Pattern . compile ( <str> ) ; public static boolean canLoadAndInitClass ( String name ) { try { Class . forName ( name , true , UnitHelp . class . getClassLoader ( ) ) ; log . info ( <str> ) ; return true ; } catch ( Throwable e ) { log . warn ( <str> , e ) ; return false ; } } public static void clear ( final IntBuffer buffer ) { for ( int index = <int> ; index < buffer . capacity ( ) ; index + + ) { buffer . put ( index , <int> ) ; } } public static long ping ( final String host ) throws Exception { final String name = System . getProperty ( <str> ) . toLowerCase ( ) ; final String command ; if ( name . contains ( <str> ) ) { command = <str> + host ; } else if ( name . contains ( <str> ) ) { command = <str> + host ; } else if ( name . contains ( <str> ) ) { command = <str> + host ; } else { throw new Exception ( <str> ) ; } final long timeStart = System . currentTimeMillis ( ) ; process ( command ) ; final long timeFinish = System . currentTimeMillis ( ) ; return timeFinish - timeStart ; } public static void process ( final String command ) throws Exception { final ProcessBuilder builder = new ProcessBuilder ( SPACES . split ( command ) ) ; final Process process = builder . start ( ) ; process . waitFor ( ) ; } public static synchronized InetSocketAddress findLocalAddress ( final String host ) { ServerSocket socket = null ; try { final InetAddress address = InetAddress . getByName ( host ) ; socket = new ServerSocket ( <int> , <int> , address ) ; return ( InetSocketAddress ) socket . getLocalSocketAddress ( ) ; } catch ( final Exception e ) { log . error ( <str> ) ; return null ; } finally { if ( socket ! = null ) { try { socket . close ( ) ; } catch ( final Exception e ) { log . error ( <str> ) ; } } } } public static InetSocketAddress hostedSocketAddress ( final String host ) throws Exception { for ( int k = <int> ; k < <int> ; k + + ) { final InetSocketAddress address = findLocalAddress ( host ) ; if ( address = = null ) { Thread . sleep ( <int> ) ; continue ; } return address ; } throw new Exception ( <str> ) ; } public static InetSocketAddress localSocketAddress ( ) throws Exception { return hostedSocketAddress ( <str> ) ; } public static void logBuffer ( final String title , final IntBuffer buffer ) { for ( int index = <int> ; index < buffer . capacity ( ) ; index + + ) { final int value = buffer . get ( index ) ; if ( value = = <int> ) { continue ; } log . info ( String . format ( <str> , title , value ) ) ; } } public static void logClassPath ( ) { final String classPath = System . getProperty ( <str> ) ; final String [ ] entries = classPath . split ( File . pathSeparator ) ; final StringBuilder text = new StringBuilder ( <int> ) ; for ( final String item : entries ) { text . append ( <str> ) ; text . append ( item ) ; } log . info ( <str> , text ) ; } public static void logLibraryPath ( ) { final String classPath = System . getProperty ( <str> ) ; final String [ ] entries = classPath . split ( File . pathSeparator ) ; final StringBuilder text = new StringBuilder ( <int> ) ; for ( final String item : entries ) { text . append ( <str> ) ; text . append ( item ) ; } log . info ( <str> , text ) ; } public static void logOsArch ( ) { final StringBuilder text = new StringBuilder ( <int> ) . append ( <str> ) . append ( System . getProperty ( <str> ) ) . append ( <str> ) . append ( System . getProperty ( <str> ) ) ; log . info ( <str> , text ) ; } public static void logSet ( final Set < ? > set ) { @SuppressWarnings ( <str> ) final TreeSet < ? > treeSet = new TreeSet ( set ) ; for ( final Object item : treeSet ) { log . info ( <str> , item ) ; } } public static String property ( final String name ) { final String value = System . getProperty ( name ) ; if ( value = = null ) { log . error ( <str> , name ) ; System . exit ( <int> ) ; } return value ; } public static int [ ] randomIntArray ( final int length , final int range ) { final int [ ] array = new int [ length ] ; final Random generator = ThreadLocalRandom . current ( ) ; for ( int i = <int> ; i < array . length ; i + + ) { array [ i ] = generator . nextInt ( range ) ; } return array ; } public static String randomString ( ) { return String . valueOf ( System . currentTimeMillis ( ) ) ; } public static String randomSuffix ( final String name ) { return name + <str> + System . currentTimeMillis ( ) ; } public static void socketAwait ( final SocketUDT socket , final StatusUDT . . . statusArray ) throws Exception { while ( true ) { for ( final StatusUDT status : statusArray ) { if ( socket . status ( ) = = status ) { return ; } else { Thread . sleep ( <int> ) ; } } } } public static Set < Integer > socketIndexSet ( final IntBuffer buffer ) { final Set < Integer > set = new HashSet < Integer > ( ) ; while ( buffer . hasRemaining ( ) ) { set . add ( buffer . get ( ) ) ; } return set ; } public static boolean socketPresent ( final SocketUDT socket , final IntBuffer buffer ) { for ( int index = <int> ; index < buffer . capacity ( ) ; index + + ) { if ( buffer . get ( index ) = = socket . id ( ) ) { return true ; } } return false ; } private UnitHelp ( ) { } } 
