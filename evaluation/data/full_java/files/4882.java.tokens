package org . apache . lucene . queryparser . classic ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . CharTermAttribute ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . * ; import org . apache . lucene . util . IOUtils ; import org . apache . lucene . util . automaton . RegExp ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . index . mapper . core . DateFieldMapper ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . index . query . support . QueryParsers ; import java . io . IOException ; import java . util . * ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . lucene . search . Queries . fixNegativeQueryIfNeeded ; public class MapperQueryParser extends QueryParser { public static final Map < String , FieldQueryExtension > FIELD_QUERY_EXTENSIONS ; static { Map < String , FieldQueryExtension > fieldQueryExtensions = new HashMap < > ( ) ; fieldQueryExtensions . put ( ExistsFieldQueryExtension . NAME , new ExistsFieldQueryExtension ( ) ) ; FIELD_QUERY_EXTENSIONS = unmodifiableMap ( fieldQueryExtensions ) ; } private final QueryShardContext context ; private QueryParserSettings settings ; private MappedFieldType currentFieldType ; public MapperQueryParser ( QueryShardContext context ) { super ( null , null ) ; this . context = context ; } public void reset ( QueryParserSettings settings ) { this . settings = settings ; if ( settings . fieldsAndWeights ( ) . isEmpty ( ) ) { this . field = settings . defaultField ( ) ; } else if ( settings . fieldsAndWeights ( ) . size ( ) = = <int> ) { this . field = settings . fieldsAndWeights ( ) . keySet ( ) . iterator ( ) . next ( ) ; } else { this . field = null ; } setAnalyzer ( settings . analyzer ( ) ) ; setMultiTermRewriteMethod ( settings . rewriteMethod ( ) ) ; setEnablePositionIncrements ( settings . enablePositionIncrements ( ) ) ; setAutoGeneratePhraseQueries ( settings . autoGeneratePhraseQueries ( ) ) ; setMaxDeterminizedStates ( settings . maxDeterminizedStates ( ) ) ; setAllowLeadingWildcard ( settings . allowLeadingWildcard ( ) ) ; setLowercaseExpandedTerms ( settings . lowercaseExpandedTerms ( ) ) ; setPhraseSlop ( settings . phraseSlop ( ) ) ; setDefaultOperator ( settings . defaultOperator ( ) ) ; setFuzzyMinSim ( settings . fuzziness ( ) . asFloat ( ) ) ; setFuzzyPrefixLength ( settings . fuzzyPrefixLength ( ) ) ; setLocale ( settings . locale ( ) ) ; } @Override Query handleBareFuzzy ( String qfield , Token fuzzySlop , String termImage ) throws ParseException { if ( fuzzySlop . image . length ( ) = = <int> ) { return getFuzzyQuery ( qfield , termImage , Float . toString ( fuzzyMinSim ) ) ; } return getFuzzyQuery ( qfield , termImage , fuzzySlop . image . substring ( <int> ) ) ; } @Override protected Query newTermQuery ( Term term ) { if ( currentFieldType ! = null ) { Query termQuery = currentFieldType . queryStringTermQuery ( term ) ; if ( termQuery ! = null ) { return termQuery ; } } return super . newTermQuery ( term ) ; } @Override protected Query newMatchAllDocsQuery ( ) { return Queries . newMatchAllQuery ( ) ; } @Override public Query getFieldQuery ( String field , String queryText , boolean quoted ) throws ParseException { FieldQueryExtension fieldQueryExtension = FIELD_QUERY_EXTENSIONS . get ( field ) ; if ( fieldQueryExtension ! = null ) { return fieldQueryExtension . query ( context , queryText ) ; } Collection < String > fields = extractMultiFields ( field ) ; if ( fields ! = null ) { if ( fields . size ( ) = = <int> ) { return getFieldQuerySingle ( fields . iterator ( ) . next ( ) , queryText , quoted ) ; } if ( settings . useDisMax ( ) ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( settings . tieBreaker ( ) ) ; boolean added = false ; for ( String mField : fields ) { Query q = getFieldQuerySingle ( mField , queryText , quoted ) ; if ( q ! = null ) { added = true ; disMaxQuery . add ( applyBoost ( mField , q ) ) ; } } if ( ! added ) { return null ; } return disMaxQuery ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( String mField : fields ) { Query q = getFieldQuerySingle ( mField , queryText , quoted ) ; if ( q ! = null ) { clauses . add ( new BooleanClause ( applyBoost ( mField , q ) , BooleanClause . Occur . SHOULD ) ) ; } } if ( clauses . size ( ) = = <int> ) return null ; return getBooleanQuery ( clauses , true ) ; } } else { return getFieldQuerySingle ( field , queryText , quoted ) ; } } private Query getFieldQuerySingle ( String field , String queryText , boolean quoted ) throws ParseException { if ( ! quoted & & queryText . length ( ) > <int> ) { if ( queryText . charAt ( <int> ) = = <str> ) { if ( queryText . length ( ) > <int> ) { if ( queryText . charAt ( <int> ) = = <str> ) { return getRangeQuerySingle ( field , queryText . substring ( <int> ) , null , true , true ) ; } } return getRangeQuerySingle ( field , queryText . substring ( <int> ) , null , false , true ) ; } else if ( queryText . charAt ( <int> ) = = <str> ) { if ( queryText . length ( ) > <int> ) { if ( queryText . charAt ( <int> ) = = <str> ) { return getRangeQuerySingle ( field , null , queryText . substring ( <int> ) , true , true ) ; } } return getRangeQuerySingle ( field , null , queryText . substring ( <int> ) , true , false ) ; } } currentFieldType = null ; Analyzer oldAnalyzer = getAnalyzer ( ) ; try { if ( quoted ) { setAnalyzer ( settings . quoteAnalyzer ( ) ) ; if ( settings . quoteFieldSuffix ( ) ! = null ) { currentFieldType = context . fieldMapper ( field + settings . quoteFieldSuffix ( ) ) ; } } if ( currentFieldType = = null ) { currentFieldType = context . fieldMapper ( field ) ; } if ( currentFieldType ! = null ) { if ( quoted ) { if ( ! settings . forceQuoteAnalyzer ( ) ) { setAnalyzer ( context . getSearchQuoteAnalyzer ( currentFieldType ) ) ; } } else { if ( ! settings . forceAnalyzer ( ) ) { setAnalyzer ( context . getSearchAnalyzer ( currentFieldType ) ) ; } } if ( currentFieldType ! = null ) { Query query = null ; if ( currentFieldType . useTermQueryWithQueryString ( ) ) { try { query = currentFieldType . termQuery ( queryText , context ) ; } catch ( RuntimeException e ) { if ( settings . lenient ( ) ) { return null ; } else { throw e ; } } } if ( query = = null ) { query = super . getFieldQuery ( currentFieldType . names ( ) . indexName ( ) , queryText , quoted ) ; } return query ; } } return super . getFieldQuery ( field , queryText , quoted ) ; } finally { setAnalyzer ( oldAnalyzer ) ; } } @Override protected Query getFieldQuery ( String field , String queryText , int slop ) throws ParseException { Collection < String > fields = extractMultiFields ( field ) ; if ( fields ! = null ) { if ( settings . useDisMax ( ) ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( settings . tieBreaker ( ) ) ; boolean added = false ; for ( String mField : fields ) { Query q = super . getFieldQuery ( mField , queryText , slop ) ; if ( q ! = null ) { added = true ; q = applySlop ( q , slop ) ; disMaxQuery . add ( applyBoost ( mField , q ) ) ; } } if ( ! added ) { return null ; } return disMaxQuery ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( String mField : fields ) { Query q = super . getFieldQuery ( mField , queryText , slop ) ; if ( q ! = null ) { q = applySlop ( q , slop ) ; clauses . add ( new BooleanClause ( applyBoost ( mField , q ) , BooleanClause . Occur . SHOULD ) ) ; } } if ( clauses . size ( ) = = <int> ) return null ; return getBooleanQuery ( clauses , true ) ; } } else { return super . getFieldQuery ( field , queryText , slop ) ; } } @Override protected Query getRangeQuery ( String field , String part1 , String part2 , boolean startInclusive , boolean endInclusive ) throws ParseException { if ( <str> . equals ( part1 ) ) { part1 = null ; } if ( <str> . equals ( part2 ) ) { part2 = null ; } Collection < String > fields = extractMultiFields ( field ) ; if ( fields = = null ) { return getRangeQuerySingle ( field , part1 , part2 , startInclusive , endInclusive ) ; } if ( fields . size ( ) = = <int> ) { return getRangeQuerySingle ( fields . iterator ( ) . next ( ) , part1 , part2 , startInclusive , endInclusive ) ; } if ( settings . useDisMax ( ) ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( settings . tieBreaker ( ) ) ; boolean added = false ; for ( String mField : fields ) { Query q = getRangeQuerySingle ( mField , part1 , part2 , startInclusive , endInclusive ) ; if ( q ! = null ) { added = true ; disMaxQuery . add ( applyBoost ( mField , q ) ) ; } } if ( ! added ) { return null ; } return disMaxQuery ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( String mField : fields ) { Query q = getRangeQuerySingle ( mField , part1 , part2 , startInclusive , endInclusive ) ; if ( q ! = null ) { clauses . add ( new BooleanClause ( applyBoost ( mField , q ) , BooleanClause . Occur . SHOULD ) ) ; } } if ( clauses . size ( ) = = <int> ) return null ; return getBooleanQuery ( clauses , true ) ; } } private Query getRangeQuerySingle ( String field , String part1 , String part2 , boolean startInclusive , boolean endInclusive ) { currentFieldType = context . fieldMapper ( field ) ; if ( currentFieldType ! = null ) { if ( lowercaseExpandedTerms & & ! currentFieldType . isNumeric ( ) ) { part1 = part1 = = null ? null : part1 . toLowerCase ( locale ) ; part2 = part2 = = null ? null : part2 . toLowerCase ( locale ) ; } try { Query rangeQuery ; if ( currentFieldType instanceof DateFieldMapper . DateFieldType & & settings . timeZone ( ) ! = null ) { DateFieldMapper . DateFieldType dateFieldType = ( DateFieldMapper . DateFieldType ) this . currentFieldType ; rangeQuery = dateFieldType . rangeQuery ( part1 , part2 , startInclusive , endInclusive , settings . timeZone ( ) , null ) ; } else { rangeQuery = currentFieldType . rangeQuery ( part1 , part2 , startInclusive , endInclusive ) ; } return rangeQuery ; } catch ( RuntimeException e ) { if ( settings . lenient ( ) ) { return null ; } throw e ; } } return newRangeQuery ( field , part1 , part2 , startInclusive , endInclusive ) ; } protected Query getFuzzyQuery ( String field , String termStr , String minSimilarity ) throws ParseException { if ( lowercaseExpandedTerms ) { termStr = termStr . toLowerCase ( locale ) ; } Collection < String > fields = extractMultiFields ( field ) ; if ( fields ! = null ) { if ( fields . size ( ) = = <int> ) { return getFuzzyQuerySingle ( fields . iterator ( ) . next ( ) , termStr , minSimilarity ) ; } if ( settings . useDisMax ( ) ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( settings . tieBreaker ( ) ) ; boolean added = false ; for ( String mField : fields ) { Query q = getFuzzyQuerySingle ( mField , termStr , minSimilarity ) ; if ( q ! = null ) { added = true ; disMaxQuery . add ( applyBoost ( mField , q ) ) ; } } if ( ! added ) { return null ; } return disMaxQuery ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( String mField : fields ) { Query q = getFuzzyQuerySingle ( mField , termStr , minSimilarity ) ; if ( q ! = null ) { clauses . add ( new BooleanClause ( applyBoost ( mField , q ) , BooleanClause . Occur . SHOULD ) ) ; } } return getBooleanQuery ( clauses , true ) ; } } else { return getFuzzyQuerySingle ( field , termStr , minSimilarity ) ; } } private Query getFuzzyQuerySingle ( String field , String termStr , String minSimilarity ) throws ParseException { currentFieldType = context . fieldMapper ( field ) ; if ( currentFieldType ! = null ) { try { return currentFieldType . fuzzyQuery ( termStr , Fuzziness . build ( minSimilarity ) , fuzzyPrefixLength , settings . fuzzyMaxExpansions ( ) , FuzzyQuery . defaultTranspositions ) ; } catch ( RuntimeException e ) { if ( settings . lenient ( ) ) { return null ; } throw e ; } } return super . getFuzzyQuery ( field , termStr , Float . parseFloat ( minSimilarity ) ) ; } @Override protected Query newFuzzyQuery ( Term term , float minimumSimilarity , int prefixLength ) { String text = term . text ( ) ; int numEdits = FuzzyQuery . floatToEdits ( minimumSimilarity , text . codePointCount ( <int> , text . length ( ) ) ) ; FuzzyQuery query = new FuzzyQuery ( term , numEdits , prefixLength , settings . fuzzyMaxExpansions ( ) , FuzzyQuery . defaultTranspositions ) ; QueryParsers . setRewriteMethod ( query , settings . fuzzyRewriteMethod ( ) ) ; return query ; } @Override protected Query getPrefixQuery ( String field , String termStr ) throws ParseException { if ( lowercaseExpandedTerms ) { termStr = termStr . toLowerCase ( locale ) ; } Collection < String > fields = extractMultiFields ( field ) ; if ( fields ! = null ) { if ( fields . size ( ) = = <int> ) { return getPrefixQuerySingle ( fields . iterator ( ) . next ( ) , termStr ) ; } if ( settings . useDisMax ( ) ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( settings . tieBreaker ( ) ) ; boolean added = false ; for ( String mField : fields ) { Query q = getPrefixQuerySingle ( mField , termStr ) ; if ( q ! = null ) { added = true ; disMaxQuery . add ( applyBoost ( mField , q ) ) ; } } if ( ! added ) { return null ; } return disMaxQuery ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( String mField : fields ) { Query q = getPrefixQuerySingle ( mField , termStr ) ; if ( q ! = null ) { clauses . add ( new BooleanClause ( applyBoost ( mField , q ) , BooleanClause . Occur . SHOULD ) ) ; } } if ( clauses . size ( ) = = <int> ) return null ; return getBooleanQuery ( clauses , true ) ; } } else { return getPrefixQuerySingle ( field , termStr ) ; } } private Query getPrefixQuerySingle ( String field , String termStr ) throws ParseException { currentFieldType = null ; Analyzer oldAnalyzer = getAnalyzer ( ) ; try { currentFieldType = context . fieldMapper ( field ) ; if ( currentFieldType ! = null ) { if ( ! settings . forceAnalyzer ( ) ) { setAnalyzer ( context . getSearchAnalyzer ( currentFieldType ) ) ; } Query query = null ; if ( currentFieldType . useTermQueryWithQueryString ( ) ) { query = currentFieldType . prefixQuery ( termStr , multiTermRewriteMethod , context ) ; } if ( query = = null ) { query = getPossiblyAnalyzedPrefixQuery ( currentFieldType . names ( ) . indexName ( ) , termStr ) ; } return query ; } return getPossiblyAnalyzedPrefixQuery ( field , termStr ) ; } catch ( RuntimeException e ) { if ( settings . lenient ( ) ) { return null ; } throw e ; } finally { setAnalyzer ( oldAnalyzer ) ; } } private Query getPossiblyAnalyzedPrefixQuery ( String field , String termStr ) throws ParseException { if ( ! settings . analyzeWildcard ( ) ) { return super . getPrefixQuery ( field , termStr ) ; } List < String > tlist ; TokenStream source = null ; try { try { source = getAnalyzer ( ) . tokenStream ( field , termStr ) ; source . reset ( ) ; } catch ( IOException e ) { return super . getPrefixQuery ( field , termStr ) ; } tlist = new ArrayList < > ( ) ; CharTermAttribute termAtt = source . addAttribute ( CharTermAttribute . class ) ; while ( true ) { try { if ( ! source . incrementToken ( ) ) break ; } catch ( IOException e ) { break ; } tlist . add ( termAtt . toString ( ) ) ; } } finally { if ( source ! = null ) { IOUtils . closeWhileHandlingException ( source ) ; } } if ( tlist . size ( ) = = <int> ) { return super . getPrefixQuery ( field , tlist . get ( <int> ) ) ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( String token : tlist ) { clauses . add ( new BooleanClause ( super . getPrefixQuery ( field , token ) , BooleanClause . Occur . SHOULD ) ) ; } return getBooleanQuery ( clauses , true ) ; } } @Override protected Query getWildcardQuery ( String field , String termStr ) throws ParseException { if ( termStr . equals ( <str> ) ) { if ( <str> . equals ( field ) | | Objects . equals ( field , this . field ) ) { String actualField = field ; if ( actualField = = null ) { actualField = this . field ; } if ( actualField = = null ) { return newMatchAllDocsQuery ( ) ; } if ( <str> . equals ( actualField ) | | <str> . equals ( actualField ) ) { return newMatchAllDocsQuery ( ) ; } return FIELD_QUERY_EXTENSIONS . get ( ExistsFieldQueryExtension . NAME ) . query ( context , actualField ) ; } } if ( lowercaseExpandedTerms ) { termStr = termStr . toLowerCase ( locale ) ; } Collection < String > fields = extractMultiFields ( field ) ; if ( fields ! = null ) { if ( fields . size ( ) = = <int> ) { return getWildcardQuerySingle ( fields . iterator ( ) . next ( ) , termStr ) ; } if ( settings . useDisMax ( ) ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( settings . tieBreaker ( ) ) ; boolean added = false ; for ( String mField : fields ) { Query q = getWildcardQuerySingle ( mField , termStr ) ; if ( q ! = null ) { added = true ; disMaxQuery . add ( applyBoost ( mField , q ) ) ; } } if ( ! added ) { return null ; } return disMaxQuery ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( String mField : fields ) { Query q = getWildcardQuerySingle ( mField , termStr ) ; if ( q ! = null ) { clauses . add ( new BooleanClause ( applyBoost ( mField , q ) , BooleanClause . Occur . SHOULD ) ) ; } } if ( clauses . size ( ) = = <int> ) return null ; return getBooleanQuery ( clauses , true ) ; } } else { return getWildcardQuerySingle ( field , termStr ) ; } } private Query getWildcardQuerySingle ( String field , String termStr ) throws ParseException { String indexedNameField = field ; currentFieldType = null ; Analyzer oldAnalyzer = getAnalyzer ( ) ; try { currentFieldType = context . fieldMapper ( field ) ; if ( currentFieldType ! = null ) { if ( ! settings . forceAnalyzer ( ) ) { setAnalyzer ( context . getSearchAnalyzer ( currentFieldType ) ) ; } indexedNameField = currentFieldType . names ( ) . indexName ( ) ; return getPossiblyAnalyzedWildcardQuery ( indexedNameField , termStr ) ; } return getPossiblyAnalyzedWildcardQuery ( indexedNameField , termStr ) ; } catch ( RuntimeException e ) { if ( settings . lenient ( ) ) { return null ; } throw e ; } finally { setAnalyzer ( oldAnalyzer ) ; } } private Query getPossiblyAnalyzedWildcardQuery ( String field , String termStr ) throws ParseException { if ( ! settings . analyzeWildcard ( ) ) { return super . getWildcardQuery ( field , termStr ) ; } boolean isWithinToken = ( ! termStr . startsWith ( <str> ) & & ! termStr . startsWith ( <str> ) ) ; StringBuilder aggStr = new StringBuilder ( ) ; StringBuilder tmp = new StringBuilder ( ) ; for ( int i = <int> ; i < termStr . length ( ) ; i + + ) { char c = termStr . charAt ( i ) ; if ( c = = <str> | | c = = <str> ) { if ( isWithinToken ) { try ( TokenStream source = getAnalyzer ( ) . tokenStream ( field , tmp . toString ( ) ) ) { source . reset ( ) ; CharTermAttribute termAtt = source . addAttribute ( CharTermAttribute . class ) ; if ( source . incrementToken ( ) ) { String term = termAtt . toString ( ) ; if ( term . length ( ) = = <int> ) { aggStr . append ( tmp ) ; } else { aggStr . append ( term ) ; } } else { aggStr . append ( tmp ) ; } } catch ( IOException e ) { aggStr . append ( tmp ) ; } tmp . setLength ( <int> ) ; } isWithinToken = false ; aggStr . append ( c ) ; } else { tmp . append ( c ) ; isWithinToken = true ; } } if ( isWithinToken ) { try { try ( TokenStream source = getAnalyzer ( ) . tokenStream ( field , tmp . toString ( ) ) ) { source . reset ( ) ; CharTermAttribute termAtt = source . addAttribute ( CharTermAttribute . class ) ; if ( source . incrementToken ( ) ) { String term = termAtt . toString ( ) ; if ( term . length ( ) = = <int> ) { aggStr . append ( tmp ) ; } else { aggStr . append ( term ) ; } } else { aggStr . append ( tmp ) ; } } } catch ( IOException e ) { aggStr . append ( tmp ) ; } } return super . getWildcardQuery ( field , aggStr . toString ( ) ) ; } @Override protected Query getRegexpQuery ( String field , String termStr ) throws ParseException { if ( lowercaseExpandedTerms ) { termStr = termStr . toLowerCase ( locale ) ; } Collection < String > fields = extractMultiFields ( field ) ; if ( fields ! = null ) { if ( fields . size ( ) = = <int> ) { return getRegexpQuerySingle ( fields . iterator ( ) . next ( ) , termStr ) ; } if ( settings . useDisMax ( ) ) { DisjunctionMaxQuery disMaxQuery = new DisjunctionMaxQuery ( settings . tieBreaker ( ) ) ; boolean added = false ; for ( String mField : fields ) { Query q = getRegexpQuerySingle ( mField , termStr ) ; if ( q ! = null ) { added = true ; disMaxQuery . add ( applyBoost ( mField , q ) ) ; } } if ( ! added ) { return null ; } return disMaxQuery ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( String mField : fields ) { Query q = getRegexpQuerySingle ( mField , termStr ) ; if ( q ! = null ) { clauses . add ( new BooleanClause ( applyBoost ( mField , q ) , BooleanClause . Occur . SHOULD ) ) ; } } if ( clauses . size ( ) = = <int> ) return null ; return getBooleanQuery ( clauses , true ) ; } } else { return getRegexpQuerySingle ( field , termStr ) ; } } private Query getRegexpQuerySingle ( String field , String termStr ) throws ParseException { currentFieldType = null ; Analyzer oldAnalyzer = getAnalyzer ( ) ; try { currentFieldType = context . fieldMapper ( field ) ; if ( currentFieldType ! = null ) { if ( ! settings . forceAnalyzer ( ) ) { setAnalyzer ( context . getSearchAnalyzer ( currentFieldType ) ) ; } Query query = null ; if ( currentFieldType . useTermQueryWithQueryString ( ) ) { query = currentFieldType . regexpQuery ( termStr , RegExp . ALL , maxDeterminizedStates , multiTermRewriteMethod , context ) ; } if ( query = = null ) { query = super . getRegexpQuery ( field , termStr ) ; } return query ; } return super . getRegexpQuery ( field , termStr ) ; } catch ( RuntimeException e ) { if ( settings . lenient ( ) ) { return null ; } throw e ; } finally { setAnalyzer ( oldAnalyzer ) ; } } @Override protected Query getBooleanQuery ( List < BooleanClause > clauses , boolean disableCoord ) throws ParseException { Query q = super . getBooleanQuery ( clauses , disableCoord ) ; if ( q = = null ) { return null ; } return fixNegativeQueryIfNeeded ( q ) ; } private Query applyBoost ( String field , Query q ) { Float fieldBoost = settings . fieldsAndWeights ( ) . get ( field ) ; if ( fieldBoost ! = null & & fieldBoost ! = <float> ) { return new BoostQuery ( q , fieldBoost ) ; } return q ; } private Query applySlop ( Query q , int slop ) { if ( q instanceof PhraseQuery ) { PhraseQuery pq = ( PhraseQuery ) q ; PhraseQuery . Builder builder = new PhraseQuery . Builder ( ) ; builder . setSlop ( slop ) ; final Term [ ] terms = pq . getTerms ( ) ; final int [ ] positions = pq . getPositions ( ) ; for ( int i = <int> ; i < terms . length ; + + i ) { builder . add ( terms [ i ] , positions [ i ] ) ; } pq = builder . build ( ) ; assert q . getBoost ( ) = = <float> ; assert q instanceof BoostQuery = = false ; return pq ; } else if ( q instanceof MultiPhraseQuery ) { ( ( MultiPhraseQuery ) q ) . setSlop ( slop ) ; return q ; } else { return q ; } } private Collection < String > extractMultiFields ( String field ) { Collection < String > fields ; if ( field ! = null ) { fields = context . simpleMatchToIndexNames ( field ) ; } else { fields = settings . fieldsAndWeights ( ) . keySet ( ) ; } return fields ; } @Override public Query parse ( String query ) throws ParseException { if ( query . trim ( ) . isEmpty ( ) ) { return new MatchNoDocsQuery ( ) ; } return super . parse ( query ) ; } } 
