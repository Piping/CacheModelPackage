package com . google . common . math ; import static com . google . common . math . Quantiles . median ; import static com . google . common . math . Quantiles . percentiles ; import static com . google . common . math . Quantiles . quartiles ; import static com . google . common . truth . Truth . assertThat ; import static java . lang . Double . NEGATIVE_INFINITY ; import static java . lang . Double . NaN ; import static java . lang . Double . POSITIVE_INFINITY ; import static java . math . RoundingMode . CEILING ; import static java . math . RoundingMode . FLOOR ; import static java . math . RoundingMode . UNNECESSARY ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . Ordering ; import com . google . common . math . Quantiles . ScaleAndIndexes ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import junit . framework . TestCase ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import java . util . Random ; public class QuantilesTest extends TestCase { private static final double ALLOWED_ERROR = <float> ; private static final ImmutableList < Double > SIXTEEN_SQUARES_DOUBLES = ImmutableList . of ( <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> ) ; private static final ImmutableList < Long > SIXTEEN_SQUARES_LONGS = ImmutableList . of ( <int> , <int> , <int> L , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; private static final ImmutableList < Integer > SIXTEEN_SQUARES_INTEGERS = ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; private static final double SIXTEEN_SQUARES_MIN = <float> ; private static final double SIXTEEN_SQUARES_DECILE_1 = <float> * ( <float> + <float> ) ; private static final double SIXTEEN_SQUARES_QUARTILE_1 = <float> * <float> + <float> * <float> ; private static final double SIXTEEN_SQUARES_MEDIAN = <float> * ( <float> + <float> ) ; private static final double SIXTEEN_SQUARES_QUARTILE_3 = <float> * <float> + <float> * <float> ; private static final double SIXTEEN_SQUARES_DECILE_8 = <float> ; private static final double SIXTEEN_SQUARES_MAX = <float> ; public void testMedian_compute_doubleCollection ( ) { assertQuantile ( <int> , SIXTEEN_SQUARES_MEDIAN , median ( ) . compute ( SIXTEEN_SQUARES_DOUBLES ) ) ; } public void testMedian_computeInPlace ( ) { double [ ] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; assertQuantile ( <int> , SIXTEEN_SQUARES_MEDIAN , median ( ) . computeInPlace ( dataset ) ) ; assertDatasetAnyOrder ( SIXTEEN_SQUARES_DOUBLES , dataset ) ; } public void testQuartiles_index_compute_doubleCollection ( ) { assertQuantile ( <int> , SIXTEEN_SQUARES_QUARTILE_1 , quartiles ( ) . index ( <int> ) . compute ( SIXTEEN_SQUARES_DOUBLES ) ) ; } public void testQuartiles_index_computeInPlace ( ) { double [ ] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; assertQuantile ( <int> , SIXTEEN_SQUARES_QUARTILE_1 , quartiles ( ) . index ( <int> ) . computeInPlace ( dataset ) ) ; assertDatasetAnyOrder ( SIXTEEN_SQUARES_DOUBLES , dataset ) ; } public void testQuartiles_indexes_varargs_compute_doubleCollection ( ) { ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_QUARTILE_1 , <int> , SIXTEEN_SQUARES_QUARTILE_3 ) ; assertQuantilesMap ( expected , quartiles ( ) . indexes ( <int> , <int> ) . compute ( SIXTEEN_SQUARES_DOUBLES ) ) ; } public void testQuartiles_indexes_varargs_computeInPlace ( ) { double [ ] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_QUARTILE_1 , <int> , SIXTEEN_SQUARES_QUARTILE_3 ) ; assertQuantilesMap ( expected , quartiles ( ) . indexes ( <int> , <int> ) . computeInPlace ( dataset ) ) ; assertDatasetAnyOrder ( SIXTEEN_SQUARES_DOUBLES , dataset ) ; } public void testScale_index_compute_doubleCollection ( ) { assertQuantile ( <int> , SIXTEEN_SQUARES_DECILE_1 , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( SIXTEEN_SQUARES_DOUBLES ) ) ; } public void testScale_index_compute_longCollection ( ) { assertQuantile ( <int> , SIXTEEN_SQUARES_DECILE_1 , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( SIXTEEN_SQUARES_LONGS ) ) ; } public void testScale_index_compute_integerCollection ( ) { assertQuantile ( <int> , SIXTEEN_SQUARES_DECILE_1 , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( SIXTEEN_SQUARES_INTEGERS ) ) ; } public void testScale_index_compute_doubleVarargs ( ) { double [ ] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; assertQuantile ( <int> , SIXTEEN_SQUARES_DECILE_1 , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( dataset ) ) ; assertDatasetInOrder ( SIXTEEN_SQUARES_DOUBLES , dataset ) ; } public void testScale_index_compute_longVarargs ( ) { long [ ] dataset = Longs . toArray ( SIXTEEN_SQUARES_LONGS ) ; assertQuantile ( <int> , SIXTEEN_SQUARES_DECILE_1 , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( dataset ) ) ; assertDatasetInOrder ( SIXTEEN_SQUARES_LONGS , dataset ) ; } public void testScale_index_compute_intVarargs ( ) { int [ ] dataset = Ints . toArray ( SIXTEEN_SQUARES_INTEGERS ) ; assertQuantile ( <int> , SIXTEEN_SQUARES_DECILE_1 , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( dataset ) ) ; assertDatasetInOrder ( SIXTEEN_SQUARES_INTEGERS , dataset ) ; } public void testScale_index_computeInPlace ( ) { double [ ] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; assertQuantile ( <int> , SIXTEEN_SQUARES_DECILE_1 , Quantiles . scale ( <int> ) . index ( <int> ) . computeInPlace ( dataset ) ) ; assertDatasetAnyOrder ( SIXTEEN_SQUARES_DOUBLES , dataset ) ; } public void testScale_index_computeInPlace_explicitVarargs ( ) { assertQuantile ( <int> , <float> , Quantiles . scale ( <int> ) . index ( <int> ) . computeInPlace ( <float> , <float> , <float> ) ) ; } public void testScale_indexes_varargs_compute_doubleCollection ( ) { ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( SIXTEEN_SQUARES_DOUBLES ) ) ; } public void testScale_indexes_varargs_compute_doubleCollection_snapshotsIndexes ( ) { ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; int [ ] indexes = { <int> , <int> , <int> , <int> , <int> , <int> } ; ScaleAndIndexes intermediate = Quantiles . scale ( <int> ) . indexes ( indexes ) ; indexes [ <int> ] = <int> ; assertQuantilesMap ( expected , intermediate . compute ( SIXTEEN_SQUARES_DOUBLES ) ) ; } public void testScale_indexes_largeVarargs_compute_doubleCollection ( ) { int scale = Integer . MAX_VALUE ; int otherIndex = ( Integer . MAX_VALUE - <int> ) / <int> ; double otherValue = <float> * <float> / Integer . MAX_VALUE + <float> * ( <float> - <float> / Integer . MAX_VALUE ) ; ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , scale , SIXTEEN_SQUARES_MAX , otherIndex , otherValue ) ; assertQuantilesMap ( expected , Quantiles . scale ( scale ) . indexes ( <int> , scale , otherIndex ) . compute ( SIXTEEN_SQUARES_DOUBLES ) ) ; } public void testScale_indexes_varargs_compute_longCollection ( ) { ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( SIXTEEN_SQUARES_LONGS ) ) ; } public void testScale_indexes_varargs_compute_integerCollection ( ) { ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( SIXTEEN_SQUARES_INTEGERS ) ) ; } public void testScale_indexes_varargs_compute_doubleVarargs ( ) { double [ ] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( dataset ) ) ; assertDatasetInOrder ( SIXTEEN_SQUARES_DOUBLES , dataset ) ; } public void testScale_indexes_varargs_compute_longVarargs ( ) { long [ ] dataset = Longs . toArray ( SIXTEEN_SQUARES_LONGS ) ; ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( dataset ) ) ; assertDatasetInOrder ( SIXTEEN_SQUARES_LONGS , dataset ) ; } public void testScale_indexes_varargs_compute_intVarargs ( ) { int [ ] dataset = Ints . toArray ( SIXTEEN_SQUARES_INTEGERS ) ; ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( dataset ) ) ; assertDatasetInOrder ( SIXTEEN_SQUARES_INTEGERS , dataset ) ; } public void testScale_indexes_varargs_computeInPlace ( ) { double [ ] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . computeInPlace ( dataset ) ) ; assertDatasetAnyOrder ( SIXTEEN_SQUARES_DOUBLES , dataset ) ; } public void testScale_indexes_varargs_computeInPlace_explicitVarargs ( ) { ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , <float> , <int> , <float> ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( <int> , <int> ) . computeInPlace ( <float> , <float> , <float> ) ) ; } public void testScale_indexes_collection_compute_doubleCollection ( ) { ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> ) ) . compute ( SIXTEEN_SQUARES_DOUBLES ) ) ; } public void testScale_indexes_collection_computeInPlace ( ) { double [ ] dataset = Doubles . toArray ( SIXTEEN_SQUARES_DOUBLES ) ; ImmutableMap < Integer , Double > expected = ImmutableMap . of ( <int> , SIXTEEN_SQUARES_MIN , <int> , SIXTEEN_SQUARES_MAX , <int> , SIXTEEN_SQUARES_MEDIAN , <int> , SIXTEEN_SQUARES_DECILE_1 , <int> , SIXTEEN_SQUARES_DECILE_8 ) ; assertQuantilesMap ( expected , Quantiles . scale ( <int> ) . indexes ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> ) ) . computeInPlace ( dataset ) ) ; assertDatasetAnyOrder ( SIXTEEN_SQUARES_DOUBLES , dataset ) ; } private static final ImmutableList < Double > ONE_TO_FIVE_AND_POSITIVE_INFINITY = ImmutableList . of ( <float> , <float> , POSITIVE_INFINITY , <float> , <float> , <float> ) ; private static final ImmutableList < Double > ONE_TO_FIVE_AND_NEGATIVE_INFINITY = ImmutableList . of ( <float> , <float> , NEGATIVE_INFINITY , <float> , <float> , <float> ) ; private static final ImmutableList < Double > NEGATIVE_INFINITY_AND_FIVE_POSITIVE_INFINITIES = ImmutableList . of ( POSITIVE_INFINITY , POSITIVE_INFINITY , NEGATIVE_INFINITY , POSITIVE_INFINITY , POSITIVE_INFINITY , POSITIVE_INFINITY ) ; private static final ImmutableList < Double > ONE_TO_FIVE_AND_NAN = ImmutableList . of ( <float> , <float> , NaN , <float> , <float> , <float> ) ; public void testScale_indexes_varargs_compute_doubleCollection_positiveInfinity ( ) { Map < Integer , Double > actual = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( ONE_TO_FIVE_AND_POSITIVE_INFINITY ) ; Map < Integer , Double > expected = ImmutableMap . < Integer , Double > builder ( ) . put ( <int> , <float> ) . put ( <int> , <float> ) . put ( <int> , <float> ) . put ( <int> , <float> ) . put ( <int> , POSITIVE_INFINITY ) . put ( <int> , POSITIVE_INFINITY ) . build ( ) ; assertQuantilesMap ( expected , actual ) ; } public void testScale_index_compute_doubleCollection_positiveInfinity ( ) { assertQuantile ( <int> , POSITIVE_INFINITY , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( ONE_TO_FIVE_AND_POSITIVE_INFINITY ) ) ; } public void testScale_indexes_varargs_compute_doubleCollection_negativeInfinity ( ) { Map < Integer , Double > actual = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( ONE_TO_FIVE_AND_NEGATIVE_INFINITY ) ; Map < Integer , Double > expected = ImmutableMap . < Integer , Double > builder ( ) . put ( <int> , NEGATIVE_INFINITY ) . put ( <int> , NEGATIVE_INFINITY ) . put ( <int> , <float> ) . put ( <int> , <float> ) . put ( <int> , <float> ) . put ( <int> , <float> ) . build ( ) ; assertQuantilesMap ( expected , actual ) ; } public void testScale_index_compute_doubleCollection_negativeInfinity ( ) { assertQuantile ( <int> , NEGATIVE_INFINITY , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( ONE_TO_FIVE_AND_NEGATIVE_INFINITY ) ) ; } public void testScale_indexes_varargs_compute_doubleCollection_bothInfinities ( ) { Map < Integer , Double > actual = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( NEGATIVE_INFINITY_AND_FIVE_POSITIVE_INFINITIES ) ; Map < Integer , Double > expected = ImmutableMap . < Integer , Double > builder ( ) . put ( <int> , NEGATIVE_INFINITY ) . put ( <int> , NaN ) . put ( <int> , POSITIVE_INFINITY ) . put ( <int> , POSITIVE_INFINITY ) . put ( <int> , POSITIVE_INFINITY ) . put ( <int> , POSITIVE_INFINITY ) . build ( ) ; assertQuantilesMap ( expected , actual ) ; } public void testScale_indexes_varargs_compute_doubleCollection_nan ( ) { Map < Integer , Double > actual = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> , <int> , <int> , <int> ) . compute ( ONE_TO_FIVE_AND_NAN ) ; Map < Integer , Double > expected = ImmutableMap . < Integer , Double > builder ( ) . put ( <int> , NaN ) . put ( <int> , NaN ) . put ( <int> , NaN ) . put ( <int> , NaN ) . put ( <int> , NaN ) . put ( <int> , NaN ) . build ( ) ; assertQuantilesMap ( expected , actual ) ; } public void testScale_index_compute_doubleCollection_nan ( ) { assertQuantile ( <int> , NaN , Quantiles . scale ( <int> ) . index ( <int> ) . compute ( ONE_TO_FIVE_AND_NAN ) ) ; } private static final int PSEUDORANDOM_DATASET_SIZE = <int> ; private static final ImmutableList < Double > PSEUDORANDOM_DATASET = generatePseudorandomDataset ( ) ; private static final ImmutableList < Double > PSEUDORANDOM_DATASET_SORTED = Ordering . natural ( ) . immutableSortedCopy ( PSEUDORANDOM_DATASET ) ; private static ImmutableList < Double > generatePseudorandomDataset ( ) { Random random = new Random ( <int> ) ; ImmutableList . Builder < Double > largeDatasetBuilder = ImmutableList . builder ( ) ; for ( int i = <int> ; i < PSEUDORANDOM_DATASET_SIZE ; i + + ) { largeDatasetBuilder . add ( random . nextGaussian ( ) ) ; } return largeDatasetBuilder . build ( ) ; } private static double expectedLargeDatasetPercentile ( int index ) { if ( index % <int> = = <int> ) { int position = IntMath . divide ( <int> * index , <int> , UNNECESSARY ) ; return PSEUDORANDOM_DATASET_SORTED . get ( position ) ; } else { int positionFloor = IntMath . divide ( <int> * index , <int> , FLOOR ) ; int positionCeil = IntMath . divide ( <int> * index , <int> , CEILING ) ; double lowerValue = PSEUDORANDOM_DATASET_SORTED . get ( positionFloor ) ; double upperValue = PSEUDORANDOM_DATASET_SORTED . get ( positionCeil ) ; return ( lowerValue + upperValue ) / <float> ; } } public void testPercentiles_index_compute_doubleCollection ( ) { for ( int index = <int> ; index < = <int> ; index + + ) { double expected = expectedLargeDatasetPercentile ( index ) ; assertQuantile ( index , expected , percentiles ( ) . index ( index ) . compute ( PSEUDORANDOM_DATASET ) ) ; } } public void testPercentiles_index_computeInPlace ( ) { for ( int index = <int> ; index < = <int> ; index + + ) { double [ ] dataset = Doubles . toArray ( PSEUDORANDOM_DATASET ) ; double expected = expectedLargeDatasetPercentile ( index ) ; assertQuantile ( index , expected , percentiles ( ) . index ( index ) . computeInPlace ( dataset ) ) ; assertDatasetAnyOrder ( PSEUDORANDOM_DATASET , dataset ) ; } } public void testPercentiles_indexes_varargsPairs_compute_doubleCollection ( ) { for ( int index1 = <int> ; index1 < = <int> ; index1 + + ) { for ( int index2 = <int> ; index2 < = <int> ; index2 + + ) { ImmutableMap . Builder < Integer , Double > expectedBuilder = ImmutableMap . builder ( ) ; expectedBuilder . put ( index1 , expectedLargeDatasetPercentile ( index1 ) ) ; if ( index2 ! = index1 ) { expectedBuilder . put ( index2 , expectedLargeDatasetPercentile ( index2 ) ) ; } ImmutableMap < Integer , Double > expected = expectedBuilder . build ( ) ; assertQuantilesMap ( expected , percentiles ( ) . indexes ( index1 , index2 ) . compute ( PSEUDORANDOM_DATASET ) ) ; } } } public void testPercentiles_indexes_varargsAll_compute_doubleCollection ( ) { ArrayList < Integer > indexes = new ArrayList < Integer > ( ) ; ImmutableMap . Builder < Integer , Double > expectedBuilder = ImmutableMap . builder ( ) ; for ( int index = <int> ; index < = <int> ; index + + ) { indexes . add ( index ) ; expectedBuilder . put ( index , expectedLargeDatasetPercentile ( index ) ) ; } Random random = new Random ( <int> ) ; Collections . shuffle ( indexes , random ) ; assertQuantilesMap ( expectedBuilder . build ( ) , percentiles ( ) . indexes ( Ints . toArray ( indexes ) ) . compute ( PSEUDORANDOM_DATASET ) ) ; } public void testPercentiles_indexes_varargsAll_computeInPlace ( ) { double [ ] dataset = Doubles . toArray ( PSEUDORANDOM_DATASET ) ; List < Integer > indexes = new ArrayList < Integer > ( ) ; ImmutableMap . Builder < Integer , Double > expectedBuilder = ImmutableMap . builder ( ) ; for ( int index = <int> ; index < = <int> ; index + + ) { indexes . add ( index ) ; expectedBuilder . put ( index , expectedLargeDatasetPercentile ( index ) ) ; } Random random = new Random ( <int> ) ; Collections . shuffle ( indexes , random ) ; assertQuantilesMap ( expectedBuilder . build ( ) , percentiles ( ) . indexes ( Ints . toArray ( indexes ) ) . computeInPlace ( dataset ) ) ; assertDatasetAnyOrder ( PSEUDORANDOM_DATASET , dataset ) ; } private static final ImmutableList < Double > EMPTY_DATASET = ImmutableList . of ( ) ; public void testScale_zero ( ) { try { Quantiles . scale ( <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_negative ( ) { try { Quantiles . scale ( - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_index_negative ( ) { Quantiles . Scale intermediate = Quantiles . scale ( <int> ) ; try { intermediate . index ( - <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_index_tooHigh ( ) { Quantiles . Scale intermediate = Quantiles . scale ( <int> ) ; try { intermediate . index ( <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_varargs_negative ( ) { Quantiles . Scale intermediate = Quantiles . scale ( <int> ) ; try { intermediate . indexes ( <int> , - <int> , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_varargs_tooHigh ( ) { Quantiles . Scale intermediate = Quantiles . scale ( <int> ) ; try { intermediate . indexes ( <int> , <int> , <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_collection_negative ( ) { Quantiles . Scale intermediate = Quantiles . scale ( <int> ) ; try { intermediate . indexes ( ImmutableList . of ( <int> , - <int> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_collection_tooHigh ( ) { Quantiles . Scale intermediate = Quantiles . scale ( <int> ) ; try { intermediate . indexes ( ImmutableList . of ( <int> , <int> , <int> ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_index_compute_doubleCollection_empty ( ) { Quantiles . ScaleAndIndex intermediate = Quantiles . scale ( <int> ) . index ( <int> ) ; try { intermediate . compute ( EMPTY_DATASET ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_index_compute_doubleVarargs_empty ( ) { Quantiles . ScaleAndIndex intermediate = Quantiles . scale ( <int> ) . index ( <int> ) ; try { intermediate . compute ( new double [ ] { } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_index_compute_longVarargs_empty ( ) { Quantiles . ScaleAndIndex intermediate = Quantiles . scale ( <int> ) . index ( <int> ) ; try { intermediate . compute ( new long [ ] { } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_index_compute_intVarargs_empty ( ) { Quantiles . ScaleAndIndex intermediate = Quantiles . scale ( <int> ) . index ( <int> ) ; try { intermediate . compute ( new int [ ] { } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_index_computeInPlace_empty ( ) { Quantiles . ScaleAndIndex intermediate = Quantiles . scale ( <int> ) . index ( <int> ) ; try { intermediate . computeInPlace ( new double [ ] { } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_varargs_compute_doubleCollection_empty ( ) { Quantiles . ScaleAndIndexes intermediate = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> ) ; try { intermediate . compute ( EMPTY_DATASET ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_varargs_compute_doubleVarargs_empty ( ) { Quantiles . ScaleAndIndexes intermediate = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> ) ; try { intermediate . compute ( new double [ ] { } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_varargs_compute_longVarargs_empty ( ) { Quantiles . ScaleAndIndexes intermediate = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> ) ; try { intermediate . compute ( new long [ ] { } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_varargs_compute_intVarargs_empty ( ) { Quantiles . ScaleAndIndexes intermediate = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> ) ; try { intermediate . compute ( new int [ ] { } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testScale_indexes_varargs_computeInPlace_empty ( ) { Quantiles . ScaleAndIndexes intermediate = Quantiles . scale ( <int> ) . indexes ( <int> , <int> , <int> ) ; try { intermediate . computeInPlace ( new double [ ] { } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } private static void assertQuantile ( int index , double expected , double actual ) { if ( expected = = POSITIVE_INFINITY ) { assertThat ( actual ) . named ( <str> + index ) . isPositiveInfinity ( ) ; } else if ( expected = = NEGATIVE_INFINITY ) { assertThat ( actual ) . named ( <str> + index ) . isNegativeInfinity ( ) ; } else if ( Double . isNaN ( expected ) ) { assertThat ( actual ) . named ( <str> + index ) . isNaN ( ) ; } else { assertThat ( actual ) . named ( <str> + index ) . isWithin ( ALLOWED_ERROR ) . of ( expected ) ; } } private static void assertQuantilesMap ( Map < Integer , Double > expected , Map < Integer , Double > actual ) { assertThat ( actual . keySet ( ) ) . isEqualTo ( expected . keySet ( ) ) ; for ( int index : expected . keySet ( ) ) { assertQuantile ( index , expected . get ( index ) , actual . get ( index ) ) ; } } private static void assertDatasetAnyOrder ( Iterable < Double > expected , double [ ] actual ) { assertThat ( Doubles . asList ( actual ) ) . containsExactlyElementsIn ( expected ) ; } private static void assertDatasetInOrder ( Collection < Double > expected , double [ ] actual ) { assertThat ( actual ) . hasValuesWithin ( <float> ) . of ( Doubles . toArray ( expected ) ) ; } private static void assertDatasetInOrder ( Iterable < Long > expected , long [ ] actual ) { assertThat ( actual ) . asList ( ) . isEqualTo ( expected ) ; } private static void assertDatasetInOrder ( Iterable < Integer > expected , int [ ] actual ) { assertThat ( actual ) . asList ( ) . isEqualTo ( expected ) ; } } 
