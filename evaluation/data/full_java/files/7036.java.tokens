package org . elasticsearch . rest . action . cat ; import org . elasticsearch . action . admin . cluster . snapshots . get . GetSnapshotsRequest ; import org . elasticsearch . action . admin . cluster . snapshots . get . GetSnapshotsResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Table ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . RestResponse ; import org . elasticsearch . rest . action . support . RestResponseListener ; import org . elasticsearch . rest . action . support . RestTable ; import org . elasticsearch . snapshots . SnapshotInfo ; import org . elasticsearch . snapshots . SnapshotState ; import org . joda . time . format . DateTimeFormat ; import org . joda . time . format . DateTimeFormatter ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . rest . RestRequest . Method . GET ; public class RestSnapshotAction extends AbstractCatAction { @Inject public RestSnapshotAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override protected void doRequest ( final RestRequest request , RestChannel channel , Client client ) { GetSnapshotsRequest getSnapshotsRequest = new GetSnapshotsRequest ( ) . repository ( request . param ( <str> ) ) . snapshots ( new String [ ] { GetSnapshotsRequest . ALL_SNAPSHOTS } ) ; getSnapshotsRequest . ignoreUnavailable ( request . paramAsBoolean ( <str> , getSnapshotsRequest . ignoreUnavailable ( ) ) ) ; getSnapshotsRequest . masterNodeTimeout ( request . paramAsTime ( <str> , getSnapshotsRequest . masterNodeTimeout ( ) ) ) ; client . admin ( ) . cluster ( ) . getSnapshots ( getSnapshotsRequest , new RestResponseListener < GetSnapshotsResponse > ( channel ) { @Override public RestResponse buildResponse ( GetSnapshotsResponse getSnapshotsResponse ) throws Exception { return RestTable . buildResponse ( buildTable ( request , getSnapshotsResponse ) , channel ) ; } } ) ; } @Override protected void documentation ( StringBuilder sb ) { sb . append ( <str> ) ; } @Override protected Table getTableWithHeader ( RestRequest request ) { return new Table ( ) . startHeaders ( ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . endHeaders ( ) ; } private DateTimeFormatter dateFormat = DateTimeFormat . forPattern ( <str> ) ; private Table buildTable ( RestRequest req , GetSnapshotsResponse getSnapshotsResponse ) { Table table = getTableWithHeader ( req ) ; for ( SnapshotInfo snapshotStatus : getSnapshotsResponse . getSnapshots ( ) ) { table . startRow ( ) ; table . addCell ( snapshotStatus . name ( ) ) ; table . addCell ( snapshotStatus . state ( ) ) ; table . addCell ( TimeUnit . SECONDS . convert ( snapshotStatus . startTime ( ) , TimeUnit . MILLISECONDS ) ) ; table . addCell ( dateFormat . print ( snapshotStatus . startTime ( ) ) ) ; table . addCell ( TimeUnit . SECONDS . convert ( snapshotStatus . endTime ( ) , TimeUnit . MILLISECONDS ) ) ; table . addCell ( dateFormat . print ( snapshotStatus . endTime ( ) ) ) ; final long durationMillis ; if ( snapshotStatus . state ( ) = = SnapshotState . IN_PROGRESS ) { durationMillis = System . currentTimeMillis ( ) - snapshotStatus . startTime ( ) ; } else { durationMillis = snapshotStatus . endTime ( ) - snapshotStatus . startTime ( ) ; } table . addCell ( TimeValue . timeValueMillis ( durationMillis ) ) ; table . addCell ( snapshotStatus . indices ( ) . size ( ) ) ; table . addCell ( snapshotStatus . successfulShards ( ) ) ; table . addCell ( snapshotStatus . failedShards ( ) ) ; table . addCell ( snapshotStatus . totalShards ( ) ) ; table . addCell ( snapshotStatus . reason ( ) ) ; table . endRow ( ) ; } return table ; } } 
