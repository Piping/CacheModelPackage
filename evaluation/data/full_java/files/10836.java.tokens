package org . gradle . internal . concurrent ; import org . gradle . internal . UncheckedException ; import java . util . List ; import java . util . concurrent . AbstractExecutorService ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . TimeUnit ; class StoppableExecutorImpl extends AbstractExecutorService implements StoppableExecutor { private final ExecutorService executor ; private final ThreadLocal < Runnable > executing = new ThreadLocal < Runnable > ( ) ; private final ExecutorPolicy executorPolicy ; StoppableExecutorImpl ( ExecutorService executor , ExecutorPolicy executorPolicy ) { this . executor = executor ; this . executorPolicy = executorPolicy ; } public void execute ( final Runnable command ) { executor . execute ( new Runnable ( ) { public void run ( ) { executing . set ( command ) ; try { executorPolicy . onExecute ( command ) ; } finally { executing . set ( null ) ; } } } ) ; } public void requestStop ( ) { executor . shutdown ( ) ; } public void stop ( ) { stop ( Integer . MAX_VALUE , TimeUnit . SECONDS ) ; } public void stop ( int timeoutValue , TimeUnit timeoutUnits ) throws IllegalStateException { requestStop ( ) ; if ( executing . get ( ) ! = null ) { throw new IllegalStateException ( <str> ) ; } try { if ( ! executor . awaitTermination ( timeoutValue , timeoutUnits ) ) { executor . shutdownNow ( ) ; throw new IllegalStateException ( <str> ) ; } } catch ( InterruptedException e ) { throw new UncheckedException ( e ) ; } executorPolicy . onStop ( ) ; } public void shutdown ( ) { executor . shutdown ( ) ; } public List < Runnable > shutdownNow ( ) { return executor . shutdownNow ( ) ; } public boolean isShutdown ( ) { return executor . isShutdown ( ) ; } public boolean isTerminated ( ) { return executor . isTerminated ( ) ; } public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { return executor . awaitTermination ( timeout , unit ) ; } } 
