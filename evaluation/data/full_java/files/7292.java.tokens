package org . elasticsearch . search . aggregations . metrics . cardinality ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . bucket . SingleBucketAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import org . elasticsearch . search . aggregations . support . ValuesSourceAggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValuesSourceConfig ; import java . io . IOException ; import java . util . List ; import java . util . Map ; final class CardinalityAggregatorFactory extends ValuesSourceAggregatorFactory . LeafOnly < ValuesSource > { private final long precisionThreshold ; CardinalityAggregatorFactory ( String name , ValuesSourceConfig config , long precisionThreshold ) { super ( name , InternalCardinality . TYPE . name ( ) , config ) ; this . precisionThreshold = precisionThreshold ; } private int precision ( Aggregator parent ) { return precisionThreshold < <int> ? defaultPrecision ( parent ) : HyperLogLogPlusPlus . precisionFromThreshold ( precisionThreshold ) ; } @Override protected Aggregator createUnmapped ( AggregationContext context , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new CardinalityAggregator ( name , null , precision ( parent ) , config . formatter ( ) , context , parent , pipelineAggregators , metaData ) ; } @Override protected Aggregator doCreateInternal ( ValuesSource valuesSource , AggregationContext context , Aggregator parent , boolean collectsFromSingleBucket , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { return new CardinalityAggregator ( name , valuesSource , precision ( parent ) , config . formatter ( ) , context , parent , pipelineAggregators , metaData ) ; } private static int defaultPrecision ( Aggregator parent ) { int precision = HyperLogLogPlusPlus . DEFAULT_PRECISION ; while ( parent ! = null ) { if ( parent instanceof SingleBucketAggregator = = false ) { precision - = <int> ; } parent = parent . parent ( ) ; } return Math . max ( precision , HyperLogLogPlusPlus . MIN_PRECISION ) ; } } 
