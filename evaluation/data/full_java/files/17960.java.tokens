package com . badlogic . gdx . graphics . g2d ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . g2d . BitmapFont . BitmapFontData ; import com . badlogic . gdx . graphics . g2d . BitmapFont . Glyph ; import com . badlogic . gdx . graphics . g2d . GlyphLayout . GlyphRun ; import com . badlogic . gdx . utils . Align ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . FloatArray ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . NumberUtils ; import com . badlogic . gdx . utils . Pools ; public class BitmapFontCache { static private final Color tempColor = new Color ( <int> , <int> , <int> , <int> ) ; static private final float whiteTint = Color . WHITE . toFloatBits ( ) ; private final BitmapFont font ; private boolean integer ; private final Array < GlyphLayout > layouts = new Array ( ) ; private final Array < GlyphLayout > pooledLayouts = new Array ( ) ; private int glyphCount ; private float x , y ; private final Color color = new Color ( <int> , <int> , <int> , <int> ) ; private float currentTint ; private float [ ] [ ] pageVertices ; private int [ ] idx ; private IntArray [ ] pageGlyphIndices ; private int [ ] tempGlyphCount ; public BitmapFontCache ( BitmapFont font ) { this ( font , font . usesIntegerPositions ( ) ) ; } public BitmapFontCache ( BitmapFont font , boolean integer ) { this . font = font ; this . integer = integer ; int pageCount = font . regions . size ; if ( pageCount = = <int> ) throw new IllegalArgumentException ( <str> ) ; pageVertices = new float [ pageCount ] [ ] ; idx = new int [ pageCount ] ; if ( pageCount > <int> ) { pageGlyphIndices = new IntArray [ pageCount ] ; for ( int i = <int> , n = pageGlyphIndices . length ; i < n ; i + + ) pageGlyphIndices [ i ] = new IntArray ( ) ; } tempGlyphCount = new int [ pageCount ] ; } public void setPosition ( float x , float y ) { translate ( x - this . x , y - this . y ) ; } public void translate ( float xAmount , float yAmount ) { if ( xAmount = = <int> & & yAmount = = <int> ) return ; if ( integer ) { xAmount = Math . round ( xAmount ) ; yAmount = Math . round ( yAmount ) ; } x + = xAmount ; y + = yAmount ; for ( int j = <int> , length = pageVertices . length ; j < length ; j + + ) { float [ ] vertices = pageVertices [ j ] ; for ( int i = <int> , n = idx [ j ] ; i < n ; i + = <int> ) { vertices [ i ] + = xAmount ; vertices [ i + <int> ] + = yAmount ; } } } public void tint ( Color tint ) { float newTint = tint . toFloatBits ( ) ; if ( currentTint = = newTint ) return ; currentTint = newTint ; int [ ] tempGlyphCount = this . tempGlyphCount ; for ( int i = <int> , n = tempGlyphCount . length ; i < n ; i + + ) tempGlyphCount [ i ] = <int> ; for ( int i = <int> , n = layouts . size ; i < n ; i + + ) { GlyphLayout layout = layouts . get ( i ) ; for ( int ii = <int> , nn = layout . runs . size ; ii < nn ; ii + + ) { GlyphRun run = layout . runs . get ( ii ) ; Array < Glyph > glyphs = run . glyphs ; float colorFloat = tempColor . set ( run . color ) . mul ( tint ) . toFloatBits ( ) ; for ( int iii = <int> , nnn = glyphs . size ; iii < nnn ; iii + + ) { Glyph glyph = glyphs . get ( iii ) ; int page = glyph . page ; int offset = tempGlyphCount [ page ] * <int> + <int> ; tempGlyphCount [ page ] + + ; float [ ] vertices = pageVertices [ page ] ; for ( int v = <int> ; v < <int> ; v + = <int> ) vertices [ offset + v ] = colorFloat ; } } } } public void setAlphas ( float alpha ) { int alphaBits = ( ( int ) ( <int> * alpha ) ) < < <int> ; float prev = <int> , newColor = <int> ; for ( int j = <int> , length = pageVertices . length ; j < length ; j + + ) { float [ ] vertices = pageVertices [ j ] ; for ( int i = <int> , n = idx [ j ] ; i < n ; i + = <int> ) { float c = vertices [ i ] ; if ( c = = prev & & i ! = <int> ) { vertices [ i ] = newColor ; } else { prev = c ; int rgba = NumberUtils . floatToIntColor ( c ) ; rgba = ( rgba & <hex> ) | alphaBits ; newColor = NumberUtils . intToFloatColor ( rgba ) ; vertices [ i ] = newColor ; } } } } public void setColors ( float color ) { for ( int j = <int> , length = pageVertices . length ; j < length ; j + + ) { float [ ] vertices = pageVertices [ j ] ; for ( int i = <int> , n = idx [ j ] ; i < n ; i + = <int> ) vertices [ i ] = color ; } } public void setColors ( Color tint ) { setColors ( tint . toFloatBits ( ) ) ; } public void setColors ( float r , float g , float b , float a ) { int intBits = ( ( int ) ( <int> * a ) < < <int> ) | ( ( int ) ( <int> * b ) < < <int> ) | ( ( int ) ( <int> * g ) < < <int> ) | ( ( int ) ( <int> * r ) ) ; setColors ( NumberUtils . intToFloatColor ( intBits ) ) ; } public void setColors ( Color tint , int start , int end ) { setColors ( tint . toFloatBits ( ) , start , end ) ; } public void setColors ( float color , int start , int end ) { if ( pageVertices . length = = <int> ) { float [ ] vertices = pageVertices [ <int> ] ; for ( int i = start * <int> + <int> , n = end * <int> ; i < n ; i + = <int> ) vertices [ i ] = color ; return ; } int pageCount = pageVertices . length ; for ( int i = <int> ; i < pageCount ; i + + ) { float [ ] vertices = pageVertices [ i ] ; IntArray glyphIndices = pageGlyphIndices [ i ] ; for ( int j = <int> , n = glyphIndices . size ; j < n ; j + + ) { int glyphIndex = glyphIndices . items [ j ] ; if ( glyphIndex > = end ) break ; if ( glyphIndex > = start ) { for ( int off = <int> ; off < <int> ; off + = <int> ) vertices [ off + ( j * <int> + <int> ) ] = color ; } } } } public Color getColor ( ) { return color ; } public void setColor ( Color color ) { this . color . set ( color ) ; } public void setColor ( float r , float g , float b , float a ) { color . set ( r , g , b , a ) ; } public void draw ( Batch spriteBatch ) { Array < TextureRegion > regions = font . getRegions ( ) ; for ( int j = <int> , n = pageVertices . length ; j < n ; j + + ) { if ( idx [ j ] > <int> ) { float [ ] vertices = pageVertices [ j ] ; spriteBatch . draw ( regions . get ( j ) . getTexture ( ) , vertices , <int> , idx [ j ] ) ; } } } public void draw ( Batch spriteBatch , int start , int end ) { if ( pageVertices . length = = <int> ) { spriteBatch . draw ( font . getRegion ( ) . getTexture ( ) , pageVertices [ <int> ] , start * <int> , ( end - start ) * <int> ) ; return ; } Array < TextureRegion > regions = font . getRegions ( ) ; for ( int i = <int> , pageCount = pageVertices . length ; i < pageCount ; i + + ) { int offset = - <int> , count = <int> ; IntArray glyphIndices = pageGlyphIndices [ i ] ; for ( int ii = <int> , n = glyphIndices . size ; ii < n ; ii + + ) { int glyphIndex = glyphIndices . get ( ii ) ; if ( glyphIndex > = end ) break ; if ( offset = = - <int> & & glyphIndex > = start ) offset = ii ; if ( glyphIndex > = start ) count + + ; } if ( offset = = - <int> | | count = = <int> ) continue ; spriteBatch . draw ( regions . get ( i ) . getTexture ( ) , pageVertices [ i ] , offset * <int> , count * <int> ) ; } } public void draw ( Batch spriteBatch , float alphaModulation ) { if ( alphaModulation = = <int> ) { draw ( spriteBatch ) ; return ; } Color color = getColor ( ) ; float oldAlpha = color . a ; color . a * = alphaModulation ; setColors ( color ) ; draw ( spriteBatch ) ; color . a = oldAlpha ; setColors ( color ) ; } public void clear ( ) { x = <int> ; y = <int> ; Pools . freeAll ( pooledLayouts , true ) ; pooledLayouts . clear ( ) ; layouts . clear ( ) ; for ( int i = <int> , n = idx . length ; i < n ; i + + ) { if ( pageGlyphIndices ! = null ) pageGlyphIndices [ i ] . clear ( ) ; idx [ i ] = <int> ; } } private void requireGlyphs ( GlyphLayout layout ) { if ( pageVertices . length = = <int> ) { int newGlyphCount = <int> ; for ( int i = <int> , n = layout . runs . size ; i < n ; i + + ) newGlyphCount + = layout . runs . get ( i ) . glyphs . size ; requirePageGlyphs ( <int> , newGlyphCount ) ; } else { int [ ] tempGlyphCount = this . tempGlyphCount ; for ( int i = <int> , n = tempGlyphCount . length ; i < n ; i + + ) tempGlyphCount [ i ] = <int> ; for ( int i = <int> , n = layout . runs . size ; i < n ; i + + ) { Array < Glyph > glyphs = layout . runs . get ( i ) . glyphs ; for ( int ii = <int> , nn = glyphs . size ; ii < nn ; ii + + ) tempGlyphCount [ glyphs . get ( ii ) . page ] + + ; } for ( int i = <int> , n = tempGlyphCount . length ; i < n ; i + + ) requirePageGlyphs ( i , tempGlyphCount [ i ] ) ; } } private void requirePageGlyphs ( int page , int glyphCount ) { if ( pageGlyphIndices ! = null ) { if ( glyphCount > pageGlyphIndices [ page ] . items . length ) pageGlyphIndices [ page ] . ensureCapacity ( glyphCount - pageGlyphIndices [ page ] . items . length ) ; } int vertexCount = idx [ page ] + glyphCount * <int> ; float [ ] vertices = pageVertices [ page ] ; if ( vertices = = null ) { pageVertices [ page ] = new float [ vertexCount ] ; } else if ( vertices . length < vertexCount ) { float [ ] newVertices = new float [ vertexCount ] ; System . arraycopy ( vertices , <int> , newVertices , <int> , idx [ page ] ) ; pageVertices [ page ] = newVertices ; } } private void addToCache ( GlyphLayout layout , float x , float y ) { int pageCount = font . regions . size ; if ( pageVertices . length < pageCount ) { float [ ] [ ] newPageVertices = new float [ pageCount ] [ ] ; System . arraycopy ( pageVertices , <int> , newPageVertices , <int> , pageVertices . length ) ; pageVertices = newPageVertices ; int [ ] newIdx = new int [ pageCount ] ; System . arraycopy ( idx , <int> , newIdx , <int> , idx . length ) ; idx = newIdx ; IntArray [ ] newPageGlyphIndices = new IntArray [ pageCount ] ; int pageGlyphIndicesLength = <int> ; if ( pageGlyphIndices ! = null ) { pageGlyphIndicesLength = pageGlyphIndices . length ; System . arraycopy ( pageGlyphIndices , <int> , newPageGlyphIndices , <int> , pageGlyphIndices . length ) ; } for ( int i = pageGlyphIndicesLength ; i < pageCount ; i + + ) newPageGlyphIndices [ i ] = new IntArray ( ) ; pageGlyphIndices = newPageGlyphIndices ; tempGlyphCount = new int [ pageCount ] ; } layouts . add ( layout ) ; requireGlyphs ( layout ) ; for ( int i = <int> , n = layout . runs . size ; i < n ; i + + ) { GlyphRun run = layout . runs . get ( i ) ; Array < Glyph > glyphs = run . glyphs ; FloatArray xAdvances = run . xAdvances ; float color = run . color . toFloatBits ( ) ; float gx = x + run . x , gy = y + run . y ; for ( int ii = <int> , nn = glyphs . size ; ii < nn ; ii + + ) { Glyph glyph = glyphs . get ( ii ) ; gx + = xAdvances . get ( ii ) ; addGlyph ( glyph , gx , gy , color ) ; } } currentTint = whiteTint ; } private void addGlyph ( Glyph glyph , float x , float y , float color ) { final float scaleX = font . data . scaleX , scaleY = font . data . scaleY ; x + = glyph . xoffset * scaleX ; y + = glyph . yoffset * scaleY ; float width = glyph . width * scaleX , height = glyph . height * scaleY ; final float u = glyph . u , u2 = glyph . u2 , v = glyph . v , v2 = glyph . v2 ; if ( integer ) { x = Math . round ( x ) ; y = Math . round ( y ) ; width = Math . round ( width ) ; height = Math . round ( height ) ; } final float x2 = x + width , y2 = y + height ; final int page = glyph . page ; int idx = this . idx [ page ] ; this . idx [ page ] + = <int> ; if ( pageGlyphIndices ! = null ) pageGlyphIndices [ page ] . add ( glyphCount + + ) ; final float [ ] vertices = pageVertices [ page ] ; vertices [ idx + + ] = x ; vertices [ idx + + ] = y ; vertices [ idx + + ] = color ; vertices [ idx + + ] = u ; vertices [ idx + + ] = v ; vertices [ idx + + ] = x ; vertices [ idx + + ] = y2 ; vertices [ idx + + ] = color ; vertices [ idx + + ] = u ; vertices [ idx + + ] = v2 ; vertices [ idx + + ] = x2 ; vertices [ idx + + ] = y2 ; vertices [ idx + + ] = color ; vertices [ idx + + ] = u2 ; vertices [ idx + + ] = v2 ; vertices [ idx + + ] = x2 ; vertices [ idx + + ] = y ; vertices [ idx + + ] = color ; vertices [ idx + + ] = u2 ; vertices [ idx ] = v ; } public GlyphLayout setText ( CharSequence str , float x , float y ) { clear ( ) ; return addText ( str , x , y , <int> , str . length ( ) , <int> , Align . left , false ) ; } public GlyphLayout setText ( CharSequence str , float x , float y , float targetWidth , int halign , boolean wrap ) { clear ( ) ; return addText ( str , x , y , <int> , str . length ( ) , targetWidth , halign , wrap ) ; } public GlyphLayout setText ( CharSequence str , float x , float y , int start , int end , float targetWidth , int halign , boolean wrap ) { clear ( ) ; return addText ( str , x , y , start , end , targetWidth , halign , wrap ) ; } public GlyphLayout setText ( CharSequence str , float x , float y , int start , int end , float targetWidth , int halign , boolean wrap , String truncate ) { clear ( ) ; return addText ( str , x , y , start , end , targetWidth , halign , wrap , truncate ) ; } public void setText ( GlyphLayout layout , float x , float y ) { clear ( ) ; addText ( layout , x , y ) ; } public GlyphLayout addText ( CharSequence str , float x , float y ) { return addText ( str , x , y , <int> , str . length ( ) , <int> , Align . left , false , null ) ; } public GlyphLayout addText ( CharSequence str , float x , float y , float targetWidth , int halign , boolean wrap ) { return addText ( str , x , y , <int> , str . length ( ) , targetWidth , halign , wrap , null ) ; } public GlyphLayout addText ( CharSequence str , float x , float y , int start , int end , float targetWidth , int halign , boolean wrap ) { return addText ( str , x , y , start , end , targetWidth , halign , wrap , null ) ; } public GlyphLayout addText ( CharSequence str , float x , float y , int start , int end , float targetWidth , int halign , boolean wrap , String truncate ) { GlyphLayout layout = Pools . obtain ( GlyphLayout . class ) ; pooledLayouts . add ( layout ) ; layout . setText ( font , str , start , end , color , targetWidth , halign , wrap , truncate ) ; addText ( layout , x , y ) ; return layout ; } public void addText ( GlyphLayout layout , float x , float y ) { addToCache ( layout , x , y + font . data . ascent ) ; } public float getX ( ) { return x ; } public float getY ( ) { return y ; } public BitmapFont getFont ( ) { return font ; } public void setUseIntegerPositions ( boolean use ) { this . integer = use ; } public boolean usesIntegerPositions ( ) { return integer ; } public float [ ] getVertices ( ) { return getVertices ( <int> ) ; } public float [ ] getVertices ( int page ) { return pageVertices [ page ] ; } public int getVertexCount ( int page ) { return idx [ page ] ; } public Array < GlyphLayout > getLayouts ( ) { return layouts ; } } 
