package org . elasticsearch . index . analysis . phonetic ; import org . apache . commons . codec . EncoderException ; import org . apache . commons . codec . StringEncoder ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class KoelnerPhonetik implements StringEncoder { private static final String [ ] POSTEL_VARIATIONS_PATTERNS = { <str> , <str> , <str> , <str> , <str> , <str> } ; private static final String [ ] POSTEL_VARIATIONS_REPLACEMENTS = { <str> , <str> , <str> , <str> , <str> , <str> } ; private Pattern [ ] variationsPatterns ; private boolean primary = false ; private final Set < Character > csz = new HashSet ( Arrays . asList ( <str> , <str> , <str> ) ) ; private final Set < Character > ckq = new HashSet ( Arrays . asList ( <str> , <str> , <str> ) ) ; private final Set < Character > aouhkxq = new HashSet ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; private final Set < Character > ahkloqrux = new HashSet ( Arrays . asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; public KoelnerPhonetik ( ) { init ( ) ; } public KoelnerPhonetik ( boolean useOnlyPrimaryCode ) { this ( ) ; this . primary = useOnlyPrimaryCode ; } protected String [ ] getPatterns ( ) { return POSTEL_VARIATIONS_PATTERNS ; } protected String [ ] getReplacements ( ) { return POSTEL_VARIATIONS_REPLACEMENTS ; } protected char getCode ( ) { return <str> ; } public double getRelativeValue ( Object o1 , Object o2 ) { String [ ] kopho1 = code ( expandUmlauts ( o1 . toString ( ) . toUpperCase ( Locale . GERMANY ) ) ) ; String [ ] kopho2 = code ( expandUmlauts ( o2 . toString ( ) . toUpperCase ( Locale . GERMANY ) ) ) ; for ( int i = <int> ; i < kopho1 . length ; i + + ) { for ( int ii = <int> ; ii < kopho2 . length ; ii + + ) { if ( kopho1 [ i ] . equals ( kopho2 [ ii ] ) ) { return <int> ; } } } return <int> ; } @Override public Object encode ( Object str ) throws EncoderException { return encode ( ( String ) str ) ; } @Override public String encode ( String str ) throws EncoderException { if ( str = = null ) return null ; String [ ] s = code ( str . toString ( ) ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = <int> ; i < s . length ; i + + ) { sb . append ( s [ i ] ) ; if ( i < s . length - <int> ) { sb . append ( <str> ) ; } } return sb . toString ( ) ; } private void init ( ) { this . variationsPatterns = new Pattern [ getPatterns ( ) . length ] ; for ( int i = <int> ; i < getPatterns ( ) . length ; i + + ) { this . variationsPatterns [ i ] = Pattern . compile ( getPatterns ( ) [ i ] ) ; } } private String [ ] code ( String str ) { List < String > parts = partition ( str ) ; String [ ] codes = new String [ parts . size ( ) ] ; int i = <int> ; for ( String s : parts ) { codes [ i + + ] = substitute ( s ) ; } return codes ; } private List < String > partition ( String str ) { String primaryForm = str ; List < String > parts = new ArrayList ( ) ; parts . add ( primaryForm . replaceAll ( <str> , <str> ) ) ; if ( ! primary ) { List < String > tmpParts = new ArrayList ( ) ; tmpParts . addAll ( ( Arrays . asList ( str . split ( <str> ) ) ) ) ; int numberOfParts = tmpParts . size ( ) ; while ( tmpParts . size ( ) > <int> ) { StringBuilder part = new StringBuilder ( ) ; for ( int i = <int> ; i < tmpParts . size ( ) ; i + + ) { part . append ( tmpParts . get ( i ) ) ; if ( ! ( i + <int> = = numberOfParts ) ) { parts . add ( part . toString ( ) ) ; } } tmpParts . remove ( <int> ) ; } } List < String > variations = new ArrayList ( ) ; for ( int i = <int> ; i < parts . size ( ) ; i + + ) { List variation = getVariations ( parts . get ( i ) ) ; if ( variation ! = null ) { variations . addAll ( variation ) ; } } return variations ; } private List getVariations ( String str ) { int position = <int> ; List < String > variations = new ArrayList ( ) ; variations . add ( <str> ) ; while ( position < str . length ( ) ) { int i = <int> ; int substPos = - <int> ; while ( substPos < position & & i < getPatterns ( ) . length ) { Matcher m = variationsPatterns [ i ] . matcher ( str ) ; while ( substPos < position & & m . find ( ) ) { substPos = m . start ( ) ; } i + + ; } if ( substPos > = position ) { i - - ; List < String > varNew = new ArrayList ( ) ; String prevPart = str . substring ( position , substPos ) ; for ( int ii = <int> ; ii < variations . size ( ) ; ii + + ) { String tmp = variations . get ( ii ) ; varNew . add ( tmp . concat ( prevPart + getReplacements ( ) [ i ] ) ) ; variations . set ( ii , variations . get ( ii ) + prevPart + getPatterns ( ) [ i ] ) ; } variations . addAll ( varNew ) ; position = substPos + getPatterns ( ) [ i ] . length ( ) ; } else { for ( int ii = <int> ; ii < variations . size ( ) ; ii + + ) { variations . set ( ii , variations . get ( ii ) + str . substring ( position , str . length ( ) ) ) ; } position = str . length ( ) ; } } return variations ; } private String substitute ( String str ) { String s = expandUmlauts ( str . toUpperCase ( Locale . GERMAN ) ) ; s = removeSequences ( s ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = <int> ; i < s . length ( ) ; i + + ) { char current = s . charAt ( i ) ; char next = i + <int> < s . length ( ) ? s . charAt ( i + <int> ) : <str> ; char prev = i > <int> ? s . charAt ( i - <int> ) : <str> ; switch ( current ) { case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : if ( i = = <int> | | ( ( i = = <int> ) & & prev = = <str> ) ) { sb . append ( getCode ( ) ) ; } break ; case <str> : sb . append ( next = = <str> ? <str> : <str> ) ; break ; case <str> : sb . append ( <str> ) ; break ; case <str> : case <str> : sb . append ( csz . contains ( next ) ? <str> : <str> ) ; break ; case <str> : case <str> : case <str> : sb . append ( <str> ) ; break ; case <str> : case <str> : case <str> : sb . append ( <str> ) ; break ; case <str> : if ( i = = <int> ) { sb . append ( ahkloqrux . contains ( next ) ? <str> : <str> ) ; } else { sb . append ( aouhkxq . contains ( next ) ? <str> : <str> ) ; } if ( sb . length ( ) > = <int> & & sb . charAt ( sb . length ( ) - <int> ) = = <str> ) { sb . setCharAt ( sb . length ( ) - <int> , <str> ) ; } break ; case <str> : sb . append ( i < <int> | | ! ckq . contains ( prev ) ? <str> : <str> ) ; break ; case <str> : sb . append ( <str> ) ; break ; case <str> : case <str> : sb . append ( <str> ) ; break ; case <str> : sb . append ( <str> ) ; break ; case <str> : case <str> : sb . append ( <str> ) ; break ; case <str> : break ; } } s = sb . toString ( ) ; s = removeSequences ( s ) ; return s ; } private String expandUmlauts ( String str ) { return str . replaceAll ( <str> , <str> ) . replaceAll ( <str> , <str> ) . replaceAll ( <str> , <str> ) ; } private String removeSequences ( String str ) { if ( str = = null | | str . length ( ) = = <int> ) { return <str> ; } int i = <int> , j = <int> ; StringBuilder sb = new StringBuilder ( ) . append ( str . charAt ( i + + ) ) ; char c ; while ( i < str . length ( ) ) { c = str . charAt ( i ) ; if ( c ! = sb . charAt ( j ) ) { sb . append ( c ) ; j + + ; } i + + ; } return sb . toString ( ) ; } } 
