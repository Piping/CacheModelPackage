package io . netty . channel . oio ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . RecvByteBufAllocator ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; public abstract class AbstractOioMessageChannel extends AbstractOioChannel { private final List < Object > readBuf = new ArrayList < Object > ( ) ; protected AbstractOioMessageChannel ( Channel parent ) { super ( parent ) ; } @Override protected void doRead ( ) { final ChannelConfig config = config ( ) ; if ( ! config . isAutoRead ( ) & & ! isReadPending ( ) ) { return ; } setReadPending ( false ) ; final ChannelPipeline pipeline = pipeline ( ) ; final RecvByteBufAllocator . Handle allocHandle = unsafe ( ) . recvBufAllocHandle ( ) ; allocHandle . reset ( config ) ; boolean closed = false ; Throwable exception = null ; try { do { int localRead = doReadMessages ( readBuf ) ; if ( localRead = = <int> ) { break ; } if ( localRead < <int> ) { closed = true ; break ; } allocHandle . incMessagesRead ( localRead ) ; } while ( allocHandle . continueReading ( ) ) ; } catch ( Throwable t ) { exception = t ; } int size = readBuf . size ( ) ; for ( int i = <int> ; i < size ; i + + ) { pipeline . fireChannelRead ( readBuf . get ( i ) ) ; } readBuf . clear ( ) ; allocHandle . readComplete ( ) ; pipeline . fireChannelReadComplete ( ) ; if ( exception ! = null ) { if ( exception instanceof IOException ) { closed = true ; } pipeline . fireExceptionCaught ( exception ) ; } if ( closed ) { if ( isOpen ( ) ) { unsafe ( ) . close ( unsafe ( ) . voidPromise ( ) ) ; } } else if ( allocHandle . lastBytesRead ( ) = = <int> & & isActive ( ) ) { read ( ) ; } } protected abstract int doReadMessages ( List < Object > msgs ) throws Exception ; } 
