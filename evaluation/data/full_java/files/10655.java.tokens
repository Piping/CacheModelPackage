package com . google . common . util . concurrent ; import static com . google . common . util . concurrent . Uninterruptibles . awaitUninterruptibly ; import com . google . common . base . CaseFormat ; import com . google . common . collect . ImmutableList ; import com . google . common . primitives . Ints ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Locale ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . FutureTask ; import java . util . concurrent . TimeUnit ; public class GeneratedMonitorTest extends TestCase { public static TestSuite suite ( ) { TestSuite suite = new TestSuite ( ) ; Method [ ] methods = Monitor . class . getMethods ( ) ; sortMethods ( methods ) ; for ( Method method : methods ) { if ( isAnyEnter ( method ) | | isWaitFor ( method ) ) { validateMethod ( method ) ; addTests ( suite , method ) ; } } assertEquals ( <int> , suite . testCount ( ) ) ; return suite ; } private static final long SMALL_TIMEOUT_MILLIS = <int> ; private static final long EXPECTED_HANG_DELAY_MILLIS = <int> ; private static final long UNEXPECTED_HANG_DELAY_MILLIS = <int> ; private enum Scenario { SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING , UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING , SATISFIED_AND_OCCUPIED_BEFORE_ENTERING , SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING , SATISFIED_BEFORE_WAITING , SATISFIED_WHILE_WAITING , SATISFIED_AND_INTERRUPTED_BEFORE_WAITING , UNSATISFIED_BEFORE_AND_WHILE_WAITING , UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING ; @Override public String toString ( ) { return CaseFormat . UPPER_UNDERSCORE . to ( CaseFormat . UPPER_CAMEL , name ( ) ) ; } } private enum Timeout { MIN ( Long . MIN_VALUE , <str> ) , MINUS_SMALL ( - SMALL_TIMEOUT_MILLIS , <str> + SMALL_TIMEOUT_MILLIS + <str> ) , ZERO ( <int> L , <str> ) , SMALL ( SMALL_TIMEOUT_MILLIS , SMALL_TIMEOUT_MILLIS + <str> ) , LARGE ( UNEXPECTED_HANG_DELAY_MILLIS * <int> , ( <int> * UNEXPECTED_HANG_DELAY_MILLIS ) + <str> ) , MAX ( Long . MAX_VALUE , <str> ) ; final long millis ; final String label ; private Timeout ( long millis , String label ) { this . millis = millis ; this . label = label ; } @Override public String toString ( ) { return label ; } } private enum TimeoutsToUse { ANY ( Timeout . values ( ) ) , PAST ( Timeout . MIN , Timeout . MINUS_SMALL , Timeout . ZERO ) , FUTURE ( Timeout . SMALL , Timeout . MAX ) , SMALL ( Timeout . SMALL ) , FINITE ( Timeout . MIN , Timeout . MINUS_SMALL , Timeout . ZERO , Timeout . SMALL ) , INFINITE ( Timeout . LARGE , Timeout . MAX ) ; final ImmutableList < Timeout > timeouts ; private TimeoutsToUse ( Timeout . . . timeouts ) { this . timeouts = ImmutableList . copyOf ( timeouts ) ; } } private enum Outcome { SUCCESS , FAILURE , INTERRUPT , HANG ; @Override public String toString ( ) { return CaseFormat . UPPER_UNDERSCORE . to ( CaseFormat . UPPER_CAMEL , name ( ) ) ; } } private static boolean isAnyEnter ( Method method ) { return method . getName ( ) . startsWith ( <str> ) | | method . getName ( ) . startsWith ( <str> ) ; } private static boolean isTryEnter ( Method method ) { return method . getName ( ) . startsWith ( <str> ) ; } private static boolean isEnterIf ( Method method ) { return method . getName ( ) . startsWith ( <str> ) ; } private static boolean isWaitFor ( Method method ) { return method . getName ( ) . startsWith ( <str> ) ; } private static boolean isGuarded ( Method method ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; return parameterTypes . length > = <int> & & parameterTypes [ <int> ] = = Monitor . Guard . class ; } private static boolean isTimed ( Method method ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; return parameterTypes . length > = <int> & & parameterTypes [ parameterTypes . length - <int> ] = = long . class & & parameterTypes [ parameterTypes . length - <int> ] = = TimeUnit . class ; } private static boolean isBoolean ( Method method ) { return method . getReturnType ( ) = = boolean . class ; } private static boolean isInterruptible ( Method method ) { return Arrays . asList ( method . getExceptionTypes ( ) ) . contains ( InterruptedException . class ) ; } private static void sortMethods ( Method [ ] methods ) { Arrays . sort ( methods , new Comparator < Method > ( ) { @Override public int compare ( Method m1 , Method m2 ) { int nameComparison = m1 . getName ( ) . compareTo ( m2 . getName ( ) ) ; if ( nameComparison ! = <int> ) { return nameComparison ; } else { return Ints . compare ( m1 . getParameterTypes ( ) . length , m2 . getParameterTypes ( ) . length ) ; } } } ) ; } private static void validateMethod ( Method method ) { String desc = method . toString ( ) ; assertTrue ( desc , isAnyEnter ( method ) | | isWaitFor ( method ) ) ; switch ( method . getParameterTypes ( ) . length ) { case <int> : assertFalse ( desc , isGuarded ( method ) ) ; assertFalse ( desc , isTimed ( method ) ) ; break ; case <int> : assertTrue ( desc , isGuarded ( method ) ) ; assertFalse ( desc , isTimed ( method ) ) ; break ; case <int> : assertFalse ( desc , isGuarded ( method ) ) ; assertTrue ( desc , isTimed ( method ) ) ; break ; case <int> : assertTrue ( desc , isGuarded ( method ) ) ; assertTrue ( desc , isTimed ( method ) ) ; break ; default : fail ( desc ) ; } if ( method . getReturnType ( ) = = void . class ) { assertFalse ( desc , isBoolean ( method ) ) ; } else { assertTrue ( desc , isBoolean ( method ) ) ; } switch ( method . getExceptionTypes ( ) . length ) { case <int> : assertFalse ( desc , isInterruptible ( method ) ) ; break ; case <int> : assertTrue ( desc , isInterruptible ( method ) ) ; break ; default : fail ( desc ) ; } if ( isEnterIf ( method ) ) { assertTrue ( desc , isGuarded ( method ) ) ; assertTrue ( desc , isBoolean ( method ) ) ; } else if ( isTryEnter ( method ) ) { assertFalse ( desc , isTimed ( method ) ) ; assertTrue ( desc , isBoolean ( method ) ) ; assertFalse ( desc , isInterruptible ( method ) ) ; } else if ( isWaitFor ( method ) ) { assertTrue ( desc , isGuarded ( method ) ) ; assertEquals ( desc , isTimed ( method ) , isBoolean ( method ) ) ; } else { assertEquals ( desc , isTimed ( method ) , isBoolean ( method ) ) ; } } private static void addTests ( TestSuite suite , Method method ) { if ( isGuarded ( method ) ) { for ( boolean fair1 : new boolean [ ] { true , false } ) { for ( boolean fair2 : new boolean [ ] { true , false } ) { suite . addTest ( generateGuardWithWrongMonitorTestCase ( method , fair1 , fair2 ) ) ; } } } if ( isAnyEnter ( method ) ) { addTests ( suite , method , Scenario . SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING , TimeoutsToUse . ANY , Outcome . SUCCESS ) ; addTests ( suite , method , Scenario . UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING , TimeoutsToUse . FINITE , isGuarded ( method ) ? ( isBoolean ( method ) ? Outcome . FAILURE : Outcome . HANG ) : Outcome . SUCCESS ) ; addTests ( suite , method , Scenario . UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING , TimeoutsToUse . INFINITE , isGuarded ( method ) ? ( isTryEnter ( method ) | | isEnterIf ( method ) ? Outcome . FAILURE : Outcome . HANG ) : Outcome . SUCCESS ) ; addTests ( suite , method , Scenario . SATISFIED_AND_OCCUPIED_BEFORE_ENTERING , TimeoutsToUse . FINITE , isBoolean ( method ) ? Outcome . FAILURE : Outcome . HANG ) ; addTests ( suite , method , Scenario . SATISFIED_AND_OCCUPIED_BEFORE_ENTERING , TimeoutsToUse . INFINITE , isGuarded ( method ) ? Outcome . HANG : ( isTryEnter ( method ) ? Outcome . FAILURE : Outcome . HANG ) ) ; addTests ( suite , method , Scenario . SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING , TimeoutsToUse . ANY , isInterruptible ( method ) ? Outcome . INTERRUPT : Outcome . SUCCESS ) ; } else { suite . addTest ( generateWaitForWhenNotOccupyingTestCase ( method , true ) ) ; suite . addTest ( generateWaitForWhenNotOccupyingTestCase ( method , false ) ) ; addTests ( suite , method , Scenario . SATISFIED_BEFORE_WAITING , TimeoutsToUse . ANY , Outcome . SUCCESS ) ; addTests ( suite , method , Scenario . SATISFIED_WHILE_WAITING , TimeoutsToUse . INFINITE , Outcome . SUCCESS ) ; addTests ( suite , method , Scenario . SATISFIED_WHILE_WAITING , TimeoutsToUse . PAST , Outcome . FAILURE ) ; addTests ( suite , method , Scenario . SATISFIED_AND_INTERRUPTED_BEFORE_WAITING , TimeoutsToUse . ANY , Outcome . SUCCESS ) ; addTests ( suite , method , Scenario . UNSATISFIED_BEFORE_AND_WHILE_WAITING , TimeoutsToUse . FINITE , Outcome . FAILURE ) ; addTests ( suite , method , Scenario . UNSATISFIED_BEFORE_AND_WHILE_WAITING , TimeoutsToUse . INFINITE , Outcome . HANG ) ; addTests ( suite , method , Scenario . UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING , TimeoutsToUse . PAST , isInterruptible ( method ) ? Outcome . INTERRUPT : Outcome . FAILURE ) ; addTests ( suite , method , Scenario . UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING , TimeoutsToUse . SMALL , isInterruptible ( method ) ? Outcome . INTERRUPT : Outcome . FAILURE ) ; addTests ( suite , method , Scenario . UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING , TimeoutsToUse . INFINITE , isInterruptible ( method ) ? Outcome . INTERRUPT : Outcome . HANG ) ; } } private static void addTests ( TestSuite suite , Method method , Scenario scenario , TimeoutsToUse timeoutsToUse , Outcome expectedOutcome ) { for ( boolean fair : new boolean [ ] { true , false } ) { if ( isTimed ( method ) ) { for ( Timeout timeout : timeoutsToUse . timeouts ) { suite . addTest ( new GeneratedMonitorTest ( method , scenario , fair , timeout , expectedOutcome ) ) ; } } else { Timeout implicitTimeout = ( isTryEnter ( method ) ? Timeout . ZERO : Timeout . MAX ) ; if ( timeoutsToUse . timeouts . contains ( implicitTimeout ) ) { suite . addTest ( new GeneratedMonitorTest ( method , scenario , fair , null , expectedOutcome ) ) ; } } } } static class FlagGuard extends Monitor . Guard { private boolean satisfied ; protected FlagGuard ( Monitor monitor ) { super ( monitor ) ; } @Override public boolean isSatisfied ( ) { return satisfied ; } public void setSatisfied ( boolean satisfied ) { this . satisfied = satisfied ; } } private final Method method ; private final Scenario scenario ; private final Timeout timeout ; private final Outcome expectedOutcome ; private final Monitor monitor ; private final FlagGuard guard ; private final CountDownLatch tearDownLatch ; private final CountDownLatch doingCallLatch ; private final CountDownLatch callCompletedLatch ; private GeneratedMonitorTest ( Method method , Scenario scenario , boolean fair , Timeout timeout , Outcome expectedOutcome ) { super ( nameFor ( method , scenario , fair , timeout , expectedOutcome ) ) ; this . method = method ; this . scenario = scenario ; this . timeout = timeout ; this . expectedOutcome = expectedOutcome ; this . monitor = new Monitor ( fair ) ; this . guard = new FlagGuard ( monitor ) ; this . tearDownLatch = new CountDownLatch ( <int> ) ; this . doingCallLatch = new CountDownLatch ( <int> ) ; this . callCompletedLatch = new CountDownLatch ( <int> ) ; } private static String nameFor ( Method method , Scenario scenario , boolean fair , Timeout timeout , Outcome expectedOutcome ) { return String . format ( Locale . ROOT , <str> , method . getName ( ) , fair ? <str> : <str> , ( timeout = = null ) ? <str> : timeout , scenario , expectedOutcome ) ; } @Override protected void runTest ( ) throws Throwable { final Runnable runChosenTest = new Runnable ( ) { @Override public void run ( ) { runChosenTest ( ) ; } } ; final FutureTask < Void > task = new FutureTask < Void > ( runChosenTest , null ) ; startThread ( new Runnable ( ) { @Override public void run ( ) { task . run ( ) ; } } ) ; awaitUninterruptibly ( doingCallLatch ) ; long hangDelayMillis = ( expectedOutcome = = Outcome . HANG ) ? EXPECTED_HANG_DELAY_MILLIS : UNEXPECTED_HANG_DELAY_MILLIS ; boolean hung = ! awaitUninterruptibly ( callCompletedLatch , hangDelayMillis , TimeUnit . MILLISECONDS ) ; if ( hung ) { assertEquals ( expectedOutcome , Outcome . HANG ) ; } else { assertNull ( task . get ( UNEXPECTED_HANG_DELAY_MILLIS , TimeUnit . MILLISECONDS ) ) ; } } @Override protected void tearDown ( ) throws Exception { tearDownLatch . countDown ( ) ; assertTrue ( <str> , monitor . enter ( UNEXPECTED_HANG_DELAY_MILLIS , TimeUnit . MILLISECONDS ) ) ; try { guard . setSatisfied ( true ) ; } finally { monitor . leave ( ) ; } } private void runChosenTest ( ) { if ( isAnyEnter ( method ) ) { runEnterTest ( ) ; } else { runWaitTest ( ) ; } } private void runEnterTest ( ) { assertFalse ( Thread . currentThread ( ) . isInterrupted ( ) ) ; assertFalse ( monitor . isOccupiedByCurrentThread ( ) ) ; doEnterScenarioSetUp ( ) ; boolean interruptedBeforeCall = Thread . currentThread ( ) . isInterrupted ( ) ; Outcome actualOutcome = doCall ( ) ; boolean occupiedAfterCall = monitor . isOccupiedByCurrentThread ( ) ; boolean interruptedAfterCall = Thread . currentThread ( ) . isInterrupted ( ) ; if ( occupiedAfterCall ) { guard . setSatisfied ( true ) ; monitor . leave ( ) ; assertFalse ( monitor . isOccupiedByCurrentThread ( ) ) ; } assertEquals ( expectedOutcome , actualOutcome ) ; assertEquals ( expectedOutcome = = Outcome . SUCCESS , occupiedAfterCall ) ; assertEquals ( interruptedBeforeCall & & expectedOutcome ! = Outcome . INTERRUPT , interruptedAfterCall ) ; } private void doEnterScenarioSetUp ( ) { switch ( scenario ) { case SATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING : enterSatisfyGuardAndLeaveInCurrentThread ( ) ; break ; case UNSATISFIED_AND_UNOCCUPIED_BEFORE_ENTERING : break ; case SATISFIED_AND_OCCUPIED_BEFORE_ENTERING : enterSatisfyGuardAndLeaveInCurrentThread ( ) ; enterAndRemainOccupyingInAnotherThread ( ) ; break ; case SATISFIED_UNOCCUPIED_AND_INTERRUPTED_BEFORE_ENTERING : enterSatisfyGuardAndLeaveInCurrentThread ( ) ; Thread . currentThread ( ) . interrupt ( ) ; break ; default : throw new AssertionError ( <str> + scenario ) ; } } private void runWaitTest ( ) { assertFalse ( Thread . currentThread ( ) . isInterrupted ( ) ) ; assertFalse ( monitor . isOccupiedByCurrentThread ( ) ) ; monitor . enter ( ) ; try { assertTrue ( monitor . isOccupiedByCurrentThread ( ) ) ; doWaitScenarioSetUp ( ) ; boolean interruptedBeforeCall = Thread . currentThread ( ) . isInterrupted ( ) ; Outcome actualOutcome = doCall ( ) ; boolean occupiedAfterCall = monitor . isOccupiedByCurrentThread ( ) ; boolean interruptedAfterCall = Thread . currentThread ( ) . isInterrupted ( ) ; assertEquals ( expectedOutcome , actualOutcome ) ; assertTrue ( occupiedAfterCall ) ; assertEquals ( interruptedBeforeCall & & expectedOutcome ! = Outcome . INTERRUPT , interruptedAfterCall ) ; } finally { guard . setSatisfied ( true ) ; monitor . leave ( ) ; assertFalse ( monitor . isOccupiedByCurrentThread ( ) ) ; } } private void doWaitScenarioSetUp ( ) { switch ( scenario ) { case SATISFIED_BEFORE_WAITING : guard . setSatisfied ( true ) ; break ; case SATISFIED_WHILE_WAITING : guard . setSatisfied ( false ) ; enterSatisfyGuardAndLeaveInAnotherThread ( ) ; break ; case UNSATISFIED_BEFORE_AND_WHILE_WAITING : guard . setSatisfied ( false ) ; break ; case SATISFIED_AND_INTERRUPTED_BEFORE_WAITING : guard . setSatisfied ( true ) ; Thread . currentThread ( ) . interrupt ( ) ; break ; case UNSATISFIED_AND_INTERRUPTED_BEFORE_WAITING : guard . setSatisfied ( false ) ; Thread . currentThread ( ) . interrupt ( ) ; break ; default : throw new AssertionError ( <str> + scenario ) ; } } private Outcome doCall ( ) { boolean guarded = isGuarded ( method ) ; boolean timed = isTimed ( method ) ; Object [ ] arguments = new Object [ ( guarded ? <int> : <int> ) + ( timed ? <int> : <int> ) ] ; if ( guarded ) { arguments [ <int> ] = guard ; } if ( timed ) { arguments [ arguments . length - <int> ] = timeout . millis ; arguments [ arguments . length - <int> ] = TimeUnit . MILLISECONDS ; } try { Object result ; doingCallLatch . countDown ( ) ; try { result = method . invoke ( monitor , arguments ) ; } finally { callCompletedLatch . countDown ( ) ; } if ( result = = null ) { return Outcome . SUCCESS ; } else if ( ( Boolean ) result ) { return Outcome . SUCCESS ; } else { return Outcome . FAILURE ; } } catch ( InvocationTargetException targetException ) { Throwable actualException = targetException . getTargetException ( ) ; if ( actualException instanceof InterruptedException ) { return Outcome . INTERRUPT ; } else { throw newAssertionError ( <str> , targetException ) ; } } catch ( IllegalAccessException e ) { throw newAssertionError ( <str> , e ) ; } } private void enterSatisfyGuardAndLeaveInCurrentThread ( ) { monitor . enter ( ) ; try { guard . setSatisfied ( true ) ; } finally { monitor . leave ( ) ; } } private void enterSatisfyGuardAndLeaveInAnotherThread ( ) { final CountDownLatch startedLatch = new CountDownLatch ( <int> ) ; startThread ( new Runnable ( ) { @Override public void run ( ) { startedLatch . countDown ( ) ; enterSatisfyGuardAndLeaveInCurrentThread ( ) ; } } ) ; awaitUninterruptibly ( startedLatch ) ; } private void enterAndRemainOccupyingInAnotherThread ( ) { final CountDownLatch enteredLatch = new CountDownLatch ( <int> ) ; startThread ( new Runnable ( ) { @Override public void run ( ) { monitor . enter ( ) ; try { enteredLatch . countDown ( ) ; awaitUninterruptibly ( tearDownLatch ) ; guard . setSatisfied ( true ) ; } finally { monitor . leave ( ) ; } } } ) ; awaitUninterruptibly ( enteredLatch ) ; } static Thread startThread ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setDaemon ( true ) ; thread . start ( ) ; return thread ; } private static TestCase generateGuardWithWrongMonitorTestCase ( final Method method , final boolean fair1 , final boolean fair2 ) { final boolean timed = isTimed ( method ) ; return new TestCase ( method . getName ( ) + ( timed ? <str> : <str> ) + <str> ) { @Override protected void runTest ( ) throws Throwable { Monitor monitor1 = new Monitor ( fair1 ) ; Monitor monitor2 = new Monitor ( fair2 ) ; FlagGuard guard = new FlagGuard ( monitor2 ) ; Object [ ] arguments = ( timed ? new Object [ ] { guard , <int> L , TimeUnit . MILLISECONDS } : new Object [ ] { guard } ) ; boolean occupyMonitor = isWaitFor ( method ) ; if ( occupyMonitor ) { monitor1 . enter ( ) ; } try { method . invoke ( monitor1 , arguments ) ; fail ( <str> ) ; } catch ( InvocationTargetException e ) { assertEquals ( IllegalMonitorStateException . class , e . getTargetException ( ) . getClass ( ) ) ; } finally { if ( occupyMonitor ) { monitor1 . leave ( ) ; } } } } ; } private static TestCase generateWaitForWhenNotOccupyingTestCase ( final Method method , final boolean fair ) { final boolean timed = isTimed ( method ) ; String testName = method . getName ( ) + ( fair ? <str> : <str> ) + ( timed ? <str> : <str> ) + <str> ; return new TestCase ( testName ) { @Override protected void runTest ( ) throws Throwable { Monitor monitor = new Monitor ( fair ) ; FlagGuard guard = new FlagGuard ( monitor ) ; Object [ ] arguments = ( timed ? new Object [ ] { guard , <int> L , TimeUnit . MILLISECONDS } : new Object [ ] { guard } ) ; try { method . invoke ( monitor , arguments ) ; fail ( <str> ) ; } catch ( InvocationTargetException e ) { assertEquals ( IllegalMonitorStateException . class , e . getTargetException ( ) . getClass ( ) ) ; } } } ; } private static AssertionError newAssertionError ( String message , Throwable cause ) { AssertionError e = new AssertionError ( message ) ; e . initCause ( cause ) ; return e ; } } 
