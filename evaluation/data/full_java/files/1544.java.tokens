package org . apache . cassandra . hints ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . file . Files ; import java . util . * ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . UUIDType ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . db . rows . BTreeRow ; import org . apache . cassandra . db . rows . BufferCell ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . UUIDGen ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . assertNotNull ; import static junit . framework . Assert . assertTrue ; import static org . apache . cassandra . hints . HintsTestUtil . assertMutationsEqual ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; @SuppressWarnings ( <str> ) public class LegacyHintsMigratorTest { private static final String KEYSPACE = <str> ; private static final String TABLE = <str> ; @BeforeClass public static void defineSchema ( ) { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE , TABLE ) ) ; } @Test public void testNothingToMigrate ( ) throws IOException { File directory = Files . createTempDirectory ( null ) . toFile ( ) ; try { testNothingToMigrate ( directory ) ; } finally { directory . deleteOnExit ( ) ; } } private static void testNothingToMigrate ( File directory ) { Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . LEGACY_HINTS ) . truncateBlocking ( ) ; new LegacyHintsMigrator ( directory , <int> * <int> * <int> ) . migrate ( ) ; HintsCatalog catalog = HintsCatalog . load ( directory ) ; assertEquals ( <int> , catalog . stores ( ) . count ( ) ) ; } @Test public void testMigrationIsComplete ( ) throws IOException { File directory = Files . createTempDirectory ( null ) . toFile ( ) ; try { testMigrationIsComplete ( directory ) ; } finally { directory . deleteOnExit ( ) ; } } private static void testMigrationIsComplete ( File directory ) { long timestamp = System . currentTimeMillis ( ) ; Map < UUID , Queue < Mutation > > mutations = new HashMap < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { UUID hostId = UUID . randomUUID ( ) ; Queue < Mutation > queue = new LinkedList < > ( ) ; mutations . put ( hostId , queue ) ; for ( int j = <int> ; j < <int> ; j + + ) { Mutation mutation = createMutation ( j , timestamp + j ) ; queue . offer ( mutation ) ; Mutation legacyHint = createLegacyHint ( mutation , timestamp , hostId ) ; legacyHint . applyUnsafe ( ) ; } } new LegacyHintsMigrator ( directory , <int> * <int> * <int> ) . migrate ( ) ; assertTrue ( Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . LEGACY_HINTS ) . isEmpty ( ) ) ; HintsCatalog catalog = HintsCatalog . load ( directory ) ; assertEquals ( <int> , catalog . stores ( ) . count ( ) ) ; for ( Map . Entry < UUID , Queue < Mutation > > entry : mutations . entrySet ( ) ) { HintsStore store = catalog . get ( entry . getKey ( ) ) ; assertNotNull ( store ) ; HintsDescriptor descriptor = store . poll ( ) ; assertNotNull ( descriptor ) ; Queue < Hint > actualHints = new LinkedList < > ( ) ; try ( HintsReader reader = HintsReader . open ( new File ( directory , descriptor . fileName ( ) ) ) ) { for ( HintsReader . Page page : reader ) page . hintsIterator ( ) . forEachRemaining ( actualHints : : offer ) ; } assertEquals ( <int> , actualHints . size ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Hint hint = actualHints . poll ( ) ; Mutation mutation = entry . getValue ( ) . poll ( ) ; int ttl = mutation . smallestGCGS ( ) ; assertEquals ( timestamp , hint . creationTime ) ; assertEquals ( ttl , hint . gcgs ) ; assertMutationsEqual ( mutation , hint . mutation ) ; } } } private static Mutation createLegacyHint ( Mutation mutation , long now , UUID targetId ) { int version = MessagingService . VERSION_21 ; int ttl = mutation . smallestGCGS ( ) ; UUID hintId = UUIDGen . getTimeUUID ( ) ; ByteBuffer key = UUIDType . instance . decompose ( targetId ) ; Clustering clustering = SystemKeyspace . LegacyHints . comparator . make ( hintId , version ) ; ByteBuffer value = ByteBuffer . wrap ( FBUtilities . serialize ( mutation , Mutation . serializer , version ) ) ; Cell cell = BufferCell . expiring ( SystemKeyspace . LegacyHints . compactValueColumn ( ) , now , ttl , FBUtilities . nowInSeconds ( ) , value ) ; return new Mutation ( PartitionUpdate . singleRowUpdate ( SystemKeyspace . LegacyHints , key , BTreeRow . singleCellRow ( clustering , cell ) ) ) ; } private static Mutation createMutation ( int index , long timestamp ) { CFMetaData table = Schema . instance . getCFMetaData ( KEYSPACE , TABLE ) ; return new RowUpdateBuilder ( table , timestamp , bytes ( index ) ) . clustering ( bytes ( index ) ) . add ( <str> , bytes ( index ) ) . build ( ) ; } } 
