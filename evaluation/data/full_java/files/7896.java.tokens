package org . elasticsearch . common . blobstore ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefBuilder ; import org . apache . lucene . util . LuceneTestCase ; import org . elasticsearch . common . blobstore . fs . FsBlobStore ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import java . io . InputStream ; import java . nio . file . Path ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . notNullValue ; @LuceneTestCase.SuppressFileSystems ( <str> ) public class BlobStoreTests extends ESTestCase { public void testWriteRead ( ) throws IOException { final BlobStore store = newBlobStore ( ) ; final BlobContainer container = store . blobContainer ( new BlobPath ( ) ) ; byte [ ] data = randomBytes ( randomIntBetween ( <int> , scaledRandomIntBetween ( <int> , <int> < < <int> ) ) ) ; container . writeBlob ( <str> , new BytesArray ( data ) ) ; try ( InputStream stream = container . readBlob ( <str> ) ) { BytesRefBuilder target = new BytesRefBuilder ( ) ; while ( target . length ( ) < data . length ) { byte [ ] buffer = new byte [ scaledRandomIntBetween ( <int> , data . length - target . length ( ) ) ] ; int offset = scaledRandomIntBetween ( <int> , buffer . length - <int> ) ; int read = stream . read ( buffer , offset , buffer . length - offset ) ; target . append ( new BytesRef ( buffer , offset , read ) ) ; } assertEquals ( data . length , target . length ( ) ) ; assertArrayEquals ( data , Arrays . copyOfRange ( target . bytes ( ) , <int> , target . length ( ) ) ) ; } store . close ( ) ; } public void testMoveAndList ( ) throws IOException { final BlobStore store = newBlobStore ( ) ; final BlobContainer container = store . blobContainer ( new BlobPath ( ) ) ; assertThat ( container . listBlobs ( ) . size ( ) , equalTo ( <int> ) ) ; int numberOfFooBlobs = randomIntBetween ( <int> , <int> ) ; int numberOfBarBlobs = randomIntBetween ( <int> , <int> ) ; Map < String , Long > generatedBlobs = new HashMap < > ( ) ; for ( int i = <int> ; i < numberOfFooBlobs ; i + + ) { int length = randomIntBetween ( <int> , <int> ) ; String name = <str> + i + <str> ; generatedBlobs . put ( name , ( long ) length ) ; createRandomBlob ( container , name , length ) ; } for ( int i = <int> ; i < numberOfBarBlobs ; i + + ) { int length = randomIntBetween ( <int> , <int> ) ; String name = <str> + i + <str> ; generatedBlobs . put ( name , ( long ) length ) ; createRandomBlob ( container , name , length ) ; } int length = randomIntBetween ( <int> , <int> ) ; String name = <str> ; generatedBlobs . put ( name , ( long ) length ) ; byte [ ] data = createRandomBlob ( container , name , length ) ; Map < String , BlobMetaData > blobs = container . listBlobs ( ) ; assertThat ( blobs . size ( ) , equalTo ( numberOfFooBlobs + numberOfBarBlobs ) ) ; for ( Map . Entry < String , Long > generated : generatedBlobs . entrySet ( ) ) { BlobMetaData blobMetaData = blobs . get ( generated . getKey ( ) ) ; assertThat ( generated . getKey ( ) , blobMetaData , notNullValue ( ) ) ; assertThat ( blobMetaData . name ( ) , equalTo ( generated . getKey ( ) ) ) ; assertThat ( blobMetaData . length ( ) , equalTo ( generated . getValue ( ) ) ) ; } assertThat ( container . listBlobsByPrefix ( <str> ) . size ( ) , equalTo ( numberOfFooBlobs ) ) ; assertThat ( container . listBlobsByPrefix ( <str> ) . size ( ) , equalTo ( numberOfBarBlobs ) ) ; assertThat ( container . listBlobsByPrefix ( <str> ) . size ( ) , equalTo ( <int> ) ) ; String newName = <str> ; container . move ( name , newName ) ; assertThat ( container . listBlobsByPrefix ( name ) . size ( ) , equalTo ( <int> ) ) ; blobs = container . listBlobsByPrefix ( newName ) ; assertThat ( blobs . size ( ) , equalTo ( <int> ) ) ; assertThat ( blobs . get ( newName ) . length ( ) , equalTo ( generatedBlobs . get ( name ) ) ) ; assertThat ( data , equalTo ( readBlobFully ( container , newName , length ) ) ) ; store . close ( ) ; } protected byte [ ] createRandomBlob ( BlobContainer container , String name , int length ) throws IOException { byte [ ] data = randomBytes ( length ) ; container . writeBlob ( name , new BytesArray ( data ) ) ; return data ; } protected byte [ ] readBlobFully ( BlobContainer container , String name , int length ) throws IOException { byte [ ] data = new byte [ length ] ; try ( InputStream inputStream = container . readBlob ( name ) ) { assertThat ( inputStream . read ( data ) , equalTo ( length ) ) ; assertThat ( inputStream . read ( ) , equalTo ( - <int> ) ) ; } return data ; } protected byte [ ] randomBytes ( int length ) { byte [ ] data = new byte [ length ] ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] = ( byte ) randomInt ( ) ; } return data ; } protected BlobStore newBlobStore ( ) throws IOException { Path tempDir = createTempDir ( ) ; Settings settings = randomBoolean ( ) ? Settings . EMPTY : Settings . builder ( ) . put ( <str> , new ByteSizeValue ( randomIntBetween ( <int> , <int> ) , ByteSizeUnit . KB ) ) . build ( ) ; FsBlobStore store = new FsBlobStore ( settings , tempDir ) ; return store ; } } 
