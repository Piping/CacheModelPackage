package com . google . common . reflect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Joiner ; import com . google . common . base . Predicate ; import com . google . common . collect . FluentIterable ; import com . google . common . collect . ForwardingSet ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import com . google . common . primitives . Primitives ; import java . io . Serializable ; import java . lang . reflect . Constructor ; import java . lang . reflect . GenericArrayType ; import java . lang . reflect . Method ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . lang . reflect . TypeVariable ; import java . lang . reflect . WildcardType ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Map ; import java . util . Set ; import javax . annotation . Nullable ; @Beta @SuppressWarnings ( <str> ) public abstract class TypeToken < T > extends TypeCapture < T > implements Serializable { private final Type runtimeType ; private transient TypeResolver typeResolver ; protected TypeToken ( ) { this . runtimeType = capture ( ) ; checkState ( ! ( runtimeType instanceof TypeVariable ) , <str> + <str> + <str> + <str> + <str> , runtimeType ) ; } protected TypeToken ( Class < ? > declaringClass ) { Type captured = super . capture ( ) ; if ( captured instanceof Class ) { this . runtimeType = captured ; } else { this . runtimeType = of ( declaringClass ) . resolveType ( captured ) . runtimeType ; } } private TypeToken ( Type type ) { this . runtimeType = checkNotNull ( type ) ; } public static < T > TypeToken < T > of ( Class < T > type ) { return new SimpleTypeToken < T > ( type ) ; } public static TypeToken < ? > of ( Type type ) { return new SimpleTypeToken < Object > ( type ) ; } public final Class < ? super T > getRawType ( ) { Class < ? > rawType = getRawTypes ( ) . iterator ( ) . next ( ) ; @SuppressWarnings ( <str> ) Class < ? super T > result = ( Class < ? super T > ) rawType ; return result ; } public final Type getType ( ) { return runtimeType ; } public final < X > TypeToken < T > where ( TypeParameter < X > typeParam , TypeToken < X > typeArg ) { TypeResolver resolver = new TypeResolver ( ) . where ( ImmutableMap . of ( new TypeResolver . TypeVariableKey ( typeParam . typeVariable ) , typeArg . runtimeType ) ) ; return new SimpleTypeToken < T > ( resolver . resolveType ( runtimeType ) ) ; } public final < X > TypeToken < T > where ( TypeParameter < X > typeParam , Class < X > typeArg ) { return where ( typeParam , of ( typeArg ) ) ; } public final TypeToken < ? > resolveType ( Type type ) { checkNotNull ( type ) ; TypeResolver resolver = typeResolver ; if ( resolver = = null ) { resolver = ( typeResolver = TypeResolver . accordingTo ( runtimeType ) ) ; } return of ( resolver . resolveType ( type ) ) ; } private Type [ ] resolveInPlace ( Type [ ] types ) { for ( int i = <int> ; i < types . length ; i + + ) { types [ i ] = resolveType ( types [ i ] ) . getType ( ) ; } return types ; } private TypeToken < ? > resolveSupertype ( Type type ) { TypeToken < ? > supertype = resolveType ( type ) ; supertype . typeResolver = typeResolver ; return supertype ; } @Nullable final TypeToken < ? super T > getGenericSuperclass ( ) { if ( runtimeType instanceof TypeVariable ) { return boundAsSuperclass ( ( ( TypeVariable < ? > ) runtimeType ) . getBounds ( ) [ <int> ] ) ; } if ( runtimeType instanceof WildcardType ) { return boundAsSuperclass ( ( ( WildcardType ) runtimeType ) . getUpperBounds ( ) [ <int> ] ) ; } Type superclass = getRawType ( ) . getGenericSuperclass ( ) ; if ( superclass = = null ) { return null ; } @SuppressWarnings ( <str> ) TypeToken < ? super T > superToken = ( TypeToken < ? super T > ) resolveSupertype ( superclass ) ; return superToken ; } @Nullable private TypeToken < ? super T > boundAsSuperclass ( Type bound ) { TypeToken < ? > token = of ( bound ) ; if ( token . getRawType ( ) . isInterface ( ) ) { return null ; } @SuppressWarnings ( <str> ) TypeToken < ? super T > superclass = ( TypeToken < ? super T > ) token ; return superclass ; } final ImmutableList < TypeToken < ? super T > > getGenericInterfaces ( ) { if ( runtimeType instanceof TypeVariable ) { return boundsAsInterfaces ( ( ( TypeVariable < ? > ) runtimeType ) . getBounds ( ) ) ; } if ( runtimeType instanceof WildcardType ) { return boundsAsInterfaces ( ( ( WildcardType ) runtimeType ) . getUpperBounds ( ) ) ; } ImmutableList . Builder < TypeToken < ? super T > > builder = ImmutableList . builder ( ) ; for ( Type interfaceType : getRawType ( ) . getGenericInterfaces ( ) ) { @SuppressWarnings ( <str> ) TypeToken < ? super T > resolvedInterface = ( TypeToken < ? super T > ) resolveSupertype ( interfaceType ) ; builder . add ( resolvedInterface ) ; } return builder . build ( ) ; } private ImmutableList < TypeToken < ? super T > > boundsAsInterfaces ( Type [ ] bounds ) { ImmutableList . Builder < TypeToken < ? super T > > builder = ImmutableList . builder ( ) ; for ( Type bound : bounds ) { @SuppressWarnings ( <str> ) TypeToken < ? super T > boundType = ( TypeToken < ? super T > ) of ( bound ) ; if ( boundType . getRawType ( ) . isInterface ( ) ) { builder . add ( boundType ) ; } } return builder . build ( ) ; } public final TypeSet getTypes ( ) { return new TypeSet ( ) ; } public final TypeToken < ? super T > getSupertype ( Class < ? super T > superclass ) { checkArgument ( this . someRawTypeIsSubclassOf ( superclass ) , <str> , superclass , this ) ; if ( runtimeType instanceof TypeVariable ) { return getSupertypeFromUpperBounds ( superclass , ( ( TypeVariable < ? > ) runtimeType ) . getBounds ( ) ) ; } if ( runtimeType instanceof WildcardType ) { return getSupertypeFromUpperBounds ( superclass , ( ( WildcardType ) runtimeType ) . getUpperBounds ( ) ) ; } if ( superclass . isArray ( ) ) { return getArraySupertype ( superclass ) ; } @SuppressWarnings ( <str> ) TypeToken < ? super T > supertype = ( TypeToken < ? super T > ) resolveSupertype ( toGenericType ( superclass ) . runtimeType ) ; return supertype ; } public final TypeToken < ? extends T > getSubtype ( Class < ? > subclass ) { checkArgument ( ! ( runtimeType instanceof TypeVariable ) , <str> , this ) ; if ( runtimeType instanceof WildcardType ) { return getSubtypeFromLowerBounds ( subclass , ( ( WildcardType ) runtimeType ) . getLowerBounds ( ) ) ; } if ( isArray ( ) ) { return getArraySubtype ( subclass ) ; } checkArgument ( getRawType ( ) . isAssignableFrom ( subclass ) , <str> , subclass , this ) ; Type resolvedTypeArgs = resolveTypeArgsForSubclass ( subclass ) ; @SuppressWarnings ( <str> ) TypeToken < ? extends T > subtype = ( TypeToken < ? extends T > ) of ( resolvedTypeArgs ) ; return subtype ; } @Deprecated public final boolean isAssignableFrom ( TypeToken < ? > type ) { return isSupertypeOf ( type ) ; } @Deprecated public final boolean isAssignableFrom ( Type type ) { return isSupertypeOf ( type ) ; } public final boolean isSupertypeOf ( TypeToken < ? > type ) { return type . isSubtypeOf ( getType ( ) ) ; } public final boolean isSupertypeOf ( Type type ) { return of ( type ) . isSubtypeOf ( getType ( ) ) ; } public final boolean isSubtypeOf ( TypeToken < ? > type ) { return isSubtypeOf ( type . getType ( ) ) ; } public final boolean isSubtypeOf ( Type supertype ) { checkNotNull ( supertype ) ; if ( supertype instanceof WildcardType ) { return any ( ( ( WildcardType ) supertype ) . getLowerBounds ( ) ) . isSupertypeOf ( runtimeType ) ; } if ( runtimeType instanceof WildcardType ) { return any ( ( ( WildcardType ) runtimeType ) . getUpperBounds ( ) ) . isSubtypeOf ( supertype ) ; } if ( runtimeType instanceof TypeVariable ) { return runtimeType . equals ( supertype ) | | any ( ( ( TypeVariable < ? > ) runtimeType ) . getBounds ( ) ) . isSubtypeOf ( supertype ) ; } if ( runtimeType instanceof GenericArrayType ) { return of ( supertype ) . isSuperTypeOfArray ( ( GenericArrayType ) runtimeType ) ; } if ( supertype instanceof Class ) { return this . someRawTypeIsSubclassOf ( ( Class < ? > ) supertype ) ; } else if ( supertype instanceof ParameterizedType ) { return this . isSubtypeOfParameterizedType ( ( ParameterizedType ) supertype ) ; } else if ( supertype instanceof GenericArrayType ) { return this . isSubTypeOfArrayType ( ( GenericArrayType ) supertype ) ; } else { return false ; } } public final boolean isArray ( ) { return getComponentType ( ) ! = null ; } public final boolean isPrimitive ( ) { return ( runtimeType instanceof Class ) & & ( ( Class < ? > ) runtimeType ) . isPrimitive ( ) ; } public final TypeToken < T > wrap ( ) { if ( isPrimitive ( ) ) { @SuppressWarnings ( <str> ) Class < T > type = ( Class < T > ) runtimeType ; return of ( Primitives . wrap ( type ) ) ; } return this ; } private boolean isWrapper ( ) { return Primitives . allWrapperTypes ( ) . contains ( runtimeType ) ; } public final TypeToken < T > unwrap ( ) { if ( isWrapper ( ) ) { @SuppressWarnings ( <str> ) Class < T > type = ( Class < T > ) runtimeType ; return of ( Primitives . unwrap ( type ) ) ; } return this ; } @Nullable public final TypeToken < ? > getComponentType ( ) { Type componentType = Types . getComponentType ( runtimeType ) ; if ( componentType = = null ) { return null ; } return of ( componentType ) ; } public final Invokable < T , Object > method ( Method method ) { checkArgument ( this . someRawTypeIsSubclassOf ( method . getDeclaringClass ( ) ) , <str> , method , this ) ; return new Invokable . MethodInvokable < T > ( method ) { @Override Type getGenericReturnType ( ) { return resolveType ( super . getGenericReturnType ( ) ) . getType ( ) ; } @Override Type [ ] getGenericParameterTypes ( ) { return resolveInPlace ( super . getGenericParameterTypes ( ) ) ; } @Override Type [ ] getGenericExceptionTypes ( ) { return resolveInPlace ( super . getGenericExceptionTypes ( ) ) ; } @Override public TypeToken < T > getOwnerType ( ) { return TypeToken . this ; } @Override public String toString ( ) { return getOwnerType ( ) + <str> + super . toString ( ) ; } } ; } public final Invokable < T , T > constructor ( Constructor < ? > constructor ) { checkArgument ( constructor . getDeclaringClass ( ) = = getRawType ( ) , <str> , constructor , getRawType ( ) ) ; return new Invokable . ConstructorInvokable < T > ( constructor ) { @Override Type getGenericReturnType ( ) { return resolveType ( super . getGenericReturnType ( ) ) . getType ( ) ; } @Override Type [ ] getGenericParameterTypes ( ) { return resolveInPlace ( super . getGenericParameterTypes ( ) ) ; } @Override Type [ ] getGenericExceptionTypes ( ) { return resolveInPlace ( super . getGenericExceptionTypes ( ) ) ; } @Override public TypeToken < T > getOwnerType ( ) { return TypeToken . this ; } @Override public String toString ( ) { return getOwnerType ( ) + <str> + Joiner . on ( <str> ) . join ( getGenericParameterTypes ( ) ) + <str> ; } } ; } public class TypeSet extends ForwardingSet < TypeToken < ? super T > > implements Serializable { private transient ImmutableSet < TypeToken < ? super T > > types ; TypeSet ( ) { } public TypeSet interfaces ( ) { return new InterfaceSet ( this ) ; } public TypeSet classes ( ) { return new ClassSet ( ) ; } @Override protected Set < TypeToken < ? super T > > delegate ( ) { ImmutableSet < TypeToken < ? super T > > filteredTypes = types ; if ( filteredTypes = = null ) { @SuppressWarnings ( { <str> , <str> } ) ImmutableList < TypeToken < ? super T > > collectedTypes = ( ImmutableList ) TypeCollector . FOR_GENERIC_TYPE . collectTypes ( TypeToken . this ) ; return ( types = FluentIterable . from ( collectedTypes ) . filter ( TypeFilter . IGNORE_TYPE_VARIABLE_OR_WILDCARD ) . toSet ( ) ) ; } else { return filteredTypes ; } } public Set < Class < ? super T > > rawTypes ( ) { @SuppressWarnings ( { <str> , <str> } ) ImmutableList < Class < ? super T > > collectedTypes = ( ImmutableList ) TypeCollector . FOR_RAW_TYPE . collectTypes ( getRawTypes ( ) ) ; return ImmutableSet . copyOf ( collectedTypes ) ; } private static final long serialVersionUID = <int> ; } private final class InterfaceSet extends TypeSet { private final transient TypeSet allTypes ; private transient ImmutableSet < TypeToken < ? super T > > interfaces ; InterfaceSet ( TypeSet allTypes ) { this . allTypes = allTypes ; } @Override protected Set < TypeToken < ? super T > > delegate ( ) { ImmutableSet < TypeToken < ? super T > > result = interfaces ; if ( result = = null ) { return ( interfaces = FluentIterable . from ( allTypes ) . filter ( TypeFilter . INTERFACE_ONLY ) . toSet ( ) ) ; } else { return result ; } } @Override public TypeSet interfaces ( ) { return this ; } @Override public Set < Class < ? super T > > rawTypes ( ) { @SuppressWarnings ( { <str> , <str> } ) ImmutableList < Class < ? super T > > collectedTypes = ( ImmutableList ) TypeCollector . FOR_RAW_TYPE . collectTypes ( getRawTypes ( ) ) ; return FluentIterable . from ( collectedTypes ) . filter ( new Predicate < Class < ? > > ( ) { @Override public boolean apply ( Class < ? > type ) { return type . isInterface ( ) ; } } ) . toSet ( ) ; } @Override public TypeSet classes ( ) { throw new UnsupportedOperationException ( <str> ) ; } private Object readResolve ( ) { return getTypes ( ) . interfaces ( ) ; } private static final long serialVersionUID = <int> ; } private final class ClassSet extends TypeSet { private transient ImmutableSet < TypeToken < ? super T > > classes ; @Override protected Set < TypeToken < ? super T > > delegate ( ) { ImmutableSet < TypeToken < ? super T > > result = classes ; if ( result = = null ) { @SuppressWarnings ( { <str> , <str> } ) ImmutableList < TypeToken < ? super T > > collectedTypes = ( ImmutableList ) TypeCollector . FOR_GENERIC_TYPE . classesOnly ( ) . collectTypes ( TypeToken . this ) ; return ( classes = FluentIterable . from ( collectedTypes ) . filter ( TypeFilter . IGNORE_TYPE_VARIABLE_OR_WILDCARD ) . toSet ( ) ) ; } else { return result ; } } @Override public TypeSet classes ( ) { return this ; } @Override public Set < Class < ? super T > > rawTypes ( ) { @SuppressWarnings ( { <str> , <str> } ) ImmutableList < Class < ? super T > > collectedTypes = ( ImmutableList ) TypeCollector . FOR_RAW_TYPE . classesOnly ( ) . collectTypes ( getRawTypes ( ) ) ; return ImmutableSet . copyOf ( collectedTypes ) ; } @Override public TypeSet interfaces ( ) { throw new UnsupportedOperationException ( <str> ) ; } private Object readResolve ( ) { return getTypes ( ) . classes ( ) ; } private static final long serialVersionUID = <int> ; } private enum TypeFilter implements Predicate < TypeToken < ? > > { IGNORE_TYPE_VARIABLE_OR_WILDCARD { @Override public boolean apply ( TypeToken < ? > type ) { return ! ( type . runtimeType instanceof TypeVariable | | type . runtimeType instanceof WildcardType ) ; } } , INTERFACE_ONLY { @Override public boolean apply ( TypeToken < ? > type ) { return type . getRawType ( ) . isInterface ( ) ; } } } @Override public boolean equals ( @Nullable Object o ) { if ( o instanceof TypeToken ) { TypeToken < ? > that = ( TypeToken < ? > ) o ; return runtimeType . equals ( that . runtimeType ) ; } return false ; } @Override public int hashCode ( ) { return runtimeType . hashCode ( ) ; } @Override public String toString ( ) { return Types . toString ( runtimeType ) ; } protected Object writeReplace ( ) { return of ( new TypeResolver ( ) . resolveType ( runtimeType ) ) ; } final TypeToken < T > rejectTypeVariables ( ) { new TypeVisitor ( ) { @Override void visitTypeVariable ( TypeVariable < ? > type ) { throw new IllegalArgumentException ( runtimeType + <str> ) ; } @Override void visitWildcardType ( WildcardType type ) { visit ( type . getLowerBounds ( ) ) ; visit ( type . getUpperBounds ( ) ) ; } @Override void visitParameterizedType ( ParameterizedType type ) { visit ( type . getActualTypeArguments ( ) ) ; visit ( type . getOwnerType ( ) ) ; } @Override void visitGenericArrayType ( GenericArrayType type ) { visit ( type . getGenericComponentType ( ) ) ; } } . visit ( runtimeType ) ; return this ; } private boolean someRawTypeIsSubclassOf ( Class < ? > superclass ) { for ( Class < ? > rawType : getRawTypes ( ) ) { if ( superclass . isAssignableFrom ( rawType ) ) { return true ; } } return false ; } private boolean isSubtypeOfParameterizedType ( ParameterizedType supertype ) { Class < ? > matchedClass = of ( supertype ) . getRawType ( ) ; if ( ! this . someRawTypeIsSubclassOf ( matchedClass ) ) { return false ; } Type [ ] typeParams = matchedClass . getTypeParameters ( ) ; Type [ ] toTypeArgs = supertype . getActualTypeArguments ( ) ; for ( int i = <int> ; i < typeParams . length ; i + + ) { if ( ! resolveType ( typeParams [ i ] ) . is ( toTypeArgs [ i ] ) ) { return false ; } } return true ; } private boolean isSubTypeOfArrayType ( GenericArrayType supertype ) { if ( runtimeType instanceof Class ) { Class < ? > fromClass = ( Class < ? > ) runtimeType ; if ( ! fromClass . isArray ( ) ) { return false ; } return of ( fromClass . getComponentType ( ) ) . isSubtypeOf ( supertype . getGenericComponentType ( ) ) ; } else if ( runtimeType instanceof GenericArrayType ) { GenericArrayType fromArrayType = ( GenericArrayType ) runtimeType ; return of ( fromArrayType . getGenericComponentType ( ) ) . isSubtypeOf ( supertype . getGenericComponentType ( ) ) ; } else { return false ; } } private boolean isSuperTypeOfArray ( GenericArrayType subtype ) { if ( runtimeType instanceof Class ) { Class < ? > thisClass = ( Class < ? > ) runtimeType ; if ( ! thisClass . isArray ( ) ) { return thisClass . isAssignableFrom ( Object [ ] . class ) ; } return of ( subtype . getGenericComponentType ( ) ) . isSubtypeOf ( thisClass . getComponentType ( ) ) ; } else if ( runtimeType instanceof GenericArrayType ) { return of ( subtype . getGenericComponentType ( ) ) . isSubtypeOf ( ( ( GenericArrayType ) runtimeType ) . getGenericComponentType ( ) ) ; } else { return false ; } } private boolean is ( Type formalType ) { if ( runtimeType . equals ( formalType ) ) { return true ; } if ( formalType instanceof WildcardType ) { return every ( ( ( WildcardType ) formalType ) . getUpperBounds ( ) ) . isSupertypeOf ( runtimeType ) & & every ( ( ( WildcardType ) formalType ) . getLowerBounds ( ) ) . isSubtypeOf ( runtimeType ) ; } return false ; } private static Bounds every ( Type [ ] bounds ) { return new Bounds ( bounds , false ) ; } private static Bounds any ( Type [ ] bounds ) { return new Bounds ( bounds , true ) ; } private static class Bounds { private final Type [ ] bounds ; private final boolean target ; Bounds ( Type [ ] bounds , boolean target ) { this . bounds = bounds ; this . target = target ; } boolean isSubtypeOf ( Type supertype ) { for ( Type bound : bounds ) { if ( of ( bound ) . isSubtypeOf ( supertype ) = = target ) { return target ; } } return ! target ; } boolean isSupertypeOf ( Type subtype ) { TypeToken < ? > type = of ( subtype ) ; for ( Type bound : bounds ) { if ( type . isSubtypeOf ( bound ) = = target ) { return target ; } } return ! target ; } } private ImmutableSet < Class < ? super T > > getRawTypes ( ) { final ImmutableSet . Builder < Class < ? > > builder = ImmutableSet . builder ( ) ; new TypeVisitor ( ) { @Override void visitTypeVariable ( TypeVariable < ? > t ) { visit ( t . getBounds ( ) ) ; } @Override void visitWildcardType ( WildcardType t ) { visit ( t . getUpperBounds ( ) ) ; } @Override void visitParameterizedType ( ParameterizedType t ) { builder . add ( ( Class < ? > ) t . getRawType ( ) ) ; } @Override void visitClass ( Class < ? > t ) { builder . add ( t ) ; } @Override void visitGenericArrayType ( GenericArrayType t ) { builder . add ( Types . getArrayClass ( of ( t . getGenericComponentType ( ) ) . getRawType ( ) ) ) ; } } . visit ( runtimeType ) ; @SuppressWarnings ( { <str> , <str> } ) ImmutableSet < Class < ? super T > > result = ( ImmutableSet ) builder . build ( ) ; return result ; } @VisibleForTesting static < T > TypeToken < ? extends T > toGenericType ( Class < T > cls ) { if ( cls . isArray ( ) ) { Type arrayOfGenericType = Types . newArrayType ( toGenericType ( cls . getComponentType ( ) ) . runtimeType ) ; @SuppressWarnings ( <str> ) TypeToken < ? extends T > result = ( TypeToken < ? extends T > ) of ( arrayOfGenericType ) ; return result ; } TypeVariable < Class < T > > [ ] typeParams = cls . getTypeParameters ( ) ; Type ownerType = cls . isMemberClass ( ) ? toGenericType ( cls . getEnclosingClass ( ) ) . runtimeType : null ; if ( ( typeParams . length > <int> ) | | ( ownerType ! = cls . getEnclosingClass ( ) ) ) { @SuppressWarnings ( <str> ) TypeToken < ? extends T > type = ( TypeToken < ? extends T > ) of ( Types . newParameterizedTypeWithOwner ( ownerType , cls , typeParams ) ) ; return type ; } else { return of ( cls ) ; } } private TypeToken < ? super T > getSupertypeFromUpperBounds ( Class < ? super T > supertype , Type [ ] upperBounds ) { for ( Type upperBound : upperBounds ) { @SuppressWarnings ( <str> ) TypeToken < ? super T > bound = ( TypeToken < ? super T > ) of ( upperBound ) ; if ( bound . isSubtypeOf ( supertype ) ) { @SuppressWarnings ( { <str> , <str> } ) TypeToken < ? super T > result = bound . getSupertype ( ( Class ) supertype ) ; return result ; } } throw new IllegalArgumentException ( supertype + <str> + this ) ; } private TypeToken < ? extends T > getSubtypeFromLowerBounds ( Class < ? > subclass , Type [ ] lowerBounds ) { for ( Type lowerBound : lowerBounds ) { @SuppressWarnings ( <str> ) TypeToken < ? extends T > bound = ( TypeToken < ? extends T > ) of ( lowerBound ) ; return bound . getSubtype ( subclass ) ; } throw new IllegalArgumentException ( subclass + <str> + this ) ; } private TypeToken < ? super T > getArraySupertype ( Class < ? super T > supertype ) { @SuppressWarnings ( <str> ) TypeToken componentType = checkNotNull ( getComponentType ( ) , <str> , supertype , this ) ; @SuppressWarnings ( <str> ) TypeToken < ? > componentSupertype = componentType . getSupertype ( supertype . getComponentType ( ) ) ; @SuppressWarnings ( <str> ) TypeToken < ? super T > result = ( TypeToken < ? super T > ) of ( newArrayClassOrGenericArrayType ( componentSupertype . runtimeType ) ) ; return result ; } private TypeToken < ? extends T > getArraySubtype ( Class < ? > subclass ) { TypeToken < ? > componentSubtype = getComponentType ( ) . getSubtype ( subclass . getComponentType ( ) ) ; @SuppressWarnings ( <str> ) TypeToken < ? extends T > result = ( TypeToken < ? extends T > ) of ( newArrayClassOrGenericArrayType ( componentSubtype . runtimeType ) ) ; return result ; } private Type resolveTypeArgsForSubclass ( Class < ? > subclass ) { if ( runtimeType instanceof Class ) { return subclass ; } TypeToken < ? > genericSubtype = toGenericType ( subclass ) ; @SuppressWarnings ( { <str> , <str> } ) Type supertypeWithArgsFromSubtype = genericSubtype . getSupertype ( ( Class ) getRawType ( ) ) . runtimeType ; return new TypeResolver ( ) . where ( supertypeWithArgsFromSubtype , runtimeType ) . resolveType ( genericSubtype . runtimeType ) ; } private static Type newArrayClassOrGenericArrayType ( Type componentType ) { return Types . JavaVersion . JAVA7 . newArrayType ( componentType ) ; } private static final class SimpleTypeToken < T > extends TypeToken < T > { SimpleTypeToken ( Type type ) { super ( type ) ; } private static final long serialVersionUID = <int> ; } private abstract static class TypeCollector < K > { static final TypeCollector < TypeToken < ? > > FOR_GENERIC_TYPE = new TypeCollector < TypeToken < ? > > ( ) { @Override Class < ? > getRawType ( TypeToken < ? > type ) { return type . getRawType ( ) ; } @Override Iterable < ? extends TypeToken < ? > > getInterfaces ( TypeToken < ? > type ) { return type . getGenericInterfaces ( ) ; } @Nullable @Override TypeToken < ? > getSuperclass ( TypeToken < ? > type ) { return type . getGenericSuperclass ( ) ; } } ; static final TypeCollector < Class < ? > > FOR_RAW_TYPE = new TypeCollector < Class < ? > > ( ) { @Override Class < ? > getRawType ( Class < ? > type ) { return type ; } @Override Iterable < ? extends Class < ? > > getInterfaces ( Class < ? > type ) { return Arrays . asList ( type . getInterfaces ( ) ) ; } @Nullable @Override Class < ? > getSuperclass ( Class < ? > type ) { return type . getSuperclass ( ) ; } } ; final TypeCollector < K > classesOnly ( ) { return new ForwardingTypeCollector < K > ( this ) { @Override Iterable < ? extends K > getInterfaces ( K type ) { return ImmutableSet . of ( ) ; } @Override ImmutableList < K > collectTypes ( Iterable < ? extends K > types ) { ImmutableList . Builder < K > builder = ImmutableList . builder ( ) ; for ( K type : types ) { if ( ! getRawType ( type ) . isInterface ( ) ) { builder . add ( type ) ; } } return super . collectTypes ( builder . build ( ) ) ; } } ; } final ImmutableList < K > collectTypes ( K type ) { return collectTypes ( ImmutableList . of ( type ) ) ; } ImmutableList < K > collectTypes ( Iterable < ? extends K > types ) { Map < K , Integer > map = Maps . newHashMap ( ) ; for ( K type : types ) { collectTypes ( type , map ) ; } return sortKeysByValue ( map , Ordering . natural ( ) . reverse ( ) ) ; } private int collectTypes ( K type , Map < ? super K , Integer > map ) { Integer existing = map . get ( type ) ; if ( existing ! = null ) { return existing ; } int aboveMe = getRawType ( type ) . isInterface ( ) ? <int> : <int> ; for ( K interfaceType : getInterfaces ( type ) ) { aboveMe = Math . max ( aboveMe , collectTypes ( interfaceType , map ) ) ; } K superclass = getSuperclass ( type ) ; if ( superclass ! = null ) { aboveMe = Math . max ( aboveMe , collectTypes ( superclass , map ) ) ; } map . put ( type , aboveMe + <int> ) ; return aboveMe + <int> ; } private static < K , V > ImmutableList < K > sortKeysByValue ( final Map < K , V > map , final Comparator < ? super V > valueComparator ) { Ordering < K > keyOrdering = new Ordering < K > ( ) { @Override public int compare ( K left , K right ) { return valueComparator . compare ( map . get ( left ) , map . get ( right ) ) ; } } ; return keyOrdering . immutableSortedCopy ( map . keySet ( ) ) ; } abstract Class < ? > getRawType ( K type ) ; abstract Iterable < ? extends K > getInterfaces ( K type ) ; @Nullable abstract K getSuperclass ( K type ) ; private static class ForwardingTypeCollector < K > extends TypeCollector < K > { private final TypeCollector < K > delegate ; ForwardingTypeCollector ( TypeCollector < K > delegate ) { this . delegate = delegate ; } @Override Class < ? > getRawType ( K type ) { return delegate . getRawType ( type ) ; } @Override Iterable < ? extends K > getInterfaces ( K type ) { return delegate . getInterfaces ( type ) ; } @Override K getSuperclass ( K type ) { return delegate . getSuperclass ( type ) ; } } } } 
