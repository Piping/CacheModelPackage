package org . apache . cassandra . stress . settings ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import org . apache . cassandra . stress . generate . DistributionFactory ; import org . apache . cassandra . stress . generate . PartitionGenerator ; import org . apache . cassandra . stress . generate . SeedManager ; import org . apache . cassandra . stress . generate . values . Bytes ; import org . apache . cassandra . stress . generate . values . Generator ; import org . apache . cassandra . stress . generate . values . GeneratorConfig ; import org . apache . cassandra . stress . generate . values . HexBytes ; import org . apache . cassandra . stress . operations . FixedOpDistribution ; import org . apache . cassandra . stress . operations . OpDistribution ; import org . apache . cassandra . stress . operations . OpDistributionFactory ; import org . apache . cassandra . stress . operations . predefined . PredefinedOperation ; import org . apache . cassandra . stress . util . Timing ; public class SettingsCommandPreDefined extends SettingsCommand { public final DistributionFactory add ; public final int keySize ; public OpDistributionFactory getFactory ( final StressSettings settings ) { final SeedManager seeds = new SeedManager ( settings ) ; return new OpDistributionFactory ( ) { public OpDistribution get ( Timing timing , int sampleCount ) { return new FixedOpDistribution ( PredefinedOperation . operation ( type , timing . newTimer ( type . toString ( ) , sampleCount ) , newGenerator ( settings ) , seeds , settings , add ) ) ; } public String desc ( ) { return type . toString ( ) ; } public Iterable < OpDistributionFactory > each ( ) { return Collections . < OpDistributionFactory > singleton ( this ) ; } } ; } PartitionGenerator newGenerator ( StressSettings settings ) { List < String > names = settings . columns . namestrs ; List < Generator > partitionKey = Collections . < Generator > singletonList ( new HexBytes ( <str> , new GeneratorConfig ( <str> , null , OptionDistribution . get ( <str> + keySize + <str> ) , null ) ) ) ; List < Generator > columns = new ArrayList < > ( ) ; for ( int i = <int> ; i < settings . columns . maxColumnsPerKey ; i + + ) columns . add ( new Bytes ( names . get ( i ) , new GeneratorConfig ( <str> + names . get ( i ) , null , settings . columns . sizeDistribution , null ) ) ) ; return new PartitionGenerator ( partitionKey , Collections . < Generator > emptyList ( ) , columns , PartitionGenerator . Order . ARBITRARY ) ; } public SettingsCommandPreDefined ( Command type , Options options ) { super ( type , options . parent ) ; add = options . add . get ( ) ; keySize = Integer . parseInt ( options . keysize . value ( ) ) ; } static class Options extends GroupedOptions { final SettingsCommand . Options parent ; protected Options ( SettingsCommand . Options parent ) { this . parent = parent ; } final OptionDistribution add = new OptionDistribution ( <str> , <str> , <str> ) ; final OptionSimple keysize = new OptionSimple ( <str> , <str> , <str> , <str> , false ) ; @Override public List < ? extends Option > options ( ) { return merge ( parent . options ( ) , Arrays . asList ( add , keysize ) ) ; } } public void truncateTables ( StressSettings settings ) { truncateTables ( settings , settings . schema . keyspace , <str> , <str> , <str> ) ; } public static SettingsCommandPreDefined build ( Command type , String [ ] params ) { GroupedOptions options = GroupedOptions . select ( params , new Options ( new Uncertainty ( ) ) , new Options ( new Count ( ) ) , new Options ( new Duration ( ) ) ) ; if ( options = = null ) { printHelp ( type ) ; System . out . println ( <str> + type + <str> ) ; System . exit ( <int> ) ; } return new SettingsCommandPreDefined ( type , ( Options ) options ) ; } static void printHelp ( Command type ) { printHelp ( type . toString ( ) . toLowerCase ( ) ) ; } static void printHelp ( String type ) { GroupedOptions . printOptions ( System . out , type . toLowerCase ( ) , new Uncertainty ( ) , new Count ( ) , new Duration ( ) ) ; } static Runnable helpPrinter ( final Command type ) { return new Runnable ( ) { @Override public void run ( ) { printHelp ( type ) ; } } ; } } 
