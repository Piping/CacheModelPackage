package org . elasticsearch . search . aggregations . metrics . avg ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . search . aggregations . AggregationStreams ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . metrics . InternalNumericMetricsAggregation ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import org . elasticsearch . search . aggregations . support . format . ValueFormatterStreams ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class InternalAvg extends InternalNumericMetricsAggregation . SingleValue implements Avg { public final static Type TYPE = new Type ( <str> ) ; public final static AggregationStreams . Stream STREAM = new AggregationStreams . Stream ( ) { @Override public InternalAvg readResult ( StreamInput in ) throws IOException { InternalAvg result = new InternalAvg ( ) ; result . readFrom ( in ) ; return result ; } } ; public static void registerStreams ( ) { AggregationStreams . registerStream ( STREAM , TYPE . stream ( ) ) ; } private double sum ; private long count ; InternalAvg ( ) { } public InternalAvg ( String name , double sum , long count , ValueFormatter formatter , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) { super ( name , pipelineAggregators , metaData ) ; this . sum = sum ; this . count = count ; this . valueFormatter = formatter ; } @Override public double value ( ) { return getValue ( ) ; } @Override public double getValue ( ) { return sum / count ; } @Override public Type type ( ) { return TYPE ; } @Override public InternalAvg doReduce ( List < InternalAggregation > aggregations , ReduceContext reduceContext ) { long count = <int> ; double sum = <int> ; for ( InternalAggregation aggregation : aggregations ) { count + = ( ( InternalAvg ) aggregation ) . count ; sum + = ( ( InternalAvg ) aggregation ) . sum ; } return new InternalAvg ( getName ( ) , sum , count , valueFormatter , pipelineAggregators ( ) , getMetaData ( ) ) ; } @Override protected void doReadFrom ( StreamInput in ) throws IOException { valueFormatter = ValueFormatterStreams . readOptional ( in ) ; sum = in . readDouble ( ) ; count = in . readVLong ( ) ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { ValueFormatterStreams . writeOptional ( valueFormatter , out ) ; out . writeDouble ( sum ) ; out . writeVLong ( count ) ; } @Override public XContentBuilder doXContentBody ( XContentBuilder builder , Params params ) throws IOException { builder . field ( CommonFields . VALUE , count ! = <int> ? getValue ( ) : null ) ; if ( count ! = <int> & & ! ( valueFormatter instanceof ValueFormatter . Raw ) ) { builder . field ( CommonFields . VALUE_AS_STRING , valueFormatter . format ( getValue ( ) ) ) ; } return builder ; } } 
