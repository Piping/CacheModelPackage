package com . google . common . collect . testing ; import static com . google . common . collect . testing . Helpers . castOrCopyToList ; import static com . google . common . collect . testing . Helpers . equal ; import static com . google . common . collect . testing . Helpers . mapEntry ; import static java . util . Collections . sort ; import com . google . common . annotations . GwtCompatible ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . SortedMap ; import java . util . SortedSet ; @GwtCompatible public final class DerivedCollectionGenerators { public static class MapEntrySetGenerator < K , V > implements TestSetGenerator < Map . Entry < K , V > > , DerivedGenerator { private final OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > mapGenerator ; public MapEntrySetGenerator ( OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > mapGenerator ) { this . mapGenerator = mapGenerator ; } @Override public SampleElements < Map . Entry < K , V > > samples ( ) { return mapGenerator . samples ( ) ; } @Override public Set < Map . Entry < K , V > > create ( Object . . . elements ) { return mapGenerator . create ( elements ) . entrySet ( ) ; } @Override public Map . Entry < K , V > [ ] createArray ( int length ) { return mapGenerator . createArray ( length ) ; } @Override public Iterable < Map . Entry < K , V > > order ( List < Map . Entry < K , V > > insertionOrder ) { return mapGenerator . order ( insertionOrder ) ; } @Override public OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > getInnerGenerator ( ) { return mapGenerator ; } } static < K , V > TestSetGenerator < K > keySetGenerator ( OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > mapGenerator ) { TestContainerGenerator < Map < K , V > , Entry < K , V > > generator = mapGenerator . getInnerGenerator ( ) ; if ( generator instanceof TestSortedMapGenerator & & ( ( TestSortedMapGenerator < K , V > ) generator ) . create ( ) . keySet ( ) instanceof SortedSet ) { return new MapSortedKeySetGenerator < K , V > ( mapGenerator ) ; } else { return new MapKeySetGenerator < K , V > ( mapGenerator ) ; } } public static class MapKeySetGenerator < K , V > implements TestSetGenerator < K > , DerivedGenerator { private final OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > mapGenerator ; private final SampleElements < K > samples ; public MapKeySetGenerator ( OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > mapGenerator ) { this . mapGenerator = mapGenerator ; final SampleElements < Map . Entry < K , V > > mapSamples = this . mapGenerator . samples ( ) ; this . samples = new SampleElements < K > ( mapSamples . e0 ( ) . getKey ( ) , mapSamples . e1 ( ) . getKey ( ) , mapSamples . e2 ( ) . getKey ( ) , mapSamples . e3 ( ) . getKey ( ) , mapSamples . e4 ( ) . getKey ( ) ) ; } @Override public SampleElements < K > samples ( ) { return samples ; } @Override public Set < K > create ( Object . . . elements ) { @SuppressWarnings ( <str> ) K [ ] keysArray = ( K [ ] ) elements ; Collection < Map . Entry < K , V > > originalEntries = mapGenerator . getSampleElements ( elements . length ) ; Collection < Map . Entry < K , V > > entries = new ArrayList < Entry < K , V > > ( elements . length ) ; int i = <int> ; for ( Map . Entry < K , V > entry : originalEntries ) { entries . add ( Helpers . mapEntry ( keysArray [ i + + ] , entry . getValue ( ) ) ) ; } return mapGenerator . create ( entries . toArray ( ) ) . keySet ( ) ; } @Override public K [ ] createArray ( int length ) { return ( ( TestMapGenerator < K , V > ) mapGenerator . getInnerGenerator ( ) ) . createKeyArray ( length ) ; } @Override public Iterable < K > order ( List < K > insertionOrder ) { V v = ( ( TestMapGenerator < K , V > ) mapGenerator . getInnerGenerator ( ) ) . samples ( ) . e0 ( ) . getValue ( ) ; List < Entry < K , V > > entries = new ArrayList < Entry < K , V > > ( ) ; for ( K element : insertionOrder ) { entries . add ( mapEntry ( element , v ) ) ; } List < K > keys = new ArrayList < K > ( ) ; for ( Entry < K , V > entry : mapGenerator . order ( entries ) ) { keys . add ( entry . getKey ( ) ) ; } return keys ; } @Override public OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > getInnerGenerator ( ) { return mapGenerator ; } } public static class MapSortedKeySetGenerator < K , V > extends MapKeySetGenerator < K , V > implements TestSortedSetGenerator < K > , DerivedGenerator { private final TestSortedMapGenerator < K , V > delegate ; public MapSortedKeySetGenerator ( OneSizeTestContainerGenerator < Map < K , V > , Entry < K , V > > mapGenerator ) { super ( mapGenerator ) ; this . delegate = ( TestSortedMapGenerator < K , V > ) mapGenerator . getInnerGenerator ( ) ; } @Override public SortedSet < K > create ( Object . . . elements ) { return ( SortedSet < K > ) super . create ( elements ) ; } @Override public K belowSamplesLesser ( ) { return delegate . belowSamplesLesser ( ) . getKey ( ) ; } @Override public K belowSamplesGreater ( ) { return delegate . belowSamplesGreater ( ) . getKey ( ) ; } @Override public K aboveSamplesLesser ( ) { return delegate . aboveSamplesLesser ( ) . getKey ( ) ; } @Override public K aboveSamplesGreater ( ) { return delegate . aboveSamplesGreater ( ) . getKey ( ) ; } } public static class MapValueCollectionGenerator < K , V > implements TestCollectionGenerator < V > , DerivedGenerator { private final OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > mapGenerator ; private final SampleElements < V > samples ; public MapValueCollectionGenerator ( OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > mapGenerator ) { this . mapGenerator = mapGenerator ; final SampleElements < Map . Entry < K , V > > mapSamples = this . mapGenerator . samples ( ) ; this . samples = new SampleElements < V > ( mapSamples . e0 ( ) . getValue ( ) , mapSamples . e1 ( ) . getValue ( ) , mapSamples . e2 ( ) . getValue ( ) , mapSamples . e3 ( ) . getValue ( ) , mapSamples . e4 ( ) . getValue ( ) ) ; } @Override public SampleElements < V > samples ( ) { return samples ; } @Override public Collection < V > create ( Object . . . elements ) { @SuppressWarnings ( <str> ) V [ ] valuesArray = ( V [ ] ) elements ; Collection < Map . Entry < K , V > > originalEntries = mapGenerator . getSampleElements ( elements . length ) ; Collection < Map . Entry < K , V > > entries = new ArrayList < Entry < K , V > > ( elements . length ) ; int i = <int> ; for ( Map . Entry < K , V > entry : originalEntries ) { entries . add ( Helpers . mapEntry ( entry . getKey ( ) , valuesArray [ i + + ] ) ) ; } return mapGenerator . create ( entries . toArray ( ) ) . values ( ) ; } @Override public V [ ] createArray ( int length ) { final V [ ] vs = ( ( TestMapGenerator < K , V > ) mapGenerator . getInnerGenerator ( ) ) . createValueArray ( length ) ; return vs ; } @Override public Iterable < V > order ( List < V > insertionOrder ) { final List < Entry < K , V > > orderedEntries = castOrCopyToList ( mapGenerator . order ( castOrCopyToList ( mapGenerator . getSampleElements ( <int> ) ) ) ) ; sort ( insertionOrder , new Comparator < V > ( ) { @Override public int compare ( V left , V right ) { return indexOfEntryWithValue ( left ) - indexOfEntryWithValue ( right ) ; } int indexOfEntryWithValue ( V value ) { for ( int i = <int> ; i < orderedEntries . size ( ) ; i + + ) { if ( equal ( orderedEntries . get ( i ) . getValue ( ) , value ) ) { return i ; } } throw new IllegalArgumentException ( <str> ) ; } } ) ; return insertionOrder ; } @Override public OneSizeTestContainerGenerator < Map < K , V > , Map . Entry < K , V > > getInnerGenerator ( ) { return mapGenerator ; } } static class ForwardingTestMapGenerator < K , V > implements TestMapGenerator < K , V > { TestMapGenerator < K , V > delegate ; ForwardingTestMapGenerator ( TestMapGenerator < K , V > delegate ) { this . delegate = delegate ; } @Override public Iterable < Entry < K , V > > order ( List < Entry < K , V > > insertionOrder ) { return delegate . order ( insertionOrder ) ; } @Override public K [ ] createKeyArray ( int length ) { return delegate . createKeyArray ( length ) ; } @Override public V [ ] createValueArray ( int length ) { return delegate . createValueArray ( length ) ; } @Override public SampleElements < Entry < K , V > > samples ( ) { return delegate . samples ( ) ; } @Override public Map < K , V > create ( Object . . . elements ) { return delegate . create ( elements ) ; } @Override public Entry < K , V > [ ] createArray ( int length ) { return delegate . createArray ( length ) ; } } public enum Bound { INCLUSIVE , EXCLUSIVE , NO_BOUND ; } public static class SortedSetSubsetTestSetGenerator < E > implements TestSortedSetGenerator < E > { final Bound to ; final Bound from ; final E firstInclusive ; final E lastInclusive ; private final Comparator < ? super E > comparator ; private final TestSortedSetGenerator < E > delegate ; public SortedSetSubsetTestSetGenerator ( TestSortedSetGenerator < E > delegate , Bound to , Bound from ) { this . to = to ; this . from = from ; this . delegate = delegate ; SortedSet < E > emptySet = delegate . create ( ) ; this . comparator = emptySet . comparator ( ) ; SampleElements < E > samples = delegate . samples ( ) ; List < E > samplesList = new ArrayList < E > ( samples . asList ( ) ) ; Collections . sort ( samplesList , comparator ) ; this . firstInclusive = samplesList . get ( <int> ) ; this . lastInclusive = samplesList . get ( samplesList . size ( ) - <int> ) ; } public final TestSortedSetGenerator < E > getInnerGenerator ( ) { return delegate ; } public final Bound getTo ( ) { return to ; } public final Bound getFrom ( ) { return from ; } @Override public SampleElements < E > samples ( ) { return delegate . samples ( ) ; } @Override public E [ ] createArray ( int length ) { return delegate . createArray ( length ) ; } @Override public Iterable < E > order ( List < E > insertionOrder ) { return delegate . order ( insertionOrder ) ; } @Override public SortedSet < E > create ( Object . . . elements ) { @SuppressWarnings ( <str> ) List < E > normalValues = ( List ) Arrays . asList ( elements ) ; List < E > extremeValues = new ArrayList < E > ( ) ; for ( Object o : elements ) { if ( o = = null ) { throw new NullPointerException ( ) ; } } E firstExclusive = delegate . belowSamplesGreater ( ) ; E lastExclusive = delegate . aboveSamplesLesser ( ) ; if ( from ! = Bound . NO_BOUND ) { extremeValues . add ( delegate . belowSamplesLesser ( ) ) ; extremeValues . add ( delegate . belowSamplesGreater ( ) ) ; } if ( to ! = Bound . NO_BOUND ) { extremeValues . add ( delegate . aboveSamplesLesser ( ) ) ; extremeValues . add ( delegate . aboveSamplesGreater ( ) ) ; } List < E > allEntries = new ArrayList < E > ( ) ; allEntries . addAll ( extremeValues ) ; allEntries . addAll ( normalValues ) ; SortedSet < E > map = delegate . create ( allEntries . toArray ( ) ) ; return createSubSet ( map , firstExclusive , lastExclusive ) ; } SortedSet < E > createSubSet ( SortedSet < E > set , E firstExclusive , E lastExclusive ) { if ( from = = Bound . NO_BOUND & & to = = Bound . EXCLUSIVE ) { return set . headSet ( lastExclusive ) ; } else if ( from = = Bound . INCLUSIVE & & to = = Bound . NO_BOUND ) { return set . tailSet ( firstInclusive ) ; } else if ( from = = Bound . INCLUSIVE & & to = = Bound . EXCLUSIVE ) { return set . subSet ( firstInclusive , lastExclusive ) ; } else { throw new IllegalArgumentException ( ) ; } } @Override public E belowSamplesLesser ( ) { throw new UnsupportedOperationException ( ) ; } @Override public E belowSamplesGreater ( ) { throw new UnsupportedOperationException ( ) ; } @Override public E aboveSamplesLesser ( ) { throw new UnsupportedOperationException ( ) ; } @Override public E aboveSamplesGreater ( ) { throw new UnsupportedOperationException ( ) ; } } public static class SortedMapSubmapTestMapGenerator < K , V > extends ForwardingTestMapGenerator < K , V > implements TestSortedMapGenerator < K , V > { final Bound to ; final Bound from ; final K firstInclusive ; final K lastInclusive ; private final Comparator < Entry < K , V > > entryComparator ; public SortedMapSubmapTestMapGenerator ( TestSortedMapGenerator < K , V > delegate , Bound to , Bound from ) { super ( delegate ) ; this . to = to ; this . from = from ; SortedMap < K , V > emptyMap = delegate . create ( ) ; this . entryComparator = Helpers . entryComparator ( emptyMap . comparator ( ) ) ; SampleElements < Entry < K , V > > samples = delegate . samples ( ) ; @SuppressWarnings ( <str> ) List < Entry < K , V > > samplesList = Arrays . asList ( samples . e0 ( ) , samples . e1 ( ) , samples . e2 ( ) , samples . e3 ( ) , samples . e4 ( ) ) ; Collections . sort ( samplesList , entryComparator ) ; this . firstInclusive = samplesList . get ( <int> ) . getKey ( ) ; this . lastInclusive = samplesList . get ( samplesList . size ( ) - <int> ) . getKey ( ) ; } @Override public SortedMap < K , V > create ( Object . . . entries ) { @SuppressWarnings ( <str> ) List < Entry < K , V > > normalValues = ( List ) Arrays . asList ( entries ) ; List < Entry < K , V > > extremeValues = new ArrayList < Entry < K , V > > ( ) ; K firstExclusive = getInnerGenerator ( ) . belowSamplesGreater ( ) . getKey ( ) ; K lastExclusive = getInnerGenerator ( ) . aboveSamplesLesser ( ) . getKey ( ) ; if ( from ! = Bound . NO_BOUND ) { extremeValues . add ( getInnerGenerator ( ) . belowSamplesLesser ( ) ) ; extremeValues . add ( getInnerGenerator ( ) . belowSamplesGreater ( ) ) ; } if ( to ! = Bound . NO_BOUND ) { extremeValues . add ( getInnerGenerator ( ) . aboveSamplesLesser ( ) ) ; extremeValues . add ( getInnerGenerator ( ) . aboveSamplesGreater ( ) ) ; } List < Entry < K , V > > allEntries = new ArrayList < Entry < K , V > > ( ) ; allEntries . addAll ( extremeValues ) ; allEntries . addAll ( normalValues ) ; SortedMap < K , V > map = ( SortedMap < K , V > ) delegate . create ( ( Object [ ] ) allEntries . toArray ( new Entry < ? , ? > [ allEntries . size ( ) ] ) ) ; return createSubMap ( map , firstExclusive , lastExclusive ) ; } SortedMap < K , V > createSubMap ( SortedMap < K , V > map , K firstExclusive , K lastExclusive ) { if ( from = = Bound . NO_BOUND & & to = = Bound . EXCLUSIVE ) { return map . headMap ( lastExclusive ) ; } else if ( from = = Bound . INCLUSIVE & & to = = Bound . NO_BOUND ) { return map . tailMap ( firstInclusive ) ; } else if ( from = = Bound . INCLUSIVE & & to = = Bound . EXCLUSIVE ) { return map . subMap ( firstInclusive , lastExclusive ) ; } else { throw new IllegalArgumentException ( ) ; } } public final Bound getTo ( ) { return to ; } public final Bound getFrom ( ) { return from ; } public final TestSortedMapGenerator < K , V > getInnerGenerator ( ) { return ( TestSortedMapGenerator < K , V > ) delegate ; } @Override public Entry < K , V > belowSamplesLesser ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Entry < K , V > belowSamplesGreater ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Entry < K , V > aboveSamplesLesser ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Entry < K , V > aboveSamplesGreater ( ) { throw new UnsupportedOperationException ( ) ; } } private DerivedCollectionGenerators ( ) { } } 
