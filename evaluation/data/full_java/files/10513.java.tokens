package com . google . common . io ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . base . Charsets ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . EOFException ; import java . io . File ; import java . io . FileOutputStream ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . RandomAccessFile ; import java . nio . channels . Channels ; import java . nio . channels . ReadableByteChannel ; import java . nio . channels . WritableByteChannel ; import java . util . Arrays ; public class ByteStreamsTest extends IoTestCase { public void testCopyChannel ( ) throws IOException { byte [ ] expected = newPreFilledByteArray ( <int> ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; WritableByteChannel outChannel = Channels . newChannel ( out ) ; ReadableByteChannel inChannel = Channels . newChannel ( new ByteArrayInputStream ( expected ) ) ; ByteStreams . copy ( inChannel , outChannel ) ; assertEquals ( expected , out . toByteArray ( ) ) ; } public void testCopyFileChannel ( ) throws IOException { final int chunkSize = <int> ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; WritableByteChannel outChannel = Channels . newChannel ( out ) ; File testFile = createTempFile ( ) ; FileOutputStream fos = new FileOutputStream ( testFile ) ; byte [ ] dummyData = newPreFilledByteArray ( chunkSize ) ; try { for ( int i = <int> ; i < <int> ; i + + ) { fos . write ( dummyData ) ; } } finally { fos . close ( ) ; } ReadableByteChannel inChannel = new RandomAccessFile ( testFile , <str> ) . getChannel ( ) ; try { ByteStreams . copy ( inChannel , outChannel ) ; } finally { inChannel . close ( ) ; } byte [ ] actual = out . toByteArray ( ) ; for ( int i = <int> ; i < <int> * chunkSize ; i + = chunkSize ) { assertEquals ( dummyData , Arrays . copyOfRange ( actual , i , i + chunkSize ) ) ; } } public void testReadFully ( ) throws IOException { byte [ ] b = new byte [ <int> ] ; try { ByteStreams . readFully ( newTestStream ( <int> ) , null , <int> , <int> ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } try { ByteStreams . readFully ( null , b , <int> , <int> ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } try { ByteStreams . readFully ( newTestStream ( <int> ) , b , - <int> , <int> ) ; fail ( <str> ) ; } catch ( IndexOutOfBoundsException e ) { } try { ByteStreams . readFully ( newTestStream ( <int> ) , b , <int> , - <int> ) ; fail ( <str> ) ; } catch ( IndexOutOfBoundsException e ) { } try { ByteStreams . readFully ( newTestStream ( <int> ) , b , <int> , - <int> ) ; fail ( <str> ) ; } catch ( IndexOutOfBoundsException e ) { } try { ByteStreams . readFully ( newTestStream ( <int> ) , b , <int> , <int> ) ; fail ( <str> ) ; } catch ( IndexOutOfBoundsException e ) { } try { ByteStreams . readFully ( newTestStream ( <int> ) , b , <int> , <int> ) ; fail ( <str> ) ; } catch ( EOFException e ) { } Arrays . fill ( b , ( byte ) <int> ) ; ByteStreams . readFully ( newTestStream ( <int> ) , b , <int> , <int> ) ; assertEquals ( new byte [ <int> ] , b ) ; Arrays . fill ( b , ( byte ) <int> ) ; ByteStreams . readFully ( newTestStream ( <int> ) , b , <int> , <int> ) ; assertEquals ( newPreFilledByteArray ( <int> ) , b ) ; Arrays . fill ( b , ( byte ) <int> ) ; ByteStreams . readFully ( newTestStream ( <int> ) , b , <int> , <int> ) ; assertEquals ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } , b ) ; } public void testSkipFully ( ) throws IOException { byte [ ] bytes = newPreFilledByteArray ( <int> ) ; skipHelper ( <int> , <int> , new ByteArrayInputStream ( bytes ) ) ; skipHelper ( <int> , <int> , new ByteArrayInputStream ( bytes ) ) ; skipHelper ( <int> , <int> , new SlowSkipper ( new ByteArrayInputStream ( bytes ) , <int> ) ) ; skipHelper ( <int> , <int> , new SlowSkipper ( new ByteArrayInputStream ( bytes ) , <int> ) ) ; skipHelper ( <int> , - <int> , new ByteArrayInputStream ( bytes ) ) ; try { skipHelper ( <int> , <int> , new ByteArrayInputStream ( bytes ) ) ; fail ( <str> ) ; } catch ( EOFException e ) { } } private static void skipHelper ( long n , int expect , InputStream in ) throws IOException { ByteStreams . skipFully ( in , n ) ; assertEquals ( expect , in . read ( ) ) ; in . close ( ) ; } private static final byte [ ] bytes = new byte [ ] { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; public void testNewDataInput_empty ( ) { byte [ ] b = new byte [ <int> ] ; ByteArrayDataInput in = ByteStreams . newDataInput ( b ) ; try { in . readInt ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testNewDataInput_normal ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes ) ; assertEquals ( <hex> , in . readInt ( ) ) ; assertEquals ( <hex> , in . readInt ( ) ) ; try { in . readInt ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testNewDataInput_readFully ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes ) ; byte [ ] actual = new byte [ bytes . length ] ; in . readFully ( actual ) ; assertEquals ( bytes , actual ) ; } public void testNewDataInput_readFullyAndThenSome ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes ) ; byte [ ] actual = new byte [ bytes . length * <int> ] ; try { in . readFully ( actual ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { assertThat ( ex . getCause ( ) ) . isInstanceOf ( EOFException . class ) ; } } public void testNewDataInput_readFullyWithOffset ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes ) ; byte [ ] actual = new byte [ <int> ] ; in . readFully ( actual , <int> , <int> ) ; assertEquals ( <int> , actual [ <int> ] ) ; assertEquals ( <int> , actual [ <int> ] ) ; assertEquals ( bytes [ <int> ] , actual [ <int> ] ) ; assertEquals ( bytes [ <int> ] , actual [ <int> ] ) ; } public void testNewDataInput_readLine ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( <str> . getBytes ( Charsets . UTF_8 ) ) ; assertEquals ( <str> , in . readLine ( ) ) ; assertEquals ( <str> , in . readLine ( ) ) ; assertEquals ( <str> , in . readLine ( ) ) ; assertEquals ( <str> , in . readLine ( ) ) ; } public void testNewDataInput_readFloat ( ) { byte [ ] data = { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; ByteArrayDataInput in = ByteStreams . newDataInput ( data ) ; assertEquals ( Float . intBitsToFloat ( <hex> ) , in . readFloat ( ) , <float> ) ; assertEquals ( Float . intBitsToFloat ( <hex> ) , in . readFloat ( ) , <float> ) ; } public void testNewDataInput_readDouble ( ) { byte [ ] data = { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; ByteArrayDataInput in = ByteStreams . newDataInput ( data ) ; assertEquals ( Double . longBitsToDouble ( <hex> ) , in . readDouble ( ) , <float> ) ; } public void testNewDataInput_readUTF ( ) { byte [ ] data = new byte [ <int> ] ; data [ <int> ] = <int> ; System . arraycopy ( <str> . getBytes ( Charsets . UTF_8 ) , <int> , data , <int> , <int> ) ; ByteArrayDataInput in = ByteStreams . newDataInput ( data ) ; assertEquals ( <str> , in . readUTF ( ) ) ; } public void testNewDataInput_readChar ( ) { byte [ ] data = <str> . getBytes ( Charsets . UTF_16BE ) ; ByteArrayDataInput in = ByteStreams . newDataInput ( data ) ; assertEquals ( <str> , in . readChar ( ) ) ; assertEquals ( <str> , in . readChar ( ) ) ; assertEquals ( <str> , in . readChar ( ) ) ; } public void testNewDataInput_readUnsignedShort ( ) { byte [ ] data = { <int> , <int> , <int> , <int> , ( byte ) <hex> , ( byte ) <hex> , <hex> , <hex> } ; ByteArrayDataInput in = ByteStreams . newDataInput ( data ) ; assertEquals ( <int> , in . readUnsignedShort ( ) ) ; assertEquals ( <int> , in . readUnsignedShort ( ) ) ; assertEquals ( <int> , in . readUnsignedShort ( ) ) ; assertEquals ( <hex> , in . readUnsignedShort ( ) ) ; } public void testNewDataInput_readLong ( ) { byte [ ] data = { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; ByteArrayDataInput in = ByteStreams . newDataInput ( data ) ; assertEquals ( <hex> , in . readLong ( ) ) ; } public void testNewDataInput_readBoolean ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes ) ; assertTrue ( in . readBoolean ( ) ) ; } public void testNewDataInput_readByte ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes ) ; for ( int i = <int> ; i < bytes . length ; i + + ) { assertEquals ( bytes [ i ] , in . readByte ( ) ) ; } try { in . readByte ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { assertThat ( ex . getCause ( ) ) . isInstanceOf ( EOFException . class ) ; } } public void testNewDataInput_readUnsignedByte ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes ) ; for ( int i = <int> ; i < bytes . length ; i + + ) { assertEquals ( bytes [ i ] , in . readUnsignedByte ( ) ) ; } try { in . readUnsignedByte ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { assertThat ( ex . getCause ( ) ) . isInstanceOf ( EOFException . class ) ; } } public void testNewDataInput_offset ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( bytes , <int> ) ; assertEquals ( <hex> , in . readInt ( ) ) ; try { in . readInt ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testNewDataInput_skip ( ) { ByteArrayDataInput in = ByteStreams . newDataInput ( new byte [ <int> ] ) ; assertEquals ( <int> , in . skipBytes ( <int> ) ) ; assertEquals ( <int> , in . skipBytes ( <int> ) ) ; } public void testNewDataInput_BAIS ( ) { ByteArrayInputStream bais = new ByteArrayInputStream ( new byte [ ] { <hex> , <hex> , <hex> , <hex> } ) ; ByteArrayDataInput in = ByteStreams . newDataInput ( bais ) ; assertEquals ( <hex> , in . readInt ( ) ) ; } public void testNewDataOutput_empty ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; assertEquals ( <int> , out . toByteArray ( ) . length ) ; } public void testNewDataOutput_writeInt ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeInt ( <hex> ) ; out . writeInt ( <hex> ) ; assertEquals ( bytes , out . toByteArray ( ) ) ; } public void testNewDataOutput_sized ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( <int> ) ; out . writeInt ( <hex> ) ; out . writeInt ( <hex> ) ; assertEquals ( bytes , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeLong ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeLong ( <hex> ) ; assertEquals ( bytes , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeByteArray ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . write ( bytes ) ; assertEquals ( bytes , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeByte ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . write ( <hex> ) ; out . writeByte ( <hex> ) ; assertEquals ( new byte [ ] { <hex> , <hex> } , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeByteOffset ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . write ( bytes , <int> , <int> ) ; byte [ ] expected = { bytes [ <int> ] , bytes [ <int> ] } ; assertEquals ( expected , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeBoolean ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeBoolean ( true ) ; out . writeBoolean ( false ) ; byte [ ] expected = { ( byte ) <int> , ( byte ) <int> } ; assertEquals ( expected , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeChar ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeChar ( <str> ) ; assertEquals ( new byte [ ] { <int> , <int> } , out . toByteArray ( ) ) ; } @AndroidIncompatible public void testNewDataOutput_writeChars ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeChars ( <str> ) ; byte [ ] expected = Arrays . copyOfRange ( <str> . getBytes ( Charsets . UTF_16 ) , <int> , <int> ) ; assertEquals ( expected , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeUTF ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeUTF ( <str> ) ; byte [ ] expected = <str> . getBytes ( Charsets . UTF_8 ) ; byte [ ] actual = out . toByteArray ( ) ; assertEquals ( <int> , actual [ <int> ] ) ; assertEquals ( expected . length , actual [ <int> ] ) ; assertEquals ( expected , Arrays . copyOfRange ( actual , <int> , actual . length ) ) ; } public void testNewDataOutput_writeShort ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeShort ( <hex> ) ; assertEquals ( new byte [ ] { <hex> , <hex> } , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeDouble ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeDouble ( Double . longBitsToDouble ( <hex> ) ) ; assertEquals ( bytes , out . toByteArray ( ) ) ; } public void testNewDataOutput_writeFloat ( ) { ByteArrayDataOutput out = ByteStreams . newDataOutput ( ) ; out . writeFloat ( Float . intBitsToFloat ( <hex> ) ) ; out . writeFloat ( Float . intBitsToFloat ( <hex> ) ) ; assertEquals ( bytes , out . toByteArray ( ) ) ; } public void testNewDataOutput_BAOS ( ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ByteArrayDataOutput out = ByteStreams . newDataOutput ( baos ) ; out . writeInt ( <hex> ) ; assertEquals ( <int> , baos . size ( ) ) ; assertEquals ( new byte [ ] { <hex> , <hex> , <hex> , <hex> } , baos . toByteArray ( ) ) ; } public void testToByteArray_withSize_givenCorrectSize ( ) throws IOException { InputStream in = newTestStream ( <int> ) ; byte [ ] b = ByteStreams . toByteArray ( in , <int> ) ; assertEquals ( <int> , b . length ) ; } public void testToByteArray_withSize_givenSmallerSize ( ) throws IOException { InputStream in = newTestStream ( <int> ) ; byte [ ] b = ByteStreams . toByteArray ( in , <int> ) ; assertEquals ( <int> , b . length ) ; } public void testToByteArray_withSize_givenLargerSize ( ) throws IOException { InputStream in = newTestStream ( <int> ) ; byte [ ] b = ByteStreams . toByteArray ( in , <int> ) ; assertEquals ( <int> , b . length ) ; } public void testToByteArray_withSize_givenSizeZero ( ) throws IOException { InputStream in = newTestStream ( <int> ) ; byte [ ] b = ByteStreams . toByteArray ( in , <int> ) ; assertEquals ( <int> , b . length ) ; } private static InputStream newTestStream ( int n ) { return new ByteArrayInputStream ( newPreFilledByteArray ( n ) ) ; } private static class SlowSkipper extends FilterInputStream { private final long max ; public SlowSkipper ( InputStream in , long max ) { super ( in ) ; this . max = max ; } @Override public long skip ( long n ) throws IOException { return super . skip ( Math . min ( max , n ) ) ; } } public void testReadBytes ( ) throws IOException { final byte [ ] array = newPreFilledByteArray ( <int> ) ; assertEquals ( array , ByteStreams . readBytes ( new ByteArrayInputStream ( array ) , new TestByteProcessor ( ) ) ) ; } private class TestByteProcessor implements ByteProcessor < byte [ ] > { private final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; @Override public boolean processBytes ( byte [ ] buf , int off , int len ) throws IOException { out . write ( buf , off , len ) ; return true ; } @Override public byte [ ] getResult ( ) { return out . toByteArray ( ) ; } } public void testByteProcessorStopEarly ( ) throws IOException { byte [ ] array = newPreFilledByteArray ( <int> ) ; assertEquals ( ( Integer ) <int> , ByteStreams . readBytes ( new ByteArrayInputStream ( array ) , new ByteProcessor < Integer > ( ) { @Override public boolean processBytes ( byte [ ] buf , int off , int len ) { assertEquals ( copyOfRange ( buf , off , off + len ) , newPreFilledByteArray ( <int> ) ) ; return false ; } @Override public Integer getResult ( ) { return <int> ; } } ) ) ; } public void testNullOutputStream ( ) throws Exception { OutputStream nos = ByteStreams . nullOutputStream ( ) ; nos . write ( <str> ) ; String test = <str> ; nos . write ( test . getBytes ( ) ) ; nos . write ( test . getBytes ( ) , <int> , <int> ) ; assertSame ( ByteStreams . nullOutputStream ( ) , ByteStreams . nullOutputStream ( ) ) ; } public void testLimit ( ) throws Exception { byte [ ] big = newPreFilledByteArray ( <int> ) ; InputStream bin = new ByteArrayInputStream ( big ) ; InputStream lin = ByteStreams . limit ( bin , <int> ) ; lin . mark ( <int> ) ; assertEquals ( <int> , lin . available ( ) ) ; int read = lin . read ( ) ; assertEquals ( big [ <int> ] , read ) ; assertEquals ( <int> , lin . available ( ) ) ; read = lin . read ( ) ; assertEquals ( big [ <int> ] , read ) ; assertEquals ( <int> , lin . available ( ) ) ; read = lin . read ( ) ; assertEquals ( - <int> , read ) ; lin . reset ( ) ; byte [ ] small = new byte [ <int> ] ; read = lin . read ( small ) ; assertEquals ( <int> , read ) ; assertEquals ( big [ <int> ] , small [ <int> ] ) ; assertEquals ( big [ <int> ] , small [ <int> ] ) ; lin . reset ( ) ; read = lin . read ( small , <int> , <int> ) ; assertEquals ( <int> , read ) ; assertEquals ( big [ <int> ] , small [ <int> ] ) ; assertEquals ( big [ <int> ] , small [ <int> ] ) ; } public void testLimit_mark ( ) throws Exception { byte [ ] big = newPreFilledByteArray ( <int> ) ; InputStream bin = new ByteArrayInputStream ( big ) ; InputStream lin = ByteStreams . limit ( bin , <int> ) ; int read = lin . read ( ) ; assertEquals ( big [ <int> ] , read ) ; lin . mark ( <int> ) ; read = lin . read ( ) ; assertEquals ( big [ <int> ] , read ) ; read = lin . read ( ) ; assertEquals ( - <int> , read ) ; lin . reset ( ) ; read = lin . read ( ) ; assertEquals ( big [ <int> ] , read ) ; read = lin . read ( ) ; assertEquals ( - <int> , read ) ; } public void testLimit_skip ( ) throws Exception { byte [ ] big = newPreFilledByteArray ( <int> ) ; InputStream bin = new ByteArrayInputStream ( big ) ; InputStream lin = ByteStreams . limit ( bin , <int> ) ; lin . mark ( <int> ) ; assertEquals ( <int> , lin . available ( ) ) ; lin . skip ( <int> ) ; assertEquals ( <int> , lin . available ( ) ) ; lin . reset ( ) ; assertEquals ( <int> , lin . available ( ) ) ; lin . skip ( <int> ) ; assertEquals ( <int> , lin . available ( ) ) ; } public void testLimit_markNotSet ( ) { byte [ ] big = newPreFilledByteArray ( <int> ) ; InputStream bin = new ByteArrayInputStream ( big ) ; InputStream lin = ByteStreams . limit ( bin , <int> ) ; try { lin . reset ( ) ; fail ( ) ; } catch ( IOException expected ) { assertThat ( expected ) . hasMessage ( <str> ) ; } } public void testLimit_markNotSupported ( ) { InputStream lin = ByteStreams . limit ( new UnmarkableInputStream ( ) , <int> ) ; try { lin . reset ( ) ; fail ( ) ; } catch ( IOException expected ) { assertThat ( expected ) . hasMessage ( <str> ) ; } } private static class UnmarkableInputStream extends InputStream { @Override public int read ( ) throws IOException { return <int> ; } @Override public boolean markSupported ( ) { return false ; } } private static byte [ ] copyOfRange ( byte [ ] in , int from , int to ) { byte [ ] out = new byte [ to - from ] ; for ( int i = <int> ; i < to - from ; i + + ) { out [ i ] = in [ from + i ] ; } return out ; } private static void assertEquals ( byte [ ] expected , byte [ ] actual ) { assertThat ( actual ) . isEqualTo ( expected ) ; } } 
