package com . google . common . primitives ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . GwtCompatible ; import java . util . Comparator ; import javax . annotation . CheckReturnValue ; @CheckReturnValue @GwtCompatible public final class SignedBytes { private SignedBytes ( ) { } public static final byte MAX_POWER_OF_TWO = <int> < < <int> ; public static byte checkedCast ( long value ) { byte result = ( byte ) value ; if ( result ! = value ) { throw new IllegalArgumentException ( <str> + value ) ; } return result ; } public static byte saturatedCast ( long value ) { if ( value > Byte . MAX_VALUE ) { return Byte . MAX_VALUE ; } if ( value < Byte . MIN_VALUE ) { return Byte . MIN_VALUE ; } return ( byte ) value ; } public static int compare ( byte a , byte b ) { return a - b ; } public static byte min ( byte . . . array ) { checkArgument ( array . length > <int> ) ; byte min = array [ <int> ] ; for ( int i = <int> ; i < array . length ; i + + ) { if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static byte max ( byte . . . array ) { checkArgument ( array . length > <int> ) ; byte max = array [ <int> ] ; for ( int i = <int> ; i < array . length ; i + + ) { if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static String join ( String separator , byte . . . array ) { checkNotNull ( separator ) ; if ( array . length = = <int> ) { return <str> ; } StringBuilder builder = new StringBuilder ( array . length * <int> ) ; builder . append ( array [ <int> ] ) ; for ( int i = <int> ; i < array . length ; i + + ) { builder . append ( separator ) . append ( array [ i ] ) ; } return builder . toString ( ) ; } public static Comparator < byte [ ] > lexicographicalComparator ( ) { return LexicographicalComparator . INSTANCE ; } private enum LexicographicalComparator implements Comparator < byte [ ] > { INSTANCE ; @Override public int compare ( byte [ ] left , byte [ ] right ) { int minLength = Math . min ( left . length , right . length ) ; for ( int i = <int> ; i < minLength ; i + + ) { int result = SignedBytes . compare ( left [ i ] , right [ i ] ) ; if ( result ! = <int> ) { return result ; } } return left . length - right . length ; } @Override public String toString ( ) { return <str> ; } } } 
