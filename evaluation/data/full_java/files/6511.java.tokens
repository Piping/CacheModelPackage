package org . elasticsearch . index . fieldvisitor ; import org . apache . lucene . index . FieldInfo ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . internal . IdFieldMapper ; import org . elasticsearch . index . mapper . internal . TypeFieldMapper ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import java . io . IOException ; import java . util . List ; public class SingleFieldsVisitor extends FieldsVisitor { private String field ; public SingleFieldsVisitor ( String field ) { super ( false ) ; this . field = field ; } @Override public Status needsField ( FieldInfo fieldInfo ) throws IOException { if ( fieldInfo . name . equals ( field ) ) { return Status . YES ; } if ( fieldInfo . name . equals ( UidFieldMapper . NAME ) ) { if ( TypeFieldMapper . NAME . equals ( field ) | | IdFieldMapper . NAME . equals ( field ) ) { return Status . YES ; } } return Status . NO ; } public void reset ( String field ) { this . field = field ; super . reset ( ) ; } public void postProcess ( MappedFieldType fieldType ) { if ( uid ! = null ) { switch ( field ) { case UidFieldMapper . NAME : addValue ( field , uid . toString ( ) ) ; case IdFieldMapper . NAME : addValue ( field , uid . id ( ) ) ; case TypeFieldMapper . NAME : addValue ( field , uid . type ( ) ) ; } } if ( fieldsValues = = null ) { return ; } List < Object > fieldValues = fieldsValues . get ( fieldType . names ( ) . indexName ( ) ) ; if ( fieldValues = = null ) { return ; } for ( int i = <int> ; i < fieldValues . size ( ) ; i + + ) { fieldValues . set ( i , fieldType . valueForSearch ( fieldValues . get ( i ) ) ) ; } } } 
