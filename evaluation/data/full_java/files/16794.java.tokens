package com . badlogic . gdx . backends . lwjgl . audio ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import org . lwjgl . BufferUtils ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . StreamUtils ; import com . jcraft . jogg . Packet ; import com . jcraft . jogg . Page ; import com . jcraft . jogg . StreamState ; import com . jcraft . jogg . SyncState ; import com . jcraft . jorbis . Block ; import com . jcraft . jorbis . Comment ; import com . jcraft . jorbis . DspState ; import com . jcraft . jorbis . Info ; public class OggInputStream extends InputStream { private final static int BUFFER_SIZE = <int> ; private int convsize = BUFFER_SIZE * <int> ; private byte [ ] convbuffer ; private InputStream input ; private Info oggInfo = new Info ( ) ; private boolean endOfStream ; private SyncState syncState = new SyncState ( ) ; private StreamState streamState = new StreamState ( ) ; private Page page = new Page ( ) ; private Packet packet = new Packet ( ) ; private Comment comment = new Comment ( ) ; private DspState dspState = new DspState ( ) ; private Block vorbisBlock = new Block ( dspState ) ; byte [ ] buffer ; int bytes = <int> ; boolean bigEndian = ByteOrder . nativeOrder ( ) . equals ( ByteOrder . BIG_ENDIAN ) ; boolean endOfBitStream = true ; boolean inited = false ; private int readIndex ; private ByteBuffer pcmBuffer ; private int total ; public OggInputStream ( InputStream input ) { this ( input , null ) ; } OggInputStream ( InputStream input , OggInputStream previousStream ) { if ( previousStream = = null ) { convbuffer = new byte [ convsize ] ; pcmBuffer = BufferUtils . createByteBuffer ( <int> * <int> ) ; } else { convbuffer = previousStream . convbuffer ; pcmBuffer = previousStream . pcmBuffer ; } this . input = input ; try { total = input . available ( ) ; } catch ( IOException ex ) { throw new GdxRuntimeException ( ex ) ; } init ( ) ; } public int getLength ( ) { return total ; } public int getChannels ( ) { return oggInfo . channels ; } public int getSampleRate ( ) { return oggInfo . rate ; } private void init ( ) { initVorbis ( ) ; readPCM ( ) ; } public int available ( ) { return endOfStream ? <int> : <int> ; } private void initVorbis ( ) { syncState . init ( ) ; } private boolean getPageAndPacket ( ) { int index = syncState . buffer ( BUFFER_SIZE ) ; if ( index = = - <int> ) return false ; buffer = syncState . data ; if ( buffer = = null ) { endOfStream = true ; return false ; } try { bytes = input . read ( buffer , index , BUFFER_SIZE ) ; } catch ( Exception e ) { throw new GdxRuntimeException ( <str> , e ) ; } syncState . wrote ( bytes ) ; if ( syncState . pageout ( page ) ! = <int> ) { if ( bytes < BUFFER_SIZE ) return false ; throw new GdxRuntimeException ( <str> ) ; } streamState . init ( page . serialno ( ) ) ; oggInfo . init ( ) ; comment . init ( ) ; if ( streamState . pagein ( page ) < <int> ) { throw new GdxRuntimeException ( <str> ) ; } if ( streamState . packetout ( packet ) ! = <int> ) { throw new GdxRuntimeException ( <str> ) ; } if ( oggInfo . synthesis_headerin ( comment , packet ) < <int> ) { throw new GdxRuntimeException ( <str> ) ; } int i = <int> ; while ( i < <int> ) { while ( i < <int> ) { int result = syncState . pageout ( page ) ; if ( result = = <int> ) break ; if ( result = = <int> ) { streamState . pagein ( page ) ; while ( i < <int> ) { result = streamState . packetout ( packet ) ; if ( result = = <int> ) break ; if ( result = = - <int> ) { throw new GdxRuntimeException ( <str> ) ; } oggInfo . synthesis_headerin ( comment , packet ) ; i + + ; } } } index = syncState . buffer ( BUFFER_SIZE ) ; if ( index = = - <int> ) return false ; buffer = syncState . data ; try { bytes = input . read ( buffer , index , BUFFER_SIZE ) ; } catch ( Exception e ) { throw new GdxRuntimeException ( <str> , e ) ; } if ( bytes = = <int> & & i < <int> ) { throw new GdxRuntimeException ( <str> ) ; } syncState . wrote ( bytes ) ; } convsize = BUFFER_SIZE / oggInfo . channels ; dspState . synthesis_init ( oggInfo ) ; vorbisBlock . init ( dspState ) ; return true ; } private void readPCM ( ) { boolean wrote = false ; while ( true ) { if ( endOfBitStream ) { if ( ! getPageAndPacket ( ) ) { break ; } endOfBitStream = false ; } if ( ! inited ) { inited = true ; return ; } float [ ] [ ] [ ] _pcm = new float [ <int> ] [ ] [ ] ; int [ ] _index = new int [ oggInfo . channels ] ; while ( ! endOfBitStream ) { while ( ! endOfBitStream ) { int result = syncState . pageout ( page ) ; if ( result = = <int> ) { break ; } if ( result = = - <int> ) { Gdx . app . log ( <str> , <str> ) ; } else { streamState . pagein ( page ) ; while ( true ) { result = streamState . packetout ( packet ) ; if ( result = = <int> ) break ; if ( result = = - <int> ) { } else { int samples ; if ( vorbisBlock . synthesis ( packet ) = = <int> ) { dspState . synthesis_blockin ( vorbisBlock ) ; } while ( ( samples = dspState . synthesis_pcmout ( _pcm , _index ) ) > <int> ) { float [ ] [ ] pcm = _pcm [ <int> ] ; int bout = ( samples < convsize ? samples : convsize ) ; for ( int i = <int> ; i < oggInfo . channels ; i + + ) { int ptr = i * <int> ; int mono = _index [ i ] ; for ( int j = <int> ; j < bout ; j + + ) { int val = ( int ) ( pcm [ i ] [ mono + j ] * <float> ) ; if ( val > <int> ) { val = <int> ; } if ( val < - <int> ) { val = - <int> ; } if ( val < <int> ) val = val | <hex> ; if ( bigEndian ) { convbuffer [ ptr ] = ( byte ) ( val > > > <int> ) ; convbuffer [ ptr + <int> ] = ( byte ) ( val ) ; } else { convbuffer [ ptr ] = ( byte ) ( val ) ; convbuffer [ ptr + <int> ] = ( byte ) ( val > > > <int> ) ; } ptr + = <int> * ( oggInfo . channels ) ; } } int bytesToWrite = <int> * oggInfo . channels * bout ; if ( bytesToWrite > pcmBuffer . remaining ( ) ) { throw new GdxRuntimeException ( <str> + bytesToWrite + <str> + pcmBuffer . remaining ( ) ) ; } else { pcmBuffer . put ( convbuffer , <int> , bytesToWrite ) ; } wrote = true ; dspState . synthesis_read ( bout ) ; } } } if ( page . eos ( ) ! = <int> ) { endOfBitStream = true ; } if ( ( ! endOfBitStream ) & & ( wrote ) ) { return ; } } } if ( ! endOfBitStream ) { bytes = <int> ; int index = syncState . buffer ( BUFFER_SIZE ) ; if ( index > = <int> ) { buffer = syncState . data ; try { bytes = input . read ( buffer , index , BUFFER_SIZE ) ; } catch ( Exception e ) { throw new GdxRuntimeException ( <str> , e ) ; } } else { bytes = <int> ; } syncState . wrote ( bytes ) ; if ( bytes = = <int> ) { endOfBitStream = true ; } } } streamState . clear ( ) ; vorbisBlock . clear ( ) ; dspState . clear ( ) ; oggInfo . clear ( ) ; } syncState . clear ( ) ; endOfStream = true ; } public int read ( ) { if ( readIndex > = pcmBuffer . position ( ) ) { pcmBuffer . clear ( ) ; readPCM ( ) ; readIndex = <int> ; } if ( readIndex > = pcmBuffer . position ( ) ) { return - <int> ; } int value = pcmBuffer . get ( readIndex ) ; if ( value < <int> ) { value = <int> + value ; } readIndex + + ; return value ; } public boolean atEnd ( ) { return endOfStream & & ( readIndex > = pcmBuffer . position ( ) ) ; } public int read ( byte [ ] b , int off , int len ) { for ( int i = <int> ; i < len ; i + + ) { int value = read ( ) ; if ( value > = <int> ) { b [ i ] = ( byte ) value ; } else { if ( i = = <int> ) { return - <int> ; } else { return i ; } } } return len ; } public int read ( byte [ ] b ) { return read ( b , <int> , b . length ) ; } public void close ( ) { StreamUtils . closeQuietly ( input ) ; } } 
