package org . gradle . api . internal . tasks ; import groovy . lang . Closure ; import groovy . lang . GString ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . TaskInternal ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . api . internal . file . UnionFileCollection ; import org . gradle . api . internal . file . collections . DefaultConfigurableFileCollection ; import org . gradle . api . tasks . TaskInputs ; import org . gradle . internal . UncheckedException ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . Callable ; public class DefaultTaskInputs implements TaskInputs { private final DefaultConfigurableFileCollection inputFiles ; private final DefaultConfigurableFileCollection sourceFiles ; private final FileResolver resolver ; private final TaskMutator taskMutator ; private final Map < String , Object > properties = new HashMap < String , Object > ( ) ; public DefaultTaskInputs ( FileResolver resolver , TaskInternal task , TaskMutator taskMutator ) { this . resolver = resolver ; this . taskMutator = taskMutator ; inputFiles = new DefaultConfigurableFileCollection ( task + <str> , resolver , null ) ; sourceFiles = new DefaultConfigurableFileCollection ( task + <str> , resolver , null ) ; } public boolean getHasInputs ( ) { return ! inputFiles . getFrom ( ) . isEmpty ( ) | | ! properties . isEmpty ( ) | | ! sourceFiles . getFrom ( ) . isEmpty ( ) ; } public FileCollection getFiles ( ) { return new UnionFileCollection ( inputFiles , sourceFiles ) ; } public TaskInputs files ( final Object . . . paths ) { taskMutator . mutate ( <str> , new Runnable ( ) { public void run ( ) { inputFiles . from ( paths ) ; } } ) ; return this ; } public TaskInputs file ( final Object path ) { taskMutator . mutate ( <str> , new Runnable ( ) { public void run ( ) { inputFiles . from ( path ) ; } } ) ; return this ; } public TaskInputs dir ( final Object dirPath ) { taskMutator . mutate ( <str> , new Runnable ( ) { public void run ( ) { inputFiles . from ( resolver . resolveFilesAsTree ( dirPath ) ) ; } } ) ; return this ; } public boolean getHasSourceFiles ( ) { return ! sourceFiles . getFrom ( ) . isEmpty ( ) ; } public FileCollection getSourceFiles ( ) { return sourceFiles ; } public TaskInputs source ( final Object . . . paths ) { taskMutator . mutate ( <str> , new Runnable ( ) { public void run ( ) { sourceFiles . from ( paths ) ; } } ) ; return this ; } public TaskInputs source ( final Object path ) { taskMutator . mutate ( <str> , new Runnable ( ) { public void run ( ) { sourceFiles . from ( path ) ; } } ) ; return this ; } public TaskInputs sourceDir ( final Object path ) { taskMutator . mutate ( <str> , new Runnable ( ) { public void run ( ) { sourceFiles . from ( resolver . resolveFilesAsTree ( path ) ) ; } } ) ; return this ; } public Map < String , Object > getProperties ( ) { Map < String , Object > actualProperties = new HashMap < String , Object > ( ) ; for ( Map . Entry < String , Object > entry : properties . entrySet ( ) ) { Object value = prepareValue ( entry . getValue ( ) ) ; actualProperties . put ( entry . getKey ( ) , value ) ; } return actualProperties ; } private Object prepareValue ( Object value ) { while ( true ) { if ( value instanceof Callable ) { Callable callable = ( Callable ) value ; try { value = callable . call ( ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } else if ( value instanceof Closure ) { Closure closure = ( Closure ) value ; value = closure . call ( ) ; } else if ( value instanceof FileCollection ) { FileCollection fileCollection = ( FileCollection ) value ; return fileCollection . getFiles ( ) ; } else { return avoidGString ( value ) ; } } } private static Object avoidGString ( Object value ) { return ( value instanceof GString ) ? value . toString ( ) : value ; } public TaskInputs property ( final String name , final Object value ) { taskMutator . mutate ( <str> , new Runnable ( ) { public void run ( ) { properties . put ( name , value ) ; } } ) ; return this ; } public TaskInputs properties ( final Map < String , ? > newProps ) { taskMutator . mutate ( <str> , new Runnable ( ) { public void run ( ) { properties . putAll ( newProps ) ; } } ) ; return this ; } } 
