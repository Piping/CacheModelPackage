package com . badlogic . gdx . utils ; class ComparableTimSort { private static final int MIN_MERGE = <int> ; private Object [ ] a ; private static final int MIN_GALLOP = <int> ; private int minGallop = MIN_GALLOP ; private static final int INITIAL_TMP_STORAGE_LENGTH = <int> ; private Object [ ] tmp ; private int stackSize = <int> ; private final int [ ] runBase ; private final int [ ] runLen ; private static final boolean DEBUG = false ; ComparableTimSort ( ) { tmp = new Object [ INITIAL_TMP_STORAGE_LENGTH ] ; runBase = new int [ <int> ] ; runLen = new int [ <int> ] ; } public void doSort ( Object [ ] a , int lo , int hi ) { stackSize = <int> ; rangeCheck ( a . length , lo , hi ) ; int nRemaining = hi - lo ; if ( nRemaining < <int> ) return ; if ( nRemaining < MIN_MERGE ) { int initRunLen = countRunAndMakeAscending ( a , lo , hi ) ; binarySort ( a , lo , hi , lo + initRunLen ) ; return ; } this . a = a ; int minRun = minRunLength ( nRemaining ) ; do { int runLen = countRunAndMakeAscending ( a , lo , hi ) ; if ( runLen < minRun ) { int force = nRemaining < = minRun ? nRemaining : minRun ; binarySort ( a , lo , lo + force , lo + runLen ) ; runLen = force ; } pushRun ( lo , runLen ) ; mergeCollapse ( ) ; lo + = runLen ; nRemaining - = runLen ; } while ( nRemaining ! = <int> ) ; if ( DEBUG ) assert lo = = hi ; mergeForceCollapse ( ) ; if ( DEBUG ) assert stackSize = = <int> ; } private ComparableTimSort ( Object [ ] a ) { this . a = a ; int len = a . length ; Object [ ] newArray = new Object [ len < <int> * INITIAL_TMP_STORAGE_LENGTH ? len > > > <int> : INITIAL_TMP_STORAGE_LENGTH ] ; tmp = newArray ; int stackLen = ( len < <int> ? <int> : len < <int> ? <int> : len < <int> ? <int> : <int> ) ; runBase = new int [ stackLen ] ; runLen = new int [ stackLen ] ; } static void sort ( Object [ ] a ) { sort ( a , <int> , a . length ) ; } static void sort ( Object [ ] a , int lo , int hi ) { rangeCheck ( a . length , lo , hi ) ; int nRemaining = hi - lo ; if ( nRemaining < <int> ) return ; if ( nRemaining < MIN_MERGE ) { int initRunLen = countRunAndMakeAscending ( a , lo , hi ) ; binarySort ( a , lo , hi , lo + initRunLen ) ; return ; } ComparableTimSort ts = new ComparableTimSort ( a ) ; int minRun = minRunLength ( nRemaining ) ; do { int runLen = countRunAndMakeAscending ( a , lo , hi ) ; if ( runLen < minRun ) { int force = nRemaining < = minRun ? nRemaining : minRun ; binarySort ( a , lo , lo + force , lo + runLen ) ; runLen = force ; } ts . pushRun ( lo , runLen ) ; ts . mergeCollapse ( ) ; lo + = runLen ; nRemaining - = runLen ; } while ( nRemaining ! = <int> ) ; if ( DEBUG ) assert lo = = hi ; ts . mergeForceCollapse ( ) ; if ( DEBUG ) assert ts . stackSize = = <int> ; } @SuppressWarnings ( <str> ) private static void binarySort ( Object [ ] a , int lo , int hi , int start ) { if ( DEBUG ) assert lo < = start & & start < = hi ; if ( start = = lo ) start + + ; for ( ; start < hi ; start + + ) { @SuppressWarnings ( <str> ) Comparable < Object > pivot = ( Comparable ) a [ start ] ; int left = lo ; int right = start ; if ( DEBUG ) assert left < = right ; while ( left < right ) { int mid = ( left + right ) > > > <int> ; if ( pivot . compareTo ( a [ mid ] ) < <int> ) right = mid ; else left = mid + <int> ; } if ( DEBUG ) assert left = = right ; int n = start - left ; switch ( n ) { case <int> : a [ left + <int> ] = a [ left + <int> ] ; case <int> : a [ left + <int> ] = a [ left ] ; break ; default : System . arraycopy ( a , left , a , left + <int> , n ) ; } a [ left ] = pivot ; } } @SuppressWarnings ( <str> ) private static int countRunAndMakeAscending ( Object [ ] a , int lo , int hi ) { if ( DEBUG ) assert lo < hi ; int runHi = lo + <int> ; if ( runHi = = hi ) return <int> ; if ( ( ( Comparable ) a [ runHi + + ] ) . compareTo ( a [ lo ] ) < <int> ) { while ( runHi < hi & & ( ( Comparable ) a [ runHi ] ) . compareTo ( a [ runHi - <int> ] ) < <int> ) runHi + + ; reverseRange ( a , lo , runHi ) ; } else { while ( runHi < hi & & ( ( Comparable ) a [ runHi ] ) . compareTo ( a [ runHi - <int> ] ) > = <int> ) runHi + + ; } return runHi - lo ; } private static void reverseRange ( Object [ ] a , int lo , int hi ) { hi - - ; while ( lo < hi ) { Object t = a [ lo ] ; a [ lo + + ] = a [ hi ] ; a [ hi - - ] = t ; } } private static int minRunLength ( int n ) { if ( DEBUG ) assert n > = <int> ; int r = <int> ; while ( n > = MIN_MERGE ) { r | = ( n & <int> ) ; n > > = <int> ; } return n + r ; } private void pushRun ( int runBase , int runLen ) { this . runBase [ stackSize ] = runBase ; this . runLen [ stackSize ] = runLen ; stackSize + + ; } private void mergeCollapse ( ) { while ( stackSize > <int> ) { int n = stackSize - <int> ; if ( n > <int> & & runLen [ n - <int> ] < = runLen [ n ] + runLen [ n + <int> ] ) { if ( runLen [ n - <int> ] < runLen [ n + <int> ] ) n - - ; mergeAt ( n ) ; } else if ( runLen [ n ] < = runLen [ n + <int> ] ) { mergeAt ( n ) ; } else { break ; } } } private void mergeForceCollapse ( ) { while ( stackSize > <int> ) { int n = stackSize - <int> ; if ( n > <int> & & runLen [ n - <int> ] < runLen [ n + <int> ] ) n - - ; mergeAt ( n ) ; } } @SuppressWarnings ( <str> ) private void mergeAt ( int i ) { if ( DEBUG ) assert stackSize > = <int> ; if ( DEBUG ) assert i > = <int> ; if ( DEBUG ) assert i = = stackSize - <int> | | i = = stackSize - <int> ; int base1 = runBase [ i ] ; int len1 = runLen [ i ] ; int base2 = runBase [ i + <int> ] ; int len2 = runLen [ i + <int> ] ; if ( DEBUG ) assert len1 > <int> & & len2 > <int> ; if ( DEBUG ) assert base1 + len1 = = base2 ; runLen [ i ] = len1 + len2 ; if ( i = = stackSize - <int> ) { runBase [ i + <int> ] = runBase [ i + <int> ] ; runLen [ i + <int> ] = runLen [ i + <int> ] ; } stackSize - - ; int k = gallopRight ( ( Comparable < Object > ) a [ base2 ] , a , base1 , len1 , <int> ) ; if ( DEBUG ) assert k > = <int> ; base1 + = k ; len1 - = k ; if ( len1 = = <int> ) return ; len2 = gallopLeft ( ( Comparable < Object > ) a [ base1 + len1 - <int> ] , a , base2 , len2 , len2 - <int> ) ; if ( DEBUG ) assert len2 > = <int> ; if ( len2 = = <int> ) return ; if ( len1 < = len2 ) mergeLo ( base1 , len1 , base2 , len2 ) ; else mergeHi ( base1 , len1 , base2 , len2 ) ; } private static int gallopLeft ( Comparable < Object > key , Object [ ] a , int base , int len , int hint ) { if ( DEBUG ) assert len > <int> & & hint > = <int> & & hint < len ; int lastOfs = <int> ; int ofs = <int> ; if ( key . compareTo ( a [ base + hint ] ) > <int> ) { int maxOfs = len - hint ; while ( ofs < maxOfs & & key . compareTo ( a [ base + hint + ofs ] ) > <int> ) { lastOfs = ofs ; ofs = ( ofs < < <int> ) + <int> ; if ( ofs < = <int> ) ofs = maxOfs ; } if ( ofs > maxOfs ) ofs = maxOfs ; lastOfs + = hint ; ofs + = hint ; } else { final int maxOfs = hint + <int> ; while ( ofs < maxOfs & & key . compareTo ( a [ base + hint - ofs ] ) < = <int> ) { lastOfs = ofs ; ofs = ( ofs < < <int> ) + <int> ; if ( ofs < = <int> ) ofs = maxOfs ; } if ( ofs > maxOfs ) ofs = maxOfs ; int tmp = lastOfs ; lastOfs = hint - ofs ; ofs = hint - tmp ; } if ( DEBUG ) assert - <int> < = lastOfs & & lastOfs < ofs & & ofs < = len ; lastOfs + + ; while ( lastOfs < ofs ) { int m = lastOfs + ( ( ofs - lastOfs ) > > > <int> ) ; if ( key . compareTo ( a [ base + m ] ) > <int> ) lastOfs = m + <int> ; else ofs = m ; } if ( DEBUG ) assert lastOfs = = ofs ; return ofs ; } private static int gallopRight ( Comparable < Object > key , Object [ ] a , int base , int len , int hint ) { if ( DEBUG ) assert len > <int> & & hint > = <int> & & hint < len ; int ofs = <int> ; int lastOfs = <int> ; if ( key . compareTo ( a [ base + hint ] ) < <int> ) { int maxOfs = hint + <int> ; while ( ofs < maxOfs & & key . compareTo ( a [ base + hint - ofs ] ) < <int> ) { lastOfs = ofs ; ofs = ( ofs < < <int> ) + <int> ; if ( ofs < = <int> ) ofs = maxOfs ; } if ( ofs > maxOfs ) ofs = maxOfs ; int tmp = lastOfs ; lastOfs = hint - ofs ; ofs = hint - tmp ; } else { int maxOfs = len - hint ; while ( ofs < maxOfs & & key . compareTo ( a [ base + hint + ofs ] ) > = <int> ) { lastOfs = ofs ; ofs = ( ofs < < <int> ) + <int> ; if ( ofs < = <int> ) ofs = maxOfs ; } if ( ofs > maxOfs ) ofs = maxOfs ; lastOfs + = hint ; ofs + = hint ; } if ( DEBUG ) assert - <int> < = lastOfs & & lastOfs < ofs & & ofs < = len ; lastOfs + + ; while ( lastOfs < ofs ) { int m = lastOfs + ( ( ofs - lastOfs ) > > > <int> ) ; if ( key . compareTo ( a [ base + m ] ) < <int> ) ofs = m ; else lastOfs = m + <int> ; } if ( DEBUG ) assert lastOfs = = ofs ; return ofs ; } @SuppressWarnings ( <str> ) private void mergeLo ( int base1 , int len1 , int base2 , int len2 ) { if ( DEBUG ) assert len1 > <int> & & len2 > <int> & & base1 + len1 = = base2 ; Object [ ] a = this . a ; Object [ ] tmp = ensureCapacity ( len1 ) ; System . arraycopy ( a , base1 , tmp , <int> , len1 ) ; int cursor1 = <int> ; int cursor2 = base2 ; int dest = base1 ; a [ dest + + ] = a [ cursor2 + + ] ; if ( - - len2 = = <int> ) { System . arraycopy ( tmp , cursor1 , a , dest , len1 ) ; return ; } if ( len1 = = <int> ) { System . arraycopy ( a , cursor2 , a , dest , len2 ) ; a [ dest + len2 ] = tmp [ cursor1 ] ; return ; } int minGallop = this . minGallop ; outer : while ( true ) { int count1 = <int> ; int count2 = <int> ; do { if ( DEBUG ) assert len1 > <int> & & len2 > <int> ; if ( ( ( Comparable ) a [ cursor2 ] ) . compareTo ( tmp [ cursor1 ] ) < <int> ) { a [ dest + + ] = a [ cursor2 + + ] ; count2 + + ; count1 = <int> ; if ( - - len2 = = <int> ) break outer ; } else { a [ dest + + ] = tmp [ cursor1 + + ] ; count1 + + ; count2 = <int> ; if ( - - len1 = = <int> ) break outer ; } } while ( ( count1 | count2 ) < minGallop ) ; do { if ( DEBUG ) assert len1 > <int> & & len2 > <int> ; count1 = gallopRight ( ( Comparable ) a [ cursor2 ] , tmp , cursor1 , len1 , <int> ) ; if ( count1 ! = <int> ) { System . arraycopy ( tmp , cursor1 , a , dest , count1 ) ; dest + = count1 ; cursor1 + = count1 ; len1 - = count1 ; if ( len1 < = <int> ) break outer ; } a [ dest + + ] = a [ cursor2 + + ] ; if ( - - len2 = = <int> ) break outer ; count2 = gallopLeft ( ( Comparable ) tmp [ cursor1 ] , a , cursor2 , len2 , <int> ) ; if ( count2 ! = <int> ) { System . arraycopy ( a , cursor2 , a , dest , count2 ) ; dest + = count2 ; cursor2 + = count2 ; len2 - = count2 ; if ( len2 = = <int> ) break outer ; } a [ dest + + ] = tmp [ cursor1 + + ] ; if ( - - len1 = = <int> ) break outer ; minGallop - - ; } while ( count1 > = MIN_GALLOP | count2 > = MIN_GALLOP ) ; if ( minGallop < <int> ) minGallop = <int> ; minGallop + = <int> ; } this . minGallop = minGallop < <int> ? <int> : minGallop ; if ( len1 = = <int> ) { if ( DEBUG ) assert len2 > <int> ; System . arraycopy ( a , cursor2 , a , dest , len2 ) ; a [ dest + len2 ] = tmp [ cursor1 ] ; } else if ( len1 = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } else { if ( DEBUG ) assert len2 = = <int> ; if ( DEBUG ) assert len1 > <int> ; System . arraycopy ( tmp , cursor1 , a , dest , len1 ) ; } } @SuppressWarnings ( <str> ) private void mergeHi ( int base1 , int len1 , int base2 , int len2 ) { if ( DEBUG ) assert len1 > <int> & & len2 > <int> & & base1 + len1 = = base2 ; Object [ ] a = this . a ; Object [ ] tmp = ensureCapacity ( len2 ) ; System . arraycopy ( a , base2 , tmp , <int> , len2 ) ; int cursor1 = base1 + len1 - <int> ; int cursor2 = len2 - <int> ; int dest = base2 + len2 - <int> ; a [ dest - - ] = a [ cursor1 - - ] ; if ( - - len1 = = <int> ) { System . arraycopy ( tmp , <int> , a , dest - ( len2 - <int> ) , len2 ) ; return ; } if ( len2 = = <int> ) { dest - = len1 ; cursor1 - = len1 ; System . arraycopy ( a , cursor1 + <int> , a , dest + <int> , len1 ) ; a [ dest ] = tmp [ cursor2 ] ; return ; } int minGallop = this . minGallop ; outer : while ( true ) { int count1 = <int> ; int count2 = <int> ; do { if ( DEBUG ) assert len1 > <int> & & len2 > <int> ; if ( ( ( Comparable ) tmp [ cursor2 ] ) . compareTo ( a [ cursor1 ] ) < <int> ) { a [ dest - - ] = a [ cursor1 - - ] ; count1 + + ; count2 = <int> ; if ( - - len1 = = <int> ) break outer ; } else { a [ dest - - ] = tmp [ cursor2 - - ] ; count2 + + ; count1 = <int> ; if ( - - len2 = = <int> ) break outer ; } } while ( ( count1 | count2 ) < minGallop ) ; do { if ( DEBUG ) assert len1 > <int> & & len2 > <int> ; count1 = len1 - gallopRight ( ( Comparable ) tmp [ cursor2 ] , a , base1 , len1 , len1 - <int> ) ; if ( count1 ! = <int> ) { dest - = count1 ; cursor1 - = count1 ; len1 - = count1 ; System . arraycopy ( a , cursor1 + <int> , a , dest + <int> , count1 ) ; if ( len1 = = <int> ) break outer ; } a [ dest - - ] = tmp [ cursor2 - - ] ; if ( - - len2 = = <int> ) break outer ; count2 = len2 - gallopLeft ( ( Comparable ) a [ cursor1 ] , tmp , <int> , len2 , len2 - <int> ) ; if ( count2 ! = <int> ) { dest - = count2 ; cursor2 - = count2 ; len2 - = count2 ; System . arraycopy ( tmp , cursor2 + <int> , a , dest + <int> , count2 ) ; if ( len2 < = <int> ) break outer ; } a [ dest - - ] = a [ cursor1 - - ] ; if ( - - len1 = = <int> ) break outer ; minGallop - - ; } while ( count1 > = MIN_GALLOP | count2 > = MIN_GALLOP ) ; if ( minGallop < <int> ) minGallop = <int> ; minGallop + = <int> ; } this . minGallop = minGallop < <int> ? <int> : minGallop ; if ( len2 = = <int> ) { if ( DEBUG ) assert len1 > <int> ; dest - = len1 ; cursor1 - = len1 ; System . arraycopy ( a , cursor1 + <int> , a , dest + <int> , len1 ) ; a [ dest ] = tmp [ cursor2 ] ; } else if ( len2 = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } else { if ( DEBUG ) assert len1 = = <int> ; if ( DEBUG ) assert len2 > <int> ; System . arraycopy ( tmp , <int> , a , dest - ( len2 - <int> ) , len2 ) ; } } private Object [ ] ensureCapacity ( int minCapacity ) { if ( tmp . length < minCapacity ) { int newSize = minCapacity ; newSize | = newSize > > <int> ; newSize | = newSize > > <int> ; newSize | = newSize > > <int> ; newSize | = newSize > > <int> ; newSize | = newSize > > <int> ; newSize + + ; if ( newSize < <int> ) newSize = minCapacity ; else newSize = Math . min ( newSize , a . length > > > <int> ) ; Object [ ] newArray = new Object [ newSize ] ; tmp = newArray ; } return tmp ; } private static void rangeCheck ( int arrayLen , int fromIndex , int toIndex ) { if ( fromIndex > toIndex ) throw new IllegalArgumentException ( <str> + fromIndex + <str> + toIndex + <str> ) ; if ( fromIndex < <int> ) throw new ArrayIndexOutOfBoundsException ( fromIndex ) ; if ( toIndex > arrayLen ) throw new ArrayIndexOutOfBoundsException ( toIndex ) ; } } 
