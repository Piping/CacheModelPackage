package com . badlogic . gdx . graphics . g2d . freetype ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Blending ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . BitmapFont . BitmapFontData ; import com . badlogic . gdx . graphics . g2d . BitmapFont . Glyph ; import com . badlogic . gdx . graphics . g2d . GlyphLayout . GlyphRun ; import com . badlogic . gdx . graphics . g2d . PixmapPacker ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . g2d . freetype . FreeType . Bitmap ; import com . badlogic . gdx . graphics . g2d . freetype . FreeType . Face ; import com . badlogic . gdx . graphics . g2d . freetype . FreeType . GlyphMetrics ; import com . badlogic . gdx . graphics . g2d . freetype . FreeType . GlyphSlot ; import com . badlogic . gdx . graphics . g2d . freetype . FreeType . Library ; import com . badlogic . gdx . graphics . g2d . freetype . FreeType . SizeMetrics ; import com . badlogic . gdx . graphics . g2d . freetype . FreeType . Stroker ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . BufferUtils ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . StreamUtils ; public class FreeTypeFontGenerator implements Disposable { static public final String DEFAULT_CHARS = <str> ; static public final int NO_MAXIMUM = - <int> ; static private int maxTextureSize = <int> ; final Library library ; final Face face ; final String name ; boolean bitmapped = false ; private int pixelWidth , pixelHeight ; public FreeTypeFontGenerator ( FileHandle font ) { name = font . pathWithoutExtension ( ) ; int fileSize = ( int ) font . length ( ) ; library = FreeType . initFreeType ( ) ; if ( library = = null ) throw new GdxRuntimeException ( <str> ) ; ByteBuffer buffer ; InputStream input = font . read ( ) ; try { if ( fileSize = = <int> ) { byte [ ] data = StreamUtils . copyStreamToByteArray ( input , fileSize > <int> ? ( int ) ( fileSize * <float> ) : <int> * <int> ) ; buffer = BufferUtils . newUnsafeByteBuffer ( data . length ) ; BufferUtils . copy ( data , <int> , buffer , data . length ) ; } else { buffer = BufferUtils . newUnsafeByteBuffer ( fileSize ) ; StreamUtils . copyStream ( input , buffer ) ; } } catch ( IOException ex ) { throw new GdxRuntimeException ( ex ) ; } finally { StreamUtils . closeQuietly ( input ) ; } face = library . newMemoryFace ( buffer , <int> ) ; if ( face = = null ) throw new GdxRuntimeException ( <str> + font ) ; if ( checkForBitmapFont ( ) ) return ; setPixelSizes ( <int> , <int> ) ; } private boolean checkForBitmapFont ( ) { if ( ( ( face . getFaceFlags ( ) & FreeType . FT_FACE_FLAG_FIXED_SIZES ) = = FreeType . FT_FACE_FLAG_FIXED_SIZES ) & & ( ( face . getFaceFlags ( ) & FreeType . FT_FACE_FLAG_HORIZONTAL ) = = FreeType . FT_FACE_FLAG_HORIZONTAL ) ) { if ( face . loadChar ( <int> , FreeType . FT_LOAD_DEFAULT ) ) { GlyphSlot slot = face . getGlyph ( ) ; if ( slot . getFormat ( ) = = <int> ) { bitmapped = true ; } } } return bitmapped ; } public BitmapFont generateFont ( FreeTypeFontParameter parameter ) { return generateFont ( parameter , new FreeTypeBitmapFontData ( ) ) ; } public BitmapFont generateFont ( FreeTypeFontParameter parameter , FreeTypeBitmapFontData data ) { generateData ( parameter , data ) ; if ( data . regions = = null & & parameter . packer ! = null ) { data . regions = new Array ( ) ; parameter . packer . updateTextureRegions ( data . regions , parameter . minFilter , parameter . magFilter , parameter . genMipMaps ) ; } BitmapFont font = new BitmapFont ( data , data . regions , true ) ; font . setOwnsTexture ( parameter . packer = = null ) ; return font ; } public int scaleForPixelHeight ( int height ) { setPixelSizes ( <int> , height ) ; SizeMetrics fontMetrics = face . getSize ( ) . getMetrics ( ) ; int ascent = FreeType . toInt ( fontMetrics . getAscender ( ) ) ; int descent = FreeType . toInt ( fontMetrics . getDescender ( ) ) ; return height * height / ( ascent - descent ) ; } public int scaleForPixelWidth ( int width , int numChars ) { SizeMetrics fontMetrics = face . getSize ( ) . getMetrics ( ) ; int advance = FreeType . toInt ( fontMetrics . getMaxAdvance ( ) ) ; int ascent = FreeType . toInt ( fontMetrics . getAscender ( ) ) ; int descent = FreeType . toInt ( fontMetrics . getDescender ( ) ) ; int unscaledHeight = ascent - descent ; int height = unscaledHeight * width / ( advance * numChars ) ; setPixelSizes ( <int> , height ) ; return height ; } public int scaleToFitSquare ( int width , int height , int numChars ) { return Math . min ( scaleForPixelHeight ( height ) , scaleForPixelWidth ( width , numChars ) ) ; } public class GlyphAndBitmap { public Glyph glyph ; public Bitmap bitmap ; } public GlyphAndBitmap generateGlyphAndBitmap ( int c , int size , boolean flip ) { setPixelSizes ( <int> , size ) ; SizeMetrics fontMetrics = face . getSize ( ) . getMetrics ( ) ; int baseline = FreeType . toInt ( fontMetrics . getAscender ( ) ) ; if ( face . getCharIndex ( c ) = = <int> ) { return null ; } if ( ! face . loadChar ( c , FreeType . FT_LOAD_DEFAULT ) ) { throw new GdxRuntimeException ( <str> ) ; } GlyphSlot slot = face . getGlyph ( ) ; Bitmap bitmap ; if ( bitmapped ) { bitmap = slot . getBitmap ( ) ; } else if ( ! slot . renderGlyph ( FreeType . FT_RENDER_MODE_NORMAL ) ) { bitmap = null ; } else { bitmap = slot . getBitmap ( ) ; } GlyphMetrics metrics = slot . getMetrics ( ) ; Glyph glyph = new Glyph ( ) ; if ( bitmap ! = null ) { glyph . width = bitmap . getWidth ( ) ; glyph . height = bitmap . getRows ( ) ; } else { glyph . width = <int> ; glyph . height = <int> ; } glyph . xoffset = slot . getBitmapLeft ( ) ; glyph . yoffset = flip ? - slot . getBitmapTop ( ) + baseline : - ( glyph . height - slot . getBitmapTop ( ) ) - baseline ; glyph . xadvance = FreeType . toInt ( metrics . getHoriAdvance ( ) ) ; glyph . srcX = <int> ; glyph . srcY = <int> ; glyph . id = c ; GlyphAndBitmap result = new GlyphAndBitmap ( ) ; result . glyph = glyph ; result . bitmap = bitmap ; return result ; } public FreeTypeBitmapFontData generateData ( int size ) { FreeTypeFontParameter parameter = new FreeTypeFontParameter ( ) ; parameter . size = size ; return generateData ( parameter ) ; } public FreeTypeBitmapFontData generateData ( FreeTypeFontParameter parameter ) { return generateData ( parameter , new FreeTypeBitmapFontData ( ) ) ; } void setPixelSizes ( int pixelWidth , int pixelHeight ) { this . pixelWidth = pixelWidth ; this . pixelHeight = pixelHeight ; if ( ! bitmapped & & ! face . setPixelSizes ( pixelWidth , pixelHeight ) ) throw new GdxRuntimeException ( <str> ) ; } public FreeTypeBitmapFontData generateData ( FreeTypeFontParameter parameter , FreeTypeBitmapFontData data ) { parameter = parameter = = null ? new FreeTypeFontParameter ( ) : parameter ; String characters = parameter . characters ; int charactersLength = characters . length ( ) ; boolean incremental = parameter . incremental ; setPixelSizes ( <int> , parameter . size ) ; SizeMetrics fontMetrics = face . getSize ( ) . getMetrics ( ) ; data . flipped = parameter . flip ; data . ascent = FreeType . toInt ( fontMetrics . getAscender ( ) ) ; data . descent = FreeType . toInt ( fontMetrics . getDescender ( ) ) ; data . lineHeight = FreeType . toInt ( fontMetrics . getHeight ( ) ) ; float baseLine = data . ascent ; if ( bitmapped & & ( data . lineHeight = = <int> ) ) { for ( int c = <int> ; c < ( <int> + face . getNumGlyphs ( ) ) ; c + + ) { if ( face . loadChar ( c , FreeType . FT_LOAD_DEFAULT ) ) { int lh = FreeType . toInt ( face . getGlyph ( ) . getMetrics ( ) . getHeight ( ) ) ; data . lineHeight = ( lh > data . lineHeight ) ? lh : data . lineHeight ; } } } if ( face . loadChar ( <str> , FreeType . FT_LOAD_DEFAULT ) | | face . loadChar ( <str> , FreeType . FT_LOAD_DEFAULT ) ) { data . spaceWidth = FreeType . toInt ( face . getGlyph ( ) . getMetrics ( ) . getHoriAdvance ( ) ) ; } else { data . spaceWidth = face . getMaxAdvanceWidth ( ) ; } for ( char xChar : data . xChars ) { if ( ! face . loadChar ( xChar , FreeType . FT_LOAD_DEFAULT ) ) continue ; data . xHeight = FreeType . toInt ( face . getGlyph ( ) . getMetrics ( ) . getHeight ( ) ) ; break ; } if ( data . xHeight = = <int> ) throw new GdxRuntimeException ( <str> ) ; for ( char capChar : data . capChars ) { if ( ! face . loadChar ( capChar , FreeType . FT_LOAD_DEFAULT ) ) continue ; data . capHeight = FreeType . toInt ( face . getGlyph ( ) . getMetrics ( ) . getHeight ( ) ) ; break ; } if ( ! bitmapped & & data . capHeight = = <int> ) throw new GdxRuntimeException ( <str> ) ; data . ascent = data . ascent - data . capHeight ; data . down = - data . lineHeight ; if ( parameter . flip ) { data . ascent = - data . ascent ; data . down = - data . down ; } boolean ownsAtlas = false ; PixmapPacker packer = parameter . packer ; if ( packer = = null ) { int size ; if ( incremental ) size = maxTextureSize ; else { int maxGlyphHeight = ( int ) Math . ceil ( data . lineHeight ) ; size = MathUtils . nextPowerOfTwo ( ( int ) Math . sqrt ( maxGlyphHeight * maxGlyphHeight * charactersLength ) ) ; if ( maxTextureSize > <int> ) size = Math . min ( size , maxTextureSize ) ; } ownsAtlas = true ; packer = new PixmapPacker ( size , size , Format . RGBA8888 , <int> , false ) ; } Stroker stroker = null ; if ( parameter . borderWidth > <int> ) { stroker = library . createStroker ( ) ; stroker . set ( ( int ) ( parameter . borderWidth * <int> f ) , parameter . borderStraight ? FreeType . FT_STROKER_LINECAP_BUTT : FreeType . FT_STROKER_LINECAP_ROUND , parameter . borderStraight ? FreeType . FT_STROKER_LINEJOIN_MITER_FIXED : FreeType . FT_STROKER_LINEJOIN_ROUND , <int> ) ; } if ( incremental ) { data . generator = this ; data . parameter = parameter ; data . stroker = stroker ; data . packer = packer ; data . glyphs = new Array ( charactersLength + <int> ) ; } for ( int i = <int> ; i < charactersLength ; i + + ) { char c = characters . charAt ( i ) ; Glyph glyph = createGlyph ( c , data , parameter , stroker , baseLine , packer ) ; if ( glyph ! = null ) { data . setGlyph ( c , glyph ) ; if ( incremental ) data . glyphs . add ( glyph ) ; } } if ( stroker ! = null & & ! incremental ) stroker . dispose ( ) ; if ( parameter . kerning ) { for ( int i = <int> ; i < charactersLength ; i + + ) { char firstChar = characters . charAt ( i ) ; Glyph first = data . getGlyph ( firstChar ) ; if ( first = = null ) continue ; int firstIndex = face . getCharIndex ( firstChar ) ; for ( int j = i ; j < charactersLength ; j + + ) { char secondChar = characters . charAt ( j ) ; Glyph second = data . getGlyph ( secondChar ) ; if ( second = = null ) continue ; int secondIndex = face . getCharIndex ( secondChar ) ; int kerning = face . getKerning ( firstIndex , secondIndex , <int> ) ; if ( kerning ! = <int> ) first . setKerning ( secondChar , FreeType . toInt ( kerning ) ) ; kerning = face . getKerning ( secondIndex , firstIndex , <int> ) ; if ( kerning ! = <int> ) second . setKerning ( firstChar , FreeType . toInt ( kerning ) ) ; } } } if ( ownsAtlas ) { data . regions = new Array ( ) ; packer . updateTextureRegions ( data . regions , parameter . minFilter , parameter . magFilter , parameter . genMipMaps ) ; } Glyph spaceGlyph = data . getGlyph ( <str> ) ; if ( spaceGlyph = = null ) { spaceGlyph = new Glyph ( ) ; spaceGlyph . xadvance = ( int ) data . spaceWidth ; spaceGlyph . id = ( int ) <str> ; data . setGlyph ( <str> , spaceGlyph ) ; } if ( spaceGlyph . width = = <int> ) spaceGlyph . width = ( int ) ( spaceGlyph . xadvance + data . padRight ) ; return data ; } Glyph createGlyph ( char c , FreeTypeBitmapFontData data , FreeTypeFontParameter parameter , Stroker stroker , float baseLine , PixmapPacker packer ) { boolean missing = face . getCharIndex ( c ) = = <int> ; if ( missing ) return null ; if ( ! face . loadChar ( c , FreeType . FT_LOAD_DEFAULT ) ) { Gdx . app . log ( <str> , <str> + c ) ; return null ; } GlyphSlot slot = face . getGlyph ( ) ; FreeType . Glyph mainGlyph = slot . getGlyph ( ) ; try { mainGlyph . toBitmap ( FreeType . FT_RENDER_MODE_NORMAL ) ; } catch ( GdxRuntimeException e ) { mainGlyph . dispose ( ) ; Gdx . app . log ( <str> , <str> + c ) ; return null ; } Bitmap mainBitmap = mainGlyph . getBitmap ( ) ; if ( mainBitmap . getWidth ( ) = = <int> | | mainBitmap . getRows ( ) = = <int> ) return null ; Pixmap mainPixmap = mainBitmap . getPixmap ( Format . RGBA8888 , parameter . color , parameter . gamma ) ; if ( parameter . borderWidth > <int> ) { FreeType . Glyph borderGlyph = slot . getGlyph ( ) ; borderGlyph . strokeBorder ( stroker , false ) ; borderGlyph . toBitmap ( FreeType . FT_RENDER_MODE_NORMAL ) ; Bitmap borderBitmap = borderGlyph . getBitmap ( ) ; Pixmap borderPixmap = borderBitmap . getPixmap ( Format . RGBA8888 , parameter . borderColor , parameter . borderGamma ) ; for ( int i = <int> , n = parameter . renderCount ; i < n ; i + + ) { borderPixmap . drawPixmap ( mainPixmap , mainGlyph . getLeft ( ) - borderGlyph . getLeft ( ) , - ( mainGlyph . getTop ( ) - borderGlyph . getTop ( ) ) ) ; } mainPixmap . dispose ( ) ; mainGlyph . dispose ( ) ; mainPixmap = borderPixmap ; mainGlyph = borderGlyph ; } if ( parameter . shadowOffsetX ! = <int> | | parameter . shadowOffsetY ! = <int> ) { float a = parameter . shadowColor . a ; parameter . shadowColor . a = <int> ; Pixmap shadowPixmapSrc = mainBitmap . getPixmap ( Format . RGBA8888 , parameter . shadowColor , parameter . shadowGamma ) ; parameter . shadowColor . a = a ; int w = shadowPixmapSrc . getWidth ( ) + Math . abs ( parameter . shadowOffsetX ) ; int h = shadowPixmapSrc . getHeight ( ) + Math . abs ( parameter . shadowOffsetY ) ; Pixmap shadowPixmap = new Pixmap ( w , h , Format . RGBA8888 ) ; Blending blending = Pixmap . getBlending ( ) ; Pixmap . setBlending ( Blending . None ) ; shadowPixmap . drawPixmap ( shadowPixmapSrc , Math . max ( parameter . shadowOffsetX , <int> ) , Math . max ( parameter . shadowOffsetY , <int> ) ) ; Pixmap . setBlending ( blending ) ; for ( int i = <int> , n = parameter . shadowRenderCount - <int> ; i < n ; i + + ) shadowPixmap . drawPixmap ( shadowPixmap , <int> , <int> ) ; ByteBuffer pixels = shadowPixmap . getPixels ( ) ; for ( int y = <int> , w4 = w * <int> ; y < h ; y + + ) for ( int x = y * w4 + <int> , n = x + w4 ; x < n ; x + = <int> ) pixels . put ( x , ( byte ) ( ( pixels . get ( x ) & <hex> ) * a ) ) ; for ( int i = <int> , n = parameter . renderCount ; i < n ; i + + ) shadowPixmap . drawPixmap ( mainPixmap , Math . max ( - parameter . shadowOffsetX , <int> ) , Math . max ( - parameter . shadowOffsetY , <int> ) ) ; mainPixmap . dispose ( ) ; mainPixmap = shadowPixmap ; } else if ( parameter . borderWidth = = <int> ) { for ( int i = <int> , n = parameter . renderCount - <int> ; i < n ; i + + ) mainPixmap . drawPixmap ( mainPixmap , <int> , <int> ) ; } GlyphMetrics metrics = slot . getMetrics ( ) ; Glyph glyph = new Glyph ( ) ; glyph . id = c ; glyph . width = mainPixmap . getWidth ( ) ; glyph . height = mainPixmap . getHeight ( ) ; glyph . xoffset = mainGlyph . getLeft ( ) ; glyph . yoffset = parameter . flip ? - mainGlyph . getTop ( ) + ( int ) baseLine : - ( glyph . height - mainGlyph . getTop ( ) ) - ( int ) baseLine ; glyph . xadvance = FreeType . toInt ( metrics . getHoriAdvance ( ) ) + ( int ) parameter . borderWidth ; if ( bitmapped ) { mainPixmap . setColor ( Color . CLEAR ) ; mainPixmap . fill ( ) ; ByteBuffer buf = mainBitmap . getBuffer ( ) ; int whiteIntBits = Color . WHITE . toIntBits ( ) ; int clearIntBits = Color . CLEAR . toIntBits ( ) ; for ( int h = <int> ; h < glyph . height ; h + + ) { int idx = h * mainBitmap . getPitch ( ) ; for ( int w = <int> ; w < ( glyph . width + glyph . xoffset ) ; w + + ) { int bit = ( buf . get ( idx + ( w / <int> ) ) > > > ( <int> - ( w % <int> ) ) ) & <int> ; mainPixmap . drawPixel ( w , h , ( ( bit = = <int> ) ? whiteIntBits : clearIntBits ) ) ; } } } Rectangle rect = packer . pack ( mainPixmap ) ; glyph . page = packer . getPages ( ) . size - <int> ; glyph . srcX = ( int ) rect . x ; glyph . srcY = ( int ) rect . y ; if ( parameter . incremental & & data . regions ! = null & & data . regions . size < = glyph . page ) packer . updateTextureRegions ( data . regions , parameter . minFilter , parameter . magFilter , parameter . genMipMaps ) ; mainPixmap . dispose ( ) ; mainGlyph . dispose ( ) ; return glyph ; } @Override public void dispose ( ) { face . dispose ( ) ; library . dispose ( ) ; } public static void setMaxTextureSize ( int texSize ) { maxTextureSize = texSize ; } public static int getMaxTextureSize ( ) { return maxTextureSize ; } static public class FreeTypeBitmapFontData extends BitmapFontData implements Disposable { Array < TextureRegion > regions ; FreeTypeFontGenerator generator ; FreeTypeFontParameter parameter ; Stroker stroker ; PixmapPacker packer ; Array < Glyph > glyphs ; private boolean dirty ; @Override public Glyph getGlyph ( char ch ) { Glyph glyph = super . getGlyph ( ch ) ; if ( glyph = = null & & generator ! = null ) { generator . setPixelSizes ( <int> , parameter . size ) ; glyph = generator . createGlyph ( ch , this , parameter , stroker , ( ascent + capHeight ) / scaleY , packer ) ; if ( glyph = = null ) return missingGlyph ; setGlyphRegion ( glyph , regions . get ( glyph . page ) ) ; setGlyph ( ch , glyph ) ; glyphs . add ( glyph ) ; dirty = true ; if ( parameter . kerning ) { Face face = generator . face ; int glyphIndex = face . getCharIndex ( ch ) ; for ( int i = <int> , n = glyphs . size ; i < n ; i + + ) { Glyph other = glyphs . get ( i ) ; int otherIndex = face . getCharIndex ( other . id ) ; int kerning = face . getKerning ( glyphIndex , otherIndex , <int> ) ; if ( kerning ! = <int> ) glyph . setKerning ( other . id , FreeType . toInt ( kerning ) ) ; kerning = face . getKerning ( otherIndex , glyphIndex , <int> ) ; if ( kerning ! = <int> ) other . setKerning ( ch , FreeType . toInt ( kerning ) ) ; } } } return glyph ; } public void getGlyphs ( GlyphRun run , CharSequence str , int start , int end , boolean tightBounds ) { if ( packer ! = null ) packer . setPackToTexture ( true ) ; super . getGlyphs ( run , str , start , end , tightBounds ) ; if ( dirty ) { dirty = false ; packer . updateTextureRegions ( regions , parameter . minFilter , parameter . magFilter , parameter . genMipMaps ) ; } } @Override public void dispose ( ) { if ( stroker ! = null ) stroker . dispose ( ) ; if ( packer ! = null ) packer . dispose ( ) ; } } public static class FreeTypeFontParameter { public int size = <int> ; public Color color = Color . WHITE ; public float gamma = <float> ; public int renderCount = <int> ; public float borderWidth = <int> ; public Color borderColor = Color . BLACK ; public boolean borderStraight = false ; public float borderGamma = <float> ; public int shadowOffsetX = <int> ; public int shadowOffsetY = <int> ; public int shadowRenderCount = <int> ; public Color shadowColor = new Color ( <int> , <int> , <int> , <float> ) ; public float shadowGamma = <float> ; public String characters = DEFAULT_CHARS ; public boolean kerning = true ; public PixmapPacker packer = null ; public boolean flip = false ; public boolean genMipMaps = false ; public TextureFilter minFilter = TextureFilter . Nearest ; public TextureFilter magFilter = TextureFilter . Nearest ; public boolean incremental ; } } 
