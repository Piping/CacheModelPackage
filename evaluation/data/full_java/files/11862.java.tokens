package org . gradle . cache . internal . btree ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class FreeListBlockStore implements BlockStore { private final BlockStore store ; private final BlockStore freeListStore ; private final int maxBlockEntries ; private FreeListBlock freeListBlock ; public FreeListBlockStore ( BlockStore store , int maxBlockEntries ) { this . store = store ; freeListStore = this ; this . maxBlockEntries = maxBlockEntries ; } public void open ( final Runnable initAction , final Factory factory ) { Runnable freeListInitAction = new Runnable ( ) { public void run ( ) { freeListBlock = new FreeListBlock ( ) ; store . write ( freeListBlock ) ; store . flush ( ) ; initAction . run ( ) ; } } ; Factory freeListFactory = new Factory ( ) { public Object create ( Class < ? extends BlockPayload > type ) { if ( type = = FreeListBlock . class ) { return new FreeListBlock ( ) ; } return factory . create ( type ) ; } } ; store . open ( freeListInitAction , freeListFactory ) ; freeListBlock = store . readFirst ( FreeListBlock . class ) ; } public void close ( ) { freeListBlock = null ; store . close ( ) ; } public void clear ( ) { store . clear ( ) ; } public void remove ( BlockPayload block ) { Block container = block . getBlock ( ) ; store . remove ( block ) ; freeListBlock . add ( container . getPos ( ) , container . getSize ( ) ) ; } public < T extends BlockPayload > T readFirst ( Class < T > payloadType ) { return store . read ( freeListBlock . getNextPos ( ) , payloadType ) ; } public < T extends BlockPayload > T read ( BlockPointer pos , Class < T > payloadType ) { return store . read ( pos , payloadType ) ; } public void write ( BlockPayload block ) { attach ( block ) ; store . write ( block ) ; } public void attach ( BlockPayload block ) { store . attach ( block ) ; freeListBlock . alloc ( block . getBlock ( ) ) ; } public void flush ( ) { store . flush ( ) ; } private void verify ( ) { FreeListBlock block = store . readFirst ( FreeListBlock . class ) ; verify ( block , Integer . MAX_VALUE ) ; } private void verify ( FreeListBlock block , int maxValue ) { if ( block . largestInNextBlock > maxValue ) { throw new RuntimeException ( <str> ) ; } int current = <int> ; for ( FreeListEntry entry : block . entries ) { if ( entry . size > maxValue ) { throw new RuntimeException ( <str> ) ; } if ( entry . size < block . largestInNextBlock ) { throw new RuntimeException ( <str> ) ; } if ( entry . size < current ) { throw new RuntimeException ( <str> ) ; } current = entry . size ; } if ( ! block . nextBlock . isNull ( ) ) { verify ( store . read ( block . nextBlock , FreeListBlock . class ) , block . largestInNextBlock ) ; } } public class FreeListBlock extends BlockPayload { private List < FreeListEntry > entries = new ArrayList < FreeListEntry > ( ) ; private int largestInNextBlock ; private BlockPointer nextBlock = new BlockPointer ( ) ; private FreeListBlock prev ; private FreeListBlock next ; @Override protected int getSize ( ) { return Block . LONG_SIZE + Block . INT_SIZE + Block . INT_SIZE + maxBlockEntries * ( Block . LONG_SIZE + Block . INT_SIZE ) ; } @Override protected int getType ( ) { return <hex> ; } @Override protected void read ( DataInputStream inputStream ) throws Exception { nextBlock = new BlockPointer ( inputStream . readLong ( ) ) ; largestInNextBlock = inputStream . readInt ( ) ; int count = inputStream . readInt ( ) ; for ( int i = <int> ; i < count ; i + + ) { BlockPointer pos = new BlockPointer ( inputStream . readLong ( ) ) ; int size = inputStream . readInt ( ) ; entries . add ( new FreeListEntry ( pos , size ) ) ; } } @Override protected void write ( DataOutputStream outputStream ) throws Exception { outputStream . writeLong ( nextBlock . getPos ( ) ) ; outputStream . writeInt ( largestInNextBlock ) ; outputStream . writeInt ( entries . size ( ) ) ; for ( FreeListEntry entry : entries ) { outputStream . writeLong ( entry . pos . getPos ( ) ) ; outputStream . writeInt ( entry . size ) ; } } public void add ( BlockPointer pos , int size ) { assert ! pos . isNull ( ) & & size > = <int> ; if ( size = = <int> ) { return ; } if ( size < largestInNextBlock ) { FreeListBlock next = getNextBlock ( ) ; next . add ( pos , size ) ; return ; } FreeListEntry entry = new FreeListEntry ( pos , size ) ; int index = Collections . binarySearch ( entries , entry ) ; if ( index < <int> ) { index = - index - <int> ; } entries . add ( index , entry ) ; if ( entries . size ( ) > maxBlockEntries ) { FreeListBlock newBlock = new FreeListBlock ( ) ; newBlock . largestInNextBlock = largestInNextBlock ; newBlock . nextBlock = nextBlock ; newBlock . prev = this ; newBlock . next = next ; next = newBlock ; List < FreeListEntry > newBlockEntries = entries . subList ( <int> , entries . size ( ) / <int> ) ; newBlock . entries . addAll ( newBlockEntries ) ; newBlockEntries . clear ( ) ; largestInNextBlock = newBlock . entries . get ( newBlock . entries . size ( ) - <int> ) . size ; freeListStore . write ( newBlock ) ; nextBlock = newBlock . getPos ( ) ; } freeListStore . write ( this ) ; } private FreeListBlock getNextBlock ( ) { if ( next = = null ) { next = freeListStore . read ( nextBlock , FreeListBlock . class ) ; next . prev = this ; } return next ; } public void alloc ( Block block ) { if ( block . hasPos ( ) ) { return ; } int requiredSize = block . getSize ( ) ; if ( entries . isEmpty ( ) | | requiredSize < = largestInNextBlock ) { if ( nextBlock . isNull ( ) ) { return ; } getNextBlock ( ) . alloc ( block ) ; return ; } int index = Collections . binarySearch ( entries , new FreeListEntry ( null , requiredSize ) ) ; if ( index < <int> ) { index = - index - <int> ; } if ( index = = entries . size ( ) ) { return ; } FreeListEntry entry = entries . remove ( index ) ; block . setPos ( entry . pos ) ; block . setSize ( entry . size ) ; freeListStore . write ( this ) ; if ( entries . size ( ) = = <int> & & prev ! = null ) { prev . nextBlock = nextBlock ; prev . largestInNextBlock = largestInNextBlock ; prev . next = next ; if ( next ! = null ) { next . prev = prev ; } freeListStore . write ( prev ) ; freeListStore . remove ( this ) ; } } } private static class FreeListEntry implements Comparable < FreeListEntry > { final BlockPointer pos ; final int size ; private FreeListEntry ( BlockPointer pos , int size ) { this . pos = pos ; this . size = size ; } public int compareTo ( FreeListEntry o ) { if ( size > o . size ) { return <int> ; } if ( size < o . size ) { return - <int> ; } return <int> ; } } } 
