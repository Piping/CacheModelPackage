package org . eclipse . debug . internal . ui . model . elements ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Map ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . debug . core . model . IErrorReportingExpression ; import org . eclipse . debug . core . model . IExpression ; import org . eclipse . debug . core . model . IValue ; import org . eclipse . debug . internal . core . IInternalDebugCoreConstants ; import org . eclipse . debug . internal . ui . viewers . model . ViewerAdapterService ; import org . eclipse . debug . internal . ui . viewers . model . ViewerUpdateMonitor ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenCountUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementContentProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IElementLabelProvider ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IHasChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ILabelUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . ui . IDebugUIConstants ; import org . eclipse . jface . resource . JFaceResources ; import org . eclipse . swt . SWT ; import org . eclipse . swt . graphics . FontData ; public class ExpressionContentProvider extends VariableContentProvider { private static class ErrorMessageElement implements IElementLabelProvider { public ErrorMessageElement ( String message ) { fMessage = message ; } private final String fMessage ; @Override public void update ( ILabelUpdate [ ] updates ) { for ( int i = <int> ; i < updates . length ; i + + ) { String [ ] columnIds = updates [ i ] . getColumnIds ( ) ; if ( columnIds = = null ) { updateLabel ( updates [ i ] , <int> ) ; } else { for ( int j = <int> ; j < columnIds . length ; j + + ) { if ( IDebugUIConstants . COLUMN_ID_VARIABLE_NAME . equals ( columnIds [ j ] ) ) { updateLabel ( updates [ i ] , j ) ; } else { updates [ i ] . setLabel ( IInternalDebugCoreConstants . EMPTY_STRING , j ) ; } } } updates [ i ] . done ( ) ; } } private void updateLabel ( ILabelUpdate update , int columnIndex ) { update . setLabel ( fMessage , columnIndex ) ; FontData fontData = JFaceResources . getFontDescriptor ( IDebugUIConstants . PREF_VARIABLE_TEXT_FONT ) . getFontData ( ) [ <int> ] ; fontData . setStyle ( SWT . ITALIC ) ; } } @Override public void update ( IChildrenCountUpdate [ ] updates ) { Map < IElementContentProvider , List < IViewerUpdate > > delegateMap = new HashMap < IElementContentProvider , List < IViewerUpdate > > ( ) ; List < IViewerUpdate > notDelegated = new ArrayList < IViewerUpdate > ( ) ; findDelegates ( delegateMap , notDelegated , updates ) ; for ( IElementContentProvider delegate : delegateMap . keySet ( ) ) { List < IViewerUpdate > updateList = delegateMap . get ( delegate ) ; delegate . update ( updateList . toArray ( new IChildrenCountUpdate [ updateList . size ( ) ] ) ) ; } if ( notDelegated . size ( ) > <int> ) { super . update ( notDelegated . toArray ( new IChildrenCountUpdate [ notDelegated . size ( ) ] ) ) ; } } @Override public void update ( IHasChildrenUpdate [ ] updates ) { Map < IElementContentProvider , List < IViewerUpdate > > delegateMap = new HashMap < IElementContentProvider , List < IViewerUpdate > > ( ) ; List < IViewerUpdate > notDelegated = new ArrayList < IViewerUpdate > ( ) ; findDelegates ( delegateMap , notDelegated , updates ) ; for ( IElementContentProvider delegate : delegateMap . keySet ( ) ) { List < IViewerUpdate > updateList = delegateMap . get ( delegate ) ; delegate . update ( updateList . toArray ( new IHasChildrenUpdate [ updateList . size ( ) ] ) ) ; } if ( notDelegated . size ( ) > <int> ) { super . update ( notDelegated . toArray ( new IHasChildrenUpdate [ notDelegated . size ( ) ] ) ) ; } } @Override public void update ( IChildrenUpdate [ ] updates ) { Map < IElementContentProvider , List < IViewerUpdate > > delegateMap = new HashMap < IElementContentProvider , List < IViewerUpdate > > ( ) ; List < IViewerUpdate > notDelegated = new ArrayList < IViewerUpdate > ( ) ; findDelegates ( delegateMap , notDelegated , updates ) ; for ( IElementContentProvider delegate : delegateMap . keySet ( ) ) { List < IViewerUpdate > updateList = delegateMap . get ( delegate ) ; delegate . update ( updateList . toArray ( new IChildrenUpdate [ updateList . size ( ) ] ) ) ; } if ( notDelegated . size ( ) > <int> ) { super . update ( notDelegated . toArray ( new IChildrenUpdate [ notDelegated . size ( ) ] ) ) ; } } private void findDelegates ( Map < IElementContentProvider , List < IViewerUpdate > > delegateMap , List < IViewerUpdate > notDelegated , IViewerUpdate [ ] updates ) { for ( int i = <int> ; i < updates . length ; i + + ) { if ( updates [ i ] instanceof ViewerUpdateMonitor & & ! ( ( ViewerUpdateMonitor ) updates [ i ] ) . isDelegated ( ) & & updates [ i ] . getElement ( ) instanceof IExpression ) { IElementContentProvider delegate = ViewerAdapterService . getContentProvider ( ( ( IExpression ) updates [ i ] . getElement ( ) ) . getValue ( ) ) ; if ( delegate ! = null ) { List < IViewerUpdate > updateList = delegateMap . get ( delegate ) ; if ( updateList = = null ) { updateList = new ArrayList < IViewerUpdate > ( ) ; delegateMap . put ( delegate , updateList ) ; } ( ( ViewerUpdateMonitor ) updates [ i ] ) . setDelegated ( true ) ; updateList . add ( updates [ i ] ) ; continue ; } } notDelegated . add ( updates [ i ] ) ; } } @Override protected Object [ ] getAllChildren ( Object parent , IPresentationContext context ) throws CoreException { if ( parent instanceof IErrorReportingExpression ) { IErrorReportingExpression expression = ( IErrorReportingExpression ) parent ; if ( expression . hasErrors ( ) ) { String [ ] messages = expression . getErrorMessages ( ) ; LinkedHashSet < ErrorMessageElement > set = new LinkedHashSet < ErrorMessageElement > ( messages . length ) ; for ( int i = <int> ; i < messages . length ; i + + ) { set . add ( new ErrorMessageElement ( messages [ i ] ) ) ; } return set . toArray ( ) ; } } if ( parent instanceof IExpression ) { IExpression expression = ( IExpression ) parent ; IValue value = expression . getValue ( ) ; if ( value ! = null ) { return getValueChildren ( expression , value , context ) ; } } return EMPTY ; } @Override protected boolean hasChildren ( Object element , IPresentationContext context , IViewerUpdate monitor ) throws CoreException { if ( element instanceof IErrorReportingExpression ) { IErrorReportingExpression expression = ( IErrorReportingExpression ) element ; if ( expression . hasErrors ( ) ) { return true ; } } if ( element instanceof IExpression ) { IValue value = ( ( IExpression ) element ) . getValue ( ) ; if ( value = = null ) { return false ; } return value . hasVariables ( ) ; } return false ; } } 
