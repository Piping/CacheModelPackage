package com . google . common . io ; import static com . google . common . io . TestOption . CLOSE_THROWS ; import static com . google . common . io . TestOption . OPEN_THROWS ; import static com . google . common . io . TestOption . READ_THROWS ; import static com . google . common . io . TestOption . WRITE_THROWS ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import com . google . common . testing . TestLogHandler ; import junit . framework . TestSuite ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . Reader ; import java . io . StringWriter ; import java . io . Writer ; import java . util . EnumSet ; import java . util . List ; public class CharSourceTest extends IoTestCase { @AndroidIncompatible public static TestSuite suite ( ) { TestSuite suite = new TestSuite ( ) ; for ( boolean asByteSource : new boolean [ ] { false , true } ) { suite . addTest ( CharSourceTester . tests ( <str> , SourceSinkFactories . stringCharSourceFactory ( ) , asByteSource ) ) ; suite . addTest ( CharSourceTester . tests ( <str> , SourceSinkFactories . emptyCharSourceFactory ( ) , asByteSource ) ) ; } suite . addTestSuite ( CharSourceTest . class ) ; return suite ; } private static final String STRING = ASCII + I18N ; private static final String LINES = <str> ; private TestCharSource source ; @Override public void setUp ( ) { source = new TestCharSource ( STRING ) ; } public void testOpenBufferedStream ( ) throws IOException { BufferedReader reader = source . openBufferedStream ( ) ; assertTrue ( source . wasStreamOpened ( ) ) ; assertFalse ( source . wasStreamClosed ( ) ) ; StringWriter writer = new StringWriter ( ) ; char [ ] buf = new char [ <int> ] ; int read ; while ( ( read = reader . read ( buf ) ) ! = - <int> ) { writer . write ( buf , <int> , read ) ; } reader . close ( ) ; writer . close ( ) ; assertTrue ( source . wasStreamClosed ( ) ) ; assertEquals ( STRING , writer . toString ( ) ) ; } public void testCopyTo_appendable ( ) throws IOException { StringBuilder builder = new StringBuilder ( ) ; assertEquals ( STRING . length ( ) , source . copyTo ( builder ) ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; assertEquals ( STRING , builder . toString ( ) ) ; } public void testCopyTo_charSink ( ) throws IOException { TestCharSink sink = new TestCharSink ( ) ; assertFalse ( sink . wasStreamOpened ( ) | | sink . wasStreamClosed ( ) ) ; assertEquals ( STRING . length ( ) , source . copyTo ( sink ) ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; assertTrue ( sink . wasStreamOpened ( ) & & sink . wasStreamClosed ( ) ) ; assertEquals ( STRING , sink . getString ( ) ) ; } public void testRead_toString ( ) throws IOException { assertEquals ( STRING , source . read ( ) ) ; assertTrue ( source . wasStreamOpened ( ) & & source . wasStreamClosed ( ) ) ; } public void testReadFirstLine ( ) throws IOException { TestCharSource lines = new TestCharSource ( LINES ) ; assertEquals ( <str> , lines . readFirstLine ( ) ) ; assertTrue ( lines . wasStreamOpened ( ) & & lines . wasStreamClosed ( ) ) ; } public void testReadLines_toList ( ) throws IOException { TestCharSource lines = new TestCharSource ( LINES ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> ) , lines . readLines ( ) ) ; assertTrue ( lines . wasStreamOpened ( ) & & lines . wasStreamClosed ( ) ) ; } public void testReadLines_withProcessor ( ) throws IOException { TestCharSource lines = new TestCharSource ( LINES ) ; List < String > list = lines . readLines ( new LineProcessor < List < String > > ( ) { List < String > list = Lists . newArrayList ( ) ; @Override public boolean processLine ( String line ) throws IOException { list . add ( line ) ; return true ; } @Override public List < String > getResult ( ) { return list ; } } ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> ) , list ) ; assertTrue ( lines . wasStreamOpened ( ) & & lines . wasStreamClosed ( ) ) ; } public void testReadLines_withProcessor_stopsOnFalse ( ) throws IOException { TestCharSource lines = new TestCharSource ( LINES ) ; List < String > list = lines . readLines ( new LineProcessor < List < String > > ( ) { List < String > list = Lists . newArrayList ( ) ; @Override public boolean processLine ( String line ) throws IOException { list . add ( line ) ; return false ; } @Override public List < String > getResult ( ) { return list ; } } ) ; assertEquals ( ImmutableList . of ( <str> ) , list ) ; assertTrue ( lines . wasStreamOpened ( ) & & lines . wasStreamClosed ( ) ) ; } public void testCopyToAppendable_doesNotCloseIfWriter ( ) throws IOException { TestWriter writer = new TestWriter ( ) ; assertFalse ( writer . closed ( ) ) ; source . copyTo ( writer ) ; assertFalse ( writer . closed ( ) ) ; } public void testClosesOnErrors_copyingToCharSinkThatThrows ( ) { for ( TestOption option : EnumSet . of ( OPEN_THROWS , WRITE_THROWS , CLOSE_THROWS ) ) { TestCharSource okSource = new TestCharSource ( STRING ) ; try { okSource . copyTo ( new TestCharSink ( option ) ) ; fail ( ) ; } catch ( IOException expected ) { } assertTrue ( <str> + option , ! okSource . wasStreamOpened ( ) | | okSource . wasStreamClosed ( ) ) ; } } public void testClosesOnErrors_whenReadThrows ( ) { TestCharSource failSource = new TestCharSource ( STRING , READ_THROWS ) ; try { failSource . copyTo ( new TestCharSink ( ) ) ; fail ( ) ; } catch ( IOException expected ) { } assertTrue ( failSource . wasStreamClosed ( ) ) ; } public void testClosesOnErrors_copyingToWriterThatThrows ( ) { TestCharSource okSource = new TestCharSource ( STRING ) ; try { okSource . copyTo ( new TestWriter ( WRITE_THROWS ) ) ; fail ( ) ; } catch ( IOException expected ) { } assertTrue ( okSource . wasStreamClosed ( ) ) ; } public void testConcat ( ) throws IOException { CharSource c1 = CharSource . wrap ( <str> ) ; CharSource c2 = CharSource . wrap ( <str> ) ; CharSource c3 = CharSource . wrap ( <str> ) ; String expected = <str> ; assertEquals ( expected , CharSource . concat ( ImmutableList . of ( c1 , c2 , c3 ) ) . read ( ) ) ; assertEquals ( expected , CharSource . concat ( c1 , c2 , c3 ) . read ( ) ) ; assertEquals ( expected , CharSource . concat ( ImmutableList . of ( c1 , c2 , c3 ) . iterator ( ) ) . read ( ) ) ; assertFalse ( CharSource . concat ( c1 , c2 , c3 ) . isEmpty ( ) ) ; CharSource emptyConcat = CharSource . concat ( CharSource . empty ( ) , CharSource . empty ( ) ) ; assertTrue ( emptyConcat . isEmpty ( ) ) ; } public void testConcat_infiniteIterable ( ) throws IOException { CharSource source = CharSource . wrap ( <str> ) ; Iterable < CharSource > cycle = Iterables . cycle ( ImmutableList . of ( source ) ) ; CharSource concatenated = CharSource . concat ( cycle ) ; String expected = <str> ; StringBuilder builder = new StringBuilder ( ) ; Reader reader = concatenated . openStream ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { builder . append ( ( char ) reader . read ( ) ) ; } assertEquals ( expected , builder . toString ( ) ) ; } static final CharSource BROKEN_READ_SOURCE = new TestCharSource ( <str> , READ_THROWS ) ; static final CharSource BROKEN_CLOSE_SOURCE = new TestCharSource ( <str> , CLOSE_THROWS ) ; static final CharSource BROKEN_OPEN_SOURCE = new TestCharSource ( <str> , OPEN_THROWS ) ; static final CharSink BROKEN_WRITE_SINK = new TestCharSink ( WRITE_THROWS ) ; static final CharSink BROKEN_CLOSE_SINK = new TestCharSink ( CLOSE_THROWS ) ; static final CharSink BROKEN_OPEN_SINK = new TestCharSink ( OPEN_THROWS ) ; private static final ImmutableSet < CharSource > BROKEN_SOURCES = ImmutableSet . of ( BROKEN_CLOSE_SOURCE , BROKEN_OPEN_SOURCE , BROKEN_READ_SOURCE ) ; private static final ImmutableSet < CharSink > BROKEN_SINKS = ImmutableSet . of ( BROKEN_CLOSE_SINK , BROKEN_OPEN_SINK , BROKEN_WRITE_SINK ) ; public void testCopyExceptions ( ) { if ( ! Closer . SuppressingSuppressor . isAvailable ( ) ) { TestLogHandler logHandler = new TestLogHandler ( ) ; Closeables . logger . addHandler ( logHandler ) ; try { for ( CharSource in : BROKEN_SOURCES ) { runFailureTest ( in , newNormalCharSink ( ) ) ; assertTrue ( logHandler . getStoredLogRecords ( ) . isEmpty ( ) ) ; runFailureTest ( in , BROKEN_CLOSE_SINK ) ; assertEquals ( ( in = = BROKEN_OPEN_SOURCE ) ? <int> : <int> , getAndResetRecords ( logHandler ) ) ; } for ( CharSink out : BROKEN_SINKS ) { runFailureTest ( newNormalCharSource ( ) , out ) ; assertTrue ( logHandler . getStoredLogRecords ( ) . isEmpty ( ) ) ; runFailureTest ( BROKEN_CLOSE_SOURCE , out ) ; assertEquals ( <int> , getAndResetRecords ( logHandler ) ) ; } for ( CharSource in : BROKEN_SOURCES ) { for ( CharSink out : BROKEN_SINKS ) { runFailureTest ( in , out ) ; assertTrue ( getAndResetRecords ( logHandler ) < = <int> ) ; } } } finally { Closeables . logger . removeHandler ( logHandler ) ; } } else { for ( CharSource in : BROKEN_SOURCES ) { int suppressed = runSuppressionFailureTest ( in , newNormalCharSink ( ) ) ; assertEquals ( <int> , suppressed ) ; suppressed = runSuppressionFailureTest ( in , BROKEN_CLOSE_SINK ) ; assertEquals ( ( in = = BROKEN_OPEN_SOURCE ) ? <int> : <int> , suppressed ) ; } for ( CharSink out : BROKEN_SINKS ) { int suppressed = runSuppressionFailureTest ( newNormalCharSource ( ) , out ) ; assertEquals ( <int> , suppressed ) ; suppressed = runSuppressionFailureTest ( BROKEN_CLOSE_SOURCE , out ) ; assertEquals ( <int> , suppressed ) ; } for ( CharSource in : BROKEN_SOURCES ) { for ( CharSink out : BROKEN_SINKS ) { int suppressed = runSuppressionFailureTest ( in , out ) ; assertTrue ( suppressed < = <int> ) ; } } } } private static int getAndResetRecords ( TestLogHandler logHandler ) { int records = logHandler . getStoredLogRecords ( ) . size ( ) ; logHandler . clear ( ) ; return records ; } private static void runFailureTest ( CharSource in , CharSink out ) { try { in . copyTo ( out ) ; fail ( ) ; } catch ( IOException expected ) { } } private static int runSuppressionFailureTest ( CharSource in , CharSink out ) { try { in . copyTo ( out ) ; fail ( ) ; } catch ( IOException expected ) { return CloserTest . getSuppressed ( expected ) . length ; } throw new AssertionError ( ) ; } private static CharSource newNormalCharSource ( ) { return CharSource . wrap ( <str> ) ; } private static CharSink newNormalCharSink ( ) { return new CharSink ( ) { @Override public Writer openStream ( ) { return new StringWriter ( ) ; } } ; } } 
