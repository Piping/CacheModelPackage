package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import static com . google . common . util . concurrent . Uninterruptibles . getUninterruptibly ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Preconditions ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Queues ; import com . google . common . util . concurrent . CollectionFuture . ListFuture ; import com . google . common . util . concurrent . ImmediateFuture . ImmediateCancelledFuture ; import com . google . common . util . concurrent . ImmediateFuture . ImmediateFailedCheckedFuture ; import com . google . common . util . concurrent . ImmediateFuture . ImmediateFailedFuture ; import com . google . common . util . concurrent . ImmediateFuture . ImmediateSuccessfulCheckedFuture ; import com . google . common . util . concurrent . ImmediateFuture . ImmediateSuccessfulFuture ; import java . util . List ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ConcurrentLinkedQueue ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executor ; import java . util . concurrent . Future ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @Beta @GwtCompatible ( emulated = true ) public final class Futures extends GwtFuturesCatchingSpecialization { private Futures ( ) { } @GwtIncompatible ( <str> ) @CheckReturnValue public static < V , X extends Exception > CheckedFuture < V , X > makeChecked ( ListenableFuture < V > future , Function < ? super Exception , X > mapper ) { return new MappingCheckedFuture < V , X > ( checkNotNull ( future ) , mapper ) ; } @CheckReturnValue public static < V > ListenableFuture < V > immediateFuture ( @Nullable V value ) { if ( value = = null ) { @SuppressWarnings ( { <str> , <str> } ) ListenableFuture < V > typedNull = ( ListenableFuture ) ImmediateSuccessfulFuture . NULL ; return typedNull ; } return new ImmediateSuccessfulFuture < V > ( value ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public static < V , X extends Exception > CheckedFuture < V , X > immediateCheckedFuture ( @Nullable V value ) { return new ImmediateSuccessfulCheckedFuture < V , X > ( value ) ; } @CheckReturnValue public static < V > ListenableFuture < V > immediateFailedFuture ( Throwable throwable ) { checkNotNull ( throwable ) ; return new ImmediateFailedFuture < V > ( throwable ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public static < V > ListenableFuture < V > immediateCancelledFuture ( ) { return new ImmediateCancelledFuture < V > ( ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public static < V , X extends Exception > CheckedFuture < V , X > immediateFailedCheckedFuture ( X exception ) { checkNotNull ( exception ) ; return new ImmediateFailedCheckedFuture < V , X > ( exception ) ; } @Deprecated @CheckReturnValue public static < V > ListenableFuture < V > withFallback ( ListenableFuture < ? extends V > input , FutureFallback < ? extends V > fallback ) { return withFallback ( input , fallback , directExecutor ( ) ) ; } @Deprecated @CheckReturnValue public static < V > ListenableFuture < V > withFallback ( ListenableFuture < ? extends V > input , FutureFallback < ? extends V > fallback , Executor executor ) { return catchingAsync ( input , Throwable . class , asAsyncFunction ( fallback ) , executor ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public static < V , X extends Throwable > ListenableFuture < V > catching ( ListenableFuture < ? extends V > input , Class < X > exceptionType , Function < ? super X , ? extends V > fallback ) { return AbstractCatchingFuture . create ( input , exceptionType , fallback ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public static < V , X extends Throwable > ListenableFuture < V > catching ( ListenableFuture < ? extends V > input , Class < X > exceptionType , Function < ? super X , ? extends V > fallback , Executor executor ) { return AbstractCatchingFuture . create ( input , exceptionType , fallback , executor ) ; } @GwtIncompatible ( <str> ) public static < V , X extends Throwable > ListenableFuture < V > catchingAsync ( ListenableFuture < ? extends V > input , Class < X > exceptionType , AsyncFunction < ? super X , ? extends V > fallback ) { return AbstractCatchingFuture . create ( input , exceptionType , fallback ) ; } @GwtIncompatible ( <str> ) public static < V , X extends Throwable > ListenableFuture < V > catchingAsync ( ListenableFuture < ? extends V > input , Class < X > exceptionType , AsyncFunction < ? super X , ? extends V > fallback , Executor executor ) { return AbstractCatchingFuture . create ( input , exceptionType , fallback , executor ) ; } @Deprecated static < V > AsyncFunction < Throwable , V > asAsyncFunction ( final FutureFallback < V > fallback ) { checkNotNull ( fallback ) ; return new AsyncFunction < Throwable , V > ( ) { @Override public ListenableFuture < V > apply ( Throwable t ) throws Exception { return checkNotNull ( fallback . create ( t ) , <str> + <str> ) ; } } ; } @GwtIncompatible ( <str> ) @CheckReturnValue public static < V > ListenableFuture < V > withTimeout ( ListenableFuture < V > delegate , long time , TimeUnit unit , ScheduledExecutorService scheduledExecutor ) { return TimeoutFuture . create ( delegate , time , unit , scheduledExecutor ) ; } @Deprecated public static < I , O > ListenableFuture < O > transform ( ListenableFuture < I > input , AsyncFunction < ? super I , ? extends O > function ) { return transformAsync ( input , function ) ; } @Deprecated public static < I , O > ListenableFuture < O > transform ( ListenableFuture < I > input , AsyncFunction < ? super I , ? extends O > function , Executor executor ) { return transformAsync ( input , function , executor ) ; } public static < I , O > ListenableFuture < O > transformAsync ( ListenableFuture < I > input , AsyncFunction < ? super I , ? extends O > function ) { return AbstractTransformFuture . create ( input , function ) ; } public static < I , O > ListenableFuture < O > transformAsync ( ListenableFuture < I > input , AsyncFunction < ? super I , ? extends O > function , Executor executor ) { return AbstractTransformFuture . create ( input , function , executor ) ; } public static < I , O > ListenableFuture < O > transform ( ListenableFuture < I > input , Function < ? super I , ? extends O > function ) { return AbstractTransformFuture . create ( input , function ) ; } public static < I , O > ListenableFuture < O > transform ( ListenableFuture < I > input , Function < ? super I , ? extends O > function , Executor executor ) { return AbstractTransformFuture . create ( input , function , executor ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public static < I , O > Future < O > lazyTransform ( final Future < I > input , final Function < ? super I , ? extends O > function ) { checkNotNull ( input ) ; checkNotNull ( function ) ; return new Future < O > ( ) { @Override public boolean cancel ( boolean mayInterruptIfRunning ) { return input . cancel ( mayInterruptIfRunning ) ; } @Override public boolean isCancelled ( ) { return input . isCancelled ( ) ; } @Override public boolean isDone ( ) { return input . isDone ( ) ; } @Override public O get ( ) throws InterruptedException , ExecutionException { return applyTransformation ( input . get ( ) ) ; } @Override public O get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { return applyTransformation ( input . get ( timeout , unit ) ) ; } private O applyTransformation ( I input ) throws ExecutionException { try { return function . apply ( input ) ; } catch ( Throwable t ) { throw new ExecutionException ( t ) ; } } } ; } @SuppressWarnings ( { <str> , <str> } ) @CheckReturnValue public static < V > ListenableFuture < V > dereference ( ListenableFuture < ? extends ListenableFuture < ? extends V > > nested ) { return transformAsync ( ( ListenableFuture ) nested , ( AsyncFunction ) DEREFERENCER ) ; } private static final AsyncFunction < ListenableFuture < Object > , Object > DEREFERENCER = new AsyncFunction < ListenableFuture < Object > , Object > ( ) { @Override public ListenableFuture < Object > apply ( ListenableFuture < Object > input ) { return input ; } } ; @Beta @SafeVarargs @CheckReturnValue public static < V > ListenableFuture < List < V > > allAsList ( ListenableFuture < ? extends V > . . . futures ) { return new ListFuture < V > ( ImmutableList . copyOf ( futures ) , true ) ; } @Beta @CheckReturnValue public static < V > ListenableFuture < List < V > > allAsList ( Iterable < ? extends ListenableFuture < ? extends V > > futures ) { return new ListFuture < V > ( ImmutableList . copyOf ( futures ) , true ) ; } @GwtIncompatible ( <str> ) @CheckReturnValue public static < V > ListenableFuture < V > nonCancellationPropagating ( ListenableFuture < V > future ) { return new NonCancellationPropagatingFuture < V > ( future ) ; } @GwtIncompatible ( <str> ) private static final class NonCancellationPropagatingFuture < V > extends AbstractFuture . TrustedFuture < V > { NonCancellationPropagatingFuture ( final ListenableFuture < V > delegate ) { delegate . addListener ( new Runnable ( ) { @Override public void run ( ) { setFuture ( delegate ) ; } } , directExecutor ( ) ) ; } } @Beta @SafeVarargs @CheckReturnValue public static < V > ListenableFuture < List < V > > successfulAsList ( ListenableFuture < ? extends V > . . . futures ) { return new ListFuture < V > ( ImmutableList . copyOf ( futures ) , false ) ; } @Beta @CheckReturnValue public static < V > ListenableFuture < List < V > > successfulAsList ( Iterable < ? extends ListenableFuture < ? extends V > > futures ) { return new ListFuture < V > ( ImmutableList . copyOf ( futures ) , false ) ; } @Beta @GwtIncompatible ( <str> ) @CheckReturnValue public static < T > ImmutableList < ListenableFuture < T > > inCompletionOrder ( Iterable < ? extends ListenableFuture < ? extends T > > futures ) { final ConcurrentLinkedQueue < SettableFuture < T > > delegates = Queues . newConcurrentLinkedQueue ( ) ; ImmutableList . Builder < ListenableFuture < T > > listBuilder = ImmutableList . builder ( ) ; SerializingExecutor executor = new SerializingExecutor ( directExecutor ( ) ) ; for ( final ListenableFuture < ? extends T > future : futures ) { SettableFuture < T > delegate = SettableFuture . create ( ) ; delegates . add ( delegate ) ; future . addListener ( new Runnable ( ) { @Override public void run ( ) { delegates . remove ( ) . setFuture ( future ) ; } } , executor ) ; listBuilder . add ( delegate ) ; } return listBuilder . build ( ) ; } public static < V > void addCallback ( ListenableFuture < V > future , FutureCallback < ? super V > callback ) { addCallback ( future , callback , directExecutor ( ) ) ; } public static < V > void addCallback ( final ListenableFuture < V > future , final FutureCallback < ? super V > callback , Executor executor ) { Preconditions . checkNotNull ( callback ) ; Runnable callbackListener = new Runnable ( ) { @Override public void run ( ) { final V value ; try { value = getUninterruptibly ( future ) ; } catch ( ExecutionException e ) { callback . onFailure ( e . getCause ( ) ) ; return ; } catch ( RuntimeException e ) { callback . onFailure ( e ) ; return ; } catch ( Error e ) { callback . onFailure ( e ) ; return ; } callback . onSuccess ( value ) ; } } ; future . addListener ( callbackListener , executor ) ; } @Deprecated @GwtIncompatible ( <str> ) public static < V , X extends Exception > V get ( Future < V > future , Class < X > exceptionClass ) throws X { return getChecked ( future , exceptionClass ) ; } @Deprecated @GwtIncompatible ( <str> ) public static < V , X extends Exception > V get ( Future < V > future , long timeout , TimeUnit unit , Class < X > exceptionClass ) throws X { return getChecked ( future , exceptionClass , timeout , unit ) ; } @GwtIncompatible ( <str> ) public static < V , X extends Exception > V getChecked ( Future < V > future , Class < X > exceptionClass ) throws X { return FuturesGetChecked . getChecked ( future , exceptionClass ) ; } @GwtIncompatible ( <str> ) public static < V , X extends Exception > V getChecked ( Future < V > future , Class < X > exceptionClass , long timeout , TimeUnit unit ) throws X { return FuturesGetChecked . getChecked ( future , exceptionClass , timeout , unit ) ; } @GwtIncompatible ( <str> ) public static < V > V getUnchecked ( Future < V > future ) { checkNotNull ( future ) ; try { return getUninterruptibly ( future ) ; } catch ( ExecutionException e ) { wrapAndThrowUnchecked ( e . getCause ( ) ) ; throw new AssertionError ( ) ; } } @GwtIncompatible ( <str> ) private static void wrapAndThrowUnchecked ( Throwable cause ) { if ( cause instanceof Error ) { throw new ExecutionError ( ( Error ) cause ) ; } throw new UncheckedExecutionException ( cause ) ; } @GwtIncompatible ( <str> ) private static class MappingCheckedFuture < V , X extends Exception > extends AbstractCheckedFuture < V , X > { final Function < ? super Exception , X > mapper ; MappingCheckedFuture ( ListenableFuture < V > delegate , Function < ? super Exception , X > mapper ) { super ( delegate ) ; this . mapper = checkNotNull ( mapper ) ; } @Override protected X mapException ( Exception e ) { return mapper . apply ( e ) ; } } } 
