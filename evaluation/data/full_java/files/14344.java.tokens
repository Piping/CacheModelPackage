package org . gradle . model . internal . inspect ; import com . google . common . base . Function ; import com . google . common . base . Predicates ; import com . google . common . cache . CacheBuilder ; import com . google . common . cache . CacheLoader ; import com . google . common . cache . LoadingCache ; import com . google . common . collect . FluentIterable ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Iterables ; import net . jcip . annotations . ThreadSafe ; import org . gradle . internal . Cast ; import org . gradle . internal . UncheckedException ; import org . gradle . model . RuleSource ; import java . lang . ref . Reference ; import java . lang . ref . WeakReference ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . concurrent . ExecutionException ; @ThreadSafe public class ModelRuleSourceDetector { private static final Comparator < Class < ? > > COMPARE_BY_CLASS_NAME = new Comparator < Class < ? > > ( ) { public int compare ( Class < ? > left , Class < ? > right ) { return left . getName ( ) . compareTo ( right . getName ( ) ) ; } } ; final LoadingCache < Class < ? > , Collection < Reference < Class < ? extends RuleSource > > > > cache = CacheBuilder . newBuilder ( ) . weakKeys ( ) . build ( new CacheLoader < Class < ? > , Collection < Reference < Class < ? extends RuleSource > > > > ( ) { @Override public Collection < Reference < Class < ? extends RuleSource > > > load ( @SuppressWarnings ( <str> ) Class < ? > container ) throws Exception { if ( isRuleSource ( container ) ) { Class < ? extends RuleSource > castClass = Cast . uncheckedCast ( container ) ; return ImmutableSet . < Reference < Class < ? extends RuleSource > > > of ( new WeakReference < Class < ? extends RuleSource > > ( castClass ) ) ; } Class < ? > [ ] declaredClasses = container . getDeclaredClasses ( ) ; if ( declaredClasses . length = = <int> ) { return Collections . emptySet ( ) ; } else { Class < ? > [ ] sortedDeclaredClasses = new Class < ? > [ declaredClasses . length ] ; System . arraycopy ( declaredClasses , <int> , sortedDeclaredClasses , <int> , declaredClasses . length ) ; Arrays . sort ( sortedDeclaredClasses , COMPARE_BY_CLASS_NAME ) ; ImmutableList . Builder < Reference < Class < ? extends RuleSource > > > found = ImmutableList . builder ( ) ; for ( Class < ? > declaredClass : sortedDeclaredClasses ) { if ( isRuleSource ( declaredClass ) ) { Class < ? extends RuleSource > castClass = Cast . uncheckedCast ( declaredClass ) ; found . add ( new WeakReference < Class < ? extends RuleSource > > ( castClass ) ) ; } } return found . build ( ) ; } } } ) ; public Iterable < Class < ? extends RuleSource > > getDeclaredSources ( Class < ? > container ) { try { return FluentIterable . from ( cache . get ( container ) ) . transform ( new Function < Reference < Class < ? extends RuleSource > > , Class < ? extends RuleSource > > ( ) { @Override public Class < ? extends RuleSource > apply ( Reference < Class < ? extends RuleSource > > input ) { return input . get ( ) ; } } ) . filter ( Predicates . notNull ( ) ) ; } catch ( ExecutionException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public boolean hasRules ( Class < ? > container ) { return ! Iterables . isEmpty ( getDeclaredSources ( container ) ) ; } private boolean isRuleSource ( Class < ? > clazz ) { return RuleSource . class . isAssignableFrom ( clazz ) ; } } 
