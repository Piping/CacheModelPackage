package org . apache . cassandra . schema ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . stream . Collectors ; import com . google . common . collect . ImmutableList ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . cql3 . functions . * ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . thrift . ThriftConversion ; import static java . lang . String . format ; import static junit . framework . Assert . assertEquals ; import static junit . framework . Assert . assertTrue ; import static org . apache . cassandra . cql3 . QueryProcessor . executeOnceInternal ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; import static org . apache . cassandra . utils . FBUtilities . json ; @SuppressWarnings ( <str> ) public class LegacySchemaMigratorTest { private static final long TIMESTAMP = <int> ; private static final String KEYSPACE_PREFIX = <str> ; @Test public void testMigrate ( ) throws IOException { CQLTester . cleanupAndLeaveDirs ( ) ; Keyspaces expected = keyspacesToMigrate ( ) ; expected . forEach ( LegacySchemaMigratorTest : : legacySerializeKeyspace ) ; LegacySchemaMigrator . migrate ( ) ; Keyspaces actual = SchemaKeyspace . fetchNonSystemKeyspaces ( ) ; loadLegacySchemaTables ( ) ; for ( CFMetaData table : LegacySchemaMigrator . LegacySchemaTables ) { String query = format ( <str> , SystemKeyspace . NAME , table . cfName ) ; assertTrue ( executeOnceInternal ( query ) . isEmpty ( ) ) ; } assertEquals ( expected , actual ) ; } private static void loadLegacySchemaTables ( ) { KeyspaceMetadata systemKeyspace = Schema . instance . getKSMetaData ( SystemKeyspace . NAME ) ; Tables systemTables = systemKeyspace . tables ; for ( CFMetaData table : LegacySchemaMigrator . LegacySchemaTables ) systemTables = systemTables . with ( table ) ; LegacySchemaMigrator . LegacySchemaTables . forEach ( Schema . instance : : load ) ; Schema . instance . setKeyspaceMetadata ( systemKeyspace . withSwapped ( systemTables ) ) ; } private static Keyspaces keyspacesToMigrate ( ) { Keyspaces . Builder keyspaces = Keyspaces . builder ( ) ; String ks1 = KEYSPACE_PREFIX + <str> ; String ks2 = KEYSPACE_PREFIX + <str> ; String ks3 = KEYSPACE_PREFIX + <str> ; String ks4 = KEYSPACE_PREFIX + <str> ; String ks5 = KEYSPACE_PREFIX + <str> ; String ks6 = KEYSPACE_PREFIX + <str> ; String ks_rcs = KEYSPACE_PREFIX + <str> ; String ks_nocommit = KEYSPACE_PREFIX + <str> ; String ks_prsi = KEYSPACE_PREFIX + <str> ; String ks_cql = KEYSPACE_PREFIX + <str> ; Map < String , String > compactionOptions = new HashMap < > ( ) ; compactionOptions . put ( <str> , <str> ) ; Map < String , String > leveledOptions = new HashMap < > ( ) ; leveledOptions . put ( <str> , <str> ) ; keyspaces . add ( KeyspaceMetadata . create ( ks1 , KeyspaceParams . simple ( <int> ) , Tables . of ( SchemaLoader . standardCFMD ( ks1 , <str> ) . compaction ( CompactionParams . scts ( compactionOptions ) ) , SchemaLoader . standardCFMD ( ks1 , <str> ) . gcGraceSeconds ( <int> ) , SchemaLoader . standardCFMD ( ks1 , <str> ) , SchemaLoader . superCFMD ( ks1 , <str> , LongType . instance ) , SchemaLoader . superCFMD ( ks1 , <str> , UTF8Type . instance ) , SchemaLoader . superCFMD ( ks1 , <str> , BytesType . instance ) , SchemaLoader . superCFMD ( ks1 , <str> , LexicalUUIDType . instance , UTF8Type . instance ) , SchemaLoader . keysIndexCFMD ( ks1 , <str> , true ) , SchemaLoader . keysIndexCFMD ( ks1 , <str> , false ) , SchemaLoader . superCFMD ( ks1 , <str> , BytesType . instance ) . gcGraceSeconds ( <int> ) , SchemaLoader . jdbcCFMD ( ks1 , <str> , UTF8Type . instance ) . addColumnDefinition ( SchemaLoader . utf8Column ( ks1 , <str> ) ) , SchemaLoader . jdbcCFMD ( ks1 , <str> , LongType . instance ) , SchemaLoader . jdbcCFMD ( ks1 , <str> , BytesType . instance ) , SchemaLoader . jdbcCFMD ( ks1 , <str> , AsciiType . instance ) , SchemaLoader . standardCFMD ( ks1 , <str> ) . compaction ( CompactionParams . lcs ( leveledOptions ) ) , SchemaLoader . standardCFMD ( ks1 , <str> ) . compaction ( CompactionParams . lcs ( leveledOptions ) ) , SchemaLoader . standardCFMD ( ks1 , <str> ) . minIndexInterval ( <int> ) . maxIndexInterval ( <int> ) . caching ( CachingParams . CACHE_NOTHING ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks2 , KeyspaceParams . simple ( <int> ) , Tables . of ( SchemaLoader . standardCFMD ( ks2 , <str> ) , SchemaLoader . superCFMD ( ks2 , <str> , BytesType . instance ) , SchemaLoader . superCFMD ( ks2 , <str> , TimeUUIDType . instance ) , SchemaLoader . keysIndexCFMD ( ks2 , <str> , true ) , SchemaLoader . compositeIndexCFMD ( ks2 , <str> , true ) , SchemaLoader . compositeIndexCFMD ( ks2 , <str> , true ) . gcGraceSeconds ( <int> ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks3 , KeyspaceParams . simple ( <int> ) , Tables . of ( SchemaLoader . standardCFMD ( ks3 , <str> ) , SchemaLoader . keysIndexCFMD ( ks3 , <str> , true ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks4 , KeyspaceParams . simple ( <int> ) , Tables . of ( SchemaLoader . standardCFMD ( ks4 , <str> ) , SchemaLoader . superCFMD ( ks4 , <str> , BytesType . instance ) , SchemaLoader . superCFMD ( ks4 , <str> , TimeUUIDType . instance ) , SchemaLoader . superCFMD ( ks4 , <str> , TimeUUIDType . instance , BytesType . instance ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks5 , KeyspaceParams . simple ( <int> ) , Tables . of ( SchemaLoader . standardCFMD ( ks5 , <str> ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks6 , KeyspaceParams . simple ( <int> ) , Tables . of ( SchemaLoader . keysIndexCFMD ( ks6 , <str> , true ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks_rcs , KeyspaceParams . simple ( <int> ) , Tables . of ( SchemaLoader . standardCFMD ( ks_rcs , <str> ) . caching ( CachingParams . CACHE_NOTHING ) , SchemaLoader . standardCFMD ( ks_rcs , <str> ) . caching ( CachingParams . CACHE_EVERYTHING ) , SchemaLoader . standardCFMD ( ks_rcs , <str> ) . caching ( new CachingParams ( true , <int> ) ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks_nocommit , KeyspaceParams . simpleTransient ( <int> ) , Tables . of ( SchemaLoader . standardCFMD ( ks_nocommit , <str> ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks_prsi , KeyspaceParams . simple ( <int> ) , Tables . of ( SchemaLoader . perRowIndexedCFMD ( ks_prsi , <str> ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( ks_cql , KeyspaceParams . simple ( <int> ) , Tables . of ( CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> , ks_cql ) , CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> , ks_cql ) , CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> + <str> , ks_cql ) , CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> , ks_cql ) , CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> , ks_cql ) ) ) ) ; keyspaces . add ( KeyspaceMetadata . create ( <str> , KeyspaceParams . nts ( <str> , <int> , <str> , <int> ) ) ) ; keyspaces . add ( keyspaceWithDroppedCollections ( ) ) ; keyspaces . add ( keyspaceWithTriggers ( ) ) ; keyspaces . add ( keyspaceWithUDTs ( ) ) ; keyspaces . add ( keyspaceWithUDFs ( ) ) ; keyspaces . add ( keyspaceWithUDFsAndUDTs ( ) ) ; keyspaces . add ( keyspaceWithUDAs ( ) ) ; keyspaces . add ( keyspaceWithUDAsAndUDTs ( ) ) ; return keyspaces . build ( ) ; } private static KeyspaceMetadata keyspaceWithDroppedCollections ( ) { String keyspace = KEYSPACE_PREFIX + <str> ; CFMetaData table = CFMetaData . compile ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> , keyspace ) ; String [ ] collectionColumnNames = { <str> , <str> , <str> , <str> } ; for ( String name : collectionColumnNames ) { ColumnDefinition column = table . getColumnDefinition ( bytes ( name ) ) ; table . recordColumnDrop ( column ) ; table . removeColumnDefinition ( column ) ; } return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( <int> ) , Tables . of ( table ) ) ; } private static KeyspaceMetadata keyspaceWithTriggers ( ) { String keyspace = KEYSPACE_PREFIX + <str> ; Triggers . Builder triggers = Triggers . builder ( ) ; CFMetaData table = SchemaLoader . standardCFMD ( keyspace , <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) triggers . add ( new TriggerMetadata ( <str> + i , <str> + i ) ) ; table . triggers ( triggers . build ( ) ) ; return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( <int> ) , Tables . of ( table ) ) ; } private static KeyspaceMetadata keyspaceWithUDTs ( ) { String keyspace = KEYSPACE_PREFIX + <str> ; UserType udt1 = new UserType ( keyspace , bytes ( <str> ) , new ArrayList < ByteBuffer > ( ) { { add ( bytes ( <str> ) ) ; add ( bytes ( <str> ) ) ; } } , new ArrayList < AbstractType < ? > > ( ) { { add ( UTF8Type . instance ) ; add ( Int32Type . instance ) ; } } ) ; UserType udt2 = new UserType ( keyspace , bytes ( <str> ) , new ArrayList < ByteBuffer > ( ) { { add ( bytes ( <str> ) ) ; add ( bytes ( <str> ) ) ; } } , new ArrayList < AbstractType < ? > > ( ) { { add ( BytesType . instance ) ; add ( BooleanType . instance ) ; } } ) ; UserType udt3 = new UserType ( keyspace , bytes ( <str> ) , new ArrayList < ByteBuffer > ( ) { { add ( bytes ( <str> ) ) ; } } , new ArrayList < AbstractType < ? > > ( ) { { add ( AsciiType . instance ) ; } } ) ; return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( <int> ) , Tables . none ( ) , Views . none ( ) , Types . of ( udt1 , udt2 , udt3 ) , Functions . none ( ) ) ; } private static KeyspaceMetadata keyspaceWithUDFs ( ) { String keyspace = KEYSPACE_PREFIX + <str> ; UDFunction udf1 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) , new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( BytesType . instance , Int32Type . instance ) , LongType . instance , false , <str> , <str> ) ; UDFunction udf2 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) , new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( AsciiType . instance , LongType . instance ) , Int32Type . instance , true , <str> , <str> ) ; UDFunction udf3 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( UTF8Type . instance ) , BooleanType . instance , false , <str> , <str> ) ; return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( <int> ) , Tables . none ( ) , Views . none ( ) , Types . none ( ) , Functions . of ( udf1 , udf2 , udf3 ) ) ; } private static KeyspaceMetadata keyspaceWithUDAs ( ) { String keyspace = KEYSPACE_PREFIX + <str> ; UDFunction udf1 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) , new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( Int32Type . instance , Int32Type . instance ) , Int32Type . instance , false , <str> , <str> ) ; UDFunction udf2 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) , new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( LongType . instance , Int32Type . instance ) , LongType . instance , false , <str> , <str> ) ; UDFunction udf3 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( LongType . instance ) , DoubleType . instance , false , <str> , <str> ) ; Functions udfs = Functions . builder ( ) . add ( udf1 ) . add ( udf2 ) . add ( udf3 ) . build ( ) ; UDAggregate uda1 = UDAggregate . create ( udfs , new FunctionName ( keyspace , <str> ) , ImmutableList . of ( udf1 . argTypes ( ) . get ( <int> ) ) , udf1 . returnType ( ) , udf1 . name ( ) , null , udf1 . argTypes ( ) . get ( <int> ) , null ) ; UDAggregate uda2 = UDAggregate . create ( udfs , new FunctionName ( keyspace , <str> ) , ImmutableList . of ( udf2 . argTypes ( ) . get ( <int> ) ) , udf3 . returnType ( ) , udf2 . name ( ) , udf3 . name ( ) , udf2 . argTypes ( ) . get ( <int> ) , LongType . instance . decompose ( <int> L ) ) ; return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( <int> ) , Tables . none ( ) , Views . none ( ) , Types . none ( ) , Functions . of ( udf1 , udf2 , udf3 , uda1 , uda2 ) ) ; } private static KeyspaceMetadata keyspaceWithUDFsAndUDTs ( ) { String keyspace = KEYSPACE_PREFIX + <str> ; UserType udt1 = new UserType ( keyspace , bytes ( <str> ) , new ArrayList < ByteBuffer > ( ) { { add ( bytes ( <str> ) ) ; add ( bytes ( <str> ) ) ; } } , new ArrayList < AbstractType < ? > > ( ) { { add ( UTF8Type . instance ) ; add ( Int32Type . instance ) ; } } ) ; UserType udt2 = new UserType ( keyspace , bytes ( <str> ) , new ArrayList < ByteBuffer > ( ) { { add ( bytes ( <str> ) ) ; add ( bytes ( <str> ) ) ; } } , new ArrayList < AbstractType < ? > > ( ) { { add ( ListType . getInstance ( udt1 , false ) ) ; add ( Int32Type . instance ) ; } } ) ; UDFunction udf1 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) , new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( udt1 , udt2 ) , LongType . instance , false , <str> , <str> ) ; UDFunction udf2 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) , new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( AsciiType . instance , LongType . instance ) , Int32Type . instance , true , <str> , <str> ) ; UDFunction udf3 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( new TupleType ( Arrays . asList ( udt1 , udt2 ) ) ) , BooleanType . instance , false , <str> , <str> ) ; return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( <int> ) , Tables . none ( ) , Views . none ( ) , Types . of ( udt1 , udt2 ) , Functions . of ( udf1 , udf2 , udf3 ) ) ; } private static KeyspaceMetadata keyspaceWithUDAsAndUDTs ( ) { String keyspace = KEYSPACE_PREFIX + <str> ; UserType udt1 = new UserType ( keyspace , bytes ( <str> ) , new ArrayList < ByteBuffer > ( ) { { add ( bytes ( <str> ) ) ; add ( bytes ( <str> ) ) ; } } , new ArrayList < AbstractType < ? > > ( ) { { add ( UTF8Type . instance ) ; add ( Int32Type . instance ) ; } } ) ; UserType udt2 = new UserType ( keyspace , bytes ( <str> ) , new ArrayList < ByteBuffer > ( ) { { add ( bytes ( <str> ) ) ; add ( bytes ( <str> ) ) ; } } , new ArrayList < AbstractType < ? > > ( ) { { add ( ListType . getInstance ( udt1 , false ) ) ; add ( Int32Type . instance ) ; } } ) ; UDFunction udf1 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) , new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( udt1 , udt2 ) , udt1 , false , <str> , <str> ) ; UDFunction udf2 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) , new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( udt2 , udt1 ) , udt2 , false , <str> , <str> ) ; UDFunction udf3 = UDFunction . create ( new FunctionName ( keyspace , <str> ) , ImmutableList . of ( new ColumnIdentifier ( <str> , false ) ) , ImmutableList . of ( udt2 ) , DoubleType . instance , false , <str> , <str> ) ; Functions udfs = Functions . builder ( ) . add ( udf1 ) . add ( udf2 ) . add ( udf3 ) . build ( ) ; UDAggregate uda1 = UDAggregate . create ( udfs , new FunctionName ( keyspace , <str> ) , ImmutableList . of ( udf1 . argTypes ( ) . get ( <int> ) ) , udf1 . returnType ( ) , udf1 . name ( ) , null , udf1 . argTypes ( ) . get ( <int> ) , null ) ; ByteBuffer twoNullEntries = ByteBuffer . allocate ( <int> ) ; twoNullEntries . putInt ( - <int> ) ; twoNullEntries . putInt ( - <int> ) ; twoNullEntries . flip ( ) ; UDAggregate uda2 = UDAggregate . create ( udfs , new FunctionName ( keyspace , <str> ) , ImmutableList . of ( udf2 . argTypes ( ) . get ( <int> ) ) , udf3 . returnType ( ) , udf2 . name ( ) , udf3 . name ( ) , udf2 . argTypes ( ) . get ( <int> ) , twoNullEntries ) ; return KeyspaceMetadata . create ( keyspace , KeyspaceParams . simple ( <int> ) , Tables . none ( ) , Views . none ( ) , Types . of ( udt1 , udt2 ) , Functions . of ( udf1 , udf2 , udf3 , uda1 , uda2 ) ) ; } private static void legacySerializeKeyspace ( KeyspaceMetadata keyspace ) { makeLegacyCreateKeyspaceMutation ( keyspace , TIMESTAMP ) . apply ( ) ; } private static Mutation makeLegacyCreateKeyspaceMutation ( KeyspaceMetadata keyspace , long timestamp ) { RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyKeyspaces , timestamp , keyspace . name ) ; adder . add ( <str> , keyspace . params . durableWrites ) . add ( <str> , keyspace . params . replication . klass . getName ( ) ) . add ( <str> , json ( keyspace . params . replication . options ) ) ; Mutation mutation = adder . build ( ) ; keyspace . tables . forEach ( table - > addTableToSchemaMutation ( table , timestamp , true , mutation ) ) ; keyspace . types . forEach ( type - > addTypeToSchemaMutation ( type , timestamp , mutation ) ) ; keyspace . functions . udfs ( ) . forEach ( udf - > addFunctionToSchemaMutation ( udf , timestamp , mutation ) ) ; keyspace . functions . udas ( ) . forEach ( uda - > addAggregateToSchemaMutation ( uda , timestamp , mutation ) ) ; return mutation ; } private static void addTableToSchemaMutation ( CFMetaData table , long timestamp , boolean withColumnsAndTriggers , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyColumnfamilies , timestamp , mutation ) . clustering ( table . cfName ) ; adder . add ( <str> , table . cfId ) . add ( <str> , table . isSuper ( ) ? <str> : <str> ) ; if ( table . isSuper ( ) ) { adder . add ( <str> , table . comparator . subtype ( <int> ) . toString ( ) ) . add ( <str> , ( ( MapType ) table . compactValueColumn ( ) . type ) . getKeysType ( ) . toString ( ) ) ; } else { adder . add ( <str> , LegacyLayout . makeLegacyComparator ( table ) . toString ( ) ) ; } adder . add ( <str> , table . params . bloomFilterFpChance ) . add ( <str> , cachingToString ( table . params . caching ) ) . add ( <str> , table . params . comment ) . add ( <str> , table . params . compaction . klass ( ) . getName ( ) ) . add ( <str> , json ( table . params . compaction . options ( ) ) ) . add ( <str> , json ( ThriftConversion . compressionParametersToThrift ( table . params . compression ) ) ) . add ( <str> , table . params . defaultTimeToLive ) . add ( <str> , table . params . gcGraceSeconds ) . add ( <str> , table . getKeyValidator ( ) . toString ( ) ) . add ( <str> , table . params . dcLocalReadRepairChance ) . add ( <str> , table . params . compaction . maxCompactionThreshold ( ) ) . add ( <str> , table . params . maxIndexInterval ) . add ( <str> , table . params . memtableFlushPeriodInMs ) . add ( <str> , table . params . compaction . minCompactionThreshold ( ) ) . add ( <str> , table . params . minIndexInterval ) . add ( <str> , table . params . readRepairChance ) . add ( <str> , table . params . speculativeRetry . toString ( ) ) ; for ( Map . Entry < ByteBuffer , CFMetaData . DroppedColumn > entry : table . getDroppedColumns ( ) . entrySet ( ) ) { String name = UTF8Type . instance . getString ( entry . getKey ( ) ) ; CFMetaData . DroppedColumn column = entry . getValue ( ) ; adder . addMapEntry ( <str> , name , column . droppedTime ) ; } adder . add ( <str> , table . isDense ( ) ) ; adder . add ( <str> , table . makeLegacyDefaultValidator ( ) . toString ( ) ) ; if ( withColumnsAndTriggers ) { for ( ColumnDefinition column : table . allColumns ( ) ) addColumnToSchemaMutation ( table , column , timestamp , mutation ) ; for ( TriggerMetadata trigger : table . getTriggers ( ) ) addTriggerToSchemaMutation ( table , trigger , timestamp , mutation ) ; } adder . build ( ) ; } private static String cachingToString ( CachingParams caching ) { return format ( <str> , caching . keysAsString ( ) , caching . rowsPerPartitionAsString ( ) ) ; } private static void addColumnToSchemaMutation ( CFMetaData table , ColumnDefinition column , long timestamp , Mutation mutation ) { String name = table . isDense ( ) & & column . kind = = ColumnDefinition . Kind . REGULAR & & column . type instanceof EmptyType ? <str> : column . name . toString ( ) ; final RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyColumns , timestamp , mutation ) . clustering ( table . cfName , name ) ; adder . add ( <str> , column . type . toString ( ) ) . add ( <str> , serializeKind ( column . kind , table . isDense ( ) ) ) . add ( <str> , column . position ( ) ) ; Optional < IndexMetadata > index = findIndexForColumn ( table . getIndexes ( ) , table , column ) ; if ( index . isPresent ( ) ) { IndexMetadata i = index . get ( ) ; adder . add ( <str> , i . name ) ; adder . add ( <str> , i . kind . toString ( ) ) ; adder . add ( <str> , json ( i . options ) ) ; } else { adder . add ( <str> , null ) ; adder . add ( <str> , null ) ; adder . add ( <str> , null ) ; } adder . build ( ) ; } private static Optional < IndexMetadata > findIndexForColumn ( Indexes indexes , CFMetaData table , ColumnDefinition column ) { for ( IndexMetadata index : indexes ) if ( CassandraIndex . parseTarget ( table , index ) . left . equals ( column ) ) return Optional . of ( index ) ; return Optional . empty ( ) ; } private static String serializeKind ( ColumnDefinition . Kind kind , boolean isDense ) { if ( kind = = ColumnDefinition . Kind . CLUSTERING ) return <str> ; if ( kind = = ColumnDefinition . Kind . REGULAR & & isDense ) return <str> ; return kind . toString ( ) . toLowerCase ( ) ; } private static void addTriggerToSchemaMutation ( CFMetaData table , TriggerMetadata trigger , long timestamp , Mutation mutation ) { new RowUpdateBuilder ( SystemKeyspace . LegacyTriggers , timestamp , mutation ) . clustering ( table . cfName , trigger . name ) . addMapEntry ( <str> , <str> , trigger . classOption ) . build ( ) ; } private static void addTypeToSchemaMutation ( UserType type , long timestamp , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyUsertypes , timestamp , mutation ) . clustering ( type . getNameAsString ( ) ) ; adder . resetCollection ( <str> ) . resetCollection ( <str> ) ; for ( int i = <int> ; i < type . size ( ) ; i + + ) { adder . addListEntry ( <str> , type . fieldName ( i ) ) . addListEntry ( <str> , type . fieldType ( i ) . toString ( ) ) ; } adder . build ( ) ; } private static void addFunctionToSchemaMutation ( UDFunction function , long timestamp , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyFunctions , timestamp , mutation ) . clustering ( function . name ( ) . name , functionSignatureWithTypes ( function ) ) ; adder . add ( <str> , function . body ( ) ) . add ( <str> , function . language ( ) ) . add ( <str> , function . returnType ( ) . toString ( ) ) . add ( <str> , function . isCalledOnNullInput ( ) ) ; adder . resetCollection ( <str> ) . resetCollection ( <str> ) ; for ( int i = <int> ; i < function . argNames ( ) . size ( ) ; i + + ) { adder . addListEntry ( <str> , function . argNames ( ) . get ( i ) . bytes ) . addListEntry ( <str> , function . argTypes ( ) . get ( i ) . toString ( ) ) ; } adder . build ( ) ; } private static void addAggregateToSchemaMutation ( UDAggregate aggregate , long timestamp , Mutation mutation ) { RowUpdateBuilder adder = new RowUpdateBuilder ( SystemKeyspace . LegacyAggregates , timestamp , mutation ) . clustering ( aggregate . name ( ) . name , functionSignatureWithTypes ( aggregate ) ) ; adder . resetCollection ( <str> ) ; adder . add ( <str> , aggregate . returnType ( ) . toString ( ) ) . add ( <str> , aggregate . stateFunction ( ) . name ( ) . name ) ; if ( aggregate . stateType ( ) ! = null ) adder . add ( <str> , aggregate . stateType ( ) . toString ( ) ) ; if ( aggregate . finalFunction ( ) ! = null ) adder . add ( <str> , aggregate . finalFunction ( ) . name ( ) . name ) ; if ( aggregate . initialCondition ( ) ! = null ) adder . add ( <str> , aggregate . initialCondition ( ) ) ; for ( AbstractType < ? > argType : aggregate . argTypes ( ) ) adder . addListEntry ( <str> , argType . toString ( ) ) ; adder . build ( ) ; } public static ByteBuffer functionSignatureWithTypes ( AbstractFunction fun ) { List < String > arguments = fun . argTypes ( ) . stream ( ) . map ( argType - > argType . asCQL3Type ( ) . toString ( ) ) . collect ( Collectors . toList ( ) ) ; return ListType . getInstance ( UTF8Type . instance , false ) . decompose ( arguments ) ; } } 
