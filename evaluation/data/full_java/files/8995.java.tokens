package org . elasticsearch . test . engine ; import org . apache . lucene . index . FilterDirectoryReader ; import org . apache . lucene . search . IndexSearcher ; import org . apache . lucene . search . SearcherManager ; import org . elasticsearch . index . engine . EngineConfig ; import org . elasticsearch . index . engine . EngineException ; import org . elasticsearch . index . engine . InternalEngine ; import java . io . IOException ; final class MockInternalEngine extends InternalEngine { private MockEngineSupport support ; private final boolean randomizeFlushOnClose ; private Class < ? extends FilterDirectoryReader > wrapperClass ; MockInternalEngine ( EngineConfig config , boolean skipInitialTranslogRecovery , Class < ? extends FilterDirectoryReader > wrapper ) throws EngineException { super ( config , skipInitialTranslogRecovery ) ; randomizeFlushOnClose = config . getIndexSettings ( ) . isOnSharedFilesystem ( ) = = false ; wrapperClass = wrapper ; } private synchronized MockEngineSupport support ( ) { if ( support = = null ) { support = new MockEngineSupport ( config ( ) , wrapperClass ) ; } return support ; } @Override public void close ( ) throws IOException { switch ( support ( ) . flushOrClose ( this , MockEngineSupport . CloseAction . CLOSE ) ) { case FLUSH_AND_CLOSE : super . flushAndClose ( ) ; break ; case CLOSE : super . close ( ) ; break ; } } @Override public void flushAndClose ( ) throws IOException { if ( randomizeFlushOnClose ) { switch ( support ( ) . flushOrClose ( this , MockEngineSupport . CloseAction . FLUSH_AND_CLOSE ) ) { case FLUSH_AND_CLOSE : super . flushAndClose ( ) ; break ; case CLOSE : super . close ( ) ; break ; } } else { super . flushAndClose ( ) ; } } @Override protected Searcher newSearcher ( String source , IndexSearcher searcher , SearcherManager manager ) throws EngineException { final Searcher engineSearcher = super . newSearcher ( source , searcher , manager ) ; return support ( ) . wrapSearcher ( source , engineSearcher , searcher , manager ) ; } } 
