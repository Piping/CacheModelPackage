package org . elasticsearch . cluster . routing ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import java . io . IOException ; public class UnassignedInfo implements ToXContent , Writeable < UnassignedInfo > { public static final FormatDateTimeFormatter DATE_TIME_FORMATTER = Joda . forPattern ( <str> ) ; public static final String INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING = <str> ; private static final TimeValue DEFAULT_DELAYED_NODE_LEFT_TIMEOUT = TimeValue . timeValueMinutes ( <int> ) ; public enum Reason { INDEX_CREATED , CLUSTER_RECOVERED , INDEX_REOPENED , DANGLING_INDEX_IMPORTED , NEW_INDEX_RESTORED , EXISTING_INDEX_RESTORED , REPLICA_ADDED , ALLOCATION_FAILED , NODE_LEFT , REROUTE_CANCELLED , REINITIALIZED , REALLOCATED_REPLICA ; } private final Reason reason ; private final long unassignedTimeMillis ; private final long unassignedTimeNanos ; private volatile long lastComputedLeftDelayNanos = <int> l ; private final String message ; private final Throwable failure ; public UnassignedInfo ( Reason reason , String message ) { this ( reason , message , null , System . nanoTime ( ) , System . currentTimeMillis ( ) ) ; } public UnassignedInfo ( Reason reason , @Nullable String message , @Nullable Throwable failure , long unassignedTimeNanos , long unassignedTimeMillis ) { this . reason = reason ; this . unassignedTimeMillis = unassignedTimeMillis ; this . unassignedTimeNanos = unassignedTimeNanos ; this . message = message ; this . failure = failure ; assert ! ( message = = null & & failure ! = null ) : <str> ; } UnassignedInfo ( StreamInput in ) throws IOException { this . reason = Reason . values ( ) [ ( int ) in . readByte ( ) ] ; this . unassignedTimeMillis = in . readLong ( ) ; this . unassignedTimeNanos = System . nanoTime ( ) ; this . message = in . readOptionalString ( ) ; this . failure = in . readThrowable ( ) ; } public void writeTo ( StreamOutput out ) throws IOException { out . writeByte ( ( byte ) reason . ordinal ( ) ) ; out . writeLong ( unassignedTimeMillis ) ; out . writeOptionalString ( message ) ; out . writeThrowable ( failure ) ; } public UnassignedInfo readFrom ( StreamInput in ) throws IOException { return new UnassignedInfo ( in ) ; } public Reason getReason ( ) { return this . reason ; } public long getUnassignedTimeInMillis ( ) { return this . unassignedTimeMillis ; } public long getUnassignedTimeInNanos ( ) { return this . unassignedTimeNanos ; } @Nullable public String getMessage ( ) { return this . message ; } @Nullable public Throwable getFailure ( ) { return failure ; } @Nullable public String getDetails ( ) { if ( message = = null ) { return null ; } return message + ( failure = = null ? <str> : <str> + ExceptionsHelper . detailedMessage ( failure ) ) ; } public long getAllocationDelayTimeoutSettingNanos ( Settings settings , Settings indexSettings ) { if ( reason ! = Reason . NODE_LEFT ) { return <int> ; } TimeValue delayTimeout = indexSettings . getAsTime ( INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , settings . getAsTime ( INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , DEFAULT_DELAYED_NODE_LEFT_TIMEOUT ) ) ; return Math . max ( <int> l , delayTimeout . nanos ( ) ) ; } public long getLastComputedLeftDelayNanos ( ) { return lastComputedLeftDelayNanos ; } public long updateDelay ( long nanoTimeNow , Settings settings , Settings indexSettings ) { long delayTimeoutNanos = getAllocationDelayTimeoutSettingNanos ( settings , indexSettings ) ; final long newComputedLeftDelayNanos ; if ( delayTimeoutNanos = = <int> l ) { newComputedLeftDelayNanos = <int> l ; } else { assert nanoTimeNow > = unassignedTimeNanos ; newComputedLeftDelayNanos = Math . max ( <int> L , delayTimeoutNanos - ( nanoTimeNow - unassignedTimeNanos ) ) ; } lastComputedLeftDelayNanos = newComputedLeftDelayNanos ; return newComputedLeftDelayNanos ; } public static int getNumberOfDelayedUnassigned ( ClusterState state ) { int count = <int> ; for ( ShardRouting shard : state . routingTable ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) ) { if ( shard . primary ( ) = = false ) { long delay = shard . unassignedInfo ( ) . getLastComputedLeftDelayNanos ( ) ; if ( delay > <int> ) { count + + ; } } } return count ; } public static long findSmallestDelayedAllocationSettingNanos ( Settings settings , ClusterState state ) { long minDelaySetting = Long . MAX_VALUE ; for ( ShardRouting shard : state . routingTable ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) ) { if ( shard . primary ( ) = = false ) { IndexMetaData indexMetaData = state . metaData ( ) . index ( shard . getIndex ( ) ) ; boolean delayed = shard . unassignedInfo ( ) . getLastComputedLeftDelayNanos ( ) > <int> ; long delayTimeoutSetting = shard . unassignedInfo ( ) . getAllocationDelayTimeoutSettingNanos ( settings , indexMetaData . getSettings ( ) ) ; if ( delayed & & delayTimeoutSetting > <int> & & delayTimeoutSetting < minDelaySetting ) { minDelaySetting = delayTimeoutSetting ; } } } return minDelaySetting = = Long . MAX_VALUE ? <int> l : minDelaySetting ; } public static long findNextDelayedAllocationIn ( ClusterState state ) { long nextDelay = Long . MAX_VALUE ; for ( ShardRouting shard : state . routingTable ( ) . shardsWithState ( ShardRoutingState . UNASSIGNED ) ) { if ( shard . primary ( ) = = false ) { long nextShardDelay = shard . unassignedInfo ( ) . getLastComputedLeftDelayNanos ( ) ; if ( nextShardDelay > <int> & & nextShardDelay < nextDelay ) { nextDelay = nextShardDelay ; } } } return nextDelay = = Long . MAX_VALUE ? <int> l : nextDelay ; } public String shortSummary ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( reason ) . append ( <str> ) ; sb . append ( <str> ) . append ( DATE_TIME_FORMATTER . printer ( ) . print ( unassignedTimeMillis ) ) . append ( <str> ) ; String details = getDetails ( ) ; if ( details ! = null ) { sb . append ( <str> ) . append ( details ) . append ( <str> ) ; } return sb . toString ( ) ; } @Override public String toString ( ) { return <str> + shortSummary ( ) + <str> ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( <str> ) ; builder . field ( <str> , reason ) ; builder . field ( <str> , DATE_TIME_FORMATTER . printer ( ) . print ( unassignedTimeMillis ) ) ; String details = getDetails ( ) ; if ( details ! = null ) { builder . field ( <str> , details ) ; } builder . endObject ( ) ; return builder ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } UnassignedInfo that = ( UnassignedInfo ) o ; if ( unassignedTimeMillis ! = that . unassignedTimeMillis ) { return false ; } if ( reason ! = that . reason ) { return false ; } if ( message ! = null ? ! message . equals ( that . message ) : that . message ! = null ) { return false ; } return ! ( failure ! = null ? ! failure . equals ( that . failure ) : that . failure ! = null ) ; } @Override public int hashCode ( ) { int result = reason ! = null ? reason . hashCode ( ) : <int> ; result = <int> * result + Long . hashCode ( unassignedTimeMillis ) ; result = <int> * result + ( message ! = null ? message . hashCode ( ) : <int> ) ; result = <int> * result + ( failure ! = null ? failure . hashCode ( ) : <int> ) ; return result ; } } 
