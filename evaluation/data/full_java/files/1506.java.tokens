package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . Random ; import java . util . UUID ; import java . util . concurrent . ThreadLocalRandom ; import junit . framework . Assert ; import org . apache . cassandra . serializers . MarshalException ; import org . junit . Test ; import static org . junit . Assert . assertEquals ; import org . apache . cassandra . utils . UUIDGen ; public class TimeUUIDTypeTest { TimeUUIDType timeUUIDType = new TimeUUIDType ( ) ; @Test public void testEquality ( ) { UUID a = UUIDGen . getTimeUUID ( ) ; UUID b = new UUID ( a . getMostSignificantBits ( ) , a . getLeastSignificantBits ( ) ) ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( a ) ) ) ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( b ) ) ) ; assertEquals ( <int> , timeUUIDType . compare ( ByteBuffer . wrap ( UUIDGen . decompose ( a ) ) , ByteBuffer . wrap ( UUIDGen . decompose ( b ) ) ) ) ; } @Test public void testSmaller ( ) { UUID a = UUIDGen . getTimeUUID ( ) ; UUID b = UUIDGen . getTimeUUID ( ) ; UUID c = UUIDGen . getTimeUUID ( ) ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( a ) ) ) ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( b ) ) ) ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( c ) ) ) ; assert timeUUIDType . compare ( ByteBuffer . wrap ( UUIDGen . decompose ( a ) ) , ByteBuffer . wrap ( UUIDGen . decompose ( b ) ) ) < <int> ; assert timeUUIDType . compare ( ByteBuffer . wrap ( UUIDGen . decompose ( b ) ) , ByteBuffer . wrap ( UUIDGen . decompose ( c ) ) ) < <int> ; assert timeUUIDType . compare ( ByteBuffer . wrap ( UUIDGen . decompose ( a ) ) , ByteBuffer . wrap ( UUIDGen . decompose ( c ) ) ) < <int> ; } @Test public void testBigger ( ) { UUID a = UUIDGen . getTimeUUID ( ) ; UUID b = UUIDGen . getTimeUUID ( ) ; UUID c = UUIDGen . getTimeUUID ( ) ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( a ) ) ) ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( b ) ) ) ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( c ) ) ) ; assert timeUUIDType . compare ( ByteBuffer . wrap ( UUIDGen . decompose ( c ) ) , ByteBuffer . wrap ( UUIDGen . decompose ( b ) ) ) > <int> ; assert timeUUIDType . compare ( ByteBuffer . wrap ( UUIDGen . decompose ( b ) ) , ByteBuffer . wrap ( UUIDGen . decompose ( a ) ) ) > <int> ; assert timeUUIDType . compare ( ByteBuffer . wrap ( UUIDGen . decompose ( c ) ) , ByteBuffer . wrap ( UUIDGen . decompose ( a ) ) ) > <int> ; } @Test public void testTimestampComparison ( ) { compareAll ( UUIDTypeTest . random ( <int> , ( byte ) <hex> ) ) ; for ( ByteBuffer [ ] permutations : UUIDTypeTest . permutations ( <int> , ( byte ) <hex> ) ) compareAll ( permutations ) ; } private void compareAll ( ByteBuffer [ ] uuids ) { for ( int i = <int> ; i < uuids . length ; i + + ) { for ( int j = i + <int> ; j < uuids . length ; j + + ) { ByteBuffer bi = uuids [ i ] ; ByteBuffer bj = uuids [ j ] ; long i0 = UUIDGen . getUUID ( bi ) . timestamp ( ) ; long i1 = UUIDGen . getUUID ( bj ) . timestamp ( ) ; int c = timeUUIDType . compare ( bi , bj ) ; if ( i0 = = i1 ) Assert . assertTrue ( isComparisonEquivalent ( bi . compareTo ( bj ) , c ) ) ; else Assert . assertTrue ( isComparisonEquivalent ( Long . compare ( i0 , i1 ) , c ) ) ; Assert . assertTrue ( isComparisonEquivalent ( compareV1 ( bi , bj ) , c ) ) ; } } } private static int compareV1 ( ByteBuffer o1 , ByteBuffer o2 ) { if ( ! o1 . hasRemaining ( ) | | ! o2 . hasRemaining ( ) ) return o1 . hasRemaining ( ) ? <int> : o2 . hasRemaining ( ) ? - <int> : <int> ; int res = compareTimestampBytes ( o1 , o2 ) ; if ( res ! = <int> ) return res ; return o1 . compareTo ( o2 ) ; } private static int compareTimestampBytes ( ByteBuffer o1 , ByteBuffer o2 ) { int o1Pos = o1 . position ( ) ; int o2Pos = o2 . position ( ) ; int d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) return d ; d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) return d ; d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) return d ; d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) return d ; d = ( o1 . get ( o1Pos ) & <hex> ) - ( o2 . get ( o2Pos ) & <hex> ) ; if ( d ! = <int> ) return d ; d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) return d ; d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) return d ; return ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; } private static boolean isComparisonEquivalent ( int c1 , int c2 ) { c1 = c1 < - <int> ? - <int> : c1 > <int> ? <int> : c1 ; c2 = c2 < - <int> ? - <int> : c2 > <int> ? <int> : c2 ; return c1 = = c2 ; } @Test public void testValidTimeVersion ( ) { UUID uuid1 = UUID . fromString ( <str> ) ; assert uuid1 . version ( ) = = <int> ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( uuid1 ) ) ) ; } @Test ( expected = MarshalException . class ) public void testInvalidTimeVersion ( ) { UUID uuid2 = UUID . fromString ( <str> ) ; assert uuid2 . version ( ) = = <int> ; timeUUIDType . validate ( ByteBuffer . wrap ( UUIDGen . decompose ( uuid2 ) ) ) ; } } 
