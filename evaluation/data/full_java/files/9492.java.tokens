package com . google . common . primitives ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import java . math . BigInteger ; import java . util . Arrays ; import java . util . Comparator ; import javax . annotation . CheckReturnValue ; @Beta @GwtCompatible public final class UnsignedLongs { private UnsignedLongs ( ) { } public static final long MAX_VALUE = - <int> ; private static long flip ( long a ) { return a ^ Long . MIN_VALUE ; } @CheckReturnValue public static int compare ( long a , long b ) { return Longs . compare ( flip ( a ) , flip ( b ) ) ; } @CheckReturnValue public static long min ( long . . . array ) { checkArgument ( array . length > <int> ) ; long min = flip ( array [ <int> ] ) ; for ( int i = <int> ; i < array . length ; i + + ) { long next = flip ( array [ i ] ) ; if ( next < min ) { min = next ; } } return flip ( min ) ; } @CheckReturnValue public static long max ( long . . . array ) { checkArgument ( array . length > <int> ) ; long max = flip ( array [ <int> ] ) ; for ( int i = <int> ; i < array . length ; i + + ) { long next = flip ( array [ i ] ) ; if ( next > max ) { max = next ; } } return flip ( max ) ; } @CheckReturnValue public static String join ( String separator , long . . . array ) { checkNotNull ( separator ) ; if ( array . length = = <int> ) { return <str> ; } StringBuilder builder = new StringBuilder ( array . length * <int> ) ; builder . append ( toString ( array [ <int> ] ) ) ; for ( int i = <int> ; i < array . length ; i + + ) { builder . append ( separator ) . append ( toString ( array [ i ] ) ) ; } return builder . toString ( ) ; } @CheckReturnValue public static Comparator < long [ ] > lexicographicalComparator ( ) { return LexicographicalComparator . INSTANCE ; } enum LexicographicalComparator implements Comparator < long [ ] > { INSTANCE ; @Override public int compare ( long [ ] left , long [ ] right ) { int minLength = Math . min ( left . length , right . length ) ; for ( int i = <int> ; i < minLength ; i + + ) { if ( left [ i ] ! = right [ i ] ) { return UnsignedLongs . compare ( left [ i ] , right [ i ] ) ; } } return left . length - right . length ; } @Override public String toString ( ) { return <str> ; } } @CheckReturnValue public static long divide ( long dividend , long divisor ) { if ( divisor < <int> ) { if ( compare ( dividend , divisor ) < <int> ) { return <int> ; } else { return <int> ; } } if ( dividend > = <int> ) { return dividend / divisor ; } long quotient = ( ( dividend > > > <int> ) / divisor ) < < <int> ; long rem = dividend - quotient * divisor ; return quotient + ( compare ( rem , divisor ) > = <int> ? <int> : <int> ) ; } @CheckReturnValue public static long remainder ( long dividend , long divisor ) { if ( divisor < <int> ) { if ( compare ( dividend , divisor ) < <int> ) { return dividend ; } else { return dividend - divisor ; } } if ( dividend > = <int> ) { return dividend % divisor ; } long quotient = ( ( dividend > > > <int> ) / divisor ) < < <int> ; long rem = dividend - quotient * divisor ; return rem - ( compare ( rem , divisor ) > = <int> ? divisor : <int> ) ; } public static long parseUnsignedLong ( String s ) { return parseUnsignedLong ( s , <int> ) ; } public static long decode ( String stringValue ) { ParseRequest request = ParseRequest . fromString ( stringValue ) ; try { return parseUnsignedLong ( request . rawValue , request . radix ) ; } catch ( NumberFormatException e ) { NumberFormatException decodeException = new NumberFormatException ( <str> + stringValue ) ; decodeException . initCause ( e ) ; throw decodeException ; } } public static long parseUnsignedLong ( String s , int radix ) { checkNotNull ( s ) ; if ( s . length ( ) = = <int> ) { throw new NumberFormatException ( <str> ) ; } if ( radix < Character . MIN_RADIX | | radix > Character . MAX_RADIX ) { throw new NumberFormatException ( <str> + radix ) ; } int max_safe_pos = maxSafeDigits [ radix ] - <int> ; long value = <int> ; for ( int pos = <int> ; pos < s . length ( ) ; pos + + ) { int digit = Character . digit ( s . charAt ( pos ) , radix ) ; if ( digit = = - <int> ) { throw new NumberFormatException ( s ) ; } if ( pos > max_safe_pos & & overflowInParse ( value , digit , radix ) ) { throw new NumberFormatException ( <str> + s ) ; } value = ( value * radix ) + digit ; } return value ; } private static boolean overflowInParse ( long current , int digit , int radix ) { if ( current > = <int> ) { if ( current < maxValueDivs [ radix ] ) { return false ; } if ( current > maxValueDivs [ radix ] ) { return true ; } return ( digit > maxValueMods [ radix ] ) ; } return true ; } @CheckReturnValue public static String toString ( long x ) { return toString ( x , <int> ) ; } @CheckReturnValue public static String toString ( long x , int radix ) { checkArgument ( radix > = Character . MIN_RADIX & & radix < = Character . MAX_RADIX , <str> , radix ) ; if ( x = = <int> ) { return <str> ; } else { char [ ] buf = new char [ <int> ] ; int i = buf . length ; if ( x < <int> ) { long quotient = divide ( x , radix ) ; long rem = x - quotient * radix ; buf [ - - i ] = Character . forDigit ( ( int ) rem , radix ) ; x = quotient ; } while ( x > <int> ) { buf [ - - i ] = Character . forDigit ( ( int ) ( x % radix ) , radix ) ; x / = radix ; } return new String ( buf , i , buf . length - i ) ; } } private static final long [ ] maxValueDivs = new long [ Character . MAX_RADIX + <int> ] ; private static final int [ ] maxValueMods = new int [ Character . MAX_RADIX + <int> ] ; private static final int [ ] maxSafeDigits = new int [ Character . MAX_RADIX + <int> ] ; static { BigInteger overflow = new BigInteger ( <str> , <int> ) ; for ( int i = Character . MIN_RADIX ; i < = Character . MAX_RADIX ; i + + ) { maxValueDivs [ i ] = divide ( MAX_VALUE , i ) ; maxValueMods [ i ] = ( int ) remainder ( MAX_VALUE , i ) ; maxSafeDigits [ i ] = overflow . toString ( i ) . length ( ) - <int> ; } } } 
