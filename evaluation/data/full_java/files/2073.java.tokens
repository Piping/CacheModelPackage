package org . nd4j . linalg . api . ops . impl . transforms ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . BaseTransformOp ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; public class MaxOut extends BaseTransformOp { private IComplexNumber maxComplex = Nd4j . createComplexNumber ( Double . NaN , Double . NaN ) ; private Number max = Double . NaN ; public MaxOut ( ) { } public MaxOut ( INDArray x , INDArray z ) { super ( x , z ) ; } public MaxOut ( INDArray x , INDArray z , int n ) { super ( x , z , n ) ; } public MaxOut ( INDArray x , INDArray y , INDArray z , int n ) { super ( x , y , z , n ) ; } public MaxOut ( INDArray x ) { super ( x ) ; } @Override public String name ( ) { return <str> ; } @Override public IComplexNumber op ( IComplexNumber origin , double other ) { setMax ( extraArgs ) ; return maxComplex ; } @Override public IComplexNumber op ( IComplexNumber origin , float other ) { setMax ( extraArgs ) ; return maxComplex ; } @Override public IComplexNumber op ( IComplexNumber origin , IComplexNumber other ) { setMax ( extraArgs ) ; return maxComplex ; } @Override public float op ( float origin , float other ) { setMax ( extraArgs ) ; return max . floatValue ( ) ; } @Override public double op ( double origin , double other ) { setMax ( extraArgs ) ; return max . doubleValue ( ) ; } @Override public double op ( double origin ) { setMax ( extraArgs ) ; return max . doubleValue ( ) ; } @Override public float op ( float origin ) { setMax ( extraArgs ) ; return max . floatValue ( ) ; } @Override public IComplexNumber op ( IComplexNumber origin ) { setMax ( extraArgs ) ; return maxComplex ; } private void setMax ( Object [ ] extraArgs ) { if ( extraArgs . length < <int> ) throw new IllegalArgumentException ( <str> ) ; if ( Double . isNaN ( max . doubleValue ( ) ) & & extraArgs [ <int> ] instanceof Number ) { max = Double . valueOf ( extraArgs [ <int> ] . toString ( ) ) ; } else if ( Double . isNaN ( maxComplex . realComponent ( ) . doubleValue ( ) ) & & extraArgs [ <int> ] instanceof IComplexNumber ) { maxComplex = ( IComplexNumber ) extraArgs [ <int> ] ; } } @Override public Op opForDimension ( int index , int dimension ) { INDArray xAlongDimension = x . vectorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new MaxOut ( xAlongDimension , y . vectorAlongDimension ( index , dimension ) , z . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new MaxOut ( xAlongDimension , z . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; } @Override public Op opForDimension ( int index , int . . . dimension ) { INDArray xAlongDimension = x . tensorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new MaxOut ( xAlongDimension , y . tensorAlongDimension ( index , dimension ) , z . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new MaxOut ( xAlongDimension , z . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; } } 
