package org . elasticsearch . action . get ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . search . fetch . source . FetchSourceContext ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . hamcrest . CoreMatchers . equalTo ; public class MultiGetShardRequestTests extends ESTestCase { public void testSerialization ( ) throws IOException { MultiGetRequest multiGetRequest = new MultiGetRequest ( ) ; if ( randomBoolean ( ) ) { multiGetRequest . preference ( randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ) ; } if ( randomBoolean ( ) ) { multiGetRequest . realtime ( false ) ; } if ( randomBoolean ( ) ) { multiGetRequest . refresh ( true ) ; } multiGetRequest . ignoreErrorsOnGeneratedFields ( randomBoolean ( ) ) ; MultiGetShardRequest multiGetShardRequest = new MultiGetShardRequest ( multiGetRequest , <str> , <int> ) ; int numItems = iterations ( <int> , <int> ) ; for ( int i = <int> ; i < numItems ; i + + ) { MultiGetRequest . Item item = new MultiGetRequest . Item ( <str> + randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) , <str> , <str> + i ) ; if ( randomBoolean ( ) ) { int numFields = randomIntBetween ( <int> , <int> ) ; String [ ] fields = new String [ numFields ] ; for ( int j = <int> ; j < fields . length ; j + + ) { fields [ j ] = randomAsciiOfLength ( randomIntBetween ( <int> , <int> ) ) ; } item . fields ( fields ) ; } if ( randomBoolean ( ) ) { item . version ( randomIntBetween ( <int> , Integer . MAX_VALUE ) ) ; item . versionType ( randomFrom ( VersionType . values ( ) ) ) ; } if ( randomBoolean ( ) ) { item . fetchSourceContext ( new FetchSourceContext ( randomBoolean ( ) ) ) ; } multiGetShardRequest . add ( <int> , item ) ; } BytesStreamOutput out = new BytesStreamOutput ( ) ; out . setVersion ( randomVersion ( random ( ) ) ) ; multiGetShardRequest . writeTo ( out ) ; StreamInput in = StreamInput . wrap ( out . bytes ( ) ) ; in . setVersion ( out . getVersion ( ) ) ; MultiGetShardRequest multiGetShardRequest2 = new MultiGetShardRequest ( ) ; multiGetShardRequest2 . readFrom ( in ) ; assertThat ( multiGetShardRequest2 . index ( ) , equalTo ( multiGetShardRequest . index ( ) ) ) ; assertThat ( multiGetShardRequest2 . preference ( ) , equalTo ( multiGetShardRequest . preference ( ) ) ) ; assertThat ( multiGetShardRequest2 . realtime ( ) , equalTo ( multiGetShardRequest . realtime ( ) ) ) ; assertThat ( multiGetShardRequest2 . refresh ( ) , equalTo ( multiGetShardRequest . refresh ( ) ) ) ; assertThat ( multiGetShardRequest2 . ignoreErrorsOnGeneratedFields ( ) , equalTo ( multiGetShardRequest . ignoreErrorsOnGeneratedFields ( ) ) ) ; assertThat ( multiGetShardRequest2 . items . size ( ) , equalTo ( multiGetShardRequest . items . size ( ) ) ) ; for ( int i = <int> ; i < multiGetShardRequest2 . items . size ( ) ; i + + ) { MultiGetRequest . Item item = multiGetShardRequest . items . get ( i ) ; MultiGetRequest . Item item2 = multiGetShardRequest2 . items . get ( i ) ; assertThat ( item2 . index ( ) , equalTo ( item . index ( ) ) ) ; assertThat ( item2 . type ( ) , equalTo ( item . type ( ) ) ) ; assertThat ( item2 . id ( ) , equalTo ( item . id ( ) ) ) ; assertThat ( item2 . fields ( ) , equalTo ( item . fields ( ) ) ) ; assertThat ( item2 . version ( ) , equalTo ( item . version ( ) ) ) ; assertThat ( item2 . versionType ( ) , equalTo ( item . versionType ( ) ) ) ; assertThat ( item2 . fetchSourceContext ( ) , equalTo ( item . fetchSourceContext ( ) ) ) ; } assertThat ( multiGetShardRequest2 . indices ( ) , equalTo ( multiGetShardRequest . indices ( ) ) ) ; assertThat ( multiGetShardRequest2 . indicesOptions ( ) , equalTo ( multiGetShardRequest . indicesOptions ( ) ) ) ; } } 
