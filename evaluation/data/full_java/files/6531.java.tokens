package org . elasticsearch . index . mapper ; import org . apache . lucene . document . FieldType ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . index . Term ; import org . apache . lucene . index . Terms ; import org . apache . lucene . queries . TermsQuery ; import org . apache . lucene . search . * ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . action . fieldstats . FieldStats ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . lucene . BytesRefs ; import org . elasticsearch . common . unit . Fuzziness ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . fielddata . FieldDataType ; import org . elasticsearch . index . query . QueryShardContext ; import org . elasticsearch . index . query . QueryShardException ; import org . elasticsearch . index . similarity . SimilarityProvider ; import java . io . IOException ; import java . util . List ; import java . util . Objects ; public abstract class MappedFieldType extends FieldType { public static class Names { private final String indexName ; private final String originalIndexName ; private final String fullName ; public Names ( String name ) { this ( name , name , name ) ; } public Names ( String indexName , String originalIndexName , String fullName ) { this . indexName = indexName ; this . originalIndexName = originalIndexName ; this . fullName = fullName ; } public String indexName ( ) { return indexName ; } public String originalIndexName ( ) { return originalIndexName ; } public String fullName ( ) { return fullName ; } @Override public boolean equals ( Object o ) { if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Names names = ( Names ) o ; if ( ! fullName . equals ( names . fullName ) ) return false ; if ( ! indexName . equals ( names . indexName ) ) return false ; if ( ! originalIndexName . equals ( names . originalIndexName ) ) return false ; return true ; } @Override public int hashCode ( ) { int result = indexName . hashCode ( ) ; result = <int> * result + originalIndexName . hashCode ( ) ; result = <int> * result + fullName . hashCode ( ) ; return result ; } } public enum Loading { LAZY { @Override public String toString ( ) { return LAZY_VALUE ; } } , EAGER { @Override public String toString ( ) { return EAGER_VALUE ; } } , EAGER_GLOBAL_ORDINALS { @Override public String toString ( ) { return EAGER_GLOBAL_ORDINALS_VALUE ; } } ; public static final String KEY = <str> ; public static final String EAGER_GLOBAL_ORDINALS_VALUE = <str> ; public static final String EAGER_VALUE = <str> ; public static final String LAZY_VALUE = <str> ; public static Loading parse ( String loading , Loading defaultValue ) { if ( Strings . isNullOrEmpty ( loading ) ) { return defaultValue ; } else if ( EAGER_GLOBAL_ORDINALS_VALUE . equalsIgnoreCase ( loading ) ) { return EAGER_GLOBAL_ORDINALS ; } else if ( EAGER_VALUE . equalsIgnoreCase ( loading ) ) { return EAGER ; } else if ( LAZY_VALUE . equalsIgnoreCase ( loading ) ) { return LAZY ; } else { throw new MapperParsingException ( <str> + KEY + <str> + loading + <str> ) ; } } } private Names names ; private float boost ; private boolean docValues ; private NamedAnalyzer indexAnalyzer ; private NamedAnalyzer searchAnalyzer ; private NamedAnalyzer searchQuoteAnalyzer ; private SimilarityProvider similarity ; private Loading normsLoading ; private FieldDataType fieldDataType ; private Object nullValue ; private String nullValueAsString ; protected MappedFieldType ( MappedFieldType ref ) { super ( ref ) ; this . names = ref . names ( ) ; this . boost = ref . boost ( ) ; this . docValues = ref . hasDocValues ( ) ; this . indexAnalyzer = ref . indexAnalyzer ( ) ; this . searchAnalyzer = ref . searchAnalyzer ( ) ; this . searchQuoteAnalyzer = ref . searchQuoteAnalyzer ( ) ; this . similarity = ref . similarity ( ) ; this . normsLoading = ref . normsLoading ( ) ; this . fieldDataType = ref . fieldDataType ( ) ; this . nullValue = ref . nullValue ( ) ; this . nullValueAsString = ref . nullValueAsString ( ) ; } public MappedFieldType ( ) { setTokenized ( true ) ; setStored ( false ) ; setStoreTermVectors ( false ) ; setOmitNorms ( false ) ; setIndexOptions ( IndexOptions . DOCS_AND_FREQS_AND_POSITIONS ) ; setBoost ( <float> ) ; fieldDataType = new FieldDataType ( typeName ( ) ) ; } @Override public abstract MappedFieldType clone ( ) ; @Override public boolean equals ( Object o ) { if ( ! super . equals ( o ) ) return false ; MappedFieldType fieldType = ( MappedFieldType ) o ; if ( similarity = = null | | fieldType . similarity = = null ) { if ( similarity ! = fieldType . similarity ) { return false ; } } else { if ( Objects . equals ( similarity . name ( ) , fieldType . similarity . name ( ) ) = = false ) { return false ; } } return boost = = fieldType . boost & & docValues = = fieldType . docValues & & Objects . equals ( names , fieldType . names ) & & Objects . equals ( indexAnalyzer , fieldType . indexAnalyzer ) & & Objects . equals ( searchAnalyzer , fieldType . searchAnalyzer ) & & Objects . equals ( searchQuoteAnalyzer ( ) , fieldType . searchQuoteAnalyzer ( ) ) & & Objects . equals ( normsLoading , fieldType . normsLoading ) & & Objects . equals ( fieldDataType , fieldType . fieldDataType ) & & Objects . equals ( nullValue , fieldType . nullValue ) & & Objects . equals ( nullValueAsString , fieldType . nullValueAsString ) ; } @Override public int hashCode ( ) { return Objects . hash ( super . hashCode ( ) , names , boost , docValues , indexAnalyzer , searchAnalyzer , searchQuoteAnalyzer , similarity = = null ? null : similarity . name ( ) , normsLoading , fieldDataType , nullValue , nullValueAsString ) ; } public abstract String typeName ( ) ; private final void checkTypeName ( MappedFieldType other ) { if ( typeName ( ) . equals ( other . typeName ( ) ) = = false ) { throw new IllegalArgumentException ( <str> + names ( ) . fullName ( ) + <str> + typeName ( ) + <str> + other . typeName ( ) + <str> ) ; } else if ( getClass ( ) ! = other . getClass ( ) ) { throw new IllegalStateException ( <str> + getClass ( ) . getSimpleName ( ) + <str> + other . getClass ( ) . getSimpleName ( ) ) ; } } public void checkCompatibility ( MappedFieldType other , List < String > conflicts , boolean strict ) { checkTypeName ( other ) ; boolean indexed = indexOptions ( ) ! = IndexOptions . NONE ; boolean mergeWithIndexed = other . indexOptions ( ) ! = IndexOptions . NONE ; if ( indexed ! = mergeWithIndexed | | tokenized ( ) ! = other . tokenized ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( stored ( ) ! = other . stored ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( hasDocValues ( ) = = false & & other . hasDocValues ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( omitNorms ( ) & & ! other . omitNorms ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( storeTermVectors ( ) ! = other . storeTermVectors ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( storeTermVectorOffsets ( ) ! = other . storeTermVectorOffsets ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( storeTermVectorPositions ( ) ! = other . storeTermVectorPositions ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( storeTermVectorPayloads ( ) ! = other . storeTermVectorPayloads ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( indexAnalyzer ( ) = = null | | <str> . equals ( indexAnalyzer ( ) . name ( ) ) ) { if ( other . indexAnalyzer ( ) ! = null & & <str> . equals ( other . indexAnalyzer ( ) . name ( ) ) = = false ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } } else if ( other . indexAnalyzer ( ) = = null | | <str> . equals ( other . indexAnalyzer ( ) . name ( ) ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } else if ( indexAnalyzer ( ) . name ( ) . equals ( other . indexAnalyzer ( ) . name ( ) ) = = false ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( ! names ( ) . indexName ( ) . equals ( other . names ( ) . indexName ( ) ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( Objects . equals ( similarity ( ) , other . similarity ( ) ) = = false ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( strict ) { if ( omitNorms ( ) ! = other . omitNorms ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( boost ( ) ! = other . boost ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( normsLoading ( ) ! = other . normsLoading ( ) ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( Objects . equals ( searchAnalyzer ( ) , other . searchAnalyzer ( ) ) = = false ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( Objects . equals ( searchQuoteAnalyzer ( ) , other . searchQuoteAnalyzer ( ) ) = = false ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( Objects . equals ( fieldDataType ( ) , other . fieldDataType ( ) ) = = false ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } if ( Objects . equals ( nullValue ( ) , other . nullValue ( ) ) = = false ) { conflicts . add ( <str> + names ( ) . fullName ( ) + <str> ) ; } } } public boolean isNumeric ( ) { return false ; } public boolean isSortable ( ) { return true ; } public Names names ( ) { return names ; } public void setNames ( Names names ) { checkIfFrozen ( ) ; this . names = names ; } public float boost ( ) { return boost ; } public void setBoost ( float boost ) { checkIfFrozen ( ) ; this . boost = boost ; } public FieldDataType fieldDataType ( ) { return fieldDataType ; } public void setFieldDataType ( FieldDataType fieldDataType ) { checkIfFrozen ( ) ; this . fieldDataType = fieldDataType ; } public boolean hasDocValues ( ) { return docValues ; } public void setHasDocValues ( boolean hasDocValues ) { checkIfFrozen ( ) ; this . docValues = hasDocValues ; } public Loading normsLoading ( ) { return normsLoading ; } public void setNormsLoading ( Loading normsLoading ) { checkIfFrozen ( ) ; this . normsLoading = normsLoading ; } public NamedAnalyzer indexAnalyzer ( ) { return indexAnalyzer ; } public void setIndexAnalyzer ( NamedAnalyzer analyzer ) { checkIfFrozen ( ) ; this . indexAnalyzer = analyzer ; } public NamedAnalyzer searchAnalyzer ( ) { return searchAnalyzer ; } public void setSearchAnalyzer ( NamedAnalyzer analyzer ) { checkIfFrozen ( ) ; this . searchAnalyzer = analyzer ; } public NamedAnalyzer searchQuoteAnalyzer ( ) { return searchQuoteAnalyzer = = null ? searchAnalyzer : searchQuoteAnalyzer ; } public void setSearchQuoteAnalyzer ( NamedAnalyzer analyzer ) { checkIfFrozen ( ) ; this . searchQuoteAnalyzer = analyzer ; } public SimilarityProvider similarity ( ) { return similarity ; } public void setSimilarity ( SimilarityProvider similarity ) { checkIfFrozen ( ) ; this . similarity = similarity ; } public Object nullValue ( ) { return nullValue ; } public String nullValueAsString ( ) { return nullValueAsString ; } public void setNullValue ( Object nullValue ) { checkIfFrozen ( ) ; this . nullValue = nullValue ; this . nullValueAsString = nullValue = = null ? null : nullValue . toString ( ) ; } public Object value ( Object value ) { return value ; } public Object valueForSearch ( Object value ) { return value ; } public BytesRef indexedValueForSearch ( Object value ) { return BytesRefs . toBytesRef ( value ) ; } public boolean useTermQueryWithQueryString ( ) { return false ; } protected Term createTerm ( Object value ) { return new Term ( names ( ) . indexName ( ) , indexedValueForSearch ( value ) ) ; } public Query termQuery ( Object value , @Nullable QueryShardContext context ) { return new TermQuery ( createTerm ( value ) ) ; } public Query termsQuery ( List values , @Nullable QueryShardContext context ) { BytesRef [ ] bytesRefs = new BytesRef [ values . size ( ) ] ; for ( int i = <int> ; i < bytesRefs . length ; i + + ) { bytesRefs [ i ] = indexedValueForSearch ( values . get ( i ) ) ; } return new TermsQuery ( names . indexName ( ) , bytesRefs ) ; } public Query rangeQuery ( Object lowerTerm , Object upperTerm , boolean includeLower , boolean includeUpper ) { return new TermRangeQuery ( names ( ) . indexName ( ) , lowerTerm = = null ? null : indexedValueForSearch ( lowerTerm ) , upperTerm = = null ? null : indexedValueForSearch ( upperTerm ) , includeLower , includeUpper ) ; } public Query fuzzyQuery ( Object value , Fuzziness fuzziness , int prefixLength , int maxExpansions , boolean transpositions ) { return new FuzzyQuery ( createTerm ( value ) , fuzziness . asDistance ( BytesRefs . toString ( value ) ) , prefixLength , maxExpansions , transpositions ) ; } public Query prefixQuery ( String value , @Nullable MultiTermQuery . RewriteMethod method , @Nullable QueryShardContext context ) { PrefixQuery query = new PrefixQuery ( createTerm ( value ) ) ; if ( method ! = null ) { query . setRewriteMethod ( method ) ; } return query ; } public Query regexpQuery ( String value , int flags , int maxDeterminizedStates , @Nullable MultiTermQuery . RewriteMethod method , @Nullable QueryShardContext context ) { if ( numericType ( ) ! = null ) { throw new QueryShardException ( context , <str> + names . fullName + <str> ) ; } RegexpQuery query = new RegexpQuery ( createTerm ( value ) , flags , maxDeterminizedStates ) ; if ( method ! = null ) { query . setRewriteMethod ( method ) ; } return query ; } public Query nullValueQuery ( ) { if ( nullValue = = null ) { return null ; } return new ConstantScoreQuery ( termQuery ( nullValue , null ) ) ; } public FieldStats stats ( Terms terms , int maxDoc ) throws IOException { return new FieldStats . Text ( maxDoc , terms . getDocCount ( ) , terms . getSumDocFreq ( ) , terms . getSumTotalTermFreq ( ) , terms . getMin ( ) , terms . getMax ( ) ) ; } @Nullable public Query queryStringTermQuery ( Term term ) { return null ; } } 
