package io . netty . handler . codec . http . multipart ; import io . netty . handler . codec . DecoderException ; import io . netty . handler . codec . http . HttpConstants ; import io . netty . handler . codec . http . HttpContent ; import io . netty . handler . codec . http . HttpHeaderNames ; import io . netty . handler . codec . http . HttpHeaderValues ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . util . internal . StringUtil ; import java . nio . charset . Charset ; import java . util . List ; public class HttpPostRequestDecoder implements InterfaceHttpPostRequestDecoder { static final int DEFAULT_DISCARD_THRESHOLD = <int> * <int> * <int> ; private final InterfaceHttpPostRequestDecoder decoder ; public HttpPostRequestDecoder ( HttpRequest request ) { this ( new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) , request , HttpConstants . DEFAULT_CHARSET ) ; } public HttpPostRequestDecoder ( HttpDataFactory factory , HttpRequest request ) { this ( factory , request , HttpConstants . DEFAULT_CHARSET ) ; } public HttpPostRequestDecoder ( HttpDataFactory factory , HttpRequest request , Charset charset ) { if ( factory = = null ) { throw new NullPointerException ( <str> ) ; } if ( request = = null ) { throw new NullPointerException ( <str> ) ; } if ( charset = = null ) { throw new NullPointerException ( <str> ) ; } if ( isMultipart ( request ) ) { decoder = new HttpPostMultipartRequestDecoder ( factory , request , charset ) ; } else { decoder = new HttpPostStandardRequestDecoder ( factory , request , charset ) ; } } protected enum MultiPartStatus { NOTSTARTED , PREAMBLE , HEADERDELIMITER , DISPOSITION , FIELD , FILEUPLOAD , MIXEDPREAMBLE , MIXEDDELIMITER , MIXEDDISPOSITION , MIXEDFILEUPLOAD , MIXEDCLOSEDELIMITER , CLOSEDELIMITER , PREEPILOGUE , EPILOGUE } public static boolean isMultipart ( HttpRequest request ) { if ( request . headers ( ) . contains ( HttpHeaderNames . CONTENT_TYPE ) ) { return getMultipartDataBoundary ( request . headers ( ) . get ( HttpHeaderNames . CONTENT_TYPE ) ) ! = null ; } else { return false ; } } protected static String [ ] getMultipartDataBoundary ( String contentType ) { String [ ] headerContentType = splitHeaderContentType ( contentType ) ; if ( headerContentType [ <int> ] . toLowerCase ( ) . startsWith ( HttpHeaderValues . MULTIPART_FORM_DATA . toString ( ) ) ) { int mrank ; int crank ; if ( headerContentType [ <int> ] . toLowerCase ( ) . startsWith ( HttpHeaderValues . BOUNDARY . toString ( ) ) ) { mrank = <int> ; crank = <int> ; } else if ( headerContentType [ <int> ] . toLowerCase ( ) . startsWith ( HttpHeaderValues . BOUNDARY . toString ( ) ) ) { mrank = <int> ; crank = <int> ; } else { return null ; } String boundary = StringUtil . substringAfter ( headerContentType [ mrank ] , <str> ) ; if ( boundary = = null ) { throw new ErrorDataDecoderException ( <str> ) ; } if ( boundary . charAt ( <int> ) = = <str> ) { String bound = boundary . trim ( ) ; int index = bound . length ( ) - <int> ; if ( bound . charAt ( index ) = = <str> ) { boundary = bound . substring ( <int> , index ) ; } } if ( headerContentType [ crank ] . toLowerCase ( ) . startsWith ( HttpHeaderValues . CHARSET . toString ( ) ) ) { String charset = StringUtil . substringAfter ( headerContentType [ crank ] , <str> ) ; if ( charset ! = null ) { return new String [ ] { <str> + boundary , charset } ; } } return new String [ ] { <str> + boundary } ; } return null ; } @Override public boolean isMultipart ( ) { return decoder . isMultipart ( ) ; } @Override public void setDiscardThreshold ( int discardThreshold ) { decoder . setDiscardThreshold ( discardThreshold ) ; } @Override public int getDiscardThreshold ( ) { return decoder . getDiscardThreshold ( ) ; } @Override public List < InterfaceHttpData > getBodyHttpDatas ( ) { return decoder . getBodyHttpDatas ( ) ; } @Override public List < InterfaceHttpData > getBodyHttpDatas ( String name ) { return decoder . getBodyHttpDatas ( name ) ; } @Override public InterfaceHttpData getBodyHttpData ( String name ) { return decoder . getBodyHttpData ( name ) ; } @Override public InterfaceHttpPostRequestDecoder offer ( HttpContent content ) { return decoder . offer ( content ) ; } @Override public boolean hasNext ( ) { return decoder . hasNext ( ) ; } @Override public InterfaceHttpData next ( ) { return decoder . next ( ) ; } @Override public InterfaceHttpData currentPartialHttpData ( ) { return decoder . currentPartialHttpData ( ) ; } @Override public void destroy ( ) { decoder . destroy ( ) ; } @Override public void cleanFiles ( ) { decoder . cleanFiles ( ) ; } @Override public void removeHttpDataFromClean ( InterfaceHttpData data ) { decoder . removeHttpDataFromClean ( data ) ; } private static String [ ] splitHeaderContentType ( String sb ) { int aStart ; int aEnd ; int bStart ; int bEnd ; int cStart ; int cEnd ; aStart = HttpPostBodyUtil . findNonWhitespace ( sb , <int> ) ; aEnd = sb . indexOf ( <str> ) ; if ( aEnd = = - <int> ) { return new String [ ] { sb , <str> , <str> } ; } bStart = HttpPostBodyUtil . findNonWhitespace ( sb , aEnd + <int> ) ; if ( sb . charAt ( aEnd - <int> ) = = <str> ) { aEnd - - ; } bEnd = sb . indexOf ( <str> , bStart ) ; if ( bEnd = = - <int> ) { bEnd = HttpPostBodyUtil . findEndOfString ( sb ) ; return new String [ ] { sb . substring ( aStart , aEnd ) , sb . substring ( bStart , bEnd ) , <str> } ; } cStart = HttpPostBodyUtil . findNonWhitespace ( sb , bEnd + <int> ) ; if ( sb . charAt ( bEnd - <int> ) = = <str> ) { bEnd - - ; } cEnd = HttpPostBodyUtil . findEndOfString ( sb ) ; return new String [ ] { sb . substring ( aStart , aEnd ) , sb . substring ( bStart , bEnd ) , sb . substring ( cStart , cEnd ) } ; } public static class NotEnoughDataDecoderException extends DecoderException { private static final long serialVersionUID = - <int> ; public NotEnoughDataDecoderException ( ) { } public NotEnoughDataDecoderException ( String msg ) { super ( msg ) ; } public NotEnoughDataDecoderException ( Throwable cause ) { super ( cause ) ; } public NotEnoughDataDecoderException ( String msg , Throwable cause ) { super ( msg , cause ) ; } } public static class EndOfDataDecoderException extends DecoderException { private static final long serialVersionUID = <int> ; } public static class ErrorDataDecoderException extends DecoderException { private static final long serialVersionUID = <int> ; public ErrorDataDecoderException ( ) { } public ErrorDataDecoderException ( String msg ) { super ( msg ) ; } public ErrorDataDecoderException ( Throwable cause ) { super ( cause ) ; } public ErrorDataDecoderException ( String msg , Throwable cause ) { super ( msg , cause ) ; } } } 
