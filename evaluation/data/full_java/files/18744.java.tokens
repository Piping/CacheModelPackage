package io . netty . buffer ; import io . netty . util . IllegalReferenceCountException ; import io . netty . util . internal . PlatformDependent ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf { private static final AtomicIntegerFieldUpdater < AbstractReferenceCountedByteBuf > refCntUpdater ; static { AtomicIntegerFieldUpdater < AbstractReferenceCountedByteBuf > updater = PlatformDependent . newAtomicIntegerFieldUpdater ( AbstractReferenceCountedByteBuf . class , <str> ) ; if ( updater = = null ) { updater = AtomicIntegerFieldUpdater . newUpdater ( AbstractReferenceCountedByteBuf . class , <str> ) ; } refCntUpdater = updater ; } private volatile int refCnt = <int> ; protected AbstractReferenceCountedByteBuf ( int maxCapacity ) { super ( maxCapacity ) ; } @Override public final int refCnt ( ) { return refCnt ; } protected final void setRefCnt ( int refCnt ) { this . refCnt = refCnt ; } @Override public ByteBuf retain ( ) { for ( ; ; ) { int refCnt = this . refCnt ; if ( refCnt = = <int> ) { throw new IllegalReferenceCountException ( <int> , <int> ) ; } if ( refCnt = = Integer . MAX_VALUE ) { throw new IllegalReferenceCountException ( Integer . MAX_VALUE , <int> ) ; } if ( refCntUpdater . compareAndSet ( this , refCnt , refCnt + <int> ) ) { break ; } } return this ; } @Override public ByteBuf retain ( int increment ) { if ( increment < = <int> ) { throw new IllegalArgumentException ( <str> + increment + <str> ) ; } for ( ; ; ) { int refCnt = this . refCnt ; if ( refCnt = = <int> ) { throw new IllegalReferenceCountException ( <int> , increment ) ; } if ( refCnt > Integer . MAX_VALUE - increment ) { throw new IllegalReferenceCountException ( refCnt , increment ) ; } if ( refCntUpdater . compareAndSet ( this , refCnt , refCnt + increment ) ) { break ; } } return this ; } @Override public ByteBuf touch ( ) { return this ; } @Override public ByteBuf touch ( Object hint ) { return this ; } @Override public final boolean release ( ) { for ( ; ; ) { int refCnt = this . refCnt ; if ( refCnt = = <int> ) { throw new IllegalReferenceCountException ( <int> , - <int> ) ; } if ( refCntUpdater . compareAndSet ( this , refCnt , refCnt - <int> ) ) { if ( refCnt = = <int> ) { deallocate ( ) ; return true ; } return false ; } } } @Override public final boolean release ( int decrement ) { if ( decrement < = <int> ) { throw new IllegalArgumentException ( <str> + decrement + <str> ) ; } for ( ; ; ) { int refCnt = this . refCnt ; if ( refCnt < decrement ) { throw new IllegalReferenceCountException ( refCnt , - decrement ) ; } if ( refCntUpdater . compareAndSet ( this , refCnt , refCnt - decrement ) ) { if ( refCnt = = decrement ) { deallocate ( ) ; return true ; } return false ; } } } protected abstract void deallocate ( ) ; } 
