package org . gradle . api . internal . tasks . scala ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import com . typesafe . zinc . * ; import org . gradle . api . internal . tasks . SimpleWorkResult ; import org . gradle . api . internal . tasks . compile . CompilationFailedException ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . api . internal . tasks . compile . JavaCompilerArgumentsBuilder ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . tasks . WorkResult ; import org . gradle . internal . jvm . Jvm ; import scala . Option ; import xsbti . F0 ; import java . io . File ; import java . io . Serializable ; import java . util . List ; public class ZincScalaCompiler implements Compiler < ScalaJavaJointCompileSpec > , Serializable { private static final Logger LOGGER = Logging . getLogger ( ZincScalaCompiler . class ) ; private final Iterable < File > scalaClasspath ; private Iterable < File > zincClasspath ; public ZincScalaCompiler ( Iterable < File > scalaClasspath , Iterable < File > zincClasspath ) { this . scalaClasspath = scalaClasspath ; this . zincClasspath = zincClasspath ; } public WorkResult execute ( ScalaJavaJointCompileSpec spec ) { return Compiler . execute ( scalaClasspath , zincClasspath , spec ) ; } private static class Compiler { static WorkResult execute ( Iterable < File > scalaClasspath , Iterable < File > zincClasspath , ScalaJavaJointCompileSpec spec ) { LOGGER . info ( <str> ) ; xsbti . Logger logger = new SbtLoggerAdapter ( ) ; com . typesafe . zinc . Compiler compiler = createCompiler ( scalaClasspath , zincClasspath , logger ) ; List < String > scalacOptions = new ZincScalaCompilerArgumentsGenerator ( ) . generate ( spec ) ; List < String > javacOptions = new JavaCompilerArgumentsBuilder ( spec ) . includeClasspath ( false ) . build ( ) ; Inputs inputs = Inputs . create ( ImmutableList . copyOf ( spec . getClasspath ( ) ) , ImmutableList . copyOf ( spec . getSource ( ) ) , spec . getDestinationDir ( ) , scalacOptions , javacOptions , spec . getScalaCompileOptions ( ) . getIncrementalOptions ( ) . getAnalysisFile ( ) , spec . getAnalysisMap ( ) , <str> , getIncOptions ( ) , true ) ; if ( LOGGER . isDebugEnabled ( ) ) { Inputs . debug ( inputs , logger ) ; } try { compiler . compile ( inputs , logger ) ; } catch ( xsbti . CompileFailed e ) { throw new CompilationFailedException ( e ) ; } return new SimpleWorkResult ( true ) ; } private static IncOptions getIncOptions ( ) { int transitiveStep = <int> ; double recompileAllFraction = <float> ; boolean relationsDebug = false ; boolean apiDebug = false ; int apiDiffContextSize = <int> ; Option < File > apiDumpDirectory = Option . empty ( ) ; boolean transactional = false ; Option < File > backup = Option . empty ( ) ; @SuppressWarnings ( <str> ) IncOptions options = new IncOptions ( transitiveStep , recompileAllFraction , relationsDebug , apiDebug , apiDiffContextSize , apiDumpDirectory , transactional , backup ) ; return options ; } static com . typesafe . zinc . Compiler createCompiler ( Iterable < File > scalaClasspath , Iterable < File > zincClasspath , xsbti . Logger logger ) { ScalaLocation scalaLocation = ScalaLocation . fromPath ( Lists . newArrayList ( scalaClasspath ) ) ; SbtJars sbtJars = SbtJars . fromPath ( Lists . newArrayList ( zincClasspath ) ) ; Setup setup = Setup . create ( scalaLocation , sbtJars , Jvm . current ( ) . getJavaHome ( ) , true ) ; if ( LOGGER . isDebugEnabled ( ) ) { Setup . debug ( setup , logger ) ; } return com . typesafe . zinc . Compiler . getOrCreate ( setup , logger ) ; } } private static class SbtLoggerAdapter implements xsbti . Logger { public void error ( F0 < String > msg ) { LOGGER . error ( msg . apply ( ) ) ; } public void warn ( F0 < String > msg ) { LOGGER . warn ( msg . apply ( ) ) ; } public void info ( F0 < String > msg ) { LOGGER . info ( msg . apply ( ) ) ; } public void debug ( F0 < String > msg ) { LOGGER . debug ( msg . apply ( ) ) ; } public void trace ( F0 < Throwable > exception ) { LOGGER . trace ( exception . apply ( ) . toString ( ) ) ; } } } 
