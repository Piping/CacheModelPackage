package org . gradle . gradleplugin . userinterface . swing . generic ; import org . gradle . foundation . output . FileLinkDefinitionLord ; import org . gradle . foundation . output . LiveOutputParser ; import org . gradle . foundation . output . FileLink ; import javax . swing . * ; import javax . swing . text . * ; import java . awt . * ; import java . awt . datatransfer . StringSelection ; import java . awt . event . KeyAdapter ; import java . awt . event . KeyEvent ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . awt . event . ActionEvent ; import java . util . List ; import java . util . Iterator ; import java . io . File ; public class OutputTextPane { private JScrollPane scroll ; private final TextPane textPane ; private DefaultStyledDocument document ; private Font font ; private AttributeSet defaultStyle ; private AttributeSet fileStyle ; private LiveOutputParser liveOutputParser ; private Interaction interaction ; private boolean allowsClickingFiles ; private boolean hasClickableLinks ; private JPopupMenu popupMenu ; public interface Interaction { public void fileClicked ( File file , int line ) ; } public OutputTextPane ( Interaction interaction , boolean allowsClickingFiles , Font font , FileLinkDefinitionLord fileLinkDefinitionLord ) { this . interaction = interaction ; this . allowsClickingFiles = allowsClickingFiles ; this . font = font ; document = new DefaultStyledDocument ( ) ; textPane = new TextPane ( document ) ; textPane . setEditable ( false ) ; textPane . setAutoscrolls ( false ) ; scroll = new JScrollPane ( textPane ) ; scroll . setAutoscrolls ( false ) ; scroll . setHorizontalScrollBarPolicy ( JScrollPane . HORIZONTAL_SCROLLBAR_AS_NEEDED ) ; scroll . setVerticalScrollBarPolicy ( JScrollPane . VERTICAL_SCROLLBAR_AS_NEEDED ) ; DefaultCaret caret = new DefaultCaret ( ) ; caret . setUpdatePolicy ( DefaultCaret . NEVER_UPDATE ) ; textPane . setCaret ( caret ) ; Color background = Color . white ; textPane . setBackground ( background ) ; scroll . setBackground ( background ) ; scroll . getViewport ( ) . setBackground ( background ) ; resetFontStyles ( ) ; textPane . addMouseListener ( new MouseAdapter ( ) { @Override public void mouseClicked ( MouseEvent e ) { handleClick ( e . getButton ( ) = = MouseEvent . BUTTON3 , e . getPoint ( ) ) ; } @Override public void mouseReleased ( MouseEvent e ) { if ( e . getButton ( ) = = MouseEvent . BUTTON3 ) { showPopup ( e . getPoint ( ) ) ; } } } ) ; textPane . addKeyListener ( new KeyAdapter ( ) { @Override public void keyPressed ( KeyEvent e ) { handleKeyPress ( e . getKeyCode ( ) ) ; } } ) ; liveOutputParser = new LiveOutputParser ( fileLinkDefinitionLord , true ) ; } private void resetFontStyles ( ) { defaultStyle = createDefaultAttributeSet ( ) ; StyleContext styleContent = StyleContext . getDefaultStyleContext ( ) ; fileStyle = createDefaultAttributeSet ( ) ; fileStyle = styleContent . addAttribute ( fileStyle , StyleConstants . Foreground , Color . blue ) ; fileStyle = styleContent . addAttribute ( fileStyle , StyleConstants . Underline , true ) ; } private AttributeSet createDefaultAttributeSet ( ) { StyleContext styleContent = StyleContext . getDefaultStyleContext ( ) ; AttributeSet attributeSet = styleContent . addAttribute ( SimpleAttributeSet . EMPTY , StyleConstants . FontFamily , font . getName ( ) ) ; attributeSet = styleContent . addAttribute ( attributeSet , StyleConstants . FontSize , font . getSize ( ) ) ; return attributeSet ; } public AttributeSet getDefaultStyle ( ) { return defaultStyle ; } public JComponent asComponent ( ) { return scroll ; } public JTextPane getTextComponent ( ) { return textPane ; } public String getText ( ) { return textPane . getText ( ) ; } private void handleClick ( boolean isRightButton , Point point ) { if ( ! isRightButton & & allowsClickingFiles ) { FileLink fileLink = getFileLinkAt ( point ) ; if ( fileLink ! = null ) { interaction . fileClicked ( fileLink . getFile ( ) , fileLink . getLineNumber ( ) ) ; } } } private void handleKeyPress ( int keyCode ) { if ( allowsClickingFiles ) { if ( keyCode = = KeyEvent . VK_ENTER ) { int caretLocation = textPane . getCaretPosition ( ) ; if ( caretLocation ! = - <int> ) { FileLink fileLink = liveOutputParser . getFileLink ( caretLocation ) ; if ( fileLink ! = null ) { interaction . fileClicked ( fileLink . getFile ( ) , fileLink . getLineNumber ( ) ) ; } } } } } private void showPopup ( Point point ) { buildPopup ( ) ; popupMenu . show ( textPane , point . x , point . y ) ; } private void buildPopup ( ) { if ( popupMenu ! = null ) { return ; } popupMenu = new JPopupMenu ( ) ; popupMenu . add ( new AbstractAction ( <str> ) { public void actionPerformed ( ActionEvent e ) { String text = textPane . getSelectedText ( ) ; if ( text ! = null ) { Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) . setContents ( new StringSelection ( text ) , null ) ; } } } ) ; popupMenu . add ( new AbstractAction ( <str> ) { public void actionPerformed ( ActionEvent e ) { textPane . selectAll ( ) ; } } ) ; } public void appendText ( String text ) { appendText ( text , false ) ; } public void setText ( String text ) { liveOutputParser . reset ( ) ; appendText ( text , true ) ; } private void appendText ( String text , boolean replaceExisting ) { Rectangle viewBounds = scroll . getViewport ( ) . getViewRect ( ) ; Dimension viewSize = scroll . getViewport ( ) . getViewSize ( ) ; int maxViewBoundsY = viewBounds . y + viewBounds . height ; boolean shouldScroll = viewSize . height - maxViewBoundsY < <int> ; try { if ( replaceExisting ) { hasClickableLinks = false ; document . remove ( <int> , document . getLength ( ) ) ; } document . insertString ( document . getLength ( ) , text , defaultStyle ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } if ( allowsClickingFiles ) { List < FileLink > fileLinks = liveOutputParser . appendText ( text ) ; highlightFileLinks ( fileLinks ) ; } if ( shouldScroll ) { SwingUtilities . invokeLater ( new Runnable ( ) { public void run ( ) { scrollToBottom ( ) ; } } ) ; } } private void highlightFileLinks ( List < FileLink > fileLinks ) { Iterator < FileLink > iterator = fileLinks . iterator ( ) ; while ( iterator . hasNext ( ) ) { FileLink fileLink = iterator . next ( ) ; document . setCharacterAttributes ( fileLink . getStartingIndex ( ) , fileLink . getLength ( ) , fileStyle , false ) ; hasClickableLinks = true ; } } private void scrollToBottom ( ) { int height = scroll . getVerticalScrollBar ( ) . getHeight ( ) ; int maximum = scroll . getVerticalScrollBar ( ) . getMaximum ( ) ; int newValue = maximum - height ; scroll . getVerticalScrollBar ( ) . setValue ( newValue ) ; } public FileLink getFileLinkAt ( Point point ) { int index = textPane . viewToModel ( point ) ; return liveOutputParser . getFileLink ( index ) ; } private class TextPane extends JTextPane { private TextPane ( DefaultStyledDocument doc ) { super ( doc ) ; } @Override public boolean getScrollableTracksViewportWidth ( ) { return false ; } } public void setFont ( Font font ) { this . font = font ; resetFontStyles ( ) ; resetText ( ) ; } private void resetText ( ) { String text = liveOutputParser . getText ( ) ; liveOutputParser . reset ( ) ; appendText ( text , true ) ; } public boolean hasClickableLinks ( ) { return hasClickableLinks ; } public boolean allowsClickingFiles ( ) { return allowsClickingFiles ; } public void selectFileLink ( FileLink fileLink ) { if ( fileLink = = null ) { return ; } textPane . setCaretPosition ( fileLink . getStartingIndex ( ) ) ; textPane . select ( fileLink . getStartingIndex ( ) , fileLink . getEndingIndex ( ) ) ; try { Rectangle startingRectangle = textPane . modelToView ( fileLink . getStartingIndex ( ) ) ; Rectangle endDingRectangle = textPane . modelToView ( fileLink . getEndingIndex ( ) ) ; Rectangle totalBounds = startingRectangle . union ( endDingRectangle ) ; textPane . scrollRectToVisible ( totalBounds ) ; textPane . requestFocus ( ) ; } catch ( BadLocationException e ) { e . printStackTrace ( ) ; } } public FileLink getPreviousFileLink ( ) { return liveOutputParser . getPreviousFileLink ( textPane . getCaretPosition ( ) ) ; } public FileLink getNextFileLink ( ) { return liveOutputParser . getNextFileLink ( textPane . getCaretPosition ( ) ) ; } public void resetHighlights ( ) { document . setCharacterAttributes ( <int> , document . getLength ( ) , defaultStyle , true ) ; if ( allowsClickingFiles ) { List < FileLink > fileLinks = liveOutputParser . getFileLinks ( ) ; highlightFileLinks ( fileLinks ) ; } } } 
