package com . badlogic . gdx . graphics . g3d . loader ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . assets . AssetManager ; import com . badlogic . gdx . assets . loaders . FileHandleResolver ; import com . badlogic . gdx . assets . loaders . ModelLoader ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Attributes ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . model . data . ModelData ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMaterial ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMesh ; import com . badlogic . gdx . graphics . g3d . model . data . ModelMeshPart ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNode ; import com . badlogic . gdx . graphics . g3d . model . data . ModelNodePart ; import com . badlogic . gdx . graphics . g3d . model . data . ModelTexture ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . FloatArray ; public class ObjLoader extends ModelLoader < ObjLoader . ObjLoaderParameters > { public static boolean logWarning = false ; public static class ObjLoaderParameters extends ModelLoader . ModelParameters { public boolean flipV ; public ObjLoaderParameters ( ) { } public ObjLoaderParameters ( boolean flipV ) { this . flipV = flipV ; } } final FloatArray verts = new FloatArray ( <int> ) ; final FloatArray norms = new FloatArray ( <int> ) ; final FloatArray uvs = new FloatArray ( <int> ) ; final Array < Group > groups = new Array < Group > ( <int> ) ; public ObjLoader ( ) { this ( null ) ; } public ObjLoader ( FileHandleResolver resolver ) { super ( resolver ) ; } public Model loadModel ( final FileHandle fileHandle , boolean flipV ) { return loadModel ( fileHandle , new ObjLoaderParameters ( flipV ) ) ; } @Override public ModelData loadModelData ( FileHandle file , ObjLoaderParameters parameters ) { return loadModelData ( file , parameters = = null ? false : parameters . flipV ) ; } protected ModelData loadModelData ( FileHandle file , boolean flipV ) { if ( logWarning ) Gdx . app . error ( <str> , <str> ) ; String line ; String [ ] tokens ; char firstChar ; MtlLoader mtl = new MtlLoader ( ) ; Group activeGroup = new Group ( <str> ) ; groups . add ( activeGroup ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( file . read ( ) ) , <int> ) ; int id = <int> ; try { while ( ( line = reader . readLine ( ) ) ! = null ) { tokens = line . split ( <str> ) ; if ( tokens . length < <int> ) break ; if ( tokens [ <int> ] . length ( ) = = <int> ) { continue ; } else if ( ( firstChar = tokens [ <int> ] . toLowerCase ( ) . charAt ( <int> ) ) = = <str> ) { continue ; } else if ( firstChar = = <str> ) { if ( tokens [ <int> ] . length ( ) = = <int> ) { verts . add ( Float . parseFloat ( tokens [ <int> ] ) ) ; verts . add ( Float . parseFloat ( tokens [ <int> ] ) ) ; verts . add ( Float . parseFloat ( tokens [ <int> ] ) ) ; } else if ( tokens [ <int> ] . charAt ( <int> ) = = <str> ) { norms . add ( Float . parseFloat ( tokens [ <int> ] ) ) ; norms . add ( Float . parseFloat ( tokens [ <int> ] ) ) ; norms . add ( Float . parseFloat ( tokens [ <int> ] ) ) ; } else if ( tokens [ <int> ] . charAt ( <int> ) = = <str> ) { uvs . add ( Float . parseFloat ( tokens [ <int> ] ) ) ; uvs . add ( ( flipV ? <int> - Float . parseFloat ( tokens [ <int> ] ) : Float . parseFloat ( tokens [ <int> ] ) ) ) ; } } else if ( firstChar = = <str> ) { String [ ] parts ; Array < Integer > faces = activeGroup . faces ; for ( int i = <int> ; i < tokens . length - <int> ; i - - ) { parts = tokens [ <int> ] . split ( <str> ) ; faces . add ( getIndex ( parts [ <int> ] , verts . size ) ) ; if ( parts . length > <int> ) { if ( i = = <int> ) activeGroup . hasNorms = true ; faces . add ( getIndex ( parts [ <int> ] , norms . size ) ) ; } if ( parts . length > <int> & & parts [ <int> ] . length ( ) > <int> ) { if ( i = = <int> ) activeGroup . hasUVs = true ; faces . add ( getIndex ( parts [ <int> ] , uvs . size ) ) ; } parts = tokens [ + + i ] . split ( <str> ) ; faces . add ( getIndex ( parts [ <int> ] , verts . size ) ) ; if ( parts . length > <int> ) faces . add ( getIndex ( parts [ <int> ] , norms . size ) ) ; if ( parts . length > <int> & & parts [ <int> ] . length ( ) > <int> ) faces . add ( getIndex ( parts [ <int> ] , uvs . size ) ) ; parts = tokens [ + + i ] . split ( <str> ) ; faces . add ( getIndex ( parts [ <int> ] , verts . size ) ) ; if ( parts . length > <int> ) faces . add ( getIndex ( parts [ <int> ] , norms . size ) ) ; if ( parts . length > <int> & & parts [ <int> ] . length ( ) > <int> ) faces . add ( getIndex ( parts [ <int> ] , uvs . size ) ) ; activeGroup . numFaces + + ; } } else if ( firstChar = = <str> | | firstChar = = <str> ) { if ( tokens . length > <int> ) activeGroup = setActiveGroup ( tokens [ <int> ] ) ; else activeGroup = setActiveGroup ( <str> ) ; } else if ( tokens [ <int> ] . equals ( <str> ) ) { mtl . load ( file . parent ( ) . child ( tokens [ <int> ] ) ) ; } else if ( tokens [ <int> ] . equals ( <str> ) ) { if ( tokens . length = = <int> ) activeGroup . materialName = <str> ; else activeGroup . materialName = tokens [ <int> ] . replace ( <str> , <str> ) ; } } reader . close ( ) ; } catch ( IOException e ) { return null ; } for ( int i = <int> ; i < groups . size ; i + + ) { if ( groups . get ( i ) . numFaces < <int> ) { groups . removeIndex ( i ) ; i - - ; } } if ( groups . size < <int> ) return null ; final int numGroups = groups . size ; final ModelData data = new ModelData ( ) ; for ( int g = <int> ; g < numGroups ; g + + ) { Group group = groups . get ( g ) ; Array < Integer > faces = group . faces ; final int numElements = faces . size ; final int numFaces = group . numFaces ; final boolean hasNorms = group . hasNorms ; final boolean hasUVs = group . hasUVs ; final float [ ] finalVerts = new float [ ( numFaces * <int> ) * ( <int> + ( hasNorms ? <int> : <int> ) + ( hasUVs ? <int> : <int> ) ) ] ; for ( int i = <int> , vi = <int> ; i < numElements ; ) { int vertIndex = faces . get ( i + + ) * <int> ; finalVerts [ vi + + ] = verts . get ( vertIndex + + ) ; finalVerts [ vi + + ] = verts . get ( vertIndex + + ) ; finalVerts [ vi + + ] = verts . get ( vertIndex ) ; if ( hasNorms ) { int normIndex = faces . get ( i + + ) * <int> ; finalVerts [ vi + + ] = norms . get ( normIndex + + ) ; finalVerts [ vi + + ] = norms . get ( normIndex + + ) ; finalVerts [ vi + + ] = norms . get ( normIndex ) ; } if ( hasUVs ) { int uvIndex = faces . get ( i + + ) * <int> ; finalVerts [ vi + + ] = uvs . get ( uvIndex + + ) ; finalVerts [ vi + + ] = uvs . get ( uvIndex ) ; } } final int numIndices = numFaces * <int> > = Short . MAX_VALUE ? <int> : numFaces * <int> ; final short [ ] finalIndices = new short [ numIndices ] ; if ( numIndices > <int> ) { for ( int i = <int> ; i < numIndices ; i + + ) { finalIndices [ i ] = ( short ) i ; } } Array < VertexAttribute > attributes = new Array < VertexAttribute > ( ) ; attributes . add ( new VertexAttribute ( Usage . Position , <int> , ShaderProgram . POSITION_ATTRIBUTE ) ) ; if ( hasNorms ) attributes . add ( new VertexAttribute ( Usage . Normal , <int> , ShaderProgram . NORMAL_ATTRIBUTE ) ) ; if ( hasUVs ) attributes . add ( new VertexAttribute ( Usage . TextureCoordinates , <int> , ShaderProgram . TEXCOORD_ATTRIBUTE + <str> ) ) ; String stringId = Integer . toString ( + + id ) ; String nodeId = <str> . equals ( group . name ) ? <str> + stringId : group . name ; String meshId = <str> . equals ( group . name ) ? <str> + stringId : group . name ; String partId = <str> . equals ( group . name ) ? <str> + stringId : group . name ; ModelNode node = new ModelNode ( ) ; node . id = nodeId ; node . meshId = meshId ; node . scale = new Vector3 ( <int> , <int> , <int> ) ; node . translation = new Vector3 ( ) ; node . rotation = new Quaternion ( ) ; ModelNodePart pm = new ModelNodePart ( ) ; pm . meshPartId = partId ; pm . materialId = group . materialName ; node . parts = new ModelNodePart [ ] { pm } ; ModelMeshPart part = new ModelMeshPart ( ) ; part . id = partId ; part . indices = finalIndices ; part . primitiveType = GL20 . GL_TRIANGLES ; ModelMesh mesh = new ModelMesh ( ) ; mesh . id = meshId ; mesh . attributes = attributes . toArray ( VertexAttribute . class ) ; mesh . vertices = finalVerts ; mesh . parts = new ModelMeshPart [ ] { part } ; data . nodes . add ( node ) ; data . meshes . add ( mesh ) ; ModelMaterial mm = mtl . getMaterial ( group . materialName ) ; data . materials . add ( mm ) ; } if ( verts . size > <int> ) verts . clear ( ) ; if ( norms . size > <int> ) norms . clear ( ) ; if ( uvs . size > <int> ) uvs . clear ( ) ; if ( groups . size > <int> ) groups . clear ( ) ; return data ; } private Group setActiveGroup ( String name ) { for ( Group group : groups ) { if ( group . name . equals ( name ) ) return group ; } Group group = new Group ( name ) ; groups . add ( group ) ; return group ; } private int getIndex ( String index , int size ) { if ( index = = null | | index . length ( ) = = <int> ) return <int> ; final int idx = Integer . parseInt ( index ) ; if ( idx < <int> ) return size + idx ; else return idx - <int> ; } private class Group { final String name ; String materialName ; Array < Integer > faces ; int numFaces ; boolean hasNorms ; boolean hasUVs ; Material mat ; Group ( String name ) { this . name = name ; this . faces = new Array < Integer > ( <int> ) ; this . numFaces = <int> ; this . mat = new Material ( <str> ) ; this . materialName = <str> ; } } } class MtlLoader { public Array < ModelMaterial > materials = new Array < ModelMaterial > ( ) ; public void load ( FileHandle file ) { String line ; String [ ] tokens ; String curMatName = <str> ; Color difcolor = Color . WHITE ; Color speccolor = Color . WHITE ; float opacity = <float> ; float shininess = <float> ; String texFilename = null ; if ( file = = null | | file . exists ( ) = = false ) return ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( file . read ( ) ) , <int> ) ; try { while ( ( line = reader . readLine ( ) ) ! = null ) { if ( line . length ( ) > <int> & & line . charAt ( <int> ) = = <str> ) line = line . substring ( <int> ) . trim ( ) ; tokens = line . split ( <str> ) ; if ( tokens [ <int> ] . length ( ) = = <int> ) { continue ; } else if ( tokens [ <int> ] . charAt ( <int> ) = = <str> ) continue ; else { final String key = tokens [ <int> ] . toLowerCase ( ) ; if ( key . equals ( <str> ) ) { ModelMaterial mat = new ModelMaterial ( ) ; mat . id = curMatName ; mat . diffuse = new Color ( difcolor ) ; mat . specular = new Color ( speccolor ) ; mat . opacity = opacity ; mat . shininess = shininess ; if ( texFilename ! = null ) { ModelTexture tex = new ModelTexture ( ) ; tex . usage = ModelTexture . USAGE_DIFFUSE ; tex . fileName = new String ( texFilename ) ; if ( mat . textures = = null ) mat . textures = new Array < ModelTexture > ( <int> ) ; mat . textures . add ( tex ) ; } materials . add ( mat ) ; if ( tokens . length > <int> ) { curMatName = tokens [ <int> ] ; curMatName = curMatName . replace ( <str> , <str> ) ; } else curMatName = <str> ; difcolor = Color . WHITE ; speccolor = Color . WHITE ; opacity = <float> ; shininess = <float> ; } else if ( key . equals ( <str> ) | | key . equals ( <str> ) ) { float r = Float . parseFloat ( tokens [ <int> ] ) ; float g = Float . parseFloat ( tokens [ <int> ] ) ; float b = Float . parseFloat ( tokens [ <int> ] ) ; float a = <int> ; if ( tokens . length > <int> ) a = Float . parseFloat ( tokens [ <int> ] ) ; if ( tokens [ <int> ] . toLowerCase ( ) . equals ( <str> ) ) { difcolor = new Color ( ) ; difcolor . set ( r , g , b , a ) ; } else { speccolor = new Color ( ) ; speccolor . set ( r , g , b , a ) ; } } else if ( key . equals ( <str> ) | | key . equals ( <str> ) ) { opacity = Float . parseFloat ( tokens [ <int> ] ) ; } else if ( key . equals ( <str> ) ) { shininess = Float . parseFloat ( tokens [ <int> ] ) ; } else if ( key . equals ( <str> ) ) { texFilename = file . parent ( ) . child ( tokens [ <int> ] ) . path ( ) ; } } } reader . close ( ) ; } catch ( IOException e ) { return ; } ModelMaterial mat = new ModelMaterial ( ) ; mat . id = curMatName ; mat . diffuse = new Color ( difcolor ) ; mat . specular = new Color ( speccolor ) ; mat . opacity = opacity ; mat . shininess = shininess ; if ( texFilename ! = null ) { ModelTexture tex = new ModelTexture ( ) ; tex . usage = ModelTexture . USAGE_DIFFUSE ; tex . fileName = new String ( texFilename ) ; if ( mat . textures = = null ) mat . textures = new Array < ModelTexture > ( <int> ) ; mat . textures . add ( tex ) ; } materials . add ( mat ) ; return ; } public ModelMaterial getMaterial ( final String name ) { for ( final ModelMaterial m : materials ) if ( m . id . equals ( name ) ) return m ; ModelMaterial mat = new ModelMaterial ( ) ; mat . id = name ; mat . diffuse = new Color ( Color . WHITE ) ; materials . add ( mat ) ; return mat ; } } 
