package org . elasticsearch . index . shard ; import org . apache . lucene . index . MergePolicy ; import org . apache . lucene . index . NoMergePolicy ; import org . apache . lucene . index . TieredMergePolicy ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; public final class MergePolicyConfig { private final TieredMergePolicy mergePolicy = new TieredMergePolicy ( ) ; private final ESLogger logger ; private final boolean mergesEnabled ; private volatile double noCFSRatio ; public static final double DEFAULT_EXPUNGE_DELETES_ALLOWED = <int> d ; public static final ByteSizeValue DEFAULT_FLOOR_SEGMENT = new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ; public static final int DEFAULT_MAX_MERGE_AT_ONCE = <int> ; public static final int DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT = <int> ; public static final ByteSizeValue DEFAULT_MAX_MERGED_SEGMENT = new ByteSizeValue ( <int> , ByteSizeUnit . GB ) ; public static final double DEFAULT_SEGMENTS_PER_TIER = <float> ; public static final double DEFAULT_RECLAIM_DELETES_WEIGHT = <float> ; public static final String INDEX_COMPOUND_FORMAT = <str> ; public static final String INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED = <str> ; public static final String INDEX_MERGE_POLICY_FLOOR_SEGMENT = <str> ; public static final String INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE = <str> ; public static final String INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT = <str> ; public static final String INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT = <str> ; public static final String INDEX_MERGE_POLICY_SEGMENTS_PER_TIER = <str> ; public static final String INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT = <str> ; public static final String INDEX_MERGE_ENABLED = <str> ; public MergePolicyConfig ( ESLogger logger , Settings indexSettings ) { this . logger = logger ; this . noCFSRatio = parseNoCFSRatio ( indexSettings . get ( INDEX_COMPOUND_FORMAT , Double . toString ( TieredMergePolicy . DEFAULT_NO_CFS_RATIO ) ) ) ; double forceMergeDeletesPctAllowed = indexSettings . getAsDouble ( <str> , DEFAULT_EXPUNGE_DELETES_ALLOWED ) ; ByteSizeValue floorSegment = indexSettings . getAsBytesSize ( <str> , DEFAULT_FLOOR_SEGMENT ) ; int maxMergeAtOnce = indexSettings . getAsInt ( <str> , DEFAULT_MAX_MERGE_AT_ONCE ) ; int maxMergeAtOnceExplicit = indexSettings . getAsInt ( <str> , DEFAULT_MAX_MERGE_AT_ONCE_EXPLICIT ) ; ByteSizeValue maxMergedSegment = indexSettings . getAsBytesSize ( <str> , DEFAULT_MAX_MERGED_SEGMENT ) ; double segmentsPerTier = indexSettings . getAsDouble ( <str> , DEFAULT_SEGMENTS_PER_TIER ) ; double reclaimDeletesWeight = indexSettings . getAsDouble ( <str> , DEFAULT_RECLAIM_DELETES_WEIGHT ) ; this . mergesEnabled = indexSettings . getAsBoolean ( INDEX_MERGE_ENABLED , true ) ; if ( mergesEnabled = = false ) { logger . warn ( <str> , INDEX_MERGE_ENABLED ) ; } maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded ( maxMergeAtOnce , segmentsPerTier ) ; mergePolicy . setNoCFSRatio ( noCFSRatio ) ; mergePolicy . setForceMergeDeletesPctAllowed ( forceMergeDeletesPctAllowed ) ; mergePolicy . setFloorSegmentMB ( floorSegment . mbFrac ( ) ) ; mergePolicy . setMaxMergeAtOnce ( maxMergeAtOnce ) ; mergePolicy . setMaxMergeAtOnceExplicit ( maxMergeAtOnceExplicit ) ; mergePolicy . setMaxMergedSegmentMB ( maxMergedSegment . mbFrac ( ) ) ; mergePolicy . setSegmentsPerTier ( segmentsPerTier ) ; mergePolicy . setReclaimDeletesWeight ( reclaimDeletesWeight ) ; logger . debug ( <str> , forceMergeDeletesPctAllowed , floorSegment , maxMergeAtOnce , maxMergeAtOnceExplicit , maxMergedSegment , segmentsPerTier , reclaimDeletesWeight ) ; } private int adjustMaxMergeAtOnceIfNeeded ( int maxMergeAtOnce , double segmentsPerTier ) { if ( ! ( segmentsPerTier > = maxMergeAtOnce ) ) { int newMaxMergeAtOnce = ( int ) segmentsPerTier ; if ( newMaxMergeAtOnce < = <int> ) { newMaxMergeAtOnce = <int> ; } logger . debug ( <str> , maxMergeAtOnce , newMaxMergeAtOnce , segmentsPerTier ) ; maxMergeAtOnce = newMaxMergeAtOnce ; } return maxMergeAtOnce ; } public MergePolicy getMergePolicy ( ) { return mergesEnabled ? mergePolicy : NoMergePolicy . INSTANCE ; } public void onRefreshSettings ( Settings settings ) { final double oldExpungeDeletesPctAllowed = mergePolicy . getForceMergeDeletesPctAllowed ( ) ; final double expungeDeletesPctAllowed = settings . getAsDouble ( INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED , oldExpungeDeletesPctAllowed ) ; if ( expungeDeletesPctAllowed ! = oldExpungeDeletesPctAllowed ) { logger . info ( <str> , oldExpungeDeletesPctAllowed , expungeDeletesPctAllowed ) ; mergePolicy . setForceMergeDeletesPctAllowed ( expungeDeletesPctAllowed ) ; } final double oldFloorSegmentMB = mergePolicy . getFloorSegmentMB ( ) ; final ByteSizeValue floorSegment = settings . getAsBytesSize ( INDEX_MERGE_POLICY_FLOOR_SEGMENT , null ) ; if ( floorSegment ! = null & & floorSegment . mbFrac ( ) ! = oldFloorSegmentMB ) { logger . info ( <str> , oldFloorSegmentMB , floorSegment ) ; mergePolicy . setFloorSegmentMB ( floorSegment . mbFrac ( ) ) ; } final double oldSegmentsPerTier = mergePolicy . getSegmentsPerTier ( ) ; final double segmentsPerTier = settings . getAsDouble ( INDEX_MERGE_POLICY_SEGMENTS_PER_TIER , oldSegmentsPerTier ) ; if ( segmentsPerTier ! = oldSegmentsPerTier ) { logger . info ( <str> , oldSegmentsPerTier , segmentsPerTier ) ; mergePolicy . setSegmentsPerTier ( segmentsPerTier ) ; } final int oldMaxMergeAtOnce = mergePolicy . getMaxMergeAtOnce ( ) ; int maxMergeAtOnce = settings . getAsInt ( INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE , oldMaxMergeAtOnce ) ; if ( maxMergeAtOnce ! = oldMaxMergeAtOnce ) { logger . info ( <str> , oldMaxMergeAtOnce , maxMergeAtOnce ) ; maxMergeAtOnce = adjustMaxMergeAtOnceIfNeeded ( maxMergeAtOnce , segmentsPerTier ) ; mergePolicy . setMaxMergeAtOnce ( maxMergeAtOnce ) ; } final int oldMaxMergeAtOnceExplicit = mergePolicy . getMaxMergeAtOnceExplicit ( ) ; final int maxMergeAtOnceExplicit = settings . getAsInt ( INDEX_MERGE_POLICY_MAX_MERGE_AT_ONCE_EXPLICIT , oldMaxMergeAtOnceExplicit ) ; if ( maxMergeAtOnceExplicit ! = oldMaxMergeAtOnceExplicit ) { logger . info ( <str> , oldMaxMergeAtOnceExplicit , maxMergeAtOnceExplicit ) ; mergePolicy . setMaxMergeAtOnceExplicit ( maxMergeAtOnceExplicit ) ; } final double oldMaxMergedSegmentMB = mergePolicy . getMaxMergedSegmentMB ( ) ; final ByteSizeValue maxMergedSegment = settings . getAsBytesSize ( INDEX_MERGE_POLICY_MAX_MERGED_SEGMENT , null ) ; if ( maxMergedSegment ! = null & & maxMergedSegment . mbFrac ( ) ! = oldMaxMergedSegmentMB ) { logger . info ( <str> , oldMaxMergedSegmentMB , maxMergedSegment ) ; mergePolicy . setMaxMergedSegmentMB ( maxMergedSegment . mbFrac ( ) ) ; } final double oldReclaimDeletesWeight = mergePolicy . getReclaimDeletesWeight ( ) ; final double reclaimDeletesWeight = settings . getAsDouble ( INDEX_MERGE_POLICY_RECLAIM_DELETES_WEIGHT , oldReclaimDeletesWeight ) ; if ( reclaimDeletesWeight ! = oldReclaimDeletesWeight ) { logger . info ( <str> , oldReclaimDeletesWeight , reclaimDeletesWeight ) ; mergePolicy . setReclaimDeletesWeight ( reclaimDeletesWeight ) ; } double noCFSRatio = parseNoCFSRatio ( settings . get ( INDEX_COMPOUND_FORMAT , Double . toString ( MergePolicyConfig . this . noCFSRatio ) ) ) ; if ( noCFSRatio ! = MergePolicyConfig . this . noCFSRatio ) { logger . info ( <str> , formatNoCFSRatio ( MergePolicyConfig . this . noCFSRatio ) , formatNoCFSRatio ( noCFSRatio ) ) ; mergePolicy . setNoCFSRatio ( noCFSRatio ) ; MergePolicyConfig . this . noCFSRatio = noCFSRatio ; } } public static double parseNoCFSRatio ( String noCFSRatio ) { noCFSRatio = noCFSRatio . trim ( ) ; if ( noCFSRatio . equalsIgnoreCase ( <str> ) ) { return <float> ; } else if ( noCFSRatio . equalsIgnoreCase ( <str> ) ) { return <float> ; } else { try { double value = Double . parseDouble ( noCFSRatio ) ; if ( value < <float> | | value > <float> ) { throw new IllegalArgumentException ( <str> + value + <str> ) ; } return value ; } catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( <str> + noCFSRatio + <str> , ex ) ; } } } public static String formatNoCFSRatio ( double ratio ) { if ( ratio = = <float> ) { return Boolean . TRUE . toString ( ) ; } else if ( ratio = = <float> ) { return Boolean . FALSE . toString ( ) ; } else { return Double . toString ( ratio ) ; } } } 
