package com . google . common . primitives ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkElementIndex ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkPositionIndexes ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Converter ; import java . io . Serializable ; import java . util . AbstractList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . RandomAccess ; import javax . annotation . CheckForNull ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @CheckReturnValue @GwtCompatible public final class Longs { private Longs ( ) { } public static final int BYTES = Long . SIZE / Byte . SIZE ; public static final long MAX_POWER_OF_TWO = <int> < < ( Long . SIZE - <int> ) ; public static int hashCode ( long value ) { return ( int ) ( value ^ ( value > > > <int> ) ) ; } public static int compare ( long a , long b ) { return ( a < b ) ? - <int> : ( ( a > b ) ? <int> : <int> ) ; } public static boolean contains ( long [ ] array , long target ) { for ( long value : array ) { if ( value = = target ) { return true ; } } return false ; } public static int indexOf ( long [ ] array , long target ) { return indexOf ( array , target , <int> , array . length ) ; } private static int indexOf ( long [ ] array , long target , int start , int end ) { for ( int i = start ; i < end ; i + + ) { if ( array [ i ] = = target ) { return i ; } } return - <int> ; } public static int indexOf ( long [ ] array , long [ ] target ) { checkNotNull ( array , <str> ) ; checkNotNull ( target , <str> ) ; if ( target . length = = <int> ) { return <int> ; } outer: for ( int i = <int> ; i < array . length - target . length + <int> ; i + + ) { for ( int j = <int> ; j < target . length ; j + + ) { if ( array [ i + j ] ! = target [ j ] ) { continue outer ; } } return i ; } return - <int> ; } public static int lastIndexOf ( long [ ] array , long target ) { return lastIndexOf ( array , target , <int> , array . length ) ; } private static int lastIndexOf ( long [ ] array , long target , int start , int end ) { for ( int i = end - <int> ; i > = start ; i - - ) { if ( array [ i ] = = target ) { return i ; } } return - <int> ; } public static long min ( long . . . array ) { checkArgument ( array . length > <int> ) ; long min = array [ <int> ] ; for ( int i = <int> ; i < array . length ; i + + ) { if ( array [ i ] < min ) { min = array [ i ] ; } } return min ; } public static long max ( long . . . array ) { checkArgument ( array . length > <int> ) ; long max = array [ <int> ] ; for ( int i = <int> ; i < array . length ; i + + ) { if ( array [ i ] > max ) { max = array [ i ] ; } } return max ; } public static long [ ] concat ( long [ ] . . . arrays ) { int length = <int> ; for ( long [ ] array : arrays ) { length + = array . length ; } long [ ] result = new long [ length ] ; int pos = <int> ; for ( long [ ] array : arrays ) { System . arraycopy ( array , <int> , result , pos , array . length ) ; pos + = array . length ; } return result ; } public static byte [ ] toByteArray ( long value ) { byte [ ] result = new byte [ <int> ] ; for ( int i = <int> ; i > = <int> ; i - - ) { result [ i ] = ( byte ) ( value & <hex> ) ; value > > = <int> ; } return result ; } public static long fromByteArray ( byte [ ] bytes ) { checkArgument ( bytes . length > = BYTES , <str> , bytes . length , BYTES ) ; return fromBytes ( bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] , bytes [ <int> ] ) ; } public static long fromBytes ( byte b1 , byte b2 , byte b3 , byte b4 , byte b5 , byte b6 , byte b7 , byte b8 ) { return ( b1 & <hex> ) < < <int> | ( b2 & <hex> ) < < <int> | ( b3 & <hex> ) < < <int> | ( b4 & <hex> ) < < <int> | ( b5 & <hex> ) < < <int> | ( b6 & <hex> ) < < <int> | ( b7 & <hex> ) < < <int> | ( b8 & <hex> ) ; } private static final byte [ ] asciiDigits = createAsciiDigits ( ) ; private static byte [ ] createAsciiDigits ( ) { byte [ ] result = new byte [ <int> ] ; Arrays . fill ( result , ( byte ) - <int> ) ; for ( int i = <int> ; i < = <int> ; i + + ) { result [ <str> + i ] = ( byte ) i ; } for ( int i = <int> ; i < = <int> ; i + + ) { result [ <str> + i ] = ( byte ) ( <int> + i ) ; result [ <str> + i ] = ( byte ) ( <int> + i ) ; } return result ; } private static int digit ( char c ) { return ( c < <int> ) ? asciiDigits [ c ] : - <int> ; } @Beta @Nullable @CheckForNull public static Long tryParse ( String string ) { return tryParse ( string , <int> ) ; } @Beta @Nullable @CheckForNull public static Long tryParse ( String string , int radix ) { if ( checkNotNull ( string ) . isEmpty ( ) ) { return null ; } if ( radix < Character . MIN_RADIX | | radix > Character . MAX_RADIX ) { throw new IllegalArgumentException ( <str> + radix ) ; } boolean negative = string . charAt ( <int> ) = = <str> ; int index = negative ? <int> : <int> ; if ( index = = string . length ( ) ) { return null ; } int digit = digit ( string . charAt ( index + + ) ) ; if ( digit < <int> | | digit > = radix ) { return null ; } long accum = - digit ; long cap = Long . MIN_VALUE / radix ; while ( index < string . length ( ) ) { digit = digit ( string . charAt ( index + + ) ) ; if ( digit < <int> | | digit > = radix | | accum < cap ) { return null ; } accum * = radix ; if ( accum < Long . MIN_VALUE + digit ) { return null ; } accum - = digit ; } if ( negative ) { return accum ; } else if ( accum = = Long . MIN_VALUE ) { return null ; } else { return - accum ; } } private static final class LongConverter extends Converter < String , Long > implements Serializable { static final LongConverter INSTANCE = new LongConverter ( ) ; @Override protected Long doForward ( String value ) { return Long . decode ( value ) ; } @Override protected String doBackward ( Long value ) { return value . toString ( ) ; } @Override public String toString ( ) { return <str> ; } private Object readResolve ( ) { return INSTANCE ; } private static final long serialVersionUID = <int> ; } @Beta public static Converter < String , Long > stringConverter ( ) { return LongConverter . INSTANCE ; } public static long [ ] ensureCapacity ( long [ ] array , int minLength , int padding ) { checkArgument ( minLength > = <int> , <str> , minLength ) ; checkArgument ( padding > = <int> , <str> , padding ) ; return ( array . length < minLength ) ? copyOf ( array , minLength + padding ) : array ; } private static long [ ] copyOf ( long [ ] original , int length ) { long [ ] copy = new long [ length ] ; System . arraycopy ( original , <int> , copy , <int> , Math . min ( original . length , length ) ) ; return copy ; } public static String join ( String separator , long . . . array ) { checkNotNull ( separator ) ; if ( array . length = = <int> ) { return <str> ; } StringBuilder builder = new StringBuilder ( array . length * <int> ) ; builder . append ( array [ <int> ] ) ; for ( int i = <int> ; i < array . length ; i + + ) { builder . append ( separator ) . append ( array [ i ] ) ; } return builder . toString ( ) ; } public static Comparator < long [ ] > lexicographicalComparator ( ) { return LexicographicalComparator . INSTANCE ; } private enum LexicographicalComparator implements Comparator < long [ ] > { INSTANCE ; @Override public int compare ( long [ ] left , long [ ] right ) { int minLength = Math . min ( left . length , right . length ) ; for ( int i = <int> ; i < minLength ; i + + ) { int result = Longs . compare ( left [ i ] , right [ i ] ) ; if ( result ! = <int> ) { return result ; } } return left . length - right . length ; } @Override public String toString ( ) { return <str> ; } } public static long [ ] toArray ( Collection < ? extends Number > collection ) { if ( collection instanceof LongArrayAsList ) { return ( ( LongArrayAsList ) collection ) . toLongArray ( ) ; } Object [ ] boxedArray = collection . toArray ( ) ; int len = boxedArray . length ; long [ ] array = new long [ len ] ; for ( int i = <int> ; i < len ; i + + ) { array [ i ] = ( ( Number ) checkNotNull ( boxedArray [ i ] ) ) . longValue ( ) ; } return array ; } public static List < Long > asList ( long . . . backingArray ) { if ( backingArray . length = = <int> ) { return Collections . emptyList ( ) ; } return new LongArrayAsList ( backingArray ) ; } @GwtCompatible private static class LongArrayAsList extends AbstractList < Long > implements RandomAccess , Serializable { final long [ ] array ; final int start ; final int end ; LongArrayAsList ( long [ ] array ) { this ( array , <int> , array . length ) ; } LongArrayAsList ( long [ ] array , int start , int end ) { this . array = array ; this . start = start ; this . end = end ; } @Override public int size ( ) { return end - start ; } @Override public boolean isEmpty ( ) { return false ; } @Override public Long get ( int index ) { checkElementIndex ( index , size ( ) ) ; return array [ start + index ] ; } @Override public boolean contains ( Object target ) { return ( target instanceof Long ) & & Longs . indexOf ( array , ( Long ) target , start , end ) ! = - <int> ; } @Override public int indexOf ( Object target ) { if ( target instanceof Long ) { int i = Longs . indexOf ( array , ( Long ) target , start , end ) ; if ( i > = <int> ) { return i - start ; } } return - <int> ; } @Override public int lastIndexOf ( Object target ) { if ( target instanceof Long ) { int i = Longs . lastIndexOf ( array , ( Long ) target , start , end ) ; if ( i > = <int> ) { return i - start ; } } return - <int> ; } @Override public Long set ( int index , Long element ) { checkElementIndex ( index , size ( ) ) ; long oldValue = array [ start + index ] ; array [ start + index ] = checkNotNull ( element ) ; return oldValue ; } @Override public List < Long > subList ( int fromIndex , int toIndex ) { int size = size ( ) ; checkPositionIndexes ( fromIndex , toIndex , size ) ; if ( fromIndex = = toIndex ) { return Collections . emptyList ( ) ; } return new LongArrayAsList ( array , start + fromIndex , start + toIndex ) ; } @Override public boolean equals ( @Nullable Object object ) { if ( object = = this ) { return true ; } if ( object instanceof LongArrayAsList ) { LongArrayAsList that = ( LongArrayAsList ) object ; int size = size ( ) ; if ( that . size ( ) ! = size ) { return false ; } for ( int i = <int> ; i < size ; i + + ) { if ( array [ start + i ] ! = that . array [ that . start + i ] ) { return false ; } } return true ; } return super . equals ( object ) ; } @Override public int hashCode ( ) { int result = <int> ; for ( int i = start ; i < end ; i + + ) { result = <int> * result + Longs . hashCode ( array [ i ] ) ; } return result ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( size ( ) * <int> ) ; builder . append ( <str> ) . append ( array [ start ] ) ; for ( int i = start + <int> ; i < end ; i + + ) { builder . append ( <str> ) . append ( array [ i ] ) ; } return builder . append ( <str> ) . toString ( ) ; } long [ ] toLongArray ( ) { int size = size ( ) ; long [ ] result = new long [ size ] ; System . arraycopy ( array , start , result , <int> , size ) ; return result ; } private static final long serialVersionUID = <int> ; } } 
