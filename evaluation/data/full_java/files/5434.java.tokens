package org . elasticsearch . action . support . nodes ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . action . FailedNodeException ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import java . io . IOException ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; public abstract class BaseNodesResponse < TNodeResponse extends BaseNodeResponse > extends ActionResponse implements Iterable < TNodeResponse > { private ClusterName clusterName ; protected TNodeResponse [ ] nodes ; private Map < String , TNodeResponse > nodesMap ; protected BaseNodesResponse ( ) { } protected BaseNodesResponse ( ClusterName clusterName , TNodeResponse [ ] nodes ) { this . clusterName = clusterName ; this . nodes = nodes ; } @Nullable public FailedNodeException [ ] failures ( ) { return null ; } public ClusterName getClusterName ( ) { return this . clusterName ; } public String getClusterNameAsString ( ) { return this . clusterName . value ( ) ; } public TNodeResponse [ ] getNodes ( ) { return nodes ; } public TNodeResponse getAt ( int position ) { return nodes [ position ] ; } @Override public Iterator < TNodeResponse > iterator ( ) { return getNodesMap ( ) . values ( ) . iterator ( ) ; } public Map < String , TNodeResponse > getNodesMap ( ) { if ( nodesMap = = null ) { nodesMap = new HashMap < > ( ) ; for ( TNodeResponse nodeResponse : nodes ) { nodesMap . put ( nodeResponse . getNode ( ) . id ( ) , nodeResponse ) ; } } return nodesMap ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; clusterName = ClusterName . readClusterName ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; clusterName . writeTo ( out ) ; } } 
