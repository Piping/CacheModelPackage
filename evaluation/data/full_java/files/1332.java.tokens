package org . apache . cassandra ; import java . nio . ByteBuffer ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . service . StorageService ; public class UpdateBuilder { private final PartitionUpdate update ; private RowUpdateBuilder currentRow ; private long timestamp = FBUtilities . timestampMicros ( ) ; private UpdateBuilder ( CFMetaData metadata , DecoratedKey partitionKey ) { this . update = new PartitionUpdate ( metadata , partitionKey , metadata . partitionColumns ( ) , <int> ) ; } public static UpdateBuilder create ( CFMetaData metadata , Object . . . partitionKey ) { return new UpdateBuilder ( metadata , makeKey ( metadata , partitionKey ) ) ; } public UpdateBuilder withTimestamp ( long timestamp ) { this . timestamp = timestamp ; return this ; } public UpdateBuilder newRow ( Object . . . clustering ) { maybeBuildCurrentRow ( ) ; currentRow = new RowUpdateBuilder ( update , timestamp , <int> ) ; if ( clustering . length > <int> ) currentRow . clustering ( clustering ) ; return this ; } public UpdateBuilder add ( String column , Object value ) { assert currentRow ! = null ; currentRow . add ( column , value ) ; return this ; } public PartitionUpdate build ( ) { maybeBuildCurrentRow ( ) ; return update ; } public IMutation makeMutation ( ) { Mutation m = new Mutation ( build ( ) ) ; return update . metadata ( ) . isCounter ( ) ? new CounterMutation ( m , ConsistencyLevel . ONE ) : m ; } public void apply ( ) { Mutation m = new Mutation ( build ( ) ) ; if ( update . metadata ( ) . isCounter ( ) ) new CounterMutation ( m , ConsistencyLevel . ONE ) . apply ( ) ; else m . apply ( ) ; } public void applyUnsafe ( ) { assert ! update . metadata ( ) . isCounter ( ) : <str> ; new Mutation ( build ( ) ) . applyUnsafe ( ) ; } private void maybeBuildCurrentRow ( ) { if ( currentRow ! = null ) { currentRow . build ( ) ; currentRow = null ; } } private static DecoratedKey makeKey ( CFMetaData metadata , Object [ ] partitionKey ) { if ( partitionKey . length = = <int> & & partitionKey [ <int> ] instanceof DecoratedKey ) return ( DecoratedKey ) partitionKey [ <int> ] ; ByteBuffer key = CFMetaData . serializePartitionKey ( metadata . getKeyValidatorAsClusteringComparator ( ) . make ( partitionKey ) ) ; return metadata . decorateKey ( key ) ; } } 
