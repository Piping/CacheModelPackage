package org . elasticsearch . script . mustache ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . test . ESTestCase ; import org . junit . Before ; import java . io . IOException ; import java . io . StringWriter ; import java . nio . charset . Charset ; import java . util . HashMap ; import java . util . Map ; import static org . hamcrest . Matchers . equalTo ; public class MustacheScriptEngineTests extends ESTestCase { private MustacheScriptEngineService qe ; private JsonEscapingMustacheFactory escaper ; @Before public void setup ( ) { qe = new MustacheScriptEngineService ( Settings . Builder . EMPTY_SETTINGS ) ; escaper = new JsonEscapingMustacheFactory ( ) ; } public void testSimpleParameterReplace ( ) { { String template = <str> + <str> + <str> + <str> + <str> ; Map < String , Object > vars = new HashMap < > ( ) ; vars . put ( <str> , <str> ) ; BytesReference o = ( BytesReference ) qe . executable ( new CompiledScript ( ScriptService . ScriptType . INLINE , <str> , <str> , qe . compile ( template ) ) , vars ) . run ( ) ; assertEquals ( <str> + <str> , new String ( o . toBytes ( ) , Charset . forName ( <str> ) ) ) ; } { String template = <str> + <str> + <str> + <str> + <str> ; Map < String , Object > vars = new HashMap < > ( ) ; vars . put ( <str> , <str> ) ; vars . put ( <str> , <str> ) ; BytesReference o = ( BytesReference ) qe . executable ( new CompiledScript ( ScriptService . ScriptType . INLINE , <str> , <str> , qe . compile ( template ) ) , vars ) . run ( ) ; assertEquals ( <str> + <str> , new String ( o . toBytes ( ) , Charset . forName ( <str> ) ) ) ; } } public void testEscapeJson ( ) throws IOException { { StringWriter writer = new StringWriter ( ) ; escaper . encode ( <str> , writer ) ; assertThat ( writer . toString ( ) , equalTo ( <str> ) ) ; } { StringWriter writer = new StringWriter ( ) ; escaper . encode ( <str> , writer ) ; assertThat ( writer . toString ( ) , equalTo ( <str> ) ) ; } Character [ ] specialChars = new Character [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; String [ ] escapedChars = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; int iters = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { int rounds = scaledRandomIntBetween ( <int> , <int> ) ; StringWriter expect = new StringWriter ( ) ; StringWriter writer = new StringWriter ( ) ; for ( int j = <int> ; j < rounds ; j + + ) { String s = getChars ( ) ; writer . write ( s ) ; expect . write ( s ) ; int charIndex = randomInt ( <int> ) ; writer . append ( specialChars [ charIndex ] ) ; expect . append ( escapedChars [ charIndex ] ) ; } StringWriter target = new StringWriter ( ) ; escaper . encode ( writer . toString ( ) , target ) ; assertThat ( expect . toString ( ) , equalTo ( target . toString ( ) ) ) ; } } private String getChars ( ) { String string = randomRealisticUnicodeOfCodepointLengthBetween ( <int> , <int> ) ; for ( int i = <int> ; i < string . length ( ) ; i + + ) { if ( isEscapeChar ( string . charAt ( i ) ) ) { return string . substring ( <int> , i ) ; } } return string ; } private static boolean isEscapeChar ( char c ) { switch ( c ) { case <str> : case <str> : return true ; } if ( c < <str> ) return true ; return false ; } } 
