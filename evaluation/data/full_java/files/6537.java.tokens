package org . elasticsearch . index . mapper ; import com . carrotsearch . hppc . ObjectHashSet ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . DelegatingAnalyzerWrapper ; import org . apache . lucene . index . IndexOptions ; import org . apache . lucene . index . Term ; import org . apache . lucene . queries . TermsQuery ; import org . apache . lucene . search . * ; import org . apache . lucene . search . BooleanClause . Occur ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . ElasticsearchGenerationException ; import org . elasticsearch . Version ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . util . concurrent . ReleasableLock ; import org . elasticsearch . index . AbstractIndexComponent ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . analysis . AnalysisService ; import org . elasticsearch . index . mapper . Mapper . BuilderContext ; import org . elasticsearch . index . mapper . internal . TypeFieldMapper ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import org . elasticsearch . index . similarity . SimilarityService ; import org . elasticsearch . indices . InvalidTypeNameException ; import org . elasticsearch . indices . TypeMissingException ; import org . elasticsearch . indices . mapper . MapperRegistry ; import org . elasticsearch . percolator . PercolatorService ; import org . elasticsearch . script . ScriptService ; import java . io . Closeable ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . locks . ReentrantReadWriteLock ; import java . util . function . Function ; import java . util . stream . Collectors ; import static java . util . Collections . * ; import static org . elasticsearch . common . collect . MapBuilder . newMapBuilder ; public class MapperService extends AbstractIndexComponent implements Closeable { public static final String DEFAULT_MAPPING = <str> ; private static ObjectHashSet < String > META_FIELDS = ObjectHashSet . from ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; private final AnalysisService analysisService ; private final boolean dynamic ; private volatile String defaultMappingSource ; private volatile String defaultPercolatorMappingSource ; private volatile Map < String , DocumentMapper > mappers = emptyMap ( ) ; final ReentrantReadWriteLock mappingLock = new ReentrantReadWriteLock ( ) ; private final ReleasableLock mappingWriteLock = new ReleasableLock ( mappingLock . writeLock ( ) ) ; private volatile FieldTypeLookup fieldTypes ; private volatile ImmutableOpenMap < String , ObjectMapper > fullPathObjectMappers = ImmutableOpenMap . of ( ) ; private boolean hasNested = false ; private final DocumentMapperParser documentParser ; private final MapperAnalyzerWrapper indexAnalyzer ; private final MapperAnalyzerWrapper searchAnalyzer ; private final MapperAnalyzerWrapper searchQuoteAnalyzer ; private final List < DocumentTypeListener > typeListeners = new CopyOnWriteArrayList < > ( ) ; private volatile Map < String , MappedFieldType > unmappedFieldTypes = emptyMap ( ) ; private volatile Set < String > parentTypes = emptySet ( ) ; final MapperRegistry mapperRegistry ; public MapperService ( IndexSettings indexSettings , AnalysisService analysisService , SimilarityService similarityService , MapperRegistry mapperRegistry ) { super ( indexSettings ) ; this . analysisService = analysisService ; this . fieldTypes = new FieldTypeLookup ( ) ; this . documentParser = new DocumentMapperParser ( indexSettings , this , analysisService , similarityService , mapperRegistry ) ; this . indexAnalyzer = new MapperAnalyzerWrapper ( analysisService . defaultIndexAnalyzer ( ) , p - > p . indexAnalyzer ( ) ) ; this . searchAnalyzer = new MapperAnalyzerWrapper ( analysisService . defaultSearchAnalyzer ( ) , p - > p . searchAnalyzer ( ) ) ; this . searchQuoteAnalyzer = new MapperAnalyzerWrapper ( analysisService . defaultSearchQuoteAnalyzer ( ) , p - > p . searchQuoteAnalyzer ( ) ) ; this . mapperRegistry = mapperRegistry ; this . dynamic = this . indexSettings . getSettings ( ) . getAsBoolean ( <str> , true ) ; defaultPercolatorMappingSource = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; if ( index ( ) . getName ( ) . equals ( ScriptService . SCRIPT_INDEX ) ) { defaultMappingSource = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; } else { defaultMappingSource = <str> ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , dynamic , defaultMappingSource , defaultPercolatorMappingSource ) ; } else if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , dynamic ) ; } } @Override public void close ( ) { for ( DocumentMapper documentMapper : mappers . values ( ) ) { documentMapper . close ( ) ; } } public boolean hasNested ( ) { return this . hasNested ; } public Iterable < DocumentMapper > docMappers ( final boolean includingDefaultMapping ) { return ( ) - > { final Collection < DocumentMapper > documentMappers ; if ( includingDefaultMapping ) { documentMappers = mappers . values ( ) ; } else { documentMappers = mappers . values ( ) . stream ( ) . filter ( mapper - > ! DEFAULT_MAPPING . equals ( mapper . type ( ) ) ) . collect ( Collectors . toList ( ) ) ; } return Collections . unmodifiableCollection ( documentMappers ) . iterator ( ) ; } ; } public AnalysisService analysisService ( ) { return this . analysisService ; } public DocumentMapperParser documentMapperParser ( ) { return this . documentParser ; } public void addTypeListener ( DocumentTypeListener listener ) { typeListeners . add ( listener ) ; } public void removeTypeListener ( DocumentTypeListener listener ) { typeListeners . remove ( listener ) ; } public DocumentMapper merge ( String type , CompressedXContent mappingSource , boolean applyDefault , boolean updateAllTypes ) { if ( DEFAULT_MAPPING . equals ( type ) ) { DocumentMapper mapper = documentParser . parseCompressed ( type , mappingSource ) ; try ( ReleasableLock lock = mappingWriteLock . acquire ( ) ) { mappers = newMapBuilder ( mappers ) . put ( type , mapper ) . map ( ) ; } try { defaultMappingSource = mappingSource . string ( ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } return mapper ; } else { return merge ( parse ( type , mappingSource , applyDefault ) , updateAllTypes ) ; } } private DocumentMapper merge ( DocumentMapper mapper , boolean updateAllTypes ) { try ( ReleasableLock lock = mappingWriteLock . acquire ( ) ) { if ( mapper . type ( ) . length ( ) = = <int> ) { throw new InvalidTypeNameException ( <str> ) ; } if ( indexSettings . getIndexVersionCreated ( ) . onOrAfter ( Version . V_2_0_0_beta1 ) & & mapper . type ( ) . length ( ) > <int> ) { throw new InvalidTypeNameException ( <str> + mapper . type ( ) + <str> + mapper . type ( ) . length ( ) + <str> ) ; } if ( mapper . type ( ) . charAt ( <int> ) = = <str> ) { throw new InvalidTypeNameException ( <str> + mapper . type ( ) + <str> ) ; } if ( mapper . type ( ) . contains ( <str> ) ) { throw new InvalidTypeNameException ( <str> + mapper . type ( ) + <str> ) ; } if ( mapper . type ( ) . contains ( <str> ) ) { throw new InvalidTypeNameException ( <str> + mapper . type ( ) + <str> ) ; } if ( mapper . type ( ) . equals ( mapper . parentFieldMapper ( ) . type ( ) ) ) { throw new IllegalArgumentException ( <str> ) ; } if ( typeNameStartsWithIllegalDot ( mapper ) ) { if ( indexSettings . getIndexVersionCreated ( ) . onOrAfter ( Version . V_2_0_0_beta1 ) ) { throw new IllegalArgumentException ( <str> + mapper . type ( ) + <str> ) ; } else { logger . warn ( <str> , mapper . type ( ) ) ; } } DocumentMapper oldMapper = mappers . get ( mapper . type ( ) ) ; if ( oldMapper ! = null ) { MergeResult result = oldMapper . merge ( mapper . mapping ( ) , true , updateAllTypes ) ; if ( result . hasConflicts ( ) ) { throw new IllegalArgumentException ( <str> + Arrays . toString ( result . buildConflicts ( ) ) + <str> ) ; } result = oldMapper . merge ( mapper . mapping ( ) , false , updateAllTypes ) ; assert result . hasConflicts ( ) = = false ; return oldMapper ; } else { Tuple < Collection < ObjectMapper > , Collection < FieldMapper > > newMappers = checkMappersCompatibility ( mapper . type ( ) , mapper . mapping ( ) , updateAllTypes ) ; Collection < ObjectMapper > newObjectMappers = newMappers . v1 ( ) ; Collection < FieldMapper > newFieldMappers = newMappers . v2 ( ) ; addMappers ( mapper . type ( ) , newObjectMappers , newFieldMappers ) ; for ( DocumentTypeListener typeListener : typeListeners ) { typeListener . beforeCreate ( mapper ) ; } mappers = newMapBuilder ( mappers ) . put ( mapper . type ( ) , mapper ) . map ( ) ; if ( mapper . parentFieldMapper ( ) . active ( ) ) { Set < String > newParentTypes = new HashSet < > ( parentTypes . size ( ) + <int> ) ; newParentTypes . addAll ( parentTypes ) ; newParentTypes . add ( mapper . parentFieldMapper ( ) . type ( ) ) ; parentTypes = unmodifiableSet ( newParentTypes ) ; } assert assertSerialization ( mapper ) ; return mapper ; } } } private boolean typeNameStartsWithIllegalDot ( DocumentMapper mapper ) { return mapper . type ( ) . startsWith ( <str> ) & & ! PercolatorService . TYPE_NAME . equals ( mapper . type ( ) ) ; } private boolean assertSerialization ( DocumentMapper mapper ) { final CompressedXContent mappingSource = mapper . mappingSource ( ) ; DocumentMapper newMapper = parse ( mapper . type ( ) , mappingSource , false ) ; if ( newMapper . mappingSource ( ) . equals ( mappingSource ) = = false ) { throw new IllegalStateException ( <str> + mappingSource + <str> + newMapper . mappingSource ( ) + <str> ) ; } return true ; } protected void checkMappersCompatibility ( String type , Collection < ObjectMapper > objectMappers , Collection < FieldMapper > fieldMappers , boolean updateAllTypes ) { assert mappingLock . isWriteLockedByCurrentThread ( ) ; for ( ObjectMapper newObjectMapper : objectMappers ) { ObjectMapper existingObjectMapper = fullPathObjectMappers . get ( newObjectMapper . fullPath ( ) ) ; if ( existingObjectMapper ! = null ) { MergeResult result = new MergeResult ( true , updateAllTypes ) ; existingObjectMapper . merge ( newObjectMapper , result ) ; if ( result . hasConflicts ( ) ) { throw new IllegalArgumentException ( <str> + newObjectMapper . fullPath ( ) + <str> + Arrays . toString ( result . buildConflicts ( ) ) ) ; } } } fieldTypes . checkCompatibility ( type , fieldMappers , updateAllTypes ) ; } protected Tuple < Collection < ObjectMapper > , Collection < FieldMapper > > checkMappersCompatibility ( String type , Mapping mapping , boolean updateAllTypes ) { List < ObjectMapper > objectMappers = new ArrayList < > ( ) ; List < FieldMapper > fieldMappers = new ArrayList < > ( ) ; for ( MetadataFieldMapper metadataMapper : mapping . metadataMappers ) { fieldMappers . add ( metadataMapper ) ; } MapperUtils . collect ( mapping . root , objectMappers , fieldMappers ) ; checkMappersCompatibility ( type , objectMappers , fieldMappers , updateAllTypes ) ; return new Tuple < > ( objectMappers , fieldMappers ) ; } protected void addMappers ( String type , Collection < ObjectMapper > objectMappers , Collection < FieldMapper > fieldMappers ) { assert mappingLock . isWriteLockedByCurrentThread ( ) ; ImmutableOpenMap . Builder < String , ObjectMapper > fullPathObjectMappers = ImmutableOpenMap . builder ( this . fullPathObjectMappers ) ; for ( ObjectMapper objectMapper : objectMappers ) { fullPathObjectMappers . put ( objectMapper . fullPath ( ) , objectMapper ) ; if ( objectMapper . nested ( ) . isNested ( ) ) { hasNested = true ; } } this . fullPathObjectMappers = fullPathObjectMappers . build ( ) ; this . fieldTypes = this . fieldTypes . copyAndAddAll ( type , fieldMappers ) ; } public DocumentMapper parse ( String mappingType , CompressedXContent mappingSource , boolean applyDefault ) throws MapperParsingException { String defaultMappingSource ; if ( PercolatorService . TYPE_NAME . equals ( mappingType ) ) { defaultMappingSource = this . defaultPercolatorMappingSource ; } else { defaultMappingSource = this . defaultMappingSource ; } return documentParser . parseCompressed ( mappingType , mappingSource , applyDefault ? defaultMappingSource : null ) ; } public boolean hasMapping ( String mappingType ) { return mappers . containsKey ( mappingType ) ; } public Collection < String > types ( ) { final Set < String > types = new HashSet < > ( mappers . keySet ( ) ) ; types . remove ( DEFAULT_MAPPING ) ; return Collections . unmodifiableSet ( types ) ; } public DocumentMapper documentMapper ( String type ) { return mappers . get ( type ) ; } public DocumentMapperForType documentMapperWithAutoCreate ( String type ) { DocumentMapper mapper = mappers . get ( type ) ; if ( mapper ! = null ) { return new DocumentMapperForType ( mapper , null ) ; } if ( ! dynamic ) { throw new TypeMissingException ( index ( ) , type , <str> ) ; } mapper = parse ( type , null , true ) ; return new DocumentMapperForType ( mapper , mapper . mapping ( ) ) ; } @Nullable public Query searchFilter ( String . . . types ) { boolean filterPercolateType = hasMapping ( PercolatorService . TYPE_NAME ) ; if ( types ! = null & & filterPercolateType ) { for ( String type : types ) { if ( PercolatorService . TYPE_NAME . equals ( type ) ) { filterPercolateType = false ; break ; } } } Query percolatorType = null ; if ( filterPercolateType ) { percolatorType = documentMapper ( PercolatorService . TYPE_NAME ) . typeFilter ( ) ; } if ( types = = null | | types . length = = <int> ) { if ( hasNested & & filterPercolateType ) { BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . add ( percolatorType , Occur . MUST_NOT ) ; bq . add ( Queries . newNonNestedFilter ( ) , Occur . MUST ) ; return new ConstantScoreQuery ( bq . build ( ) ) ; } else if ( hasNested ) { return Queries . newNonNestedFilter ( ) ; } else if ( filterPercolateType ) { return new ConstantScoreQuery ( Queries . not ( percolatorType ) ) ; } else { return null ; } } if ( types . length = = <int> ) { DocumentMapper docMapper = documentMapper ( types [ <int> ] ) ; Query filter = docMapper ! = null ? docMapper . typeFilter ( ) : new TermQuery ( new Term ( TypeFieldMapper . NAME , types [ <int> ] ) ) ; if ( filterPercolateType ) { BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . add ( percolatorType , Occur . MUST_NOT ) ; bq . add ( filter , Occur . MUST ) ; return new ConstantScoreQuery ( bq . build ( ) ) ; } else { return filter ; } } boolean useTermsFilter = true ; for ( String type : types ) { DocumentMapper docMapper = documentMapper ( type ) ; if ( docMapper = = null ) { useTermsFilter = false ; break ; } if ( docMapper . typeMapper ( ) . fieldType ( ) . indexOptions ( ) = = IndexOptions . NONE ) { useTermsFilter = false ; break ; } } if ( useTermsFilter ) { BytesRef [ ] typesBytes = new BytesRef [ types . length ] ; for ( int i = <int> ; i < typesBytes . length ; i + + ) { typesBytes [ i ] = new BytesRef ( types [ i ] ) ; } TermsQuery termsFilter = new TermsQuery ( TypeFieldMapper . NAME , typesBytes ) ; if ( filterPercolateType ) { BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . add ( percolatorType , Occur . MUST_NOT ) ; bq . add ( termsFilter , Occur . MUST ) ; return new ConstantScoreQuery ( bq . build ( ) ) ; } else { return termsFilter ; } } else { BooleanQuery . Builder bool = new BooleanQuery . Builder ( ) ; for ( String type : types ) { DocumentMapper docMapper = documentMapper ( type ) ; if ( docMapper = = null ) { bool . add ( new TermQuery ( new Term ( TypeFieldMapper . NAME , type ) ) , BooleanClause . Occur . SHOULD ) ; } else { bool . add ( docMapper . typeFilter ( ) , BooleanClause . Occur . SHOULD ) ; } } if ( filterPercolateType ) { bool . add ( percolatorType , BooleanClause . Occur . MUST_NOT ) ; } if ( hasNested ) { bool . add ( Queries . newNonNestedFilter ( ) , BooleanClause . Occur . MUST ) ; } return new ConstantScoreQuery ( bool . build ( ) ) ; } } public MappedFieldType indexName ( String indexName ) { return fieldTypes . getByIndexName ( indexName ) ; } public MappedFieldType fullName ( String fullName ) { return fieldTypes . get ( fullName ) ; } public Collection < String > simpleMatchToIndexNames ( String pattern ) { if ( Regex . isSimpleMatchPattern ( pattern ) = = false ) { return Collections . singletonList ( pattern ) ; } return fieldTypes . simpleMatchToIndexNames ( pattern ) ; } public Collection < String > simpleMatchToIndexNames ( String pattern , @Nullable String [ ] types ) { return simpleMatchToIndexNames ( pattern ) ; } public ObjectMapper getObjectMapper ( String name , @Nullable String [ ] types ) { return fullPathObjectMappers . get ( name ) ; } public MappedFieldType smartNameFieldType ( String smartName ) { MappedFieldType fieldType = fullName ( smartName ) ; if ( fieldType ! = null ) { return fieldType ; } return indexName ( smartName ) ; } public MappedFieldType smartNameFieldType ( String smartName , @Nullable String [ ] types ) { return smartNameFieldType ( smartName ) ; } public MappedFieldType unmappedFieldType ( String type ) { MappedFieldType fieldType = unmappedFieldTypes . get ( type ) ; if ( fieldType = = null ) { final Mapper . TypeParser . ParserContext parserContext = documentMapperParser ( ) . parserContext ( type ) ; Mapper . TypeParser typeParser = parserContext . typeParser ( type ) ; if ( typeParser = = null ) { throw new IllegalArgumentException ( <str> + type + <str> ) ; } final Mapper . Builder < ? , ? > builder = typeParser . parse ( <str> + type , emptyMap ( ) , parserContext ) ; final BuilderContext builderContext = new BuilderContext ( indexSettings . getSettings ( ) , new ContentPath ( <int> ) ) ; fieldType = ( ( FieldMapper ) builder . build ( builderContext ) ) . fieldType ( ) ; Map < String , MappedFieldType > newUnmappedFieldTypes = new HashMap < > ( ) ; newUnmappedFieldTypes . putAll ( unmappedFieldTypes ) ; newUnmappedFieldTypes . put ( type , fieldType ) ; unmappedFieldTypes = unmodifiableMap ( newUnmappedFieldTypes ) ; } return fieldType ; } public Analyzer indexAnalyzer ( ) { return this . indexAnalyzer ; } public Analyzer searchAnalyzer ( ) { return this . searchAnalyzer ; } public Analyzer searchQuoteAnalyzer ( ) { return this . searchQuoteAnalyzer ; } public ObjectMapper resolveClosestNestedObjectMapper ( String fieldName ) { int indexOf = fieldName . lastIndexOf ( <str> ) ; if ( indexOf = = - <int> ) { return null ; } else { do { String objectPath = fieldName . substring ( <int> , indexOf ) ; ObjectMapper objectMapper = fullPathObjectMappers . get ( objectPath ) ; if ( objectMapper = = null ) { indexOf = objectPath . lastIndexOf ( <str> ) ; continue ; } if ( objectMapper . nested ( ) . isNested ( ) ) { return objectMapper ; } indexOf = objectPath . lastIndexOf ( <str> ) ; } while ( indexOf ! = - <int> ) ; } return null ; } public Set < String > getParentTypes ( ) { return parentTypes ; } public static boolean isMetadataField ( String fieldName ) { return META_FIELDS . contains ( fieldName ) ; } public static String [ ] getAllMetaFields ( ) { return META_FIELDS . toArray ( String . class ) ; } final class MapperAnalyzerWrapper extends DelegatingAnalyzerWrapper { private final Analyzer defaultAnalyzer ; private final Function < MappedFieldType , Analyzer > extractAnalyzer ; MapperAnalyzerWrapper ( Analyzer defaultAnalyzer , Function < MappedFieldType , Analyzer > extractAnalyzer ) { super ( Analyzer . PER_FIELD_REUSE_STRATEGY ) ; this . defaultAnalyzer = defaultAnalyzer ; this . extractAnalyzer = extractAnalyzer ; } @Override protected Analyzer getWrappedAnalyzer ( String fieldName ) { MappedFieldType fieldType = smartNameFieldType ( fieldName ) ; if ( fieldType ! = null ) { Analyzer analyzer = extractAnalyzer . apply ( fieldType ) ; if ( analyzer ! = null ) { return analyzer ; } } return defaultAnalyzer ; } } } 
