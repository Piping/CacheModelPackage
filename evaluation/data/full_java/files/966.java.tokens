package org . apache . cassandra . service . pager ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . filter . DataLimits ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . service . ClientState ; abstract class AbstractQueryPager implements QueryPager { protected final ReadCommand command ; protected final DataLimits limits ; protected final int protocolVersion ; private int remaining ; private DecoratedKey lastKey ; private int remainingInPartition ; private boolean exhausted ; protected AbstractQueryPager ( ReadCommand command , int protocolVersion ) { this . command = command ; this . protocolVersion = protocolVersion ; this . limits = command . limits ( ) ; this . remaining = limits . count ( ) ; this . remainingInPartition = limits . perPartitionCount ( ) ; } public ReadExecutionController executionController ( ) { return command . executionController ( ) ; } public PartitionIterator fetchPage ( int pageSize , ConsistencyLevel consistency , ClientState clientState ) throws RequestValidationException , RequestExecutionException { if ( isExhausted ( ) ) return EmptyIterators . partition ( ) ; pageSize = Math . min ( pageSize , remaining ) ; Pager pager = new Pager ( limits . forPaging ( pageSize ) , command . nowInSec ( ) ) ; return Transformation . apply ( nextPageReadCommand ( pageSize ) . execute ( consistency , clientState ) , pager ) ; } public PartitionIterator fetchPageInternal ( int pageSize , ReadExecutionController executionController ) throws RequestValidationException , RequestExecutionException { if ( isExhausted ( ) ) return EmptyIterators . partition ( ) ; pageSize = Math . min ( pageSize , remaining ) ; Pager pager = new Pager ( limits . forPaging ( pageSize ) , command . nowInSec ( ) ) ; return Transformation . apply ( nextPageReadCommand ( pageSize ) . executeInternal ( executionController ) , pager ) ; } private class Pager extends Transformation < RowIterator > { private final DataLimits pageLimits ; private final DataLimits . Counter counter ; private Row lastRow ; private boolean isFirstPartition = true ; private Pager ( DataLimits pageLimits , int nowInSec ) { this . counter = pageLimits . newCounter ( nowInSec , true ) ; this . pageLimits = pageLimits ; } @Override public RowIterator applyToPartition ( RowIterator partition ) { DecoratedKey key = partition . partitionKey ( ) ; if ( lastKey = = null | | ! lastKey . equals ( key ) ) remainingInPartition = limits . perPartitionCount ( ) ; lastKey = key ; if ( isFirstPartition ) { isFirstPartition = false ; if ( isPreviouslyReturnedPartition ( key ) & & ! partition . hasNext ( ) ) { partition . close ( ) ; return null ; } } return Transformation . apply ( counter . applyTo ( partition ) , this ) ; } @Override public void onClose ( ) { recordLast ( lastKey , lastRow ) ; int counted = counter . counted ( ) ; remaining - = counted ; if ( lastRow ! = null & & lastRow . clustering ( ) = = Clustering . STATIC_CLUSTERING ) { remainingInPartition = <int> ; } else { remainingInPartition - = counter . countedInCurrentPartition ( ) ; } exhausted = counted < pageLimits . count ( ) ; } public Row applyToStatic ( Row row ) { if ( ! row . isEmpty ( ) ) lastRow = row ; return row ; } @Override public Row applyToRow ( Row row ) { lastRow = row ; return row ; } } protected void restoreState ( DecoratedKey lastKey , int remaining , int remainingInPartition ) { this . lastKey = lastKey ; this . remaining = remaining ; this . remainingInPartition = remainingInPartition ; } public boolean isExhausted ( ) { return exhausted | | remaining = = <int> | | ( ( this instanceof SinglePartitionPager ) & & remainingInPartition = = <int> ) ; } public int maxRemaining ( ) { return remaining ; } protected int remainingInPartition ( ) { return remainingInPartition ; } protected abstract ReadCommand nextPageReadCommand ( int pageSize ) ; protected abstract void recordLast ( DecoratedKey key , Row row ) ; protected abstract boolean isPreviouslyReturnedPartition ( DecoratedKey key ) ; } 
