package org . elasticsearch . action . admin . indices . warmer . delete ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . master . TransportMasterNodeAction ; import org . elasticsearch . cluster . AckedClusterStateUpdateTask ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . search . warmer . IndexWarmerMissingException ; import org . elasticsearch . search . warmer . IndexWarmersMetaData ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public class TransportDeleteWarmerAction extends TransportMasterNodeAction < DeleteWarmerRequest , DeleteWarmerResponse > { @Inject public TransportDeleteWarmerAction ( Settings settings , TransportService transportService , ClusterService clusterService , ThreadPool threadPool , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , DeleteWarmerAction . NAME , transportService , clusterService , threadPool , actionFilters , indexNameExpressionResolver , DeleteWarmerRequest : : new ) ; } @Override protected String executor ( ) { return ThreadPool . Names . SAME ; } @Override protected DeleteWarmerResponse newResponse ( ) { return new DeleteWarmerResponse ( ) ; } @Override protected ClusterBlockException checkBlock ( DeleteWarmerRequest request , ClusterState state ) { return state . blocks ( ) . indicesBlockedException ( ClusterBlockLevel . METADATA_WRITE , indexNameExpressionResolver . concreteIndices ( state , request ) ) ; } @Override protected void masterOperation ( final DeleteWarmerRequest request , final ClusterState state , final ActionListener < DeleteWarmerResponse > listener ) { final String [ ] concreteIndices = indexNameExpressionResolver . concreteIndices ( state , request ) ; clusterService . submitStateUpdateTask ( <str> + Arrays . toString ( request . names ( ) ) + <str> , new AckedClusterStateUpdateTask < DeleteWarmerResponse > ( request , listener ) { @Override protected DeleteWarmerResponse newResponse ( boolean acknowledged ) { return new DeleteWarmerResponse ( acknowledged ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . debug ( <str> , t , Arrays . toString ( request . names ( ) ) , concreteIndices ) ; super . onFailure ( source , t ) ; } @Override public ClusterState execute ( ClusterState currentState ) { MetaData . Builder mdBuilder = MetaData . builder ( currentState . metaData ( ) ) ; boolean globalFoundAtLeastOne = false ; boolean deleteAll = false ; for ( int i = <int> ; i < request . names ( ) . length ; i + + ) { if ( request . names ( ) [ i ] . equals ( MetaData . ALL ) ) { deleteAll = true ; break ; } } for ( String index : concreteIndices ) { IndexMetaData indexMetaData = currentState . metaData ( ) . index ( index ) ; if ( indexMetaData = = null ) { throw new IndexNotFoundException ( index ) ; } IndexWarmersMetaData warmers = indexMetaData . custom ( IndexWarmersMetaData . TYPE ) ; if ( warmers ! = null ) { List < IndexWarmersMetaData . Entry > entries = new ArrayList < > ( ) ; for ( IndexWarmersMetaData . Entry entry : warmers . entries ( ) ) { boolean keepWarmer = true ; for ( String warmer : request . names ( ) ) { if ( Regex . simpleMatch ( warmer , entry . name ( ) ) | | warmer . equals ( MetaData . ALL ) ) { globalFoundAtLeastOne = true ; keepWarmer = false ; break ; } } if ( keepWarmer ) { entries . add ( entry ) ; } } if ( entries . size ( ) ! = warmers . entries ( ) . size ( ) ) { warmers = new IndexWarmersMetaData ( entries . toArray ( new IndexWarmersMetaData . Entry [ entries . size ( ) ] ) ) ; IndexMetaData . Builder indexBuilder = IndexMetaData . builder ( indexMetaData ) . putCustom ( IndexWarmersMetaData . TYPE , warmers ) ; mdBuilder . put ( indexBuilder ) ; } } } if ( globalFoundAtLeastOne = = false & & deleteAll = = false ) { throw new IndexWarmerMissingException ( request . names ( ) ) ; } if ( logger . isInfoEnabled ( ) ) { for ( String index : concreteIndices ) { IndexMetaData indexMetaData = currentState . metaData ( ) . index ( index ) ; if ( indexMetaData = = null ) { throw new IndexNotFoundException ( index ) ; } IndexWarmersMetaData warmers = indexMetaData . custom ( IndexWarmersMetaData . TYPE ) ; if ( warmers ! = null ) { for ( IndexWarmersMetaData . Entry entry : warmers . entries ( ) ) { for ( String warmer : request . names ( ) ) { if ( Regex . simpleMatch ( warmer , entry . name ( ) ) | | warmer . equals ( MetaData . ALL ) ) { logger . info ( <str> , index , entry . name ( ) ) ; } } } } else if ( deleteAll ) { logger . debug ( <str> , index ) ; } } } return ClusterState . builder ( currentState ) . metaData ( mdBuilder ) . build ( ) ; } } ) ; } } 
