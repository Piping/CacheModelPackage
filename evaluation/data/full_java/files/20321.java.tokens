package io . netty . channel . socket . oio ; import io . netty . buffer . ByteBuf ; import io . netty . channel . Channel ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelPromise ; import io . netty . channel . ConnectTimeoutException ; import io . netty . channel . EventLoop ; import io . netty . channel . oio . OioByteStreamChannel ; import io . netty . channel . socket . ServerSocketChannel ; import io . netty . channel . socket . SocketChannel ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . Socket ; import java . net . SocketAddress ; import java . net . SocketTimeoutException ; public class OioSocketChannel extends OioByteStreamChannel implements SocketChannel { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( OioSocketChannel . class ) ; private final Socket socket ; private final OioSocketChannelConfig config ; public OioSocketChannel ( ) { this ( new Socket ( ) ) ; } public OioSocketChannel ( Socket socket ) { this ( null , socket ) ; } public OioSocketChannel ( Channel parent , Socket socket ) { super ( parent ) ; this . socket = socket ; config = new DefaultOioSocketChannelConfig ( this , socket ) ; boolean success = false ; try { if ( socket . isConnected ( ) ) { activate ( socket . getInputStream ( ) , socket . getOutputStream ( ) ) ; } socket . setSoTimeout ( SO_TIMEOUT ) ; success = true ; } catch ( Exception e ) { throw new ChannelException ( <str> , e ) ; } finally { if ( ! success ) { try { socket . close ( ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } } } } @Override public ServerSocketChannel parent ( ) { return ( ServerSocketChannel ) super . parent ( ) ; } @Override public OioSocketChannelConfig config ( ) { return config ; } @Override public boolean isOpen ( ) { return ! socket . isClosed ( ) ; } @Override public boolean isActive ( ) { return ! socket . isClosed ( ) & & socket . isConnected ( ) ; } @Override public boolean isInputShutdown ( ) { return super . isInputShutdown ( ) ; } @Override public boolean isOutputShutdown ( ) { return socket . isOutputShutdown ( ) | | ! isActive ( ) ; } @Override public ChannelFuture shutdownOutput ( ) { return shutdownOutput ( newPromise ( ) ) ; } @Override protected int doReadBytes ( ByteBuf buf ) throws Exception { if ( socket . isClosed ( ) ) { return - <int> ; } try { return super . doReadBytes ( buf ) ; } catch ( SocketTimeoutException ignored ) { return <int> ; } } @Override public ChannelFuture shutdownOutput ( final ChannelPromise future ) { EventLoop loop = eventLoop ( ) ; if ( loop . inEventLoop ( ) ) { try { socket . shutdownOutput ( ) ; future . setSuccess ( ) ; } catch ( Throwable t ) { future . setFailure ( t ) ; } } else { loop . execute ( new OneTimeTask ( ) { @Override public void run ( ) { shutdownOutput ( future ) ; } } ) ; } return future ; } @Override public InetSocketAddress localAddress ( ) { return ( InetSocketAddress ) super . localAddress ( ) ; } @Override public InetSocketAddress remoteAddress ( ) { return ( InetSocketAddress ) super . remoteAddress ( ) ; } @Override protected SocketAddress localAddress0 ( ) { return socket . getLocalSocketAddress ( ) ; } @Override protected SocketAddress remoteAddress0 ( ) { return socket . getRemoteSocketAddress ( ) ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { socket . bind ( localAddress ) ; } @Override protected void doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { if ( localAddress ! = null ) { socket . bind ( localAddress ) ; } boolean success = false ; try { socket . connect ( remoteAddress , config ( ) . getConnectTimeoutMillis ( ) ) ; activate ( socket . getInputStream ( ) , socket . getOutputStream ( ) ) ; success = true ; } catch ( SocketTimeoutException e ) { ConnectTimeoutException cause = new ConnectTimeoutException ( <str> + remoteAddress ) ; cause . setStackTrace ( e . getStackTrace ( ) ) ; throw cause ; } finally { if ( ! success ) { doClose ( ) ; } } } @Override protected void doDisconnect ( ) throws Exception { doClose ( ) ; } @Override protected void doClose ( ) throws Exception { socket . close ( ) ; } @Override protected boolean checkInputShutdown ( ) { if ( isInputShutdown ( ) ) { try { Thread . sleep ( config ( ) . getSoTimeout ( ) ) ; } catch ( Throwable e ) { } return true ; } return false ; } @Override protected void setReadPending ( boolean readPending ) { super . setReadPending ( readPending ) ; } } 
