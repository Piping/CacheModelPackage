package org . gradle . cache . internal ; import org . gradle . api . Action ; import org . gradle . cache . CacheOpenException ; import org . gradle . cache . CacheValidator ; import org . gradle . cache . PersistentCache ; import org . gradle . cache . internal . locklistener . NoOpFileLockContentionHandler ; import org . gradle . test . fixtures . file . TestFile ; import org . gradle . test . fixtures . file . TestNameTestDirectoryProvider ; import org . gradle . util . GUtil ; import org . gradle . util . JUnit4GroovyMockery ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Before ; import org . junit . Rule ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . util . HashMap ; import java . util . Map ; import java . util . Properties ; import static org . gradle . cache . internal . FileLockManager . LockMode ; import static org . gradle . cache . internal . filelock . LockOptionsBuilder . mode ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . fail ; @RunWith ( JMock . class ) public class DefaultPersistentDirectoryCacheTest { @Rule public final TestNameTestDirectoryProvider tmpDir = new TestNameTestDirectoryProvider ( ) ; private final JUnit4Mockery context = new JUnit4GroovyMockery ( ) ; private final ProcessMetaDataProvider metaDataProvider = context . mock ( ProcessMetaDataProvider . class ) ; private final FileLockManager lockManager = new DefaultFileLockManager ( metaDataProvider , new NoOpFileLockContentionHandler ( ) ) ; private final Action < PersistentCache > action = context . mock ( Action . class ) ; private final CacheValidator validator = context . mock ( CacheValidator . class ) ; private final Map < String , String > properties = GUtil . map ( <str> , <str> , <str> , <str> ) ; @Before public void setup ( ) { context . checking ( new Expectations ( ) { { allowing ( metaDataProvider ) . getProcessDisplayName ( ) ; will ( returnValue ( <str> ) ) ; allowing ( metaDataProvider ) . getProcessIdentifier ( ) ; allowing ( validator ) . isValid ( ) ; will ( returnValue ( true ) ) ; } } ) ; } @Test public void initialisesCacheWhenCacheDirDoesNotExist ( ) { TestFile emptyDir = tmpDir . getTestDirectory ( ) . file ( <str> ) ; emptyDir . assertDoesNotExist ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( with ( notNullValue ( PersistentCache . class ) ) ) ; } } ) ; DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache ( emptyDir , <str> , validator , properties , mode ( LockMode . Shared ) , action , lockManager ) ; cache . open ( ) ; assertThat ( loadProperties ( emptyDir . file ( <str> ) ) , equalTo ( properties ) ) ; } @Test public void initializesCacheWhenPropertiesFileDoesNotExist ( ) { TestFile dir = tmpDir . getTestDirectory ( ) . file ( <str> ) . createDir ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( with ( notNullValue ( PersistentCache . class ) ) ) ; } } ) ; DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache ( dir , <str> , validator , properties , mode ( LockMode . Shared ) , action , lockManager ) ; cache . open ( ) ; assertThat ( loadProperties ( dir . file ( <str> ) ) , equalTo ( properties ) ) ; } @Test public void rebuildsCacheWhenPropertiesHaveChanged ( ) { TestFile dir = createCacheDir ( <str> , <str> ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( with ( notNullValue ( PersistentCache . class ) ) ) ; } } ) ; DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache ( dir , <str> , validator , properties , mode ( LockMode . Shared ) , action , lockManager ) ; cache . open ( ) ; assertThat ( loadProperties ( dir . file ( <str> ) ) , equalTo ( properties ) ) ; } @Test public void rebuildsCacheWhenCacheValidatorReturnsFalse ( ) { TestFile dir = createCacheDir ( ) ; final CacheValidator invalidator = context . mock ( CacheValidator . class ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( with ( notNullValue ( PersistentCache . class ) ) ) ; exactly ( <int> ) . of ( invalidator ) . isValid ( ) ; will ( returnValue ( false ) ) ; allowing ( invalidator ) . isValid ( ) ; will ( returnValue ( true ) ) ; } } ) ; DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache ( dir , <str> , invalidator , properties , mode ( LockMode . Shared ) , action , lockManager ) ; cache . open ( ) ; assertThat ( loadProperties ( dir . file ( <str> ) ) , equalTo ( properties ) ) ; } @Test public void rebuildsCacheWhenInitialiserFailedOnPreviousOpen ( ) { TestFile dir = tmpDir . getTestDirectory ( ) . file ( <str> ) . createDir ( ) ; final RuntimeException failure = new RuntimeException ( ) ; context . checking ( new Expectations ( ) { { one ( action ) . execute ( with ( notNullValue ( PersistentCache . class ) ) ) ; will ( throwException ( failure ) ) ; } } ) ; try { new DefaultPersistentDirectoryCache ( dir , <str> , validator , properties , mode ( LockMode . Shared ) , action , lockManager ) . open ( ) ; fail ( ) ; } catch ( CacheOpenException e ) { assertThat ( e . getCause ( ) , sameInstance ( ( Throwable ) failure ) ) ; } context . checking ( new Expectations ( ) { { one ( action ) . execute ( with ( notNullValue ( PersistentCache . class ) ) ) ; } } ) ; DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache ( dir , <str> , validator , properties , mode ( LockMode . Shared ) , action , lockManager ) ; cache . open ( ) ; assertThat ( loadProperties ( dir . file ( <str> ) ) , equalTo ( properties ) ) ; } @Test public void doesNotInitializeCacheWhenCacheDirExistsAndIsNotInvalid ( ) { TestFile dir = createCacheDir ( ) ; DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache ( dir , <str> , validator , properties , mode ( LockMode . Shared ) , action , lockManager ) ; cache . open ( ) ; dir . file ( <str> ) . assertIsFile ( ) ; dir . file ( <str> ) . assertIsFile ( ) ; } private Map < String , String > loadProperties ( TestFile file ) { Properties properties = GUtil . loadProperties ( file ) ; Map < String , String > result = new HashMap < String , String > ( ) ; for ( Map . Entry < Object , Object > entry : properties . entrySet ( ) ) { result . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; } return result ; } private TestFile createCacheDir ( String . . . extraProps ) { TestFile dir = tmpDir . getTestDirectory ( ) ; Map < String , Object > properties = new HashMap < String , Object > ( ) ; properties . putAll ( this . properties ) ; properties . putAll ( GUtil . map ( ( Object [ ] ) extraProps ) ) ; DefaultPersistentDirectoryCache cache = new DefaultPersistentDirectoryCache ( dir , <str> , validator , properties , mode ( LockMode . Shared ) , null , lockManager ) ; cache . open ( ) ; dir . file ( <str> ) . touch ( ) ; cache . close ( ) ; return dir ; } } 
