package org . elasticsearch . index . translog ; import org . apache . lucene . store . AlreadyClosedException ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . lease . Releasables ; import java . io . IOException ; import java . util . concurrent . atomic . AtomicBoolean ; final class MultiSnapshot implements Translog . Snapshot { private final Translog . Snapshot [ ] translogs ; private AtomicBoolean closed = new AtomicBoolean ( false ) ; private final int estimatedTotalOperations ; private int index ; MultiSnapshot ( Translog . Snapshot [ ] translogs ) { this . translogs = translogs ; int ops = <int> ; for ( Translog . Snapshot translog : translogs ) { final int tops = translog . estimatedTotalOperations ( ) ; if ( tops = = TranslogReader . UNKNOWN_OP_COUNT ) { ops = TranslogReader . UNKNOWN_OP_COUNT ; break ; } assert tops > = <int> : <str> + tops ; ops + = tops ; } estimatedTotalOperations = ops ; index = <int> ; } @Override public int estimatedTotalOperations ( ) { return estimatedTotalOperations ; } @Override public Translog . Operation next ( ) throws IOException { ensureOpen ( ) ; for ( ; index < translogs . length ; index + + ) { final Translog . Snapshot current = translogs [ index ] ; Translog . Operation op = current . next ( ) ; if ( op ! = null ) { return op ; } } return null ; } protected void ensureOpen ( ) { if ( closed . get ( ) ) { throw new AlreadyClosedException ( <str> ) ; } } @Override public void close ( ) throws ElasticsearchException { if ( closed . compareAndSet ( false , true ) ) { Releasables . close ( translogs ) ; } } } 
