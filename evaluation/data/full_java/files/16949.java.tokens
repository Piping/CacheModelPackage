package java . nio ; import com . google . gwt . corp . compatibility . Endianness ; import com . google . gwt . corp . compatibility . Numbers ; abstract class HeapByteBuffer extends BaseByteBuffer { protected final byte [ ] backingArray ; protected final int offset ; HeapByteBuffer ( byte [ ] backingArray ) { this ( backingArray , backingArray . length , <int> ) ; } HeapByteBuffer ( int capacity ) { this ( new byte [ capacity ] , capacity , <int> ) ; } HeapByteBuffer ( byte [ ] backingArray , int capacity , int offset ) { super ( capacity ) ; this . backingArray = backingArray ; this . offset = offset ; if ( offset + capacity > backingArray . length ) { throw new IndexOutOfBoundsException ( ) ; } } public final ByteBuffer get ( byte [ ] dest , int off , int len ) { int length = dest . length ; if ( off < <int> | | len < <int> | | ( long ) off + ( long ) len > length ) { throw new IndexOutOfBoundsException ( ) ; } if ( len > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } System . arraycopy ( backingArray , offset + position , dest , off , len ) ; position + = len ; return this ; } public final byte get ( ) { if ( position = = limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position + + ] ; } public final byte get ( int index ) { if ( index < <int> | | index > = limit ) { throw new IndexOutOfBoundsException ( ) ; } return backingArray [ offset + index ] ; } public final double getDouble ( ) { return Numbers . longBitsToDouble ( getLong ( ) ) ; } public final double getDouble ( int index ) { return Numbers . longBitsToDouble ( getLong ( index ) ) ; } public final float getFloat ( ) { return Numbers . intBitsToFloat ( getInt ( ) ) ; } public final float getFloat ( int index ) { return Numbers . intBitsToFloat ( getInt ( index ) ) ; } public final int getInt ( ) { int newPosition = position + <int> ; if ( newPosition > limit ) { throw new BufferUnderflowException ( ) ; } int result = loadInt ( position ) ; position = newPosition ; return result ; } public final int getInt ( int index ) { if ( index < <int> | | index + <int> > limit ) { throw new IndexOutOfBoundsException ( ) ; } return loadInt ( index ) ; } public final long getLong ( ) { int newPosition = position + <int> ; if ( newPosition > limit ) { throw new BufferUnderflowException ( ) ; } long result = loadLong ( position ) ; position = newPosition ; return result ; } public final long getLong ( int index ) { if ( index < <int> | | index + <int> > limit ) { throw new IndexOutOfBoundsException ( ) ; } return loadLong ( index ) ; } public final short getShort ( ) { int newPosition = position + <int> ; if ( newPosition > limit ) { throw new BufferUnderflowException ( ) ; } short result = loadShort ( position ) ; position = newPosition ; return result ; } public final short getShort ( int index ) { if ( index < <int> | | index + <int> > limit ) { throw new IndexOutOfBoundsException ( ) ; } return loadShort ( index ) ; } public final boolean isDirect ( ) { return false ; } protected final int loadInt ( int index ) { int baseOffset = offset + index ; int bytes = <int> ; if ( order = = Endianness . BIG_ENDIAN ) { for ( int i = <int> ; i < <int> ; i + + ) { bytes = bytes < < <int> ; bytes = bytes | ( backingArray [ baseOffset + i ] & <hex> ) ; } } else { for ( int i = <int> ; i > = <int> ; i - - ) { bytes = bytes < < <int> ; bytes = bytes | ( backingArray [ baseOffset + i ] & <hex> ) ; } } return bytes ; } protected final long loadLong ( int index ) { int baseOffset = offset + index ; long bytes = <int> ; if ( order = = Endianness . BIG_ENDIAN ) { for ( int i = <int> ; i < <int> ; i + + ) { bytes = bytes < < <int> ; bytes = bytes | ( backingArray [ baseOffset + i ] & <hex> ) ; } } else { for ( int i = <int> ; i > = <int> ; i - - ) { bytes = bytes < < <int> ; bytes = bytes | ( backingArray [ baseOffset + i ] & <hex> ) ; } } return bytes ; } protected final short loadShort ( int index ) { int baseOffset = offset + index ; short bytes = <int> ; if ( order = = Endianness . BIG_ENDIAN ) { bytes = ( short ) ( backingArray [ baseOffset ] < < <int> ) ; bytes | = ( backingArray [ baseOffset + <int> ] & <hex> ) ; } else { bytes = ( short ) ( backingArray [ baseOffset + <int> ] < < <int> ) ; bytes | = ( backingArray [ baseOffset ] & <hex> ) ; } return bytes ; } protected final void store ( int index , int value ) { int baseOffset = offset + index ; if ( order = = Endianness . BIG_ENDIAN ) { for ( int i = <int> ; i > = <int> ; i - - ) { backingArray [ baseOffset + i ] = ( byte ) ( value & <hex> ) ; value = value > > <int> ; } } else { for ( int i = <int> ; i < = <int> ; i + + ) { backingArray [ baseOffset + i ] = ( byte ) ( value & <hex> ) ; value = value > > <int> ; } } } protected final void store ( int index , long value ) { int baseOffset = offset + index ; if ( order = = Endianness . BIG_ENDIAN ) { for ( int i = <int> ; i > = <int> ; i - - ) { backingArray [ baseOffset + i ] = ( byte ) ( value & <hex> ) ; value = value > > <int> ; } } else { for ( int i = <int> ; i < = <int> ; i + + ) { backingArray [ baseOffset + i ] = ( byte ) ( value & <hex> ) ; value = value > > <int> ; } } } protected final void store ( int index , short value ) { int baseOffset = offset + index ; if ( order = = Endianness . BIG_ENDIAN ) { backingArray [ baseOffset ] = ( byte ) ( ( value > > <int> ) & <hex> ) ; backingArray [ baseOffset + <int> ] = ( byte ) ( value & <hex> ) ; } else { backingArray [ baseOffset + <int> ] = ( byte ) ( ( value > > <int> ) & <hex> ) ; backingArray [ baseOffset ] = ( byte ) ( value & <hex> ) ; } } } 
