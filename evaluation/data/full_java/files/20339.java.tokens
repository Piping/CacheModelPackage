package io . netty . channel ; import ch . qos . logback . classic . Logger ; import ch . qos . logback . classic . spi . ILoggingEvent ; import ch . qos . logback . core . Appender ; import io . netty . channel . local . LocalChannel ; import io . netty . util . concurrent . EventExecutor ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . slf4j . LoggerFactory ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executors ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; public class SingleThreadEventLoopTest { private static final Runnable NOOP = new Runnable ( ) { @Override public void run ( ) { } } ; private SingleThreadEventLoopA loopA ; private SingleThreadEventLoopB loopB ; @Before public void newEventLoop ( ) { loopA = new SingleThreadEventLoopA ( ) ; loopB = new SingleThreadEventLoopB ( ) ; } @After public void stopEventLoop ( ) { if ( ! loopA . isShuttingDown ( ) ) { loopA . shutdownGracefully ( <int> , <int> , TimeUnit . MILLISECONDS ) ; } if ( ! loopB . isShuttingDown ( ) ) { loopB . shutdownGracefully ( <int> , <int> , TimeUnit . MILLISECONDS ) ; } while ( ! loopA . isTerminated ( ) ) { try { loopA . awaitTermination ( <int> , TimeUnit . DAYS ) ; } catch ( InterruptedException e ) { } } assertEquals ( <int> , loopA . cleanedUp . get ( ) ) ; while ( ! loopB . isTerminated ( ) ) { try { loopB . awaitTermination ( <int> , TimeUnit . DAYS ) ; } catch ( InterruptedException e ) { } } } @Test @SuppressWarnings ( <str> ) public void shutdownBeforeStart ( ) throws Exception { loopA . shutdown ( ) ; assertRejection ( loopA ) ; } @Test @SuppressWarnings ( <str> ) public void shutdownAfterStart ( ) throws Exception { final CountDownLatch latch = new CountDownLatch ( <int> ) ; loopA . execute ( new Runnable ( ) { @Override public void run ( ) { latch . countDown ( ) ; } } ) ; latch . await ( ) ; loopA . shutdown ( ) ; assertRejection ( loopA ) ; assertTrue ( loopA . isShutdown ( ) ) ; while ( ! loopA . isTerminated ( ) ) { loopA . awaitTermination ( <int> , TimeUnit . DAYS ) ; } } private static void assertRejection ( EventExecutor loop ) { try { loop . execute ( NOOP ) ; fail ( <str> ) ; } catch ( RejectedExecutionException e ) { } } @Test public void scheduleTaskA ( ) throws Exception { testScheduleTask ( loopA ) ; } @Test public void scheduleTaskB ( ) throws Exception { testScheduleTask ( loopB ) ; } private static void testScheduleTask ( EventLoop loopA ) throws InterruptedException , ExecutionException { long startTime = System . nanoTime ( ) ; final AtomicLong endTime = new AtomicLong ( ) ; loopA . schedule ( new Runnable ( ) { @Override public void run ( ) { endTime . set ( System . nanoTime ( ) ) ; } } , <int> , TimeUnit . MILLISECONDS ) . get ( ) ; assertThat ( endTime . get ( ) - startTime , is ( greaterThanOrEqualTo ( TimeUnit . MILLISECONDS . toNanos ( <int> ) ) ) ) ; } @Test public void scheduleTaskAtFixedRateA ( ) throws Exception { testScheduleTaskAtFixedRate ( loopA ) ; } @Test public void scheduleTaskAtFixedRateB ( ) throws Exception { testScheduleTaskAtFixedRate ( loopB ) ; } private static void testScheduleTaskAtFixedRate ( EventLoop loopA ) throws InterruptedException { final Queue < Long > timestamps = new LinkedBlockingQueue < Long > ( ) ; ScheduledFuture < ? > f = loopA . scheduleAtFixedRate ( new Runnable ( ) { @Override public void run ( ) { timestamps . add ( System . nanoTime ( ) ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } , <int> , <int> , TimeUnit . MILLISECONDS ) ; Thread . sleep ( <int> ) ; assertTrue ( f . cancel ( true ) ) ; assertEquals ( <int> , timestamps . size ( ) ) ; Long firstTimestamp = null ; int cnt = <int> ; for ( Long t : timestamps ) { if ( firstTimestamp = = null ) { firstTimestamp = t ; continue ; } long timepoint = t - firstTimestamp ; assertThat ( timepoint , is ( greaterThanOrEqualTo ( TimeUnit . MILLISECONDS . toNanos ( <int> * cnt + <int> ) ) ) ) ; assertThat ( timepoint , is ( lessThan ( TimeUnit . MILLISECONDS . toNanos ( <int> * ( cnt + <int> ) + <int> ) ) ) ) ; cnt + + ; } } @Test public void scheduleLaggyTaskAtFixedRateA ( ) throws Exception { testScheduleLaggyTaskAtFixedRate ( loopA ) ; } @Test public void scheduleLaggyTaskAtFixedRateB ( ) throws Exception { testScheduleLaggyTaskAtFixedRate ( loopB ) ; } private static void testScheduleLaggyTaskAtFixedRate ( EventLoop loopA ) throws InterruptedException { final Queue < Long > timestamps = new LinkedBlockingQueue < Long > ( ) ; ScheduledFuture < ? > f = loopA . scheduleAtFixedRate ( new Runnable ( ) { @Override public void run ( ) { boolean empty = timestamps . isEmpty ( ) ; timestamps . add ( System . nanoTime ( ) ) ; if ( empty ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } } , <int> , <int> , TimeUnit . MILLISECONDS ) ; Thread . sleep ( <int> ) ; assertTrue ( f . cancel ( true ) ) ; assertEquals ( <int> , timestamps . size ( ) ) ; int i = <int> ; Long previousTimestamp = null ; for ( Long t : timestamps ) { if ( previousTimestamp = = null ) { previousTimestamp = t ; continue ; } long diff = t . longValue ( ) - previousTimestamp . longValue ( ) ; if ( i = = <int> ) { assertThat ( diff , is ( greaterThanOrEqualTo ( TimeUnit . MILLISECONDS . toNanos ( <int> ) ) ) ) ; } else { assertThat ( diff , is ( lessThanOrEqualTo ( TimeUnit . MILLISECONDS . toNanos ( <int> ) ) ) ) ; } previousTimestamp = t ; i + + ; } } @Test public void scheduleTaskWithFixedDelayA ( ) throws Exception { testScheduleTaskWithFixedDelay ( loopA ) ; } @Test public void scheduleTaskWithFixedDelayB ( ) throws Exception { testScheduleTaskWithFixedDelay ( loopB ) ; } private static void testScheduleTaskWithFixedDelay ( EventLoop loopA ) throws InterruptedException { final Queue < Long > timestamps = new LinkedBlockingQueue < Long > ( ) ; ScheduledFuture < ? > f = loopA . scheduleWithFixedDelay ( new Runnable ( ) { @Override public void run ( ) { timestamps . add ( System . nanoTime ( ) ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } , <int> , <int> , TimeUnit . MILLISECONDS ) ; Thread . sleep ( <int> ) ; assertTrue ( f . cancel ( true ) ) ; assertEquals ( <int> , timestamps . size ( ) ) ; Long previousTimestamp = null ; for ( Long t : timestamps ) { if ( previousTimestamp = = null ) { previousTimestamp = t ; continue ; } assertThat ( t . longValue ( ) - previousTimestamp . longValue ( ) , is ( greaterThanOrEqualTo ( TimeUnit . MILLISECONDS . toNanos ( <int> ) ) ) ) ; previousTimestamp = t ; } } @Test @SuppressWarnings ( <str> ) public void shutdownWithPendingTasks ( ) throws Exception { final int NUM_TASKS = <int> ; final AtomicInteger ranTasks = new AtomicInteger ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; final Runnable task = new Runnable ( ) { @Override public void run ( ) { ranTasks . incrementAndGet ( ) ; while ( latch . getCount ( ) > <int> ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { } } } } ; for ( int i = <int> ; i < NUM_TASKS ; i + + ) { loopA . execute ( task ) ; } while ( ranTasks . get ( ) = = <int> ) { Thread . yield ( ) ; } assertEquals ( <int> , ranTasks . get ( ) ) ; loopA . shutdown ( ) ; latch . countDown ( ) ; while ( ! loopA . isTerminated ( ) ) { loopA . awaitTermination ( <int> , TimeUnit . DAYS ) ; } assertEquals ( NUM_TASKS , ranTasks . get ( ) ) ; } @Test ( timeout = <int> ) @SuppressWarnings ( <str> ) public void testRegistrationAfterShutdown ( ) throws Exception { loopA . shutdown ( ) ; Logger root = ( Logger ) LoggerFactory . getLogger ( org . slf4j . Logger . ROOT_LOGGER_NAME ) ; List < Appender < ILoggingEvent > > appenders = new ArrayList < Appender < ILoggingEvent > > ( ) ; for ( Iterator < Appender < ILoggingEvent > > i = root . iteratorForAppenders ( ) ; i . hasNext ( ) ; ) { Appender < ILoggingEvent > a = i . next ( ) ; appenders . add ( a ) ; root . detachAppender ( a ) ; } try { ChannelFuture f = loopA . register ( new LocalChannel ( ) ) ; f . awaitUninterruptibly ( ) ; assertFalse ( f . isSuccess ( ) ) ; assertThat ( f . cause ( ) , is ( instanceOf ( RejectedExecutionException . class ) ) ) ; assertFalse ( f . channel ( ) . isOpen ( ) ) ; } finally { for ( Appender < ILoggingEvent > a : appenders ) { root . addAppender ( a ) ; } } } @Test ( timeout = <int> ) @SuppressWarnings ( <str> ) public void testRegistrationAfterShutdown2 ( ) throws Exception { loopA . shutdown ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; Channel ch = new LocalChannel ( ) ; ChannelPromise promise = ch . newPromise ( ) ; promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { latch . countDown ( ) ; } } ) ; Logger root = ( Logger ) LoggerFactory . getLogger ( org . slf4j . Logger . ROOT_LOGGER_NAME ) ; List < Appender < ILoggingEvent > > appenders = new ArrayList < Appender < ILoggingEvent > > ( ) ; for ( Iterator < Appender < ILoggingEvent > > i = root . iteratorForAppenders ( ) ; i . hasNext ( ) ; ) { Appender < ILoggingEvent > a = i . next ( ) ; appenders . add ( a ) ; root . detachAppender ( a ) ; } try { ChannelFuture f = loopA . register ( ch , promise ) ; f . awaitUninterruptibly ( ) ; assertFalse ( f . isSuccess ( ) ) ; assertThat ( f . cause ( ) , is ( instanceOf ( RejectedExecutionException . class ) ) ) ; assertFalse ( latch . await ( <int> , TimeUnit . SECONDS ) ) ; assertFalse ( ch . isOpen ( ) ) ; } finally { for ( Appender < ILoggingEvent > a : appenders ) { root . addAppender ( a ) ; } } } @Test ( timeout = <int> ) public void testGracefulShutdownQuietPeriod ( ) throws Exception { loopA . shutdownGracefully ( <int> , Integer . MAX_VALUE , TimeUnit . SECONDS ) ; for ( int i = <int> ; i < <int> ; i + + ) { Thread . sleep ( <int> ) ; loopA . execute ( NOOP ) ; } long startTime = System . nanoTime ( ) ; assertThat ( loopA . isShuttingDown ( ) , is ( true ) ) ; assertThat ( loopA . isShutdown ( ) , is ( false ) ) ; while ( ! loopA . isTerminated ( ) ) { loopA . awaitTermination ( Integer . MAX_VALUE , TimeUnit . SECONDS ) ; } assertThat ( System . nanoTime ( ) - startTime , is ( greaterThanOrEqualTo ( TimeUnit . SECONDS . toNanos ( <int> ) ) ) ) ; } @Test ( timeout = <int> ) public void testGracefulShutdownTimeout ( ) throws Exception { loopA . shutdownGracefully ( <int> , <int> , TimeUnit . SECONDS ) ; for ( int i = <int> ; i < <int> ; i + + ) { Thread . sleep ( <int> ) ; loopA . execute ( NOOP ) ; } try { for ( int i = <int> ; i < <int> ; i + + ) { Thread . sleep ( <int> ) ; loopA . execute ( NOOP ) ; } fail ( <str> ) ; } catch ( RejectedExecutionException e ) { } assertThat ( loopA . isShuttingDown ( ) , is ( true ) ) ; assertThat ( loopA . isShutdown ( ) , is ( true ) ) ; } private static class SingleThreadEventLoopA extends SingleThreadEventLoop { final AtomicInteger cleanedUp = new AtomicInteger ( ) ; SingleThreadEventLoopA ( ) { super ( null , Executors . defaultThreadFactory ( ) , true ) ; } @Override protected void run ( ) { for ( ; ; ) { Runnable task = takeTask ( ) ; if ( task ! = null ) { task . run ( ) ; updateLastExecutionTime ( ) ; } if ( confirmShutdown ( ) ) { break ; } } } @Override protected void cleanup ( ) { cleanedUp . incrementAndGet ( ) ; } } private static class SingleThreadEventLoopB extends SingleThreadEventLoop { SingleThreadEventLoopB ( ) { super ( null , Executors . defaultThreadFactory ( ) , false ) ; } @Override protected void run ( ) { for ( ; ; ) { try { Thread . sleep ( TimeUnit . NANOSECONDS . toMillis ( delayNanos ( System . nanoTime ( ) ) ) ) ; } catch ( InterruptedException e ) { } runAllTasks ( ) ; if ( confirmShutdown ( ) ) { break ; } } } @Override protected void wakeup ( boolean inEventLoop ) { interruptThread ( ) ; } } } 
