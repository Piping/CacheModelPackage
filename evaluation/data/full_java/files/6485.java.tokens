package org . elasticsearch . index . fielddata . plain ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . BytesRefIterator ; import org . apache . lucene . util . CharsRefBuilder ; import org . apache . lucene . util . NumericUtils ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . fielddata . * ; import org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource . Nested ; import org . elasticsearch . index . mapper . MappedFieldType . Names ; import org . elasticsearch . search . MultiValueMode ; import java . io . IOException ; abstract class AbstractIndexGeoPointFieldData extends AbstractIndexFieldData < AtomicGeoPointFieldData > implements IndexGeoPointFieldData { protected abstract static class BaseGeoPointTermsEnum { protected final BytesRefIterator termsEnum ; protected BaseGeoPointTermsEnum ( BytesRefIterator termsEnum ) { this . termsEnum = termsEnum ; } } protected static class GeoPointTermsEnum extends BaseGeoPointTermsEnum { protected GeoPointTermsEnum ( BytesRefIterator termsEnum ) { super ( termsEnum ) ; } public Long next ( ) throws IOException { final BytesRef term = termsEnum . next ( ) ; if ( term = = null ) { return null ; } return NumericUtils . prefixCodedToLong ( term ) ; } } protected static class GeoPointTermsEnumLegacy extends BaseGeoPointTermsEnum { private final GeoPoint next ; private final CharsRefBuilder spare ; protected GeoPointTermsEnumLegacy ( BytesRefIterator termsEnum ) { super ( termsEnum ) ; next = new GeoPoint ( ) ; spare = new CharsRefBuilder ( ) ; } public GeoPoint next ( ) throws IOException { final BytesRef term = termsEnum . next ( ) ; if ( term = = null ) { return null ; } spare . copyUTF8Bytes ( term ) ; int commaIndex = - <int> ; for ( int i = <int> ; i < spare . length ( ) ; i + + ) { if ( spare . charAt ( i ) = = <str> ) { commaIndex = i ; break ; } } if ( commaIndex = = - <int> ) { assert false ; return next . reset ( <int> , <int> ) ; } final double lat = Double . parseDouble ( new String ( spare . chars ( ) , <int> , commaIndex ) ) ; final double lon = Double . parseDouble ( new String ( spare . chars ( ) , commaIndex + <int> , spare . length ( ) - ( commaIndex + <int> ) ) ) ; return next . reset ( lat , lon ) ; } } public AbstractIndexGeoPointFieldData ( IndexSettings indexSettings , Names fieldNames , FieldDataType fieldDataType , IndexFieldDataCache cache ) { super ( indexSettings , fieldNames , fieldDataType , cache ) ; } @Override public final XFieldComparatorSource comparatorSource ( @Nullable Object missingValue , MultiValueMode sortMode , Nested nested ) { throw new IllegalArgumentException ( <str> ) ; } @Override protected AtomicGeoPointFieldData empty ( int maxDoc ) { return AbstractAtomicGeoPointFieldData . empty ( maxDoc ) ; } } 
