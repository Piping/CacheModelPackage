package org . apache . cassandra . stress ; import java . io . PrintStream ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ThreadFactory ; import org . apache . cassandra . stress . util . * ; import org . apache . commons . lang3 . time . DurationFormatUtils ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . stress . settings . StressSettings ; public class StressMetrics { private static final ThreadFactory tf = new NamedThreadFactory ( <str> ) ; private final PrintStream output ; private final Thread thread ; private volatile boolean stop = false ; private volatile boolean cancelled = false ; private final Uncertainty rowRateUncertainty = new Uncertainty ( ) ; private final CountDownLatch stopped = new CountDownLatch ( <int> ) ; private final Timing timing ; private final Callable < JmxCollector . GcStats > gcStatsCollector ; private volatile JmxCollector . GcStats totalGcStats ; private final StressSettings settings ; public StressMetrics ( PrintStream output , final long logIntervalMillis , StressSettings settings ) { this . output = output ; this . settings = settings ; Callable < JmxCollector . GcStats > gcStatsCollector ; totalGcStats = new JmxCollector . GcStats ( <int> ) ; try { gcStatsCollector = new JmxCollector ( settings . node . resolveAllPermitted ( settings ) , settings . port . jmxPort ) ; } catch ( Throwable t ) { switch ( settings . log . level ) { case VERBOSE : t . printStackTrace ( ) ; } System . err . println ( <str> ) ; gcStatsCollector = new Callable < JmxCollector . GcStats > ( ) { public JmxCollector . GcStats call ( ) throws Exception { return totalGcStats ; } } ; } this . gcStatsCollector = gcStatsCollector ; this . timing = new Timing ( settings . samples . historyCount , settings . samples . reportCount ) ; printHeader ( <str> , output ) ; thread = tf . newThread ( new Runnable ( ) { @Override public void run ( ) { timing . start ( ) ; try { while ( ! stop ) { try { long sleepNanos = timing . getHistory ( ) . endNanos ( ) - System . nanoTime ( ) ; long sleep = ( sleepNanos / <int> ) + logIntervalMillis ; if ( sleep < logIntervalMillis > > > <int> ) Thread . sleep ( logIntervalMillis ) ; else Thread . sleep ( sleep ) ; update ( ) ; } catch ( InterruptedException e ) { break ; } } update ( ) ; } catch ( InterruptedException e ) { } catch ( Exception e ) { cancel ( ) ; e . printStackTrace ( StressMetrics . this . output ) ; } finally { rowRateUncertainty . wakeAll ( ) ; stopped . countDown ( ) ; } } } ) ; } public void start ( ) { thread . start ( ) ; } public void waitUntilConverges ( double targetUncertainty , int minMeasurements , int maxMeasurements ) throws InterruptedException { rowRateUncertainty . await ( targetUncertainty , minMeasurements , maxMeasurements ) ; } public void cancel ( ) { cancelled = true ; stop = true ; thread . interrupt ( ) ; rowRateUncertainty . wakeAll ( ) ; } public void stop ( ) throws InterruptedException { stop = true ; thread . interrupt ( ) ; stopped . await ( ) ; } private void update ( ) throws InterruptedException { Timing . TimingResult < JmxCollector . GcStats > result = timing . snap ( gcStatsCollector ) ; totalGcStats = JmxCollector . GcStats . aggregate ( Arrays . asList ( totalGcStats , result . extra ) ) ; TimingInterval current = result . intervals . combine ( settings . samples . reportCount ) ; TimingInterval history = timing . getHistory ( ) . combine ( settings . samples . historyCount ) ; rowRateUncertainty . update ( current . adjustedRowRate ( ) ) ; if ( current . partitionCount ! = <int> ) { if ( result . intervals . intervals ( ) . size ( ) > <int> ) { for ( Map . Entry < String , TimingInterval > type : result . intervals . intervals ( ) . entrySet ( ) ) printRow ( <str> , type . getKey ( ) , type . getValue ( ) , timing . getHistory ( ) . get ( type . getKey ( ) ) , result . extra , rowRateUncertainty , output ) ; } printRow ( <str> , <str> , current , history , result . extra , rowRateUncertainty , output ) ; } if ( timing . done ( ) ) stop = true ; } public static final String HEADFORMAT = <str> ; public static final String ROWFORMAT = <str> ; public static final String [ ] HEADMETRICS = new String [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; public static final String HEAD = String . format ( HEADFORMAT , ( Object [ ] ) HEADMETRICS ) ; private static void printHeader ( String prefix , PrintStream output ) { output . println ( prefix + HEAD ) ; } private static void printRow ( String prefix , String type , TimingInterval interval , TimingInterval total , JmxCollector . GcStats gcStats , Uncertainty opRateUncertainty , PrintStream output ) { output . println ( prefix + String . format ( ROWFORMAT , type + <str> , total . operationCount , interval . opRate ( ) , interval . partitionRate ( ) , interval . rowRate ( ) , interval . meanLatency ( ) , interval . medianLatency ( ) , interval . rankLatency ( <float> ) , interval . rankLatency ( <float> ) , interval . rankLatency ( <float> ) , interval . maxLatency ( ) , total . runTime ( ) / <int> f , opRateUncertainty . getUncertainty ( ) , interval . errorCount , gcStats . count , gcStats . maxms , gcStats . summs , gcStats . sdvms , gcStats . bytes / ( <int> < < <int> ) ) ) ; } public void summarise ( ) { output . println ( <str> ) ; output . println ( <str> ) ; TimingIntervals opHistory = timing . getHistory ( ) ; TimingInterval history = opHistory . combine ( settings . samples . historyCount ) ; output . println ( String . format ( <str> , history . opRate ( ) , opHistory . opRates ( ) ) ) ; output . println ( String . format ( <str> , history . partitionRate ( ) , opHistory . partitionRates ( ) ) ) ; output . println ( String . format ( <str> , history . rowRate ( ) , opHistory . rowRates ( ) ) ) ; output . println ( String . format ( <str> , history . meanLatency ( ) , opHistory . meanLatencies ( ) ) ) ; output . println ( String . format ( <str> , history . medianLatency ( ) , opHistory . medianLatencies ( ) ) ) ; output . println ( String . format ( <str> , history . rankLatency ( <float> ) , opHistory . rankLatencies ( <float> ) ) ) ; output . println ( String . format ( <str> , history . rankLatency ( <float> ) , opHistory . rankLatencies ( <float> ) ) ) ; output . println ( String . format ( <str> , history . rankLatency ( <float> ) , opHistory . rankLatencies ( <float> ) ) ) ; output . println ( String . format ( <str> , history . maxLatency ( ) , opHistory . maxLatencies ( ) ) ) ; output . println ( String . format ( <str> , history . partitionCount , opHistory . partitionCounts ( ) ) ) ; output . println ( String . format ( <str> , history . errorCount , opHistory . errorCounts ( ) ) ) ; output . println ( String . format ( <str> , totalGcStats . count ) ) ; output . println ( String . format ( <str> , totalGcStats . bytes / ( <int> < < <int> ) ) ) ; output . println ( String . format ( <str> , totalGcStats . summs / <int> ) ) ; output . println ( String . format ( <str> , totalGcStats . summs / totalGcStats . count ) ) ; output . println ( String . format ( <str> , totalGcStats . sdvms ) ) ; output . println ( <str> + DurationFormatUtils . formatDuration ( history . runTime ( ) , <str> , true ) ) ; output . println ( <str> ) ; } public static void summarise ( List < String > ids , List < StressMetrics > summarise , PrintStream out , int historySampleCount ) { int idLen = <int> ; for ( String id : ids ) idLen = Math . max ( id . length ( ) , idLen ) ; String formatstr = <str> + idLen + <str> ; printHeader ( String . format ( formatstr , <str> ) , out ) ; for ( int i = <int> ; i < ids . size ( ) ; i + + ) { for ( Map . Entry < String , TimingInterval > type : summarise . get ( i ) . timing . getHistory ( ) . intervals ( ) . entrySet ( ) ) { printRow ( String . format ( formatstr , ids . get ( i ) ) , type . getKey ( ) , type . getValue ( ) , type . getValue ( ) , summarise . get ( i ) . totalGcStats , summarise . get ( i ) . rowRateUncertainty , out ) ; } TimingInterval hist = summarise . get ( i ) . timing . getHistory ( ) . combine ( historySampleCount ) ; printRow ( String . format ( formatstr , ids . get ( i ) ) , <str> , hist , hist , summarise . get ( i ) . totalGcStats , summarise . get ( i ) . rowRateUncertainty , out ) ; } } public Timing getTiming ( ) { return timing ; } public boolean wasCancelled ( ) { return cancelled ; } } 
