package com . badlogic . gdx . backends . lwjgl . audio ; import java . nio . ByteBuffer ; import java . nio . IntBuffer ; import org . lwjgl . BufferUtils ; import org . lwjgl . openal . AL11 ; import com . badlogic . gdx . audio . AudioDevice ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . GdxRuntimeException ; import static org . lwjgl . openal . AL10 . * ; public class OpenALAudioDevice implements AudioDevice { static private final int bytesPerSample = <int> ; private final OpenALAudio audio ; private final int channels ; private IntBuffer buffers ; private int sourceID = - <int> ; private int format , sampleRate ; private boolean isPlaying ; private float volume = <int> ; private float renderedSeconds , secondsPerBuffer ; private byte [ ] bytes ; private final int bufferSize ; private final int bufferCount ; private final ByteBuffer tempBuffer ; public OpenALAudioDevice ( OpenALAudio audio , int sampleRate , boolean isMono , int bufferSize , int bufferCount ) { this . audio = audio ; channels = isMono ? <int> : <int> ; this . bufferSize = bufferSize ; this . bufferCount = bufferCount ; this . format = channels > <int> ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16 ; this . sampleRate = sampleRate ; secondsPerBuffer = ( float ) bufferSize / bytesPerSample / channels / sampleRate ; tempBuffer = BufferUtils . createByteBuffer ( bufferSize ) ; } public void writeSamples ( short [ ] samples , int offset , int numSamples ) { if ( bytes = = null | | bytes . length < numSamples * <int> ) bytes = new byte [ numSamples * <int> ] ; int end = Math . min ( offset + numSamples , samples . length ) ; for ( int i = offset , ii = <int> ; i < end ; i + + ) { short sample = samples [ i ] ; bytes [ ii + + ] = ( byte ) ( sample & <hex> ) ; bytes [ ii + + ] = ( byte ) ( ( sample > > <int> ) & <hex> ) ; } writeSamples ( bytes , <int> , numSamples * <int> ) ; } public void writeSamples ( float [ ] samples , int offset , int numSamples ) { if ( bytes = = null | | bytes . length < numSamples * <int> ) bytes = new byte [ numSamples * <int> ] ; int end = Math . min ( offset + numSamples , samples . length ) ; for ( int i = offset , ii = <int> ; i < end ; i + + ) { float floatSample = samples [ i ] ; floatSample = MathUtils . clamp ( floatSample , - <float> , <float> ) ; int intSample = ( int ) ( floatSample * <int> ) ; bytes [ ii + + ] = ( byte ) ( intSample & <hex> ) ; bytes [ ii + + ] = ( byte ) ( ( intSample > > <int> ) & <hex> ) ; } writeSamples ( bytes , <int> , numSamples * <int> ) ; } public void writeSamples ( byte [ ] data , int offset , int length ) { if ( length < <int> ) throw new IllegalArgumentException ( <str> ) ; if ( sourceID = = - <int> ) { sourceID = audio . obtainSource ( true ) ; if ( sourceID = = - <int> ) return ; if ( buffers = = null ) { buffers = BufferUtils . createIntBuffer ( bufferCount ) ; alGenBuffers ( buffers ) ; if ( alGetError ( ) ! = AL_NO_ERROR ) throw new GdxRuntimeException ( <str> ) ; } alSourcei ( sourceID , AL_LOOPING , AL_FALSE ) ; alSourcef ( sourceID , AL_GAIN , volume ) ; int queuedBuffers = <int> ; for ( int i = <int> ; i < bufferCount ; i + + ) { int bufferID = buffers . get ( i ) ; int written = Math . min ( bufferSize , length ) ; tempBuffer . clear ( ) ; tempBuffer . put ( data , offset , written ) . flip ( ) ; alBufferData ( bufferID , format , tempBuffer , sampleRate ) ; alSourceQueueBuffers ( sourceID , bufferID ) ; length - = written ; offset + = written ; queuedBuffers + + ; } tempBuffer . clear ( ) . flip ( ) ; for ( int i = queuedBuffers ; i < bufferCount ; i + + ) { int bufferID = buffers . get ( i ) ; alBufferData ( bufferID , format , tempBuffer , sampleRate ) ; alSourceQueueBuffers ( sourceID , bufferID ) ; } alSourcePlay ( sourceID ) ; isPlaying = true ; } while ( length > <int> ) { int written = fillBuffer ( data , offset , length ) ; length - = written ; offset + = written ; } } private int fillBuffer ( byte [ ] data , int offset , int length ) { int written = Math . min ( bufferSize , length ) ; outer: while ( true ) { int buffers = alGetSourcei ( sourceID , AL_BUFFERS_PROCESSED ) ; while ( buffers - - > <int> ) { int bufferID = alSourceUnqueueBuffers ( sourceID ) ; if ( bufferID = = AL_INVALID_VALUE ) break ; renderedSeconds + = secondsPerBuffer ; tempBuffer . clear ( ) ; tempBuffer . put ( data , offset , written ) . flip ( ) ; alBufferData ( bufferID , format , tempBuffer , sampleRate ) ; alSourceQueueBuffers ( sourceID , bufferID ) ; break outer ; } try { Thread . sleep ( ( long ) ( <int> * secondsPerBuffer / bufferCount ) ) ; } catch ( InterruptedException ignored ) { } } if ( ! isPlaying | | alGetSourcei ( sourceID , AL_SOURCE_STATE ) ! = AL_PLAYING ) { alSourcePlay ( sourceID ) ; isPlaying = true ; } return written ; } public void stop ( ) { if ( sourceID = = - <int> ) return ; audio . freeSource ( sourceID ) ; sourceID = - <int> ; renderedSeconds = <int> ; isPlaying = false ; } public boolean isPlaying ( ) { if ( sourceID = = - <int> ) return false ; return isPlaying ; } public void setVolume ( float volume ) { this . volume = volume ; if ( sourceID ! = - <int> ) alSourcef ( sourceID , AL_GAIN , volume ) ; } public float getPosition ( ) { if ( sourceID = = - <int> ) return <int> ; return renderedSeconds + alGetSourcef ( sourceID , AL11 . AL_SEC_OFFSET ) ; } public void setPosition ( float position ) { renderedSeconds = position ; } public int getChannels ( ) { return format = = AL_FORMAT_STEREO16 ? <int> : <int> ; } public int getRate ( ) { return sampleRate ; } public void dispose ( ) { if ( buffers = = null ) return ; if ( sourceID ! = - <int> ) { audio . freeSource ( sourceID ) ; sourceID = - <int> ; } alDeleteBuffers ( buffers ) ; buffers = null ; } public boolean isMono ( ) { return channels = = <int> ; } public int getLatency ( ) { return ( int ) ( secondsPerBuffer * bufferCount * <int> ) ; } } 
