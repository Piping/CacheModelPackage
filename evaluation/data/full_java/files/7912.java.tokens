package org . elasticsearch . common . geo ; import com . spatial4j . core . exception . InvalidShapeException ; import com . spatial4j . core . shape . Circle ; import com . spatial4j . core . shape . Rectangle ; import com . spatial4j . core . shape . Shape ; import com . spatial4j . core . shape . ShapeCollection ; import com . spatial4j . core . shape . jts . JtsGeometry ; import com . spatial4j . core . shape . jts . JtsPoint ; import com . vividsolutions . jts . geom . * ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . common . geo . builders . ShapeBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . hamcrest . ElasticsearchGeoAssertions ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import static org . elasticsearch . common . geo . builders . ShapeBuilder . SPATIAL_CONTEXT ; public class GeoJSONShapeParserTests extends ESTestCase { private final static GeometryFactory GEOMETRY_FACTORY = SPATIAL_CONTEXT . getGeometryFactory ( ) ; public void testParse_simplePoint ( ) throws IOException { String pointGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . string ( ) ; Point expected = GEOMETRY_FACTORY . createPoint ( new Coordinate ( <float> , <float> ) ) ; assertGeometryEquals ( new JtsPoint ( expected , SPATIAL_CONTEXT ) , pointGeoJson ) ; } public void testParse_lineString ( ) throws IOException { String lineGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; List < Coordinate > lineCoordinates = new ArrayList < > ( ) ; lineCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; lineCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; LineString expected = GEOMETRY_FACTORY . createLineString ( lineCoordinates . toArray ( new Coordinate [ lineCoordinates . size ( ) ] ) ) ; assertGeometryEquals ( jtsGeom ( expected ) , lineGeoJson ) ; } public void testParse_multiLineString ( ) throws IOException { String multilinesGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; MultiLineString expected = GEOMETRY_FACTORY . createMultiLineString ( new LineString [ ] { GEOMETRY_FACTORY . createLineString ( new Coordinate [ ] { new Coordinate ( <int> , <int> ) , new Coordinate ( <int> , <int> ) , } ) , GEOMETRY_FACTORY . createLineString ( new Coordinate [ ] { new Coordinate ( <int> , <int> ) , new Coordinate ( <int> , <int> ) , } ) , } ) ; assertGeometryEquals ( jtsGeom ( expected ) , multilinesGeoJson ) ; } public void testParse_circle ( ) throws IOException { String multilinesGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . field ( <str> , <str> ) . endObject ( ) . string ( ) ; Circle expected = SPATIAL_CONTEXT . makeCircle ( <float> , <float> , <int> * <int> / GeoUtils . EARTH_EQUATOR ) ; assertGeometryEquals ( expected , multilinesGeoJson ) ; } public void testParse_multiDimensionShapes ( ) throws IOException { String pointGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . string ( ) ; Point expectedPt = GEOMETRY_FACTORY . createPoint ( new Coordinate ( <float> , <float> ) ) ; assertGeometryEquals ( new JtsPoint ( expectedPt , SPATIAL_CONTEXT ) , pointGeoJson ) ; String lineGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( <float> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; List < Coordinate > lineCoordinates = new ArrayList < > ( ) ; lineCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; lineCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; LineString expectedLS = GEOMETRY_FACTORY . createLineString ( lineCoordinates . toArray ( new Coordinate [ lineCoordinates . size ( ) ] ) ) ; assertGeometryEquals ( jtsGeom ( expectedLS ) , lineGeoJson ) ; } public void testParse_envelope ( ) throws IOException { String multilinesGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( - <int> ) . value ( <int> ) . endArray ( ) . startArray ( ) . value ( <int> ) . value ( - <int> ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; Rectangle expected = SPATIAL_CONTEXT . makeRectangle ( - <int> , <int> , - <int> , <int> ) ; assertGeometryEquals ( expected , multilinesGeoJson ) ; multilinesGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( <int> ) . value ( <int> ) . endArray ( ) . startArray ( ) . value ( - <int> ) . value ( - <int> ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; expected = SPATIAL_CONTEXT . makeRectangle ( - <int> , <int> , - <int> , <int> ) ; assertGeometryEquals ( expected , multilinesGeoJson ) ; multilinesGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( <int> ) . value ( <int> ) . endArray ( ) . startArray ( ) . value ( - <int> ) . value ( - <int> ) . endArray ( ) . startArray ( ) . value ( <int> ) . value ( - <int> ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( multilinesGeoJson ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; multilinesGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( multilinesGeoJson ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; } public void testParse_polygonNoHoles ( ) throws IOException { String polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; List < Coordinate > shellCoordinates = new ArrayList < > ( ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; LinearRing shell = GEOMETRY_FACTORY . createLinearRing ( shellCoordinates . toArray ( new Coordinate [ shellCoordinates . size ( ) ] ) ) ; Polygon expected = GEOMETRY_FACTORY . createPolygon ( shell , null ) ; assertGeometryEquals ( jtsGeom ( expected ) , polygonGeoJson ) ; } public void testParse_invalidPoint ( ) throws IOException { String invalidPoint1 = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( invalidPoint1 ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; String invalidPoint2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidPoint2 ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; } public void testParse_invalidMultipoint ( ) throws IOException { String invalidMultipoint1 = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( invalidMultipoint1 ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; String invalidMultipoint2 = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidMultipoint2 ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; String invalidMultipoint3 = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidMultipoint3 ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; } public void testParse_invalidMultiPolygon ( ) throws IOException { String multiPolygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( multiPolygonGeoJson ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , InvalidShapeException . class ) ; } public void testParse_OGCPolygonWithoutHoles ( ) throws IOException { String polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; Shape shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertMultiPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertMultiPolygon ( shape ) ; } public void testParse_OGCPolygonWithHoles ( ) throws IOException { String polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; Shape shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertMultiPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertMultiPolygon ( shape ) ; } public void testParse_invalidPolygon ( ) throws IOException { String invalidPoly = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( invalidPoly ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; invalidPoly = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidPoly ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; invalidPoly = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidPoly ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; invalidPoly = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . nullValue ( ) . nullValue ( ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidPoly ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , IllegalArgumentException . class ) ; invalidPoly = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . nullValue ( ) . nullValue ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidPoly ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , IllegalArgumentException . class ) ; invalidPoly = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidPoly ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; invalidPoly = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( invalidPoly ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , ElasticsearchParseException . class ) ; } public void testParse_polygonWithHole ( ) throws IOException { String polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; List < Coordinate > shellCoordinates = new ArrayList < > ( ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> , <float> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> , <float> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; List < Coordinate > holeCoordinates = new ArrayList < > ( ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; LinearRing shell = GEOMETRY_FACTORY . createLinearRing ( shellCoordinates . toArray ( new Coordinate [ shellCoordinates . size ( ) ] ) ) ; LinearRing [ ] holes = new LinearRing [ <int> ] ; holes [ <int> ] = GEOMETRY_FACTORY . createLinearRing ( holeCoordinates . toArray ( new Coordinate [ holeCoordinates . size ( ) ] ) ) ; Polygon expected = GEOMETRY_FACTORY . createPolygon ( shell , holes ) ; assertGeometryEquals ( jtsGeom ( expected ) , polygonGeoJson ) ; } public void testParse_selfCrossingPolygon ( ) throws IOException { String polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertValidException ( parser , InvalidShapeException . class ) ; } public void testParse_multiPoint ( ) throws IOException { String multiPointGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; ShapeCollection expected = shapeCollection ( SPATIAL_CONTEXT . makePoint ( <int> , <int> ) , SPATIAL_CONTEXT . makePoint ( <int> , <float> ) ) ; assertGeometryEquals ( expected , multiPointGeoJson ) ; } public void testParse_multiPolygon ( ) throws IOException { String multiPolygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; List < Coordinate > shellCoordinates = new ArrayList < > ( ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; List < Coordinate > holeCoordinates = new ArrayList < > ( ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; LinearRing shell = GEOMETRY_FACTORY . createLinearRing ( shellCoordinates . toArray ( new Coordinate [ shellCoordinates . size ( ) ] ) ) ; LinearRing [ ] holes = new LinearRing [ <int> ] ; holes [ <int> ] = GEOMETRY_FACTORY . createLinearRing ( holeCoordinates . toArray ( new Coordinate [ holeCoordinates . size ( ) ] ) ) ; Polygon withHoles = GEOMETRY_FACTORY . createPolygon ( shell , holes ) ; shellCoordinates = new ArrayList < > ( ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shell = GEOMETRY_FACTORY . createLinearRing ( shellCoordinates . toArray ( new Coordinate [ shellCoordinates . size ( ) ] ) ) ; Polygon withoutHoles = GEOMETRY_FACTORY . createPolygon ( shell , null ) ; Shape expected = shapeCollection ( withoutHoles , withHoles ) ; assertGeometryEquals ( expected , multiPolygonGeoJson ) ; multiPolygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; shellCoordinates = new ArrayList < > ( ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; shellCoordinates . add ( new Coordinate ( <int> , <int> ) ) ; holeCoordinates = new ArrayList < > ( ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; holeCoordinates . add ( new Coordinate ( <float> , <float> ) ) ; shell = GEOMETRY_FACTORY . createLinearRing ( shellCoordinates . toArray ( new Coordinate [ shellCoordinates . size ( ) ] ) ) ; holes = new LinearRing [ <int> ] ; holes [ <int> ] = GEOMETRY_FACTORY . createLinearRing ( holeCoordinates . toArray ( new Coordinate [ holeCoordinates . size ( ) ] ) ) ; withHoles = GEOMETRY_FACTORY . createPolygon ( shell , holes ) ; assertGeometryEquals ( jtsGeom ( withHoles ) , multiPolygonGeoJson ) ; } public void testParse_geometryCollection ( ) throws IOException { String geometryCollectionGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endObject ( ) . startObject ( ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . endArray ( ) . endObject ( ) . string ( ) ; Shape [ ] expected = new Shape [ <int> ] ; LineString expectedLineString = GEOMETRY_FACTORY . createLineString ( new Coordinate [ ] { new Coordinate ( <int> , <int> ) , new Coordinate ( <int> , <int> ) , } ) ; expected [ <int> ] = jtsGeom ( expectedLineString ) ; Point expectedPoint = GEOMETRY_FACTORY . createPoint ( new Coordinate ( <float> , <float> ) ) ; expected [ <int> ] = new JtsPoint ( expectedPoint , SPATIAL_CONTEXT ) ; assertGeometryEquals ( shapeCollection ( expected ) , geometryCollectionGeoJson ) ; } public void testThatParserExtractsCorrectTypeAndCoordinatesFromArbitraryJson ( ) throws IOException { String pointGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startObject ( <str> ) . startArray ( <str> ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . string ( ) ; Point expected = GEOMETRY_FACTORY . createPoint ( new Coordinate ( <float> , <float> ) ) ; assertGeometryEquals ( new JtsPoint ( expected , SPATIAL_CONTEXT ) , pointGeoJson ) ; } public void testParse_orientationOption ( ) throws IOException { String polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; XContentParser parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; Shape shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertMultiPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertMultiPolygon ( shape ) ; polygonGeoJson = XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . field ( <str> , <str> ) . startArray ( <str> ) . startArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . startArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( <float> ) . endArray ( ) . startArray ( ) . value ( <float> ) . value ( - <float> ) . endArray ( ) . startArray ( ) . value ( - <float> ) . value ( <float> ) . endArray ( ) . endArray ( ) . endArray ( ) . endObject ( ) . string ( ) ; parser = JsonXContent . jsonXContent . createParser ( polygonGeoJson ) ; parser . nextToken ( ) ; shape = ShapeBuilder . parse ( parser ) . build ( ) ; ElasticsearchGeoAssertions . assertMultiPolygon ( shape ) ; } private void assertGeometryEquals ( Shape expected , String geoJson ) throws IOException { XContentParser parser = JsonXContent . jsonXContent . createParser ( geoJson ) ; parser . nextToken ( ) ; ElasticsearchGeoAssertions . assertEquals ( expected , ShapeBuilder . parse ( parser ) . build ( ) ) ; } private ShapeCollection < Shape > shapeCollection ( Shape . . . shapes ) { return new ShapeCollection < > ( Arrays . asList ( shapes ) , SPATIAL_CONTEXT ) ; } private ShapeCollection < Shape > shapeCollection ( Geometry . . . geoms ) { List < Shape > shapes = new ArrayList < > ( geoms . length ) ; for ( Geometry geom : geoms ) { shapes . add ( jtsGeom ( geom ) ) ; } return new ShapeCollection < > ( shapes , SPATIAL_CONTEXT ) ; } private JtsGeometry jtsGeom ( Geometry geom ) { return new JtsGeometry ( geom , SPATIAL_CONTEXT , false , false ) ; } } 
