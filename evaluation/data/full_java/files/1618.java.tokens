package org . apache . cassandra . service ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . * ; import com . google . common . collect . HashMultimap ; import com . google . common . collect . Multimap ; import org . junit . AfterClass ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . RandomPartitioner ; import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . gms . ApplicationState ; import org . apache . cassandra . gms . Gossiper ; import org . apache . cassandra . gms . VersionedValue ; import org . apache . cassandra . locator . AbstractReplicationStrategy ; import org . apache . cassandra . locator . SimpleSnitch ; import org . apache . cassandra . locator . TokenMetadata ; import org . apache . cassandra . schema . KeyspaceMetadata ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; public class MoveTest { private static final IPartitioner partitioner = RandomPartitioner . instance ; private static IPartitioner oldPartitioner ; private static final String KEYSPACE1 = <str> ; private static final String KEYSPACE2 = <str> ; private static final String KEYSPACE3 = <str> ; private static final String KEYSPACE4 = <str> ; @BeforeClass public static void setup ( ) throws ConfigurationException { oldPartitioner = StorageService . instance . setPartitionerUnsafe ( partitioner ) ; SchemaLoader . loadSchema ( ) ; SchemaLoader . schemaDefinition ( <str> ) ; } @AfterClass public static void tearDown ( ) { StorageService . instance . setPartitionerUnsafe ( oldPartitioner ) ; } @Before public void clearTokenMetadata ( ) { PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; StorageService . instance . getTokenMetadata ( ) . clearUnsafe ( ) ; } @Test public void newTestWriteEndpointsDuringMove ( ) throws Exception { StorageService ss = StorageService . instance ; final int RING_SIZE = <int> ; final int MOVING_NODE = <int> ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , RING_SIZE ) ; Map < Token , List < InetAddress > > expectedEndpoints = new HashMap < Token , List < InetAddress > > ( ) ; for ( Token token : keyTokens ) { List < InetAddress > endpoints = new ArrayList < InetAddress > ( ) ; Iterator < Token > tokenIter = TokenMetadata . ringIterator ( tmd . sortedTokens ( ) , token , false ) ; while ( tokenIter . hasNext ( ) ) { endpoints . add ( tmd . getEndpoint ( tokenIter . next ( ) ) ) ; } expectedEndpoints . put ( token , endpoints ) ; } Token newToken = positionToken ( MOVING_NODE ) ; ss . onChange ( hosts . get ( MOVING_NODE ) , ApplicationState . STATUS , valueFactory . moving ( newToken ) ) ; PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; assertTrue ( tmd . isMoving ( hosts . get ( MOVING_NODE ) ) ) ; AbstractReplicationStrategy strategy ; for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) { strategy = getStrategy ( keyspaceName , tmd ) ; int numMoved = <int> ; for ( Token token : keyTokens ) { int replicationFactor = strategy . getReplicationFactor ( ) ; HashSet < InetAddress > actual = new HashSet < InetAddress > ( tmd . getWriteEndpoints ( token , keyspaceName , strategy . calculateNaturalEndpoints ( token , tmd . cloneOnlyTokenMap ( ) ) ) ) ; HashSet < InetAddress > expected = new HashSet < InetAddress > ( ) ; for ( int i = <int> ; i < replicationFactor ; i + + ) { expected . add ( expectedEndpoints . get ( token ) . get ( i ) ) ; } if ( expected . size ( ) = = actual . size ( ) ) { assertEquals ( <str> , expected , actual ) ; } else { expected . add ( hosts . get ( MOVING_NODE ) ) ; assertEquals ( <str> , expected , actual ) ; numMoved + + ; } } assertEquals ( <str> , <int> , numMoved ) ; } ss . onChange ( hosts . get ( MOVING_NODE ) , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( newToken ) ) ) ; } @Test public void testSimultaneousMove ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; final int RING_SIZE = <int> ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; IPartitioner partitioner = RandomPartitioner . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , RING_SIZE ) ; final int [ ] MOVING = new int [ ] { <int> , <int> , <int> } ; Map < Integer , Token > newTokens = new HashMap < Integer , Token > ( ) ; for ( int movingIndex : MOVING ) { Token newToken = positionToken ( movingIndex ) ; ss . onChange ( hosts . get ( movingIndex ) , ApplicationState . STATUS , valueFactory . moving ( newToken ) ) ; newTokens . put ( movingIndex , newToken ) ; } Collection < InetAddress > endpoints ; tmd = tmd . cloneAfterAllSettled ( ) ; ss . setTokenMetadataUnsafe ( tmd ) ; InetAddress boot1 = InetAddress . getByName ( <str> ) ; Gossiper . instance . initializeNodeUnsafe ( boot1 , UUID . randomUUID ( ) , <int> ) ; Gossiper . instance . injectApplicationState ( boot1 , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( boot1 , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; InetAddress boot2 = InetAddress . getByName ( <str> ) ; Gossiper . instance . initializeNodeUnsafe ( boot2 , UUID . randomUUID ( ) , <int> ) ; Gossiper . instance . injectApplicationState ( boot2 , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( keyTokens . get ( <int> ) ) ) ) ; ss . onChange ( boot2 , ApplicationState . STATUS , valueFactory . bootstrapping ( Collections . < Token > singleton ( keyTokens . get ( <int> ) ) ) ) ; PendingRangeCalculatorService . instance . blockUntilFinished ( ) ; Map < String , AbstractReplicationStrategy > keyspaceStrategyMap = new HashMap < String , AbstractReplicationStrategy > ( ) ; for ( int i = <int> ; i < = <int> ; i + + ) { keyspaceStrategyMap . put ( <str> + i , getStrategy ( <str> + i , tmd ) ) ; } Multimap < InetAddress , Range < Token > > keyspace1ranges = keyspaceStrategyMap . get ( KEYSPACE1 ) . getAddressRanges ( ) ; Collection < Range < Token > > ranges1 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges1 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges1 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges2 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges2 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges2 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges3 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges3 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges3 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges4 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges4 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges4 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges5 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges5 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges5 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges6 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges6 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges6 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges7 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges7 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges7 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges8 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges8 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges8 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges9 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges9 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges9 . iterator ( ) . next ( ) ) ; Collection < Range < Token > > ranges10 = keyspace1ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( <int> , collectionSize ( ranges10 ) ) ; assertEquals ( generateRange ( <int> , <int> ) , ranges10 . iterator ( ) . next ( ) ) ; Multimap < InetAddress , Range < Token > > keyspace3ranges = keyspaceStrategyMap . get ( KEYSPACE3 ) . getAddressRanges ( ) ; ranges1 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges1 ) , <int> ) ; assertTrue ( ranges1 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges2 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges2 ) , <int> ) ; assertTrue ( ranges2 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges3 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges3 ) , <int> ) ; assertTrue ( ranges3 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges4 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges4 ) , <int> ) ; assertTrue ( ranges4 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges5 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges5 ) , <int> ) ; assertTrue ( ranges5 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges6 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges6 ) , <int> ) ; assertTrue ( ranges6 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges7 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges7 ) , <int> ) ; assertTrue ( ranges7 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges8 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges8 ) , <int> ) ; assertTrue ( ranges8 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges9 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges9 ) , <int> ) ; assertTrue ( ranges9 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges10 = keyspace3ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges10 ) , <int> ) ; assertTrue ( ranges10 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; Multimap < InetAddress , Range < Token > > keyspace4ranges = keyspaceStrategyMap . get ( KEYSPACE4 ) . getAddressRanges ( ) ; ranges1 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges1 ) , <int> ) ; assertTrue ( ranges1 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges2 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges2 ) , <int> ) ; assertTrue ( ranges2 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges3 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges3 ) , <int> ) ; assertTrue ( ranges3 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges4 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges4 ) , <int> ) ; assertTrue ( ranges4 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges5 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges5 ) , <int> ) ; assertTrue ( ranges5 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges6 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges6 ) , <int> ) ; assertTrue ( ranges6 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges7 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges7 ) , <int> ) ; assertTrue ( ranges7 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges8 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges8 ) , <int> ) ; assertTrue ( ranges8 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges9 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges9 ) , <int> ) ; assertTrue ( ranges9 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; ranges10 = keyspace4ranges . get ( InetAddress . getByName ( <str> ) ) ; assertEquals ( collectionSize ( ranges10 ) , <int> ) ; assertTrue ( ranges10 . equals ( generateRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ) ; Map < String , Multimap < Token , InetAddress > > expectedEndpoints = new HashMap < String , Multimap < Token , InetAddress > > ( ) ; expectedEndpoints . put ( KEYSPACE1 , HashMultimap . < Token , InetAddress > create ( ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE1 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . put ( KEYSPACE2 , HashMultimap . < Token , InetAddress > create ( ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . get ( KEYSPACE2 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> ) ) ; expectedEndpoints . put ( KEYSPACE3 , HashMultimap . < Token , InetAddress > create ( ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE3 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . put ( KEYSPACE4 , HashMultimap . < Token , InetAddress > create ( ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; expectedEndpoints . get ( KEYSPACE4 ) . putAll ( new BigIntegerToken ( <str> ) , makeAddrs ( <str> , <str> , <str> ) ) ; for ( Map . Entry < String , AbstractReplicationStrategy > keyspaceStrategy : keyspaceStrategyMap . entrySet ( ) ) { String keyspaceName = keyspaceStrategy . getKey ( ) ; AbstractReplicationStrategy strategy = keyspaceStrategy . getValue ( ) ; for ( Token token : keyTokens ) { endpoints = tmd . getWriteEndpoints ( token , keyspaceName , strategy . getNaturalEndpoints ( token ) ) ; assertEquals ( expectedEndpoints . get ( keyspaceName ) . get ( token ) . size ( ) , endpoints . size ( ) ) ; assertTrue ( expectedEndpoints . get ( keyspaceName ) . get ( token ) . containsAll ( endpoints ) ) ; } if ( strategy . getReplicationFactor ( ) ! = <int> ) continue ; for ( int i = <int> ; i < <int> ; i + + ) { endpoints = tmd . getWriteEndpoints ( keyTokens . get ( i ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( i ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( i + <int> ) ) ) ; } endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot1 ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( boot2 ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; endpoints = tmd . getWriteEndpoints ( keyTokens . get ( <int> ) , keyspaceName , strategy . getNaturalEndpoints ( keyTokens . get ( <int> ) ) ) ; assertEquals ( <int> , endpoints . size ( ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; assertTrue ( endpoints . contains ( hosts . get ( <int> ) ) ) ; } for ( Integer movingIndex : MOVING ) { ss . onChange ( hosts . get ( movingIndex ) , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( newTokens . get ( movingIndex ) ) ) ) ; } } @Test public void testStateJumpToNormal ( ) throws UnknownHostException { StorageService ss = StorageService . instance ; TokenMetadata tmd = ss . getTokenMetadata ( ) ; IPartitioner partitioner = RandomPartitioner . instance ; VersionedValue . VersionedValueFactory valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; ArrayList < Token > endpointTokens = new ArrayList < Token > ( ) ; ArrayList < Token > keyTokens = new ArrayList < Token > ( ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; List < UUID > hostIds = new ArrayList < UUID > ( ) ; Util . createInitialRing ( ss , partitioner , endpointTokens , keyTokens , hosts , hostIds , <int> ) ; Token newToken = positionToken ( <int> ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . moving ( newToken ) ) ; assertTrue ( tmd . isMoving ( hosts . get ( <int> ) ) ) ; assertEquals ( endpointTokens . get ( <int> ) , tmd . getToken ( hosts . get ( <int> ) ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( newToken ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( newToken ) ) ) ; assertTrue ( tmd . getMovingEndpoints ( ) . isEmpty ( ) ) ; assertEquals ( newToken , tmd . getToken ( hosts . get ( <int> ) ) ) ; newToken = positionToken ( <int> ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . moving ( newToken ) ) ; Gossiper . instance . injectApplicationState ( hosts . get ( <int> ) , ApplicationState . TOKENS , valueFactory . tokens ( Collections . singleton ( newToken ) ) ) ; ss . onChange ( hosts . get ( <int> ) , ApplicationState . STATUS , valueFactory . normal ( Collections . singleton ( newToken ) ) ) ; assertTrue ( tmd . getBootstrapTokens ( ) . isEmpty ( ) ) ; assertTrue ( tmd . getMovingEndpoints ( ) . isEmpty ( ) ) ; assertEquals ( newToken , tmd . getToken ( hosts . get ( <int> ) ) ) ; } private static Collection < InetAddress > makeAddrs ( String . . . hosts ) throws UnknownHostException { ArrayList < InetAddress > addrs = new ArrayList < InetAddress > ( hosts . length ) ; for ( String host : hosts ) addrs . add ( InetAddress . getByName ( host ) ) ; return addrs ; } private AbstractReplicationStrategy getStrategy ( String keyspaceName , TokenMetadata tmd ) { KeyspaceMetadata ksmd = Schema . instance . getKSMetaData ( keyspaceName ) ; return AbstractReplicationStrategy . createReplicationStrategy ( keyspaceName , ksmd . params . replication . klass , tmd , new SimpleSnitch ( ) , ksmd . params . replication . options ) ; } private Token positionToken ( int position ) { return new BigIntegerToken ( String . valueOf ( <int> * position + <int> ) ) ; } private int collectionSize ( Collection < ? > collection ) { if ( collection . isEmpty ( ) ) return <int> ; Iterator < ? > iterator = collection . iterator ( ) ; int count = <int> ; while ( iterator . hasNext ( ) ) { iterator . next ( ) ; count + + ; } return count ; } private Collection < Range < Token > > generateRanges ( int . . . rangePairs ) { if ( rangePairs . length % <int> = = <int> ) throw new RuntimeException ( <str> ) ; Set < Range < Token > > ranges = new HashSet < Range < Token > > ( ) ; for ( int i = <int> ; i < rangePairs . length ; i + = <int> ) { ranges . add ( generateRange ( rangePairs [ i ] , rangePairs [ i + <int> ] ) ) ; } return ranges ; } private Range < Token > generateRange ( int left , int right ) { return new Range < Token > ( new BigIntegerToken ( String . valueOf ( left ) ) , new BigIntegerToken ( String . valueOf ( right ) ) ) ; } } 
