package org . elasticsearch . gateway ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . index . Index ; import org . elasticsearch . test . ESTestCase ; import org . hamcrest . Matchers ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . Map ; import static org . hamcrest . Matchers . equalTo ; public class DanglingIndicesStateTests extends ESTestCase { private static Settings indexSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_VERSION_CREATED , Version . CURRENT ) . build ( ) ; public void testCleanupWhenEmpty ( ) throws Exception { try ( NodeEnvironment env = newNodeEnvironment ( ) ) { MetaStateService metaStateService = new MetaStateService ( Settings . EMPTY , env ) ; DanglingIndicesState danglingState = new DanglingIndicesState ( Settings . EMPTY , env , metaStateService , null ) ; assertTrue ( danglingState . getDanglingIndices ( ) . isEmpty ( ) ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; danglingState . cleanupAllocatedDangledIndices ( metaData ) ; assertTrue ( danglingState . getDanglingIndices ( ) . isEmpty ( ) ) ; } } public void testDanglingProcessing ( ) throws Exception { try ( NodeEnvironment env = newNodeEnvironment ( ) ) { MetaStateService metaStateService = new MetaStateService ( Settings . EMPTY , env ) ; DanglingIndicesState danglingState = new DanglingIndicesState ( Settings . EMPTY , env , metaStateService , null ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; IndexMetaData dangledIndex = IndexMetaData . builder ( <str> ) . settings ( indexSettings ) . build ( ) ; metaStateService . writeIndex ( <str> , dangledIndex , null ) ; int numberOfChecks = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numberOfChecks ; i + + ) { Map < String , IndexMetaData > newDanglingIndices = danglingState . findNewDanglingIndices ( metaData ) ; assertThat ( newDanglingIndices . size ( ) , equalTo ( <int> ) ) ; assertThat ( newDanglingIndices . keySet ( ) , Matchers . hasItems ( <str> ) ) ; assertTrue ( danglingState . getDanglingIndices ( ) . isEmpty ( ) ) ; } for ( int i = <int> ; i < numberOfChecks ; i + + ) { danglingState . findNewAndAddDanglingIndices ( metaData ) ; assertThat ( danglingState . getDanglingIndices ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( danglingState . getDanglingIndices ( ) . keySet ( ) , Matchers . hasItems ( <str> ) ) ; } metaData = MetaData . builder ( metaData ) . put ( dangledIndex , true ) . build ( ) ; for ( int i = <int> ; i < numberOfChecks ; i + + ) { Map < String , IndexMetaData > newDanglingIndices = danglingState . findNewDanglingIndices ( metaData ) ; assertTrue ( newDanglingIndices . isEmpty ( ) ) ; assertThat ( danglingState . getDanglingIndices ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( danglingState . getDanglingIndices ( ) . keySet ( ) , Matchers . hasItems ( <str> ) ) ; } danglingState . cleanupAllocatedDangledIndices ( metaData ) ; assertTrue ( danglingState . getDanglingIndices ( ) . isEmpty ( ) ) ; } } public void testRenameOfIndexState ( ) throws Exception { try ( NodeEnvironment env = newNodeEnvironment ( ) ) { MetaStateService metaStateService = new MetaStateService ( Settings . EMPTY , env ) ; DanglingIndicesState danglingState = new DanglingIndicesState ( Settings . EMPTY , env , metaStateService , null ) ; MetaData metaData = MetaData . builder ( ) . build ( ) ; IndexMetaData dangledIndex = IndexMetaData . builder ( <str> ) . settings ( indexSettings ) . build ( ) ; metaStateService . writeIndex ( <str> , dangledIndex , null ) ; for ( Path path : env . indexPaths ( new Index ( <str> ) ) ) { Files . move ( path , path . getParent ( ) . resolve ( <str> ) ) ; } Map < String , IndexMetaData > newDanglingIndices = danglingState . findNewDanglingIndices ( metaData ) ; assertThat ( newDanglingIndices . size ( ) , equalTo ( <int> ) ) ; assertThat ( newDanglingIndices . keySet ( ) , Matchers . hasItems ( <str> ) ) ; } } } 
