package org . elasticsearch . test . search . aggregations . bucket ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . search . aggregations . Aggregation ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTerms ; import org . elasticsearch . search . aggregations . bucket . significant . SignificantTermsBuilder ; import org . elasticsearch . search . aggregations . bucket . terms . StringTerms ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . TermsBuilder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESTestCase ; import org . junit . Assert ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . test . ESIntegTestCase . client ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; public class SharedSignificantTermsTestMethods { public static final String INDEX_NAME = <str> ; public static final String DOC_TYPE = <str> ; public static final String TEXT_FIELD = <str> ; public static final String CLASS_FIELD = <str> ; public static void aggregateAndCheckFromSeveralShards ( ESIntegTestCase testCase ) throws ExecutionException , InterruptedException { String type = ESTestCase . randomBoolean ( ) ? <str> : <str> ; String settings = <str> ; index01Docs ( type , settings , testCase ) ; testCase . ensureGreen ( ) ; testCase . logClusterState ( ) ; checkSignificantTermsAggregationCorrect ( testCase ) ; } private static void checkSignificantTermsAggregationCorrect ( ESIntegTestCase testCase ) { SearchResponse response = client ( ) . prepareSearch ( INDEX_NAME ) . setTypes ( DOC_TYPE ) . addAggregation ( new TermsBuilder ( <str> ) . field ( CLASS_FIELD ) . subAggregation ( new SignificantTermsBuilder ( <str> ) . field ( TEXT_FIELD ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; StringTerms classes = response . getAggregations ( ) . get ( <str> ) ; Assert . assertThat ( classes . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( Terms . Bucket classBucket : classes . getBuckets ( ) ) { Map < String , Aggregation > aggs = classBucket . getAggregations ( ) . asMap ( ) ; Assert . assertTrue ( aggs . containsKey ( <str> ) ) ; SignificantTerms agg = ( SignificantTerms ) aggs . get ( <str> ) ; Assert . assertThat ( agg . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; SignificantTerms . Bucket sigBucket = agg . iterator ( ) . next ( ) ; String term = sigBucket . getKeyAsString ( ) ; String classTerm = classBucket . getKeyAsString ( ) ; Assert . assertTrue ( term . equals ( classTerm ) ) ; } } public static void index01Docs ( String type , String settings , ESIntegTestCase testCase ) throws ExecutionException , InterruptedException { String mappings = <str> + type + <str> ; assertAcked ( testCase . prepareCreate ( INDEX_NAME ) . setSettings ( settings ) . addMapping ( <str> , mappings ) ) ; String [ ] gb = { <str> , <str> } ; List < IndexRequestBuilder > indexRequestBuilderList = new ArrayList < > ( ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , <str> , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , <str> , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , <str> , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , <str> , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , gb , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , gb , CLASS_FIELD , <str> ) ) ; indexRequestBuilderList . add ( client ( ) . prepareIndex ( INDEX_NAME , DOC_TYPE , <str> ) . setSource ( TEXT_FIELD , <str> , CLASS_FIELD , <str> ) ) ; testCase . indexRandom ( true , false , indexRequestBuilderList ) ; } } 
