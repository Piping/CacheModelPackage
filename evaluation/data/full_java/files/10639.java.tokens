package com . google . common . util . concurrent ; import static com . google . common . util . concurrent . MoreExecutors . directExecutor ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executor ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicInteger ; public class ExecutionListTest extends TestCase { private final ExecutionList list = new ExecutionList ( ) ; public void testRunOnPopulatedList ( ) throws Exception { Executor exec = Executors . newCachedThreadPool ( ) ; CountDownLatch countDownLatch = new CountDownLatch ( <int> ) ; list . add ( new MockRunnable ( countDownLatch ) , exec ) ; list . add ( new MockRunnable ( countDownLatch ) , exec ) ; list . add ( new MockRunnable ( countDownLatch ) , exec ) ; assertEquals ( countDownLatch . getCount ( ) , <int> ) ; list . execute ( ) ; assertTrue ( countDownLatch . await ( <int> , TimeUnit . SECONDS ) ) ; } public void testExecute_idempotent ( ) { final AtomicInteger runCalled = new AtomicInteger ( ) ; list . add ( new Runnable ( ) { @Override public void run ( ) { runCalled . getAndIncrement ( ) ; } } , directExecutor ( ) ) ; list . execute ( ) ; assertEquals ( <int> , runCalled . get ( ) ) ; list . execute ( ) ; assertEquals ( <int> , runCalled . get ( ) ) ; } public void testExecute_idempotentConcurrently ( ) throws InterruptedException { final CountDownLatch okayToRun = new CountDownLatch ( <int> ) ; final AtomicInteger runCalled = new AtomicInteger ( ) ; list . add ( new Runnable ( ) { @Override public void run ( ) { try { okayToRun . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new RuntimeException ( e ) ; } runCalled . getAndIncrement ( ) ; } } , directExecutor ( ) ) ; Runnable execute = new Runnable ( ) { @Override public void run ( ) { list . execute ( ) ; } } ; Thread thread1 = new Thread ( execute ) ; Thread thread2 = new Thread ( execute ) ; thread1 . start ( ) ; thread2 . start ( ) ; assertEquals ( <int> , runCalled . get ( ) ) ; okayToRun . countDown ( ) ; thread1 . join ( ) ; thread2 . join ( ) ; assertEquals ( <int> , runCalled . get ( ) ) ; } public void testAddAfterRun ( ) throws Exception { testRunOnPopulatedList ( ) ; CountDownLatch countDownLatch = new CountDownLatch ( <int> ) ; list . add ( new MockRunnable ( countDownLatch ) , Executors . newCachedThreadPool ( ) ) ; assertTrue ( countDownLatch . await ( <int> , TimeUnit . SECONDS ) ) ; } public void testOrdering ( ) throws Exception { final AtomicInteger integer = new AtomicInteger ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { final int expectedCount = i ; list . add ( new Runnable ( ) { @Override public void run ( ) { integer . compareAndSet ( expectedCount , expectedCount + <int> ) ; } } , MoreExecutors . directExecutor ( ) ) ; } list . execute ( ) ; assertEquals ( <int> , integer . get ( ) ) ; } private class MockRunnable implements Runnable { CountDownLatch countDownLatch ; MockRunnable ( CountDownLatch countDownLatch ) { this . countDownLatch = countDownLatch ; } @Override public void run ( ) { countDownLatch . countDown ( ) ; } } public void testExceptionsCaught ( ) { list . add ( THROWING_RUNNABLE , directExecutor ( ) ) ; list . execute ( ) ; list . add ( THROWING_RUNNABLE , directExecutor ( ) ) ; } public void testNulls ( ) { new NullPointerTester ( ) . testAllPublicInstanceMethods ( new ExecutionList ( ) ) ; } private static final Runnable THROWING_RUNNABLE = new Runnable ( ) { @Override public void run ( ) { throw new RuntimeException ( ) ; } } ; } 
