package org . apache . cassandra . db . compaction ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . db . marshal . AsciiType ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . junit . BeforeClass ; import com . google . common . collect . Multimap ; import com . google . common . collect . Sets ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . apache . cassandra . OrderedJUnit4ClassRunner ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . ISSTableScanner ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . tools . SSTableExpiredBlockers ; import org . apache . cassandra . utils . ByteBufferUtil ; import java . io . IOException ; import java . util . Collections ; import java . util . Set ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertTrue ; @RunWith ( OrderedJUnit4ClassRunner . class ) public class TTLExpiryTest { public static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , CFMetaData . Builder . create ( KEYSPACE1 , CF_STANDARD1 ) . addPartitionKey ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . addRegularColumn ( <str> , AsciiType . instance ) . build ( ) . gcGraceSeconds ( <int> ) ) ; } @Test public void testAggressiveFullyExpired ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( <str> ) ; cfs . disableAutoCompaction ( ) ; cfs . metadata . gcGraceSeconds ( <int> ) ; String key = <str> ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; Set < SSTableReader > sstables = Sets . newHashSet ( cfs . getLiveSSTables ( ) ) ; int now = ( int ) ( System . currentTimeMillis ( ) / <int> ) ; int gcBefore = now + <int> ; Set < SSTableReader > expired = CompactionController . getFullyExpiredSSTables ( cfs , sstables , Collections . EMPTY_SET , gcBefore ) ; assertEquals ( <int> , expired . size ( ) ) ; cfs . clearUnsafe ( ) ; } @Test public void testSimpleExpire ( ) throws InterruptedException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( <str> ) ; cfs . disableAutoCompaction ( ) ; cfs . metadata . gcGraceSeconds ( <int> ) ; long timestamp = System . currentTimeMillis ( ) ; String key = <str> ; new RowUpdateBuilder ( cfs . metadata , timestamp , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , timestamp , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , timestamp , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , timestamp , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; Thread . sleep ( <int> ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; cfs . enableAutoCompaction ( true ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; } @Test public void testNoExpire ( ) throws InterruptedException , IOException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( <str> ) ; cfs . disableAutoCompaction ( ) ; cfs . metadata . gcGraceSeconds ( <int> ) ; long timestamp = System . currentTimeMillis ( ) ; String key = <str> ; new RowUpdateBuilder ( cfs . metadata , timestamp , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , timestamp , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; new RowUpdateBuilder ( cfs . metadata , timestamp , <int> , key ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; String noTTLKey = <str> ; new RowUpdateBuilder ( cfs . metadata , timestamp , noTTLKey ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; Thread . sleep ( <int> ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; cfs . enableAutoCompaction ( true ) ; assertEquals ( <int> , cfs . getLiveSSTables ( ) . size ( ) ) ; SSTableReader sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; ISSTableScanner scanner = sstable . getScanner ( ColumnFilter . all ( sstable . metadata ) , DataRange . allData ( cfs . getPartitioner ( ) ) , false ) ; assertTrue ( scanner . hasNext ( ) ) ; while ( scanner . hasNext ( ) ) { UnfilteredRowIterator iter = scanner . next ( ) ; assertEquals ( Util . dk ( noTTLKey ) , iter . partitionKey ( ) ) ; } scanner . close ( ) ; } @Test public void testCheckForExpiredSSTableBlockers ( ) throws InterruptedException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( <str> ) ; cfs . truncateBlocking ( ) ; cfs . disableAutoCompaction ( ) ; cfs . metadata . gcGraceSeconds ( <int> ) ; new RowUpdateBuilder ( cfs . metadata , System . currentTimeMillis ( ) , <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; SSTableReader blockingSSTable = cfs . getSSTables ( SSTableSet . LIVE ) . iterator ( ) . next ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { new RowUpdateBuilder ( cfs . metadata , System . currentTimeMillis ( ) , <str> ) . delete ( <str> ) . build ( ) . applyUnsafe ( ) ; cfs . forceBlockingFlush ( ) ; } Multimap < SSTableReader , SSTableReader > blockers = SSTableExpiredBlockers . checkForExpiredSSTableBlockers ( cfs . getSSTables ( SSTableSet . LIVE ) , ( int ) ( System . currentTimeMillis ( ) / <int> ) + <int> ) ; assertEquals ( <int> , blockers . keySet ( ) . size ( ) ) ; assertTrue ( blockers . keySet ( ) . contains ( blockingSSTable ) ) ; assertEquals ( <int> , blockers . get ( blockingSSTable ) . size ( ) ) ; } } 
