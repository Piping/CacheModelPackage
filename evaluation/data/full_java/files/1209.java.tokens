package org . apache . cassandra . utils ; import java . nio . ByteBuffer ; import java . util . concurrent . atomic . AtomicReference ; import org . apache . cassandra . db . SystemKeyspace ; public class CounterId implements Comparable < CounterId > { public static final int LENGTH = <int> ; private static class LocalId { static final LocalCounterIdHolder instance = new LocalCounterIdHolder ( ) ; } private final ByteBuffer id ; private static LocalCounterIdHolder localId ( ) { return LocalId . instance ; } public static CounterId getLocalId ( ) { return localId ( ) . get ( ) ; } public static CounterId fromInt ( int n ) { long lowBits = <hex> | n ; return new CounterId ( ByteBuffer . allocate ( <int> ) . putLong ( <int> , <int> ) . putLong ( <int> , lowBits ) ) ; } public static CounterId wrap ( ByteBuffer id ) { return new CounterId ( id ) ; } public static CounterId wrap ( ByteBuffer bb , int offset ) { ByteBuffer dup = bb . duplicate ( ) ; dup . position ( offset ) ; dup . limit ( dup . position ( ) + LENGTH ) ; return wrap ( dup ) ; } private CounterId ( ByteBuffer id ) { if ( id . remaining ( ) ! = LENGTH ) throw new IllegalArgumentException ( <str> + LENGTH + <str> ) ; this . id = id ; } public static CounterId generate ( ) { return new CounterId ( ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( ) ) ) ; } public ByteBuffer bytes ( ) { return id ; } public boolean isLocalId ( ) { return equals ( getLocalId ( ) ) ; } public int compareTo ( CounterId o ) { return ByteBufferUtil . compareSubArrays ( id , id . position ( ) , o . id , o . id . position ( ) , CounterId . LENGTH ) ; } @Override public String toString ( ) { return UUIDGen . getUUID ( id ) . toString ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; CounterId otherId = ( CounterId ) o ; return id . equals ( otherId . id ) ; } @Override public int hashCode ( ) { return id . hashCode ( ) ; } private static class LocalCounterIdHolder { private final AtomicReference < CounterId > current ; LocalCounterIdHolder ( ) { current = new AtomicReference < > ( wrap ( ByteBufferUtil . bytes ( SystemKeyspace . getLocalHostId ( ) ) ) ) ; } CounterId get ( ) { return current . get ( ) ; } } } 
