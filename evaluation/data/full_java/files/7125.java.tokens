package org . elasticsearch . search . aggregations ; import org . apache . lucene . search . BooleanClause . Occur ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . search . SearchParseElement ; import org . elasticsearch . search . SearchPhase ; import org . elasticsearch . search . aggregations . bucket . global . GlobalAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . SiblingPipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . query . QueryPhaseExecutionException ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public class AggregationPhase implements SearchPhase { private final Map < String , SearchParseElement > parseElements ; @Inject public AggregationPhase ( AggregationParseElement parseElement , AggregationBinaryParseElement binaryParseElement ) { Map < String , SearchParseElement > parseElements = new HashMap < > ( ) ; parseElements . put ( <str> , parseElement ) ; parseElements . put ( <str> , parseElement ) ; parseElements . put ( <str> , binaryParseElement ) ; parseElements . put ( <str> , binaryParseElement ) ; parseElements . put ( <str> , binaryParseElement ) ; parseElements . put ( <str> , binaryParseElement ) ; this . parseElements = unmodifiableMap ( parseElements ) ; } @Override public Map < String , ? extends SearchParseElement > parseElements ( ) { return parseElements ; } @Override public void preProcess ( SearchContext context ) { if ( context . aggregations ( ) ! = null ) { AggregationContext aggregationContext = new AggregationContext ( context ) ; context . aggregations ( ) . aggregationContext ( aggregationContext ) ; List < Aggregator > collectors = new ArrayList < > ( ) ; Aggregator [ ] aggregators ; try { AggregatorFactories factories = context . aggregations ( ) . factories ( ) ; aggregators = factories . createTopLevelAggregators ( aggregationContext ) ; for ( int i = <int> ; i < aggregators . length ; i + + ) { if ( aggregators [ i ] instanceof GlobalAggregator = = false ) { collectors . add ( aggregators [ i ] ) ; } } context . aggregations ( ) . aggregators ( aggregators ) ; if ( ! collectors . isEmpty ( ) ) { final BucketCollector collector = BucketCollector . wrap ( collectors ) ; collector . preCollection ( ) ; context . queryCollectors ( ) . put ( AggregationPhase . class , collector ) ; } } catch ( IOException e ) { throw new AggregationInitializationException ( <str> , e ) ; } } } @Override public void execute ( SearchContext context ) { if ( context . aggregations ( ) = = null ) { context . queryResult ( ) . aggregations ( null ) ; return ; } if ( context . queryResult ( ) . aggregations ( ) ! = null ) { return ; } Aggregator [ ] aggregators = context . aggregations ( ) . aggregators ( ) ; List < Aggregator > globals = new ArrayList < > ( ) ; for ( int i = <int> ; i < aggregators . length ; i + + ) { if ( aggregators [ i ] instanceof GlobalAggregator ) { globals . add ( aggregators [ i ] ) ; } } if ( ! globals . isEmpty ( ) ) { BucketCollector globalsCollector = BucketCollector . wrap ( globals ) ; Query query = Queries . newMatchAllQuery ( ) ; Query searchFilter = context . searchFilter ( context . types ( ) ) ; if ( searchFilter ! = null ) { BooleanQuery filtered = new BooleanQuery . Builder ( ) . add ( query , Occur . MUST ) . add ( searchFilter , Occur . FILTER ) . build ( ) ; query = filtered ; } try { globalsCollector . preCollection ( ) ; context . searcher ( ) . search ( query , globalsCollector ) ; } catch ( Exception e ) { throw new QueryPhaseExecutionException ( context , <str> , e ) ; } finally { context . clearReleasables ( SearchContext . Lifetime . COLLECTION ) ; } } List < InternalAggregation > aggregations = new ArrayList < > ( aggregators . length ) ; for ( Aggregator aggregator : context . aggregations ( ) . aggregators ( ) ) { try { aggregator . postCollection ( ) ; aggregations . add ( aggregator . buildAggregation ( <int> ) ) ; } catch ( IOException e ) { throw new AggregationExecutionException ( <str> + aggregator . name ( ) + <str> , e ) ; } } context . queryResult ( ) . aggregations ( new InternalAggregations ( aggregations ) ) ; try { List < PipelineAggregator > pipelineAggregators = context . aggregations ( ) . factories ( ) . createPipelineAggregators ( ) ; List < SiblingPipelineAggregator > siblingPipelineAggregators = new ArrayList < > ( pipelineAggregators . size ( ) ) ; for ( PipelineAggregator pipelineAggregator : pipelineAggregators ) { if ( pipelineAggregator instanceof SiblingPipelineAggregator ) { siblingPipelineAggregators . add ( ( SiblingPipelineAggregator ) pipelineAggregator ) ; } else { throw new AggregationExecutionException ( <str> + pipelineAggregator . name ( ) + <str> + pipelineAggregator . type ( ) . name ( ) + <str> ) ; } } context . queryResult ( ) . pipelineAggregators ( siblingPipelineAggregators ) ; } catch ( IOException e ) { throw new AggregationExecutionException ( <str> , e ) ; } context . aggregations ( null ) ; context . queryCollectors ( ) . remove ( AggregationPhase . class ) ; } } 
