package org . gradle . nativeplatform . fixtures ; import com . google . common . base . Joiner ; import net . rubygrapefruit . platform . SystemInfo ; import net . rubygrapefruit . platform . WindowsRegistry ; import org . gradle . api . Nullable ; import org . gradle . api . internal . file . TestFiles ; import org . gradle . internal . nativeintegration . ProcessEnvironment ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . nativeplatform . platform . internal . DefaultNativePlatform ; import org . gradle . nativeplatform . toolchain . Clang ; import org . gradle . nativeplatform . toolchain . Gcc ; import org . gradle . nativeplatform . toolchain . VisualCpp ; import org . gradle . nativeplatform . toolchain . internal . gcc . version . GccVersionDeterminer ; import org . gradle . nativeplatform . toolchain . internal . gcc . version . GccVersionResult ; import org . gradle . nativeplatform . toolchain . internal . msvcpp . DefaultVisualStudioLocator ; import org . gradle . nativeplatform . toolchain . internal . msvcpp . VisualStudioInstall ; import org . gradle . nativeplatform . toolchain . internal . msvcpp . VisualStudioLocator ; import org . gradle . nativeplatform . toolchain . plugins . ClangCompilerPlugin ; import org . gradle . nativeplatform . toolchain . plugins . GccCompilerPlugin ; import org . gradle . nativeplatform . toolchain . plugins . MicrosoftVisualCppPlugin ; import org . gradle . process . internal . DefaultExecAction ; import org . gradle . process . internal . ExecAction ; import org . gradle . process . internal . ExecActionFactory ; import org . gradle . test . fixtures . file . TestFile ; import org . gradle . testfixtures . internal . NativeServicesTestFixture ; import org . gradle . util . VersionNumber ; import java . io . File ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class AvailableToolChains { private static List < ToolChainCandidate > toolChains ; @Nullable public static InstalledToolChain getDefaultToolChain ( ) { for ( ToolChainCandidate toolChain : getToolChains ( ) ) { if ( toolChain . isAvailable ( ) ) { return ( InstalledToolChain ) toolChain ; } } return null ; } @Nullable public static ToolChainCandidate getToolChain ( ToolChainRequirement requirement ) { for ( ToolChainCandidate toolChainCandidate : getToolChains ( ) ) { if ( toolChainCandidate . meets ( requirement ) ) { return toolChainCandidate ; } } return null ; } public static List < ToolChainCandidate > getToolChains ( ) { if ( toolChains = = null ) { List < ToolChainCandidate > compilers = new ArrayList < ToolChainCandidate > ( ) ; if ( OperatingSystem . current ( ) . isWindows ( ) ) { compilers . add ( findVisualCpp ( ) ) ; compilers . add ( findMinGW ( ) ) ; compilers . add ( findCygwin ( ) ) ; } else { compilers . add ( findGcc ( ) ) ; compilers . add ( findClang ( ) ) ; } toolChains = compilers ; } return toolChains ; } static private ToolChainCandidate findClang ( ) { File compilerExe = OperatingSystem . current ( ) . findInPath ( <str> ) ; if ( compilerExe ! = null ) { return new InstalledClang ( ) ; } return new UnavailableToolChain ( <str> ) ; } static private ToolChainCandidate findVisualCpp ( ) { VisualStudioLocator vsLocator = new DefaultVisualStudioLocator ( OperatingSystem . current ( ) , NativeServicesTestFixture . getInstance ( ) . get ( WindowsRegistry . class ) , NativeServicesTestFixture . getInstance ( ) . get ( SystemInfo . class ) ) ; VisualStudioLocator . SearchResult searchResult = vsLocator . locateVisualStudioInstalls ( null ) ; if ( searchResult . isAvailable ( ) ) { VisualStudioInstall install = searchResult . getVisualStudio ( ) ; return new InstalledVisualCpp ( ) . withInstall ( install ) ; } return new UnavailableToolChain ( <str> ) ; } static private ToolChainCandidate findMinGW ( ) { File compilerExe = new File ( <str> ) ; if ( compilerExe . isFile ( ) ) { return new InstalledWindowsGcc ( <str> ) . inPath ( compilerExe . getParentFile ( ) ) ; } return new UnavailableToolChain ( <str> ) ; } static private ToolChainCandidate findCygwin ( ) { File compilerExe = new File ( <str> ) ; if ( compilerExe . isFile ( ) ) { return new InstalledWindowsGcc ( <str> ) . inPath ( compilerExe . getParentFile ( ) ) ; } return new UnavailableToolChain ( <str> ) ; } static private ToolChainCandidate findGcc ( ) { GccVersionDeterminer versionDeterminer = GccVersionDeterminer . forGcc ( new ExecActionFactory ( ) { public ExecAction newExecAction ( ) { return new DefaultExecAction ( TestFiles . resolver ( ) ) ; } } ) ; List < File > gppCandidates = OperatingSystem . current ( ) . findAllInPath ( <str> ) ; for ( int i = <int> ; i < gppCandidates . size ( ) ; i + + ) { File candidate = gppCandidates . get ( i ) ; GccVersionResult version = versionDeterminer . getGccMetaData ( candidate , Collections . < String > emptyList ( ) ) ; if ( version . isAvailable ( ) ) { InstalledGcc gcc = new InstalledGcc ( <str> ) ; if ( i > <int> ) { gcc . inPath ( candidate . getParentFile ( ) ) ; } return gcc ; } } return new UnavailableToolChain ( <str> ) ; } public static abstract class ToolChainCandidate { @Override public String toString ( ) { return getDisplayName ( ) ; } public abstract String getDisplayName ( ) ; public abstract boolean isAvailable ( ) ; public abstract boolean meets ( ToolChainRequirement requirement ) ; public abstract void initialiseEnvironment ( ) ; public abstract void resetEnvironment ( ) ; } public abstract static class InstalledToolChain extends ToolChainCandidate { private static final ProcessEnvironment PROCESS_ENVIRONMENT = NativeServicesTestFixture . getInstance ( ) . get ( ProcessEnvironment . class ) ; protected final List < File > pathEntries = new ArrayList < File > ( ) ; private final String displayName ; protected final String pathVarName ; private final String objectFileNameSuffix ; private String originalPath ; public InstalledToolChain ( String displayName ) { this . displayName = displayName ; this . pathVarName = OperatingSystem . current ( ) . getPathVar ( ) ; this . objectFileNameSuffix = OperatingSystem . current ( ) . isWindows ( ) ? <str> : <str> ; } InstalledToolChain inPath ( File . . . pathEntries ) { Collections . addAll ( this . pathEntries , pathEntries ) ; return this ; } @Override public String getDisplayName ( ) { return displayName ; } @Override public boolean isAvailable ( ) { return true ; } public String getTypeDisplayName ( ) { return getDisplayName ( ) . replaceAll ( <str> , <str> ) ; } public abstract String getInstanceDisplayName ( ) ; public ExecutableFixture executable ( Object path ) { return new ExecutableFixture ( new TestFile ( OperatingSystem . current ( ) . getExecutableName ( path . toString ( ) ) ) , this ) ; } public TestFile objectFile ( Object path ) { return new TestFile ( path . toString ( ) + objectFileNameSuffix ) ; } public SharedLibraryFixture sharedLibrary ( Object path ) { return new SharedLibraryFixture ( new TestFile ( OperatingSystem . current ( ) . getSharedLibraryName ( path . toString ( ) ) ) , this ) ; } public StaticLibraryFixture staticLibrary ( Object path ) { return new StaticLibraryFixture ( new TestFile ( OperatingSystem . current ( ) . getStaticLibraryName ( path . toString ( ) ) ) , this ) ; } public NativeBinaryFixture resourceOnlyLibrary ( Object path ) { return new NativeBinaryFixture ( new TestFile ( OperatingSystem . current ( ) . getSharedLibraryName ( path . toString ( ) ) ) , this ) ; } public void initialiseEnvironment ( ) { String compilerPath = Joiner . on ( File . pathSeparator ) . join ( pathEntries ) ; if ( compilerPath . length ( ) > <int> ) { originalPath = System . getenv ( pathVarName ) ; String path = compilerPath + File . pathSeparator + originalPath ; System . out . println ( String . format ( <str> , path ) ) ; PROCESS_ENVIRONMENT . setEnvironmentVariable ( pathVarName , path ) ; } } public void resetEnvironment ( ) { if ( originalPath ! = null ) { PROCESS_ENVIRONMENT . setEnvironmentVariable ( pathVarName , originalPath ) ; } } public abstract String getBuildScriptConfig ( ) ; public abstract String getImplementationClass ( ) ; public abstract String getPluginClass ( ) ; public boolean isVisualCpp ( ) { return false ; } public List < File > getPathEntries ( ) { return pathEntries ; } public List < String > getRuntimeEnv ( ) { return Collections . emptyList ( ) ; } public String getId ( ) { return displayName . replaceAll ( <str> , <str> ) ; } } public static abstract class GccCompatibleToolChain extends InstalledToolChain { protected GccCompatibleToolChain ( String displayName ) { super ( displayName ) ; } protected String find ( String tool ) { if ( getPathEntries ( ) . isEmpty ( ) ) { return tool ; } return new File ( getPathEntries ( ) . get ( <int> ) , tool ) . getAbsolutePath ( ) ; } public String getLinker ( ) { return getCCompiler ( ) ; } public String getStaticLibArchiver ( ) { return find ( <str> ) ; } public abstract String getCCompiler ( ) ; } public static class InstalledGcc extends GccCompatibleToolChain { public InstalledGcc ( String name ) { super ( name ) ; } @Override public boolean meets ( ToolChainRequirement requirement ) { return requirement = = ToolChainRequirement . Gcc | | requirement = = ToolChainRequirement . GccCompatible | | requirement = = ToolChainRequirement . Available ; } @Override public String getBuildScriptConfig ( ) { String config = String . format ( <str> , getId ( ) , getImplementationClass ( ) ) ; for ( File pathEntry : getPathEntries ( ) ) { config + = String . format ( <str> , getId ( ) , pathEntry . toURI ( ) ) ; } return config ; } @Override public String getCCompiler ( ) { return find ( <str> ) ; } public String getInstanceDisplayName ( ) { return String . format ( <str> , getId ( ) ) ; } public String getImplementationClass ( ) { return Gcc . class . getSimpleName ( ) ; } @Override public String getPluginClass ( ) { return GccCompilerPlugin . class . getSimpleName ( ) ; } } public static class InstalledWindowsGcc extends InstalledGcc { public InstalledWindowsGcc ( String name ) { super ( name ) ; } public List < String > getRuntimeEnv ( ) { if ( pathEntries . isEmpty ( ) ) { return Collections . emptyList ( ) ; } String path = Joiner . on ( File . pathSeparator ) . join ( pathEntries ) + File . pathSeparator + System . getenv ( pathVarName ) ; return Collections . singletonList ( pathVarName + <str> + path ) ; } } public static class InstalledVisualCpp extends InstalledToolChain { private VersionNumber version ; private File installDir ; public InstalledVisualCpp ( ) { super ( <str> ) ; } @Override public String getId ( ) { return <str> ; } public InstalledVisualCpp withInstall ( VisualStudioInstall install ) { DefaultNativePlatform targetPlatform = new DefaultNativePlatform ( <str> ) ; installDir = install . getVisualStudioDir ( ) ; version = install . getVersion ( ) ; pathEntries . addAll ( install . getVisualCpp ( ) . getPath ( targetPlatform ) ) ; return this ; } @Override public boolean meets ( ToolChainRequirement requirement ) { switch ( requirement ) { case Available : case VisualCpp : return true ; case VisualCpp2013 : return version . compareTo ( VersionNumber . parse ( <str> ) ) > = <int> ; default : return false ; } } @Override public String getBuildScriptConfig ( ) { String config = String . format ( <str> , getId ( ) , getImplementationClass ( ) ) ; if ( installDir ! = null ) { config + = String . format ( <str> , getId ( ) , installDir . toURI ( ) ) ; } return config ; } public String getImplementationClass ( ) { return VisualCpp . class . getSimpleName ( ) ; } public String getInstanceDisplayName ( ) { return String . format ( <str> , getId ( ) ) ; } @Override public String getPluginClass ( ) { return MicrosoftVisualCppPlugin . class . getSimpleName ( ) ; } public boolean isVisualCpp ( ) { return true ; } public VersionNumber getVersion ( ) { return version ; } @Override public TestFile objectFile ( Object path ) { return new TestFile ( path . toString ( ) + <str> ) ; } } public static class InstalledClang extends GccCompatibleToolChain { public InstalledClang ( ) { super ( <str> ) ; } @Override public boolean meets ( ToolChainRequirement requirement ) { return requirement = = ToolChainRequirement . Clang | | requirement = = ToolChainRequirement . GccCompatible | | requirement = = ToolChainRequirement . Available ; } @Override public String getBuildScriptConfig ( ) { return <str> ; } @Override public String getCCompiler ( ) { return find ( <str> ) ; } public String getInstanceDisplayName ( ) { return String . format ( <str> , getId ( ) ) ; } @Override public String getImplementationClass ( ) { return Clang . class . getSimpleName ( ) ; } @Override public String getPluginClass ( ) { return ClangCompilerPlugin . class . getSimpleName ( ) ; } } public static class UnavailableToolChain extends ToolChainCandidate { private final String name ; public UnavailableToolChain ( String name ) { this . name = name ; } @Override public boolean meets ( ToolChainRequirement requirement ) { return false ; } @Override public String getDisplayName ( ) { return name ; } @Override public boolean isAvailable ( ) { return false ; } @Override public void initialiseEnvironment ( ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public void resetEnvironment ( ) { throw new UnsupportedOperationException ( <str> ) ; } } } 
