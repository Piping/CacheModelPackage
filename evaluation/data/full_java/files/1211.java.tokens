package org . apache . cassandra . utils ; import java . util . Arrays ; import java . util . HashMap ; import java . util . TreeSet ; import java . util . concurrent . ThreadLocalRandom ; public class DynamicList < E > { public static class Node < E > { private final int [ ] size ; private final Node < E > [ ] links ; private E value ; private Node ( int height , E value ) { this . value = value ; links = new Node [ height * <int> ] ; size = new int [ height ] ; Arrays . fill ( size , <int> ) ; } private int height ( ) { return size . length ; } private Node < E > next ( int i ) { return links [ i * <int> ] ; } private Node < E > prev ( int i ) { return links [ <int> + i * <int> ] ; } private void setNext ( int i , Node < E > next ) { links [ i * <int> ] = next ; } private void setPrev ( int i , Node < E > prev ) { links [ <int> + i * <int> ] = prev ; } private Node parent ( int parentHeight ) { Node prev = this ; while ( true ) { int height = prev . height ( ) ; if ( parentHeight < height ) return prev ; prev = prev . prev ( height - <int> ) ; } } } private final int maxHeight ; private final Node < E > head ; private int size ; public DynamicList ( int maxExpectedSize ) { this . maxHeight = <int> + Math . max ( <int> , ( int ) Math . ceil ( Math . log ( maxExpectedSize ) / Math . log ( <int> ) ) ) ; head = new Node < > ( maxHeight , null ) ; } private int randomLevel ( ) { return <int> + Integer . bitCount ( ThreadLocalRandom . current ( ) . nextInt ( ) & ( ( <int> < < ( maxHeight - <int> ) ) - <int> ) ) ; } public Node < E > append ( E value ) { return append ( value , Integer . MAX_VALUE ) ; } public Node < E > append ( E value , int maxSize ) { Node < E > newTail = new Node < > ( randomLevel ( ) , value ) ; if ( size > = maxSize ) return null ; size + + ; Node < E > tail = head ; for ( int i = maxHeight - <int> ; i > = newTail . height ( ) ; i - - ) { Node < E > next ; while ( ( next = tail . next ( i ) ) ! = null ) tail = next ; tail . size [ i ] + + ; } for ( int i = newTail . height ( ) - <int> ; i > = <int> ; i - - ) { Node < E > next ; while ( ( next = tail . next ( i ) ) ! = null ) tail = next ; tail . setNext ( i , newTail ) ; newTail . setPrev ( i , tail ) ; } return newTail ; } public void remove ( Node < E > node ) { assert node . value ! = null ; node . value = null ; size - - ; for ( int i = <int> ; i < node . height ( ) ; i + + ) { Node < E > prev = node . prev ( i ) ; Node < E > next = node . next ( i ) ; assert prev ! = null ; prev . setNext ( i , next ) ; if ( next ! = null ) next . setPrev ( i , prev ) ; prev . size [ i ] + = node . size [ i ] - <int> ; } for ( int i = node . height ( ) ; i < maxHeight ; i + + ) { while ( i = = node . height ( ) ) node = node . prev ( i - <int> ) ; node . size [ i ] - - ; } } public E get ( int index ) { if ( index > = size ) return null ; index + + ; int c = <int> ; Node < E > finger = head ; for ( int i = maxHeight - <int> ; i > = <int> ; i - - ) { while ( c + finger . size [ i ] < = index ) { c + = finger . size [ i ] ; finger = finger . next ( i ) ; } } assert c = = index ; return finger . value ; } public int size ( ) { return size ; } private boolean isWellFormed ( ) { for ( int i = <int> ; i < maxHeight ; i + + ) { int c = <int> ; for ( Node node = head ; node ! = null ; node = node . next ( i ) ) { if ( node . prev ( i ) ! = null & & node . prev ( i ) . next ( i ) ! = node ) return false ; if ( node . next ( i ) ! = null & & node . next ( i ) . prev ( i ) ! = node ) return false ; c + = node . size [ i ] ; if ( i + <int> < maxHeight & & node . parent ( i + <int> ) . next ( i + <int> ) = = node . next ( i ) ) { if ( node . parent ( i + <int> ) . size [ i + <int> ] ! = c ) return false ; c = <int> ; } } if ( i = = maxHeight - <int> & & c ! = size + <int> ) return false ; } return true ; } public static void main ( String [ ] args ) { DynamicList < Integer > list = new DynamicList < > ( <int> ) ; TreeSet < Integer > canon = new TreeSet < > ( ) ; HashMap < Integer , Node > nodes = new HashMap < > ( ) ; int c = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { nodes . put ( c , list . append ( c ) ) ; canon . add ( c ) ; c + + ; } ThreadLocalRandom rand = ThreadLocalRandom . current ( ) ; assert list . isWellFormed ( ) ; for ( int loop = <int> ; loop < <int> ; loop + + ) { System . out . println ( loop ) ; for ( int i = <int> ; i < <int> ; i + + ) { int index = rand . nextInt ( <int> ) ; Integer seed = list . get ( index ) ; list . remove ( nodes . remove ( seed ) ) ; canon . remove ( seed ) ; nodes . put ( c , list . append ( c ) ) ; canon . add ( c ) ; c + + ; } assert list . isWellFormed ( ) ; } } } 
