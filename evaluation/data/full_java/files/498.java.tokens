package org . apache . cassandra . db . rows ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import java . util . * ; import java . util . function . BiFunction ; import com . google . common . base . Function ; import com . google . common . collect . Iterables ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . DeletionTime ; import org . apache . cassandra . db . DeletionPurger ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . marshal . ByteType ; import org . apache . cassandra . db . marshal . SetType ; import org . apache . cassandra . utils . ObjectSizes ; import org . apache . cassandra . utils . btree . BTree ; import org . apache . cassandra . utils . btree . UpdateFunction ; public class ComplexColumnData extends ColumnData implements Iterable < Cell > { static final Cell [ ] NO_CELLS = new Cell [ <int> ] ; private static final long EMPTY_SIZE = ObjectSizes . measure ( new ComplexColumnData ( ColumnDefinition . regularDef ( <str> , <str> , <str> , SetType . getInstance ( ByteType . instance , true ) ) , NO_CELLS , new DeletionTime ( <int> , <int> ) ) ) ; private final Object [ ] cells ; private final DeletionTime complexDeletion ; ComplexColumnData ( ColumnDefinition column , Object [ ] cells , DeletionTime complexDeletion ) { super ( column ) ; assert column . isComplex ( ) ; assert cells . length > <int> | | ! complexDeletion . isLive ( ) ; this . cells = cells ; this . complexDeletion = complexDeletion ; } public boolean hasCells ( ) { return ! BTree . isEmpty ( cells ) ; } public int cellsCount ( ) { return BTree . size ( cells ) ; } public Cell getCell ( CellPath path ) { return ( Cell ) BTree . < Object > find ( cells , column . asymmetricCellPathComparator ( ) , path ) ; } public Cell getCellByIndex ( int idx ) { return BTree . findByIndex ( cells , idx ) ; } public DeletionTime complexDeletion ( ) { return complexDeletion ; } public Iterator < Cell > iterator ( ) { return BTree . iterator ( cells ) ; } public Iterator < Cell > reverseIterator ( ) { return BTree . iterator ( cells , BTree . Dir . DESC ) ; } public int dataSize ( ) { int size = complexDeletion . dataSize ( ) ; for ( Cell cell : this ) size + = cell . dataSize ( ) ; return size ; } public long unsharedHeapSizeExcludingData ( ) { long heapSize = EMPTY_SIZE + ObjectSizes . sizeOfArray ( cells ) ; for ( Cell cell : this ) heapSize + = cell . unsharedHeapSizeExcludingData ( ) ; return heapSize ; } public void validate ( ) { for ( Cell cell : this ) cell . validate ( ) ; } public void digest ( MessageDigest digest ) { if ( ! complexDeletion . isLive ( ) ) complexDeletion . digest ( digest ) ; for ( Cell cell : this ) cell . digest ( digest ) ; } public ComplexColumnData markCounterLocalToBeCleared ( ) { return transformAndFilter ( complexDeletion , Cell : : markCounterLocalToBeCleared ) ; } public ComplexColumnData filter ( ColumnFilter filter , DeletionTime activeDeletion , CFMetaData . DroppedColumn dropped ) { ColumnFilter . Tester cellTester = filter . newTester ( column ) ; if ( cellTester = = null & & activeDeletion . isLive ( ) & & dropped = = null ) return this ; DeletionTime newDeletion = activeDeletion . supersedes ( complexDeletion ) ? DeletionTime . LIVE : complexDeletion ; return transformAndFilter ( newDeletion , ( cell ) - > ( cellTester = = null | | cellTester . includes ( cell . path ( ) ) ) & & ! activeDeletion . deletes ( cell ) & & ( dropped = = null | | cell . timestamp ( ) > dropped . droppedTime ) ? cell : null ) ; } public ComplexColumnData purge ( DeletionPurger purger , int nowInSec ) { DeletionTime newDeletion = complexDeletion . isLive ( ) | | purger . shouldPurge ( complexDeletion ) ? DeletionTime . LIVE : complexDeletion ; return transformAndFilter ( newDeletion , ( cell ) - > cell . purge ( purger , nowInSec ) ) ; } private ComplexColumnData transformAndFilter ( DeletionTime newDeletion , Function < ? super Cell , ? extends Cell > function ) { Object [ ] transformed = BTree . transformAndFilter ( cells , function ) ; if ( cells = = transformed & & newDeletion = = complexDeletion ) return this ; if ( newDeletion = = DeletionTime . LIVE & & BTree . isEmpty ( transformed ) ) return null ; return new ComplexColumnData ( column , transformed , newDeletion ) ; } public ComplexColumnData updateAllTimestamp ( long newTimestamp ) { DeletionTime newDeletion = complexDeletion . isLive ( ) ? complexDeletion : new DeletionTime ( newTimestamp - <int> , complexDeletion . localDeletionTime ( ) ) ; return transformAndFilter ( newDeletion , ( cell ) - > ( Cell ) cell . updateAllTimestamp ( newTimestamp ) ) ; } void setValue ( CellPath path , ByteBuffer value ) { Cell current = ( Cell ) BTree . < Object > find ( cells , column . asymmetricCellPathComparator ( ) , path ) ; BTree . replaceInSitu ( cells , column . cellComparator ( ) , current , current . withUpdatedValue ( value ) ) ; } @Override public boolean equals ( Object other ) { if ( this = = other ) return true ; if ( ! ( other instanceof ComplexColumnData ) ) return false ; ComplexColumnData that = ( ComplexColumnData ) other ; return this . column ( ) . equals ( that . column ( ) ) & & this . complexDeletion ( ) . equals ( that . complexDeletion ) & & BTree . equals ( this . cells , that . cells ) ; } @Override public int hashCode ( ) { return Objects . hash ( column ( ) , complexDeletion ( ) , cells ) ; } public static Builder builder ( ) { return new Builder ( ) ; } public static class Builder { private static BiFunction < Cell , Cell , Cell > noResolve = ( a , b ) - > { throw new IllegalStateException ( ) ; } ; private DeletionTime complexDeletion ; private ColumnDefinition column ; private BTree . Builder < Cell > builder ; public void newColumn ( ColumnDefinition column ) { this . column = column ; this . complexDeletion = DeletionTime . LIVE ; if ( builder = = null ) builder = BTree . builder ( column . cellComparator ( ) ) ; else builder . reuse ( column . cellComparator ( ) ) ; } public void addComplexDeletion ( DeletionTime complexDeletion ) { this . complexDeletion = complexDeletion ; } public void addCell ( Cell cell ) { assert cell . column ( ) . equals ( column ) ; builder . add ( cell ) ; } public ComplexColumnData build ( ) { if ( complexDeletion . isLive ( ) & & builder . isEmpty ( ) ) return null ; return new ComplexColumnData ( column , builder . build ( ) , complexDeletion ) ; } } } 
