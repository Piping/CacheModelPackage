package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Environment ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . ModelBatch ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . environment . DirectionalLight ; import com . badlogic . gdx . graphics . g3d . utils . ModelBuilder ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . physics . bullet . collision . btBoxShape ; import com . badlogic . gdx . physics . bullet . collision . btBroadphaseInterface ; import com . badlogic . gdx . physics . bullet . collision . btCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . collision . btCollisionDispatcher ; import com . badlogic . gdx . physics . bullet . collision . btCollisionShape ; import com . badlogic . gdx . physics . bullet . collision . btDbvtBroadphase ; import com . badlogic . gdx . physics . bullet . collision . btDefaultCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . collision . btSphereShape ; import com . badlogic . gdx . physics . bullet . dynamics . btConstraintSolver ; import com . badlogic . gdx . physics . bullet . dynamics . btDiscreteDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btRigidBody ; import com . badlogic . gdx . physics . bullet . dynamics . btRigidBody . btRigidBodyConstructionInfo ; import com . badlogic . gdx . physics . bullet . dynamics . btSequentialImpulseConstraintSolver ; import com . badlogic . gdx . physics . bullet . linearmath . btDefaultMotionState ; import com . badlogic . gdx . utils . Array ; public class BasicBulletTest extends BulletTest { ModelBatch modelBatch ; Environment lights ; ModelBuilder modelBuilder = new ModelBuilder ( ) ; btCollisionConfiguration collisionConfiguration ; btCollisionDispatcher dispatcher ; btBroadphaseInterface broadphase ; btConstraintSolver solver ; btDynamicsWorld collisionWorld ; Vector3 gravity = new Vector3 ( <int> , - <float> , <int> ) ; Vector3 tempVector = new Vector3 ( ) ; Array < Model > models = new Array < Model > ( ) ; Array < ModelInstance > instances = new Array < ModelInstance > ( ) ; Array < btDefaultMotionState > motionStates = new Array < btDefaultMotionState > ( ) ; Array < btRigidBodyConstructionInfo > bodyInfos = new Array < btRigidBodyConstructionInfo > ( ) ; Array < btCollisionShape > shapes = new Array < btCollisionShape > ( ) ; Array < btRigidBody > bodies = new Array < btRigidBody > ( ) ; @Override public void create ( ) { super . create ( ) ; instructions = <str> ; lights = new Environment ( ) ; lights . set ( new ColorAttribute ( ColorAttribute . AmbientLight , <float> , <float> , <float> , <float> ) ) ; lights . add ( new DirectionalLight ( ) . set ( <float> , <float> , <float> , - <float> , - <float> , - <float> ) ) ; final float width = Gdx . graphics . getWidth ( ) ; final float height = Gdx . graphics . getHeight ( ) ; if ( width > height ) camera = new PerspectiveCamera ( <int> f , <float> * width / height , <float> ) ; else camera = new PerspectiveCamera ( <int> f , <float> , <float> * height / width ) ; camera . position . set ( <int> f , <int> f , <int> f ) ; camera . lookAt ( <int> , <int> , <int> ) ; camera . update ( ) ; modelBatch = new ModelBatch ( ) ; final Model groundModel = modelBuilder . createRect ( <int> f , <float> , - <int> f , - <int> f , <float> , - <int> f , - <int> f , <float> , <int> f , <int> f , <float> , <int> f , <int> , <int> , <int> , new Material ( ColorAttribute . createDiffuse ( Color . BLUE ) , ColorAttribute . createSpecular ( Color . WHITE ) , FloatAttribute . createShininess ( <int> f ) ) , Usage . Position | Usage . Normal ) ; models . add ( groundModel ) ; final Model sphereModel = modelBuilder . createSphere ( <float> , <float> , <float> , <int> , <int> , new Material ( ColorAttribute . createDiffuse ( Color . RED ) , ColorAttribute . createSpecular ( Color . WHITE ) , FloatAttribute . createShininess ( <int> f ) ) , Usage . Position | Usage . Normal ) ; models . add ( sphereModel ) ; BaseBulletTest . init ( ) ; collisionConfiguration = new btDefaultCollisionConfiguration ( ) ; dispatcher = new btCollisionDispatcher ( collisionConfiguration ) ; broadphase = new btDbvtBroadphase ( ) ; solver = new btSequentialImpulseConstraintSolver ( ) ; collisionWorld = new btDiscreteDynamicsWorld ( dispatcher , broadphase , solver , collisionConfiguration ) ; collisionWorld . setGravity ( gravity ) ; btCollisionShape groundShape = new btBoxShape ( tempVector . set ( <int> , <int> , <int> ) ) ; shapes . add ( groundShape ) ; btRigidBodyConstructionInfo groundInfo = new btRigidBodyConstructionInfo ( <float> , null , groundShape , Vector3 . Zero ) ; bodyInfos . add ( groundInfo ) ; btCollisionShape sphereShape = new btSphereShape ( <float> ) ; shapes . add ( sphereShape ) ; sphereShape . calculateLocalInertia ( <float> , tempVector ) ; btRigidBodyConstructionInfo sphereInfo = new btRigidBodyConstructionInfo ( <float> , null , sphereShape , tempVector ) ; bodyInfos . add ( sphereInfo ) ; ModelInstance ground = new ModelInstance ( groundModel ) ; instances . add ( ground ) ; btDefaultMotionState groundMotionState = new btDefaultMotionState ( ) ; groundMotionState . setWorldTransform ( ground . transform ) ; motionStates . add ( groundMotionState ) ; btRigidBody groundBody = new btRigidBody ( groundInfo ) ; groundBody . setMotionState ( groundMotionState ) ; bodies . add ( groundBody ) ; collisionWorld . addRigidBody ( groundBody ) ; for ( float x = - <int> f ; x < = <int> f ; x + = <float> ) { for ( float y = <float> ; y < = <int> f ; y + = <float> ) { for ( float z = <float> ; z < = <float> ; z + = <float> ) { ModelInstance sphere = new ModelInstance ( sphereModel ) ; instances . add ( sphere ) ; sphere . transform . trn ( x + <float> * MathUtils . random ( ) , y + <float> * MathUtils . random ( ) , z + <float> * MathUtils . random ( ) ) ; btDefaultMotionState sphereMotionState = new btDefaultMotionState ( ) ; sphereMotionState . setWorldTransform ( sphere . transform ) ; motionStates . add ( sphereMotionState ) ; btRigidBody sphereBody = new btRigidBody ( sphereInfo ) ; sphereBody . setMotionState ( sphereMotionState ) ; bodies . add ( sphereBody ) ; collisionWorld . addRigidBody ( sphereBody ) ; } } } } @Override public void render ( ) { Gdx . gl . glViewport ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT | GL20 . GL_DEPTH_BUFFER_BIT ) ; fpsCounter . put ( Gdx . graphics . getFramesPerSecond ( ) ) ; performanceCounter . tick ( ) ; performanceCounter . start ( ) ; ( ( btDynamicsWorld ) collisionWorld ) . stepSimulation ( Gdx . graphics . getDeltaTime ( ) , <int> ) ; performanceCounter . stop ( ) ; int c = motionStates . size ; for ( int i = <int> ; i < c ; i + + ) { motionStates . get ( i ) . getWorldTransform ( instances . get ( i ) . transform ) ; } modelBatch . begin ( camera ) ; modelBatch . render ( instances , lights ) ; modelBatch . end ( ) ; performance . setLength ( <int> ) ; performance . append ( <str> ) . append ( fpsCounter . value ) . append ( <str> ) . append ( ( int ) ( performanceCounter . load . value * <int> f ) ) . append ( <str> ) ; } @Override public void dispose ( ) { collisionWorld . dispose ( ) ; solver . dispose ( ) ; broadphase . dispose ( ) ; dispatcher . dispose ( ) ; collisionConfiguration . dispose ( ) ; for ( btRigidBody body : bodies ) body . dispose ( ) ; bodies . clear ( ) ; for ( btDefaultMotionState motionState : motionStates ) motionState . dispose ( ) ; motionStates . clear ( ) ; for ( btCollisionShape shape : shapes ) shape . dispose ( ) ; shapes . clear ( ) ; for ( btRigidBodyConstructionInfo info : bodyInfos ) info . dispose ( ) ; bodyInfos . clear ( ) ; modelBatch . dispose ( ) ; instances . clear ( ) ; for ( Model model : models ) model . dispose ( ) ; models . clear ( ) ; } } 
