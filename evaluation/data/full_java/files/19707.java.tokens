package io . netty . util . internal ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . Queue ; final class MpscLinkedQueue < E > extends MpscLinkedQueueTailRef < E > implements Queue < E > { private static final long serialVersionUID = - <int> ; long p00 , p01 , p02 , p03 , p04 , p05 , p06 , p07 ; long p30 , p31 , p32 , p33 , p34 , p35 , p36 , p37 ; MpscLinkedQueue ( ) { MpscLinkedQueueNode < E > tombstone = new DefaultNode < E > ( null ) ; setHeadRef ( tombstone ) ; setTailRef ( tombstone ) ; } private MpscLinkedQueueNode < E > peekNode ( ) { MpscLinkedQueueNode < E > head = headRef ( ) ; MpscLinkedQueueNode < E > next = head . next ( ) ; if ( next = = null & & head ! = tailRef ( ) ) { do { next = head . next ( ) ; } while ( next = = null ) ; } return next ; } @Override @SuppressWarnings ( <str> ) public boolean offer ( E value ) { if ( value = = null ) { throw new NullPointerException ( <str> ) ; } final MpscLinkedQueueNode < E > newTail ; if ( value instanceof MpscLinkedQueueNode ) { newTail = ( MpscLinkedQueueNode < E > ) value ; newTail . setNext ( null ) ; } else { newTail = new DefaultNode < E > ( value ) ; } MpscLinkedQueueNode < E > oldTail = getAndSetTailRef ( newTail ) ; oldTail . setNext ( newTail ) ; return true ; } @Override public E poll ( ) { final MpscLinkedQueueNode < E > next = peekNode ( ) ; if ( next = = null ) { return null ; } MpscLinkedQueueNode < E > oldHead = headRef ( ) ; lazySetHeadRef ( next ) ; oldHead . unlink ( ) ; return next . clearMaybe ( ) ; } @Override public E peek ( ) { final MpscLinkedQueueNode < E > next = peekNode ( ) ; if ( next = = null ) { return null ; } return next . value ( ) ; } @Override public int size ( ) { int count = <int> ; MpscLinkedQueueNode < E > n = peekNode ( ) ; for ( ; ; ) { if ( n = = null | | n . value ( ) = = null ) { break ; } MpscLinkedQueueNode < E > next = n . next ( ) ; if ( n = = next ) { break ; } n = next ; if ( + + count = = Integer . MAX_VALUE ) { break ; } } return count ; } @Override public boolean isEmpty ( ) { return headRef ( ) = = tailRef ( ) ; } @Override public boolean contains ( Object o ) { MpscLinkedQueueNode < E > n = peekNode ( ) ; for ( ; ; ) { if ( n = = null ) { break ; } E value = n . value ( ) ; if ( value = = null ) { return false ; } if ( value = = o ) { return true ; } MpscLinkedQueueNode < E > next = n . next ( ) ; if ( n = = next ) { break ; } n = next ; } return false ; } @Override public Iterator < E > iterator ( ) { return new ReadOnlyIterator < E > ( toList ( ) . iterator ( ) ) ; } @Override public boolean add ( E e ) { if ( offer ( e ) ) { return true ; } throw new IllegalStateException ( <str> ) ; } @Override public E remove ( ) { E e = poll ( ) ; if ( e ! = null ) { return e ; } throw new NoSuchElementException ( ) ; } @Override public E element ( ) { E e = peek ( ) ; if ( e ! = null ) { return e ; } throw new NoSuchElementException ( ) ; } private List < E > toList ( int initialCapacity ) { return toList ( new ArrayList < E > ( initialCapacity ) ) ; } private List < E > toList ( ) { return toList ( new ArrayList < E > ( ) ) ; } private List < E > toList ( List < E > elements ) { MpscLinkedQueueNode < E > n = peekNode ( ) ; for ( ; ; ) { if ( n = = null ) { break ; } E value = n . value ( ) ; if ( value = = null ) { break ; } if ( ! elements . add ( value ) ) { break ; } MpscLinkedQueueNode < E > next = n . next ( ) ; if ( n = = next ) { break ; } n = next ; } return elements ; } @Override public Object [ ] toArray ( ) { return toList ( ) . toArray ( ) ; } @Override @SuppressWarnings ( <str> ) public < T > T [ ] toArray ( T [ ] a ) { return toList ( a . length ) . toArray ( a ) ; } @Override public boolean remove ( Object o ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean containsAll ( Collection < ? > c ) { for ( Object e : c ) { if ( ! contains ( e ) ) { return false ; } } return true ; } @Override public boolean addAll ( Collection < ? extends E > c ) { if ( c = = null ) { throw new NullPointerException ( <str> ) ; } if ( c = = this ) { throw new IllegalArgumentException ( <str> ) ; } boolean modified = false ; for ( E e : c ) { add ( e ) ; modified = true ; } return modified ; } @Override public boolean removeAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean retainAll ( Collection < ? > c ) { throw new UnsupportedOperationException ( ) ; } @Override public void clear ( ) { while ( poll ( ) ! = null ) { continue ; } } private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; for ( E e : this ) { out . writeObject ( e ) ; } out . writeObject ( null ) ; } private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; final MpscLinkedQueueNode < E > tombstone = new DefaultNode < E > ( null ) ; setHeadRef ( tombstone ) ; setTailRef ( tombstone ) ; for ( ; ; ) { @SuppressWarnings ( <str> ) E e = ( E ) in . readObject ( ) ; if ( e = = null ) { break ; } add ( e ) ; } } private static final class DefaultNode < T > extends MpscLinkedQueueNode < T > { private T value ; DefaultNode ( T value ) { this . value = value ; } @Override public T value ( ) { return value ; } @Override protected T clearMaybe ( ) { T value = this . value ; this . value = null ; return value ; } } } 
