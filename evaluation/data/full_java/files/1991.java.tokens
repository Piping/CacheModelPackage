package org . nd4j . linalg . api . ndarray ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . indexing . Indices ; import org . nd4j . linalg . api . shape . Shape ; import java . util . ArrayList ; import java . util . List ; @Deprecated public class LinearViewNDArray extends BaseNDArray { private INDArray wrapped ; private List < INDArray > vectors ; public LinearViewNDArray ( INDArray wrapped ) { if ( wrapped . getLeadingOnes ( ) > <int> | | wrapped . getTrailingOnes ( ) > <int> ) { wrapped = Nd4j . create ( wrapped . data ( ) , Shape . squeeze ( wrapped . shape ( ) ) ) ; } this . wrapped = wrapped ; this . shape = new int [ ] { <int> , wrapped . length ( ) } ; this . data = wrapped . data ( ) ; this . offset = wrapped . offset ( ) ; this . ordering = wrapped . ordering ( ) ; this . length = wrapped . length ( ) ; vectors = new ArrayList < > ( ) ; collectRows ( wrapped ) ; } protected void collectRows ( INDArray slice ) { if ( slice . isRowVector ( ) ) { vectors . add ( slice ) ; } else if ( isMatrix ( ) ) { for ( int i = <int> ; i < slice . rows ( ) ; i + + ) vectors . add ( slice . getRow ( i ) ) ; } else if ( ! slice . isVector ( ) & & slice . size ( <int> ) = = <int> ) { slice = Nd4j . create ( slice . data ( ) , Shape . squeeze ( slice . shape ( ) ) ) ; if ( Shape . isVector ( slice . shape ( ) ) ) { vectors . add ( slice ) ; } else { for ( int i = <int> ; i < slice . slices ( ) ; i + + ) collectRows ( slice . slice ( i ) ) ; } } else for ( int i = <int> ; i < slice . slices ( ) ; i + + ) collectRows ( slice . slice ( i ) ) ; } @Override public boolean isCleanedUp ( ) { return wrapped . isCleanedUp ( ) ; } @Override public void cleanup ( ) { wrapped . cleanup ( ) ; } @Override public void resetLinearView ( ) { } @Override public int secondaryStride ( ) { return wrapped . secondaryStride ( ) ; } @Override public int majorStride ( ) { return wrapped . majorStride ( ) ; } @Override public INDArray linearView ( ) { return this ; } @Override public INDArray linearViewColumnOrder ( ) { return this ; } @Override public int vectorsAlongDimension ( int dimension ) { if ( dimension > <int> ) throw new IllegalArgumentException ( <str> ) ; return <int> ; } @Override public INDArray vectorAlongDimension ( int index , int dimension ) { if ( dimension = = <int> | | dimension = = <int> & & index = = <int> ) return this ; throw new IllegalArgumentException ( <str> ) ; } @Override public INDArray putScalar ( int i , double value ) { int vectorSize = wrapped . size ( - <int> ) ; int vectorIdx = Indices . rowNumber ( i , wrapped ) ; INDArray currVector = vectors . get ( vectorIdx ) ; int offset = vectorSize * vectorIdx ; int idx = i - offset ; currVector . putScalar ( idx , value ) ; return this ; } @Override public DataBuffer data ( ) { throw new UnsupportedOperationException ( ) ; } @Override public int length ( ) { return wrapped . length ( ) ; } @Override public double getDouble ( int i ) { if ( wrapped . isVector ( ) ) return wrapped . getDouble ( i ) ; int vectorSize = wrapped . size ( - <int> ) ; int vectorIdx = Indices . rowNumber ( i , wrapped ) ; INDArray currVector = vectors . get ( vectorIdx ) ; int offset = vectorSize * vectorIdx ; int idx = i - offset ; return currVector . getDouble ( idx ) ; } @Override public int hashCode ( ) { return wrapped . hashCode ( ) ; } @Override public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( <str> ) ; for ( int i = <int> ; i < wrapped . length ( ) ; i + + ) { sb . append ( getDouble ( i ) ) ; if ( i < wrapped . length ( ) - <int> ) { sb . append ( <str> ) ; } } sb . append ( <str> ) ; return sb . toString ( ) ; } } 
