package com . badlogic . gdx . utils ; import java . util . Comparator ; public class QuickSelect < T > { private T [ ] array ; private Comparator < ? super T > comp ; public int select ( T [ ] items , Comparator < T > comp , int n , int size ) { this . array = items ; this . comp = comp ; return recursiveSelect ( <int> , size - <int> , n ) ; } private int partition ( int left , int right , int pivot ) { T pivotValue = array [ pivot ] ; swap ( right , pivot ) ; int storage = left ; for ( int i = left ; i < right ; i + + ) { if ( comp . compare ( array [ i ] , pivotValue ) < <int> ) { swap ( storage , i ) ; storage + + ; } } swap ( right , storage ) ; return storage ; } private int recursiveSelect ( int left , int right , int k ) { if ( left = = right ) return left ; int pivotIndex = medianOfThreePivot ( left , right ) ; int pivotNewIndex = partition ( left , right , pivotIndex ) ; int pivotDist = ( pivotNewIndex - left ) + <int> ; int result ; if ( pivotDist = = k ) { result = pivotNewIndex ; } else if ( k < pivotDist ) { result = recursiveSelect ( left , pivotNewIndex - <int> , k ) ; } else { result = recursiveSelect ( pivotNewIndex + <int> , right , k - pivotDist ) ; } return result ; } private int medianOfThreePivot ( int leftIdx , int rightIdx ) { T left = array [ leftIdx ] ; int midIdx = ( leftIdx + rightIdx ) / <int> ; T mid = array [ midIdx ] ; T right = array [ rightIdx ] ; if ( comp . compare ( left , mid ) > <int> ) { if ( comp . compare ( mid , right ) > <int> ) { return midIdx ; } else if ( comp . compare ( left , right ) > <int> ) { return rightIdx ; } else { return leftIdx ; } } else { if ( comp . compare ( left , right ) > <int> ) { return leftIdx ; } else if ( comp . compare ( mid , right ) > <int> ) { return rightIdx ; } else { return midIdx ; } } } private void swap ( int left , int right ) { T tmp = array [ left ] ; array [ left ] = array [ right ] ; array [ right ] = tmp ; } } 
