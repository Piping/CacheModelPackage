package org . elasticsearch . common . util ; import org . elasticsearch . common . regex . Regex ; import java . net . URI ; import java . net . URISyntaxException ; public class URIPattern { private final URI uriPattern ; public URIPattern ( String pattern ) { try { uriPattern = new URI ( pattern ) ; } catch ( URISyntaxException ex ) { throw new IllegalArgumentException ( <str> + pattern + <str> ) ; } } public boolean match ( URI uri ) { return matchNormalized ( uri . normalize ( ) ) ; } public static boolean match ( URIPattern [ ] patterns , URI uri ) { URI normalized = uri . normalize ( ) ; for ( URIPattern pattern : patterns ) { if ( pattern . matchNormalized ( normalized ) ) { return true ; } } return false ; } private boolean matchNormalized ( URI uri ) { if ( uriPattern . isOpaque ( ) ) { return uri . isOpaque ( ) & & match ( uriPattern . getScheme ( ) , uri . getScheme ( ) ) & & match ( uriPattern . getSchemeSpecificPart ( ) , uri . getSchemeSpecificPart ( ) ) & & match ( uriPattern . getFragment ( ) , uri . getFragment ( ) ) ; } else { return match ( uriPattern . getScheme ( ) , uri . getScheme ( ) ) & & match ( uriPattern . getAuthority ( ) , uri . getAuthority ( ) ) & & match ( uriPattern . getQuery ( ) , uri . getQuery ( ) ) & & match ( uriPattern . getPath ( ) , uri . getPath ( ) ) & & match ( uriPattern . getFragment ( ) , uri . getFragment ( ) ) ; } } private boolean match ( String pattern , String value ) { if ( value = = null ) { if ( pattern = = null | | Regex . isMatchAllPattern ( pattern ) ) { return true ; } } return Regex . simpleMatch ( pattern , value ) ; } @Override public String toString ( ) { return uriPattern . toString ( ) ; } } 
