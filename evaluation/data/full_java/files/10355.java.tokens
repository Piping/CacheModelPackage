package com . google . common . collect ; import static com . google . common . collect . BoundType . CLOSED ; import static com . google . common . collect . BoundType . OPEN ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Objects ; import com . google . common . testing . NullPointerTester ; import junit . framework . TestCase ; import java . util . Arrays ; import java . util . List ; @GwtCompatible ( emulated = true ) public class GeneralRangeTest extends TestCase { private static final Ordering < Integer > ORDERING = Ordering . natural ( ) . nullsFirst ( ) ; private static final List < Integer > IN_ORDER_VALUES = Arrays . asList ( null , <int> , <int> , <int> , <int> , <int> ) ; public void testCreateEmptyRangeFails ( ) { for ( BoundType lboundType : BoundType . values ( ) ) { for ( BoundType uboundType : BoundType . values ( ) ) { try { GeneralRange . range ( ORDERING , <int> , lboundType , <int> , uboundType ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } } public void testCreateEmptyRangeOpenOpenFails ( ) { for ( Integer i : IN_ORDER_VALUES ) { try { GeneralRange . range ( ORDERING , i , OPEN , i , OPEN ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } } public void testCreateEmptyRangeClosedOpenSucceeds ( ) { for ( Integer i : IN_ORDER_VALUES ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , i , CLOSED , i , OPEN ) ; for ( Integer j : IN_ORDER_VALUES ) { assertFalse ( range . contains ( j ) ) ; } } } public void testCreateEmptyRangeOpenClosedSucceeds ( ) { for ( Integer i : IN_ORDER_VALUES ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , i , OPEN , i , CLOSED ) ; for ( Integer j : IN_ORDER_VALUES ) { assertFalse ( range . contains ( j ) ) ; } } } public void testCreateSingletonRangeSucceeds ( ) { for ( Integer i : IN_ORDER_VALUES ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , i , CLOSED , i , CLOSED ) ; for ( Integer j : IN_ORDER_VALUES ) { assertEquals ( Objects . equal ( i , j ) , range . contains ( j ) ) ; } } } public void testSingletonRange ( ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , CLOSED ) ; for ( Integer i : IN_ORDER_VALUES ) { assertEquals ( ORDERING . compare ( i , <int> ) = = <int> , range . contains ( i ) ) ; } } public void testLowerRange ( ) { for ( BoundType lBoundType : BoundType . values ( ) ) { GeneralRange < Integer > range = GeneralRange . downTo ( ORDERING , <int> , lBoundType ) ; for ( Integer i : IN_ORDER_VALUES ) { assertEquals ( ORDERING . compare ( i , <int> ) > <int> | | ( ORDERING . compare ( i , <int> ) = = <int> & & lBoundType = = CLOSED ) , range . contains ( i ) ) ; assertEquals ( ORDERING . compare ( i , <int> ) < <int> | | ( ORDERING . compare ( i , <int> ) = = <int> & & lBoundType = = OPEN ) , range . tooLow ( i ) ) ; assertFalse ( range . tooHigh ( i ) ) ; } } } public void testUpperRange ( ) { for ( BoundType lBoundType : BoundType . values ( ) ) { GeneralRange < Integer > range = GeneralRange . upTo ( ORDERING , <int> , lBoundType ) ; for ( Integer i : IN_ORDER_VALUES ) { assertEquals ( ORDERING . compare ( i , <int> ) < <int> | | ( ORDERING . compare ( i , <int> ) = = <int> & & lBoundType = = CLOSED ) , range . contains ( i ) ) ; assertEquals ( ORDERING . compare ( i , <int> ) > <int> | | ( ORDERING . compare ( i , <int> ) = = <int> & & lBoundType = = OPEN ) , range . tooHigh ( i ) ) ; assertFalse ( range . tooLow ( i ) ) ; } } } public void testDoublyBoundedAgainstRange ( ) { for ( BoundType lboundType : BoundType . values ( ) ) { for ( BoundType uboundType : BoundType . values ( ) ) { Range < Integer > range = Range . range ( <int> , lboundType , <int> , uboundType ) ; GeneralRange < Integer > gRange = GeneralRange . range ( ORDERING , <int> , lboundType , <int> , uboundType ) ; for ( Integer i : IN_ORDER_VALUES ) { assertEquals ( i ! = null & & range . contains ( i ) , gRange . contains ( i ) ) ; } } } } public void testIntersectAgainstMatchingEndpointsRange ( ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , OPEN ) ; assertEquals ( GeneralRange . range ( ORDERING , <int> , OPEN , <int> , OPEN ) , range . intersect ( GeneralRange . range ( ORDERING , <int> , OPEN , <int> , CLOSED ) ) ) ; } public void testIntersectAgainstBiggerRange ( ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , OPEN ) ; assertEquals ( GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , OPEN ) , range . intersect ( GeneralRange . range ( ORDERING , null , OPEN , <int> , CLOSED ) ) ) ; assertEquals ( GeneralRange . range ( ORDERING , <int> , OPEN , <int> , OPEN ) , range . intersect ( GeneralRange . range ( ORDERING , <int> , OPEN , <int> , CLOSED ) ) ) ; assertEquals ( GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , OPEN ) , range . intersect ( GeneralRange . range ( ORDERING , <int> , OPEN , <int> , OPEN ) ) ) ; } public void testIntersectAgainstSmallerRange ( ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , <int> , OPEN , <int> , OPEN ) ; assertEquals ( GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , OPEN ) , range . intersect ( GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , CLOSED ) ) ) ; } public void testIntersectOverlappingRange ( ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , <int> , OPEN , <int> , CLOSED ) ; assertEquals ( GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , CLOSED ) , range . intersect ( GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , CLOSED ) ) ) ; assertEquals ( GeneralRange . range ( ORDERING , <int> , OPEN , <int> , OPEN ) , range . intersect ( GeneralRange . range ( ORDERING , <int> , OPEN , <int> , OPEN ) ) ) ; } public void testIntersectNonOverlappingRange ( ) { GeneralRange < Integer > range = GeneralRange . range ( ORDERING , <int> , OPEN , <int> , CLOSED ) ; assertTrue ( range . intersect ( GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , CLOSED ) ) . isEmpty ( ) ) ; assertTrue ( range . intersect ( GeneralRange . range ( ORDERING , <int> , OPEN , <int> , OPEN ) ) . isEmpty ( ) ) ; } public void testFromRangeAll ( ) { assertEquals ( GeneralRange . all ( Ordering . natural ( ) ) , GeneralRange . from ( Range . all ( ) ) ) ; } public void testFromRangeOneEnd ( ) { for ( BoundType endpointType : BoundType . values ( ) ) { assertEquals ( GeneralRange . upTo ( Ordering . natural ( ) , <int> , endpointType ) , GeneralRange . from ( Range . upTo ( <int> , endpointType ) ) ) ; assertEquals ( GeneralRange . downTo ( Ordering . natural ( ) , <int> , endpointType ) , GeneralRange . from ( Range . downTo ( <int> , endpointType ) ) ) ; } } public void testFromRangeTwoEnds ( ) { for ( BoundType lowerType : BoundType . values ( ) ) { for ( BoundType upperType : BoundType . values ( ) ) { assertEquals ( GeneralRange . range ( Ordering . natural ( ) , <int> , lowerType , <int> , upperType ) , GeneralRange . from ( Range . range ( <int> , lowerType , <int> , upperType ) ) ) ; } } } public void testReverse ( ) { assertEquals ( GeneralRange . all ( ORDERING . reverse ( ) ) , GeneralRange . all ( ORDERING ) . reverse ( ) ) ; assertEquals ( GeneralRange . downTo ( ORDERING . reverse ( ) , <int> , CLOSED ) , GeneralRange . upTo ( ORDERING , <int> , CLOSED ) . reverse ( ) ) ; assertEquals ( GeneralRange . upTo ( ORDERING . reverse ( ) , <int> , OPEN ) , GeneralRange . downTo ( ORDERING , <int> , OPEN ) . reverse ( ) ) ; assertEquals ( GeneralRange . range ( ORDERING . reverse ( ) , <int> , OPEN , <int> , CLOSED ) , GeneralRange . range ( ORDERING , <int> , CLOSED , <int> , OPEN ) . reverse ( ) ) ; } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( GeneralRange . class ) ; } } 
