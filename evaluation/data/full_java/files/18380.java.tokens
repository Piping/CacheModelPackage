package com . badlogic . gdx . utils ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . FileOutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . lang . reflect . Method ; import java . util . HashSet ; import java . util . UUID ; import java . util . zip . CRC32 ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class SharedLibraryLoader { static public boolean isWindows = System . getProperty ( <str> ) . contains ( <str> ) ; static public boolean isLinux = System . getProperty ( <str> ) . contains ( <str> ) ; static public boolean isMac = System . getProperty ( <str> ) . contains ( <str> ) ; static public boolean isIos = false ; static public boolean isAndroid = false ; static public boolean isARM = System . getProperty ( <str> ) . startsWith ( <str> ) ; static public boolean is64Bit = System . getProperty ( <str> ) . equals ( <str> ) | | System . getProperty ( <str> ) . equals ( <str> ) ; static public String abi = ( System . getProperty ( <str> ) ! = null ? System . getProperty ( <str> ) : <str> ) ; static { String vm = System . getProperty ( <str> ) ; if ( vm ! = null & & vm . contains ( <str> ) ) { isAndroid = true ; isWindows = false ; isLinux = false ; isMac = false ; is64Bit = false ; } if ( ! isAndroid & & ! isWindows & & ! isLinux & & ! isMac ) { isIos = true ; is64Bit = false ; } } static private final HashSet < String > loadedLibraries = new HashSet ( ) ; private String nativesJar ; public SharedLibraryLoader ( ) { } public SharedLibraryLoader ( String nativesJar ) { this . nativesJar = nativesJar ; } public String crc ( InputStream input ) { if ( input = = null ) throw new IllegalArgumentException ( <str> ) ; CRC32 crc = new CRC32 ( ) ; byte [ ] buffer = new byte [ <int> ] ; try { while ( true ) { int length = input . read ( buffer ) ; if ( length = = - <int> ) break ; crc . update ( buffer , <int> , length ) ; } } catch ( Exception ex ) { StreamUtils . closeQuietly ( input ) ; } return Long . toString ( crc . getValue ( ) , <int> ) ; } public String mapLibraryName ( String libraryName ) { if ( isWindows ) return libraryName + ( is64Bit ? <str> : <str> ) ; if ( isLinux ) return <str> + libraryName + ( isARM ? <str> + abi : <str> ) + ( is64Bit ? <str> : <str> ) ; if ( isMac ) return <str> + libraryName + ( is64Bit ? <str> : <str> ) ; return libraryName ; } public synchronized void load ( String libraryName ) { if ( isIos ) return ; libraryName = mapLibraryName ( libraryName ) ; if ( loadedLibraries . contains ( libraryName ) ) return ; try { if ( isAndroid ) System . loadLibrary ( libraryName ) ; else loadFile ( libraryName ) ; } catch ( Throwable ex ) { throw new GdxRuntimeException ( <str> + libraryName + <str> + System . getProperty ( <str> ) + ( is64Bit ? <str> : <str> ) , ex ) ; } loadedLibraries . add ( libraryName ) ; } private InputStream readFile ( String path ) { if ( nativesJar = = null ) { InputStream input = SharedLibraryLoader . class . getResourceAsStream ( <str> + path ) ; if ( input = = null ) throw new GdxRuntimeException ( <str> + path ) ; return input ; } try { ZipFile file = new ZipFile ( nativesJar ) ; ZipEntry entry = file . getEntry ( path ) ; if ( entry = = null ) throw new GdxRuntimeException ( <str> + path + <str> + nativesJar ) ; return file . getInputStream ( entry ) ; } catch ( IOException ex ) { throw new GdxRuntimeException ( <str> + path + <str> + nativesJar , ex ) ; } } public File extractFile ( String sourcePath , String dirName ) throws IOException { try { String sourceCrc = crc ( readFile ( sourcePath ) ) ; if ( dirName = = null ) dirName = sourceCrc ; File extractedFile = getExtractedFile ( dirName , new File ( sourcePath ) . getName ( ) ) ; if ( extractedFile = = null ) { extractedFile = getExtractedFile ( UUID . randomUUID ( ) . toString ( ) , new File ( sourcePath ) . getName ( ) ) ; if ( extractedFile = = null ) throw new GdxRuntimeException ( <str> ) ; } return extractFile ( sourcePath , sourceCrc , extractedFile ) ; } catch ( RuntimeException ex ) { File file = new File ( System . getProperty ( <str> ) , sourcePath ) ; if ( file . exists ( ) ) return file ; throw ex ; } } public void extractFileTo ( String sourcePath , File dir ) throws IOException { extractFile ( sourcePath , crc ( readFile ( sourcePath ) ) , new File ( dir , new File ( sourcePath ) . getName ( ) ) ) ; } private File getExtractedFile ( String dirName , String fileName ) { File idealFile = new File ( System . getProperty ( <str> ) + <str> + System . getProperty ( <str> ) + <str> + dirName , fileName ) ; if ( canWrite ( idealFile ) ) return idealFile ; try { File file = File . createTempFile ( dirName , null ) ; if ( file . delete ( ) ) { file = new File ( file , fileName ) ; if ( canWrite ( file ) ) return file ; } } catch ( IOException ignored ) { } File file = new File ( System . getProperty ( <str> ) + <str> + dirName , fileName ) ; if ( canWrite ( file ) ) return file ; file = new File ( <str> + dirName , fileName ) ; if ( canWrite ( file ) ) return file ; return null ; } private boolean canWrite ( File file ) { File parent = file . getParentFile ( ) ; File testFile ; if ( file . exists ( ) ) { if ( ! file . canWrite ( ) | | ! canExecute ( file ) ) return false ; testFile = new File ( parent , UUID . randomUUID ( ) . toString ( ) ) ; } else { parent . mkdirs ( ) ; if ( ! parent . isDirectory ( ) ) return false ; testFile = file ; } try { new FileOutputStream ( testFile ) . close ( ) ; if ( ! canExecute ( testFile ) ) return false ; return true ; } catch ( Throwable ex ) { return false ; } finally { testFile . delete ( ) ; } } private boolean canExecute ( File file ) { try { Method canExecute = File . class . getMethod ( <str> ) ; if ( ( Boolean ) canExecute . invoke ( file ) ) return true ; Method setExecutable = File . class . getMethod ( <str> , boolean . class , boolean . class ) ; setExecutable . invoke ( file , true , false ) ; return ( Boolean ) canExecute . invoke ( file ) ; } catch ( Exception ignored ) { } return false ; } private File extractFile ( String sourcePath , String sourceCrc , File extractedFile ) throws IOException { String extractedCrc = null ; if ( extractedFile . exists ( ) ) { try { extractedCrc = crc ( new FileInputStream ( extractedFile ) ) ; } catch ( FileNotFoundException ignored ) { } } if ( extractedCrc = = null | | ! extractedCrc . equals ( sourceCrc ) ) { try { InputStream input = readFile ( sourcePath ) ; extractedFile . getParentFile ( ) . mkdirs ( ) ; FileOutputStream output = new FileOutputStream ( extractedFile ) ; byte [ ] buffer = new byte [ <int> ] ; while ( true ) { int length = input . read ( buffer ) ; if ( length = = - <int> ) break ; output . write ( buffer , <int> , length ) ; } input . close ( ) ; output . close ( ) ; } catch ( IOException ex ) { throw new GdxRuntimeException ( <str> + sourcePath + <str> + extractedFile . getAbsolutePath ( ) , ex ) ; } } return extractedFile ; } private void loadFile ( String sourcePath ) { String sourceCrc = crc ( readFile ( sourcePath ) ) ; String fileName = new File ( sourcePath ) . getName ( ) ; File file = new File ( System . getProperty ( <str> ) + <str> + System . getProperty ( <str> ) + <str> + sourceCrc , fileName ) ; Throwable ex = loadFile ( sourcePath , sourceCrc , file ) ; if ( ex = = null ) return ; try { file = File . createTempFile ( sourceCrc , null ) ; if ( file . delete ( ) & & loadFile ( sourcePath , sourceCrc , file ) = = null ) return ; } catch ( Throwable ignored ) { } file = new File ( System . getProperty ( <str> ) + <str> + sourceCrc , fileName ) ; if ( loadFile ( sourcePath , sourceCrc , file ) = = null ) return ; file = new File ( <str> + sourceCrc , fileName ) ; if ( loadFile ( sourcePath , sourceCrc , file ) = = null ) return ; file = new File ( System . getProperty ( <str> ) , sourcePath ) ; if ( file . exists ( ) ) { System . load ( file . getAbsolutePath ( ) ) ; return ; } throw new GdxRuntimeException ( ex ) ; } private Throwable loadFile ( String sourcePath , String sourceCrc , File extractedFile ) { try { System . load ( extractFile ( sourcePath , sourceCrc , extractedFile ) . getAbsolutePath ( ) ) ; return null ; } catch ( Throwable ex ) { return ex ; } } } 
