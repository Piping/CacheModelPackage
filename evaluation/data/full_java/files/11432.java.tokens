package org . gradle . api . internal . classpath ; import org . gradle . api . UncheckedIOException ; import org . gradle . api . internal . GradleDistributionLocator ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . util . GUtil ; import java . io . File ; import java . io . IOException ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import java . util . zip . ZipEntry ; import java . util . zip . ZipFile ; public class DefaultModuleRegistry implements ModuleRegistry { private final GradleDistributionLocator gradleDistributionLocator ; private final Map < String , Module > modules = new HashMap < String , Module > ( ) ; private final List < File > classpath = new ArrayList < File > ( ) ; private final Map < String , File > classpathJars = new LinkedHashMap < String , File > ( ) ; public DefaultModuleRegistry ( ) { this ( new DefaultClassPath ( ) ) ; } public DefaultModuleRegistry ( ClassPath additionalModuleClassPath ) { this ( DefaultModuleRegistry . class . getClassLoader ( ) , additionalModuleClassPath , new DefaultGradleDistributionLocator ( DefaultModuleRegistry . class ) ) ; } DefaultModuleRegistry ( ClassLoader classLoader , File distDir ) { this ( classLoader , new DefaultClassPath ( ) , new DefaultGradleDistributionLocator ( distDir ) ) ; } private DefaultModuleRegistry ( ClassLoader classLoader , ClassPath additionalModuleClassPath , GradleDistributionLocator gradleDistributionLocator ) { this . gradleDistributionLocator = gradleDistributionLocator ; for ( File classpathFile : new EffectiveClassPath ( classLoader ) . plus ( additionalModuleClassPath ) . getAsFiles ( ) ) { classpath . add ( classpathFile ) ; if ( classpathFile . isFile ( ) & & ! classpathJars . containsKey ( classpathFile . getName ( ) ) ) { classpathJars . put ( classpathFile . getName ( ) , classpathFile ) ; } } } @Override public ClassPath getAdditionalClassPath ( ) { return gradleDistributionLocator . getGradleHome ( ) = = null ? new DefaultClassPath ( classpath ) : new DefaultClassPath ( ) ; } public Module getExternalModule ( String name ) { File externalJar = findJar ( name ) ; if ( externalJar = = null ) { throw new UnknownModuleException ( String . format ( <str> , name , gradleDistributionLocator . getGradleHome ( ) ) ) ; } return new DefaultModule ( name , Collections . singleton ( externalJar ) , Collections . < File > emptySet ( ) , Collections . < Module > emptySet ( ) ) ; } public Module getModule ( String name ) { Module module = modules . get ( name ) ; if ( module = = null ) { module = loadModule ( name ) ; modules . put ( name , module ) ; } return module ; } private Module loadModule ( String moduleName ) { File jarFile = findJar ( moduleName ) ; if ( jarFile ! = null ) { Set < File > implementationClasspath = new LinkedHashSet < File > ( ) ; implementationClasspath . add ( jarFile ) ; Properties properties = loadModuleProperties ( moduleName , jarFile ) ; return module ( moduleName , properties , implementationClasspath ) ; } String resourceName = String . format ( <str> , moduleName ) ; Set < File > implementationClasspath = new LinkedHashSet < File > ( ) ; findImplementationClasspath ( moduleName , implementationClasspath ) ; for ( File file : implementationClasspath ) { if ( file . isDirectory ( ) ) { File propertiesFile = new File ( file , resourceName ) ; if ( propertiesFile . isFile ( ) ) { Properties properties = GUtil . loadProperties ( propertiesFile ) ; return module ( moduleName , properties , implementationClasspath ) ; } } } if ( gradleDistributionLocator . getGradleHome ( ) = = null ) { throw new UnknownModuleException ( String . format ( <str> , moduleName ) ) ; } throw new UnknownModuleException ( String . format ( <str> , moduleName , gradleDistributionLocator . getGradleHome ( ) ) ) ; } private Module module ( String moduleName , Properties properties , Set < File > implementationClasspath ) { Set < File > runtimeClasspath = new LinkedHashSet < File > ( ) ; String runtime = properties . getProperty ( <str> ) ; for ( String jarName : split ( runtime ) ) { runtimeClasspath . add ( findDependencyJar ( moduleName , jarName ) ) ; } Set < Module > modules = new LinkedHashSet < Module > ( ) ; String projects = properties . getProperty ( <str> ) ; for ( String project : split ( projects ) ) { modules . add ( getModule ( project ) ) ; } return new DefaultModule ( moduleName , implementationClasspath , runtimeClasspath , modules ) ; } private String [ ] split ( String value ) { if ( value = = null ) { return new String [ <int> ] ; } value = value . trim ( ) ; if ( value . length ( ) = = <int> ) { return new String [ <int> ] ; } return value . split ( <str> ) ; } private void findImplementationClasspath ( String name , Collection < File > implementationClasspath ) { List < String > suffixes = new ArrayList < String > ( ) ; Matcher matcher = Pattern . compile ( <str> ) . matcher ( name ) ; matcher . matches ( ) ; String projectDirName = matcher . group ( <int> ) ; String projectName = toCamelCase ( projectDirName ) ; suffixes . add ( String . format ( <str> , projectName ) . replace ( <str> , File . separatorChar ) ) ; suffixes . add ( String . format ( <str> , projectDirName ) . replace ( <str> , File . separatorChar ) ) ; suffixes . add ( String . format ( <str> , projectDirName ) . replace ( <str> , File . separatorChar ) ) ; suffixes . add ( String . format ( <str> , projectDirName ) . replace ( <str> , File . separatorChar ) ) ; suffixes . add ( String . format ( <str> , projectDirName ) . replace ( <str> , File . separatorChar ) ) ; suffixes . add ( String . format ( <str> , projectDirName ) . replace ( <str> , File . separatorChar ) ) ; for ( File file : classpath ) { if ( file . isDirectory ( ) ) { for ( String suffix : suffixes ) { if ( file . getAbsolutePath ( ) . endsWith ( suffix ) ) { implementationClasspath . add ( file ) ; } } } } } private String toCamelCase ( String name ) { StringBuffer result = new StringBuffer ( ) ; Matcher matcher = Pattern . compile ( <str> ) . matcher ( name ) ; while ( matcher . find ( ) ) { matcher . appendReplacement ( result , <str> ) ; result . append ( matcher . group ( <int> ) . toUpperCase ( ) ) ; } matcher . appendTail ( result ) ; return result . toString ( ) ; } private Properties loadModuleProperties ( String name , File jarFile ) { try { ZipFile zipFile = new ZipFile ( jarFile ) ; try { final String entryName = String . format ( <str> , name ) ; ZipEntry entry = zipFile . getEntry ( entryName ) ; if ( entry = = null ) { throw new IllegalStateException ( <str> + entryName + <str> + jarFile . getAbsolutePath ( ) ) ; } return GUtil . loadProperties ( zipFile . getInputStream ( entry ) ) ; } finally { zipFile . close ( ) ; } } catch ( IOException e ) { throw new UncheckedIOException ( e ) ; } } private File findJar ( String name ) { Pattern pattern = Pattern . compile ( Pattern . quote ( name ) + <str> ) ; for ( File libDir : gradleDistributionLocator . getLibDirs ( ) ) { for ( File file : libDir . listFiles ( ) ) { if ( pattern . matcher ( file . getName ( ) ) . matches ( ) ) { return file ; } } } for ( File file : classpath ) { if ( pattern . matcher ( file . getName ( ) ) . matches ( ) ) { return file ; } } return null ; } private File findDependencyJar ( String module , String name ) { File jarFile = classpathJars . get ( name ) ; if ( jarFile ! = null ) { return jarFile ; } if ( gradleDistributionLocator . getGradleHome ( ) = = null ) { throw new IllegalArgumentException ( String . format ( <str> , name , module ) ) ; } for ( File libDir : gradleDistributionLocator . getLibDirs ( ) ) { jarFile = new File ( libDir , name ) ; if ( jarFile . isFile ( ) ) { return jarFile ; } } throw new IllegalArgumentException ( String . format ( <str> , name , module , gradleDistributionLocator . getGradleHome ( ) ) ) ; } private static class DefaultModule implements Module { private final String name ; private final ClassPath implementationClasspath ; private final ClassPath runtimeClasspath ; private final Set < Module > modules ; private final ClassPath classpath ; public DefaultModule ( String name , Set < File > implementationClasspath , Set < File > runtimeClasspath , Set < Module > modules ) { this . name = name ; this . implementationClasspath = new DefaultClassPath ( implementationClasspath ) ; this . runtimeClasspath = new DefaultClassPath ( runtimeClasspath ) ; this . modules = modules ; Set < File > classpath = new LinkedHashSet < File > ( ) ; classpath . addAll ( implementationClasspath ) ; classpath . addAll ( runtimeClasspath ) ; this . classpath = new DefaultClassPath ( classpath ) ; } @Override public String toString ( ) { return String . format ( <str> , name ) ; } public Set < Module > getRequiredModules ( ) { return modules ; } public ClassPath getImplementationClasspath ( ) { return implementationClasspath ; } public ClassPath getRuntimeClasspath ( ) { return runtimeClasspath ; } public ClassPath getClasspath ( ) { return classpath ; } public Set < Module > getAllRequiredModules ( ) { Set < Module > modules = new LinkedHashSet < Module > ( ) ; modules . add ( this ) ; for ( Module module : this . modules ) { modules . addAll ( module . getAllRequiredModules ( ) ) ; } return modules ; } } } 
