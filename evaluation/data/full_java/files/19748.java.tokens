package io . netty . util . internal . logging ; import java . text . MessageFormat ; import java . util . HashMap ; import java . util . Map ; final class MessageFormatter { static final char DELIM_START = <str> ; static final char DELIM_STOP = <str> ; static final String DELIM_STR = <str> ; private static final char ESCAPE_CHAR = <str> ; static FormattingTuple format ( String messagePattern , Object arg ) { return arrayFormat ( messagePattern , new Object [ ] { arg } ) ; } static FormattingTuple format ( final String messagePattern , Object argA , Object argB ) { return arrayFormat ( messagePattern , new Object [ ] { argA , argB } ) ; } static Throwable getThrowableCandidate ( Object [ ] argArray ) { if ( argArray = = null | | argArray . length = = <int> ) { return null ; } final Object lastEntry = argArray [ argArray . length - <int> ] ; if ( lastEntry instanceof Throwable ) { return ( Throwable ) lastEntry ; } return null ; } static FormattingTuple arrayFormat ( final String messagePattern , final Object [ ] argArray ) { Throwable throwableCandidate = getThrowableCandidate ( argArray ) ; if ( messagePattern = = null ) { return new FormattingTuple ( null , argArray , throwableCandidate ) ; } if ( argArray = = null ) { return new FormattingTuple ( messagePattern ) ; } int i = <int> ; int j ; StringBuffer sbuf = new StringBuffer ( messagePattern . length ( ) + <int> ) ; int L ; for ( L = <int> ; L < argArray . length ; L + + ) { j = messagePattern . indexOf ( DELIM_STR , i ) ; if ( j = = - <int> ) { if ( i = = <int> ) { return new FormattingTuple ( messagePattern , argArray , throwableCandidate ) ; } else { sbuf . append ( messagePattern . substring ( i , messagePattern . length ( ) ) ) ; return new FormattingTuple ( sbuf . toString ( ) , argArray , throwableCandidate ) ; } } else { if ( isEscapedDelimeter ( messagePattern , j ) ) { if ( ! isDoubleEscaped ( messagePattern , j ) ) { L - - ; sbuf . append ( messagePattern . substring ( i , j - <int> ) ) ; sbuf . append ( DELIM_START ) ; i = j + <int> ; } else { sbuf . append ( messagePattern . substring ( i , j - <int> ) ) ; deeplyAppendParameter ( sbuf , argArray [ L ] , new HashMap < Object [ ] , Void > ( ) ) ; i = j + <int> ; } } else { sbuf . append ( messagePattern . substring ( i , j ) ) ; deeplyAppendParameter ( sbuf , argArray [ L ] , new HashMap < Object [ ] , Void > ( ) ) ; i = j + <int> ; } } } sbuf . append ( messagePattern . substring ( i , messagePattern . length ( ) ) ) ; if ( L < argArray . length - <int> ) { return new FormattingTuple ( sbuf . toString ( ) , argArray , throwableCandidate ) ; } else { return new FormattingTuple ( sbuf . toString ( ) , argArray , null ) ; } } static boolean isEscapedDelimeter ( String messagePattern , int delimeterStartIndex ) { if ( delimeterStartIndex = = <int> ) { return false ; } return messagePattern . charAt ( delimeterStartIndex - <int> ) = = ESCAPE_CHAR ; } static boolean isDoubleEscaped ( String messagePattern , int delimeterStartIndex ) { return delimeterStartIndex > = <int> & & messagePattern . charAt ( delimeterStartIndex - <int> ) = = ESCAPE_CHAR ; } private static void deeplyAppendParameter ( StringBuffer sbuf , Object o , Map < Object [ ] , Void > seenMap ) { if ( o = = null ) { sbuf . append ( <str> ) ; return ; } if ( ! o . getClass ( ) . isArray ( ) ) { safeObjectAppend ( sbuf , o ) ; } else { if ( o instanceof boolean [ ] ) { booleanArrayAppend ( sbuf , ( boolean [ ] ) o ) ; } else if ( o instanceof byte [ ] ) { byteArrayAppend ( sbuf , ( byte [ ] ) o ) ; } else if ( o instanceof char [ ] ) { charArrayAppend ( sbuf , ( char [ ] ) o ) ; } else if ( o instanceof short [ ] ) { shortArrayAppend ( sbuf , ( short [ ] ) o ) ; } else if ( o instanceof int [ ] ) { intArrayAppend ( sbuf , ( int [ ] ) o ) ; } else if ( o instanceof long [ ] ) { longArrayAppend ( sbuf , ( long [ ] ) o ) ; } else if ( o instanceof float [ ] ) { floatArrayAppend ( sbuf , ( float [ ] ) o ) ; } else if ( o instanceof double [ ] ) { doubleArrayAppend ( sbuf , ( double [ ] ) o ) ; } else { objectArrayAppend ( sbuf , ( Object [ ] ) o , seenMap ) ; } } } private static void safeObjectAppend ( StringBuffer sbuf , Object o ) { try { String oAsString = o . toString ( ) ; sbuf . append ( oAsString ) ; } catch ( Throwable t ) { System . err . println ( <str> + o . getClass ( ) . getName ( ) + <str> ) ; t . printStackTrace ( ) ; sbuf . append ( <str> ) ; } } private static void objectArrayAppend ( StringBuffer sbuf , Object [ ] a , Map < Object [ ] , Void > seenMap ) { sbuf . append ( <str> ) ; if ( ! seenMap . containsKey ( a ) ) { seenMap . put ( a , null ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { deeplyAppendParameter ( sbuf , a [ i ] , seenMap ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } seenMap . remove ( a ) ; } else { sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void booleanArrayAppend ( StringBuffer sbuf , boolean [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } sbuf . append ( <str> ) ; } private static void byteArrayAppend ( StringBuffer sbuf , byte [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } sbuf . append ( <str> ) ; } private static void charArrayAppend ( StringBuffer sbuf , char [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } sbuf . append ( <str> ) ; } private static void shortArrayAppend ( StringBuffer sbuf , short [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } sbuf . append ( <str> ) ; } private static void intArrayAppend ( StringBuffer sbuf , int [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } sbuf . append ( <str> ) ; } private static void longArrayAppend ( StringBuffer sbuf , long [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } sbuf . append ( <str> ) ; } private static void floatArrayAppend ( StringBuffer sbuf , float [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } sbuf . append ( <str> ) ; } private static void doubleArrayAppend ( StringBuffer sbuf , double [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) { sbuf . append ( <str> ) ; } } sbuf . append ( <str> ) ; } private MessageFormatter ( ) { } } 
