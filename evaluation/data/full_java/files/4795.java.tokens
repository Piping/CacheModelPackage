package org . eclipse . ui . console ; import java . io . IOException ; import java . io . OutputStream ; import org . eclipse . swt . graphics . Color ; import org . eclipse . ui . WorkbenchEncoding ; import org . eclipse . ui . internal . console . IOConsolePartitioner ; public class IOConsoleOutputStream extends OutputStream { private boolean closed = false ; private IOConsolePartitioner partitioner ; private IOConsole console ; private boolean activateOnWrite = false ; private Color color ; private int fontStyle ; private String fEncoding ; private String fDefaultEncoding = WorkbenchEncoding . getWorkbenchDefaultEncoding ( ) ; private boolean fNeedsEncoding = false ; private boolean prependCR ; IOConsoleOutputStream ( IOConsole console ) { this . console = console ; this . partitioner = ( IOConsolePartitioner ) console . getPartitioner ( ) ; } public int getFontStyle ( ) { return fontStyle ; } public void setFontStyle ( int newFontStyle ) { if ( newFontStyle ! = fontStyle ) { int old = fontStyle ; fontStyle = newFontStyle ; console . firePropertyChange ( this , IConsoleConstants . P_FONT_STYLE , Integer . valueOf ( old ) , Integer . valueOf ( fontStyle ) ) ; } } public boolean isActivateOnWrite ( ) { return activateOnWrite ; } public void setActivateOnWrite ( boolean activateOnWrite ) { this . activateOnWrite = activateOnWrite ; } public void setColor ( Color newColor ) { Color old = color ; if ( old = = null | | ! old . equals ( newColor ) ) { color = newColor ; console . firePropertyChange ( this , IConsoleConstants . P_STREAM_COLOR , old , newColor ) ; } } public Color getColor ( ) { return color ; } public synchronized boolean isClosed ( ) { return closed ; } @Override public synchronized void close ( ) throws IOException { if ( closed ) { throw new IOException ( <str> ) ; } if ( prependCR ) { prependCR = false ; notifyParitioner ( <str> ) ; } console . streamClosed ( this ) ; closed = true ; partitioner = null ; } @Override public void flush ( ) throws IOException { if ( closed ) { throw new IOException ( <str> ) ; } } @Override public void write ( byte [ ] b , int off , int len ) throws IOException { if ( fNeedsEncoding ) { encodedWrite ( new String ( b , off , len , fEncoding ) ) ; } else { encodedWrite ( new String ( b , off , len ) ) ; } } @Override public void write ( byte [ ] b ) throws IOException { write ( b , <int> , b . length ) ; } @Override public void write ( int b ) throws IOException { write ( new byte [ ] { ( byte ) b } , <int> , <int> ) ; } public void write ( String str ) throws IOException { encodedWrite ( str ) ; } private synchronized void encodedWrite ( String encodedString ) throws IOException { if ( closed ) { throw new IOException ( <str> ) ; } String newencoding = encodedString ; if ( prependCR ) { newencoding = <str> + newencoding ; prependCR = false ; } if ( newencoding . endsWith ( <str> ) ) { prependCR = true ; newencoding = new String ( newencoding . substring ( <int> , newencoding . length ( ) - <int> ) ) ; } notifyParitioner ( newencoding ) ; } private void notifyParitioner ( String encodedString ) throws IOException { try { partitioner . streamAppended ( this , encodedString ) ; if ( activateOnWrite ) { console . activate ( ) ; } else { ConsolePlugin . getDefault ( ) . getConsoleManager ( ) . warnOfContentChange ( console ) ; } } catch ( IOException e ) { if ( ! closed ) { close ( ) ; } throw e ; } } public void setEncoding ( String encoding ) { fEncoding = encoding ; fNeedsEncoding = ( fEncoding ! = null ) & & ( ! fEncoding . equals ( fDefaultEncoding ) ) ; } } 
