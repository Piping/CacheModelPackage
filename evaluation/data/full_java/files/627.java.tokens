package org . apache . cassandra . hints ; import java . io . File ; import java . io . IOException ; import java . nio . file . Files ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . stream . Stream ; import org . apache . cassandra . io . FSReadError ; import org . apache . cassandra . utils . CLibrary ; import org . apache . cassandra . utils . SyncUtil ; import static java . util . stream . Collectors . groupingBy ; final class HintsCatalog { private final File hintsDirectory ; private final Map < UUID , HintsStore > stores ; private HintsCatalog ( File hintsDirectory , Map < UUID , List < HintsDescriptor > > descriptors ) { this . hintsDirectory = hintsDirectory ; this . stores = new ConcurrentHashMap < > ( ) ; for ( Map . Entry < UUID , List < HintsDescriptor > > entry : descriptors . entrySet ( ) ) stores . put ( entry . getKey ( ) , HintsStore . create ( entry . getKey ( ) , hintsDirectory , entry . getValue ( ) ) ) ; } static HintsCatalog load ( File hintsDirectory ) { try { Map < UUID , List < HintsDescriptor > > stores = Files . list ( hintsDirectory . toPath ( ) ) . filter ( HintsDescriptor : : isHintFileName ) . map ( HintsDescriptor : : readFromFile ) . collect ( groupingBy ( h - > h . hostId ) ) ; return new HintsCatalog ( hintsDirectory , stores ) ; } catch ( IOException e ) { throw new FSReadError ( e , hintsDirectory ) ; } } Stream < HintsStore > stores ( ) { return stores . values ( ) . stream ( ) ; } void maybeLoadStores ( Iterable < UUID > hostIds ) { for ( UUID hostId : hostIds ) get ( hostId ) ; } HintsStore get ( UUID hostId ) { HintsStore store = stores . get ( hostId ) ; return store = = null ? stores . computeIfAbsent ( hostId , ( id ) - > HintsStore . create ( id , hintsDirectory , Collections . emptyList ( ) ) ) : store ; } void deleteAllHints ( ) { stores . keySet ( ) . forEach ( this : : deleteAllHints ) ; } void deleteAllHints ( UUID hostId ) { HintsStore store = stores . get ( hostId ) ; if ( store ! = null ) store . deleteAllHints ( ) ; } boolean hasFiles ( ) { return stores ( ) . anyMatch ( HintsStore : : hasFiles ) ; } void exciseStore ( UUID hostId ) { deleteAllHints ( hostId ) ; stores . remove ( hostId ) ; } void fsyncDirectory ( ) { int fd = CLibrary . tryOpenDirectory ( hintsDirectory . getAbsolutePath ( ) ) ; if ( fd ! = - <int> ) { SyncUtil . trySync ( fd ) ; CLibrary . tryCloseFD ( fd ) ; } } } 
