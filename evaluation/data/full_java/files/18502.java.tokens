package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . tests . utils . GdxTest ; public class InverseKinematicsTest extends GdxTest { static class Bone { final float len ; final Vector3 position = new Vector3 ( ) ; final Vector3 inertia = new Vector3 ( ) ; public String name ; public Bone ( String name , float x , float y , float len ) { this . name = name ; this . position . set ( x , y , <int> ) ; this . len = len ; } public String toString ( ) { return <str> + name + <str> + position + <str> + len ; } } static final float GRAVITY = <int> ; OrthographicCamera camera ; ShapeRenderer renderer ; Bone [ ] bones ; Vector3 globalCoords = new Vector3 ( ) ; Vector3 endPoint = new Vector3 ( ) ; Vector2 diff = new Vector2 ( ) ; @Override public void create ( ) { float aspect = Gdx . graphics . getWidth ( ) / ( float ) Gdx . graphics . getHeight ( ) ; camera = new OrthographicCamera ( <int> * aspect , <int> ) ; camera . update ( ) ; renderer = new ShapeRenderer ( ) ; renderer . setProjectionMatrix ( camera . combined ) ; bones = new Bone [ ] { new Bone ( <str> , <int> , <int> , <int> ) , new Bone ( <str> , <int> , <int> , <int> ) , new Bone ( <str> , <int> , <int> , <int> ) , new Bone ( <str> , <int> , <int> , <int> ) , new Bone ( <str> , <int> , <int> , <int> ) } ; globalCoords . set ( bones [ <int> ] . position ) ; } @Override public void dispose ( ) { renderer . dispose ( ) ; } @Override public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; camera . update ( ) ; renderer . setProjectionMatrix ( camera . combined ) ; if ( Gdx . input . isTouched ( ) ) camera . unproject ( globalCoords . set ( Gdx . input . getX ( ) , Gdx . input . getY ( ) , <int> ) ) ; solveFakeIK ( globalCoords ) ; renderBones ( ) ; } private void renderBones ( ) { renderer . begin ( ShapeType . Line ) ; renderer . setColor ( <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < bones . length - <int> ; i + + ) { renderer . line ( bones [ i ] . position . x , bones [ i ] . position . y , bones [ i + <int> ] . position . x , bones [ i + <int> ] . position . y ) ; } renderer . end ( ) ; renderer . begin ( ShapeType . Point ) ; renderer . setColor ( <int> , <int> , <int> , <int> ) ; for ( int i = <int> ; i < bones . length ; i + + ) { renderer . point ( bones [ i ] . position . x , bones [ i ] . position . y , <int> ) ; } renderer . end ( ) ; } public void solveFakeIK ( Vector3 target ) { float gravity = Gdx . graphics . getDeltaTime ( ) * GRAVITY ; endPoint . set ( target ) ; bones [ <int> ] . position . set ( endPoint ) ; for ( int i = <int> ; i < bones . length - <int> ; i + + ) { Bone bone = bones [ i ] ; endPoint . set ( bone . position ) ; diff . set ( endPoint . x , endPoint . y ) . sub ( bones [ i + <int> ] . position . x , bones [ i + <int> ] . position . y ) ; diff . add ( <int> , gravity ) ; diff . add ( bones [ i + <int> ] . inertia . x , bones [ i + <int> ] . inertia . y ) ; diff . nor ( ) . scl ( bones [ i + <int> ] . len ) ; float x = endPoint . x - diff . x ; float y = endPoint . y - diff . y ; float delta = Gdx . graphics . getDeltaTime ( ) ; bones [ i + <int> ] . inertia . add ( ( bones [ i + <int> ] . position . x - x ) * delta , ( bones [ i + <int> ] . position . y - y ) * delta , <int> ) . scl ( <float> ) ; bones [ i + <int> ] . position . set ( x , y , <int> ) ; } } } 
