package org . gradle . process . internal ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . messaging . remote . ConnectionAcceptor ; import org . gradle . messaging . remote . ObjectConnection ; import org . gradle . process . ExecResult ; import java . util . Date ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; import static java . lang . String . format ; public class DefaultWorkerProcess implements WorkerProcess { private final static Logger LOGGER = Logging . getLogger ( DefaultWorkerProcess . class ) ; private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private ObjectConnection connection ; private ConnectionAcceptor acceptor ; private ExecHandle execHandle ; private boolean running ; private Throwable processFailure ; private final long connectTimeout ; public DefaultWorkerProcess ( int connectTimeoutValue , TimeUnit connectTimeoutUnits ) { connectTimeout = connectTimeoutUnits . toMillis ( connectTimeoutValue ) ; } public void setExecHandle ( ExecHandle execHandle ) { this . execHandle = execHandle ; execHandle . addListener ( new ExecHandleListener ( ) { public void executionStarted ( ExecHandle execHandle ) { } public void executionFinished ( ExecHandle execHandle , ExecResult execResult ) { onProcessStop ( execResult ) ; } } ) ; } public void startAccepting ( ConnectionAcceptor acceptor ) { lock . lock ( ) ; try { this . acceptor = acceptor ; } finally { lock . unlock ( ) ; } } public void onConnect ( ObjectConnection connection ) { ConnectionAcceptor stoppable ; lock . lock ( ) ; try { LOGGER . debug ( <str> , connection , execHandle ) ; this . connection = connection ; condition . signalAll ( ) ; stoppable = acceptor ; } finally { lock . unlock ( ) ; } stoppable . requestStop ( ) ; } private void onProcessStop ( ExecResult execResult ) { lock . lock ( ) ; try { try { execResult . rethrowFailure ( ) . assertNormalExitValue ( ) ; } catch ( Throwable e ) { processFailure = e ; } running = false ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } @Override public String toString ( ) { return <str> + <str> + running + <str> + execHandle + <str> ; } public ObjectConnection getConnection ( ) { return connection ; } public void start ( ) { try { doStart ( ) ; } catch ( Throwable t ) { cleanup ( ) ; throw UncheckedException . throwAsUncheckedException ( t ) ; } } private void doStart ( ) { lock . lock ( ) ; try { running = true ; } finally { lock . unlock ( ) ; } execHandle . start ( ) ; Date connectExpiry = new Date ( System . currentTimeMillis ( ) + connectTimeout ) ; lock . lock ( ) ; try { while ( connection = = null & & running ) { try { if ( ! condition . awaitUntil ( connectExpiry ) ) { throw new ExecException ( format ( <str> + <str> + <str> + <str> , execHandle , ( ( double ) connectTimeout ) / <int> , execHandle . getState ( ) , running ) ) ; } } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } if ( processFailure ! = null ) { throw UncheckedException . throwAsUncheckedException ( processFailure ) ; } if ( connection = = null ) { throw new ExecException ( format ( <str> , execHandle ) ) ; } } finally { lock . unlock ( ) ; } } public ExecResult waitForStop ( ) { try { return execHandle . waitForFinish ( ) . assertNormalExitValue ( ) ; } finally { cleanup ( ) ; } } private void cleanup ( ) { CompositeStoppable stoppable ; lock . lock ( ) ; try { stoppable = CompositeStoppable . stoppable ( acceptor , connection ) ; } finally { this . connection = null ; this . acceptor = null ; this . execHandle = null ; lock . unlock ( ) ; } stoppable . stop ( ) ; } } 
