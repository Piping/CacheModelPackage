package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . action . admin . indices . refresh . RefreshRequest ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . index . query . TermQueryBuilder ; import org . elasticsearch . search . aggregations . bucket . sampler . Sampler ; import org . elasticsearch . search . aggregations . bucket . sampler . SamplerAggregationBuilder ; import org . elasticsearch . search . aggregations . bucket . sampler . SamplerAggregator ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . Terms . Bucket ; import org . elasticsearch . search . aggregations . bucket . terms . TermsBuilder ; import org . elasticsearch . search . aggregations . metrics . max . Max ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . Collection ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_REPLICAS ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . search . aggregations . AggregationBuilders . max ; import static org . elasticsearch . search . aggregations . AggregationBuilders . sampler ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; @ESIntegTestCase.SuiteScopeTestCase public class SamplerIT extends ESIntegTestCase { public static final int NUM_SHARDS = <int> ; public String randomExecutionHint ( ) { return randomBoolean ( ) ? null : randomFrom ( SamplerAggregator . ExecutionMode . values ( ) ) . toString ( ) ; } @Override public void setupSuiteScopeCluster ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , NUM_SHARDS , SETTING_NUMBER_OF_REPLICAS , <int> ) . addMapping ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; createIndex ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( SETTING_NUMBER_OF_SHARDS , NUM_SHARDS , SETTING_NUMBER_OF_REPLICAS , <int> ) . addMapping ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; ensureGreen ( ) ; String data [ ] = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; for ( int i = <int> ; i < data . length ; i + + ) { String [ ] parts = data [ i ] . split ( <str> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( <str> , parts [ <int> ] , <str> , parts [ <int> ] , <str> , parts [ <int> ] , <str> , Float . parseFloat ( parts [ <int> ] ) ) . get ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( <str> , parts [ <int> ] , <str> , parts [ <int> ] , <str> , Float . parseFloat ( parts [ <int> ] ) ) . get ( ) ; } client ( ) . admin ( ) . indices ( ) . refresh ( new RefreshRequest ( <str> ) ) . get ( ) ; } public void testIssue10719 ( ) throws Exception { boolean asc = randomBoolean ( ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . addAggregation ( terms ( <str> ) . field ( <str> ) . order ( Terms . Order . aggregation ( <str> , asc ) ) . subAggregation ( sampler ( <str> ) . shardSize ( <int> ) . subAggregation ( max ( <str> ) . field ( <str> ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms genres = response . getAggregations ( ) . get ( <str> ) ; Collection < Bucket > genreBuckets = genres . getBuckets ( ) ; assertThat ( genreBuckets . size ( ) , greaterThan ( <int> ) ) ; double lastMaxPrice = asc ? Double . MIN_VALUE : Double . MAX_VALUE ; for ( Terms . Bucket genreBucket : genres . getBuckets ( ) ) { Sampler sample = genreBucket . getAggregations ( ) . get ( <str> ) ; Max maxPriceInGenre = sample . getAggregations ( ) . get ( <str> ) ; double price = maxPriceInGenre . getValue ( ) ; if ( asc ) { assertThat ( price , greaterThanOrEqualTo ( lastMaxPrice ) ) ; } else { assertThat ( price , lessThanOrEqualTo ( lastMaxPrice ) ) ; } lastMaxPrice = price ; } } public void testNoDiversity ( ) throws Exception { SamplerAggregationBuilder sampleAgg = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . addAggregation ( sampleAgg ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Sampler sample = response . getAggregations ( ) . get ( <str> ) ; Terms authors = sample . getAggregations ( ) . get ( <str> ) ; Collection < Bucket > testBuckets = authors . getBuckets ( ) ; long maxBooksPerAuthor = <int> ; for ( Terms . Bucket testBucket : testBuckets ) { maxBooksPerAuthor = Math . max ( testBucket . getDocCount ( ) , maxBooksPerAuthor ) ; } assertThat ( maxBooksPerAuthor , equalTo ( <int> ) ) ; } public void testSimpleDiversity ( ) throws Exception { int MAX_DOCS_PER_AUTHOR = <int> ; SamplerAggregationBuilder sampleAgg = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) ; sampleAgg . field ( <str> ) . maxDocsPerValue ( MAX_DOCS_PER_AUTHOR ) . executionHint ( randomExecutionHint ( ) ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . addAggregation ( sampleAgg ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Sampler sample = response . getAggregations ( ) . get ( <str> ) ; Terms authors = sample . getAggregations ( ) . get ( <str> ) ; Collection < Bucket > testBuckets = authors . getBuckets ( ) ; for ( Terms . Bucket testBucket : testBuckets ) { assertThat ( testBucket . getDocCount ( ) , lessThanOrEqualTo ( ( long ) NUM_SHARDS * MAX_DOCS_PER_AUTHOR ) ) ; } } public void testNestedDiversity ( ) throws Exception { int MAX_DOCS_PER_AUTHOR = <int> ; TermsBuilder rootTerms = new TermsBuilder ( <str> ) . field ( <str> ) ; SamplerAggregationBuilder sampleAgg = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) ; sampleAgg . field ( <str> ) . maxDocsPerValue ( MAX_DOCS_PER_AUTHOR ) . executionHint ( randomExecutionHint ( ) ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; rootTerms . subAggregation ( sampleAgg ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . addAggregation ( rootTerms ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms genres = response . getAggregations ( ) . get ( <str> ) ; Collection < Bucket > genreBuckets = genres . getBuckets ( ) ; for ( Terms . Bucket genreBucket : genreBuckets ) { Sampler sample = genreBucket . getAggregations ( ) . get ( <str> ) ; Terms authors = sample . getAggregations ( ) . get ( <str> ) ; Collection < Bucket > testBuckets = authors . getBuckets ( ) ; for ( Terms . Bucket testBucket : testBuckets ) { assertThat ( testBucket . getDocCount ( ) , lessThanOrEqualTo ( ( long ) NUM_SHARDS * MAX_DOCS_PER_AUTHOR ) ) ; } } } public void testNestedSamples ( ) throws Exception { int MAX_DOCS_PER_AUTHOR = <int> ; int MAX_DOCS_PER_GENRE = <int> ; SamplerAggregationBuilder rootSample = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) . field ( <str> ) . maxDocsPerValue ( MAX_DOCS_PER_GENRE ) ; SamplerAggregationBuilder sampleAgg = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) ; sampleAgg . field ( <str> ) . maxDocsPerValue ( MAX_DOCS_PER_AUTHOR ) . executionHint ( randomExecutionHint ( ) ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; rootSample . subAggregation ( sampleAgg ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . addAggregation ( rootSample ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Sampler genreSample = response . getAggregations ( ) . get ( <str> ) ; Sampler sample = genreSample . getAggregations ( ) . get ( <str> ) ; Terms genres = sample . getAggregations ( ) . get ( <str> ) ; Collection < Bucket > testBuckets = genres . getBuckets ( ) ; for ( Terms . Bucket testBucket : testBuckets ) { assertThat ( testBucket . getDocCount ( ) , lessThanOrEqualTo ( ( long ) NUM_SHARDS * MAX_DOCS_PER_GENRE ) ) ; } Terms authors = sample . getAggregations ( ) . get ( <str> ) ; testBuckets = authors . getBuckets ( ) ; for ( Terms . Bucket testBucket : testBuckets ) { assertThat ( testBucket . getDocCount ( ) , lessThanOrEqualTo ( ( long ) NUM_SHARDS * MAX_DOCS_PER_AUTHOR ) ) ; } } public void testUnmappedChildAggNoDiversity ( ) throws Exception { SamplerAggregationBuilder sampleAgg = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . addAggregation ( sampleAgg ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Sampler sample = response . getAggregations ( ) . get ( <str> ) ; assertThat ( sample . getDocCount ( ) , equalTo ( <int> l ) ) ; Terms authors = sample . getAggregations ( ) . get ( <str> ) ; assertThat ( authors . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testPartiallyUnmappedChildAggNoDiversity ( ) throws Exception { SamplerAggregationBuilder sampleAgg = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . setExplain ( true ) . addAggregation ( sampleAgg ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Sampler sample = response . getAggregations ( ) . get ( <str> ) ; assertThat ( sample . getDocCount ( ) , greaterThan ( <int> l ) ) ; Terms authors = sample . getAggregations ( ) . get ( <str> ) ; assertThat ( authors . getBuckets ( ) . size ( ) , greaterThan ( <int> ) ) ; } public void testPartiallyUnmappedDiversifyField ( ) throws Exception { SamplerAggregationBuilder sampleAgg = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) . field ( <str> ) . maxDocsPerValue ( <int> ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . addAggregation ( sampleAgg ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Sampler sample = response . getAggregations ( ) . get ( <str> ) ; assertThat ( sample . getDocCount ( ) , greaterThan ( <int> l ) ) ; Terms authors = sample . getAggregations ( ) . get ( <str> ) ; assertThat ( authors . getBuckets ( ) . size ( ) , greaterThan ( <int> ) ) ; } public void testWhollyUnmappedDiversifyField ( ) throws Exception { int MAX_DOCS_PER_AUTHOR = <int> ; SamplerAggregationBuilder sampleAgg = new SamplerAggregationBuilder ( <str> ) . shardSize ( <int> ) ; sampleAgg . field ( <str> ) . maxDocsPerValue ( MAX_DOCS_PER_AUTHOR ) . executionHint ( randomExecutionHint ( ) ) ; sampleAgg . subAggregation ( new TermsBuilder ( <str> ) . field ( <str> ) ) ; SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . setSearchType ( SearchType . QUERY_AND_FETCH ) . setQuery ( new TermQueryBuilder ( <str> , <str> ) ) . setFrom ( <int> ) . setSize ( <int> ) . addAggregation ( sampleAgg ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Sampler sample = response . getAggregations ( ) . get ( <str> ) ; assertThat ( sample . getDocCount ( ) , equalTo ( <int> l ) ) ; Terms authors = sample . getAggregations ( ) . get ( <str> ) ; assertNull ( authors ) ; } } 
