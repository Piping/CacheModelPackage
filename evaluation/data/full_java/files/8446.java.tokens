package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . search . aggregations . bucket . global . Global ; import org . elasticsearch . search . aggregations . metrics . stats . Stats ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . global ; import static org . elasticsearch . search . aggregations . AggregationBuilders . stats ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . sameInstance ; import static org . hamcrest . core . IsNull . notNullValue ; @ESIntegTestCase.SuiteScopeTestCase public class GlobalIT extends ESIntegTestCase { static int numDocs ; @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs / <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i + <int> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , i + <int> ) . field ( <str> , <str> ) . endObject ( ) ) ) ; } for ( int i = numDocs / <int> ; i < numDocs ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i + <int> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , i + <int> ) . field ( <str> , <str> ) . field ( <str> , <str> + i + <int> ) . endObject ( ) ) ) ; } indexRandom ( true , builders ) ; ensureSearchable ( ) ; } public void testWithStatsSubAggregator ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , <str> ) ) . addAggregation ( global ( <str> ) . subAggregation ( stats ( <str> ) . field ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Global global = response . getAggregations ( ) . get ( <str> ) ; assertThat ( global , notNullValue ( ) ) ; assertThat ( global . getName ( ) , equalTo ( <str> ) ) ; assertThat ( global . getDocCount ( ) , equalTo ( ( long ) numDocs ) ) ; assertThat ( ( long ) global . getProperty ( <str> ) , equalTo ( ( long ) numDocs ) ) ; assertThat ( global . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Stats stats = global . getAggregations ( ) . get ( <str> ) ; assertThat ( ( Stats ) global . getProperty ( <str> ) , sameInstance ( stats ) ) ; assertThat ( stats , notNullValue ( ) ) ; assertThat ( stats . getName ( ) , equalTo ( <str> ) ) ; long sum = <int> ; for ( int i = <int> ; i < numDocs ; + + i ) { sum + = i + <int> ; } assertThat ( stats . getAvg ( ) , equalTo ( ( double ) sum / numDocs ) ) ; assertThat ( stats . getMin ( ) , equalTo ( <float> ) ) ; assertThat ( stats . getMax ( ) , equalTo ( ( double ) numDocs ) ) ; assertThat ( stats . getCount ( ) , equalTo ( ( long ) numDocs ) ) ; assertThat ( stats . getSum ( ) , equalTo ( ( double ) sum ) ) ; } public void testNonTopLevel ( ) throws Exception { try { client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , <str> ) ) . addAggregation ( global ( <str> ) . subAggregation ( global ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> + <str> ) ; } catch ( ElasticsearchException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } } 
