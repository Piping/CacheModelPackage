package org . apache . cassandra . schema ; import java . io . IOException ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Method ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import com . google . common . collect . ImmutableMap ; import org . apache . commons . lang3 . builder . EqualsBuilder ; import org . apache . commons . lang3 . builder . HashCodeBuilder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . ParameterizedClass ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . compress . * ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import static java . lang . String . format ; @SuppressWarnings ( <str> ) public final class CompressionParams { private static final Logger logger = LoggerFactory . getLogger ( CompressionParams . class ) ; private static volatile boolean hasLoggedSsTableCompressionWarning ; private static volatile boolean hasLoggedChunkLengthWarning ; private static volatile boolean hasLoggedCrcCheckChanceWarning ; public static final int DEFAULT_CHUNK_LENGTH = <int> ; public static final IVersionedSerializer < CompressionParams > serializer = new Serializer ( ) ; public static final String CLASS = <str> ; public static final String CHUNK_LENGTH_IN_KB = <str> ; public static final String ENABLED = <str> ; public static final CompressionParams DEFAULT = new CompressionParams ( LZ4Compressor . instance , DEFAULT_CHUNK_LENGTH , Collections . emptyMap ( ) ) ; private static final String CRC_CHECK_CHANCE_WARNING = <str> + <str> ; @Deprecated public static final String SSTABLE_COMPRESSION = <str> ; @Deprecated public static final String CHUNK_LENGTH_KB = <str> ; @Deprecated public static final String CRC_CHECK_CHANCE = <str> ; private final ICompressor sstableCompressor ; private final Integer chunkLength ; private final ImmutableMap < String , String > otherOptions ; private volatile double crcCheckChance = <float> ; public static CompressionParams fromMap ( Map < String , String > opts ) { Map < String , String > options = copyOptions ( opts ) ; String sstableCompressionClass ; if ( ! opts . isEmpty ( ) & & isEnabled ( opts ) & & ! containsSstableCompressionClass ( opts ) ) throw new ConfigurationException ( format ( <str> , CLASS ) ) ; if ( ! removeEnabled ( options ) ) { sstableCompressionClass = null ; if ( ! options . isEmpty ( ) ) throw new ConfigurationException ( format ( <str> , ENABLED ) ) ; } else { sstableCompressionClass = removeSstableCompressionClass ( options ) ; } Integer chunkLength = removeChunkLength ( options ) ; CompressionParams cp = new CompressionParams ( sstableCompressionClass , chunkLength , options ) ; cp . validate ( ) ; return cp ; } public Class < ? extends ICompressor > klass ( ) { return sstableCompressor . getClass ( ) ; } public static CompressionParams noCompression ( ) { return new CompressionParams ( ( ICompressor ) null , DEFAULT_CHUNK_LENGTH , Collections . emptyMap ( ) ) ; } public static CompressionParams snappy ( ) { return snappy ( null ) ; } public static CompressionParams snappy ( Integer chunkLength ) { return new CompressionParams ( SnappyCompressor . instance , chunkLength , Collections . emptyMap ( ) ) ; } public static CompressionParams deflate ( ) { return deflate ( null ) ; } public static CompressionParams deflate ( Integer chunkLength ) { return new CompressionParams ( DeflateCompressor . instance , chunkLength , Collections . emptyMap ( ) ) ; } public static CompressionParams lz4 ( ) { return lz4 ( null ) ; } public static CompressionParams lz4 ( Integer chunkLength ) { return new CompressionParams ( LZ4Compressor . instance , chunkLength , Collections . emptyMap ( ) ) ; } public CompressionParams ( String sstableCompressorClass , Integer chunkLength , Map < String , String > otherOptions ) throws ConfigurationException { this ( createCompressor ( parseCompressorClass ( sstableCompressorClass ) , otherOptions ) , chunkLength , otherOptions ) ; } private CompressionParams ( ICompressor sstableCompressor , Integer chunkLength , Map < String , String > otherOptions ) throws ConfigurationException { this . sstableCompressor = sstableCompressor ; this . chunkLength = chunkLength ; this . otherOptions = ImmutableMap . copyOf ( otherOptions ) ; } public CompressionParams copy ( ) { return new CompressionParams ( sstableCompressor , chunkLength , otherOptions ) ; } public boolean isEnabled ( ) { return sstableCompressor ! = null ; } public ICompressor getSstableCompressor ( ) { return sstableCompressor ; } public ImmutableMap < String , String > getOtherOptions ( ) { return otherOptions ; } public int chunkLength ( ) { return chunkLength = = null ? DEFAULT_CHUNK_LENGTH : chunkLength ; } private static Class < ? > parseCompressorClass ( String className ) throws ConfigurationException { if ( className = = null | | className . isEmpty ( ) ) return null ; className = className . contains ( <str> ) ? className : <str> + className ; try { return Class . forName ( className ) ; } catch ( Exception e ) { throw new ConfigurationException ( <str> + className , e ) ; } } private static ICompressor createCompressor ( Class < ? > compressorClass , Map < String , String > compressionOptions ) throws ConfigurationException { if ( compressorClass = = null ) { if ( ! compressionOptions . isEmpty ( ) ) throw new ConfigurationException ( <str> + compressionOptions . keySet ( ) + <str> ) ; return null ; } if ( compressionOptions . containsKey ( CRC_CHECK_CHANCE ) ) { if ( ! hasLoggedCrcCheckChanceWarning ) { logger . warn ( CRC_CHECK_CHANCE_WARNING ) ; hasLoggedCrcCheckChanceWarning = true ; } compressionOptions . remove ( CRC_CHECK_CHANCE ) ; } try { Method method = compressorClass . getMethod ( <str> , Map . class ) ; ICompressor compressor = ( ICompressor ) method . invoke ( null , compressionOptions ) ; for ( String provided : compressionOptions . keySet ( ) ) if ( ! compressor . supportedOptions ( ) . contains ( provided ) ) throw new ConfigurationException ( <str> + provided ) ; return compressor ; } catch ( NoSuchMethodException e ) { throw new ConfigurationException ( <str> , e ) ; } catch ( SecurityException e ) { throw new ConfigurationException ( <str> , e ) ; } catch ( IllegalAccessException e ) { throw new ConfigurationException ( <str> + compressorClass . getName ( ) , e ) ; } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof ConfigurationException ) throw ( ConfigurationException ) e . getTargetException ( ) ; Throwable cause = e . getCause ( ) = = null ? e : e . getCause ( ) ; throw new ConfigurationException ( format ( <str> , compressorClass . getSimpleName ( ) , cause . getClass ( ) . getName ( ) , cause . getMessage ( ) ) , e ) ; } catch ( ExceptionInInitializerError e ) { throw new ConfigurationException ( <str> + compressorClass . getName ( ) ) ; } } public static ICompressor createCompressor ( ParameterizedClass compression ) throws ConfigurationException { return createCompressor ( parseCompressorClass ( compression . class_name ) , copyOptions ( compression . parameters ) ) ; } private static Map < String , String > copyOptions ( Map < ? extends CharSequence , ? extends CharSequence > co ) { if ( co = = null | | co . isEmpty ( ) ) return Collections . < String , String > emptyMap ( ) ; Map < String , String > compressionOptions = new HashMap < > ( ) ; for ( Map . Entry < ? extends CharSequence , ? extends CharSequence > entry : co . entrySet ( ) ) compressionOptions . put ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) . toString ( ) ) ; return compressionOptions ; } private static Integer parseChunkLength ( String chLengthKB ) throws ConfigurationException { if ( chLengthKB = = null ) return null ; try { int parsed = Integer . parseInt ( chLengthKB ) ; if ( parsed > Integer . MAX_VALUE / <int> ) throw new ConfigurationException ( format ( <str> , CHUNK_LENGTH_IN_KB , parsed ) ) ; return <int> * parsed ; } catch ( NumberFormatException e ) { throw new ConfigurationException ( <str> + CHUNK_LENGTH_IN_KB , e ) ; } } private static Integer removeChunkLength ( Map < String , String > options ) { if ( options . containsKey ( CHUNK_LENGTH_IN_KB ) ) { if ( options . containsKey ( CHUNK_LENGTH_KB ) ) { throw new ConfigurationException ( format ( <str> , CHUNK_LENGTH_KB , CHUNK_LENGTH_IN_KB ) ) ; } return parseChunkLength ( options . remove ( CHUNK_LENGTH_IN_KB ) ) ; } if ( options . containsKey ( CHUNK_LENGTH_KB ) ) { if ( ! hasLoggedChunkLengthWarning ) { hasLoggedChunkLengthWarning = true ; logger . warn ( format ( <str> , CHUNK_LENGTH_KB , CHUNK_LENGTH_IN_KB ) ) ; } return parseChunkLength ( options . remove ( CHUNK_LENGTH_KB ) ) ; } return null ; } public static boolean containsSstableCompressionClass ( Map < String , String > options ) { return options . containsKey ( CLASS ) | | options . containsKey ( SSTABLE_COMPRESSION ) ; } private static String removeSstableCompressionClass ( Map < String , String > options ) { if ( options . containsKey ( CLASS ) ) { if ( options . containsKey ( SSTABLE_COMPRESSION ) ) throw new ConfigurationException ( format ( <str> , SSTABLE_COMPRESSION , CLASS ) ) ; String clazz = options . remove ( CLASS ) ; if ( clazz . isEmpty ( ) ) throw new ConfigurationException ( format ( <str> , CLASS ) ) ; return clazz ; } if ( options . containsKey ( SSTABLE_COMPRESSION ) & & ! hasLoggedSsTableCompressionWarning ) { hasLoggedSsTableCompressionWarning = true ; logger . warn ( format ( <str> , SSTABLE_COMPRESSION , CLASS ) ) ; } return options . remove ( SSTABLE_COMPRESSION ) ; } public static boolean isEnabled ( Map < String , String > options ) { String enabled = options . get ( ENABLED ) ; return enabled = = null | | Boolean . parseBoolean ( enabled ) ; } private static boolean removeEnabled ( Map < String , String > options ) { String enabled = options . remove ( ENABLED ) ; return enabled = = null | | Boolean . parseBoolean ( enabled ) ; } public void validate ( ) throws ConfigurationException { if ( chunkLength ! = null ) { if ( chunkLength < = <int> ) throw new ConfigurationException ( <str> + CHUNK_LENGTH_IN_KB ) ; int c = chunkLength ; boolean found = false ; while ( c ! = <int> ) { if ( ( c & <hex> ) ! = <int> ) { if ( found ) throw new ConfigurationException ( CHUNK_LENGTH_IN_KB + <str> ) ; else found = true ; } c > > = <int> ; } } } public Map < String , String > asMap ( ) { if ( ! isEnabled ( ) ) return Collections . singletonMap ( ENABLED , <str> ) ; Map < String , String > options = new HashMap < > ( otherOptions ) ; options . put ( CLASS , sstableCompressor . getClass ( ) . getName ( ) ) ; options . put ( CHUNK_LENGTH_IN_KB , chunkLengthInKB ( ) ) ; return options ; } public String chunkLengthInKB ( ) { return String . valueOf ( chunkLength ( ) / <int> ) ; } public void setCrcCheckChance ( double crcCheckChance ) { this . crcCheckChance = crcCheckChance ; } public double getCrcCheckChance ( ) { return crcCheckChance ; } @Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } else if ( obj = = null | | obj . getClass ( ) ! = getClass ( ) ) { return false ; } CompressionParams cp = ( CompressionParams ) obj ; return new EqualsBuilder ( ) . append ( sstableCompressor , cp . sstableCompressor ) . append ( chunkLength ( ) , cp . chunkLength ( ) ) . append ( otherOptions , cp . otherOptions ) . isEquals ( ) ; } @Override public int hashCode ( ) { return new HashCodeBuilder ( <int> , <int> ) . append ( sstableCompressor ) . append ( chunkLength ( ) ) . append ( otherOptions ) . toHashCode ( ) ; } static class Serializer implements IVersionedSerializer < CompressionParams > { public void serialize ( CompressionParams parameters , DataOutputPlus out , int version ) throws IOException { out . writeUTF ( parameters . sstableCompressor . getClass ( ) . getSimpleName ( ) ) ; out . writeInt ( parameters . otherOptions . size ( ) ) ; for ( Map . Entry < String , String > entry : parameters . otherOptions . entrySet ( ) ) { out . writeUTF ( entry . getKey ( ) ) ; out . writeUTF ( entry . getValue ( ) ) ; } out . writeInt ( parameters . chunkLength ( ) ) ; } public CompressionParams deserialize ( DataInputPlus in , int version ) throws IOException { String compressorName = in . readUTF ( ) ; int optionCount = in . readInt ( ) ; Map < String , String > options = new HashMap < > ( ) ; for ( int i = <int> ; i < optionCount ; + + i ) { String key = in . readUTF ( ) ; String value = in . readUTF ( ) ; options . put ( key , value ) ; } int chunkLength = in . readInt ( ) ; CompressionParams parameters ; try { parameters = new CompressionParams ( compressorName , chunkLength , options ) ; } catch ( ConfigurationException e ) { throw new RuntimeException ( <str> , e ) ; } return parameters ; } public long serializedSize ( CompressionParams parameters , int version ) { long size = TypeSizes . sizeof ( parameters . sstableCompressor . getClass ( ) . getSimpleName ( ) ) ; size + = TypeSizes . sizeof ( parameters . otherOptions . size ( ) ) ; for ( Map . Entry < String , String > entry : parameters . otherOptions . entrySet ( ) ) { size + = TypeSizes . sizeof ( entry . getKey ( ) ) ; size + = TypeSizes . sizeof ( entry . getValue ( ) ) ; } size + = TypeSizes . sizeof ( parameters . chunkLength ( ) ) ; return size ; } } } 
