package org . elasticsearch . search . aggregations . bucket ; import org . elasticsearch . common . lease . Releasable ; import org . elasticsearch . common . util . BigArrays ; import org . elasticsearch . common . util . IntArray ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorBase ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregations ; import org . elasticsearch . search . aggregations . LeafBucketCollector ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import java . io . IOException ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; public abstract class BucketsAggregator extends AggregatorBase { private final BigArrays bigArrays ; private IntArray docCounts ; public BucketsAggregator ( String name , AggregatorFactories factories , AggregationContext context , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { super ( name , factories , context , parent , pipelineAggregators , metaData ) ; bigArrays = context . bigArrays ( ) ; docCounts = bigArrays . newIntArray ( <int> , true ) ; } public final long maxBucketOrd ( ) { return docCounts . size ( ) ; } public final void grow ( long maxBucketOrd ) { docCounts = bigArrays . grow ( docCounts , maxBucketOrd ) ; } public final void collectBucket ( LeafBucketCollector subCollector , int doc , long bucketOrd ) throws IOException { grow ( bucketOrd + <int> ) ; collectExistingBucket ( subCollector , doc , bucketOrd ) ; } public final void collectExistingBucket ( LeafBucketCollector subCollector , int doc , long bucketOrd ) throws IOException { docCounts . increment ( bucketOrd , <int> ) ; subCollector . collect ( doc , bucketOrd ) ; } public IntArray getDocCounts ( ) { return docCounts ; } public final void incrementBucketDocCount ( long bucketOrd , int inc ) { docCounts = bigArrays . grow ( docCounts , bucketOrd + <int> ) ; docCounts . increment ( bucketOrd , inc ) ; } public final int bucketDocCount ( long bucketOrd ) { if ( bucketOrd > = docCounts . size ( ) ) { return <int> ; } else { return docCounts . get ( bucketOrd ) ; } } protected final InternalAggregations bucketAggregations ( long bucket ) throws IOException { final InternalAggregation [ ] aggregations = new InternalAggregation [ subAggregators . length ] ; for ( int i = <int> ; i < subAggregators . length ; i + + ) { aggregations [ i ] = subAggregators [ i ] . buildAggregation ( bucket ) ; } return new InternalAggregations ( Arrays . asList ( aggregations ) ) ; } protected final InternalAggregations bucketEmptyAggregations ( ) { final InternalAggregation [ ] aggregations = new InternalAggregation [ subAggregators . length ] ; for ( int i = <int> ; i < subAggregators . length ; i + + ) { aggregations [ i ] = subAggregators [ i ] . buildEmptyAggregation ( ) ; } return new InternalAggregations ( Arrays . asList ( aggregations ) ) ; } @Override public final void close ( ) { try ( Releasable releasable = docCounts ) { super . close ( ) ; } } } 
