package com . google . common . base ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import java . io . Serializable ; import java . util . Iterator ; import javax . annotation . Nullable ; @Beta @GwtCompatible public abstract class Converter < A , B > implements Function < A , B > { private final boolean handleNullAutomatically ; private transient Converter < B , A > reverse ; protected Converter ( ) { this ( true ) ; } Converter ( boolean handleNullAutomatically ) { this . handleNullAutomatically = handleNullAutomatically ; } protected abstract B doForward ( A a ) ; protected abstract A doBackward ( B b ) ; @Nullable public final B convert ( @Nullable A a ) { return correctedDoForward ( a ) ; } @Nullable B correctedDoForward ( @Nullable A a ) { if ( handleNullAutomatically ) { return a = = null ? null : checkNotNull ( doForward ( a ) ) ; } else { return doForward ( a ) ; } } @Nullable A correctedDoBackward ( @Nullable B b ) { if ( handleNullAutomatically ) { return b = = null ? null : checkNotNull ( doBackward ( b ) ) ; } else { return doBackward ( b ) ; } } public Iterable < B > convertAll ( final Iterable < ? extends A > fromIterable ) { checkNotNull ( fromIterable , <str> ) ; return new Iterable < B > ( ) { @Override public Iterator < B > iterator ( ) { return new Iterator < B > ( ) { private final Iterator < ? extends A > fromIterator = fromIterable . iterator ( ) ; @Override public boolean hasNext ( ) { return fromIterator . hasNext ( ) ; } @Override public B next ( ) { return convert ( fromIterator . next ( ) ) ; } @Override public void remove ( ) { fromIterator . remove ( ) ; } } ; } } ; } public Converter < B , A > reverse ( ) { Converter < B , A > result = reverse ; return ( result = = null ) ? reverse = new ReverseConverter < A , B > ( this ) : result ; } private static final class ReverseConverter < A , B > extends Converter < B , A > implements Serializable { final Converter < A , B > original ; ReverseConverter ( Converter < A , B > original ) { this . original = original ; } @Override protected A doForward ( B b ) { throw new AssertionError ( ) ; } @Override protected B doBackward ( A a ) { throw new AssertionError ( ) ; } @Override @Nullable A correctedDoForward ( @Nullable B b ) { return original . correctedDoBackward ( b ) ; } @Override @Nullable B correctedDoBackward ( @Nullable A a ) { return original . correctedDoForward ( a ) ; } @Override public Converter < A , B > reverse ( ) { return original ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof ReverseConverter ) { ReverseConverter < ? , ? > that = ( ReverseConverter < ? , ? > ) object ; return this . original . equals ( that . original ) ; } return false ; } @Override public int hashCode ( ) { return ~ original . hashCode ( ) ; } @Override public String toString ( ) { return original + <str> ; } private static final long serialVersionUID = <int> L ; } public final < C > Converter < A , C > andThen ( Converter < B , C > secondConverter ) { return doAndThen ( secondConverter ) ; } < C > Converter < A , C > doAndThen ( Converter < B , C > secondConverter ) { return new ConverterComposition < A , B , C > ( this , checkNotNull ( secondConverter ) ) ; } private static final class ConverterComposition < A , B , C > extends Converter < A , C > implements Serializable { final Converter < A , B > first ; final Converter < B , C > second ; ConverterComposition ( Converter < A , B > first , Converter < B , C > second ) { this . first = first ; this . second = second ; } @Override protected C doForward ( A a ) { throw new AssertionError ( ) ; } @Override protected A doBackward ( C c ) { throw new AssertionError ( ) ; } @Override @Nullable C correctedDoForward ( @Nullable A a ) { return second . correctedDoForward ( first . correctedDoForward ( a ) ) ; } @Override @Nullable A correctedDoBackward ( @Nullable C c ) { return first . correctedDoBackward ( second . correctedDoBackward ( c ) ) ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof ConverterComposition ) { ConverterComposition < ? , ? , ? > that = ( ConverterComposition < ? , ? , ? > ) object ; return this . first . equals ( that . first ) & & this . second . equals ( that . second ) ; } return false ; } @Override public int hashCode ( ) { return <int> * first . hashCode ( ) + second . hashCode ( ) ; } @Override public String toString ( ) { return first + <str> + second + <str> ; } private static final long serialVersionUID = <int> L ; } @Deprecated @Override @Nullable public final B apply ( @Nullable A a ) { return convert ( a ) ; } @Override public boolean equals ( @Nullable Object object ) { return super . equals ( object ) ; } public static < A , B > Converter < A , B > from ( Function < ? super A , ? extends B > forwardFunction , Function < ? super B , ? extends A > backwardFunction ) { return new FunctionBasedConverter < A , B > ( forwardFunction , backwardFunction ) ; } private static final class FunctionBasedConverter < A , B > extends Converter < A , B > implements Serializable { private final Function < ? super A , ? extends B > forwardFunction ; private final Function < ? super B , ? extends A > backwardFunction ; private FunctionBasedConverter ( Function < ? super A , ? extends B > forwardFunction , Function < ? super B , ? extends A > backwardFunction ) { this . forwardFunction = checkNotNull ( forwardFunction ) ; this . backwardFunction = checkNotNull ( backwardFunction ) ; } @Override protected B doForward ( A a ) { return forwardFunction . apply ( a ) ; } @Override protected A doBackward ( B b ) { return backwardFunction . apply ( b ) ; } @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof FunctionBasedConverter ) { FunctionBasedConverter < ? , ? > that = ( FunctionBasedConverter < ? , ? > ) object ; return this . forwardFunction . equals ( that . forwardFunction ) & & this . backwardFunction . equals ( that . backwardFunction ) ; } return false ; } @Override public int hashCode ( ) { return forwardFunction . hashCode ( ) * <int> + backwardFunction . hashCode ( ) ; } @Override public String toString ( ) { return <str> + forwardFunction + <str> + backwardFunction + <str> ; } } @SuppressWarnings ( <str> ) public static < T > Converter < T , T > identity ( ) { return ( IdentityConverter < T > ) IdentityConverter . INSTANCE ; } private static final class IdentityConverter < T > extends Converter < T , T > implements Serializable { static final IdentityConverter INSTANCE = new IdentityConverter ( ) ; @Override protected T doForward ( T t ) { return t ; } @Override protected T doBackward ( T t ) { return t ; } @Override public IdentityConverter < T > reverse ( ) { return this ; } @Override < S > Converter < T , S > doAndThen ( Converter < T , S > otherConverter ) { return checkNotNull ( otherConverter , <str> ) ; } @Override public String toString ( ) { return <str> ; } private Object readResolve ( ) { return INSTANCE ; } private static final long serialVersionUID = <int> L ; } } 
