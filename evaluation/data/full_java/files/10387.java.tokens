package com . google . common . collect ; import static com . google . common . collect . testing . Helpers . nefariousMapEntry ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Supplier ; import com . google . common . testing . SerializableTester ; import junit . framework . TestCase ; import java . io . Serializable ; import java . util . AbstractMap ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Queue ; import java . util . RandomAccess ; import java . util . Set ; import java . util . SortedSet ; @GwtCompatible ( emulated = true ) public class MapConstraintsTest extends TestCase { private static final String TEST_KEY = <str> ; private static final Integer TEST_VALUE = <int> ; static final class TestKeyException extends IllegalArgumentException { private static final long serialVersionUID = <int> ; } static final class TestValueException extends IllegalArgumentException { private static final long serialVersionUID = <int> ; } static final MapConstraint < String , Integer > TEST_CONSTRAINT = new TestConstraint ( ) ; private static final class TestConstraint implements MapConstraint < String , Integer > , Serializable { @Override public void checkKeyValue ( String key , Integer value ) { if ( TEST_KEY . equals ( key ) ) { throw new TestKeyException ( ) ; } if ( TEST_VALUE . equals ( value ) ) { throw new TestValueException ( ) ; } } private static final long serialVersionUID = <int> ; } public void testNotNull ( ) { MapConstraint < Object , Object > constraint = MapConstraints . notNull ( ) ; constraint . checkKeyValue ( <str> , <int> ) ; assertEquals ( <str> , constraint . toString ( ) ) ; try { constraint . checkKeyValue ( null , <int> ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } try { constraint . checkKeyValue ( <str> , null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } try { constraint . checkKeyValue ( null , null ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } } public void testConstrainedMapLegal ( ) { Map < String , Integer > map = Maps . newLinkedHashMap ( ) ; Map < String , Integer > constrained = MapConstraints . constrainedMap ( map , TEST_CONSTRAINT ) ; map . put ( TEST_KEY , TEST_VALUE ) ; constrained . put ( <str> , <int> ) ; map . putAll ( ImmutableMap . of ( <str> , <int> ) ) ; constrained . putAll ( ImmutableMap . of ( <str> , <int> ) ) ; assertTrue ( map . equals ( constrained ) ) ; assertTrue ( constrained . equals ( map ) ) ; assertEquals ( map . entrySet ( ) , constrained . entrySet ( ) ) ; assertEquals ( map . keySet ( ) , constrained . keySet ( ) ) ; assertEquals ( HashMultiset . create ( map . values ( ) ) , HashMultiset . create ( constrained . values ( ) ) ) ; assertThat ( map . values ( ) ) . isNotInstanceOf ( Serializable . class ) ; assertEquals ( map . toString ( ) , constrained . toString ( ) ) ; assertEquals ( map . hashCode ( ) , constrained . hashCode ( ) ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( TEST_KEY , TEST_VALUE ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } public void testConstrainedMapIllegal ( ) { Map < String , Integer > map = Maps . newLinkedHashMap ( ) ; Map < String , Integer > constrained = MapConstraints . constrainedMap ( map , TEST_CONSTRAINT ) ; try { constrained . put ( TEST_KEY , TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . put ( <str> , TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . put ( TEST_KEY , <int> ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . putAll ( ImmutableMap . of ( <str> , <int> , TEST_KEY , <int> ) ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } assertEquals ( Collections . emptySet ( ) , map . entrySet ( ) ) ; assertEquals ( Collections . emptySet ( ) , constrained . entrySet ( ) ) ; } public void testConstrainedBiMapLegal ( ) { BiMap < String , Integer > map = new AbstractBiMap < String , Integer > ( Maps . < String , Integer > newLinkedHashMap ( ) , Maps . < Integer , String > newLinkedHashMap ( ) ) { } ; BiMap < String , Integer > constrained = MapConstraints . constrainedBiMap ( map , TEST_CONSTRAINT ) ; map . put ( TEST_KEY , TEST_VALUE ) ; constrained . put ( <str> , <int> ) ; map . putAll ( ImmutableMap . of ( <str> , <int> ) ) ; constrained . putAll ( ImmutableMap . of ( <str> , <int> ) ) ; assertTrue ( map . equals ( constrained ) ) ; assertTrue ( constrained . equals ( map ) ) ; assertEquals ( map . entrySet ( ) , constrained . entrySet ( ) ) ; assertEquals ( map . keySet ( ) , constrained . keySet ( ) ) ; assertEquals ( map . values ( ) , constrained . values ( ) ) ; assertEquals ( map . toString ( ) , constrained . toString ( ) ) ; assertEquals ( map . hashCode ( ) , constrained . hashCode ( ) ) ; assertThat ( map . entrySet ( ) ) . containsExactly ( Maps . immutableEntry ( TEST_KEY , TEST_VALUE ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; } public void testConstrainedBiMapIllegal ( ) { BiMap < String , Integer > map = new AbstractBiMap < String , Integer > ( Maps . < String , Integer > newLinkedHashMap ( ) , Maps . < Integer , String > newLinkedHashMap ( ) ) { } ; BiMap < String , Integer > constrained = MapConstraints . constrainedBiMap ( map , TEST_CONSTRAINT ) ; try { constrained . put ( TEST_KEY , TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . put ( <str> , TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . put ( TEST_KEY , <int> ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . putAll ( ImmutableMap . of ( <str> , <int> , TEST_KEY , <int> ) ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . forcePut ( TEST_KEY , <int> ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . inverse ( ) . forcePut ( TEST_VALUE , <str> ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . inverse ( ) . forcePut ( <int> , TEST_KEY ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } assertEquals ( Collections . emptySet ( ) , map . entrySet ( ) ) ; assertEquals ( Collections . emptySet ( ) , constrained . entrySet ( ) ) ; } public void testConstrainedMultimapLegal ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; multimap . put ( TEST_KEY , TEST_VALUE ) ; constrained . put ( <str> , <int> ) ; multimap . get ( <str> ) . add ( <int> ) ; constrained . get ( <str> ) . add ( <int> ) ; multimap . get ( <str> ) . addAll ( Arrays . asList ( <int> ) ) ; constrained . get ( <str> ) . addAll ( Arrays . asList ( <int> ) ) ; multimap . putAll ( <str> , Arrays . asList ( <int> ) ) ; constrained . putAll ( <str> , Arrays . asList ( <int> ) ) ; multimap . putAll ( new ImmutableMultimap . Builder < String , Integer > ( ) . put ( <str> , <int> ) . build ( ) ) ; constrained . putAll ( new ImmutableMultimap . Builder < String , Integer > ( ) . put ( <str> , <int> ) . build ( ) ) ; multimap . putAll ( new ImmutableMultimap . Builder < String , Integer > ( ) . put ( <str> , <int> ) . build ( ) ) ; constrained . putAll ( new ImmutableMultimap . Builder < String , Integer > ( ) . put ( <str> , <int> ) . build ( ) ) ; assertTrue ( multimap . equals ( constrained ) ) ; assertTrue ( constrained . equals ( multimap ) ) ; assertThat ( ImmutableList . copyOf ( multimap . entries ( ) ) ) . isEqualTo ( ImmutableList . copyOf ( constrained . entries ( ) ) ) ; assertThat ( constrained . asMap ( ) . get ( <str> ) ) . contains ( <int> ) ; assertNull ( constrained . asMap ( ) . get ( <str> ) ) ; assertEquals ( multimap . asMap ( ) , constrained . asMap ( ) ) ; assertEquals ( multimap . values ( ) , constrained . values ( ) ) ; assertEquals ( multimap . keys ( ) , constrained . keys ( ) ) ; assertEquals ( multimap . keySet ( ) , constrained . keySet ( ) ) ; assertEquals ( multimap . toString ( ) , constrained . toString ( ) ) ; assertEquals ( multimap . hashCode ( ) , constrained . hashCode ( ) ) ; assertThat ( multimap . entries ( ) ) . containsExactly ( Maps . immutableEntry ( TEST_KEY , TEST_VALUE ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( <str> , <int> ) ) . inOrder ( ) ; assertThat ( constrained . asMap ( ) . values ( ) ) . isNotInstanceOf ( Serializable . class ) ; Iterator < Collection < Integer > > iterator = constrained . asMap ( ) . values ( ) . iterator ( ) ; iterator . next ( ) ; iterator . next ( ) . add ( <int> ) ; assertTrue ( multimap . containsEntry ( <str> , <int> ) ) ; } public void testConstrainedTypePreservingList ( ) { ListMultimap < String , Integer > multimap = MapConstraints . constrainedListMultimap ( LinkedListMultimap . < String , Integer > create ( ) , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; Map . Entry < String , Collection < Integer > > entry = multimap . asMap ( ) . entrySet ( ) . iterator ( ) . next ( ) ; assertTrue ( entry . getValue ( ) instanceof List ) ; assertFalse ( multimap . entries ( ) instanceof Set ) ; assertFalse ( multimap . get ( <str> ) instanceof RandomAccess ) ; } public void testConstrainedTypePreservingRandomAccessList ( ) { ListMultimap < String , Integer > multimap = MapConstraints . constrainedListMultimap ( ArrayListMultimap . < String , Integer > create ( ) , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; Map . Entry < String , Collection < Integer > > entry = multimap . asMap ( ) . entrySet ( ) . iterator ( ) . next ( ) ; assertTrue ( entry . getValue ( ) instanceof List ) ; assertFalse ( multimap . entries ( ) instanceof Set ) ; assertTrue ( multimap . get ( <str> ) instanceof RandomAccess ) ; } public void testConstrainedTypePreservingSet ( ) { SetMultimap < String , Integer > multimap = MapConstraints . constrainedSetMultimap ( LinkedHashMultimap . < String , Integer > create ( ) , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; Map . Entry < String , Collection < Integer > > entry = multimap . asMap ( ) . entrySet ( ) . iterator ( ) . next ( ) ; assertTrue ( entry . getValue ( ) instanceof Set ) ; } public void testConstrainedTypePreservingSortedSet ( ) { Comparator < Integer > comparator = Collections . reverseOrder ( ) ; SortedSetMultimap < String , Integer > delegate = TreeMultimap . create ( Ordering . < String > natural ( ) , comparator ) ; SortedSetMultimap < String , Integer > multimap = MapConstraints . constrainedSortedSetMultimap ( delegate , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; Map . Entry < String , Collection < Integer > > entry = multimap . asMap ( ) . entrySet ( ) . iterator ( ) . next ( ) ; assertTrue ( entry . getValue ( ) instanceof SortedSet ) ; assertSame ( comparator , multimap . valueComparator ( ) ) ; assertSame ( comparator , multimap . get ( <str> ) . comparator ( ) ) ; } @SuppressWarnings ( <str> ) public void testConstrainedMultimapIllegal ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; try { constrained . put ( TEST_KEY , <int> ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . put ( <str> , TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . put ( TEST_KEY , TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . get ( TEST_KEY ) . add ( <int> ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . get ( <str> ) . add ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . get ( TEST_KEY ) . add ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . get ( TEST_KEY ) . addAll ( Arrays . asList ( <int> ) ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . get ( <str> ) . addAll ( Arrays . asList ( <int> , TEST_VALUE ) ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . get ( TEST_KEY ) . addAll ( Arrays . asList ( <int> , TEST_VALUE ) ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . putAll ( TEST_KEY , Arrays . asList ( <int> ) ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . putAll ( <str> , Arrays . asList ( <int> , TEST_VALUE ) ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . putAll ( TEST_KEY , Arrays . asList ( <int> , TEST_VALUE ) ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . putAll ( new ImmutableMultimap . Builder < String , Integer > ( ) . put ( TEST_KEY , <int> ) . put ( <str> , <int> ) . build ( ) ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . putAll ( new ImmutableMultimap . Builder < String , Integer > ( ) . put ( <str> , TEST_VALUE ) . put ( <str> , <int> ) . build ( ) ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . putAll ( new ImmutableMultimap . Builder < String , Integer > ( ) . put ( TEST_KEY , TEST_VALUE ) . put ( <str> , <int> ) . build ( ) ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . entries ( ) . add ( Maps . immutableEntry ( TEST_KEY , <int> ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { constrained . entries ( ) . addAll ( Arrays . asList ( Maps . immutableEntry ( <str> , <int> ) , Maps . immutableEntry ( TEST_KEY , <int> ) ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } assertTrue ( multimap . isEmpty ( ) ) ; assertTrue ( constrained . isEmpty ( ) ) ; constrained . put ( <str> , <int> ) ; try { constrained . asMap ( ) . get ( <str> ) . add ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . asMap ( ) . values ( ) . iterator ( ) . next ( ) . add ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { ( ( Collection < Integer > ) constrained . asMap ( ) . values ( ) . toArray ( ) [ <int> ] ) . add ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } assertThat ( ImmutableList . copyOf ( multimap . entries ( ) ) ) . isEqualTo ( ImmutableList . copyOf ( constrained . entries ( ) ) ) ; assertEquals ( multimap . asMap ( ) , constrained . asMap ( ) ) ; assertEquals ( multimap . values ( ) , constrained . values ( ) ) ; assertEquals ( multimap . keys ( ) , constrained . keys ( ) ) ; assertEquals ( multimap . keySet ( ) , constrained . keySet ( ) ) ; assertEquals ( multimap . toString ( ) , constrained . toString ( ) ) ; assertEquals ( multimap . hashCode ( ) , constrained . hashCode ( ) ) ; } private static class QueueSupplier implements Supplier < Queue < Integer > > { @Override public Queue < Integer > get ( ) { return new LinkedList < Integer > ( ) ; } } public void testConstrainedMultimapQueue ( ) { Multimap < String , Integer > multimap = Multimaps . newMultimap ( new HashMap < String , Collection < Integer > > ( ) , new QueueSupplier ( ) ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; constrained . put ( <str> , <int> ) ; assertTrue ( constrained . get ( <str> ) . contains ( <int> ) ) ; assertTrue ( multimap . get ( <str> ) . contains ( <int> ) ) ; try { constrained . put ( TEST_KEY , <int> ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } try { constrained . put ( <str> , TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . get ( <str> ) . add ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } try { constrained . get ( TEST_KEY ) . add ( <int> ) ; fail ( <str> ) ; } catch ( TestKeyException expected ) { } assertEquals ( <int> , constrained . size ( ) ) ; assertEquals ( <int> , multimap . size ( ) ) ; } public void testMapEntrySetToArray ( ) { Map < String , Integer > map = Maps . newLinkedHashMap ( ) ; Map < String , Integer > constrained = MapConstraints . constrainedMap ( map , TEST_CONSTRAINT ) ; map . put ( <str> , <int> ) ; @SuppressWarnings ( <str> ) Map . Entry < String , Integer > entry = ( Map . Entry ) constrained . entrySet ( ) . toArray ( ) [ <int> ] ; try { entry . setValue ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } assertFalse ( map . containsValue ( TEST_VALUE ) ) ; } public void testMapEntrySetContainsNefariousEntry ( ) { Map < String , Integer > map = Maps . newTreeMap ( ) ; Map < String , Integer > constrained = MapConstraints . constrainedMap ( map , TEST_CONSTRAINT ) ; map . put ( <str> , <int> ) ; Map . Entry < String , Integer > nefariousEntry = nefariousMapEntry ( TEST_KEY , TEST_VALUE ) ; Set < Map . Entry < String , Integer > > entries = constrained . entrySet ( ) ; assertFalse ( entries . contains ( nefariousEntry ) ) ; assertFalse ( map . containsValue ( TEST_VALUE ) ) ; assertFalse ( entries . containsAll ( Collections . singleton ( nefariousEntry ) ) ) ; assertFalse ( map . containsValue ( TEST_VALUE ) ) ; } public void testMultimapAsMapEntriesToArray ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; @SuppressWarnings ( <str> ) Map . Entry < String , Collection < Integer > > entry = ( Map . Entry < String , Collection < Integer > > ) constrained . asMap ( ) . entrySet ( ) . toArray ( ) [ <int> ] ; try { entry . setValue ( Collections . < Integer > emptySet ( ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { entry . getValue ( ) . add ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; } public void testMultimapAsMapValuesToArray ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; @SuppressWarnings ( <str> ) Collection < Integer > collection = ( Collection < Integer > ) constrained . asMap ( ) . values ( ) . toArray ( ) [ <int> ] ; try { collection . add ( TEST_VALUE ) ; fail ( <str> ) ; } catch ( TestValueException expected ) { } assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; } public void testMultimapEntriesContainsNefariousEntry ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; Map . Entry < String , Integer > nefariousEntry = nefariousMapEntry ( TEST_KEY , TEST_VALUE ) ; Collection < Map . Entry < String , Integer > > entries = constrained . entries ( ) ; assertFalse ( entries . contains ( nefariousEntry ) ) ; assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; assertFalse ( entries . containsAll ( Collections . singleton ( nefariousEntry ) ) ) ; assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; } public void testMultimapEntriesRemoveNefariousEntry ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; Map . Entry < String , Integer > nefariousEntry = nefariousMapEntry ( TEST_KEY , TEST_VALUE ) ; Collection < Map . Entry < String , Integer > > entries = constrained . entries ( ) ; assertFalse ( entries . remove ( nefariousEntry ) ) ; assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; try { assertFalse ( entries . removeAll ( Collections . singleton ( nefariousEntry ) ) ) ; } catch ( TestValueException tolerated ) { } assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; } public void testMultimapAsMapEntriesContainsNefariousEntry ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; Map . Entry < String , ? extends Collection < Integer > > nefariousEntry = nefariousMapEntry ( TEST_KEY , Collections . singleton ( TEST_VALUE ) ) ; Set < Map . Entry < String , Collection < Integer > > > entries = constrained . asMap ( ) . entrySet ( ) ; assertFalse ( entries . contains ( nefariousEntry ) ) ; assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; assertFalse ( entries . containsAll ( Collections . singleton ( nefariousEntry ) ) ) ; assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; } public void testMultimapAsMapEntriesRemoveNefariousEntry ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; multimap . put ( <str> , <int> ) ; Map . Entry < String , ? extends Collection < Integer > > nefariousEntry = nefariousMapEntry ( TEST_KEY , Collections . singleton ( TEST_VALUE ) ) ; Set < Map . Entry < String , Collection < Integer > > > entries = constrained . asMap ( ) . entrySet ( ) ; assertFalse ( entries . remove ( nefariousEntry ) ) ; assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; assertFalse ( entries . removeAll ( Collections . singleton ( nefariousEntry ) ) ) ; assertFalse ( multimap . containsValue ( TEST_VALUE ) ) ; } public void testNefariousMapPutAll ( ) { Map < String , Integer > map = Maps . newLinkedHashMap ( ) ; Map < String , Integer > constrained = MapConstraints . constrainedMap ( map , TEST_CONSTRAINT ) ; Map < String , Integer > onceIterable = onceIterableMap ( <str> , <int> ) ; constrained . putAll ( onceIterable ) ; assertEquals ( ( Integer ) <int> , constrained . get ( <str> ) ) ; } public void testNefariousMultimapPutAllIterable ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; Collection < Integer > onceIterable = ConstraintsTest . onceIterableCollection ( <int> ) ; constrained . putAll ( <str> , onceIterable ) ; assertEquals ( ImmutableList . of ( <int> ) , constrained . get ( <str> ) ) ; } public void testNefariousMultimapPutAllMultimap ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; Multimap < String , Integer > onceIterable = Multimaps . forMap ( onceIterableMap ( <str> , <int> ) ) ; constrained . putAll ( onceIterable ) ; assertEquals ( ImmutableList . of ( <int> ) , constrained . get ( <str> ) ) ; } public void testNefariousMultimapGetAddAll ( ) { Multimap < String , Integer > multimap = LinkedListMultimap . create ( ) ; Multimap < String , Integer > constrained = MapConstraints . constrainedMultimap ( multimap , TEST_CONSTRAINT ) ; Collection < Integer > onceIterable = ConstraintsTest . onceIterableCollection ( <int> ) ; constrained . get ( <str> ) . addAll ( onceIterable ) ; assertEquals ( ImmutableList . of ( <int> ) , constrained . get ( <str> ) ) ; } static < K , V > Map < K , V > onceIterableMap ( K key , V value ) { final Map . Entry < K , V > entry = Maps . immutableEntry ( key , value ) ; return new AbstractMap < K , V > ( ) { boolean iteratorCalled ; @Override public int size ( ) { return <int> ; } @Override public Set < Entry < K , V > > entrySet ( ) { return new ForwardingSet < Entry < K , V > > ( ) { @Override protected Set < Entry < K , V > > delegate ( ) { return Collections . singleton ( entry ) ; } @Override public Iterator < Entry < K , V > > iterator ( ) { assertFalse ( <str> , iteratorCalled ) ; iteratorCalled = true ; return super . iterator ( ) ; } } ; } @Override public Set < K > keySet ( ) { throw new UnsupportedOperationException ( ) ; } @Override public Collection < V > values ( ) { throw new UnsupportedOperationException ( ) ; } } ; } @GwtIncompatible ( <str> ) public void testSerialization ( ) { assertSame ( MapConstraints . notNull ( ) , SerializableTester . reserialize ( MapConstraints . notNull ( ) ) ) ; } } 
