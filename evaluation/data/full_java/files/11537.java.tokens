package org . gradle . api . internal . file . collections ; import org . gradle . api . GradleException ; import org . gradle . api . file . FileTreeElement ; import org . gradle . api . file . FileVisitDetails ; import org . gradle . api . file . FileVisitor ; import org . gradle . api . file . RelativePath ; import org . gradle . api . internal . file . DefaultFileVisitDetails ; import org . gradle . api . internal . file . FileSystemSubset ; import org . gradle . api . internal . file . pattern . PatternStep ; import org . gradle . api . internal . file . pattern . PatternStepFactory ; import org . gradle . api . specs . Spec ; import org . gradle . api . specs . Specs ; import org . gradle . api . tasks . util . PatternSet ; import org . gradle . internal . nativeintegration . filesystem . FileSystem ; import org . gradle . internal . nativeintegration . services . FileSystems ; import java . io . File ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; public class SingleIncludePatternFileTree implements MinimalFileTree { private final File baseDir ; private final String includePattern ; private final List < String > patternSegments ; private final Spec < FileTreeElement > excludeSpec ; private final FileSystem fileSystem = FileSystems . getDefault ( ) ; public SingleIncludePatternFileTree ( File baseDir , String includePattern ) { this ( baseDir , includePattern , Specs . < FileTreeElement > satisfyNone ( ) ) ; } public SingleIncludePatternFileTree ( File baseDir , String includePattern , Spec < FileTreeElement > excludeSpec ) { this . baseDir = baseDir ; if ( includePattern . endsWith ( <str> ) | | includePattern . endsWith ( <str> ) ) { includePattern + = <str> ; } this . includePattern = includePattern ; this . patternSegments = Arrays . asList ( includePattern . split ( <str> ) ) ; this . excludeSpec = excludeSpec ; } public void visit ( FileVisitor visitor ) { doVisit ( visitor , baseDir , new LinkedList < String > ( ) , <int> , new AtomicBoolean ( ) ) ; } private void doVisit ( FileVisitor visitor , File file , LinkedList < String > relativePath , int segmentIndex , AtomicBoolean stopFlag ) { if ( stopFlag . get ( ) ) { return ; } String segment = patternSegments . get ( segmentIndex ) ; if ( segment . contains ( <str> ) ) { PatternSet patternSet = new PatternSet ( ) ; patternSet . include ( includePattern ) ; patternSet . exclude ( excludeSpec ) ; DirectoryFileTree fileTree = new DirectoryFileTree ( baseDir , patternSet ) ; fileTree . visitFrom ( visitor , file , new RelativePath ( file . isFile ( ) , relativePath . toArray ( new String [ relativePath . size ( ) ] ) ) ) ; } else if ( segment . contains ( <str> ) | | segment . contains ( <str> ) ) { PatternStep step = PatternStepFactory . getStep ( segment , false ) ; File [ ] children = file . listFiles ( ) ; if ( children = = null ) { if ( ! file . canRead ( ) ) { throw new GradleException ( String . format ( <str> , file ) ) ; } throw new GradleException ( String . format ( <str> , file ) ) ; } for ( File child : children ) { if ( stopFlag . get ( ) ) { break ; } if ( step . matches ( child . getName ( ) ) ) { relativePath . addLast ( child . getName ( ) ) ; doVisitDirOrFile ( visitor , child , relativePath , segmentIndex + <int> , stopFlag ) ; relativePath . removeLast ( ) ; } } } else { relativePath . addLast ( segment ) ; doVisitDirOrFile ( visitor , new File ( file , segment ) , relativePath , segmentIndex + <int> , stopFlag ) ; relativePath . removeLast ( ) ; } } private void doVisitDirOrFile ( FileVisitor visitor , File file , LinkedList < String > relativePath , int segmentIndex , AtomicBoolean stopFlag ) { if ( file . isFile ( ) ) { if ( segmentIndex = = patternSegments . size ( ) ) { RelativePath path = new RelativePath ( true , relativePath . toArray ( new String [ relativePath . size ( ) ] ) ) ; FileVisitDetails details = new DefaultFileVisitDetails ( file , path , stopFlag , fileSystem , fileSystem ) ; if ( ! excludeSpec . isSatisfiedBy ( details ) ) { visitor . visitFile ( details ) ; } } } else if ( file . isDirectory ( ) ) { RelativePath path = new RelativePath ( false , relativePath . toArray ( new String [ relativePath . size ( ) ] ) ) ; FileVisitDetails details = new DefaultFileVisitDetails ( file , path , stopFlag , fileSystem , fileSystem ) ; if ( ! excludeSpec . isSatisfiedBy ( details ) ) { visitor . visitDir ( details ) ; } if ( segmentIndex < patternSegments . size ( ) ) { doVisit ( visitor , file , relativePath , segmentIndex , stopFlag ) ; } } } public String getDisplayName ( ) { return <str> + baseDir + <str> + includePattern + <str> ; } @Override public void registerWatchPoints ( FileSystemSubset . Builder builder ) { builder . add ( baseDir , new PatternSet ( ) . include ( includePattern ) . exclude ( excludeSpec ) ) ; } @Override public void visitTreeOrBackingFile ( FileVisitor visitor ) { visit ( visitor ) ; } } 
