package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . physics . bullet . collision . btAxisSweep3 ; import com . badlogic . gdx . physics . bullet . collision . btBroadphaseProxy ; import com . badlogic . gdx . physics . bullet . collision . btCapsuleShape ; import com . badlogic . gdx . physics . bullet . collision . btCollisionDispatcher ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObject ; import com . badlogic . gdx . physics . bullet . collision . btConvexShape ; import com . badlogic . gdx . physics . bullet . collision . btDbvtBroadphase ; import com . badlogic . gdx . physics . bullet . collision . btDefaultCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . collision . btGhostPairCallback ; import com . badlogic . gdx . physics . bullet . collision . btPairCachingGhostObject ; import com . badlogic . gdx . physics . bullet . dynamics . btDiscreteDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btKinematicCharacterController ; import com . badlogic . gdx . physics . bullet . dynamics . btSequentialImpulseConstraintSolver ; public class CharacterTest extends BaseBulletTest { final int BOXCOUNT_X = <int> ; final int BOXCOUNT_Y = <int> ; final int BOXCOUNT_Z = <int> ; final float BOXOFFSET_X = - <float> ; final float BOXOFFSET_Y = <float> ; final float BOXOFFSET_Z = <float> ; BulletEntity ground ; BulletEntity character ; btGhostPairCallback ghostPairCallback ; btPairCachingGhostObject ghostObject ; btConvexShape ghostShape ; btKinematicCharacterController characterController ; Matrix4 characterTransform ; Vector3 characterDirection = new Vector3 ( ) ; Vector3 walkDirection = new Vector3 ( ) ; @Override public BulletWorld createWorld ( ) { btDefaultCollisionConfiguration collisionConfiguration = new btDefaultCollisionConfiguration ( ) ; btCollisionDispatcher dispatcher = new btCollisionDispatcher ( collisionConfiguration ) ; btAxisSweep3 sweep = new btAxisSweep3 ( new Vector3 ( - <int> , - <int> , - <int> ) , new Vector3 ( <int> , <int> , <int> ) ) ; btSequentialImpulseConstraintSolver solver = new btSequentialImpulseConstraintSolver ( ) ; btDiscreteDynamicsWorld collisionWorld = new btDiscreteDynamicsWorld ( dispatcher , sweep , solver , collisionConfiguration ) ; ghostPairCallback = new btGhostPairCallback ( ) ; sweep . getOverlappingPairCache ( ) . setInternalGhostPairCallback ( ghostPairCallback ) ; return new BulletWorld ( collisionConfiguration , dispatcher , sweep , solver , collisionWorld ) ; } @Override public void create ( ) { super . create ( ) ; instructions = <str> ; final Texture texture = new Texture ( Gdx . files . internal ( <str> ) ) ; disposables . add ( texture ) ; final Material material = new Material ( TextureAttribute . createDiffuse ( texture ) , ColorAttribute . createSpecular ( <int> , <int> , <int> , <int> ) , FloatAttribute . createShininess ( <float> ) ) ; final long attributes = Usage . Position | Usage . Normal | Usage . TextureCoordinates ; final Model capsule = modelBuilder . createCapsule ( <float> , <float> , <int> , material , attributes ) ; disposables . add ( capsule ) ; world . addConstructor ( <str> , new BulletConstructor ( capsule , null ) ) ; character = world . add ( <str> , <float> , <float> , <float> ) ; characterTransform = character . transform ; ghostObject = new btPairCachingGhostObject ( ) ; ghostObject . setWorldTransform ( characterTransform ) ; ghostShape = new btCapsuleShape ( <float> , <float> ) ; ghostObject . setCollisionShape ( ghostShape ) ; ghostObject . setCollisionFlags ( btCollisionObject . CollisionFlags . CF_CHARACTER_OBJECT ) ; characterController = new btKinematicCharacterController ( ghostObject , ghostShape , <float> ) ; world . collisionWorld . addCollisionObject ( ghostObject , ( short ) btBroadphaseProxy . CollisionFilterGroups . CharacterFilter , ( short ) ( btBroadphaseProxy . CollisionFilterGroups . StaticFilter | btBroadphaseProxy . CollisionFilterGroups . DefaultFilter ) ) ; ( ( btDiscreteDynamicsWorld ) ( world . collisionWorld ) ) . addAction ( characterController ) ; ( ground = world . add ( <str> , <float> , <float> , <float> ) ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; for ( int x = <int> ; x < BOXCOUNT_X ; x + + ) { for ( int y = <int> ; y < BOXCOUNT_Y ; y + + ) { for ( int z = <int> ; z < BOXCOUNT_Z ; z + + ) { world . add ( <str> , BOXOFFSET_X + x , BOXOFFSET_Y + y , BOXOFFSET_Z + z ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; } } } } @Override public void update ( ) { if ( Gdx . input . isKeyPressed ( Keys . LEFT ) ) { characterTransform . rotate ( <int> , <int> , <int> , <float> ) ; ghostObject . setWorldTransform ( characterTransform ) ; } if ( Gdx . input . isKeyPressed ( Keys . RIGHT ) ) { characterTransform . rotate ( <int> , <int> , <int> , - <float> ) ; ghostObject . setWorldTransform ( characterTransform ) ; } characterDirection . set ( - <int> , <int> , <int> ) . rot ( characterTransform ) . nor ( ) ; walkDirection . set ( <int> , <int> , <int> ) ; if ( Gdx . input . isKeyPressed ( Keys . UP ) ) walkDirection . add ( characterDirection ) ; if ( Gdx . input . isKeyPressed ( Keys . DOWN ) ) walkDirection . add ( - characterDirection . x , - characterDirection . y , - characterDirection . z ) ; walkDirection . scl ( <float> * Gdx . graphics . getDeltaTime ( ) ) ; characterController . setWalkDirection ( walkDirection ) ; super . update ( ) ; ghostObject . getWorldTransform ( characterTransform ) ; } @Override protected void renderWorld ( ) { super . renderWorld ( ) ; } @Override public boolean tap ( float x , float y , int count , int button ) { shoot ( x , y ) ; return true ; } @Override public void dispose ( ) { ( ( btDiscreteDynamicsWorld ) ( world . collisionWorld ) ) . removeAction ( characterController ) ; world . collisionWorld . removeCollisionObject ( ghostObject ) ; super . dispose ( ) ; characterController . dispose ( ) ; ghostObject . dispose ( ) ; ghostShape . dispose ( ) ; ghostPairCallback . dispose ( ) ; ground = null ; } } 
