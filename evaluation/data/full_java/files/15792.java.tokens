package org . gradle . api . tasks . testing ; import org . gradle . api . DefaultTask ; import org . gradle . api . Incubating ; import org . gradle . api . Transformer ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . file . UnionFileCollection ; import org . gradle . api . internal . tasks . testing . junit . report . DefaultTestReport ; import org . gradle . api . internal . tasks . testing . junit . result . AggregateTestResultsProvider ; import org . gradle . api . internal . tasks . testing . junit . result . BinaryResultBackedTestResultsProvider ; import org . gradle . api . internal . tasks . testing . junit . result . TestResultsProvider ; import org . gradle . api . tasks . InputFiles ; import org . gradle . api . tasks . OutputDirectory ; import org . gradle . api . tasks . SkipWhenEmpty ; import org . gradle . api . tasks . TaskAction ; import java . io . File ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import static org . gradle . internal . concurrent . CompositeStoppable . stoppable ; import static org . gradle . util . CollectionUtils . collect ; @Incubating public class TestReport extends DefaultTask { private File destinationDir ; private List < Object > results = new ArrayList < Object > ( ) ; @OutputDirectory public File getDestinationDir ( ) { return destinationDir ; } public void setDestinationDir ( File destinationDir ) { this . destinationDir = destinationDir ; } @InputFiles @SkipWhenEmpty public FileCollection getTestResultDirs ( ) { UnionFileCollection dirs = new UnionFileCollection ( ) ; for ( Object result : results ) { addTo ( result , dirs ) ; } return dirs ; } private void addTo ( Object result , UnionFileCollection dirs ) { if ( result instanceof Test ) { Test test = ( Test ) result ; dirs . add ( getProject ( ) . files ( test . getBinResultsDir ( ) ) . builtBy ( test ) ) ; } else if ( result instanceof Iterable < ? > ) { Iterable < ? > iterable = ( Iterable < ? > ) result ; for ( Object nested : iterable ) { addTo ( nested , dirs ) ; } } else { dirs . add ( getProject ( ) . files ( result ) ) ; } } public void setTestResultDirs ( Iterable < File > testResultDirs ) { this . results . clear ( ) ; reportOn ( testResultDirs ) ; } public void reportOn ( Object . . . results ) { for ( Object result : results ) { this . results . add ( result ) ; } } @TaskAction void generateReport ( ) { TestResultsProvider resultsProvider = createAggregateProvider ( ) ; try { if ( resultsProvider . isHasResults ( ) ) { DefaultTestReport testReport = new DefaultTestReport ( ) ; testReport . generateReport ( resultsProvider , getDestinationDir ( ) ) ; } else { getLogger ( ) . info ( <str> , getPath ( ) , getTestResultDirs ( ) . getFiles ( ) ) ; setDidWork ( false ) ; } } finally { stoppable ( resultsProvider ) . stop ( ) ; } } private TestResultsProvider createAggregateProvider ( ) { List < TestResultsProvider > resultsProviders = new LinkedList < TestResultsProvider > ( ) ; try { FileCollection resultDirs = getTestResultDirs ( ) ; if ( resultDirs . getFiles ( ) . size ( ) = = <int> ) { return new BinaryResultBackedTestResultsProvider ( resultDirs . getSingleFile ( ) ) ; } else { return new AggregateTestResultsProvider ( collect ( resultDirs , resultsProviders , new Transformer < TestResultsProvider , File > ( ) { public TestResultsProvider transform ( File dir ) { return new BinaryResultBackedTestResultsProvider ( dir ) ; } } ) ) ; } } catch ( RuntimeException e ) { stoppable ( resultsProviders ) . stop ( ) ; throw e ; } } } 
