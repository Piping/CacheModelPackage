package org . gradle . messaging . dispatch ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . AsyncStoppable ; import java . util . LinkedList ; import java . util . concurrent . Executor ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class AsyncDispatch < T > implements Dispatch < T > , AsyncStoppable { private enum State { Init , Stopped } private static final int MAX_QUEUE_SIZE = <int> ; private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private final LinkedList < T > queue = new LinkedList < T > ( ) ; private final Executor executor ; private final int maxQueueSize ; private int dispatchers ; private State state ; public AsyncDispatch ( Executor executor ) { this ( executor , null , MAX_QUEUE_SIZE ) ; } public AsyncDispatch ( Executor executor , final Dispatch < ? super T > dispatch ) { this ( executor , dispatch , MAX_QUEUE_SIZE ) ; } public AsyncDispatch ( Executor executor , final Dispatch < ? super T > dispatch , int maxQueueSize ) { this . executor = executor ; this . maxQueueSize = maxQueueSize ; state = State . Init ; if ( dispatch ! = null ) { dispatchTo ( dispatch ) ; } } public void dispatchTo ( final Dispatch < ? super T > dispatch ) { onDispatchThreadStart ( ) ; executor . execute ( new Runnable ( ) { public void run ( ) { try { dispatchMessages ( dispatch ) ; } finally { onDispatchThreadExit ( ) ; } } } ) ; } private void onDispatchThreadStart ( ) { lock . lock ( ) ; try { if ( state ! = State . Init ) { throw new IllegalStateException ( <str> ) ; } dispatchers + + ; } finally { lock . unlock ( ) ; } } private void onDispatchThreadExit ( ) { lock . lock ( ) ; try { dispatchers - - ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } private void setState ( State state ) { this . state = state ; condition . signalAll ( ) ; } private void dispatchMessages ( Dispatch < ? super T > dispatch ) { while ( true ) { T message = null ; lock . lock ( ) ; try { while ( state ! = State . Stopped & & queue . isEmpty ( ) ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw new UncheckedException ( e ) ; } } if ( ! queue . isEmpty ( ) ) { message = queue . remove ( ) ; condition . signalAll ( ) ; } } finally { lock . unlock ( ) ; } if ( message = = null ) { return ; } dispatch . dispatch ( message ) ; } } public void dispatch ( final T message ) { lock . lock ( ) ; try { while ( state ! = State . Stopped & & queue . size ( ) > = maxQueueSize ) { try { condition . await ( ) ; } catch ( InterruptedException e ) { throw new UncheckedException ( e ) ; } } if ( state = = State . Stopped ) { throw new IllegalStateException ( <str> + message ) ; } queue . add ( message ) ; condition . signalAll ( ) ; } finally { lock . unlock ( ) ; } } public void requestStop ( ) { lock . lock ( ) ; try { doRequestStop ( ) ; } finally { lock . unlock ( ) ; } } private void doRequestStop ( ) { setState ( State . Stopped ) ; } public void stop ( ) { lock . lock ( ) ; try { setState ( State . Stopped ) ; while ( dispatchers > <int> ) { condition . await ( ) ; } if ( ! queue . isEmpty ( ) ) { throw new IllegalStateException ( <str> ) ; } } catch ( InterruptedException e ) { throw new UncheckedException ( e ) ; } finally { lock . unlock ( ) ; } } } 
