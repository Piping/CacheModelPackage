package org . elasticsearch . action . termvectors . dfs ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ShardOperationFailedException ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . DefaultShardOperationFailedException ; import org . elasticsearch . action . support . broadcast . BroadcastShardOperationFailedException ; import org . elasticsearch . action . support . broadcast . TransportBroadcastAction ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . routing . GroupShardsIterator ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . concurrent . AtomicArray ; import org . elasticsearch . search . SearchService ; import org . elasticsearch . search . controller . SearchPhaseController ; import org . elasticsearch . search . dfs . AggregatedDfs ; import org . elasticsearch . search . dfs . DfsSearchResult ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . atomic . AtomicReferenceArray ; public class TransportDfsOnlyAction extends TransportBroadcastAction < DfsOnlyRequest , DfsOnlyResponse , ShardDfsOnlyRequest , ShardDfsOnlyResponse > { public static final String NAME = <str> ; private final SearchService searchService ; private final SearchPhaseController searchPhaseController ; @Inject public TransportDfsOnlyAction ( Settings settings , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , SearchService searchService , SearchPhaseController searchPhaseController ) { super ( settings , NAME , threadPool , clusterService , transportService , actionFilters , indexNameExpressionResolver , DfsOnlyRequest : : new , ShardDfsOnlyRequest : : new , ThreadPool . Names . SEARCH ) ; this . searchService = searchService ; this . searchPhaseController = searchPhaseController ; } @Override protected void doExecute ( DfsOnlyRequest request , ActionListener < DfsOnlyResponse > listener ) { request . nowInMillis = System . currentTimeMillis ( ) ; super . doExecute ( request , listener ) ; } @Override protected ShardDfsOnlyRequest newShardRequest ( int numShards , ShardRouting shard , DfsOnlyRequest request ) { String [ ] filteringAliases = indexNameExpressionResolver . filteringAliases ( clusterService . state ( ) , shard . index ( ) , request . indices ( ) ) ; return new ShardDfsOnlyRequest ( shard , numShards , filteringAliases , request . nowInMillis , request ) ; } @Override protected ShardDfsOnlyResponse newShardResponse ( ) { return new ShardDfsOnlyResponse ( ) ; } @Override protected GroupShardsIterator shards ( ClusterState clusterState , DfsOnlyRequest request , String [ ] concreteIndices ) { Map < String , Set < String > > routingMap = indexNameExpressionResolver . resolveSearchRouting ( clusterState , request . routing ( ) , request . indices ( ) ) ; return clusterService . operationRouting ( ) . searchShards ( clusterState , concreteIndices , routingMap , request . preference ( ) ) ; } @Override protected ClusterBlockException checkGlobalBlock ( ClusterState state , DfsOnlyRequest request ) { return state . blocks ( ) . globalBlockedException ( ClusterBlockLevel . READ ) ; } @Override protected ClusterBlockException checkRequestBlock ( ClusterState state , DfsOnlyRequest countRequest , String [ ] concreteIndices ) { return state . blocks ( ) . indicesBlockedException ( ClusterBlockLevel . READ , concreteIndices ) ; } @Override protected DfsOnlyResponse newResponse ( DfsOnlyRequest request , AtomicReferenceArray shardsResponses , ClusterState clusterState ) { int successfulShards = <int> ; int failedShards = <int> ; List < ShardOperationFailedException > shardFailures = null ; AtomicArray < DfsSearchResult > dfsResults = new AtomicArray < > ( shardsResponses . length ( ) ) ; for ( int i = <int> ; i < shardsResponses . length ( ) ; i + + ) { Object shardResponse = shardsResponses . get ( i ) ; if ( shardResponse = = null ) { } else if ( shardResponse instanceof BroadcastShardOperationFailedException ) { failedShards + + ; if ( shardFailures = = null ) { shardFailures = new ArrayList < > ( ) ; } shardFailures . add ( new DefaultShardOperationFailedException ( ( BroadcastShardOperationFailedException ) shardResponse ) ) ; } else { dfsResults . set ( i , ( ( ShardDfsOnlyResponse ) shardResponse ) . getDfsSearchResult ( ) ) ; successfulShards + + ; } } AggregatedDfs dfs = searchPhaseController . aggregateDfs ( dfsResults ) ; return new DfsOnlyResponse ( dfs , shardsResponses . length ( ) , successfulShards , failedShards , shardFailures , buildTookInMillis ( request ) ) ; } @Override protected ShardDfsOnlyResponse shardOperation ( ShardDfsOnlyRequest request ) { DfsSearchResult dfsSearchResult = searchService . executeDfsPhase ( request . getShardSearchRequest ( ) ) ; searchService . freeContext ( dfsSearchResult . id ( ) ) ; return new ShardDfsOnlyResponse ( request . shardId ( ) , dfsSearchResult ) ; } protected final long buildTookInMillis ( DfsOnlyRequest request ) { return Math . max ( <int> , System . currentTimeMillis ( ) - request . nowInMillis ) ; } } 
