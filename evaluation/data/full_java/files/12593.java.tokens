package org . gradle . api . internal . artifacts . ivyservice . ivyresolve . parser ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import java . io . * ; import java . util . LinkedList ; import java . util . List ; public final class PomDomParser { private PomDomParser ( ) { } public static String getTextContent ( Element element ) { StringBuilder result = new StringBuilder ( ) ; NodeList childNodes = element . getChildNodes ( ) ; for ( int i = <int> ; i < childNodes . getLength ( ) ; i + + ) { Node child = childNodes . item ( i ) ; switch ( child . getNodeType ( ) ) { case Node . CDATA_SECTION_NODE : case Node . TEXT_NODE : result . append ( child . getNodeValue ( ) ) ; break ; default : break ; } } return result . toString ( ) ; } public static String getFirstChildText ( Element parentElem , String name ) { Element node = getFirstChildElement ( parentElem , name ) ; if ( node ! = null ) { return getTextContent ( node ) ; } else { return null ; } } public static Element getFirstChildElement ( Element parentElem , String name ) { if ( parentElem = = null ) { return null ; } NodeList childs = parentElem . getChildNodes ( ) ; for ( int i = <int> ; i < childs . getLength ( ) ; i + + ) { Node node = childs . item ( i ) ; if ( node instanceof Element & & name . equals ( node . getNodeName ( ) ) ) { return ( Element ) node ; } } return null ; } public static List < Element > getAllChilds ( Element parent ) { List < Element > r = new LinkedList < Element > ( ) ; if ( parent ! = null ) { NodeList childs = parent . getChildNodes ( ) ; for ( int i = <int> ; i < childs . getLength ( ) ; i + + ) { Node node = childs . item ( i ) ; if ( node instanceof Element ) { r . add ( ( Element ) node ) ; } } } return r ; } public static final class AddDTDFilterInputStream extends FilterInputStream { private static final int MARK = <int> ; private static final String DOCTYPE = <str> ; private int count ; private byte [ ] prefix = DOCTYPE . getBytes ( ) ; public AddDTDFilterInputStream ( InputStream in ) throws IOException { super ( new BufferedInputStream ( in ) ) ; this . in . mark ( MARK ) ; int byte1 = this . in . read ( ) ; int byte2 = this . in . read ( ) ; int byte3 = this . in . read ( ) ; if ( byte1 = = <int> & & byte2 = = <int> & & byte3 = = <int> ) { this . in . mark ( MARK ) ; } else { this . in . reset ( ) ; } int bytesToSkip = <int> ; LineNumberReader reader = new LineNumberReader ( new InputStreamReader ( this . in , <str> ) , <int> ) ; String firstLine = reader . readLine ( ) ; if ( firstLine ! = null ) { String trimmed = firstLine . trim ( ) ; if ( trimmed . startsWith ( <str> ) ) { int endIndex = trimmed . indexOf ( <str> ) ; String xmlDecl = trimmed . substring ( <int> , endIndex + <int> ) ; prefix = ( xmlDecl + <str> + DOCTYPE ) . getBytes ( ) ; bytesToSkip = xmlDecl . getBytes ( ) . length ; } } this . in . reset ( ) ; for ( int i = <int> ; i < bytesToSkip ; i + + ) { this . in . read ( ) ; } } public int read ( ) throws IOException { if ( count < prefix . length ) { return prefix [ count + + ] ; } return super . read ( ) ; } public int read ( byte [ ] b , int off , int len ) throws IOException { if ( b = = null ) { throw new NullPointerException ( ) ; } else if ( ( off < <int> ) | | ( off > b . length ) | | ( len < <int> ) | | ( ( off + len ) > b . length ) | | ( ( off + len ) < <int> ) ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len = = <int> ) { return <int> ; } int nbrBytesCopied = <int> ; if ( count < prefix . length ) { int nbrBytesFromPrefix = Math . min ( prefix . length - count , len ) ; System . arraycopy ( prefix , count , b , off , nbrBytesFromPrefix ) ; nbrBytesCopied = nbrBytesFromPrefix ; } if ( nbrBytesCopied < len ) { nbrBytesCopied + = in . read ( b , off + nbrBytesCopied , len - nbrBytesCopied ) ; } count + = nbrBytesCopied ; return nbrBytesCopied ; } } } 
