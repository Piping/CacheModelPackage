package org . apache . cassandra . service ; import java . net . InetAddress ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . concurrent . TimeUnit ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . epoll . Epoll ; import io . netty . channel . epoll . EpollEventLoopGroup ; import io . netty . channel . nio . NioEventLoopGroup ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . Future ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . metrics . ClientMetrics ; import org . apache . cassandra . transport . RequestThreadPoolExecutor ; import org . apache . cassandra . transport . Server ; public class NativeTransportService { private static final Logger logger = LoggerFactory . getLogger ( NativeTransportService . class ) ; private Collection < Server > servers = Collections . emptyList ( ) ; private boolean initialized = false ; private EventLoopGroup workerGroup ; private EventExecutor eventExecutorGroup ; @VisibleForTesting synchronized void initialize ( ) { if ( initialized ) return ; eventExecutorGroup = new RequestThreadPoolExecutor ( ) ; if ( useEpoll ( ) ) { workerGroup = new EpollEventLoopGroup ( ) ; logger . info ( <str> ) ; } else { workerGroup = new NioEventLoopGroup ( ) ; logger . info ( <str> ) ; } int nativePort = DatabaseDescriptor . getNativeTransportPort ( ) ; int nativePortSSL = DatabaseDescriptor . getNativeTransportPortSSL ( ) ; InetAddress nativeAddr = DatabaseDescriptor . getRpcAddress ( ) ; org . apache . cassandra . transport . Server . Builder builder = new org . apache . cassandra . transport . Server . Builder ( ) . withEventExecutor ( eventExecutorGroup ) . withEventLoopGroup ( workerGroup ) . withHost ( nativeAddr ) ; if ( ! DatabaseDescriptor . getClientEncryptionOptions ( ) . enabled ) { servers = Collections . singleton ( builder . withSSL ( false ) . withPort ( nativePort ) . build ( ) ) ; } else { if ( nativePort ! = nativePortSSL ) { servers = Collections . unmodifiableList ( Arrays . asList ( builder . withSSL ( false ) . withPort ( nativePort ) . build ( ) , builder . withSSL ( true ) . withPort ( nativePortSSL ) . build ( ) ) ) ; } else { servers = Collections . singleton ( builder . withSSL ( true ) . withPort ( nativePort ) . build ( ) ) ; } } ClientMetrics . instance . addCounter ( <str> , ( ) - > { int ret = <int> ; for ( Server server : servers ) ret + = server . getConnectedClients ( ) ; return ret ; } ) ; initialized = true ; } public void start ( ) { initialize ( ) ; servers . forEach ( Server : : start ) ; } public void stop ( ) { servers . forEach ( Server : : stop ) ; } public void destroy ( ) { stop ( ) ; servers = Collections . emptyList ( ) ; Future < ? > wgStop = workerGroup . shutdownGracefully ( <int> , <int> , TimeUnit . SECONDS ) ; try { wgStop . await ( <int> ) ; } catch ( InterruptedException e1 ) { Thread . currentThread ( ) . interrupt ( ) ; } eventExecutorGroup . shutdown ( ) ; } public static boolean useEpoll ( ) { final boolean enableEpoll = Boolean . valueOf ( System . getProperty ( <str> , <str> ) ) ; return enableEpoll & & Epoll . isAvailable ( ) ; } public boolean isRunning ( ) { for ( Server server : servers ) if ( server . isRunning ( ) ) return true ; return false ; } @VisibleForTesting EventLoopGroup getWorkerGroup ( ) { return workerGroup ; } @VisibleForTesting EventExecutor getEventExecutor ( ) { return eventExecutorGroup ; } @VisibleForTesting Collection < Server > getServers ( ) { return servers ; } } 
