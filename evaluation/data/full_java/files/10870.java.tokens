package org . gradle . internal . operations ; import com . google . common . collect . Lists ; import com . google . common . collect . Queues ; import com . google . common . util . concurrent . * ; import org . gradle . internal . UncheckedException ; import java . util . Collection ; import java . util . List ; import java . util . Queue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutorService ; class DefaultBuildOperationQueue < T extends BuildOperation > implements BuildOperationQueue < T > { private final ListeningExecutorService executor ; private final BuildOperationWorker < T > worker ; private final List < ListenableFuture > operations ; private final String logLocation ; private boolean waitingForCompletion ; DefaultBuildOperationQueue ( ExecutorService executor , BuildOperationWorker < T > worker , String logLocation ) { this . logLocation = logLocation ; this . executor = MoreExecutors . listeningDecorator ( executor ) ; this . worker = worker ; this . operations = Lists . newLinkedList ( ) ; } public void add ( final T operation ) { if ( waitingForCompletion ) { throw new IllegalStateException ( <str> ) ; } ListenableFuture < ? > future = executor . submit ( new OperationHolder ( operation ) ) ; operations . add ( future ) ; } public void waitForCompletion ( ) throws MultipleBuildOperationFailures { waitingForCompletion = true ; CountDownLatch finished = new CountDownLatch ( operations . size ( ) ) ; Queue < Throwable > failures = Queues . newConcurrentLinkedQueue ( ) ; for ( ListenableFuture operation : operations ) { Futures . addCallback ( operation , new CompletionCallback ( finished , failures ) ) ; } try { finished . await ( ) ; } catch ( InterruptedException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } if ( ! failures . isEmpty ( ) ) { throw new MultipleBuildOperationFailures ( getFailureMessage ( failures ) , failures , logLocation ) ; } } private String getFailureMessage ( Collection < Throwable > failures ) { if ( failures . size ( ) = = <int> ) { return <str> ; } return <str> ; } private static class CompletionCallback implements FutureCallback { private final CountDownLatch finished ; private final Collection < Throwable > failures ; private CompletionCallback ( CountDownLatch finished , Collection < Throwable > failures ) { this . finished = finished ; this . failures = failures ; } public void onSuccess ( Object result ) { finished . countDown ( ) ; } public void onFailure ( Throwable t ) { failures . add ( t ) ; finished . countDown ( ) ; } } private class OperationHolder implements Runnable { private final T operation ; OperationHolder ( T operation ) { this . operation = operation ; } public void run ( ) { worker . execute ( operation ) ; } public String toString ( ) { return <str> . concat ( worker . getDisplayName ( ) ) . concat ( <str> ) . concat ( operation . getDescription ( ) ) ; } } } 
