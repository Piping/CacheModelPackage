package com . google . common . reflect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . CharMatcher ; import com . google . common . base . Predicate ; import com . google . common . base . Splitter ; import com . google . common . collect . FluentIterable ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Maps ; import com . google . common . collect . MultimapBuilder ; import com . google . common . collect . SetMultimap ; import com . google . common . collect . Sets ; import java . io . File ; import java . io . IOException ; import java . net . MalformedURLException ; import java . net . URL ; import java . net . URLClassLoader ; import java . util . Enumeration ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . jar . Attributes ; import java . util . jar . JarEntry ; import java . util . jar . JarFile ; import java . util . jar . Manifest ; import java . util . logging . Logger ; import javax . annotation . Nullable ; @Beta public final class ClassPath { private static final Logger logger = Logger . getLogger ( ClassPath . class . getName ( ) ) ; private static final Predicate < ClassInfo > IS_TOP_LEVEL = new Predicate < ClassInfo > ( ) { @Override public boolean apply ( ClassInfo info ) { return info . className . indexOf ( <str> ) = = - <int> ; } } ; private static final Splitter CLASS_PATH_ATTRIBUTE_SEPARATOR = Splitter . on ( <str> ) . omitEmptyStrings ( ) ; private static final String CLASS_FILE_NAME_EXTENSION = <str> ; private final ImmutableSet < ResourceInfo > resources ; private ClassPath ( ImmutableSet < ResourceInfo > resources ) { this . resources = resources ; } public static ClassPath from ( ClassLoader classloader ) throws IOException { DefaultScanner scanner = new DefaultScanner ( ) ; scanner . scan ( classloader ) ; return new ClassPath ( scanner . getResources ( ) ) ; } public ImmutableSet < ResourceInfo > getResources ( ) { return resources ; } public ImmutableSet < ClassInfo > getAllClasses ( ) { return FluentIterable . from ( resources ) . filter ( ClassInfo . class ) . toSet ( ) ; } public ImmutableSet < ClassInfo > getTopLevelClasses ( ) { return FluentIterable . from ( resources ) . filter ( ClassInfo . class ) . filter ( IS_TOP_LEVEL ) . toSet ( ) ; } public ImmutableSet < ClassInfo > getTopLevelClasses ( String packageName ) { checkNotNull ( packageName ) ; ImmutableSet . Builder < ClassInfo > builder = ImmutableSet . builder ( ) ; for ( ClassInfo classInfo : getTopLevelClasses ( ) ) { if ( classInfo . getPackageName ( ) . equals ( packageName ) ) { builder . add ( classInfo ) ; } } return builder . build ( ) ; } public ImmutableSet < ClassInfo > getTopLevelClassesRecursive ( String packageName ) { checkNotNull ( packageName ) ; String packagePrefix = packageName + <str> ; ImmutableSet . Builder < ClassInfo > builder = ImmutableSet . builder ( ) ; for ( ClassInfo classInfo : getTopLevelClasses ( ) ) { if ( classInfo . getName ( ) . startsWith ( packagePrefix ) ) { builder . add ( classInfo ) ; } } return builder . build ( ) ; } @Beta public static class ResourceInfo { private final String resourceName ; final ClassLoader loader ; static ResourceInfo of ( String resourceName , ClassLoader loader ) { if ( resourceName . endsWith ( CLASS_FILE_NAME_EXTENSION ) ) { return new ClassInfo ( resourceName , loader ) ; } else { return new ResourceInfo ( resourceName , loader ) ; } } ResourceInfo ( String resourceName , ClassLoader loader ) { this . resourceName = checkNotNull ( resourceName ) ; this . loader = checkNotNull ( loader ) ; } public final URL url ( ) throws NoSuchElementException { URL url = loader . getResource ( resourceName ) ; if ( url = = null ) { throw new NoSuchElementException ( resourceName ) ; } return url ; } public final String getResourceName ( ) { return resourceName ; } @Override public int hashCode ( ) { return resourceName . hashCode ( ) ; } @Override public boolean equals ( Object obj ) { if ( obj instanceof ResourceInfo ) { ResourceInfo that = ( ResourceInfo ) obj ; return resourceName . equals ( that . resourceName ) & & loader = = that . loader ; } return false ; } @Override public String toString ( ) { return resourceName ; } } @Beta public static final class ClassInfo extends ResourceInfo { private final String className ; ClassInfo ( String resourceName , ClassLoader loader ) { super ( resourceName , loader ) ; this . className = getClassName ( resourceName ) ; } public String getPackageName ( ) { return Reflection . getPackageName ( className ) ; } public String getSimpleName ( ) { int lastDollarSign = className . lastIndexOf ( <str> ) ; if ( lastDollarSign ! = - <int> ) { String innerClassName = className . substring ( lastDollarSign + <int> ) ; return CharMatcher . DIGIT . trimLeadingFrom ( innerClassName ) ; } String packageName = getPackageName ( ) ; if ( packageName . isEmpty ( ) ) { return className ; } return className . substring ( packageName . length ( ) + <int> ) ; } public String getName ( ) { return className ; } public Class < ? > load ( ) { try { return loader . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( e ) ; } } @Override public String toString ( ) { return className ; } } abstract static class Scanner { private final Set < File > scannedUris = Sets . newHashSet ( ) ; public final void scan ( ClassLoader classloader ) throws IOException { for ( Map . Entry < File , ClassLoader > entry : getClassPathEntries ( classloader ) . entrySet ( ) ) { scan ( entry . getKey ( ) , entry . getValue ( ) ) ; } } protected abstract void scanDirectory ( ClassLoader loader , File directory ) throws IOException ; protected abstract void scanJarFile ( ClassLoader loader , JarFile file ) throws IOException ; @VisibleForTesting final void scan ( File file , ClassLoader classloader ) throws IOException { if ( scannedUris . add ( file . getCanonicalFile ( ) ) ) { scanFrom ( file , classloader ) ; } } private void scanFrom ( File file , ClassLoader classloader ) throws IOException { if ( ! file . exists ( ) ) { return ; } if ( file . isDirectory ( ) ) { scanDirectory ( classloader , file ) ; } else { scanJar ( file , classloader ) ; } } private void scanJar ( File file , ClassLoader classloader ) throws IOException { JarFile jarFile ; try { jarFile = new JarFile ( file ) ; } catch ( IOException e ) { return ; } try { for ( File path : getClassPathFromManifest ( file , jarFile . getManifest ( ) ) ) { scan ( path , classloader ) ; } scanJarFile ( classloader , jarFile ) ; } finally { try { jarFile . close ( ) ; } catch ( IOException ignored ) { } } } @VisibleForTesting static ImmutableSet < File > getClassPathFromManifest ( File jarFile , @Nullable Manifest manifest ) { if ( manifest = = null ) { return ImmutableSet . of ( ) ; } ImmutableSet . Builder < File > builder = ImmutableSet . builder ( ) ; String classpathAttribute = manifest . getMainAttributes ( ) . getValue ( Attributes . Name . CLASS_PATH . toString ( ) ) ; if ( classpathAttribute ! = null ) { for ( String path : CLASS_PATH_ATTRIBUTE_SEPARATOR . split ( classpathAttribute ) ) { URL url ; try { url = getClassPathEntry ( jarFile , path ) ; } catch ( MalformedURLException e ) { logger . warning ( <str> + path ) ; continue ; } if ( url . getProtocol ( ) . equals ( <str> ) ) { builder . add ( new File ( url . getFile ( ) ) ) ; } } } return builder . build ( ) ; } @VisibleForTesting static ImmutableMap < File , ClassLoader > getClassPathEntries ( ClassLoader classloader ) { LinkedHashMap < File , ClassLoader > entries = Maps . newLinkedHashMap ( ) ; ClassLoader parent = classloader . getParent ( ) ; if ( parent ! = null ) { entries . putAll ( getClassPathEntries ( parent ) ) ; } if ( classloader instanceof URLClassLoader ) { URLClassLoader urlClassLoader = ( URLClassLoader ) classloader ; for ( URL entry : urlClassLoader . getURLs ( ) ) { if ( entry . getProtocol ( ) . equals ( <str> ) ) { File file = new File ( entry . getFile ( ) ) ; if ( ! entries . containsKey ( file ) ) { entries . put ( file , classloader ) ; } } } } return ImmutableMap . copyOf ( entries ) ; } @VisibleForTesting static URL getClassPathEntry ( File jarFile , String path ) throws MalformedURLException { return new URL ( jarFile . toURI ( ) . toURL ( ) , path ) ; } } @VisibleForTesting static final class DefaultScanner extends Scanner { private final SetMultimap < ClassLoader , String > resources = MultimapBuilder . hashKeys ( ) . linkedHashSetValues ( ) . build ( ) ; ImmutableSet < ResourceInfo > getResources ( ) { ImmutableSet . Builder < ResourceInfo > builder = ImmutableSet . builder ( ) ; for ( Map . Entry < ClassLoader , String > entry : resources . entries ( ) ) { builder . add ( ResourceInfo . of ( entry . getValue ( ) , entry . getKey ( ) ) ) ; } return builder . build ( ) ; } @Override protected void scanJarFile ( ClassLoader classloader , JarFile file ) { Enumeration < JarEntry > entries = file . entries ( ) ; while ( entries . hasMoreElements ( ) ) { JarEntry entry = entries . nextElement ( ) ; if ( entry . isDirectory ( ) | | entry . getName ( ) . equals ( JarFile . MANIFEST_NAME ) ) { continue ; } resources . get ( classloader ) . add ( entry . getName ( ) ) ; } } @Override protected void scanDirectory ( ClassLoader classloader , File directory ) throws IOException { scanDirectory ( directory , classloader , <str> ) ; } private void scanDirectory ( File directory , ClassLoader classloader , String packagePrefix ) throws IOException { File [ ] files = directory . listFiles ( ) ; if ( files = = null ) { logger . warning ( <str> + directory ) ; return ; } for ( File f : files ) { String name = f . getName ( ) ; if ( f . isDirectory ( ) ) { scanDirectory ( f , classloader , packagePrefix + name + <str> ) ; } else { String resourceName = packagePrefix + name ; if ( ! resourceName . equals ( JarFile . MANIFEST_NAME ) ) { resources . get ( classloader ) . add ( resourceName ) ; } } } } } @VisibleForTesting static String getClassName ( String filename ) { int classNameEnd = filename . length ( ) - CLASS_FILE_NAME_EXTENSION . length ( ) ; return filename . substring ( <int> , classNameEnd ) . replace ( <str> , <str> ) ; } } 
