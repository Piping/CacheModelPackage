package com . badlogic . gdx . graphics . g2d ; import static com . badlogic . gdx . graphics . g2d . SpriteBatch . * ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . utils . NumberUtils ; public class Sprite extends TextureRegion { static final int VERTEX_SIZE = <int> + <int> + <int> ; static final int SPRITE_SIZE = <int> * VERTEX_SIZE ; final float [ ] vertices = new float [ SPRITE_SIZE ] ; private final Color color = new Color ( <int> , <int> , <int> , <int> ) ; private float x , y ; float width , height ; private float originX , originY ; private float rotation ; private float scaleX = <int> , scaleY = <int> ; private boolean dirty = true ; private Rectangle bounds ; public Sprite ( ) { setColor ( <int> , <int> , <int> , <int> ) ; } public Sprite ( Texture texture ) { this ( texture , <int> , <int> , texture . getWidth ( ) , texture . getHeight ( ) ) ; } public Sprite ( Texture texture , int srcWidth , int srcHeight ) { this ( texture , <int> , <int> , srcWidth , srcHeight ) ; } public Sprite ( Texture texture , int srcX , int srcY , int srcWidth , int srcHeight ) { if ( texture = = null ) throw new IllegalArgumentException ( <str> ) ; this . texture = texture ; setRegion ( srcX , srcY , srcWidth , srcHeight ) ; setColor ( <int> , <int> , <int> , <int> ) ; setSize ( Math . abs ( srcWidth ) , Math . abs ( srcHeight ) ) ; setOrigin ( width / <int> , height / <int> ) ; } public Sprite ( TextureRegion region ) { setRegion ( region ) ; setColor ( <int> , <int> , <int> , <int> ) ; setSize ( region . getRegionWidth ( ) , region . getRegionHeight ( ) ) ; setOrigin ( width / <int> , height / <int> ) ; } public Sprite ( TextureRegion region , int srcX , int srcY , int srcWidth , int srcHeight ) { setRegion ( region , srcX , srcY , srcWidth , srcHeight ) ; setColor ( <int> , <int> , <int> , <int> ) ; setSize ( Math . abs ( srcWidth ) , Math . abs ( srcHeight ) ) ; setOrigin ( width / <int> , height / <int> ) ; } public Sprite ( Sprite sprite ) { set ( sprite ) ; } public void set ( Sprite sprite ) { if ( sprite = = null ) throw new IllegalArgumentException ( <str> ) ; System . arraycopy ( sprite . vertices , <int> , vertices , <int> , SPRITE_SIZE ) ; texture = sprite . texture ; u = sprite . u ; v = sprite . v ; u2 = sprite . u2 ; v2 = sprite . v2 ; x = sprite . x ; y = sprite . y ; width = sprite . width ; height = sprite . height ; regionWidth = sprite . regionWidth ; regionHeight = sprite . regionHeight ; originX = sprite . originX ; originY = sprite . originY ; rotation = sprite . rotation ; scaleX = sprite . scaleX ; scaleY = sprite . scaleY ; color . set ( sprite . color ) ; dirty = sprite . dirty ; } public void setBounds ( float x , float y , float width , float height ) { this . x = x ; this . y = y ; this . width = width ; this . height = height ; if ( dirty ) return ; float x2 = x + width ; float y2 = y + height ; float [ ] vertices = this . vertices ; vertices [ X1 ] = x ; vertices [ Y1 ] = y ; vertices [ X2 ] = x ; vertices [ Y2 ] = y2 ; vertices [ X3 ] = x2 ; vertices [ Y3 ] = y2 ; vertices [ X4 ] = x2 ; vertices [ Y4 ] = y ; if ( rotation ! = <int> | | scaleX ! = <int> | | scaleY ! = <int> ) dirty = true ; } public void setSize ( float width , float height ) { this . width = width ; this . height = height ; if ( dirty ) return ; float x2 = x + width ; float y2 = y + height ; float [ ] vertices = this . vertices ; vertices [ X1 ] = x ; vertices [ Y1 ] = y ; vertices [ X2 ] = x ; vertices [ Y2 ] = y2 ; vertices [ X3 ] = x2 ; vertices [ Y3 ] = y2 ; vertices [ X4 ] = x2 ; vertices [ Y4 ] = y ; if ( rotation ! = <int> | | scaleX ! = <int> | | scaleY ! = <int> ) dirty = true ; } public void setPosition ( float x , float y ) { translate ( x - this . x , y - this . y ) ; } public void setX ( float x ) { translateX ( x - this . x ) ; } public void setY ( float y ) { translateY ( y - this . y ) ; } public void setCenterX ( float x ) { setX ( x - width / <int> ) ; } public void setCenterY ( float y ) { setY ( y - height / <int> ) ; } public void setCenter ( float x , float y ) { setCenterX ( x ) ; setCenterY ( y ) ; } public void translateX ( float xAmount ) { this . x + = xAmount ; if ( dirty ) return ; float [ ] vertices = this . vertices ; vertices [ X1 ] + = xAmount ; vertices [ X2 ] + = xAmount ; vertices [ X3 ] + = xAmount ; vertices [ X4 ] + = xAmount ; } public void translateY ( float yAmount ) { y + = yAmount ; if ( dirty ) return ; float [ ] vertices = this . vertices ; vertices [ Y1 ] + = yAmount ; vertices [ Y2 ] + = yAmount ; vertices [ Y3 ] + = yAmount ; vertices [ Y4 ] + = yAmount ; } public void translate ( float xAmount , float yAmount ) { x + = xAmount ; y + = yAmount ; if ( dirty ) return ; float [ ] vertices = this . vertices ; vertices [ X1 ] + = xAmount ; vertices [ Y1 ] + = yAmount ; vertices [ X2 ] + = xAmount ; vertices [ Y2 ] + = yAmount ; vertices [ X3 ] + = xAmount ; vertices [ Y3 ] + = yAmount ; vertices [ X4 ] + = xAmount ; vertices [ Y4 ] + = yAmount ; } public void setColor ( Color tint ) { float color = tint . toFloatBits ( ) ; float [ ] vertices = this . vertices ; vertices [ C1 ] = color ; vertices [ C2 ] = color ; vertices [ C3 ] = color ; vertices [ C4 ] = color ; } public void setAlpha ( float a ) { int intBits = NumberUtils . floatToIntColor ( vertices [ C1 ] ) ; int alphaBits = ( int ) ( <int> * a ) < < <int> ; intBits = intBits & <hex> ; intBits = intBits | alphaBits ; float color = NumberUtils . intToFloatColor ( intBits ) ; vertices [ C1 ] = color ; vertices [ C2 ] = color ; vertices [ C3 ] = color ; vertices [ C4 ] = color ; } public void setColor ( float r , float g , float b , float a ) { int intBits = ( ( int ) ( <int> * a ) < < <int> ) | ( ( int ) ( <int> * b ) < < <int> ) | ( ( int ) ( <int> * g ) < < <int> ) | ( ( int ) ( <int> * r ) ) ; float color = NumberUtils . intToFloatColor ( intBits ) ; float [ ] vertices = this . vertices ; vertices [ C1 ] = color ; vertices [ C2 ] = color ; vertices [ C3 ] = color ; vertices [ C4 ] = color ; } public void setColor ( float color ) { float [ ] vertices = this . vertices ; vertices [ C1 ] = color ; vertices [ C2 ] = color ; vertices [ C3 ] = color ; vertices [ C4 ] = color ; } public void setOrigin ( float originX , float originY ) { this . originX = originX ; this . originY = originY ; dirty = true ; } public void setOriginCenter ( ) { this . originX = width / <int> ; this . originY = height / <int> ; dirty = true ; } public void setRotation ( float degrees ) { this . rotation = degrees ; dirty = true ; } public float getRotation ( ) { return rotation ; } public void rotate ( float degrees ) { if ( degrees = = <int> ) return ; rotation + = degrees ; dirty = true ; } public void rotate90 ( boolean clockwise ) { float [ ] vertices = this . vertices ; if ( clockwise ) { float temp = vertices [ V1 ] ; vertices [ V1 ] = vertices [ V4 ] ; vertices [ V4 ] = vertices [ V3 ] ; vertices [ V3 ] = vertices [ V2 ] ; vertices [ V2 ] = temp ; temp = vertices [ U1 ] ; vertices [ U1 ] = vertices [ U4 ] ; vertices [ U4 ] = vertices [ U3 ] ; vertices [ U3 ] = vertices [ U2 ] ; vertices [ U2 ] = temp ; } else { float temp = vertices [ V1 ] ; vertices [ V1 ] = vertices [ V2 ] ; vertices [ V2 ] = vertices [ V3 ] ; vertices [ V3 ] = vertices [ V4 ] ; vertices [ V4 ] = temp ; temp = vertices [ U1 ] ; vertices [ U1 ] = vertices [ U2 ] ; vertices [ U2 ] = vertices [ U3 ] ; vertices [ U3 ] = vertices [ U4 ] ; vertices [ U4 ] = temp ; } } public void setScale ( float scaleXY ) { this . scaleX = scaleXY ; this . scaleY = scaleXY ; dirty = true ; } public void setScale ( float scaleX , float scaleY ) { this . scaleX = scaleX ; this . scaleY = scaleY ; dirty = true ; } public void scale ( float amount ) { this . scaleX + = amount ; this . scaleY + = amount ; dirty = true ; } public float [ ] getVertices ( ) { if ( dirty ) { dirty = false ; float [ ] vertices = this . vertices ; float localX = - originX ; float localY = - originY ; float localX2 = localX + width ; float localY2 = localY + height ; float worldOriginX = this . x - localX ; float worldOriginY = this . y - localY ; if ( scaleX ! = <int> | | scaleY ! = <int> ) { localX * = scaleX ; localY * = scaleY ; localX2 * = scaleX ; localY2 * = scaleY ; } if ( rotation ! = <int> ) { final float cos = MathUtils . cosDeg ( rotation ) ; final float sin = MathUtils . sinDeg ( rotation ) ; final float localXCos = localX * cos ; final float localXSin = localX * sin ; final float localYCos = localY * cos ; final float localYSin = localY * sin ; final float localX2Cos = localX2 * cos ; final float localX2Sin = localX2 * sin ; final float localY2Cos = localY2 * cos ; final float localY2Sin = localY2 * sin ; final float x1 = localXCos - localYSin + worldOriginX ; final float y1 = localYCos + localXSin + worldOriginY ; vertices [ X1 ] = x1 ; vertices [ Y1 ] = y1 ; final float x2 = localXCos - localY2Sin + worldOriginX ; final float y2 = localY2Cos + localXSin + worldOriginY ; vertices [ X2 ] = x2 ; vertices [ Y2 ] = y2 ; final float x3 = localX2Cos - localY2Sin + worldOriginX ; final float y3 = localY2Cos + localX2Sin + worldOriginY ; vertices [ X3 ] = x3 ; vertices [ Y3 ] = y3 ; vertices [ X4 ] = x1 + ( x3 - x2 ) ; vertices [ Y4 ] = y3 - ( y2 - y1 ) ; } else { final float x1 = localX + worldOriginX ; final float y1 = localY + worldOriginY ; final float x2 = localX2 + worldOriginX ; final float y2 = localY2 + worldOriginY ; vertices [ X1 ] = x1 ; vertices [ Y1 ] = y1 ; vertices [ X2 ] = x1 ; vertices [ Y2 ] = y2 ; vertices [ X3 ] = x2 ; vertices [ Y3 ] = y2 ; vertices [ X4 ] = x2 ; vertices [ Y4 ] = y1 ; } } return vertices ; } public Rectangle getBoundingRectangle ( ) { final float [ ] vertices = getVertices ( ) ; float minx = vertices [ X1 ] ; float miny = vertices [ Y1 ] ; float maxx = vertices [ X1 ] ; float maxy = vertices [ Y1 ] ; minx = minx > vertices [ X2 ] ? vertices [ X2 ] : minx ; minx = minx > vertices [ X3 ] ? vertices [ X3 ] : minx ; minx = minx > vertices [ X4 ] ? vertices [ X4 ] : minx ; maxx = maxx < vertices [ X2 ] ? vertices [ X2 ] : maxx ; maxx = maxx < vertices [ X3 ] ? vertices [ X3 ] : maxx ; maxx = maxx < vertices [ X4 ] ? vertices [ X4 ] : maxx ; miny = miny > vertices [ Y2 ] ? vertices [ Y2 ] : miny ; miny = miny > vertices [ Y3 ] ? vertices [ Y3 ] : miny ; miny = miny > vertices [ Y4 ] ? vertices [ Y4 ] : miny ; maxy = maxy < vertices [ Y2 ] ? vertices [ Y2 ] : maxy ; maxy = maxy < vertices [ Y3 ] ? vertices [ Y3 ] : maxy ; maxy = maxy < vertices [ Y4 ] ? vertices [ Y4 ] : maxy ; if ( bounds = = null ) bounds = new Rectangle ( ) ; bounds . x = minx ; bounds . y = miny ; bounds . width = maxx - minx ; bounds . height = maxy - miny ; return bounds ; } public void draw ( Batch batch ) { batch . draw ( texture , getVertices ( ) , <int> , SPRITE_SIZE ) ; } public void draw ( Batch batch , float alphaModulation ) { float oldAlpha = getColor ( ) . a ; setAlpha ( oldAlpha * alphaModulation ) ; draw ( batch ) ; setAlpha ( oldAlpha ) ; } public float getX ( ) { return x ; } public float getY ( ) { return y ; } public float getWidth ( ) { return width ; } public float getHeight ( ) { return height ; } public float getOriginX ( ) { return originX ; } public float getOriginY ( ) { return originY ; } public float getScaleX ( ) { return scaleX ; } public float getScaleY ( ) { return scaleY ; } public Color getColor ( ) { int intBits = NumberUtils . floatToIntColor ( vertices [ C1 ] ) ; Color color = this . color ; color . r = ( intBits & <hex> ) / <int> f ; color . g = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; color . b = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; color . a = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; return color ; } public void setRegion ( float u , float v , float u2 , float v2 ) { super . setRegion ( u , v , u2 , v2 ) ; float [ ] vertices = Sprite . this . vertices ; vertices [ U1 ] = u ; vertices [ V1 ] = v2 ; vertices [ U2 ] = u ; vertices [ V2 ] = v ; vertices [ U3 ] = u2 ; vertices [ V3 ] = v ; vertices [ U4 ] = u2 ; vertices [ V4 ] = v2 ; } public void setU ( float u ) { super . setU ( u ) ; vertices [ U1 ] = u ; vertices [ U2 ] = u ; } public void setV ( float v ) { super . setV ( v ) ; vertices [ V2 ] = v ; vertices [ V3 ] = v ; } public void setU2 ( float u2 ) { super . setU2 ( u2 ) ; vertices [ U3 ] = u2 ; vertices [ U4 ] = u2 ; } public void setV2 ( float v2 ) { super . setV2 ( v2 ) ; vertices [ V1 ] = v2 ; vertices [ V4 ] = v2 ; } public void setFlip ( boolean x , boolean y ) { boolean performX = false ; boolean performY = false ; if ( isFlipX ( ) ! = x ) { performX = true ; } if ( isFlipY ( ) ! = y ) { performY = true ; } flip ( performX , performY ) ; } public void flip ( boolean x , boolean y ) { super . flip ( x , y ) ; float [ ] vertices = Sprite . this . vertices ; if ( x ) { float temp = vertices [ U1 ] ; vertices [ U1 ] = vertices [ U3 ] ; vertices [ U3 ] = temp ; temp = vertices [ U2 ] ; vertices [ U2 ] = vertices [ U4 ] ; vertices [ U4 ] = temp ; } if ( y ) { float temp = vertices [ V1 ] ; vertices [ V1 ] = vertices [ V3 ] ; vertices [ V3 ] = temp ; temp = vertices [ V2 ] ; vertices [ V2 ] = vertices [ V4 ] ; vertices [ V4 ] = temp ; } } public void scroll ( float xAmount , float yAmount ) { float [ ] vertices = Sprite . this . vertices ; if ( xAmount ! = <int> ) { float u = ( vertices [ U1 ] + xAmount ) % <int> ; float u2 = u + width / texture . getWidth ( ) ; this . u = u ; this . u2 = u2 ; vertices [ U1 ] = u ; vertices [ U2 ] = u ; vertices [ U3 ] = u2 ; vertices [ U4 ] = u2 ; } if ( yAmount ! = <int> ) { float v = ( vertices [ V2 ] + yAmount ) % <int> ; float v2 = v + height / texture . getHeight ( ) ; this . v = v ; this . v2 = v2 ; vertices [ V1 ] = v2 ; vertices [ V2 ] = v ; vertices [ V3 ] = v ; vertices [ V4 ] = v2 ; } } } 
