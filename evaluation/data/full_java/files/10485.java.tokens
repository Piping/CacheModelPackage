package com . google . common . hash ; import com . google . common . collect . ImmutableList ; import com . google . common . hash . HashTestUtils . RandomHasherAction ; import junit . framework . TestCase ; import java . io . ByteArrayOutputStream ; import java . nio . ByteBuffer ; import java . nio . charset . Charset ; import java . util . Arrays ; import java . util . List ; import java . util . Random ; public class AbstractNonStreamingHashFunctionTest extends TestCase { public void testExhaustive ( ) { List < Hasher > hashers = ImmutableList . of ( new StreamingVersion ( ) . newHasher ( ) , new StreamingVersion ( ) . newHasher ( <int> ) , new NonStreamingVersion ( ) . newHasher ( ) , new NonStreamingVersion ( ) . newHasher ( <int> ) ) ; Random random = new Random ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { RandomHasherAction . pickAtRandom ( random ) . performAction ( random , hashers ) ; } HashCode [ ] codes = new HashCode [ hashers . size ( ) ] ; for ( int i = <int> ; i < hashers . size ( ) ; i + + ) { codes [ i ] = hashers . get ( i ) . hash ( ) ; } for ( int i = <int> ; i < codes . length ; i + + ) { assertEquals ( codes [ i - <int> ] , codes [ i ] ) ; } } public void testPutStringWithLowSurrogate ( ) { assertPutString ( new char [ ] { <str> , HashTestUtils . randomLowSurrogate ( new Random ( ) ) } ) ; } public void testPutStringWithHighSurrogate ( ) { assertPutString ( new char [ ] { <str> , HashTestUtils . randomHighSurrogate ( new Random ( ) ) } ) ; } public void testPutStringWithLowHighSurrogate ( ) { assertPutString ( new char [ ] { HashTestUtils . randomLowSurrogate ( new Random ( ) ) , HashTestUtils . randomHighSurrogate ( new Random ( ) ) } ) ; } public void testPutStringWithHighLowSurrogate ( ) { assertPutString ( new char [ ] { HashTestUtils . randomHighSurrogate ( new Random ( ) ) , HashTestUtils . randomLowSurrogate ( new Random ( ) ) } ) ; } private static void assertPutString ( char [ ] chars ) { Hasher h1 = new NonStreamingVersion ( ) . newHasher ( ) ; Hasher h2 = new NonStreamingVersion ( ) . newHasher ( ) ; String s = new String ( chars ) ; for ( int i = <int> ; i < s . length ( ) ; i + + ) { h1 . putChar ( s . charAt ( i ) ) ; } h2 . putUnencodedChars ( s ) ; assertEquals ( h1 . hash ( ) , h2 . hash ( ) ) ; } static class StreamingVersion extends AbstractStreamingHashFunction { @Override public int bits ( ) { return <int> ; } @Override public Hasher newHasher ( ) { return new AbstractStreamingHasher ( <int> , <int> ) { final ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; @Override HashCode makeHash ( ) { return HashCode . fromBytes ( out . toByteArray ( ) ) ; } @Override protected void process ( ByteBuffer bb ) { while ( bb . hasRemaining ( ) ) { out . write ( bb . get ( ) ) ; } } @Override protected void processRemaining ( ByteBuffer bb ) { while ( bb . hasRemaining ( ) ) { out . write ( bb . get ( ) ) ; } } } ; } } static class NonStreamingVersion extends AbstractNonStreamingHashFunction { @Override public int bits ( ) { return <int> ; } @Override public HashCode hashBytes ( byte [ ] input ) { return HashCode . fromBytes ( input ) ; } @Override public HashCode hashBytes ( byte [ ] input , int off , int len ) { return HashCode . fromBytes ( Arrays . copyOfRange ( input , off , off + len ) ) ; } @Override public HashCode hashString ( CharSequence input , Charset charset ) { throw new UnsupportedOperationException ( ) ; } @Override public HashCode hashLong ( long input ) { throw new UnsupportedOperationException ( ) ; } @Override public HashCode hashInt ( int input ) { throw new UnsupportedOperationException ( ) ; } } } 
