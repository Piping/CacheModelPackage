package com . google . common . escape ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import java . util . Map ; import javax . annotation . Nullable ; @Beta @GwtCompatible public abstract class ArrayBasedUnicodeEscaper extends UnicodeEscaper { private final char [ ] [ ] replacements ; private final int replacementsLength ; private final int safeMin ; private final int safeMax ; private final char safeMinChar ; private final char safeMaxChar ; protected ArrayBasedUnicodeEscaper ( Map < Character , String > replacementMap , int safeMin , int safeMax , @Nullable String unsafeReplacement ) { this ( ArrayBasedEscaperMap . create ( replacementMap ) , safeMin , safeMax , unsafeReplacement ) ; } protected ArrayBasedUnicodeEscaper ( ArrayBasedEscaperMap escaperMap , int safeMin , int safeMax , @Nullable String unsafeReplacement ) { checkNotNull ( escaperMap ) ; this . replacements = escaperMap . getReplacementArray ( ) ; this . replacementsLength = replacements . length ; if ( safeMax < safeMin ) { safeMax = - <int> ; safeMin = Integer . MAX_VALUE ; } this . safeMin = safeMin ; this . safeMax = safeMax ; if ( safeMin > = Character . MIN_HIGH_SURROGATE ) { this . safeMinChar = Character . MAX_VALUE ; this . safeMaxChar = <int> ; } else { this . safeMinChar = ( char ) safeMin ; this . safeMaxChar = ( char ) Math . min ( safeMax , Character . MIN_HIGH_SURROGATE - <int> ) ; } } @Override public final String escape ( String s ) { checkNotNull ( s ) ; for ( int i = <int> ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; if ( ( c < replacementsLength & & replacements [ c ] ! = null ) | | c > safeMaxChar | | c < safeMinChar ) { return escapeSlow ( s , i ) ; } } return s ; } @Override protected final int nextEscapeIndex ( CharSequence csq , int index , int end ) { while ( index < end ) { char c = csq . charAt ( index ) ; if ( ( c < replacementsLength & & replacements [ c ] ! = null ) | | c > safeMaxChar | | c < safeMinChar ) { break ; } index + + ; } return index ; } @Override protected final char [ ] escape ( int cp ) { if ( cp < replacementsLength ) { char [ ] chars = replacements [ cp ] ; if ( chars ! = null ) { return chars ; } } if ( cp > = safeMin & & cp < = safeMax ) { return null ; } return escapeUnsafe ( cp ) ; } protected abstract char [ ] escapeUnsafe ( int cp ) ; } 
