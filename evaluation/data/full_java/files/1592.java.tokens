package org . apache . cassandra . locator ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . ArrayList ; import java . util . Collection ; import java . util . HashSet ; import java . util . List ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . OrderPreservingPartitioner ; import org . apache . cassandra . dht . OrderPreservingPartitioner . StringToken ; import org . apache . cassandra . dht . RandomPartitioner . BigIntegerToken ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . PendingRangeCalculatorService ; import org . apache . cassandra . service . StorageServiceAccessor ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class SimpleStrategyTest { public static final String KEYSPACE1 = <str> ; @BeforeClass public static void defineSchema ( ) throws Exception { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) ) ; } @Test public void tryValidKeyspace ( ) { assert Keyspace . open ( KEYSPACE1 ) . getReplicationStrategy ( ) ! = null ; } @Test public void testBigIntegerEndpoints ( ) throws UnknownHostException { List < Token > endpointTokens = new ArrayList < Token > ( ) ; List < Token > keyTokens = new ArrayList < Token > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { endpointTokens . add ( new BigIntegerToken ( String . valueOf ( <int> * i ) ) ) ; keyTokens . add ( new BigIntegerToken ( String . valueOf ( <int> * i + <int> ) ) ) ; } verifyGetNaturalEndpoints ( endpointTokens . toArray ( new Token [ <int> ] ) , keyTokens . toArray ( new Token [ <int> ] ) ) ; } @Test public void testStringEndpoints ( ) throws UnknownHostException { IPartitioner partitioner = OrderPreservingPartitioner . instance ; List < Token > endpointTokens = new ArrayList < Token > ( ) ; List < Token > keyTokens = new ArrayList < Token > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { endpointTokens . add ( new StringToken ( String . valueOf ( ( char ) ( <str> + i * <int> ) ) ) ) ; keyTokens . add ( partitioner . getToken ( ByteBufferUtil . bytes ( String . valueOf ( ( char ) ( <str> + i * <int> + <int> ) ) ) ) ) ; } verifyGetNaturalEndpoints ( endpointTokens . toArray ( new Token [ <int> ] ) , keyTokens . toArray ( new Token [ <int> ] ) ) ; } private void verifyGetNaturalEndpoints ( Token [ ] endpointTokens , Token [ ] keyTokens ) throws UnknownHostException { TokenMetadata tmd ; AbstractReplicationStrategy strategy ; for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) { tmd = new TokenMetadata ( ) ; strategy = getStrategy ( keyspaceName , tmd ) ; List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; for ( int i = <int> ; i < endpointTokens . length ; i + + ) { InetAddress ep = InetAddress . getByName ( <str> + String . valueOf ( i + <int> ) ) ; tmd . updateNormalToken ( endpointTokens [ i ] , ep ) ; hosts . add ( ep ) ; } for ( int i = <int> ; i < keyTokens . length ; i + + ) { List < InetAddress > endpoints = strategy . getNaturalEndpoints ( keyTokens [ i ] ) ; assertEquals ( strategy . getReplicationFactor ( ) , endpoints . size ( ) ) ; List < InetAddress > correctEndpoints = new ArrayList < InetAddress > ( ) ; for ( int j = <int> ; j < endpoints . size ( ) ; j + + ) correctEndpoints . add ( hosts . get ( ( i + j + <int> ) % hosts . size ( ) ) ) ; assertEquals ( new HashSet < InetAddress > ( correctEndpoints ) , new HashSet < InetAddress > ( endpoints ) ) ; } } } @Test public void testGetEndpointsDuringBootstrap ( ) throws UnknownHostException { final int RING_SIZE = <int> ; TokenMetadata tmd = new TokenMetadata ( ) ; TokenMetadata oldTmd = StorageServiceAccessor . setTokenMetadata ( tmd ) ; Token [ ] endpointTokens = new Token [ RING_SIZE ] ; Token [ ] keyTokens = new Token [ RING_SIZE ] ; for ( int i = <int> ; i < RING_SIZE ; i + + ) { endpointTokens [ i ] = new BigIntegerToken ( String . valueOf ( RING_SIZE * <int> * i ) ) ; keyTokens [ i ] = new BigIntegerToken ( String . valueOf ( RING_SIZE * <int> * i + RING_SIZE ) ) ; } List < InetAddress > hosts = new ArrayList < InetAddress > ( ) ; for ( int i = <int> ; i < endpointTokens . length ; i + + ) { InetAddress ep = InetAddress . getByName ( <str> + String . valueOf ( i + <int> ) ) ; tmd . updateNormalToken ( endpointTokens [ i ] , ep ) ; hosts . add ( ep ) ; } Token bsToken = new BigIntegerToken ( String . valueOf ( <int> ) ) ; InetAddress bootstrapEndpoint = InetAddress . getByName ( <str> ) ; tmd . addBootstrapToken ( bsToken , bootstrapEndpoint ) ; AbstractReplicationStrategy strategy = null ; for ( String keyspaceName : Schema . instance . getNonSystemKeyspaces ( ) ) { strategy = getStrategy ( keyspaceName , tmd ) ; PendingRangeCalculatorService . calculatePendingRanges ( strategy , keyspaceName ) ; int replicationFactor = strategy . getReplicationFactor ( ) ; for ( int i = <int> ; i < keyTokens . length ; i + + ) { Collection < InetAddress > endpoints = tmd . getWriteEndpoints ( keyTokens [ i ] , keyspaceName , strategy . getNaturalEndpoints ( keyTokens [ i ] ) ) ; assertTrue ( endpoints . size ( ) > = replicationFactor ) ; for ( int j = <int> ; j < replicationFactor ; j + + ) { assertTrue ( endpoints . contains ( hosts . get ( ( i + j + <int> ) % hosts . size ( ) ) ) ) ; } if ( i < RING_SIZE - replicationFactor ) assertFalse ( endpoints . contains ( bootstrapEndpoint ) ) ; else assertTrue ( endpoints . contains ( bootstrapEndpoint ) ) ; } } StorageServiceAccessor . setTokenMetadata ( oldTmd ) ; } private AbstractReplicationStrategy getStrategy ( String keyspaceName , TokenMetadata tmd ) { KeyspaceMetadata ksmd = Schema . instance . getKSMetaData ( keyspaceName ) ; return AbstractReplicationStrategy . createReplicationStrategy ( keyspaceName , ksmd . params . replication . klass , tmd , new SimpleSnitch ( ) , ksmd . params . replication . options ) ; } } 
