package org . elasticsearch . action . indexedscripts . put ; import java . nio . charset . StandardCharsets ; import org . elasticsearch . ElasticsearchGenerationException ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Requests ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . script . ScriptService ; import java . io . IOException ; import java . util . Map ; import static org . elasticsearch . action . ValidateActions . addValidationError ; public class PutIndexedScriptRequest extends ActionRequest < PutIndexedScriptRequest > implements IndicesRequest { private String scriptLang ; private String id ; private BytesReference source ; private IndexRequest . OpType opType = IndexRequest . OpType . INDEX ; private long version = Versions . MATCH_ANY ; private VersionType versionType = VersionType . INTERNAL ; private XContentType contentType = Requests . INDEX_CONTENT_TYPE ; public PutIndexedScriptRequest ( ) { super ( ) ; } public PutIndexedScriptRequest ( String scriptLang ) { super ( ) ; this . scriptLang = scriptLang ; } public PutIndexedScriptRequest ( String scriptLang , String id ) { super ( ) ; this . scriptLang = scriptLang ; this . id = id ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( scriptLang = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( source = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( id = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( ! versionType . validateVersionForWrites ( version ) ) { validationException = addValidationError ( <str> + version + <str> + versionType . name ( ) + <str> , validationException ) ; } return validationException ; } @Override public String [ ] indices ( ) { return new String [ ] { ScriptService . SCRIPT_INDEX } ; } @Override public IndicesOptions indicesOptions ( ) { return IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ; } public PutIndexedScriptRequest contentType ( XContentType contentType ) { this . contentType = contentType ; return this ; } public String scriptLang ( ) { return scriptLang ; } public PutIndexedScriptRequest scriptLang ( String scriptLang ) { this . scriptLang = scriptLang ; return this ; } public String id ( ) { return id ; } public PutIndexedScriptRequest id ( String id ) { this . id = id ; return this ; } public BytesReference source ( ) { return source ; } public Map < String , Object > sourceAsMap ( ) { return XContentHelper . convertToMap ( source , false ) . v2 ( ) ; } public PutIndexedScriptRequest source ( Map source ) throws ElasticsearchGenerationException { return source ( source , contentType ) ; } public PutIndexedScriptRequest source ( Map source , XContentType contentType ) throws ElasticsearchGenerationException { try { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . map ( source ) ; return source ( builder ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> + source + <str> , e ) ; } } public PutIndexedScriptRequest source ( String source ) { this . source = new BytesArray ( source . getBytes ( StandardCharsets . UTF_8 ) ) ; return this ; } public PutIndexedScriptRequest source ( XContentBuilder sourceBuilder ) { source = sourceBuilder . bytes ( ) ; return this ; } public PutIndexedScriptRequest source ( Object . . . source ) { if ( source . length % <int> ! = <int> ) { throw new IllegalArgumentException ( <str> + source . length + <str> ) ; } try { XContentBuilder builder = XContentFactory . contentBuilder ( contentType ) ; builder . startObject ( ) ; for ( int i = <int> ; i < source . length ; i + + ) { builder . field ( source [ i + + ] . toString ( ) , source [ i ] ) ; } builder . endObject ( ) ; return source ( builder ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> , e ) ; } } public PutIndexedScriptRequest source ( BytesReference source ) { this . source = source ; return this ; } public PutIndexedScriptRequest source ( byte [ ] source ) { return source ( source , <int> , source . length ) ; } public PutIndexedScriptRequest source ( byte [ ] source , int offset , int length ) { return source ( new BytesArray ( source , offset , length ) ) ; } public PutIndexedScriptRequest opType ( IndexRequest . OpType opType ) { this . opType = opType ; return this ; } public PutIndexedScriptRequest create ( boolean create ) { if ( create ) { return opType ( IndexRequest . OpType . CREATE ) ; } else { return opType ( IndexRequest . OpType . INDEX ) ; } } public IndexRequest . OpType opType ( ) { return this . opType ; } public PutIndexedScriptRequest version ( long version ) { this . version = version ; return this ; } public long version ( ) { return this . version ; } public PutIndexedScriptRequest versionType ( VersionType versionType ) { this . versionType = versionType ; return this ; } public VersionType versionType ( ) { return this . versionType ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; scriptLang = in . readString ( ) ; id = in . readOptionalString ( ) ; source = in . readBytesReference ( ) ; opType = IndexRequest . OpType . fromId ( in . readByte ( ) ) ; version = in . readLong ( ) ; versionType = VersionType . fromValue ( in . readByte ( ) ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( scriptLang ) ; out . writeOptionalString ( id ) ; out . writeBytesReference ( source ) ; out . writeByte ( opType . id ( ) ) ; out . writeLong ( version ) ; out . writeByte ( versionType . getValue ( ) ) ; } @Override public String toString ( ) { String sSource = <str> ; try { sSource = XContentHelper . convertToJson ( source , false ) ; } catch ( Exception e ) { } return <str> + ScriptService . SCRIPT_INDEX + <str> + scriptLang + <str> + id + <str> + sSource + <str> ; } } 
