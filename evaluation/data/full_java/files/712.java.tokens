package org . apache . cassandra . io . sstable . format . big ; import java . util . Collection ; import java . util . Set ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . RowIndexEntry ; import org . apache . cassandra . db . SerializationHeader ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . io . sstable . Component ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . * ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; import org . apache . cassandra . io . sstable . metadata . StatsMetadata ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . ChecksumType ; public class BigFormat implements SSTableFormat { public static final BigFormat instance = new BigFormat ( ) ; public static final Version latestVersion = new BigVersion ( BigVersion . current_version ) ; private static final SSTableReader . Factory readerFactory = new ReaderFactory ( ) ; private static final SSTableWriter . Factory writerFactory = new WriterFactory ( ) ; private BigFormat ( ) { } @Override public Version getLatestVersion ( ) { return latestVersion ; } @Override public Version getVersion ( String version ) { return new BigVersion ( version ) ; } @Override public SSTableWriter . Factory getWriterFactory ( ) { return writerFactory ; } @Override public SSTableReader . Factory getReaderFactory ( ) { return readerFactory ; } @Override public RowIndexEntry . IndexSerializer getIndexSerializer ( CFMetaData metadata , Version version , SerializationHeader header ) { return new RowIndexEntry . Serializer ( metadata , version , header ) ; } static class WriterFactory extends SSTableWriter . Factory { @Override public SSTableWriter open ( Descriptor descriptor , long keyCount , long repairedAt , CFMetaData metadata , MetadataCollector metadataCollector , SerializationHeader header , Collection < SSTableFlushObserver > observers , LifecycleTransaction txn ) { return new BigTableWriter ( descriptor , keyCount , repairedAt , metadata , metadataCollector , header , observers , txn ) ; } } static class ReaderFactory extends SSTableReader . Factory { @Override public SSTableReader open ( Descriptor descriptor , Set < Component > components , CFMetaData metadata , Long maxDataAge , StatsMetadata sstableMetadata , SSTableReader . OpenReason openReason , SerializationHeader header ) { return new BigTableReader ( descriptor , components , metadata , maxDataAge , sstableMetadata , openReason , header ) ; } } static class BigVersion extends Version { public static final String current_version = <str> ; public static final String earliest_supported_version = <str> ; private final boolean isLatestVersion ; private final boolean hasSamplingLevel ; private final boolean newStatsFile ; private final ChecksumType compressedChecksumType ; private final ChecksumType uncompressedChecksumType ; private final boolean hasRepairedAt ; private final boolean tracksLegacyCounterShards ; private final boolean newFileName ; public final boolean storeRows ; public final int correspondingMessagingVersion ; public final boolean hasBoundaries ; private final boolean hasOldBfHashOrder ; private final boolean hasCompactionAncestors ; BigVersion ( String version ) { super ( instance , version ) ; isLatestVersion = version . compareTo ( current_version ) = = <int> ; hasSamplingLevel = version . compareTo ( <str> ) > = <int> ; newStatsFile = version . compareTo ( <str> ) > = <int> ; ChecksumType checksumType = ChecksumType . CRC32 ; if ( version . compareTo ( <str> ) > = <int> & & version . compareTo ( <str> ) < <int> ) checksumType = ChecksumType . Adler32 ; this . uncompressedChecksumType = checksumType ; checksumType = ChecksumType . CRC32 ; if ( version . compareTo ( <str> ) > = <int> & & version . compareTo ( <str> ) < <int> ) checksumType = ChecksumType . Adler32 ; this . compressedChecksumType = checksumType ; hasRepairedAt = version . compareTo ( <str> ) > = <int> ; tracksLegacyCounterShards = version . compareTo ( <str> ) > = <int> ; newFileName = version . compareTo ( <str> ) > = <int> ; hasOldBfHashOrder = version . compareTo ( <str> ) < <int> ; hasCompactionAncestors = version . compareTo ( <str> ) < <int> ; storeRows = version . compareTo ( <str> ) > = <int> ; correspondingMessagingVersion = storeRows ? MessagingService . VERSION_30 : MessagingService . VERSION_21 ; hasBoundaries = version . compareTo ( <str> ) < <int> ; } @Override public boolean isLatestVersion ( ) { return isLatestVersion ; } @Override public boolean hasSamplingLevel ( ) { return hasSamplingLevel ; } @Override public boolean hasNewStatsFile ( ) { return newStatsFile ; } @Override public ChecksumType compressedChecksumType ( ) { return compressedChecksumType ; } @Override public ChecksumType uncompressedChecksumType ( ) { return uncompressedChecksumType ; } @Override public boolean hasRepairedAt ( ) { return hasRepairedAt ; } @Override public boolean tracksLegacyCounterShards ( ) { return tracksLegacyCounterShards ; } @Override public boolean hasOldBfHashOrder ( ) { return hasOldBfHashOrder ; } @Override public boolean hasCompactionAncestors ( ) { return hasCompactionAncestors ; } @Override public boolean hasNewFileName ( ) { return newFileName ; } @Override public boolean storeRows ( ) { return storeRows ; } @Override public int correspondingMessagingVersion ( ) { return correspondingMessagingVersion ; } @Override public boolean hasBoundaries ( ) { return hasBoundaries ; } @Override public boolean isCompatible ( ) { return version . compareTo ( earliest_supported_version ) > = <int> & & version . charAt ( <int> ) < = current_version . charAt ( <int> ) ; } @Override public boolean isCompatibleForStreaming ( ) { return isCompatible ( ) & & version . charAt ( <int> ) = = current_version . charAt ( <int> ) ; } } } 
