package org . elasticsearch . plan . a ; import org . elasticsearch . test . ESTestCase ; public class UtilityTests extends ESTestCase { public void testDivideWithoutOverflowInt ( ) { assertEquals ( <int> / <int> , Utility . divideWithoutOverflow ( <int> , <int> ) ) ; try { Utility . divideWithoutOverflow ( Integer . MIN_VALUE , - <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . divideWithoutOverflow ( <int> , <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testDivideWithoutOverflowLong ( ) { assertEquals ( <int> / <int> , Utility . divideWithoutOverflow ( <int> , <int> ) ) ; try { Utility . divideWithoutOverflow ( Long . MIN_VALUE , - <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . divideWithoutOverflow ( <int> , <int> L ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testToByteExact ( ) { for ( int b = Byte . MIN_VALUE ; b < Byte . MAX_VALUE ; b + + ) { assertEquals ( ( byte ) b , Utility . toByteExact ( b ) ) ; } try { Utility . toByteExact ( Byte . MIN_VALUE - <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . toByteExact ( Byte . MAX_VALUE + <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testToShortExact ( ) { for ( int s = Short . MIN_VALUE ; s < Short . MAX_VALUE ; s + + ) { assertEquals ( ( short ) s , Utility . toShortExact ( s ) ) ; } try { Utility . toShortExact ( Short . MIN_VALUE - <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . toShortExact ( Short . MAX_VALUE + <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testToCharExact ( ) { for ( int c = Character . MIN_VALUE ; c < Character . MAX_VALUE ; c + + ) { assertEquals ( ( char ) c , Utility . toCharExact ( c ) ) ; } try { Utility . toCharExact ( Character . MIN_VALUE - <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . toCharExact ( Character . MAX_VALUE + <int> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testAddWithoutOverflowFloat ( ) { assertEquals ( <int> F , Utility . addWithoutOverflow ( <float> , <float> ) , <float> ) ; assertTrue ( Float . isNaN ( Utility . addWithoutOverflow ( <float> , Float . NaN ) ) ) ; assertTrue ( Float . isNaN ( Utility . addWithoutOverflow ( Float . POSITIVE_INFINITY , Float . NEGATIVE_INFINITY ) ) ) ; try { Utility . addWithoutOverflow ( Float . MAX_VALUE , Float . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . addWithoutOverflow ( - Float . MAX_VALUE , - Float . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testAddWithoutOverflowDouble ( ) { assertEquals ( <int> D , Utility . addWithoutOverflow ( <float> , <float> ) , <float> ) ; assertTrue ( Double . isNaN ( Utility . addWithoutOverflow ( <float> , Double . NaN ) ) ) ; assertTrue ( Double . isNaN ( Utility . addWithoutOverflow ( Double . POSITIVE_INFINITY , Double . NEGATIVE_INFINITY ) ) ) ; try { Utility . addWithoutOverflow ( Double . MAX_VALUE , Double . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . addWithoutOverflow ( - Double . MAX_VALUE , - Double . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testSubtractWithoutOverflowFloat ( ) { assertEquals ( <float> , Utility . subtractWithoutOverflow ( <int> F , <float> ) , <float> ) ; assertTrue ( Float . isNaN ( Utility . subtractWithoutOverflow ( <float> , Float . NaN ) ) ) ; assertTrue ( Float . isNaN ( Utility . subtractWithoutOverflow ( Float . POSITIVE_INFINITY , Float . POSITIVE_INFINITY ) ) ) ; try { Utility . subtractWithoutOverflow ( Float . MAX_VALUE , - Float . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . subtractWithoutOverflow ( - Float . MAX_VALUE , Float . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testSubtractWithoutOverflowDouble ( ) { assertEquals ( <float> , Utility . subtractWithoutOverflow ( <int> D , <float> ) , <float> ) ; assertTrue ( Double . isNaN ( Utility . subtractWithoutOverflow ( <float> , Double . NaN ) ) ) ; assertTrue ( Double . isNaN ( Utility . subtractWithoutOverflow ( Double . POSITIVE_INFINITY , Double . POSITIVE_INFINITY ) ) ) ; try { Utility . subtractWithoutOverflow ( Double . MAX_VALUE , - Double . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . subtractWithoutOverflow ( - Double . MAX_VALUE , Double . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testMultiplyWithoutOverflowFloat ( ) { assertEquals ( <int> F , Utility . multiplyWithoutOverflow ( <float> , <float> ) , <float> ) ; assertTrue ( Float . isNaN ( Utility . multiplyWithoutOverflow ( <float> , Float . NaN ) ) ) ; assertEquals ( Float . POSITIVE_INFINITY , Utility . multiplyWithoutOverflow ( <float> , Float . POSITIVE_INFINITY ) , <float> ) ; try { Utility . multiplyWithoutOverflow ( Float . MAX_VALUE , Float . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testMultiplyWithoutOverflowDouble ( ) { assertEquals ( <int> D , Utility . multiplyWithoutOverflow ( <float> , <float> ) , <float> ) ; assertTrue ( Double . isNaN ( Utility . multiplyWithoutOverflow ( <float> , Double . NaN ) ) ) ; assertEquals ( Double . POSITIVE_INFINITY , Utility . multiplyWithoutOverflow ( <float> , Double . POSITIVE_INFINITY ) , <float> ) ; try { Utility . multiplyWithoutOverflow ( Double . MAX_VALUE , Double . MAX_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testDivideWithoutOverflowFloat ( ) { assertEquals ( <float> , Utility . divideWithoutOverflow ( <int> F , <float> ) , <float> ) ; assertTrue ( Float . isNaN ( Utility . divideWithoutOverflow ( <float> , Float . NaN ) ) ) ; assertEquals ( Float . POSITIVE_INFINITY , Utility . divideWithoutOverflow ( Float . POSITIVE_INFINITY , <float> ) , <float> ) ; try { Utility . divideWithoutOverflow ( Float . MAX_VALUE , Float . MIN_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . divideWithoutOverflow ( <float> , <float> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . divideWithoutOverflow ( <float> , <float> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testDivideWithoutOverflowDouble ( ) { assertEquals ( <float> , Utility . divideWithoutOverflow ( <int> D , <float> ) , <float> ) ; assertTrue ( Double . isNaN ( Utility . divideWithoutOverflow ( <float> , Double . NaN ) ) ) ; assertEquals ( Double . POSITIVE_INFINITY , Utility . divideWithoutOverflow ( Double . POSITIVE_INFINITY , <float> ) , <float> ) ; try { Utility . divideWithoutOverflow ( Double . MAX_VALUE , Double . MIN_VALUE ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . divideWithoutOverflow ( <float> , <float> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } try { Utility . divideWithoutOverflow ( <float> , <float> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testRemainderWithoutOverflowFloat ( ) { assertEquals ( <float> , Utility . remainderWithoutOverflow ( <int> F , <float> ) , <float> ) ; try { Utility . remainderWithoutOverflow ( <float> , <float> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } public void testRemainderWithoutOverflowDouble ( ) { assertEquals ( <float> , Utility . remainderWithoutOverflow ( <int> D , <float> ) , <float> ) ; try { Utility . remainderWithoutOverflow ( <float> , <float> ) ; fail ( <str> ) ; } catch ( ArithmeticException expected ) { } } } 
