package com . google . common . primitives ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import sun . misc . Unsafe ; import java . nio . ByteOrder ; import java . util . Comparator ; import javax . annotation . CheckReturnValue ; public final class UnsignedBytes { private UnsignedBytes ( ) { } public static final byte MAX_POWER_OF_TWO = ( byte ) <hex> ; public static final byte MAX_VALUE = ( byte ) <hex> ; private static final int UNSIGNED_MASK = <hex> ; @CheckReturnValue public static int toInt ( byte value ) { return value & UNSIGNED_MASK ; } public static byte checkedCast ( long value ) { if ( ( value > > Byte . SIZE ) ! = <int> ) { throw new IllegalArgumentException ( <str> + value ) ; } return ( byte ) value ; } public static byte saturatedCast ( long value ) { if ( value > toInt ( MAX_VALUE ) ) { return MAX_VALUE ; } if ( value < <int> ) { return ( byte ) <int> ; } return ( byte ) value ; } @CheckReturnValue public static int compare ( byte a , byte b ) { return toInt ( a ) - toInt ( b ) ; } @CheckReturnValue public static byte min ( byte . . . array ) { checkArgument ( array . length > <int> ) ; int min = toInt ( array [ <int> ] ) ; for ( int i = <int> ; i < array . length ; i + + ) { int next = toInt ( array [ i ] ) ; if ( next < min ) { min = next ; } } return ( byte ) min ; } @CheckReturnValue public static byte max ( byte . . . array ) { checkArgument ( array . length > <int> ) ; int max = toInt ( array [ <int> ] ) ; for ( int i = <int> ; i < array . length ; i + + ) { int next = toInt ( array [ i ] ) ; if ( next > max ) { max = next ; } } return ( byte ) max ; } @Beta @CheckReturnValue public static String toString ( byte x ) { return toString ( x , <int> ) ; } @Beta @CheckReturnValue public static String toString ( byte x , int radix ) { checkArgument ( radix > = Character . MIN_RADIX & & radix < = Character . MAX_RADIX , <str> , radix ) ; return Integer . toString ( toInt ( x ) , radix ) ; } @Beta public static byte parseUnsignedByte ( String string ) { return parseUnsignedByte ( string , <int> ) ; } @Beta public static byte parseUnsignedByte ( String string , int radix ) { int parse = Integer . parseInt ( checkNotNull ( string ) , radix ) ; if ( parse > > Byte . SIZE = = <int> ) { return ( byte ) parse ; } else { throw new NumberFormatException ( <str> + parse ) ; } } @CheckReturnValue public static String join ( String separator , byte . . . array ) { checkNotNull ( separator ) ; if ( array . length = = <int> ) { return <str> ; } StringBuilder builder = new StringBuilder ( array . length * ( <int> + separator . length ( ) ) ) ; builder . append ( toInt ( array [ <int> ] ) ) ; for ( int i = <int> ; i < array . length ; i + + ) { builder . append ( separator ) . append ( toString ( array [ i ] ) ) ; } return builder . toString ( ) ; } @CheckReturnValue public static Comparator < byte [ ] > lexicographicalComparator ( ) { return LexicographicalComparatorHolder . BEST_COMPARATOR ; } @VisibleForTesting static Comparator < byte [ ] > lexicographicalComparatorJavaImpl ( ) { return LexicographicalComparatorHolder . PureJavaComparator . INSTANCE ; } @VisibleForTesting static class LexicographicalComparatorHolder { static final String UNSAFE_COMPARATOR_NAME = LexicographicalComparatorHolder . class . getName ( ) + <str> ; static final Comparator < byte [ ] > BEST_COMPARATOR = getBestComparator ( ) ; @VisibleForTesting enum UnsafeComparator implements Comparator < byte [ ] > { INSTANCE ; static final boolean BIG_ENDIAN = ByteOrder . nativeOrder ( ) . equals ( ByteOrder . BIG_ENDIAN ) ; static final Unsafe theUnsafe ; static final int BYTE_ARRAY_BASE_OFFSET ; static { theUnsafe = getUnsafe ( ) ; BYTE_ARRAY_BASE_OFFSET = theUnsafe . arrayBaseOffset ( byte [ ] . class ) ; if ( theUnsafe . arrayIndexScale ( byte [ ] . class ) ! = <int> ) { throw new AssertionError ( ) ; } } private static sun . misc . Unsafe getUnsafe ( ) { try { return sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException e ) { } try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) { return k . cast ( x ) ; } } throw new NoSuchFieldError ( <str> ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw new RuntimeException ( <str> , e . getCause ( ) ) ; } } @Override public int compare ( byte [ ] left , byte [ ] right ) { int minLength = Math . min ( left . length , right . length ) ; int minWords = minLength / Longs . BYTES ; for ( int i = <int> ; i < minWords * Longs . BYTES ; i + = Longs . BYTES ) { long lw = theUnsafe . getLong ( left , BYTE_ARRAY_BASE_OFFSET + ( long ) i ) ; long rw = theUnsafe . getLong ( right , BYTE_ARRAY_BASE_OFFSET + ( long ) i ) ; if ( lw ! = rw ) { if ( BIG_ENDIAN ) { return UnsignedLongs . compare ( lw , rw ) ; } int n = Long . numberOfTrailingZeros ( lw ^ rw ) & ~ <hex> ; return ( int ) ( ( ( lw > > > n ) & UNSIGNED_MASK ) - ( ( rw > > > n ) & UNSIGNED_MASK ) ) ; } } for ( int i = minWords * Longs . BYTES ; i < minLength ; i + + ) { int result = UnsignedBytes . compare ( left [ i ] , right [ i ] ) ; if ( result ! = <int> ) { return result ; } } return left . length - right . length ; } @Override public String toString ( ) { return <str> ; } } enum PureJavaComparator implements Comparator < byte [ ] > { INSTANCE ; @Override public int compare ( byte [ ] left , byte [ ] right ) { int minLength = Math . min ( left . length , right . length ) ; for ( int i = <int> ; i < minLength ; i + + ) { int result = UnsignedBytes . compare ( left [ i ] , right [ i ] ) ; if ( result ! = <int> ) { return result ; } } return left . length - right . length ; } @Override public String toString ( ) { return <str> ; } } static Comparator < byte [ ] > getBestComparator ( ) { try { Class < ? > theClass = Class . forName ( UNSAFE_COMPARATOR_NAME ) ; @SuppressWarnings ( <str> ) Comparator < byte [ ] > comparator = ( Comparator < byte [ ] > ) theClass . getEnumConstants ( ) [ <int> ] ; return comparator ; } catch ( Throwable t ) { return lexicographicalComparatorJavaImpl ( ) ; } } } } 
