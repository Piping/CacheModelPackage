package org . apache . cassandra . db . monitoring ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . config . Config ; import static java . lang . System . getProperty ; public class MonitoringTask { private static final String LINE_SEPARATOR = getProperty ( <str> ) ; private static final Logger logger = LoggerFactory . getLogger ( MonitoringTask . class ) ; private static final int REPORT_INTERVAL_MS = Math . max ( <int> , Integer . valueOf ( System . getProperty ( Config . PROPERTY_PREFIX + <str> , <str> ) ) ) ; private static final int MAX_OPERATIONS = Integer . valueOf ( System . getProperty ( Config . PROPERTY_PREFIX + <str> , <str> ) ) ; @VisibleForTesting static MonitoringTask instance = make ( REPORT_INTERVAL_MS , MAX_OPERATIONS ) ; private final int maxOperations ; private final ScheduledFuture < ? > reportingTask ; private final BlockingQueue < FailedOperation > operationsQueue ; private final AtomicLong numDroppedOperations ; private long lastLogTime ; @VisibleForTesting static MonitoringTask make ( int reportIntervalMillis , int maxTimedoutOperations ) { if ( instance ! = null ) { instance . cancel ( ) ; instance = null ; } return new MonitoringTask ( reportIntervalMillis , maxTimedoutOperations ) ; } private MonitoringTask ( int reportIntervalMillis , int maxOperations ) { this . maxOperations = maxOperations ; this . operationsQueue = maxOperations > <int> ? new ArrayBlockingQueue < > ( maxOperations ) : new LinkedBlockingQueue < > ( ) ; this . numDroppedOperations = new AtomicLong ( ) ; this . lastLogTime = ApproximateTime . currentTimeMillis ( ) ; logger . info ( <str> , reportIntervalMillis , maxOperations ) ; this . reportingTask = ScheduledExecutors . scheduledTasks . scheduleWithFixedDelay ( ( ) - > logFailedOperations ( ApproximateTime . currentTimeMillis ( ) ) , reportIntervalMillis , reportIntervalMillis , TimeUnit . MILLISECONDS ) ; } public void cancel ( ) { reportingTask . cancel ( false ) ; } public static void addFailedOperation ( Monitorable operation , long now ) { instance . innerAddFailedOperation ( operation , now ) ; } private void innerAddFailedOperation ( Monitorable operation , long now ) { if ( maxOperations = = <int> ) return ; if ( ! operationsQueue . offer ( new FailedOperation ( operation , now ) ) ) numDroppedOperations . incrementAndGet ( ) ; } @VisibleForTesting FailedOperations aggregateFailedOperations ( ) { Map < String , FailedOperation > operations = new HashMap < > ( ) ; FailedOperation failedOperation ; while ( ( failedOperation = operationsQueue . poll ( ) ) ! = null ) { FailedOperation existing = operations . get ( failedOperation . name ( ) ) ; if ( existing ! = null ) existing . addTimeout ( failedOperation ) ; else operations . put ( failedOperation . name ( ) , failedOperation ) ; } return new FailedOperations ( operations , numDroppedOperations . getAndSet ( <int> L ) ) ; } @VisibleForTesting List < String > getFailedOperations ( ) { FailedOperations failedOperations = aggregateFailedOperations ( ) ; String ret = failedOperations . getLogMessage ( ) ; lastLogTime = ApproximateTime . currentTimeMillis ( ) ; return ret . isEmpty ( ) ? Collections . emptyList ( ) : Arrays . asList ( ret . split ( <str> ) ) ; } @VisibleForTesting void logFailedOperations ( long now ) { FailedOperations failedOperations = aggregateFailedOperations ( ) ; if ( ! failedOperations . isEmpty ( ) ) { long elapsed = now - lastLogTime ; logger . warn ( <str> , failedOperations . num ( ) , elapsed ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( <str> , failedOperations . num ( ) , elapsed , LINE_SEPARATOR , failedOperations . getLogMessage ( ) ) ; } lastLogTime = now ; } private static final class FailedOperations { public final Map < String , FailedOperation > operations ; public final long numDropped ; FailedOperations ( Map < String , FailedOperation > operations , long numDropped ) { this . operations = operations ; this . numDropped = numDropped ; } public boolean isEmpty ( ) { return operations . isEmpty ( ) & & numDropped = = <int> ; } public long num ( ) { return operations . size ( ) + numDropped ; } public String getLogMessage ( ) { if ( isEmpty ( ) ) return <str> ; final StringBuilder ret = new StringBuilder ( ) ; operations . values ( ) . forEach ( o - > addOperation ( ret , o ) ) ; if ( numDropped > <int> ) ret . append ( LINE_SEPARATOR ) . append ( <str> ) . append ( numDropped ) . append ( <str> ) ; return ret . toString ( ) ; } private static void addOperation ( StringBuilder ret , FailedOperation operation ) { if ( ret . length ( ) > <int> ) ret . append ( LINE_SEPARATOR ) ; ret . append ( operation . getLogMessage ( ) ) ; } } private final static class FailedOperation { public final Monitorable operation ; public int numTimeouts ; public long totalTime ; public long maxTime ; public long minTime ; private String name ; FailedOperation ( Monitorable operation , long failedAt ) { this . operation = operation ; numTimeouts = <int> ; totalTime = failedAt - operation . constructionTime ( ) . timestamp ; minTime = totalTime ; maxTime = totalTime ; } public String name ( ) { if ( name = = null ) name = operation . name ( ) ; return name ; } void addTimeout ( FailedOperation operation ) { numTimeouts + + ; totalTime + = operation . totalTime ; maxTime = Math . max ( maxTime , operation . maxTime ) ; minTime = Math . min ( minTime , operation . minTime ) ; } public String getLogMessage ( ) { if ( numTimeouts = = <int> ) return String . format ( <str> , name ( ) , totalTime , operation . timeout ( ) , operation . constructionTime ( ) . isCrossNode ? <str> : <str> ) ; else return String . format ( <str> , name ( ) , numTimeouts , totalTime / numTimeouts , minTime , maxTime , operation . timeout ( ) , operation . constructionTime ( ) . isCrossNode ? <str> : <str> ) ; } } } 
