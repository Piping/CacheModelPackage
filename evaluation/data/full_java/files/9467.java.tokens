package com . google . common . net ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkState ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Objects ; import com . google . common . base . Strings ; import java . io . Serializable ; import javax . annotation . Nullable ; import javax . annotation . concurrent . Immutable ; @Beta @Immutable @GwtCompatible public final class HostAndPort implements Serializable { private static final int NO_PORT = - <int> ; private final String host ; private final int port ; private final boolean hasBracketlessColons ; private HostAndPort ( String host , int port , boolean hasBracketlessColons ) { this . host = host ; this . port = port ; this . hasBracketlessColons = hasBracketlessColons ; } public String getHostText ( ) { return host ; } public boolean hasPort ( ) { return port > = <int> ; } public int getPort ( ) { checkState ( hasPort ( ) ) ; return port ; } public int getPortOrDefault ( int defaultPort ) { return hasPort ( ) ? port : defaultPort ; } public static HostAndPort fromParts ( String host , int port ) { checkArgument ( isValidPort ( port ) , <str> , port ) ; HostAndPort parsedHost = fromString ( host ) ; checkArgument ( ! parsedHost . hasPort ( ) , <str> , host ) ; return new HostAndPort ( parsedHost . host , port , parsedHost . hasBracketlessColons ) ; } public static HostAndPort fromHost ( String host ) { HostAndPort parsedHost = fromString ( host ) ; checkArgument ( ! parsedHost . hasPort ( ) , <str> , host ) ; return parsedHost ; } public static HostAndPort fromString ( String hostPortString ) { checkNotNull ( hostPortString ) ; String host ; String portString = null ; boolean hasBracketlessColons = false ; if ( hostPortString . startsWith ( <str> ) ) { String [ ] hostAndPort = getHostAndPortFromBracketedHost ( hostPortString ) ; host = hostAndPort [ <int> ] ; portString = hostAndPort [ <int> ] ; } else { int colonPos = hostPortString . indexOf ( <str> ) ; if ( colonPos > = <int> & & hostPortString . indexOf ( <str> , colonPos + <int> ) = = - <int> ) { host = hostPortString . substring ( <int> , colonPos ) ; portString = hostPortString . substring ( colonPos + <int> ) ; } else { host = hostPortString ; hasBracketlessColons = ( colonPos > = <int> ) ; } } int port = NO_PORT ; if ( ! Strings . isNullOrEmpty ( portString ) ) { checkArgument ( ! portString . startsWith ( <str> ) , <str> , hostPortString ) ; try { port = Integer . parseInt ( portString ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( <str> + hostPortString ) ; } checkArgument ( isValidPort ( port ) , <str> , hostPortString ) ; } return new HostAndPort ( host , port , hasBracketlessColons ) ; } private static String [ ] getHostAndPortFromBracketedHost ( String hostPortString ) { int colonIndex = <int> ; int closeBracketIndex = <int> ; checkArgument ( hostPortString . charAt ( <int> ) = = <str> , <str> , hostPortString ) ; colonIndex = hostPortString . indexOf ( <str> ) ; closeBracketIndex = hostPortString . lastIndexOf ( <str> ) ; checkArgument ( colonIndex > - <int> & & closeBracketIndex > colonIndex , <str> , hostPortString ) ; String host = hostPortString . substring ( <int> , closeBracketIndex ) ; if ( closeBracketIndex + <int> = = hostPortString . length ( ) ) { return new String [ ] { host , <str> } ; } else { checkArgument ( hostPortString . charAt ( closeBracketIndex + <int> ) = = <str> , <str> , hostPortString ) ; for ( int i = closeBracketIndex + <int> ; i < hostPortString . length ( ) ; + + i ) { checkArgument ( Character . isDigit ( hostPortString . charAt ( i ) ) , <str> , hostPortString ) ; } return new String [ ] { host , hostPortString . substring ( closeBracketIndex + <int> ) } ; } } public HostAndPort withDefaultPort ( int defaultPort ) { checkArgument ( isValidPort ( defaultPort ) ) ; if ( hasPort ( ) | | port = = defaultPort ) { return this ; } return new HostAndPort ( host , defaultPort , hasBracketlessColons ) ; } public HostAndPort requireBracketsForIPv6 ( ) { checkArgument ( ! hasBracketlessColons , <str> , host ) ; return this ; } @Override public boolean equals ( @Nullable Object other ) { if ( this = = other ) { return true ; } if ( other instanceof HostAndPort ) { HostAndPort that = ( HostAndPort ) other ; return Objects . equal ( this . host , that . host ) & & this . port = = that . port & & this . hasBracketlessColons = = that . hasBracketlessColons ; } return false ; } @Override public int hashCode ( ) { return Objects . hashCode ( host , port , hasBracketlessColons ) ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( host . length ( ) + <int> ) ; if ( host . indexOf ( <str> ) > = <int> ) { builder . append ( <str> ) . append ( host ) . append ( <str> ) ; } else { builder . append ( host ) ; } if ( hasPort ( ) ) { builder . append ( <str> ) . append ( port ) ; } return builder . toString ( ) ; } private static boolean isValidPort ( int port ) { return port > = <int> & & port < = <int> ; } private static final long serialVersionUID = <int> ; } 
