package org . gradle . performance . fixture ; import org . gradle . performance . measure . DataAmount ; import org . gradle . performance . measure . MeasuredOperation ; import org . gradle . util . GFileUtils ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . IOException ; import java . math . BigDecimal ; import java . text . DecimalFormatSymbols ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Locale ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class GCLoggingCollector implements DataCollector { private File logFile ; @Override public List < String > getAdditionalJvmOpts ( File workingDir ) { logFile = new File ( workingDir , <str> ) ; return Arrays . asList ( <str> , <str> , <str> , <str> + logFile . getAbsolutePath ( ) , <str> ) ; } @Override public List < String > getAdditionalArgs ( File workingDir ) { return Collections . emptyList ( ) ; } public void collect ( BuildExperimentInvocationInfo invocationInfo , MeasuredOperation operation ) { collect ( operation , Locale . getDefault ( ) ) ; if ( logFile . exists ( ) & & invocationInfo ! = null ) { LogFiles . copyLogFile ( logFile , invocationInfo , <str> , <str> ) ; } } public void collect ( MeasuredOperation operation , Locale locale ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( logFile ) ) ; try { collect ( new WaitingReader ( reader ) , operation , locale ) ; } finally { reader . close ( ) ; } } catch ( Exception e ) { throw new RuntimeException ( String . format ( <str> , logFile , GFileUtils . readFileQuietly ( logFile ) ) , e ) ; } } private void collect ( WaitingReader reader , MeasuredOperation operation , Locale locale ) throws IOException { char decimalSeparator = ( new DecimalFormatSymbols ( locale ) ) . getDecimalSeparator ( ) ; GCEventParser eventParser = new GCEventParser ( decimalSeparator ) ; Pattern memoryPoolPattern = Pattern . compile ( <str> ) ; long totalHeapUsage = <int> ; long maxUsage = <int> ; long maxUncollectedUsage = <int> ; long maxCommittedUsage = <int> ; long usageAtPreviousCollection = <int> ; int events = <int> ; boolean processHeapUsageSummary = false ; while ( true ) { String line = reader . readLine ( ) ; if ( line = = null ) { break ; } if ( line . equals ( <str> ) ) { processHeapUsageSummary = true ; break ; } GCEventParser . GCEvent event = eventParser . parseLine ( line ) ; if ( event = = GCEventParser . GCEvent . IGNORED ) { continue ; } events + + ; if ( event . start < usageAtPreviousCollection ) { throw new IllegalArgumentException ( <str> + line ) ; } if ( event . timestamp . isAfter ( operation . getEnd ( ) ) ) { break ; } if ( ! event . timestamp . isBefore ( operation . getStart ( ) ) ) { totalHeapUsage + = event . start - usageAtPreviousCollection ; maxUsage = Math . max ( maxUsage , event . start ) ; maxUncollectedUsage = Math . max ( maxUncollectedUsage , event . end ) ; maxCommittedUsage = Math . max ( maxCommittedUsage , event . committed ) ; } usageAtPreviousCollection = event . end ; } if ( events = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } long finalHeapUsage = <int> ; long finalCommittedHeap = <int> ; if ( processHeapUsageSummary ) { while ( true ) { String line = reader . readLine ( ) ; if ( line = = null ) { break ; } Matcher matcher = memoryPoolPattern . matcher ( line ) ; if ( ! matcher . lookingAt ( ) ) { continue ; } String pool = matcher . group ( <int> ) . trim ( ) ; if ( pool . toLowerCase ( ) . contains ( <str> ) | | pool . toLowerCase ( ) . contains ( <str> ) ) { break ; } long committed = Long . parseLong ( matcher . group ( <int> ) ) ; long usage = Long . parseLong ( matcher . group ( <int> ) ) ; finalHeapUsage + = usage ; finalCommittedHeap + = committed ; } if ( finalHeapUsage = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( finalHeapUsage < usageAtPreviousCollection ) { throw new IllegalArgumentException ( <str> ) ; } totalHeapUsage + = finalHeapUsage - usageAtPreviousCollection ; maxUsage = Math . max ( maxUsage , finalHeapUsage ) ; maxCommittedUsage = Math . max ( maxCommittedUsage , finalCommittedHeap ) ; } operation . setTotalHeapUsage ( DataAmount . kbytes ( BigDecimal . valueOf ( totalHeapUsage ) ) ) ; operation . setMaxHeapUsage ( DataAmount . kbytes ( BigDecimal . valueOf ( maxUsage ) ) ) ; operation . setMaxUncollectedHeap ( DataAmount . kbytes ( BigDecimal . valueOf ( maxUncollectedUsage ) ) ) ; operation . setMaxCommittedHeap ( DataAmount . kbytes ( BigDecimal . valueOf ( maxCommittedUsage ) ) ) ; } } 
