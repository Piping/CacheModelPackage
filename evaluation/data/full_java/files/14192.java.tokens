package org . gradle . messaging . remote . internal . hub . queue ; import org . gradle . messaging . dispatch . Dispatch ; import org . gradle . messaging . remote . internal . hub . protocol . EndOfStream ; import org . gradle . messaging . remote . internal . hub . protocol . InterHubMessage ; import java . util . * ; import java . util . concurrent . locks . Lock ; public class MultiEndPointQueue implements Dispatch < InterHubMessage > { private final Set < EndPointQueue > endpoints = new HashSet < EndPointQueue > ( ) ; private final List < InterHubMessage > queue = new ArrayList < InterHubMessage > ( ) ; private final List < EndPointQueue > waiting = new ArrayList < EndPointQueue > ( ) ; private final Lock lock ; private final QueueInitializer initializer = new QueueInitializer ( ) ; public MultiEndPointQueue ( Lock lock ) { this . lock = lock ; } public void dispatch ( InterHubMessage message ) { queue . add ( message ) ; flush ( ) ; } void empty ( EndPointQueue endPointQueue ) { waiting . add ( endPointQueue ) ; flush ( ) ; } void stopped ( EndPointQueue queue ) { waiting . remove ( queue ) ; endpoints . remove ( queue ) ; queue . dispatch ( new EndOfStream ( ) ) ; } public void drain ( Collection < InterHubMessage > drainTo ) { drainTo . addAll ( queue ) ; queue . clear ( ) ; } private void flush ( ) { EndPointQueue selected = waiting . isEmpty ( ) ? null : waiting . get ( <int> ) ; while ( ! queue . isEmpty ( ) ) { InterHubMessage message = queue . get ( <int> ) ; switch ( message . getDelivery ( ) ) { case Stateful : case AllHandlers : if ( endpoints . isEmpty ( ) ) { return ; } if ( message . getDelivery ( ) = = InterHubMessage . Delivery . Stateful ) { initializer . onStatefulMessage ( message ) ; } for ( EndPointQueue endpoint : endpoints ) { endpoint . dispatch ( message ) ; } queue . remove ( <int> ) ; waiting . clear ( ) ; continue ; case SingleHandler : if ( selected = = null ) { return ; } queue . remove ( <int> ) ; waiting . remove ( selected ) ; selected . dispatch ( message ) ; break ; default : throw new IllegalArgumentException ( <str> + message . getDelivery ( ) ) ; } } } public EndPointQueue newEndpoint ( ) { EndPointQueue endPointQueue = new EndPointQueue ( this , lock . newCondition ( ) ) ; endpoints . add ( endPointQueue ) ; initializer . onQueueAdded ( endPointQueue ) ; return endPointQueue ; } } 
