package org . elasticsearch . mapper . attachments ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . MapperTestUtils ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . ParseContext ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import org . junit . Before ; import java . io . IOException ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . StreamsUtils . copyToBytesFromClasspath ; import static org . elasticsearch . test . StreamsUtils . copyToStringFromClasspath ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; public class LanguageDetectionAttachmentMapperTests extends AttachmentUnitTestCase { private DocumentMapper docMapper ; @Before public void setupMapperParser ( ) throws IOException { setupMapperParser ( true ) ; } public void setupMapperParser ( boolean langDetect ) throws IOException { DocumentMapperParser mapperParser = MapperTestUtils . newMapperService ( createTempDir ( ) , Settings . settingsBuilder ( ) . put ( <str> , langDetect ) . build ( ) , getIndicesModuleWithRegisteredAttachmentMapper ( ) ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; docMapper = mapperParser . parse ( mapping ) ; assertThat ( docMapper . mappers ( ) . getMapper ( <str> ) , instanceOf ( StringFieldMapper . class ) ) ; } private void testLanguage ( String filename , String expected , String . . . forcedLanguage ) throws IOException { byte [ ] html = copyToBytesFromClasspath ( <str> + filename ) ; XContentBuilder xcb = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , filename ) . field ( <str> , html ) ; if ( forcedLanguage . length > <int> ) { xcb . field ( <str> , forcedLanguage [ <int> ] ) ; } xcb . endObject ( ) . endObject ( ) ; ParseContext . Document doc = docMapper . parse ( <str> , <str> , <str> , xcb . bytes ( ) ) . rootDoc ( ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , equalTo ( expected ) ) ; } public void testFrDetection ( ) throws Exception { testLanguage ( <str> , <str> ) ; } public void testEnDetection ( ) throws Exception { testLanguage ( <str> , <str> ) ; } public void testFrForced ( ) throws Exception { testLanguage ( <str> , <str> , <str> ) ; } public void testNoLanguage ( ) throws Exception { testLanguage ( <str> , <str> ) ; } public void testLangDetectDisabled ( ) throws Exception { setupMapperParser ( false ) ; testLanguage ( <str> , null ) ; } public void testLangDetectDocumentEnabled ( ) throws Exception { setupMapperParser ( false ) ; byte [ ] html = copyToBytesFromClasspath ( <str> ) ; XContentBuilder xcb = jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , html ) . field ( <str> , true ) . endObject ( ) . endObject ( ) ; ParseContext . Document doc = docMapper . parse ( <str> , <str> , <str> , xcb . bytes ( ) ) . rootDoc ( ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , equalTo ( <str> ) ) ; } } 
