package org . elasticsearch . search . aggregations . pipeline . bucketscript ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . Script . ScriptField ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilder ; import java . io . IOException ; import java . util . Map ; public class BucketScriptBuilder extends PipelineAggregatorBuilder < BucketScriptBuilder > { private String format ; private GapPolicy gapPolicy ; private Script script ; private Map < String , String > bucketsPathsMap ; public BucketScriptBuilder ( String name ) { super ( name , BucketScriptPipelineAggregator . TYPE . name ( ) ) ; } public BucketScriptBuilder script ( Script script ) { this . script = script ; return this ; } public BucketScriptBuilder format ( String format ) { this . format = format ; return this ; } public BucketScriptBuilder gapPolicy ( GapPolicy gapPolicy ) { this . gapPolicy = gapPolicy ; return this ; } public BucketScriptBuilder setBucketsPathsMap ( Map < String , String > bucketsPathsMap ) { this . bucketsPathsMap = bucketsPathsMap ; return this ; } @Override protected XContentBuilder internalXContent ( XContentBuilder builder , Params builderParams ) throws IOException { if ( script ! = null ) { builder . field ( ScriptField . SCRIPT . getPreferredName ( ) , script ) ; } if ( format ! = null ) { builder . field ( BucketScriptParser . FORMAT . getPreferredName ( ) , format ) ; } if ( gapPolicy ! = null ) { builder . field ( BucketScriptParser . GAP_POLICY . getPreferredName ( ) , gapPolicy . getName ( ) ) ; } if ( bucketsPathsMap ! = null ) { builder . field ( PipelineAggregator . Parser . BUCKETS_PATH . getPreferredName ( ) , bucketsPathsMap ) ; } return builder ; } } 
