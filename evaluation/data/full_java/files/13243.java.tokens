package org . gradle . integtests . fixtures ; import org . gradle . api . Action ; import org . gradle . api . Transformer ; import org . gradle . integtests . fixtures . executer . GradleDistribution ; import org . gradle . integtests . fixtures . executer . UnderDevelopmentGradleDistribution ; import org . gradle . integtests . fixtures . versions . ReleasedVersionDistributions ; import org . gradle . internal . jvm . Jvm ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . util . CollectionUtils ; import org . gradle . util . GradleVersion ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import static org . gradle . util . CollectionUtils . * ; public abstract class AbstractCompatibilityTestRunner extends AbstractMultiTestRunner { private static final String VERSIONS_SYSPROP_NAME = <str> ; protected final GradleDistribution current = new UnderDevelopmentGradleDistribution ( ) ; protected final List < GradleDistribution > previous ; protected final boolean implicitVersion ; protected AbstractCompatibilityTestRunner ( Class < ? > target ) { this ( target , System . getProperty ( VERSIONS_SYSPROP_NAME , <str> ) ) ; } private AbstractCompatibilityTestRunner ( Class < ? > target , String versionStr ) { super ( target ) ; validateTestName ( target ) ; previous = new ArrayList < GradleDistribution > ( ) ; final ReleasedVersionDistributions previousVersions = new ReleasedVersionDistributions ( ) ; if ( versionStr . equals ( <str> ) ) { previous . add ( previousVersions . getMostRecentFinalRelease ( ) ) ; implicitVersion = true ; } else if ( versionStr . equals ( <str> ) ) { implicitVersion = true ; List < GradleDistribution > all = previousVersions . getAll ( ) ; for ( GradleDistribution previous : all ) { if ( ! previous . worksWith ( Jvm . current ( ) ) ) { add ( new IgnoredVersion ( previous , <str> ) ) ; continue ; } if ( ! previous . worksWith ( OperatingSystem . current ( ) ) ) { add ( new IgnoredVersion ( previous , <str> ) ) ; continue ; } this . previous . add ( previous ) ; } } else if ( versionStr . matches ( <str> ) ) { implicitVersion = false ; String [ ] versions = versionStr . split ( <str> ) ; List < GradleVersion > gradleVersions = CollectionUtils . sort ( collect ( Arrays . asList ( versions ) , new Transformer < GradleVersion , String > ( ) { public GradleVersion transform ( String versionString ) { return GradleVersion . version ( versionString ) ; } } ) , Collections . reverseOrder ( ) ) ; inject ( previous , gradleVersions , new Action < InjectionStep < List < GradleDistribution > , GradleVersion > > ( ) { public void execute ( InjectionStep < List < GradleDistribution > , GradleVersion > step ) { GradleDistribution distribution = previousVersions . getDistribution ( step . getItem ( ) ) ; if ( distribution = = null ) { throw new RuntimeException ( <str> + step . getItem ( ) . getVersion ( ) + <str> ) ; } step . getTarget ( ) . add ( distribution ) ; } } ) ; } else { throw new RuntimeException ( <str> + VERSIONS_SYSPROP_NAME + <str> + versionStr + <str> ) ; } } private void validateTestName ( Class < ? > target ) { if ( ! target . getSimpleName ( ) . contains ( <str> ) ) { throw new RuntimeException ( <str> + this . getClass ( ) . getSimpleName ( ) + <str> + <str> + <str> + target . getSimpleName ( ) + <str> ) ; } } public List < GradleDistribution > getPrevious ( ) { return previous ; } private static class IgnoredVersion extends Execution { private final GradleDistribution distribution ; private final String why ; private IgnoredVersion ( GradleDistribution distribution , String why ) { this . distribution = distribution ; this . why = why ; } @Override protected boolean isTestEnabled ( TestDetails testDetails ) { return false ; } @Override protected String getDisplayName ( ) { return String . format ( <str> , distribution . getVersion ( ) , why ) ; } } } 
