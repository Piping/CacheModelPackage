package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . ListTestSuiteBuilder ; import com . google . common . collect . testing . NavigableSetTestSuiteBuilder ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetAsListGenerator ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetCopyOfGenerator ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetDescendingAsListGenerator ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetDescendingGenerator ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetExplicitComparator ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetExplicitSuperclassComparatorGenerator ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetReversedOrderGenerator ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetSubsetAsListGenerator ; import com . google . common . collect . testing . google . SetGenerators . ImmutableSortedSetUnhashableGenerator ; import com . google . common . collect . testing . testers . SetHashCodeTester ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestSuite ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . Iterator ; import java . util . NoSuchElementException ; import java . util . Set ; import java . util . SortedSet ; import java . util . TreeSet ; @GwtCompatible ( emulated = true ) public class ImmutableSortedSetTest extends AbstractImmutableSetTest { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ImmutableSortedSetCopyOfGenerator ( ) ) . named ( ImmutableSortedSetTest . class . getName ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ImmutableSortedSetExplicitComparator ( ) ) . named ( ImmutableSortedSetTest . class . getName ( ) + <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ImmutableSortedSetExplicitSuperclassComparatorGenerator ( ) ) . named ( ImmutableSortedSetTest . class . getName ( ) + <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ImmutableSortedSetReversedOrderGenerator ( ) ) . named ( ImmutableSortedSetTest . class . getName ( ) + <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ImmutableSortedSetUnhashableGenerator ( ) ) . suppressing ( SetHashCodeTester . getHashCodeMethods ( ) ) . named ( ImmutableSortedSetTest . class . getName ( ) + <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( NavigableSetTestSuiteBuilder . using ( new ImmutableSortedSetDescendingGenerator ( ) ) . named ( ImmutableSortedSetTest . class . getName ( ) + <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableSortedSetAsListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableSortedSetSubsetAsListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableSortedSetDescendingAsListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTestSuite ( ImmutableSortedSetTest . class ) ; return suite ; } private enum StringLengthComparator implements Comparator < String > { INSTANCE ; @Override public int compare ( String a , String b ) { return a . length ( ) - b . length ( ) ; } } private static final Comparator < String > STRING_LENGTH = StringLengthComparator . INSTANCE ; @Override protected SortedSet < String > of ( ) { return ImmutableSortedSet . of ( ) ; } @Override protected SortedSet < String > of ( String e ) { return ImmutableSortedSet . of ( e ) ; } @Override protected SortedSet < String > of ( String e1 , String e2 ) { return ImmutableSortedSet . of ( e1 , e2 ) ; } @Override protected SortedSet < String > of ( String e1 , String e2 , String e3 ) { return ImmutableSortedSet . of ( e1 , e2 , e3 ) ; } @Override protected SortedSet < String > of ( String e1 , String e2 , String e3 , String e4 ) { return ImmutableSortedSet . of ( e1 , e2 , e3 , e4 ) ; } @Override protected SortedSet < String > of ( String e1 , String e2 , String e3 , String e4 , String e5 ) { return ImmutableSortedSet . of ( e1 , e2 , e3 , e4 , e5 ) ; } @Override protected SortedSet < String > of ( String e1 , String e2 , String e3 , String e4 , String e5 , String e6 , String . . . rest ) { return ImmutableSortedSet . of ( e1 , e2 , e3 , e4 , e5 , e6 , rest ) ; } @Override protected SortedSet < String > copyOf ( String [ ] elements ) { return ImmutableSortedSet . copyOf ( elements ) ; } @Override protected SortedSet < String > copyOf ( Collection < String > elements ) { return ImmutableSortedSet . copyOf ( elements ) ; } @Override protected SortedSet < String > copyOf ( Iterable < String > elements ) { return ImmutableSortedSet . copyOf ( elements ) ; } @Override protected SortedSet < String > copyOf ( Iterator < String > elements ) { return ImmutableSortedSet . copyOf ( elements ) ; } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { new NullPointerTester ( ) . testAllPublicStaticMethods ( ImmutableSortedSet . class ) ; } public void testEmpty_comparator ( ) { SortedSet < String > set = of ( ) ; assertSame ( Ordering . natural ( ) , set . comparator ( ) ) ; } public void testEmpty_headSet ( ) { SortedSet < String > set = of ( ) ; assertSame ( set , set . headSet ( <str> ) ) ; } public void testEmpty_tailSet ( ) { SortedSet < String > set = of ( ) ; assertSame ( set , set . tailSet ( <str> ) ) ; } public void testEmpty_subSet ( ) { SortedSet < String > set = of ( ) ; assertSame ( set , set . subSet ( <str> , <str> ) ) ; } public void testEmpty_first ( ) { SortedSet < String > set = of ( ) ; try { set . first ( ) ; fail ( ) ; } catch ( NoSuchElementException expected ) { } } public void testEmpty_last ( ) { SortedSet < String > set = of ( ) ; try { set . last ( ) ; fail ( ) ; } catch ( NoSuchElementException expected ) { } } @GwtIncompatible ( <str> ) public void testEmpty_serialization ( ) { SortedSet < String > set = of ( ) ; SortedSet < String > copy = SerializableTester . reserialize ( set ) ; assertSame ( set , copy ) ; } public void testSingle_comparator ( ) { SortedSet < String > set = of ( <str> ) ; assertSame ( Ordering . natural ( ) , set . comparator ( ) ) ; } public void testSingle_headSet ( ) { SortedSet < String > set = of ( <str> ) ; assertTrue ( set . headSet ( <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . headSet ( <str> ) ) . contains ( <str> ) ; assertSame ( of ( ) , set . headSet ( <str> ) ) ; assertSame ( of ( ) , set . headSet ( <str> ) ) ; } public void testSingle_tailSet ( ) { SortedSet < String > set = of ( <str> ) ; assertTrue ( set . tailSet ( <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . tailSet ( <str> ) ) . contains ( <str> ) ; assertThat ( set . tailSet ( <str> ) ) . contains ( <str> ) ; assertSame ( of ( ) , set . tailSet ( <str> ) ) ; } public void testSingle_subSet ( ) { SortedSet < String > set = of ( <str> ) ; assertTrue ( set . subSet ( <str> , <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . subSet ( <str> , <str> ) ) . contains ( <str> ) ; assertThat ( set . subSet ( <str> , <str> ) ) . contains ( <str> ) ; assertSame ( of ( ) , set . subSet ( <str> , <str> ) ) ; assertSame ( of ( ) , set . subSet ( <str> , <str> ) ) ; assertSame ( of ( ) , set . subSet ( <str> , <str> ) ) ; } public void testSingle_first ( ) { SortedSet < String > set = of ( <str> ) ; assertEquals ( <str> , set . first ( ) ) ; } public void testSingle_last ( ) { SortedSet < String > set = of ( <str> ) ; assertEquals ( <str> , set . last ( ) ) ; } @GwtIncompatible ( <str> ) public void testSingle_serialization ( ) { SortedSet < String > set = of ( <str> ) ; SortedSet < String > copy = SerializableTester . reserializeAndAssert ( set ) ; assertEquals ( set . comparator ( ) , copy . comparator ( ) ) ; } public void testOf_ordering ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testOf_gwtArraycopyBug ( ) { Interface a = new Impl ( ) ; Interface b = new Impl ( ) ; ImmutableSortedSet < Interface > set = ImmutableSortedSet . of ( a , b ) ; set . toArray ( ) ; set . toArray ( new Object [ <int> ] ) ; } interface Interface extends Comparable < Interface > { } static class Impl implements Interface { static int nextId ; Integer id = nextId + + ; @Override public int compareTo ( Interface other ) { return id . compareTo ( ( ( Impl ) other ) . id ) ; } } public void testOf_ordering_dupes ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testOf_comparator ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; assertSame ( Ordering . natural ( ) , set . comparator ( ) ) ; } public void testOf_headSet ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( set . headSet ( <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . headSet ( <str> ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( set . headSet ( <str> ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertSame ( of ( ) , set . headSet ( <str> ) ) ; assertSame ( of ( ) , set . headSet ( <str> ) ) ; } public void testOf_tailSet ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( set . tailSet ( <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . tailSet ( <str> ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( set . tailSet ( <str> ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertSame ( of ( ) , set . tailSet ( <str> ) ) ; } public void testOf_subSet ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> ) ; assertTrue ( set . subSet ( <str> , <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . subSet ( <str> , <str> ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( set . subSet ( <str> , <str> ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertSame ( of ( ) , set . subSet ( <str> , <str> ) ) ; assertSame ( of ( ) , set . subSet ( <str> , <str> ) ) ; assertSame ( of ( ) , set . subSet ( <str> , <str> ) ) ; try { set . subSet ( <str> , <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @GwtIncompatible ( <str> ) public void testOf_subSetSerialization ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> ) ; SerializableTester . reserializeAndAssert ( set . subSet ( <str> , <str> ) ) ; } public void testOf_first ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( <str> , set . first ( ) ) ; } public void testOf_last ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> ) ; assertEquals ( <str> , set . last ( ) ) ; } @GwtIncompatible ( <str> ) public void testOf_serialization ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> ) ; SortedSet < String > copy = SerializableTester . reserializeAndAssert ( set ) ; assertTrue ( Iterables . elementsEqual ( set , copy ) ) ; assertEquals ( set . comparator ( ) , copy . comparator ( ) ) ; } public void testExplicit_ordering ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testExplicit_ordering_dupes ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testExplicit_contains ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertTrue ( set . contains ( <str> ) ) ; assertTrue ( set . contains ( <str> ) ) ; assertFalse ( set . contains ( <str> ) ) ; assertFalse ( set . contains ( <str> ) ) ; assertFalse ( set . contains ( null ) ) ; } public void testExplicit_containsMismatchedTypes ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertFalse ( set . contains ( ( Object ) <float> ) ) ; } public void testExplicit_comparator ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertSame ( STRING_LENGTH , set . comparator ( ) ) ; } public void testExplicit_headSet ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertTrue ( set . headSet ( <str> ) instanceof ImmutableSortedSet ) ; assertTrue ( set . headSet ( <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . headSet ( <str> ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( set . headSet ( <str> ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertTrue ( set . headSet ( <str> ) . isEmpty ( ) ) ; assertTrue ( set . headSet ( <str> ) . isEmpty ( ) ) ; } public void testExplicit_tailSet ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertTrue ( set . tailSet ( <str> ) instanceof ImmutableSortedSet ) ; assertTrue ( set . tailSet ( <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . tailSet ( <str> ) ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( set . tailSet ( <str> ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertTrue ( set . tailSet ( <str> ) . isEmpty ( ) ) ; } public void testExplicit_subSet ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertTrue ( set . subSet ( <str> , <str> ) instanceof ImmutableSortedSet ) ; assertTrue ( set . subSet ( <str> , <str> ) instanceof ImmutableSortedSet ) ; assertThat ( set . subSet ( <str> , <str> ) ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( set . subSet ( <str> , <str> ) ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertTrue ( set . subSet ( <str> , <str> ) . isEmpty ( ) ) ; assertTrue ( set . subSet ( <str> , <str> ) . isEmpty ( ) ) ; assertTrue ( set . subSet ( <str> , <str> ) . isEmpty ( ) ) ; try { set . subSet ( <str> , <str> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testExplicit_first ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertEquals ( <str> , set . first ( ) ) ; } public void testExplicit_last ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; assertEquals ( <str> , set . last ( ) ) ; } @GwtIncompatible ( <str> ) public void testExplicitEmpty_serialization ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . build ( ) ; SortedSet < String > copy = SerializableTester . reserializeAndAssert ( set ) ; assertTrue ( set . isEmpty ( ) ) ; assertTrue ( copy . isEmpty ( ) ) ; assertSame ( set . comparator ( ) , copy . comparator ( ) ) ; } @GwtIncompatible ( <str> ) public void testExplicit_serialization ( ) { SortedSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; SortedSet < String > copy = SerializableTester . reserializeAndAssert ( set ) ; assertTrue ( Iterables . elementsEqual ( set , copy ) ) ; assertSame ( set . comparator ( ) , copy . comparator ( ) ) ; } public void testCopyOf_ordering ( ) { SortedSet < String > set = copyOf ( asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOf_ordering_dupes ( ) { SortedSet < String > set = copyOf ( asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOf_subSet ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; SortedSet < String > subset = set . subSet ( <str> , <str> ) ; SortedSet < String > copy = copyOf ( subset ) ; assertEquals ( subset , copy ) ; } public void testCopyOf_headSet ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; SortedSet < String > headset = set . headSet ( <str> ) ; SortedSet < String > copy = copyOf ( headset ) ; assertEquals ( headset , copy ) ; } public void testCopyOf_tailSet ( ) { SortedSet < String > set = of ( <str> , <str> , <str> , <str> , <str> , <str> ) ; SortedSet < String > tailset = set . tailSet ( <str> ) ; SortedSet < String > copy = copyOf ( tailset ) ; assertEquals ( tailset , copy ) ; } public void testCopyOf_comparator ( ) { SortedSet < String > set = copyOf ( asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertSame ( Ordering . natural ( ) , set . comparator ( ) ) ; } public void testCopyOf_iterator_ordering ( ) { SortedSet < String > set = copyOf ( asIterator ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOf_iterator_ordering_dupes ( ) { SortedSet < String > set = copyOf ( asIterator ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOf_iterator_comparator ( ) { SortedSet < String > set = copyOf ( asIterator ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertSame ( Ordering . natural ( ) , set . comparator ( ) ) ; } public void testCopyOf_sortedSet_ordering ( ) { SortedSet < String > set = copyOf ( Sets . newTreeSet ( asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOf_sortedSet_comparator ( ) { SortedSet < String > set = copyOf ( Sets . < String > newTreeSet ( ) ) ; assertSame ( Ordering . natural ( ) , set . comparator ( ) ) ; } public void testCopyOfExplicit_ordering ( ) { SortedSet < String > set = ImmutableSortedSet . copyOf ( STRING_LENGTH , asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOfExplicit_ordering_dupes ( ) { SortedSet < String > set = ImmutableSortedSet . copyOf ( STRING_LENGTH , asList ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOfExplicit_comparator ( ) { SortedSet < String > set = ImmutableSortedSet . copyOf ( STRING_LENGTH , asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertSame ( STRING_LENGTH , set . comparator ( ) ) ; } public void testCopyOfExplicit_iterator_ordering ( ) { SortedSet < String > set = ImmutableSortedSet . copyOf ( STRING_LENGTH , asIterator ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOfExplicit_iterator_ordering_dupes ( ) { SortedSet < String > set = ImmutableSortedSet . copyOf ( STRING_LENGTH , asIterator ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOfExplicit_iterator_comparator ( ) { SortedSet < String > set = ImmutableSortedSet . copyOf ( STRING_LENGTH , asIterator ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; assertSame ( STRING_LENGTH , set . comparator ( ) ) ; } public void testCopyOf_sortedSetIterable ( ) { SortedSet < String > input = Sets . newTreeSet ( STRING_LENGTH ) ; Collections . addAll ( input , <str> , <str> , <str> , <str> , <str> , <str> ) ; SortedSet < String > set = copyOf ( input ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOfSorted_natural_ordering ( ) { SortedSet < String > input = Sets . newTreeSet ( asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; SortedSet < String > set = ImmutableSortedSet . copyOfSorted ( input ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; } public void testCopyOfSorted_natural_comparator ( ) { SortedSet < String > input = Sets . newTreeSet ( asList ( <str> , <str> , <str> , <str> , <str> , <str> ) ) ; SortedSet < String > set = ImmutableSortedSet . copyOfSorted ( input ) ; assertSame ( Ordering . natural ( ) , set . comparator ( ) ) ; } public void testCopyOfSorted_explicit_ordering ( ) { SortedSet < String > input = Sets . newTreeSet ( STRING_LENGTH ) ; Collections . addAll ( input , <str> , <str> , <str> , <str> , <str> , <str> ) ; SortedSet < String > set = ImmutableSortedSet . copyOfSorted ( input ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertSame ( STRING_LENGTH , set . comparator ( ) ) ; } public void testEquals_bothDefaultOrdering ( ) { SortedSet < String > set = of ( <str> , <str> , <str> ) ; assertEquals ( set , Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) ) ; assertEquals ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) , set ) ; assertFalse ( set . equals ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) ) ) ; assertFalse ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) . equals ( set ) ) ; assertFalse ( set . equals ( Sets . newHashSet ( <int> , <int> , <int> ) ) ) ; assertFalse ( Sets . newHashSet ( <int> , <int> , <int> ) . equals ( set ) ) ; } public void testEquals_bothExplicitOrdering ( ) { SortedSet < String > set = of ( <str> , <str> , <str> ) ; assertEquals ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) , set ) ; assertFalse ( set . equals ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) ) ) ; assertFalse ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) . equals ( set ) ) ; assertFalse ( set . equals ( Sets . newHashSet ( <int> , <int> , <int> ) ) ) ; assertFalse ( Sets . newHashSet ( <int> , <int> , <int> ) . equals ( set ) ) ; Set < String > complex = Sets . newTreeSet ( STRING_LENGTH ) ; Collections . addAll ( complex , <str> , <str> , <str> ) ; assertEquals ( set , complex ) ; } public void testEquals_bothDefaultOrdering_StringVsInt ( ) { SortedSet < String > set = of ( <str> , <str> , <str> ) ; assertFalse ( set . equals ( Sets . newTreeSet ( asList ( <int> , <int> , <int> ) ) ) ) ; assertNotEqualLenient ( Sets . newTreeSet ( asList ( <int> , <int> , <int> ) ) , set ) ; } public void testEquals_bothExplicitOrdering_StringVsInt ( ) { SortedSet < String > set = of ( <str> , <str> , <str> ) ; assertFalse ( set . equals ( Sets . newTreeSet ( asList ( <int> , <int> , <int> ) ) ) ) ; assertNotEqualLenient ( Sets . newTreeSet ( asList ( <int> , <int> , <int> ) ) , set ) ; } public void testContainsAll_notSortedSet ( ) { SortedSet < String > set = of ( <str> , <str> , <str> ) ; assertTrue ( set . containsAll ( Collections . emptyList ( ) ) ) ; assertTrue ( set . containsAll ( asList ( <str> ) ) ) ; assertTrue ( set . containsAll ( asList ( <str> , <str> ) ) ) ; assertTrue ( set . containsAll ( asList ( <str> , <str> ) ) ) ; assertTrue ( set . containsAll ( asList ( <str> , <str> , <str> ) ) ) ; assertFalse ( set . containsAll ( asList ( <str> ) ) ) ; assertFalse ( set . containsAll ( asList ( <str> ) ) ) ; assertFalse ( set . containsAll ( asList ( <str> , <str> ) ) ) ; assertFalse ( set . containsAll ( asList ( <str> , <str> , <str> ) ) ) ; } public void testContainsAll_sameComparator ( ) { SortedSet < String > set = of ( <str> , <str> , <str> ) ; assertTrue ( set . containsAll ( Sets . newTreeSet ( ) ) ) ; assertTrue ( set . containsAll ( Sets . newTreeSet ( asList ( <str> ) ) ) ) ; assertTrue ( set . containsAll ( Sets . newTreeSet ( asList ( <str> , <str> ) ) ) ) ; assertTrue ( set . containsAll ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) ) ) ; assertFalse ( set . containsAll ( Sets . newTreeSet ( asList ( <str> ) ) ) ) ; assertFalse ( set . containsAll ( Sets . newTreeSet ( asList ( <str> ) ) ) ) ; assertFalse ( set . containsAll ( Sets . newTreeSet ( asList ( <str> , <str> ) ) ) ) ; assertFalse ( set . containsAll ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) ) ) ; } public void testContainsAll_sameComparator_StringVsInt ( ) { SortedSet < String > set = of ( <str> , <str> , <str> ) ; SortedSet < Integer > unexpected = Sets . newTreeSet ( Ordering . natural ( ) ) ; unexpected . addAll ( asList ( <int> , <int> , <int> ) ) ; assertFalse ( set . containsAll ( ( Collection < ? > ) unexpected ) ) ; } public void testContainsAll_differentComparator ( ) { Comparator < Comparable < ? > > comparator = Collections . reverseOrder ( ) ; SortedSet < String > set = new ImmutableSortedSet . Builder < String > ( comparator ) . add ( <str> , <str> , <str> ) . build ( ) ; assertTrue ( set . containsAll ( Sets . newTreeSet ( ) ) ) ; assertTrue ( set . containsAll ( Sets . newTreeSet ( asList ( <str> ) ) ) ) ; assertTrue ( set . containsAll ( Sets . newTreeSet ( asList ( <str> , <str> ) ) ) ) ; assertTrue ( set . containsAll ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) ) ) ; assertFalse ( set . containsAll ( Sets . newTreeSet ( asList ( <str> ) ) ) ) ; assertFalse ( set . containsAll ( Sets . newTreeSet ( asList ( <str> ) ) ) ) ; assertFalse ( set . containsAll ( Sets . newTreeSet ( asList ( <str> , <str> ) ) ) ) ; assertFalse ( set . containsAll ( Sets . newTreeSet ( asList ( <str> , <str> , <str> ) ) ) ) ; } @GwtIncompatible ( <str> ) public void testDifferentComparator_serialization ( ) { Comparator < Comparable < ? > > comparator = Ordering . natural ( ) . reverse ( ) ; SortedSet < String > set = new ImmutableSortedSet . Builder < String > ( comparator ) . add ( <str> , <str> , <str> ) . build ( ) ; SortedSet < String > copy = SerializableTester . reserializeAndAssert ( set ) ; assertTrue ( Iterables . elementsEqual ( set , copy ) ) ; assertEquals ( set . comparator ( ) , copy . comparator ( ) ) ; } public void testReverseOrder ( ) { SortedSet < String > set = ImmutableSortedSet . < String > reverseOrder ( ) . add ( <str> , <str> , <str> ) . build ( ) ; assertThat ( set ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertEquals ( Ordering . natural ( ) . reverse ( ) , set . comparator ( ) ) ; } private static final Comparator < Object > TO_STRING = new Comparator < Object > ( ) { @Override public int compare ( Object o1 , Object o2 ) { return o1 . toString ( ) . compareTo ( o2 . toString ( ) ) ; } } ; public void testSupertypeComparator ( ) { SortedSet < Integer > set = new ImmutableSortedSet . Builder < Integer > ( TO_STRING ) . add ( <int> , <int> , <int> , <int> ) . build ( ) ; assertThat ( set ) . containsExactly ( <int> , <int> , <int> , <int> ) . inOrder ( ) ; } public void testSupertypeComparatorSubtypeElements ( ) { SortedSet < Number > set = new ImmutableSortedSet . Builder < Number > ( TO_STRING ) . add ( <int> , <int> , <int> , <int> ) . build ( ) ; assertThat ( set ) . containsExactly ( <int> , <int> , <int> , <int> ) . inOrder ( ) ; } @Override < E extends Comparable < E > > ImmutableSortedSet . Builder < E > builder ( ) { return ImmutableSortedSet . naturalOrder ( ) ; } @Override int getComplexBuilderSetLastElement ( ) { return <hex> ; } public void testLegacyComparable_of ( ) { ImmutableSortedSet < LegacyComparable > set0 = ImmutableSortedSet . of ( ) ; @SuppressWarnings ( <str> ) ImmutableSortedSet < LegacyComparable > set1 = ImmutableSortedSet . of ( LegacyComparable . Z ) ; @SuppressWarnings ( <str> ) ImmutableSortedSet < LegacyComparable > set2 = ImmutableSortedSet . of ( LegacyComparable . Z , LegacyComparable . Y ) ; } public void testLegacyComparable_copyOf_collection ( ) { ImmutableSortedSet < LegacyComparable > set = ImmutableSortedSet . copyOf ( LegacyComparable . VALUES_BACKWARD ) ; assertTrue ( Iterables . elementsEqual ( LegacyComparable . VALUES_FORWARD , set ) ) ; } public void testLegacyComparable_copyOf_iterator ( ) { ImmutableSortedSet < LegacyComparable > set = ImmutableSortedSet . copyOf ( LegacyComparable . VALUES_BACKWARD . iterator ( ) ) ; assertTrue ( Iterables . elementsEqual ( LegacyComparable . VALUES_FORWARD , set ) ) ; } public void testLegacyComparable_builder_natural ( ) { @SuppressWarnings ( <str> ) ImmutableSortedSet . Builder < LegacyComparable > builder = ImmutableSortedSet . < LegacyComparable > naturalOrder ( ) ; builder . addAll ( LegacyComparable . VALUES_BACKWARD ) ; builder . add ( LegacyComparable . X ) ; builder . add ( LegacyComparable . Y , LegacyComparable . Z ) ; ImmutableSortedSet < LegacyComparable > set = builder . build ( ) ; assertTrue ( Iterables . elementsEqual ( LegacyComparable . VALUES_FORWARD , set ) ) ; } public void testLegacyComparable_builder_reverse ( ) { @SuppressWarnings ( <str> ) ImmutableSortedSet . Builder < LegacyComparable > builder = ImmutableSortedSet . < LegacyComparable > reverseOrder ( ) ; builder . addAll ( LegacyComparable . VALUES_FORWARD ) ; builder . add ( LegacyComparable . X ) ; builder . add ( LegacyComparable . Y , LegacyComparable . Z ) ; ImmutableSortedSet < LegacyComparable > set = builder . build ( ) ; assertTrue ( Iterables . elementsEqual ( LegacyComparable . VALUES_BACKWARD , set ) ) ; } @SuppressWarnings ( { <str> , <str> } ) public void testBuilderMethod ( ) { try { ImmutableSortedSet . builder ( ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testAsList ( ) { ImmutableSet < String > set = ImmutableSortedSet . of ( <str> , <str> , <str> , <str> , <str> ) ; ImmutableList < String > list = set . asList ( ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> , <str> , <str> ) , list ) ; assertSame ( list , ImmutableList . copyOf ( set ) ) ; } @GwtIncompatible ( <str> ) public void testAsListReturnTypeAndSerialization ( ) { ImmutableSet < String > set = ImmutableSortedSet . of ( <str> , <str> , <str> , <str> , <str> ) ; ImmutableList < String > list = set . asList ( ) ; assertTrue ( list instanceof ImmutableSortedAsList ) ; ImmutableList < String > copy = SerializableTester . reserializeAndAssert ( list ) ; assertTrue ( copy instanceof ImmutableSortedAsList ) ; } public void testSubsetAsList ( ) { ImmutableSet < String > set = ImmutableSortedSet . of ( <str> , <str> , <str> , <str> , <str> ) . subSet ( <str> , <str> ) ; ImmutableList < String > list = set . asList ( ) ; assertEquals ( ImmutableList . of ( <str> , <str> , <str> ) , list ) ; assertEquals ( list , ImmutableList . copyOf ( set ) ) ; } @GwtIncompatible ( <str> ) public void testSubsetAsListReturnTypeAndSerialization ( ) { ImmutableSet < String > set = ImmutableSortedSet . of ( <str> , <str> , <str> , <str> , <str> ) . subSet ( <str> , <str> ) ; ImmutableList < String > list = set . asList ( ) ; assertTrue ( list instanceof ImmutableSortedAsList ) ; ImmutableList < String > copy = SerializableTester . reserializeAndAssert ( list ) ; assertTrue ( copy instanceof ImmutableSortedAsList ) ; } public void testAsListInconsistentComprator ( ) { ImmutableSet < String > set = ImmutableSortedSet . orderedBy ( STRING_LENGTH ) . add ( <str> , <str> , <str> , <str> , <str> , <str> ) . build ( ) ; ImmutableList < String > list = set . asList ( ) ; assertTrue ( list . contains ( <str> ) ) ; assertEquals ( <int> , list . indexOf ( <str> ) ) ; assertEquals ( <int> , list . lastIndexOf ( <str> ) ) ; assertFalse ( list . contains ( <str> ) ) ; assertEquals ( - <int> , list . indexOf ( <str> ) ) ; assertEquals ( - <int> , list . lastIndexOf ( <str> ) ) ; assertFalse ( list . contains ( <str> ) ) ; assertEquals ( - <int> , list . indexOf ( <str> ) ) ; assertEquals ( - <int> , list . lastIndexOf ( <str> ) ) ; } private static < E > Iterator < E > asIterator ( E . . . elements ) { return asList ( elements ) . iterator ( ) ; } private static void assertNotEqualLenient ( TreeSet < ? > unexpected , SortedSet < ? > actual ) { try { assertThat ( actual ) . isNotEqualTo ( unexpected ) ; } catch ( ClassCastException accepted ) { } } public void testHeadSetInclusive ( ) { String [ ] strings = NUMBER_NAMES . toArray ( new String [ <int> ] ) ; ImmutableSortedSet < String > set = ImmutableSortedSet . copyOf ( strings ) ; Arrays . sort ( strings ) ; for ( int i = <int> ; i < strings . length ; i + + ) { assertThat ( set . headSet ( strings [ i ] , true ) ) . containsExactlyElementsIn ( sortedNumberNames ( <int> , i + <int> ) ) . inOrder ( ) ; } } public void testHeadSetExclusive ( ) { String [ ] strings = NUMBER_NAMES . toArray ( new String [ <int> ] ) ; ImmutableSortedSet < String > set = ImmutableSortedSet . copyOf ( strings ) ; Arrays . sort ( strings ) ; for ( int i = <int> ; i < strings . length ; i + + ) { assertThat ( set . headSet ( strings [ i ] , false ) ) . containsExactlyElementsIn ( sortedNumberNames ( <int> , i ) ) . inOrder ( ) ; } } public void testTailSetInclusive ( ) { String [ ] strings = NUMBER_NAMES . toArray ( new String [ <int> ] ) ; ImmutableSortedSet < String > set = ImmutableSortedSet . copyOf ( strings ) ; Arrays . sort ( strings ) ; for ( int i = <int> ; i < strings . length ; i + + ) { assertThat ( set . tailSet ( strings [ i ] , true ) ) . containsExactlyElementsIn ( sortedNumberNames ( i , strings . length ) ) . inOrder ( ) ; } } public void testTailSetExclusive ( ) { String [ ] strings = NUMBER_NAMES . toArray ( new String [ <int> ] ) ; ImmutableSortedSet < String > set = ImmutableSortedSet . copyOf ( strings ) ; Arrays . sort ( strings ) ; for ( int i = <int> ; i < strings . length ; i + + ) { assertThat ( set . tailSet ( strings [ i ] , false ) ) . containsExactlyElementsIn ( sortedNumberNames ( i + <int> , strings . length ) ) . inOrder ( ) ; } } public void testSubSetExclusiveExclusive ( ) { String [ ] strings = NUMBER_NAMES . toArray ( new String [ <int> ] ) ; ImmutableSortedSet < String > set = ImmutableSortedSet . copyOf ( strings ) ; Arrays . sort ( strings ) ; for ( int i = <int> ; i < strings . length ; i + + ) { for ( int j = i ; j < strings . length ; j + + ) { assertThat ( set . subSet ( strings [ i ] , false , strings [ j ] , false ) ) . containsExactlyElementsIn ( sortedNumberNames ( Math . min ( i + <int> , j ) , j ) ) . inOrder ( ) ; } } } public void testSubSetInclusiveExclusive ( ) { String [ ] strings = NUMBER_NAMES . toArray ( new String [ <int> ] ) ; ImmutableSortedSet < String > set = ImmutableSortedSet . copyOf ( strings ) ; Arrays . sort ( strings ) ; for ( int i = <int> ; i < strings . length ; i + + ) { for ( int j = i ; j < strings . length ; j + + ) { assertThat ( set . subSet ( strings [ i ] , true , strings [ j ] , false ) ) . containsExactlyElementsIn ( sortedNumberNames ( i , j ) ) . inOrder ( ) ; } } } public void testSubSetExclusiveInclusive ( ) { String [ ] strings = NUMBER_NAMES . toArray ( new String [ <int> ] ) ; ImmutableSortedSet < String > set = ImmutableSortedSet . copyOf ( strings ) ; Arrays . sort ( strings ) ; for ( int i = <int> ; i < strings . length ; i + + ) { for ( int j = i ; j < strings . length ; j + + ) { assertThat ( set . subSet ( strings [ i ] , false , strings [ j ] , true ) ) . containsExactlyElementsIn ( sortedNumberNames ( i + <int> , j + <int> ) ) . inOrder ( ) ; } } } public void testSubSetInclusiveInclusive ( ) { String [ ] strings = NUMBER_NAMES . toArray ( new String [ <int> ] ) ; ImmutableSortedSet < String > set = ImmutableSortedSet . copyOf ( strings ) ; Arrays . sort ( strings ) ; for ( int i = <int> ; i < strings . length ; i + + ) { for ( int j = i ; j < strings . length ; j + + ) { assertThat ( set . subSet ( strings [ i ] , true , strings [ j ] , true ) ) . containsExactlyElementsIn ( sortedNumberNames ( i , j + <int> ) ) . inOrder ( ) ; } } } private static ImmutableList < String > sortedNumberNames ( int i , int j ) { return ImmutableList . copyOf ( SORTED_NUMBER_NAMES . subList ( i , j ) ) ; } private static final ImmutableList < String > NUMBER_NAMES = ImmutableList . of ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; private static final ImmutableList < String > SORTED_NUMBER_NAMES = Ordering . natural ( ) . immutableSortedCopy ( NUMBER_NAMES ) ; private static class SelfComparableExample implements Comparable < SelfComparableExample > { @Override public int compareTo ( SelfComparableExample o ) { return <int> ; } } public void testBuilderGenerics_SelfComparable ( ) { ImmutableSortedSet . Builder < SelfComparableExample > natural = ImmutableSortedSet . naturalOrder ( ) ; ImmutableSortedSet . Builder < SelfComparableExample > reverse = ImmutableSortedSet . reverseOrder ( ) ; } private static class SuperComparableExample extends SelfComparableExample { } public void testBuilderGenerics_SuperComparable ( ) { ImmutableSortedSet . Builder < SuperComparableExample > natural = ImmutableSortedSet . naturalOrder ( ) ; ImmutableSortedSet . Builder < SuperComparableExample > reverse = ImmutableSortedSet . reverseOrder ( ) ; } } 
