package org . gradle . nativeplatform . internal . resolve ; import org . gradle . api . DomainObjectSet ; import org . gradle . api . InvalidUserDataException ; import org . gradle . language . base . internal . resolve . LibraryResolveException ; import org . gradle . nativeplatform . * ; import org . gradle . nativeplatform . platform . NativePlatform ; import org . gradle . util . GUtil ; import java . util . Set ; class DefaultLibraryResolver { private final NativeLibraryRequirement requirement ; private final NativeBinarySpec context ; private final LibraryBinaryLocator libraryBinaryLocator ; public DefaultLibraryResolver ( LibraryBinaryLocator libraryBinaryLocator , NativeLibraryRequirement requirement , NativeBinarySpec context ) { this . requirement = requirement ; this . context = context ; this . libraryBinaryLocator = libraryBinaryLocator ; } public NativeLibraryBinary resolveLibraryBinary ( ) { DomainObjectSet < NativeLibraryBinary > binaries = libraryBinaryLocator . getBinaries ( requirement ) ; if ( binaries = = null ) { throw new LibraryResolveException ( getFailureMessage ( requirement ) ) ; } return new LibraryResolution ( ) . withFlavor ( context . getFlavor ( ) ) . withPlatform ( context . getTargetPlatform ( ) ) . withBuildType ( context . getBuildType ( ) ) . resolveLibrary ( binaries ) ; } private String getFailureMessage ( NativeLibraryRequirement requirement ) { return requirement . getProjectPath ( ) = = null ? String . format ( <str> , requirement . getLibraryName ( ) ) : String . format ( <str> , requirement . getLibraryName ( ) , requirement . getProjectPath ( ) ) ; } private class LibraryResolution { private Flavor flavor ; private NativePlatform platform ; private BuildType buildType ; public LibraryResolution withFlavor ( Flavor flavor ) { this . flavor = flavor ; return this ; } public LibraryResolution withPlatform ( NativePlatform platform ) { this . platform = platform ; return this ; } public LibraryResolution withBuildType ( BuildType buildType ) { this . buildType = buildType ; return this ; } public NativeDependencySet resolve ( DomainObjectSet < NativeLibraryBinary > allBinaries ) { NativeLibraryBinary resolve = resolveLibrary ( allBinaries ) ; return new DefaultNativeDependencySet ( resolve ) ; } public NativeLibraryBinary resolveLibrary ( DomainObjectSet < NativeLibraryBinary > allBinaries ) { Class < ? extends NativeLibraryBinary > type = getTypeForLinkage ( requirement . getLinkage ( ) ) ; DomainObjectSet < ? extends NativeLibraryBinary > candidateBinaries = allBinaries . withType ( type ) ; return resolve ( candidateBinaries ) ; } private Class < ? extends NativeLibraryBinary > getTypeForLinkage ( String linkage ) { if ( <str> . equals ( linkage ) ) { return StaticLibraryBinary . class ; } if ( <str> . equals ( linkage ) | | linkage = = null ) { return SharedLibraryBinary . class ; } throw new InvalidUserDataException ( <str> + linkage ) ; } private NativeLibraryBinary resolve ( Set < ? extends NativeLibraryBinary > candidates ) { for ( NativeLibraryBinary candidate : candidates ) { if ( flavor ! = null & & ! flavor . getName ( ) . equals ( candidate . getFlavor ( ) . getName ( ) ) ) { continue ; } if ( platform ! = null & & ! platform . getName ( ) . equals ( candidate . getTargetPlatform ( ) . getName ( ) ) ) { continue ; } if ( buildType ! = null & & ! buildType . getName ( ) . equals ( candidate . getBuildType ( ) . getName ( ) ) ) { continue ; } return candidate ; } String typeName = GUtil . elvis ( requirement . getLinkage ( ) , <str> ) ; throw new LibraryResolveException ( String . format ( <str> , typeName , requirement . getLibraryName ( ) , flavor . getName ( ) , platform . getName ( ) , buildType . getName ( ) ) ) ; } } } 
