package org . gradle . api . reporting . components . internal ; import com . google . common . collect . Maps ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . tasks . diagnostics . internal . text . TextReportBuilder ; import org . gradle . internal . text . TreeFormatter ; import org . gradle . language . base . LanguageSourceSet ; import org . gradle . model . ModelMap ; import org . gradle . model . internal . manage . schema . ModelProperty ; import org . gradle . model . internal . manage . schema . ModelSchema ; import org . gradle . model . internal . manage . schema . ModelSchemaStore ; import org . gradle . model . internal . manage . schema . StructSchema ; import org . gradle . platform . base . BinarySpec ; import org . gradle . platform . base . internal . BinaryBuildAbility ; import org . gradle . platform . base . internal . BinarySpecInternal ; import org . gradle . platform . base . internal . VariantAspect ; import org . gradle . reporting . ReportRenderer ; import java . util . Map ; public abstract class AbstractBinaryRenderer < T extends BinarySpec > extends ReportRenderer < BinarySpec , TextReportBuilder > { private ModelSchemaStore schemaStore ; protected AbstractBinaryRenderer ( ModelSchemaStore schemaStore ) { this . schemaStore = schemaStore ; } public void render ( BinarySpec binary , TextReportBuilder builder ) { String heading = StringUtils . capitalize ( binary . getDisplayName ( ) ) ; if ( ! binary . isBuildable ( ) ) { heading + = <str> ; } builder . heading ( heading ) ; builder . item ( <str> , binary . getBuildTask ( ) . getPath ( ) ) ; T specialized = getTargetType ( ) . cast ( binary ) ; renderTasks ( specialized , builder ) ; renderVariants ( specialized , builder ) ; renderDetails ( specialized , builder ) ; renderOutputs ( specialized , builder ) ; renderBuildAbility ( specialized , builder ) ; renderOwnedSourceSets ( specialized , builder ) ; } public abstract Class < T > getTargetType ( ) ; protected void renderOutputs ( T binary , TextReportBuilder builder ) { } protected void renderVariants ( T binary , TextReportBuilder builder ) { ModelSchema < ? > schema = schemaStore . getSchema ( ( ( BinarySpecInternal ) binary ) . getPublicType ( ) ) ; if ( ! ( schema instanceof StructSchema ) ) { return ; } Map < String , Object > variants = Maps . newTreeMap ( ) ; VariantAspect variantAspect = ( ( StructSchema < ? > ) schema ) . getAspect ( VariantAspect . class ) ; if ( variantAspect ! = null ) { for ( ModelProperty < ? > property : variantAspect . getDimensions ( ) ) { variants . put ( property . getName ( ) , property . getPropertyValue ( binary ) ) ; } } for ( Map . Entry < String , Object > variant : variants . entrySet ( ) ) { String variantName = variant . getKey ( ) ; builder . item ( variantName , RendererUtils . displayValueOf ( variant . getValue ( ) ) ) ; } } protected void renderDetails ( T binary , TextReportBuilder builder ) { } protected void renderTasks ( T binary , TextReportBuilder builder ) { } private void renderBuildAbility ( BinarySpec binary , TextReportBuilder builder ) { BinaryBuildAbility buildAbility = ( ( BinarySpecInternal ) binary ) . getBuildAbility ( ) ; if ( ! buildAbility . isBuildable ( ) ) { TreeFormatter formatter = new TreeFormatter ( ) ; buildAbility . explain ( formatter ) ; builder . item ( formatter . toString ( ) ) ; } } protected void renderOwnedSourceSets ( T binary , TextReportBuilder builder ) { if ( ( ( BinarySpecInternal ) binary ) . isLegacyBinary ( ) ) { return ; } ModelMap < LanguageSourceSet > sources = binary . getSources ( ) ; if ( ! sources . isEmpty ( ) ) { SourceSetRenderer sourceSetRenderer = new SourceSetRenderer ( ) ; builder . collection ( <str> , sources . values ( ) , sourceSetRenderer , <str> ) ; } } } 
