package org . junit . tests . running . classes ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; import java . util . List ; import org . hamcrest . Matcher ; import org . hamcrest . TypeSafeMatcher ; import org . junit . Assert ; import org . junit . BeforeClass ; import org . junit . Ignore ; import org . junit . Test ; import org . junit . internal . AssumptionViolatedException ; import org . junit . runner . Description ; import org . junit . runner . JUnitCore ; import org . junit . runner . Request ; import org . junit . runner . Result ; import org . junit . runner . manipulation . Filter ; import org . junit . runner . notification . Failure ; import org . junit . runner . notification . RunListener ; import org . junit . runner . notification . RunNotifier ; import org . junit . runners . BlockJUnit4ClassRunner ; import org . junit . runners . ParentRunner ; import org . junit . runners . model . InitializationError ; import org . junit . runners . model . RunnerScheduler ; import org . junit . tests . experimental . rules . RuleMemberValidatorTest . TestWithNonStaticClassRule ; import org . junit . tests . experimental . rules . RuleMemberValidatorTest . TestWithProtectedClassRule ; public class ParentRunnerTest { public static String log = <str> ; public static class FruitTest { @Test public void apple ( ) { log + = <str> ; } @Test public void Banana ( ) { log + = <str> ; } } @Test public void useChildHarvester ( ) throws InitializationError { log = <str> ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( FruitTest . class ) ; runner . setScheduler ( new RunnerScheduler ( ) { public void schedule ( Runnable childStatement ) { log + = <str> ; childStatement . run ( ) ; log + = <str> ; } public void finished ( ) { log + = <str> ; } } ) ; runner . run ( new RunNotifier ( ) ) ; assertEquals ( <str> , log ) ; } @Test public void testMultipleFilters ( ) throws Exception { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( ExampleTest . class ) ; Request requestFiltered = request . filterWith ( new Exclude ( <str> ) ) ; Request requestFilteredFiltered = requestFiltered . filterWith ( new Exclude ( <str> ) ) ; Result result = junitCore . run ( requestFilteredFiltered ) ; assertThat ( result . getFailures ( ) , isEmpty ( ) ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; } private Matcher < List < ? > > isEmpty ( ) { return new TypeSafeMatcher < List < ? > > ( ) { public void describeTo ( org . hamcrest . Description description ) { description . appendText ( <str> ) ; } @Override public boolean matchesSafely ( List < ? > item ) { return item . size ( ) = = <int> ; } } ; } private static class Exclude extends Filter { private final String methodName ; public Exclude ( String methodName ) { this . methodName = methodName ; } @Override public boolean shouldRun ( Description description ) { return ! description . getMethodName ( ) . equals ( methodName ) ; } @Override public String describe ( ) { return <str> + methodName ; } } public static class ExampleTest { @Test public void test1 ( ) throws Exception { } @Test public void test2 ( ) throws Exception { } @Test public void test3 ( ) throws Exception { } } @Test public void failWithHelpfulMessageForProtectedClassRule ( ) { assertClassHasFailureMessage ( TestWithProtectedClassRule . class , <str> ) ; } @Test public void failWithHelpfulMessageForNonStaticClassRule ( ) { assertClassHasFailureMessage ( TestWithNonStaticClassRule . class , <str> ) ; } static class NonPublicTestClass { public NonPublicTestClass ( ) { } } @Test public void cannotBeCreatedWithNonPublicTestClass ( ) { assertClassHasFailureMessage ( NonPublicTestClass . class , <str> ) ; } private void assertClassHasFailureMessage ( Class < ? > klass , String message ) { JUnitCore junitCore = new JUnitCore ( ) ; Request request = Request . aClass ( klass ) ; Result result = junitCore . run ( request ) ; assertThat ( result . getFailureCount ( ) , is ( <int> ) ) ; assertThat ( result . getFailures ( ) . get ( <int> ) . getMessage ( ) , is ( equalTo ( message ) ) ) ; } public static class AssertionErrorAtParentLevelTest { @BeforeClass public static void beforeClass ( ) throws Throwable { throw new AssertionError ( <str> ) ; } @Test public void test ( ) { } } @Test public void assertionErrorAtParentLevelTest ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssertionErrorAtParentLevelTest . class ) ; Assert . assertEquals ( <int> , countingRunListener . testStarted ) ; Assert . assertEquals ( <int> , countingRunListener . testFinished ) ; Assert . assertEquals ( <int> , countingRunListener . testFailure ) ; Assert . assertEquals ( <int> , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( <int> , countingRunListener . testIgnored ) ; } public static class AssumptionViolatedAtParentLevelTest { @SuppressWarnings ( <str> ) @BeforeClass public static void beforeClass ( ) { throw new AssumptionViolatedException ( <str> ) ; } @Test public void test ( ) { } } @Test public void assumptionViolatedAtParentLevel ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( AssumptionViolatedAtParentLevelTest . class ) ; Assert . assertEquals ( <int> , countingRunListener . testStarted ) ; Assert . assertEquals ( <int> , countingRunListener . testFinished ) ; Assert . assertEquals ( <int> , countingRunListener . testFailure ) ; Assert . assertEquals ( <int> , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( <int> , countingRunListener . testIgnored ) ; } public static class TestTest { @Test public void pass ( ) { } @Test public void fail ( ) { throw new AssertionError ( <str> ) ; } @Ignore @Test public void ignore ( ) { } @SuppressWarnings ( <str> ) @Test public void assumptionFail ( ) { throw new AssumptionViolatedException ( <str> ) ; } } @Test public void parentRunnerTestMethods ( ) throws InitializationError { CountingRunListener countingRunListener = runTestWithParentRunner ( TestTest . class ) ; Assert . assertEquals ( <int> , countingRunListener . testStarted ) ; Assert . assertEquals ( <int> , countingRunListener . testFinished ) ; Assert . assertEquals ( <int> , countingRunListener . testFailure ) ; Assert . assertEquals ( <int> , countingRunListener . testAssumptionFailure ) ; Assert . assertEquals ( <int> , countingRunListener . testIgnored ) ; } private CountingRunListener runTestWithParentRunner ( Class < ? > testClass ) throws InitializationError { CountingRunListener listener = new CountingRunListener ( ) ; RunNotifier runNotifier = new RunNotifier ( ) ; runNotifier . addListener ( listener ) ; ParentRunner < ? > runner = new BlockJUnit4ClassRunner ( testClass ) ; runner . run ( runNotifier ) ; return listener ; } private static class CountingRunListener extends RunListener { private int testStarted = <int> ; private int testFinished = <int> ; private int testFailure = <int> ; private int testAssumptionFailure = <int> ; private int testIgnored = <int> ; @Override public void testStarted ( Description description ) throws Exception { testStarted + + ; } @Override public void testFinished ( Description description ) throws Exception { testFinished + + ; } @Override public void testFailure ( Failure failure ) throws Exception { testFailure + + ; } @Override public void testAssumptionFailure ( Failure failure ) { testAssumptionFailure + + ; } @Override public void testIgnored ( Description description ) throws Exception { testIgnored + + ; } } } 
