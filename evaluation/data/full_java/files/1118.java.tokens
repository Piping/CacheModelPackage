package org . apache . cassandra . tools . nodetool ; import static com . google . common . collect . Lists . newArrayList ; import static org . apache . commons . lang3 . StringUtils . EMPTY ; import io . airlift . command . Arguments ; import io . airlift . command . Command ; import io . airlift . command . Option ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import com . google . common . collect . Sets ; import org . apache . cassandra . repair . RepairParallelism ; import org . apache . cassandra . repair . SystemDistributedKeyspace ; import org . apache . cassandra . repair . messages . RepairOption ; import org . apache . cassandra . tools . NodeProbe ; import org . apache . cassandra . tools . NodeTool . NodeToolCmd ; import org . apache . commons . lang3 . StringUtils ; @Command ( name = <str> , description = <str> ) public class Repair extends NodeToolCmd { public final static Set < String > ONLY_EXPLICITLY_REPAIRED = Sets . newHashSet ( SystemDistributedKeyspace . NAME ) ; @Arguments ( usage = <str> , description = <str> ) private List < String > args = new ArrayList < > ( ) ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean sequential = false ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean dcParallel = false ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean localDC = false ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private List < String > specificDataCenters = new ArrayList < > ( ) ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private List < String > specificHosts = new ArrayList < > ( ) ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private String startToken = EMPTY ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private String endToken = EMPTY ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean primaryRange = false ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean fullRepair = false ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> + <str> + <str> ) private int numJobThreads = <int> ; @Option ( title = <str> , name = { <str> , <str> } , description = <str> ) private boolean trace = false ; @Override public void execute ( NodeProbe probe ) { List < String > keyspaces = parseOptionalKeyspace ( args , probe ) ; String [ ] cfnames = parseOptionalTables ( args ) ; if ( primaryRange & & ( ! specificDataCenters . isEmpty ( ) | | ! specificHosts . isEmpty ( ) ) ) throw new RuntimeException ( <str> ) ; for ( String keyspace : keyspaces ) { if ( ( args = = null | | args . isEmpty ( ) ) & & ONLY_EXPLICITLY_REPAIRED . contains ( keyspace ) ) continue ; Map < String , String > options = new HashMap < > ( ) ; RepairParallelism parallelismDegree = RepairParallelism . PARALLEL ; if ( sequential ) parallelismDegree = RepairParallelism . SEQUENTIAL ; else if ( dcParallel ) parallelismDegree = RepairParallelism . DATACENTER_AWARE ; options . put ( RepairOption . PARALLELISM_KEY , parallelismDegree . getName ( ) ) ; options . put ( RepairOption . PRIMARY_RANGE_KEY , Boolean . toString ( primaryRange ) ) ; options . put ( RepairOption . INCREMENTAL_KEY , Boolean . toString ( ! fullRepair ) ) ; options . put ( RepairOption . JOB_THREADS_KEY , Integer . toString ( numJobThreads ) ) ; options . put ( RepairOption . TRACE_KEY , Boolean . toString ( trace ) ) ; options . put ( RepairOption . COLUMNFAMILIES_KEY , StringUtils . join ( cfnames , <str> ) ) ; if ( ! startToken . isEmpty ( ) | | ! endToken . isEmpty ( ) ) { options . put ( RepairOption . RANGES_KEY , startToken + <str> + endToken ) ; } if ( localDC ) { options . put ( RepairOption . DATACENTERS_KEY , StringUtils . join ( newArrayList ( probe . getDataCenter ( ) ) , <str> ) ) ; } else { options . put ( RepairOption . DATACENTERS_KEY , StringUtils . join ( specificDataCenters , <str> ) ) ; } options . put ( RepairOption . HOSTS_KEY , StringUtils . join ( specificHosts , <str> ) ) ; try { probe . repairAsync ( System . out , keyspace , options ) ; } catch ( Exception e ) { throw new RuntimeException ( <str> , e ) ; } } } } 
