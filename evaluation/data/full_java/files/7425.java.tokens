package org . elasticsearch . search . aggregations . pipeline . movavg ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorFactory ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . MovAvgModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . MovAvgModelParserMapper ; import org . elasticsearch . search . aggregations . support . format . ValueFormat ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . text . ParseException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; public class MovAvgParser implements PipelineAggregator . Parser { public static final ParseField MODEL = new ParseField ( <str> ) ; public static final ParseField WINDOW = new ParseField ( <str> ) ; public static final ParseField SETTINGS = new ParseField ( <str> ) ; public static final ParseField PREDICT = new ParseField ( <str> ) ; public static final ParseField MINIMIZE = new ParseField ( <str> ) ; private final MovAvgModelParserMapper movAvgModelParserMapper ; @Inject public MovAvgParser ( MovAvgModelParserMapper movAvgModelParserMapper ) { this . movAvgModelParserMapper = movAvgModelParserMapper ; } @Override public String type ( ) { return MovAvgPipelineAggregator . TYPE . name ( ) ; } @Override public PipelineAggregatorFactory parse ( String pipelineAggregatorName , XContentParser parser , SearchContext context ) throws IOException { XContentParser . Token token ; String currentFieldName = null ; String [ ] bucketsPaths = null ; String format = null ; GapPolicy gapPolicy = GapPolicy . SKIP ; int window = <int> ; Map < String , Object > settings = null ; String model = <str> ; int predict = <int> ; Boolean minimize = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_NUMBER ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , WINDOW ) ) { window = parser . intValue ( ) ; if ( window < = <int> ) { throw new SearchParseException ( context , <str> + currentFieldName + <str> + <str> + predict + <str> + pipelineAggregatorName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , PREDICT ) ) { predict = parser . intValue ( ) ; if ( predict < = <int> ) { throw new SearchParseException ( context , <str> + currentFieldName + <str> + <str> + predict + <str> + pipelineAggregatorName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + pipelineAggregatorName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_STRING ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , FORMAT ) ) { format = parser . text ( ) ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , BUCKETS_PATH ) ) { bucketsPaths = new String [ ] { parser . text ( ) } ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , GAP_POLICY ) ) { gapPolicy = GapPolicy . parse ( context , parser . text ( ) , parser . getTokenLocation ( ) ) ; } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , MODEL ) ) { model = parser . text ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + pipelineAggregatorName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_ARRAY ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , BUCKETS_PATH ) ) { List < String > paths = new ArrayList < > ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_ARRAY ) { String path = parser . text ( ) ; paths . add ( path ) ; } bucketsPaths = paths . toArray ( new String [ paths . size ( ) ] ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + pipelineAggregatorName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , SETTINGS ) ) { settings = parser . map ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + pipelineAggregatorName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . VALUE_BOOLEAN ) { if ( context . parseFieldMatcher ( ) . match ( currentFieldName , MINIMIZE ) ) { minimize = parser . booleanValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + pipelineAggregatorName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + pipelineAggregatorName + <str> , parser . getTokenLocation ( ) ) ; } } if ( bucketsPaths = = null ) { throw new SearchParseException ( context , <str> + BUCKETS_PATH . getPreferredName ( ) + <str> + pipelineAggregatorName + <str> , parser . getTokenLocation ( ) ) ; } ValueFormatter formatter = null ; if ( format ! = null ) { formatter = ValueFormat . Patternable . Number . format ( format ) . formatter ( ) ; } else { formatter = ValueFormatter . RAW ; } MovAvgModel . AbstractModelParser modelParser = movAvgModelParserMapper . get ( model ) ; if ( modelParser = = null ) { throw new SearchParseException ( context , <str> + model + <str> + movAvgModelParserMapper . getAllNames ( ) . toString ( ) , parser . getTokenLocation ( ) ) ; } MovAvgModel movAvgModel ; try { movAvgModel = modelParser . parse ( settings , pipelineAggregatorName , window , context . parseFieldMatcher ( ) ) ; } catch ( ParseException exception ) { throw new SearchParseException ( context , <str> + model + <str> , null , exception ) ; } if ( minimize = = null ) { minimize = movAvgModel . minimizeByDefault ( ) ; } else if ( minimize & & ! movAvgModel . canBeMinimized ( ) ) { throw new SearchParseException ( context , <str> + model + <str> , null ) ; } return new MovAvgPipelineAggregator . Factory ( pipelineAggregatorName , bucketsPaths , formatter , gapPolicy , window , predict , movAvgModel , minimize ) ; } } 
