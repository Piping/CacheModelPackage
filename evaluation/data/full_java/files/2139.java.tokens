package org . nd4j . linalg . api . parallel . tasks . cpu . misc ; import io . netty . buffer . ByteBuf ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . parallel . tasks . Task ; import org . nd4j . linalg . api . parallel . tasks . TaskExecutorProvider ; import org . nd4j . linalg . factory . Nd4j ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . Future ; import java . util . concurrent . RecursiveTask ; public class CPUCol2ImTask extends RecursiveTask < INDArray > implements Task < INDArray > { protected Future < INDArray > future ; protected List < CPUCol2ImTask > subTasks ; protected final INDArray col ; protected INDArray imgOut ; protected final int kernelHeight ; protected final int kernelWidth ; protected final int strideY ; protected final int strideX ; protected final int padHeight ; protected final int padWidth ; protected final int imgHeight ; protected final int imgWidth ; protected final int parallelThreshold ; protected final int exampleFrom ; protected final int exampleTo ; protected final int depthFrom ; protected final int depthTo ; public CPUCol2ImTask ( INDArray col , int strideY , int strideX , int padHeight , int padWidth , int imgHeight , int imgWidth , int parallelThreshold ) { this ( col , getNewOutputArray ( col , imgHeight , imgWidth ) , strideY , strideX , padHeight , padWidth , imgHeight , imgWidth , <int> , col . size ( <int> ) , <int> , col . size ( <int> ) , parallelThreshold ) ; } public CPUCol2ImTask ( INDArray col , INDArray imgOut , int strideY , int strideX , int padHeight , int padWidth , int imgHeight , int imgWidth , int exampleFrom , int exampleTo , int depthFrom , int depthTo , int parallelThreshold ) { this . col = col ; this . imgOut = imgOut ; this . kernelHeight = col . size ( <int> ) ; this . kernelWidth = col . size ( <int> ) ; this . strideY = strideY ; this . strideX = strideX ; this . padHeight = padHeight ; this . padWidth = padWidth ; this . imgHeight = imgHeight ; this . imgWidth = imgWidth ; this . parallelThreshold = parallelThreshold ; this . exampleFrom = exampleFrom ; this . exampleTo = exampleTo ; this . depthFrom = depthFrom ; this . depthTo = depthTo ; } private static INDArray getNewOutputArray ( INDArray col , int imgHeight , int imgWidth ) { int n = col . size ( <int> ) ; int c = col . size ( <int> ) ; return Nd4j . create ( n , c , imgHeight , imgWidth ) ; } @Override protected INDArray compute ( ) { splitOrExecute ( true ) ; return imgOut ; } @Override public INDArray call ( ) { splitOrExecute ( true ) ; return null ; } private void splitOrExecute ( final boolean forkJoin ) { if ( ! forkJoin ) subTasks = new ArrayList < > ( ) ; if ( parallelThreshold ! = Integer . MAX_VALUE & & opSize ( ) > parallelThreshold ) { CPUCol2ImTask first ; CPUCol2ImTask second ; int temp ; if ( ( temp = exampleTo - exampleFrom ) > <int> ) { int countFirst = temp / <int> ; first = new CPUCol2ImTask ( col , imgOut , strideY , strideX , padHeight , padWidth , imgHeight , imgWidth , exampleFrom , exampleFrom + countFirst , depthFrom , depthTo , parallelThreshold ) ; if ( forkJoin ) first . fork ( ) ; else { first . invokeAsync ( ) ; subTasks . add ( first ) ; } second = new CPUCol2ImTask ( col , imgOut , strideY , strideX , padHeight , padWidth , imgHeight , imgWidth , exampleFrom + countFirst , exampleTo , depthFrom , depthTo , parallelThreshold ) ; if ( forkJoin ) second . fork ( ) ; else { second . invokeAsync ( ) ; subTasks . add ( second ) ; } } else if ( ( temp = depthTo - depthFrom ) > <int> ) { int countFirst = temp / <int> ; first = new CPUCol2ImTask ( col , imgOut , strideY , strideX , padHeight , padWidth , imgHeight , imgWidth , exampleFrom , exampleTo , depthFrom , depthFrom + countFirst , parallelThreshold ) ; first . fork ( ) ; second = new CPUCol2ImTask ( col , imgOut , strideY , strideX , padHeight , padWidth , imgHeight , imgWidth , exampleFrom , exampleTo , depthFrom + countFirst , depthTo , parallelThreshold ) ; second . fork ( ) ; } else { execute ( ) ; return ; } if ( forkJoin ) { first . join ( ) ; second . join ( ) ; } } else { execute ( ) ; } } private int opSize ( ) { return ( exampleTo - exampleFrom ) * ( depthTo - depthFrom ) * col . size ( <int> ) * col . size ( <int> ) * kernelHeight * kernelWidth ; } private void execute ( ) { DataBuffer dbIn = col . data ( ) ; if ( dbIn . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { if ( dbIn . dataType ( ) = = DataBuffer . Type . FLOAT ) { doHeapFloat ( ) ; } else { doHeapDouble ( ) ; } } else { if ( dbIn . dataType ( ) = = DataBuffer . Type . FLOAT ) { doDirectFloat ( ) ; } else { doDirectDouble ( ) ; } } } private void doHeapFloat ( ) { DataBuffer dbCol = col . data ( ) ; DataBuffer dbOut = imgOut . data ( ) ; int outArrayOffset = imgOut . offset ( ) ; int [ ] outShape = imgOut . shape ( ) ; int [ ] outStride = imgOut . stride ( ) ; int inOffset = col . offset ( ) ; int [ ] inShape = col . shape ( ) ; int [ ] inStride = col . stride ( ) ; int [ ] outIndices = new int [ <int> ] ; int [ ] inIndices = new int [ <int> ] ; final int inStride2 = inStride [ <int> ] ; final int inStride3 = inStride [ <int> ] ; final int outStride2 = outStride [ <int> ] ; final int outStride3 = outStride [ <int> ] ; final int outShape2 = outShape [ <int> ] ; final int outShape3 = outShape [ <int> ] ; final int yOutTo = inShape [ <int> ] ; final int xOutTo = inShape [ <int> ] ; final boolean padding = padHeight > <int> | | padWidth > <int> ; float [ ] fIn = ( float [ ] ) dbCol . array ( ) ; float [ ] fOut = ( float [ ] ) dbOut . array ( ) ; for ( int ex = exampleFrom ; ex < exampleTo ; ex + + ) { for ( int d = depthFrom ; d < depthTo ; d + + ) { inIndices [ <int> ] = ex ; inIndices [ <int> ] = d ; outIndices [ <int> ] = ex ; outIndices [ <int> ] = d ; for ( int x = <int> ; x < xOutTo ; x + + ) { for ( int y = <int> ; y < yOutTo ; y + + ) { inIndices [ <int> ] = y ; inIndices [ <int> ] = x ; int baseOffsetIn = getOffsetUnsafe6 ( inOffset , inShape , inStride , inIndices ) ; if ( padding ) { int i = y * strideY - padHeight ; int j = x * strideX - padWidth ; outIndices [ <int> ] = i ; outIndices [ <int> ] = j ; int baseOffsetOut = getOffsetUnsafe4 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( inStride2 < = inStride3 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( j + patchX < <int> | | j + patchX > = outShape3 ) continue ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | i + patchY > = outShape2 ) continue ; fOut [ baseOffsetOut + patchY * outStride2 + patchX * outStride3 ] + = fIn [ baseOffsetIn + patchY * inStride2 + patchX * inStride3 ] ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | i + patchY > = outShape2 ) continue ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( j + patchX < <int> | | j + patchX > = outShape3 ) continue ; fOut [ baseOffsetOut + patchY * outStride2 + patchX * outStride3 ] + = fIn [ baseOffsetIn + patchY * inStride2 + patchX * inStride3 ] ; } } } } else { int i = y * strideY ; int j = x * strideX ; outIndices [ <int> ] = i ; outIndices [ <int> ] = j ; int baseOffsetOut = getOffsetUnsafe4 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( inStride2 < = inStride3 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { fOut [ baseOffsetOut + patchY * outStride2 + patchX * outStride3 ] + = fIn [ baseOffsetIn + patchY * inStride2 + patchX * inStride3 ] ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { fOut [ baseOffsetOut + patchY * outStride2 + patchX * outStride3 ] + = fIn [ baseOffsetIn + patchY * inStride2 + patchX * inStride3 ] ; } } } } } } } } } private void doHeapDouble ( ) { DataBuffer dbCol = col . data ( ) ; DataBuffer dbOut = imgOut . data ( ) ; int outArrayOffset = imgOut . offset ( ) ; int [ ] outShape = imgOut . shape ( ) ; int [ ] outStride = imgOut . stride ( ) ; int inOffset = col . offset ( ) ; int [ ] inShape = col . shape ( ) ; int [ ] inStride = col . stride ( ) ; int [ ] outIndices = new int [ <int> ] ; int [ ] inIndices = new int [ <int> ] ; final int inStride2 = inStride [ <int> ] ; final int inStride3 = inStride [ <int> ] ; final int outStride2 = outStride [ <int> ] ; final int outStride3 = outStride [ <int> ] ; final int outShape2 = outShape [ <int> ] ; final int outShape3 = outShape [ <int> ] ; final int yOutTo = inShape [ <int> ] ; final int xOutTo = inShape [ <int> ] ; final boolean padding = padHeight > <int> | | padWidth > <int> ; double [ ] dIn = ( double [ ] ) dbCol . array ( ) ; double [ ] dOut = ( double [ ] ) dbOut . array ( ) ; for ( int ex = exampleFrom ; ex < exampleTo ; ex + + ) { for ( int d = depthFrom ; d < depthTo ; d + + ) { inIndices [ <int> ] = ex ; inIndices [ <int> ] = d ; outIndices [ <int> ] = ex ; outIndices [ <int> ] = d ; for ( int x = <int> ; x < xOutTo ; x + + ) { for ( int y = <int> ; y < yOutTo ; y + + ) { inIndices [ <int> ] = y ; inIndices [ <int> ] = x ; int baseOffsetIn = getOffsetUnsafe6 ( inOffset , inShape , inStride , inIndices ) ; if ( padding ) { int i = y * strideY - padHeight ; int j = x * strideX - padWidth ; outIndices [ <int> ] = i ; outIndices [ <int> ] = j ; int baseOffsetOut = getOffsetUnsafe4 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( inStride2 < = inStride3 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( j + patchX < <int> | | j + patchX > = outShape3 ) continue ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | i + patchY > = outShape2 ) continue ; dOut [ baseOffsetOut + patchY * outStride2 + patchX * outStride3 ] + = dIn [ baseOffsetIn + patchY * inStride2 + patchX * inStride3 ] ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | i + patchY > = outShape2 ) continue ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( j + patchX < <int> | | j + patchX > = outShape3 ) continue ; dOut [ baseOffsetOut + patchY * outStride2 + patchX * outStride3 ] + = dIn [ baseOffsetIn + patchY * inStride2 + patchX * inStride3 ] ; } } } } else { int i = y * strideY ; int j = x * strideX ; outIndices [ <int> ] = i ; outIndices [ <int> ] = j ; int baseOffsetOut = getOffsetUnsafe4 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( inStride2 < = inStride3 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { dOut [ baseOffsetOut + patchY * outStride2 + patchX * outStride3 ] + = dIn [ baseOffsetIn + patchY * inStride2 + patchX * inStride3 ] ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { dOut [ baseOffsetOut + patchY * outStride2 + patchX * outStride3 ] + = dIn [ baseOffsetIn + patchY * inStride2 + patchX * inStride3 ] ; } } } } } } } } } private void doDirectFloat ( ) { DataBuffer dbCol = col . data ( ) ; DataBuffer dbOut = imgOut . data ( ) ; int outArrayOffset = imgOut . offset ( ) ; int [ ] outShape = imgOut . shape ( ) ; int [ ] outStride = imgOut . stride ( ) ; int inOffset = col . offset ( ) ; int [ ] inShape = col . shape ( ) ; int [ ] inStride = col . stride ( ) ; int [ ] outIndices = new int [ <int> ] ; int [ ] inIndices = new int [ <int> ] ; final int inStride2_times4 = inStride [ <int> ] * <int> ; final int inStride3_times4 = inStride [ <int> ] * <int> ; final int outStride2_times4 = outStride [ <int> ] * <int> ; final int outStride3_times4 = outStride [ <int> ] * <int> ; final int outShape2 = outShape [ <int> ] ; final int outShape3 = outShape [ <int> ] ; final int yOutTo = inShape [ <int> ] ; final int xOutTo = inShape [ <int> ] ; final boolean padding = padHeight > <int> | | padWidth > <int> ; ByteBuf nbbIn = dbCol . asNetty ( ) ; ByteBuf nbbOut = dbOut . asNetty ( ) ; for ( int ex = exampleFrom ; ex < exampleTo ; ex + + ) { for ( int d = depthFrom ; d < depthTo ; d + + ) { inIndices [ <int> ] = ex ; inIndices [ <int> ] = d ; outIndices [ <int> ] = ex ; outIndices [ <int> ] = d ; for ( int x = <int> ; x < xOutTo ; x + + ) { for ( int y = <int> ; y < yOutTo ; y + + ) { inIndices [ <int> ] = y ; inIndices [ <int> ] = x ; int baseOffsetInBytes = <int> * getOffsetUnsafe6 ( inOffset , inShape , inStride , inIndices ) ; if ( padding ) { int i = y * strideY - padHeight ; int j = x * strideX - padWidth ; outIndices [ <int> ] = i ; outIndices [ <int> ] = j ; int baseOffsetOutBytes = <int> * getOffsetUnsafe4 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( inStride2_times4 < = inStride3_times4 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( j + patchX < <int> | | j + patchX > = outShape3 ) continue ; int outBufferIdxXBytes = baseOffsetOutBytes + patchX * outStride3_times4 ; int inBufferIdxXBytes = baseOffsetInBytes + patchX * inStride3_times4 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | i + patchY > = outShape2 ) continue ; int byteOffset = outBufferIdxXBytes + patchY * outStride2_times4 ; nbbOut . setFloat ( byteOffset , nbbOut . getFloat ( byteOffset ) + nbbIn . getFloat ( inBufferIdxXBytes + patchY * inStride2_times4 ) ) ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | i + patchY > = outShape2 ) continue ; int outBufferIdxYBytes = baseOffsetOutBytes + patchY * outStride2_times4 ; int inBufferIdxYBytes = baseOffsetInBytes + patchY * inStride2_times4 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( j + patchX < <int> | | j + patchX > = outShape3 ) continue ; int byteOffset = outBufferIdxYBytes + patchX * outStride3_times4 ; nbbOut . setFloat ( byteOffset , nbbOut . getFloat ( byteOffset ) + nbbIn . getFloat ( inBufferIdxYBytes + patchX * inStride3_times4 ) ) ; } } } } else { int i = y * strideY ; int j = x * strideX ; outIndices [ <int> ] = i ; outIndices [ <int> ] = j ; int baseOffsetOutBytes = <int> * getOffsetUnsafe4 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( inStride2_times4 < = inStride3_times4 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxXBytes = baseOffsetOutBytes + patchX * outStride3_times4 ; int inBufferIdxXBytes = baseOffsetInBytes + patchX * inStride3_times4 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int byteOffset = outBufferIdxXBytes + patchY * outStride2_times4 ; nbbOut . setFloat ( byteOffset , nbbOut . getFloat ( byteOffset ) + nbbIn . getFloat ( inBufferIdxXBytes + patchY * inStride2_times4 ) ) ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxYBytes = baseOffsetOutBytes + patchY * outStride2_times4 ; int inBufferIdxYBytes = baseOffsetInBytes + patchY * inStride2_times4 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int byteOffset = outBufferIdxYBytes + patchX * outStride3_times4 ; nbbOut . setFloat ( byteOffset , nbbOut . getFloat ( byteOffset ) + nbbIn . getFloat ( inBufferIdxYBytes + patchX * inStride3_times4 ) ) ; } } } } } } } } } private void doDirectDouble ( ) { DataBuffer dbCol = col . data ( ) ; DataBuffer dbOut = imgOut . data ( ) ; int outArrayOffset = imgOut . offset ( ) ; int [ ] outShape = imgOut . shape ( ) ; int [ ] outStride = imgOut . stride ( ) ; int inOffset = col . offset ( ) ; int [ ] inShape = col . shape ( ) ; int [ ] inStride = col . stride ( ) ; int [ ] outIndices = new int [ <int> ] ; int [ ] inIndices = new int [ <int> ] ; final int inStride2_times8 = inStride [ <int> ] * <int> ; final int inStride3_times8 = inStride [ <int> ] * <int> ; final int outStride2_times8 = outStride [ <int> ] * <int> ; final int outStride3_times8 = outStride [ <int> ] * <int> ; final int outShape2 = outShape [ <int> ] ; final int outShape3 = outShape [ <int> ] ; final int yOutTo = inShape [ <int> ] ; final int xOutTo = inShape [ <int> ] ; final boolean padding = padHeight > <int> | | padWidth > <int> ; ByteBuf nbbIn = dbCol . asNetty ( ) ; ByteBuf nbbOut = dbOut . asNetty ( ) ; for ( int ex = exampleFrom ; ex < exampleTo ; ex + + ) { for ( int d = depthFrom ; d < depthTo ; d + + ) { inIndices [ <int> ] = ex ; inIndices [ <int> ] = d ; outIndices [ <int> ] = ex ; outIndices [ <int> ] = d ; for ( int x = <int> ; x < xOutTo ; x + + ) { for ( int y = <int> ; y < yOutTo ; y + + ) { inIndices [ <int> ] = y ; inIndices [ <int> ] = x ; int baseOffsetInBytes = <int> * getOffsetUnsafe6 ( inOffset , inShape , inStride , inIndices ) ; if ( padding ) { int i = y * strideY - padHeight ; int j = x * strideX - padWidth ; outIndices [ <int> ] = i ; outIndices [ <int> ] = j ; int baseOffsetOutBytes = <int> * getOffsetUnsafe4 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( inStride2_times8 < = inStride3_times8 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( j + patchX < <int> | | j + patchX > = outShape3 ) continue ; int outBufferIdxXBytes = baseOffsetOutBytes + patchX * outStride3_times8 ; int inBufferIdxXBytes = baseOffsetInBytes + patchX * inStride3_times8 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | i + patchY > = outShape2 ) continue ; int byteOffset = outBufferIdxXBytes + patchY * outStride2_times8 ; nbbOut . setDouble ( byteOffset , nbbOut . getDouble ( byteOffset ) + nbbIn . getDouble ( inBufferIdxXBytes + patchY * inStride2_times8 ) ) ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { if ( i + patchY < <int> | | i + patchY > = outShape2 ) continue ; int outBufferIdxYBytes = baseOffsetOutBytes + patchY * outStride2_times8 ; int inBufferIdxYBytes = baseOffsetInBytes + patchY * inStride2_times8 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { if ( j + patchX < <int> | | j + patchX > = outShape3 ) continue ; int byteOffset = outBufferIdxYBytes + patchX * outStride3_times8 ; nbbOut . setDouble ( byteOffset , nbbOut . getDouble ( byteOffset ) + nbbIn . getDouble ( inBufferIdxYBytes + patchX * inStride3_times8 ) ) ; } } } } else { int i = y * strideY ; int j = x * strideX ; outIndices [ <int> ] = i ; outIndices [ <int> ] = j ; int baseOffsetOutBytes = <int> * getOffsetUnsafe4 ( outArrayOffset , outShape , outStride , outIndices ) ; if ( inStride2_times8 < = inStride3_times8 ) { for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int outBufferIdxXBytes = baseOffsetOutBytes + patchX * outStride3_times8 ; int inBufferIdxXBytes = baseOffsetInBytes + patchX * inStride3_times8 ; for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int byteOffset = outBufferIdxXBytes + patchY * outStride2_times8 ; nbbOut . setDouble ( byteOffset , nbbOut . getDouble ( byteOffset ) + nbbIn . getDouble ( inBufferIdxXBytes + patchY * inStride2_times8 ) ) ; } } } else { for ( int patchY = <int> ; patchY < kernelHeight ; patchY + + ) { int outBufferIdxYBytes = baseOffsetOutBytes + patchY * outStride2_times8 ; int inBufferIdxYBytes = baseOffsetInBytes + patchY * inStride2_times8 ; for ( int patchX = <int> ; patchX < kernelWidth ; patchX + + ) { int byteOffset = outBufferIdxYBytes + patchX * outStride3_times8 ; nbbOut . setDouble ( byteOffset , nbbOut . getDouble ( byteOffset ) + nbbIn . getDouble ( inBufferIdxYBytes + patchX * inStride3_times8 ) ) ; } } } } } } } } } private static int getOffsetUnsafe4 ( int baseOffset , int [ ] shape , int [ ] stride , int [ ] indices ) { int offset = baseOffset ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; return offset ; } private static int getOffsetUnsafe6 ( int baseOffset , int [ ] shape , int [ ] stride , int [ ] indices ) { int offset = baseOffset ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; if ( shape [ <int> ] ! = <int> ) offset + = indices [ <int> ] * stride [ <int> ] ; return offset ; } @Override public INDArray invokeBlocking ( ) { invokeAsync ( ) ; return blockUntilComplete ( ) ; } @Override public void invokeAsync ( ) { future = TaskExecutorProvider . getTaskExecutor ( ) . executeAsync ( this ) ; } @Override public INDArray blockUntilComplete ( ) { try { future . get ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( subTasks ! = null ) { for ( CPUCol2ImTask task : subTasks ) { task . blockUntilComplete ( ) ; } } return imgOut ; } } 
