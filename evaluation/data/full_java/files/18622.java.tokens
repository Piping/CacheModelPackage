package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . FloatAttribute ; import com . badlogic . gdx . graphics . g3d . attributes . TextureAttribute ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . physics . bullet . collision . CustomCollisionDispatcher ; import com . badlogic . gdx . physics . bullet . collision . btBoxShape ; import com . badlogic . gdx . physics . bullet . collision . btCapsuleShape ; import com . badlogic . gdx . physics . bullet . collision . btCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . collision . btCollisionDispatcher ; import com . badlogic . gdx . physics . bullet . collision . btCollisionObject ; import com . badlogic . gdx . physics . bullet . collision . btConeShape ; import com . badlogic . gdx . physics . bullet . collision . btCylinderShape ; import com . badlogic . gdx . physics . bullet . collision . btDbvtBroadphase ; import com . badlogic . gdx . physics . bullet . collision . btDefaultCollisionConfiguration ; import com . badlogic . gdx . physics . bullet . collision . btSphereShape ; import com . badlogic . gdx . physics . bullet . dynamics . btDiscreteDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btSequentialImpulseConstraintSolver ; public class CollisionDispatcherTest extends BaseBulletTest { public static class MyCollisionDispatcher extends CustomCollisionDispatcher { public MyCollisionDispatcher ( btCollisionConfiguration collisionConfiguration ) { super ( collisionConfiguration ) ; } @Override public boolean needsCollision ( btCollisionObject body0 , btCollisionObject body1 ) { if ( body0 . getUserValue ( ) % <int> = = <int> | | body1 . getUserValue ( ) % <int> = = <int> ) return super . needsCollision ( body0 , body1 ) ; return false ; } @Override public boolean needsResponse ( btCollisionObject body0 , btCollisionObject body1 ) { if ( body0 . getUserValue ( ) % <int> = = <int> | | body1 . getUserValue ( ) % <int> = = <int> ) return super . needsCollision ( body0 , body1 ) ; return false ; } } @Override public BulletWorld createWorld ( ) { btDefaultCollisionConfiguration collisionConfiguration = new btDefaultCollisionConfiguration ( ) ; MyCollisionDispatcher dispatcher = new MyCollisionDispatcher ( collisionConfiguration ) ; btDbvtBroadphase broadphase = new btDbvtBroadphase ( ) ; btSequentialImpulseConstraintSolver solver = new btSequentialImpulseConstraintSolver ( ) ; btDiscreteDynamicsWorld collisionWorld = new btDiscreteDynamicsWorld ( dispatcher , broadphase , solver , collisionConfiguration ) ; return new BulletWorld ( collisionConfiguration , dispatcher , broadphase , solver , collisionWorld ) ; } @Override public void create ( ) { super . create ( ) ; world . add ( <str> , <float> , <float> , <float> ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; for ( float x = - <float> ; x < = <float> ; x + = <float> ) { for ( float y = <float> ; y < = <int> f ; y + = <float> ) { world . add ( <str> , x + <float> * MathUtils . random ( ) , y + <float> * MathUtils . random ( ) , <float> * MathUtils . random ( ) ) . body . setUserValue ( ( int ) ( ( x + <float> ) / <float> + <float> ) ) ; } } } @Override public boolean tap ( float x , float y , int count , int button ) { shoot ( x , y ) ; return true ; } } 
