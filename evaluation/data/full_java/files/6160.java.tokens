package org . elasticsearch . common . xcontent . support . filtering ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . util . CollectionUtils ; import java . util . ArrayList ; import java . util . List ; public class FilterPath { static final FilterPath EMPTY = new FilterPath ( ) ; private final String filter ; private final String segment ; private final FilterPath next ; private final boolean simpleWildcard ; private final boolean doubleWildcard ; protected FilterPath ( String filter , String segment , FilterPath next ) { this . filter = filter ; this . segment = segment ; this . next = next ; this . simpleWildcard = ( segment ! = null ) & & ( segment . length ( ) = = <int> ) & & ( segment . charAt ( <int> ) = = <str> ) ; this . doubleWildcard = ( segment ! = null ) & & ( segment . length ( ) = = <int> ) & & ( segment . charAt ( <int> ) = = <str> ) & & ( segment . charAt ( <int> ) = = <str> ) ; } private FilterPath ( ) { this ( <str> , <str> , null ) ; } public FilterPath matchProperty ( String name ) { if ( ( next ! = null ) & & ( simpleWildcard | | doubleWildcard | | Regex . simpleMatch ( segment , name ) ) ) { return next ; } return null ; } public boolean matches ( ) { return next = = null ; } boolean isDoubleWildcard ( ) { return doubleWildcard ; } boolean isSimpleWildcard ( ) { return simpleWildcard ; } String getSegment ( ) { return segment ; } FilterPath getNext ( ) { return next ; } public static FilterPath [ ] compile ( String . . . filters ) { if ( CollectionUtils . isEmpty ( filters ) ) { return null ; } List < FilterPath > paths = new ArrayList < > ( ) ; for ( String filter : filters ) { if ( filter ! = null ) { filter = filter . trim ( ) ; if ( filter . length ( ) > <int> ) { paths . add ( parse ( filter , filter ) ) ; } } } return paths . toArray ( new FilterPath [ paths . size ( ) ] ) ; } private static FilterPath parse ( final String filter , final String segment ) { int end = segment . length ( ) ; for ( int i = <int> ; i < end ; ) { char c = segment . charAt ( i ) ; if ( c = = <str> ) { String current = segment . substring ( <int> , i ) . replaceAll ( <str> , <str> ) ; return new FilterPath ( filter , current , parse ( filter , segment . substring ( i + <int> ) ) ) ; } + + i ; if ( ( c = = <str> ) & & ( i < end ) & & ( segment . charAt ( i ) = = <str> ) ) { + + i ; } } return new FilterPath ( filter , segment . replaceAll ( <str> , <str> ) , EMPTY ) ; } @Override public String toString ( ) { return <str> + filter + <str> + segment + <str> ; } } 
