package org . elasticsearch . percolator ; import org . elasticsearch . action . percolate . PercolateRequestBuilder ; import org . elasticsearch . action . percolate . PercolateResponse ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . search . aggregations . Aggregation ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . search . aggregations . Aggregations ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . Terms . Order ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilders ; import org . elasticsearch . search . aggregations . pipeline . bucketmetrics . InternalBucketMetricValue ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . action . percolate . PercolateSourceBuilder . docBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertMatchCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . arrayWithSize ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . notNullValue ; public class PercolatorFacetsAndAggregationsIT extends ESIntegTestCase { public void testFacetsAndAggregations ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; ensureGreen ( ) ; int numQueries = scaledRandomIntBetween ( <int> , <int> ) ; int numUniqueQueries = between ( <int> , numQueries / <int> ) ; String [ ] values = new String [ numUniqueQueries ] ; for ( int i = <int> ; i < values . length ; i + + ) { values [ i ] = <str> + i ; } int [ ] expectedCount = new int [ numUniqueQueries ] ; logger . info ( <str> , numQueries ) ; for ( int i = <int> ; i < numQueries ; i + + ) { String value = values [ i % numUniqueQueries ] ; expectedCount [ i % numUniqueQueries ] + + ; QueryBuilder queryBuilder = matchQuery ( <str> , value ) ; client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , Integer . toString ( i ) ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , queryBuilder ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < numQueries ; i + + ) { String value = values [ i % numUniqueQueries ] ; PercolateRequestBuilder percolateRequestBuilder = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setPercolateDoc ( docBuilder ( ) . setDoc ( jsonBuilder ( ) . startObject ( ) . field ( <str> , value ) . endObject ( ) ) ) ; SubAggCollectionMode aggCollectionMode = randomFrom ( SubAggCollectionMode . values ( ) ) ; percolateRequestBuilder . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) ) ; if ( randomBoolean ( ) ) { percolateRequestBuilder . setPercolateQuery ( matchAllQuery ( ) ) ; } if ( randomBoolean ( ) ) { percolateRequestBuilder . setScore ( true ) ; } else { percolateRequestBuilder . setSortByScore ( true ) . setSize ( numQueries ) ; } boolean countOnly = randomBoolean ( ) ; if ( countOnly ) { percolateRequestBuilder . setOnlyCount ( countOnly ) ; } PercolateResponse response = percolateRequestBuilder . execute ( ) . actionGet ( ) ; assertMatchCount ( response , expectedCount [ i % numUniqueQueries ] ) ; if ( ! countOnly ) { assertThat ( response . getMatches ( ) , arrayWithSize ( expectedCount [ i % numUniqueQueries ] ) ) ; } List < Aggregation > aggregations = response . getAggregations ( ) . asList ( ) ; assertThat ( aggregations . size ( ) , equalTo ( <int> ) ) ; assertThat ( aggregations . get ( <int> ) . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > buckets = new ArrayList < > ( ( ( Terms ) aggregations . get ( <int> ) ) . getBuckets ( ) ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; assertThat ( buckets . get ( <int> ) . getKeyAsString ( ) , equalTo ( <str> ) ) ; assertThat ( buckets . get ( <int> ) . getDocCount ( ) , equalTo ( ( long ) expectedCount [ i % values . length ] ) ) ; } } public void testAggregationsAndPipelineAggregations ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; ensureGreen ( ) ; int numQueries = scaledRandomIntBetween ( <int> , <int> ) ; int numUniqueQueries = between ( <int> , numQueries / <int> ) ; String [ ] values = new String [ numUniqueQueries ] ; for ( int i = <int> ; i < values . length ; i + + ) { values [ i ] = <str> + i ; } int [ ] expectedCount = new int [ numUniqueQueries ] ; logger . info ( <str> , numQueries ) ; for ( int i = <int> ; i < numQueries ; i + + ) { String value = values [ i % numUniqueQueries ] ; expectedCount [ i % numUniqueQueries ] + + ; QueryBuilder queryBuilder = matchQuery ( <str> , value ) ; client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , Integer . toString ( i ) ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , queryBuilder ) . field ( <str> , <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < numQueries ; i + + ) { String value = values [ i % numUniqueQueries ] ; PercolateRequestBuilder percolateRequestBuilder = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setPercolateDoc ( docBuilder ( ) . setDoc ( jsonBuilder ( ) . startObject ( ) . field ( <str> , value ) . endObject ( ) ) ) ; SubAggCollectionMode aggCollectionMode = randomFrom ( SubAggCollectionMode . values ( ) ) ; percolateRequestBuilder . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) ) ; if ( randomBoolean ( ) ) { percolateRequestBuilder . setPercolateQuery ( matchAllQuery ( ) ) ; } if ( randomBoolean ( ) ) { percolateRequestBuilder . setScore ( true ) ; } else { percolateRequestBuilder . setSortByScore ( true ) . setSize ( numQueries ) ; } boolean countOnly = randomBoolean ( ) ; if ( countOnly ) { percolateRequestBuilder . setOnlyCount ( countOnly ) ; } percolateRequestBuilder . addAggregation ( PipelineAggregatorBuilders . maxBucket ( <str> ) . setBucketsPaths ( <str> ) ) ; PercolateResponse response = percolateRequestBuilder . execute ( ) . actionGet ( ) ; assertMatchCount ( response , expectedCount [ i % numUniqueQueries ] ) ; if ( ! countOnly ) { assertThat ( response . getMatches ( ) , arrayWithSize ( expectedCount [ i % numUniqueQueries ] ) ) ; } Aggregations aggregations = response . getAggregations ( ) ; assertThat ( aggregations . asList ( ) . size ( ) , equalTo ( <int> ) ) ; Terms terms = aggregations . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > buckets = new ArrayList < > ( terms . getBuckets ( ) ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; assertThat ( buckets . get ( <int> ) . getKeyAsString ( ) , equalTo ( <str> ) ) ; assertThat ( buckets . get ( <int> ) . getDocCount ( ) , equalTo ( ( long ) expectedCount [ i % values . length ] ) ) ; InternalBucketMetricValue maxA = aggregations . get ( <str> ) ; assertThat ( maxA , notNullValue ( ) ) ; assertThat ( maxA . getName ( ) , equalTo ( <str> ) ) ; assertThat ( maxA . value ( ) , equalTo ( ( double ) expectedCount [ i % values . length ] ) ) ; assertThat ( maxA . keys ( ) , equalTo ( new String [ ] { <str> } ) ) ; } } public void testSignificantAggs ( ) throws Exception { client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . execute ( ) . actionGet ( ) ; ensureGreen ( ) ; PercolateRequestBuilder percolateRequestBuilder = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setPercolateDoc ( docBuilder ( ) . setDoc ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) ) . addAggregation ( AggregationBuilders . significantTerms ( <str> ) . field ( <str> ) ) ; PercolateResponse response = percolateRequestBuilder . get ( ) ; assertNoFailures ( response ) ; } public void testSingleShardAggregations ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( indexSettings ( ) ) . put ( <str> , <int> ) ) . addMapping ( <str> , <str> , <str> , <str> , <str> ) ) ; ensureGreen ( ) ; int numQueries = scaledRandomIntBetween ( <int> , <int> ) ; logger . info ( <str> , numQueries ) ; for ( int i = <int> ; i < numQueries ; i + + ) { String value = <str> ; QueryBuilder queryBuilder = matchQuery ( <str> , value ) ; client ( ) . prepareIndex ( <str> , PercolatorService . TYPE_NAME , Integer . toString ( i ) ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( <str> , queryBuilder ) . field ( <str> , i % <int> = = <int> ? <str> : <str> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < numQueries ; i + + ) { String value = <str> ; PercolateRequestBuilder percolateRequestBuilder = client ( ) . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setPercolateDoc ( docBuilder ( ) . setDoc ( jsonBuilder ( ) . startObject ( ) . field ( <str> , value ) . endObject ( ) ) ) ; SubAggCollectionMode aggCollectionMode = randomFrom ( SubAggCollectionMode . values ( ) ) ; percolateRequestBuilder . addAggregation ( AggregationBuilders . terms ( <str> ) . field ( <str> ) . collectMode ( aggCollectionMode ) . order ( Order . term ( true ) ) . shardSize ( <int> ) . size ( <int> ) ) ; if ( randomBoolean ( ) ) { percolateRequestBuilder . setPercolateQuery ( matchAllQuery ( ) ) ; } if ( randomBoolean ( ) ) { percolateRequestBuilder . setScore ( true ) ; } else { percolateRequestBuilder . setSortByScore ( true ) . setSize ( numQueries ) ; } boolean countOnly = randomBoolean ( ) ; if ( countOnly ) { percolateRequestBuilder . setOnlyCount ( countOnly ) ; } percolateRequestBuilder . addAggregation ( PipelineAggregatorBuilders . maxBucket ( <str> ) . setBucketsPaths ( <str> ) ) ; PercolateResponse response = percolateRequestBuilder . execute ( ) . actionGet ( ) ; assertMatchCount ( response , numQueries ) ; if ( ! countOnly ) { assertThat ( response . getMatches ( ) , arrayWithSize ( numQueries ) ) ; } Aggregations aggregations = response . getAggregations ( ) ; assertThat ( aggregations . asList ( ) . size ( ) , equalTo ( <int> ) ) ; Terms terms = aggregations . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; List < Terms . Bucket > buckets = new ArrayList < > ( terms . getBuckets ( ) ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; assertThat ( buckets . get ( <int> ) . getKeyAsString ( ) , equalTo ( <str> ) ) ; InternalBucketMetricValue maxA = aggregations . get ( <str> ) ; assertThat ( maxA , notNullValue ( ) ) ; assertThat ( maxA . getName ( ) , equalTo ( <str> ) ) ; assertThat ( maxA . keys ( ) , equalTo ( new String [ ] { <str> } ) ) ; } } } 
