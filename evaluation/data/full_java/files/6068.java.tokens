package org . elasticsearch . common . unit ; import org . elasticsearch . common . geo . GeoUtils ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import java . io . IOException ; public enum DistanceUnit { INCH ( <float> , <str> , <str> ) , YARD ( <float> , <str> , <str> ) , FEET ( <float> , <str> , <str> ) , KILOMETERS ( <float> , <str> , <str> ) , NAUTICALMILES ( <float> , <str> , <str> , <str> ) , MILLIMETERS ( <float> , <str> , <str> ) , CENTIMETERS ( <float> , <str> , <str> ) , MILES ( <float> , <str> , <str> ) , METERS ( <int> , <str> , <str> ) ; public static final DistanceUnit DEFAULT = METERS ; private double meters ; private final String [ ] names ; DistanceUnit ( double meters , String . . . names ) { this . meters = meters ; this . names = names ; } public double getEarthCircumference ( ) { return GeoUtils . EARTH_EQUATOR / meters ; } public double getEarthRadius ( ) { return GeoUtils . EARTH_SEMI_MAJOR_AXIS / meters ; } public double getDistancePerDegree ( ) { return GeoUtils . EARTH_EQUATOR / ( <float> * meters ) ; } public double toMeters ( double distance ) { return convert ( distance , this , DistanceUnit . METERS ) ; } public double fromMeters ( double distance ) { return convert ( distance , DistanceUnit . METERS , this ) ; } public double convert ( double distance , DistanceUnit unit ) { return convert ( distance , unit , this ) ; } public String toString ( double distance ) { return distance + toString ( ) ; } @Override public String toString ( ) { return names [ <int> ] ; } public static double convert ( double distance , DistanceUnit from , DistanceUnit to ) { if ( from = = to ) { return distance ; } else { return distance * from . meters / to . meters ; } } public static double parse ( String distance , DistanceUnit defaultUnit , DistanceUnit to ) { Distance dist = Distance . parseDistance ( distance , defaultUnit ) ; return convert ( dist . value , dist . unit , to ) ; } public double parse ( String distance , DistanceUnit defaultUnit ) { return parse ( distance , defaultUnit , this ) ; } public static DistanceUnit fromString ( String unit ) { for ( DistanceUnit dunit : values ( ) ) { for ( String name : dunit . names ) { if ( name . equals ( unit ) ) { return dunit ; } } } throw new IllegalArgumentException ( <str> + unit + <str> ) ; } public static DistanceUnit parseUnit ( String distance , DistanceUnit defaultUnit ) { for ( DistanceUnit unit : values ( ) ) { for ( String name : unit . names ) { if ( distance . endsWith ( name ) ) { return unit ; } } } return defaultUnit ; } public static void writeDistanceUnit ( StreamOutput out , DistanceUnit unit ) throws IOException { out . writeByte ( ( byte ) unit . ordinal ( ) ) ; } public static DistanceUnit readDistanceUnit ( StreamInput in ) throws IOException { byte b = in . readByte ( ) ; if ( b < <int> | | b > = values ( ) . length ) { throw new IllegalArgumentException ( <str> + b + <str> ) ; } else { return values ( ) [ b ] ; } } public static class Distance implements Comparable < Distance > { public final double value ; public final DistanceUnit unit ; public Distance ( double value , DistanceUnit unit ) { super ( ) ; this . value = value ; this . unit = unit ; } public Distance convert ( DistanceUnit unit ) { if ( this . unit = = unit ) { return this ; } else { return new Distance ( DistanceUnit . convert ( value , this . unit , unit ) , unit ) ; } } @Override public boolean equals ( Object obj ) { if ( obj = = null ) { return false ; } else if ( obj instanceof Distance ) { Distance other = ( Distance ) obj ; return DistanceUnit . convert ( value , unit , other . unit ) = = other . value ; } else { return false ; } } @Override public int hashCode ( ) { return Double . valueOf ( value * unit . meters ) . hashCode ( ) ; } @Override public int compareTo ( Distance o ) { return Double . compare ( value , DistanceUnit . convert ( o . value , o . unit , unit ) ) ; } @Override public String toString ( ) { return unit . toString ( value ) ; } public static Distance parseDistance ( String distance ) { return parseDistance ( distance , DEFAULT ) ; } private static Distance parseDistance ( String distance , DistanceUnit defaultUnit ) { for ( DistanceUnit unit : values ( ) ) { for ( String name : unit . names ) { if ( distance . endsWith ( name ) ) { return new Distance ( Double . parseDouble ( distance . substring ( <int> , distance . length ( ) - name . length ( ) ) ) , unit ) ; } } } return new Distance ( Double . parseDouble ( distance ) , defaultUnit ) ; } } } 
