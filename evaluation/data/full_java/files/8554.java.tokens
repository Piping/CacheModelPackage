package org . elasticsearch . test . geo ; import com . carrotsearch . randomizedtesting . generators . RandomInts ; import com . spatial4j . core . context . jts . JtsSpatialContext ; import com . spatial4j . core . distance . DistanceUtils ; import com . spatial4j . core . exception . InvalidShapeException ; import com . spatial4j . core . shape . Point ; import com . spatial4j . core . shape . Rectangle ; import com . spatial4j . core . shape . impl . Range ; import com . vividsolutions . jts . algorithm . ConvexHull ; import com . vividsolutions . jts . geom . Coordinate ; import com . vividsolutions . jts . geom . Geometry ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . common . geo . builders . GeometryCollectionBuilder ; import org . elasticsearch . common . geo . builders . LineStringBuilder ; import org . elasticsearch . common . geo . builders . MultiLineStringBuilder ; import org . elasticsearch . common . geo . builders . MultiPointBuilder ; import org . elasticsearch . common . geo . builders . PointBuilder ; import org . elasticsearch . common . geo . builders . PointCollection ; import org . elasticsearch . common . geo . builders . PolygonBuilder ; import org . elasticsearch . common . geo . builders . ShapeBuilder ; import org . elasticsearch . search . geo . GeoShapeQueryTests ; import org . junit . Assert ; import java . util . Random ; import static com . spatial4j . core . shape . SpatialRelation . CONTAINS ; public class RandomShapeGenerator extends RandomGeoGenerator { protected static JtsSpatialContext ctx = ShapeBuilder . SPATIAL_CONTEXT ; protected static final double xDIVISIBLE = <int> ; protected static boolean ST_VALIDATE = true ; public static enum ShapeType { POINT , MULTIPOINT , LINESTRING , MULTILINESTRING , POLYGON ; private static final ShapeType [ ] types = values ( ) ; public static ShapeType randomType ( Random r ) { return types [ RandomInts . randomIntBetween ( r , <int> , types . length - <int> ) ] ; } } public static ShapeBuilder createShape ( Random r ) throws InvalidShapeException { return createShapeNear ( r , null ) ; } public static ShapeBuilder createShape ( Random r , ShapeType st ) { return createShapeNear ( r , null , st ) ; } public static ShapeBuilder createShapeNear ( Random r , Point nearPoint ) throws InvalidShapeException { return createShape ( r , nearPoint , null , null ) ; } public static ShapeBuilder createShapeNear ( Random r , Point nearPoint , ShapeType st ) throws InvalidShapeException { return createShape ( r , nearPoint , null , st ) ; } public static ShapeBuilder createShapeWithin ( Random r , Rectangle bbox ) throws InvalidShapeException { return createShape ( r , null , bbox , null ) ; } public static ShapeBuilder createShapeWithin ( Random r , Rectangle bbox , ShapeType st ) throws InvalidShapeException { return createShape ( r , null , bbox , st ) ; } public static GeometryCollectionBuilder createGeometryCollection ( Random r ) throws InvalidShapeException { return createGeometryCollection ( r , null , null , <int> ) ; } public static GeometryCollectionBuilder createGeometryCollectionNear ( Random r , Point nearPoint ) throws InvalidShapeException { return createGeometryCollection ( r , nearPoint , null , <int> ) ; } public static GeometryCollectionBuilder createGeometryCollectionNear ( Random r , Point nearPoint , int size ) throws InvalidShapeException { return createGeometryCollection ( r , nearPoint , null , size ) ; } public static GeometryCollectionBuilder createGeometryCollectionWithin ( Random r , Rectangle within ) throws InvalidShapeException { return createGeometryCollection ( r , null , within , <int> ) ; } public static GeometryCollectionBuilder createGeometryCollectionWithin ( Random r , Rectangle within , int size ) throws InvalidShapeException { return createGeometryCollection ( r , null , within , size ) ; } protected static GeometryCollectionBuilder createGeometryCollection ( Random r , Point nearPoint , Rectangle bounds , int numGeometries ) throws InvalidShapeException { if ( numGeometries < = <int> ) { numGeometries = RandomInts . randomIntBetween ( r , <int> , <int> ) ; } if ( nearPoint = = null ) { nearPoint = xRandomPoint ( r ) ; } if ( bounds = = null ) { bounds = xRandomRectangle ( r , nearPoint ) ; } GeometryCollectionBuilder gcb = new GeometryCollectionBuilder ( ) ; for ( int i = <int> ; i < numGeometries ; ) { ShapeBuilder builder = createShapeWithin ( r , bounds ) ; if ( builder ! = null ) { gcb . shape ( builder ) ; + + i ; } } return gcb ; } private static ShapeBuilder createShape ( Random r , Point nearPoint , Rectangle within , ShapeType st ) throws InvalidShapeException { ShapeBuilder shape ; short i = <int> ; do { shape = createShape ( r , nearPoint , within , st , ST_VALIDATE ) ; if ( shape ! = null ) { return shape ; } } while ( + + i ! = <int> ) ; throw new InvalidShapeException ( <str> ) ; } private static ShapeBuilder createShape ( Random r , Point nearPoint , Rectangle within , ShapeType st , boolean validate ) throws InvalidShapeException { if ( st = = null ) { st = ShapeType . randomType ( r ) ; } if ( within = = null ) { within = xRandomRectangle ( r , nearPoint ) ; } switch ( st ) { case POINT : Point p = xRandomPointIn ( r , within ) ; PointBuilder pb = new PointBuilder ( ) . coordinate ( new Coordinate ( p . getX ( ) , p . getY ( ) , Double . NaN ) ) ; return pb ; case MULTIPOINT : case LINESTRING : int numPoints = RandomInts . randomIntBetween ( r , <int> , <int> ) ; PointCollection pcb = ( st = = ShapeType . MULTIPOINT ) ? new MultiPointBuilder ( ) : new LineStringBuilder ( ) ; for ( int i = <int> ; i < numPoints ; + + i ) { p = xRandomPointIn ( r , within ) ; pcb . point ( p . getX ( ) , p . getY ( ) ) ; } return pcb ; case MULTILINESTRING : MultiLineStringBuilder mlsb = new MultiLineStringBuilder ( ) ; for ( int i = <int> ; i < RandomInts . randomIntBetween ( r , <int> , <int> ) ; + + i ) { mlsb . linestring ( ( LineStringBuilder ) createShape ( r , nearPoint , within , ShapeType . LINESTRING , false ) ) ; } return mlsb ; case POLYGON : numPoints = RandomInts . randomIntBetween ( r , <int> , <int> ) ; Coordinate [ ] coordinates = new Coordinate [ numPoints ] ; for ( int i = <int> ; i < numPoints ; + + i ) { p = ( Point ) createShape ( r , nearPoint , within , ShapeType . POINT , false ) . build ( ) ; coordinates [ i ] = new Coordinate ( p . getX ( ) , p . getY ( ) ) ; } Geometry shell = new ConvexHull ( coordinates , ctx . getGeometryFactory ( ) ) . getConvexHull ( ) ; Coordinate [ ] shellCoords = shell . getCoordinates ( ) ; if ( shellCoords . length < <int> ) { shellCoords = new Coordinate [ <int> ] ; shellCoords [ <int> ] = new Coordinate ( within . getMinX ( ) , within . getMinY ( ) ) ; shellCoords [ <int> ] = new Coordinate ( within . getMinX ( ) , within . getMaxY ( ) ) ; shellCoords [ <int> ] = new Coordinate ( within . getMaxX ( ) , within . getMaxY ( ) ) ; shellCoords [ <int> ] = new Coordinate ( within . getMaxX ( ) , within . getMinY ( ) ) ; } PolygonBuilder pgb = new PolygonBuilder ( ) . points ( shellCoords ) . close ( ) ; if ( validate ) { try { pgb . build ( ) ; } catch ( Throwable e ) { if ( e instanceof InvalidShapeException | | e instanceof AssertionError ) { return null ; } throw e ; } } return pgb ; default : throw new ElasticsearchException ( <str> + st + <str> ) ; } } public static Point xRandomPoint ( Random r ) { return xRandomPointIn ( r , ctx . getWorldBounds ( ) ) ; } protected static Point xRandomPointIn ( Random rand , Rectangle r ) { double [ ] pt = new double [ <int> ] ; randomPointIn ( rand , r . getMinX ( ) , r . getMinY ( ) , r . getMaxX ( ) , r . getMaxY ( ) , pt ) ; Point p = ctx . makePoint ( pt [ <int> ] , pt [ <int> ] ) ; Assert . assertEquals ( CONTAINS , r . relate ( p ) ) ; return p ; } public static Rectangle xRandomRectangle ( Random r , Point nearP ) { Rectangle bounds = ctx . getWorldBounds ( ) ; if ( nearP = = null ) nearP = xRandomPointIn ( r , bounds ) ; Range xRange = xRandomRange ( r , rarely ( r ) ? <int> : nearP . getX ( ) , Range . xRange ( bounds , ctx ) ) ; Range yRange = xRandomRange ( r , rarely ( r ) ? <int> : nearP . getY ( ) , Range . yRange ( bounds , ctx ) ) ; return xMakeNormRect ( xDivisible ( xRange . getMin ( ) * <int> e3 ) / <int> e3 , xDivisible ( xRange . getMax ( ) * <int> e3 ) / <int> e3 , xDivisible ( yRange . getMin ( ) * <int> e3 ) / <int> e3 , xDivisible ( yRange . getMax ( ) * <int> e3 ) / <int> e3 ) ; } private static boolean rarely ( Random r ) { return RandomInts . randomInt ( r , <int> ) > = <int> ; } private static Range xRandomRange ( Random r , double near , Range bounds ) { double mid = near + r . nextGaussian ( ) * bounds . getWidth ( ) / <int> ; double width = Math . abs ( r . nextGaussian ( ) ) * bounds . getWidth ( ) / <int> ; return new Range ( mid - width / <int> , mid + width / <int> ) ; } private static double xDivisible ( double v , double divisible ) { return ( int ) ( Math . round ( v / divisible ) * divisible ) ; } private static double xDivisible ( double v ) { return xDivisible ( v , xDIVISIBLE ) ; } protected static Rectangle xMakeNormRect ( double minX , double maxX , double minY , double maxY ) { minX = DistanceUtils . normLonDEG ( minX ) ; maxX = DistanceUtils . normLonDEG ( maxX ) ; if ( maxX < minX ) { double t = minX ; minX = maxX ; maxX = t ; } double minWorldY = ctx . getWorldBounds ( ) . getMinY ( ) ; double maxWorldY = ctx . getWorldBounds ( ) . getMaxY ( ) ; if ( minY < minWorldY | | minY > maxWorldY ) { minY = DistanceUtils . normLatDEG ( minY ) ; } if ( maxY < minWorldY | | maxY > maxWorldY ) { maxY = DistanceUtils . normLatDEG ( maxY ) ; } if ( maxY < minY ) { double t = minY ; minY = maxY ; maxY = t ; } return ctx . makeRectangle ( minX , maxX , minY , maxY ) ; } } 
