package org . apache . cassandra . db . view ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . TimeUnit ; import java . util . stream . Collectors ; import javax . annotation . Nullable ; import com . google . common . collect . Iterables ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . statements . ParsedStatement ; import org . apache . cassandra . cql3 . statements . SelectStatement ; import org . apache . cassandra . db . * ; import org . apache . cassandra . config . * ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . AbstractReadCommandBuilder . SinglePartitionSliceBuilder ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . partitions . AbstractBTreePartition ; import org . apache . cassandra . db . partitions . PartitionIterator ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . schema . KeyspaceMetadata ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . pager . QueryPager ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . utils . FBUtilities ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class View { private static final Logger logger = LoggerFactory . getLogger ( View . class ) ; private static class Columns { public final List < ColumnDefinition > partitionDefs ; public final List < ColumnDefinition > primaryKeyDefs ; public final List < ColumnDefinition > baseComplexColumns ; private Columns ( List < ColumnDefinition > partitionDefs , List < ColumnDefinition > primaryKeyDefs , List < ColumnDefinition > baseComplexColumns ) { this . partitionDefs = partitionDefs ; this . primaryKeyDefs = primaryKeyDefs ; this . baseComplexColumns = baseComplexColumns ; } } public final String name ; private volatile ViewDefinition definition ; private final ColumnFamilyStore baseCfs ; private Columns columns ; private final boolean viewPKIncludesOnlyBasePKColumns ; private final boolean includeAllColumns ; private ViewBuilder builder ; private final SelectStatement . RawStatement rawSelect ; private SelectStatement select ; private ReadQuery query ; public View ( ViewDefinition definition , ColumnFamilyStore baseCfs ) { this . baseCfs = baseCfs ; name = definition . viewName ; includeAllColumns = definition . includeAllColumns ; viewPKIncludesOnlyBasePKColumns = updateDefinition ( definition ) ; this . rawSelect = definition . select ; } public ViewDefinition getDefinition ( ) { return definition ; } private boolean resolveAndAddColumns ( Iterable < ColumnIdentifier > columns , List < ColumnDefinition > . . . definitions ) { boolean allArePrimaryKeys = true ; for ( ColumnIdentifier identifier : columns ) { ColumnDefinition cdef = baseCfs . metadata . getColumnDefinition ( identifier ) ; assert cdef ! = null : <str> + identifier . toString ( ) ; for ( List < ColumnDefinition > list : definitions ) { list . add ( cdef ) ; } allArePrimaryKeys = allArePrimaryKeys & & cdef . isPrimaryKeyColumn ( ) ; } return allArePrimaryKeys ; } public boolean updateDefinition ( ViewDefinition definition ) { this . definition = definition ; CFMetaData viewCfm = definition . metadata ; List < ColumnDefinition > partitionDefs = new ArrayList < > ( viewCfm . partitionKeyColumns ( ) . size ( ) ) ; List < ColumnDefinition > primaryKeyDefs = new ArrayList < > ( viewCfm . partitionKeyColumns ( ) . size ( ) + viewCfm . clusteringColumns ( ) . size ( ) ) ; List < ColumnDefinition > baseComplexColumns = new ArrayList < > ( ) ; boolean partitionAllPrimaryKeyColumns = resolveAndAddColumns ( Iterables . transform ( viewCfm . partitionKeyColumns ( ) , cd - > cd . name ) , primaryKeyDefs , partitionDefs ) ; boolean clusteringAllPrimaryKeyColumns = resolveAndAddColumns ( Iterables . transform ( viewCfm . clusteringColumns ( ) , cd - > cd . name ) , primaryKeyDefs ) ; for ( ColumnDefinition cdef : baseCfs . metadata . allColumns ( ) ) { if ( cdef . isComplex ( ) ) { baseComplexColumns . add ( cdef ) ; } } this . columns = new Columns ( partitionDefs , primaryKeyDefs , baseComplexColumns ) ; return partitionAllPrimaryKeyColumns & & clusteringAllPrimaryKeyColumns ; } public boolean updateAffectsView ( AbstractBTreePartition partition ) { ReadQuery selectQuery = getReadQuery ( ) ; if ( ! partition . metadata ( ) . cfId . equals ( definition . baseTableId ) ) return false ; if ( ! selectQuery . selectsKey ( partition . partitionKey ( ) ) ) return false ; if ( ! partition . deletionInfo ( ) . isLive ( ) ) return true ; for ( Row row : partition ) { if ( ! selectQuery . selectsClustering ( partition . partitionKey ( ) , row . clustering ( ) ) ) continue ; if ( includeAllColumns | | ! row . deletion ( ) . isLive ( ) ) return true ; if ( row . primaryKeyLivenessInfo ( ) . isLive ( FBUtilities . nowInSeconds ( ) ) ) return true ; for ( ColumnData data : row ) { if ( definition . metadata . getColumnDefinition ( data . column ( ) . name ) ! = null ) return true ; } } return false ; } private Clustering viewClustering ( TemporalRow temporalRow , TemporalRow . Resolver resolver ) { CFMetaData viewCfm = definition . metadata ; int numViewClustering = viewCfm . clusteringColumns ( ) . size ( ) ; CBuilder clustering = CBuilder . create ( viewCfm . comparator ) ; for ( int i = <int> ; i < numViewClustering ; i + + ) { ColumnDefinition definition = viewCfm . clusteringColumns ( ) . get ( i ) ; clustering . add ( temporalRow . clusteringValue ( definition , resolver ) ) ; } return clustering . build ( ) ; } private PartitionUpdate createTombstone ( TemporalRow temporalRow , DecoratedKey partitionKey , Row . Deletion deletion , TemporalRow . Resolver resolver , int nowInSec ) { CFMetaData viewCfm = definition . metadata ; Row . Builder builder = BTreeRow . unsortedBuilder ( nowInSec ) ; builder . newRow ( viewClustering ( temporalRow , resolver ) ) ; builder . addRowDeletion ( deletion ) ; return PartitionUpdate . singleRowUpdate ( viewCfm , partitionKey , builder . build ( ) ) ; } private PartitionUpdate createComplexTombstone ( TemporalRow temporalRow , DecoratedKey partitionKey , ColumnDefinition deletedColumn , DeletionTime deletionTime , TemporalRow . Resolver resolver , int nowInSec ) { CFMetaData viewCfm = definition . metadata ; Row . Builder builder = BTreeRow . unsortedBuilder ( nowInSec ) ; builder . newRow ( viewClustering ( temporalRow , resolver ) ) ; builder . addComplexDeletion ( deletedColumn , deletionTime ) ; return PartitionUpdate . singleRowUpdate ( viewCfm , partitionKey , builder . build ( ) ) ; } private DecoratedKey viewPartitionKey ( TemporalRow temporalRow , TemporalRow . Resolver resolver ) { List < ColumnDefinition > partitionDefs = this . columns . partitionDefs ; Object [ ] partitionKey = new Object [ partitionDefs . size ( ) ] ; for ( int i = <int> ; i < partitionKey . length ; i + + ) { ByteBuffer value = temporalRow . clusteringValue ( partitionDefs . get ( i ) , resolver ) ; if ( value = = null ) return null ; partitionKey [ i ] = value ; } CFMetaData metadata = definition . metadata ; return metadata . decorateKey ( CFMetaData . serializePartitionKey ( metadata . getKeyValidatorAsClusteringComparator ( ) . make ( partitionKey ) ) ) ; } private PartitionUpdate createRangeTombstoneForRow ( TemporalRow temporalRow ) { if ( viewPKIncludesOnlyBasePKColumns ) return null ; boolean hasUpdate = false ; List < ColumnDefinition > primaryKeyDefs = this . columns . primaryKeyDefs ; for ( ColumnDefinition viewPartitionKeys : primaryKeyDefs ) { if ( ! viewPartitionKeys . isPrimaryKeyColumn ( ) & & temporalRow . clusteringValue ( viewPartitionKeys , TemporalRow . oldValueIfUpdated ) ! = null ) hasUpdate = true ; } if ( ! hasUpdate ) return null ; TemporalRow . Resolver resolver = TemporalRow . earliest ; return createTombstone ( temporalRow , viewPartitionKey ( temporalRow , resolver ) , Row . Deletion . shadowable ( new DeletionTime ( temporalRow . viewClusteringTimestamp ( ) , temporalRow . nowInSec ) ) , resolver , temporalRow . nowInSec ) ; } private PartitionUpdate createUpdatesForInserts ( TemporalRow temporalRow ) { TemporalRow . Resolver resolver = TemporalRow . latest ; DecoratedKey partitionKey = viewPartitionKey ( temporalRow , resolver ) ; CFMetaData viewCfm = definition . metadata ; if ( partitionKey = = null ) { return null ; } Row . Builder regularBuilder = BTreeRow . unsortedBuilder ( temporalRow . nowInSec ) ; CBuilder clustering = CBuilder . create ( viewCfm . comparator ) ; for ( int i = <int> ; i < viewCfm . clusteringColumns ( ) . size ( ) ; i + + ) { ColumnDefinition column = viewCfm . clusteringColumns ( ) . get ( i ) ; ByteBuffer value = temporalRow . clusteringValue ( column , resolver ) ; if ( value = = null ) return null ; clustering . add ( value ) ; } regularBuilder . newRow ( clustering . build ( ) ) ; regularBuilder . addPrimaryKeyLivenessInfo ( LivenessInfo . create ( viewCfm , temporalRow . viewClusteringTimestamp ( ) , temporalRow . viewClusteringTtl ( ) , temporalRow . viewClusteringLocalDeletionTime ( ) ) ) ; for ( ColumnDefinition columnDefinition : viewCfm . allColumns ( ) ) { if ( columnDefinition . isPrimaryKeyColumn ( ) ) continue ; for ( Cell cell : temporalRow . values ( columnDefinition , resolver ) ) { regularBuilder . addCell ( cell ) ; } } Row row = regularBuilder . build ( ) ; if ( row . isEmpty ( ) ) return null ; return PartitionUpdate . singleRowUpdate ( viewCfm , partitionKey , row ) ; } private Collection < Mutation > createForDeletionInfo ( TemporalRow . Set rowSet , AbstractBTreePartition partition ) { final TemporalRow . Resolver resolver = TemporalRow . earliest ; DeletionInfo deletionInfo = partition . deletionInfo ( ) ; List < Mutation > mutations = new ArrayList < > ( ) ; if ( ! columns . baseComplexColumns . isEmpty ( ) ) { for ( Row row : partition ) { if ( ! row . hasComplexDeletion ( ) ) continue ; TemporalRow temporalRow = rowSet . getClustering ( row . clustering ( ) ) ; assert temporalRow ! = null ; for ( ColumnDefinition definition : columns . baseComplexColumns ) { ComplexColumnData columnData = row . getComplexColumnData ( definition ) ; if ( columnData ! = null ) { DeletionTime time = columnData . complexDeletion ( ) ; if ( ! time . isLive ( ) ) { DecoratedKey targetKey = viewPartitionKey ( temporalRow , resolver ) ; if ( targetKey ! = null ) mutations . add ( new Mutation ( createComplexTombstone ( temporalRow , targetKey , definition , time , resolver , temporalRow . nowInSec ) ) ) ; } } } } } ReadCommand command = null ; if ( ! deletionInfo . isLive ( ) ) { DecoratedKey dk = rowSet . dk ; if ( ! deletionInfo . getPartitionDeletion ( ) . isLive ( ) ) { command = getSelectStatement ( ) . internalReadForView ( dk , rowSet . nowInSec ) ; } else { SinglePartitionSliceBuilder builder = new SinglePartitionSliceBuilder ( baseCfs , dk ) ; Iterator < RangeTombstone > tombstones = deletionInfo . rangeIterator ( false ) ; while ( tombstones . hasNext ( ) ) { RangeTombstone tombstone = tombstones . next ( ) ; builder . addSlice ( tombstone . deletedSlice ( ) ) ; } command = builder . build ( ) ; } } if ( command = = null ) { ReadQuery selectQuery = getReadQuery ( ) ; SinglePartitionSliceBuilder builder = null ; for ( Row row : partition ) { if ( ! row . deletion ( ) . isLive ( ) ) { if ( ! selectQuery . selectsClustering ( rowSet . dk , row . clustering ( ) ) ) continue ; if ( builder = = null ) builder = new SinglePartitionSliceBuilder ( baseCfs , rowSet . dk ) ; builder . addSlice ( Slice . make ( row . clustering ( ) ) ) ; } } if ( builder ! = null ) command = builder . build ( ) ; } if ( command ! = null ) { ReadQuery selectQuery = getReadQuery ( ) ; assert selectQuery . selectsKey ( rowSet . dk ) ; if ( ! rowSet . hasTombstonedExisting ( ) ) { QueryPager pager = command . getPager ( null , Server . CURRENT_VERSION ) ; while ( ! pager . isExhausted ( ) ) { try ( ReadExecutionController executionController = pager . executionController ( ) ; PartitionIterator iter = pager . fetchPageInternal ( <int> , executionController ) ) { if ( ! iter . hasNext ( ) ) break ; try ( RowIterator rowIterator = iter . next ( ) ) { while ( rowIterator . hasNext ( ) ) { Row row = rowIterator . next ( ) ; if ( selectQuery . selectsClustering ( rowSet . dk , row . clustering ( ) ) ) rowSet . addRow ( row , false ) ; } } } } rowSet . setTombstonedExisting ( ) ; } for ( TemporalRow temporalRow : rowSet ) { DeletionTime deletionTime = temporalRow . deletionTime ( partition ) ; if ( ! deletionTime . isLive ( ) ) { DecoratedKey value = viewPartitionKey ( temporalRow , resolver ) ; if ( value ! = null ) { PartitionUpdate update = createTombstone ( temporalRow , value , Row . Deletion . regular ( deletionTime ) , resolver , temporalRow . nowInSec ) ; if ( update ! = null ) mutations . add ( new Mutation ( update ) ) ; } } } } return ! mutations . isEmpty ( ) ? mutations : null ; } private void readLocalRows ( TemporalRow . Set rowSet ) { long start = System . currentTimeMillis ( ) ; SinglePartitionSliceBuilder builder = new SinglePartitionSliceBuilder ( baseCfs , rowSet . dk ) ; for ( TemporalRow temporalRow : rowSet ) builder . addSlice ( temporalRow . baseSlice ( ) ) ; QueryPager pager = builder . build ( ) . getPager ( null , Server . CURRENT_VERSION ) ; while ( ! pager . isExhausted ( ) ) { try ( ReadExecutionController executionController = pager . executionController ( ) ; PartitionIterator iter = pager . fetchPageInternal ( <int> , executionController ) ) { while ( iter . hasNext ( ) ) { try ( RowIterator rows = iter . next ( ) ) { while ( rows . hasNext ( ) ) { rowSet . addRow ( rows . next ( ) , false ) ; } } } } } baseCfs . metric . viewReadTime . update ( System . currentTimeMillis ( ) - start , TimeUnit . MILLISECONDS ) ; } private TemporalRow . Set separateRows ( AbstractBTreePartition partition , Set < ColumnIdentifier > viewPrimaryKeyCols ) { TemporalRow . Set rowSet = new TemporalRow . Set ( baseCfs , viewPrimaryKeyCols , partition . partitionKey ( ) . getKey ( ) ) ; for ( Row row : partition ) rowSet . addRow ( row , true ) ; return rowSet ; } public TemporalRow . Set getTemporalRowSet ( AbstractBTreePartition partition , TemporalRow . Set existing , boolean isBuilding ) { if ( ! updateAffectsView ( partition ) ) return existing ; Set < ColumnIdentifier > columns = new HashSet < > ( this . columns . primaryKeyDefs . size ( ) ) ; for ( ColumnDefinition def : this . columns . primaryKeyDefs ) columns . add ( def . name ) ; TemporalRow . Set rowSet ; if ( existing = = null ) { rowSet = separateRows ( partition , columns ) ; if ( ! isBuilding ) readLocalRows ( rowSet ) ; } else { rowSet = existing . withNewViewPrimaryKey ( columns ) ; } return rowSet ; } public SelectStatement getSelectStatement ( ) { if ( select = = null ) { ClientState state = ClientState . forInternalCalls ( ) ; state . setKeyspace ( baseCfs . keyspace . getName ( ) ) ; rawSelect . prepareKeyspace ( state ) ; ParsedStatement . Prepared prepared = rawSelect . prepare ( true ) ; select = ( SelectStatement ) prepared . statement ; } return select ; } public ReadQuery getReadQuery ( ) { if ( query = = null ) query = getSelectStatement ( ) . getQuery ( QueryOptions . forInternalCalls ( Collections . emptyList ( ) ) , FBUtilities . nowInSeconds ( ) ) ; return query ; } public Collection < Mutation > createMutations ( AbstractBTreePartition partition , TemporalRow . Set rowSet , boolean isBuilding ) { if ( ! updateAffectsView ( partition ) ) return null ; ReadQuery selectQuery = getReadQuery ( ) ; Collection < Mutation > mutations = null ; for ( TemporalRow temporalRow : rowSet ) { if ( partition . rowCount ( ) ! = <int> & & ! selectQuery . selectsClustering ( partition . partitionKey ( ) , temporalRow . baseClustering ( ) ) ) continue ; if ( ! isBuilding ) { PartitionUpdate partitionTombstone = createRangeTombstoneForRow ( temporalRow ) ; if ( partitionTombstone ! = null ) { if ( mutations = = null ) mutations = new LinkedList < > ( ) ; mutations . add ( new Mutation ( partitionTombstone ) ) ; } } PartitionUpdate insert = createUpdatesForInserts ( temporalRow ) ; if ( insert ! = null ) { if ( mutations = = null ) mutations = new LinkedList < > ( ) ; mutations . add ( new Mutation ( insert ) ) ; } } if ( ! isBuilding ) { Collection < Mutation > deletion = createForDeletionInfo ( rowSet , partition ) ; if ( deletion ! = null & & ! deletion . isEmpty ( ) ) { if ( mutations = = null ) mutations = new LinkedList < > ( ) ; mutations . addAll ( deletion ) ; } } return mutations ; } public synchronized void build ( ) { if ( this . builder ! = null ) { this . builder . stop ( ) ; this . builder = null ; } this . builder = new ViewBuilder ( baseCfs , this ) ; CompactionManager . instance . submitViewBuilder ( builder ) ; } @Nullable public static CFMetaData findBaseTable ( String keyspace , String viewName ) { ViewDefinition view = Schema . instance . getView ( keyspace , viewName ) ; return ( view = = null ) ? null : Schema . instance . getCFMetaData ( view . baseTableId ) ; } public static Iterable < ViewDefinition > findAll ( String keyspace , String baseTable ) { KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( keyspace ) ; final UUID baseId = Schema . instance . getId ( keyspace , baseTable ) ; return Iterables . filter ( ksm . views , view - > view . baseTableId . equals ( baseId ) ) ; } public static String buildSelectStatement ( String cfName , Collection < ColumnDefinition > includedColumns , String whereClause ) { StringBuilder rawSelect = new StringBuilder ( <str> ) ; if ( includedColumns = = null | | includedColumns . isEmpty ( ) ) rawSelect . append ( <str> ) ; else rawSelect . append ( includedColumns . stream ( ) . map ( id - > id . name . toCQLString ( ) ) . collect ( Collectors . joining ( <str> ) ) ) ; rawSelect . append ( <str> ) . append ( cfName ) . append ( <str> ) . append ( whereClause ) . append ( <str> ) ; return rawSelect . toString ( ) ; } public static String relationsToWhereClause ( List < Relation > whereClause ) { List < String > expressions = new ArrayList < > ( whereClause . size ( ) ) ; for ( Relation rel : whereClause ) { StringBuilder sb = new StringBuilder ( ) ; if ( rel . isMultiColumn ( ) ) { sb . append ( ( ( MultiColumnRelation ) rel ) . getEntities ( ) . stream ( ) . map ( ColumnIdentifier . Raw : : toCQLString ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ) ; } else { sb . append ( ( ( SingleColumnRelation ) rel ) . getEntity ( ) . toCQLString ( ) ) ; } sb . append ( <str> ) . append ( rel . operator ( ) ) . append ( <str> ) ; if ( rel . isIN ( ) ) { sb . append ( rel . getInValues ( ) . stream ( ) . map ( Term . Raw : : getText ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ) ; } else { sb . append ( rel . getValue ( ) . getText ( ) ) ; } expressions . add ( sb . toString ( ) ) ; } return expressions . stream ( ) . collect ( Collectors . joining ( <str> ) ) ; } } 
