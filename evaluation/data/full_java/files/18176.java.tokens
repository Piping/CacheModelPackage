package com . badlogic . gdx . math ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class Bezier < T extends Vector < T > > implements Path < T > { public static < T extends Vector < T > > T linear ( final T out , final float t , final T p0 , final T p1 , final T tmp ) { return out . set ( p0 ) . scl ( <float> - t ) . add ( tmp . set ( p1 ) . scl ( t ) ) ; } public static < T extends Vector < T > > T linear_derivative ( final T out , final float t , final T p0 , final T p1 , final T tmp ) { return out . set ( p1 ) . sub ( p0 ) ; } public static < T extends Vector < T > > T quadratic ( final T out , final float t , final T p0 , final T p1 , final T p2 , final T tmp ) { final float dt = <float> - t ; return out . set ( p0 ) . scl ( dt * dt ) . add ( tmp . set ( p1 ) . scl ( <int> * dt * t ) ) . add ( tmp . set ( p2 ) . scl ( t * t ) ) ; } public static < T extends Vector < T > > T quadratic_derivative ( final T out , final float t , final T p0 , final T p1 , final T p2 , final T tmp ) { final float dt = <float> - t ; return out . set ( p1 ) . sub ( p0 ) . scl ( <int> ) . scl ( <int> - t ) . add ( tmp . set ( p2 ) . sub ( p1 ) . scl ( t ) . scl ( <int> ) ) ; } public static < T extends Vector < T > > T cubic ( final T out , final float t , final T p0 , final T p1 , final T p2 , final T p3 , final T tmp ) { final float dt = <float> - t ; final float dt2 = dt * dt ; final float t2 = t * t ; return out . set ( p0 ) . scl ( dt2 * dt ) . add ( tmp . set ( p1 ) . scl ( <int> * dt2 * t ) ) . add ( tmp . set ( p2 ) . scl ( <int> * dt * t2 ) ) . add ( tmp . set ( p3 ) . scl ( t2 * t ) ) ; } public static < T extends Vector < T > > T cubic_derivative ( final T out , final float t , final T p0 , final T p1 , final T p2 , final T p3 , final T tmp ) { final float dt = <float> - t ; final float dt2 = dt * dt ; final float t2 = t * t ; return out . set ( p1 ) . sub ( p0 ) . scl ( dt2 * <int> ) . add ( tmp . set ( p2 ) . sub ( p1 ) . scl ( dt * t * <int> ) ) . add ( tmp . set ( p3 ) . sub ( p2 ) . scl ( t2 * <int> ) ) ; } public Array < T > points = new Array < T > ( ) ; private T tmp ; private T tmp2 ; private T tmp3 ; public Bezier ( ) { } public Bezier ( final T . . . points ) { set ( points ) ; } public Bezier ( final T [ ] points , final int offset , final int length ) { set ( points , offset , length ) ; } public Bezier ( final Array < T > points , final int offset , final int length ) { set ( points , offset , length ) ; } public Bezier set ( final T . . . points ) { return set ( points , <int> , points . length ) ; } public Bezier set ( final T [ ] points , final int offset , final int length ) { if ( length < <int> | | length > <int> ) throw new GdxRuntimeException ( <str> ) ; if ( tmp = = null ) tmp = points [ <int> ] . cpy ( ) ; if ( tmp2 = = null ) tmp2 = points [ <int> ] . cpy ( ) ; if ( tmp3 = = null ) tmp3 = points [ <int> ] . cpy ( ) ; this . points . clear ( ) ; this . points . addAll ( points , offset , length ) ; return this ; } public Bezier set ( final Array < T > points , final int offset , final int length ) { if ( length < <int> | | length > <int> ) throw new GdxRuntimeException ( <str> ) ; if ( tmp = = null ) tmp = points . get ( <int> ) . cpy ( ) ; this . points . clear ( ) ; this . points . addAll ( points , offset , length ) ; return this ; } @Override public T valueAt ( final T out , final float t ) { final int n = points . size ; if ( n = = <int> ) linear ( out , t , points . get ( <int> ) , points . get ( <int> ) , tmp ) ; else if ( n = = <int> ) quadratic ( out , t , points . get ( <int> ) , points . get ( <int> ) , points . get ( <int> ) , tmp ) ; else if ( n = = <int> ) cubic ( out , t , points . get ( <int> ) , points . get ( <int> ) , points . get ( <int> ) , points . get ( <int> ) , tmp ) ; return out ; } @Override public T derivativeAt ( final T out , final float t ) { final int n = points . size ; if ( n = = <int> ) linear_derivative ( out , t , points . get ( <int> ) , points . get ( <int> ) , tmp ) ; else if ( n = = <int> ) quadratic_derivative ( out , t , points . get ( <int> ) , points . get ( <int> ) , points . get ( <int> ) , tmp ) ; else if ( n = = <int> ) cubic_derivative ( out , t , points . get ( <int> ) , points . get ( <int> ) , points . get ( <int> ) , points . get ( <int> ) , tmp ) ; return out ; } @Override public float approximate ( final T v ) { T p1 = points . get ( <int> ) ; T p2 = points . get ( points . size - <int> ) ; T p3 = v ; float l1Sqr = p1 . dst2 ( p2 ) ; float l2Sqr = p3 . dst2 ( p2 ) ; float l3Sqr = p3 . dst2 ( p1 ) ; float l1 = ( float ) Math . sqrt ( l1Sqr ) ; float s = ( l2Sqr + l1Sqr - l3Sqr ) / ( <int> * l1 ) ; return MathUtils . clamp ( ( l1 - s ) / l1 , <float> , <float> ) ; } @Override public float locate ( T v ) { return approximate ( v ) ; } @Override public float approxLength ( int samples ) { float tempLength = <int> ; for ( int i = <int> ; i < samples ; + + i ) { tmp2 . set ( tmp3 ) ; valueAt ( tmp3 , ( i ) / ( ( float ) samples - <int> ) ) ; if ( i > <int> ) tempLength + = tmp2 . dst ( tmp3 ) ; } return tempLength ; } } 
