package org . elasticsearch . rest . action . admin . indices . mapping . get ; import com . carrotsearch . hppc . cursors . ObjectObjectCursor ; import org . elasticsearch . action . admin . indices . mapping . get . GetMappingsRequest ; import org . elasticsearch . action . admin . indices . mapping . get . GetMappingsResponse ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentBuilderString ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . indices . TypeMissingException ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestBuilderListener ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestStatus . OK ; public class RestGetMappingAction extends BaseRestHandler { @Inject public RestGetMappingAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final String [ ] indices = Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ; final String [ ] types = request . paramAsStringArrayOrEmptyIfAll ( <str> ) ; GetMappingsRequest getMappingsRequest = new GetMappingsRequest ( ) ; getMappingsRequest . indices ( indices ) . types ( types ) ; getMappingsRequest . indicesOptions ( IndicesOptions . fromRequest ( request , getMappingsRequest . indicesOptions ( ) ) ) ; getMappingsRequest . local ( request . paramAsBoolean ( <str> , getMappingsRequest . local ( ) ) ) ; client . admin ( ) . indices ( ) . getMappings ( getMappingsRequest , new RestBuilderListener < GetMappingsResponse > ( channel ) { @Override public RestResponse buildResponse ( GetMappingsResponse response , XContentBuilder builder ) throws Exception { builder . startObject ( ) ; ImmutableOpenMap < String , ImmutableOpenMap < String , MappingMetaData > > mappingsByIndex = response . getMappings ( ) ; if ( mappingsByIndex . isEmpty ( ) ) { if ( indices . length ! = <int> & & types . length ! = <int> ) { return new BytesRestResponse ( OK , builder . endObject ( ) ) ; } else if ( indices . length ! = <int> ) { return new BytesRestResponse ( channel , new IndexNotFoundException ( indices [ <int> ] ) ) ; } else if ( types . length ! = <int> ) { return new BytesRestResponse ( channel , new TypeMissingException ( new Index ( <str> ) , types [ <int> ] ) ) ; } else { return new BytesRestResponse ( OK , builder . endObject ( ) ) ; } } for ( ObjectObjectCursor < String , ImmutableOpenMap < String , MappingMetaData > > indexEntry : mappingsByIndex ) { if ( indexEntry . value . isEmpty ( ) ) { continue ; } builder . startObject ( indexEntry . key , XContentBuilder . FieldCaseConversion . NONE ) ; builder . startObject ( Fields . MAPPINGS ) ; for ( ObjectObjectCursor < String , MappingMetaData > typeEntry : indexEntry . value ) { builder . field ( typeEntry . key ) ; builder . map ( typeEntry . value . sourceAsMap ( ) ) ; } builder . endObject ( ) ; builder . endObject ( ) ; } builder . endObject ( ) ; return new BytesRestResponse ( OK , builder ) ; } } ) ; } static class Fields { static final XContentBuilderString MAPPINGS = new XContentBuilderString ( <str> ) ; } } 
