package org . apache . cassandra . utils . memory ; import java . lang . ref . PhantomReference ; import java . lang . ref . ReferenceQueue ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicLongFieldUpdater ; import org . apache . cassandra . concurrent . NamedThreadFactory ; import org . apache . cassandra . io . compress . BufferType ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . NoSpamLogger ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . metrics . BufferPoolMetrics ; import org . apache . cassandra . utils . concurrent . Ref ; public class BufferPool { static final int CHUNK_SIZE = <int> < < <int> ; @VisibleForTesting public static long MEMORY_USAGE_THRESHOLD = DatabaseDescriptor . getFileCacheSizeInMB ( ) * <int> * <int> ; @VisibleForTesting public static boolean ALLOCATE_ON_HEAP_WHEN_EXAHUSTED = DatabaseDescriptor . getBufferPoolUseHeapIfExhausted ( ) ; @VisibleForTesting public static boolean DISABLED = Boolean . parseBoolean ( System . getProperty ( <str> , <str> ) ) ; @VisibleForTesting public static boolean DEBUG = false ; private static final Logger logger = LoggerFactory . getLogger ( BufferPool . class ) ; private static final NoSpamLogger noSpamLogger = NoSpamLogger . getLogger ( logger , <int> , TimeUnit . MINUTES ) ; private static final ByteBuffer EMPTY_BUFFER = ByteBuffer . allocateDirect ( <int> ) ; private static final GlobalPool globalPool = new GlobalPool ( ) ; private static final ThreadLocal < LocalPool > localPool = new ThreadLocal < LocalPool > ( ) { @Override protected LocalPool initialValue ( ) { return new LocalPool ( ) ; } } ; public static ByteBuffer get ( int size ) { if ( DISABLED ) return allocate ( size , ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ) ; else return takeFromPool ( size , ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ) ; } public static ByteBuffer get ( int size , BufferType bufferType ) { boolean direct = bufferType = = BufferType . OFF_HEAP ; if ( DISABLED | | ! direct ) return allocate ( size , ! direct ) ; else return takeFromPool ( size , ! direct ) ; } public static ByteBuffer tryGet ( int size ) { if ( DISABLED ) return allocate ( size , ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ) ; else return maybeTakeFromPool ( size , ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ) ; } private static ByteBuffer allocate ( int size , boolean onHeap ) { return onHeap ? ByteBuffer . allocate ( size ) : ByteBuffer . allocateDirect ( size ) ; } private static ByteBuffer takeFromPool ( int size , boolean allocateOnHeapWhenExhausted ) { ByteBuffer ret = maybeTakeFromPool ( size , allocateOnHeapWhenExhausted ) ; if ( ret ! = null ) return ret ; if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , size ) ; return localPool . get ( ) . allocate ( size , allocateOnHeapWhenExhausted ) ; } private static ByteBuffer maybeTakeFromPool ( int size , boolean allocateOnHeapWhenExhausted ) { if ( size < <int> ) throw new IllegalArgumentException ( <str> + size + <str> ) ; if ( size = = <int> ) return EMPTY_BUFFER ; if ( size > CHUNK_SIZE ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( <str> , size , CHUNK_SIZE ) ; return localPool . get ( ) . allocate ( size , allocateOnHeapWhenExhausted ) ; } return localPool . get ( ) . get ( size ) ; } public static void put ( ByteBuffer buffer ) { if ( ! ( DISABLED | | buffer . hasArray ( ) ) ) localPool . get ( ) . put ( buffer ) ; } @VisibleForTesting static void reset ( ) { localPool . get ( ) . reset ( ) ; globalPool . reset ( ) ; } @VisibleForTesting static Chunk currentChunk ( ) { return localPool . get ( ) . chunks [ <int> ] ; } @VisibleForTesting static int numChunks ( ) { int ret = <int> ; for ( Chunk chunk : localPool . get ( ) . chunks ) { if ( chunk ! = null ) ret + + ; } return ret ; } @VisibleForTesting static void assertAllRecycled ( ) { globalPool . debug . check ( ) ; } public static long sizeInBytes ( ) { return globalPool . sizeInBytes ( ) ; } static final class Debug { long recycleRound = <int> ; final Queue < Chunk > allChunks = new ConcurrentLinkedQueue < > ( ) ; void register ( Chunk chunk ) { allChunks . add ( chunk ) ; } void recycle ( Chunk chunk ) { chunk . lastRecycled = recycleRound ; } void check ( ) { for ( Chunk chunk : allChunks ) assert chunk . lastRecycled = = recycleRound ; recycleRound + + ; } } static final class GlobalPool { static final int MACRO_CHUNK_SIZE = <int> < < <int> ; static { assert Integer . bitCount ( CHUNK_SIZE ) = = <int> ; assert Integer . bitCount ( MACRO_CHUNK_SIZE ) = = <int> ; assert MACRO_CHUNK_SIZE % CHUNK_SIZE = = <int> ; if ( DISABLED ) logger . info ( <str> , ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ? <str> : <str> ) ; else logger . info ( <str> , MEMORY_USAGE_THRESHOLD / ( <int> * <int> ) , ALLOCATE_ON_HEAP_WHEN_EXAHUSTED ? <str> : <str> ) ; } private final Debug debug = new Debug ( ) ; private final Queue < Chunk > macroChunks = new ConcurrentLinkedQueue < > ( ) ; private final Queue < Chunk > chunks = new ConcurrentLinkedQueue < > ( ) ; private final AtomicLong memoryUsage = new AtomicLong ( ) ; public Chunk get ( ) { while ( true ) { Chunk chunk = chunks . poll ( ) ; if ( chunk ! = null ) return chunk ; if ( ! allocateMoreChunks ( ) ) return chunks . poll ( ) ; } } private boolean allocateMoreChunks ( ) { while ( true ) { long cur = memoryUsage . get ( ) ; if ( cur + MACRO_CHUNK_SIZE > MEMORY_USAGE_THRESHOLD ) { noSpamLogger . info ( <str> , MEMORY_USAGE_THRESHOLD , MACRO_CHUNK_SIZE ) ; return false ; } if ( memoryUsage . compareAndSet ( cur , cur + MACRO_CHUNK_SIZE ) ) break ; } Chunk chunk = new Chunk ( allocateDirectAligned ( MACRO_CHUNK_SIZE ) ) ; chunk . acquire ( null ) ; macroChunks . add ( chunk ) ; for ( int i = <int> ; i < MACRO_CHUNK_SIZE ; i + = CHUNK_SIZE ) { Chunk add = new Chunk ( chunk . get ( CHUNK_SIZE ) ) ; chunks . add ( add ) ; if ( DEBUG ) debug . register ( add ) ; } return true ; } public void recycle ( Chunk chunk ) { chunks . add ( chunk ) ; } public long sizeInBytes ( ) { return memoryUsage . get ( ) ; } @VisibleForTesting void reset ( ) { while ( ! chunks . isEmpty ( ) ) chunks . poll ( ) . reset ( ) ; while ( ! macroChunks . isEmpty ( ) ) macroChunks . poll ( ) . reset ( ) ; memoryUsage . set ( <int> ) ; } } static final class LocalPool { private final static BufferPoolMetrics metrics = new BufferPoolMetrics ( ) ; private final Chunk [ ] chunks = new Chunk [ <int> ] ; private byte chunkCount = <int> ; public LocalPool ( ) { localPoolReferences . add ( new LocalPoolRef ( this , localPoolRefQueue ) ) ; } private Chunk addChunkFromGlobalPool ( ) { Chunk chunk = globalPool . get ( ) ; if ( chunk = = null ) return null ; addChunk ( chunk ) ; return chunk ; } private void addChunk ( Chunk chunk ) { chunk . acquire ( this ) ; if ( chunkCount < <int> ) { chunks [ chunkCount + + ] = chunk ; return ; } int smallestChunkIdx = <int> ; if ( chunks [ <int> ] . free ( ) < chunks [ <int> ] . free ( ) ) smallestChunkIdx = <int> ; if ( chunks [ <int> ] . free ( ) < chunks [ smallestChunkIdx ] . free ( ) ) smallestChunkIdx = <int> ; chunks [ smallestChunkIdx ] . release ( ) ; if ( smallestChunkIdx ! = <int> ) chunks [ smallestChunkIdx ] = chunks [ <int> ] ; chunks [ <int> ] = chunk ; } public ByteBuffer get ( int size ) { for ( Chunk chunk : chunks ) { if ( chunk = = null ) break ; ByteBuffer buffer = chunk . get ( size ) ; if ( buffer ! = null ) return buffer ; } Chunk chunk = addChunkFromGlobalPool ( ) ; if ( chunk ! = null ) return chunk . get ( size ) ; return null ; } private ByteBuffer allocate ( int size , boolean onHeap ) { metrics . misses . mark ( ) ; return BufferPool . allocate ( size , onHeap ) ; } public void put ( ByteBuffer buffer ) { Chunk chunk = Chunk . getParentChunk ( buffer ) ; if ( chunk = = null ) { FileUtils . clean ( buffer ) ; return ; } LocalPool owner = chunk . owner ; long free = chunk . free ( buffer , owner = = null | owner = = this ) ; if ( free = = <int> L ) { chunk . recycle ( ) ; if ( owner = = this ) removeFromLocalQueue ( chunk ) ; } else if ( ( ( free = = - <int> ) & & owner ! = this ) & & chunk . owner = = null ) { chunk . tryRecycle ( ) ; } } private void removeFromLocalQueue ( Chunk chunk ) { if ( chunks [ <int> ] = = chunk ) { chunks [ <int> ] = chunks [ <int> ] ; chunks [ <int> ] = chunks [ <int> ] ; } else if ( chunks [ <int> ] = = chunk ) { chunks [ <int> ] = chunks [ <int> ] ; } else assert chunks [ <int> ] = = chunk ; chunks [ <int> ] = null ; chunkCount - - ; } @VisibleForTesting void reset ( ) { chunkCount = <int> ; for ( int i = <int> ; i < chunks . length ; i + + ) { if ( chunks [ i ] ! = null ) { chunks [ i ] . owner = null ; chunks [ i ] . freeSlots = <int> L ; chunks [ i ] . recycle ( ) ; chunks [ i ] = null ; } } } } private static final class LocalPoolRef extends PhantomReference < LocalPool > { private final Chunk [ ] chunks ; public LocalPoolRef ( LocalPool localPool , ReferenceQueue < ? super LocalPool > q ) { super ( localPool , q ) ; chunks = localPool . chunks ; } public void release ( ) { for ( int i = <int> ; i < chunks . length ; i + + ) { if ( chunks [ i ] ! = null ) { chunks [ i ] . release ( ) ; chunks [ i ] = null ; } } } } private static final ConcurrentLinkedQueue < LocalPoolRef > localPoolReferences = new ConcurrentLinkedQueue < > ( ) ; private static final ReferenceQueue < Object > localPoolRefQueue = new ReferenceQueue < > ( ) ; private static final ExecutorService EXEC = Executors . newFixedThreadPool ( <int> , new NamedThreadFactory ( <str> ) ) ; static { EXEC . execute ( new Runnable ( ) { public void run ( ) { try { while ( true ) { Object obj = localPoolRefQueue . remove ( ) ; if ( obj instanceof LocalPoolRef ) { ( ( LocalPoolRef ) obj ) . release ( ) ; localPoolReferences . remove ( obj ) ; } } } catch ( InterruptedException e ) { } finally { EXEC . execute ( this ) ; } } } ) ; } private static ByteBuffer allocateDirectAligned ( int capacity ) { int align = MemoryUtil . pageSize ( ) ; if ( Integer . bitCount ( align ) ! = <int> ) throw new IllegalArgumentException ( <str> ) ; ByteBuffer buffer = ByteBuffer . allocateDirect ( capacity + align ) ; long address = MemoryUtil . getAddress ( buffer ) ; long offset = address & ( align - <int> ) ; if ( offset = = <int> ) { buffer . limit ( capacity ) ; } else { int pos = ( int ) ( align - offset ) ; buffer . position ( pos ) ; buffer . limit ( pos + capacity ) ; } return buffer . slice ( ) ; } final static class Chunk { private final ByteBuffer slab ; private final long baseAddress ; private final int shift ; private volatile long freeSlots ; private static final AtomicLongFieldUpdater < Chunk > freeSlotsUpdater = AtomicLongFieldUpdater . newUpdater ( Chunk . class , <str> ) ; private volatile LocalPool owner ; private long lastRecycled ; private final Chunk original ; Chunk ( Chunk recycle ) { assert recycle . freeSlots = = <int> L ; this . slab = recycle . slab ; this . baseAddress = recycle . baseAddress ; this . shift = recycle . shift ; this . freeSlots = - <int> ; this . original = recycle . original ; if ( DEBUG ) globalPool . debug . recycle ( original ) ; } Chunk ( ByteBuffer slab ) { assert ! slab . hasArray ( ) ; this . slab = slab ; this . baseAddress = MemoryUtil . getAddress ( slab ) ; this . shift = <int> & ( Integer . numberOfTrailingZeros ( slab . capacity ( ) / <int> ) ) ; this . freeSlots = slab . capacity ( ) = = <int> ? <int> L : - <int> ; this . original = DEBUG ? this : null ; } void acquire ( LocalPool owner ) { assert this . owner = = null ; this . owner = owner ; } void release ( ) { this . owner = null ; tryRecycle ( ) ; } void tryRecycle ( ) { assert owner = = null ; if ( isFree ( ) & & freeSlotsUpdater . compareAndSet ( this , - <int> , <int> L ) ) recycle ( ) ; } void recycle ( ) { assert freeSlots = = <int> L ; globalPool . recycle ( new Chunk ( this ) ) ; } static Chunk getParentChunk ( ByteBuffer buffer ) { Object attachment = MemoryUtil . getAttachment ( buffer ) ; if ( attachment instanceof Chunk ) return ( Chunk ) attachment ; if ( attachment instanceof Ref ) return ( ( Ref < Chunk > ) attachment ) . get ( ) ; return null ; } ByteBuffer setAttachment ( ByteBuffer buffer ) { if ( Ref . DEBUG_ENABLED ) MemoryUtil . setAttachment ( buffer , new Ref < > ( this , null ) ) ; else MemoryUtil . setAttachment ( buffer , this ) ; return buffer ; } boolean releaseAttachment ( ByteBuffer buffer ) { Object attachment = MemoryUtil . getAttachment ( buffer ) ; if ( attachment = = null ) return false ; if ( attachment instanceof Ref ) ( ( Ref < Chunk > ) attachment ) . release ( ) ; return true ; } @VisibleForTesting void reset ( ) { Chunk parent = getParentChunk ( slab ) ; if ( parent ! = null ) parent . free ( slab , false ) ; else FileUtils . clean ( slab ) ; } @VisibleForTesting long setFreeSlots ( long val ) { long ret = freeSlots ; freeSlots = val ; return ret ; } int capacity ( ) { return <int> < < shift ; } final int unit ( ) { return <int> < < shift ; } final boolean isFree ( ) { return freeSlots = = - <int> ; } int free ( ) { return Long . bitCount ( freeSlots ) * unit ( ) ; } ByteBuffer get ( int size ) { int slotCount = ( size - <int> + unit ( ) ) > > > shift ; if ( slotCount > <int> ) return null ; long slotBits = - <int> > > > ( <int> - slotCount ) ; long searchMask = <hex> ; searchMask * = <int> > > > ( ( slotCount - <int> ) & <int> ) ; searchMask & = - <int> > > > ( slotCount - <int> ) ; while ( true ) { long cur = freeSlots ; int index = Long . numberOfTrailingZeros ( cur & searchMask ) ; if ( index = = <int> ) return null ; searchMask ^ = <int> < < index ; long candidate = slotBits < < index ; if ( ( candidate & cur ) = = candidate ) { while ( true ) { if ( freeSlotsUpdater . compareAndSet ( this , cur , cur & ~ candidate ) ) break ; cur = freeSlots ; assert ( ( candidate & cur ) = = candidate ) ; } return get ( index < < shift , size ) ; } } } private ByteBuffer get ( int offset , int size ) { slab . limit ( offset + size ) ; slab . position ( offset ) ; return setAttachment ( slab . slice ( ) ) ; } int roundUp ( int v ) { return BufferPool . roundUp ( v , unit ( ) ) ; } long free ( ByteBuffer buffer , boolean tryRelease ) { if ( ! releaseAttachment ( buffer ) ) return <int> ; long address = MemoryUtil . getAddress ( buffer ) ; assert ( address > = baseAddress ) & ( address < = baseAddress + capacity ( ) ) ; int position = ( int ) ( address - baseAddress ) ; int size = roundUp ( buffer . capacity ( ) ) ; position > > = shift ; int slotCount = size > > shift ; long slotBits = ( <int> < < slotCount ) - <int> ; long shiftedSlotBits = ( slotBits < < position ) ; if ( slotCount = = <int> ) { assert size = = capacity ( ) ; assert position = = <int> ; shiftedSlotBits = - <int> ; } long next ; while ( true ) { long cur = freeSlots ; next = cur | shiftedSlotBits ; assert next = = ( cur ^ shiftedSlotBits ) ; if ( tryRelease & & ( next = = - <int> ) ) next = <int> L ; if ( freeSlotsUpdater . compareAndSet ( this , cur , next ) ) return next ; } } @Override public String toString ( ) { return String . format ( <str> , slab , Long . toBinaryString ( freeSlots ) , capacity ( ) , free ( ) ) ; } } @VisibleForTesting public static int roundUpNormal ( int size ) { return roundUp ( size , CHUNK_SIZE / <int> ) ; } private static int roundUp ( int size , int unit ) { int mask = unit - <int> ; return ( size + mask ) & ~ mask ; } } 
