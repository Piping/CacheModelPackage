package com . badlogic . gdx . backends . android ; import javax . microedition . khronos . egl . EGL10 ; import javax . microedition . khronos . egl . EGLConfig ; import javax . microedition . khronos . egl . EGLContext ; import javax . microedition . khronos . egl . EGLDisplay ; import javax . microedition . khronos . opengles . GL10 ; import android . opengl . GLSurfaceView ; import android . opengl . GLSurfaceView . EGLConfigChooser ; import android . opengl . GLSurfaceView . Renderer ; import android . util . DisplayMetrics ; import android . view . Display ; import android . view . View ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Graphics ; import com . badlogic . gdx . LifecycleListener ; import com . badlogic . gdx . backends . android . surfaceview . GLSurfaceView20 ; import com . badlogic . gdx . backends . android . surfaceview . GLSurfaceView20API18 ; import com . badlogic . gdx . backends . android . surfaceview . GLSurfaceViewAPI18 ; import com . badlogic . gdx . backends . android . surfaceview . GdxEglConfigChooser ; import com . badlogic . gdx . backends . android . surfaceview . ResolutionStrategy ; import com . badlogic . gdx . graphics . Cubemap ; import com . badlogic . gdx . graphics . Cursor ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . GL30 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . glutils . FrameBuffer ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . WindowedMean ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class AndroidGraphics implements Graphics , Renderer { private static final String LOG_TAG = <str> ; static volatile boolean enforceContinuousRendering = false ; final View view ; int width ; int height ; AndroidApplicationBase app ; GL20 gl20 ; GL30 gl30 ; EGLContext eglContext ; String extensions ; protected long lastFrameTime = System . nanoTime ( ) ; protected float deltaTime = <int> ; protected long frameStart = System . nanoTime ( ) ; protected long frameId = - <int> ; protected int frames = <int> ; protected int fps ; protected WindowedMean mean = new WindowedMean ( <int> ) ; volatile boolean created = false ; volatile boolean running = false ; volatile boolean pause = false ; volatile boolean resume = false ; volatile boolean destroy = false ; private float ppiX = <int> ; private float ppiY = <int> ; private float ppcX = <int> ; private float ppcY = <int> ; private float density = <int> ; protected final AndroidApplicationConfiguration config ; private BufferFormat bufferFormat = new BufferFormat ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , false ) ; private boolean isContinuous = true ; public AndroidGraphics ( AndroidApplicationBase application , AndroidApplicationConfiguration config , ResolutionStrategy resolutionStrategy ) { this ( application , config , resolutionStrategy , true ) ; } public AndroidGraphics ( AndroidApplicationBase application , AndroidApplicationConfiguration config , ResolutionStrategy resolutionStrategy , boolean focusableView ) { this . config = config ; this . app = application ; view = createGLSurfaceView ( application , resolutionStrategy ) ; preserveEGLContextOnPause ( ) ; if ( focusableView ) { view . setFocusable ( true ) ; view . setFocusableInTouchMode ( true ) ; } } protected void preserveEGLContextOnPause ( ) { int sdkVersion = android . os . Build . VERSION . SDK_INT ; if ( ( sdkVersion > = <int> & & view instanceof GLSurfaceView20 ) | | view instanceof GLSurfaceView20API18 ) { try { view . getClass ( ) . getMethod ( <str> , boolean . class ) . invoke ( view , true ) ; } catch ( Exception e ) { Gdx . app . log ( LOG_TAG , <str> ) ; } } } protected View createGLSurfaceView ( AndroidApplicationBase application , final ResolutionStrategy resolutionStrategy ) { if ( ! checkGL20 ( ) ) throw new GdxRuntimeException ( <str> ) ; EGLConfigChooser configChooser = getEglConfigChooser ( ) ; int sdkVersion = android . os . Build . VERSION . SDK_INT ; if ( sdkVersion < = <int> & & config . useGLSurfaceView20API18 ) { GLSurfaceView20API18 view = new GLSurfaceView20API18 ( application . getContext ( ) , resolutionStrategy ) ; if ( configChooser ! = null ) view . setEGLConfigChooser ( configChooser ) ; else view . setEGLConfigChooser ( config . r , config . g , config . b , config . a , config . depth , config . stencil ) ; view . setRenderer ( this ) ; return view ; } else { GLSurfaceView20 view = new GLSurfaceView20 ( application . getContext ( ) , resolutionStrategy ) ; if ( configChooser ! = null ) view . setEGLConfigChooser ( configChooser ) ; else view . setEGLConfigChooser ( config . r , config . g , config . b , config . a , config . depth , config . stencil ) ; view . setRenderer ( this ) ; return view ; } } public void onPauseGLSurfaceView ( ) { if ( view ! = null ) { if ( view instanceof GLSurfaceViewAPI18 ) ( ( GLSurfaceViewAPI18 ) view ) . onPause ( ) ; if ( view instanceof GLSurfaceView ) ( ( GLSurfaceView ) view ) . onPause ( ) ; } } public void onResumeGLSurfaceView ( ) { if ( view ! = null ) { if ( view instanceof GLSurfaceViewAPI18 ) ( ( GLSurfaceViewAPI18 ) view ) . onResume ( ) ; if ( view instanceof GLSurfaceView ) ( ( GLSurfaceView ) view ) . onResume ( ) ; } } protected EGLConfigChooser getEglConfigChooser ( ) { return new GdxEglConfigChooser ( config . r , config . g , config . b , config . a , config . depth , config . stencil , config . numSamples ) ; } private void updatePpi ( ) { DisplayMetrics metrics = new DisplayMetrics ( ) ; app . getWindowManager ( ) . getDefaultDisplay ( ) . getMetrics ( metrics ) ; ppiX = metrics . xdpi ; ppiY = metrics . ydpi ; ppcX = metrics . xdpi / <float> ; ppcY = metrics . ydpi / <float> ; density = metrics . density ; } protected boolean checkGL20 ( ) { EGL10 egl = ( EGL10 ) EGLContext . getEGL ( ) ; EGLDisplay display = egl . eglGetDisplay ( EGL10 . EGL_DEFAULT_DISPLAY ) ; int [ ] version = new int [ <int> ] ; egl . eglInitialize ( display , version ) ; int EGL_OPENGL_ES2_BIT = <int> ; int [ ] configAttribs = { EGL10 . EGL_RED_SIZE , <int> , EGL10 . EGL_GREEN_SIZE , <int> , EGL10 . EGL_BLUE_SIZE , <int> , EGL10 . EGL_RENDERABLE_TYPE , EGL_OPENGL_ES2_BIT , EGL10 . EGL_NONE } ; EGLConfig [ ] configs = new EGLConfig [ <int> ] ; int [ ] num_config = new int [ <int> ] ; egl . eglChooseConfig ( display , configAttribs , configs , <int> , num_config ) ; egl . eglTerminate ( display ) ; return num_config [ <int> ] > <int> ; } @Override public GL20 getGL20 ( ) { return gl20 ; } @Override public int getHeight ( ) { return height ; } @Override public int getWidth ( ) { return width ; } private void setupGL ( javax . microedition . khronos . opengles . GL10 gl ) { if ( gl20 ! = null ) return ; gl20 = new AndroidGL20 ( ) ; Gdx . gl = gl20 ; Gdx . gl20 = gl20 ; Gdx . app . log ( LOG_TAG , <str> + gl . glGetString ( GL10 . GL_RENDERER ) ) ; Gdx . app . log ( LOG_TAG , <str> + gl . glGetString ( GL10 . GL_VENDOR ) ) ; Gdx . app . log ( LOG_TAG , <str> + gl . glGetString ( GL10 . GL_VERSION ) ) ; Gdx . app . log ( LOG_TAG , <str> + gl . glGetString ( GL10 . GL_EXTENSIONS ) ) ; } @Override public void onSurfaceChanged ( javax . microedition . khronos . opengles . GL10 gl , int width , int height ) { this . width = width ; this . height = height ; updatePpi ( ) ; gl . glViewport ( <int> , <int> , this . width , this . height ) ; if ( created = = false ) { app . getApplicationListener ( ) . create ( ) ; created = true ; synchronized ( this ) { running = true ; } } app . getApplicationListener ( ) . resize ( width , height ) ; } @Override public void onSurfaceCreated ( javax . microedition . khronos . opengles . GL10 gl , EGLConfig config ) { eglContext = ( ( EGL10 ) EGLContext . getEGL ( ) ) . eglGetCurrentContext ( ) ; setupGL ( gl ) ; logConfig ( config ) ; updatePpi ( ) ; Mesh . invalidateAllMeshes ( app ) ; Texture . invalidateAllTextures ( app ) ; Cubemap . invalidateAllCubemaps ( app ) ; ShaderProgram . invalidateAllShaderPrograms ( app ) ; FrameBuffer . invalidateAllFrameBuffers ( app ) ; logManagedCachesStatus ( ) ; Display display = app . getWindowManager ( ) . getDefaultDisplay ( ) ; this . width = display . getWidth ( ) ; this . height = display . getHeight ( ) ; this . mean = new WindowedMean ( <int> ) ; this . lastFrameTime = System . nanoTime ( ) ; gl . glViewport ( <int> , <int> , this . width , this . height ) ; } private void logConfig ( EGLConfig config ) { EGL10 egl = ( EGL10 ) EGLContext . getEGL ( ) ; EGLDisplay display = egl . eglGetDisplay ( EGL10 . EGL_DEFAULT_DISPLAY ) ; int r = getAttrib ( egl , display , config , EGL10 . EGL_RED_SIZE , <int> ) ; int g = getAttrib ( egl , display , config , EGL10 . EGL_GREEN_SIZE , <int> ) ; int b = getAttrib ( egl , display , config , EGL10 . EGL_BLUE_SIZE , <int> ) ; int a = getAttrib ( egl , display , config , EGL10 . EGL_ALPHA_SIZE , <int> ) ; int d = getAttrib ( egl , display , config , EGL10 . EGL_DEPTH_SIZE , <int> ) ; int s = getAttrib ( egl , display , config , EGL10 . EGL_STENCIL_SIZE , <int> ) ; int samples = Math . max ( getAttrib ( egl , display , config , EGL10 . EGL_SAMPLES , <int> ) , getAttrib ( egl , display , config , GdxEglConfigChooser . EGL_COVERAGE_SAMPLES_NV , <int> ) ) ; boolean coverageSample = getAttrib ( egl , display , config , GdxEglConfigChooser . EGL_COVERAGE_SAMPLES_NV , <int> ) ! = <int> ; Gdx . app . log ( LOG_TAG , <str> + r + <str> + g + <str> + b + <str> + a + <str> ) ; Gdx . app . log ( LOG_TAG , <str> + d + <str> ) ; Gdx . app . log ( LOG_TAG , <str> + s + <str> ) ; Gdx . app . log ( LOG_TAG , <str> + samples + <str> ) ; Gdx . app . log ( LOG_TAG , <str> + coverageSample + <str> ) ; bufferFormat = new BufferFormat ( r , g , b , a , d , s , samples , coverageSample ) ; } int [ ] value = new int [ <int> ] ; private int getAttrib ( EGL10 egl , EGLDisplay display , EGLConfig config , int attrib , int defValue ) { if ( egl . eglGetConfigAttrib ( display , config , attrib , value ) ) { return value [ <int> ] ; } return defValue ; } Object synch = new Object ( ) ; void resume ( ) { synchronized ( synch ) { running = true ; resume = true ; } } void pause ( ) { synchronized ( synch ) { if ( ! running ) return ; running = false ; pause = true ; while ( pause ) { try { synch . wait ( <int> ) ; if ( pause ) { Gdx . app . error ( LOG_TAG , <str> ) ; android . os . Process . killProcess ( android . os . Process . myPid ( ) ) ; } } catch ( InterruptedException ignored ) { Gdx . app . log ( LOG_TAG , <str> ) ; } } } } void destroy ( ) { synchronized ( synch ) { running = false ; destroy = true ; while ( destroy ) { try { synch . wait ( ) ; } catch ( InterruptedException ex ) { Gdx . app . log ( LOG_TAG , <str> ) ; } } } } @Override public void onDrawFrame ( javax . microedition . khronos . opengles . GL10 gl ) { long time = System . nanoTime ( ) ; deltaTime = ( time - lastFrameTime ) / <float> ; lastFrameTime = time ; if ( ! resume ) { mean . addValue ( deltaTime ) ; } else { deltaTime = <int> ; } boolean lrunning = false ; boolean lpause = false ; boolean ldestroy = false ; boolean lresume = false ; synchronized ( synch ) { lrunning = running ; lpause = pause ; ldestroy = destroy ; lresume = resume ; if ( resume ) { resume = false ; } if ( pause ) { pause = false ; synch . notifyAll ( ) ; } if ( destroy ) { destroy = false ; synch . notifyAll ( ) ; } } if ( lresume ) { Array < LifecycleListener > listeners = app . getLifecycleListeners ( ) ; synchronized ( listeners ) { for ( LifecycleListener listener : listeners ) { listener . resume ( ) ; } } app . getApplicationListener ( ) . resume ( ) ; Gdx . app . log ( LOG_TAG , <str> ) ; } if ( lrunning ) { synchronized ( app . getRunnables ( ) ) { app . getExecutedRunnables ( ) . clear ( ) ; app . getExecutedRunnables ( ) . addAll ( app . getRunnables ( ) ) ; app . getRunnables ( ) . clear ( ) ; } for ( int i = <int> ; i < app . getExecutedRunnables ( ) . size ; i + + ) { try { app . getExecutedRunnables ( ) . get ( i ) . run ( ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; } } app . getInput ( ) . processEvents ( ) ; frameId + + ; app . getApplicationListener ( ) . render ( ) ; } if ( lpause ) { Array < LifecycleListener > listeners = app . getLifecycleListeners ( ) ; synchronized ( listeners ) { for ( LifecycleListener listener : listeners ) { listener . pause ( ) ; } } app . getApplicationListener ( ) . pause ( ) ; Gdx . app . log ( LOG_TAG , <str> ) ; } if ( ldestroy ) { Array < LifecycleListener > listeners = app . getLifecycleListeners ( ) ; synchronized ( listeners ) { for ( LifecycleListener listener : listeners ) { listener . dispose ( ) ; } } app . getApplicationListener ( ) . dispose ( ) ; Gdx . app . log ( LOG_TAG , <str> ) ; } if ( time - frameStart > <int> ) { fps = frames ; frames = <int> ; frameStart = time ; } frames + + ; } @Override public long getFrameId ( ) { return frameId ; } @Override public float getDeltaTime ( ) { return mean . getMean ( ) = = <int> ? deltaTime : mean . getMean ( ) ; } @Override public float getRawDeltaTime ( ) { return deltaTime ; } @Override public GraphicsType getType ( ) { return GraphicsType . AndroidGL ; } @Override public int getFramesPerSecond ( ) { return fps ; } public void clearManagedCaches ( ) { Mesh . clearAllMeshes ( app ) ; Texture . clearAllTextures ( app ) ; Cubemap . clearAllCubemaps ( app ) ; ShaderProgram . clearAllShaderPrograms ( app ) ; FrameBuffer . clearAllFrameBuffers ( app ) ; logManagedCachesStatus ( ) ; } protected void logManagedCachesStatus ( ) { Gdx . app . log ( LOG_TAG , Mesh . getManagedStatus ( ) ) ; Gdx . app . log ( LOG_TAG , Texture . getManagedStatus ( ) ) ; Gdx . app . log ( LOG_TAG , Cubemap . getManagedStatus ( ) ) ; Gdx . app . log ( LOG_TAG , ShaderProgram . getManagedStatus ( ) ) ; Gdx . app . log ( LOG_TAG , FrameBuffer . getManagedStatus ( ) ) ; } public View getView ( ) { return view ; } @Override public float getPpiX ( ) { return ppiX ; } @Override public float getPpiY ( ) { return ppiY ; } @Override public float getPpcX ( ) { return ppcX ; } @Override public float getPpcY ( ) { return ppcY ; } @Override public float getDensity ( ) { return density ; } @Override public boolean supportsDisplayModeChange ( ) { return false ; } @Override public boolean setDisplayMode ( DisplayMode displayMode ) { return false ; } @Override public DisplayMode [ ] getDisplayModes ( ) { return new DisplayMode [ ] { getDesktopDisplayMode ( ) } ; } @Override public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { return false ; } @Override public void setTitle ( String title ) { } private class AndroidDisplayMode extends DisplayMode { protected AndroidDisplayMode ( int width , int height , int refreshRate , int bitsPerPixel ) { super ( width , height , refreshRate , bitsPerPixel ) ; } } @Override public DisplayMode getDesktopDisplayMode ( ) { DisplayMetrics metrics = new DisplayMetrics ( ) ; app . getWindowManager ( ) . getDefaultDisplay ( ) . getMetrics ( metrics ) ; return new AndroidDisplayMode ( metrics . widthPixels , metrics . heightPixels , <int> , <int> ) ; } @Override public BufferFormat getBufferFormat ( ) { return bufferFormat ; } @Override public void setVSync ( boolean vsync ) { } @Override public boolean supportsExtension ( String extension ) { if ( extensions = = null ) extensions = Gdx . gl . glGetString ( GL10 . GL_EXTENSIONS ) ; return extensions . contains ( extension ) ; } @Override public void setContinuousRendering ( boolean isContinuous ) { if ( view ! = null ) { this . isContinuous = enforceContinuousRendering | | isContinuous ; int renderMode = this . isContinuous ? GLSurfaceView . RENDERMODE_CONTINUOUSLY : GLSurfaceView . RENDERMODE_WHEN_DIRTY ; if ( view instanceof GLSurfaceViewAPI18 ) ( ( GLSurfaceViewAPI18 ) view ) . setRenderMode ( renderMode ) ; if ( view instanceof GLSurfaceView ) ( ( GLSurfaceView ) view ) . setRenderMode ( renderMode ) ; mean . clear ( ) ; } } @Override public boolean isContinuousRendering ( ) { return isContinuous ; } @Override public void requestRendering ( ) { if ( view ! = null ) { if ( view instanceof GLSurfaceViewAPI18 ) ( ( GLSurfaceViewAPI18 ) view ) . requestRender ( ) ; if ( view instanceof GLSurfaceView ) ( ( GLSurfaceView ) view ) . requestRender ( ) ; } } @Override public boolean isFullscreen ( ) { return true ; } @Override public boolean isGL30Available ( ) { return gl30 ! = null ; } @Override public GL30 getGL30 ( ) { return gl30 ; } @Override public Cursor newCursor ( Pixmap pixmap , int xHotspot , int yHotspot ) { return null ; } @Override public void setCursor ( Cursor cursor ) { } } 
