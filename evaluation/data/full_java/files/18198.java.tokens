package com . badlogic . gdx . math ; public class Polygon implements Shape2D { private float [ ] localVertices ; private float [ ] worldVertices ; private float x , y ; private float originX , originY ; private float rotation ; private float scaleX = <int> , scaleY = <int> ; private boolean dirty = true ; private Rectangle bounds ; public Polygon ( ) { this . localVertices = new float [ <int> ] ; } public Polygon ( float [ ] vertices ) { if ( vertices . length < <int> ) throw new IllegalArgumentException ( <str> ) ; this . localVertices = vertices ; } public float [ ] getVertices ( ) { return localVertices ; } public float [ ] getTransformedVertices ( ) { if ( ! dirty ) return worldVertices ; dirty = false ; final float [ ] localVertices = this . localVertices ; if ( worldVertices = = null | | worldVertices . length ! = localVertices . length ) worldVertices = new float [ localVertices . length ] ; final float [ ] worldVertices = this . worldVertices ; final float positionX = x ; final float positionY = y ; final float originX = this . originX ; final float originY = this . originY ; final float scaleX = this . scaleX ; final float scaleY = this . scaleY ; final boolean scale = scaleX ! = <int> | | scaleY ! = <int> ; final float rotation = this . rotation ; final float cos = MathUtils . cosDeg ( rotation ) ; final float sin = MathUtils . sinDeg ( rotation ) ; for ( int i = <int> , n = localVertices . length ; i < n ; i + = <int> ) { float x = localVertices [ i ] - originX ; float y = localVertices [ i + <int> ] - originY ; if ( scale ) { x * = scaleX ; y * = scaleY ; } if ( rotation ! = <int> ) { float oldX = x ; x = cos * x - sin * y ; y = sin * oldX + cos * y ; } worldVertices [ i ] = positionX + x + originX ; worldVertices [ i + <int> ] = positionY + y + originY ; } return worldVertices ; } public void setOrigin ( float originX , float originY ) { this . originX = originX ; this . originY = originY ; dirty = true ; } public void setPosition ( float x , float y ) { this . x = x ; this . y = y ; dirty = true ; } public void setVertices ( float [ ] vertices ) { if ( vertices . length < <int> ) throw new IllegalArgumentException ( <str> ) ; localVertices = vertices ; dirty = true ; } public void translate ( float x , float y ) { this . x + = x ; this . y + = y ; dirty = true ; } public void setRotation ( float degrees ) { this . rotation = degrees ; dirty = true ; } public void rotate ( float degrees ) { rotation + = degrees ; dirty = true ; } public void setScale ( float scaleX , float scaleY ) { this . scaleX = scaleX ; this . scaleY = scaleY ; dirty = true ; } public void scale ( float amount ) { this . scaleX + = amount ; this . scaleY + = amount ; dirty = true ; } public void dirty ( ) { dirty = true ; } public float area ( ) { float [ ] vertices = getTransformedVertices ( ) ; return GeometryUtils . polygonArea ( vertices , <int> , vertices . length ) ; } public Rectangle getBoundingRectangle ( ) { float [ ] vertices = getTransformedVertices ( ) ; float minX = vertices [ <int> ] ; float minY = vertices [ <int> ] ; float maxX = vertices [ <int> ] ; float maxY = vertices [ <int> ] ; final int numFloats = vertices . length ; for ( int i = <int> ; i < numFloats ; i + = <int> ) { minX = minX > vertices [ i ] ? vertices [ i ] : minX ; minY = minY > vertices [ i + <int> ] ? vertices [ i + <int> ] : minY ; maxX = maxX < vertices [ i ] ? vertices [ i ] : maxX ; maxY = maxY < vertices [ i + <int> ] ? vertices [ i + <int> ] : maxY ; } if ( bounds = = null ) bounds = new Rectangle ( ) ; bounds . x = minX ; bounds . y = minY ; bounds . width = maxX - minX ; bounds . height = maxY - minY ; return bounds ; } @Override public boolean contains ( float x , float y ) { final float [ ] vertices = getTransformedVertices ( ) ; final int numFloats = vertices . length ; int intersects = <int> ; for ( int i = <int> ; i < numFloats ; i + = <int> ) { float x1 = vertices [ i ] ; float y1 = vertices [ i + <int> ] ; float x2 = vertices [ ( i + <int> ) % numFloats ] ; float y2 = vertices [ ( i + <int> ) % numFloats ] ; if ( ( ( y1 < = y & & y < y2 ) | | ( y2 < = y & & y < y1 ) ) & & x < ( ( x2 - x1 ) / ( y2 - y1 ) * ( y - y1 ) + x1 ) ) intersects + + ; } return ( intersects & <int> ) = = <int> ; } @Override public boolean contains ( Vector2 point ) { return contains ( point . x , point . y ) ; } public float getX ( ) { return x ; } public float getY ( ) { return y ; } public float getOriginX ( ) { return originX ; } public float getOriginY ( ) { return originY ; } public float getRotation ( ) { return rotation ; } public float getScaleX ( ) { return scaleX ; } public float getScaleY ( ) { return scaleY ; } } 
