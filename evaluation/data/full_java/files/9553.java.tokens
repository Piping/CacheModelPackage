package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . Supplier ; import com . google . common . base . Throwables ; import com . google . common . collect . Lists ; import com . google . common . collect . Queues ; import com . google . common . util . concurrent . ForwardingListenableFuture . SimpleForwardingListenableFuture ; import java . lang . reflect . InvocationTargetException ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . Callable ; import java . util . concurrent . Delayed ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . ScheduledExecutorService ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . ThreadPoolExecutor . CallerRunsPolicy ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import javax . annotation . concurrent . GuardedBy ; @GwtCompatible ( emulated = true ) public final class MoreExecutors { private MoreExecutors ( ) { } @Beta @GwtIncompatible ( <str> ) public static ExecutorService getExitingExecutorService ( ThreadPoolExecutor executor , long terminationTimeout , TimeUnit timeUnit ) { return new Application ( ) . getExitingExecutorService ( executor , terminationTimeout , timeUnit ) ; } @Beta @GwtIncompatible ( <str> ) public static ScheduledExecutorService getExitingScheduledExecutorService ( ScheduledThreadPoolExecutor executor , long terminationTimeout , TimeUnit timeUnit ) { return new Application ( ) . getExitingScheduledExecutorService ( executor , terminationTimeout , timeUnit ) ; } @Beta @GwtIncompatible ( <str> ) public static void addDelayedShutdownHook ( ExecutorService service , long terminationTimeout , TimeUnit timeUnit ) { new Application ( ) . addDelayedShutdownHook ( service , terminationTimeout , timeUnit ) ; } @Beta @GwtIncompatible ( <str> ) public static ExecutorService getExitingExecutorService ( ThreadPoolExecutor executor ) { return new Application ( ) . getExitingExecutorService ( executor ) ; } @Beta @GwtIncompatible ( <str> ) public static ScheduledExecutorService getExitingScheduledExecutorService ( ScheduledThreadPoolExecutor executor ) { return new Application ( ) . getExitingScheduledExecutorService ( executor ) ; } @GwtIncompatible ( <str> ) @VisibleForTesting static class Application { final ExecutorService getExitingExecutorService ( ThreadPoolExecutor executor , long terminationTimeout , TimeUnit timeUnit ) { useDaemonThreadFactory ( executor ) ; ExecutorService service = Executors . unconfigurableExecutorService ( executor ) ; addDelayedShutdownHook ( service , terminationTimeout , timeUnit ) ; return service ; } final ScheduledExecutorService getExitingScheduledExecutorService ( ScheduledThreadPoolExecutor executor , long terminationTimeout , TimeUnit timeUnit ) { useDaemonThreadFactory ( executor ) ; ScheduledExecutorService service = Executors . unconfigurableScheduledExecutorService ( executor ) ; addDelayedShutdownHook ( service , terminationTimeout , timeUnit ) ; return service ; } final void addDelayedShutdownHook ( final ExecutorService service , final long terminationTimeout , final TimeUnit timeUnit ) { checkNotNull ( service ) ; checkNotNull ( timeUnit ) ; addShutdownHook ( MoreExecutors . newThread ( <str> + service , new Runnable ( ) { @Override public void run ( ) { try { service . shutdown ( ) ; service . awaitTermination ( terminationTimeout , timeUnit ) ; } catch ( InterruptedException ignored ) { } } } ) ) ; } final ExecutorService getExitingExecutorService ( ThreadPoolExecutor executor ) { return getExitingExecutorService ( executor , <int> , TimeUnit . SECONDS ) ; } final ScheduledExecutorService getExitingScheduledExecutorService ( ScheduledThreadPoolExecutor executor ) { return getExitingScheduledExecutorService ( executor , <int> , TimeUnit . SECONDS ) ; } @VisibleForTesting void addShutdownHook ( Thread hook ) { Runtime . getRuntime ( ) . addShutdownHook ( hook ) ; } } @GwtIncompatible ( <str> ) private static void useDaemonThreadFactory ( ThreadPoolExecutor executor ) { executor . setThreadFactory ( new ThreadFactoryBuilder ( ) . setDaemon ( true ) . setThreadFactory ( executor . getThreadFactory ( ) ) . build ( ) ) ; } @Deprecated @GwtIncompatible ( <str> ) public static ListeningExecutorService sameThreadExecutor ( ) { return new DirectExecutorService ( ) ; } @GwtIncompatible ( <str> ) private static final class DirectExecutorService extends AbstractListeningExecutorService { private final Object lock = new Object ( ) ; @GuardedBy ( <str> ) private int runningTasks = <int> ; @GuardedBy ( <str> ) private boolean shutdown = false ; @Override public void execute ( Runnable command ) { startTask ( ) ; try { command . run ( ) ; } finally { endTask ( ) ; } } @Override public boolean isShutdown ( ) { synchronized ( lock ) { return shutdown ; } } @Override public void shutdown ( ) { synchronized ( lock ) { shutdown = true ; if ( runningTasks = = <int> ) { lock . notifyAll ( ) ; } } } @Override public List < Runnable > shutdownNow ( ) { shutdown ( ) ; return Collections . emptyList ( ) ; } @Override public boolean isTerminated ( ) { synchronized ( lock ) { return shutdown & & runningTasks = = <int> ; } } @Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { long nanos = unit . toNanos ( timeout ) ; synchronized ( lock ) { for ( ; ; ) { if ( shutdown & & runningTasks = = <int> ) { return true ; } else if ( nanos < = <int> ) { return false ; } else { long now = System . nanoTime ( ) ; TimeUnit . NANOSECONDS . timedWait ( lock , nanos ) ; nanos - = System . nanoTime ( ) - now ; } } } } private void startTask ( ) { synchronized ( lock ) { if ( shutdown ) { throw new RejectedExecutionException ( <str> ) ; } runningTasks + + ; } } private void endTask ( ) { synchronized ( lock ) { int numRunning = - - runningTasks ; if ( numRunning = = <int> ) { lock . notifyAll ( ) ; } } } } @GwtIncompatible ( <str> ) public static ListeningExecutorService newDirectExecutorService ( ) { return new DirectExecutorService ( ) ; } public static Executor directExecutor ( ) { return DirectExecutor . INSTANCE ; } private enum DirectExecutor implements Executor { INSTANCE ; @Override public void execute ( Runnable command ) { command . run ( ) ; } @Override public String toString ( ) { return <str> ; } } @GwtIncompatible ( <str> ) public static ListeningExecutorService listeningDecorator ( ExecutorService delegate ) { return ( delegate instanceof ListeningExecutorService ) ? ( ListeningExecutorService ) delegate : ( delegate instanceof ScheduledExecutorService ) ? new ScheduledListeningDecorator ( ( ScheduledExecutorService ) delegate ) : new ListeningDecorator ( delegate ) ; } @GwtIncompatible ( <str> ) public static ListeningScheduledExecutorService listeningDecorator ( ScheduledExecutorService delegate ) { return ( delegate instanceof ListeningScheduledExecutorService ) ? ( ListeningScheduledExecutorService ) delegate : new ScheduledListeningDecorator ( delegate ) ; } @GwtIncompatible ( <str> ) private static class ListeningDecorator extends AbstractListeningExecutorService { private final ExecutorService delegate ; ListeningDecorator ( ExecutorService delegate ) { this . delegate = checkNotNull ( delegate ) ; } @Override public final boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { return delegate . awaitTermination ( timeout , unit ) ; } @Override public final boolean isShutdown ( ) { return delegate . isShutdown ( ) ; } @Override public final boolean isTerminated ( ) { return delegate . isTerminated ( ) ; } @Override public final void shutdown ( ) { delegate . shutdown ( ) ; } @Override public final List < Runnable > shutdownNow ( ) { return delegate . shutdownNow ( ) ; } @Override public final void execute ( Runnable command ) { delegate . execute ( command ) ; } } @GwtIncompatible ( <str> ) private static final class ScheduledListeningDecorator extends ListeningDecorator implements ListeningScheduledExecutorService { @SuppressWarnings ( <str> ) final ScheduledExecutorService delegate ; ScheduledListeningDecorator ( ScheduledExecutorService delegate ) { super ( delegate ) ; this . delegate = checkNotNull ( delegate ) ; } @Override public ListenableScheduledFuture < ? > schedule ( Runnable command , long delay , TimeUnit unit ) { TrustedListenableFutureTask < Void > task = TrustedListenableFutureTask . create ( command , null ) ; ScheduledFuture < ? > scheduled = delegate . schedule ( task , delay , unit ) ; return new ListenableScheduledTask < Void > ( task , scheduled ) ; } @Override public < V > ListenableScheduledFuture < V > schedule ( Callable < V > callable , long delay , TimeUnit unit ) { TrustedListenableFutureTask < V > task = TrustedListenableFutureTask . create ( callable ) ; ScheduledFuture < ? > scheduled = delegate . schedule ( task , delay , unit ) ; return new ListenableScheduledTask < V > ( task , scheduled ) ; } @Override public ListenableScheduledFuture < ? > scheduleAtFixedRate ( Runnable command , long initialDelay , long period , TimeUnit unit ) { NeverSuccessfulListenableFutureTask task = new NeverSuccessfulListenableFutureTask ( command ) ; ScheduledFuture < ? > scheduled = delegate . scheduleAtFixedRate ( task , initialDelay , period , unit ) ; return new ListenableScheduledTask < Void > ( task , scheduled ) ; } @Override public ListenableScheduledFuture < ? > scheduleWithFixedDelay ( Runnable command , long initialDelay , long delay , TimeUnit unit ) { NeverSuccessfulListenableFutureTask task = new NeverSuccessfulListenableFutureTask ( command ) ; ScheduledFuture < ? > scheduled = delegate . scheduleWithFixedDelay ( task , initialDelay , delay , unit ) ; return new ListenableScheduledTask < Void > ( task , scheduled ) ; } private static final class ListenableScheduledTask < V > extends SimpleForwardingListenableFuture < V > implements ListenableScheduledFuture < V > { private final ScheduledFuture < ? > scheduledDelegate ; public ListenableScheduledTask ( ListenableFuture < V > listenableDelegate , ScheduledFuture < ? > scheduledDelegate ) { super ( listenableDelegate ) ; this . scheduledDelegate = scheduledDelegate ; } @Override public boolean cancel ( boolean mayInterruptIfRunning ) { boolean cancelled = super . cancel ( mayInterruptIfRunning ) ; if ( cancelled ) { scheduledDelegate . cancel ( mayInterruptIfRunning ) ; } return cancelled ; } @Override public long getDelay ( TimeUnit unit ) { return scheduledDelegate . getDelay ( unit ) ; } @Override public int compareTo ( Delayed other ) { return scheduledDelegate . compareTo ( other ) ; } } @GwtIncompatible ( <str> ) private static final class NeverSuccessfulListenableFutureTask extends AbstractFuture < Void > implements Runnable { private final Runnable delegate ; public NeverSuccessfulListenableFutureTask ( Runnable delegate ) { this . delegate = checkNotNull ( delegate ) ; } @Override public void run ( ) { try { delegate . run ( ) ; } catch ( Throwable t ) { setException ( t ) ; throw Throwables . propagate ( t ) ; } } } } @GwtIncompatible ( <str> ) static < T > T invokeAnyImpl ( ListeningExecutorService executorService , Collection < ? extends Callable < T > > tasks , boolean timed , long nanos ) throws InterruptedException , ExecutionException , TimeoutException { checkNotNull ( executorService ) ; int ntasks = tasks . size ( ) ; checkArgument ( ntasks > <int> ) ; List < Future < T > > futures = Lists . newArrayListWithCapacity ( ntasks ) ; BlockingQueue < Future < T > > futureQueue = Queues . newLinkedBlockingQueue ( ) ; try { ExecutionException ee = null ; long lastTime = timed ? System . nanoTime ( ) : <int> ; Iterator < ? extends Callable < T > > it = tasks . iterator ( ) ; futures . add ( submitAndAddQueueListener ( executorService , it . next ( ) , futureQueue ) ) ; - - ntasks ; int active = <int> ; for ( ; ; ) { Future < T > f = futureQueue . poll ( ) ; if ( f = = null ) { if ( ntasks > <int> ) { - - ntasks ; futures . add ( submitAndAddQueueListener ( executorService , it . next ( ) , futureQueue ) ) ; + + active ; } else if ( active = = <int> ) { break ; } else if ( timed ) { f = futureQueue . poll ( nanos , TimeUnit . NANOSECONDS ) ; if ( f = = null ) { throw new TimeoutException ( ) ; } long now = System . nanoTime ( ) ; nanos - = now - lastTime ; lastTime = now ; } else { f = futureQueue . take ( ) ; } } if ( f ! = null ) { - - active ; try { return f . get ( ) ; } catch ( ExecutionException eex ) { ee = eex ; } catch ( RuntimeException rex ) { ee = new ExecutionException ( rex ) ; } } } if ( ee = = null ) { ee = new ExecutionException ( null ) ; } throw ee ; } finally { for ( Future < T > f : futures ) { f . cancel ( true ) ; } } } @GwtIncompatible ( <str> ) private static < T > ListenableFuture < T > submitAndAddQueueListener ( ListeningExecutorService executorService , Callable < T > task , final BlockingQueue < Future < T > > queue ) { final ListenableFuture < T > future = executorService . submit ( task ) ; future . addListener ( new Runnable ( ) { @Override public void run ( ) { queue . add ( future ) ; } } , directExecutor ( ) ) ; return future ; } @Beta @GwtIncompatible ( <str> ) public static ThreadFactory platformThreadFactory ( ) { if ( ! isAppEngine ( ) ) { return Executors . defaultThreadFactory ( ) ; } try { return ( ThreadFactory ) Class . forName ( <str> ) . getMethod ( <str> ) . invoke ( null ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( <str> , e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( <str> , e ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( <str> , e ) ; } catch ( InvocationTargetException e ) { throw Throwables . propagate ( e . getCause ( ) ) ; } } @GwtIncompatible ( <str> ) private static boolean isAppEngine ( ) { if ( System . getProperty ( <str> ) = = null ) { return false ; } try { return Class . forName ( <str> ) . getMethod ( <str> ) . invoke ( null ) ! = null ; } catch ( ClassNotFoundException e ) { return false ; } catch ( InvocationTargetException e ) { return false ; } catch ( IllegalAccessException e ) { return false ; } catch ( NoSuchMethodException e ) { return false ; } } @GwtIncompatible ( <str> ) static Thread newThread ( String name , Runnable runnable ) { checkNotNull ( name ) ; checkNotNull ( runnable ) ; Thread result = platformThreadFactory ( ) . newThread ( runnable ) ; try { result . setName ( name ) ; } catch ( SecurityException e ) { } return result ; } @GwtIncompatible ( <str> ) static Executor renamingDecorator ( final Executor executor , final Supplier < String > nameSupplier ) { checkNotNull ( executor ) ; checkNotNull ( nameSupplier ) ; if ( isAppEngine ( ) ) { return executor ; } return new Executor ( ) { @Override public void execute ( Runnable command ) { executor . execute ( Callables . threadRenaming ( command , nameSupplier ) ) ; } } ; } @GwtIncompatible ( <str> ) static ExecutorService renamingDecorator ( final ExecutorService service , final Supplier < String > nameSupplier ) { checkNotNull ( service ) ; checkNotNull ( nameSupplier ) ; if ( isAppEngine ( ) ) { return service ; } return new WrappingExecutorService ( service ) { @Override protected < T > Callable < T > wrapTask ( Callable < T > callable ) { return Callables . threadRenaming ( callable , nameSupplier ) ; } @Override protected Runnable wrapTask ( Runnable command ) { return Callables . threadRenaming ( command , nameSupplier ) ; } } ; } @GwtIncompatible ( <str> ) static ScheduledExecutorService renamingDecorator ( final ScheduledExecutorService service , final Supplier < String > nameSupplier ) { checkNotNull ( service ) ; checkNotNull ( nameSupplier ) ; if ( isAppEngine ( ) ) { return service ; } return new WrappingScheduledExecutorService ( service ) { @Override protected < T > Callable < T > wrapTask ( Callable < T > callable ) { return Callables . threadRenaming ( callable , nameSupplier ) ; } @Override protected Runnable wrapTask ( Runnable command ) { return Callables . threadRenaming ( command , nameSupplier ) ; } } ; } @Beta @GwtIncompatible ( <str> ) public static boolean shutdownAndAwaitTermination ( ExecutorService service , long timeout , TimeUnit unit ) { checkNotNull ( unit ) ; service . shutdown ( ) ; try { long halfTimeoutNanos = TimeUnit . NANOSECONDS . convert ( timeout , unit ) / <int> ; if ( ! service . awaitTermination ( halfTimeoutNanos , TimeUnit . NANOSECONDS ) ) { service . shutdownNow ( ) ; service . awaitTermination ( halfTimeoutNanos , TimeUnit . NANOSECONDS ) ; } } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; service . shutdownNow ( ) ; } return service . isTerminated ( ) ; } static Executor rejectionPropagatingExecutor ( final Executor delegate , final AbstractFuture < ? > future ) { checkNotNull ( delegate ) ; checkNotNull ( future ) ; if ( delegate = = directExecutor ( ) ) { return delegate ; } return new Executor ( ) { volatile boolean thrownFromDelegate = true ; @Override public void execute ( final Runnable command ) { try { delegate . execute ( new Runnable ( ) { @Override public void run ( ) { thrownFromDelegate = false ; command . run ( ) ; } } ) ; } catch ( RejectedExecutionException e ) { if ( thrownFromDelegate ) { future . setException ( e ) ; } } } } ; } } 
