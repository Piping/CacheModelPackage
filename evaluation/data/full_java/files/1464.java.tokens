package org . apache . cassandra . db ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import org . junit . Before ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . cql3 . statements . IndexTarget ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . index . Index ; import org . apache . cassandra . schema . IndexMetadata ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . apache . cassandra . Util . throwAssert ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; public class SecondaryIndexTest { public static final String KEYSPACE1 = <str> ; public static final String WITH_COMPOSITE_INDEX = <str> ; public static final String WITH_KEYS_INDEX = <str> ; public static final String COMPOSITE_INDEX_TO_BE_ADDED = <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE1 , WITH_COMPOSITE_INDEX , true ) . gcGraceSeconds ( <int> ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE1 , COMPOSITE_INDEX_TO_BE_ADDED , false ) . gcGraceSeconds ( <int> ) , SchemaLoader . keysIndexCFMD ( KEYSPACE1 , WITH_KEYS_INDEX , true ) . gcGraceSeconds ( <int> ) ) ; } @Before public void truncateCFS ( ) { Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_COMPOSITE_INDEX ) . truncateBlocking ( ) ; Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( COMPOSITE_INDEX_TO_BE_ADDED ) . truncateBlocking ( ) ; Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_KEYS_INDEX ) . truncateBlocking ( ) ; } @Test public void testIndexScan ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_COMPOSITE_INDEX ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; List < FilteredPartition > partitions = Util . getAll ( Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyIncl ( <str> ) . columns ( <str> ) . build ( ) ) ; assertEquals ( <int> , partitions . size ( ) ) ; Util . assertCellValue ( <int> , cfs , Util . row ( partitions . get ( <int> ) , <str> ) , <str> ) ; Util . assertCellValue ( <int> , cfs , Util . row ( partitions . get ( <int> ) , <str> ) , <str> ) ; partitions = Util . getAll ( Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyIncl ( <str> ) . build ( ) ) ; assertEquals ( <int> , partitions . size ( ) ) ; Row first = Util . row ( partitions . get ( <int> ) , <str> ) ; Util . assertCellValue ( <int> , cfs , first , <str> ) ; Util . assertCellValue ( <int> , cfs , first , <str> ) ; Row second = Util . row ( partitions . get ( <int> ) , <str> ) ; Util . assertCellValue ( <int> , cfs , second , <str> ) ; Util . assertCellValue ( <int> , cfs , second , <str> ) ; Row third = Util . row ( partitions . get ( <int> ) , <str> ) ; Util . assertCellValue ( <int> , cfs , third , <str> ) ; Util . assertCellValue ( <int> , cfs , third , <str> ) ; ReadCommand rc = Util . cmd ( cfs ) . fromKeyIncl ( <str> ) . toKeyIncl ( <str> ) . columns ( <str> ) . filterOn ( <str> , Operator . EQ , <int> ) . build ( ) ; Index . Searcher searcher = cfs . indexManager . getBestIndexFor ( rc ) . searcherFor ( rc ) ; try ( ReadExecutionController executionController = rc . executionController ( ) ; UnfilteredPartitionIterator pi = searcher . search ( executionController ) ) { assertTrue ( pi . hasNext ( ) ) ; pi . next ( ) . close ( ) ; } partitions = Util . getAll ( Util . cmd ( cfs ) . fromKeyIncl ( <str> ) . toKeyIncl ( <str> ) . filterOn ( <str> , Operator . GT , <int> ) . build ( ) ) ; int rowCount = <int> ; for ( FilteredPartition partition : partitions ) { for ( Row row : partition ) { + + rowCount ; assert ByteBufferUtil . toLong ( Util . cell ( cfs , row , <str> ) . value ( ) ) > <int> ; } } assertEquals ( <int> , rowCount ) ; Util . assertEmpty ( Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyIncl ( <str> ) . filterOn ( <str> , Operator . NEQ , <int> ) . build ( ) ) ; Util . assertEmpty ( Util . cmd ( cfs ) . fromKeyExcl ( <str> ) . toKeyIncl ( <str> ) . filterOn ( <str> , Operator . EQ , <int> ) . filterOn ( <str> , Operator . NEQ , <int> ) . build ( ) ) ; } @Test public void testLargeScan ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_COMPOSITE_INDEX ) ; ByteBuffer bBB = ByteBufferUtil . bytes ( <str> ) ; ByteBuffer nbBB = ByteBufferUtil . bytes ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { new RowUpdateBuilder ( cfs . metadata , FBUtilities . timestampMicros ( ) , <str> + i ) . clustering ( <str> ) . add ( <str> , <int> ) . add ( <str> , ByteBufferUtil . bytes ( ( long ) ( i % <int> ) ) ) . build ( ) . applyUnsafe ( ) ; } List < FilteredPartition > partitions = Util . getAll ( Util . cmd ( cfs ) . filterOn ( <str> , Operator . EQ , <int> ) . filterOn ( <str> , Operator . EQ , <int> ) . build ( ) ) ; Set < DecoratedKey > keys = new HashSet < > ( ) ; int rowCount = <int> ; for ( FilteredPartition partition : partitions ) { keys . add ( partition . partitionKey ( ) ) ; rowCount + = partition . rowCount ( ) ; } assertEquals ( rowCount , keys . size ( ) ) ; assertEquals ( <int> , rowCount ) ; } @Test public void testCompositeIndexDeletions ( ) throws IOException { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_COMPOSITE_INDEX ) ; ByteBuffer bBB = ByteBufferUtil . bytes ( <str> ) ; ColumnDefinition bDef = cfs . metadata . getColumnDefinition ( bBB ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; assertIndexedOne ( cfs , col , <int> ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , <str> , <str> ) . applyUnsafe ( ) ; assertIndexedNone ( cfs , col , <int> ) ; ReadCommand rc = Util . cmd ( cfs ) . build ( ) ; assertNull ( cfs . indexManager . getBestIndexFor ( rc ) ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . apply ( ) ; ; assertIndexedOne ( cfs , col , <int> ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , <str> , <str> ) . applyUnsafe ( ) ; assertIndexedOne ( cfs , col , <int> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . delete ( bDef ) . build ( ) . applyUnsafe ( ) ; assertIndexedOne ( cfs , col , <int> ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , <str> , <str> ) . applyUnsafe ( ) ; rc = Util . cmd ( cfs ) . build ( ) ; assertNull ( cfs . indexManager . getBestIndexFor ( rc ) ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . apply ( ) ; ; rc = Util . cmd ( cfs ) . build ( ) ; assertNull ( cfs . indexManager . getBestIndexFor ( rc ) ) ; } @Test public void testCompositeIndexUpdate ( ) throws IOException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( WITH_COMPOSITE_INDEX ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; assertIndexedNone ( cfs , col , <int> ) ; assertIndexedOne ( cfs , col , <int> ) ; assertIndexedNone ( cfs , col , <int> ) ; assertIndexedOne ( cfs , col , <int> ) ; } @Test public void testIndexUpdateOverwritingExpiringColumns ( ) throws Exception { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_COMPOSITE_INDEX ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; assertIndexedOne ( cfs , col , <int> ) ; TimeUnit . SECONDS . sleep ( <int> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; assertIndexedOne ( cfs , col , <int> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; assertIndexedOne ( cfs , col , <int> ) ; TimeUnit . SECONDS . sleep ( <int> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; assertIndexedNone ( cfs , col , <int> ) ; assertIndexedOne ( cfs , col , <int> ) ; } @Test public void testDeleteOfInconsistentValuesInKeysIndex ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( WITH_KEYS_INDEX ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . noRowMarker ( ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; keyspace . getColumnFamilyStore ( WITH_KEYS_INDEX ) . forceBlockingFlush ( ) ; keyspace . apply ( new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . noRowMarker ( ) . add ( <str> , <int> ) . build ( ) , true , false ) ; assertIndexedNone ( cfs , col , <int> ) ; assertIndexedNone ( cfs , col , <int> ) ; keyspace . apply ( new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . noRowMarker ( ) . add ( <str> , <int> ) . build ( ) , true , false ) ; assertIndexedNone ( cfs , col , <int> ) ; } @Test public void testDeleteOfInconsistentValuesFromCompositeIndex ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; String cfName = WITH_COMPOSITE_INDEX ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( cfName ) ; ByteBuffer col = ByteBufferUtil . bytes ( <str> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; assertIndexedOne ( cfs , col , <int> ) ; keyspace . getColumnFamilyStore ( cfName ) . forceBlockingFlush ( ) ; assertIndexedOne ( cfs , col , <int> ) ; keyspace . apply ( new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) , true , false ) ; assertIndexedNone ( cfs , col , <int> ) ; assertIndexedNone ( cfs , col , <int> ) ; keyspace . apply ( new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) , true , false ) ; assertIndexedNone ( cfs , col , <int> ) ; } @Test public void testDeleteCompositeIndex ( ) throws Exception { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_COMPOSITE_INDEX ) ; ByteBuffer colName = ByteBufferUtil . bytes ( <str> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , <str> , <str> ) . applyUnsafe ( ) ; try { Thread . sleep ( <int> ) ; } catch ( Exception e ) { } assertIndexedNone ( cfs , colName , <int> ) ; } @Test public void testDeleteKeysIndex ( ) throws Exception { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_KEYS_INDEX ) ; ByteBuffer colName = ByteBufferUtil . bytes ( <str> ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; RowUpdateBuilder . deleteRow ( cfs . metadata , <int> , <str> ) . applyUnsafe ( ) ; try { Thread . sleep ( <int> ) ; } catch ( Exception e ) { } assertIndexedNone ( cfs , colName , <int> ) ; } @Test public void testIndexScanWithLimitOne ( ) { ColumnFamilyStore cfs = Keyspace . open ( KEYSPACE1 ) . getColumnFamilyStore ( WITH_COMPOSITE_INDEX ) ; Mutation rm ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; Util . getOnlyRow ( Util . cmd ( cfs ) . filterOn ( <str> , Operator . EQ , <int> ) . filterOn ( <str> , Operator . EQ , <int> ) . withLimit ( <int> ) . build ( ) ) ; } @Test public void testIndexCreate ( ) throws IOException , InterruptedException , ExecutionException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( COMPOSITE_INDEX_TO_BE_ADDED ) ; new RowUpdateBuilder ( cfs . metadata , <int> , <str> ) . clustering ( <str> ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; String indexName = <str> ; ColumnDefinition old = cfs . metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; IndexMetadata indexDef = IndexMetadata . fromIndexTargets ( cfs . metadata , Collections . singletonList ( new IndexTarget ( old . name , IndexTarget . Type . VALUES ) ) , indexName , IndexMetadata . Kind . COMPOSITES , Collections . EMPTY_MAP ) ; cfs . metadata . indexes ( cfs . metadata . getIndexes ( ) . with ( indexDef ) ) ; Future < ? > future = cfs . indexManager . addIndex ( indexDef ) ; future . get ( ) ; boolean flushed = false ; ColumnFamilyStore indexCfs = cfs . indexManager . getIndex ( indexDef ) . getBackingTable ( ) . orElseThrow ( throwAssert ( <str> ) ) ; flushed = ! indexCfs . getLiveSSTables ( ) . isEmpty ( ) ; assertTrue ( flushed ) ; assertIndexedOne ( cfs , ByteBufferUtil . bytes ( <str> ) , <int> ) ; assertTrue ( cfs . getBuiltIndexes ( ) . contains ( indexName ) ) ; cfs . indexManager . removeIndex ( indexDef . name ) ; assertFalse ( cfs . getBuiltIndexes ( ) . contains ( indexName ) ) ; future = cfs . indexManager . addIndex ( indexDef ) ; future . get ( ) ; assertIndexedOne ( cfs , ByteBufferUtil . bytes ( <str> ) , <int> ) ; } @Test public void testKeysSearcherSimple ( ) throws Exception { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( WITH_KEYS_INDEX ) ; for ( int i = <int> ; i < <int> ; i + + ) new RowUpdateBuilder ( cfs . metadata , <int> , <str> + i ) . noRowMarker ( ) . add ( <str> , <int> ) . build ( ) . applyUnsafe ( ) ; assertIndexedCount ( cfs , ByteBufferUtil . bytes ( <str> ) , <int> , <int> ) ; cfs . forceBlockingFlush ( ) ; assertIndexedCount ( cfs , ByteBufferUtil . bytes ( <str> ) , <int> , <int> ) ; } private void assertIndexedNone ( ColumnFamilyStore cfs , ByteBuffer col , Object val ) { assertIndexedCount ( cfs , col , val , <int> ) ; } private void assertIndexedOne ( ColumnFamilyStore cfs , ByteBuffer col , Object val ) { assertIndexedCount ( cfs , col , val , <int> ) ; } private void assertIndexedCount ( ColumnFamilyStore cfs , ByteBuffer col , Object val , int count ) { ColumnDefinition cdef = cfs . metadata . getColumnDefinition ( col ) ; ReadCommand rc = Util . cmd ( cfs ) . filterOn ( cdef . name . toString ( ) , Operator . EQ , ( ( AbstractType ) cdef . cellValueType ( ) ) . decompose ( val ) ) . build ( ) ; Index . Searcher searcher = cfs . indexManager . getBestIndexFor ( rc ) . searcherFor ( rc ) ; if ( count ! = <int> ) assertNotNull ( searcher ) ; try ( ReadExecutionController executionController = rc . executionController ( ) ; PartitionIterator iter = UnfilteredPartitionIterators . filter ( searcher . search ( executionController ) , FBUtilities . nowInSeconds ( ) ) ) { assertEquals ( count , Util . size ( iter ) ) ; } } } 
