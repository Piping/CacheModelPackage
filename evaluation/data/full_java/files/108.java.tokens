package org . apache . cassandra . concurrent ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentSkipListMap ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicLong ; import static org . apache . cassandra . concurrent . SEPWorker . Work ; public class SharedExecutorPool { public static final SharedExecutorPool SHARED = new SharedExecutorPool ( <str> ) ; final String poolName ; final AtomicLong workerId = new AtomicLong ( ) ; final List < SEPExecutor > executors = new CopyOnWriteArrayList < > ( ) ; final AtomicInteger spinningCount = new AtomicInteger ( ) ; final AtomicLong stopCheck = new AtomicLong ( ) ; final ConcurrentSkipListMap < Long , SEPWorker > spinning = new ConcurrentSkipListMap < > ( ) ; final ConcurrentSkipListMap < Long , SEPWorker > descheduled = new ConcurrentSkipListMap < > ( ) ; public SharedExecutorPool ( String poolName ) { this . poolName = poolName ; } void schedule ( Work work ) { Map . Entry < Long , SEPWorker > e ; while ( null ! = ( e = spinning . pollFirstEntry ( ) ) | | null ! = ( e = descheduled . pollFirstEntry ( ) ) ) if ( e . getValue ( ) . assign ( work , false ) ) return ; if ( ! work . isStop ( ) ) new SEPWorker ( workerId . incrementAndGet ( ) , work , this ) ; } void maybeStartSpinningWorker ( ) { int current = spinningCount . get ( ) ; if ( current = = <int> & & spinningCount . compareAndSet ( <int> , <int> ) ) schedule ( Work . SPINNING ) ; } public TracingAwareExecutorService newExecutor ( int maxConcurrency , int maxQueuedTasks , String jmxPath , String name ) { SEPExecutor executor = new SEPExecutor ( this , maxConcurrency , maxQueuedTasks , jmxPath , name ) ; executors . add ( executor ) ; return executor ; } } 
