package org . apache . cassandra . cql3 . validation . entities ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . Callable ; import java . util . concurrent . CountDownLatch ; import org . apache . commons . lang3 . StringUtils ; import org . junit . Test ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . statements . IndexTarget ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DeletionTime ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . rows . Cell ; import org . apache . cassandra . db . rows . Row ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . SyntaxException ; import org . apache . cassandra . index . IndexNotAvailableException ; import org . apache . cassandra . index . SecondaryIndexManager ; import org . apache . cassandra . index . StubIndex ; import org . apache . cassandra . index . internal . CustomCassandraIndex ; import org . apache . cassandra . schema . IndexMetadata ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . transport . messages . ResultMessage ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . MD5Digest ; import org . apache . cassandra . utils . Pair ; import static org . apache . cassandra . Util . throwAssert ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class SecondaryIndexTest extends CQLTester { private static final int TOO_BIG = <int> * <int> ; @Test public void testCreateAndDropIndex ( ) throws Throwable { testCreateAndDropIndex ( <str> , false ) ; testCreateAndDropIndex ( <str> , true ) ; } @Test public void testCreateAndDropIndexWithQuotedIdentifier ( ) throws Throwable { testCreateAndDropIndex ( <str> , false ) ; testCreateAndDropIndex ( <str> , true ) ; } @Test public void testCreateAndDropIndexWithCamelCaseIdentifier ( ) throws Throwable { testCreateAndDropIndex ( <str> , false ) ; testCreateAndDropIndex ( <str> , true ) ; } private void testCreateAndDropIndex ( String indexName , boolean addKeyspaceOnDrop ) throws Throwable { execute ( <str> ) ; assertInvalidMessage ( String . format ( <str> , removeQuotes ( indexName . toLowerCase ( Locale . US ) ) ) , <str> + indexName + <str> ) ; createTable ( <str> ) ; createIndex ( <str> + indexName + <str> ) ; createIndex ( <str> + indexName + <str> ) ; assertInvalidMessage ( String . format ( <str> , removeQuotes ( indexName . toLowerCase ( Locale . US ) ) ) , <str> + indexName + <str> ) ; String otherIndexName = <str> + System . nanoTime ( ) ; assertInvalidMessage ( String . format ( <str> , removeQuotes ( otherIndexName . toLowerCase ( Locale . US ) ) , removeQuotes ( indexName . toLowerCase ( Locale . US ) ) ) , <str> + otherIndexName + <str> ) ; execute ( <str> , <int> , <int> ) ; execute ( <str> , <int> , <int> ) ; execute ( <str> , <int> , <int> ) ; execute ( <str> , <int> , <int> ) ; assertRows ( execute ( <str> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertInvalidMessage ( String . format ( <str> , removeQuotes ( indexName . toLowerCase ( Locale . US ) ) ) , <str> + indexName ) ; if ( addKeyspaceOnDrop ) { dropIndex ( <str> + KEYSPACE + <str> + indexName ) ; } else { execute ( <str> + KEYSPACE ) ; execute ( <str> + indexName ) ; } assertInvalidMessage ( <str> , <str> , <int> ) ; dropIndex ( <str> + indexName ) ; assertInvalidMessage ( String . format ( <str> , removeQuotes ( indexName . toLowerCase ( Locale . US ) ) ) , <str> + indexName ) ; } private static String removeQuotes ( String indexName ) { return StringUtils . remove ( indexName , <str> ) ; } @Test public void testSelectWithEQ ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; UUID id1 = UUID . fromString ( <str> ) ; UUID id2 = UUID . fromString ( <str> ) ; execute ( <str> , id1 ) ; execute ( <str> , id2 ) ; assertEmpty ( execute ( <str> , id1 ) ) ; assertRows ( execute ( <str> , id2 ) , row ( <str> ) ) ; } @Test public void testNamelessIndex ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <str> ) , row ( <str> ) ) ; execute ( <str> ) ; assertInvalid ( <str> ) ; } @Test public void testRangeQuery ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> ) ; execute ( <str> , <int> , <int> , <int> ) ; assertInvalid ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) ) ; } @Test public void testUnknownCompressionOptions ( ) throws Throwable { String tableName = createTableName ( ) ; assertInvalidThrow ( SyntaxException . class , String . format ( <str> , tableName ) ) ; assertInvalidThrow ( ConfigurationException . class , String . format ( <str> , tableName ) ) ; } @Test public void testDataCenterName ( ) throws Throwable { execute ( <str> ) ; } @Test public void testIndexOnComposite ( ) throws Throwable { String tableName = createTable ( <str> ) ; execute ( <str> , <int> , <int> , <str> , <str> ) ; execute ( <str> , <int> , <int> , <str> , <str> ) ; execute ( <str> , <int> , <int> , <str> , <str> ) ; execute ( <str> , <int> , <int> , <str> , <str> ) ; execute ( <str> , <int> , <int> , <str> , <str> ) ; createIndex ( <str> ) ; assertTrue ( waitForIndex ( keyspace ( ) , tableName , <str> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; execute ( <str> , <int> , <int> , <str> , <str> ) ; execute ( <str> , <int> , <int> , <str> , <str> ) ; execute ( <str> , <int> , <int> , <str> , <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; } @Test public void testInvalidIndexSelect ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; createIndex ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertInvalid ( <str> ) ; createTable ( <str> ) ; createIndex ( <str> ) ; assertInvalid ( <str> ) ; } @Test public void testIndexesOnComplexPrimaryKey ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> ) ) ; } @Test public void testIndexOnCompoundRowKey ( ) throws Throwable { createTable ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <str> , <int> , <int> , <int> ) ) ; } @Test public void testIndexOnCountersInvalid ( ) throws Throwable { createTable ( <str> ) ; assertInvalid ( <str> ) ; } @Test public void testIndexOnCollections ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; createIndex ( <str> ) ; createIndex ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertEmpty ( execute ( <str> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) ) ; assertEmpty ( execute ( <str> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) ) ; assertEmpty ( execute ( <str> ) ) ; } @Test public void testIndexOnMapKeys ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) , row ( <int> , <int> ) ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> ) ) ; assertEmpty ( execute ( <str> ) ) ; } @Test public void testIndexOnKeyWithReverseClustering ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) , row ( <int> , <int> , <int> ) ) ; } @Test public void testSelectCountOnIndexedColumn ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; createIndex ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> L ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <int> ) ) ; } @Test public void testSyntaxVariationsForIndexOnCollectionsValue ( ) throws Throwable { createTable ( <str> ) ; createAndDropCollectionValuesIndex ( <str> ) ; createAndDropCollectionValuesIndex ( <str> ) ; createAndDropCollectionValuesIndex ( <str> ) ; } private void createAndDropCollectionValuesIndex ( String columnName ) throws Throwable { String indexName = columnName + <str> ; SecondaryIndexManager indexManager = getCurrentColumnFamilyStore ( ) . indexManager ; createIndex ( String . format ( <str> , indexName , columnName ) ) ; IndexMetadata indexDef = indexManager . getIndexByName ( indexName ) . getIndexMetadata ( ) ; assertEquals ( String . format ( <str> , columnName ) , indexDef . options . get ( IndexTarget . TARGET_OPTION_NAME ) ) ; dropIndex ( String . format ( <str> , KEYSPACE , indexName ) ) ; assertFalse ( indexManager . hasIndexes ( ) ) ; createIndex ( String . format ( <str> , indexName , columnName ) ) ; assertEquals ( indexDef , indexManager . getIndexByName ( indexName ) . getIndexMetadata ( ) ) ; dropIndex ( String . format ( <str> , KEYSPACE , indexName ) ) ; } @Test public void testCreateIndexWithQuotedColumnNames ( ) throws Throwable { createTable ( <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ) ; createAndDropIndexWithQuotedColumnIdentifier ( <str> ) ; createAndDropIndexWithQuotedColumnIdentifier ( <str> ) ; createAndDropIndexWithQuotedColumnIdentifier ( <str> ) ; createAndDropIndexWithQuotedColumnIdentifier ( <str> ) ; createAndDropIndexWithQuotedColumnIdentifier ( <str> ) ; createAndDropIndexWithQuotedColumnIdentifier ( <str> ) ; createAndDropIndexWithQuotedColumnIdentifier ( <str> ) ; } private void createAndDropIndexWithQuotedColumnIdentifier ( String target ) throws Throwable { String indexName = <str> ; createIndex ( String . format ( <str> , indexName , target ) ) ; SecondaryIndexManager indexManager = getCurrentColumnFamilyStore ( ) . indexManager ; IndexMetadata indexDef = indexManager . getIndexByName ( indexName ) . getIndexMetadata ( ) ; dropIndex ( String . format ( <str> , KEYSPACE , indexName ) ) ; createIndex ( String . format ( <str> , indexName , indexDef . options . get ( IndexTarget . TARGET_OPTION_NAME ) ) ) ; assertEquals ( indexDef , indexManager . getIndexByName ( indexName ) . getIndexMetadata ( ) ) ; dropIndex ( String . format ( <str> , KEYSPACE , indexName ) ) ; } @Test public void testCanQuerySecondaryIndex ( ) throws Throwable { String tableName = createTable ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; createIndex ( <str> ) ; assertTrue ( waitForIndex ( keyspace ( ) , tableName , <str> ) ) ; assertRows ( execute ( <str> ) , row ( <int> ) ) ; cleanupCache ( ) ; assertRows ( execute ( <str> ) , row ( <int> ) ) ; } @Test public void testIndexOnCompositeValueOver64k ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; failInsert ( <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; failInsert ( <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; failInsert ( <str> + <str> + <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; failInsert ( <str> + <str> + <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; } @Test public void testCompactTableWithValueOver64k ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; failInsert ( <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; failInsert ( <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; failInsert ( <str> + <str> + <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; failInsert ( <str> + <str> + <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; } @Test public void testIndexOnPartitionKeyInsertValueOver64k ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; succeedInsert ( <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; succeedInsert ( <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; succeedInsert ( <str> + <str> + <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; long batchSizeThreshold = DatabaseDescriptor . getBatchSizeFailThreshold ( ) ; try { DatabaseDescriptor . setBatchSizeFailThresholdInKB ( ( TOO_BIG / <int> ) * <int> ) ; succeedInsert ( <str> + <str> + <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; } finally { DatabaseDescriptor . setBatchSizeFailThresholdInKB ( ( int ) ( batchSizeThreshold / <int> ) ) ; } } @Test public void testIndexOnClusteringColumnInsertValueOver64k ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; succeedInsert ( <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; succeedInsert ( <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; succeedInsert ( <str> + <str> + <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; long batchSizeThreshold = DatabaseDescriptor . getBatchSizeFailThreshold ( ) ; try { DatabaseDescriptor . setBatchSizeFailThresholdInKB ( ( TOO_BIG / <int> ) * <int> ) ; succeedInsert ( <str> + <str> + <str> , ByteBuffer . allocate ( TOO_BIG ) ) ; } finally { DatabaseDescriptor . setBatchSizeFailThresholdInKB ( ( int ) ( batchSizeThreshold / <int> ) ) ; } } @Test public void testIndexOnFullCollectionEntryInsertCollectionValueOver64k ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; Map < Integer , ByteBuffer > map = new HashMap < > ( ) ; map . put ( <int> , ByteBuffer . allocate ( <int> * <int> ) ) ; failInsert ( <str> , map ) ; failInsert ( <str> , map ) ; failInsert ( <str> + <str> + <str> , map ) ; failInsert ( <str> + <str> + <str> , map ) ; } public void failInsert ( String insertCQL , Object . . . args ) throws Throwable { try { execute ( insertCQL , args ) ; fail ( <str> ) ; } catch ( Exception e ) { } } public void succeedInsert ( String insertCQL , Object . . . args ) throws Throwable { execute ( insertCQL , args ) ; flush ( ) ; } @Test public void testIndexesOnClustering ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <str> ) , row ( <str> ) ) ; assertRows ( execute ( <str> ) , row ( <str> ) , row ( <str> ) ) ; assertRows ( execute ( <str> ) , row ( <str> ) ) ; execute ( <str> ) ; assertRows ( execute ( <str> ) , row ( <str> ) , row ( <str> ) , row ( <str> ) ) ; assertRows ( execute ( <str> ) , row ( <str> ) , row ( <str> ) ) ; } @Test public void testIndexesOnClusteringInvalid ( ) throws Throwable { createTable ( <str> ) ; assertInvalid ( <str> ) ; assertInvalid ( <str> ) ; createTable ( <str> ) ; assertInvalid ( <str> ) ; assertInvalid ( <str> ) ; assertInvalid ( <str> ) ; createTable ( <str> ) ; assertInvalid ( <str> ) ; } @Test public void testMultipleIndexesOnOneColumn ( ) throws Throwable { String indexClassName = StubIndex . class . getName ( ) ; createTable ( <str> ) ; createIndex ( String . format ( <str> , indexClassName ) ) ; createIndex ( String . format ( <str> , indexClassName ) ) ; ColumnFamilyStore cfs = getCurrentColumnFamilyStore ( ) ; CFMetaData cfm = cfs . metadata ; StubIndex index1 = ( StubIndex ) cfs . indexManager . getIndex ( cfm . getIndexes ( ) . get ( <str> ) . orElseThrow ( throwAssert ( <str> ) ) ) ; StubIndex index2 = ( StubIndex ) cfs . indexManager . getIndex ( cfm . getIndexes ( ) . get ( <str> ) . orElseThrow ( throwAssert ( <str> ) ) ) ; Object [ ] row1a = row ( <int> , <int> , <int> ) ; Object [ ] row1b = row ( <int> , <int> , <int> ) ; Object [ ] row2 = row ( <int> , <int> , <int> ) ; execute ( <str> , row1a ) ; execute ( <str> , row1b ) ; execute ( <str> , row2 ) ; assertEquals ( <int> , index1 . rowsInserted . size ( ) ) ; assertColumnValue ( <int> , <str> , index1 . rowsInserted . get ( <int> ) , cfm ) ; assertColumnValue ( <int> , <str> , index1 . rowsInserted . get ( <int> ) , cfm ) ; assertEquals ( <int> , index2 . rowsInserted . size ( ) ) ; assertColumnValue ( <int> , <str> , index2 . rowsInserted . get ( <int> ) , cfm ) ; assertColumnValue ( <int> , <str> , index2 . rowsInserted . get ( <int> ) , cfm ) ; assertEquals ( <int> , index1 . rowsUpdated . size ( ) ) ; assertColumnValue ( <int> , <str> , index1 . rowsUpdated . get ( <int> ) . left , cfm ) ; assertColumnValue ( <int> , <str> , index1 . rowsUpdated . get ( <int> ) . right , cfm ) ; assertEquals ( <int> , index2 . rowsUpdated . size ( ) ) ; assertColumnValue ( <int> , <str> , index2 . rowsUpdated . get ( <int> ) . left , cfm ) ; assertColumnValue ( <int> , <str> , index2 . rowsUpdated . get ( <int> ) . right , cfm ) ; } @Test public void testDeletions ( ) throws Throwable { String indexClassName = StubIndex . class . getName ( ) ; createTable ( <str> ) ; createIndex ( String . format ( <str> , indexClassName ) ) ; ColumnFamilyStore cfs = getCurrentColumnFamilyStore ( ) ; CFMetaData cfm = cfs . metadata ; StubIndex index1 = ( StubIndex ) cfs . indexManager . getIndex ( cfm . getIndexes ( ) . get ( <str> ) . orElseThrow ( throwAssert ( <str> ) ) ) ; execute ( <str> , <int> , <int> , <int> ) ; assertEquals ( <int> , index1 . rowsInserted . size ( ) ) ; execute ( <str> , <int> , <int> ) ; assertEquals ( <int> , index1 . rowsUpdated . size ( ) ) ; Pair < Row , Row > update = index1 . rowsUpdated . get ( <int> ) ; Row existingRow = update . left ; Row newRow = update . right ; assertTrue ( existingRow . deletion ( ) . isLive ( ) ) ; assertEquals ( DeletionTime . LIVE , existingRow . deletion ( ) . time ( ) ) ; assertEquals ( <int> , existingRow . primaryKeyLivenessInfo ( ) . timestamp ( ) ) ; assertFalse ( newRow . deletion ( ) . isLive ( ) ) ; assertEquals ( <int> , newRow . deletion ( ) . time ( ) . markedForDeleteAt ( ) ) ; assertFalse ( newRow . cells ( ) . iterator ( ) . hasNext ( ) ) ; execute ( <str> , <int> , <int> ) ; assertEquals ( <int> , index1 . rowsUpdated . size ( ) ) ; update = index1 . rowsUpdated . get ( <int> ) ; existingRow = update . left ; newRow = update . right ; assertFalse ( existingRow . deletion ( ) . isLive ( ) ) ; assertEquals ( <int> , existingRow . deletion ( ) . time ( ) . markedForDeleteAt ( ) ) ; assertFalse ( existingRow . cells ( ) . iterator ( ) . hasNext ( ) ) ; assertFalse ( newRow . deletion ( ) . isLive ( ) ) ; assertEquals ( <int> , newRow . deletion ( ) . time ( ) . markedForDeleteAt ( ) ) ; assertFalse ( newRow . cells ( ) . iterator ( ) . hasNext ( ) ) ; } @Test public void testUpdatesToMemtableData ( ) throws Throwable { createTable ( <str> ) ; createIndex ( String . format ( <str> , StubIndex . class . getName ( ) ) ) ; execute ( <str> ) ; ColumnDefinition v1 = getCurrentColumnFamilyStore ( ) . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , true ) ) ; ColumnDefinition v2 = getCurrentColumnFamilyStore ( ) . metadata . getColumnDefinition ( new ColumnIdentifier ( <str> , true ) ) ; StubIndex index = ( StubIndex ) getCurrentColumnFamilyStore ( ) . indexManager . getIndexByName ( <str> ) ; assertEquals ( <int> , index . rowsInserted . size ( ) ) ; execute ( <str> ) ; assertEquals ( <int> , index . rowsUpdated . size ( ) ) ; Row oldRow = index . rowsUpdated . get ( <int> ) . left ; assertEquals ( <int> , oldRow . size ( ) ) ; validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( <int> ) , <int> ) ; Row newRow = index . rowsUpdated . get ( <int> ) . right ; assertEquals ( <int> , newRow . size ( ) ) ; validateCell ( newRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( <int> ) , <int> ) ; index . reset ( ) ; execute ( <str> ) ; assertEquals ( <int> , index . rowsUpdated . size ( ) ) ; oldRow = index . rowsUpdated . get ( <int> ) . left ; assertEquals ( <int> , oldRow . size ( ) ) ; validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( <int> ) , <int> ) ; validateCell ( oldRow . getCell ( v2 ) , v2 , ByteBufferUtil . bytes ( <int> ) , <int> ) ; newRow = index . rowsUpdated . get ( <int> ) . right ; assertEquals ( <int> , newRow . size ( ) ) ; validateCell ( newRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( <int> ) , <int> ) ; validateCell ( newRow . getCell ( v2 ) , v2 , ByteBufferUtil . bytes ( <int> ) , <int> ) ; index . reset ( ) ; execute ( <str> ) ; assertEquals ( <int> , index . rowsUpdated . size ( ) ) ; oldRow = index . rowsUpdated . get ( <int> ) . left ; assertEquals ( <int> , oldRow . size ( ) ) ; validateCell ( oldRow . getCell ( v1 ) , v1 , ByteBufferUtil . bytes ( <int> ) , <int> ) ; newRow = index . rowsUpdated . get ( <int> ) . right ; assertEquals ( <int> , newRow . size ( ) ) ; Cell newCell = newRow . getCell ( v1 ) ; assertTrue ( newCell . isTombstone ( ) ) ; assertEquals ( <int> , newCell . timestamp ( ) ) ; index . reset ( ) ; execute ( <str> ) ; assertEquals ( <int> , index . rowsUpdated . size ( ) ) ; oldRow = index . rowsUpdated . get ( <int> ) . left ; assertEquals ( <int> , oldRow . size ( ) ) ; assertEquals ( <int> , oldRow . primaryKeyLivenessInfo ( ) . timestamp ( ) ) ; newRow = index . rowsUpdated . get ( <int> ) . right ; assertEquals ( <int> , newRow . size ( ) ) ; assertEquals ( <int> , newRow . primaryKeyLivenessInfo ( ) . timestamp ( ) ) ; } @Test public void testIndexQueriesWithIndexNotReady ( ) throws Throwable { createTable ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) for ( int j = <int> ; j < <int> ; j + + ) execute ( <str> , i , j , i + j ) ; createIndex ( <str> + IndexBlockingOnInitialization . class . getName ( ) + <str> ) ; try { execute ( <str> ) ; fail ( ) ; } catch ( IndexNotAvailableException e ) { assertTrue ( true ) ; } finally { execute ( <str> + KEYSPACE + <str> ) ; } } @Test public void droppingIndexInvalidatesPreparedStatements ( ) throws Throwable { createTable ( <str> ) ; createIndex ( <str> ) ; MD5Digest cqlId = prepareStatement ( <str> , false ) . statementId ; Integer thriftId = prepareStatement ( <str> , true ) . toThriftPreparedResult ( ) . getItemId ( ) ; assertNotNull ( QueryProcessor . instance . getPrepared ( cqlId ) ) ; assertNotNull ( QueryProcessor . instance . getPreparedForThrift ( thriftId ) ) ; dropIndex ( <str> ) ; assertNull ( QueryProcessor . instance . getPrepared ( cqlId ) ) ; assertNull ( QueryProcessor . instance . getPreparedForThrift ( thriftId ) ) ; } private ResultMessage . Prepared prepareStatement ( String cql , boolean forThrift ) { return QueryProcessor . prepare ( String . format ( cql , KEYSPACE , currentTable ( ) ) , ClientState . forInternalCalls ( ) , forThrift ) ; } private void validateCell ( Cell cell , ColumnDefinition def , ByteBuffer val , long timestamp ) { assertNotNull ( cell ) ; assertEquals ( <int> , def . type . compare ( cell . value ( ) , val ) ) ; assertEquals ( timestamp , cell . timestamp ( ) ) ; } private static void assertColumnValue ( int expected , String name , Row row , CFMetaData cfm ) { ColumnDefinition col = cfm . getColumnDefinition ( new ColumnIdentifier ( name , true ) ) ; AbstractType < ? > type = col . type ; assertEquals ( expected , type . compose ( row . getCell ( col ) . value ( ) ) ) ; } public static class IndexBlockingOnInitialization extends CustomCassandraIndex { private final CountDownLatch latch = new CountDownLatch ( <int> ) ; public IndexBlockingOnInitialization ( ColumnFamilyStore baseCfs , IndexMetadata indexDef ) { super ( baseCfs , indexDef ) ; } @Override public Callable < ? > getInitializationTask ( ) { return ( ) - > { latch . await ( ) ; return null ; } ; } @Override public Callable < ? > getInvalidateTask ( ) { latch . countDown ( ) ; return super . getInvalidateTask ( ) ; } } } 
