package io . netty . channel . local ; import io . netty . bootstrap . Bootstrap ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . AbstractChannel ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultEventLoopGroup ; import io . netty . channel . EventLoop ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . SingleThreadEventLoop ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . concurrent . Future ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import org . junit . Test ; import java . nio . channels . ClosedChannelException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executor ; import java . util . concurrent . atomic . AtomicReference ; import static java . util . concurrent . TimeUnit . SECONDS ; import static org . hamcrest . CoreMatchers . instanceOf ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNull ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; public class LocalChannelTest { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( LocalChannelTest . class ) ; private static final LocalAddress TEST_ADDRESS = new LocalAddress ( <str> ) ; private static EventLoopGroup group1 ; private static EventLoopGroup group2 ; private static EventLoopGroup sharedGroup ; @BeforeClass public static void beforeClass ( ) { group1 = new DefaultEventLoopGroup ( <int> ) ; group2 = new DefaultEventLoopGroup ( <int> ) ; sharedGroup = new DefaultEventLoopGroup ( <int> ) ; } @AfterClass public static void afterClass ( ) throws InterruptedException { Future < ? > group1Future = group1 . shutdownGracefully ( <int> , <int> , SECONDS ) ; Future < ? > group2Future = group2 . shutdownGracefully ( <int> , <int> , SECONDS ) ; Future < ? > sharedGroupFuture = sharedGroup . shutdownGracefully ( <int> , <int> , SECONDS ) ; group1Future . await ( ) ; group2Future . await ( ) ; sharedGroupFuture . await ( ) ; } @Test public void testLocalAddressReuse ( ) throws Exception { for ( int i = <int> ; i < <int> ; i + + ) { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; cb . group ( group1 ) . channel ( LocalChannel . class ) . handler ( new TestHandler ( ) ) ; sb . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new TestHandler ( ) ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . sync ( ) . channel ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; cc = cb . connect ( sc . localAddress ( ) ) . sync ( ) . channel ( ) ; final Channel ccCpy = cc ; cc . eventLoop ( ) . execute ( new Runnable ( ) { @Override public void run ( ) { ccCpy . pipeline ( ) . fireChannelRead ( <str> ) ; latch . countDown ( ) ; } } ) ; assertTrue ( latch . await ( <int> , SECONDS ) ) ; closeChannel ( cc ) ; closeChannel ( sc ) ; sc . closeFuture ( ) . sync ( ) ; assertNull ( String . format ( <str> , LocalChannelRegistry . get ( TEST_ADDRESS ) , TEST_ADDRESS ) , LocalChannelRegistry . get ( TEST_ADDRESS ) ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } } @Test public void testWriteFailsFastOnClosedChannel ( ) throws Exception { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; cb . group ( group1 ) . channel ( LocalChannel . class ) . handler ( new TestHandler ( ) ) ; sb . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new TestHandler ( ) ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . sync ( ) . channel ( ) ; cc = cb . connect ( sc . localAddress ( ) ) . sync ( ) . channel ( ) ; cc . close ( ) . sync ( ) ; try { cc . writeAndFlush ( new Object ( ) ) . sync ( ) ; fail ( <str> ) ; } catch ( Exception e ) { assertThat ( e , is ( instanceOf ( ClosedChannelException . class ) ) ) ; if ( e . getStackTrace ( ) . length > <int> ) { assertThat ( e . getStackTrace ( ) [ <int> ] . getClassName ( ) , is ( AbstractChannel . class . getName ( ) + <str> ) ) ; e . printStackTrace ( ) ; } } } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } @Test public void testServerCloseChannelSameEventLoop ( ) throws Exception { final CountDownLatch latch = new CountDownLatch ( <int> ) ; ServerBootstrap sb = new ServerBootstrap ( ) . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new SimpleChannelInboundHandler < Object > ( ) { @Override protected void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { ctx . close ( ) ; latch . countDown ( ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . sync ( ) . channel ( ) ; Bootstrap b = new Bootstrap ( ) . group ( group2 ) . channel ( LocalChannel . class ) . handler ( new SimpleChannelInboundHandler < Object > ( ) { @Override protected void channelRead0 ( ChannelHandlerContext ctx , Object msg ) throws Exception { } } ) ; cc = b . connect ( sc . localAddress ( ) ) . sync ( ) . channel ( ) ; cc . writeAndFlush ( new Object ( ) ) ; assertTrue ( latch . await ( <int> , SECONDS ) ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } @Test public void localChannelRaceCondition ( ) throws Exception { final CountDownLatch closeLatch = new CountDownLatch ( <int> ) ; final EventLoopGroup clientGroup = new DefaultEventLoopGroup ( <int> ) { @Override protected EventLoop newChild ( Executor threadFactory , Object . . . args ) throws Exception { return new SingleThreadEventLoop ( this , threadFactory , true ) { @Override protected void run ( ) { for ( ; ; ) { Runnable task = takeTask ( ) ; if ( task ! = null ) { if ( task . getClass ( ) . getEnclosingClass ( ) = = LocalChannel . class ) { try { closeLatch . await ( ) ; } catch ( InterruptedException e ) { throw new Error ( e ) ; } } task . run ( ) ; updateLastExecutionTime ( ) ; } if ( confirmShutdown ( ) ) { break ; } } } } ; } } ; Channel sc = null ; Channel cc = null ; try { ServerBootstrap sb = new ServerBootstrap ( ) ; sc = sb . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { ch . close ( ) ; closeLatch . countDown ( ) ; } } ) . bind ( TEST_ADDRESS ) . sync ( ) . channel ( ) ; Bootstrap bootstrap = new Bootstrap ( ) ; bootstrap . group ( clientGroup ) . channel ( LocalChannel . class ) . handler ( new ChannelInitializer < Channel > ( ) { @Override protected void initChannel ( Channel ch ) throws Exception { } } ) ; ChannelFuture future = bootstrap . connect ( sc . localAddress ( ) ) ; assertTrue ( <str> , future . await ( <int> ) ) ; cc = future . channel ( ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; clientGroup . shutdownGracefully ( <int> , <int> , SECONDS ) . await ( ) ; } } @Test public void testReRegister ( ) { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; cb . group ( group1 ) . channel ( LocalChannel . class ) . handler ( new TestHandler ( ) ) ; sb . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new TestHandler ( ) ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . syncUninterruptibly ( ) . channel ( ) ; cc = cb . connect ( sc . localAddress ( ) ) . syncUninterruptibly ( ) . channel ( ) ; cc . deregister ( ) . syncUninterruptibly ( ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } @Test public void testCloseInWritePromiseCompletePreservesOrder ( ) throws InterruptedException { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; final CountDownLatch messageLatch = new CountDownLatch ( <int> ) ; final ByteBuf data = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; try { cb . group ( group1 ) . channel ( LocalChannel . class ) . handler ( new TestHandler ( ) ) ; sb . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( msg . equals ( data ) ) { ReferenceCountUtil . safeRelease ( msg ) ; messageLatch . countDown ( ) ; } else { super . channelRead ( ctx , msg ) ; } } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { messageLatch . countDown ( ) ; super . channelInactive ( ctx ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . syncUninterruptibly ( ) . channel ( ) ; cc = cb . connect ( sc . localAddress ( ) ) . syncUninterruptibly ( ) . channel ( ) ; final Channel ccCpy = cc ; cc . pipeline ( ) . lastContext ( ) . executor ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { ChannelPromise promise = ccCpy . newPromise ( ) ; promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { ccCpy . pipeline ( ) . lastContext ( ) . close ( ) ; } } ) ; ccCpy . writeAndFlush ( data . duplicate ( ) . retain ( ) , promise ) ; } } ) ; assertTrue ( messageLatch . await ( <int> , SECONDS ) ) ; assertFalse ( cc . isOpen ( ) ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } finally { data . release ( ) ; } } @Test public void testWriteInWritePromiseCompletePreservesOrder ( ) throws InterruptedException { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; final CountDownLatch messageLatch = new CountDownLatch ( <int> ) ; final ByteBuf data = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; final ByteBuf data2 = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; try { cb . group ( group1 ) . channel ( LocalChannel . class ) . handler ( new TestHandler ( ) ) ; sb . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { final long count = messageLatch . getCount ( ) ; if ( ( data . equals ( msg ) & & count = = <int> ) | | ( data2 . equals ( msg ) & & count = = <int> ) ) { ReferenceCountUtil . safeRelease ( msg ) ; messageLatch . countDown ( ) ; } else { super . channelRead ( ctx , msg ) ; } } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . syncUninterruptibly ( ) . channel ( ) ; cc = cb . connect ( sc . localAddress ( ) ) . syncUninterruptibly ( ) . channel ( ) ; final Channel ccCpy = cc ; cc . pipeline ( ) . lastContext ( ) . executor ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { ChannelPromise promise = ccCpy . newPromise ( ) ; promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { ccCpy . writeAndFlush ( data2 . duplicate ( ) . retain ( ) , ccCpy . newPromise ( ) ) ; } } ) ; ccCpy . writeAndFlush ( data . duplicate ( ) . retain ( ) , promise ) ; } } ) ; assertTrue ( messageLatch . await ( <int> , SECONDS ) ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } finally { data . release ( ) ; data2 . release ( ) ; } } @Test public void testPeerWriteInWritePromiseCompleteDifferentEventLoopPreservesOrder ( ) throws InterruptedException { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; final CountDownLatch messageLatch = new CountDownLatch ( <int> ) ; final ByteBuf data = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; final ByteBuf data2 = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; final CountDownLatch serverChannelLatch = new CountDownLatch ( <int> ) ; final AtomicReference < Channel > serverChannelRef = new AtomicReference < Channel > ( ) ; cb . group ( group1 ) . channel ( LocalChannel . class ) . handler ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( data2 . equals ( msg ) ) { ReferenceCountUtil . safeRelease ( msg ) ; messageLatch . countDown ( ) ; } else { super . channelRead ( ctx , msg ) ; } } } ) ; sb . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( data . equals ( msg ) ) { ReferenceCountUtil . safeRelease ( msg ) ; messageLatch . countDown ( ) ; } else { super . channelRead ( ctx , msg ) ; } } } ) ; serverChannelRef . set ( ch ) ; serverChannelLatch . countDown ( ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . syncUninterruptibly ( ) . channel ( ) ; cc = cb . connect ( sc . localAddress ( ) ) . syncUninterruptibly ( ) . channel ( ) ; assertTrue ( serverChannelLatch . await ( <int> , SECONDS ) ) ; final Channel ccCpy = cc ; cc . pipeline ( ) . lastContext ( ) . executor ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { ChannelPromise promise = ccCpy . newPromise ( ) ; promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { Channel serverChannelCpy = serverChannelRef . get ( ) ; serverChannelCpy . writeAndFlush ( data2 . duplicate ( ) . retain ( ) , serverChannelCpy . newPromise ( ) ) ; } } ) ; ccCpy . writeAndFlush ( data . duplicate ( ) . retain ( ) , promise ) ; } } ) ; assertTrue ( messageLatch . await ( <int> , SECONDS ) ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; data . release ( ) ; data2 . release ( ) ; } } @Test public void testPeerWriteInWritePromiseCompleteSameEventLoopPreservesOrder ( ) throws InterruptedException { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; final CountDownLatch messageLatch = new CountDownLatch ( <int> ) ; final ByteBuf data = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; final ByteBuf data2 = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; final CountDownLatch serverChannelLatch = new CountDownLatch ( <int> ) ; final AtomicReference < Channel > serverChannelRef = new AtomicReference < Channel > ( ) ; try { cb . group ( sharedGroup ) . channel ( LocalChannel . class ) . handler ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( data2 . equals ( msg ) & & messageLatch . getCount ( ) = = <int> ) { ReferenceCountUtil . safeRelease ( msg ) ; messageLatch . countDown ( ) ; } else { super . channelRead ( ctx , msg ) ; } } } ) ; sb . group ( sharedGroup ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( data . equals ( msg ) & & messageLatch . getCount ( ) = = <int> ) { ReferenceCountUtil . safeRelease ( msg ) ; messageLatch . countDown ( ) ; } else { super . channelRead ( ctx , msg ) ; } } } ) ; serverChannelRef . set ( ch ) ; serverChannelLatch . countDown ( ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . syncUninterruptibly ( ) . channel ( ) ; cc = cb . connect ( sc . localAddress ( ) ) . syncUninterruptibly ( ) . channel ( ) ; assertTrue ( serverChannelLatch . await ( <int> , SECONDS ) ) ; final Channel ccCpy = cc ; cc . pipeline ( ) . lastContext ( ) . executor ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { ChannelPromise promise = ccCpy . newPromise ( ) ; promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { Channel serverChannelCpy = serverChannelRef . get ( ) ; serverChannelCpy . writeAndFlush ( data2 . duplicate ( ) . retain ( ) , serverChannelCpy . newPromise ( ) ) ; } } ) ; ccCpy . writeAndFlush ( data . duplicate ( ) . retain ( ) , promise ) ; } } ) ; assertTrue ( messageLatch . await ( <int> , SECONDS ) ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } finally { data . release ( ) ; data2 . release ( ) ; } } @Test public void testClosePeerInWritePromiseCompleteSameEventLoopPreservesOrder ( ) throws InterruptedException { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; final CountDownLatch messageLatch = new CountDownLatch ( <int> ) ; final CountDownLatch serverChannelLatch = new CountDownLatch ( <int> ) ; final ByteBuf data = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; final AtomicReference < Channel > serverChannelRef = new AtomicReference < Channel > ( ) ; try { cb . group ( sharedGroup ) . channel ( LocalChannel . class ) . handler ( new TestHandler ( ) ) ; sb . group ( sharedGroup ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( msg . equals ( data ) ) { ReferenceCountUtil . safeRelease ( msg ) ; messageLatch . countDown ( ) ; } else { super . channelRead ( ctx , msg ) ; } } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { messageLatch . countDown ( ) ; super . channelInactive ( ctx ) ; } } ) ; serverChannelRef . set ( ch ) ; serverChannelLatch . countDown ( ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . syncUninterruptibly ( ) . channel ( ) ; cc = cb . connect ( sc . localAddress ( ) ) . syncUninterruptibly ( ) . channel ( ) ; assertTrue ( serverChannelLatch . await ( <int> , SECONDS ) ) ; final Channel ccCpy = cc ; cc . pipeline ( ) . lastContext ( ) . executor ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { ChannelPromise promise = ccCpy . newPromise ( ) ; promise . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { serverChannelRef . get ( ) . close ( ) ; } } ) ; ccCpy . writeAndFlush ( data . duplicate ( ) . retain ( ) , promise ) ; } } ) ; assertTrue ( messageLatch . await ( <int> , SECONDS ) ) ; assertFalse ( cc . isOpen ( ) ) ; assertFalse ( serverChannelRef . get ( ) . isOpen ( ) ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } finally { data . release ( ) ; } } @Test public void testWriteWhilePeerIsClosedReleaseObjectAndFailPromise ( ) throws InterruptedException { Bootstrap cb = new Bootstrap ( ) ; ServerBootstrap sb = new ServerBootstrap ( ) ; final CountDownLatch serverMessageLatch = new CountDownLatch ( <int> ) ; final LatchChannelFutureListener serverChannelCloseLatch = new LatchChannelFutureListener ( <int> ) ; final LatchChannelFutureListener clientChannelCloseLatch = new LatchChannelFutureListener ( <int> ) ; final CountDownLatch writeFailLatch = new CountDownLatch ( <int> ) ; final ByteBuf data = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; final ByteBuf data2 = Unpooled . wrappedBuffer ( new byte [ <int> ] ) ; final CountDownLatch serverChannelLatch = new CountDownLatch ( <int> ) ; final AtomicReference < Channel > serverChannelRef = new AtomicReference < Channel > ( ) ; try { cb . group ( group1 ) . channel ( LocalChannel . class ) . handler ( new TestHandler ( ) ) ; sb . group ( group2 ) . channel ( LocalServerChannel . class ) . childHandler ( new ChannelInitializer < LocalChannel > ( ) { @Override public void initChannel ( LocalChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new ChannelInboundHandlerAdapter ( ) { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { if ( data . equals ( msg ) ) { ReferenceCountUtil . safeRelease ( msg ) ; serverMessageLatch . countDown ( ) ; } else { super . channelRead ( ctx , msg ) ; } } } ) ; serverChannelRef . set ( ch ) ; serverChannelLatch . countDown ( ) ; } } ) ; Channel sc = null ; Channel cc = null ; try { sc = sb . bind ( TEST_ADDRESS ) . syncUninterruptibly ( ) . channel ( ) ; cc = cb . connect ( sc . localAddress ( ) ) . syncUninterruptibly ( ) . channel ( ) ; assertTrue ( serverChannelLatch . await ( <int> , SECONDS ) ) ; final Channel ccCpy = cc ; final Channel serverChannelCpy = serverChannelRef . get ( ) ; serverChannelCpy . closeFuture ( ) . addListener ( serverChannelCloseLatch ) ; ccCpy . closeFuture ( ) . addListener ( clientChannelCloseLatch ) ; cc . pipeline ( ) . lastContext ( ) . executor ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { ccCpy . writeAndFlush ( data . duplicate ( ) . retain ( ) , ccCpy . newPromise ( ) ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { serverChannelCpy . eventLoop ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { int waitCount = <int> ; while ( ccCpy . isOpen ( ) ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException ignored ) { } if ( + + waitCount > <int> ) { fail ( ) ; } } serverChannelCpy . writeAndFlush ( data2 . duplicate ( ) . retain ( ) , serverChannelCpy . newPromise ( ) ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( ! future . isSuccess ( ) & & future . cause ( ) instanceof ClosedChannelException ) { writeFailLatch . countDown ( ) ; } } } ) ; } } ) ; ccCpy . close ( ) ; } } ) ; } } ) ; assertTrue ( serverMessageLatch . await ( <int> , SECONDS ) ) ; assertTrue ( writeFailLatch . await ( <int> , SECONDS ) ) ; assertTrue ( serverChannelCloseLatch . await ( <int> , SECONDS ) ) ; assertTrue ( clientChannelCloseLatch . await ( <int> , SECONDS ) ) ; assertFalse ( ccCpy . isOpen ( ) ) ; assertFalse ( serverChannelCpy . isOpen ( ) ) ; } finally { closeChannel ( cc ) ; closeChannel ( sc ) ; } } finally { data . release ( ) ; data2 . release ( ) ; } } private static final class LatchChannelFutureListener extends CountDownLatch implements ChannelFutureListener { public LatchChannelFutureListener ( int count ) { super ( count ) ; } @Override public void operationComplete ( ChannelFuture future ) throws Exception { countDown ( ) ; } } private static void closeChannel ( Channel cc ) { if ( cc ! = null ) { cc . close ( ) . syncUninterruptibly ( ) ; } } static class TestHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { logger . info ( String . format ( <str> , msg ) ) ; ReferenceCountUtil . safeRelease ( msg ) ; } } } 
