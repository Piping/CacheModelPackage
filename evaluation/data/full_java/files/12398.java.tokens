package org . gradle . api . internal . project ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . Project ; import org . gradle . api . specs . Spec ; import org . gradle . util . TestUtil ; import org . junit . Before ; import org . junit . Test ; import java . util . SortedSet ; import java . util . TreeSet ; import static junit . framework . Assert . assertSame ; import static org . gradle . util . WrapUtil . toSet ; import static org . gradle . util . WrapUtil . toSortedSet ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; public class DefaultProjectRegistryTest { public static final String CHILD_NAME = <str> ; public static final String CHILD_CHILD_NAME = <str> ; private DefaultProject rootMock ; private DefaultProject childMock ; private DefaultProject childChildMock ; private DefaultProjectRegistry < ProjectInternal > projectRegistry ; @Before public void setUp ( ) { projectRegistry = new DefaultProjectRegistry < ProjectInternal > ( ) ; rootMock = TestUtil . createRootProject ( ) ; childMock = TestUtil . createChildProject ( rootMock , CHILD_NAME ) ; childChildMock = TestUtil . createChildProject ( childMock , CHILD_CHILD_NAME ) ; projectRegistry . addProject ( rootMock ) ; projectRegistry . addProject ( childMock ) ; projectRegistry . addProject ( childChildMock ) ; } @Test public void addProject ( ) { checkAccessMethods ( rootMock , toSortedSet ( rootMock , childMock , childChildMock ) , toSortedSet ( childMock , childChildMock ) , rootMock ) ; checkAccessMethods ( childMock , toSortedSet ( childMock , childChildMock ) , toSortedSet ( childChildMock ) , childMock ) ; checkAccessMethods ( childChildMock , toSortedSet ( childChildMock ) , new TreeSet ( ) , childChildMock ) ; } private void checkAccessMethods ( Project project , SortedSet < DefaultProject > expectedAllProjects , SortedSet < DefaultProject > expectedSubProjects , Project expectedGetProject ) { assertSame ( expectedGetProject , projectRegistry . getProject ( project . getPath ( ) ) ) ; assertEquals ( expectedAllProjects , projectRegistry . getAllProjects ( project . getPath ( ) ) ) ; assertEquals ( expectedSubProjects , projectRegistry . getSubProjects ( project . getPath ( ) ) ) ; assertSame ( expectedGetProject , projectRegistry . getProject ( project . getProjectDir ( ) ) ) ; assertTrue ( projectRegistry . getAllProjects ( ) . contains ( project ) ) ; } @Test public void cannotLocateProjectsWithAmbiguousProjectDir ( ) { DefaultProject duplicateProjectDirProject = TestUtil . createChildProject ( childMock , <str> , childMock . getProjectDir ( ) ) ; projectRegistry . addProject ( duplicateProjectDirProject ) ; try { projectRegistry . getProject ( childMock . getProjectDir ( ) ) ; fail ( ) ; } catch ( InvalidUserDataException e ) { assertThat ( e . getMessage ( ) , startsWith ( <str> ) ) ; } } @Test public void accessMethodsForNonExistingsPaths ( ) { projectRegistry = new DefaultProjectRegistry < ProjectInternal > ( ) ; Project otherRoot = TestUtil . createRootProject ( ) ; assertNull ( projectRegistry . getProject ( otherRoot . getPath ( ) ) ) ; assertEquals ( new TreeSet < ProjectInternal > ( ) , projectRegistry . getAllProjects ( otherRoot . getPath ( ) ) ) ; assertEquals ( new TreeSet < ProjectInternal > ( ) , projectRegistry . getSubProjects ( otherRoot . getPath ( ) ) ) ; assertNull ( projectRegistry . getProject ( otherRoot . getProjectDir ( ) ) ) ; } @Test public void canLocalAllProjects ( ) { assertThat ( projectRegistry . getAllProjects ( ) , equalTo ( toSet ( ( ProjectInternal ) rootMock , childMock , childChildMock ) ) ) ; } @Test public void canLocateAllProjectsWhichMatchSpec ( ) { Spec < Project > spec = new Spec < Project > ( ) { public boolean isSatisfiedBy ( Project element ) { return element . getName ( ) . contains ( <str> ) ; } } ; assertThat ( projectRegistry . findAll ( spec ) , equalTo ( toSet ( ( ProjectInternal ) childMock , childChildMock ) ) ) ; } @Test public void canRemoveProject ( ) { String path = childChildMock . getPath ( ) ; assertThat ( projectRegistry . removeProject ( path ) , sameInstance ( ( ProjectInternal ) childChildMock ) ) ; assertThat ( projectRegistry . getProject ( path ) , nullValue ( ) ) ; assertThat ( projectRegistry . getProject ( childChildMock . getProjectDir ( ) ) , nullValue ( ) ) ; assertTrue ( projectRegistry . getAllProjects ( path ) . isEmpty ( ) ) ; assertTrue ( projectRegistry . getSubProjects ( path ) . isEmpty ( ) ) ; assertFalse ( projectRegistry . getAllProjects ( ) . contains ( childChildMock ) ) ; assertFalse ( projectRegistry . getAllProjects ( <str> ) . contains ( childChildMock ) ) ; assertFalse ( projectRegistry . getSubProjects ( <str> ) . contains ( childChildMock ) ) ; } } 
