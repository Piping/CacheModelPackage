package com . google . common . io ; import com . google . common . testing . GcFinalization ; import java . io . File ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; public class FileBackedOutputStreamTest extends IoTestCase { public void testThreshold ( ) throws Exception { testThreshold ( <int> , <int> , true , false ) ; testThreshold ( <int> , <int> , true , false ) ; testThreshold ( <int> , <int> , true , false ) ; testThreshold ( <int> , <int> , true , false ) ; testThreshold ( <int> , <int> , false , false ) ; testThreshold ( <int> , <int> , false , false ) ; testThreshold ( <int> , <int> , false , false ) ; testThreshold ( <int> , <int> , false , false ) ; } public void testFinalizeDeletesFile ( ) throws Exception { byte [ ] data = newPreFilledByteArray ( <int> ) ; FileBackedOutputStream out = new FileBackedOutputStream ( <int> , true ) ; write ( out , data , <int> , <int> , true ) ; final File file = out . getFile ( ) ; assertEquals ( <int> , file . length ( ) ) ; assertTrue ( file . exists ( ) ) ; out . close ( ) ; out = null ; GcFinalization . awaitDone ( new GcFinalization . FinalizationPredicate ( ) { @Override public boolean isDone ( ) { return ! file . exists ( ) ; } } ) ; } public void testThreshold_resetOnFinalize ( ) throws Exception { testThreshold ( <int> , <int> , true , true ) ; testThreshold ( <int> , <int> , true , true ) ; testThreshold ( <int> , <int> , true , true ) ; testThreshold ( <int> , <int> , true , true ) ; testThreshold ( <int> , <int> , false , true ) ; testThreshold ( <int> , <int> , false , true ) ; testThreshold ( <int> , <int> , false , true ) ; testThreshold ( <int> , <int> , false , true ) ; } private void testThreshold ( int fileThreshold , int dataSize , boolean singleByte , boolean resetOnFinalize ) throws IOException { byte [ ] data = newPreFilledByteArray ( dataSize ) ; FileBackedOutputStream out = new FileBackedOutputStream ( fileThreshold , resetOnFinalize ) ; ByteSource source = out . asByteSource ( ) ; int chunk1 = Math . min ( dataSize , fileThreshold ) ; int chunk2 = dataSize - chunk1 ; if ( chunk1 > <int> ) { write ( out , data , <int> , chunk1 , singleByte ) ; assertTrue ( ByteSource . wrap ( data ) . slice ( <int> , chunk1 ) . contentEquals ( source ) ) ; } File file = out . getFile ( ) ; assertNull ( file ) ; if ( chunk2 > <int> ) { write ( out , data , chunk1 , chunk2 , singleByte ) ; file = out . getFile ( ) ; assertEquals ( dataSize , file . length ( ) ) ; assertTrue ( file . exists ( ) ) ; } out . close ( ) ; assertTrue ( Arrays . equals ( data , source . read ( ) ) ) ; out . reset ( ) ; if ( file ! = null ) { assertFalse ( file . exists ( ) ) ; } } private static void write ( OutputStream out , byte [ ] b , int off , int len , boolean singleByte ) throws IOException { if ( singleByte ) { for ( int i = off ; i < off + len ; i + + ) { out . write ( b [ i ] ) ; } } else { out . write ( b , off , len ) ; } out . flush ( ) ; } public void testWriteErrorAfterClose ( ) throws Exception { byte [ ] data = newPreFilledByteArray ( <int> ) ; FileBackedOutputStream out = new FileBackedOutputStream ( <int> ) ; ByteSource source = out . asByteSource ( ) ; out . write ( data ) ; assertTrue ( Arrays . equals ( data , source . read ( ) ) ) ; out . close ( ) ; try { out . write ( <int> ) ; fail ( <str> ) ; } catch ( IOException expected ) { } assertTrue ( Arrays . equals ( data , source . read ( ) ) ) ; out . reset ( ) ; } public void testReset ( ) throws Exception { byte [ ] data = newPreFilledByteArray ( <int> ) ; FileBackedOutputStream out = new FileBackedOutputStream ( Integer . MAX_VALUE ) ; ByteSource source = out . asByteSource ( ) ; out . write ( data ) ; assertTrue ( Arrays . equals ( data , source . read ( ) ) ) ; out . reset ( ) ; assertTrue ( Arrays . equals ( new byte [ <int> ] , source . read ( ) ) ) ; out . write ( data ) ; assertTrue ( Arrays . equals ( data , source . read ( ) ) ) ; out . close ( ) ; } } 
