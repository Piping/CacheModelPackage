package org . eclipse . debug . internal . ui . viewers . update ; import java . util . HashMap ; import java . util . LinkedHashSet ; import java . util . Map ; import java . util . Set ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchManager ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . IStackFrame ; import org . eclipse . debug . core . model . IThread ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . provisional . AbstractModelProxy ; public class ThreadEventHandler extends DebugEventHandler { private Set < IThread > fThreadQueue = new LinkedHashSet < IThread > ( ) ; private Map < IThread , IStackFrame > fLastTopFrame = new HashMap < IThread , IStackFrame > ( ) ; public ThreadEventHandler ( AbstractModelProxy proxy ) { super ( proxy ) ; } @Override public synchronized void dispose ( ) { fLastTopFrame . clear ( ) ; fThreadQueue . clear ( ) ; super . dispose ( ) ; } @Override protected void handleSuspend ( DebugEvent event ) { IThread thread = ( IThread ) event . getSource ( ) ; if ( event . isEvaluation ( ) ) { ModelDelta delta = buildRootDelta ( ) ; ModelDelta node = addPathToThread ( delta , thread ) ; node = node . addNode ( thread , IModelDelta . NO_CHANGE ) ; try { IStackFrame frame = thread . getTopStackFrame ( ) ; if ( frame ! = null ) { int flag = IModelDelta . NO_CHANGE ; if ( event . getDetail ( ) = = DebugEvent . EVALUATION ) { flag = flag | IModelDelta . CONTENT ; } else if ( event . getDetail ( ) = = DebugEvent . EVALUATION_IMPLICIT ) { flag = flag | IModelDelta . STATE ; } node . addNode ( frame , flag ) ; fireDelta ( delta ) ; } } catch ( DebugException e ) { } } else { queueSuspendedThread ( event ) ; int extras = IModelDelta . STATE ; switch ( event . getDetail ( ) ) { case DebugEvent . BREAKPOINT : extras = IModelDelta . EXPAND | IModelDelta . REVEAL ; break ; case DebugEvent . CLIENT_REQUEST : extras = IModelDelta . EXPAND ; break ; default : break ; } fireDeltaUpdatingSelectedFrame ( thread , IModelDelta . NO_CHANGE | extras , event ) ; } } private boolean isEqual ( Object o1 , Object o2 ) { if ( o1 = = o2 ) { return true ; } if ( o1 = = null ) { return false ; } return o1 . equals ( o2 ) ; } @Override protected void handleResume ( DebugEvent event ) { IThread thread = removeSuspendedThread ( event ) ; fireDeltaAndClearTopFrame ( thread , IModelDelta . STATE | IModelDelta . CONTENT | IModelDelta . SELECT ) ; thread = getNextSuspendedThread ( ) ; if ( thread ! = null ) { fireDeltaUpdatingSelectedFrame ( thread , IModelDelta . NO_CHANGE | IModelDelta . REVEAL , event ) ; } } @Override protected void handleCreate ( DebugEvent event ) { fireDeltaAndClearTopFrame ( ( IThread ) event . getSource ( ) , IModelDelta . ADDED | IModelDelta . STATE ) ; } @Override protected void handleTerminate ( DebugEvent event ) { IThread thread = ( IThread ) event . getSource ( ) ; IDebugTarget target = thread . getDebugTarget ( ) ; if ( ! ( target . isTerminated ( ) | | target . isDisconnected ( ) ) ) { fireDeltaAndClearTopFrame ( thread , IModelDelta . REMOVED ) ; } } @Override protected void handleChange ( DebugEvent event ) { if ( event . getDetail ( ) = = DebugEvent . STATE ) { fireDeltaUpdatingThread ( ( IThread ) event . getSource ( ) , IModelDelta . STATE ) ; } else { fireDeltaUpdatingThread ( ( IThread ) event . getSource ( ) , IModelDelta . CONTENT ) ; } } @Override protected void handleLateSuspend ( DebugEvent suspend , DebugEvent resume ) { IThread thread = queueSuspendedThread ( suspend ) ; if ( suspend . isEvaluation ( ) & & suspend . getDetail ( ) = = DebugEvent . EVALUATION_IMPLICIT ) { ModelDelta delta = buildRootDelta ( ) ; ModelDelta node = addPathToThread ( delta , thread ) ; node = node . addNode ( thread , IModelDelta . STATE ) ; try { IStackFrame frame = thread . getTopStackFrame ( ) ; if ( frame ! = null ) { node . addNode ( frame , IModelDelta . STATE ) ; fireDelta ( delta ) ; } } catch ( DebugException e ) { } } else { fireDeltaUpdatingSelectedFrame ( thread , IModelDelta . STATE | IModelDelta . EXPAND , suspend ) ; } } @Override protected void handleSuspendTimeout ( DebugEvent event ) { IThread thread = removeSuspendedThread ( event ) ; fireDeltaUpdatingThread ( thread , IModelDelta . STATE ) ; } protected ModelDelta buildRootDelta ( ) { return new ModelDelta ( getLaunchManager ( ) , IModelDelta . NO_CHANGE ) ; } protected ILaunchManager getLaunchManager ( ) { return DebugPlugin . getDefault ( ) . getLaunchManager ( ) ; } protected ModelDelta addPathToThread ( ModelDelta delta , IThread thread ) { ILaunch launch = thread . getLaunch ( ) ; Object [ ] children = launch . getChildren ( ) ; delta = delta . addNode ( launch , indexOf ( getLaunchManager ( ) . getLaunches ( ) , launch ) , IModelDelta . NO_CHANGE , children . length ) ; IDebugTarget debugTarget = thread . getDebugTarget ( ) ; int numThreads = - <int> ; try { numThreads = debugTarget . getThreads ( ) . length ; } catch ( DebugException e ) { } return delta . addNode ( debugTarget , indexOf ( children , debugTarget ) , IModelDelta . NO_CHANGE , numThreads ) ; } private void fireDeltaAndClearTopFrame ( IThread thread , int flags ) { ModelDelta delta = buildRootDelta ( ) ; ModelDelta node = addPathToThread ( delta , thread ) ; node . addNode ( thread , indexOf ( thread ) , flags ) ; synchronized ( this ) { fLastTopFrame . remove ( thread ) ; } fireDelta ( delta ) ; } private void fireDeltaUpdatingSelectedFrame ( IThread thread , int flags , DebugEvent event ) { ModelDelta delta = buildRootDelta ( ) ; ModelDelta node = addPathToThread ( delta , thread ) ; IStackFrame prev = null ; synchronized ( this ) { prev = fLastTopFrame . get ( thread ) ; } IStackFrame frame = null ; try { Object frameToSelect = event . getData ( ) ; if ( frameToSelect = = null | | ! ( frameToSelect instanceof IStackFrame ) ) { frame = thread . getTopStackFrame ( ) ; } else { frame = ( IStackFrame ) frameToSelect ; } } catch ( DebugException e ) { } int threadIndex = indexOf ( thread ) ; int childCount = childCount ( thread ) ; if ( isEqual ( frame , prev ) ) { if ( frame = = null ) { if ( thread . isSuspended ( ) ) { node = node . addNode ( thread , threadIndex , flags | IModelDelta . STATE | IModelDelta . SELECT , childCount ) ; } } else { node = node . addNode ( thread , threadIndex , flags , childCount ) ; } } else { if ( event . getDetail ( ) = = DebugEvent . STEP_END ) { if ( prev = = null ) { flags = flags | IModelDelta . EXPAND ; } else if ( frame = = null ) { return ; } } node = node . addNode ( thread , threadIndex , flags | IModelDelta . CONTENT , childCount ) ; } if ( frame ! = null ) { node . addNode ( frame , indexOf ( frame ) , IModelDelta . STATE | IModelDelta . SELECT , childCount ( frame ) ) ; } synchronized ( this ) { if ( ! isDisposed ( ) ) { fLastTopFrame . put ( thread , frame ) ; } } fireDelta ( delta ) ; } protected int indexOf ( IThread thread ) { try { return indexOf ( thread . getDebugTarget ( ) . getThreads ( ) , thread ) ; } catch ( DebugException e ) { } return - <int> ; } protected int indexOf ( IStackFrame frame ) { try { return indexOf ( frame . getThread ( ) . getStackFrames ( ) , frame ) ; } catch ( DebugException e ) { return - <int> ; } } protected int childCount ( IThread thread ) { try { return thread . getStackFrames ( ) . length ; } catch ( DebugException e ) { } return - <int> ; } protected int childCount ( IStackFrame frame ) { return <int> ; } private void fireDeltaUpdatingThread ( IThread thread , int flags ) { ModelDelta delta = buildRootDelta ( ) ; ModelDelta node = addPathToThread ( delta , thread ) ; node = node . addNode ( thread , flags ) ; fireDelta ( delta ) ; } @Override protected boolean handlesEvent ( DebugEvent event ) { return event . getSource ( ) instanceof IThread ; } protected synchronized IThread queueSuspendedThread ( DebugEvent event ) { IThread thread = ( IThread ) event . getSource ( ) ; if ( ! isDisposed ( ) ) { fThreadQueue . add ( thread ) ; } return thread ; } protected synchronized IThread removeSuspendedThread ( DebugEvent event ) { IThread thread = ( IThread ) event . getSource ( ) ; fThreadQueue . remove ( thread ) ; return thread ; } protected synchronized IThread queueSuspendedThread ( IThread thread ) { if ( ! isDisposed ( ) ) { fThreadQueue . add ( thread ) ; } return thread ; } protected synchronized void removeQueuedThread ( IThread thread ) { fThreadQueue . remove ( thread ) ; } protected synchronized IThread getNextSuspendedThread ( ) { if ( ! fThreadQueue . isEmpty ( ) ) { return fThreadQueue . iterator ( ) . next ( ) ; } return null ; } } 
