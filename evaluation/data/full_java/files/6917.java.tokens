package org . elasticsearch . percolator ; import com . carrotsearch . hppc . FloatArrayList ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . * ; import org . apache . lucene . search . BooleanClause . Occur ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . index . fielddata . IndexFieldData ; import org . elasticsearch . index . fielddata . SortedBinaryDocValues ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . Uid ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import org . elasticsearch . index . query . ParsedQuery ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . BucketCollector ; import org . elasticsearch . search . aggregations . bucket . global . GlobalAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . highlight . HighlightField ; import org . elasticsearch . search . highlight . HighlightPhase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ConcurrentMap ; abstract class QueryCollector extends SimpleCollector { final IndexFieldData < ? > uidFieldData ; final IndexSearcher searcher ; final ConcurrentMap < BytesRef , Query > queries ; final ESLogger logger ; boolean isNestedDoc = false ; BytesRef current ; SortedBinaryDocValues values ; final BucketCollector aggregatorCollector ; LeafCollector aggregatorLeafCollector ; QueryCollector ( ESLogger logger , PercolateContext context , boolean isNestedDoc ) throws IOException { this . logger = logger ; this . queries = context . percolateQueries ( ) ; this . searcher = context . docSearcher ( ) ; final MappedFieldType uidMapper = context . mapperService ( ) . smartNameFieldType ( UidFieldMapper . NAME ) ; this . uidFieldData = context . fieldData ( ) . getForField ( uidMapper ) ; this . isNestedDoc = isNestedDoc ; List < Aggregator > aggregatorCollectors = new ArrayList < > ( ) ; if ( context . aggregations ( ) ! = null ) { AggregationContext aggregationContext = new AggregationContext ( context ) ; context . aggregations ( ) . aggregationContext ( aggregationContext ) ; Aggregator [ ] aggregators = context . aggregations ( ) . factories ( ) . createTopLevelAggregators ( aggregationContext ) ; for ( int i = <int> ; i < aggregators . length ; i + + ) { if ( ! ( aggregators [ i ] instanceof GlobalAggregator ) ) { Aggregator aggregator = aggregators [ i ] ; aggregatorCollectors . add ( aggregator ) ; } } context . aggregations ( ) . aggregators ( aggregators ) ; } aggregatorCollector = BucketCollector . wrap ( aggregatorCollectors ) ; aggregatorCollector . preCollection ( ) ; } public void postMatch ( int doc ) throws IOException { aggregatorLeafCollector . collect ( doc ) ; } @Override public void setScorer ( Scorer scorer ) throws IOException { aggregatorLeafCollector . setScorer ( scorer ) ; } @Override public boolean needsScores ( ) { return aggregatorCollector . needsScores ( ) ; } @Override public void doSetNextReader ( LeafReaderContext context ) throws IOException { values = uidFieldData . load ( context ) . getBytesValues ( ) ; aggregatorLeafCollector = aggregatorCollector . getLeafCollector ( context ) ; } static Match match ( ESLogger logger , PercolateContext context , HighlightPhase highlightPhase , boolean isNestedDoc ) throws IOException { return new Match ( logger , context , highlightPhase , isNestedDoc ) ; } static Count count ( ESLogger logger , PercolateContext context , boolean isNestedDoc ) throws IOException { return new Count ( logger , context , isNestedDoc ) ; } static MatchAndScore matchAndScore ( ESLogger logger , PercolateContext context , HighlightPhase highlightPhase , boolean isNestedDoc ) throws IOException { return new MatchAndScore ( logger , context , highlightPhase , isNestedDoc ) ; } static MatchAndSort matchAndSort ( ESLogger logger , PercolateContext context , boolean isNestedDoc ) throws IOException { return new MatchAndSort ( logger , context , isNestedDoc ) ; } protected final Query getQuery ( int doc ) { values . setDocument ( doc ) ; final int numValues = values . count ( ) ; if ( numValues = = <int> ) { return null ; } assert numValues = = <int> ; current = Uid . splitUidIntoTypeAndId ( values . valueAt ( <int> ) ) [ <int> ] ; return queries . get ( current ) ; } final static class Match extends QueryCollector { final PercolateContext context ; final HighlightPhase highlightPhase ; final List < BytesRef > matches = new ArrayList < > ( ) ; final List < Map < String , HighlightField > > hls = new ArrayList < > ( ) ; final boolean limit ; final int size ; long counter = <int> ; Match ( ESLogger logger , PercolateContext context , HighlightPhase highlightPhase , boolean isNestedDoc ) throws IOException { super ( logger , context , isNestedDoc ) ; this . limit = context . limit ; this . size = context . size ( ) ; this . context = context ; this . highlightPhase = highlightPhase ; } @Override public void collect ( int doc ) throws IOException { final Query query = getQuery ( doc ) ; if ( query = = null ) { return ; } Query existsQuery = query ; if ( isNestedDoc ) { existsQuery = new BooleanQuery . Builder ( ) . add ( existsQuery , Occur . MUST ) . add ( Queries . newNonNestedFilter ( ) , Occur . FILTER ) . build ( ) ; } try { if ( context . highlight ( ) ! = null ) { context . parsedQuery ( new ParsedQuery ( query ) ) ; context . hitContext ( ) . cache ( ) . clear ( ) ; } if ( Lucene . exists ( searcher , existsQuery ) ) { if ( ! limit | | counter < size ) { matches . add ( BytesRef . deepCopyOf ( current ) ) ; if ( context . highlight ( ) ! = null ) { highlightPhase . hitExecute ( context , context . hitContext ( ) ) ; hls . add ( context . hitContext ( ) . hit ( ) . getHighlightFields ( ) ) ; } } counter + + ; postMatch ( doc ) ; } } catch ( IOException e ) { logger . warn ( <str> + current . utf8ToString ( ) + <str> , e ) ; } } long counter ( ) { return counter ; } List < BytesRef > matches ( ) { return matches ; } List < Map < String , HighlightField > > hls ( ) { return hls ; } } final static class MatchAndSort extends QueryCollector { private final TopScoreDocCollector topDocsCollector ; private LeafCollector topDocsLeafCollector ; MatchAndSort ( ESLogger logger , PercolateContext context , boolean isNestedDoc ) throws IOException { super ( logger , context , isNestedDoc ) ; topDocsCollector = TopScoreDocCollector . create ( context . size ( ) ) ; } @Override public boolean needsScores ( ) { return super . needsScores ( ) | | topDocsCollector . needsScores ( ) ; } @Override public void collect ( int doc ) throws IOException { final Query query = getQuery ( doc ) ; if ( query = = null ) { return ; } Query existsQuery = query ; if ( isNestedDoc ) { existsQuery = new BooleanQuery . Builder ( ) . add ( existsQuery , Occur . MUST ) . add ( Queries . newNonNestedFilter ( ) , Occur . FILTER ) . build ( ) ; } try { if ( Lucene . exists ( searcher , existsQuery ) ) { topDocsLeafCollector . collect ( doc ) ; postMatch ( doc ) ; } } catch ( IOException e ) { logger . warn ( <str> + current . utf8ToString ( ) + <str> , e ) ; } } @Override public void doSetNextReader ( LeafReaderContext context ) throws IOException { super . doSetNextReader ( context ) ; topDocsLeafCollector = topDocsCollector . getLeafCollector ( context ) ; } @Override public void setScorer ( Scorer scorer ) throws IOException { topDocsLeafCollector . setScorer ( scorer ) ; } TopDocs topDocs ( ) { return topDocsCollector . topDocs ( ) ; } } final static class MatchAndScore extends QueryCollector { final PercolateContext context ; final HighlightPhase highlightPhase ; final List < BytesRef > matches = new ArrayList < > ( ) ; final List < Map < String , HighlightField > > hls = new ArrayList < > ( ) ; final FloatArrayList scores = new FloatArrayList ( ) ; final boolean limit ; final int size ; long counter = <int> ; private Scorer scorer ; MatchAndScore ( ESLogger logger , PercolateContext context , HighlightPhase highlightPhase , boolean isNestedDoc ) throws IOException { super ( logger , context , isNestedDoc ) ; this . limit = context . limit ; this . size = context . size ( ) ; this . context = context ; this . highlightPhase = highlightPhase ; } @Override public boolean needsScores ( ) { return true ; } @Override public void collect ( int doc ) throws IOException { final Query query = getQuery ( doc ) ; if ( query = = null ) { return ; } Query existsQuery = query ; if ( isNestedDoc ) { existsQuery = new BooleanQuery . Builder ( ) . add ( existsQuery , Occur . MUST ) . add ( Queries . newNonNestedFilter ( ) , Occur . FILTER ) . build ( ) ; } try { if ( context . highlight ( ) ! = null ) { context . parsedQuery ( new ParsedQuery ( query ) ) ; context . hitContext ( ) . cache ( ) . clear ( ) ; } if ( Lucene . exists ( searcher , existsQuery ) ) { if ( ! limit | | counter < size ) { matches . add ( BytesRef . deepCopyOf ( current ) ) ; scores . add ( scorer . score ( ) ) ; if ( context . highlight ( ) ! = null ) { highlightPhase . hitExecute ( context , context . hitContext ( ) ) ; hls . add ( context . hitContext ( ) . hit ( ) . getHighlightFields ( ) ) ; } } counter + + ; postMatch ( doc ) ; } } catch ( IOException e ) { logger . warn ( <str> + current . utf8ToString ( ) + <str> , e ) ; } } @Override public void setScorer ( Scorer scorer ) throws IOException { this . scorer = scorer ; } long counter ( ) { return counter ; } List < BytesRef > matches ( ) { return matches ; } FloatArrayList scores ( ) { return scores ; } List < Map < String , HighlightField > > hls ( ) { return hls ; } } final static class Count extends QueryCollector { private long counter = <int> ; Count ( ESLogger logger , PercolateContext context , boolean isNestedDoc ) throws IOException { super ( logger , context , isNestedDoc ) ; } @Override public void collect ( int doc ) throws IOException { final Query query = getQuery ( doc ) ; if ( query = = null ) { return ; } Query existsQuery = query ; if ( isNestedDoc ) { existsQuery = new BooleanQuery . Builder ( ) . add ( existsQuery , Occur . MUST ) . add ( Queries . newNonNestedFilter ( ) , Occur . FILTER ) . build ( ) ; } try { if ( Lucene . exists ( searcher , existsQuery ) ) { counter + + ; postMatch ( doc ) ; } } catch ( IOException e ) { logger . warn ( <str> + current . utf8ToString ( ) + <str> , e ) ; } } long counter ( ) { return counter ; } } } 
