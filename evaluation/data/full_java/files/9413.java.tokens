package com . google . common . hash ; import com . google . common . primitives . Longs ; import sun . misc . Unsafe ; import java . nio . ByteOrder ; final class LittleEndianByteArray { private static final LittleEndianBytes byteArray ; static long load64 ( byte [ ] input , int offset ) { assert input . length > = offset + <int> ; return byteArray . getLongLittleEndian ( input , offset ) ; } static long load64Safely ( byte [ ] input , int offset , int length ) { long result = <int> ; int limit = Math . min ( length , <int> ) ; for ( int i = <int> ; i < limit ; i + + ) { result | = ( input [ offset + i ] & <hex> ) < < ( i * <int> ) ; } return result ; } static void store64 ( byte [ ] sink , int offset , long value ) { assert offset > = <int> & & offset + <int> < = sink . length ; byteArray . putLongLittleEndian ( sink , offset , value ) ; } static int load32 ( byte [ ] source , int offset ) { return ( source [ offset ] & <hex> ) | ( ( source [ offset + <int> ] & <hex> ) < < <int> ) | ( ( source [ offset + <int> ] & <hex> ) < < <int> ) | ( ( source [ offset + <int> ] & <hex> ) < < <int> ) ; } static boolean usingUnsafe ( ) { return ( byteArray instanceof UnsafeByteArray ) ; } private interface LittleEndianBytes { long getLongLittleEndian ( byte [ ] array , int offset ) ; void putLongLittleEndian ( byte [ ] array , int offset , long value ) ; } private enum UnsafeByteArray implements LittleEndianBytes { UNSAFE_LITTLE_ENDIAN { @Override public long getLongLittleEndian ( byte [ ] array , int offset ) { return theUnsafe . getLong ( array , ( long ) offset + BYTE_ARRAY_BASE_OFFSET ) ; } @Override public void putLongLittleEndian ( byte [ ] array , int offset , long value ) { theUnsafe . putLong ( array , ( long ) offset + BYTE_ARRAY_BASE_OFFSET , value ) ; } } , UNSAFE_BIG_ENDIAN { @Override public long getLongLittleEndian ( byte [ ] array , int offset ) { long bigEndian = theUnsafe . getLong ( array , ( long ) offset + BYTE_ARRAY_BASE_OFFSET ) ; return Long . reverseBytes ( bigEndian ) ; } @Override public void putLongLittleEndian ( byte [ ] array , int offset , long value ) { long littleEndianValue = Long . reverseBytes ( value ) ; theUnsafe . putLong ( array , ( long ) offset + BYTE_ARRAY_BASE_OFFSET , littleEndianValue ) ; } } ; private static final Unsafe theUnsafe ; private static final int BYTE_ARRAY_BASE_OFFSET ; private static sun . misc . Unsafe getUnsafe ( ) { try { return sun . misc . Unsafe . getUnsafe ( ) ; } catch ( SecurityException tryReflectionInstead ) { } try { return java . security . AccessController . doPrivileged ( new java . security . PrivilegedExceptionAction < sun . misc . Unsafe > ( ) { @Override public sun . misc . Unsafe run ( ) throws Exception { Class < sun . misc . Unsafe > k = sun . misc . Unsafe . class ; for ( java . lang . reflect . Field f : k . getDeclaredFields ( ) ) { f . setAccessible ( true ) ; Object x = f . get ( null ) ; if ( k . isInstance ( x ) ) { return k . cast ( x ) ; } } throw new NoSuchFieldError ( <str> ) ; } } ) ; } catch ( java . security . PrivilegedActionException e ) { throw new RuntimeException ( <str> , e . getCause ( ) ) ; } } static { theUnsafe = getUnsafe ( ) ; BYTE_ARRAY_BASE_OFFSET = theUnsafe . arrayBaseOffset ( byte [ ] . class ) ; if ( theUnsafe . arrayIndexScale ( byte [ ] . class ) ! = <int> ) { throw new AssertionError ( ) ; } } } private enum JavaLittleEndianBytes implements LittleEndianBytes { INSTANCE { @Override public long getLongLittleEndian ( byte [ ] source , int offset ) { return Longs . fromBytes ( source [ offset + <int> ] , source [ offset + <int> ] , source [ offset + <int> ] , source [ offset + <int> ] , source [ offset + <int> ] , source [ offset + <int> ] , source [ offset + <int> ] , source [ offset ] ) ; } @Override public void putLongLittleEndian ( byte [ ] sink , int offset , long value ) { long mask = <hex> ; for ( int i = <int> ; i < <int> ; mask < < = <int> , i + + ) { sink [ offset + i ] = ( byte ) ( ( value & mask ) > > ( i * <int> ) ) ; } } } ; } static { LittleEndianBytes theGetter ; try { theGetter = ByteOrder . nativeOrder ( ) . equals ( ByteOrder . LITTLE_ENDIAN ) ? UnsafeByteArray . UNSAFE_LITTLE_ENDIAN : UnsafeByteArray . UNSAFE_BIG_ENDIAN ; } catch ( Throwable t ) { theGetter = JavaLittleEndianBytes . INSTANCE ; } byteArray = theGetter ; } private LittleEndianByteArray ( ) { } } 
