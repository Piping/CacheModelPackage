package io . netty . handler . codec . spdy ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . Unpooled ; import java . util . zip . Deflater ; import static io . netty . handler . codec . spdy . SpdyCodecUtil . * ; class SpdyHeaderBlockZlibEncoder extends SpdyHeaderBlockRawEncoder { private final Deflater compressor ; private boolean finished ; SpdyHeaderBlockZlibEncoder ( SpdyVersion spdyVersion , int compressionLevel ) { super ( spdyVersion ) ; if ( compressionLevel < <int> | | compressionLevel > <int> ) { throw new IllegalArgumentException ( <str> + compressionLevel + <str> ) ; } compressor = new Deflater ( compressionLevel ) ; compressor . setDictionary ( SPDY_DICT ) ; } private int setInput ( ByteBuf decompressed ) { int len = decompressed . readableBytes ( ) ; if ( decompressed . hasArray ( ) ) { compressor . setInput ( decompressed . array ( ) , decompressed . arrayOffset ( ) + decompressed . readerIndex ( ) , len ) ; } else { byte [ ] in = new byte [ len ] ; decompressed . getBytes ( decompressed . readerIndex ( ) , in ) ; compressor . setInput ( in , <int> , in . length ) ; } return len ; } private ByteBuf encode ( ByteBufAllocator alloc , int len ) { ByteBuf compressed = alloc . heapBuffer ( len ) ; boolean release = true ; try { while ( compressInto ( compressed ) ) { compressed . ensureWritable ( compressed . capacity ( ) < < <int> ) ; } release = false ; return compressed ; } finally { if ( release ) { compressed . release ( ) ; } } } private boolean compressInto ( ByteBuf compressed ) { byte [ ] out = compressed . array ( ) ; int off = compressed . arrayOffset ( ) + compressed . writerIndex ( ) ; int toWrite = compressed . writableBytes ( ) ; int numBytes = compressor . deflate ( out , off , toWrite , Deflater . SYNC_FLUSH ) ; compressed . writerIndex ( compressed . writerIndex ( ) + numBytes ) ; return numBytes = = toWrite ; } @Override public ByteBuf encode ( ByteBufAllocator alloc , SpdyHeadersFrame frame ) throws Exception { if ( frame = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( finished ) { return Unpooled . EMPTY_BUFFER ; } ByteBuf decompressed = super . encode ( alloc , frame ) ; try { if ( ! decompressed . isReadable ( ) ) { return Unpooled . EMPTY_BUFFER ; } int len = setInput ( decompressed ) ; return encode ( alloc , len ) ; } finally { decompressed . release ( ) ; } } @Override public void end ( ) { if ( finished ) { return ; } finished = true ; compressor . end ( ) ; super . end ( ) ; } } 
