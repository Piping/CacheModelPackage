package org . gradle . launcher . daemon . server . exec ; import org . gradle . api . logging . LogLevel ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . launcher . daemon . diagnostics . DaemonDiagnostics ; import org . gradle . launcher . daemon . logging . DaemonMessages ; import org . gradle . launcher . daemon . protocol . Build ; import org . gradle . launcher . daemon . server . api . DaemonCommandExecution ; import org . gradle . logging . internal . LoggingOutputInternal ; import org . gradle . logging . internal . OutputEvent ; import org . gradle . logging . internal . OutputEventListener ; public class LogToClient extends BuildCommandOnly { public static final String DISABLE_OUTPUT = <str> ; private static final Logger LOGGER = Logging . getLogger ( LogToClient . class ) ; private final LoggingOutputInternal loggingOutput ; private final DaemonDiagnostics diagnostics ; public LogToClient ( LoggingOutputInternal loggingOutput , DaemonDiagnostics diagnostics ) { this . loggingOutput = loggingOutput ; this . diagnostics = diagnostics ; } protected void doBuild ( final DaemonCommandExecution execution , Build build ) { if ( Boolean . getBoolean ( DISABLE_OUTPUT ) ) { execution . proceed ( ) ; return ; } final LogLevel buildLogLevel = build . getParameters ( ) . getLogLevel ( ) ; OutputEventListener listener = new OutputEventListener ( ) { public void onOutput ( OutputEvent event ) { try { if ( event . getLogLevel ( ) ! = null & & event . getLogLevel ( ) . compareTo ( buildLogLevel ) > = <int> ) { execution . getConnection ( ) . logEvent ( event ) ; } } catch ( Exception e ) { } } } ; LOGGER . debug ( DaemonMessages . ABOUT_TO_START_RELAYING_LOGS ) ; loggingOutput . addOutputEventListener ( listener ) ; try { LOGGER . info ( <str> , DaemonMessages . STARTED_RELAYING_LOGS , diagnostics . getPid ( ) , diagnostics . getDaemonLog ( ) ) ; execution . proceed ( ) ; } finally { loggingOutput . removeOutputEventListener ( listener ) ; } } } 
