package com . badlogic . gdx . graphics . g3d . shaders ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GLTexture ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . g3d . Attributes ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . Shader ; import com . badlogic . gdx . graphics . g3d . utils . RenderContext ; import com . badlogic . gdx . graphics . g3d . utils . TextureDescriptor ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . Matrix3 ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . IntIntMap ; public abstract class BaseShader implements Shader { public interface Validator { boolean validate ( final BaseShader shader , final int inputID , final Renderable renderable ) ; } public interface Setter { boolean isGlobal ( final BaseShader shader , final int inputID ) ; void set ( final BaseShader shader , final int inputID , final Renderable renderable , final Attributes combinedAttributes ) ; } public abstract static class GlobalSetter implements Setter { @Override public boolean isGlobal ( final BaseShader shader , final int inputID ) { return true ; } } public abstract static class LocalSetter implements Setter { @Override public boolean isGlobal ( final BaseShader shader , final int inputID ) { return false ; } } public static class Uniform implements Validator { public final String alias ; public final long materialMask ; public final long environmentMask ; public final long overallMask ; public Uniform ( final String alias , final long materialMask , final long environmentMask , final long overallMask ) { this . alias = alias ; this . materialMask = materialMask ; this . environmentMask = environmentMask ; this . overallMask = overallMask ; } public Uniform ( final String alias , final long materialMask , final long environmentMask ) { this ( alias , materialMask , environmentMask , <int> ) ; } public Uniform ( final String alias , final long overallMask ) { this ( alias , <int> , <int> , overallMask ) ; } public Uniform ( final String alias ) { this ( alias , <int> , <int> ) ; } public boolean validate ( final BaseShader shader , final int inputID , final Renderable renderable ) { final long matFlags = ( renderable ! = null & & renderable . material ! = null ) ? renderable . material . getMask ( ) : <int> ; final long envFlags = ( renderable ! = null & & renderable . environment ! = null ) ? renderable . environment . getMask ( ) : <int> ; return ( ( matFlags & materialMask ) = = materialMask ) & & ( ( envFlags & environmentMask ) = = environmentMask ) & & ( ( ( matFlags | envFlags ) & overallMask ) = = overallMask ) ; } } private final Array < String > uniforms = new Array < String > ( ) ; private final Array < Validator > validators = new Array < Validator > ( ) ; private final Array < Setter > setters = new Array < Setter > ( ) ; private int locations [ ] ; private final IntArray globalUniforms = new IntArray ( ) ; private final IntArray localUniforms = new IntArray ( ) ; private final IntIntMap attributes = new IntIntMap ( ) ; public ShaderProgram program ; public RenderContext context ; public Camera camera ; private Mesh currentMesh ; public int register ( final String alias , final Validator validator , final Setter setter ) { if ( locations ! = null ) throw new GdxRuntimeException ( <str> ) ; final int existing = getUniformID ( alias ) ; if ( existing > = <int> ) { validators . set ( existing , validator ) ; setters . set ( existing , setter ) ; return existing ; } uniforms . add ( alias ) ; validators . add ( validator ) ; setters . add ( setter ) ; return uniforms . size - <int> ; } public int register ( final String alias , final Validator validator ) { return register ( alias , validator , null ) ; } public int register ( final String alias , final Setter setter ) { return register ( alias , null , setter ) ; } public int register ( final String alias ) { return register ( alias , null , null ) ; } public int register ( final Uniform uniform , final Setter setter ) { return register ( uniform . alias , uniform , setter ) ; } public int register ( final Uniform uniform ) { return register ( uniform , null ) ; } public int getUniformID ( final String alias ) { final int n = uniforms . size ; for ( int i = <int> ; i < n ; i + + ) if ( uniforms . get ( i ) . equals ( alias ) ) return i ; return - <int> ; } public String getUniformAlias ( final int id ) { return uniforms . get ( id ) ; } public void init ( final ShaderProgram program , final Renderable renderable ) { if ( locations ! = null ) throw new GdxRuntimeException ( <str> ) ; if ( ! program . isCompiled ( ) ) throw new GdxRuntimeException ( program . getLog ( ) ) ; this . program = program ; final int n = uniforms . size ; locations = new int [ n ] ; for ( int i = <int> ; i < n ; i + + ) { final String input = uniforms . get ( i ) ; final Validator validator = validators . get ( i ) ; final Setter setter = setters . get ( i ) ; if ( validator ! = null & & ! validator . validate ( this , i , renderable ) ) locations [ i ] = - <int> ; else { locations [ i ] = program . fetchUniformLocation ( input , false ) ; if ( locations [ i ] > = <int> & & setter ! = null ) { if ( setter . isGlobal ( this , i ) ) globalUniforms . add ( i ) ; else localUniforms . add ( i ) ; } } if ( locations [ i ] < <int> ) { validators . set ( i , null ) ; setters . set ( i , null ) ; } } if ( renderable ! = null ) { final VertexAttributes attrs = renderable . meshPart . mesh . getVertexAttributes ( ) ; final int c = attrs . size ( ) ; for ( int i = <int> ; i < c ; i + + ) { final VertexAttribute attr = attrs . get ( i ) ; final int location = program . getAttributeLocation ( attr . alias ) ; if ( location > = <int> ) attributes . put ( attr . getKey ( ) , location ) ; } } } @Override public void begin ( Camera camera , RenderContext context ) { this . camera = camera ; this . context = context ; program . begin ( ) ; currentMesh = null ; for ( int u , i = <int> ; i < globalUniforms . size ; + + i ) if ( setters . get ( u = globalUniforms . get ( i ) ) ! = null ) setters . get ( u ) . set ( this , u , null , null ) ; } private final IntArray tempArray = new IntArray ( ) ; private final int [ ] getAttributeLocations ( final VertexAttributes attrs ) { tempArray . clear ( ) ; final int n = attrs . size ( ) ; for ( int i = <int> ; i < n ; i + + ) { tempArray . add ( attributes . get ( attrs . get ( i ) . getKey ( ) , - <int> ) ) ; } return tempArray . items ; } private Attributes combinedAttributes = new Attributes ( ) ; @Override public void render ( Renderable renderable ) { if ( renderable . worldTransform . det3x3 ( ) = = <int> ) return ; combinedAttributes . clear ( ) ; if ( renderable . environment ! = null ) combinedAttributes . set ( renderable . environment ) ; if ( renderable . material ! = null ) combinedAttributes . set ( renderable . material ) ; render ( renderable , combinedAttributes ) ; } public void render ( Renderable renderable , final Attributes combinedAttributes ) { for ( int u , i = <int> ; i < localUniforms . size ; + + i ) if ( setters . get ( u = localUniforms . get ( i ) ) ! = null ) setters . get ( u ) . set ( this , u , renderable , combinedAttributes ) ; if ( currentMesh ! = renderable . meshPart . mesh ) { if ( currentMesh ! = null ) currentMesh . unbind ( program , tempArray . items ) ; currentMesh = renderable . meshPart . mesh ; currentMesh . bind ( program , getAttributeLocations ( renderable . meshPart . mesh . getVertexAttributes ( ) ) ) ; } renderable . meshPart . render ( program , false ) ; } @Override public void end ( ) { if ( currentMesh ! = null ) { currentMesh . unbind ( program , tempArray . items ) ; currentMesh = null ; } program . end ( ) ; } @Override public void dispose ( ) { program = null ; uniforms . clear ( ) ; validators . clear ( ) ; setters . clear ( ) ; localUniforms . clear ( ) ; globalUniforms . clear ( ) ; locations = null ; } public final boolean has ( final int inputID ) { return inputID > = <int> & & inputID < locations . length & & locations [ inputID ] > = <int> ; } public final int loc ( final int inputID ) { return ( inputID > = <int> & & inputID < locations . length ) ? locations [ inputID ] : - <int> ; } public final boolean set ( final int uniform , final Matrix4 value ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformMatrix ( locations [ uniform ] , value ) ; return true ; } public final boolean set ( final int uniform , final Matrix3 value ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformMatrix ( locations [ uniform ] , value ) ; return true ; } public final boolean set ( final int uniform , final Vector3 value ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformf ( locations [ uniform ] , value ) ; return true ; } public final boolean set ( final int uniform , final Vector2 value ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformf ( locations [ uniform ] , value ) ; return true ; } public final boolean set ( final int uniform , final Color value ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformf ( locations [ uniform ] , value ) ; return true ; } public final boolean set ( final int uniform , final float value ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformf ( locations [ uniform ] , value ) ; return true ; } public final boolean set ( final int uniform , final float v1 , final float v2 ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformf ( locations [ uniform ] , v1 , v2 ) ; return true ; } public final boolean set ( final int uniform , final float v1 , final float v2 , final float v3 ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformf ( locations [ uniform ] , v1 , v2 , v3 ) ; return true ; } public final boolean set ( final int uniform , final float v1 , final float v2 , final float v3 , final float v4 ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformf ( locations [ uniform ] , v1 , v2 , v3 , v4 ) ; return true ; } public final boolean set ( final int uniform , final int value ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformi ( locations [ uniform ] , value ) ; return true ; } public final boolean set ( final int uniform , final int v1 , final int v2 ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformi ( locations [ uniform ] , v1 , v2 ) ; return true ; } public final boolean set ( final int uniform , final int v1 , final int v2 , final int v3 ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformi ( locations [ uniform ] , v1 , v2 , v3 ) ; return true ; } public final boolean set ( final int uniform , final int v1 , final int v2 , final int v3 , final int v4 ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformi ( locations [ uniform ] , v1 , v2 , v3 , v4 ) ; return true ; } public final boolean set ( final int uniform , final TextureDescriptor textureDesc ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformi ( locations [ uniform ] , context . textureBinder . bind ( textureDesc ) ) ; return true ; } public final boolean set ( final int uniform , final GLTexture texture ) { if ( locations [ uniform ] < <int> ) return false ; program . setUniformi ( locations [ uniform ] , context . textureBinder . bind ( texture ) ) ; return true ; } } 
