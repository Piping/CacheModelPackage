package org . apache . cassandra . locator ; import java . lang . management . ManagementFactory ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . TimeUnit ; import com . codahale . metrics . ExponentiallyDecayingReservoir ; import javax . management . MBeanServer ; import javax . management . ObjectName ; import org . apache . cassandra . concurrent . ScheduledExecutors ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . FBUtilities ; public class DynamicEndpointSnitch extends AbstractEndpointSnitch implements ILatencySubscriber , DynamicEndpointSnitchMBean { private static final double ALPHA = <float> ; private static final int WINDOW_SIZE = <int> ; private final int UPDATE_INTERVAL_IN_MS = DatabaseDescriptor . getDynamicUpdateInterval ( ) ; private final int RESET_INTERVAL_IN_MS = DatabaseDescriptor . getDynamicResetInterval ( ) ; private final double BADNESS_THRESHOLD = DatabaseDescriptor . getDynamicBadnessThreshold ( ) ; private double RANGE_MERGING_PREFERENCE = <float> ; private String mbeanName ; private boolean registered = false ; private volatile HashMap < InetAddress , Double > scores = new HashMap < > ( ) ; private final ConcurrentHashMap < InetAddress , ExponentiallyDecayingReservoir > samples = new ConcurrentHashMap < > ( ) ; public final IEndpointSnitch subsnitch ; public DynamicEndpointSnitch ( IEndpointSnitch snitch ) { this ( snitch , null ) ; } public DynamicEndpointSnitch ( IEndpointSnitch snitch , String instance ) { mbeanName = <str> ; if ( instance ! = null ) mbeanName + = <str> + instance ; subsnitch = snitch ; Runnable update = new Runnable ( ) { public void run ( ) { updateScores ( ) ; } } ; Runnable reset = new Runnable ( ) { public void run ( ) { reset ( ) ; } } ; ScheduledExecutors . scheduledTasks . scheduleWithFixedDelay ( update , UPDATE_INTERVAL_IN_MS , UPDATE_INTERVAL_IN_MS , TimeUnit . MILLISECONDS ) ; ScheduledExecutors . scheduledTasks . scheduleWithFixedDelay ( reset , RESET_INTERVAL_IN_MS , RESET_INTERVAL_IN_MS , TimeUnit . MILLISECONDS ) ; registerMBean ( ) ; } private void registerMBean ( ) { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . registerMBean ( this , new ObjectName ( mbeanName ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } public void unregisterMBean ( ) { MBeanServer mbs = ManagementFactory . getPlatformMBeanServer ( ) ; try { mbs . unregisterMBean ( new ObjectName ( mbeanName ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } @Override public void gossiperStarting ( ) { subsnitch . gossiperStarting ( ) ; } public String getRack ( InetAddress endpoint ) { return subsnitch . getRack ( endpoint ) ; } public String getDatacenter ( InetAddress endpoint ) { return subsnitch . getDatacenter ( endpoint ) ; } public List < InetAddress > getSortedListByProximity ( final InetAddress address , Collection < InetAddress > addresses ) { List < InetAddress > list = new ArrayList < InetAddress > ( addresses ) ; sortByProximity ( address , list ) ; return list ; } @Override public void sortByProximity ( final InetAddress address , List < InetAddress > addresses ) { assert address . equals ( FBUtilities . getBroadcastAddress ( ) ) ; if ( BADNESS_THRESHOLD = = <int> ) { sortByProximityWithScore ( address , addresses ) ; } else { sortByProximityWithBadness ( address , addresses ) ; } } private void sortByProximityWithScore ( final InetAddress address , List < InetAddress > addresses ) { final HashMap < InetAddress , Double > scores = this . scores ; Collections . sort ( addresses , new Comparator < InetAddress > ( ) { public int compare ( InetAddress a1 , InetAddress a2 ) { return compareEndpoints ( address , a1 , a2 , scores ) ; } } ) ; } private void sortByProximityWithBadness ( final InetAddress address , List < InetAddress > addresses ) { if ( addresses . size ( ) < <int> ) return ; subsnitch . sortByProximity ( address , addresses ) ; HashMap < InetAddress , Double > scores = this . scores ; ArrayList < Double > subsnitchOrderedScores = new ArrayList < > ( addresses . size ( ) ) ; for ( InetAddress inet : addresses ) { Double score = scores . get ( inet ) ; if ( score = = null ) return ; subsnitchOrderedScores . add ( score ) ; } ArrayList < Double > sortedScores = new ArrayList < > ( subsnitchOrderedScores ) ; Collections . sort ( sortedScores ) ; Iterator < Double > sortedScoreIterator = sortedScores . iterator ( ) ; for ( Double subsnitchScore : subsnitchOrderedScores ) { if ( subsnitchScore > ( sortedScoreIterator . next ( ) * ( <float> + BADNESS_THRESHOLD ) ) ) { sortByProximityWithScore ( address , addresses ) ; return ; } } } private int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 , Map < InetAddress , Double > scores ) { Double scored1 = scores . get ( a1 ) ; Double scored2 = scores . get ( a2 ) ; if ( scored1 = = null ) { scored1 = <float> ; receiveTiming ( a1 , <int> ) ; } if ( scored2 = = null ) { scored2 = <float> ; receiveTiming ( a2 , <int> ) ; } if ( scored1 . equals ( scored2 ) ) return subsnitch . compareEndpoints ( target , a1 , a2 ) ; if ( scored1 < scored2 ) return - <int> ; else return <int> ; } public int compareEndpoints ( InetAddress target , InetAddress a1 , InetAddress a2 ) { throw new UnsupportedOperationException ( <str> ) ; } public void receiveTiming ( InetAddress host , long latency ) { ExponentiallyDecayingReservoir sample = samples . get ( host ) ; if ( sample = = null ) { ExponentiallyDecayingReservoir maybeNewSample = new ExponentiallyDecayingReservoir ( WINDOW_SIZE , ALPHA ) ; sample = samples . putIfAbsent ( host , maybeNewSample ) ; if ( sample = = null ) sample = maybeNewSample ; } sample . update ( latency ) ; } private void updateScores ( ) { if ( ! StorageService . instance . isInitialized ( ) ) return ; if ( ! registered ) { if ( MessagingService . instance ( ) ! = null ) { MessagingService . instance ( ) . register ( this ) ; registered = true ; } } double maxLatency = <int> ; HashMap < InetAddress , Double > newScores = new HashMap < > ( ) ; for ( Map . Entry < InetAddress , ExponentiallyDecayingReservoir > entry : samples . entrySet ( ) ) { double mean = entry . getValue ( ) . getSnapshot ( ) . getMedian ( ) ; if ( mean > maxLatency ) maxLatency = mean ; } for ( Map . Entry < InetAddress , ExponentiallyDecayingReservoir > entry : samples . entrySet ( ) ) { double score = entry . getValue ( ) . getSnapshot ( ) . getMedian ( ) / maxLatency ; score + = StorageService . instance . getSeverity ( entry . getKey ( ) ) ; newScores . put ( entry . getKey ( ) , score ) ; } scores = newScores ; } private void reset ( ) { samples . clear ( ) ; } public Map < InetAddress , Double > getScores ( ) { return scores ; } public int getUpdateInterval ( ) { return UPDATE_INTERVAL_IN_MS ; } public int getResetInterval ( ) { return RESET_INTERVAL_IN_MS ; } public double getBadnessThreshold ( ) { return BADNESS_THRESHOLD ; } public String getSubsnitchClassName ( ) { return subsnitch . getClass ( ) . getName ( ) ; } public List < Double > dumpTimings ( String hostname ) throws UnknownHostException { InetAddress host = InetAddress . getByName ( hostname ) ; ArrayList < Double > timings = new ArrayList < Double > ( ) ; ExponentiallyDecayingReservoir sample = samples . get ( host ) ; if ( sample ! = null ) { for ( double time : sample . getSnapshot ( ) . getValues ( ) ) timings . add ( time ) ; } return timings ; } public void setSeverity ( double severity ) { StorageService . instance . reportManualSeverity ( severity ) ; } public double getSeverity ( ) { return StorageService . instance . getSeverity ( FBUtilities . getBroadcastAddress ( ) ) ; } public boolean isWorthMergingForRangeQuery ( List < InetAddress > merged , List < InetAddress > l1 , List < InetAddress > l2 ) { if ( ! subsnitch . isWorthMergingForRangeQuery ( merged , l1 , l2 ) ) return false ; if ( l1 . size ( ) = = <int> & & l2 . size ( ) = = <int> & & l1 . get ( <int> ) . equals ( l2 . get ( <int> ) ) ) return true ; double maxMerged = maxScore ( merged ) ; double maxL1 = maxScore ( l1 ) ; double maxL2 = maxScore ( l2 ) ; if ( maxMerged < <int> | | maxL1 < <int> | | maxL2 < <int> ) return true ; return maxMerged < = ( maxL1 + maxL2 ) * RANGE_MERGING_PREFERENCE ; } private double maxScore ( List < InetAddress > endpoints ) { double maxScore = - <float> ; for ( InetAddress endpoint : endpoints ) { Double score = scores . get ( endpoint ) ; if ( score = = null ) continue ; if ( score > maxScore ) maxScore = score ; } return maxScore ; } } 
