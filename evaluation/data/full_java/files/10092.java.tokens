package com . google . common . collect . testing . testers ; import static com . google . common . collect . testing . features . CollectionSize . ZERO ; import static com . google . common . collect . testing . features . MapFeature . ALLOWS_NULL_KEYS ; import static com . google . common . collect . testing . features . MapFeature . ALLOWS_NULL_VALUES ; import static com . google . common . collect . testing . features . MapFeature . FAILS_FAST_ON_CONCURRENT_MODIFICATION ; import static com . google . common . collect . testing . features . MapFeature . SUPPORTS_PUT ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . testing . AbstractMapTester ; import com . google . common . collect . testing . Helpers ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import java . lang . reflect . Method ; import java . util . ConcurrentModificationException ; import java . util . Iterator ; import java . util . Map ; import java . util . Map . Entry ; @SuppressWarnings ( <str> ) @GwtCompatible ( emulated = true ) public class MapPutTester < K , V > extends AbstractMapTester < K , V > { private Entry < K , V > nullKeyEntry ; private Entry < K , V > nullValueEntry ; private Entry < K , V > nullKeyValueEntry ; private Entry < K , V > presentKeyNullValueEntry ; @Override public void setUp ( ) throws Exception { super . setUp ( ) ; nullKeyEntry = entry ( null , v3 ( ) ) ; nullValueEntry = entry ( k3 ( ) , null ) ; nullKeyValueEntry = entry ( null , null ) ; presentKeyNullValueEntry = entry ( k0 ( ) , null ) ; } @MapFeature.Require ( SUPPORTS_PUT ) public void testPut_supportedNotPresent ( ) { assertNull ( <str> , put ( e3 ( ) ) ) ; expectAdded ( e3 ( ) ) ; } @MapFeature.Require ( { FAILS_FAST_ON_CONCURRENT_MODIFICATION , SUPPORTS_PUT } ) @CollectionSize.Require ( absent = ZERO ) public void testPutAbsentConcurrentWithEntrySetIteration ( ) { try { Iterator < Entry < K , V > > iterator = getMap ( ) . entrySet ( ) . iterator ( ) ; put ( e3 ( ) ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @MapFeature.Require ( { FAILS_FAST_ON_CONCURRENT_MODIFICATION , SUPPORTS_PUT } ) @CollectionSize.Require ( absent = ZERO ) public void testPutAbsentConcurrentWithKeySetIteration ( ) { try { Iterator < K > iterator = getMap ( ) . keySet ( ) . iterator ( ) ; put ( e3 ( ) ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @MapFeature.Require ( { FAILS_FAST_ON_CONCURRENT_MODIFICATION , SUPPORTS_PUT } ) @CollectionSize.Require ( absent = ZERO ) public void testPutAbsentConcurrentWithValueIteration ( ) { try { Iterator < V > iterator = getMap ( ) . values ( ) . iterator ( ) ; put ( e3 ( ) ) ; iterator . next ( ) ; fail ( <str> ) ; } catch ( ConcurrentModificationException expected ) { } } @MapFeature.Require ( absent = SUPPORTS_PUT ) public void testPut_unsupportedNotPresent ( ) { try { put ( e3 ( ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } expectUnchanged ( ) ; expectMissing ( e3 ( ) ) ; } @MapFeature.Require ( absent = SUPPORTS_PUT ) @CollectionSize.Require ( absent = ZERO ) public void testPut_unsupportedPresentExistingValue ( ) { try { assertEquals ( <str> , v0 ( ) , put ( e0 ( ) ) ) ; } catch ( UnsupportedOperationException tolerated ) { } expectUnchanged ( ) ; } @MapFeature.Require ( absent = SUPPORTS_PUT ) @CollectionSize.Require ( absent = ZERO ) public void testPut_unsupportedPresentDifferentValue ( ) { try { getMap ( ) . put ( k0 ( ) , v3 ( ) ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } expectUnchanged ( ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_KEYS } ) public void testPut_nullKeySupportedNotPresent ( ) { assertNull ( <str> , put ( nullKeyEntry ) ) ; expectAdded ( nullKeyEntry ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_KEYS } ) @CollectionSize.Require ( absent = ZERO ) public void testPut_nullKeySupportedPresent ( ) { Entry < K , V > newEntry = entry ( null , v3 ( ) ) ; initMapWithNullKey ( ) ; assertEquals ( <str> , getValueForNullKey ( ) , put ( newEntry ) ) ; Entry < K , V > [ ] expected = createArrayWithNullKey ( ) ; expected [ getNullLocation ( ) ] = newEntry ; expectContents ( expected ) ; } @MapFeature.Require ( value = SUPPORTS_PUT , absent = ALLOWS_NULL_KEYS ) public void testPut_nullKeyUnsupported ( ) { try { put ( nullKeyEntry ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } expectUnchanged ( ) ; expectNullKeyMissingWhenNullKeysUnsupported ( <str> ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_VALUES } ) public void testPut_nullValueSupported ( ) { assertNull ( <str> , put ( nullValueEntry ) ) ; expectAdded ( nullValueEntry ) ; } @MapFeature.Require ( value = SUPPORTS_PUT , absent = ALLOWS_NULL_VALUES ) public void testPut_nullValueUnsupported ( ) { try { put ( nullValueEntry ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } expectUnchanged ( ) ; expectNullValueMissingWhenNullValuesUnsupported ( <str> ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_VALUES } ) @CollectionSize.Require ( absent = ZERO ) public void testPut_replaceWithNullValueSupported ( ) { assertEquals ( <str> , v0 ( ) , put ( presentKeyNullValueEntry ) ) ; expectReplacement ( presentKeyNullValueEntry ) ; } @MapFeature.Require ( value = SUPPORTS_PUT , absent = ALLOWS_NULL_VALUES ) @CollectionSize.Require ( absent = ZERO ) public void testPut_replaceWithNullValueUnsupported ( ) { try { put ( presentKeyNullValueEntry ) ; fail ( <str> ) ; } catch ( NullPointerException expected ) { } expectUnchanged ( ) ; expectNullValueMissingWhenNullValuesUnsupported ( <str> ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_VALUES } ) @CollectionSize.Require ( absent = ZERO ) public void testPut_replaceNullValueWithNullSupported ( ) { initMapWithNullValue ( ) ; assertNull ( <str> , getMap ( ) . put ( getKeyForNullValue ( ) , null ) ) ; expectContents ( createArrayWithNullValue ( ) ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_VALUES } ) @CollectionSize.Require ( absent = ZERO ) public void testPut_replaceNullValueWithNonNullSupported ( ) { Entry < K , V > newEntry = entry ( getKeyForNullValue ( ) , v3 ( ) ) ; initMapWithNullValue ( ) ; assertNull ( <str> , put ( newEntry ) ) ; Entry < K , V > [ ] expected = createArrayWithNullValue ( ) ; expected [ getNullLocation ( ) ] = newEntry ; expectContents ( expected ) ; } @MapFeature.Require ( { SUPPORTS_PUT , ALLOWS_NULL_KEYS , ALLOWS_NULL_VALUES } ) public void testPut_nullKeyAndValueSupported ( ) { assertNull ( <str> , put ( nullKeyValueEntry ) ) ; expectAdded ( nullKeyValueEntry ) ; } private V put ( Map . Entry < K , V > entry ) { return getMap ( ) . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } @GwtIncompatible ( <str> ) public static Method getPutNullKeyUnsupportedMethod ( ) { return Helpers . getMethod ( MapPutTester . class , <str> ) ; } } 
