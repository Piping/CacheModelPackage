package org . apache . cassandra . db . marshal ; import static org . junit . Assert . assertEquals ; import java . nio . ByteBuffer ; import java . util . Iterator ; import java . util . Random ; import java . util . UUID ; import org . junit . Test ; import junit . framework . Assert ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . UUIDGen ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; public class UUIDTypeTest { private static final Logger logger = LoggerFactory . getLogger ( UUIDTypeTest . class ) ; UUIDType uuidType = new UUIDType ( ) ; @Test public void testRandomCompare ( ) { UUID t1 = UUIDGen . getTimeUUID ( ) ; UUID t2 = UUIDGen . getTimeUUID ( ) ; testCompare ( null , t2 , - <int> ) ; testCompare ( t1 , null , <int> ) ; testCompare ( t1 , t2 , - <int> ) ; testCompare ( t1 , t1 , <int> ) ; testCompare ( t2 , t2 , <int> ) ; UUID nullId = new UUID ( <int> , <int> ) ; testCompare ( nullId , t1 , - <int> ) ; testCompare ( t2 , nullId , <int> ) ; testCompare ( nullId , nullId , <int> ) ; for ( int test = <int> ; test < <int> ; test + + ) { UUID r1 = UUID . randomUUID ( ) ; UUID r2 = UUID . randomUUID ( ) ; testCompare ( r1 , r2 , compareUUID ( r1 , r2 ) ) ; testCompare ( r1 , r1 , <int> ) ; testCompare ( r2 , r2 , <int> ) ; testCompare ( t1 , r1 , - <int> ) ; testCompare ( r2 , t2 , <int> ) ; } } public static int compareUnsigned ( long n1 , long n2 ) { if ( n1 = = n2 ) { return <int> ; } if ( ( n1 < n2 ) ^ ( ( n1 < <int> ) ! = ( n2 < <int> ) ) ) { return - <int> ; } return <int> ; } public static int compareUUID ( UUID u1 , UUID u2 ) { int c = compareUnsigned ( u1 . getMostSignificantBits ( ) , u2 . getMostSignificantBits ( ) ) ; if ( c ! = <int> ) { return c ; } return compareUnsigned ( u1 . getLeastSignificantBits ( ) , u2 . getLeastSignificantBits ( ) ) ; } public String describeCompare ( UUID u1 , UUID u2 , int c ) { String tb1 = ( u1 = = null ) ? <str> : ( u1 . version ( ) = = <int> ) ? <str> : <str> ; String tb2 = ( u2 = = null ) ? <str> : ( u2 . version ( ) = = <int> ) ? <str> : <str> ; String comp = ( c < <int> ) ? <str> : ( ( c = = <int> ) ? <str> : <str> ) ; return tb1 + u1 + comp + tb2 + u2 ; } public int sign ( int i ) { if ( i < <int> ) { return - <int> ; } if ( i > <int> ) { return <int> ; } return <int> ; } public static ByteBuffer bytebuffer ( UUID uuid ) { if ( uuid = = null ) return ByteBufferUtil . EMPTY_BYTE_BUFFER ; long msb = uuid . getMostSignificantBits ( ) ; long lsb = uuid . getLeastSignificantBits ( ) ; byte [ ] bytes = new byte [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) { bytes [ i ] = ( byte ) ( msb > > > <int> * ( <int> - i ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { bytes [ i ] = ( byte ) ( lsb > > > <int> * ( <int> - i ) ) ; } return ByteBuffer . wrap ( bytes ) ; } public void logJdkUUIDCompareToVariance ( UUID u1 , UUID u2 , int expC ) { if ( ( u1 = = null ) | | ( u2 = = null ) ) return ; if ( u1 . version ( ) ! = u2 . version ( ) ) return ; if ( u1 . version ( ) = = <int> ) return ; if ( u1 . compareTo ( u2 ) ! = expC ) logger . info ( <str> ) ; } public void testCompare ( UUID u1 , UUID u2 , int expC ) { int c = sign ( uuidType . compare ( bytebuffer ( u1 ) , bytebuffer ( u2 ) ) ) ; expC = sign ( expC ) ; assertEquals ( <str> + describeCompare ( u1 , u2 , expC ) + <str> + describeCompare ( u1 , u2 , c ) , expC , c ) ; if ( ( ( u1 ! = null ) & & ( u1 . version ( ) = = <int> ) ) & & ( ( u2 ! = null ) & & ( u2 . version ( ) = = <int> ) ) ) assertEquals ( c , sign ( TimeUUIDType . instance . compare ( bytebuffer ( u1 ) , bytebuffer ( u2 ) ) ) ) ; logJdkUUIDCompareToVariance ( u1 , u2 , c ) ; } @Test public void testTimeEquality ( ) { UUID a = UUIDGen . getTimeUUID ( ) ; UUID b = new UUID ( a . getMostSignificantBits ( ) , a . getLeastSignificantBits ( ) ) ; assertEquals ( <int> , uuidType . compare ( bytebuffer ( a ) , bytebuffer ( b ) ) ) ; } @Test public void testTimeSmaller ( ) { UUID a = UUIDGen . getTimeUUID ( ) ; UUID b = UUIDGen . getTimeUUID ( ) ; UUID c = UUIDGen . getTimeUUID ( ) ; assert uuidType . compare ( bytebuffer ( a ) , bytebuffer ( b ) ) < <int> ; assert uuidType . compare ( bytebuffer ( b ) , bytebuffer ( c ) ) < <int> ; assert uuidType . compare ( bytebuffer ( a ) , bytebuffer ( c ) ) < <int> ; } @Test public void testTimeBigger ( ) { UUID a = UUIDGen . getTimeUUID ( ) ; UUID b = UUIDGen . getTimeUUID ( ) ; UUID c = UUIDGen . getTimeUUID ( ) ; assert uuidType . compare ( bytebuffer ( c ) , bytebuffer ( b ) ) > <int> ; assert uuidType . compare ( bytebuffer ( b ) , bytebuffer ( a ) ) > <int> ; assert uuidType . compare ( bytebuffer ( c ) , bytebuffer ( a ) ) > <int> ; } @Test public void testPermutations ( ) { compareAll ( random ( <int> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> ) ) ; for ( ByteBuffer [ ] permutations : permutations ( <int> , ( byte ) <hex> , ( byte ) <hex> , ( byte ) <hex> ) ) compareAll ( permutations ) ; } private void compareAll ( ByteBuffer [ ] uuids ) { for ( int i = <int> ; i < uuids . length ; i + + ) { for ( int j = i + <int> ; j < uuids . length ; j + + ) { ByteBuffer bi = uuids [ i ] ; ByteBuffer bj = uuids [ j ] ; UUID ui = UUIDGen . getUUID ( bi ) ; UUID uj = UUIDGen . getUUID ( bj ) ; int c = uuidType . compare ( bi , bj ) ; if ( ui . version ( ) ! = uj . version ( ) ) { Assert . assertTrue ( isComparisonEquivalent ( ui . version ( ) - uj . version ( ) , c ) ) ; } else if ( ui . version ( ) = = <int> ) { long i0 = ui . timestamp ( ) ; long i1 = uj . timestamp ( ) ; if ( i0 = = i1 ) Assert . assertTrue ( isComparisonEquivalent ( ByteBufferUtil . compareUnsigned ( bi , bj ) , c ) ) ; else Assert . assertTrue ( isComparisonEquivalent ( Long . compare ( i0 , i1 ) , c ) ) ; } else { Assert . assertTrue ( isComparisonEquivalent ( ByteBufferUtil . compareUnsigned ( bi , bj ) , c ) ) ; } Assert . assertTrue ( isComparisonEquivalent ( compareV1 ( bi , bj ) , c ) ) ; } } } private static boolean isComparisonEquivalent ( int c1 , int c2 ) { c1 = c1 < - <int> ? - <int> : c1 > <int> ? <int> : c1 ; c2 = c2 < - <int> ? - <int> : c2 > <int> ? <int> : c2 ; return c1 = = c2 ; } static Iterable < ByteBuffer [ ] > permutations ( final int randomCount , final byte . . . types ) { final Random random = new Random ( ) ; long seed = random . nextLong ( ) ; random . setSeed ( seed ) ; System . out . println ( <str> + seed ) ; return new Iterable < ByteBuffer [ ] > ( ) { public Iterator < ByteBuffer [ ] > iterator ( ) { return new Iterator < ByteBuffer [ ] > ( ) { byte [ ] bytes = new byte [ <int> ] ; int c = - <int> , i = <int> ; public boolean hasNext ( ) { return i < <int> | | c < randomCount - <int> ; } public ByteBuffer [ ] next ( ) { if ( i = = <int> ) { random . nextBytes ( bytes ) ; i = <int> ; c + + ; } return permute ( bytes , i + + , types ) ; } public void remove ( ) { } } ; } } ; } static ByteBuffer [ ] permute ( byte [ ] src , int byteIndex , byte . . . types ) { assert src . length = = <int> ; assert byteIndex < <int> ; byte [ ] bytes = src . clone ( ) ; ByteBuffer [ ] permute ; if ( byteIndex = = <int> ) { permute = new ByteBuffer [ <int> * types . length ] ; for ( int i = <int> ; i < types . length ; i + + ) { for ( int j = <int> ; j < <int> ; j + + ) { int k = i * <int> + j ; bytes [ <int> ] = ( byte ) ( types [ i ] | j ) ; permute [ k ] = ByteBuffer . wrap ( bytes . clone ( ) ) ; } } } else { permute = new ByteBuffer [ <int> * types . length ] ; for ( int i = <int> ; i < types . length ; i + + ) { bytes [ <int> ] = types [ i ] ; for ( int j = <int> ; j < <int> ; j + + ) { int k = i * <int> + j ; bytes [ byteIndex ] = ( byte ) ( ( bytes [ byteIndex ] & <hex> ) | i ) ; permute [ k ] = ByteBuffer . wrap ( bytes . clone ( ) ) ; } } } return permute ; } static ByteBuffer [ ] random ( int count , byte . . . types ) { Random random = new Random ( ) ; long seed = random . nextLong ( ) ; random . setSeed ( seed ) ; System . out . println ( <str> + seed ) ; ByteBuffer [ ] uuids = new ByteBuffer [ count * types . length ] ; for ( int i = <int> ; i < types . length ; i + + ) { for ( int j = <int> ; j < count ; j + + ) { int k = ( i * count ) + j ; uuids [ k ] = ByteBuffer . allocate ( <int> ) ; random . nextBytes ( uuids [ k ] . array ( ) ) ; uuids [ k ] . array ( ) [ <int> ] & = <hex> ; uuids [ k ] . array ( ) [ <int> ] | = types [ i ] ; } } return uuids ; } private static int compareV1 ( ByteBuffer b1 , ByteBuffer b2 ) { if ( ( b1 = = null ) | | ( b1 . remaining ( ) < <int> ) ) { return ( ( b2 = = null ) | | ( b2 . remaining ( ) < <int> ) ) ? <int> : - <int> ; } if ( ( b2 = = null ) | | ( b2 . remaining ( ) < <int> ) ) { return <int> ; } int s1 = b1 . position ( ) ; int s2 = b2 . position ( ) ; int v1 = ( b1 . get ( s1 + <int> ) > > <int> ) & <hex> ; int v2 = ( b2 . get ( s2 + <int> ) > > <int> ) & <hex> ; if ( v1 ! = v2 ) { return v1 - v2 ; } if ( v1 = = <int> ) { int c = compareTimestampBytes ( b1 , b2 ) ; if ( c ! = <int> ) { return c ; } } for ( int i = <int> ; i < <int> ; i + + ) { int c = ( ( b1 . get ( s1 + i ) ) & <hex> ) - ( ( b2 . get ( s2 + i ) ) & <hex> ) ; if ( c ! = <int> ) { return c ; } } return <int> ; } private static int compareTimestampBytes ( ByteBuffer o1 , ByteBuffer o2 ) { int o1Pos = o1 . position ( ) ; int o2Pos = o2 . position ( ) ; int d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) { return d ; } d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) { return d ; } d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) { return d ; } d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) { return d ; } d = ( o1 . get ( o1Pos ) & <hex> ) - ( o2 . get ( o2Pos ) & <hex> ) ; if ( d ! = <int> ) { return d ; } d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) { return d ; } d = ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; if ( d ! = <int> ) { return d ; } return ( o1 . get ( o1Pos + <int> ) & <hex> ) - ( o2 . get ( o2Pos + <int> ) & <hex> ) ; } } 
