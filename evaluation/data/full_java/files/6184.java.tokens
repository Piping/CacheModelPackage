package org . elasticsearch . discovery . zen . ping ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . component . LifecycleComponent ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . unit . TimeValue ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . atomic . AtomicLong ; import static org . elasticsearch . cluster . ClusterName . readClusterName ; import static org . elasticsearch . cluster . node . DiscoveryNode . readNode ; public interface ZenPing extends LifecycleComponent < ZenPing > { void setPingContextProvider ( PingContextProvider contextProvider ) ; void ping ( PingListener listener , TimeValue timeout ) ; public interface PingListener { void onPing ( PingResponse [ ] pings ) ; } public static class PingResponse implements Streamable { public static final PingResponse [ ] EMPTY = new PingResponse [ <int> ] ; private static final AtomicLong idGenerator = new AtomicLong ( ) ; private long id ; private ClusterName clusterName ; private DiscoveryNode node ; private DiscoveryNode master ; private boolean hasJoinedOnce ; private PingResponse ( ) { } public PingResponse ( DiscoveryNode node , DiscoveryNode master , ClusterName clusterName , boolean hasJoinedOnce ) { this . id = idGenerator . incrementAndGet ( ) ; this . node = node ; this . master = master ; this . clusterName = clusterName ; this . hasJoinedOnce = hasJoinedOnce ; } public long id ( ) { return this . id ; } public ClusterName clusterName ( ) { return this . clusterName ; } public DiscoveryNode node ( ) { return node ; } public DiscoveryNode master ( ) { return master ; } public boolean hasJoinedOnce ( ) { return hasJoinedOnce ; } public static PingResponse readPingResponse ( StreamInput in ) throws IOException { PingResponse response = new PingResponse ( ) ; response . readFrom ( in ) ; return response ; } @Override public void readFrom ( StreamInput in ) throws IOException { clusterName = readClusterName ( in ) ; node = readNode ( in ) ; if ( in . readBoolean ( ) ) { master = readNode ( in ) ; } this . hasJoinedOnce = in . readBoolean ( ) ; this . id = in . readLong ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { clusterName . writeTo ( out ) ; node . writeTo ( out ) ; if ( master = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; master . writeTo ( out ) ; } out . writeBoolean ( hasJoinedOnce ) ; out . writeLong ( id ) ; } @Override public String toString ( ) { return <str> + node + <str> + id + <str> + master + <str> + hasJoinedOnce + <str> + clusterName . value ( ) + <str> ; } } public static class PingCollection { Map < DiscoveryNode , PingResponse > pings ; public PingCollection ( ) { pings = new HashMap < > ( ) ; } public synchronized boolean addPing ( PingResponse ping ) { PingResponse existingResponse = pings . get ( ping . node ( ) ) ; if ( existingResponse = = null | | existingResponse . id ( ) < = ping . id ( ) ) { pings . put ( ping . node ( ) , ping ) ; return true ; } return false ; } public synchronized void addPings ( PingResponse [ ] pings ) { for ( PingResponse ping : pings ) { addPing ( ping ) ; } } public synchronized PingResponse [ ] toArray ( ) { return pings . values ( ) . toArray ( new PingResponse [ pings . size ( ) ] ) ; } public synchronized int size ( ) { return pings . size ( ) ; } } } 
