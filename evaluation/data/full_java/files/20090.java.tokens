package io . netty . microbenchmark . common ; import io . netty . microbench . util . AbstractMicrobenchmark ; import io . netty . util . AsciiString ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . PlatformDependent ; import org . openjdk . jmh . annotations . Benchmark ; import org . openjdk . jmh . annotations . Level ; import org . openjdk . jmh . annotations . Measurement ; import org . openjdk . jmh . annotations . Param ; import org . openjdk . jmh . annotations . Setup ; import org . openjdk . jmh . annotations . Threads ; import org . openjdk . jmh . annotations . Warmup ; import java . util . Random ; @Threads ( <int> ) @Measurement ( iterations = <int> ) @Warmup ( iterations = <int> ) public class AsciiStringBenchmark extends AbstractMicrobenchmark { @Param ( { <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) public int size ; private AsciiString asciiString ; private String string ; private static final Random random = new Random ( ) ; @Setup ( Level . Trial ) public void setup ( ) { byte [ ] bytes = new byte [ size ] ; random . nextBytes ( bytes ) ; asciiString = new AsciiString ( bytes , false ) ; string = new String ( bytes , CharsetUtil . US_ASCII ) ; } @Benchmark public int hashCodeBenchBytesOld ( ) { int h = <int> ; final int end = asciiString . arrayOffset ( ) + asciiString . length ( ) ; for ( int i = asciiString . arrayOffset ( ) ; i < end ; + + i ) { h = h * <int> + ( asciiString . array ( ) [ i ] & <hex> ) ; } return h ; } @Benchmark public int hashCodeBenchBytesNew ( ) { return PlatformDependent . hashCodeAscii ( asciiString . array ( ) , asciiString . arrayOffset ( ) , asciiString . length ( ) ) ; } @Benchmark public int hashCodeBenchCharSequenceOld ( ) { int h = <int> ; for ( int i = <int> ; i < string . length ( ) ; + + i ) { h = h * <int> + ( string . charAt ( i ) & <hex> ) ; } return h ; } @Benchmark public int hashCodeBenchCharSequenceNew ( ) { return PlatformDependent . hashCodeAscii ( string ) ; } } 
