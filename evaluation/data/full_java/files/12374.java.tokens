package org . gradle . api . internal . artifacts . dsl . dependencies ; import groovy . lang . Closure ; import org . gradle . api . artifacts . ClientModule ; import org . gradle . api . artifacts . Dependency ; import org . gradle . api . artifacts . ModuleDependency ; import org . gradle . api . internal . artifacts . dependencies . DefaultClientModule ; import org . gradle . util . TestUtil ; import org . gradle . util . WrapUtil ; import org . hamcrest . Matchers ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Test ; import static org . junit . Assert . assertThat ; public class ModuleFactoryDelegateTest { private JUnit4Mockery context = new JUnit4Mockery ( ) ; private DependencyFactory dependencyFactoryStub = context . mock ( DependencyFactory . class ) ; private ClientModule clientModule = new DefaultClientModule ( <str> , <str> , <str> ) ; private ModuleFactoryDelegate moduleFactoryDelegate = new ModuleFactoryDelegate ( clientModule , dependencyFactoryStub ) ; @Test public void dependency ( ) { final String dependencyNotation = <str> ; final ModuleDependency dependencyDummy = context . mock ( ModuleDependency . class ) ; letFactoryStubReturnDependency ( dependencyNotation , dependencyDummy ) ; moduleFactoryDelegate . dependency ( dependencyNotation ) ; assertThat ( clientModule . getDependencies ( ) , Matchers . equalTo ( WrapUtil . toSet ( dependencyDummy ) ) ) ; } @Test public void dependencyWithClosure ( ) { final String dependencyNotation = <str> ; final Closure configureClosure = TestUtil . toClosure ( <str> ) ; final ModuleDependency dependencyDummy = context . mock ( ModuleDependency . class ) ; letFactoryStubReturnDependency ( dependencyNotation , dependencyDummy ) ; moduleFactoryDelegate . dependency ( dependencyNotation , configureClosure ) ; assertThat ( clientModule . getDependencies ( ) , Matchers . equalTo ( WrapUtil . toSet ( dependencyDummy ) ) ) ; } @Test public void dependencies ( ) { final String dependencyNotation1 = <str> ; final String dependencyNotation2 = <str> ; final ModuleDependency dependencyDummy1 = context . mock ( ModuleDependency . class , <str> ) ; final ModuleDependency dependencyDummy2 = context . mock ( ModuleDependency . class , <str> ) ; letFactoryStubReturnDependency ( dependencyNotation1 , dependencyDummy1 ) ; letFactoryStubReturnDependency ( dependencyNotation2 , dependencyDummy2 ) ; moduleFactoryDelegate . dependencies ( ( Object [ ] ) WrapUtil . toArray ( dependencyNotation1 , dependencyNotation2 ) ) ; assertThat ( clientModule . getDependencies ( ) , Matchers . equalTo ( WrapUtil . toSet ( dependencyDummy1 , dependencyDummy2 ) ) ) ; } private void letFactoryStubReturnDependency ( final String dependencyNotation , final Dependency dependencyDummy ) { context . checking ( new Expectations ( ) { { allowing ( dependencyFactoryStub ) . createDependency ( dependencyNotation ) ; will ( returnValue ( dependencyDummy ) ) ; } } ) ; } @Test public void module ( ) { final String clientModuleNotation = <str> ; final Closure configureClosure = TestUtil . toClosure ( <str> ) ; final ClientModule clientModuleDummy = context . mock ( ClientModule . class ) ; context . checking ( new Expectations ( ) { { allowing ( dependencyFactoryStub ) . createModule ( clientModuleNotation , configureClosure ) ; will ( returnValue ( clientModuleDummy ) ) ; } } ) ; moduleFactoryDelegate . module ( clientModuleNotation , configureClosure ) ; assertThat ( this . clientModule . getDependencies ( ) , Matchers . equalTo ( WrapUtil . < ModuleDependency > toSet ( clientModuleDummy ) ) ) ; } } 
