package com . google . common . cache ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . Maps ; import com . google . common . util . concurrent . Futures ; import com . google . common . util . concurrent . ListenableFuture ; import java . util . Map ; import java . util . concurrent . atomic . AtomicInteger ; import javax . annotation . Nullable ; @GwtCompatible ( emulated = true ) class TestingCacheLoaders { static < K , V > CacheLoader < K , V > bulkLoader ( final CacheLoader < K , V > loader ) { checkNotNull ( loader ) ; return new CacheLoader < K , V > ( ) { @Override public V load ( K key ) throws Exception { return loader . load ( key ) ; } @Override public Map < K , V > loadAll ( Iterable < ? extends K > keys ) throws Exception { Map < K , V > result = Maps . newHashMap ( ) ; for ( K key : keys ) { result . put ( key , load ( key ) ) ; } return result ; } } ; } static < K , V > ConstantLoader < K , V > constantLoader ( @Nullable V constant ) { return new ConstantLoader < K , V > ( constant ) ; } static IncrementingLoader incrementingLoader ( ) { return new IncrementingLoader ( ) ; } static < K , V > CacheLoader < K , V > errorLoader ( final Error e ) { checkNotNull ( e ) ; return new CacheLoader < K , V > ( ) { @Override public V load ( K key ) { throw e ; } } ; } static < K , V > CacheLoader < K , V > exceptionLoader ( final Exception e ) { checkNotNull ( e ) ; return new CacheLoader < K , V > ( ) { @Override public V load ( K key ) throws Exception { throw e ; } } ; } static < T > IdentityLoader < T > identityLoader ( ) { return new IdentityLoader < T > ( ) ; } static class CountingLoader extends CacheLoader < Object , Object > { private final AtomicInteger count = new AtomicInteger ( ) ; @Override public Object load ( Object from ) { count . incrementAndGet ( ) ; return new Object ( ) ; } public int getCount ( ) { return count . get ( ) ; } } static final class ConstantLoader < K , V > extends CacheLoader < K , V > { private final V constant ; ConstantLoader ( V constant ) { this . constant = constant ; } @Override public V load ( K key ) { return constant ; } } static class IncrementingLoader extends CacheLoader < Integer , Integer > { private final AtomicInteger countLoad = new AtomicInteger ( ) ; private final AtomicInteger countReload = new AtomicInteger ( ) ; @Override public Integer load ( Integer key ) { countLoad . incrementAndGet ( ) ; return key ; } @GwtIncompatible ( <str> ) @Override public ListenableFuture < Integer > reload ( Integer key , Integer oldValue ) { countReload . incrementAndGet ( ) ; return Futures . immediateFuture ( oldValue + <int> ) ; } public int getLoadCount ( ) { return countLoad . get ( ) ; } public int getReloadCount ( ) { return countReload . get ( ) ; } } static final class IdentityLoader < T > extends CacheLoader < T , T > { @Override public T load ( T key ) { return key ; } } } 
