package org . apache . cassandra . io . sstable ; import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Random ; import java . util . Set ; import org . junit . Assert ; import org . junit . BeforeClass ; import org . junit . Ignore ; import org . junit . Test ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DeletionTime ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . rows . SliceableUnfilteredRowIterator ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . db . marshal . BytesType ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableFormat ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . format . Version ; import org . apache . cassandra . io . sstable . format . big . BigFormat ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . CacheService ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . streaming . StreamPlan ; import org . apache . cassandra . streaming . StreamSession ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; public class LegacySSTableTest { private static final Logger logger = LoggerFactory . getLogger ( LegacySSTableTest . class ) ; public static final String LEGACY_SSTABLE_PROP = <str> ; public static final String KSNAME = <str> ; public static final String CFNAME = <str> ; public static Set < String > TEST_DATA ; public static File LEGACY_SSTABLE_ROOT ; public static final String [ ] legacyVersions = { <str> , <str> , <str> , <str> } ; static final String longString = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; CFMetaData metadata = CFMetaData . Builder . createDense ( KSNAME , CFNAME , false , false ) . addPartitionKey ( <str> , BytesType . instance ) . addClusteringColumn ( <str> , BytesType . instance ) . addRegularColumn ( <str> , BytesType . instance ) . build ( ) ; SchemaLoader . createKeyspace ( KSNAME , KeyspaceParams . simple ( <int> ) , metadata ) ; beforeClass ( ) ; } public static void beforeClass ( ) { Keyspace . setInitialized ( ) ; String scp = System . getProperty ( LEGACY_SSTABLE_PROP ) ; assert scp ! = null ; LEGACY_SSTABLE_ROOT = new File ( scp ) . getAbsoluteFile ( ) ; assert LEGACY_SSTABLE_ROOT . isDirectory ( ) ; TEST_DATA = new HashSet < String > ( ) ; for ( int i = <int> ; i < <int> ; + + i ) TEST_DATA . add ( Integer . toString ( i ) ) ; } protected Descriptor getDescriptor ( String ver ) { File directory = new File ( LEGACY_SSTABLE_ROOT + File . separator + ver + File . separator + KSNAME ) ; return new Descriptor ( ver , directory , KSNAME , CFNAME , <int> , SSTableFormat . Type . LEGACY ) ; } @Test public void testStreaming ( ) throws Throwable { StorageService . instance . initServer ( ) ; for ( File version : LEGACY_SSTABLE_ROOT . listFiles ( ) ) { if ( ! new File ( LEGACY_SSTABLE_ROOT + File . separator + version . getName ( ) + File . separator + KSNAME ) . isDirectory ( ) ) continue ; if ( Version . validate ( version . getName ( ) ) & & SSTableFormat . Type . LEGACY . info . getVersion ( version . getName ( ) ) . isCompatibleForStreaming ( ) ) testStreaming ( version . getName ( ) ) ; } } private void testStreaming ( String version ) throws Exception { SSTableReader sstable = SSTableReader . open ( getDescriptor ( version ) ) ; IPartitioner p = sstable . getPartitioner ( ) ; List < Range < Token > > ranges = new ArrayList < > ( ) ; ranges . add ( new Range < > ( p . getMinimumToken ( ) , p . getToken ( ByteBufferUtil . bytes ( <str> ) ) ) ) ; ranges . add ( new Range < > ( p . getToken ( ByteBufferUtil . bytes ( <str> ) ) , p . getMinimumToken ( ) ) ) ; ArrayList < StreamSession . SSTableStreamingSections > details = new ArrayList < > ( ) ; details . add ( new StreamSession . SSTableStreamingSections ( sstable . ref ( ) , sstable . getPositionsForRanges ( ranges ) , sstable . estimatedKeysForRanges ( ranges ) , sstable . getSSTableMetadata ( ) . repairedAt ) ) ; new StreamPlan ( <str> ) . transferFiles ( FBUtilities . getBroadcastAddress ( ) , details ) . execute ( ) . get ( ) ; ColumnFamilyStore cfs = Keyspace . open ( KSNAME ) . getColumnFamilyStore ( CFNAME ) ; assert cfs . getLiveSSTables ( ) . size ( ) = = <int> ; sstable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; for ( String keystring : TEST_DATA ) { ByteBuffer key = bytes ( keystring ) ; SliceableUnfilteredRowIterator iter = sstable . iterator ( Util . dk ( key ) , ColumnFilter . selectionBuilder ( ) . add ( cfs . metadata . getColumnDefinition ( bytes ( <str> ) ) ) . build ( ) , false , false ) ; assert iter . partitionLevelDeletion ( ) . equals ( DeletionTime . LIVE ) ; assert iter . next ( ) . clustering ( ) . get ( <int> ) . equals ( key ) ; } sstable . selfRef ( ) . release ( ) ; } @Test public void testVersions ( ) throws Throwable { boolean notSkipped = false ; for ( File version : LEGACY_SSTABLE_ROOT . listFiles ( ) ) { if ( ! new File ( LEGACY_SSTABLE_ROOT + File . separator + version . getName ( ) + File . separator + KSNAME ) . isDirectory ( ) ) continue ; if ( Version . validate ( version . getName ( ) ) & & SSTableFormat . Type . LEGACY . info . getVersion ( version . getName ( ) ) . isCompatible ( ) ) { notSkipped = true ; testVersion ( version . getName ( ) ) ; } } assert notSkipped ; } public void testVersion ( String version ) throws Throwable { try { ColumnFamilyStore cfs = Keyspace . open ( KSNAME ) . getColumnFamilyStore ( CFNAME ) ; SSTableReader reader = SSTableReader . open ( getDescriptor ( version ) ) ; for ( String keystring : TEST_DATA ) { ByteBuffer key = bytes ( keystring ) ; SliceableUnfilteredRowIterator iter = reader . iterator ( Util . dk ( key ) , ColumnFilter . selection ( cfs . metadata . partitionColumns ( ) ) , false , false ) ; assert iter . partitionLevelDeletion ( ) . equals ( DeletionTime . LIVE ) ; assert iter . next ( ) . clustering ( ) . get ( <int> ) . equals ( key ) ; } } catch ( Throwable e ) { System . err . println ( <str> + version ) ; throw e ; } } @Test public void testLegacyCqlTables ( ) throws Exception { createKeyspace ( ) ; loadLegacyTables ( ) ; } private static void loadLegacyTables ( ) throws Exception { for ( String legacyVersion : legacyVersions ) { logger . info ( <str> , legacyVersion ) ; createTables ( legacyVersion ) ; loadLegacyTable ( <str> , legacyVersion ) ; loadLegacyTable ( <str> , legacyVersion ) ; loadLegacyTable ( <str> , legacyVersion ) ; loadLegacyTable ( <str> , legacyVersion ) ; CacheService . instance . invalidateKeyCache ( ) ; long startCount = CacheService . instance . keyCache . size ( ) ; for ( int ck = <int> ; ck < <int> ; ck + + ) { String ckValue = Integer . toString ( ck ) + longString ; for ( int pk = <int> ; pk < <int> ; pk + + ) { logger . debug ( <str> , pk , ck ) ; String pkValue = Integer . toString ( pk ) ; UntypedResultSet rs ; if ( ck = = <int> ) { rs = QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) , pkValue ) ; Assert . assertNotNull ( rs ) ; Assert . assertEquals ( <int> , rs . size ( ) ) ; Assert . assertEquals ( <str> , rs . one ( ) . getString ( <str> ) ) ; rs = QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) , pkValue ) ; Assert . assertNotNull ( rs ) ; Assert . assertEquals ( <int> , rs . size ( ) ) ; Assert . assertEquals ( <int> , rs . one ( ) . getLong ( <str> ) ) ; } rs = QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) , pkValue , ckValue ) ; assertLegacyClustRows ( <int> , rs ) ; String ckValue2 = Integer . toString ( ck < <int> ? <int> : ck - <int> ) + longString ; String ckValue3 = Integer . toString ( ck > <int> ? <int> : ck + <int> ) + longString ; rs = QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) , pkValue , ckValue , ckValue2 , ckValue3 ) ; assertLegacyClustRows ( <int> , rs ) ; rs = QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) , pkValue , ckValue ) ; Assert . assertNotNull ( rs ) ; Assert . assertEquals ( <int> , rs . size ( ) ) ; Assert . assertEquals ( <int> , rs . one ( ) . getLong ( <str> ) ) ; } } long endCount = CacheService . instance . keyCache . size ( ) ; Assert . assertTrue ( endCount > startCount ) ; CacheService . instance . keyCache . submitWrite ( Integer . MAX_VALUE ) . get ( ) ; CacheService . instance . invalidateKeyCache ( ) ; Assert . assertEquals ( startCount , CacheService . instance . keyCache . size ( ) ) ; CacheService . instance . keyCache . loadSaved ( ) ; if ( BigFormat . instance . getVersion ( legacyVersion ) . storeRows ( ) ) Assert . assertEquals ( endCount , CacheService . instance . keyCache . size ( ) ) ; else Assert . assertEquals ( startCount , CacheService . instance . keyCache . size ( ) ) ; } } private void createKeyspace ( ) { QueryProcessor . executeInternal ( <str> ) ; } private static void createTables ( String legacyVersion ) { QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , legacyVersion ) ) ; } private static void assertLegacyClustRows ( int count , UntypedResultSet rs ) { Assert . assertNotNull ( rs ) ; Assert . assertEquals ( count , rs . size ( ) ) ; for ( int i = <int> ; i < count ; i + + ) { for ( UntypedResultSet . Row r : rs ) { Assert . assertEquals ( <int> , r . getString ( <str> ) . length ( ) ) ; } } } private static void loadLegacyTable ( String tablePattern , String legacyVersion ) throws IOException { String table = String . format ( tablePattern , legacyVersion ) ; logger . info ( <str> , table ) ; ColumnFamilyStore cfs = Keyspace . open ( <str> ) . getColumnFamilyStore ( table ) ; for ( File cfDir : cfs . getDirectories ( ) . getCFDirectories ( ) ) { copySstablesToTestData ( legacyVersion , table , cfDir ) ; } cfs . loadNewSSTables ( ) ; } @Test @Ignore public void testGenerateSstables ( ) throws Throwable { createKeyspace ( ) ; createTables ( BigFormat . latestVersion . getVersion ( ) ) ; Random rand = new Random ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { sb . append ( ( char ) ( <str> + rand . nextInt ( <int> ) ) ) ; } String randomString = sb . toString ( ) ; for ( int pk = <int> ; pk < <int> ; pk + + ) { String valPk = Integer . toString ( pk ) ; QueryProcessor . executeInternal ( String . format ( <str> , BigFormat . latestVersion , valPk , <str> ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , BigFormat . latestVersion , valPk ) ) ; for ( int ck = <int> ; ck < <int> ; ck + + ) { String valCk = Integer . toString ( ck ) ; QueryProcessor . executeInternal ( String . format ( <str> , BigFormat . latestVersion , valPk , valCk + longString , randomString ) ) ; QueryProcessor . executeInternal ( String . format ( <str> , BigFormat . latestVersion , valPk , valCk + longString ) ) ; } } StorageService . instance . forceKeyspaceFlush ( <str> ) ; File ksDir = new File ( LEGACY_SSTABLE_ROOT , String . format ( <str> , BigFormat . latestVersion ) ) ; ksDir . mkdirs ( ) ; copySstablesFromTestData ( String . format ( <str> , BigFormat . latestVersion ) , ksDir ) ; copySstablesFromTestData ( String . format ( <str> , BigFormat . latestVersion ) , ksDir ) ; copySstablesFromTestData ( String . format ( <str> , BigFormat . latestVersion ) , ksDir ) ; copySstablesFromTestData ( String . format ( <str> , BigFormat . latestVersion ) , ksDir ) ; } private void copySstablesFromTestData ( String table , File ksDir ) throws IOException { File cfDir = new File ( ksDir , table ) ; cfDir . mkdir ( ) ; for ( File srcDir : Keyspace . open ( <str> ) . getColumnFamilyStore ( table ) . getDirectories ( ) . getCFDirectories ( ) ) { for ( File file : srcDir . listFiles ( ) ) { copyFile ( cfDir , file ) ; } } } private static void copySstablesToTestData ( String legacyVersion , String table , File cfDir ) throws IOException { for ( File file : new File ( LEGACY_SSTABLE_ROOT , String . format ( <str> , legacyVersion , table ) ) . listFiles ( ) ) { copyFile ( cfDir , file ) ; } } private static void copyFile ( File cfDir , File file ) throws IOException { byte [ ] buf = new byte [ <int> ] ; if ( file . isFile ( ) ) { File target = new File ( cfDir , file . getName ( ) ) ; int rd ; FileInputStream is = new FileInputStream ( file ) ; FileOutputStream os = new FileOutputStream ( target ) ; while ( ( rd = is . read ( buf ) ) > = <int> ) os . write ( buf , <int> , rd ) ; } } } 
