package com . google . common . cache ; import static com . google . common . cache . CacheBuilderSpec . parse ; import static com . google . common . cache . TestingWeighers . constantWeigher ; import com . google . common . base . Suppliers ; import com . google . common . cache . LocalCache . Strength ; import com . google . common . testing . EqualsTester ; import junit . framework . TestCase ; import java . util . concurrent . TimeUnit ; public class CacheBuilderSpecTest extends TestCase { public void testParse_empty ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertNull ( spec . maximumSize ) ; assertNull ( spec . maximumWeight ) ; assertNull ( spec . concurrencyLevel ) ; assertNull ( spec . keyStrength ) ; assertNull ( spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) , CacheBuilder . from ( spec ) ) ; } public void testParse_initialCapacity ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertEquals ( <int> , spec . initialCapacity . intValue ( ) ) ; assertNull ( spec . maximumSize ) ; assertNull ( spec . maximumWeight ) ; assertNull ( spec . concurrencyLevel ) ; assertNull ( spec . keyStrength ) ; assertNull ( spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . initialCapacity ( <int> ) , CacheBuilder . from ( spec ) ) ; } public void testParse_initialCapacityRepeated ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_maximumSize ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertEquals ( <int> , spec . maximumSize . longValue ( ) ) ; assertNull ( spec . concurrencyLevel ) ; assertNull ( spec . keyStrength ) ; assertNull ( spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . maximumSize ( <int> ) , CacheBuilder . from ( spec ) ) ; } public void testParse_maximumSizeRepeated ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_maximumWeight ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertEquals ( <int> , spec . maximumWeight . longValue ( ) ) ; assertNull ( spec . concurrencyLevel ) ; assertNull ( spec . keyStrength ) ; assertNull ( spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . maximumWeight ( <int> ) , CacheBuilder . from ( spec ) ) ; } public void testParse_maximumWeightRepeated ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_maximumSizeAndMaximumWeight ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_concurrencyLevel ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertNull ( spec . maximumSize ) ; assertNull ( spec . maximumWeight ) ; assertEquals ( <int> , spec . concurrencyLevel . intValue ( ) ) ; assertNull ( spec . keyStrength ) ; assertNull ( spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . concurrencyLevel ( <int> ) , CacheBuilder . from ( spec ) ) ; } public void testParse_concurrencyLevelRepeated ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_weakKeys ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertNull ( spec . maximumSize ) ; assertNull ( spec . maximumWeight ) ; assertNull ( spec . concurrencyLevel ) ; assertEquals ( Strength . WEAK , spec . keyStrength ) ; assertNull ( spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . weakKeys ( ) , CacheBuilder . from ( spec ) ) ; } public void testParse_weakKeysCannotHaveValue ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_repeatedKeyStrength ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_softValues ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertNull ( spec . maximumSize ) ; assertNull ( spec . maximumWeight ) ; assertNull ( spec . concurrencyLevel ) ; assertNull ( spec . keyStrength ) ; assertEquals ( Strength . SOFT , spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . softValues ( ) , CacheBuilder . from ( spec ) ) ; } public void testParse_softValuesCannotHaveValue ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_weakValues ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertNull ( spec . maximumSize ) ; assertNull ( spec . maximumWeight ) ; assertNull ( spec . concurrencyLevel ) ; assertNull ( spec . keyStrength ) ; assertEquals ( Strength . WEAK , spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . weakValues ( ) , CacheBuilder . from ( spec ) ) ; } public void testParse_weakValuesCannotHaveValue ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_repeatedValueStrength ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_writeExpirationDays ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertNull ( spec . maximumSize ) ; assertNull ( spec . maximumWeight ) ; assertNull ( spec . concurrencyLevel ) ; assertNull ( spec . keyStrength ) ; assertNull ( spec . valueStrength ) ; assertEquals ( TimeUnit . DAYS , spec . writeExpirationTimeUnit ) ; assertEquals ( <int> , spec . writeExpirationDuration ) ; assertNull ( spec . accessExpirationTimeUnit ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . DAYS ) , CacheBuilder . from ( spec ) ) ; } public void testParse_writeExpirationHours ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertEquals ( TimeUnit . HOURS , spec . writeExpirationTimeUnit ) ; assertEquals ( <int> , spec . writeExpirationDuration ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . HOURS ) , CacheBuilder . from ( spec ) ) ; } public void testParse_writeExpirationMinutes ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertEquals ( TimeUnit . MINUTES , spec . writeExpirationTimeUnit ) ; assertEquals ( <int> , spec . writeExpirationDuration ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MINUTES ) , CacheBuilder . from ( spec ) ) ; } public void testParse_writeExpirationSeconds ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertEquals ( TimeUnit . SECONDS , spec . writeExpirationTimeUnit ) ; assertEquals ( <int> , spec . writeExpirationDuration ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . SECONDS ) , CacheBuilder . from ( spec ) ) ; } public void testParse_writeExpirationRepeated ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_accessExpirationDays ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertNull ( spec . initialCapacity ) ; assertNull ( spec . maximumSize ) ; assertNull ( spec . maximumWeight ) ; assertNull ( spec . concurrencyLevel ) ; assertNull ( spec . keyStrength ) ; assertNull ( spec . valueStrength ) ; assertNull ( spec . writeExpirationTimeUnit ) ; assertEquals ( TimeUnit . DAYS , spec . accessExpirationTimeUnit ) ; assertEquals ( <int> , spec . accessExpirationDuration ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterAccess ( <int> , TimeUnit . DAYS ) , CacheBuilder . from ( spec ) ) ; } public void testParse_accessExpirationHours ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertEquals ( TimeUnit . HOURS , spec . accessExpirationTimeUnit ) ; assertEquals ( <int> , spec . accessExpirationDuration ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterAccess ( <int> , TimeUnit . HOURS ) , CacheBuilder . from ( spec ) ) ; } public void testParse_accessExpirationMinutes ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertEquals ( TimeUnit . MINUTES , spec . accessExpirationTimeUnit ) ; assertEquals ( <int> , spec . accessExpirationDuration ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterAccess ( <int> , TimeUnit . MINUTES ) , CacheBuilder . from ( spec ) ) ; } public void testParse_accessExpirationSeconds ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertEquals ( TimeUnit . SECONDS , spec . accessExpirationTimeUnit ) ; assertEquals ( <int> , spec . accessExpirationDuration ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterAccess ( <int> , TimeUnit . SECONDS ) , CacheBuilder . from ( spec ) ) ; } public void testParse_accessExpirationRepeated ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_recordStats ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertTrue ( spec . recordStats ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . recordStats ( ) , CacheBuilder . from ( spec ) ) ; } public void testParse_recordStatsValueSpecified ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_recordStatsRepeated ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_accessExpirationAndWriteExpiration ( ) { CacheBuilderSpec spec = parse ( <str> ) ; assertEquals ( TimeUnit . MINUTES , spec . writeExpirationTimeUnit ) ; assertEquals ( <int> , spec . writeExpirationDuration ) ; assertEquals ( TimeUnit . SECONDS , spec . accessExpirationTimeUnit ) ; assertEquals ( <int> , spec . accessExpirationDuration ) ; assertCacheBuilderEquivalence ( CacheBuilder . newBuilder ( ) . expireAfterAccess ( <int> , TimeUnit . SECONDS ) . expireAfterWrite ( <int> , TimeUnit . MINUTES ) , CacheBuilder . from ( spec ) ) ; } public void testParse_multipleKeys ( ) { CacheBuilderSpec spec = parse ( <str> + <str> ) ; assertEquals ( <int> , spec . initialCapacity . intValue ( ) ) ; assertEquals ( <int> , spec . maximumSize . intValue ( ) ) ; assertNull ( spec . maximumWeight ) ; assertEquals ( <int> , spec . concurrencyLevel . intValue ( ) ) ; assertEquals ( Strength . WEAK , spec . keyStrength ) ; assertEquals ( Strength . WEAK , spec . valueStrength ) ; assertEquals ( TimeUnit . HOURS , spec . writeExpirationTimeUnit ) ; assertEquals ( TimeUnit . MINUTES , spec . accessExpirationTimeUnit ) ; assertEquals ( <int> , spec . writeExpirationDuration ) ; assertEquals ( <int> , spec . accessExpirationDuration ) ; CacheBuilder < ? , ? > expected = CacheBuilder . newBuilder ( ) . initialCapacity ( <int> ) . maximumSize ( <int> ) . concurrencyLevel ( <int> ) . weakKeys ( ) . weakValues ( ) . expireAfterAccess ( <int> , TimeUnit . MINUTES ) . expireAfterWrite ( <int> , TimeUnit . HOURS ) ; assertCacheBuilderEquivalence ( expected , CacheBuilder . from ( spec ) ) ; } public void testParse_whitespaceAllowed ( ) { CacheBuilderSpec spec = parse ( <str> + <str> ) ; assertEquals ( <int> , spec . initialCapacity . intValue ( ) ) ; assertEquals ( <int> , spec . maximumSize . intValue ( ) ) ; assertNull ( spec . maximumWeight ) ; assertNull ( spec . concurrencyLevel ) ; assertEquals ( Strength . WEAK , spec . keyStrength ) ; assertEquals ( Strength . SOFT , spec . valueStrength ) ; assertEquals ( TimeUnit . SECONDS , spec . writeExpirationTimeUnit ) ; assertEquals ( <int> , spec . writeExpirationDuration ) ; assertNull ( spec . accessExpirationTimeUnit ) ; CacheBuilder < ? , ? > expected = CacheBuilder . newBuilder ( ) . initialCapacity ( <int> ) . maximumSize ( <int> ) . weakKeys ( ) . softValues ( ) . expireAfterWrite ( <int> , TimeUnit . SECONDS ) ; assertCacheBuilderEquivalence ( expected , CacheBuilder . from ( spec ) ) ; } public void testParse_unknownKey ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testParse_extraCommaIsInvalid ( ) { try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } try { parse ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testEqualsAndHashCode ( ) { new EqualsTester ( ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . addEqualityGroup ( parse ( <str> ) , parse ( <str> ) ) . testEquals ( ) ; } public void testMaximumWeight_withWeigher ( ) { CacheBuilder < Object , Object > builder = CacheBuilder . from ( parse ( <str> ) ) ; builder . weigher ( constantWeigher ( <int> ) ) . build ( CacheLoader . from ( Suppliers . ofInstance ( null ) ) ) ; } public void testMaximumWeight_withoutWeigher ( ) { CacheBuilder < Object , Object > builder = CacheBuilder . from ( parse ( <str> ) ) ; try { builder . build ( CacheLoader . from ( Suppliers . ofInstance ( null ) ) ) ; fail ( ) ; } catch ( IllegalStateException expected ) { } } public void testMaximumSize_withWeigher ( ) { CacheBuilder < Object , Object > builder = CacheBuilder . from ( parse ( <str> ) ) ; builder . weigher ( constantWeigher ( <int> ) ) . build ( CacheLoader . from ( Suppliers . ofInstance ( null ) ) ) ; } public void testMaximumSize_withoutWeigher ( ) { CacheBuilder < Object , Object > builder = CacheBuilder . from ( parse ( <str> ) ) ; builder . build ( CacheLoader . from ( Suppliers . ofInstance ( null ) ) ) ; } public void testDisableCaching ( ) { CacheBuilder < Object , Object > builder = CacheBuilder . from ( CacheBuilderSpec . disableCaching ( ) ) ; Object key = new Object ( ) ; Object value = new Object ( ) ; LoadingCache < Object , Object > cache = builder . build ( CacheLoader . from ( Suppliers . ofInstance ( value ) ) ) ; assertSame ( value , cache . getUnchecked ( key ) ) ; assertEquals ( <int> , cache . size ( ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( key ) ) ; } public void testCacheBuilderFrom_string ( ) { CacheBuilder < ? , ? > fromString = CacheBuilder . from ( <str> + <str> ) ; CacheBuilder < ? , ? > expected = CacheBuilder . newBuilder ( ) . initialCapacity ( <int> ) . maximumSize ( <int> ) . concurrencyLevel ( <int> ) . weakKeys ( ) . weakValues ( ) . expireAfterAccess ( <int> , TimeUnit . MINUTES ) ; assertCacheBuilderEquivalence ( expected , fromString ) ; } private static void assertCacheBuilderEquivalence ( CacheBuilder < ? , ? > a , CacheBuilder < ? , ? > b ) { assertEquals ( <str> , a . concurrencyLevel , b . concurrencyLevel ) ; assertEquals ( <str> , a . expireAfterAccessNanos , b . expireAfterAccessNanos ) ; assertEquals ( <str> , a . expireAfterWriteNanos , b . expireAfterWriteNanos ) ; assertEquals ( <str> , a . initialCapacity , b . initialCapacity ) ; assertEquals ( <str> , a . maximumSize , b . maximumSize ) ; assertEquals ( <str> , a . maximumWeight , b . maximumWeight ) ; assertEquals ( <str> , a . refreshNanos , b . refreshNanos ) ; assertEquals ( <str> , a . keyEquivalence , b . keyEquivalence ) ; assertEquals ( <str> , a . keyStrength , b . keyStrength ) ; assertEquals ( <str> , a . removalListener , b . removalListener ) ; assertEquals ( <str> , a . weigher , b . weigher ) ; assertEquals ( <str> , a . valueEquivalence , b . valueEquivalence ) ; assertEquals ( <str> , a . valueStrength , b . valueStrength ) ; assertEquals ( <str> , a . statsCounterSupplier , b . statsCounterSupplier ) ; assertEquals ( <str> , a . ticker , b . ticker ) ; assertEquals ( <str> , a . isRecordingStats ( ) , b . isRecordingStats ( ) ) ; } } 
