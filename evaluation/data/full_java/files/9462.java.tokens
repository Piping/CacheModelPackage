package com . google . common . math ; import static com . google . common . base . Preconditions . checkState ; import static java . lang . Double . NaN ; import static java . lang . Double . doubleToLongBits ; import static java . lang . Double . isNaN ; import com . google . common . annotations . Beta ; import com . google . common . base . MoreObjects ; import com . google . common . base . Objects ; import java . io . Serializable ; import javax . annotation . Nullable ; @Beta public final class PairedStats implements Serializable { private final Stats xStats ; private final Stats yStats ; private final double sumOfProductsOfDeltas ; PairedStats ( Stats xStats , Stats yStats , double sumOfProductsOfDeltas ) { this . xStats = xStats ; this . yStats = yStats ; this . sumOfProductsOfDeltas = sumOfProductsOfDeltas ; } public long count ( ) { return xStats . count ( ) ; } public Stats xStats ( ) { return xStats ; } public Stats yStats ( ) { return yStats ; } public double populationCovariance ( ) { checkState ( count ( ) ! = <int> ) ; return sumOfProductsOfDeltas / count ( ) ; } public double sampleCovariance ( ) { checkState ( count ( ) > <int> ) ; return sumOfProductsOfDeltas / ( count ( ) - <int> ) ; } public double pearsonsCorrelationCoefficient ( ) { checkState ( count ( ) > <int> ) ; if ( isNaN ( sumOfProductsOfDeltas ) ) { return NaN ; } double xSumOfSquaresOfDeltas = xStats ( ) . sumOfSquaresOfDeltas ( ) ; double ySumOfSquaresOfDeltas = yStats ( ) . sumOfSquaresOfDeltas ( ) ; checkState ( xSumOfSquaresOfDeltas > <float> ) ; checkState ( ySumOfSquaresOfDeltas > <float> ) ; double productOfSumsOfSquaresOfDeltas = ensurePositive ( xSumOfSquaresOfDeltas * ySumOfSquaresOfDeltas ) ; return ensureInUnitRange ( sumOfProductsOfDeltas / Math . sqrt ( productOfSumsOfSquaresOfDeltas ) ) ; } public LinearTransformation leastSquaresFit ( ) { checkState ( count ( ) > <int> ) ; if ( isNaN ( sumOfProductsOfDeltas ) ) { return LinearTransformation . forNaN ( ) ; } double xSumOfSquaresOfDeltas = xStats . sumOfSquaresOfDeltas ( ) ; if ( xSumOfSquaresOfDeltas > <float> ) { if ( yStats . sumOfSquaresOfDeltas ( ) > <float> ) { return LinearTransformation . mapping ( xStats . mean ( ) , yStats . mean ( ) ) . withSlope ( sumOfProductsOfDeltas / xSumOfSquaresOfDeltas ) ; } else { return LinearTransformation . horizontal ( yStats . mean ( ) ) ; } } else { checkState ( yStats . sumOfSquaresOfDeltas ( ) > <float> ) ; return LinearTransformation . vertical ( xStats . mean ( ) ) ; } } @Override public boolean equals ( @Nullable Object obj ) { if ( obj = = null ) { return false ; } if ( getClass ( ) ! = obj . getClass ( ) ) { return false ; } PairedStats other = ( PairedStats ) obj ; return ( xStats . equals ( other . xStats ) ) & & ( yStats . equals ( other . yStats ) ) & & ( doubleToLongBits ( sumOfProductsOfDeltas ) = = doubleToLongBits ( other . sumOfProductsOfDeltas ) ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( xStats , yStats , sumOfProductsOfDeltas ) ; } @Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( <str> , xStats ) . add ( <str> , yStats ) . add ( <str> , populationCovariance ( ) ) . toString ( ) ; } private static double ensurePositive ( double value ) { if ( value > <float> ) { return value ; } else { return Double . MIN_VALUE ; } } private static double ensureInUnitRange ( double value ) { if ( value > = <float> ) { return <float> ; } if ( value < = - <float> ) { return - <float> ; } return value ; } private static final long serialVersionUID = <int> ; } 
