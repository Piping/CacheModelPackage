package org . gradle . groovy . scripts . internal ; import org . codehaus . groovy . ast . ClassNode ; import org . codehaus . groovy . ast . ImportNode ; import org . codehaus . groovy . ast . MethodNode ; import org . codehaus . groovy . ast . ModuleNode ; import org . codehaus . groovy . control . CompilationFailedException ; import org . codehaus . groovy . control . Phases ; import org . codehaus . groovy . control . SourceUnit ; import org . gradle . internal . UncheckedException ; import java . lang . reflect . Field ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . Map ; public class SubsetScriptTransformer extends AbstractScriptTransformer { private final StatementTransformer transformer ; public SubsetScriptTransformer ( StatementTransformer transformer ) { this . transformer = transformer ; } protected int getPhase ( ) { return Phases . CONVERSION ; } public void call ( SourceUnit source ) throws CompilationFailedException { AstUtils . filterAndTransformStatements ( source , transformer ) ; Iterator < ImportNode > iter = source . getAST ( ) . getImports ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { ImportNode importedClass = iter . next ( ) ; if ( ! AstUtils . isVisible ( source , importedClass . getClassName ( ) ) ) { try { Field field = ModuleNode . class . getDeclaredField ( <str> ) ; field . setAccessible ( true ) ; Map value = ( Map ) field . get ( source . getAST ( ) ) ; value . remove ( importedClass . getAlias ( ) ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } } iter = source . getAST ( ) . getStaticImports ( ) . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { ImportNode importedClass = iter . next ( ) ; if ( ! AstUtils . isVisible ( source , importedClass . getClassName ( ) ) ) { iter . remove ( ) ; } } iter = source . getAST ( ) . getStaticStarImports ( ) . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { ImportNode importedClass = iter . next ( ) ; if ( ! AstUtils . isVisible ( source , importedClass . getClassName ( ) ) ) { iter . remove ( ) ; } } ClassNode scriptClass = AstUtils . getScriptClass ( source ) ; Iterator < ClassNode > classes = source . getAST ( ) . getClasses ( ) . iterator ( ) ; while ( classes . hasNext ( ) ) { ClassNode classNode = classes . next ( ) ; if ( classNode ! = scriptClass ) { classes . remove ( ) ; } } if ( scriptClass ! = null ) { for ( MethodNode methodNode : new ArrayList < MethodNode > ( scriptClass . getMethods ( ) ) ) { if ( ! methodNode . getName ( ) . equals ( <str> ) ) { AstUtils . removeMethod ( scriptClass , methodNode ) ; } } } source . getAST ( ) . getMethods ( ) . clear ( ) ; } } 
