package org . elasticsearch . cluster ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . * ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . * ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . transport . LocalTransportAddress ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . gateway . GatewayService ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . search . warmer . IndexWarmersMetaData ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . Collections ; import java . util . List ; import static java . util . Collections . emptyList ; import static org . elasticsearch . cluster . metadata . AliasMetaData . newAliasMetaDataBuilder ; import static org . elasticsearch . cluster . routing . RandomShardRoutingMutator . randomChange ; import static org . elasticsearch . cluster . routing . RandomShardRoutingMutator . randomReason ; import static org . elasticsearch . test . VersionUtils . randomVersion ; import static org . elasticsearch . test . XContentTestUtils . convertToMap ; import static org . elasticsearch . test . XContentTestUtils . differenceBetweenMapsIgnoringArrayOrder ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . SUITE , numDataNodes = <int> , numClientNodes = <int> ) public class ClusterStateDiffIT extends ESIntegTestCase { public void testClusterStateDiffSerialization ( ) throws Exception { DiscoveryNode masterNode = new DiscoveryNode ( <str> , new LocalTransportAddress ( <str> ) , Version . CURRENT ) ; DiscoveryNode otherNode = new DiscoveryNode ( <str> , new LocalTransportAddress ( <str> ) , Version . CURRENT ) ; DiscoveryNodes discoveryNodes = DiscoveryNodes . builder ( ) . put ( masterNode ) . put ( otherNode ) . localNodeId ( masterNode . id ( ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( new ClusterName ( <str> ) ) . nodes ( discoveryNodes ) . build ( ) ; ClusterState clusterStateFromDiffs = ClusterState . Builder . fromBytes ( ClusterState . Builder . toBytes ( clusterState ) , otherNode ) ; int iterationCount = randomIntBetween ( <int> , <int> ) ; for ( int iteration = <int> ; iteration < iterationCount ; iteration + + ) { ClusterState previousClusterState = clusterState ; ClusterState previousClusterStateFromDiffs = clusterStateFromDiffs ; int changesCount = randomIntBetween ( <int> , <int> ) ; ClusterState . Builder builder = null ; for ( int i = <int> ; i < changesCount ; i + + ) { if ( i > <int> ) { clusterState = builder . build ( ) ; } switch ( randomInt ( <int> ) ) { case <int> : builder = randomNodes ( clusterState ) ; break ; case <int> : builder = randomRoutingTable ( clusterState ) ; break ; case <int> : builder = randomBlocks ( clusterState ) ; break ; case <int> : builder = randomClusterStateCustoms ( clusterState ) ; break ; case <int> : builder = randomMetaDataChanges ( clusterState ) ; break ; default : throw new IllegalArgumentException ( <str> ) ; } } clusterState = builder . incrementVersion ( ) . build ( ) ; if ( randomIntBetween ( <int> , <int> ) < <int> ) { clusterStateFromDiffs = ClusterState . Builder . fromBytes ( ClusterState . Builder . toBytes ( clusterState ) , previousClusterStateFromDiffs . nodes ( ) . localNode ( ) ) ; } else { Diff < ClusterState > diffBeforeSerialization = clusterState . diff ( previousClusterState ) ; BytesStreamOutput os = new BytesStreamOutput ( ) ; diffBeforeSerialization . writeTo ( os ) ; byte [ ] diffBytes = os . bytes ( ) . toBytes ( ) ; Diff < ClusterState > diff ; try ( StreamInput input = StreamInput . wrap ( diffBytes ) ) { diff = previousClusterStateFromDiffs . readDiffFrom ( input ) ; clusterStateFromDiffs = diff . apply ( previousClusterStateFromDiffs ) ; } } try { assertThat ( clusterStateFromDiffs . version ( ) , equalTo ( clusterState . version ( ) ) ) ; assertThat ( clusterStateFromDiffs . stateUUID ( ) , equalTo ( clusterState . stateUUID ( ) ) ) ; assertThat ( clusterStateFromDiffs . nodes ( ) . nodes ( ) , equalTo ( clusterState . nodes ( ) . nodes ( ) ) ) ; assertThat ( clusterStateFromDiffs . nodes ( ) . localNodeId ( ) , equalTo ( previousClusterStateFromDiffs . nodes ( ) . localNodeId ( ) ) ) ; assertThat ( clusterStateFromDiffs . nodes ( ) . nodes ( ) , equalTo ( clusterState . nodes ( ) . nodes ( ) ) ) ; for ( ObjectCursor < String > node : clusterStateFromDiffs . nodes ( ) . nodes ( ) . keys ( ) ) { DiscoveryNode node1 = clusterState . nodes ( ) . get ( node . value ) ; DiscoveryNode node2 = clusterStateFromDiffs . nodes ( ) . get ( node . value ) ; assertThat ( node1 . version ( ) , equalTo ( node2 . version ( ) ) ) ; assertThat ( node1 . address ( ) , equalTo ( node2 . address ( ) ) ) ; assertThat ( node1 . attributes ( ) , equalTo ( node2 . attributes ( ) ) ) ; } assertThat ( clusterStateFromDiffs . routingTable ( ) . version ( ) , equalTo ( clusterState . routingTable ( ) . version ( ) ) ) ; assertThat ( clusterStateFromDiffs . routingTable ( ) . indicesRouting ( ) , equalTo ( clusterState . routingTable ( ) . indicesRouting ( ) ) ) ; assertThat ( clusterStateFromDiffs . blocks ( ) . global ( ) , equalTo ( clusterStateFromDiffs . blocks ( ) . global ( ) ) ) ; assertThat ( clusterStateFromDiffs . blocks ( ) . indices ( ) , equalTo ( clusterStateFromDiffs . blocks ( ) . indices ( ) ) ) ; assertThat ( clusterStateFromDiffs . blocks ( ) . disableStatePersistence ( ) , equalTo ( clusterStateFromDiffs . blocks ( ) . disableStatePersistence ( ) ) ) ; assertThat ( clusterStateFromDiffs . metaData ( ) . version ( ) , equalTo ( clusterState . metaData ( ) . version ( ) ) ) ; assertThat ( clusterStateFromDiffs . metaData ( ) . clusterUUID ( ) , equalTo ( clusterState . metaData ( ) . clusterUUID ( ) ) ) ; assertThat ( clusterStateFromDiffs . metaData ( ) . transientSettings ( ) , equalTo ( clusterState . metaData ( ) . transientSettings ( ) ) ) ; assertThat ( clusterStateFromDiffs . metaData ( ) . persistentSettings ( ) , equalTo ( clusterState . metaData ( ) . persistentSettings ( ) ) ) ; assertThat ( clusterStateFromDiffs . metaData ( ) . indices ( ) , equalTo ( clusterState . metaData ( ) . indices ( ) ) ) ; assertThat ( clusterStateFromDiffs . metaData ( ) . templates ( ) , equalTo ( clusterState . metaData ( ) . templates ( ) ) ) ; assertThat ( clusterStateFromDiffs . metaData ( ) . customs ( ) , equalTo ( clusterState . metaData ( ) . customs ( ) ) ) ; assertThat ( clusterStateFromDiffs . metaData ( ) . equalsAliases ( clusterState . metaData ( ) ) , is ( true ) ) ; assertNull ( differenceBetweenMapsIgnoringArrayOrder ( convertToMap ( clusterStateFromDiffs ) , convertToMap ( clusterState ) ) ) ; assertThat ( ClusterState . Builder . toBytes ( clusterStateFromDiffs ) . length , equalTo ( ClusterState . Builder . toBytes ( clusterState ) . length ) ) ; } catch ( AssertionError error ) { logger . error ( <str> , clusterState . toString ( ) , clusterStateFromDiffs . toString ( ) ) ; throw error ; } } logger . info ( <str> , clusterState . toString ( ) ) ; } private ClusterState . Builder randomNodes ( ClusterState clusterState ) { DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( clusterState . nodes ( ) ) ; List < String > nodeIds = randomSubsetOf ( randomInt ( clusterState . nodes ( ) . nodes ( ) . size ( ) - <int> ) , clusterState . nodes ( ) . nodes ( ) . keys ( ) . toArray ( String . class ) ) ; for ( String nodeId : nodeIds ) { if ( nodeId . startsWith ( <str> ) ) { if ( randomBoolean ( ) ) { nodes . remove ( nodeId ) ; } else { nodes . put ( new DiscoveryNode ( nodeId , new LocalTransportAddress ( randomAsciiOfLength ( <int> ) ) , randomVersion ( random ( ) ) ) ) ; } } } int additionalNodeCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < additionalNodeCount ; i + + ) { nodes . put ( new DiscoveryNode ( <str> + randomAsciiOfLength ( <int> ) , new LocalTransportAddress ( randomAsciiOfLength ( <int> ) ) , randomVersion ( random ( ) ) ) ) ; } return ClusterState . builder ( clusterState ) . nodes ( nodes ) ; } private ClusterState . Builder randomRoutingTable ( ClusterState clusterState ) { RoutingTable . Builder builder = RoutingTable . builder ( clusterState . routingTable ( ) ) ; int numberOfIndices = clusterState . routingTable ( ) . indicesRouting ( ) . size ( ) ; if ( numberOfIndices > <int> ) { List < String > randomIndices = randomSubsetOf ( randomInt ( numberOfIndices - <int> ) , clusterState . routingTable ( ) . indicesRouting ( ) . keys ( ) . toArray ( String . class ) ) ; for ( String index : randomIndices ) { if ( randomBoolean ( ) ) { builder . remove ( index ) ; } else { builder . add ( randomChangeToIndexRoutingTable ( clusterState . routingTable ( ) . indicesRouting ( ) . get ( index ) , clusterState . nodes ( ) . nodes ( ) . keys ( ) . toArray ( String . class ) ) ) ; } } } int additionalIndexCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < additionalIndexCount ; i + + ) { builder . add ( randomIndexRoutingTable ( <str> + randomInt ( ) , clusterState . nodes ( ) . nodes ( ) . keys ( ) . toArray ( String . class ) ) ) ; } return ClusterState . builder ( clusterState ) . routingTable ( builder . build ( ) ) ; } private IndexRoutingTable randomIndexRoutingTable ( String index , String [ ] nodeIds ) { IndexRoutingTable . Builder builder = IndexRoutingTable . builder ( index ) ; int shardCount = randomInt ( <int> ) ; for ( int i = <int> ; i < shardCount ; i + + ) { IndexShardRoutingTable . Builder indexShard = new IndexShardRoutingTable . Builder ( new ShardId ( index , i ) ) ; int replicaCount = randomIntBetween ( <int> , <int> ) ; for ( int j = <int> ; j < replicaCount ; j + + ) { UnassignedInfo unassignedInfo = null ; if ( randomInt ( <int> ) = = <int> ) { unassignedInfo = new UnassignedInfo ( randomReason ( ) , randomAsciiOfLength ( <int> ) ) ; } indexShard . addShard ( TestShardRouting . newShardRouting ( index , i , randomFrom ( nodeIds ) , null , null , j = = <int> , ShardRoutingState . fromValue ( ( byte ) randomIntBetween ( <int> , <int> ) ) , <int> , unassignedInfo ) ) ; } builder . addIndexShard ( indexShard . build ( ) ) ; } return builder . build ( ) ; } private IndexRoutingTable randomChangeToIndexRoutingTable ( IndexRoutingTable original , String [ ] nodes ) { IndexRoutingTable . Builder builder = IndexRoutingTable . builder ( original . getIndex ( ) ) ; for ( ObjectCursor < IndexShardRoutingTable > indexShardRoutingTable : original . shards ( ) . values ( ) ) { for ( ShardRouting shardRouting : indexShardRoutingTable . value . shards ( ) ) { final ShardRouting newShardRouting = new ShardRouting ( shardRouting ) ; randomChange ( newShardRouting , nodes ) ; builder . addShard ( indexShardRoutingTable . value , newShardRouting ) ; } } return builder . build ( ) ; } private ClusterState . Builder randomBlocks ( ClusterState clusterState ) { ClusterBlocks . Builder builder = ClusterBlocks . builder ( ) . blocks ( clusterState . blocks ( ) ) ; int globalBlocksCount = clusterState . blocks ( ) . global ( ) . size ( ) ; if ( globalBlocksCount > <int> ) { List < ClusterBlock > blocks = randomSubsetOf ( randomInt ( globalBlocksCount - <int> ) , clusterState . blocks ( ) . global ( ) . toArray ( new ClusterBlock [ globalBlocksCount ] ) ) ; for ( ClusterBlock block : blocks ) { builder . removeGlobalBlock ( block ) ; } } int additionalGlobalBlocksCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < additionalGlobalBlocksCount ; i + + ) { builder . addGlobalBlock ( randomGlobalBlock ( ) ) ; } return ClusterState . builder ( clusterState ) . blocks ( builder ) ; } private ClusterBlock randomGlobalBlock ( ) { switch ( randomInt ( <int> ) ) { case <int> : return DiscoverySettings . NO_MASTER_BLOCK_ALL ; case <int> : return DiscoverySettings . NO_MASTER_BLOCK_WRITES ; default : return GatewayService . STATE_NOT_RECOVERED_BLOCK ; } } private interface RandomClusterPart < T > { ImmutableOpenMap < String , T > parts ( ClusterState clusterState ) ; ClusterState . Builder put ( ClusterState . Builder builder , T part ) ; ClusterState . Builder remove ( ClusterState . Builder builder , String name ) ; T randomCreate ( String name ) ; T randomChange ( T part ) ; } private < T > ClusterState randomClusterStateParts ( ClusterState clusterState , String prefix , RandomClusterPart < T > randomPart ) { ClusterState . Builder builder = ClusterState . builder ( clusterState ) ; ImmutableOpenMap < String , T > parts = randomPart . parts ( clusterState ) ; int partCount = parts . size ( ) ; if ( partCount > <int> ) { List < String > randomParts = randomSubsetOf ( randomInt ( partCount - <int> ) , randomPart . parts ( clusterState ) . keys ( ) . toArray ( String . class ) ) ; for ( String part : randomParts ) { if ( randomBoolean ( ) ) { randomPart . remove ( builder , part ) ; } else { randomPart . put ( builder , randomPart . randomChange ( parts . get ( part ) ) ) ; } } } int additionalPartCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < additionalPartCount ; i + + ) { String name = randomName ( prefix ) ; randomPart . put ( builder , randomPart . randomCreate ( name ) ) ; } return builder . build ( ) ; } private ClusterState . Builder randomMetaDataChanges ( ClusterState clusterState ) { MetaData metaData = clusterState . metaData ( ) ; int changesCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < changesCount ; i + + ) { switch ( randomInt ( <int> ) ) { case <int> : metaData = randomMetaDataSettings ( metaData ) ; break ; case <int> : metaData = randomIndices ( metaData ) ; break ; case <int> : metaData = randomTemplates ( metaData ) ; break ; case <int> : metaData = randomMetaDataCustoms ( metaData ) ; break ; default : throw new IllegalArgumentException ( <str> ) ; } } return ClusterState . builder ( clusterState ) . metaData ( MetaData . builder ( metaData ) . version ( metaData . version ( ) + <int> ) . build ( ) ) ; } private Settings randomSettings ( Settings settings ) { Settings . Builder builder = Settings . builder ( ) ; if ( randomBoolean ( ) ) { builder . put ( settings ) ; } int settingsCount = randomInt ( <int> ) ; for ( int i = <int> ; i < settingsCount ; i + + ) { builder . put ( randomAsciiOfLength ( <int> ) , randomAsciiOfLength ( <int> ) ) ; } return builder . build ( ) ; } private MetaData randomMetaDataSettings ( MetaData metaData ) { if ( randomBoolean ( ) ) { return MetaData . builder ( metaData ) . persistentSettings ( randomSettings ( metaData . persistentSettings ( ) ) ) . build ( ) ; } else { return MetaData . builder ( metaData ) . transientSettings ( randomSettings ( metaData . transientSettings ( ) ) ) . build ( ) ; } } private interface RandomPart < T > { ImmutableOpenMap < String , T > parts ( MetaData metaData ) ; MetaData . Builder put ( MetaData . Builder builder , T part ) ; MetaData . Builder remove ( MetaData . Builder builder , String name ) ; T randomCreate ( String name ) ; T randomChange ( T part ) ; } private < T > MetaData randomParts ( MetaData metaData , String prefix , RandomPart < T > randomPart ) { MetaData . Builder builder = MetaData . builder ( metaData ) ; ImmutableOpenMap < String , T > parts = randomPart . parts ( metaData ) ; int partCount = parts . size ( ) ; if ( partCount > <int> ) { List < String > randomParts = randomSubsetOf ( randomInt ( partCount - <int> ) , randomPart . parts ( metaData ) . keys ( ) . toArray ( String . class ) ) ; for ( String part : randomParts ) { if ( randomBoolean ( ) ) { randomPart . remove ( builder , part ) ; } else { randomPart . put ( builder , randomPart . randomChange ( parts . get ( part ) ) ) ; } } } int additionalPartCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < additionalPartCount ; i + + ) { String name = randomName ( prefix ) ; randomPart . put ( builder , randomPart . randomCreate ( name ) ) ; } return builder . build ( ) ; } private MetaData randomIndices ( MetaData metaData ) { return randomParts ( metaData , <str> , new RandomPart < IndexMetaData > ( ) { @Override public ImmutableOpenMap < String , IndexMetaData > parts ( MetaData metaData ) { return metaData . indices ( ) ; } @Override public MetaData . Builder put ( MetaData . Builder builder , IndexMetaData part ) { return builder . put ( part , true ) ; } @Override public MetaData . Builder remove ( MetaData . Builder builder , String name ) { return builder . remove ( name ) ; } @Override public IndexMetaData randomCreate ( String name ) { IndexMetaData . Builder builder = IndexMetaData . builder ( name ) ; Settings . Builder settingsBuilder = Settings . builder ( ) ; setRandomIndexSettings ( getRandom ( ) , settingsBuilder ) ; settingsBuilder . put ( randomSettings ( Settings . EMPTY ) ) . put ( IndexMetaData . SETTING_VERSION_CREATED , randomVersion ( random ( ) ) ) ; builder . settings ( settingsBuilder ) ; builder . numberOfShards ( randomIntBetween ( <int> , <int> ) ) . numberOfReplicas ( randomInt ( <int> ) ) ; int aliasCount = randomInt ( <int> ) ; if ( randomBoolean ( ) ) { builder . putCustom ( IndexWarmersMetaData . TYPE , randomWarmers ( ) ) ; } for ( int i = <int> ; i < aliasCount ; i + + ) { builder . putAlias ( randomAlias ( ) ) ; } return builder . build ( ) ; } @Override public IndexMetaData randomChange ( IndexMetaData part ) { IndexMetaData . Builder builder = IndexMetaData . builder ( part ) ; switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : builder . settings ( Settings . builder ( ) . put ( part . getSettings ( ) ) . put ( randomSettings ( Settings . EMPTY ) ) ) ; break ; case <int> : if ( randomBoolean ( ) & & part . getAliases ( ) . isEmpty ( ) = = false ) { builder . removeAlias ( randomFrom ( part . getAliases ( ) . keys ( ) . toArray ( String . class ) ) ) ; } else { builder . putAlias ( AliasMetaData . builder ( randomAsciiOfLength ( <int> ) ) ) ; } break ; case <int> : builder . settings ( Settings . builder ( ) . put ( part . getSettings ( ) ) . put ( IndexMetaData . SETTING_INDEX_UUID , Strings . randomBase64UUID ( ) ) ) ; break ; case <int> : builder . putCustom ( IndexWarmersMetaData . TYPE , randomWarmers ( ) ) ; break ; default : throw new IllegalArgumentException ( <str> ) ; } return builder . build ( ) ; } } ) ; } private IndexWarmersMetaData randomWarmers ( ) { if ( randomBoolean ( ) ) { return new IndexWarmersMetaData ( new IndexWarmersMetaData . Entry ( randomName ( <str> ) , new String [ ] { randomName ( <str> ) } , randomBoolean ( ) , new IndexWarmersMetaData . SearchSource ( new BytesArray ( randomAsciiOfLength ( <int> ) ) ) ) ) ; } else { return new IndexWarmersMetaData ( ) ; } } private MetaData randomTemplates ( MetaData metaData ) { return randomParts ( metaData , <str> , new RandomPart < IndexTemplateMetaData > ( ) { @Override public ImmutableOpenMap < String , IndexTemplateMetaData > parts ( MetaData metaData ) { return metaData . templates ( ) ; } @Override public MetaData . Builder put ( MetaData . Builder builder , IndexTemplateMetaData part ) { return builder . put ( part ) ; } @Override public MetaData . Builder remove ( MetaData . Builder builder , String name ) { return builder . removeTemplate ( name ) ; } @Override public IndexTemplateMetaData randomCreate ( String name ) { IndexTemplateMetaData . Builder builder = IndexTemplateMetaData . builder ( name ) ; builder . order ( randomInt ( <int> ) ) . template ( randomName ( <str> ) ) . settings ( randomSettings ( Settings . EMPTY ) ) ; int aliasCount = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < aliasCount ; i + + ) { builder . putAlias ( randomAlias ( ) ) ; } if ( randomBoolean ( ) ) { builder . putCustom ( IndexWarmersMetaData . TYPE , randomWarmers ( ) ) ; } return builder . build ( ) ; } @Override public IndexTemplateMetaData randomChange ( IndexTemplateMetaData part ) { IndexTemplateMetaData . Builder builder = new IndexTemplateMetaData . Builder ( part ) ; builder . order ( randomInt ( <int> ) ) ; return builder . build ( ) ; } } ) ; } private AliasMetaData randomAlias ( ) { AliasMetaData . Builder builder = newAliasMetaDataBuilder ( randomName ( <str> ) ) ; if ( randomBoolean ( ) ) { builder . filter ( QueryBuilders . termQuery ( <str> , randomRealisticUnicodeOfCodepointLength ( <int> ) ) . toString ( ) ) ; } if ( randomBoolean ( ) ) { builder . routing ( randomAsciiOfLength ( <int> ) ) ; } return builder . build ( ) ; } private MetaData randomMetaDataCustoms ( final MetaData metaData ) { return randomParts ( metaData , <str> , new RandomPart < MetaData . Custom > ( ) { @Override public ImmutableOpenMap < String , MetaData . Custom > parts ( MetaData metaData ) { return metaData . customs ( ) ; } @Override public MetaData . Builder put ( MetaData . Builder builder , MetaData . Custom part ) { return builder . putCustom ( part . type ( ) , part ) ; } @Override public MetaData . Builder remove ( MetaData . Builder builder , String name ) { return builder . removeCustom ( name ) ; } @Override public MetaData . Custom randomCreate ( String name ) { return new RepositoriesMetaData ( ) ; } @Override public MetaData . Custom randomChange ( MetaData . Custom part ) { return part ; } } ) ; } private ClusterState . Builder randomClusterStateCustoms ( final ClusterState clusterState ) { return ClusterState . builder ( randomClusterStateParts ( clusterState , <str> , new RandomClusterPart < ClusterState . Custom > ( ) { @Override public ImmutableOpenMap < String , ClusterState . Custom > parts ( ClusterState clusterState ) { return clusterState . customs ( ) ; } @Override public ClusterState . Builder put ( ClusterState . Builder builder , ClusterState . Custom part ) { return builder . putCustom ( part . type ( ) , part ) ; } @Override public ClusterState . Builder remove ( ClusterState . Builder builder , String name ) { return builder . removeCustom ( name ) ; } @Override public ClusterState . Custom randomCreate ( String name ) { switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : return new SnapshotsInProgress ( new SnapshotsInProgress . Entry ( new SnapshotId ( randomName ( <str> ) , randomName ( <str> ) ) , randomBoolean ( ) , SnapshotsInProgress . State . fromValue ( ( byte ) randomIntBetween ( <int> , <int> ) ) , Collections . < String > emptyList ( ) , Math . abs ( randomLong ( ) ) , ImmutableOpenMap . of ( ) ) ) ; case <int> : return new RestoreInProgress ( new RestoreInProgress . Entry ( new SnapshotId ( randomName ( <str> ) , randomName ( <str> ) ) , RestoreInProgress . State . fromValue ( ( byte ) randomIntBetween ( <int> , <int> ) ) , emptyList ( ) , ImmutableOpenMap . of ( ) ) ) ; default : throw new IllegalArgumentException ( <str> ) ; } } @Override public ClusterState . Custom randomChange ( ClusterState . Custom part ) { return part ; } } ) ) ; } private String randomName ( String prefix ) { return prefix + Strings . randomBase64UUID ( getRandom ( ) ) ; } } 
