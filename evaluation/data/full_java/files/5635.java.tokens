package org . elasticsearch . cluster . routing . allocation . decider ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; public class ShardsLimitAllocationDecider extends AllocationDecider { public static final String NAME = <str> ; private volatile int clusterShardLimit ; public static final String INDEX_TOTAL_SHARDS_PER_NODE = <str> ; public static final String CLUSTER_TOTAL_SHARDS_PER_NODE = <str> ; class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { Integer newClusterLimit = settings . getAsInt ( CLUSTER_TOTAL_SHARDS_PER_NODE , null ) ; if ( newClusterLimit ! = null ) { logger . info ( <str> , CLUSTER_TOTAL_SHARDS_PER_NODE , ShardsLimitAllocationDecider . this . clusterShardLimit , newClusterLimit ) ; ShardsLimitAllocationDecider . this . clusterShardLimit = newClusterLimit ; } } } @Inject public ShardsLimitAllocationDecider ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; this . clusterShardLimit = settings . getAsInt ( CLUSTER_TOTAL_SHARDS_PER_NODE , - <int> ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } @Override public Decision canAllocate ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { IndexMetaData indexMd = allocation . routingNodes ( ) . metaData ( ) . index ( shardRouting . index ( ) ) ; int indexShardLimit = indexMd . getSettings ( ) . getAsInt ( INDEX_TOTAL_SHARDS_PER_NODE , - <int> ) ; final int clusterShardLimit = this . clusterShardLimit ; if ( indexShardLimit < = <int> & & clusterShardLimit < = <int> ) { return allocation . decision ( Decision . YES , NAME , <str> , indexShardLimit , clusterShardLimit ) ; } int indexShardCount = <int> ; int nodeShardCount = <int> ; for ( ShardRouting nodeShard : node ) { if ( nodeShard . relocating ( ) ) { continue ; } nodeShardCount + + ; if ( nodeShard . index ( ) . equals ( shardRouting . index ( ) ) ) { indexShardCount + + ; } } if ( clusterShardLimit > <int> & & nodeShardCount > = clusterShardLimit ) { return allocation . decision ( Decision . NO , NAME , <str> , nodeShardCount , clusterShardLimit ) ; } if ( indexShardLimit > <int> & & indexShardCount > = indexShardLimit ) { return allocation . decision ( Decision . NO , NAME , <str> , shardRouting . index ( ) , indexShardCount , indexShardLimit ) ; } return allocation . decision ( Decision . YES , NAME , <str> , indexShardLimit , clusterShardLimit ) ; } @Override public Decision canRemain ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { IndexMetaData indexMd = allocation . routingNodes ( ) . metaData ( ) . index ( shardRouting . index ( ) ) ; int indexShardLimit = indexMd . getSettings ( ) . getAsInt ( INDEX_TOTAL_SHARDS_PER_NODE , - <int> ) ; final int clusterShardLimit = this . clusterShardLimit ; if ( indexShardLimit < = <int> & & clusterShardLimit < = <int> ) { return allocation . decision ( Decision . YES , NAME , <str> , indexShardLimit , clusterShardLimit ) ; } int indexShardCount = <int> ; int nodeShardCount = <int> ; for ( ShardRouting nodeShard : node ) { if ( nodeShard . relocating ( ) ) { continue ; } nodeShardCount + + ; if ( nodeShard . index ( ) . equals ( shardRouting . index ( ) ) ) { indexShardCount + + ; } } if ( clusterShardLimit > <int> & & nodeShardCount > clusterShardLimit ) { return allocation . decision ( Decision . NO , NAME , <str> , nodeShardCount , clusterShardLimit ) ; } if ( indexShardLimit > <int> & & indexShardCount > indexShardLimit ) { return allocation . decision ( Decision . NO , NAME , <str> , shardRouting . index ( ) , indexShardCount , indexShardLimit ) ; } return allocation . decision ( Decision . YES , NAME , <str> , indexShardLimit , clusterShardLimit ) ; } @Override public Decision canAllocate ( RoutingNode node , RoutingAllocation allocation ) { final int clusterShardLimit = this . clusterShardLimit ; if ( clusterShardLimit < = <int> ) { return allocation . decision ( Decision . YES , NAME , <str> , clusterShardLimit ) ; } int nodeShardCount = <int> ; for ( ShardRouting nodeShard : node ) { if ( nodeShard . relocating ( ) ) { continue ; } nodeShardCount + + ; } if ( clusterShardLimit > = <int> & & nodeShardCount > = clusterShardLimit ) { return allocation . decision ( Decision . NO , NAME , <str> , nodeShardCount , clusterShardLimit ) ; } return allocation . decision ( Decision . YES , NAME , <str> , clusterShardLimit ) ; } } 
