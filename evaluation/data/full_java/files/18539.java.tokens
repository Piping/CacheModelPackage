package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . PerformanceCounter ; import java . util . Comparator ; public class SelectTest extends GdxTest { static PerformanceCounter perf = new PerformanceCounter ( <str> ) ; static boolean verify ; private static boolean quiet ; @Override public void create ( ) { int n = <int> ; player = createDummies ( n ) ; enemy = createDummies ( n ) ; int runs = <int> ; quiet = true ; allRandom ( ) ; print ( <str> ) ; correctnessTest ( runs , <int> ) ; print ( <str> ) ; correctnessTest ( runs , enemy . size / <int> ) ; print ( <str> ) ; correctnessTest ( runs , enemy . size ) ; runs = <int> ; quiet = true ; print ( <str> ) ; performanceTest ( runs , <int> ) ; print ( <str> ) ; performanceTest ( runs , enemy . size / <int> ) ; print ( <str> ) ; performanceTest ( runs , enemy . size ) ; print ( <str> ) ; consistencyTest ( runs , <int> ) ; print ( <str> ) ; consistencyTest ( runs , enemy . size / <int> ) ; print ( <str> ) ; consistencyTest ( runs , enemy . size ) ; print ( <str> ) ; testValueMatchesIndex ( runs , <int> ) ; print ( <str> ) ; testValueMatchesIndex ( runs , enemy . size / <int> ) ; print ( <str> ) ; testValueMatchesIndex ( runs , enemy . size ) ; print ( <str> ) ; } public static void correctnessTest ( int runs , int k ) { String msg = String . format ( <str> , runs , player . size , enemy . size ) ; verify = true ; test ( runs , k ) ; print ( msg + <str> ) ; } public static void performanceTest ( int runs , int k ) { verify = false ; test ( runs , k ) ; String msg = String . format ( <str> , runs , player . size , enemy . size ) ; print ( msg + String . format ( <str> , allPerf . time . min , allPerf . time . max , allPerf . time . average * <int> , allPerf . time . total * <int> , comparisonsMade ) ) ; } public static void consistencyTest ( int runs , int k ) { verify = false ; Dummy test = player . get ( <int> ) ; Dummy lastFound = null ; allRandom ( ) ; for ( int i = <int> ; i < runs ; i + + ) { Dummy found = test . getKthNearestEnemy ( k ) ; if ( lastFound = = null ) { lastFound = found ; } else { if ( ! ( lastFound . equals ( found ) ) ) { print ( <str> ) ; print ( <str> + lastFound ) ; print ( <str> + found ) ; throw new GdxRuntimeException ( <str> ) ; } } } } public static void testValueMatchesIndex ( int runs , int k ) { verify = false ; for ( int i = <int> ; i < runs ; i + + ) { allRandom ( ) ; player . shuffle ( ) ; enemy . shuffle ( ) ; originDummy = player . random ( ) ; int idx = enemy . selectRankedIndex ( distComp , k ) ; Dummy indexDummy = enemy . get ( idx ) ; Dummy valueDummy = enemy . selectRanked ( distComp , k ) ; if ( ! ( indexDummy . equals ( valueDummy ) ) ) { throw new GdxRuntimeException ( <str> + <str> + indexDummy + <str> + <str> + valueDummy ) ; } } } public static void test ( int runs , int k ) { comparisonsMade = <int> ; perf . reset ( ) ; allPerf . reset ( ) ; allRandom ( ) ; enemy . shuffle ( ) ; player . shuffle ( ) ; for ( int i = <int> ; i < runs ; i + + ) { getKthNearestEnemy ( quiet , k ) ; } } public static void allRandom ( ) { for ( Dummy d : player ) { d . setRandomPos ( ) ; } for ( Dummy d : enemy ) { d . setRandomPos ( ) ; } } private static PerformanceCounter allPerf = new PerformanceCounter ( <str> ) ; public static void getKthNearestEnemy ( boolean silent , int k ) { Dummy kthDummy = null ; perf . reset ( ) ; allPerf . start ( ) ; for ( Dummy d : player ) { Dummy found = d . getKthNearestEnemy ( k ) ; } allPerf . stop ( ) ; allPerf . tick ( ) ; if ( silent ) return ; print ( String . format ( <str> , perf . time . min * <int> , perf . time . max * <int> , perf . time . average * <int> , perf . time . total * <int> ) ) ; } public static void verifyCorrectness ( Dummy d , int k ) { enemy . sort ( distComp ) ; int idx = enemy . indexOf ( d , true ) ; if ( enemy . get ( idx ) ! = enemy . get ( k - <int> ) ) { System . out . println ( <str> + originDummy ) ; System . out . println ( <str> + <str> + idx + <str> + ( k - <int> ) ) ; throw new GdxRuntimeException ( <str> ) ; } } static class Dummy { public Vector2 pos ; public int id ; public Dummy ( ) { } @Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof Dummy ) ) { throw new GdxRuntimeException ( <str> ) ; } Dummy d = ( Dummy ) obj ; float epsilon = <float> ; float diff = Math . abs ( d . pos . x - this . pos . x ) + Math . abs ( d . pos . y - this . pos . y ) ; if ( diff > epsilon ) return false ; return true ; } public Dummy getKthNearestEnemy ( int k ) { perf . start ( ) ; originDummy = this ; Dummy found = enemy . selectRanked ( distComp , k ) ; perf . stop ( ) ; perf . tick ( ) ; if ( verify ) { verifyCorrectness ( found , k ) ; } return found ; } public void setRandomPos ( ) { float max = <int> ; this . pos . x = - max + MathUtils . random ( max * <int> ) ; this . pos . y = - max + MathUtils . random ( max * <int> ) ; float xShift = <int> ; if ( player . contains ( this , true ) ) { this . pos . x - = xShift ; } else if ( enemy . contains ( this , true ) ) { this . pos . x + = xShift ; } else { throw new RuntimeException ( <str> ) ; } } @Override public String toString ( ) { return String . format ( <str> , pos . x , pos . y ) ; } } public static int nextID = <int> ; public static Array < Dummy > player ; public static Array < Dummy > enemy ; public static Array < Dummy > createDummies ( int n ) { float variance = <int> ; Array < Dummy > dummies = new Array < Dummy > ( ) ; for ( int i = <int> ; i < n ; i + + ) { Dummy d = new Dummy ( ) ; dummies . add ( d ) ; d . pos = new Vector2 ( ) ; d . id = nextID + + ; } return dummies ; } static Dummy originDummy ; static long comparisonsMade = <int> ; static Comparator < Dummy > distComp = new Comparator < Dummy > ( ) { @Override public int compare ( Dummy o1 , Dummy o2 ) { comparisonsMade + + ; float d1 = originDummy . pos . dst2 ( o1 . pos ) ; float d2 = originDummy . pos . dst2 ( o2 . pos ) ; float diff = d1 - d2 ; if ( diff < <int> ) return - <int> ; if ( diff > <int> ) return <int> ; return <int> ; } } ; public static void print ( Object . . . objs ) { for ( Object o : objs ) { System . out . print ( o ) ; } System . out . println ( ) ; } } 
