package com . badlogic . gdx . physics . box2d ; import org . jbox2d . common . Vec2 ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . physics . box2d . BodyDef . BodyType ; import com . badlogic . gdx . utils . Array ; public class Body { final World world ; public final org . jbox2d . dynamics . Body body ; final Vec2 tmp = new Vec2 ( ) ; final Vec2 tmp2 = new Vec2 ( ) ; final Array < Fixture > fixtures = new Array < Fixture > ( ) ; final Array < JointEdge > joints = new Array < JointEdge > ( ) ; protected Body ( World world , org . jbox2d . dynamics . Body body ) { this . world = world ; this . body = body ; } public void setTransform ( Vector2 position , float angle ) { tmp . set ( position . x , position . y ) ; body . setTransform ( tmp , angle ) ; } public void setTransform ( float x , float y , float angle ) { tmp . set ( x , y ) ; body . setTransform ( tmp , angle ) ; } Transform transform = new Transform ( ) ; public Transform getTransform ( ) { org . jbox2d . common . Transform trans = body . getTransform ( ) ; transform . vals [ Transform . POS_X ] = trans . p . x ; transform . vals [ Transform . POS_Y ] = trans . p . y ; transform . vals [ Transform . COS ] = trans . q . c ; transform . vals [ Transform . SIN ] = trans . q . s ; return transform ; } final Vector2 position = new Vector2 ( ) ; public Vector2 getPosition ( ) { Vec2 pos = body . getPosition ( ) ; position . set ( pos . x , pos . y ) ; return position ; } public float getAngle ( ) { return body . getAngle ( ) ; } final Vector2 worldCenter = new Vector2 ( ) ; public Vector2 getWorldCenter ( ) { Vec2 wc = body . getWorldCenter ( ) ; return worldCenter . set ( wc . x , wc . y ) ; } private final Vector2 localCenter = new Vector2 ( ) ; public Vector2 getLocalCenter ( ) { Vec2 lc = body . getLocalCenter ( ) ; localCenter . set ( lc . x , lc . y ) ; return localCenter ; } public void setLinearVelocity ( Vector2 v ) { tmp . set ( v . x , v . y ) ; body . setLinearVelocity ( tmp ) ; } public void setLinearVelocity ( float vX , float vY ) { tmp . set ( vX , vY ) ; body . setLinearVelocity ( tmp ) ; } private final Vector2 linearVelocity = new Vector2 ( ) ; public Vector2 getLinearVelocity ( ) { Vec2 lv = body . getLinearVelocity ( ) ; linearVelocity . set ( lv . x , lv . y ) ; return linearVelocity ; } public void setAngularVelocity ( float omega ) { body . setAngularVelocity ( omega ) ; } public float getAngularVelocity ( ) { return body . getAngularVelocity ( ) ; } public void applyForce ( Vector2 force , Vector2 point , boolean wrap ) { tmp . set ( force . x , force . y ) ; tmp2 . set ( point . x , point . y ) ; body . applyForce ( tmp , tmp2 ) ; } public void applyForce ( float forceX , float forceY , float pointX , float pointY , boolean wake ) { tmp . set ( forceX , forceY ) ; tmp2 . set ( pointX , pointY ) ; body . applyForce ( tmp , tmp2 ) ; } public void applyForceToCenter ( Vector2 force , boolean wake ) { tmp . set ( force . x , force . y ) ; body . applyForceToCenter ( tmp ) ; } public void applyForceToCenter ( float forceX , float forceY , boolean wake ) { tmp . set ( forceX , forceY ) ; body . applyForceToCenter ( tmp ) ; } public void applyTorque ( float torque , boolean wake ) { body . applyTorque ( torque ) ; } public void applyLinearImpulse ( Vector2 impulse , Vector2 point , boolean wake ) { tmp . set ( impulse . x , impulse . y ) ; tmp2 . set ( point . x , point . y ) ; body . applyLinearImpulse ( tmp , tmp2 , wake ) ; } public void applyLinearImpulse ( float impulseX , float impulseY , float pointX , float pointY , boolean wake ) { tmp . set ( impulseX , impulseY ) ; tmp2 . set ( pointX , pointY ) ; body . applyLinearImpulse ( tmp , tmp2 , wake ) ; } public void applyAngularImpulse ( float impulse , boolean wake ) { body . applyAngularImpulse ( impulse ) ; } public float getMass ( ) { return body . getMass ( ) ; } public float getInertia ( ) { return body . getInertia ( ) ; } private final MassData massData = new MassData ( ) ; private final org . jbox2d . collision . shapes . MassData massData2 = new org . jbox2d . collision . shapes . MassData ( ) ; public MassData getMassData ( ) { body . getMassData ( massData2 ) ; massData . center . set ( massData2 . center . x , massData2 . center . y ) ; massData . I = massData2 . I ; massData . mass = massData2 . mass ; return massData ; } public void setMassData ( MassData data ) { massData2 . center . set ( data . center . x , data . center . y ) ; massData2 . I = data . I ; massData2 . mass = data . mass ; body . setMassData ( massData2 ) ; } public void resetMassData ( ) { body . resetMassData ( ) ; } private final Vector2 worldPoint = new Vector2 ( ) ; public Vector2 getWorldPoint ( Vector2 localPoint ) { tmp . set ( localPoint . x , localPoint . y ) ; Vec2 wp = body . getWorldPoint ( tmp ) ; return worldPoint . set ( wp . x , wp . y ) ; } private final Vector2 worldVector = new Vector2 ( ) ; public Vector2 getWorldVector ( Vector2 localVector ) { tmp . set ( localVector . x , localVector . y ) ; Vec2 wv = body . getWorldVector ( tmp ) ; return worldVector . set ( wv . x , wv . y ) ; } public final Vector2 localPoint2 = new Vector2 ( ) ; public Vector2 getLocalPoint ( Vector2 worldPoint ) { tmp . set ( worldPoint . x , worldPoint . y ) ; Vec2 lp = body . getLocalPoint ( tmp ) ; return localPoint2 . set ( lp . x , lp . y ) ; } public final Vector2 localVector = new Vector2 ( ) ; public Vector2 getLocalVector ( Vector2 worldVector ) { tmp . set ( worldVector . x , worldVector . y ) ; Vec2 lv = body . getLocalVector ( tmp ) ; return localVector . set ( lv . x , lv . y ) ; } public final Vector2 linVelWorld = new Vector2 ( ) ; public Vector2 getLinearVelocityFromWorldPoint ( Vector2 worldPoint ) { tmp . set ( worldPoint . x , worldPoint . y ) ; Vec2 lv = body . getLinearVelocityFromWorldPoint ( tmp ) ; return linVelWorld . set ( lv . x , lv . y ) ; } public final Vector2 linVelLoc = new Vector2 ( ) ; public Vector2 getLinearVelocityFromLocalPoint ( Vector2 localPoint ) { tmp . set ( localPoint . x , localPoint . y ) ; Vec2 lv = body . getLinearVelocityFromLocalPoint ( tmp ) ; return linVelLoc . set ( lv . x , lv . y ) ; } public float getLinearDamping ( ) { return body . getLinearDamping ( ) ; } public void setLinearDamping ( float linearDamping ) { body . setLinearDamping ( linearDamping ) ; } public float getAngularDamping ( ) { return body . getAngularDamping ( ) ; } public void setAngularDamping ( float angularDamping ) { body . setAngularDamping ( angularDamping ) ; } public void setType ( BodyType type ) { org . jbox2d . dynamics . BodyType t = org . jbox2d . dynamics . BodyType . DYNAMIC ; if ( type = = BodyType . DynamicBody ) t = org . jbox2d . dynamics . BodyType . DYNAMIC ; if ( type = = BodyType . KinematicBody ) t = org . jbox2d . dynamics . BodyType . KINEMATIC ; if ( type = = BodyType . StaticBody ) t = org . jbox2d . dynamics . BodyType . STATIC ; body . setType ( t ) ; } public BodyType getType ( ) { org . jbox2d . dynamics . BodyType type = body . getType ( ) ; if ( type = = org . jbox2d . dynamics . BodyType . DYNAMIC ) return BodyType . DynamicBody ; if ( type = = org . jbox2d . dynamics . BodyType . KINEMATIC ) return BodyType . KinematicBody ; if ( type = = org . jbox2d . dynamics . BodyType . STATIC ) return BodyType . StaticBody ; return BodyType . DynamicBody ; } public void setBullet ( boolean flag ) { body . setBullet ( flag ) ; } public boolean isBullet ( ) { return body . isBullet ( ) ; } public void setSleepingAllowed ( boolean flag ) { body . setSleepingAllowed ( flag ) ; } public boolean isSleepingAllowed ( ) { return body . isSleepingAllowed ( ) ; } public void setAwake ( boolean flag ) { body . setAwake ( flag ) ; } public boolean isAwake ( ) { return body . isAwake ( ) ; } public void setActive ( boolean flag ) { body . setActive ( flag ) ; } public boolean isActive ( ) { return body . isActive ( ) ; } public void setFixedRotation ( boolean flag ) { body . setFixedRotation ( flag ) ; } public boolean isFixedRotation ( ) { return body . isFixedRotation ( ) ; } public Fixture createFixture ( FixtureDef def ) { org . jbox2d . dynamics . FixtureDef fd = def . toJBox2d ( ) ; org . jbox2d . dynamics . Fixture f = body . createFixture ( fd ) ; Fixture fixture = new Fixture ( this , f ) ; fixtures . add ( fixture ) ; world . fixtures . put ( f , fixture ) ; return fixture ; } public Fixture createFixture ( Shape shape , float density ) { org . jbox2d . dynamics . Fixture f = body . createFixture ( shape . shape , density ) ; Fixture fixture = new Fixture ( this , f ) ; fixtures . add ( fixture ) ; world . fixtures . put ( f , fixture ) ; return fixture ; } public void destroyFixture ( Fixture fixture ) { body . destroyFixture ( fixture . fixture ) ; fixtures . removeValue ( fixture , true ) ; world . fixtures . remove ( fixture . fixture ) ; } public Array < Fixture > getFixtureList ( ) { return fixtures ; } public Array < JointEdge > getJointList ( ) { org . jbox2d . dynamics . joints . JointEdge jointEdge = body . getJointList ( ) ; joints . clear ( ) ; while ( jointEdge ! = null ) { JointEdge edge = new JointEdge ( world . bodies . get ( jointEdge . other ) , world . joints . get ( jointEdge . joint ) ) ; joints . add ( edge ) ; jointEdge = jointEdge . next ; } return joints ; } public float getGravityScale ( ) { return body . getGravityScale ( ) ; } public void setGravityScale ( float scale ) { body . setGravityScale ( scale ) ; } public World getWorld ( ) { return world ; } private Object userData ; public Object getUserData ( ) { return userData ; } public void setUserData ( Object userData ) { this . userData = userData ; } } 
