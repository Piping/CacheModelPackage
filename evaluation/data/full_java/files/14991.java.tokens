package org . gradle . nativeplatform . test . plugins ; import org . gradle . api . * ; import org . gradle . api . tasks . TaskContainer ; import org . gradle . language . base . plugins . LifecycleBasePlugin ; import org . gradle . language . nativeplatform . DependentSourceSet ; import org . gradle . model . * ; import org . gradle . nativeplatform . internal . NativeBinarySpecInternal ; import org . gradle . nativeplatform . plugins . NativeComponentPlugin ; import org . gradle . nativeplatform . tasks . InstallExecutable ; import org . gradle . nativeplatform . test . NativeTestSuiteBinarySpec ; import org . gradle . nativeplatform . test . internal . NativeTestSuiteBinarySpecInternal ; import org . gradle . nativeplatform . test . tasks . RunTestExecutable ; import org . gradle . platform . base . BinarySpec ; import org . gradle . platform . base . internal . BinaryNamingScheme ; import org . gradle . platform . base . internal . BinarySpecInternal ; import org . gradle . platform . base . test . TestSuiteContainer ; import org . gradle . platform . base . test . TestSuiteSpec ; @Incubating public class NativeBinariesTestPlugin implements Plugin < Project > { public void apply ( final Project project ) { project . getPluginManager ( ) . apply ( NativeComponentPlugin . class ) ; } @SuppressWarnings ( <str> ) static class Rules extends RuleSource { @Model void testSuites ( TestSuiteContainer testSuites ) { } @Defaults void attachTestedBinarySourcesToTestBinaries ( ModelMap < BinarySpec > binaries ) { binaries . withType ( NativeTestSuiteBinarySpecInternal . class ) . afterEach ( new Action < NativeTestSuiteBinarySpecInternal > ( ) { @Override public void execute ( NativeTestSuiteBinarySpecInternal testSuiteBinary ) { BinarySpec testedBinary = testSuiteBinary . getTestedBinary ( ) ; for ( DependentSourceSet testSource : testSuiteBinary . getInputs ( ) . withType ( DependentSourceSet . class ) ) { testSource . lib ( testedBinary . getInputs ( ) ) ; } testSuiteBinary . getInputs ( ) . addAll ( testedBinary . getInputs ( ) ) ; } } ) ; } @Mutate public void createTestTasks ( final TaskContainer tasks , ModelMap < NativeTestSuiteBinarySpec > binaries ) { for ( NativeTestSuiteBinarySpec testBinary : binaries ) { NativeBinarySpecInternal binary = ( NativeBinarySpecInternal ) testBinary ; final BinaryNamingScheme namingScheme = binary . getNamingScheme ( ) ; RunTestExecutable runTask = tasks . create ( namingScheme . getTaskName ( <str> ) , RunTestExecutable . class ) ; final Project project = runTask . getProject ( ) ; runTask . setDescription ( String . format ( <str> , binary ) ) ; final InstallExecutable installTask = binary . getTasks ( ) . withType ( InstallExecutable . class ) . iterator ( ) . next ( ) ; runTask . getInputs ( ) . files ( installTask . getOutputs ( ) . getFiles ( ) ) ; runTask . setExecutable ( installTask . getRunScript ( ) . getPath ( ) ) ; runTask . setOutputDir ( namingScheme . getOutputDirectory ( project . getBuildDir ( ) , <str> ) ) ; testBinary . getTasks ( ) . add ( runTask ) ; } } @Defaults public void copyTestBinariesToGlobalContainer ( ModelMap < BinarySpec > binaries , TestSuiteContainer testSuites ) { for ( TestSuiteSpec testSuite : testSuites . withType ( TestSuiteSpec . class ) . values ( ) ) { for ( BinarySpecInternal binary : testSuite . getBinaries ( ) . withType ( BinarySpecInternal . class ) . values ( ) ) { binaries . put ( binary . getProjectScopedName ( ) , binary ) ; } } } @Mutate void attachBinariesToCheckLifecycle ( ModelMap < Task > tasks , final ModelMap < NativeTestSuiteBinarySpec > binaries ) { tasks . named ( LifecycleBasePlugin . CHECK_TASK_NAME , new Action < Task > ( ) { @Override public void execute ( Task checkTask ) { for ( NativeTestSuiteBinarySpec testBinary : binaries ) { checkTask . dependsOn ( testBinary . getTasks ( ) . getRun ( ) ) ; } } } ) ; } } } 
