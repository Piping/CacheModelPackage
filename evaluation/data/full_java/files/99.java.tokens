package org . apache . cassandra . concurrent ; import java . util . concurrent . * ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . tracing . TraceState ; import org . apache . cassandra . tracing . Tracing ; import static org . apache . cassandra . tracing . Tracing . isTracing ; public class DebuggableThreadPoolExecutor extends ThreadPoolExecutor implements TracingAwareExecutorService { protected static final Logger logger = LoggerFactory . getLogger ( DebuggableThreadPoolExecutor . class ) ; public static final RejectedExecutionHandler blockingExecutionHandler = new RejectedExecutionHandler ( ) { public void rejectedExecution ( Runnable task , ThreadPoolExecutor executor ) { ( ( DebuggableThreadPoolExecutor ) executor ) . onInitialRejection ( task ) ; BlockingQueue < Runnable > queue = executor . getQueue ( ) ; while ( true ) { if ( executor . isShutdown ( ) ) { ( ( DebuggableThreadPoolExecutor ) executor ) . onFinalRejection ( task ) ; throw new RejectedExecutionException ( <str> ) ; } try { if ( queue . offer ( task , <int> , TimeUnit . MILLISECONDS ) ) { ( ( DebuggableThreadPoolExecutor ) executor ) . onFinalAccept ( task ) ; break ; } } catch ( InterruptedException e ) { throw new AssertionError ( e ) ; } } } } ; public DebuggableThreadPoolExecutor ( String threadPoolName , int priority ) { this ( <int> , Integer . MAX_VALUE , TimeUnit . SECONDS , new LinkedBlockingQueue < Runnable > ( ) , new NamedThreadFactory ( threadPoolName , priority ) ) ; } public DebuggableThreadPoolExecutor ( int corePoolSize , long keepAliveTime , TimeUnit unit , BlockingQueue < Runnable > queue , ThreadFactory factory ) { this ( corePoolSize , corePoolSize , keepAliveTime , unit , queue , factory ) ; } public DebuggableThreadPoolExecutor ( int corePoolSize , int maximumPoolSize , long keepAliveTime , TimeUnit unit , BlockingQueue < Runnable > workQueue , ThreadFactory threadFactory ) { super ( corePoolSize , maximumPoolSize , keepAliveTime , unit , workQueue , threadFactory ) ; allowCoreThreadTimeOut ( true ) ; this . setRejectedExecutionHandler ( blockingExecutionHandler ) ; } public static DebuggableThreadPoolExecutor createCachedThreadpoolWithMaxSize ( String threadPoolName ) { return new DebuggableThreadPoolExecutor ( <int> , Integer . MAX_VALUE , <int> , TimeUnit . SECONDS , new SynchronousQueue < Runnable > ( ) , new NamedThreadFactory ( threadPoolName ) ) ; } public static DebuggableThreadPoolExecutor createWithFixedPoolSize ( String threadPoolName , int size ) { return createWithMaximumPoolSize ( threadPoolName , size , Integer . MAX_VALUE , TimeUnit . SECONDS ) ; } public static DebuggableThreadPoolExecutor createWithMaximumPoolSize ( String threadPoolName , int size , int keepAliveTime , TimeUnit unit ) { return new DebuggableThreadPoolExecutor ( size , Integer . MAX_VALUE , keepAliveTime , unit , new LinkedBlockingQueue < Runnable > ( ) , new NamedThreadFactory ( threadPoolName ) ) ; } protected void onInitialRejection ( Runnable task ) { } protected void onFinalAccept ( Runnable task ) { } protected void onFinalRejection ( Runnable task ) { } public void execute ( Runnable command , TraceState state ) { super . execute ( state = = null | | command instanceof TraceSessionWrapper ? command : new TraceSessionWrapper < Object > ( command , state ) ) ; } public void maybeExecuteImmediately ( Runnable command ) { execute ( command ) ; } @Override public void execute ( Runnable command ) { super . execute ( isTracing ( ) & & ! ( command instanceof TraceSessionWrapper ) ? new TraceSessionWrapper < Object > ( Executors . callable ( command , null ) ) : command ) ; } @Override protected < T > RunnableFuture < T > newTaskFor ( Runnable runnable , T result ) { if ( isTracing ( ) & & ! ( runnable instanceof TraceSessionWrapper ) ) { return new TraceSessionWrapper < T > ( Executors . callable ( runnable , result ) ) ; } return super . newTaskFor ( runnable , result ) ; } @Override protected < T > RunnableFuture < T > newTaskFor ( Callable < T > callable ) { if ( isTracing ( ) & & ! ( callable instanceof TraceSessionWrapper ) ) { return new TraceSessionWrapper < T > ( callable ) ; } return super . newTaskFor ( callable ) ; } @Override protected void afterExecute ( Runnable r , Throwable t ) { super . afterExecute ( r , t ) ; maybeResetTraceSessionWrapper ( r ) ; logExceptionsAfterExecute ( r , t ) ; } protected static void maybeResetTraceSessionWrapper ( Runnable r ) { if ( r instanceof TraceSessionWrapper ) { TraceSessionWrapper tsw = ( TraceSessionWrapper ) r ; tsw . reset ( ) ; } } @Override protected void beforeExecute ( Thread t , Runnable r ) { if ( r instanceof TraceSessionWrapper ) ( ( TraceSessionWrapper ) r ) . setupContext ( ) ; super . beforeExecute ( t , r ) ; } public static void logExceptionsAfterExecute ( Runnable r , Throwable t ) { Throwable hiddenThrowable = extractThrowable ( r ) ; if ( hiddenThrowable ! = null ) handleOrLog ( hiddenThrowable ) ; if ( t ! = null & & Thread . getDefaultUncaughtExceptionHandler ( ) = = null ) handleOrLog ( t ) ; } public static void handleOrLog ( Throwable t ) { if ( Thread . getDefaultUncaughtExceptionHandler ( ) = = null ) logger . error ( <str> , t ) ; else Thread . getDefaultUncaughtExceptionHandler ( ) . uncaughtException ( Thread . currentThread ( ) , t ) ; } public static Throwable extractThrowable ( Runnable runnable ) { if ( ( runnable instanceof Future < ? > ) & & ( ( Future < ? > ) runnable ) . isDone ( ) ) { try { ( ( Future < ? > ) runnable ) . get ( ) ; } catch ( InterruptedException e ) { throw new AssertionError ( e ) ; } catch ( CancellationException e ) { logger . trace ( <str> , e ) ; } catch ( ExecutionException e ) { return e . getCause ( ) ; } } return null ; } private static class TraceSessionWrapper < T > extends FutureTask < T > { private final TraceState state ; public TraceSessionWrapper ( Callable < T > callable ) { super ( callable ) ; state = Tracing . instance . get ( ) ; } public TraceSessionWrapper ( Runnable command , TraceState state ) { super ( command , null ) ; this . state = state ; } private void setupContext ( ) { Tracing . instance . set ( state ) ; } private void reset ( ) { Tracing . instance . set ( null ) ; } } } 
