package org . gradle . foundation . ipc . gradle ; import org . gradle . BuildAdapter ; import org . gradle . BuildResult ; import org . gradle . api . internal . GradleInternal ; import org . gradle . api . internal . project . ProjectTaskLister ; import org . gradle . api . invocation . Gradle ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . logging . StandardOutputListener ; import org . gradle . foundation . ProjectConverter ; import org . gradle . foundation . ProjectView ; import org . gradle . foundation . ipc . basic . ClientProcess ; import org . gradle . foundation . ipc . basic . MessageObject ; import org . gradle . foundation . ipc . basic . Server ; import org . gradle . gradleplugin . foundation . GradlePluginLord ; import java . io . Serializable ; import java . net . Socket ; import java . util . ArrayList ; import java . util . List ; public class TaskListClientProtocol implements ClientProcess . Protocol { private final Logger logger = Logging . getLogger ( TaskListClientProtocol . class ) ; private ClientProcess client ; private boolean continueConnection = true ; private Gradle gradle ; private Server localServer ; public TaskListClientProtocol ( Gradle gradle ) { this . gradle = gradle ; } public void initialize ( ClientProcess client ) { this . client = client ; this . gradle . addListener ( new RefreshTaskListBuildListener ( client ) ) ; } private class RefreshTaskListBuildListener extends BuildAdapter implements StandardOutputListener { private ClientProcess client ; private StringBuffer allOutputText = new StringBuffer ( ) ; public RefreshTaskListBuildListener ( ClientProcess client ) { this . client = client ; } public synchronized void onOutput ( CharSequence output ) { allOutputText . append ( output ) ; } @Override public void buildFinished ( BuildResult buildResult ) { boolean wasSuccessful = buildResult . getFailure ( ) = = null ; String output = allOutputText . toString ( ) ; if ( ! wasSuccessful ) { String details = GradlePluginLord . getGradleExceptionMessage ( buildResult . getFailure ( ) , gradle . getStartParameter ( ) . getShowStacktrace ( ) ) ; output + = details ; client . sendMessage ( ProtocolConstants . TASK_LIST_COMPLETED_WITH_ERRORS_TYPE , output , wasSuccessful ) ; } else { ProjectConverter buildExecuter = new ProjectConverter ( ( ( GradleInternal ) buildResult . getGradle ( ) ) . getServices ( ) . get ( ProjectTaskLister . class ) ) ; List < ProjectView > projects = new ArrayList < ProjectView > ( ) ; projects . addAll ( buildExecuter . convertProjects ( buildResult . getGradle ( ) . getRootProject ( ) ) ) ; client . sendMessage ( ProtocolConstants . TASK_LIST_COMPLETED_SUCCESSFULLY_TYPE , output , ( Serializable ) projects ) ; } client . sendMessage ( ProtocolConstants . EXITING , null , null ) ; client . stop ( ) ; } } public boolean serverConnected ( Socket clientSocket ) { MessageObject message = client . readMessage ( ) ; if ( message = = null ) { return false ; } if ( ! ProtocolConstants . HANDSHAKE_TYPE . equalsIgnoreCase ( message . getMessageType ( ) ) ) { logger . error ( <str> ) ; return false ; } localServer = new Server ( new KillGradleServerProtocol ( ) ) ; localServer . start ( ) ; client . sendMessage ( ProtocolConstants . HANDSHAKE_TYPE , ProtocolConstants . HANDSHAKE_CLIENT , localServer . getPort ( ) ) ; return true ; } public boolean continueConnection ( ) { return continueConnection ; } public void shutdown ( ) { continueConnection = false ; } } 
