package io . netty . handler . ssl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . ByteBufUtil ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandler ; import io . netty . channel . ChannelOutboundHandler ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . ChannelPromiseNotifier ; import io . netty . channel . PendingWriteQueue ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . handler . codec . UnsupportedMessageTypeException ; import io . netty . util . concurrent . DefaultPromise ; import io . netty . util . concurrent . EventExecutor ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . FutureListener ; import io . netty . util . concurrent . ImmediateExecutor ; import io . netty . util . concurrent . Promise ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import javax . net . ssl . SSLEngine ; import javax . net . ssl . SSLEngineResult ; import javax . net . ssl . SSLEngineResult . HandshakeStatus ; import javax . net . ssl . SSLEngineResult . Status ; import javax . net . ssl . SSLException ; import javax . net . ssl . SSLSession ; import java . io . IOException ; import java . net . SocketAddress ; import java . nio . ByteBuffer ; import java . nio . channels . ClosedChannelException ; import java . nio . channels . DatagramChannel ; import java . nio . channels . SocketChannel ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executor ; import java . util . concurrent . ScheduledFuture ; import java . util . concurrent . TimeUnit ; import java . util . regex . Pattern ; public class SslHandler extends ByteToMessageDecoder implements ChannelOutboundHandler { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( SslHandler . class ) ; private static final Pattern IGNORABLE_CLASS_IN_STACK = Pattern . compile ( <str> ) ; private static final Pattern IGNORABLE_ERROR_MESSAGE = Pattern . compile ( <str> , Pattern . CASE_INSENSITIVE ) ; private static final SSLException SSLENGINE_CLOSED = new SSLException ( <str> ) ; private static final SSLException HANDSHAKE_TIMED_OUT = new SSLException ( <str> ) ; private static final ClosedChannelException CHANNEL_CLOSED = new ClosedChannelException ( ) ; static { SSLENGINE_CLOSED . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; HANDSHAKE_TIMED_OUT . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; CHANNEL_CLOSED . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } private volatile ChannelHandlerContext ctx ; private final SSLEngine engine ; private final int maxPacketBufferSize ; private final Executor delegatedTaskExecutor ; private final ByteBuffer [ ] singleBuffer = new ByteBuffer [ <int> ] ; private final boolean wantsDirectBuffer ; private final boolean wantsLargeOutboundNetworkBuffer ; private boolean wantsInboundHeapBuffer ; private final boolean startTls ; private boolean sentFirstMessage ; private boolean flushedBeforeHandshake ; private boolean readDuringHandshake ; private PendingWriteQueue pendingUnencryptedWrites ; private Promise < Channel > handshakePromise = new LazyChannelPromise ( ) ; private final LazyChannelPromise sslCloseFuture = new LazyChannelPromise ( ) ; private boolean needsFlush ; private boolean outboundClosed ; private int packetLength ; private boolean firedChannelRead ; private volatile long handshakeTimeoutMillis = <int> ; private volatile long closeNotifyTimeoutMillis = <int> ; public SslHandler ( SSLEngine engine ) { this ( engine , false ) ; } @SuppressWarnings ( <str> ) public SslHandler ( SSLEngine engine , boolean startTls ) { this ( engine , startTls , ImmediateExecutor . INSTANCE ) ; } @Deprecated public SslHandler ( SSLEngine engine , Executor delegatedTaskExecutor ) { this ( engine , false , delegatedTaskExecutor ) ; } @Deprecated public SslHandler ( SSLEngine engine , boolean startTls , Executor delegatedTaskExecutor ) { if ( engine = = null ) { throw new NullPointerException ( <str> ) ; } if ( delegatedTaskExecutor = = null ) { throw new NullPointerException ( <str> ) ; } this . engine = engine ; this . delegatedTaskExecutor = delegatedTaskExecutor ; this . startTls = startTls ; maxPacketBufferSize = engine . getSession ( ) . getPacketBufferSize ( ) ; boolean opensslEngine = engine instanceof OpenSslEngine ; wantsDirectBuffer = opensslEngine ; wantsLargeOutboundNetworkBuffer = ! opensslEngine ; setCumulator ( opensslEngine ? COMPOSITE_CUMULATOR : MERGE_CUMULATOR ) ; } public long getHandshakeTimeoutMillis ( ) { return handshakeTimeoutMillis ; } public void setHandshakeTimeout ( long handshakeTimeout , TimeUnit unit ) { if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } setHandshakeTimeoutMillis ( unit . toMillis ( handshakeTimeout ) ) ; } public void setHandshakeTimeoutMillis ( long handshakeTimeoutMillis ) { if ( handshakeTimeoutMillis < <int> ) { throw new IllegalArgumentException ( <str> + handshakeTimeoutMillis + <str> ) ; } this . handshakeTimeoutMillis = handshakeTimeoutMillis ; } public long getCloseNotifyTimeoutMillis ( ) { return closeNotifyTimeoutMillis ; } public void setCloseNotifyTimeout ( long closeNotifyTimeout , TimeUnit unit ) { if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } setCloseNotifyTimeoutMillis ( unit . toMillis ( closeNotifyTimeout ) ) ; } public void setCloseNotifyTimeoutMillis ( long closeNotifyTimeoutMillis ) { if ( closeNotifyTimeoutMillis < <int> ) { throw new IllegalArgumentException ( <str> + closeNotifyTimeoutMillis + <str> ) ; } this . closeNotifyTimeoutMillis = closeNotifyTimeoutMillis ; } public SSLEngine engine ( ) { return engine ; } public String applicationProtocol ( ) { SSLSession sess = engine ( ) . getSession ( ) ; if ( ! ( sess instanceof ApplicationProtocolAccessor ) ) { return null ; } return ( ( ApplicationProtocolAccessor ) sess ) . getApplicationProtocol ( ) ; } public Future < Channel > handshakeFuture ( ) { return handshakePromise ; } public ChannelFuture close ( ) { return close ( ctx . newPromise ( ) ) ; } public ChannelFuture close ( final ChannelPromise future ) { final ChannelHandlerContext ctx = this . ctx ; ctx . executor ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { outboundClosed = true ; engine . closeOutbound ( ) ; try { write ( ctx , Unpooled . EMPTY_BUFFER , future ) ; flush ( ctx ) ; } catch ( Exception e ) { if ( ! future . tryFailure ( e ) ) { logger . warn ( <str> , ctx . channel ( ) , e ) ; } } } } ) ; return future ; } public Future < Channel > sslCloseFuture ( ) { return sslCloseFuture ; } @Override public void handlerRemoved0 ( ChannelHandlerContext ctx ) throws Exception { if ( ! pendingUnencryptedWrites . isEmpty ( ) ) { pendingUnencryptedWrites . removeAndFailAll ( new ChannelException ( <str> ) ) ; } } @Override public void bind ( ChannelHandlerContext ctx , SocketAddress localAddress , ChannelPromise promise ) throws Exception { ctx . bind ( localAddress , promise ) ; } @Override public void connect ( ChannelHandlerContext ctx , SocketAddress remoteAddress , SocketAddress localAddress , ChannelPromise promise ) throws Exception { ctx . connect ( remoteAddress , localAddress , promise ) ; } @Override public void deregister ( ChannelHandlerContext ctx , ChannelPromise promise ) throws Exception { ctx . deregister ( promise ) ; } @Override public void disconnect ( final ChannelHandlerContext ctx , final ChannelPromise promise ) throws Exception { closeOutboundAndChannel ( ctx , promise , true ) ; } @Override public void close ( final ChannelHandlerContext ctx , final ChannelPromise promise ) throws Exception { closeOutboundAndChannel ( ctx , promise , false ) ; } @Override public void read ( ChannelHandlerContext ctx ) throws Exception { if ( ! handshakePromise . isDone ( ) ) { readDuringHandshake = true ; } ctx . read ( ) ; } @Override public void write ( final ChannelHandlerContext ctx , Object msg , ChannelPromise promise ) throws Exception { if ( ! ( msg instanceof ByteBuf ) ) { promise . setFailure ( new UnsupportedMessageTypeException ( msg , ByteBuf . class ) ) ; return ; } pendingUnencryptedWrites . add ( msg , promise ) ; } @Override public void flush ( ChannelHandlerContext ctx ) throws Exception { if ( startTls & & ! sentFirstMessage ) { sentFirstMessage = true ; pendingUnencryptedWrites . removeAndWriteAll ( ) ; ctx . flush ( ) ; return ; } if ( pendingUnencryptedWrites . isEmpty ( ) ) { pendingUnencryptedWrites . add ( Unpooled . EMPTY_BUFFER , ctx . newPromise ( ) ) ; } if ( ! handshakePromise . isDone ( ) ) { flushedBeforeHandshake = true ; } wrap ( ctx , false ) ; ctx . flush ( ) ; } private void wrap ( ChannelHandlerContext ctx , boolean inUnwrap ) throws SSLException { ByteBuf out = null ; ChannelPromise promise = null ; ByteBufAllocator alloc = ctx . alloc ( ) ; try { for ( ; ; ) { Object msg = pendingUnencryptedWrites . current ( ) ; if ( msg = = null ) { break ; } ByteBuf buf = ( ByteBuf ) msg ; if ( out = = null ) { out = allocateOutNetBuf ( ctx , buf . readableBytes ( ) ) ; } SSLEngineResult result = wrap ( alloc , engine , buf , out ) ; if ( ! buf . isReadable ( ) ) { promise = pendingUnencryptedWrites . remove ( ) ; } else { promise = null ; } if ( result . getStatus ( ) = = Status . CLOSED ) { pendingUnencryptedWrites . removeAndFailAll ( SSLENGINE_CLOSED ) ; return ; } else { switch ( result . getHandshakeStatus ( ) ) { case NEED_TASK : runDelegatedTasks ( ) ; break ; case FINISHED : setHandshakeSuccess ( ) ; case NOT_HANDSHAKING : setHandshakeSuccessIfStillHandshaking ( ) ; case NEED_WRAP : finishWrap ( ctx , out , promise , inUnwrap ) ; promise = null ; out = null ; break ; case NEED_UNWRAP : return ; default : throw new IllegalStateException ( <str> + result . getHandshakeStatus ( ) ) ; } } } } catch ( SSLException e ) { setHandshakeFailure ( ctx , e ) ; throw e ; } finally { finishWrap ( ctx , out , promise , inUnwrap ) ; } } private void finishWrap ( ChannelHandlerContext ctx , ByteBuf out , ChannelPromise promise , boolean inUnwrap ) { if ( out = = null ) { out = Unpooled . EMPTY_BUFFER ; } else if ( ! out . isReadable ( ) ) { out . release ( ) ; out = Unpooled . EMPTY_BUFFER ; } if ( promise ! = null ) { ctx . write ( out , promise ) ; } else { ctx . write ( out ) ; } if ( inUnwrap ) { needsFlush = true ; } } private void wrapNonAppData ( ChannelHandlerContext ctx , boolean inUnwrap ) throws SSLException { ByteBuf out = null ; ByteBufAllocator alloc = ctx . alloc ( ) ; try { for ( ; ; ) { if ( out = = null ) { out = allocateOutNetBuf ( ctx , <int> ) ; } SSLEngineResult result = wrap ( alloc , engine , Unpooled . EMPTY_BUFFER , out ) ; if ( result . bytesProduced ( ) > <int> ) { ctx . write ( out ) ; if ( inUnwrap ) { needsFlush = true ; } out = null ; } switch ( result . getHandshakeStatus ( ) ) { case FINISHED : setHandshakeSuccess ( ) ; break ; case NEED_TASK : runDelegatedTasks ( ) ; break ; case NEED_UNWRAP : if ( ! inUnwrap ) { unwrapNonAppData ( ctx ) ; } break ; case NEED_WRAP : break ; case NOT_HANDSHAKING : setHandshakeSuccessIfStillHandshaking ( ) ; if ( ! inUnwrap ) { unwrapNonAppData ( ctx ) ; } break ; default : throw new IllegalStateException ( <str> + result . getHandshakeStatus ( ) ) ; } if ( result . bytesProduced ( ) = = <int> ) { break ; } if ( result . bytesConsumed ( ) = = <int> & & result . getHandshakeStatus ( ) = = HandshakeStatus . NOT_HANDSHAKING ) { break ; } } } catch ( SSLException e ) { setHandshakeFailure ( ctx , e ) ; throw e ; } finally { if ( out ! = null ) { out . release ( ) ; } } } private SSLEngineResult wrap ( ByteBufAllocator alloc , SSLEngine engine , ByteBuf in , ByteBuf out ) throws SSLException { ByteBuf newDirectIn = null ; try { int readerIndex = in . readerIndex ( ) ; int readableBytes = in . readableBytes ( ) ; final ByteBuffer [ ] in0 ; if ( in . isDirect ( ) | | ! wantsDirectBuffer ) { if ( ! ( in instanceof CompositeByteBuf ) & & in . nioBufferCount ( ) = = <int> ) { in0 = singleBuffer ; in0 [ <int> ] = in . internalNioBuffer ( readerIndex , readableBytes ) ; } else { in0 = in . nioBuffers ( ) ; } } else { newDirectIn = alloc . directBuffer ( readableBytes ) ; newDirectIn . writeBytes ( in , readerIndex , readableBytes ) ; in0 = singleBuffer ; in0 [ <int> ] = newDirectIn . internalNioBuffer ( <int> , readableBytes ) ; } for ( ; ; ) { ByteBuffer out0 = out . nioBuffer ( out . writerIndex ( ) , out . writableBytes ( ) ) ; SSLEngineResult result = engine . wrap ( in0 , out0 ) ; in . skipBytes ( result . bytesConsumed ( ) ) ; out . writerIndex ( out . writerIndex ( ) + result . bytesProduced ( ) ) ; switch ( result . getStatus ( ) ) { case BUFFER_OVERFLOW : out . ensureWritable ( maxPacketBufferSize ) ; break ; default : return result ; } } } finally { singleBuffer [ <int> ] = null ; if ( newDirectIn ! = null ) { newDirectIn . release ( ) ; } } } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { setHandshakeFailure ( ctx , CHANNEL_CLOSED , ! outboundClosed ) ; super . channelInactive ( ctx ) ; } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { if ( ignoreException ( cause ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + <str> , ctx . channel ( ) , cause ) ; } if ( ctx . channel ( ) . isActive ( ) ) { ctx . close ( ) ; } } else { ctx . fireExceptionCaught ( cause ) ; } } private boolean ignoreException ( Throwable t ) { if ( ! ( t instanceof SSLException ) & & t instanceof IOException & & sslCloseFuture . isDone ( ) ) { String message = String . valueOf ( t . getMessage ( ) ) . toLowerCase ( ) ; if ( IGNORABLE_ERROR_MESSAGE . matcher ( message ) . matches ( ) ) { return true ; } StackTraceElement [ ] elements = t . getStackTrace ( ) ; for ( StackTraceElement element : elements ) { String classname = element . getClassName ( ) ; String methodname = element . getMethodName ( ) ; if ( classname . startsWith ( <str> ) ) { continue ; } if ( ! <str> . equals ( methodname ) ) { continue ; } if ( IGNORABLE_CLASS_IN_STACK . matcher ( classname ) . matches ( ) ) { return true ; } try { Class < ? > clazz = PlatformDependent . getClassLoader ( getClass ( ) ) . loadClass ( classname ) ; if ( SocketChannel . class . isAssignableFrom ( clazz ) | | DatagramChannel . class . isAssignableFrom ( clazz ) ) { return true ; } if ( PlatformDependent . javaVersion ( ) > = <int> & & <str> . equals ( clazz . getSuperclass ( ) . getName ( ) ) ) { return true ; } } catch ( ClassNotFoundException e ) { } } } return false ; } public static boolean isEncrypted ( ByteBuf buffer ) { if ( buffer . readableBytes ( ) < <int> ) { throw new IllegalArgumentException ( <str> ) ; } return getEncryptedPacketLength ( buffer , buffer . readerIndex ( ) ) ! = - <int> ; } private static int getEncryptedPacketLength ( ByteBuf buffer , int offset ) { int packetLength = <int> ; boolean tls ; switch ( buffer . getUnsignedByte ( offset ) ) { case <int> : case <int> : case <int> : case <int> : tls = true ; break ; default : tls = false ; } if ( tls ) { int majorVersion = buffer . getUnsignedByte ( offset + <int> ) ; if ( majorVersion = = <int> ) { packetLength = buffer . getUnsignedShort ( offset + <int> ) + <int> ; if ( packetLength < = <int> ) { tls = false ; } } else { tls = false ; } } if ( ! tls ) { boolean sslv2 = true ; int headerLength = ( buffer . getUnsignedByte ( offset ) & <hex> ) ! = <int> ? <int> : <int> ; int majorVersion = buffer . getUnsignedByte ( offset + headerLength + <int> ) ; if ( majorVersion = = <int> | | majorVersion = = <int> ) { if ( headerLength = = <int> ) { packetLength = ( buffer . getShort ( offset ) & <hex> ) + <int> ; } else { packetLength = ( buffer . getShort ( offset ) & <hex> ) + <int> ; } if ( packetLength < = headerLength ) { sslv2 = false ; } } else { sslv2 = false ; } if ( ! sslv2 ) { return - <int> ; } } return packetLength ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws SSLException { final int startOffset = in . readerIndex ( ) ; final int endOffset = in . writerIndex ( ) ; int offset = startOffset ; int totalLength = <int> ; if ( packetLength > <int> ) { if ( endOffset - startOffset < packetLength ) { return ; } else { offset + = packetLength ; totalLength = packetLength ; packetLength = <int> ; } } boolean nonSslRecord = false ; while ( totalLength < OpenSslEngine . MAX_ENCRYPTED_PACKET_LENGTH ) { final int readableBytes = endOffset - offset ; if ( readableBytes < <int> ) { break ; } final int packetLength = getEncryptedPacketLength ( in , offset ) ; if ( packetLength = = - <int> ) { nonSslRecord = true ; break ; } assert packetLength > <int> ; if ( packetLength > readableBytes ) { this . packetLength = packetLength ; break ; } int newTotalLength = totalLength + packetLength ; if ( newTotalLength > OpenSslEngine . MAX_ENCRYPTED_PACKET_LENGTH ) { break ; } offset + = packetLength ; totalLength = newTotalLength ; } if ( totalLength > <int> ) { boolean decoded = false ; in . skipBytes ( totalLength ) ; if ( in . isDirect ( ) & & wantsInboundHeapBuffer ) { ByteBuf copy = ctx . alloc ( ) . heapBuffer ( totalLength ) ; try { copy . writeBytes ( in , startOffset , totalLength ) ; decoded = unwrap ( ctx , copy , <int> , totalLength ) ; } finally { copy . release ( ) ; } } else { decoded = unwrap ( ctx , in , startOffset , totalLength ) ; } if ( ! firedChannelRead ) { firedChannelRead = decoded ; } } if ( nonSslRecord ) { NotSslRecordException e = new NotSslRecordException ( <str> + ByteBufUtil . hexDump ( in ) ) ; in . skipBytes ( in . readableBytes ( ) ) ; ctx . fireExceptionCaught ( e ) ; setHandshakeFailure ( ctx , e ) ; } } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { discardSomeReadBytes ( ) ; if ( needsFlush ) { needsFlush = false ; ctx . flush ( ) ; } if ( ! ctx . channel ( ) . config ( ) . isAutoRead ( ) & & ( ! firedChannelRead | | ! handshakePromise . isDone ( ) ) ) { ctx . read ( ) ; } firedChannelRead = false ; ctx . fireChannelReadComplete ( ) ; } private void unwrapNonAppData ( ChannelHandlerContext ctx ) throws SSLException { unwrap ( ctx , Unpooled . EMPTY_BUFFER , <int> , <int> ) ; } private boolean unwrap ( ChannelHandlerContext ctx , ByteBuf packet , int offset , int length ) throws SSLException { boolean decoded = false ; boolean wrapLater = false ; boolean notifyClosure = false ; ByteBuf decodeOut = allocate ( ctx , length ) ; try { for ( ; ; ) { final SSLEngineResult result = unwrap ( engine , packet , offset , length , decodeOut ) ; final Status status = result . getStatus ( ) ; final HandshakeStatus handshakeStatus = result . getHandshakeStatus ( ) ; final int produced = result . bytesProduced ( ) ; final int consumed = result . bytesConsumed ( ) ; offset + = consumed ; length - = consumed ; switch ( status ) { case BUFFER_OVERFLOW : int readableBytes = decodeOut . readableBytes ( ) ; if ( readableBytes > <int> ) { decoded = true ; ctx . fireChannelRead ( decodeOut ) ; } else { decodeOut . release ( ) ; } decodeOut = allocate ( ctx , engine . getSession ( ) . getApplicationBufferSize ( ) - readableBytes ) ; continue ; case CLOSED : notifyClosure = true ; break ; default : break ; } switch ( handshakeStatus ) { case NEED_UNWRAP : break ; case NEED_WRAP : wrapNonAppData ( ctx , true ) ; break ; case NEED_TASK : runDelegatedTasks ( ) ; break ; case FINISHED : setHandshakeSuccess ( ) ; wrapLater = true ; continue ; case NOT_HANDSHAKING : if ( setHandshakeSuccessIfStillHandshaking ( ) ) { wrapLater = true ; continue ; } if ( flushedBeforeHandshake ) { flushedBeforeHandshake = false ; wrapLater = true ; } break ; default : throw new IllegalStateException ( <str> + handshakeStatus ) ; } if ( status = = Status . BUFFER_UNDERFLOW | | consumed = = <int> & & produced = = <int> ) { break ; } } if ( wrapLater ) { wrap ( ctx , true ) ; } if ( notifyClosure ) { sslCloseFuture . trySuccess ( ctx . channel ( ) ) ; } } catch ( SSLException e ) { setHandshakeFailure ( ctx , e ) ; throw e ; } finally { if ( decodeOut . isReadable ( ) ) { decoded = true ; ctx . fireChannelRead ( decodeOut ) ; } else { decodeOut . release ( ) ; } } return decoded ; } private SSLEngineResult unwrap ( SSLEngine engine , ByteBuf in , int readerIndex , int len , ByteBuf out ) throws SSLException { int nioBufferCount = in . nioBufferCount ( ) ; int writerIndex = out . writerIndex ( ) ; final SSLEngineResult result ; if ( engine instanceof OpenSslEngine & & nioBufferCount > <int> ) { OpenSslEngine opensslEngine = ( OpenSslEngine ) engine ; try { singleBuffer [ <int> ] = toByteBuffer ( out , writerIndex , out . writableBytes ( ) ) ; result = opensslEngine . unwrap ( in . nioBuffers ( readerIndex , len ) , singleBuffer ) ; out . writerIndex ( writerIndex + result . bytesProduced ( ) ) ; } finally { singleBuffer [ <int> ] = null ; } } else { result = engine . unwrap ( toByteBuffer ( in , readerIndex , len ) , toByteBuffer ( out , writerIndex , out . writableBytes ( ) ) ) ; } out . writerIndex ( writerIndex + result . bytesProduced ( ) ) ; return result ; } private static ByteBuffer toByteBuffer ( ByteBuf out , int index , int len ) { return out . nioBufferCount ( ) = = <int> ? out . internalNioBuffer ( index , len ) : out . nioBuffer ( index , len ) ; } private void runDelegatedTasks ( ) { if ( delegatedTaskExecutor = = ImmediateExecutor . INSTANCE ) { for ( ; ; ) { Runnable task = engine . getDelegatedTask ( ) ; if ( task = = null ) { break ; } task . run ( ) ; } } else { final List < Runnable > tasks = new ArrayList < Runnable > ( <int> ) ; for ( ; ; ) { final Runnable task = engine . getDelegatedTask ( ) ; if ( task = = null ) { break ; } tasks . add ( task ) ; } if ( tasks . isEmpty ( ) ) { return ; } final CountDownLatch latch = new CountDownLatch ( <int> ) ; delegatedTaskExecutor . execute ( new OneTimeTask ( ) { @Override public void run ( ) { try { for ( Runnable task : tasks ) { task . run ( ) ; } } catch ( Exception e ) { ctx . fireExceptionCaught ( e ) ; } finally { latch . countDown ( ) ; } } } ) ; boolean interrupted = false ; while ( latch . getCount ( ) ! = <int> ) { try { latch . await ( ) ; } catch ( InterruptedException e ) { interrupted = true ; } } if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; } } } private boolean setHandshakeSuccessIfStillHandshaking ( ) { if ( ! handshakePromise . isDone ( ) ) { setHandshakeSuccess ( ) ; return true ; } return false ; } private void setHandshakeSuccess ( ) { final String cipherSuite = String . valueOf ( engine . getSession ( ) . getCipherSuite ( ) ) ; if ( ! wantsDirectBuffer & & ( cipherSuite . contains ( <str> ) | | cipherSuite . contains ( <str> ) ) ) { wantsInboundHeapBuffer = true ; } handshakePromise . trySuccess ( ctx . channel ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , ctx . channel ( ) , engine . getSession ( ) . getCipherSuite ( ) ) ; } ctx . fireUserEventTriggered ( SslHandshakeCompletionEvent . SUCCESS ) ; if ( readDuringHandshake & & ! ctx . channel ( ) . config ( ) . isAutoRead ( ) ) { readDuringHandshake = false ; ctx . read ( ) ; } } private void setHandshakeFailure ( ChannelHandlerContext ctx , Throwable cause ) { setHandshakeFailure ( ctx , cause , true ) ; } private void setHandshakeFailure ( ChannelHandlerContext ctx , Throwable cause , boolean closeInbound ) { engine . closeOutbound ( ) ; if ( closeInbound ) { try { engine . closeInbound ( ) ; } catch ( SSLException e ) { String msg = e . getMessage ( ) ; if ( msg = = null | | ! msg . contains ( <str> ) ) { logger . debug ( <str> , ctx . channel ( ) , e ) ; } } } notifyHandshakeFailure ( cause ) ; pendingUnencryptedWrites . removeAndFailAll ( cause ) ; } private void notifyHandshakeFailure ( Throwable cause ) { if ( handshakePromise . tryFailure ( cause ) ) { ctx . fireUserEventTriggered ( new SslHandshakeCompletionEvent ( cause ) ) ; ctx . close ( ) ; } } private void closeOutboundAndChannel ( final ChannelHandlerContext ctx , final ChannelPromise promise , boolean disconnect ) throws Exception { if ( ! ctx . channel ( ) . isActive ( ) ) { if ( disconnect ) { ctx . disconnect ( promise ) ; } else { ctx . close ( promise ) ; } return ; } outboundClosed = true ; engine . closeOutbound ( ) ; ChannelPromise closeNotifyFuture = ctx . newPromise ( ) ; write ( ctx , Unpooled . EMPTY_BUFFER , closeNotifyFuture ) ; flush ( ctx ) ; safeClose ( ctx , closeNotifyFuture , promise ) ; } @Override public void handlerAdded ( final ChannelHandlerContext ctx ) throws Exception { this . ctx = ctx ; pendingUnencryptedWrites = new PendingWriteQueue ( ctx ) ; if ( ctx . channel ( ) . isActive ( ) & & engine . getUseClientMode ( ) ) { handshake ( null ) ; } else { } } public Future < Channel > renegotiate ( ) { ChannelHandlerContext ctx = this . ctx ; if ( ctx = = null ) { throw new IllegalStateException ( ) ; } return renegotiate ( ctx . executor ( ) . < Channel > newPromise ( ) ) ; } public Future < Channel > renegotiate ( final Promise < Channel > promise ) { if ( promise = = null ) { throw new NullPointerException ( <str> ) ; } ChannelHandlerContext ctx = this . ctx ; if ( ctx = = null ) { throw new IllegalStateException ( ) ; } EventExecutor executor = ctx . executor ( ) ; if ( ! executor . inEventLoop ( ) ) { executor . execute ( new OneTimeTask ( ) { @Override public void run ( ) { handshake ( promise ) ; } } ) ; return promise ; } handshake ( promise ) ; return promise ; } private void handshake ( final Promise < Channel > newHandshakePromise ) { final Promise < Channel > p ; if ( newHandshakePromise ! = null ) { final Promise < Channel > oldHandshakePromise = handshakePromise ; if ( ! oldHandshakePromise . isDone ( ) ) { oldHandshakePromise . addListener ( new FutureListener < Channel > ( ) { @Override public void operationComplete ( Future < Channel > future ) throws Exception { if ( future . isSuccess ( ) ) { newHandshakePromise . setSuccess ( future . getNow ( ) ) ; } else { newHandshakePromise . setFailure ( future . cause ( ) ) ; } } } ) ; return ; } handshakePromise = p = newHandshakePromise ; } else { p = handshakePromise ; assert ! p . isDone ( ) ; } final ChannelHandlerContext ctx = this . ctx ; try { engine . beginHandshake ( ) ; wrapNonAppData ( ctx , false ) ; ctx . flush ( ) ; } catch ( Exception e ) { notifyHandshakeFailure ( e ) ; } final long handshakeTimeoutMillis = this . handshakeTimeoutMillis ; if ( handshakeTimeoutMillis < = <int> | | p . isDone ( ) ) { return ; } final ScheduledFuture < ? > timeoutFuture = ctx . executor ( ) . schedule ( new OneTimeTask ( ) { @Override public void run ( ) { if ( p . isDone ( ) ) { return ; } notifyHandshakeFailure ( HANDSHAKE_TIMED_OUT ) ; } } , handshakeTimeoutMillis , TimeUnit . MILLISECONDS ) ; p . addListener ( new FutureListener < Channel > ( ) { @Override public void operationComplete ( Future < Channel > f ) throws Exception { timeoutFuture . cancel ( false ) ; } } ) ; } @Override public void channelActive ( final ChannelHandlerContext ctx ) throws Exception { if ( ! startTls & & engine . getUseClientMode ( ) ) { handshake ( null ) ; } ctx . fireChannelActive ( ) ; } private void safeClose ( final ChannelHandlerContext ctx , ChannelFuture flushFuture , final ChannelPromise promise ) { if ( ! ctx . channel ( ) . isActive ( ) ) { ctx . close ( promise ) ; return ; } final ScheduledFuture < ? > timeoutFuture ; if ( closeNotifyTimeoutMillis > <int> ) { timeoutFuture = ctx . executor ( ) . schedule ( new OneTimeTask ( ) { @Override public void run ( ) { logger . warn ( <str> , ctx . channel ( ) ) ; ctx . close ( ctx . newPromise ( ) ) . addListener ( new ChannelPromiseNotifier ( promise ) ) ; } } , closeNotifyTimeoutMillis , TimeUnit . MILLISECONDS ) ; } else { timeoutFuture = null ; } flushFuture . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( timeoutFuture ! = null ) { timeoutFuture . cancel ( false ) ; } ctx . close ( ctx . newPromise ( ) ) . addListener ( new ChannelPromiseNotifier ( promise ) ) ; } } ) ; } private ByteBuf allocate ( ChannelHandlerContext ctx , int capacity ) { ByteBufAllocator alloc = ctx . alloc ( ) ; if ( wantsDirectBuffer ) { return alloc . directBuffer ( capacity ) ; } else { return alloc . buffer ( capacity ) ; } } private ByteBuf allocateOutNetBuf ( ChannelHandlerContext ctx , int pendingBytes ) { if ( wantsLargeOutboundNetworkBuffer ) { return allocate ( ctx , maxPacketBufferSize ) ; } else { return allocate ( ctx , Math . min ( pendingBytes + OpenSslEngine . MAX_ENCRYPTION_OVERHEAD_LENGTH , maxPacketBufferSize ) ) ; } } private final class LazyChannelPromise extends DefaultPromise < Channel > { @Override protected EventExecutor executor ( ) { if ( ctx = = null ) { throw new IllegalStateException ( ) ; } return ctx . executor ( ) ; } @Override protected void checkDeadLock ( ) { if ( ctx = = null ) { return ; } super . checkDeadLock ( ) ; } } } 
