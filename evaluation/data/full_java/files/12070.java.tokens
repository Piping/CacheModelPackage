package org . gradle . internal . filewatch ; import org . gradle . api . Action ; import org . gradle . api . internal . file . FileSystemSubset ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import java . io . IOException ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; import java . util . concurrent . atomic . AtomicReference ; import java . util . concurrent . locks . Condition ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DefaultFileSystemChangeWaiterFactory implements FileSystemChangeWaiterFactory { private final ExecutorFactory executorFactory ; private final FileWatcherFactory fileWatcherFactory ; private final long quietPeriodMillis ; public DefaultFileSystemChangeWaiterFactory ( ExecutorFactory executorFactory , FileWatcherFactory fileWatcherFactory ) { this ( executorFactory , fileWatcherFactory , <int> ) ; } public DefaultFileSystemChangeWaiterFactory ( ExecutorFactory executorFactory , FileWatcherFactory fileWatcherFactory , long quietPeriodMillis ) { this . executorFactory = executorFactory ; this . fileWatcherFactory = fileWatcherFactory ; this . quietPeriodMillis = quietPeriodMillis ; } @Override public FileSystemChangeWaiter createChangeWaiter ( BuildCancellationToken cancellationToken ) { return new ChangeWaiter ( fileWatcherFactory , quietPeriodMillis , cancellationToken ) ; } private static class ChangeWaiter implements FileSystemChangeWaiter { private final long quietPeriodMillis ; private final BuildCancellationToken cancellationToken ; private final AtomicReference < Throwable > error = new AtomicReference < Throwable > ( ) ; private final Lock lock = new ReentrantLock ( ) ; private final Condition condition = lock . newCondition ( ) ; private final AtomicLong lastChangeAt = new AtomicLong ( <int> ) ; private final FileWatcher watcher ; private final Action < Throwable > onError ; private ChangeWaiter ( FileWatcherFactory fileWatcherFactory , long quietPeriodMillis , BuildCancellationToken cancellationToken ) { this . quietPeriodMillis = quietPeriodMillis ; this . cancellationToken = cancellationToken ; this . onError = new Action < Throwable > ( ) { @Override public void execute ( Throwable throwable ) { error . set ( throwable ) ; signal ( lock , condition ) ; } } ; watcher = fileWatcherFactory . watch ( onError , new FileWatcherListener ( ) { @Override public void onChange ( final FileWatcher watcher , FileWatcherEvent event ) { if ( ! ( event . getType ( ) = = FileWatcherEvent . Type . MODIFY & & event . getFile ( ) . isDirectory ( ) ) ) { signal ( lock , condition , new Runnable ( ) { @Override public void run ( ) { lastChangeAt . set ( monotonicClockMillis ( ) ) ; } } ) ; } } } ) ; } @Override public void watch ( FileSystemSubset fileSystemSubset ) { try { watcher . watch ( fileSystemSubset ) ; } catch ( IOException e ) { onError . execute ( e ) ; } } public void wait ( Runnable notifier ) { if ( cancellationToken . isCancellationRequested ( ) ) { return ; } Runnable cancellationHandler = new Runnable ( ) { @Override public void run ( ) { signal ( lock , condition ) ; } } ; try { cancellationToken . addCallback ( cancellationHandler ) ; notifier . run ( ) ; lock . lock ( ) ; try { long lastChangeAtValue = lastChangeAt . get ( ) ; while ( ! cancellationToken . isCancellationRequested ( ) & & error . get ( ) = = null & & ( lastChangeAtValue = = <int> | | monotonicClockMillis ( ) - lastChangeAtValue < quietPeriodMillis ) ) { condition . await ( quietPeriodMillis , TimeUnit . MILLISECONDS ) ; lastChangeAtValue = lastChangeAt . get ( ) ; } } finally { lock . unlock ( ) ; } Throwable throwable = error . get ( ) ; if ( throwable ! = null ) { throw throwable ; } } catch ( Throwable e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } finally { cancellationToken . removeCallback ( cancellationHandler ) ; CompositeStoppable . stoppable ( watcher ) . stop ( ) ; } } } private static long monotonicClockMillis ( ) { return System . nanoTime ( ) / <int> ; } private static void signal ( Lock lock , Condition condition , Runnable runnable ) { lock . lock ( ) ; try { runnable . run ( ) ; condition . signal ( ) ; } finally { lock . unlock ( ) ; } } private static void signal ( Lock lock , Condition condition ) { signal ( lock , condition , new Runnable ( ) { @Override public void run ( ) { } } ) ; } } 
