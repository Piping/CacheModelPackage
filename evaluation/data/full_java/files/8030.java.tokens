package org . elasticsearch . discovery . zen . publish ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . transport . DummyTransportAddress ; import org . elasticsearch . discovery . zen . publish . PendingClusterStatesQueue . ClusterStateContext ; import org . elasticsearch . test . ESTestCase ; import java . util . * ; import static org . hamcrest . Matchers . * ; public class PendingClusterStatesQueueTests extends ESTestCase { public void testSelectNextStateToProcess_empty ( ) { PendingClusterStatesQueue queue = new PendingClusterStatesQueue ( logger , randomIntBetween ( <int> , <int> ) ) ; assertThat ( queue . getNextClusterStateToProcess ( ) , nullValue ( ) ) ; } public void testDroppingStatesAtCapacity ( ) { List < ClusterState > states = randomStates ( scaledRandomIntBetween ( <int> , <int> ) , <str> , <str> , <str> , <str> ) ; Collections . shuffle ( states , random ( ) ) ; final int numberOfStateToDrop = states . size ( ) / <int> ; List < ClusterState > stateToDrop = states . subList ( <int> , numberOfStateToDrop ) ; final int queueSize = states . size ( ) - numberOfStateToDrop ; PendingClusterStatesQueue queue = createQueueWithStates ( stateToDrop , queueSize ) ; List < ClusterStateContext > committedContexts = randomCommitStates ( queue ) ; for ( ClusterState state : states . subList ( numberOfStateToDrop , states . size ( ) ) ) { queue . addPending ( state ) ; } assertThat ( queue . pendingClusterStates ( ) . length , equalTo ( queueSize ) ) ; for ( ClusterStateContext context : committedContexts ) { assertThat ( ( ( MockListener ) context . listener ) . failure , notNullValue ( ) ) ; } for ( ClusterState state : stateToDrop ) { assertThat ( queue . findState ( state . stateUUID ( ) ) , nullValue ( ) ) ; } } public void testSimpleQueueSameMaster ( ) { final int numUpdates = scaledRandomIntBetween ( <int> , <int> ) ; List < ClusterState > states = randomStates ( numUpdates , <str> ) ; Collections . shuffle ( states , random ( ) ) ; PendingClusterStatesQueue queue ; queue = createQueueWithStates ( states ) ; assertThat ( queue . getNextClusterStateToProcess ( ) , nullValue ( ) ) ; ClusterState highestCommitted = null ; for ( ClusterStateContext context : randomCommitStates ( queue ) ) { if ( highestCommitted = = null | | context . state . supersedes ( highestCommitted ) ) { highestCommitted = context . state ; } } assertThat ( queue . getNextClusterStateToProcess ( ) , sameInstance ( highestCommitted ) ) ; queue . markAsProcessed ( highestCommitted ) ; assertThat ( queue . getNextClusterStateToProcess ( ) , nullValue ( ) ) ; } public void testProcessedStateCleansStatesFromOtherMasters ( ) { List < ClusterState > states = randomStates ( scaledRandomIntBetween ( <int> , <int> ) , <str> , <str> , <str> , <str> ) ; PendingClusterStatesQueue queue = createQueueWithStates ( states ) ; List < ClusterStateContext > committedContexts = randomCommitStates ( queue ) ; ClusterState randomCommitted = randomFrom ( committedContexts ) . state ; queue . markAsProcessed ( randomCommitted ) ; final String processedMaster = randomCommitted . nodes ( ) . masterNodeId ( ) ; for ( ClusterStateContext context : queue . pendingStates ) { final String pendingMaster = context . state . nodes ( ) . masterNodeId ( ) ; assertThat ( <str> + pendingMaster + <str> + processedMaster + <str> , pendingMaster , equalTo ( processedMaster ) ) ; } for ( ClusterStateContext context : committedContexts ) { if ( context . state . nodes ( ) . masterNodeId ( ) . equals ( processedMaster ) = = false ) { assertThat ( ( ( MockListener ) context . listener ) . failure , notNullValue ( ) ) ; } } } public void testFailedStateCleansSupersededStatesOnly ( ) { List < ClusterState > states = randomStates ( scaledRandomIntBetween ( <int> , <int> ) , <str> , <str> , <str> , <str> ) ; PendingClusterStatesQueue queue = createQueueWithStates ( states ) ; List < ClusterStateContext > committedContexts = randomCommitStates ( queue ) ; ClusterState toFail = randomFrom ( committedContexts ) . state ; queue . markAsFailed ( toFail , new ElasticsearchException ( <str> ) ) ; final Map < String , ClusterStateContext > committedContextsById = new HashMap < > ( ) ; for ( ClusterStateContext context : committedContexts ) { committedContextsById . put ( context . stateUUID ( ) , context ) ; } for ( ClusterStateContext context : queue . pendingStates ) { if ( context . committed ( ) ) { assertFalse ( <str> + context . state + <str> + toFail , toFail . supersedes ( context . state ) ) ; } } for ( ClusterState state : states ) { ClusterStateContext pendingContext = queue . findState ( state . stateUUID ( ) ) ; if ( pendingContext ! = null ) { continue ; } if ( state . equals ( toFail ) ) { continue ; } assertThat ( <str> , committedContextsById , hasKey ( state . stateUUID ( ) ) ) ; final ClusterStateContext context = committedContextsById . get ( state . stateUUID ( ) ) ; assertThat ( <str> + context + <str> + toFail , toFail . supersedes ( context . state ) , equalTo ( true ) ) ; assertThat ( <str> , ( ( MockListener ) context . listener ) . failure , notNullValue ( ) ) ; assertThat ( <str> , ( ( MockListener ) context . listener ) . failure . getMessage ( ) , containsString ( <str> ) ) ; } } public void testFailAllAndClear ( ) { List < ClusterState > states = randomStates ( scaledRandomIntBetween ( <int> , <int> ) , <str> , <str> , <str> , <str> ) ; PendingClusterStatesQueue queue = createQueueWithStates ( states ) ; List < ClusterStateContext > committedContexts = randomCommitStates ( queue ) ; queue . failAllStatesAndClear ( new ElasticsearchException ( <str> ) ) ; assertThat ( queue . pendingStates , empty ( ) ) ; assertThat ( queue . getNextClusterStateToProcess ( ) , nullValue ( ) ) ; for ( ClusterStateContext context : committedContexts ) { assertThat ( <str> , ( ( MockListener ) context . listener ) . failure , notNullValue ( ) ) ; assertThat ( <str> , ( ( MockListener ) context . listener ) . failure . getMessage ( ) , containsString ( <str> ) ) ; } } public void testQueueStats ( ) { List < ClusterState > states = randomStates ( scaledRandomIntBetween ( <int> , <int> ) , <str> ) ; PendingClusterStatesQueue queue = createQueueWithStates ( states ) ; assertThat ( queue . stats ( ) . getTotal ( ) , equalTo ( states . size ( ) ) ) ; assertThat ( queue . stats ( ) . getPending ( ) , equalTo ( states . size ( ) ) ) ; assertThat ( queue . stats ( ) . getCommitted ( ) , equalTo ( <int> ) ) ; List < ClusterStateContext > committedContexts = randomCommitStates ( queue ) ; assertThat ( queue . stats ( ) . getTotal ( ) , equalTo ( states . size ( ) ) ) ; assertThat ( queue . stats ( ) . getPending ( ) , equalTo ( states . size ( ) - committedContexts . size ( ) ) ) ; assertThat ( queue . stats ( ) . getCommitted ( ) , equalTo ( committedContexts . size ( ) ) ) ; ClusterState highestCommitted = null ; for ( ClusterStateContext context : committedContexts ) { if ( highestCommitted = = null | | context . state . supersedes ( highestCommitted ) ) { highestCommitted = context . state ; } } queue . markAsProcessed ( highestCommitted ) ; assertThat ( queue . stats ( ) . getTotal ( ) , equalTo ( states . size ( ) - committedContexts . size ( ) ) ) ; assertThat ( queue . stats ( ) . getPending ( ) , equalTo ( states . size ( ) - committedContexts . size ( ) ) ) ; assertThat ( queue . stats ( ) . getCommitted ( ) , equalTo ( <int> ) ) ; } protected List < ClusterStateContext > randomCommitStates ( PendingClusterStatesQueue queue ) { List < ClusterStateContext > committedContexts = new ArrayList < > ( ) ; for ( int iter = randomInt ( queue . pendingStates . size ( ) - <int> ) ; iter > = <int> ; iter - - ) { ClusterState state = queue . markAsCommitted ( randomFrom ( queue . pendingStates ) . stateUUID ( ) , new MockListener ( ) ) ; if ( state ! = null ) { committedContexts . add ( queue . findState ( state . stateUUID ( ) ) ) ; } } return committedContexts ; } PendingClusterStatesQueue createQueueWithStates ( List < ClusterState > states ) { return createQueueWithStates ( states , states . size ( ) * <int> ) ; } PendingClusterStatesQueue createQueueWithStates ( List < ClusterState > states , int maxQueueSize ) { PendingClusterStatesQueue queue ; queue = new PendingClusterStatesQueue ( logger , maxQueueSize ) ; for ( ClusterState state : states ) { queue . addPending ( state ) ; } return queue ; } List < ClusterState > randomStates ( int count , String . . . masters ) { ArrayList < ClusterState > states = new ArrayList < > ( count ) ; ClusterState [ ] lastClusterStatePerMaster = new ClusterState [ masters . length ] ; for ( ; count > <int> ; count - - ) { int masterIndex = randomInt ( masters . length - <int> ) ; ClusterState state = lastClusterStatePerMaster [ masterIndex ] ; if ( state = = null ) { state = ClusterState . builder ( ClusterName . DEFAULT ) . nodes ( DiscoveryNodes . builder ( ) . put ( new DiscoveryNode ( masters [ masterIndex ] , DummyTransportAddress . INSTANCE , Version . CURRENT ) ) . masterNodeId ( masters [ masterIndex ] ) . build ( ) ) . build ( ) ; } else { state = ClusterState . builder ( state ) . incrementVersion ( ) . build ( ) ; } states . add ( state ) ; lastClusterStatePerMaster [ masterIndex ] = state ; } return states ; } static class MockListener implements PendingClusterStatesQueue . StateProcessedListener { volatile boolean processed ; volatile Throwable failure ; @Override public void onNewClusterStateProcessed ( ) { processed = true ; } @Override public void onNewClusterStateFailed ( Throwable t ) { failure = t ; } } } 
