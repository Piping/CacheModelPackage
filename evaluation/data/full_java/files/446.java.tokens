package org . apache . cassandra . db . marshal ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import org . apache . cassandra . cql3 . CQL3Type ; import org . apache . cassandra . cql3 . Constants ; import org . apache . cassandra . cql3 . Term ; import org . apache . cassandra . serializers . TypeSerializer ; import org . apache . cassandra . serializers . IntegerSerializer ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . ByteBufferUtil ; public final class IntegerType extends AbstractType < BigInteger > { public static final IntegerType instance = new IntegerType ( ) ; private static int findMostSignificantByte ( ByteBuffer bytes ) { int len = bytes . remaining ( ) - <int> ; int i = <int> ; for ( ; i < len ; i + + ) { byte b0 = bytes . get ( bytes . position ( ) + i ) ; if ( b0 ! = <int> & & b0 ! = - <int> ) break ; byte b1 = bytes . get ( bytes . position ( ) + i + <int> ) ; if ( b0 = = <int> & & b1 ! = <int> ) { if ( b1 > <int> ) i + + ; break ; } if ( b0 = = - <int> & & b1 ! = - <int> ) { if ( b1 < <int> ) i + + ; break ; } } return i ; } IntegerType ( ) { super ( ComparisonType . CUSTOM ) ; } public boolean isEmptyValueMeaningless ( ) { return true ; } public int compareCustom ( ByteBuffer lhs , ByteBuffer rhs ) { return IntegerType . compareIntegers ( lhs , rhs ) ; } public static int compareIntegers ( ByteBuffer lhs , ByteBuffer rhs ) { int lhsLen = lhs . remaining ( ) ; int rhsLen = rhs . remaining ( ) ; if ( lhsLen = = <int> ) return rhsLen = = <int> ? <int> : - <int> ; if ( rhsLen = = <int> ) return <int> ; int lhsMsbIdx = findMostSignificantByte ( lhs ) ; int rhsMsbIdx = findMostSignificantByte ( rhs ) ; int lhsLenDiff = lhsLen - lhsMsbIdx ; int rhsLenDiff = rhsLen - rhsMsbIdx ; byte lhsMsb = lhs . get ( lhs . position ( ) + lhsMsbIdx ) ; byte rhsMsb = rhs . get ( rhs . position ( ) + rhsMsbIdx ) ; if ( lhsLenDiff ! = rhsLenDiff ) { if ( lhsMsb < <int> ) return rhsMsb < <int> ? rhsLenDiff - lhsLenDiff : - <int> ; if ( rhsMsb < <int> ) return <int> ; return lhsLenDiff - rhsLenDiff ; } if ( lhsMsb ! = rhsMsb ) return lhsMsb - rhsMsb ; lhsMsbIdx + + ; rhsMsbIdx + + ; while ( lhsMsbIdx < lhsLen ) { lhsMsb = lhs . get ( lhs . position ( ) + lhsMsbIdx + + ) ; rhsMsb = rhs . get ( rhs . position ( ) + rhsMsbIdx + + ) ; if ( lhsMsb ! = rhsMsb ) return ( lhsMsb & <hex> ) - ( rhsMsb & <hex> ) ; } return <int> ; } public ByteBuffer fromString ( String source ) throws MarshalException { if ( source . isEmpty ( ) ) return ByteBufferUtil . EMPTY_BYTE_BUFFER ; BigInteger integerType ; try { integerType = new BigInteger ( source ) ; } catch ( Exception e ) { throw new MarshalException ( String . format ( <str> , source ) , e ) ; } return decompose ( integerType ) ; } @Override public Term fromJSONObject ( Object parsed ) throws MarshalException { try { return new Constants . Value ( getSerializer ( ) . serialize ( new BigInteger ( parsed . toString ( ) ) ) ) ; } catch ( NumberFormatException exc ) { throw new MarshalException ( String . format ( <str> , parsed ) ) ; } } @Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { return getSerializer ( ) . deserialize ( buffer ) . toString ( ) ; } @Override public boolean isValueCompatibleWithInternal ( AbstractType < ? > otherType ) { return this = = otherType | | Int32Type . instance . isValueCompatibleWith ( otherType ) | | LongType . instance . isValueCompatibleWith ( otherType ) ; } public CQL3Type asCQL3Type ( ) { return CQL3Type . Native . VARINT ; } public TypeSerializer < BigInteger > getSerializer ( ) { return IntegerSerializer . instance ; } } 
