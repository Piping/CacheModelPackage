package org . elasticsearch . index . engine ; import org . apache . lucene . search . ReferenceManager ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . RamUsageEstimator ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import java . io . IOException ; import java . util . Collection ; import java . util . Collections ; import java . util . Map ; import java . util . concurrent . atomic . AtomicLong ; class LiveVersionMap implements ReferenceManager . RefreshListener , Accountable { private static class Maps { final Map < BytesRef , VersionValue > current ; final Map < BytesRef , VersionValue > old ; public Maps ( Map < BytesRef , VersionValue > current , Map < BytesRef , VersionValue > old ) { this . current = current ; this . old = old ; } public Maps ( ) { this ( ConcurrentCollections . < BytesRef , VersionValue > newConcurrentMapWithAggressiveConcurrency ( ) , ConcurrentCollections . < BytesRef , VersionValue > newConcurrentMapWithAggressiveConcurrency ( ) ) ; } } private final Map < BytesRef , VersionValue > tombstones = ConcurrentCollections . newConcurrentMapWithAggressiveConcurrency ( ) ; private volatile Maps maps = new Maps ( ) ; private ReferenceManager mgr ; private static final int BASE_BYTES_PER_BYTESREF = RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + <int> * RamUsageEstimator . NUM_BYTES_INT + RamUsageEstimator . NUM_BYTES_OBJECT_REF + RamUsageEstimator . NUM_BYTES_ARRAY_HEADER ; private static final int BASE_BYTES_PER_CHM_ENTRY = RamUsageEstimator . NUM_BYTES_OBJECT_HEADER + RamUsageEstimator . NUM_BYTES_INT + <int> * RamUsageEstimator . NUM_BYTES_OBJECT_REF ; final AtomicLong ramBytesUsedCurrent = new AtomicLong ( ) ; final AtomicLong ramBytesUsedTombstones = new AtomicLong ( ) ; synchronized void setManager ( ReferenceManager newMgr ) { if ( mgr ! = null ) { mgr . removeListener ( this ) ; } mgr = newMgr ; maps = new Maps ( ) ; mgr . addListener ( this ) ; } @Override public void beforeRefresh ( ) throws IOException { maps = new Maps ( ConcurrentCollections . < BytesRef , VersionValue > newConcurrentMapWithAggressiveConcurrency ( ) , maps . current ) ; ramBytesUsedCurrent . set ( <int> ) ; } @Override public void afterRefresh ( boolean didRefresh ) throws IOException { maps = new Maps ( maps . current , ConcurrentCollections . < BytesRef , VersionValue > newConcurrentMapWithAggressiveConcurrency ( ) ) ; } VersionValue getUnderLock ( BytesRef uid ) { Maps currentMaps = maps ; VersionValue value = currentMaps . current . get ( uid ) ; if ( value ! = null ) { return value ; } value = currentMaps . old . get ( uid ) ; if ( value ! = null ) { return value ; } return tombstones . get ( uid ) ; } void putUnderLock ( BytesRef uid , VersionValue version ) { long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid . bytes . length ; final VersionValue prev = maps . current . put ( uid , version ) ; if ( prev ! = null ) { long prevBytes = BASE_BYTES_PER_CHM_ENTRY ; if ( prev . delete ( ) = = false ) { prevBytes + = prev . ramBytesUsed ( ) + uidRAMBytesUsed ; } ramBytesUsedCurrent . addAndGet ( - prevBytes ) ; } long newBytes = BASE_BYTES_PER_CHM_ENTRY ; if ( version . delete ( ) = = false ) { newBytes + = version . ramBytesUsed ( ) + uidRAMBytesUsed ; } ramBytesUsedCurrent . addAndGet ( newBytes ) ; final VersionValue prevTombstone ; if ( version . delete ( ) ) { prevTombstone = tombstones . put ( uid , version ) ; ramBytesUsedTombstones . addAndGet ( BASE_BYTES_PER_CHM_ENTRY + version . ramBytesUsed ( ) + uidRAMBytesUsed ) ; if ( prevTombstone = = null & & prev ! = null & & prev . delete ( ) ) { ramBytesUsedCurrent . addAndGet ( - ( prev . ramBytesUsed ( ) + uidRAMBytesUsed ) ) ; } } else { prevTombstone = tombstones . remove ( uid ) ; } if ( prevTombstone ! = null ) { long v = ramBytesUsedTombstones . addAndGet ( - ( BASE_BYTES_PER_CHM_ENTRY + prevTombstone . ramBytesUsed ( ) + uidRAMBytesUsed ) ) ; assert v > = <int> : <str> + v ; } } void removeTombstoneUnderLock ( BytesRef uid ) { long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid . bytes . length ; final VersionValue prev = tombstones . remove ( uid ) ; if ( prev ! = null ) { assert prev . delete ( ) ; long v = ramBytesUsedTombstones . addAndGet ( - ( BASE_BYTES_PER_CHM_ENTRY + prev . ramBytesUsed ( ) + uidRAMBytesUsed ) ) ; assert v > = <int> : <str> + v ; } final VersionValue curVersion = maps . current . get ( uid ) ; if ( curVersion ! = null & & curVersion . delete ( ) ) { ramBytesUsedCurrent . addAndGet ( curVersion . ramBytesUsed ( ) + uidRAMBytesUsed ) ; } } VersionValue getTombstoneUnderLock ( BytesRef uid ) { return tombstones . get ( uid ) ; } Iterable < Map . Entry < BytesRef , VersionValue > > getAllTombstones ( ) { return tombstones . entrySet ( ) ; } synchronized void clear ( ) { maps = new Maps ( ) ; tombstones . clear ( ) ; ramBytesUsedCurrent . set ( <int> ) ; if ( mgr ! = null ) { mgr . removeListener ( this ) ; mgr = null ; } } @Override public long ramBytesUsed ( ) { return ramBytesUsedCurrent . get ( ) + ramBytesUsedTombstones . get ( ) ; } long ramBytesUsedForRefresh ( ) { return ramBytesUsedCurrent . get ( ) ; } @Override public Collection < Accountable > getChildResources ( ) { return Collections . emptyList ( ) ; } } 
