package org . elasticsearch . index ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . admin . cluster . snapshots . create . CreateSnapshotResponse ; import org . elasticsearch . action . admin . cluster . snapshots . restore . RestoreSnapshotResponse ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsResponse ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShadowIndexShard ; import org . elasticsearch . index . translog . TranslogStats ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . indices . recovery . RecoveryTarget ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . snapshots . SnapshotState ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . InternalTestCluster ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . nio . file . Path ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertOrderedSearchHits ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> ) public class IndexWithShadowReplicasIT extends ESIntegTestCase { private Settings nodeSettings ( Path dataPath ) { return nodeSettings ( dataPath . toString ( ) ) ; } private Settings nodeSettings ( String dataPath ) { return Settings . builder ( ) . put ( <str> , false ) . put ( <str> , dataPath ) . put ( <str> , randomFrom ( <str> , <str> ) ) . build ( ) ; } @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockTransportService . TestPlugin . class ) ; } public void testCannotCreateWithBadPath ( ) throws Exception { Settings nodeSettings = nodeSettings ( <str> ) ; internalCluster ( ) . startNodesAsync ( <int> , nodeSettings ) . get ( ) ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , <str> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . build ( ) ; try { assertAcked ( prepareCreate ( <str> ) . setSettings ( idxSettings ) ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertTrue ( e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) ) ; } } public void testRestoreToShadow ( ) throws ExecutionException , InterruptedException { final Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; internalCluster ( ) . startNodesAsync ( <int> , nodeSettings ) . get ( ) ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . build ( ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( idxSettings ) ) ; ensureGreen ( ) ; final int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( <str> , <str> ) . get ( ) ; } assertNoFailures ( client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . setForce ( true ) . setWaitIfOngoing ( true ) . execute ( ) . actionGet ( ) ) ; assertAcked ( client ( ) . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , randomRepoPath ( ) ) ) ) ; CreateSnapshotResponse createSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> ) . get ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; Settings shadowSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . build ( ) ; logger . info ( <str> ) ; RestoreSnapshotResponse restoreSnapshotResponse = client ( ) . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setIndexSettings ( shadowSettings ) . setWaitForCompletion ( true ) . setRenamePattern ( <str> ) . setRenameReplacement ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; ensureGreen ( ) ; refresh ( ) ; for ( IndicesService service : internalCluster ( ) . getDataNodeInstances ( IndicesService . class ) ) { if ( service . hasIndex ( <str> ) ) { IndexShard shard = service . indexServiceSafe ( <str> ) . getShardOrNull ( <int> ) ; if ( shard . routingEntry ( ) . primary ( ) ) { assertFalse ( shard instanceof ShadowIndexShard ) ; } else { assertTrue ( shard instanceof ShadowIndexShard ) ; } } } logger . info ( <str> ) ; SearchResponse resp = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( resp , numDocs ) ; } public void testIndexWithFewDocuments ( ) throws Exception { final Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; internalCluster ( ) . startNodesAsync ( <int> , nodeSettings ) . get ( ) ; final String IDX = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexShard . INDEX_TRANSLOG_DISABLE_FLUSH , true ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureGreen ( IDX ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; IndicesStatsResponse indicesStatsResponse = client ( ) . admin ( ) . indices ( ) . prepareStats ( IDX ) . clear ( ) . setTranslog ( true ) . get ( ) ; assertEquals ( <int> , indicesStatsResponse . getIndex ( IDX ) . getPrimaries ( ) . getTranslog ( ) . estimatedNumberOfOperations ( ) ) ; assertEquals ( <int> , indicesStatsResponse . getIndex ( IDX ) . getTotal ( ) . getTranslog ( ) . estimatedNumberOfOperations ( ) ) ; for ( IndicesService service : internalCluster ( ) . getInstances ( IndicesService . class ) ) { IndexService indexService = service . indexService ( IDX ) ; if ( indexService ! = null ) { IndexShard shard = indexService . getShard ( <int> ) ; TranslogStats translogStats = shard . translogStats ( ) ; assertTrue ( translogStats ! = null | | shard instanceof ShadowIndexShard ) ; if ( translogStats ! = null ) { assertEquals ( <int> , translogStats . estimatedNumberOfOperations ( ) ) ; } } } GetResponse gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setRealtime ( true ) . setFields ( <str> ) . get ( ) ; GetResponse gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setRealtime ( true ) . setFields ( <str> ) . get ( ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; flushAndRefresh ( IDX ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; refresh ( ) ; gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setRealtime ( false ) . setFields ( <str> ) . get ( ) ; gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setRealtime ( false ) . setFields ( <str> ) . get ( ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; logger . info ( <str> ) ; if ( randomBoolean ( ) ) { logger . info ( <str> ) ; internalCluster ( ) . rollingRestart ( ) ; } else { logger . info ( <str> ) ; internalCluster ( ) . fullRestart ( ) ; } client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) ; ensureGreen ( IDX ) ; flushAndRefresh ( IDX ) ; logger . info ( <str> ) ; SearchResponse resp = client ( ) . prepareSearch ( IDX ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( resp , <int> ) ; logger . info ( <str> ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( IDX ) ) ; } public void testReplicaToPrimaryPromotion ( ) throws Exception { Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; String node1 = internalCluster ( ) . startNode ( nodeSettings ) ; String IDX = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureYellow ( IDX ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; GetResponse gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; GetResponse gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; assertTrue ( gResp1 . isExists ( ) ) ; assertTrue ( gResp2 . isExists ( ) ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; String node2 = internalCluster ( ) . startNode ( nodeSettings ) ; ensureGreen ( IDX ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) ; flushAndRefresh ( IDX ) ; logger . info ( <str> , node1 ) ; internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( node1 ) ) ; ensureYellow ( IDX ) ; logger . info ( <str> ) ; SearchResponse resp = client ( ) . prepareSearch ( IDX ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( resp , <int> ) ; gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; assertTrue ( gResp1 . isExists ( ) ) ; assertTrue ( gResp2 . toString ( ) , gResp2 . isExists ( ) ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; assertTrue ( gResp1 . isExists ( ) ) ; assertTrue ( gResp2 . toString ( ) , gResp2 . isExists ( ) ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; } public void testPrimaryRelocation ( ) throws Exception { Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; String node1 = internalCluster ( ) . startNode ( nodeSettings ) ; String IDX = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureYellow ( IDX ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; GetResponse gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; GetResponse gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; assertTrue ( gResp1 . isExists ( ) ) ; assertTrue ( gResp2 . isExists ( ) ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; String node2 = internalCluster ( ) . startNode ( nodeSettings ) ; ensureGreen ( IDX ) ; client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) ; flushAndRefresh ( IDX ) ; String node3 = internalCluster ( ) . startNode ( nodeSettings ) ; Settings build = Settings . builder ( ) . put ( <str> , node1 ) . build ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( IDX ) . setSettings ( build ) . execute ( ) . actionGet ( ) ; ensureGreen ( IDX ) ; logger . info ( <str> ) ; SearchResponse resp = client ( ) . prepareSearch ( IDX ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( resp , <int> ) ; gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; assertTrue ( gResp1 . isExists ( ) ) ; assertTrue ( gResp2 . toString ( ) , gResp2 . isExists ( ) ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setPreference ( <str> ) . setFields ( <str> ) . get ( ) ; gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setPreference ( <str> ) . setFields ( <str> ) . get ( ) ; assertTrue ( gResp1 . isExists ( ) ) ; assertTrue ( gResp2 . isExists ( ) ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; } public void testPrimaryRelocationWithConcurrentIndexing ( ) throws Throwable { Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; String node1 = internalCluster ( ) . startNode ( nodeSettings ) ; final String IDX = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureYellow ( IDX ) ; String node2 = internalCluster ( ) . startNode ( nodeSettings ) ; ensureGreen ( IDX ) ; flushAndRefresh ( IDX ) ; String node3 = internalCluster ( ) . startNode ( nodeSettings ) ; final AtomicInteger counter = new AtomicInteger ( <int> ) ; final CountDownLatch started = new CountDownLatch ( <int> ) ; final int numPhase1Docs = scaledRandomIntBetween ( <int> , <int> ) ; final int numPhase2Docs = scaledRandomIntBetween ( <int> , <int> ) ; final CountDownLatch phase1finished = new CountDownLatch ( <int> ) ; final CountDownLatch phase2finished = new CountDownLatch ( <int> ) ; final CopyOnWriteArrayList < Throwable > exceptions = new CopyOnWriteArrayList < > ( ) ; Thread thread = new Thread ( ) { @Override public void run ( ) { started . countDown ( ) ; while ( counter . get ( ) < ( numPhase1Docs + numPhase2Docs ) ) { try { final IndexResponse indexResponse = client ( ) . prepareIndex ( IDX , <str> , Integer . toString ( counter . incrementAndGet ( ) ) ) . setSource ( <str> , <str> ) . get ( ) ; assertTrue ( indexResponse . isCreated ( ) ) ; } catch ( Throwable t ) { exceptions . add ( t ) ; } final int docCount = counter . get ( ) ; if ( docCount = = numPhase1Docs ) { phase1finished . countDown ( ) ; } } logger . info ( <str> ) ; phase2finished . countDown ( ) ; } } ; thread . start ( ) ; started . await ( ) ; phase1finished . await ( ) ; logger . info ( <str> , node1 ) ; Settings build = Settings . builder ( ) . put ( <str> , node1 ) . build ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( IDX ) . setSettings ( build ) . execute ( ) . actionGet ( ) ; phase2finished . await ( ) ; ExceptionsHelper . rethrowAndSuppress ( exceptions ) ; ensureGreen ( IDX ) ; thread . join ( ) ; logger . info ( <str> ) ; flushAndRefresh ( ) ; SearchResponse resp = client ( ) . prepareSearch ( IDX ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( resp , counter . get ( ) ) ; assertHitCount ( resp , numPhase1Docs + numPhase2Docs ) ; } public void testPrimaryRelocationWhereRecoveryFails ( ) throws Exception { Path dataPath = createTempDir ( ) ; Settings nodeSettings = Settings . builder ( ) . put ( <str> , false ) . put ( <str> , dataPath ) . build ( ) ; String node1 = internalCluster ( ) . startNode ( nodeSettings ) ; final String IDX = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureYellow ( IDX ) ; String node2 = internalCluster ( ) . startNode ( nodeSettings ) ; ensureGreen ( IDX ) ; flushAndRefresh ( IDX ) ; String node3 = internalCluster ( ) . startNode ( nodeSettings ) ; final AtomicInteger counter = new AtomicInteger ( <int> ) ; final CountDownLatch started = new CountDownLatch ( <int> ) ; final int numPhase1Docs = scaledRandomIntBetween ( <int> , <int> ) ; final int numPhase2Docs = scaledRandomIntBetween ( <int> , <int> ) ; final int numPhase3Docs = scaledRandomIntBetween ( <int> , <int> ) ; final CountDownLatch phase1finished = new CountDownLatch ( <int> ) ; final CountDownLatch phase2finished = new CountDownLatch ( <int> ) ; final CountDownLatch phase3finished = new CountDownLatch ( <int> ) ; final AtomicBoolean keepFailing = new AtomicBoolean ( true ) ; MockTransportService mockTransportService = ( ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , node1 ) ) ; mockTransportService . addDelegate ( internalCluster ( ) . getInstance ( TransportService . class , node3 ) , new MockTransportService . DelegateTransport ( mockTransportService . original ( ) ) { @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { if ( keepFailing . get ( ) & & action . equals ( RecoveryTarget . Actions . TRANSLOG_OPS ) ) { logger . info ( <str> ) ; throw new ElasticsearchException ( <str> ) ; } super . sendRequest ( node , requestId , action , request , options ) ; } } ) ; Thread thread = new Thread ( ) { @Override public void run ( ) { started . countDown ( ) ; while ( counter . get ( ) < ( numPhase1Docs + numPhase2Docs + numPhase3Docs ) ) { final IndexResponse indexResponse = client ( ) . prepareIndex ( IDX , <str> , Integer . toString ( counter . incrementAndGet ( ) ) ) . setSource ( <str> , <str> ) . get ( ) ; assertTrue ( indexResponse . isCreated ( ) ) ; final int docCount = counter . get ( ) ; if ( docCount = = numPhase1Docs ) { phase1finished . countDown ( ) ; } else if ( docCount = = ( numPhase1Docs + numPhase2Docs ) ) { phase2finished . countDown ( ) ; } } logger . info ( <str> ) ; phase3finished . countDown ( ) ; } } ; thread . start ( ) ; started . await ( ) ; phase1finished . await ( ) ; logger . info ( <str> , node1 ) ; Settings build = Settings . builder ( ) . put ( <str> , node1 ) . build ( ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( IDX ) . setSettings ( build ) . execute ( ) . actionGet ( ) ; phase2finished . await ( ) ; keepFailing . set ( false ) ; phase3finished . await ( ) ; ensureGreen ( IDX ) ; thread . join ( ) ; logger . info ( <str> ) ; flushAndRefresh ( ) ; SearchResponse resp = client ( ) . prepareSearch ( IDX ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( resp , counter . get ( ) ) ; } public void testIndexWithShadowReplicasCleansUp ( ) throws Exception { Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; int nodeCount = randomIntBetween ( <int> , <int> ) ; internalCluster ( ) . startNodesAsync ( nodeCount , nodeSettings ) . get ( ) ; String IDX = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , randomIntBetween ( <int> , nodeCount - <int> ) ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureGreen ( IDX ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; flushAndRefresh ( IDX ) ; GetResponse gResp1 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; GetResponse gResp2 = client ( ) . prepareGet ( IDX , <str> , <str> ) . setFields ( <str> ) . get ( ) ; assertThat ( gResp1 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( gResp2 . getField ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; logger . info ( <str> ) ; SearchResponse resp = client ( ) . prepareSearch ( IDX ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( resp , <int> ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( IDX ) ) ; assertPathHasBeenCleared ( dataPath ) ; } public void testShadowReplicaNaturalRelocation ( ) throws Exception { Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; internalCluster ( ) . startNodesAsync ( <int> , nodeSettings ) . get ( ) ; String IDX = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureGreen ( IDX ) ; int docCount = randomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < docCount ; i + + ) { builders . add ( client ( ) . prepareIndex ( IDX , <str> , i + <str> ) . setSource ( <str> , <str> ) ) ; } indexRandom ( true , true , true , builders ) ; flushAndRefresh ( IDX ) ; final String node3 = internalCluster ( ) . startNode ( nodeSettings ) ; assertBusy ( new Runnable ( ) { @Override public void run ( ) { client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForNodes ( <str> ) . get ( ) ; ClusterStateResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; RoutingNodes nodes = resp . getState ( ) . getRoutingNodes ( ) ; for ( RoutingNode node : nodes ) { logger . info ( <str> , node . numberOfOwningShards ( ) ) ; assertThat ( <str> , node . numberOfOwningShards ( ) , greaterThanOrEqualTo ( <int> ) ) ; } } } ) ; ensureYellow ( IDX ) ; logger . info ( <str> ) ; SearchResponse resp = client ( ) . prepareSearch ( IDX ) . setQuery ( matchAllQuery ( ) ) . get ( ) ; assertHitCount ( resp , docCount ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( IDX ) ) ; assertPathHasBeenCleared ( dataPath ) ; } public void testShadowReplicasUsingFieldData ( ) throws Exception { Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; internalCluster ( ) . startNodesAsync ( <int> , nodeSettings ) . get ( ) ; String IDX = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureGreen ( IDX ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; flushAndRefresh ( IDX ) ; SearchResponse resp = client ( ) . prepareSearch ( IDX ) . setQuery ( matchAllQuery ( ) ) . addFieldDataField ( <str> ) . addSort ( <str> , SortOrder . ASC ) . get ( ) ; assertHitCount ( resp , <int> ) ; assertOrderedSearchHits ( resp , <str> , <str> , <str> , <str> ) ; SearchHit [ ] hits = resp . getHits ( ) . hits ( ) ; assertThat ( hits [ <int> ] . field ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( hits [ <int> ] . field ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( hits [ <int> ] . field ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( hits [ <int> ] . field ( <str> ) . getValue ( ) . toString ( ) , equalTo ( <str> ) ) ; } private void assertNoShardsOn ( final List < String > nodeList ) throws Exception { assertBusy ( new Runnable ( ) { @Override public void run ( ) { ClusterStateResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; RoutingNodes nodes = resp . getState ( ) . getRoutingNodes ( ) ; for ( RoutingNode node : nodes ) { logger . info ( <str> , node . node ( ) . getName ( ) , node . numberOfOwningShards ( ) ) ; if ( nodeList . contains ( node . node ( ) . getName ( ) ) ) { assertThat ( <str> , node . numberOfOwningShards ( ) , equalTo ( <int> ) ) ; } } } } ) ; } private void assertShardCountOn ( final String nodeName , final int shardCount ) throws Exception { assertBusy ( new Runnable ( ) { @Override public void run ( ) { ClusterStateResponse resp = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; RoutingNodes nodes = resp . getState ( ) . getRoutingNodes ( ) ; for ( RoutingNode node : nodes ) { logger . info ( <str> , node . node ( ) . getName ( ) , node . numberOfOwningShards ( ) ) ; if ( nodeName . equals ( node . node ( ) . getName ( ) ) ) { assertThat ( node . numberOfOwningShards ( ) , equalTo ( shardCount ) ) ; } } } } ) ; } public void testIndexOnSharedFSRecoversToAnyNode ( ) throws Exception { Path dataPath = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath ) ; Settings fooSettings = Settings . builder ( ) . put ( nodeSettings ) . put ( <str> , <str> ) . build ( ) ; Settings barSettings = Settings . builder ( ) . put ( nodeSettings ) . put ( <str> , <str> ) . build ( ) ; final InternalTestCluster . Async < List < String > > fooNodes = internalCluster ( ) . startNodesAsync ( <int> , fooSettings ) ; final InternalTestCluster . Async < List < String > > barNodes = internalCluster ( ) . startNodesAsync ( <int> , barSettings ) ; fooNodes . get ( ) ; barNodes . get ( ) ; String IDX = <str> ; Settings includeFoo = Settings . builder ( ) . put ( <str> , <str> ) . build ( ) ; Settings includeBar = Settings . builder ( ) . put ( <str> , <str> ) . build ( ) ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . put ( IndexMetaData . SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE , true ) . put ( includeFoo ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureGreen ( IDX ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; client ( ) . prepareIndex ( IDX , <str> , <str> ) . setSource ( <str> , <str> ) . get ( ) ; flushAndRefresh ( IDX ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( IDX ) . setSettings ( includeBar ) . get ( ) ; assertNoShardsOn ( fooNodes . get ( ) ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( IDX ) . setSettings ( includeFoo ) . get ( ) ; assertNoShardsOn ( barNodes . get ( ) ) ; logger . info ( <str> ) ; internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( fooNodes . get ( ) . get ( <int> ) ) ) ; assertShardCountOn ( fooNodes . get ( ) . get ( <int> ) , <int> ) ; assertNoShardsOn ( barNodes . get ( ) ) ; logger . info ( <str> ) ; internalCluster ( ) . stopRandomNode ( InternalTestCluster . nameFilter ( fooNodes . get ( ) . get ( <int> ) ) ) ; ensureGreen ( IDX ) ; logger . info ( <str> ) ; String newFooNode = internalCluster ( ) . startNode ( fooSettings ) ; assertShardCountOn ( newFooNode , <int> ) ; assertNoShardsOn ( barNodes . get ( ) ) ; } public void testDeletingClosedIndexRemovesFiles ( ) throws Exception { Path dataPath = createTempDir ( ) ; Path dataPath2 = createTempDir ( ) ; Settings nodeSettings = nodeSettings ( dataPath . getParent ( ) ) ; internalCluster ( ) . startNodesAsync ( <int> , nodeSettings ) . get ( ) ; String IDX = <str> ; String IDX2 = <str> ; Settings idxSettings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; Settings idx2Settings = Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , <int> ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , <int> ) . put ( IndexMetaData . SETTING_DATA_PATH , dataPath2 . toAbsolutePath ( ) . toString ( ) ) . put ( IndexMetaData . SETTING_SHADOW_REPLICAS , true ) . put ( IndexMetaData . SETTING_SHARED_FILESYSTEM , true ) . build ( ) ; prepareCreate ( IDX ) . setSettings ( idxSettings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; prepareCreate ( IDX2 ) . setSettings ( idx2Settings ) . addMapping ( <str> , <str> , <str> ) . get ( ) ; ensureGreen ( IDX , IDX2 ) ; int docCount = randomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < docCount ; i + + ) { builders . add ( client ( ) . prepareIndex ( IDX , <str> , i + <str> ) . setSource ( <str> , <str> ) ) ; builders . add ( client ( ) . prepareIndex ( IDX2 , <str> , i + <str> ) . setSource ( <str> , <str> ) ) ; } indexRandom ( true , true , true , builders ) ; flushAndRefresh ( IDX , IDX2 ) ; logger . info ( <str> , IDX ) ; client ( ) . admin ( ) . indices ( ) . prepareClose ( IDX ) . get ( ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareDelete ( IDX2 ) . get ( ) ; assertPathHasBeenCleared ( dataPath2 ) ; logger . info ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareDelete ( IDX ) . get ( ) ; assertPathHasBeenCleared ( dataPath ) ; } } 
