package org . apache . cassandra . service ; import java . net . InetAddress ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import org . apache . cassandra . exceptions . WriteFailureException ; import org . apache . cassandra . exceptions . WriteTimeoutException ; import org . apache . cassandra . net . MessageIn ; public class BatchlogResponseHandler < T > extends AbstractWriteResponseHandler < T > { AbstractWriteResponseHandler < T > wrapped ; BatchlogCleanup cleanup ; protected volatile int requiredBeforeFinish ; private static final AtomicIntegerFieldUpdater < BatchlogResponseHandler > requiredBeforeFinishUpdater = AtomicIntegerFieldUpdater . newUpdater ( BatchlogResponseHandler . class , <str> ) ; public BatchlogResponseHandler ( AbstractWriteResponseHandler < T > wrapped , int requiredBeforeFinish , BatchlogCleanup cleanup ) { super ( wrapped . keyspace , wrapped . naturalEndpoints , wrapped . pendingEndpoints , wrapped . consistencyLevel , wrapped . callback , wrapped . writeType ) ; this . wrapped = wrapped ; this . requiredBeforeFinish = requiredBeforeFinish ; this . cleanup = cleanup ; } protected int ackCount ( ) { return wrapped . ackCount ( ) ; } public void response ( MessageIn < T > msg ) { wrapped . response ( msg ) ; if ( requiredBeforeFinishUpdater . decrementAndGet ( this ) = = <int> ) cleanup . run ( ) ; } public boolean isLatencyForSnitch ( ) { return wrapped . isLatencyForSnitch ( ) ; } public void onFailure ( InetAddress from ) { wrapped . onFailure ( from ) ; } public void assureSufficientLiveNodes ( ) { wrapped . assureSufficientLiveNodes ( ) ; } public void get ( ) throws WriteTimeoutException , WriteFailureException { wrapped . get ( ) ; } protected int totalBlockFor ( ) { return wrapped . totalBlockFor ( ) ; } protected int totalEndpoints ( ) { return wrapped . totalEndpoints ( ) ; } protected boolean waitingFor ( InetAddress from ) { return wrapped . waitingFor ( from ) ; } protected void signal ( ) { wrapped . signal ( ) ; } public static class BatchlogCleanup { private final BatchlogCleanupCallback callback ; protected volatile int mutationsWaitingFor ; private static final AtomicIntegerFieldUpdater < BatchlogCleanup > mutationsWaitingForUpdater = AtomicIntegerFieldUpdater . newUpdater ( BatchlogCleanup . class , <str> ) ; public BatchlogCleanup ( int mutationsWaitingFor , BatchlogCleanupCallback callback ) { this . mutationsWaitingFor = mutationsWaitingFor ; this . callback = callback ; } public void run ( ) { if ( mutationsWaitingForUpdater . decrementAndGet ( this ) = = <int> ) callback . invoke ( ) ; } } public interface BatchlogCleanupCallback { void invoke ( ) ; } } 
