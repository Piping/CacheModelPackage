package org . apache . cassandra . dht ; import java . util . Collections ; import java . util . List ; import org . apache . cassandra . utils . Pair ; public class IncludingExcludingBounds < T extends RingPosition < T > > extends AbstractBounds < T > { public IncludingExcludingBounds ( T left , T right ) { super ( left , right ) ; assert ! strictlyWrapsAround ( left , right ) & & ( right . isMinimum ( ) | | left . compareTo ( right ) ! = <int> ) : <str> + left + <str> + right + <str> ; } public boolean contains ( T position ) { return ( Range . contains ( left , right , position ) | | left . equals ( position ) ) & & ! right . equals ( position ) ; } public Pair < AbstractBounds < T > , AbstractBounds < T > > split ( T position ) { assert contains ( position ) ; AbstractBounds < T > lb = new Bounds < T > ( left , position ) ; AbstractBounds < T > rb = new ExcludingBounds < T > ( position , right ) ; return Pair . create ( lb , rb ) ; } public boolean inclusiveLeft ( ) { return true ; } public boolean inclusiveRight ( ) { return false ; } public List < ? extends AbstractBounds < T > > unwrap ( ) { return Collections . < AbstractBounds < T > > singletonList ( this ) ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof IncludingExcludingBounds ) ) return false ; IncludingExcludingBounds < ? > rhs = ( IncludingExcludingBounds < ? > ) o ; return left . equals ( rhs . left ) & & right . equals ( rhs . right ) ; } @Override public String toString ( ) { return <str> + left + <str> + right + <str> ; } protected String getOpeningString ( ) { return <str> ; } protected String getClosingString ( ) { return <str> ; } public boolean isStartInclusive ( ) { return true ; } public boolean isEndInclusive ( ) { return false ; } public AbstractBounds < T > withNewRight ( T newRight ) { return new IncludingExcludingBounds < T > ( left , newRight ) ; } } 
