package com . google . common . util . concurrent ; import junit . framework . TestCase ; import java . util . concurrent . Callable ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . TimeUnit ; public class SimpleTimeLimiterTest extends TestCase { private static final int DELAY_MS = <int> ; private static final int ENOUGH_MS = <int> ; private static final int NOT_ENOUGH_MS = <int> ; private TimeLimiter service ; private static final ExecutorService executor = Executors . newFixedThreadPool ( <int> ) ; private static String someGoodStaticMethod ( ) throws InterruptedException { TimeUnit . MILLISECONDS . sleep ( DELAY_MS ) ; return <str> ; } private static String someBadStaticMethod ( ) throws InterruptedException , SampleException { TimeUnit . MILLISECONDS . sleep ( DELAY_MS ) ; throw new SampleException ( ) ; } @Override protected void setUp ( ) throws Exception { super . setUp ( ) ; service = new SimpleTimeLimiter ( executor ) ; } public void testGoodCallableWithEnoughTime ( ) throws Exception { long start = System . nanoTime ( ) ; String result = service . callWithTimeout ( new Callable < String > ( ) { @Override public String call ( ) throws InterruptedException { return someGoodStaticMethod ( ) ; } } , ENOUGH_MS , TimeUnit . MILLISECONDS , true ) ; assertEquals ( <str> , result ) ; assertTheCallTookBetween ( start , DELAY_MS , ENOUGH_MS ) ; } public void testGoodCallableWithNotEnoughTime ( ) throws Exception { long start = System . nanoTime ( ) ; try { service . callWithTimeout ( new Callable < String > ( ) { @Override public String call ( ) throws InterruptedException { return someGoodStaticMethod ( ) ; } } , NOT_ENOUGH_MS , TimeUnit . MILLISECONDS , true ) ; fail ( <str> ) ; } catch ( UncheckedTimeoutException expected ) { } assertTheCallTookBetween ( start , NOT_ENOUGH_MS , DELAY_MS ) ; } public void testBadCallableWithEnoughTime ( ) throws Exception { long start = System . nanoTime ( ) ; try { service . callWithTimeout ( new Callable < String > ( ) { @Override public String call ( ) throws SampleException , InterruptedException { return someBadStaticMethod ( ) ; } } , ENOUGH_MS , TimeUnit . MILLISECONDS , true ) ; fail ( <str> ) ; } catch ( SampleException expected ) { } assertTheCallTookBetween ( start , DELAY_MS , ENOUGH_MS ) ; } public void testBadCallableWithNotEnoughTime ( ) throws Exception { long start = System . nanoTime ( ) ; try { service . callWithTimeout ( new Callable < String > ( ) { @Override public String call ( ) throws SampleException , InterruptedException { return someBadStaticMethod ( ) ; } } , NOT_ENOUGH_MS , TimeUnit . MILLISECONDS , true ) ; fail ( <str> ) ; } catch ( UncheckedTimeoutException expected ) { } assertTheCallTookBetween ( start , NOT_ENOUGH_MS , DELAY_MS ) ; } public void testGoodMethodWithEnoughTime ( ) throws Exception { SampleImpl target = new SampleImpl ( ) ; Sample proxy = service . newProxy ( target , Sample . class , ENOUGH_MS , TimeUnit . MILLISECONDS ) ; long start = System . nanoTime ( ) ; assertEquals ( <str> , proxy . sleepThenReturnInput ( <str> ) ) ; assertTheCallTookBetween ( start , DELAY_MS , ENOUGH_MS ) ; assertTrue ( target . finished ) ; } public void testGoodMethodWithNotEnoughTime ( ) throws Exception { SampleImpl target = new SampleImpl ( ) ; Sample proxy = service . newProxy ( target , Sample . class , NOT_ENOUGH_MS , TimeUnit . MILLISECONDS ) ; long start = System . nanoTime ( ) ; try { proxy . sleepThenReturnInput ( <str> ) ; fail ( <str> ) ; } catch ( UncheckedTimeoutException expected ) { } assertTheCallTookBetween ( start , NOT_ENOUGH_MS , DELAY_MS ) ; assertFalse ( target . finished ) ; TimeUnit . MILLISECONDS . sleep ( ENOUGH_MS ) ; assertFalse ( target . finished ) ; } public void testBadMethodWithEnoughTime ( ) throws Exception { SampleImpl target = new SampleImpl ( ) ; Sample proxy = service . newProxy ( target , Sample . class , ENOUGH_MS , TimeUnit . MILLISECONDS ) ; long start = System . nanoTime ( ) ; try { proxy . sleepThenThrowException ( ) ; fail ( <str> ) ; } catch ( SampleException expected ) { } assertTheCallTookBetween ( start , DELAY_MS , ENOUGH_MS ) ; } public void testBadMethodWithNotEnoughTime ( ) throws Exception { SampleImpl target = new SampleImpl ( ) ; Sample proxy = service . newProxy ( target , Sample . class , NOT_ENOUGH_MS , TimeUnit . MILLISECONDS ) ; long start = System . nanoTime ( ) ; try { proxy . sleepThenThrowException ( ) ; fail ( <str> ) ; } catch ( UncheckedTimeoutException expected ) { } assertTheCallTookBetween ( start , NOT_ENOUGH_MS , DELAY_MS ) ; } private static void assertTheCallTookBetween ( long startNanos , int atLeastMillis , int atMostMillis ) { long nanos = System . nanoTime ( ) - startNanos ; assertTrue ( nanos > = atLeastMillis * <int> ) ; assertTrue ( nanos < = atMostMillis * <int> ) ; } public interface Sample { String sleepThenReturnInput ( String input ) ; void sleepThenThrowException ( ) throws SampleException ; } @SuppressWarnings ( <str> ) public static class SampleException extends Exception { } public static class SampleImpl implements Sample { boolean finished ; @Override public String sleepThenReturnInput ( String input ) { try { TimeUnit . MILLISECONDS . sleep ( DELAY_MS ) ; finished = true ; return input ; } catch ( InterruptedException e ) { return null ; } } @Override public void sleepThenThrowException ( ) throws SampleException { try { TimeUnit . MILLISECONDS . sleep ( DELAY_MS ) ; } catch ( InterruptedException e ) { } throw new SampleException ( ) ; } } } 
