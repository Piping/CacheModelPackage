package org . gradle . nativeplatform . internal . resolve ; import org . gradle . api . tasks . Optional ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . typeconversion . * ; import org . gradle . nativeplatform . NativeLibraryRequirement ; import org . gradle . nativeplatform . NativeLibrarySpec ; import org . gradle . nativeplatform . internal . ProjectNativeLibraryRequirement ; class NativeDependencyNotationParser { public static NotationParser < Object , NativeLibraryRequirement > parser ( ) { return NotationParserBuilder . toType ( NativeLibraryRequirement . class ) . converter ( new LibraryConverter ( ) ) . converter ( new NativeLibraryRequirementMapNotationConverter ( ) ) . toComposite ( ) ; } private static class LibraryConverter extends TypedNotationConverter < NativeLibrarySpec , NativeLibraryRequirement > { private LibraryConverter ( ) { super ( NativeLibrarySpec . class ) ; } @Override protected NativeLibraryRequirement parseType ( NativeLibrarySpec notation ) { return notation . getShared ( ) ; } } private static class NativeLibraryRequirementMapNotationConverter extends MapNotationConverter < NativeLibraryRequirement > { @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) . example ( <str> ) ; } @SuppressWarnings ( <str> ) protected NativeLibraryRequirement parseMap ( @MapKey ( <str> ) String libraryName , @Optional @MapKey ( <str> ) String projectPath , @Optional @MapKey ( <str> ) String linkage ) { return new ProjectNativeLibraryRequirement ( projectPath , libraryName , linkage ) ; } } } 
