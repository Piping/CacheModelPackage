package org . elasticsearch . bootstrap ; import org . elasticsearch . Build ; import org . elasticsearch . Version ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . cli . CliTool . ExitStatus ; import org . elasticsearch . common . cli . CliToolTestCase ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . monitor . jvm . JvmInfo ; import org . hamcrest . Matcher ; import org . junit . After ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Locale ; import static org . elasticsearch . common . cli . CliTool . ExitStatus . * ; import static org . hamcrest . Matchers . * ; @SuppressForbidden ( reason = <str> ) public class BootstrapCliParserTests extends CliToolTestCase { private CaptureOutputTerminal terminal = new CaptureOutputTerminal ( ) ; private List < String > propertiesToClear = new ArrayList < > ( ) ; @After public void clearProperties ( ) { for ( String property : propertiesToClear ) { System . clearProperty ( property ) ; } } public void testThatVersionIsReturned ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK_AND_EXIT ) ; assertThatTerminalOutput ( containsString ( Version . CURRENT . toString ( ) ) ) ; assertThatTerminalOutput ( containsString ( Build . CURRENT . shortHash ( ) ) ) ; assertThatTerminalOutput ( containsString ( Build . CURRENT . date ( ) ) ) ; assertThatTerminalOutput ( containsString ( JvmInfo . jvmInfo ( ) . version ( ) ) ) ; } public void testThatVersionIsReturnedAsStartParameter ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK_AND_EXIT ) ; assertThatTerminalOutput ( containsString ( Version . CURRENT . toString ( ) ) ) ; assertThatTerminalOutput ( containsString ( Build . CURRENT . shortHash ( ) ) ) ; assertThatTerminalOutput ( containsString ( Build . CURRENT . date ( ) ) ) ; assertThatTerminalOutput ( containsString ( JvmInfo . jvmInfo ( ) . version ( ) ) ) ; CaptureOutputTerminal terminal = new CaptureOutputTerminal ( ) ; parser = new BootstrapCLIParser ( terminal ) ; status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK_AND_EXIT ) ; assertThatTerminalOutput ( containsString ( Version . CURRENT . toString ( ) ) ) ; assertThatTerminalOutput ( containsString ( Build . CURRENT . shortHash ( ) ) ) ; assertThatTerminalOutput ( containsString ( Build . CURRENT . date ( ) ) ) ; assertThatTerminalOutput ( containsString ( JvmInfo . jvmInfo ( ) . version ( ) ) ) ; } public void testThatPidFileCanBeConfigured ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; registerProperties ( <str> ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , USAGE ) ; status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK ) ; assertSystemProperty ( <str> , <str> ) ; System . clearProperty ( <str> ) ; status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK ) ; assertSystemProperty ( <str> , <str> ) ; } public void testThatParsingDaemonizeWorks ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; registerProperties ( <str> ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK ) ; assertThat ( System . getProperty ( <str> ) , is ( <str> ) ) ; } public void testThatNotDaemonizingDoesNotConfigureProperties ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; registerProperties ( <str> ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK ) ; assertThat ( System . getProperty ( <str> ) , is ( nullValue ( ) ) ) ; } public void testThatJavaPropertyStyleArgumentsCanBeParsed ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; registerProperties ( <str> , <str> ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK ) ; assertSystemProperty ( <str> , <str> ) ; assertSystemProperty ( <str> , <str> ) ; } public void testThatJavaPropertyStyleArgumentsWithEsPrefixAreNotPrefixedTwice ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; registerProperties ( <str> , <str> ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK ) ; assertThat ( System . getProperty ( <str> ) , is ( nullValue ( ) ) ) ; assertSystemProperty ( <str> , <str> ) ; assertSystemProperty ( <str> , <str> ) ; } public void testThatUnknownLongOptionsCanBeParsed ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; registerProperties ( <str> , <str> ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , OK ) ; assertSystemProperty ( <str> , <str> ) ; assertSystemProperty ( <str> , <str> ) ; } public void testThatUnknownLongOptionsNeedAValue ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; registerProperties ( <str> ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , USAGE ) ; assertThatTerminalOutput ( containsString ( <str> ) ) ; status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , USAGE ) ; assertThatTerminalOutput ( containsString ( <str> ) ) ; } public void testParsingErrors ( ) { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; ExitStatus status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , USAGE ) ; assertThatTerminalOutput ( containsString ( <str> ) ) ; terminal = new CaptureOutputTerminal ( ) ; parser = new BootstrapCLIParser ( terminal ) ; status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , USAGE ) ; assertThatTerminalOutput ( containsString ( <str> ) ) ; terminal = new CaptureOutputTerminal ( ) ; parser = new BootstrapCLIParser ( terminal ) ; status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , USAGE ) ; assertThatTerminalOutput ( containsString ( <str> ) ) ; terminal = new CaptureOutputTerminal ( ) ; parser = new BootstrapCLIParser ( terminal ) ; status = parser . execute ( args ( <str> ) ) ; assertStatus ( status , USAGE ) ; assertThatTerminalOutput ( containsString ( <str> ) ) ; } public void testHelpWorks ( ) throws Exception { List < Tuple < String , String > > tuples = new ArrayList < > ( ) ; tuples . add ( new Tuple < > ( <str> , <str> ) ) ; tuples . add ( new Tuple < > ( <str> , <str> ) ) ; tuples . add ( new Tuple < > ( <str> , <str> ) ) ; tuples . add ( new Tuple < > ( <str> , <str> ) ) ; tuples . add ( new Tuple < > ( <str> , <str> ) ) ; tuples . add ( new Tuple < > ( <str> , <str> ) ) ; for ( Tuple < String , String > tuple : tuples ) { terminal = new CaptureOutputTerminal ( ) ; BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; ExitStatus status = parser . execute ( args ( tuple . v1 ( ) ) ) ; assertStatus ( status , OK_AND_EXIT ) ; assertTerminalOutputContainsHelpFile ( terminal , <str> + tuple . v2 ( ) ) ; } } public void testThatSpacesInParametersAreSupported ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; registerProperties ( <str> , <str> ) ; ExitStatus status = parser . execute ( <str> , <str> , <str> , <str> , <str> ) ; assertStatus ( status , OK ) ; assertSystemProperty ( <str> , <str> ) ; assertSystemProperty ( <str> , <str> ) ; } public void testThatHelpfulErrorMessageIsGivenWhenParametersAreOutOfOrder ( ) throws Exception { BootstrapCLIParser parser = new BootstrapCLIParser ( terminal ) ; try { parser . parse ( <str> , new String [ ] { <str> , <str> } ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } private void registerProperties ( String . . . systemProperties ) { propertiesToClear . addAll ( Arrays . asList ( systemProperties ) ) ; } private void assertSystemProperty ( String name , String expectedValue ) { String msg = String . format ( Locale . ROOT , <str> , name , expectedValue , terminal . getTerminalOutput ( ) ) ; assertThat ( msg , System . getProperty ( name ) , is ( expectedValue ) ) ; } private void assertStatus ( ExitStatus status , ExitStatus expectedStatus ) { assertThat ( String . format ( Locale . ROOT , <str> , expectedStatus , status , terminal . getTerminalOutput ( ) ) , status , is ( expectedStatus ) ) ; } private void assertThatTerminalOutput ( Matcher < String > matcher ) { assertThat ( terminal . getTerminalOutput ( ) , hasItem ( matcher ) ) ; } } 
