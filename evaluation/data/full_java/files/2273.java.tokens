package org . nd4j . linalg . util ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . Nd4j ; public class FeatureUtil { public static INDArray toOutcomeVector ( int index , int numOutcomes ) { int [ ] nums = new int [ numOutcomes ] ; nums [ index ] = <int> ; return ArrayUtil . toNDArray ( nums ) ; } public static INDArray toOutcomeMatrix ( int [ ] index , int numOutcomes ) { INDArray ret = Nd4j . create ( index . length , numOutcomes ) ; for ( int i = <int> ; i < ret . rows ( ) ; i + + ) { int [ ] nums = new int [ numOutcomes ] ; nums [ index [ i ] ] = <int> ; ret . putRow ( i , ArrayUtil . toNDArray ( nums ) ) ; } return ret ; } public static void normalizeMatrix ( INDArray toNormalize ) { INDArray columnMeans = toNormalize . mean ( <int> ) ; toNormalize . subiRowVector ( columnMeans ) ; INDArray std = toNormalize . std ( <int> ) ; std . addi ( Nd4j . scalar ( <float> ) ) ; toNormalize . diviRowVector ( std ) ; } public static void scaleByMax ( INDArray toScale ) { INDArray scale = toScale . max ( <int> ) ; for ( int i = <int> ; i < toScale . rows ( ) ; i + + ) { double scaleBy = scale . getDouble ( i ) ; toScale . putRow ( i , toScale . getRow ( i ) . divi ( scaleBy ) ) ; } } public static void scaleMinMax ( double min , double max , INDArray toScale ) { INDArray min2 = toScale . min ( <int> ) ; INDArray max2 = toScale . max ( <int> ) ; INDArray std = toScale . subRowVector ( min2 ) . diviRowVector ( max2 . sub ( min2 ) ) ; INDArray scaled = std . mul ( max - min ) . addi ( min ) ; toScale . assign ( scaled ) ; } } 
