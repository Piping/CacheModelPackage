package com . google . common . collect ; import static com . google . common . collect . BoundType . OPEN ; import static com . google . common . collect . Range . range ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . testing . SerializableTester ; import java . util . List ; import java . util . NavigableMap ; @GwtIncompatible ( <str> ) public class TreeRangeSetTest extends AbstractRangeSetTest { private static final ImmutableList < Range < Integer > > QUERY_RANGES ; private static final int MIN_BOUND = - <int> ; private static final int MAX_BOUND = <int> ; static { ImmutableList . Builder < Range < Integer > > queryBuilder = ImmutableList . builder ( ) ; queryBuilder . add ( Range . < Integer > all ( ) ) ; for ( int i = MIN_BOUND ; i < = MAX_BOUND ; i + + ) { for ( BoundType boundType : BoundType . values ( ) ) { queryBuilder . add ( Range . upTo ( i , boundType ) ) ; queryBuilder . add ( Range . downTo ( i , boundType ) ) ; } queryBuilder . add ( Range . singleton ( i ) ) ; queryBuilder . add ( Range . openClosed ( i , i ) ) ; queryBuilder . add ( Range . closedOpen ( i , i ) ) ; for ( BoundType lowerBoundType : BoundType . values ( ) ) { for ( int j = i + <int> ; j < = MAX_BOUND ; j + + ) { for ( BoundType upperBoundType : BoundType . values ( ) ) { queryBuilder . add ( Range . range ( i , lowerBoundType , j , upperBoundType ) ) ; } } } } QUERY_RANGES = queryBuilder . build ( ) ; } void testViewAgainstExpected ( RangeSet < Integer > expected , RangeSet < Integer > view ) { assertEquals ( expected , view ) ; assertEquals ( expected . asRanges ( ) , view . asRanges ( ) ) ; assertEquals ( expected . isEmpty ( ) , view . isEmpty ( ) ) ; if ( ! expected . isEmpty ( ) ) { assertEquals ( expected . span ( ) , view . span ( ) ) ; } for ( int i = MIN_BOUND - <int> ; i < = MAX_BOUND + <int> ; i + + ) { assertEquals ( expected . contains ( i ) , view . contains ( i ) ) ; assertEquals ( expected . rangeContaining ( i ) , view . rangeContaining ( i ) ) ; } testEnclosing ( view ) ; if ( view instanceof TreeRangeSet ) { testRangesByLowerBounds ( ( TreeRangeSet < Integer > ) view , expected . asRanges ( ) ) ; } } private static final ImmutableList < Cut < Integer > > CUTS_TO_TEST ; static { List < Cut < Integer > > cutsToTest = Lists . newArrayList ( ) ; for ( int i = MIN_BOUND - <int> ; i < = MAX_BOUND + <int> ; i + + ) { cutsToTest . add ( Cut . belowValue ( i ) ) ; cutsToTest . add ( Cut . aboveValue ( i ) ) ; } cutsToTest . add ( Cut . < Integer > aboveAll ( ) ) ; cutsToTest . add ( Cut . < Integer > belowAll ( ) ) ; CUTS_TO_TEST = ImmutableList . copyOf ( cutsToTest ) ; } private void testRangesByLowerBounds ( TreeRangeSet < Integer > rangeSet , Iterable < Range < Integer > > expectedRanges ) { NavigableMap < Cut < Integer > , Range < Integer > > expectedRangesByLowerBound = Maps . newTreeMap ( ) ; for ( Range < Integer > range : expectedRanges ) { expectedRangesByLowerBound . put ( range . lowerBound , range ) ; } NavigableMap < Cut < Integer > , Range < Integer > > rangesByLowerBound = rangeSet . rangesByLowerBound ; testNavigationAgainstExpected ( expectedRangesByLowerBound , rangesByLowerBound , CUTS_TO_TEST ) ; } < K , V > void testNavigationAgainstExpected ( NavigableMap < K , V > expected , NavigableMap < K , V > navigableMap , Iterable < K > keysToTest ) { for ( K key : keysToTest ) { assertEquals ( expected . lowerEntry ( key ) , navigableMap . lowerEntry ( key ) ) ; assertEquals ( expected . floorEntry ( key ) , navigableMap . floorEntry ( key ) ) ; assertEquals ( expected . ceilingEntry ( key ) , navigableMap . ceilingEntry ( key ) ) ; assertEquals ( expected . higherEntry ( key ) , navigableMap . higherEntry ( key ) ) ; for ( boolean inclusive : new boolean [ ] { false , true } ) { assertThat ( navigableMap . headMap ( key , inclusive ) . entrySet ( ) ) . containsExactlyElementsIn ( expected . headMap ( key , inclusive ) . entrySet ( ) ) . inOrder ( ) ; assertThat ( navigableMap . tailMap ( key , inclusive ) . entrySet ( ) ) . containsExactlyElementsIn ( expected . tailMap ( key , inclusive ) . entrySet ( ) ) . inOrder ( ) ; assertThat ( navigableMap . headMap ( key , inclusive ) . descendingMap ( ) . entrySet ( ) ) . containsExactlyElementsIn ( expected . headMap ( key , inclusive ) . descendingMap ( ) . entrySet ( ) ) . inOrder ( ) ; assertThat ( navigableMap . tailMap ( key , inclusive ) . descendingMap ( ) . entrySet ( ) ) . containsExactlyElementsIn ( expected . tailMap ( key , inclusive ) . descendingMap ( ) . entrySet ( ) ) . inOrder ( ) ; } } } public void testEnclosing ( RangeSet < Integer > rangeSet ) { for ( Range < Integer > query : QUERY_RANGES ) { boolean expectEnclose = false ; for ( Range < Integer > expectedRange : rangeSet . asRanges ( ) ) { if ( expectedRange . encloses ( query ) ) { expectEnclose = true ; break ; } } assertEquals ( rangeSet + <str> + query + <str> , expectEnclose , rangeSet . encloses ( query ) ) ; } } public void testAllSingleRangesComplementAgainstRemove ( ) { for ( Range < Integer > range : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range ) ; TreeRangeSet < Integer > complement = TreeRangeSet . create ( ) ; complement . add ( Range . < Integer > all ( ) ) ; complement . remove ( range ) ; assertEquals ( complement , rangeSet . complement ( ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactlyElementsIn ( complement . asRanges ( ) ) . inOrder ( ) ; } } public void testInvariantsEmpty ( ) { testInvariants ( TreeRangeSet . create ( ) ) ; } public void testAllSingleRangesEnclosing ( ) { for ( Range < Integer > range : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range ) ; testEnclosing ( rangeSet ) ; testEnclosing ( rangeSet . complement ( ) ) ; } } public void testAllTwoRangesEnclosing ( ) { for ( Range < Integer > range1 : QUERY_RANGES ) { for ( Range < Integer > range2 : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range1 ) ; rangeSet . add ( range2 ) ; testEnclosing ( rangeSet ) ; testEnclosing ( rangeSet . complement ( ) ) ; } } } public void testCreateCopy ( ) { for ( Range < Integer > range1 : QUERY_RANGES ) { for ( Range < Integer > range2 : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range1 ) ; rangeSet . add ( range2 ) ; assertEquals ( rangeSet , TreeRangeSet . create ( rangeSet ) ) ; } } } private RangeSet < Integer > expectedSubRangeSet ( RangeSet < Integer > rangeSet , Range < Integer > subRange ) { RangeSet < Integer > expected = TreeRangeSet . create ( ) ; for ( Range < Integer > range : rangeSet . asRanges ( ) ) { if ( range . isConnected ( subRange ) ) { expected . add ( range . intersection ( subRange ) ) ; } } return expected ; } private RangeSet < Integer > expectedComplement ( RangeSet < Integer > rangeSet ) { RangeSet < Integer > expected = TreeRangeSet . create ( ) ; expected . add ( Range . < Integer > all ( ) ) ; expected . removeAll ( rangeSet ) ; return expected ; } public void testSubRangeSet ( ) { for ( Range < Integer > range1 : QUERY_RANGES ) { for ( Range < Integer > range2 : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range1 ) ; rangeSet . add ( range2 ) ; for ( Range < Integer > subRange : QUERY_RANGES ) { testViewAgainstExpected ( expectedSubRangeSet ( rangeSet , subRange ) , rangeSet . subRangeSet ( subRange ) ) ; } } } } public void testComplement ( ) { for ( Range < Integer > range1 : QUERY_RANGES ) { for ( Range < Integer > range2 : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range1 ) ; rangeSet . add ( range2 ) ; testViewAgainstExpected ( expectedComplement ( rangeSet ) , rangeSet . complement ( ) ) ; } } } public void testSubRangeSetOfComplement ( ) { for ( Range < Integer > range1 : QUERY_RANGES ) { for ( Range < Integer > range2 : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range1 ) ; rangeSet . add ( range2 ) ; for ( Range < Integer > subRange : QUERY_RANGES ) { testViewAgainstExpected ( expectedSubRangeSet ( expectedComplement ( rangeSet ) , subRange ) , rangeSet . complement ( ) . subRangeSet ( subRange ) ) ; } } } } public void testComplementOfSubRangeSet ( ) { for ( Range < Integer > range1 : QUERY_RANGES ) { for ( Range < Integer > range2 : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range1 ) ; rangeSet . add ( range2 ) ; for ( Range < Integer > subRange : QUERY_RANGES ) { testViewAgainstExpected ( expectedComplement ( expectedSubRangeSet ( rangeSet , subRange ) ) , rangeSet . subRangeSet ( subRange ) . complement ( ) ) ; } } } } public void testRangesByUpperBound ( ) { for ( Range < Integer > range1 : QUERY_RANGES ) { for ( Range < Integer > range2 : QUERY_RANGES ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( range1 ) ; rangeSet . add ( range2 ) ; NavigableMap < Cut < Integer > , Range < Integer > > expectedRangesByUpperBound = Maps . newTreeMap ( ) ; for ( Range < Integer > range : rangeSet . asRanges ( ) ) { expectedRangesByUpperBound . put ( range . upperBound , range ) ; } testNavigationAgainstExpected ( expectedRangesByUpperBound , new TreeRangeSet . RangesByUpperBound < Integer > ( rangeSet . rangesByLowerBound ) , CUTS_TO_TEST ) ; } } } public void testMergesConnectedWithOverlap ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . open ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closedOpen ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . atLeast ( <int> ) ) . inOrder ( ) ; } public void testMergesConnectedDisjoint ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . open ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closedOpen ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . atLeast ( <int> ) ) . inOrder ( ) ; } public void testIgnoresSmallerSharingNoBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . open ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testIgnoresSmallerSharingLowerBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testIgnoresSmallerSharingUpperBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testIgnoresEqual ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testExtendSameLowerBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testExtendSameUpperBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testExtendBothDirections ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testAddEmpty ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closedOpen ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . isEmpty ( ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . < Integer > all ( ) ) ; } public void testFillHoleExactly ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closedOpen ( <int> , <int> ) ) ; rangeSet . add ( Range . closedOpen ( <int> , <int> ) ) ; rangeSet . add ( Range . closedOpen ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closedOpen ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . atLeast ( <int> ) ) . inOrder ( ) ; } public void testFillHoleWithOverlap ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closedOpen ( <int> , <int> ) ) ; rangeSet . add ( Range . closedOpen ( <int> , <int> ) ) ; rangeSet . add ( Range . closedOpen ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closedOpen ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . atLeast ( <int> ) ) . inOrder ( ) ; } public void testAddManyPairs ( ) { for ( int aLow = <int> ; aLow < <int> ; aLow + + ) { for ( int aHigh = <int> ; aHigh < <int> ; aHigh + + ) { for ( BoundType aLowType : BoundType . values ( ) ) { for ( BoundType aHighType : BoundType . values ( ) ) { if ( ( aLow = = aHigh & & aLowType = = OPEN & & aHighType = = OPEN ) | | aLow > aHigh ) { continue ; } for ( int bLow = <int> ; bLow < <int> ; bLow + + ) { for ( int bHigh = <int> ; bHigh < <int> ; bHigh + + ) { for ( BoundType bLowType : BoundType . values ( ) ) { for ( BoundType bHighType : BoundType . values ( ) ) { if ( ( bLow = = bHigh & & bLowType = = OPEN & & bHighType = = OPEN ) | | bLow > bHigh ) { continue ; } doPairTest ( range ( aLow , aLowType , aHigh , aHighType ) , range ( bLow , bLowType , bHigh , bHighType ) ) ; } } } } } } } } } private static void doPairTest ( Range < Integer > a , Range < Integer > b ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( a ) ; rangeSet . add ( b ) ; if ( a . isEmpty ( ) & & b . isEmpty ( ) ) { assertThat ( rangeSet . asRanges ( ) ) . isEmpty ( ) ; } else if ( a . isEmpty ( ) ) { assertThat ( rangeSet . asRanges ( ) ) . contains ( b ) ; } else if ( b . isEmpty ( ) ) { assertThat ( rangeSet . asRanges ( ) ) . contains ( a ) ; } else if ( a . isConnected ( b ) ) { assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( a . span ( b ) ) ; } else { if ( a . lowerEndpoint ( ) < b . lowerEndpoint ( ) ) { assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( a , b ) . inOrder ( ) ; } else { assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( b , a ) . inOrder ( ) ; } } } public void testRemoveEmpty ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closedOpen ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . closed ( <int> , <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testRemovePartSharingLowerBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closedOpen ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . singleton ( <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testRemovePartSharingUpperBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . openClosed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . contains ( Range . singleton ( <int> ) ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testRemoveMiddle ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . atMost ( <int> ) ) ; rangeSet . remove ( Range . closedOpen ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( Range . lessThan ( <int> ) , Range . closed ( <int> , <int> ) ) . inOrder ( ) ; assertThat ( rangeSet . complement ( ) . asRanges ( ) ) . containsExactly ( Range . closedOpen ( <int> , <int> ) , Range . greaterThan ( <int> ) ) . inOrder ( ) ; } public void testRemoveNoOverlap ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closedOpen ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( Range . closed ( <int> , <int> ) ) ; } public void testRemovePartFromBelowLowerBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( Range . openClosed ( <int> , <int> ) ) ; } public void testRemovePartFromAboveUpperBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . containsExactly ( Range . closedOpen ( <int> , <int> ) ) ; } public void testRemoveExact ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . isEmpty ( ) ; } public void testRemoveAllFromBelowLowerBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . isEmpty ( ) ; } public void testRemoveAllFromAboveUpperBound ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . isEmpty ( ) ; } public void testRemoveAllExtendingBothDirections ( ) { TreeRangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . closed ( <int> , <int> ) ) ; testInvariants ( rangeSet ) ; assertThat ( rangeSet . asRanges ( ) ) . isEmpty ( ) ; } public void testRangeContaining1 ( ) { RangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; assertEquals ( Range . closed ( <int> , <int> ) , rangeSet . rangeContaining ( <int> ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertNull ( rangeSet . rangeContaining ( <int> ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; } public void testRangeContaining2 ( ) { RangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . open ( <int> , <int> ) ) ; assertEquals ( Range . closed ( <int> , <int> ) , rangeSet . rangeContaining ( <int> ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertEquals ( Range . closed ( <int> , <int> ) , rangeSet . rangeContaining ( <int> ) ) ; assertTrue ( rangeSet . contains ( <int> ) ) ; assertNull ( rangeSet . rangeContaining ( <int> ) ) ; assertFalse ( rangeSet . contains ( <int> ) ) ; } @GwtIncompatible ( <str> ) public void testSerialization ( ) { RangeSet < Integer > rangeSet = TreeRangeSet . create ( ) ; rangeSet . add ( Range . closed ( <int> , <int> ) ) ; rangeSet . remove ( Range . open ( <int> , <int> ) ) ; SerializableTester . reserializeAndAssert ( rangeSet ) ; } } 
