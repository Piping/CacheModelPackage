package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputMultiplexer ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . PerspectiveCamera ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . glutils . MipMapGenerator ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . scenes . scene2d . Stage ; import com . badlogic . gdx . scenes . scene2d . ui . CheckBox ; import com . badlogic . gdx . scenes . scene2d . ui . Label ; import com . badlogic . gdx . scenes . scene2d . ui . SelectBox ; import com . badlogic . gdx . scenes . scene2d . ui . Table ; import com . badlogic . gdx . scenes . scene2d . ui . SelectBox . SelectBoxStyle ; import com . badlogic . gdx . scenes . scene2d . ui . Skin ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . tests . utils . PerspectiveCamController ; import com . badlogic . gdx . utils . GdxRuntimeException ; public class MipMapTest extends GdxTest { PerspectiveCamera camera ; PerspectiveCamController controller ; Mesh mesh ; Texture textureHW ; Texture textureSW ; Texture currTexture ; ShaderProgram shader ; Stage ui ; Skin skin ; InputMultiplexer multiplexer ; SelectBox < String > minFilter ; SelectBox < String > magFilter ; CheckBox hwMipMap ; @Override public void create ( ) { camera = new PerspectiveCamera ( <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; camera . position . set ( <int> , <float> , <float> ) ; camera . lookAt ( <int> , <int> , <int> ) ; camera . update ( ) ; controller = new PerspectiveCamController ( camera ) ; mesh = new Mesh ( true , <int> , <int> , new VertexAttribute ( Usage . Position , <int> , ShaderProgram . POSITION_ATTRIBUTE ) , new VertexAttribute ( Usage . TextureCoordinates , <int> , ShaderProgram . TEXCOORD_ATTRIBUTE ) ) ; mesh . setVertices ( new float [ ] { - <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , <int> , <int> , - <int> , <int> , - <int> , <int> , <int> , } ) ; mesh . setIndices ( new short [ ] { <int> , <int> , <int> , <int> } ) ; shader = new ShaderProgram ( Gdx . files . internal ( <str> ) . readString ( ) , Gdx . files . internal ( <str> ) . readString ( ) ) ; if ( ! shader . isCompiled ( ) ) throw new GdxRuntimeException ( <str> + shader . getLog ( ) ) ; textureHW = new Texture ( Gdx . files . internal ( <str> ) , Format . RGB565 , true ) ; MipMapGenerator . setUseHardwareMipMap ( false ) ; textureSW = new Texture ( Gdx . files . internal ( <str> ) , Format . RGB565 , true ) ; currTexture = textureHW ; createUI ( ) ; multiplexer = new InputMultiplexer ( ) ; Gdx . input . setInputProcessor ( multiplexer ) ; multiplexer . addProcessor ( ui ) ; multiplexer . addProcessor ( controller ) ; } private void createUI ( ) { skin = new Skin ( Gdx . files . internal ( <str> ) ) ; ui = new Stage ( ) ; String [ ] filters = new String [ TextureFilter . values ( ) . length ] ; int idx = <int> ; for ( TextureFilter filter : TextureFilter . values ( ) ) { filters [ idx + + ] = filter . toString ( ) ; } hwMipMap = new CheckBox ( <str> , skin ) ; minFilter = new SelectBox ( skin ) ; minFilter . setItems ( filters ) ; magFilter = new SelectBox ( skin . get ( SelectBoxStyle . class ) ) ; magFilter . setItems ( <str> , <str> ) ; Table table = new Table ( ) ; table . setSize ( ui . getWidth ( ) , <int> ) ; table . setY ( ui . getHeight ( ) - <int> ) ; table . add ( hwMipMap ) . spaceRight ( <int> ) ; table . add ( new Label ( <str> , skin ) ) . spaceRight ( <int> ) ; table . add ( minFilter ) . spaceRight ( <int> ) ; table . add ( new Label ( <str> , skin ) ) . spaceRight ( <int> ) ; table . add ( magFilter ) ; ui . addActor ( table ) ; } @Override public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; Gdx . gl . glEnable ( GL20 . GL_TEXTURE_2D ) ; camera . update ( ) ; currTexture = hwMipMap . isChecked ( ) ? textureHW : textureSW ; currTexture . bind ( ) ; currTexture . setFilter ( TextureFilter . valueOf ( minFilter . getSelected ( ) ) , TextureFilter . valueOf ( magFilter . getSelected ( ) ) ) ; shader . begin ( ) ; shader . setUniformMatrix ( <str> , camera . combined ) ; shader . setUniformi ( <str> , <int> ) ; mesh . render ( shader , GL20 . GL_TRIANGLE_FAN ) ; shader . end ( ) ; ui . act ( ) ; ui . draw ( ) ; } @Override public void dispose ( ) { shader . dispose ( ) ; textureHW . dispose ( ) ; textureSW . dispose ( ) ; mesh . dispose ( ) ; ui . dispose ( ) ; skin . dispose ( ) ; } } 
