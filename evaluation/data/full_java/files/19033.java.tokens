package io . netty . handler . codec . dns ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . CorruptedFrameException ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . StringUtil ; public class DefaultDnsRecordDecoder implements DnsRecordDecoder { protected DefaultDnsRecordDecoder ( ) { } @Override public final DnsQuestion decodeQuestion ( ByteBuf in ) throws Exception { String name = decodeName ( in ) ; DnsRecordType type = DnsRecordType . valueOf ( in . readUnsignedShort ( ) ) ; int qClass = in . readUnsignedShort ( ) ; return new DefaultDnsQuestion ( name , type , qClass ) ; } @Override public final < T extends DnsRecord > T decodeRecord ( ByteBuf in ) throws Exception { final int startOffset = in . readerIndex ( ) ; final String name = decodeName ( in ) ; final int endOffset = in . writerIndex ( ) ; if ( endOffset - startOffset < <int> ) { in . readerIndex ( startOffset ) ; return null ; } final DnsRecordType type = DnsRecordType . valueOf ( in . readUnsignedShort ( ) ) ; final int aClass = in . readUnsignedShort ( ) ; final long ttl = in . readUnsignedInt ( ) ; final int length = in . readUnsignedShort ( ) ; final int offset = in . readerIndex ( ) ; if ( endOffset - offset < length ) { in . readerIndex ( startOffset ) ; return null ; } @SuppressWarnings ( <str> ) T record = ( T ) decodeRecord ( name , type , aClass , ttl , in , offset , length ) ; in . readerIndex ( offset + length ) ; return record ; } protected DnsRecord decodeRecord ( String name , DnsRecordType type , int dnsClass , long timeToLive , ByteBuf in , int offset , int length ) throws Exception { return new DefaultDnsRawRecord ( name , type , dnsClass , timeToLive , in . duplicate ( ) . setIndex ( offset , offset + length ) . retain ( ) ) ; } protected String decodeName ( ByteBuf in ) { int position = - <int> ; int checked = <int> ; final int end = in . writerIndex ( ) ; final StringBuilder name = new StringBuilder ( in . readableBytes ( ) < < <int> ) ; for ( int len = in . readUnsignedByte ( ) ; in . isReadable ( ) & & len ! = <int> ; len = in . readUnsignedByte ( ) ) { boolean pointer = ( len & <hex> ) = = <hex> ; if ( pointer ) { if ( position = = - <int> ) { position = in . readerIndex ( ) + <int> ; } final int next = ( len & <hex> ) < < <int> | in . readUnsignedByte ( ) ; if ( next > = end ) { throw new CorruptedFrameException ( <str> ) ; } in . readerIndex ( next ) ; checked + = <int> ; if ( checked > = end ) { throw new CorruptedFrameException ( <str> ) ; } } else { name . append ( in . toString ( in . readerIndex ( ) , len , CharsetUtil . UTF_8 ) ) . append ( <str> ) ; in . skipBytes ( len ) ; } } if ( position ! = - <int> ) { in . readerIndex ( position ) ; } if ( name . length ( ) = = <int> ) { return StringUtil . EMPTY_STRING ; } return name . substring ( <int> , name . length ( ) - <int> ) ; } } 
