package org . jbox2d . dynamics . joints ; import org . jbox2d . common . Mat22 ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Transform ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . SolverData ; import org . jbox2d . pooling . IWorldPool ; public class MouseJoint extends Joint { private final Vec2 m_localAnchorB = new Vec2 ( ) ; private final Vec2 m_targetA = new Vec2 ( ) ; private float m_frequencyHz ; private float m_dampingRatio ; private float m_beta ; private final Vec2 m_impulse = new Vec2 ( ) ; private float m_maxForce ; private float m_gamma ; private int m_indexB ; private final Vec2 m_rB = new Vec2 ( ) ; private final Vec2 m_localCenterB = new Vec2 ( ) ; private float m_invMassB ; private float m_invIB ; private final Mat22 m_mass = new Mat22 ( ) ; private final Vec2 m_C = new Vec2 ( ) ; protected MouseJoint ( IWorldPool argWorld , MouseJointDef def ) { super ( argWorld , def ) ; assert ( def . target . isValid ( ) ) ; assert ( def . maxForce > = <int> ) ; assert ( def . frequencyHz > = <int> ) ; assert ( def . dampingRatio > = <int> ) ; m_targetA . set ( def . target ) ; Transform . mulTransToOutUnsafe ( m_bodyB . getTransform ( ) , m_targetA , m_localAnchorB ) ; m_maxForce = def . maxForce ; m_impulse . setZero ( ) ; m_frequencyHz = def . frequencyHz ; m_dampingRatio = def . dampingRatio ; m_beta = <int> ; m_gamma = <int> ; } @Override public void getAnchorA ( Vec2 argOut ) { argOut . set ( m_targetA ) ; } @Override public void getAnchorB ( Vec2 argOut ) { m_bodyB . getWorldPointToOut ( m_localAnchorB , argOut ) ; } @Override public void getReactionForce ( float invDt , Vec2 argOut ) { argOut . set ( m_impulse ) . mulLocal ( invDt ) ; } @Override public float getReactionTorque ( float invDt ) { return invDt * <float> ; } public void setTarget ( Vec2 target ) { if ( m_bodyB . isAwake ( ) = = false ) { m_bodyB . setAwake ( true ) ; } m_targetA . set ( target ) ; } public Vec2 getTarget ( ) { return m_targetA ; } public void setMaxForce ( float force ) { m_maxForce = force ; } public float getMaxForce ( ) { return m_maxForce ; } public void setFrequency ( float hz ) { m_frequencyHz = hz ; } public float getFrequency ( ) { return m_frequencyHz ; } public void setDampingRatio ( float ratio ) { m_dampingRatio = ratio ; } public float getDampingRatio ( ) { return m_dampingRatio ; } @Override public void initVelocityConstraints ( final SolverData data ) { m_indexB = m_bodyB . m_islandIndex ; m_localCenterB . set ( m_bodyB . m_sweep . localCenter ) ; m_invMassB = m_bodyB . m_invMass ; m_invIB = m_bodyB . m_invI ; Vec2 cB = data . positions [ m_indexB ] . c ; float aB = data . positions [ m_indexB ] . a ; Vec2 vB = data . velocities [ m_indexB ] . v ; float wB = data . velocities [ m_indexB ] . w ; final Rot qB = pool . popRot ( ) ; qB . set ( aB ) ; float mass = m_bodyB . getMass ( ) ; float omega = <float> * MathUtils . PI * m_frequencyHz ; float d = <float> * mass * m_dampingRatio * omega ; float k = mass * ( omega * omega ) ; float h = data . step . dt ; assert ( d + h * k > Settings . EPSILON ) ; m_gamma = h * ( d + h * k ) ; if ( m_gamma ! = <float> ) { m_gamma = <float> / m_gamma ; } m_beta = h * k * m_gamma ; Vec2 temp = pool . popVec2 ( ) ; Rot . mulToOutUnsafe ( qB , temp . set ( m_localAnchorB ) . subLocal ( m_localCenterB ) , m_rB ) ; final Mat22 K = pool . popMat22 ( ) ; K . ex . x = m_invMassB + m_invIB * m_rB . y * m_rB . y + m_gamma ; K . ex . y = - m_invIB * m_rB . x * m_rB . y ; K . ey . x = K . ex . y ; K . ey . y = m_invMassB + m_invIB * m_rB . x * m_rB . x + m_gamma ; K . invertToOut ( m_mass ) ; m_C . set ( cB ) . addLocal ( m_rB ) . subLocal ( m_targetA ) ; m_C . mulLocal ( m_beta ) ; wB * = <float> ; if ( data . step . warmStarting ) { m_impulse . mulLocal ( data . step . dtRatio ) ; vB . x + = m_invMassB * m_impulse . x ; vB . y + = m_invMassB * m_impulse . y ; wB + = m_invIB * Vec2 . cross ( m_rB , m_impulse ) ; } else { m_impulse . setZero ( ) ; } data . velocities [ m_indexB ] . w = wB ; pool . pushVec2 ( <int> ) ; pool . pushMat22 ( <int> ) ; pool . pushRot ( <int> ) ; } @Override public boolean solvePositionConstraints ( final SolverData data ) { return true ; } @Override public void solveVelocityConstraints ( final SolverData data ) { Vec2 vB = data . velocities [ m_indexB ] . v ; float wB = data . velocities [ m_indexB ] . w ; final Vec2 Cdot = pool . popVec2 ( ) ; Vec2 . crossToOutUnsafe ( wB , m_rB , Cdot ) ; Cdot . addLocal ( vB ) ; final Vec2 impulse = pool . popVec2 ( ) ; final Vec2 temp = pool . popVec2 ( ) ; temp . set ( m_impulse ) . mulLocal ( m_gamma ) . addLocal ( m_C ) . addLocal ( Cdot ) . negateLocal ( ) ; Mat22 . mulToOutUnsafe ( m_mass , temp , impulse ) ; Vec2 oldImpulse = temp ; oldImpulse . set ( m_impulse ) ; m_impulse . addLocal ( impulse ) ; float maxImpulse = data . step . dt * m_maxForce ; if ( m_impulse . lengthSquared ( ) > maxImpulse * maxImpulse ) { m_impulse . mulLocal ( maxImpulse / m_impulse . length ( ) ) ; } impulse . set ( m_impulse ) . subLocal ( oldImpulse ) ; vB . x + = m_invMassB * impulse . x ; vB . y + = m_invMassB * impulse . y ; wB + = m_invIB * Vec2 . cross ( m_rB , impulse ) ; data . velocities [ m_indexB ] . w = wB ; pool . pushVec2 ( <int> ) ; } } 
