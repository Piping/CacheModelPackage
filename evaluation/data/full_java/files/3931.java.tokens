package org . eclipse . debug . tests . viewer . model ; import java . util . regex . Pattern ; import junit . framework . TestCase ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . TreeModelViewerFilter ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . ITreeSelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . TreeSelection ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . jface . viewers . ViewerFilter ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; abstract public class FilterTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; ITreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public FilterTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , true , true ) ; fShell . open ( ) ; } abstract protected IInternalTreeModelViewer createViewer ( Display display , Shell shell ) ; @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } @Override protected void runTest ( ) throws Throwable { try { super . runTest ( ) ; } catch ( Throwable t ) { throw new ExecutionException ( <str> + t . getMessage ( ) + <str> + fListener . toString ( ) , t ) ; } } protected IInternalTreeModelViewer getInternalViewer ( ) { return ( IInternalTreeModelViewer ) fViewer ; } class TestViewerFilter extends ViewerFilter { Pattern fPattern ; TestViewerFilter ( String pattern ) { fPattern = Pattern . compile ( pattern ) ; } @Override public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( element instanceof TestElement ) { TestElement te = ( TestElement ) element ; return ! fPattern . matcher ( te . getLabel ( ) ) . find ( ) ; } return true ; } } class TestTMVFilter extends TreeModelViewerFilter { Pattern fPattern ; Object fParentElement ; TestTMVFilter ( String pattern , Object parentElement ) { fPattern = Pattern . compile ( pattern ) ; fParentElement = parentElement ; } @Override public boolean isApplicable ( ITreeModelViewer viewer , Object parentElement ) { if ( fParentElement ! = null ) { return fParentElement . equals ( parentElement ) ; } return true ; } @Override public boolean select ( Viewer viewer , Object parentElement , Object element ) { if ( element instanceof TestElement ) { TestElement te = ( TestElement ) element ; return ! fPattern . matcher ( te . getLabel ( ) ) . find ( ) ; } return true ; } } public void testSimpleSingleLevel ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; doTestSimpleLevel ( model , new ViewerFilter [ ] { new TestViewerFilter ( <str> ) } ) ; } public void testSimpleSingleLevelWithTMVFilter ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; doTestSimpleLevel ( model , new ViewerFilter [ ] { new TestTMVFilter ( <str> , model . getRootElement ( ) ) } ) ; } public void testSimpleSingleLevelWithMixedFilters ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; doTestSimpleLevel ( model , new ViewerFilter [ ] { new TestTMVFilter ( <str> , model . getRootElement ( ) ) , new TestViewerFilter ( <str> ) } ) ; } public void testSimpleMultiLevel ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; doTestSimpleLevel ( model , new ViewerFilter [ ] { new TestViewerFilter ( <str> ) , new TestViewerFilter ( <str> ) } ) ; } public void testSimpleMultiLevelWithTMVFilter ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; doTestSimpleLevel ( model , new ViewerFilter [ ] { new TestTMVFilter ( <str> , null ) , new TestTMVFilter ( <str> , null ) } ) ; } public void testSimpleMultiLevelWithMixedFilters ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; doTestSimpleLevel ( model , new ViewerFilter [ ] { new TestViewerFilter ( <str> ) , new TestTMVFilter ( <str> , null ) } ) ; } private void doTestSimpleLevel ( TestModel model , ViewerFilter [ ] filters ) throws InterruptedException { fViewer . setAutoExpandLevel ( - <int> ) ; fViewer . setFilters ( filters ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , filters , - <int> , true , true ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , false , filters ) ; } public void testLargeSingleLevel ( ) throws InterruptedException { doTestLargeSingleLevel ( new ViewerFilter [ ] { new TestViewerFilter ( <str> ) } ) ; } public void testLargeSingleLevelWithTMVFilter ( ) throws InterruptedException { doTestLargeSingleLevel ( new ViewerFilter [ ] { new TestTMVFilter ( <str> , null ) } ) ; } private void doTestLargeSingleLevel ( ViewerFilter [ ] filters ) throws InterruptedException { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . setElementChildren ( TreePath . EMPTY , TestModel . makeSingleLevelModelElements ( model , <int> , <str> ) ) ; fViewer . setFilters ( filters ) ; fListener . setFailOnRedundantUpdates ( false ) ; fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } public void testReplacedUnrealizedFilteredElement ( ) throws InterruptedException { doTestReplacedUnrealizedFilteredElement ( new ViewerFilter [ ] { new TestViewerFilter ( <str> ) } ) ; } public void testReplacedUnrealizedFilteredElementWithTMVFilter ( ) throws InterruptedException { doTestReplacedUnrealizedFilteredElement ( new ViewerFilter [ ] { new TestTMVFilter ( <str> , null ) } ) ; } private void doTestReplacedUnrealizedFilteredElement ( ViewerFilter [ ] filters ) throws InterruptedException { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . setElementChildren ( TreePath . EMPTY , TestModel . makeSingleLevelModelElements ( model , <int> , <str> ) ) ; fViewer . setFilters ( filters ) ; fListener . setFailOnRedundantUpdates ( false ) ; fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TestElement replacedElement = new TestElement ( model , <str> , new TestElement [ <int> ] ) ; IModelDelta replaceDelta = model . replaceElementChild ( TreePath . EMPTY , <int> , replacedElement ) ; fListener . reset ( ) ; model . postDelta ( replaceDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( ) ; ( ( IInternalTreeModelViewer ) fViewer ) . reveal ( TreePath . EMPTY , <int> ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TreePath [ ] replacedElementPaths = fViewer . getElementPaths ( replacedElement ) ; assertTrue ( replacedElementPaths . length ! = <int> ) ; } public void testRefreshUnrealizedFilteredElement ( ) throws InterruptedException { doTestRefreshUnrealizedFilteredElement ( new ViewerFilter [ ] { new TestViewerFilter ( <str> ) } ) ; } public void testRefreshUnrealizedFilteredElementWithTMVFilter ( ) throws InterruptedException { doTestRefreshUnrealizedFilteredElement ( new ViewerFilter [ ] { new TestTMVFilter ( <str> , null ) } ) ; } private void doTestRefreshUnrealizedFilteredElement ( ViewerFilter [ ] filters ) throws InterruptedException { TestModel model = new TestModel ( ) ; model . setRoot ( new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . setElementChildren ( TreePath . EMPTY , TestModel . makeSingleLevelModelElements ( model , <int> , <str> ) ) ; fViewer . setFilters ( filters ) ; fListener . setFailOnRedundantUpdates ( false ) ; fListener . reset ( ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TestElement replacedElement = new TestElement ( model , <str> , new TestElement [ <int> ] ) ; model . replaceElementChild ( TreePath . EMPTY , <int> , replacedElement ) ; fListener . reset ( ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( ) ; ( ( IInternalTreeModelViewer ) fViewer ) . reveal ( TreePath . EMPTY , <int> ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TreePath [ ] replacedElementPaths = fViewer . getElementPaths ( replacedElement ) ; assertTrue ( replacedElementPaths . length ! = <int> ) ; } public void testRefreshToUnfilterElements ( ) throws InterruptedException { doTestRefreshToUnfilterElements ( new ViewerFilter [ ] { new TestViewerFilter ( <str> ) , new TestViewerFilter ( <str> ) } ) ; } public void testRefreshToUnfilterElementsWithTMVFilter ( ) throws InterruptedException { doTestRefreshToUnfilterElements ( new ViewerFilter [ ] { new TestTMVFilter ( <str> , null ) , new TestTMVFilter ( <str> , null ) } ) ; } public void testRefreshToUnfilterElementsWithMixedFilters ( ) throws InterruptedException { doTestRefreshToUnfilterElements ( new ViewerFilter [ ] { new TestViewerFilter ( <str> ) , new TestTMVFilter ( <str> , null ) } ) ; } private void doTestRefreshToUnfilterElements ( ViewerFilter [ ] filters ) throws InterruptedException { ViewerFilter [ ] filters1 = filters ; TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setFilters ( filters ) ; fListener . setFailOnRedundantUpdates ( false ) ; fListener . reset ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } filters1 = new ViewerFilter [ <int> ] ; fViewer . setFilters ( filters1 ) ; fListener . reset ( ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , false , filters1 ) ; } public void testPreserveExpandedOnMultLevelContent ( ) throws InterruptedException { TestModel model = StateTests . alternatingSubsreesModel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; StateTests . expandAlternateElements ( fListener , model , true ) ; TreeSelection originalSelection = new TreeSelection ( new TreePath [ ] { model . findElement ( <str> ) , model . findElement ( <str> ) , model . findElement ( <str> ) } ) ; fViewer . setSelection ( originalSelection ) ; assertTrue ( StateTests . areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; ViewerFilter [ ] filters = new ViewerFilter [ ] { new TestViewerFilter ( <str> ) } ; fViewer . setFilters ( filters ) ; fListener . reset ( false , false ) ; fListener . addUpdates ( getInternalViewer ( ) , TreePath . EMPTY , model . getRootElement ( ) , filters , - <int> , ALL_UPDATES_COMPLETE ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true , filters ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( StateTests . areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; assertTrue ( fListener . checkCoalesced ( TreePath . EMPTY , <int> , <int> ) ) ; filters = new ViewerFilter [ <int> ] ; fViewer . setFilters ( filters ) ; fListener . reset ( ) ; fListener . addUpdates ( getInternalViewer ( ) , TreePath . EMPTY , model . getRootElement ( ) , filters , - <int> , ALL_UPDATES_COMPLETE ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true , filters ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = true ) ; assertTrue ( getInternalViewer ( ) . getExpandedState ( model . findElement ( <str> ) ) = = false ) ; assertTrue ( StateTests . areTreeSelectionsEqual ( originalSelection , ( ITreeSelection ) fViewer . getSelection ( ) ) ) ; } } 
