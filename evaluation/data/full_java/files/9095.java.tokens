package com . google . common . base ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . base . Preconditions . checkPositionIndex ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . annotations . VisibleForTesting ; import java . util . Arrays ; import java . util . BitSet ; import javax . annotation . CheckReturnValue ; @Beta @GwtCompatible ( emulated = true ) public abstract class CharMatcher implements Predicate < Character > { public static CharMatcher any ( ) { return Any . INSTANCE ; } public static CharMatcher none ( ) { return None . INSTANCE ; } public static CharMatcher whitespace ( ) { return Whitespace . INSTANCE ; } public static CharMatcher breakingWhitespace ( ) { return BreakingWhitespace . INSTANCE ; } public static CharMatcher ascii ( ) { return Ascii . INSTANCE ; } public static CharMatcher digit ( ) { return Digit . INSTANCE ; } public static CharMatcher javaDigit ( ) { return JavaDigit . INSTANCE ; } public static CharMatcher javaLetter ( ) { return JavaLetter . INSTANCE ; } public static CharMatcher javaLetterOrDigit ( ) { return JavaLetterOrDigit . INSTANCE ; } public static CharMatcher javaUpperCase ( ) { return JavaUpperCase . INSTANCE ; } public static CharMatcher javaLowerCase ( ) { return JavaLowerCase . INSTANCE ; } public static CharMatcher javaIsoControl ( ) { return JavaIsoControl . INSTANCE ; } public static CharMatcher invisible ( ) { return Invisible . INSTANCE ; } public static CharMatcher singleWidth ( ) { return SingleWidth . INSTANCE ; } public static final CharMatcher WHITESPACE = whitespace ( ) ; public static final CharMatcher BREAKING_WHITESPACE = breakingWhitespace ( ) ; public static final CharMatcher ASCII = ascii ( ) ; public static final CharMatcher DIGIT = digit ( ) ; public static final CharMatcher JAVA_DIGIT = javaDigit ( ) ; public static final CharMatcher JAVA_LETTER = javaLetter ( ) ; public static final CharMatcher JAVA_LETTER_OR_DIGIT = javaLetterOrDigit ( ) ; public static final CharMatcher JAVA_UPPER_CASE = javaUpperCase ( ) ; public static final CharMatcher JAVA_LOWER_CASE = javaLowerCase ( ) ; public static final CharMatcher JAVA_ISO_CONTROL = javaIsoControl ( ) ; public static final CharMatcher INVISIBLE = invisible ( ) ; public static final CharMatcher SINGLE_WIDTH = singleWidth ( ) ; public static final CharMatcher ANY = any ( ) ; public static final CharMatcher NONE = none ( ) ; public static CharMatcher is ( final char match ) { return new Is ( match ) ; } public static CharMatcher isNot ( final char match ) { return new IsNot ( match ) ; } public static CharMatcher anyOf ( final CharSequence sequence ) { switch ( sequence . length ( ) ) { case <int> : return none ( ) ; case <int> : return is ( sequence . charAt ( <int> ) ) ; case <int> : return isEither ( sequence . charAt ( <int> ) , sequence . charAt ( <int> ) ) ; default : return new AnyOf ( sequence ) ; } } public static CharMatcher noneOf ( CharSequence sequence ) { return anyOf ( sequence ) . negate ( ) ; } public static CharMatcher inRange ( final char startInclusive , final char endInclusive ) { return new InRange ( startInclusive , endInclusive ) ; } public static CharMatcher forPredicate ( final Predicate < ? super Character > predicate ) { return predicate instanceof CharMatcher ? ( CharMatcher ) predicate : new ForPredicate ( predicate ) ; } protected CharMatcher ( ) { } public abstract boolean matches ( char c ) ; public CharMatcher negate ( ) { return new Negated ( this ) ; } public CharMatcher and ( CharMatcher other ) { return new And ( this , other ) ; } public CharMatcher or ( CharMatcher other ) { return new Or ( this , other ) ; } public CharMatcher precomputed ( ) { return Platform . precomputeCharMatcher ( this ) ; } private static final int DISTINCT_CHARS = Character . MAX_VALUE - Character . MIN_VALUE + <int> ; @GwtIncompatible ( <str> ) CharMatcher precomputedInternal ( ) { final BitSet table = new BitSet ( ) ; setBits ( table ) ; int totalCharacters = table . cardinality ( ) ; if ( totalCharacters * <int> < = DISTINCT_CHARS ) { return precomputedPositive ( totalCharacters , table , toString ( ) ) ; } else { table . flip ( Character . MIN_VALUE , Character . MAX_VALUE + <int> ) ; int negatedCharacters = DISTINCT_CHARS - totalCharacters ; String suffix = <str> ; final String description = toString ( ) ; String negatedDescription = description . endsWith ( suffix ) ? description . substring ( <int> , description . length ( ) - suffix . length ( ) ) : description + suffix ; return new NegatedFastMatcher ( precomputedPositive ( negatedCharacters , table , negatedDescription ) ) { @Override public String toString ( ) { return description ; } } ; } } @GwtIncompatible ( <str> ) private static CharMatcher precomputedPositive ( int totalCharacters , BitSet table , String description ) { switch ( totalCharacters ) { case <int> : return none ( ) ; case <int> : return is ( ( char ) table . nextSetBit ( <int> ) ) ; case <int> : char c1 = ( char ) table . nextSetBit ( <int> ) ; char c2 = ( char ) table . nextSetBit ( c1 + <int> ) ; return isEither ( c1 , c2 ) ; default : return isSmall ( totalCharacters , table . length ( ) ) ? SmallCharMatcher . from ( table , description ) : new BitSetMatcher ( table , description ) ; } } @GwtIncompatible ( <str> ) private static boolean isSmall ( int totalCharacters , int tableLength ) { return totalCharacters < = SmallCharMatcher . MAX_SIZE & & tableLength > ( totalCharacters * <int> * Character . SIZE ) ; } @GwtIncompatible ( <str> ) void setBits ( BitSet table ) { for ( int c = Character . MAX_VALUE ; c > = Character . MIN_VALUE ; c - - ) { if ( matches ( ( char ) c ) ) { table . set ( c ) ; } } } public boolean matchesAnyOf ( CharSequence sequence ) { return ! matchesNoneOf ( sequence ) ; } public boolean matchesAllOf ( CharSequence sequence ) { for ( int i = sequence . length ( ) - <int> ; i > = <int> ; i - - ) { if ( ! matches ( sequence . charAt ( i ) ) ) { return false ; } } return true ; } public boolean matchesNoneOf ( CharSequence sequence ) { return indexIn ( sequence ) = = - <int> ; } public int indexIn ( CharSequence sequence ) { return indexIn ( sequence , <int> ) ; } public int indexIn ( CharSequence sequence , int start ) { int length = sequence . length ( ) ; checkPositionIndex ( start , length ) ; for ( int i = start ; i < length ; i + + ) { if ( matches ( sequence . charAt ( i ) ) ) { return i ; } } return - <int> ; } public int lastIndexIn ( CharSequence sequence ) { for ( int i = sequence . length ( ) - <int> ; i > = <int> ; i - - ) { if ( matches ( sequence . charAt ( i ) ) ) { return i ; } } return - <int> ; } public int countIn ( CharSequence sequence ) { int count = <int> ; for ( int i = <int> ; i < sequence . length ( ) ; i + + ) { if ( matches ( sequence . charAt ( i ) ) ) { count + + ; } } return count ; } @CheckReturnValue public String removeFrom ( CharSequence sequence ) { String string = sequence . toString ( ) ; int pos = indexIn ( string ) ; if ( pos = = - <int> ) { return string ; } char [ ] chars = string . toCharArray ( ) ; int spread = <int> ; OUT : while ( true ) { pos + + ; while ( true ) { if ( pos = = chars . length ) { break OUT ; } if ( matches ( chars [ pos ] ) ) { break ; } chars [ pos - spread ] = chars [ pos ] ; pos + + ; } spread + + ; } return new String ( chars , <int> , pos - spread ) ; } @CheckReturnValue public String retainFrom ( CharSequence sequence ) { return negate ( ) . removeFrom ( sequence ) ; } @CheckReturnValue public String replaceFrom ( CharSequence sequence , char replacement ) { String string = sequence . toString ( ) ; int pos = indexIn ( string ) ; if ( pos = = - <int> ) { return string ; } char [ ] chars = string . toCharArray ( ) ; chars [ pos ] = replacement ; for ( int i = pos + <int> ; i < chars . length ; i + + ) { if ( matches ( chars [ i ] ) ) { chars [ i ] = replacement ; } } return new String ( chars ) ; } @CheckReturnValue public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { int replacementLen = replacement . length ( ) ; if ( replacementLen = = <int> ) { return removeFrom ( sequence ) ; } if ( replacementLen = = <int> ) { return replaceFrom ( sequence , replacement . charAt ( <int> ) ) ; } String string = sequence . toString ( ) ; int pos = indexIn ( string ) ; if ( pos = = - <int> ) { return string ; } int len = string . length ( ) ; StringBuilder buf = new StringBuilder ( ( len * <int> / <int> ) + <int> ) ; int oldpos = <int> ; do { buf . append ( string , oldpos , pos ) ; buf . append ( replacement ) ; oldpos = pos + <int> ; pos = indexIn ( string , oldpos ) ; } while ( pos ! = - <int> ) ; buf . append ( string , oldpos , len ) ; return buf . toString ( ) ; } @CheckReturnValue public String trimFrom ( CharSequence sequence ) { int len = sequence . length ( ) ; int first ; int last ; for ( first = <int> ; first < len ; first + + ) { if ( ! matches ( sequence . charAt ( first ) ) ) { break ; } } for ( last = len - <int> ; last > first ; last - - ) { if ( ! matches ( sequence . charAt ( last ) ) ) { break ; } } return sequence . subSequence ( first , last + <int> ) . toString ( ) ; } @CheckReturnValue public String trimLeadingFrom ( CharSequence sequence ) { int len = sequence . length ( ) ; for ( int first = <int> ; first < len ; first + + ) { if ( ! matches ( sequence . charAt ( first ) ) ) { return sequence . subSequence ( first , len ) . toString ( ) ; } } return <str> ; } @CheckReturnValue public String trimTrailingFrom ( CharSequence sequence ) { int len = sequence . length ( ) ; for ( int last = len - <int> ; last > = <int> ; last - - ) { if ( ! matches ( sequence . charAt ( last ) ) ) { return sequence . subSequence ( <int> , last + <int> ) . toString ( ) ; } } return <str> ; } @CheckReturnValue public String collapseFrom ( CharSequence sequence , char replacement ) { int len = sequence . length ( ) ; for ( int i = <int> ; i < len ; i + + ) { char c = sequence . charAt ( i ) ; if ( matches ( c ) ) { if ( c = = replacement & & ( i = = len - <int> | | ! matches ( sequence . charAt ( i + <int> ) ) ) ) { i + + ; } else { StringBuilder builder = new StringBuilder ( len ) . append ( sequence . subSequence ( <int> , i ) ) . append ( replacement ) ; return finishCollapseFrom ( sequence , i + <int> , len , replacement , builder , true ) ; } } } return sequence . toString ( ) ; } @CheckReturnValue public String trimAndCollapseFrom ( CharSequence sequence , char replacement ) { int len = sequence . length ( ) ; int first = <int> ; int last = len - <int> ; while ( first < len & & matches ( sequence . charAt ( first ) ) ) { first + + ; } while ( last > first & & matches ( sequence . charAt ( last ) ) ) { last - - ; } return ( first = = <int> & & last = = len - <int> ) ? collapseFrom ( sequence , replacement ) : finishCollapseFrom ( sequence , first , last + <int> , replacement , new StringBuilder ( last + <int> - first ) , false ) ; } private String finishCollapseFrom ( CharSequence sequence , int start , int end , char replacement , StringBuilder builder , boolean inMatchingGroup ) { for ( int i = start ; i < end ; i + + ) { char c = sequence . charAt ( i ) ; if ( matches ( c ) ) { if ( ! inMatchingGroup ) { builder . append ( replacement ) ; inMatchingGroup = true ; } } else { builder . append ( c ) ; inMatchingGroup = false ; } } return builder . toString ( ) ; } @Deprecated @Override public boolean apply ( Character character ) { return matches ( character ) ; } @Override public String toString ( ) { return super . toString ( ) ; } private static String showCharacter ( char c ) { String hex = <str> ; char [ ] tmp = { <str> , <str> , <str> , <str> , <str> , <str> } ; for ( int i = <int> ; i < <int> ; i + + ) { tmp [ <int> - i ] = hex . charAt ( c & <hex> ) ; c = ( char ) ( c > > <int> ) ; } return String . copyValueOf ( tmp ) ; } abstract static class FastMatcher extends CharMatcher { @Override public final CharMatcher precomputed ( ) { return this ; } @Override public CharMatcher negate ( ) { return new NegatedFastMatcher ( this ) ; } } abstract static class NamedFastMatcher extends FastMatcher { private final String description ; NamedFastMatcher ( String description ) { this . description = checkNotNull ( description ) ; } @Override public final String toString ( ) { return description ; } } static class NegatedFastMatcher extends Negated { NegatedFastMatcher ( CharMatcher original ) { super ( original ) ; } @Override public final CharMatcher precomputed ( ) { return this ; } } @GwtIncompatible ( <str> ) private static final class BitSetMatcher extends NamedFastMatcher { private final BitSet table ; private BitSetMatcher ( BitSet table , String description ) { super ( description ) ; if ( table . length ( ) + Long . SIZE < table . size ( ) ) { table = ( BitSet ) table . clone ( ) ; } this . table = table ; } @Override public boolean matches ( char c ) { return table . get ( c ) ; } @Override void setBits ( BitSet bitSet ) { bitSet . or ( table ) ; } } private static final class Any extends NamedFastMatcher { static final Any INSTANCE = new Any ( ) ; private Any ( ) { super ( <str> ) ; } @Override public boolean matches ( char c ) { return true ; } @Override public int indexIn ( CharSequence sequence ) { return ( sequence . length ( ) = = <int> ) ? - <int> : <int> ; } @Override public int indexIn ( CharSequence sequence , int start ) { int length = sequence . length ( ) ; checkPositionIndex ( start , length ) ; return ( start = = length ) ? - <int> : start ; } @Override public int lastIndexIn ( CharSequence sequence ) { return sequence . length ( ) - <int> ; } @Override public boolean matchesAllOf ( CharSequence sequence ) { checkNotNull ( sequence ) ; return true ; } @Override public boolean matchesNoneOf ( CharSequence sequence ) { return sequence . length ( ) = = <int> ; } @Override public String removeFrom ( CharSequence sequence ) { checkNotNull ( sequence ) ; return <str> ; } @Override public String replaceFrom ( CharSequence sequence , char replacement ) { char [ ] array = new char [ sequence . length ( ) ] ; Arrays . fill ( array , replacement ) ; return new String ( array ) ; } @Override public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { StringBuilder result = new StringBuilder ( sequence . length ( ) * replacement . length ( ) ) ; for ( int i = <int> ; i < sequence . length ( ) ; i + + ) { result . append ( replacement ) ; } return result . toString ( ) ; } @Override public String collapseFrom ( CharSequence sequence , char replacement ) { return ( sequence . length ( ) = = <int> ) ? <str> : String . valueOf ( replacement ) ; } @Override public String trimFrom ( CharSequence sequence ) { checkNotNull ( sequence ) ; return <str> ; } @Override public int countIn ( CharSequence sequence ) { return sequence . length ( ) ; } @Override public CharMatcher and ( CharMatcher other ) { return checkNotNull ( other ) ; } @Override public CharMatcher or ( CharMatcher other ) { checkNotNull ( other ) ; return this ; } @Override public CharMatcher negate ( ) { return none ( ) ; } } private static final class None extends NamedFastMatcher { static final None INSTANCE = new None ( ) ; private None ( ) { super ( <str> ) ; } @Override public boolean matches ( char c ) { return false ; } @Override public int indexIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return - <int> ; } @Override public int indexIn ( CharSequence sequence , int start ) { int length = sequence . length ( ) ; checkPositionIndex ( start , length ) ; return - <int> ; } @Override public int lastIndexIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return - <int> ; } @Override public boolean matchesAllOf ( CharSequence sequence ) { return sequence . length ( ) = = <int> ; } @Override public boolean matchesNoneOf ( CharSequence sequence ) { checkNotNull ( sequence ) ; return true ; } @Override public String removeFrom ( CharSequence sequence ) { return sequence . toString ( ) ; } @Override public String replaceFrom ( CharSequence sequence , char replacement ) { return sequence . toString ( ) ; } @Override public String replaceFrom ( CharSequence sequence , CharSequence replacement ) { checkNotNull ( replacement ) ; return sequence . toString ( ) ; } @Override public String collapseFrom ( CharSequence sequence , char replacement ) { return sequence . toString ( ) ; } @Override public String trimFrom ( CharSequence sequence ) { return sequence . toString ( ) ; } @Override public String trimLeadingFrom ( CharSequence sequence ) { return sequence . toString ( ) ; } @Override public String trimTrailingFrom ( CharSequence sequence ) { return sequence . toString ( ) ; } @Override public int countIn ( CharSequence sequence ) { checkNotNull ( sequence ) ; return <int> ; } @Override public CharMatcher and ( CharMatcher other ) { checkNotNull ( other ) ; return this ; } @Override public CharMatcher or ( CharMatcher other ) { return checkNotNull ( other ) ; } @Override public CharMatcher negate ( ) { return any ( ) ; } } @VisibleForTesting static final class Whitespace extends NamedFastMatcher { static final String TABLE = <str> + <str> + <str> + <str> ; static final int MULTIPLIER = <int> ; static final int SHIFT = Integer . numberOfLeadingZeros ( TABLE . length ( ) - <int> ) ; static final Whitespace INSTANCE = new Whitespace ( ) ; Whitespace ( ) { super ( <str> ) ; } @Override public boolean matches ( char c ) { return TABLE . charAt ( ( MULTIPLIER * c ) > > > SHIFT ) = = c ; } @GwtIncompatible ( <str> ) @Override void setBits ( BitSet table ) { for ( int i = <int> ; i < TABLE . length ( ) ; i + + ) { table . set ( TABLE . charAt ( i ) ) ; } } } private static final class BreakingWhitespace extends CharMatcher { static final CharMatcher INSTANCE = new BreakingWhitespace ( ) ; @Override public boolean matches ( char c ) { switch ( c ) { case <str> : case <str> : case <oct> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : case <str> : return true ; case <str> : return false ; default : return c > = <str> & & c < = <str> ; } } @Override public String toString ( ) { return <str> ; } } private static final class Ascii extends NamedFastMatcher { static final Ascii INSTANCE = new Ascii ( ) ; Ascii ( ) { super ( <str> ) ; } @Override public boolean matches ( char c ) { return c < = <str> ; } } private static class RangesMatcher extends CharMatcher { private final String description ; private final char [ ] rangeStarts ; private final char [ ] rangeEnds ; RangesMatcher ( String description , char [ ] rangeStarts , char [ ] rangeEnds ) { this . description = description ; this . rangeStarts = rangeStarts ; this . rangeEnds = rangeEnds ; checkArgument ( rangeStarts . length = = rangeEnds . length ) ; for ( int i = <int> ; i < rangeStarts . length ; i + + ) { checkArgument ( rangeStarts [ i ] < = rangeEnds [ i ] ) ; if ( i + <int> < rangeStarts . length ) { checkArgument ( rangeEnds [ i ] < rangeStarts [ i + <int> ] ) ; } } } @Override public boolean matches ( char c ) { int index = Arrays . binarySearch ( rangeStarts , c ) ; if ( index > = <int> ) { return true ; } else { index = ~ index - <int> ; return index > = <int> & & c < = rangeEnds [ index ] ; } } @Override public String toString ( ) { return description ; } } private static final class Digit extends RangesMatcher { private static final String ZEROES = <str> + <str> + <str> ; private static char [ ] zeroes ( ) { return ZEROES . toCharArray ( ) ; } private static char [ ] nines ( ) { char [ ] nines = new char [ ZEROES . length ( ) ] ; for ( int i = <int> ; i < ZEROES . length ( ) ; i + + ) { nines [ i ] = ( char ) ( ZEROES . charAt ( i ) + <int> ) ; } return nines ; } static final Digit INSTANCE = new Digit ( ) ; private Digit ( ) { super ( <str> , zeroes ( ) , nines ( ) ) ; } } private static final class JavaDigit extends CharMatcher { static final JavaDigit INSTANCE = new JavaDigit ( ) ; @Override public boolean matches ( char c ) { return Character . isDigit ( c ) ; } @Override public String toString ( ) { return <str> ; } } private static final class JavaLetter extends CharMatcher { static final JavaLetter INSTANCE = new JavaLetter ( ) ; @Override public boolean matches ( char c ) { return Character . isLetter ( c ) ; } @Override public String toString ( ) { return <str> ; } } private static final class JavaLetterOrDigit extends CharMatcher { static final JavaLetterOrDigit INSTANCE = new JavaLetterOrDigit ( ) ; @Override public boolean matches ( char c ) { return Character . isLetterOrDigit ( c ) ; } @Override public String toString ( ) { return <str> ; } } private static final class JavaUpperCase extends CharMatcher { static final JavaUpperCase INSTANCE = new JavaUpperCase ( ) ; @Override public boolean matches ( char c ) { return Character . isUpperCase ( c ) ; } @Override public String toString ( ) { return <str> ; } } private static final class JavaLowerCase extends CharMatcher { static final JavaLowerCase INSTANCE = new JavaLowerCase ( ) ; @Override public boolean matches ( char c ) { return Character . isLowerCase ( c ) ; } @Override public String toString ( ) { return <str> ; } } private static final class JavaIsoControl extends NamedFastMatcher { static final JavaIsoControl INSTANCE = new JavaIsoControl ( ) ; private JavaIsoControl ( ) { super ( <str> ) ; } @Override public boolean matches ( char c ) { return c < = <str> | | ( c > = <str> & & c < = <str> ) ; } } private static final class Invisible extends RangesMatcher { private static final String RANGE_STARTS = <str> + <str> ; private static final String RANGE_ENDS = <str> + <str> ; static final Invisible INSTANCE = new Invisible ( ) ; private Invisible ( ) { super ( <str> , RANGE_STARTS . toCharArray ( ) , RANGE_ENDS . toCharArray ( ) ) ; } } private static final class SingleWidth extends RangesMatcher { static final SingleWidth INSTANCE = new SingleWidth ( ) ; private SingleWidth ( ) { super ( <str> , <str> . toCharArray ( ) , <str> . toCharArray ( ) ) ; } } private static class Negated extends CharMatcher { final CharMatcher original ; Negated ( CharMatcher original ) { this . original = checkNotNull ( original ) ; } @Override public boolean matches ( char c ) { return ! original . matches ( c ) ; } @Override public boolean matchesAllOf ( CharSequence sequence ) { return original . matchesNoneOf ( sequence ) ; } @Override public boolean matchesNoneOf ( CharSequence sequence ) { return original . matchesAllOf ( sequence ) ; } @Override public int countIn ( CharSequence sequence ) { return sequence . length ( ) - original . countIn ( sequence ) ; } @GwtIncompatible ( <str> ) @Override void setBits ( BitSet table ) { BitSet tmp = new BitSet ( ) ; original . setBits ( tmp ) ; tmp . flip ( Character . MIN_VALUE , Character . MAX_VALUE + <int> ) ; table . or ( tmp ) ; } @Override public CharMatcher negate ( ) { return original ; } @Override public String toString ( ) { return original + <str> ; } } private static final class And extends CharMatcher { final CharMatcher first ; final CharMatcher second ; And ( CharMatcher a , CharMatcher b ) { first = checkNotNull ( a ) ; second = checkNotNull ( b ) ; } @Override public boolean matches ( char c ) { return first . matches ( c ) & & second . matches ( c ) ; } @GwtIncompatible ( <str> ) @Override void setBits ( BitSet table ) { BitSet tmp1 = new BitSet ( ) ; first . setBits ( tmp1 ) ; BitSet tmp2 = new BitSet ( ) ; second . setBits ( tmp2 ) ; tmp1 . and ( tmp2 ) ; table . or ( tmp1 ) ; } @Override public String toString ( ) { return <str> + first + <str> + second + <str> ; } } private static final class Or extends CharMatcher { final CharMatcher first ; final CharMatcher second ; Or ( CharMatcher a , CharMatcher b ) { first = checkNotNull ( a ) ; second = checkNotNull ( b ) ; } @GwtIncompatible ( <str> ) @Override void setBits ( BitSet table ) { first . setBits ( table ) ; second . setBits ( table ) ; } @Override public boolean matches ( char c ) { return first . matches ( c ) | | second . matches ( c ) ; } @Override public String toString ( ) { return <str> + first + <str> + second + <str> ; } } private static final class Is extends FastMatcher { private final char match ; Is ( char match ) { this . match = match ; } @Override public boolean matches ( char c ) { return c = = match ; } @Override public String replaceFrom ( CharSequence sequence , char replacement ) { return sequence . toString ( ) . replace ( match , replacement ) ; } @Override public CharMatcher and ( CharMatcher other ) { return other . matches ( match ) ? this : none ( ) ; } @Override public CharMatcher or ( CharMatcher other ) { return other . matches ( match ) ? other : super . or ( other ) ; } @Override public CharMatcher negate ( ) { return isNot ( match ) ; } @GwtIncompatible ( <str> ) @Override void setBits ( BitSet table ) { table . set ( match ) ; } @Override public String toString ( ) { return <str> + showCharacter ( match ) + <str> ; } } private static final class IsNot extends FastMatcher { private final char match ; IsNot ( char match ) { this . match = match ; } @Override public boolean matches ( char c ) { return c ! = match ; } @Override public CharMatcher and ( CharMatcher other ) { return other . matches ( match ) ? super . and ( other ) : other ; } @Override public CharMatcher or ( CharMatcher other ) { return other . matches ( match ) ? any ( ) : this ; } @GwtIncompatible ( <str> ) @Override void setBits ( BitSet table ) { table . set ( <int> , match ) ; table . set ( match + <int> , Character . MAX_VALUE + <int> ) ; } @Override public CharMatcher negate ( ) { return is ( match ) ; } @Override public String toString ( ) { return <str> + showCharacter ( match ) + <str> ; } } private static CharMatcher . IsEither isEither ( char c1 , char c2 ) { return new CharMatcher . IsEither ( c1 , c2 ) ; } private static final class IsEither extends FastMatcher { private final char match1 ; private final char match2 ; IsEither ( char match1 , char match2 ) { this . match1 = match1 ; this . match2 = match2 ; } @Override public boolean matches ( char c ) { return c = = match1 | | c = = match2 ; } @GwtIncompatible ( <str> ) @Override void setBits ( BitSet table ) { table . set ( match1 ) ; table . set ( match2 ) ; } @Override public String toString ( ) { return <str> + showCharacter ( match1 ) + showCharacter ( match2 ) + <str> ; } } private static final class AnyOf extends CharMatcher { private final char [ ] chars ; public AnyOf ( CharSequence chars ) { this . chars = chars . toString ( ) . toCharArray ( ) ; Arrays . sort ( this . chars ) ; } @Override public boolean matches ( char c ) { return Arrays . binarySearch ( chars , c ) > = <int> ; } @Override @GwtIncompatible ( <str> ) void setBits ( BitSet table ) { for ( char c : chars ) { table . set ( c ) ; } } @Override public String toString ( ) { StringBuilder description = new StringBuilder ( <str> ) ; for ( char c : chars ) { description . append ( showCharacter ( c ) ) ; } description . append ( <str> ) ; return description . toString ( ) ; } } private static final class InRange extends FastMatcher { private final char startInclusive ; private final char endInclusive ; InRange ( char startInclusive , char endInclusive ) { checkArgument ( endInclusive > = startInclusive ) ; this . startInclusive = startInclusive ; this . endInclusive = endInclusive ; } @Override public boolean matches ( char c ) { return startInclusive < = c & & c < = endInclusive ; } @GwtIncompatible ( <str> ) @Override void setBits ( BitSet table ) { table . set ( startInclusive , endInclusive + <int> ) ; } @Override public String toString ( ) { return <str> + showCharacter ( startInclusive ) + <str> + showCharacter ( endInclusive ) + <str> ; } } private static final class ForPredicate extends CharMatcher { private final Predicate < ? super Character > predicate ; ForPredicate ( Predicate < ? super Character > predicate ) { this . predicate = checkNotNull ( predicate ) ; } @Override public boolean matches ( char c ) { return predicate . apply ( c ) ; } @SuppressWarnings ( <str> ) @Override public boolean apply ( Character character ) { return predicate . apply ( checkNotNull ( character ) ) ; } @Override public String toString ( ) { return <str> + predicate + <str> ; } } } 
