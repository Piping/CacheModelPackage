package clojure . asm . commons ; import clojure . asm . Handle ; import clojure . asm . Label ; import clojure . asm . MethodVisitor ; import clojure . asm . Opcodes ; public class CodeSizeEvaluator extends MethodVisitor implements Opcodes { private int minSize ; private int maxSize ; public CodeSizeEvaluator ( final MethodVisitor mv ) { this ( Opcodes . ASM4 , mv ) ; } protected CodeSizeEvaluator ( final int api , final MethodVisitor mv ) { super ( api , mv ) ; } public int getMinSize ( ) { return this . minSize ; } public int getMaxSize ( ) { return this . maxSize ; } @Override public void visitInsn ( final int opcode ) { minSize + = <int> ; maxSize + = <int> ; if ( mv ! = null ) { mv . visitInsn ( opcode ) ; } } @Override public void visitIntInsn ( final int opcode , final int operand ) { if ( opcode = = SIPUSH ) { minSize + = <int> ; maxSize + = <int> ; } else { minSize + = <int> ; maxSize + = <int> ; } if ( mv ! = null ) { mv . visitIntInsn ( opcode , operand ) ; } } @Override public void visitVarInsn ( final int opcode , final int var ) { if ( var < <int> & & opcode ! = RET ) { minSize + = <int> ; maxSize + = <int> ; } else if ( var > = <int> ) { minSize + = <int> ; maxSize + = <int> ; } else { minSize + = <int> ; maxSize + = <int> ; } if ( mv ! = null ) { mv . visitVarInsn ( opcode , var ) ; } } @Override public void visitTypeInsn ( final int opcode , final String type ) { minSize + = <int> ; maxSize + = <int> ; if ( mv ! = null ) { mv . visitTypeInsn ( opcode , type ) ; } } @Override public void visitFieldInsn ( final int opcode , final String owner , final String name , final String desc ) { minSize + = <int> ; maxSize + = <int> ; if ( mv ! = null ) { mv . visitFieldInsn ( opcode , owner , name , desc ) ; } } @Override public void visitMethodInsn ( final int opcode , final String owner , final String name , final String desc ) { if ( opcode = = INVOKEINTERFACE ) { minSize + = <int> ; maxSize + = <int> ; } else { minSize + = <int> ; maxSize + = <int> ; } if ( mv ! = null ) { mv . visitMethodInsn ( opcode , owner , name , desc ) ; } } @Override public void visitInvokeDynamicInsn ( String name , String desc , Handle bsm , Object . . . bsmArgs ) { minSize + = <int> ; maxSize + = <int> ; if ( mv ! = null ) { mv . visitInvokeDynamicInsn ( name , desc , bsm , bsmArgs ) ; } } @Override public void visitJumpInsn ( final int opcode , final Label label ) { minSize + = <int> ; if ( opcode = = GOTO | | opcode = = JSR ) { maxSize + = <int> ; } else { maxSize + = <int> ; } if ( mv ! = null ) { mv . visitJumpInsn ( opcode , label ) ; } } @Override public void visitLdcInsn ( final Object cst ) { if ( cst instanceof Long | | cst instanceof Double ) { minSize + = <int> ; maxSize + = <int> ; } else { minSize + = <int> ; maxSize + = <int> ; } if ( mv ! = null ) { mv . visitLdcInsn ( cst ) ; } } @Override public void visitIincInsn ( final int var , final int increment ) { if ( var > <int> | | increment > <int> | | increment < - <int> ) { minSize + = <int> ; maxSize + = <int> ; } else { minSize + = <int> ; maxSize + = <int> ; } if ( mv ! = null ) { mv . visitIincInsn ( var , increment ) ; } } @Override public void visitTableSwitchInsn ( final int min , final int max , final Label dflt , final Label . . . labels ) { minSize + = <int> + labels . length * <int> ; maxSize + = <int> + labels . length * <int> ; if ( mv ! = null ) { mv . visitTableSwitchInsn ( min , max , dflt , labels ) ; } } @Override public void visitLookupSwitchInsn ( final Label dflt , final int [ ] keys , final Label [ ] labels ) { minSize + = <int> + keys . length * <int> ; maxSize + = <int> + keys . length * <int> ; if ( mv ! = null ) { mv . visitLookupSwitchInsn ( dflt , keys , labels ) ; } } @Override public void visitMultiANewArrayInsn ( final String desc , final int dims ) { minSize + = <int> ; maxSize + = <int> ; if ( mv ! = null ) { mv . visitMultiANewArrayInsn ( desc , dims ) ; } } } 
