package org . apache . cassandra . db . marshal ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import org . apache . cassandra . cql3 . Term ; import org . apache . cassandra . serializers . TypeSerializer ; import org . apache . cassandra . serializers . BytesSerializer ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class AbstractCompositeType extends AbstractType < ByteBuffer > { protected AbstractCompositeType ( ) { super ( ComparisonType . CUSTOM ) ; } public int compareCustom ( ByteBuffer o1 , ByteBuffer o2 ) { if ( ! o1 . hasRemaining ( ) | | ! o2 . hasRemaining ( ) ) return o1 . hasRemaining ( ) ? <int> : o2 . hasRemaining ( ) ? - <int> : <int> ; ByteBuffer bb1 = o1 . duplicate ( ) ; ByteBuffer bb2 = o2 . duplicate ( ) ; boolean isStatic1 = readIsStatic ( bb1 ) ; boolean isStatic2 = readIsStatic ( bb2 ) ; if ( isStatic1 ! = isStatic2 ) return isStatic1 ? - <int> : <int> ; int i = <int> ; ByteBuffer previous = null ; while ( bb1 . remaining ( ) > <int> & & bb2 . remaining ( ) > <int> ) { AbstractType < ? > comparator = getComparator ( i , bb1 , bb2 ) ; ByteBuffer value1 = ByteBufferUtil . readBytesWithShortLength ( bb1 ) ; ByteBuffer value2 = ByteBufferUtil . readBytesWithShortLength ( bb2 ) ; int cmp = comparator . compareCollectionMembers ( value1 , value2 , previous ) ; if ( cmp ! = <int> ) return cmp ; previous = value1 ; byte b1 = bb1 . get ( ) ; byte b2 = bb2 . get ( ) ; if ( b1 ! = b2 ) return b1 - b2 ; + + i ; } if ( bb1 . remaining ( ) = = <int> ) return bb2 . remaining ( ) = = <int> ? <int> : - <int> ; return <int> ; } protected abstract boolean readIsStatic ( ByteBuffer bb ) ; public ByteBuffer [ ] split ( ByteBuffer name ) { List < ByteBuffer > l = new ArrayList < ByteBuffer > ( ) ; ByteBuffer bb = name . duplicate ( ) ; readIsStatic ( bb ) ; int i = <int> ; while ( bb . remaining ( ) > <int> ) { getComparator ( i + + , bb ) ; l . add ( ByteBufferUtil . readBytesWithShortLength ( bb ) ) ; bb . get ( ) ; } return l . toArray ( new ByteBuffer [ l . size ( ) ] ) ; } public static String escape ( String input ) { if ( input . isEmpty ( ) ) return input ; String res = input . replaceAll ( <str> , <str> ) ; char last = res . charAt ( res . length ( ) - <int> ) ; return last = = <str> | | last = = <str> ? res + <str> : res ; } static String unescape ( String input ) { if ( input . isEmpty ( ) ) return input ; String res = input . replaceAll ( <str> , <str> ) ; char last = res . charAt ( res . length ( ) - <int> ) ; return last = = <str> ? res . substring ( <int> , res . length ( ) - <int> ) : res ; } static List < String > split ( String input ) { if ( input . isEmpty ( ) ) return Collections . < String > emptyList ( ) ; List < String > res = new ArrayList < String > ( ) ; int prev = <int> ; for ( int i = <int> ; i < input . length ( ) ; i + + ) { if ( input . charAt ( i ) ! = <str> | | ( i > <int> & & input . charAt ( i - <int> ) = = <str> ) ) continue ; res . add ( input . substring ( prev , i ) ) ; prev = i + <int> ; } res . add ( input . substring ( prev , input . length ( ) ) ) ; return res ; } public String getString ( ByteBuffer bytes ) { StringBuilder sb = new StringBuilder ( ) ; ByteBuffer bb = bytes . duplicate ( ) ; readIsStatic ( bb ) ; int i = <int> ; while ( bb . remaining ( ) > <int> ) { if ( bb . remaining ( ) ! = bytes . remaining ( ) ) sb . append ( <str> ) ; AbstractType < ? > comparator = getAndAppendComparator ( i , bb , sb ) ; ByteBuffer value = ByteBufferUtil . readBytesWithShortLength ( bb ) ; sb . append ( escape ( comparator . getString ( value ) ) ) ; byte b = bb . get ( ) ; if ( b ! = <int> ) { sb . append ( b < <int> ? <str> : <str> ) ; break ; } + + i ; } return sb . toString ( ) ; } public ByteBuffer fromString ( String source ) { List < String > parts = split ( source ) ; List < ByteBuffer > components = new ArrayList < ByteBuffer > ( parts . size ( ) ) ; List < ParsedComparator > comparators = new ArrayList < ParsedComparator > ( parts . size ( ) ) ; int totalLength = <int> , i = <int> ; boolean lastByteIsOne = false ; boolean lastByteIsMinusOne = false ; for ( String part : parts ) { if ( part . equals ( <str> ) ) { lastByteIsOne = true ; break ; } else if ( part . equals ( <str> ) ) { lastByteIsMinusOne = true ; break ; } ParsedComparator p = parseComparator ( i , part ) ; AbstractType < ? > type = p . getAbstractType ( ) ; part = p . getRemainingPart ( ) ; ByteBuffer component = type . fromString ( unescape ( part ) ) ; totalLength + = p . getComparatorSerializedSize ( ) + <int> + component . remaining ( ) + <int> ; components . add ( component ) ; comparators . add ( p ) ; + + i ; } ByteBuffer bb = ByteBuffer . allocate ( totalLength ) ; i = <int> ; for ( ByteBuffer component : components ) { comparators . get ( i ) . serializeComparator ( bb ) ; ByteBufferUtil . writeShortLength ( bb , component . remaining ( ) ) ; bb . put ( component ) ; bb . put ( ( byte ) <int> ) ; + + i ; } if ( lastByteIsOne ) bb . put ( bb . limit ( ) - <int> , ( byte ) <int> ) ; else if ( lastByteIsMinusOne ) bb . put ( bb . limit ( ) - <int> , ( byte ) - <int> ) ; bb . rewind ( ) ; return bb ; } @Override public Term fromJSONObject ( Object parsed ) { throw new UnsupportedOperationException ( ) ; } @Override public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { throw new UnsupportedOperationException ( ) ; } @Override public void validate ( ByteBuffer bytes ) throws MarshalException { ByteBuffer bb = bytes . duplicate ( ) ; readIsStatic ( bb ) ; int i = <int> ; ByteBuffer previous = null ; while ( bb . remaining ( ) > <int> ) { AbstractType < ? > comparator = validateComparator ( i , bb ) ; if ( bb . remaining ( ) < <int> ) throw new MarshalException ( <str> + i ) ; int length = ByteBufferUtil . readShortLength ( bb ) ; if ( bb . remaining ( ) < length ) throw new MarshalException ( <str> + i ) ; ByteBuffer value = ByteBufferUtil . readBytes ( bb , length ) ; comparator . validateCollectionMember ( value , previous ) ; if ( bb . remaining ( ) = = <int> ) throw new MarshalException ( <str> + i ) ; byte b = bb . get ( ) ; if ( b ! = <int> & & bb . remaining ( ) ! = <int> ) throw new MarshalException ( <str> + i ) ; previous = value ; + + i ; } } public abstract ByteBuffer decompose ( Object . . . objects ) ; public TypeSerializer < ByteBuffer > getSerializer ( ) { return BytesSerializer . instance ; } abstract protected AbstractType < ? > getComparator ( int i , ByteBuffer bb ) ; abstract protected AbstractType < ? > getComparator ( int i , ByteBuffer bb1 , ByteBuffer bb2 ) ; abstract protected AbstractType < ? > getAndAppendComparator ( int i , ByteBuffer bb , StringBuilder sb ) ; abstract protected AbstractType < ? > validateComparator ( int i , ByteBuffer bb ) throws MarshalException ; abstract protected ParsedComparator parseComparator ( int i , String part ) ; protected static interface ParsedComparator { AbstractType < ? > getAbstractType ( ) ; String getRemainingPart ( ) ; int getComparatorSerializedSize ( ) ; void serializeComparator ( ByteBuffer bb ) ; } } 
