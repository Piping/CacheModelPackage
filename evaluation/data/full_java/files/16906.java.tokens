package java . io ; import java . nio . CharBuffer ; import java . nio . ReadOnlyBufferException ; public abstract class Reader implements Readable , Closeable { protected Object lock ; protected Reader ( ) { super ( ) ; lock = this ; } protected Reader ( Object lock ) { if ( lock = = null ) { throw new NullPointerException ( ) ; } this . lock = lock ; } public abstract void close ( ) throws IOException ; public void mark ( int readLimit ) throws IOException { throw new IOException ( ) ; } public boolean markSupported ( ) { return false ; } public int read ( ) throws IOException { synchronized ( lock ) { char charArray [ ] = new char [ <int> ] ; if ( read ( charArray , <int> , <int> ) ! = - <int> ) { return charArray [ <int> ] ; } return - <int> ; } } public int read ( char buf [ ] ) throws IOException { return read ( buf , <int> , buf . length ) ; } public abstract int read ( char buf [ ] , int offset , int count ) throws IOException ; public boolean ready ( ) throws IOException { return false ; } public void reset ( ) throws IOException { throw new IOException ( ) ; } public long skip ( long count ) throws IOException { if ( count < <int> ) { throw new IllegalArgumentException ( ) ; } synchronized ( lock ) { long skipped = <int> ; int toRead = count < <int> ? ( int ) count : <int> ; char charsSkipped [ ] = new char [ toRead ] ; while ( skipped < count ) { int read = read ( charsSkipped , <int> , toRead ) ; if ( read = = - <int> ) { return skipped ; } skipped + = read ; if ( read < toRead ) { return skipped ; } if ( count - skipped < toRead ) { toRead = ( int ) ( count - skipped ) ; } } return skipped ; } } public int read ( CharBuffer target ) throws IOException { if ( null = = target ) { throw new NullPointerException ( ) ; } int length = target . length ( ) ; char [ ] buf = new char [ length ] ; length = Math . min ( length , read ( buf ) ) ; if ( length > <int> ) { target . put ( buf , <int> , length ) ; } return length ; } } 
