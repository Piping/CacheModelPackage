package org . gradle . api . internal . artifacts . dsl . dependencies ; import groovy . lang . Closure ; import groovy . lang . GroovyObjectSupport ; import groovy . lang . MissingMethodException ; import org . gradle . api . Action ; import org . gradle . api . artifacts . Configuration ; import org . gradle . api . artifacts . ConfigurationContainer ; import org . gradle . api . artifacts . Dependency ; import org . gradle . api . artifacts . dsl . ComponentMetadataHandler ; import org . gradle . api . artifacts . dsl . ComponentModuleMetadataHandler ; import org . gradle . api . artifacts . dsl . DependencyHandler ; import org . gradle . api . artifacts . query . ArtifactResolutionQuery ; import org . gradle . api . internal . artifacts . query . ArtifactResolutionQueryFactory ; import org . gradle . util . CollectionUtils ; import org . gradle . util . ConfigureUtil ; import java . util . List ; import java . util . Map ; public class DefaultDependencyHandler extends GroovyObjectSupport implements DependencyHandler { private final ConfigurationContainer configurationContainer ; private final DependencyFactory dependencyFactory ; private final ProjectFinder projectFinder ; private final ComponentMetadataHandler componentMetadataHandler ; private final ComponentModuleMetadataHandler componentModuleMetadataHandler ; private final ArtifactResolutionQueryFactory resolutionQueryFactory ; public DefaultDependencyHandler ( ConfigurationContainer configurationContainer , DependencyFactory dependencyFactory , ProjectFinder projectFinder , ComponentMetadataHandler componentMetadataHandler , ComponentModuleMetadataHandler componentModuleMetadataHandler , ArtifactResolutionQueryFactory resolutionQueryFactory ) { this . configurationContainer = configurationContainer ; this . dependencyFactory = dependencyFactory ; this . projectFinder = projectFinder ; this . componentMetadataHandler = componentMetadataHandler ; this . componentModuleMetadataHandler = componentModuleMetadataHandler ; this . resolutionQueryFactory = resolutionQueryFactory ; } public Dependency add ( String configurationName , Object dependencyNotation ) { return add ( configurationName , dependencyNotation , null ) ; } public Dependency add ( String configurationName , Object dependencyNotation , Closure configureClosure ) { return doAdd ( configurationContainer . findByName ( configurationName ) , dependencyNotation , configureClosure ) ; } public Dependency create ( Object dependencyNotation ) { return create ( dependencyNotation , null ) ; } public Dependency create ( Object dependencyNotation , Closure configureClosure ) { Dependency dependency = dependencyFactory . createDependency ( dependencyNotation ) ; return ConfigureUtil . configure ( configureClosure , dependency ) ; } private Dependency doAdd ( Configuration configuration , Object dependencyNotation , Closure configureClosure ) { if ( dependencyNotation instanceof Configuration ) { Configuration other = ( Configuration ) dependencyNotation ; if ( ! configurationContainer . contains ( other ) ) { throw new UnsupportedOperationException ( <str> ) ; } configuration . extendsFrom ( other ) ; return null ; } Dependency dependency = create ( dependencyNotation , configureClosure ) ; configuration . getDependencies ( ) . add ( dependency ) ; return dependency ; } public Dependency module ( Object notation ) { return module ( notation , null ) ; } public Dependency project ( Map < String , ? > notation ) { return dependencyFactory . createProjectDependencyFromMap ( projectFinder , notation ) ; } public Dependency module ( Object notation , Closure configureClosure ) { return dependencyFactory . createModule ( notation , configureClosure ) ; } public Dependency gradleApi ( ) { return dependencyFactory . createDependency ( DependencyFactory . ClassPathNotation . GRADLE_API ) ; } public Dependency gradleTestKit ( ) { return dependencyFactory . createDependency ( DependencyFactory . ClassPathNotation . GRADLE_TEST_KIT ) ; } public Dependency localGroovy ( ) { return dependencyFactory . createDependency ( DependencyFactory . ClassPathNotation . LOCAL_GROOVY ) ; } public Object methodMissing ( String name , Object args ) { Object [ ] argsArray = ( Object [ ] ) args ; Configuration configuration = configurationContainer . findByName ( name ) ; if ( configuration = = null ) { throw new MissingMethodException ( name , this . getClass ( ) , argsArray ) ; } List < ? > normalizedArgs = CollectionUtils . flattenCollections ( argsArray ) ; if ( normalizedArgs . size ( ) = = <int> & & normalizedArgs . get ( <int> ) instanceof Closure ) { return doAdd ( configuration , normalizedArgs . get ( <int> ) , ( Closure ) normalizedArgs . get ( <int> ) ) ; } else if ( normalizedArgs . size ( ) = = <int> ) { return doAdd ( configuration , normalizedArgs . get ( <int> ) , null ) ; } else { for ( Object arg : normalizedArgs ) { doAdd ( configuration , arg , null ) ; } return null ; } } public void components ( Action < ? super ComponentMetadataHandler > configureAction ) { configureAction . execute ( getComponents ( ) ) ; } public ComponentMetadataHandler getComponents ( ) { return componentMetadataHandler ; } public void modules ( Action < ? super ComponentModuleMetadataHandler > configureAction ) { configureAction . execute ( getModules ( ) ) ; } public ComponentModuleMetadataHandler getModules ( ) { return componentModuleMetadataHandler ; } public ArtifactResolutionQuery createArtifactResolutionQuery ( ) { return resolutionQueryFactory . createArtifactResolutionQuery ( ) ; } } 
