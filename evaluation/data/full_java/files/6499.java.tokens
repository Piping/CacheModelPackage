package org . elasticsearch . index . fielddata . plain ; import org . apache . lucene . index . BinaryDocValues ; import org . apache . lucene . util . Accountable ; import org . apache . lucene . util . ArrayUtil ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . RamUsageEstimator ; import org . elasticsearch . common . geo . GeoPoint ; import org . elasticsearch . common . util . ByteUtils ; import org . elasticsearch . index . fielddata . MultiGeoPointValues ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; final class GeoPointLegacyDVAtomicFieldData extends AbstractAtomicGeoPointFieldData { private static final int COORDINATE_SIZE = <int> ; private static final int GEOPOINT_SIZE = COORDINATE_SIZE * <int> ; private final BinaryDocValues values ; GeoPointLegacyDVAtomicFieldData ( BinaryDocValues values ) { super ( ) ; this . values = values ; } @Override public long ramBytesUsed ( ) { return <int> ; } @Override public Collection < Accountable > getChildResources ( ) { return Collections . emptyList ( ) ; } @Override public void close ( ) { } @Override public MultiGeoPointValues getGeoPointValues ( ) { return new MultiGeoPointValues ( ) { int count ; GeoPoint [ ] points = new GeoPoint [ <int> ] ; @Override public void setDocument ( int docId ) { final BytesRef bytes = values . get ( docId ) ; assert bytes . length % GEOPOINT_SIZE = = <int> ; count = ( bytes . length > > > <int> ) ; if ( count > points . length ) { final int previousLength = points . length ; points = Arrays . copyOf ( points , ArrayUtil . oversize ( count , RamUsageEstimator . NUM_BYTES_OBJECT_REF ) ) ; for ( int i = previousLength ; i < points . length ; + + i ) { points [ i ] = new GeoPoint ( Double . NaN , Double . NaN ) ; } } for ( int i = <int> ; i < count ; + + i ) { final double lat = ByteUtils . readDoubleLE ( bytes . bytes , bytes . offset + i * GEOPOINT_SIZE ) ; final double lon = ByteUtils . readDoubleLE ( bytes . bytes , bytes . offset + i * GEOPOINT_SIZE + COORDINATE_SIZE ) ; points [ i ] . reset ( lat , lon ) ; } } @Override public int count ( ) { return count ; } @Override public GeoPoint valueAt ( int index ) { return points [ index ] ; } } ; } } 
