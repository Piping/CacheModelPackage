package io . netty . handler . codec . memcache . binary ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . handler . codec . EncoderException ; import io . netty . handler . codec . memcache . DefaultLastMemcacheContent ; import io . netty . handler . codec . memcache . DefaultMemcacheContent ; import io . netty . util . CharsetUtil ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import static org . hamcrest . CoreMatchers . * ; import static org . hamcrest . core . IsEqual . equalTo ; import static org . junit . Assert . * ; public class BinaryMemcacheEncoderTest { public static final int DEFAULT_HEADER_SIZE = <int> ; private EmbeddedChannel channel ; @Before public void setup ( ) throws Exception { channel = new EmbeddedChannel ( new BinaryMemcacheRequestEncoder ( ) ) ; } @After public void teardown ( ) throws Exception { channel . finish ( ) ; } @Test public void shouldEncodeDefaultHeader ( ) { BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest ( ) ; boolean result = channel . writeOutbound ( request ) ; assertThat ( result , is ( true ) ) ; ByteBuf written = channel . readOutbound ( ) ; assertThat ( written . readableBytes ( ) , is ( DEFAULT_HEADER_SIZE ) ) ; assertThat ( written . readByte ( ) , is ( ( byte ) <hex> ) ) ; assertThat ( written . readByte ( ) , is ( ( byte ) <hex> ) ) ; written . release ( ) ; } @Test public void shouldEncodeCustomHeader ( ) { BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest ( ) ; request . setMagic ( ( byte ) <hex> ) ; request . setOpcode ( BinaryMemcacheOpcodes . GET ) ; boolean result = channel . writeOutbound ( request ) ; assertThat ( result , is ( true ) ) ; ByteBuf written = channel . readOutbound ( ) ; assertThat ( written . readableBytes ( ) , is ( DEFAULT_HEADER_SIZE ) ) ; assertThat ( written . readByte ( ) , is ( ( byte ) <hex> ) ) ; assertThat ( written . readByte ( ) , is ( BinaryMemcacheOpcodes . GET ) ) ; written . release ( ) ; } @Test public void shouldEncodeExtras ( ) { String extrasContent = <str> ; ByteBuf extras = Unpooled . copiedBuffer ( extrasContent , CharsetUtil . UTF_8 ) ; int extrasLength = extras . readableBytes ( ) ; BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest ( extras ) ; request . setExtrasLength ( ( byte ) extrasLength ) ; boolean result = channel . writeOutbound ( request ) ; assertThat ( result , is ( true ) ) ; ByteBuf written = channel . readOutbound ( ) ; assertThat ( written . readableBytes ( ) , is ( DEFAULT_HEADER_SIZE + extrasLength ) ) ; written . readBytes ( DEFAULT_HEADER_SIZE ) ; assertThat ( written . readBytes ( extrasLength ) . toString ( CharsetUtil . UTF_8 ) , equalTo ( extrasContent ) ) ; written . release ( ) ; } @Test public void shouldEncodeKey ( ) { String key = <str> ; int keyLength = key . length ( ) ; BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest ( key ) ; request . setKeyLength ( ( byte ) keyLength ) ; boolean result = channel . writeOutbound ( request ) ; assertThat ( result , is ( true ) ) ; ByteBuf written = channel . readOutbound ( ) ; assertThat ( written . readableBytes ( ) , is ( DEFAULT_HEADER_SIZE + keyLength ) ) ; written . readBytes ( DEFAULT_HEADER_SIZE ) ; assertThat ( written . readBytes ( keyLength ) . toString ( CharsetUtil . UTF_8 ) , equalTo ( key ) ) ; written . release ( ) ; } @Test public void shouldEncodeContent ( ) { DefaultMemcacheContent content1 = new DefaultMemcacheContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . UTF_8 ) ) ; DefaultLastMemcacheContent content2 = new DefaultLastMemcacheContent ( Unpooled . copiedBuffer ( <str> , CharsetUtil . UTF_8 ) ) ; int totalBodyLength = content1 . content ( ) . readableBytes ( ) + content2 . content ( ) . readableBytes ( ) ; BinaryMemcacheRequest request = new DefaultBinaryMemcacheRequest ( ) ; request . setTotalBodyLength ( totalBodyLength ) ; boolean result = channel . writeOutbound ( request ) ; assertThat ( result , is ( true ) ) ; result = channel . writeOutbound ( content1 ) ; assertThat ( result , is ( true ) ) ; result = channel . writeOutbound ( content2 ) ; assertThat ( result , is ( true ) ) ; ByteBuf written = channel . readOutbound ( ) ; assertThat ( written . readableBytes ( ) , is ( DEFAULT_HEADER_SIZE ) ) ; written . release ( ) ; written = channel . readOutbound ( ) ; assertThat ( written . readableBytes ( ) , is ( content1 . content ( ) . readableBytes ( ) ) ) ; assertThat ( written . readBytes ( content1 . content ( ) . readableBytes ( ) ) . toString ( CharsetUtil . UTF_8 ) , is ( <str> ) ) ; written . release ( ) ; written = channel . readOutbound ( ) ; assertThat ( written . readableBytes ( ) , is ( content2 . content ( ) . readableBytes ( ) ) ) ; assertThat ( written . readBytes ( content2 . content ( ) . readableBytes ( ) ) . toString ( CharsetUtil . UTF_8 ) , is ( <str> ) ) ; written . release ( ) ; } @Test ( expected = EncoderException . class ) public void shouldFailWithoutLastContent ( ) { channel . writeOutbound ( new DefaultMemcacheContent ( Unpooled . EMPTY_BUFFER ) ) ; channel . writeOutbound ( new DefaultBinaryMemcacheRequest ( ) ) ; } } 
