package org . elasticsearch . env ; import org . apache . lucene . util . Constants ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . io . PathUtils ; import java . io . IOException ; import java . nio . file . FileStore ; import java . nio . file . FileSystemException ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . attribute . FileAttributeView ; import java . nio . file . attribute . FileStoreAttributeView ; import java . util . Arrays ; class ESFileStore extends FileStore { final FileStore in ; final Boolean spins ; @SuppressForbidden ( reason = <str> ) ESFileStore ( FileStore in ) { this . in = in ; Boolean spins ; if ( Constants . LINUX ) { try { spins = IOUtils . spins ( PathUtils . get ( getMountPointLinux ( in ) ) ) ; } catch ( Exception e ) { spins = null ; } } else { spins = null ; } this . spins = spins ; } private static String getMountPointLinux ( FileStore store ) { String desc = store . toString ( ) ; int index = desc . lastIndexOf ( <str> ) ; if ( index ! = - <int> ) { return desc . substring ( <int> , index ) ; } else { return desc ; } } @SuppressForbidden ( reason = <str> ) static FileStore getMatchingFileStore ( Path path , FileStore fileStores [ ] ) throws IOException { if ( Constants . WINDOWS ) { return getFileStoreWindows ( path , fileStores ) ; } final FileStore store ; try { store = Files . getFileStore ( path ) ; } catch ( IOException unexpected ) { if ( Constants . FREE_BSD ) { throw new IOException ( <str> + path + <str> , unexpected ) ; } else { throw unexpected ; } } try { String mount = getMountPointLinux ( store ) ; FileStore sameMountPoint = null ; for ( FileStore fs : fileStores ) { if ( mount . equals ( getMountPointLinux ( fs ) ) ) { if ( sameMountPoint = = null ) { sameMountPoint = fs ; } else { return store ; } } } if ( sameMountPoint ! = null ) { return sameMountPoint ; } else { return store ; } } catch ( Exception e ) { } return store ; } @SuppressForbidden ( reason = <str> ) static FileStore getFileStoreWindows ( Path path , FileStore fileStores [ ] ) throws IOException { assert Constants . WINDOWS ; try { return Files . getFileStore ( path ) ; } catch ( FileSystemException possibleBug ) { final char driveLetter ; try { String root = path . toRealPath ( ) . getRoot ( ) . toString ( ) ; if ( root . length ( ) < <int> ) { throw new RuntimeException ( <str> + root ) ; } driveLetter = Character . toLowerCase ( root . charAt ( <int> ) ) ; if ( Character . isAlphabetic ( driveLetter ) = = false | | root . charAt ( <int> ) ! = <str> ) { throw new RuntimeException ( <str> + root ) ; } } catch ( Throwable checkFailed ) { possibleBug . addSuppressed ( checkFailed ) ; throw possibleBug ; } try { for ( FileStore store : fileStores ) { String toString = store . toString ( ) ; int length = toString . length ( ) ; if ( length > <int> & & toString . endsWith ( <str> ) & & toString . charAt ( length - <int> ) = = <str> ) { if ( Character . toLowerCase ( toString . charAt ( length - <int> ) ) = = driveLetter ) { return store ; } } } throw new RuntimeException ( <str> ) ; } catch ( Throwable weTried ) { IOException newException = new IOException ( <str> + path + <str> + Arrays . toString ( fileStores ) , weTried ) ; newException . addSuppressed ( possibleBug ) ; throw newException ; } } } @Override public String name ( ) { return in . name ( ) ; } @Override public String type ( ) { return in . type ( ) ; } @Override public boolean isReadOnly ( ) { return in . isReadOnly ( ) ; } @Override public long getTotalSpace ( ) throws IOException { return in . getTotalSpace ( ) ; } @Override public long getUsableSpace ( ) throws IOException { return in . getUsableSpace ( ) ; } @Override public long getUnallocatedSpace ( ) throws IOException { return in . getUnallocatedSpace ( ) ; } @Override public boolean supportsFileAttributeView ( Class < ? extends FileAttributeView > type ) { return in . supportsFileAttributeView ( type ) ; } @Override public boolean supportsFileAttributeView ( String name ) { if ( <str> . equals ( name ) ) { return true ; } else { return in . supportsFileAttributeView ( name ) ; } } @Override public < V extends FileStoreAttributeView > V getFileStoreAttributeView ( Class < V > type ) { return in . getFileStoreAttributeView ( type ) ; } @Override public Object getAttribute ( String attribute ) throws IOException { if ( <str> . equals ( attribute ) ) { return spins ; } else { return in . getAttribute ( attribute ) ; } } @Override public String toString ( ) { return in . toString ( ) ; } } 
