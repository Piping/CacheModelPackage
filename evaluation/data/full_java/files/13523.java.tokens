package org . gradle . api . tasks . javadoc ; import groovy . lang . Closure ; import org . gradle . api . Incubating ; import org . gradle . api . file . FileCollection ; import org . gradle . api . tasks . * ; import org . gradle . api . tasks . javadoc . internal . JavadocSpec ; import org . gradle . external . javadoc . MinimalJavadocOptions ; import org . gradle . external . javadoc . StandardJavadocDocletOptions ; import org . gradle . jvm . internal . toolchain . JavaToolChainInternal ; import org . gradle . jvm . platform . JavaPlatform ; import org . gradle . jvm . platform . internal . DefaultJavaPlatform ; import org . gradle . jvm . toolchain . JavaToolChain ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . util . GUtil ; import javax . inject . Inject ; import java . io . File ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; @ParallelizableTask public class Javadoc extends SourceTask { private File destinationDir ; private boolean failOnError = true ; private String title ; private String maxMemory ; private MinimalJavadocOptions options = new StandardJavadocDocletOptions ( ) ; private FileCollection classpath = getProject ( ) . files ( ) ; private String executable ; @TaskAction protected void generate ( ) { final File destinationDir = getDestinationDir ( ) ; if ( options . getDestinationDirectory ( ) = = null ) { options . destinationDirectory ( destinationDir ) ; } options . classpath ( new ArrayList < File > ( getClasspath ( ) . getFiles ( ) ) ) ; if ( ! GUtil . isTrue ( options . getWindowTitle ( ) ) & & GUtil . isTrue ( getTitle ( ) ) ) { options . windowTitle ( getTitle ( ) ) ; } if ( options instanceof StandardJavadocDocletOptions ) { StandardJavadocDocletOptions docletOptions = ( StandardJavadocDocletOptions ) options ; if ( ! GUtil . isTrue ( docletOptions . getDocTitle ( ) ) & & GUtil . isTrue ( getTitle ( ) ) ) { docletOptions . setDocTitle ( getTitle ( ) ) ; } } if ( maxMemory ! = null ) { final List < String > jFlags = options . getJFlags ( ) ; final Iterator < String > jFlagsIt = jFlags . iterator ( ) ; boolean containsXmx = false ; while ( ! containsXmx & & jFlagsIt . hasNext ( ) ) { final String jFlag = jFlagsIt . next ( ) ; if ( jFlag . startsWith ( <str> ) ) { containsXmx = true ; } } if ( ! containsXmx ) { options . jFlags ( <str> + maxMemory ) ; } } List < String > sourceNames = new ArrayList < String > ( ) ; for ( File sourceFile : getSource ( ) ) { sourceNames . add ( sourceFile . getAbsolutePath ( ) ) ; } options . setSourceNames ( sourceNames ) ; executeExternalJavadoc ( ) ; } private void executeExternalJavadoc ( ) { JavadocSpec spec = new JavadocSpec ( ) ; spec . setExecutable ( executable ) ; spec . setOptions ( options ) ; spec . setIgnoreFailures ( ! failOnError ) ; spec . setWorkingDir ( getProject ( ) . getProjectDir ( ) ) ; spec . setOptionsFile ( getOptionsFile ( ) ) ; Compiler < JavadocSpec > generator = ( ( JavaToolChainInternal ) getToolChain ( ) ) . select ( getPlatform ( ) ) . newCompiler ( JavadocSpec . class ) ; generator . execute ( spec ) ; } @Incubating @Inject public JavaToolChain getToolChain ( ) { throw new UnsupportedOperationException ( ) ; } @Incubating public void setToolChain ( JavaToolChain toolChain ) { throw new UnsupportedOperationException ( ) ; } private JavaPlatform getPlatform ( ) { return DefaultJavaPlatform . current ( ) ; } @OutputDirectory public File getDestinationDir ( ) { return destinationDir ; } public void setDestinationDir ( File destinationDir ) { this . destinationDir = destinationDir ; } public String getMaxMemory ( ) { return maxMemory ; } public void setMaxMemory ( String maxMemory ) { this . maxMemory = maxMemory ; } @Input @Optional public String getTitle ( ) { return title ; } public void setTitle ( String title ) { this . title = title ; } public boolean isVerbose ( ) { return options . isVerbose ( ) ; } public void setVerbose ( boolean verbose ) { if ( verbose ) { options . verbose ( ) ; } } @InputFiles public FileCollection getClasspath ( ) { return classpath ; } public void setClasspath ( FileCollection classpath ) { this . classpath = classpath ; } @Nested public MinimalJavadocOptions getOptions ( ) { return options ; } public void setOptions ( MinimalJavadocOptions options ) { this . options = options ; } public void options ( Closure < ? > block ) { getProject ( ) . configure ( getOptions ( ) , block ) ; } @Input public boolean isFailOnError ( ) { return failOnError ; } public void setFailOnError ( boolean failOnError ) { this . failOnError = failOnError ; } public File getOptionsFile ( ) { return new File ( getTemporaryDir ( ) , <str> ) ; } @Input @Optional public String getExecutable ( ) { return executable ; } public void setExecutable ( String executable ) { this . executable = executable ; } } 
