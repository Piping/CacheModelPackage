package org . apache . cassandra . index . internal . composites ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . List ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ClusteringIndexNamesFilter ; import org . apache . cassandra . db . filter . DataLimits ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . db . partitions . UnfilteredPartitionIterator ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . index . internal . CassandraIndex ; import org . apache . cassandra . index . internal . CassandraIndexSearcher ; import org . apache . cassandra . index . internal . IndexEntry ; import org . apache . cassandra . utils . btree . BTreeSet ; import org . apache . cassandra . utils . concurrent . OpOrder ; public class CompositesSearcher extends CassandraIndexSearcher { private static final Logger logger = LoggerFactory . getLogger ( CompositesSearcher . class ) ; public CompositesSearcher ( ReadCommand command , RowFilter . Expression expression , CassandraIndex index ) { super ( command , expression , index ) ; } private boolean isMatchingEntry ( DecoratedKey partitionKey , IndexEntry entry , ReadCommand command ) { return command . selectsKey ( partitionKey ) & & command . selectsClustering ( partitionKey , entry . indexedEntryClustering ) ; } protected UnfilteredPartitionIterator queryDataFromIndex ( final DecoratedKey indexKey , final RowIterator indexHits , final ReadCommand command , final ReadExecutionController executionController ) { assert indexHits . staticRow ( ) = = Rows . EMPTY_STATIC_ROW ; return new UnfilteredPartitionIterator ( ) { private IndexEntry nextEntry ; private UnfilteredRowIterator next ; public boolean isForThrift ( ) { return command . isForThrift ( ) ; } public CFMetaData metadata ( ) { return command . metadata ( ) ; } public boolean hasNext ( ) { return prepareNext ( ) ; } public UnfilteredRowIterator next ( ) { if ( next = = null ) prepareNext ( ) ; UnfilteredRowIterator toReturn = next ; next = null ; return toReturn ; } private boolean prepareNext ( ) { if ( next ! = null ) return true ; if ( nextEntry = = null ) { if ( ! indexHits . hasNext ( ) ) return false ; nextEntry = index . decodeEntry ( indexKey , indexHits . next ( ) ) ; } BTreeSet . Builder < Clustering > clusterings = BTreeSet . builder ( index . baseCfs . getComparator ( ) ) ; List < IndexEntry > entries = new ArrayList < > ( ) ; DecoratedKey partitionKey = index . baseCfs . decorateKey ( nextEntry . indexedKey ) ; while ( nextEntry ! = null & & partitionKey . getKey ( ) . equals ( nextEntry . indexedKey ) ) { if ( isMatchingEntry ( partitionKey , nextEntry , command ) ) { clusterings . add ( nextEntry . indexedEntryClustering ) ; entries . add ( nextEntry ) ; } nextEntry = indexHits . hasNext ( ) ? index . decodeEntry ( indexKey , indexHits . next ( ) ) : null ; } if ( clusterings . isEmpty ( ) ) return prepareNext ( ) ; ClusteringIndexNamesFilter filter = new ClusteringIndexNamesFilter ( clusterings . build ( ) , false ) ; SinglePartitionReadCommand dataCmd = SinglePartitionReadCommand . create ( index . baseCfs . metadata , command . nowInSec ( ) , command . columnFilter ( ) , command . rowFilter ( ) , DataLimits . NONE , partitionKey , filter ) ; @SuppressWarnings ( <str> ) UnfilteredRowIterator dataIter = filterStaleEntries ( dataCmd . queryMemtableAndDisk ( index . baseCfs , executionController . baseReadOpOrderGroup ( ) ) , indexKey . getKey ( ) , entries , executionController . writeOpOrderGroup ( ) , command . nowInSec ( ) ) ; if ( dataIter . isEmpty ( ) ) { dataIter . close ( ) ; return prepareNext ( ) ; } next = dataIter ; return true ; } public void remove ( ) { throw new UnsupportedOperationException ( ) ; } public void close ( ) { indexHits . close ( ) ; if ( next ! = null ) next . close ( ) ; } } ; } private void deleteAllEntries ( final List < IndexEntry > entries , final OpOrder . Group writeOp , final int nowInSec ) { entries . forEach ( entry - > index . deleteStaleEntry ( entry . indexValue , entry . indexClustering , new DeletionTime ( entry . timestamp , nowInSec ) , writeOp ) ) ; } private UnfilteredRowIterator filterStaleEntries ( UnfilteredRowIterator dataIter , final ByteBuffer indexValue , final List < IndexEntry > entries , final OpOrder . Group writeOp , final int nowInSec ) { final List < IndexEntry > staleEntries = new ArrayList < > ( ) ; if ( ! dataIter . partitionLevelDeletion ( ) . isLive ( ) ) { DeletionTime deletion = dataIter . partitionLevelDeletion ( ) ; entries . forEach ( e - > { if ( deletion . deletes ( e . timestamp ) ) staleEntries . add ( e ) ; } ) ; } ClusteringComparator comparator = dataIter . metadata ( ) . comparator ; class Transform extends Transformation { private int entriesIdx ; @Override public Row applyToRow ( Row row ) { IndexEntry entry = findEntry ( row . clustering ( ) ) ; if ( ! index . isStale ( row , indexValue , nowInSec ) ) return row ; staleEntries . add ( entry ) ; return null ; } private IndexEntry findEntry ( Clustering clustering ) { assert entriesIdx < entries . size ( ) ; while ( entriesIdx < entries . size ( ) ) { IndexEntry entry = entries . get ( entriesIdx + + ) ; int cmp = comparator . compare ( entry . indexedEntryClustering , clustering ) ; assert cmp < = <int> ; if ( cmp = = <int> ) return entry ; else staleEntries . add ( entry ) ; } throw new AssertionError ( ) ; } @Override public void onClose ( ) { deleteAllEntries ( staleEntries , writeOp , nowInSec ) ; } } return Transformation . apply ( dataIter , new Transform ( ) ) ; } } 
