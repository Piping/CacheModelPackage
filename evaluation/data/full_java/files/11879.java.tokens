package org . gradle . cache . internal . locklistener ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . cache . internal . FileLockCommunicator ; import org . gradle . cache . internal . GracefullyStoppedException ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . concurrent . StoppableExecutor ; import org . gradle . messaging . remote . internal . inet . InetAddressFactory ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DefaultFileLockContentionHandler implements FileLockContentionHandler , Stoppable { private static final Logger LOGGER = Logging . getLogger ( DefaultFileLockContentionHandler . class ) ; private final Lock lock = new ReentrantLock ( ) ; private final Map < Long , Runnable > contendedActions = new HashMap < Long , Runnable > ( ) ; private final ExecutorFactory executorFactory ; private final InetAddressFactory addressFactory ; private FileLockCommunicator communicator ; private StoppableExecutor executor ; private boolean stopped ; public DefaultFileLockContentionHandler ( ExecutorFactory executorFactory , InetAddressFactory addressFactory ) { this . executorFactory = executorFactory ; this . addressFactory = addressFactory ; } private Runnable listener ( ) { return new Runnable ( ) { public void run ( ) { try { LOGGER . debug ( <str> ) ; doRun ( ) ; } catch ( Throwable t ) { LOGGER . error ( <str> , t ) ; } finally { LOGGER . debug ( <str> ) ; } } private void doRun ( ) { while ( true ) { long lockId ; try { lockId = communicator . receive ( ) ; } catch ( GracefullyStoppedException e ) { return ; } lock . lock ( ) ; Runnable action ; try { action = contendedActions . get ( lockId ) ; if ( action = = null ) { continue ; } } finally { lock . unlock ( ) ; } action . run ( ) ; } } } ; } public void start ( long lockId , Runnable whenContended ) { lock . lock ( ) ; try { assertNotStopped ( ) ; if ( communicator = = null ) { throw new IllegalStateException ( <str> ) ; } if ( executor = = null ) { executor = executorFactory . create ( <str> ) ; executor . execute ( listener ( ) ) ; } if ( contendedActions . containsKey ( lockId ) ) { throw new UnsupportedOperationException ( <str> ) ; } contendedActions . put ( lockId , whenContended ) ; } finally { lock . unlock ( ) ; } } public void pingOwner ( int port , long lockId , String displayName ) { getCommunicator ( ) . pingOwner ( port , lockId , displayName ) ; } private void assertNotStopped ( ) { if ( stopped ) { throw new IllegalStateException ( <str> ) ; } } public void stop ( long lockId ) { lock . lock ( ) ; try { contendedActions . remove ( lockId ) ; } finally { lock . unlock ( ) ; } } public void stop ( ) { lock . lock ( ) ; try { stopped = true ; contendedActions . clear ( ) ; if ( communicator ! = null ) { communicator . stop ( ) ; } } finally { lock . unlock ( ) ; } if ( executor ! = null ) { executor . stop ( ) ; } } public int reservePort ( ) { return getCommunicator ( ) . getPort ( ) ; } private FileLockCommunicator getCommunicator ( ) { lock . lock ( ) ; try { assertNotStopped ( ) ; if ( communicator = = null ) { communicator = new FileLockCommunicator ( addressFactory ) ; } return communicator ; } finally { lock . unlock ( ) ; } } } 
