package com . google . common . math ; import static com . google . common . math . MathBenchmarking . ARRAY_MASK ; import static com . google . common . math . MathBenchmarking . ARRAY_SIZE ; import static com . google . common . math . MathBenchmarking . RANDOM_SOURCE ; import static com . google . common . math . MathBenchmarking . randomExponent ; import static com . google . common . math . MathBenchmarking . randomNonNegativeBigInteger ; import static com . google . common . math . MathBenchmarking . randomPositiveBigInteger ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . common . math . LongMath ; public class LongMathBenchmark { private static final int [ ] exponents = new int [ ARRAY_SIZE ] ; private static final int [ ] factorialArguments = new int [ ARRAY_SIZE ] ; private static final int [ ] [ ] binomialArguments = new int [ ARRAY_SIZE ] [ <int> ] ; private static final long [ ] positive = new long [ ARRAY_SIZE ] ; private static final long [ ] nonnegative = new long [ ARRAY_SIZE ] ; private static final long [ ] longs = new long [ ARRAY_SIZE ] ; @BeforeExperiment void setUp ( ) { for ( int i = <int> ; i < ARRAY_SIZE ; i + + ) { exponents [ i ] = randomExponent ( ) ; positive [ i ] = randomPositiveBigInteger ( Long . SIZE - <int> ) . longValue ( ) ; nonnegative [ i ] = randomNonNegativeBigInteger ( Long . SIZE - <int> ) . longValue ( ) ; longs [ i ] = RANDOM_SOURCE . nextLong ( ) ; factorialArguments [ i ] = RANDOM_SOURCE . nextInt ( <int> ) ; binomialArguments [ i ] [ <int> ] = RANDOM_SOURCE . nextInt ( MathBenchmarking . biggestBinomials . length ) ; int k = binomialArguments [ i ] [ <int> ] ; binomialArguments [ i ] [ <int> ] = RANDOM_SOURCE . nextInt ( MathBenchmarking . biggestBinomials [ k ] - k ) + k ; } } @Benchmark int pow ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = LongMath . pow ( positive [ j ] , exponents [ j ] ) ; } return tmp ; } @Benchmark int mod ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = LongMath . mod ( longs [ j ] , positive [ j ] ) ; } return tmp ; } @Benchmark int gCD ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = LongMath . mod ( nonnegative [ j ] , positive [ j ] ) ; } return tmp ; } @Benchmark int factorial ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = LongMath . factorial ( factorialArguments [ j ] ) ; } return tmp ; } @Benchmark int binomial ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = LongMath . binomial ( binomialArguments [ j ] [ <int> ] , binomialArguments [ j ] [ <int> ] ) ; } return tmp ; } } 
