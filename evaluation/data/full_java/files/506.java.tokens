package org . apache . cassandra . db . rows ; import java . util . Comparator ; import java . util . Iterator ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . ColumnFilter ; public class RowAndDeletionMergeIterator extends AbstractUnfilteredRowIterator { private final boolean removeShadowedData ; private final Comparator < Clusterable > comparator ; private final ColumnFilter selection ; private final Iterator < Row > rows ; private Row nextRow ; private final Iterator < RangeTombstone > ranges ; private RangeTombstone nextRange ; private RangeTombstone openRange ; public RowAndDeletionMergeIterator ( CFMetaData metadata , DecoratedKey partitionKey , DeletionTime partitionLevelDeletion , ColumnFilter selection , Row staticRow , boolean isReversed , EncodingStats stats , Iterator < Row > rows , Iterator < RangeTombstone > ranges , boolean removeShadowedData ) { super ( metadata , partitionKey , partitionLevelDeletion , selection . fetchedColumns ( ) , staticRow , isReversed , stats ) ; this . comparator = isReversed ? metadata . comparator . reversed ( ) : metadata . comparator ; this . selection = selection ; this . removeShadowedData = removeShadowedData ; this . rows = rows ; this . ranges = ranges ; } protected Unfiltered computeNext ( ) { while ( true ) { updateNextRow ( ) ; if ( nextRow = = null ) { if ( openRange ! = null ) return closeOpenedRange ( ) ; updateNextRange ( ) ; return nextRange = = null ? endOfData ( ) : openRange ( ) ; } if ( openRange = = null ) { updateNextRange ( ) ; if ( nextRange ! = null & & comparator . compare ( openBound ( nextRange ) , nextRow . clustering ( ) ) < <int> ) return openRange ( ) ; Row row = consumeNextRow ( ) ; if ( row ! = null ) return row ; } else { if ( comparator . compare ( closeBound ( openRange ) , nextRow . clustering ( ) ) < <int> ) return closeOpenedRange ( ) ; Row row = consumeNextRow ( ) ; if ( row ! = null ) return row ; } } } private void updateNextRow ( ) { if ( nextRow = = null & & rows . hasNext ( ) ) nextRow = rows . next ( ) ; } private void updateNextRange ( ) { while ( nextRange = = null & & ranges . hasNext ( ) ) { nextRange = ranges . next ( ) ; if ( removeShadowedData & & partitionLevelDeletion ( ) . supersedes ( nextRange . deletionTime ( ) ) ) nextRange = null ; } } private Row consumeNextRow ( ) { Row row = nextRow ; nextRow = null ; if ( ! removeShadowedData ) return row . filter ( selection , metadata ( ) ) ; DeletionTime activeDeletion = openRange = = null ? partitionLevelDeletion ( ) : openRange . deletionTime ( ) ; return row . filter ( selection , activeDeletion , false , metadata ( ) ) ; } private RangeTombstone consumeNextRange ( ) { RangeTombstone range = nextRange ; nextRange = null ; return range ; } private RangeTombstone consumeOpenRange ( ) { RangeTombstone range = openRange ; openRange = null ; return range ; } private Slice . Bound openBound ( RangeTombstone range ) { return range . deletedSlice ( ) . open ( isReverseOrder ( ) ) ; } private Slice . Bound closeBound ( RangeTombstone range ) { return range . deletedSlice ( ) . close ( isReverseOrder ( ) ) ; } private RangeTombstoneMarker closeOpenedRange ( ) { updateNextRange ( ) ; RangeTombstoneMarker marker ; if ( nextRange ! = null & & comparator . compare ( closeBound ( openRange ) , openBound ( nextRange ) ) = = <int> ) { marker = RangeTombstoneBoundaryMarker . makeBoundary ( isReverseOrder ( ) , closeBound ( openRange ) , openBound ( nextRange ) , openRange . deletionTime ( ) , nextRange . deletionTime ( ) ) ; openRange = consumeNextRange ( ) ; } else { RangeTombstone toClose = consumeOpenRange ( ) ; marker = new RangeTombstoneBoundMarker ( closeBound ( toClose ) , toClose . deletionTime ( ) ) ; } return marker ; } private RangeTombstoneMarker openRange ( ) { assert openRange = = null & & nextRange ! = null ; openRange = consumeNextRange ( ) ; return new RangeTombstoneBoundMarker ( openBound ( openRange ) , openRange . deletionTime ( ) ) ; } } 
