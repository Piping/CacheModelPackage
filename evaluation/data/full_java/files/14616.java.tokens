package org . gradle . performance . results ; import org . gradle . internal . UncheckedException ; import org . gradle . performance . fixture . BaselineVersion ; import org . gradle . performance . fixture . CrossVersionPerformanceResults ; import org . gradle . performance . fixture . DataReporter ; import org . gradle . performance . fixture . MeasuredOperationList ; import org . gradle . performance . measure . DataAmount ; import org . gradle . performance . measure . Duration ; import org . gradle . performance . measure . MeasuredOperation ; import org . gradle . util . GradleVersion ; import java . io . Closeable ; import java . io . File ; import java . sql . * ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . * ; public class CrossVersionResultsStore implements DataReporter < CrossVersionPerformanceResults > , ResultsStore , Closeable { private final File dbFile ; private final long ignoreV17Before ; private final H2FileDb db ; public CrossVersionResultsStore ( ) { this ( new File ( System . getProperty ( <str> ) , <str> ) ) ; } public CrossVersionResultsStore ( File dbFile ) { this . dbFile = dbFile ; db = new H2FileDb ( dbFile , new CrossVersionResultsSchemaInitializer ( ) ) ; DateFormat timeStampFormat = new SimpleDateFormat ( <str> ) ; timeStampFormat . setTimeZone ( TimeZone . getTimeZone ( <str> ) ) ; try { ignoreV17Before = timeStampFormat . parse ( <str> ) . getTime ( ) ; } catch ( ParseException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } } public void report ( final CrossVersionPerformanceResults results ) { try { db . withConnection ( new ConnectionAction < Void > ( ) { public Void execute ( Connection connection ) throws Exception { long testId ; PreparedStatement statement = connection . prepareStatement ( <str> ) ; try { statement . setString ( <int> , results . getTestId ( ) ) ; statement . setTimestamp ( <int> , new Timestamp ( results . getTestTime ( ) ) ) ; statement . setString ( <int> , results . getVersionUnderTest ( ) ) ; statement . setString ( <int> , results . getTestProject ( ) ) ; statement . setObject ( <int> , results . getTasks ( ) ) ; statement . setObject ( <int> , results . getArgs ( ) ) ; statement . setString ( <int> , results . getOperatingSystem ( ) ) ; statement . setString ( <int> , results . getJvm ( ) ) ; statement . setString ( <int> , results . getVcsBranch ( ) ) ; statement . setString ( <int> , results . getVcsCommit ( ) ) ; statement . execute ( ) ; ResultSet keys = statement . getGeneratedKeys ( ) ; keys . next ( ) ; testId = keys . getLong ( <int> ) ; } finally { statement . close ( ) ; } statement = connection . prepareStatement ( <str> ) ; try { addOperations ( statement , testId , null , results . getCurrent ( ) ) ; for ( BaselineVersion baselineVersion : results . getBaselineVersions ( ) ) { addOperations ( statement , testId , baselineVersion . getVersion ( ) , baselineVersion . getResults ( ) ) ; } } finally { statement . close ( ) ; } return null ; } } ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( <str> , dbFile ) , e ) ; } } private void addOperations ( PreparedStatement statement , long testId , String version , MeasuredOperationList operations ) throws SQLException { for ( MeasuredOperation operation : operations ) { statement . setLong ( <int> , testId ) ; statement . setString ( <int> , version ) ; statement . setBigDecimal ( <int> , operation . getTotalTime ( ) . toUnits ( Duration . MILLI_SECONDS ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getConfigurationTime ( ) . toUnits ( Duration . MILLI_SECONDS ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getExecutionTime ( ) . toUnits ( Duration . MILLI_SECONDS ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getTotalMemoryUsed ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getTotalHeapUsage ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getMaxHeapUsage ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getMaxUncollectedHeap ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . setBigDecimal ( <int> , operation . getMaxCommittedHeap ( ) . toUnits ( DataAmount . BYTES ) . getValue ( ) ) ; statement . execute ( ) ; } } @Override public List < String > getTestNames ( ) { try { return db . withConnection ( new ConnectionAction < List < String > > ( ) { public List < String > execute ( Connection connection ) throws Exception { List < String > testNames = new ArrayList < String > ( ) ; ResultSet testExecutions = connection . createStatement ( ) . executeQuery ( <str> ) ; while ( testExecutions . next ( ) ) { testNames . add ( testExecutions . getString ( <int> ) ) ; } return testNames ; } } ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( <str> , dbFile ) , e ) ; } } @Override public TestExecutionHistory getTestResults ( String testName ) { return getTestResults ( testName , Integer . MAX_VALUE ) ; } @Override public TestExecutionHistory getTestResults ( final String testName , final int mostRecentN ) { try { return db . withConnection ( new ConnectionAction < CrossVersionTestExecutionHistory > ( ) { public CrossVersionTestExecutionHistory execute ( Connection connection ) throws Exception { List < CrossVersionPerformanceResults > results = new ArrayList < CrossVersionPerformanceResults > ( ) ; Set < String > allVersions = new TreeSet < String > ( new Comparator < String > ( ) { public int compare ( String o1 , String o2 ) { return GradleVersion . version ( o1 ) . compareTo ( GradleVersion . version ( o2 ) ) ; } } ) ; Set < String > allBranches = new TreeSet < String > ( ) ; PreparedStatement executionsForName = connection . prepareStatement ( <str> ) ; PreparedStatement operationsForExecution = connection . prepareStatement ( <str> ) ; executionsForName . setInt ( <int> , mostRecentN ) ; executionsForName . setString ( <int> , testName ) ; ResultSet testExecutions = executionsForName . executeQuery ( ) ; while ( testExecutions . next ( ) ) { long id = testExecutions . getLong ( <int> ) ; CrossVersionPerformanceResults performanceResults = new CrossVersionPerformanceResults ( ) ; performanceResults . setTestId ( testName ) ; performanceResults . setTestTime ( testExecutions . getTimestamp ( <int> ) . getTime ( ) ) ; performanceResults . setVersionUnderTest ( testExecutions . getString ( <int> ) ) ; performanceResults . setTestProject ( testExecutions . getString ( <int> ) ) ; performanceResults . setTasks ( toArray ( testExecutions . getObject ( <int> ) ) ) ; performanceResults . setArgs ( toArray ( testExecutions . getObject ( <int> ) ) ) ; performanceResults . setOperatingSystem ( testExecutions . getString ( <int> ) ) ; performanceResults . setJvm ( testExecutions . getString ( <int> ) ) ; performanceResults . setVcsBranch ( testExecutions . getString ( <int> ) . trim ( ) ) ; performanceResults . setVcsCommit ( testExecutions . getString ( <int> ) ) ; results . add ( performanceResults ) ; allBranches . add ( performanceResults . getVcsBranch ( ) ) ; operationsForExecution . setLong ( <int> , id ) ; ResultSet builds = operationsForExecution . executeQuery ( ) ; while ( builds . next ( ) ) { String version = builds . getString ( <int> ) ; if ( <str> . equals ( version ) & & performanceResults . getTestTime ( ) < = ignoreV17Before ) { continue ; } MeasuredOperation operation = new MeasuredOperation ( ) ; operation . setTotalTime ( Duration . millis ( builds . getBigDecimal ( <int> ) ) ) ; operation . setConfigurationTime ( Duration . millis ( builds . getBigDecimal ( <int> ) ) ) ; operation . setExecutionTime ( Duration . millis ( builds . getBigDecimal ( <int> ) ) ) ; operation . setTotalMemoryUsed ( DataAmount . bytes ( builds . getBigDecimal ( <int> ) ) ) ; operation . setTotalHeapUsage ( DataAmount . bytes ( builds . getBigDecimal ( <int> ) ) ) ; operation . setMaxHeapUsage ( DataAmount . bytes ( builds . getBigDecimal ( <int> ) ) ) ; operation . setMaxUncollectedHeap ( DataAmount . bytes ( builds . getBigDecimal ( <int> ) ) ) ; operation . setMaxCommittedHeap ( DataAmount . bytes ( builds . getBigDecimal ( <int> ) ) ) ; if ( version = = null ) { performanceResults . getCurrent ( ) . add ( operation ) ; } else { BaselineVersion baselineVersion = performanceResults . baseline ( version ) ; baselineVersion . getResults ( ) . add ( operation ) ; allVersions . add ( version ) ; } } } testExecutions . close ( ) ; operationsForExecution . close ( ) ; executionsForName . close ( ) ; return new CrossVersionTestExecutionHistory ( testName , new ArrayList < String > ( allVersions ) , new ArrayList < String > ( allBranches ) , results ) ; } } ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( <str> , dbFile ) , e ) ; } } private String [ ] toArray ( Object object ) { Object [ ] value = ( Object [ ] ) object ; String [ ] result = new String [ value . length ] ; for ( int i = <int> ; i < value . length ; i + + ) { result [ i ] = value [ i ] . toString ( ) ; } return result ; } public void close ( ) { db . close ( ) ; } private class CrossVersionResultsSchemaInitializer implements ConnectionAction < Void > { @Override public Void execute ( Connection connection ) throws Exception { Statement statement = connection . createStatement ( ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; if ( columnExists ( connection , <str> , <str> ) ) { statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; } statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . execute ( <str> ) ; statement . close ( ) ; return null ; } private boolean columnExists ( Connection connection , String table , String column ) throws SQLException { ResultSet columns = connection . getMetaData ( ) . getColumns ( null , null , table , column ) ; boolean exists = columns . next ( ) ; columns . close ( ) ; return exists ; } } } 
