package org . gradle . model . internal . core ; import com . google . common . base . CharMatcher ; import com . google . common . base . Joiner ; import com . google . common . base . Splitter ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import net . jcip . annotations . ThreadSafe ; import org . gradle . api . GradleException ; import org . gradle . api . Nullable ; import org . gradle . internal . exceptions . Contextual ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; @ThreadSafe public class ModelPath implements Iterable < String > , Comparable < ModelPath > { public static final ModelPath ROOT = new ModelPath ( <str> , Collections . < String > emptyList ( ) ) { @Override public String toString ( ) { return <str> ; } @Override public ModelPath descendant ( ModelPath path ) { return path ; } } ; public static final String SEPARATOR = <str> ; public static final Splitter PATH_SPLITTER = Splitter . on ( <str> ) ; public static final Joiner PATH_JOINER = Joiner . on ( <str> ) ; private final String path ; private final List < String > components ; public ModelPath ( String path ) { this . path = path ; this . components = PATH_SPLITTER . splitToList ( path ) ; } public ModelPath ( Iterable < String > parts ) { this . path = PATH_JOINER . join ( parts ) ; this . components = ImmutableList . copyOf ( parts ) ; } private ModelPath ( String path , List < String > parts ) { this . path = path ; this . components = parts ; } public int compareTo ( ModelPath other ) { return path . compareTo ( other . path ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } ModelPath modelPath = ( ModelPath ) o ; return components . size ( ) = = modelPath . components . size ( ) & & path . equals ( modelPath . path ) ; } @Override public int hashCode ( ) { return path . hashCode ( ) ; } public int getDepth ( ) { return components . size ( ) ; } public List < String > getComponents ( ) { return components ; } public Iterator < String > iterator ( ) { return components . iterator ( ) ; } @Override public String toString ( ) { return path ; } public static ModelPath path ( String path ) { return new ModelPath ( path ) ; } public static ModelPath path ( Iterable < String > names ) { return new ModelPath ( names ) ; } public static String pathString ( Iterable < String > names ) { return PATH_JOINER . join ( names ) ; } public ModelPath child ( String child ) { List < String > childComponents = new ArrayList < String > ( components ) ; childComponents . add ( child ) ; return path ( childComponents ) ; } public ModelPath getRootParent ( ) { return components . size ( ) < = <int> ? null : ModelPath . path ( components . get ( <int> ) ) ; } @Nullable public ModelPath getParent ( ) { if ( components . isEmpty ( ) ) { return null ; } if ( components . size ( ) = = <int> ) { return ROOT ; } List < String > parentComponents = components . subList ( <int> , components . size ( ) - <int> ) ; String parentPath = path . substring ( <int> , path . length ( ) - components . get ( components . size ( ) - <int> ) . length ( ) - <int> ) ; return new ModelPath ( parentPath , parentComponents ) ; } public String getName ( ) { if ( components . isEmpty ( ) ) { return <str> ; } return components . get ( components . size ( ) - <int> ) ; } public boolean isDirectChild ( @Nullable ModelPath other ) { if ( other = = null ) { return false ; } if ( other . getDepth ( ) ! = getDepth ( ) + <int> ) { return false ; } ModelPath otherParent = other . getParent ( ) ; return otherParent ! = null & & otherParent . equals ( this ) ; } public boolean isDescendant ( @Nullable ModelPath other ) { if ( other = = null ) { return false ; } if ( other . getDepth ( ) < = getDepth ( ) ) { return false ; } return getComponents ( ) . equals ( other . getComponents ( ) . subList ( <int> , getDepth ( ) ) ) ; } public ModelPath descendant ( ModelPath path ) { return path ( Iterables . concat ( components , path . components ) ) ; } public static class InvalidNameException extends GradleException { public InvalidNameException ( String message ) { super ( message ) ; } } @Contextual public static class InvalidPathException extends GradleException { public InvalidPathException ( String message , InvalidNameException e ) { super ( message , e ) ; } } private static final CharMatcher VALID_FIRST_CHAR_MATCHER = CharMatcher . inRange ( <str> , <str> ) . or ( CharMatcher . inRange ( <str> , <str> ) ) . or ( CharMatcher . is ( <str> ) ) ; private final static CharMatcher INVALID_FIRST_CHAR_MATCHER = VALID_FIRST_CHAR_MATCHER . negate ( ) . precomputed ( ) ; private final static CharMatcher INVALID_CHAR_MATCHER = CharMatcher . inRange ( <str> , <str> ) . or ( VALID_FIRST_CHAR_MATCHER ) . or ( CharMatcher . is ( <str> ) ) . negate ( ) . precomputed ( ) ; public static void validateName ( String name ) { if ( name . isEmpty ( ) ) { throw new InvalidNameException ( <str> ) ; } char firstChar = name . charAt ( <int> ) ; if ( INVALID_FIRST_CHAR_MATCHER . matches ( firstChar ) ) { throw new InvalidNameException ( String . format ( <str> , name , firstChar ) ) ; } for ( int i = <int> ; i < name . length ( ) ; + + i ) { char character = name . charAt ( i ) ; if ( INVALID_CHAR_MATCHER . matches ( character ) ) { throw new InvalidNameException ( String . format ( <str> , name , character ) ) ; } } } @Nullable public static ModelPath validatedPath ( @Nullable String path ) { if ( path = = null ) { return null ; } else { validatePath ( path ) ; return path ( path ) ; } } public static ModelPath nonNullValidatedPath ( String path ) { if ( path = = null ) { throw new IllegalArgumentException ( <str> ) ; } else { return validatedPath ( path ) ; } } public static void validatePath ( String path ) throws InvalidPathException { if ( path . isEmpty ( ) ) { throw new InvalidPathException ( <str> , null ) ; } if ( path . startsWith ( SEPARATOR ) ) { throw new InvalidPathException ( String . format ( <str> , path , SEPARATOR ) , null ) ; } if ( path . endsWith ( SEPARATOR ) ) { throw new InvalidPathException ( String . format ( <str> , path , SEPARATOR ) , null ) ; } List < String > names = PATH_SPLITTER . splitToList ( path ) ; if ( names . size ( ) = = <int> ) { validateName ( names . get ( <int> ) ) ; } else { for ( String name : names ) { try { validateName ( name ) ; } catch ( InvalidNameException e ) { throw new InvalidPathException ( String . format ( <str> , path ) , e ) ; } } } } } 
