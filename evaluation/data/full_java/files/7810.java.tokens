package org . elasticsearch . cluster . ack ; import org . elasticsearch . action . admin . cluster . node . info . NodeInfo ; import org . elasticsearch . action . admin . cluster . node . info . NodesInfoResponse ; import org . elasticsearch . action . admin . cluster . settings . ClusterUpdateSettingsResponse ; import org . elasticsearch . action . admin . indices . close . CloseIndexResponse ; import org . elasticsearch . action . admin . indices . open . OpenIndexResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . routing . IndexRoutingTable ; import org . elasticsearch . cluster . routing . IndexShardRoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . decider . ConcurrentRebalanceAllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . ThrottlingAllocationDecider ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . ESIntegTestCase . Scope . TEST ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . equalTo ; @ClusterScope ( scope = TEST , minNumDataNodes = <int> ) public class AckClusterUpdateSettingsIT extends ESIntegTestCase { @Override protected Settings nodeSettings ( int nodeOrdinal ) { return Settings . builder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( ThrottlingAllocationDecider . CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES , <int> ) . put ( ConcurrentRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE , <int> ) . build ( ) ; } @Override protected int minimumNumberOfShards ( ) { return cluster ( ) . numDataNodes ( ) ; } @Override protected int numberOfReplicas ( ) { return <int> ; } private void removePublishTimeout ( ) { assertAcked ( client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( Settings . builder ( ) . put ( DiscoverySettings . PUBLISH_TIMEOUT , <str> ) ) ) ; } public void testClusterUpdateSettingsAcknowledgement ( ) { createIndex ( <str> ) ; ensureGreen ( ) ; removePublishTimeout ( ) ; NodesInfoResponse nodesInfo = client ( ) . admin ( ) . cluster ( ) . prepareNodesInfo ( ) . get ( ) ; String excludedNodeId = null ; for ( NodeInfo nodeInfo : nodesInfo ) { if ( nodeInfo . getNode ( ) . isDataNode ( ) ) { excludedNodeId = nodeInfo . getNode ( ) . id ( ) ; break ; } } assertNotNull ( excludedNodeId ) ; ClusterUpdateSettingsResponse clusterUpdateSettingsResponse = client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( <str> , excludedNodeId ) ) . get ( ) ; assertAcked ( clusterUpdateSettingsResponse ) ; assertThat ( clusterUpdateSettingsResponse . getTransientSettings ( ) . get ( <str> ) , equalTo ( excludedNodeId ) ) ; for ( Client client : clients ( ) ) { ClusterState clusterState = getLocalClusterState ( client ) ; assertThat ( clusterState . getRoutingNodes ( ) . metaData ( ) . transientSettings ( ) . get ( <str> ) , equalTo ( excludedNodeId ) ) ; for ( IndexRoutingTable indexRoutingTable : clusterState . routingTable ( ) ) { for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { for ( ShardRouting shardRouting : indexShardRoutingTable ) { assert clusterState . nodes ( ) ! = null ; if ( shardRouting . unassigned ( ) = = false & & clusterState . nodes ( ) . get ( shardRouting . currentNodeId ( ) ) . id ( ) . equals ( excludedNodeId ) ) { assertThat ( shardRouting . relocating ( ) , equalTo ( true ) ) ; } } } } } } public void testClusterUpdateSettingsNoAcknowledgement ( ) { client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , between ( cluster ( ) . numDataNodes ( ) , DEFAULT_MAX_NUM_SHARDS ) ) . put ( <str> , <int> ) ) . get ( ) ; ensureGreen ( ) ; removePublishTimeout ( ) ; NodesInfoResponse nodesInfo = client ( ) . admin ( ) . cluster ( ) . prepareNodesInfo ( ) . get ( ) ; String excludedNodeId = null ; for ( NodeInfo nodeInfo : nodesInfo ) { if ( nodeInfo . getNode ( ) . isDataNode ( ) ) { excludedNodeId = nodeInfo . getNode ( ) . id ( ) ; break ; } } assertNotNull ( excludedNodeId ) ; ClusterUpdateSettingsResponse clusterUpdateSettingsResponse = client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTimeout ( <str> ) . setTransientSettings ( settingsBuilder ( ) . put ( <str> , excludedNodeId ) ) . get ( ) ; assertThat ( clusterUpdateSettingsResponse . isAcknowledged ( ) , equalTo ( false ) ) ; assertThat ( clusterUpdateSettingsResponse . getTransientSettings ( ) . get ( <str> ) , equalTo ( excludedNodeId ) ) ; } private static ClusterState getLocalClusterState ( Client client ) { return client . admin ( ) . cluster ( ) . prepareState ( ) . setLocal ( true ) . get ( ) . getState ( ) ; } public void testOpenIndexNoAcknowledgement ( ) { createIndex ( <str> ) ; ensureGreen ( ) ; removePublishTimeout ( ) ; CloseIndexResponse closeIndexResponse = client ( ) . admin ( ) . indices ( ) . prepareClose ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( closeIndexResponse . isAcknowledged ( ) , equalTo ( true ) ) ; OpenIndexResponse openIndexResponse = client ( ) . admin ( ) . indices ( ) . prepareOpen ( <str> ) . setTimeout ( <str> ) . get ( ) ; assertThat ( openIndexResponse . isAcknowledged ( ) , equalTo ( false ) ) ; ensureGreen ( <str> ) ; } } 
