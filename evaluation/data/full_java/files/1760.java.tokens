package org . apache . cassandra . stress . settings ; import java . io . File ; import java . net . URI ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import org . apache . cassandra . stress . Operation ; import org . apache . cassandra . stress . StressProfile ; import org . apache . cassandra . stress . generate . DistributionFactory ; import org . apache . cassandra . stress . generate . PartitionGenerator ; import org . apache . cassandra . stress . generate . SeedManager ; import org . apache . cassandra . stress . operations . OpDistributionFactory ; import org . apache . cassandra . stress . operations . SampledOpDistributionFactory ; import org . apache . cassandra . stress . util . Timer ; public class SettingsCommandUser extends SettingsCommand { private final Map < String , Double > ratios ; private final DistributionFactory clustering ; public final StressProfile profile ; public SettingsCommandUser ( Options options ) { super ( Command . USER , options . parent ) ; clustering = options . clustering . get ( ) ; ratios = options . ops . ratios ( ) ; String yamlPath = options . profile . value ( ) ; File yamlFile = new File ( yamlPath ) ; profile = StressProfile . load ( yamlFile . exists ( ) ? yamlFile . toURI ( ) : URI . create ( yamlPath ) ) ; if ( ratios . size ( ) = = <int> ) throw new IllegalArgumentException ( <str> ) ; } public boolean hasInsertOnly ( ) { return ratios . size ( ) = = <int> & & ratios . containsKey ( <str> ) ; } public OpDistributionFactory getFactory ( final StressSettings settings ) { final SeedManager seeds = new SeedManager ( settings ) ; return new SampledOpDistributionFactory < String > ( ratios , clustering ) { protected List < ? extends Operation > get ( Timer timer , PartitionGenerator generator , String key ) { if ( key . equalsIgnoreCase ( <str> ) ) return Collections . singletonList ( profile . getInsert ( timer , generator , seeds , settings ) ) ; if ( key . equalsIgnoreCase ( <str> ) ) return profile . getValidate ( timer , generator , seeds , settings ) ; return Collections . singletonList ( profile . getQuery ( key , timer , generator , seeds , settings ) ) ; } protected PartitionGenerator newGenerator ( ) { return profile . newGenerator ( settings ) ; } } ; } public void truncateTables ( StressSettings settings ) { profile . truncateTable ( settings ) ; } static final class Options extends GroupedOptions { final SettingsCommand . Options parent ; protected Options ( SettingsCommand . Options parent ) { this . parent = parent ; } final OptionDistribution clustering = new OptionDistribution ( <str> , <str> , <str> ) ; final OptionSimple profile = new OptionSimple ( <str> , <str> , null , <str> , true ) ; final OptionAnyProbabilities ops = new OptionAnyProbabilities ( <str> , <str> ) ; @Override public List < ? extends Option > options ( ) { return merge ( Arrays . asList ( ops , profile , clustering ) , parent . options ( ) ) ; } } public static SettingsCommandUser build ( String [ ] params ) { GroupedOptions options = GroupedOptions . select ( params , new Options ( new Uncertainty ( ) ) , new Options ( new Duration ( ) ) , new Options ( new Count ( ) ) ) ; if ( options = = null ) { printHelp ( ) ; System . out . println ( <str> ) ; System . exit ( <int> ) ; } return new SettingsCommandUser ( ( Options ) options ) ; } public static void printHelp ( ) { GroupedOptions . printOptions ( System . out , <str> , new Options ( new Uncertainty ( ) ) , new Options ( new Count ( ) ) , new Options ( new Duration ( ) ) ) ; } public static Runnable helpPrinter ( ) { return new Runnable ( ) { @Override public void run ( ) { printHelp ( ) ; } } ; } } 
