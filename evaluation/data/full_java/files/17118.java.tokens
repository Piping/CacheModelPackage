package com . badlogic . gdx . physics . box2d . joints ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . physics . box2d . Body ; import com . badlogic . gdx . physics . box2d . JointDef ; public class RevoluteJointDef extends JointDef { public RevoluteJointDef ( ) { type = JointType . RevoluteJoint ; } public void initialize ( Body bodyA , Body bodyB , Vector2 anchor ) { this . bodyA = bodyA ; this . bodyB = bodyB ; localAnchorA . set ( bodyA . getLocalPoint ( anchor ) ) ; localAnchorB . set ( bodyB . getLocalPoint ( anchor ) ) ; referenceAngle = bodyB . getAngle ( ) - bodyA . getAngle ( ) ; } public final Vector2 localAnchorA = new Vector2 ( ) ; public final Vector2 localAnchorB = new Vector2 ( ) ; ; public float referenceAngle = <int> ; public boolean enableLimit = false ; public float lowerAngle = <int> ; public float upperAngle = <int> ; public boolean enableMotor = false ; public float motorSpeed = <int> ; public float maxMotorTorque = <int> ; @Override public org . jbox2d . dynamics . joints . JointDef toJBox2d ( ) { org . jbox2d . dynamics . joints . RevoluteJointDef jd = new org . jbox2d . dynamics . joints . RevoluteJointDef ( ) ; jd . bodyA = bodyA . body ; jd . bodyB = bodyB . body ; jd . collideConnected = collideConnected ; jd . enableLimit = enableLimit ; jd . enableMotor = enableMotor ; jd . localAnchorA . set ( localAnchorA . x , localAnchorA . y ) ; jd . localAnchorB . set ( localAnchorB . x , localAnchorB . y ) ; jd . lowerAngle = lowerAngle ; jd . maxMotorTorque = maxMotorTorque ; jd . motorSpeed = motorSpeed ; jd . referenceAngle = referenceAngle ; jd . type = org . jbox2d . dynamics . joints . JointType . REVOLUTE ; jd . upperAngle = upperAngle ; return jd ; } } 
