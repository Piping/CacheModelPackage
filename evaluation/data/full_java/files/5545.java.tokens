package org . elasticsearch . cluster . action . index ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaDataMappingService ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; public class NodeMappingRefreshAction extends AbstractComponent { public static final String ACTION_NAME = <str> ; private final TransportService transportService ; private final MetaDataMappingService metaDataMappingService ; @Inject public NodeMappingRefreshAction ( Settings settings , TransportService transportService , MetaDataMappingService metaDataMappingService ) { super ( settings ) ; this . transportService = transportService ; this . metaDataMappingService = metaDataMappingService ; transportService . registerRequestHandler ( ACTION_NAME , NodeMappingRefreshRequest : : new , ThreadPool . Names . SAME , new NodeMappingRefreshTransportHandler ( ) ) ; } public void nodeMappingRefresh ( final ClusterState state , final NodeMappingRefreshRequest request ) { final DiscoveryNodes nodes = state . nodes ( ) ; if ( nodes . masterNode ( ) = = null ) { logger . warn ( <str> , request . index ( ) ) ; return ; } transportService . sendRequest ( nodes . masterNode ( ) , ACTION_NAME , request , EmptyTransportResponseHandler . INSTANCE_SAME ) ; } private class NodeMappingRefreshTransportHandler implements TransportRequestHandler < NodeMappingRefreshRequest > { @Override public void messageReceived ( NodeMappingRefreshRequest request , TransportChannel channel ) throws Exception { metaDataMappingService . refreshMapping ( request . index ( ) , request . indexUUID ( ) ) ; channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } } public static class NodeMappingRefreshRequest extends TransportRequest implements IndicesRequest { private String index ; private String indexUUID = IndexMetaData . INDEX_UUID_NA_VALUE ; private String nodeId ; public NodeMappingRefreshRequest ( ) { } public NodeMappingRefreshRequest ( String index , String indexUUID , String nodeId ) { this . index = index ; this . indexUUID = indexUUID ; this . nodeId = nodeId ; } @Override public String [ ] indices ( ) { return new String [ ] { index } ; } @Override public IndicesOptions indicesOptions ( ) { return IndicesOptions . strictSingleIndexNoExpandForbidClosed ( ) ; } public String index ( ) { return index ; } public String indexUUID ( ) { return indexUUID ; } public String nodeId ( ) { return nodeId ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( index ) ; out . writeString ( nodeId ) ; out . writeString ( indexUUID ) ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; index = in . readString ( ) ; nodeId = in . readString ( ) ; indexUUID = in . readString ( ) ; } } } 
