package com . badlogic . gdx . backends . android . surfaceview ; import javax . microedition . khronos . egl . EGL10 ; import javax . microedition . khronos . egl . EGLConfig ; import javax . microedition . khronos . egl . EGLDisplay ; import android . opengl . GLSurfaceView ; import android . opengl . GLSurfaceView . EGLConfigChooser ; import android . util . Log ; public class GdxEglConfigChooser implements GLSurfaceView . EGLConfigChooser { private static final int EGL_OPENGL_ES2_BIT = <int> ; public static final int EGL_COVERAGE_BUFFERS_NV = <hex> ; public static final int EGL_COVERAGE_SAMPLES_NV = <hex> ; private static final String TAG = <str> ; protected int mRedSize ; protected int mGreenSize ; protected int mBlueSize ; protected int mAlphaSize ; protected int mDepthSize ; protected int mStencilSize ; protected int mNumSamples ; protected final int [ ] mConfigAttribs ; private int [ ] mValue = new int [ <int> ] ; public GdxEglConfigChooser ( int r , int g , int b , int a , int depth , int stencil , int numSamples ) { mRedSize = r ; mGreenSize = g ; mBlueSize = b ; mAlphaSize = a ; mDepthSize = depth ; mStencilSize = stencil ; mNumSamples = numSamples ; mConfigAttribs = new int [ ] { EGL10 . EGL_RED_SIZE , <int> , EGL10 . EGL_GREEN_SIZE , <int> , EGL10 . EGL_BLUE_SIZE , <int> , EGL10 . EGL_RENDERABLE_TYPE , EGL_OPENGL_ES2_BIT , EGL10 . EGL_NONE } ; } public EGLConfig chooseConfig ( EGL10 egl , EGLDisplay display ) { int [ ] num_config = new int [ <int> ] ; egl . eglChooseConfig ( display , mConfigAttribs , null , <int> , num_config ) ; int numConfigs = num_config [ <int> ] ; if ( numConfigs < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } EGLConfig [ ] configs = new EGLConfig [ numConfigs ] ; egl . eglChooseConfig ( display , mConfigAttribs , configs , numConfigs , num_config ) ; EGLConfig config = chooseConfig ( egl , display , configs ) ; return config ; } public EGLConfig chooseConfig ( EGL10 egl , EGLDisplay display , EGLConfig [ ] configs ) { EGLConfig best = null ; EGLConfig bestAA = null ; EGLConfig safe = null ; for ( EGLConfig config : configs ) { int d = findConfigAttrib ( egl , display , config , EGL10 . EGL_DEPTH_SIZE , <int> ) ; int s = findConfigAttrib ( egl , display , config , EGL10 . EGL_STENCIL_SIZE , <int> ) ; if ( d < mDepthSize | | s < mStencilSize ) continue ; int r = findConfigAttrib ( egl , display , config , EGL10 . EGL_RED_SIZE , <int> ) ; int g = findConfigAttrib ( egl , display , config , EGL10 . EGL_GREEN_SIZE , <int> ) ; int b = findConfigAttrib ( egl , display , config , EGL10 . EGL_BLUE_SIZE , <int> ) ; int a = findConfigAttrib ( egl , display , config , EGL10 . EGL_ALPHA_SIZE , <int> ) ; if ( safe = = null & & r = = <int> & & g = = <int> & & b = = <int> & & a = = <int> ) { safe = config ; } if ( best = = null & & r = = mRedSize & & g = = mGreenSize & & b = = mBlueSize & & a = = mAlphaSize ) { best = config ; if ( mNumSamples = = <int> ) { break ; } } int hasSampleBuffers = findConfigAttrib ( egl , display , config , EGL10 . EGL_SAMPLE_BUFFERS , <int> ) ; int numSamples = findConfigAttrib ( egl , display , config , EGL10 . EGL_SAMPLES , <int> ) ; if ( bestAA = = null & & hasSampleBuffers = = <int> & & numSamples > = mNumSamples & & r = = mRedSize & & g = = mGreenSize & & b = = mBlueSize & & a = = mAlphaSize ) { bestAA = config ; continue ; } hasSampleBuffers = findConfigAttrib ( egl , display , config , EGL_COVERAGE_BUFFERS_NV , <int> ) ; numSamples = findConfigAttrib ( egl , display , config , EGL_COVERAGE_SAMPLES_NV , <int> ) ; if ( bestAA = = null & & hasSampleBuffers = = <int> & & numSamples > = mNumSamples & & r = = mRedSize & & g = = mGreenSize & & b = = mBlueSize & & a = = mAlphaSize ) { bestAA = config ; continue ; } } if ( bestAA ! = null ) return bestAA ; else if ( best ! = null ) return best ; else return safe ; } private int findConfigAttrib ( EGL10 egl , EGLDisplay display , EGLConfig config , int attribute , int defaultValue ) { if ( egl . eglGetConfigAttrib ( display , config , attribute , mValue ) ) { return mValue [ <int> ] ; } return defaultValue ; } private void printConfigs ( EGL10 egl , EGLDisplay display , EGLConfig [ ] configs ) { int numConfigs = configs . length ; Log . w ( TAG , String . format ( <str> , numConfigs ) ) ; for ( int i = <int> ; i < numConfigs ; i + + ) { Log . w ( TAG , String . format ( <str> , i ) ) ; printConfig ( egl , display , configs [ i ] ) ; } } private void printConfig ( EGL10 egl , EGLDisplay display , EGLConfig config ) { int [ ] attributes = { EGL10 . EGL_BUFFER_SIZE , EGL10 . EGL_ALPHA_SIZE , EGL10 . EGL_BLUE_SIZE , EGL10 . EGL_GREEN_SIZE , EGL10 . EGL_RED_SIZE , EGL10 . EGL_DEPTH_SIZE , EGL10 . EGL_STENCIL_SIZE , EGL10 . EGL_CONFIG_CAVEAT , EGL10 . EGL_CONFIG_ID , EGL10 . EGL_LEVEL , EGL10 . EGL_MAX_PBUFFER_HEIGHT , EGL10 . EGL_MAX_PBUFFER_PIXELS , EGL10 . EGL_MAX_PBUFFER_WIDTH , EGL10 . EGL_NATIVE_RENDERABLE , EGL10 . EGL_NATIVE_VISUAL_ID , EGL10 . EGL_NATIVE_VISUAL_TYPE , <hex> , EGL10 . EGL_SAMPLES , EGL10 . EGL_SAMPLE_BUFFERS , EGL10 . EGL_SURFACE_TYPE , EGL10 . EGL_TRANSPARENT_TYPE , EGL10 . EGL_TRANSPARENT_RED_VALUE , EGL10 . EGL_TRANSPARENT_GREEN_VALUE , EGL10 . EGL_TRANSPARENT_BLUE_VALUE , <hex> , <hex> , <hex> , <hex> , EGL10 . EGL_LUMINANCE_SIZE , EGL10 . EGL_ALPHA_MASK_SIZE , EGL10 . EGL_COLOR_BUFFER_TYPE , EGL10 . EGL_RENDERABLE_TYPE , <hex> , EGL_COVERAGE_BUFFERS_NV , EGL_COVERAGE_SAMPLES_NV } ; String [ ] names = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; int [ ] value = new int [ <int> ] ; for ( int i = <int> ; i < attributes . length ; i + + ) { int attribute = attributes [ i ] ; String name = names [ i ] ; if ( egl . eglGetConfigAttrib ( display , config , attribute , value ) ) { Log . w ( TAG , String . format ( <str> , name , value [ <int> ] ) ) ; } else { egl . eglGetError ( ) ; } } } } 
