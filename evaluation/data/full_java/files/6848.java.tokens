package org . elasticsearch . indices . breaker ; import org . elasticsearch . common . breaker . ChildMemoryCircuitBreaker ; import org . elasticsearch . common . breaker . CircuitBreaker ; import org . elasticsearch . common . breaker . CircuitBreakingException ; import org . elasticsearch . common . breaker . NoopCircuitBreaker ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . node . settings . NodeSettingsService ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicLong ; public class HierarchyCircuitBreakerService extends CircuitBreakerService { private static final String CHILD_LOGGER_PREFIX = <str> ; private final ConcurrentMap < String , CircuitBreaker > breakers = new ConcurrentHashMap ( ) ; public static final String OLD_CIRCUIT_BREAKER_MAX_BYTES_SETTING = <str> ; public static final String OLD_CIRCUIT_BREAKER_OVERHEAD_SETTING = <str> ; public static final String TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING = <str> ; public static final String DEFAULT_TOTAL_CIRCUIT_BREAKER_LIMIT = <str> ; public static final String FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING = <str> ; public static final String FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING = <str> ; public static final String FIELDDATA_CIRCUIT_BREAKER_TYPE_SETTING = <str> ; public static final String DEFAULT_FIELDDATA_BREAKER_LIMIT = <str> ; public static final double DEFAULT_FIELDDATA_OVERHEAD_CONSTANT = <float> ; public static final String REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING = <str> ; public static final String REQUEST_CIRCUIT_BREAKER_OVERHEAD_SETTING = <str> ; public static final String REQUEST_CIRCUIT_BREAKER_TYPE_SETTING = <str> ; public static final String DEFAULT_REQUEST_BREAKER_LIMIT = <str> ; public static final String DEFAULT_BREAKER_TYPE = <str> ; private volatile BreakerSettings parentSettings ; private volatile BreakerSettings fielddataSettings ; private volatile BreakerSettings requestSettings ; private final AtomicLong parentTripCount = new AtomicLong ( <int> ) ; @Inject public HierarchyCircuitBreakerService ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; String compatibilityFielddataLimitDefault = DEFAULT_FIELDDATA_BREAKER_LIMIT ; ByteSizeValue compatibilityFielddataLimit = settings . getAsMemory ( OLD_CIRCUIT_BREAKER_MAX_BYTES_SETTING , null ) ; if ( compatibilityFielddataLimit ! = null ) { compatibilityFielddataLimitDefault = compatibilityFielddataLimit . toString ( ) ; } double compatibilityFielddataOverheadDefault = DEFAULT_FIELDDATA_OVERHEAD_CONSTANT ; Double compatibilityFielddataOverhead = settings . getAsDouble ( OLD_CIRCUIT_BREAKER_OVERHEAD_SETTING , null ) ; if ( compatibilityFielddataOverhead ! = null ) { compatibilityFielddataOverheadDefault = compatibilityFielddataOverhead ; } this . fielddataSettings = new BreakerSettings ( CircuitBreaker . FIELDDATA , settings . getAsMemory ( FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING , compatibilityFielddataLimitDefault ) . bytes ( ) , settings . getAsDouble ( FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING , compatibilityFielddataOverheadDefault ) , CircuitBreaker . Type . parseValue ( settings . get ( FIELDDATA_CIRCUIT_BREAKER_TYPE_SETTING , DEFAULT_BREAKER_TYPE ) ) ) ; this . requestSettings = new BreakerSettings ( CircuitBreaker . REQUEST , settings . getAsMemory ( REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING , DEFAULT_REQUEST_BREAKER_LIMIT ) . bytes ( ) , settings . getAsDouble ( REQUEST_CIRCUIT_BREAKER_OVERHEAD_SETTING , <float> ) , CircuitBreaker . Type . parseValue ( settings . get ( REQUEST_CIRCUIT_BREAKER_TYPE_SETTING , DEFAULT_BREAKER_TYPE ) ) ) ; this . parentSettings = new BreakerSettings ( CircuitBreaker . PARENT , settings . getAsMemory ( TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING , DEFAULT_TOTAL_CIRCUIT_BREAKER_LIMIT ) . bytes ( ) , <float> , CircuitBreaker . Type . PARENT ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , this . parentSettings ) ; } registerBreaker ( this . requestSettings ) ; registerBreaker ( this . fielddataSettings ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } public class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { ByteSizeValue newFielddataMax = settings . getAsMemory ( FIELDDATA_CIRCUIT_BREAKER_LIMIT_SETTING , null ) ; Double newFielddataOverhead = settings . getAsDouble ( FIELDDATA_CIRCUIT_BREAKER_OVERHEAD_SETTING , null ) ; if ( newFielddataMax ! = null | | newFielddataOverhead ! = null ) { long newFielddataLimitBytes = newFielddataMax = = null ? HierarchyCircuitBreakerService . this . fielddataSettings . getLimit ( ) : newFielddataMax . bytes ( ) ; newFielddataOverhead = newFielddataOverhead = = null ? HierarchyCircuitBreakerService . this . fielddataSettings . getOverhead ( ) : newFielddataOverhead ; BreakerSettings newFielddataSettings = new BreakerSettings ( CircuitBreaker . FIELDDATA , newFielddataLimitBytes , newFielddataOverhead , HierarchyCircuitBreakerService . this . fielddataSettings . getType ( ) ) ; registerBreaker ( newFielddataSettings ) ; HierarchyCircuitBreakerService . this . fielddataSettings = newFielddataSettings ; logger . info ( <str> , newFielddataSettings ) ; } ByteSizeValue newRequestMax = settings . getAsMemory ( REQUEST_CIRCUIT_BREAKER_LIMIT_SETTING , null ) ; Double newRequestOverhead = settings . getAsDouble ( REQUEST_CIRCUIT_BREAKER_OVERHEAD_SETTING , null ) ; if ( newRequestMax ! = null | | newRequestOverhead ! = null ) { long newRequestLimitBytes = newRequestMax = = null ? HierarchyCircuitBreakerService . this . requestSettings . getLimit ( ) : newRequestMax . bytes ( ) ; newRequestOverhead = newRequestOverhead = = null ? HierarchyCircuitBreakerService . this . requestSettings . getOverhead ( ) : newRequestOverhead ; BreakerSettings newRequestSettings = new BreakerSettings ( CircuitBreaker . REQUEST , newRequestLimitBytes , newRequestOverhead , HierarchyCircuitBreakerService . this . requestSettings . getType ( ) ) ; registerBreaker ( newRequestSettings ) ; HierarchyCircuitBreakerService . this . requestSettings = newRequestSettings ; logger . info ( <str> , newRequestSettings ) ; } long oldParentMax = HierarchyCircuitBreakerService . this . parentSettings . getLimit ( ) ; ByteSizeValue newParentMax = settings . getAsMemory ( TOTAL_CIRCUIT_BREAKER_LIMIT_SETTING , null ) ; if ( newParentMax ! = null & & ( newParentMax . bytes ( ) ! = oldParentMax ) ) { BreakerSettings newParentSettings = new BreakerSettings ( CircuitBreaker . PARENT , newParentMax . bytes ( ) , <float> , CircuitBreaker . Type . PARENT ) ; validateSettings ( new BreakerSettings [ ] { newParentSettings } ) ; HierarchyCircuitBreakerService . this . parentSettings = newParentSettings ; logger . info ( <str> , newParentSettings ) ; } } } public static void validateSettings ( BreakerSettings [ ] childrenSettings ) throws IllegalStateException { for ( BreakerSettings childSettings : childrenSettings ) { if ( childSettings . getLimit ( ) = = - <int> ) { continue ; } if ( childSettings . getOverhead ( ) < <int> ) { throw new IllegalStateException ( <str> + childSettings + <str> ) ; } } } @Override public CircuitBreaker getBreaker ( String name ) { return this . breakers . get ( name ) ; } @Override public AllCircuitBreakerStats stats ( ) { long parentEstimated = <int> ; List < CircuitBreakerStats > allStats = new ArrayList < > ( ) ; for ( CircuitBreaker breaker : this . breakers . values ( ) ) { allStats . add ( stats ( breaker . getName ( ) ) ) ; parentEstimated + = breaker . getUsed ( ) ; } allStats . add ( new CircuitBreakerStats ( CircuitBreaker . PARENT , parentSettings . getLimit ( ) , parentEstimated , <float> , parentTripCount . get ( ) ) ) ; return new AllCircuitBreakerStats ( allStats . toArray ( new CircuitBreakerStats [ allStats . size ( ) ] ) ) ; } @Override public CircuitBreakerStats stats ( String name ) { CircuitBreaker breaker = this . breakers . get ( name ) ; return new CircuitBreakerStats ( breaker . getName ( ) , breaker . getLimit ( ) , breaker . getUsed ( ) , breaker . getOverhead ( ) , breaker . getTrippedCount ( ) ) ; } public void checkParentLimit ( String label ) throws CircuitBreakingException { long totalUsed = <int> ; for ( CircuitBreaker breaker : this . breakers . values ( ) ) { totalUsed + = ( breaker . getUsed ( ) * breaker . getOverhead ( ) ) ; } long parentLimit = this . parentSettings . getLimit ( ) ; if ( totalUsed > parentLimit ) { this . parentTripCount . incrementAndGet ( ) ; throw new CircuitBreakingException ( <str> + label + <str> + parentLimit + <str> + new ByteSizeValue ( parentLimit ) + <str> , totalUsed , parentLimit ) ; } } @Override public void registerBreaker ( BreakerSettings breakerSettings ) { validateSettings ( new BreakerSettings [ ] { breakerSettings } ) ; if ( breakerSettings . getType ( ) = = CircuitBreaker . Type . NOOP ) { CircuitBreaker breaker = new NoopCircuitBreaker ( breakerSettings . getName ( ) ) ; breakers . put ( breakerSettings . getName ( ) , breaker ) ; } else { CircuitBreaker oldBreaker ; CircuitBreaker breaker = new ChildMemoryCircuitBreaker ( breakerSettings , Loggers . getLogger ( CHILD_LOGGER_PREFIX + breakerSettings . getName ( ) ) , this , breakerSettings . getName ( ) ) ; for ( ; ; ) { oldBreaker = breakers . putIfAbsent ( breakerSettings . getName ( ) , breaker ) ; if ( oldBreaker = = null ) { return ; } breaker = new ChildMemoryCircuitBreaker ( breakerSettings , ( ChildMemoryCircuitBreaker ) oldBreaker , Loggers . getLogger ( CHILD_LOGGER_PREFIX + breakerSettings . getName ( ) ) , this , breakerSettings . getName ( ) ) ; if ( breakers . replace ( breakerSettings . getName ( ) , oldBreaker , breaker ) ) { return ; } } } } } 
