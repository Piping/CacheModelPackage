package org . elasticsearch . index . query ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermRangeQuery ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . joda . DateMathParser ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . common . lucene . BytesRefs ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . core . DateFieldMapper ; import org . joda . time . DateTimeZone ; import java . io . IOException ; import java . util . Objects ; public class RangeQueryBuilder extends AbstractQueryBuilder < RangeQueryBuilder > implements MultiTermQueryBuilder < RangeQueryBuilder > { public static final boolean DEFAULT_INCLUDE_UPPER = true ; public static final boolean DEFAULT_INCLUDE_LOWER = true ; public static final String NAME = <str> ; private final String fieldName ; private Object from ; private Object to ; private DateTimeZone timeZone ; private boolean includeLower = DEFAULT_INCLUDE_LOWER ; private boolean includeUpper = DEFAULT_INCLUDE_UPPER ; private FormatDateTimeFormatter format ; static final RangeQueryBuilder PROTOTYPE = new RangeQueryBuilder ( <str> ) ; public RangeQueryBuilder ( String fieldName ) { if ( Strings . isEmpty ( fieldName ) ) { throw new IllegalArgumentException ( <str> ) ; } this . fieldName = fieldName ; } public String fieldName ( ) { return this . fieldName ; } public RangeQueryBuilder from ( Object from , boolean includeLower ) { this . from = convertToBytesRefIfString ( from ) ; this . includeLower = includeLower ; return this ; } public RangeQueryBuilder from ( Object from ) { return from ( from , this . includeLower ) ; } public Object from ( ) { return convertToStringIfBytesRef ( this . from ) ; } public RangeQueryBuilder gt ( Object from ) { return from ( from , false ) ; } public RangeQueryBuilder gte ( Object from ) { return from ( from , true ) ; } public RangeQueryBuilder to ( Object to , boolean includeUpper ) { this . to = convertToBytesRefIfString ( to ) ; this . includeUpper = includeUpper ; return this ; } public RangeQueryBuilder to ( Object to ) { return to ( to , this . includeUpper ) ; } public Object to ( ) { return convertToStringIfBytesRef ( this . to ) ; } public RangeQueryBuilder lt ( Object to ) { return to ( to , false ) ; } public RangeQueryBuilder lte ( Object to ) { return to ( to , true ) ; } public RangeQueryBuilder includeLower ( boolean includeLower ) { this . includeLower = includeLower ; return this ; } public boolean includeLower ( ) { return this . includeLower ; } public RangeQueryBuilder includeUpper ( boolean includeUpper ) { this . includeUpper = includeUpper ; return this ; } public boolean includeUpper ( ) { return this . includeUpper ; } public RangeQueryBuilder timeZone ( String timeZone ) { if ( timeZone = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . timeZone = DateTimeZone . forID ( timeZone ) ; return this ; } public String timeZone ( ) { return this . timeZone = = null ? null : this . timeZone . getID ( ) ; } public RangeQueryBuilder format ( String format ) { if ( format = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . format = Joda . forPattern ( format ) ; return this ; } public String format ( ) { return this . format = = null ? null : this . format . format ( ) ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . startObject ( fieldName ) ; builder . field ( RangeQueryParser . FROM_FIELD . getPreferredName ( ) , convertToStringIfBytesRef ( this . from ) ) ; builder . field ( RangeQueryParser . TO_FIELD . getPreferredName ( ) , convertToStringIfBytesRef ( this . to ) ) ; builder . field ( RangeQueryParser . INCLUDE_LOWER_FIELD . getPreferredName ( ) , includeLower ) ; builder . field ( RangeQueryParser . INCLUDE_UPPER_FIELD . getPreferredName ( ) , includeUpper ) ; if ( timeZone ! = null ) { builder . field ( RangeQueryParser . TIME_ZONE_FIELD . getPreferredName ( ) , timeZone . getID ( ) ) ; } if ( format ! = null ) { builder . field ( RangeQueryParser . FORMAT_FIELD . getPreferredName ( ) , format . format ( ) ) ; } printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; builder . endObject ( ) ; } @Override public String getWriteableName ( ) { return NAME ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { Query query = null ; MappedFieldType mapper = context . fieldMapper ( this . fieldName ) ; if ( mapper ! = null ) { if ( mapper instanceof DateFieldMapper . DateFieldType ) { DateMathParser forcedDateParser = null ; if ( this . format ! = null ) { forcedDateParser = new DateMathParser ( this . format ) ; } query = ( ( DateFieldMapper . DateFieldType ) mapper ) . rangeQuery ( from , to , includeLower , includeUpper , timeZone , forcedDateParser ) ; } else { if ( timeZone ! = null ) { throw new QueryShardException ( context , <str> + fieldName + <str> ) ; } query = mapper . rangeQuery ( from , to , includeLower , includeUpper ) ; } } else { if ( timeZone ! = null ) { throw new QueryShardException ( context , <str> + fieldName + <str> ) ; } } if ( query = = null ) { query = new TermRangeQuery ( this . fieldName , BytesRefs . toBytesRef ( from ) , BytesRefs . toBytesRef ( to ) , includeLower , includeUpper ) ; } return query ; } @Override protected RangeQueryBuilder doReadFrom ( StreamInput in ) throws IOException { RangeQueryBuilder rangeQueryBuilder = new RangeQueryBuilder ( in . readString ( ) ) ; rangeQueryBuilder . from = in . readGenericValue ( ) ; rangeQueryBuilder . to = in . readGenericValue ( ) ; rangeQueryBuilder . includeLower = in . readBoolean ( ) ; rangeQueryBuilder . includeUpper = in . readBoolean ( ) ; String timeZoneId = in . readOptionalString ( ) ; if ( timeZoneId ! = null ) { rangeQueryBuilder . timeZone = DateTimeZone . forID ( timeZoneId ) ; } String formatString = in . readOptionalString ( ) ; if ( formatString ! = null ) { rangeQueryBuilder . format = Joda . forPattern ( formatString ) ; } return rangeQueryBuilder ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeString ( this . fieldName ) ; out . writeGenericValue ( this . from ) ; out . writeGenericValue ( this . to ) ; out . writeBoolean ( this . includeLower ) ; out . writeBoolean ( this . includeUpper ) ; String timeZoneId = null ; if ( this . timeZone ! = null ) { timeZoneId = this . timeZone . getID ( ) ; } out . writeOptionalString ( timeZoneId ) ; String formatString = null ; if ( this . format ! = null ) { formatString = this . format . format ( ) ; } out . writeOptionalString ( formatString ) ; } @Override protected int doHashCode ( ) { String timeZoneId = timeZone = = null ? null : timeZone . getID ( ) ; String formatString = format = = null ? null : format . format ( ) ; return Objects . hash ( fieldName , from , to , timeZoneId , includeLower , includeUpper , formatString ) ; } @Override protected boolean doEquals ( RangeQueryBuilder other ) { String timeZoneId = timeZone = = null ? null : timeZone . getID ( ) ; String formatString = format = = null ? null : format . format ( ) ; return Objects . equals ( fieldName , other . fieldName ) & & Objects . equals ( from , other . from ) & & Objects . equals ( to , other . to ) & & Objects . equals ( timeZoneId , other . timeZone ( ) ) & & Objects . equals ( includeLower , other . includeLower ) & & Objects . equals ( includeUpper , other . includeUpper ) & & Objects . equals ( formatString , other . format ( ) ) ; } } 
