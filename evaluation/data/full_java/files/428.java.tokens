package org . apache . cassandra . db . marshal ; import java . io . IOException ; import java . lang . reflect . Method ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Map ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . cql3 . CQL3Type ; import org . apache . cassandra . cql3 . Term ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . exceptions . SyntaxException ; import org . apache . cassandra . serializers . TypeSerializer ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . FastByteOperations ; import org . github . jamm . Unmetered ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . apache . cassandra . db . marshal . AbstractType . ComparisonType . CUSTOM ; import static org . apache . cassandra . db . marshal . AbstractType . ComparisonType . NOT_COMPARABLE ; @Unmetered public abstract class AbstractType < T > implements Comparator < ByteBuffer > { private static final Logger logger = LoggerFactory . getLogger ( AbstractType . class ) ; public final Comparator < ByteBuffer > reverseComparator ; public static enum ComparisonType { NOT_COMPARABLE , BYTE_ORDER , CUSTOM } public final ComparisonType comparisonType ; public final boolean isByteOrderComparable ; protected AbstractType ( ComparisonType comparisonType ) { this . comparisonType = comparisonType ; this . isByteOrderComparable = comparisonType = = ComparisonType . BYTE_ORDER ; reverseComparator = ( o1 , o2 ) - > AbstractType . this . compare ( o2 , o1 ) ; try { Method custom = getClass ( ) . getMethod ( <str> , ByteBuffer . class , ByteBuffer . class ) ; if ( ( custom . getDeclaringClass ( ) = = AbstractType . class ) = = ( comparisonType = = CUSTOM ) ) throw new IllegalStateException ( ( comparisonType = = CUSTOM ? <str> : <str> ) + <str> + getClass ( ) . getSimpleName ( ) + <str> ) ; } catch ( NoSuchMethodException e ) { throw new IllegalStateException ( ) ; } } public static List < String > asCQLTypeStringList ( List < AbstractType < ? > > abstractTypes ) { List < String > r = new ArrayList < > ( abstractTypes . size ( ) ) ; for ( AbstractType < ? > abstractType : abstractTypes ) r . add ( abstractType . asCQL3Type ( ) . toString ( ) ) ; return r ; } public T compose ( ByteBuffer bytes ) { return getSerializer ( ) . deserialize ( bytes ) ; } public ByteBuffer decompose ( T value ) { return getSerializer ( ) . serialize ( value ) ; } public String getString ( ByteBuffer bytes ) { if ( bytes = = null ) return <str> ; TypeSerializer < T > serializer = getSerializer ( ) ; serializer . validate ( bytes ) ; return serializer . toString ( serializer . deserialize ( bytes ) ) ; } public abstract ByteBuffer fromString ( String source ) throws MarshalException ; public abstract Term fromJSONObject ( Object parsed ) throws MarshalException ; public String toJSONString ( ByteBuffer buffer , int protocolVersion ) { return <str> + getSerializer ( ) . deserialize ( buffer ) . toString ( ) + <str> ; } public void validate ( ByteBuffer bytes ) throws MarshalException { getSerializer ( ) . validate ( bytes ) ; } public final int compare ( ByteBuffer left , ByteBuffer right ) { return isByteOrderComparable ? FastByteOperations . compareUnsigned ( left , right ) : compareCustom ( left , right ) ; } public int compareCustom ( ByteBuffer left , ByteBuffer right ) { throw new UnsupportedOperationException ( ) ; } public void validateCellValue ( ByteBuffer cellValue ) throws MarshalException { validate ( cellValue ) ; } public CQL3Type asCQL3Type ( ) { return new CQL3Type . Custom ( this ) ; } public int compareForCQL ( ByteBuffer v1 , ByteBuffer v2 ) { return compare ( v1 , v2 ) ; } public abstract TypeSerializer < T > getSerializer ( ) ; public String getString ( Collection < ByteBuffer > names ) { StringBuilder builder = new StringBuilder ( ) ; for ( ByteBuffer name : names ) { builder . append ( getString ( name ) ) . append ( <str> ) ; } return builder . toString ( ) ; } public boolean isCounter ( ) { return false ; } public boolean isFrozenCollection ( ) { return isCollection ( ) & & ! isMultiCell ( ) ; } public boolean isReversed ( ) { return false ; } public static AbstractType < ? > parseDefaultParameters ( AbstractType < ? > baseType , TypeParser parser ) throws SyntaxException { Map < String , String > parameters = parser . getKeyValueParameters ( ) ; String reversed = parameters . get ( <str> ) ; if ( reversed ! = null & & ( reversed . isEmpty ( ) | | reversed . equals ( <str> ) ) ) { return ReversedType . getInstance ( baseType ) ; } else { return baseType ; } } public boolean isCompatibleWith ( AbstractType < ? > previous ) { return this . equals ( previous ) ; } public boolean isValueCompatibleWith ( AbstractType < ? > otherType ) { return isValueCompatibleWithInternal ( ( otherType instanceof ReversedType ) ? ( ( ReversedType ) otherType ) . baseType : otherType ) ; } protected boolean isValueCompatibleWithInternal ( AbstractType < ? > otherType ) { return isCompatibleWith ( otherType ) ; } public int compareCollectionMembers ( ByteBuffer v1 , ByteBuffer v2 , ByteBuffer collectionName ) { return compare ( v1 , v2 ) ; } public void validateCollectionMember ( ByteBuffer bytes , ByteBuffer collectionName ) throws MarshalException { validate ( bytes ) ; } public boolean isCollection ( ) { return false ; } public boolean isMultiCell ( ) { return false ; } public AbstractType < ? > freeze ( ) { return this ; } public boolean isEmptyValueMeaningless ( ) { return false ; } public String toString ( boolean ignoreFreezing ) { return this . toString ( ) ; } public int componentsCount ( ) { return <int> ; } public List < AbstractType < ? > > getComponents ( ) { return Collections . < AbstractType < ? > > singletonList ( this ) ; } protected int valueLengthIfFixed ( ) { return - <int> ; } public void writeValue ( ByteBuffer value , DataOutputPlus out ) throws IOException { assert value . hasRemaining ( ) ; if ( valueLengthIfFixed ( ) > = <int> ) out . write ( value ) ; else ByteBufferUtil . writeWithVIntLength ( value , out ) ; } public long writtenLength ( ByteBuffer value ) { assert value . hasRemaining ( ) ; return valueLengthIfFixed ( ) > = <int> ? value . remaining ( ) : TypeSizes . sizeofWithVIntLength ( value ) ; } public ByteBuffer readValue ( DataInputPlus in ) throws IOException { int length = valueLengthIfFixed ( ) ; if ( length > = <int> ) return ByteBufferUtil . read ( in , length ) ; else return ByteBufferUtil . readWithVIntLength ( in ) ; } public void skipValue ( DataInputPlus in ) throws IOException { int length = valueLengthIfFixed ( ) ; if ( length > = <int> ) in . skipBytesFully ( length ) ; else ByteBufferUtil . skipWithVIntLength ( in ) ; } public boolean references ( AbstractType < ? > check ) { return this . equals ( check ) ; } @Override public String toString ( ) { return getClass ( ) . getName ( ) ; } public void checkComparable ( ) { switch ( comparisonType ) { case NOT_COMPARABLE : throw new IllegalArgumentException ( this + <str> ) ; } } } 
