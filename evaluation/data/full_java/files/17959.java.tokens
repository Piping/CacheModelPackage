package com . badlogic . gdx . graphics . g2d ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . files . FileHandle ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . g2d . GlyphLayout . GlyphRun ; import com . badlogic . gdx . graphics . g2d . TextureAtlas . AtlasRegion ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . FloatArray ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . StreamUtils ; public class BitmapFont implements Disposable { static private final int LOG2_PAGE_SIZE = <int> ; static private final int PAGE_SIZE = <int> < < LOG2_PAGE_SIZE ; static private final int PAGES = <hex> / PAGE_SIZE ; final BitmapFontData data ; Array < TextureRegion > regions ; private final BitmapFontCache cache ; private boolean flipped ; boolean integer ; private boolean ownsTexture ; public BitmapFont ( ) { this ( Gdx . files . classpath ( <str> ) , Gdx . files . classpath ( <str> ) , false , true ) ; } public BitmapFont ( boolean flip ) { this ( Gdx . files . classpath ( <str> ) , Gdx . files . classpath ( <str> ) , flip , true ) ; } public BitmapFont ( FileHandle fontFile , TextureRegion region ) { this ( fontFile , region , false ) ; } public BitmapFont ( FileHandle fontFile , TextureRegion region , boolean flip ) { this ( new BitmapFontData ( fontFile , flip ) , region , true ) ; } public BitmapFont ( FileHandle fontFile ) { this ( fontFile , false ) ; } public BitmapFont ( FileHandle fontFile , boolean flip ) { this ( new BitmapFontData ( fontFile , flip ) , ( TextureRegion ) null , true ) ; } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip ) { this ( fontFile , imageFile , flip , true ) ; } public BitmapFont ( FileHandle fontFile , FileHandle imageFile , boolean flip , boolean integer ) { this ( new BitmapFontData ( fontFile , flip ) , new TextureRegion ( new Texture ( imageFile , false ) ) , integer ) ; ownsTexture = true ; } public BitmapFont ( BitmapFontData data , TextureRegion region , boolean integer ) { this ( data , region ! = null ? Array . with ( region ) : null , integer ) ; } public BitmapFont ( BitmapFontData data , Array < TextureRegion > pageRegions , boolean integer ) { this . flipped = data . flipped ; this . data = data ; this . integer = integer ; if ( pageRegions = = null | | pageRegions . size = = <int> ) { int n = data . imagePaths . length ; regions = new Array ( n ) ; for ( int i = <int> ; i < n ; i + + ) { FileHandle file ; if ( data . fontFile = = null ) file = Gdx . files . internal ( data . imagePaths [ i ] ) ; else file = Gdx . files . getFileHandle ( data . imagePaths [ i ] , data . fontFile . type ( ) ) ; regions . add ( new TextureRegion ( new Texture ( file , false ) ) ) ; } ownsTexture = true ; } else { regions = pageRegions ; ownsTexture = false ; } cache = newFontCache ( ) ; load ( data ) ; } protected void load ( BitmapFontData data ) { for ( Glyph [ ] page : data . glyphs ) { if ( page = = null ) continue ; for ( Glyph glyph : page ) if ( glyph ! = null ) data . setGlyphRegion ( glyph , regions . get ( glyph . page ) ) ; } if ( data . missingGlyph ! = null ) data . setGlyphRegion ( data . missingGlyph , regions . get ( data . missingGlyph . page ) ) ; } public GlyphLayout draw ( Batch batch , CharSequence str , float x , float y ) { cache . clear ( ) ; GlyphLayout layout = cache . addText ( str , x , y ) ; cache . draw ( batch ) ; return layout ; } public GlyphLayout draw ( Batch batch , CharSequence str , float x , float y , float targetWidth , int halign , boolean wrap ) { cache . clear ( ) ; GlyphLayout layout = cache . addText ( str , x , y , targetWidth , halign , wrap ) ; cache . draw ( batch ) ; return layout ; } public GlyphLayout draw ( Batch batch , CharSequence str , float x , float y , int start , int end , float targetWidth , int halign , boolean wrap ) { cache . clear ( ) ; GlyphLayout layout = cache . addText ( str , x , y , start , end , targetWidth , halign , wrap ) ; cache . draw ( batch ) ; return layout ; } public GlyphLayout draw ( Batch batch , CharSequence str , float x , float y , int start , int end , float targetWidth , int halign , boolean wrap , String truncate ) { cache . clear ( ) ; GlyphLayout layout = cache . addText ( str , x , y , start , end , targetWidth , halign , wrap , truncate ) ; cache . draw ( batch ) ; return layout ; } public void draw ( Batch batch , GlyphLayout layout , float x , float y ) { cache . clear ( ) ; cache . addText ( layout , x , y ) ; cache . draw ( batch ) ; } public Color getColor ( ) { return cache . getColor ( ) ; } public void setColor ( Color color ) { cache . getColor ( ) . set ( color ) ; } public void setColor ( float r , float g , float b , float a ) { cache . getColor ( ) . set ( r , g , b , a ) ; } public float getScaleX ( ) { return data . scaleX ; } public float getScaleY ( ) { return data . scaleY ; } public TextureRegion getRegion ( ) { return regions . first ( ) ; } public Array < TextureRegion > getRegions ( ) { return regions ; } public TextureRegion getRegion ( int index ) { return regions . get ( index ) ; } public float getLineHeight ( ) { return data . lineHeight ; } public float getSpaceWidth ( ) { return data . spaceWidth ; } public float getXHeight ( ) { return data . xHeight ; } public float getCapHeight ( ) { return data . capHeight ; } public float getAscent ( ) { return data . ascent ; } public float getDescent ( ) { return data . descent ; } public boolean isFlipped ( ) { return flipped ; } public void dispose ( ) { if ( ownsTexture ) { for ( int i = <int> ; i < regions . size ; i + + ) regions . get ( i ) . getTexture ( ) . dispose ( ) ; } } public void setFixedWidthGlyphs ( CharSequence glyphs ) { BitmapFontData data = this . data ; int maxAdvance = <int> ; for ( int index = <int> , end = glyphs . length ( ) ; index < end ; index + + ) { Glyph g = data . getGlyph ( glyphs . charAt ( index ) ) ; if ( g ! = null & & g . xadvance > maxAdvance ) maxAdvance = g . xadvance ; } for ( int index = <int> , end = glyphs . length ( ) ; index < end ; index + + ) { Glyph g = data . getGlyph ( glyphs . charAt ( index ) ) ; if ( g = = null ) continue ; g . xoffset + = Math . round ( ( maxAdvance - g . xadvance ) / <int> ) ; g . xadvance = maxAdvance ; g . kerning = null ; g . fixedWidth = true ; } } public void setUseIntegerPositions ( boolean integer ) { this . integer = integer ; cache . setUseIntegerPositions ( integer ) ; } public boolean usesIntegerPositions ( ) { return integer ; } public BitmapFontCache getCache ( ) { return cache ; } public BitmapFontData getData ( ) { return data ; } public boolean ownsTexture ( ) { return ownsTexture ; } public void setOwnsTexture ( boolean ownsTexture ) { this . ownsTexture = ownsTexture ; } public BitmapFontCache newFontCache ( ) { return new BitmapFontCache ( this , integer ) ; } public String toString ( ) { if ( data . fontFile ! = null ) return data . fontFile . nameWithoutExtension ( ) ; return super . toString ( ) ; } public static class Glyph { public int id ; public int srcX ; public int srcY ; public int width , height ; public float u , v , u2 , v2 ; public int xoffset , yoffset ; public int xadvance ; public byte [ ] [ ] kerning ; public boolean fixedWidth ; public int page = <int> ; public int getKerning ( char ch ) { if ( kerning ! = null ) { byte [ ] page = kerning [ ch > > > LOG2_PAGE_SIZE ] ; if ( page ! = null ) return page [ ch & PAGE_SIZE - <int> ] ; } return <int> ; } public void setKerning ( int ch , int value ) { if ( kerning = = null ) kerning = new byte [ PAGES ] [ ] ; byte [ ] page = kerning [ ch > > > LOG2_PAGE_SIZE ] ; if ( page = = null ) kerning [ ch > > > LOG2_PAGE_SIZE ] = page = new byte [ PAGE_SIZE ] ; page [ ch & PAGE_SIZE - <int> ] = ( byte ) value ; } public String toString ( ) { return Character . toString ( ( char ) id ) ; } } static int indexOf ( CharSequence text , char ch , int start ) { final int n = text . length ( ) ; for ( ; start < n ; start + + ) if ( text . charAt ( start ) = = ch ) return start ; return n ; } static public class BitmapFontData { public String [ ] imagePaths ; public FileHandle fontFile ; public boolean flipped ; public float padTop , padRight , padBottom , padLeft ; public float lineHeight ; public float capHeight = <int> ; public float ascent ; public float descent ; public float down ; public float scaleX = <int> , scaleY = <int> ; public boolean markupEnabled ; public float cursorX ; public final Glyph [ ] [ ] glyphs = new Glyph [ PAGES ] [ ] ; public Glyph missingGlyph ; public float spaceWidth ; public float xHeight = <int> ; public char [ ] breakChars ; public char [ ] xChars = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; public char [ ] capChars = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; public BitmapFontData ( ) { } public BitmapFontData ( FileHandle fontFile , boolean flip ) { this . fontFile = fontFile ; this . flipped = flip ; load ( fontFile , flip ) ; } public void load ( FileHandle fontFile , boolean flip ) { if ( imagePaths ! = null ) throw new IllegalStateException ( <str> ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( fontFile . read ( ) ) , <int> ) ; try { String line = reader . readLine ( ) ; if ( line = = null ) throw new GdxRuntimeException ( <str> ) ; line = line . substring ( line . indexOf ( <str> ) + <int> ) ; String [ ] padding = line . substring ( <int> , line . indexOf ( <str> ) ) . split ( <str> , <int> ) ; if ( padding . length ! = <int> ) throw new GdxRuntimeException ( <str> ) ; padTop = Integer . parseInt ( padding [ <int> ] ) ; padLeft = Integer . parseInt ( padding [ <int> ] ) ; padBottom = Integer . parseInt ( padding [ <int> ] ) ; padRight = Integer . parseInt ( padding [ <int> ] ) ; float padY = padTop + padBottom ; line = reader . readLine ( ) ; if ( line = = null ) throw new GdxRuntimeException ( <str> ) ; String [ ] common = line . split ( <str> , <int> ) ; if ( common . length < <int> ) throw new GdxRuntimeException ( <str> ) ; if ( ! common [ <int> ] . startsWith ( <str> ) ) throw new GdxRuntimeException ( <str> ) ; lineHeight = Integer . parseInt ( common [ <int> ] . substring ( <int> ) ) ; if ( ! common [ <int> ] . startsWith ( <str> ) ) throw new GdxRuntimeException ( <str> ) ; float baseLine = Integer . parseInt ( common [ <int> ] . substring ( <int> ) ) ; int pageCount = <int> ; if ( common . length > = <int> & & common [ <int> ] ! = null & & common [ <int> ] . startsWith ( <str> ) ) { try { pageCount = Math . max ( <int> , Integer . parseInt ( common [ <int> ] . substring ( <int> ) ) ) ; } catch ( NumberFormatException ignored ) { } } imagePaths = new String [ pageCount ] ; for ( int p = <int> ; p < pageCount ; p + + ) { line = reader . readLine ( ) ; if ( line = = null ) throw new GdxRuntimeException ( <str> ) ; String [ ] pageLine = line . split ( <str> , <int> ) ; if ( ! pageLine [ <int> ] . startsWith ( <str> ) ) throw new GdxRuntimeException ( <str> ) ; if ( pageLine [ <int> ] . startsWith ( <str> ) ) { try { int pageID = Integer . parseInt ( pageLine [ <int> ] . substring ( <int> ) ) ; if ( pageID ! = p ) throw new GdxRuntimeException ( <str> + pageLine [ <int> ] . substring ( <int> ) ) ; } catch ( NumberFormatException ex ) { throw new GdxRuntimeException ( <str> + pageLine [ <int> ] . substring ( <int> ) , ex ) ; } } String fileName = null ; if ( pageLine [ <int> ] . endsWith ( <str> ) ) { fileName = pageLine [ <int> ] . substring ( <int> , pageLine [ <int> ] . length ( ) - <int> ) ; } else { fileName = pageLine [ <int> ] . substring ( <int> , pageLine [ <int> ] . length ( ) ) ; } imagePaths [ p ] = fontFile . parent ( ) . child ( fileName ) . path ( ) . replaceAll ( <str> , <str> ) ; } descent = <int> ; while ( true ) { line = reader . readLine ( ) ; if ( line = = null ) break ; if ( line . startsWith ( <str> ) ) break ; if ( ! line . startsWith ( <str> ) ) continue ; Glyph glyph = new Glyph ( ) ; StringTokenizer tokens = new StringTokenizer ( line , <str> ) ; tokens . nextToken ( ) ; tokens . nextToken ( ) ; int ch = Integer . parseInt ( tokens . nextToken ( ) ) ; if ( ch = = - <int> ) missingGlyph = glyph ; else if ( ch < = Character . MAX_VALUE ) setGlyph ( ch , glyph ) ; else continue ; glyph . id = ch ; tokens . nextToken ( ) ; glyph . srcX = Integer . parseInt ( tokens . nextToken ( ) ) ; tokens . nextToken ( ) ; glyph . srcY = Integer . parseInt ( tokens . nextToken ( ) ) ; tokens . nextToken ( ) ; glyph . width = Integer . parseInt ( tokens . nextToken ( ) ) ; tokens . nextToken ( ) ; glyph . height = Integer . parseInt ( tokens . nextToken ( ) ) ; tokens . nextToken ( ) ; glyph . xoffset = Integer . parseInt ( tokens . nextToken ( ) ) ; tokens . nextToken ( ) ; if ( flip ) glyph . yoffset = Integer . parseInt ( tokens . nextToken ( ) ) ; else glyph . yoffset = - ( glyph . height + Integer . parseInt ( tokens . nextToken ( ) ) ) ; tokens . nextToken ( ) ; glyph . xadvance = Integer . parseInt ( tokens . nextToken ( ) ) ; if ( tokens . hasMoreTokens ( ) ) tokens . nextToken ( ) ; if ( tokens . hasMoreTokens ( ) ) { try { glyph . page = Integer . parseInt ( tokens . nextToken ( ) ) ; } catch ( NumberFormatException ignored ) { } } if ( glyph . width > <int> & & glyph . height > <int> ) descent = Math . min ( baseLine + glyph . yoffset , descent ) ; } descent + = padBottom ; while ( true ) { line = reader . readLine ( ) ; if ( line = = null ) break ; if ( ! line . startsWith ( <str> ) ) break ; StringTokenizer tokens = new StringTokenizer ( line , <str> ) ; tokens . nextToken ( ) ; tokens . nextToken ( ) ; int first = Integer . parseInt ( tokens . nextToken ( ) ) ; tokens . nextToken ( ) ; int second = Integer . parseInt ( tokens . nextToken ( ) ) ; if ( first < <int> | | first > Character . MAX_VALUE | | second < <int> | | second > Character . MAX_VALUE ) continue ; Glyph glyph = getGlyph ( ( char ) first ) ; tokens . nextToken ( ) ; int amount = Integer . parseInt ( tokens . nextToken ( ) ) ; if ( glyph ! = null ) { glyph . setKerning ( second , amount ) ; } } Glyph spaceGlyph = getGlyph ( <str> ) ; if ( spaceGlyph = = null ) { spaceGlyph = new Glyph ( ) ; spaceGlyph . id = ( int ) <str> ; Glyph xadvanceGlyph = getGlyph ( <str> ) ; if ( xadvanceGlyph = = null ) xadvanceGlyph = getFirstGlyph ( ) ; spaceGlyph . xadvance = xadvanceGlyph . xadvance ; setGlyph ( <str> , spaceGlyph ) ; } if ( spaceGlyph . width = = <int> ) { spaceGlyph . width = ( int ) ( padLeft + spaceGlyph . xadvance + padRight ) ; spaceGlyph . xoffset = ( int ) - padLeft ; } spaceWidth = spaceGlyph . width ; Glyph xGlyph = null ; for ( char xChar : xChars ) { xGlyph = getGlyph ( xChar ) ; if ( xGlyph ! = null ) break ; } if ( xGlyph = = null ) xGlyph = getFirstGlyph ( ) ; xHeight = xGlyph . height - padY ; Glyph capGlyph = null ; for ( char capChar : capChars ) { capGlyph = getGlyph ( capChar ) ; if ( capGlyph ! = null ) break ; } if ( capGlyph = = null ) { for ( Glyph [ ] page : this . glyphs ) { if ( page = = null ) continue ; for ( Glyph glyph : page ) { if ( glyph = = null | | glyph . height = = <int> | | glyph . width = = <int> ) continue ; capHeight = Math . max ( capHeight , glyph . height ) ; } } } else capHeight = capGlyph . height ; capHeight - = padY ; ascent = baseLine - capHeight ; down = - lineHeight ; if ( flip ) { ascent = - ascent ; down = - down ; } } catch ( Exception ex ) { throw new GdxRuntimeException ( <str> + fontFile , ex ) ; } finally { StreamUtils . closeQuietly ( reader ) ; } } public void setGlyphRegion ( Glyph glyph , TextureRegion region ) { Texture texture = region . getTexture ( ) ; float invTexWidth = <float> / texture . getWidth ( ) ; float invTexHeight = <float> / texture . getHeight ( ) ; float offsetX = <int> , offsetY = <int> ; float u = region . u ; float v = region . v ; float regionWidth = region . getRegionWidth ( ) ; float regionHeight = region . getRegionHeight ( ) ; if ( region instanceof AtlasRegion ) { AtlasRegion atlasRegion = ( AtlasRegion ) region ; offsetX = atlasRegion . offsetX ; offsetY = atlasRegion . originalHeight - atlasRegion . packedHeight - atlasRegion . offsetY ; } float x = glyph . srcX ; float x2 = glyph . srcX + glyph . width ; float y = glyph . srcY ; float y2 = glyph . srcY + glyph . height ; if ( offsetX > <int> ) { x - = offsetX ; if ( x < <int> ) { glyph . width + = x ; glyph . xoffset - = x ; x = <int> ; } x2 - = offsetX ; if ( x2 > regionWidth ) { glyph . width - = x2 - regionWidth ; x2 = regionWidth ; } } if ( offsetY > <int> ) { y - = offsetY ; if ( y < <int> ) { glyph . height + = y ; y = <int> ; } y2 - = offsetY ; if ( y2 > regionHeight ) { float amount = y2 - regionHeight ; glyph . height - = amount ; glyph . yoffset + = amount ; y2 = regionHeight ; } } glyph . u = u + x * invTexWidth ; glyph . u2 = u + x2 * invTexWidth ; if ( flipped ) { glyph . v = v + y * invTexHeight ; glyph . v2 = v + y2 * invTexHeight ; } else { glyph . v2 = v + y * invTexHeight ; glyph . v = v + y2 * invTexHeight ; } } public void setLineHeight ( float height ) { lineHeight = height * scaleY ; down = flipped ? lineHeight : - lineHeight ; } public void setGlyph ( int ch , Glyph glyph ) { Glyph [ ] page = glyphs [ ch / PAGE_SIZE ] ; if ( page = = null ) glyphs [ ch / PAGE_SIZE ] = page = new Glyph [ PAGE_SIZE ] ; page [ ch & PAGE_SIZE - <int> ] = glyph ; } public Glyph getFirstGlyph ( ) { for ( Glyph [ ] page : this . glyphs ) { if ( page = = null ) continue ; for ( Glyph glyph : page ) { if ( glyph = = null | | glyph . height = = <int> | | glyph . width = = <int> ) continue ; return glyph ; } } throw new GdxRuntimeException ( <str> ) ; } public boolean hasGlyph ( char ch ) { if ( missingGlyph ! = null ) return true ; return getGlyph ( ch ) ! = null ; } public Glyph getGlyph ( char ch ) { Glyph [ ] page = glyphs [ ch / PAGE_SIZE ] ; if ( page ! = null ) return page [ ch & PAGE_SIZE - <int> ] ; return null ; } public void getGlyphs ( GlyphRun run , CharSequence str , int start , int end , boolean tightBounds ) { boolean markupEnabled = this . markupEnabled ; float scaleX = this . scaleX ; Glyph missingGlyph = this . missingGlyph ; Array < Glyph > glyphs = run . glyphs ; FloatArray xAdvances = run . xAdvances ; Glyph lastGlyph = null ; while ( start < end ) { char ch = str . charAt ( start + + ) ; Glyph glyph = getGlyph ( ch ) ; if ( glyph = = null ) { if ( missingGlyph = = null ) continue ; glyph = missingGlyph ; } glyphs . add ( glyph ) ; if ( lastGlyph = = null ) xAdvances . add ( ( ! tightBounds | | glyph . fixedWidth ) ? <int> : - glyph . xoffset * scaleX - padLeft ) ; else xAdvances . add ( ( lastGlyph . xadvance + lastGlyph . getKerning ( ch ) ) * scaleX ) ; lastGlyph = glyph ; if ( markupEnabled & & ch = = <str> & & start < end & & str . charAt ( start ) = = <str> ) start + + ; } if ( lastGlyph ! = null ) { float lastGlyphWidth = ( ! tightBounds | | lastGlyph . fixedWidth ) ? lastGlyph . xadvance : lastGlyph . xoffset + lastGlyph . width - padRight ; xAdvances . add ( lastGlyphWidth * scaleX ) ; } } public int getWrapIndex ( Array < Glyph > glyphs , int start ) { int i = start - <int> ; for ( ; i > = <int> ; i - - ) if ( ! isWhitespace ( ( char ) glyphs . get ( i ) . id ) ) break ; for ( ; i > = <int> ; i - - ) { char ch = ( char ) glyphs . get ( i ) . id ; if ( isWhitespace ( ch ) | | isBreakChar ( ch ) ) return i + <int> ; } return <int> ; } public boolean isBreakChar ( char c ) { if ( breakChars = = null ) return false ; for ( char br : breakChars ) if ( c = = br ) return true ; return false ; } public boolean isWhitespace ( char c ) { switch ( c ) { case <str> : case <str> : case <str> : case <str> : return true ; default : return false ; } } public String getImagePath ( int index ) { return imagePaths [ index ] ; } public String [ ] getImagePaths ( ) { return imagePaths ; } public FileHandle getFontFile ( ) { return fontFile ; } public void setScale ( float scaleX , float scaleY ) { if ( scaleX = = <int> ) throw new IllegalArgumentException ( <str> ) ; if ( scaleY = = <int> ) throw new IllegalArgumentException ( <str> ) ; float x = scaleX / this . scaleX ; float y = scaleY / this . scaleY ; lineHeight * = y ; spaceWidth * = x ; xHeight * = y ; capHeight * = y ; ascent * = y ; descent * = y ; down * = y ; padTop * = y ; padLeft * = y ; padBottom * = y ; padRight * = y ; this . scaleX = scaleX ; this . scaleY = scaleY ; } public void setScale ( float scaleXY ) { setScale ( scaleXY , scaleXY ) ; } public void scale ( float amount ) { setScale ( scaleX + amount , scaleY + amount ) ; } } } 
