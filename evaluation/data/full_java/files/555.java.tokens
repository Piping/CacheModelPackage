package org . apache . cassandra . dht ; import java . io . DataInput ; import java . io . IOException ; import java . io . Serializable ; import java . nio . ByteBuffer ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class Token implements RingPosition < Token > , Serializable { private static final long serialVersionUID = <int> ; public static final TokenSerializer serializer = new TokenSerializer ( ) ; public static abstract class TokenFactory { public abstract ByteBuffer toByteArray ( Token token ) ; public abstract Token fromByteArray ( ByteBuffer bytes ) ; public abstract String toString ( Token token ) ; public abstract Token fromString ( String string ) ; public abstract void validate ( String token ) throws ConfigurationException ; } public static class TokenSerializer implements IPartitionerDependentSerializer < Token > { public void serialize ( Token token , DataOutputPlus out , int version ) throws IOException { IPartitioner p = token . getPartitioner ( ) ; ByteBuffer b = p . getTokenFactory ( ) . toByteArray ( token ) ; ByteBufferUtil . writeWithLength ( b , out ) ; } public Token deserialize ( DataInput in , IPartitioner p , int version ) throws IOException { int size = in . readInt ( ) ; byte [ ] bytes = new byte [ size ] ; in . readFully ( bytes ) ; return p . getTokenFactory ( ) . fromByteArray ( ByteBuffer . wrap ( bytes ) ) ; } public long serializedSize ( Token object , int version ) { IPartitioner p = object . getPartitioner ( ) ; ByteBuffer b = p . getTokenFactory ( ) . toByteArray ( object ) ; return TypeSizes . sizeof ( b . remaining ( ) ) + b . remaining ( ) ; } } abstract public IPartitioner getPartitioner ( ) ; abstract public long getHeapSize ( ) ; abstract public Object getTokenValue ( ) ; abstract public double size ( Token next ) ; abstract public Token increaseSlightly ( ) ; public Token getToken ( ) { return this ; } public Token minValue ( ) { return getPartitioner ( ) . getMinimumToken ( ) ; } public boolean isMinimum ( ) { return this . equals ( minValue ( ) ) ; } public KeyBound minKeyBound ( ) { return new KeyBound ( this , true ) ; } public KeyBound maxKeyBound ( ) { if ( isMinimum ( ) ) return minKeyBound ( ) ; return new KeyBound ( this , false ) ; } @SuppressWarnings ( <str> ) public < R extends RingPosition < R > > R upperBound ( Class < R > klass ) { if ( klass . equals ( getClass ( ) ) ) return ( R ) this ; else return ( R ) maxKeyBound ( ) ; } public static class KeyBound implements PartitionPosition { private final Token token ; public final boolean isMinimumBound ; private KeyBound ( Token t , boolean isMinimumBound ) { this . token = t ; this . isMinimumBound = isMinimumBound ; } public Token getToken ( ) { return token ; } public int compareTo ( PartitionPosition pos ) { if ( this = = pos ) return <int> ; int cmp = getToken ( ) . compareTo ( pos . getToken ( ) ) ; if ( cmp ! = <int> ) return cmp ; if ( isMinimumBound ) return ( ( pos instanceof KeyBound ) & & ( ( KeyBound ) pos ) . isMinimumBound ) ? <int> : - <int> ; else return ( ( pos instanceof KeyBound ) & & ! ( ( KeyBound ) pos ) . isMinimumBound ) ? <int> : <int> ; } public IPartitioner getPartitioner ( ) { return getToken ( ) . getPartitioner ( ) ; } public KeyBound minValue ( ) { return getPartitioner ( ) . getMinimumToken ( ) . minKeyBound ( ) ; } public boolean isMinimum ( ) { return getToken ( ) . isMinimum ( ) ; } public PartitionPosition . Kind kind ( ) { return isMinimumBound ? PartitionPosition . Kind . MIN_BOUND : PartitionPosition . Kind . MAX_BOUND ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj = = null | | this . getClass ( ) ! = obj . getClass ( ) ) return false ; KeyBound other = ( KeyBound ) obj ; return token . equals ( other . token ) & & isMinimumBound = = other . isMinimumBound ; } @Override public int hashCode ( ) { return getToken ( ) . hashCode ( ) + ( isMinimumBound ? <int> : <int> ) ; } @Override public String toString ( ) { return String . format ( <str> , isMinimumBound ? <str> : <str> , getToken ( ) . toString ( ) ) ; } } } 
