package org . elasticsearch . common . util . concurrent ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . locks . ReentrantLock ; public class KeyedLock < T > { private final boolean fair ; public KeyedLock ( boolean fair ) { this . fair = fair ; } public KeyedLock ( ) { this ( false ) ; } private final ConcurrentMap < T , KeyLock > map = ConcurrentCollections . newConcurrentMap ( ) ; protected final ThreadLocal < KeyLock > threadLocal = new ThreadLocal < > ( ) ; public void acquire ( T key ) { while ( true ) { if ( threadLocal . get ( ) ! = null ) { throw new IllegalStateException ( <str> + Thread . currentThread ( ) . getId ( ) + <str> + key ) ; } KeyLock perNodeLock = map . get ( key ) ; if ( perNodeLock = = null ) { KeyLock newLock = new KeyLock ( fair ) ; perNodeLock = map . putIfAbsent ( key , newLock ) ; if ( perNodeLock = = null ) { newLock . lock ( ) ; threadLocal . set ( newLock ) ; return ; } } assert perNodeLock ! = null ; int i = perNodeLock . count . get ( ) ; if ( i > <int> & & perNodeLock . count . compareAndSet ( i , i + <int> ) ) { perNodeLock . lock ( ) ; threadLocal . set ( perNodeLock ) ; return ; } } } public void release ( T key ) { KeyLock lock = threadLocal . get ( ) ; if ( lock = = null ) { throw new IllegalStateException ( <str> ) ; } release ( key , lock ) ; } void release ( T key , KeyLock lock ) { assert lock . isHeldByCurrentThread ( ) ; assert lock = = map . get ( key ) ; lock . unlock ( ) ; threadLocal . set ( null ) ; int decrementAndGet = lock . count . decrementAndGet ( ) ; if ( decrementAndGet = = <int> ) { map . remove ( key , lock ) ; } } @SuppressWarnings ( <str> ) private final static class KeyLock extends ReentrantLock { KeyLock ( boolean fair ) { super ( fair ) ; } private final AtomicInteger count = new AtomicInteger ( <int> ) ; } public boolean hasLockedKeys ( ) { return ! map . isEmpty ( ) ; } } 
