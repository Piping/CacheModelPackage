package org . gradle . initialization ; import org . gradle . BuildListener ; import org . gradle . BuildResult ; import org . gradle . api . internal . ExceptionAnalyser ; import org . gradle . api . internal . GradleInternal ; import org . gradle . api . logging . StandardOutputListener ; import org . gradle . configuration . BuildConfigurer ; import org . gradle . execution . BuildConfigurationActionExecuter ; import org . gradle . execution . BuildExecuter ; import org . gradle . internal . Factory ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . progress . BuildOperationExecutor ; import org . gradle . internal . service . scopes . BuildScopeServices ; import org . gradle . logging . LoggingManagerInternal ; public class DefaultGradleLauncher extends GradleLauncher { private enum Stage { Configure , Build } private final GradleInternal gradle ; private final InitScriptHandler initScriptHandler ; private final SettingsLoader settingsLoader ; private final BuildConfigurer buildConfigurer ; private final ExceptionAnalyser exceptionAnalyser ; private final LoggingManagerInternal loggingManager ; private final BuildListener buildListener ; private final ModelConfigurationListener modelConfigurationListener ; private final BuildCompletionListener buildCompletionListener ; private final BuildOperationExecutor buildOperationExecutor ; private final BuildConfigurationActionExecuter buildConfigurationActionExecuter ; private final BuildExecuter buildExecuter ; private final BuildScopeServices buildServices ; public DefaultGradleLauncher ( GradleInternal gradle , InitScriptHandler initScriptHandler , SettingsLoader settingsLoader , BuildConfigurer buildConfigurer , ExceptionAnalyser exceptionAnalyser , LoggingManagerInternal loggingManager , BuildListener buildListener , ModelConfigurationListener modelConfigurationListener , BuildCompletionListener buildCompletionListener , BuildOperationExecutor operationExecutor , BuildConfigurationActionExecuter buildConfigurationActionExecuter , BuildExecuter buildExecuter , BuildScopeServices buildServices ) { this . gradle = gradle ; this . initScriptHandler = initScriptHandler ; this . settingsLoader = settingsLoader ; this . buildConfigurer = buildConfigurer ; this . exceptionAnalyser = exceptionAnalyser ; this . buildListener = buildListener ; this . loggingManager = loggingManager ; this . modelConfigurationListener = modelConfigurationListener ; this . buildOperationExecutor = operationExecutor ; this . buildConfigurationActionExecuter = buildConfigurationActionExecuter ; this . buildExecuter = buildExecuter ; this . buildCompletionListener = buildCompletionListener ; this . buildServices = buildServices ; } public GradleInternal getGradle ( ) { return gradle ; } @Override public BuildResult run ( ) { return doBuild ( Stage . Build ) ; } @Override public BuildResult getBuildAnalysis ( ) { return doBuild ( Stage . Configure ) ; } private BuildResult doBuild ( final Stage upTo ) { loggingManager . start ( ) ; return buildOperationExecutor . run ( <str> , new Factory < BuildResult > ( ) { @Override public BuildResult create ( ) { Throwable failure = null ; try { buildListener . buildStarted ( gradle ) ; doBuildStages ( upTo ) ; } catch ( Throwable t ) { failure = exceptionAnalyser . transform ( t ) ; } BuildResult buildResult = new BuildResult ( gradle , failure ) ; buildListener . buildFinished ( buildResult ) ; if ( failure ! = null ) { throw new ReportedException ( failure ) ; } return buildResult ; } } ) ; } private void doBuildStages ( Stage upTo ) { initScriptHandler . executeScripts ( gradle ) ; settingsLoader . findAndLoadSettings ( gradle ) ; buildOperationExecutor . run ( <str> , new Runnable ( ) { @Override public void run ( ) { buildConfigurer . configure ( gradle ) ; if ( ! gradle . getStartParameter ( ) . isConfigureOnDemand ( ) ) { buildListener . projectsEvaluated ( gradle ) ; } modelConfigurationListener . onConfigure ( gradle ) ; } } ) ; if ( upTo = = Stage . Configure ) { return ; } buildOperationExecutor . run ( <str> , new Runnable ( ) { @Override public void run ( ) { buildConfigurationActionExecuter . select ( gradle ) ; if ( gradle . getStartParameter ( ) . isConfigureOnDemand ( ) ) { buildListener . projectsEvaluated ( gradle ) ; } } } ) ; buildOperationExecutor . run ( <str> , new Runnable ( ) { @Override public void run ( ) { buildExecuter . execute ( gradle ) ; } } ) ; assert upTo = = Stage . Build ; } @Override public void addListener ( Object listener ) { gradle . addListener ( listener ) ; } @Override public void addStandardOutputListener ( StandardOutputListener listener ) { loggingManager . addStandardOutputListener ( listener ) ; } @Override public void addStandardErrorListener ( StandardOutputListener listener ) { loggingManager . addStandardErrorListener ( listener ) ; } public void stop ( ) { try { loggingManager . stop ( ) ; CompositeStoppable . stoppable ( buildServices ) . stop ( ) ; } finally { buildCompletionListener . completed ( ) ; } } } 
