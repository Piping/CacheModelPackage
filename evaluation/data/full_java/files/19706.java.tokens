package io . netty . util . internal ; final class MpscArrayQueue < E > extends MpscArrayQueueConsumerField < E > { long p40 , p41 , p42 , p43 , p44 , p45 , p46 ; long p30 , p31 , p32 , p33 , p34 , p35 , p36 , p37 ; public MpscArrayQueue ( final int capacity ) { super ( capacity ) ; } @Override public boolean offer ( final E e ) { if ( null = = e ) { throw new NullPointerException ( <str> ) ; } final long mask = this . mask ; final long capacity = mask + <int> ; long consumerIndexCache = lvConsumerIndexCache ( ) ; long currentProducerIndex ; do { currentProducerIndex = lvProducerIndex ( ) ; final long wrapPoint = currentProducerIndex - capacity ; if ( consumerIndexCache < = wrapPoint ) { final long currHead = lvConsumerIndex ( ) ; if ( currHead < = wrapPoint ) { return false ; } else { svConsumerIndexCache ( currHead ) ; consumerIndexCache = currHead ; } } } while ( ! casProducerIndex ( currentProducerIndex , currentProducerIndex + <int> ) ) ; final long offset = calcElementOffset ( currentProducerIndex , mask ) ; soElement ( offset , e ) ; return true ; } public int weakOffer ( final E e ) { if ( null = = e ) { throw new NullPointerException ( <str> ) ; } final long mask = this . mask ; final long capacity = mask + <int> ; final long currentTail = lvProducerIndex ( ) ; final long consumerIndexCache = lvConsumerIndexCache ( ) ; final long wrapPoint = currentTail - capacity ; if ( consumerIndexCache < = wrapPoint ) { long currHead = lvConsumerIndex ( ) ; if ( currHead < = wrapPoint ) { return <int> ; } else { svConsumerIndexCache ( currHead ) ; } } if ( ! casProducerIndex ( currentTail , currentTail + <int> ) ) { return - <int> ; } final long offset = calcElementOffset ( currentTail , mask ) ; soElement ( offset , e ) ; return <int> ; } @Override public E poll ( ) { final long consumerIndex = lvConsumerIndex ( ) ; final long offset = calcElementOffset ( consumerIndex ) ; final E [ ] buffer = this . buffer ; E e = lvElement ( buffer , offset ) ; if ( null = = e ) { if ( consumerIndex ! = lvProducerIndex ( ) ) { do { e = lvElement ( buffer , offset ) ; } while ( e = = null ) ; } else { return null ; } } spElement ( buffer , offset , null ) ; soConsumerIndex ( consumerIndex + <int> ) ; return e ; } @Override public E peek ( ) { final E [ ] buffer = this . buffer ; final long consumerIndex = lvConsumerIndex ( ) ; final long offset = calcElementOffset ( consumerIndex ) ; E e = lvElement ( buffer , offset ) ; if ( null = = e ) { if ( consumerIndex ! = lvProducerIndex ( ) ) { do { e = lvElement ( buffer , offset ) ; } while ( e = = null ) ; } else { return null ; } } return e ; } @Override public int size ( ) { long after = lvConsumerIndex ( ) ; while ( true ) { final long before = after ; final long currentProducerIndex = lvProducerIndex ( ) ; after = lvConsumerIndex ( ) ; if ( before = = after ) { return ( int ) ( currentProducerIndex - after ) ; } } } @Override public boolean isEmpty ( ) { return lvConsumerIndex ( ) = = lvProducerIndex ( ) ; } } abstract class MpscArrayQueueL1Pad < E > extends ConcurrentCircularArrayQueue < E > { long p10 , p11 , p12 , p13 , p14 , p15 , p16 ; long p30 , p31 , p32 , p33 , p34 , p35 , p36 , p37 ; public MpscArrayQueueL1Pad ( int capacity ) { super ( capacity ) ; } } abstract class MpscArrayQueueTailField < E > extends MpscArrayQueueL1Pad < E > { private static final long P_INDEX_OFFSET ; static { try { P_INDEX_OFFSET = PlatformDependent0 . UNSAFE . objectFieldOffset ( MpscArrayQueueTailField . class . getDeclaredField ( <str> ) ) ; } catch ( NoSuchFieldException e ) { throw new RuntimeException ( e ) ; } } private volatile long producerIndex ; public MpscArrayQueueTailField ( int capacity ) { super ( capacity ) ; } protected final long lvProducerIndex ( ) { return producerIndex ; } protected final boolean casProducerIndex ( long expect , long newValue ) { return PlatformDependent0 . UNSAFE . compareAndSwapLong ( this , P_INDEX_OFFSET , expect , newValue ) ; } } abstract class MpscArrayQueueMidPad < E > extends MpscArrayQueueTailField < E > { long p20 , p21 , p22 , p23 , p24 , p25 , p26 ; long p30 , p31 , p32 , p33 , p34 , p35 , p36 , p37 ; public MpscArrayQueueMidPad ( int capacity ) { super ( capacity ) ; } } abstract class MpscArrayQueueHeadCacheField < E > extends MpscArrayQueueMidPad < E > { private volatile long headCache ; public MpscArrayQueueHeadCacheField ( int capacity ) { super ( capacity ) ; } protected final long lvConsumerIndexCache ( ) { return headCache ; } protected final void svConsumerIndexCache ( long v ) { headCache = v ; } } abstract class MpscArrayQueueL2Pad < E > extends MpscArrayQueueHeadCacheField < E > { long p20 , p21 , p22 , p23 , p24 , p25 , p26 ; long p30 , p31 , p32 , p33 , p34 , p35 , p36 , p37 ; public MpscArrayQueueL2Pad ( int capacity ) { super ( capacity ) ; } } abstract class MpscArrayQueueConsumerField < E > extends MpscArrayQueueL2Pad < E > { private static final long C_INDEX_OFFSET ; static { try { C_INDEX_OFFSET = PlatformDependent0 . UNSAFE . objectFieldOffset ( MpscArrayQueueConsumerField . class . getDeclaredField ( <str> ) ) ; } catch ( NoSuchFieldException e ) { throw new RuntimeException ( e ) ; } } private volatile long consumerIndex ; public MpscArrayQueueConsumerField ( int capacity ) { super ( capacity ) ; } protected final long lvConsumerIndex ( ) { return consumerIndex ; } protected void soConsumerIndex ( long l ) { PlatformDependent0 . UNSAFE . putOrderedLong ( this , C_INDEX_OFFSET , l ) ; } } 
