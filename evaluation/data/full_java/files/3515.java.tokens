package org . eclipse . core . externaltools . internal . launchConfigurations ; import java . io . File ; import java . util . HashMap ; import java . util . Map ; import org . eclipse . core . externaltools . internal . IExternalToolConstants ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . ILaunch ; import org . eclipse . debug . core . ILaunchConfiguration ; import org . eclipse . debug . core . RefreshUtil ; import org . eclipse . debug . core . model . IProcess ; import org . eclipse . debug . core . model . LaunchConfigurationDelegate ; import org . eclipse . osgi . util . NLS ; public class ProgramLaunchDelegate extends LaunchConfigurationDelegate { private static final String ATTR_LAUNCH_IN_BACKGROUND = <str> ; @Override public void launch ( ILaunchConfiguration configuration , String mode , ILaunch launch , IProgressMonitor monitor ) throws CoreException { if ( monitor . isCanceled ( ) ) { return ; } IPath location = ExternalToolsCoreUtil . getLocation ( configuration ) ; if ( monitor . isCanceled ( ) ) { return ; } IPath workingDirectory = ExternalToolsCoreUtil . getWorkingDirectory ( configuration ) ; if ( monitor . isCanceled ( ) ) { return ; } String [ ] arguments = ExternalToolsCoreUtil . getArguments ( configuration ) ; if ( monitor . isCanceled ( ) ) { return ; } int cmdLineLength = <int> ; if ( arguments ! = null ) { cmdLineLength + = arguments . length ; } String [ ] cmdLine = new String [ cmdLineLength ] ; cmdLine [ <int> ] = location . toOSString ( ) ; if ( arguments ! = null ) { System . arraycopy ( arguments , <int> , cmdLine , <int> , arguments . length ) ; } File workingDir = null ; if ( workingDirectory ! = null ) { workingDir = workingDirectory . toFile ( ) ; } if ( monitor . isCanceled ( ) ) { return ; } String [ ] envp = DebugPlugin . getDefault ( ) . getLaunchManager ( ) . getEnvironment ( configuration ) ; if ( monitor . isCanceled ( ) ) { return ; } Process p = DebugPlugin . exec ( cmdLine , workingDir , envp ) ; IProcess process = null ; Map < String , String > processAttributes = new HashMap < String , String > ( ) ; String programName = location . lastSegment ( ) ; String extension = location . getFileExtension ( ) ; if ( extension ! = null ) { programName = programName . substring ( <int> , programName . length ( ) - ( extension . length ( ) + <int> ) ) ; } programName = programName . toLowerCase ( ) ; processAttributes . put ( IProcess . ATTR_PROCESS_TYPE , programName ) ; if ( p ! = null ) { monitor . beginTask ( NLS . bind ( ExternalToolsProgramMessages . ProgramLaunchDelegate_3 , new String [ ] { configuration . getName ( ) } ) , IProgressMonitor . UNKNOWN ) ; process = DebugPlugin . newProcess ( launch , p , location . toOSString ( ) , processAttributes ) ; } if ( p = = null | | process = = null ) { if ( p ! = null ) { p . destroy ( ) ; } throw new CoreException ( new Status ( IStatus . ERROR , IExternalToolConstants . PLUGIN_ID , IExternalToolConstants . ERR_INTERNAL_ERROR , ExternalToolsProgramMessages . ProgramLaunchDelegate_4 , null ) ) ; } process . setAttribute ( IProcess . ATTR_CMDLINE , generateCommandLine ( cmdLine ) ) ; if ( configuration . getAttribute ( ATTR_LAUNCH_IN_BACKGROUND , true ) ) { String scope = configuration . getAttribute ( RefreshUtil . ATTR_REFRESH_SCOPE , ( String ) null ) ; if ( scope ! = null ) { BackgroundResourceRefresher refresher = new BackgroundResourceRefresher ( configuration , process ) ; refresher . startBackgroundRefresh ( ) ; } } else { while ( ! process . isTerminated ( ) ) { try { if ( monitor . isCanceled ( ) ) { process . terminate ( ) ; break ; } Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } RefreshUtil . refreshResources ( configuration , monitor ) ; } } private String generateCommandLine ( String [ ] commandLine ) { if ( commandLine . length < <int> ) { return IExternalToolConstants . EMPTY_STRING ; } StringBuffer buf = new StringBuffer ( ) ; for ( int i = <int> ; i < commandLine . length ; i + + ) { buf . append ( <str> ) ; char [ ] characters = commandLine [ i ] . toCharArray ( ) ; StringBuffer command = new StringBuffer ( ) ; boolean containsSpace = false ; for ( int j = <int> ; j < characters . length ; j + + ) { char character = characters [ j ] ; if ( character = = <str> ) { command . append ( <str> ) ; } else if ( character = = <str> ) { containsSpace = true ; } command . append ( character ) ; } if ( containsSpace ) { buf . append ( <str> ) ; buf . append ( command ) ; buf . append ( <str> ) ; } else { buf . append ( command ) ; } } return buf . toString ( ) ; } @Override protected IProject [ ] getBuildOrder ( ILaunchConfiguration configuration , String mode ) throws CoreException { IProject [ ] projects = ExternalToolsCoreUtil . getBuildProjects ( configuration , null ) ; if ( projects = = null ) { return null ; } boolean isRef = ExternalToolsCoreUtil . isIncludeReferencedProjects ( configuration , null ) ; if ( isRef ) { return computeReferencedBuildOrder ( projects ) ; } return computeBuildOrder ( projects ) ; } @Override protected boolean saveBeforeLaunch ( ILaunchConfiguration configuration , String mode , IProgressMonitor monitor ) throws CoreException { if ( IExternalToolConstants . ID_EXTERNAL_TOOLS_BUILDER_LAUNCH_CATEGORY . equals ( configuration . getType ( ) . getCategory ( ) ) ) { return true ; } return super . saveBeforeLaunch ( configuration , mode , monitor ) ; } } 
