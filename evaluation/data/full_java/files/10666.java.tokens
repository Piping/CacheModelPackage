package com . google . common . util . concurrent ; import static java . lang . reflect . Modifier . isStatic ; import static java . util . concurrent . TimeUnit . MICROSECONDS ; import static java . util . concurrent . TimeUnit . MILLISECONDS ; import static java . util . concurrent . TimeUnit . NANOSECONDS ; import static java . util . concurrent . TimeUnit . SECONDS ; import com . google . common . collect . ImmutableClassToInstanceMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Lists ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . NullPointerTester . Visibility ; import com . google . common . util . concurrent . RateLimiter . SleepingStopwatch ; import junit . framework . TestCase ; import org . easymock . EasyMock ; import org . mockito . Mockito ; import java . lang . reflect . Method ; import java . util . Arrays ; import java . util . List ; import java . util . Locale ; import java . util . Random ; import java . util . concurrent . TimeUnit ; public class RateLimiterTest extends TestCase { private static final double EPSILON = <float> ; private final FakeStopwatch stopwatch = new FakeStopwatch ( ) ; public void testSimple ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; assertEvents ( <str> , <str> , <str> ) ; } public void testImmediateTryAcquire ( ) { RateLimiter r = RateLimiter . create ( <int> ) ; assertTrue ( <str> , r . tryAcquire ( ) ) ; assertFalse ( <str> , r . tryAcquire ( ) ) ; } public void testDoubleMinValueCanAcquireExactlyOnce ( ) { RateLimiter r = RateLimiter . create ( stopwatch , Double . MIN_VALUE ) ; assertTrue ( <str> , r . tryAcquire ( ) ) ; assertFalse ( <str> , r . tryAcquire ( ) ) ; stopwatch . sleepMillis ( Integer . MAX_VALUE ) ; assertFalse ( <str> , r . tryAcquire ( ) ) ; } public void testSimpleRateUpdate ( ) { RateLimiter limiter = RateLimiter . create ( <float> , <int> , SECONDS ) ; assertEquals ( <float> , limiter . getRate ( ) ) ; limiter . setRate ( <float> ) ; assertEquals ( <float> , limiter . getRate ( ) ) ; try { limiter . setRate ( <float> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { limiter . setRate ( - <float> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testAcquireParameterValidation ( ) { RateLimiter limiter = RateLimiter . create ( <int> ) ; try { limiter . acquire ( <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { limiter . acquire ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { limiter . tryAcquire ( <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { limiter . tryAcquire ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { limiter . tryAcquire ( <int> , <int> , SECONDS ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { limiter . tryAcquire ( - <int> , <int> , SECONDS ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testSimpleWithWait ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; limiter . acquire ( ) ; stopwatch . sleepMillis ( <int> ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; assertEvents ( <str> , <str> , <str> , <str> ) ; } public void testSimpleAcquireReturnValues ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; assertEquals ( <float> , limiter . acquire ( ) , EPSILON ) ; stopwatch . sleepMillis ( <int> ) ; assertEquals ( <float> , limiter . acquire ( ) , EPSILON ) ; assertEquals ( <float> , limiter . acquire ( ) , EPSILON ) ; assertEvents ( <str> , <str> , <str> , <str> ) ; } public void testSimpleAcquireEarliestAvailableIsInPast ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; assertEquals ( <float> , limiter . acquire ( ) , EPSILON ) ; stopwatch . sleepMillis ( <int> ) ; assertEquals ( <float> , limiter . acquire ( ) , EPSILON ) ; assertEquals ( <float> , limiter . acquire ( ) , EPSILON ) ; assertEquals ( <float> , limiter . acquire ( ) , EPSILON ) ; } public void testOneSecondBurst ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; stopwatch . sleepMillis ( <int> ) ; stopwatch . sleepMillis ( <int> ) ; limiter . acquire ( <int> ) ; limiter . acquire ( <int> ) ; limiter . acquire ( <int> ) ; limiter . acquire ( <int> ) ; limiter . acquire ( ) ; assertEvents ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; } public void testCreateWarmupParameterValidation ( ) { RateLimiter . create ( <float> , <int> , NANOSECONDS ) ; RateLimiter . create ( <float> , <int> , NANOSECONDS ) ; try { RateLimiter . create ( <float> , <int> , NANOSECONDS ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } try { RateLimiter . create ( <float> , - <int> , NANOSECONDS ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } @AndroidIncompatible public void testWarmUp ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> , <int> , MILLISECONDS , <float> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } assertEvents ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; } public void testWarmUpWithColdFactor ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> , <int> , MILLISECONDS , <float> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } assertEvents ( <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; } public void testWarmUpWithColdFactor1 ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> , <int> , MILLISECONDS , <float> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } assertEvents ( <str> , <str> , <str> ) ; } @AndroidIncompatible public void testWarmUpAndUpdate ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> , <int> , MILLISECONDS , <float> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } limiter . setRate ( <float> ) ; limiter . acquire ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } assertEvents ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; } public void testWarmUpAndUpdateWithColdFactor ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> , <int> , MILLISECONDS , <float> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } limiter . setRate ( <float> ) ; limiter . acquire ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } stopwatch . sleepMillis ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } assertEvents ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; } public void testBurstyAndUpdate ( ) { RateLimiter rateLimiter = RateLimiter . create ( stopwatch , <float> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . setRate ( <float> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; assertEvents ( <str> , <str> , <str> , <str> , <str> , <str> ) ; } public void testTryAcquire_noWaitAllowed ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; assertTrue ( limiter . tryAcquire ( <int> , SECONDS ) ) ; assertFalse ( limiter . tryAcquire ( <int> , SECONDS ) ) ; assertFalse ( limiter . tryAcquire ( <int> , SECONDS ) ) ; stopwatch . sleepMillis ( <int> ) ; assertFalse ( limiter . tryAcquire ( <int> , SECONDS ) ) ; } public void testTryAcquire_someWaitAllowed ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; assertTrue ( limiter . tryAcquire ( <int> , SECONDS ) ) ; assertTrue ( limiter . tryAcquire ( <int> , MILLISECONDS ) ) ; assertFalse ( limiter . tryAcquire ( <int> , MILLISECONDS ) ) ; stopwatch . sleepMillis ( <int> ) ; assertTrue ( limiter . tryAcquire ( <int> , MILLISECONDS ) ) ; } public void testTryAcquire_overflow ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; assertTrue ( limiter . tryAcquire ( <int> , MICROSECONDS ) ) ; stopwatch . sleepMillis ( <int> ) ; assertTrue ( limiter . tryAcquire ( Long . MAX_VALUE , MICROSECONDS ) ) ; } public void testTryAcquire_negative ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; assertTrue ( limiter . tryAcquire ( <int> , <int> , SECONDS ) ) ; stopwatch . sleepMillis ( <int> ) ; assertFalse ( limiter . tryAcquire ( <int> , Long . MIN_VALUE , SECONDS ) ) ; stopwatch . sleepMillis ( <int> ) ; assertTrue ( limiter . tryAcquire ( <int> , - <int> , SECONDS ) ) ; } public void testSimpleWeights ( ) { RateLimiter rateLimiter = RateLimiter . create ( stopwatch , <float> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; rateLimiter . acquire ( <int> ) ; assertEvents ( <str> , <str> , <str> , <str> , <str> , <str> ) ; } public void testInfinity_Bursty ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , Double . POSITIVE_INFINITY ) ; limiter . acquire ( Integer . MAX_VALUE / <int> ) ; limiter . acquire ( Integer . MAX_VALUE / <int> ) ; limiter . acquire ( Integer . MAX_VALUE ) ; assertEvents ( <str> , <str> , <str> ) ; limiter . setRate ( <float> ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; assertEvents ( <str> , <str> , <str> , <str> , <str> ) ; limiter . setRate ( Double . POSITIVE_INFINITY ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; assertEvents ( <str> , <str> , <str> ) ; } public void testInfinity_BustyTimeElapsed ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , Double . POSITIVE_INFINITY ) ; stopwatch . instant + = <int> ; limiter . setRate ( <float> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } assertEvents ( <str> , <str> , <str> , <str> , <str> ) ; } public void testInfinity_WarmUp ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , Double . POSITIVE_INFINITY , <int> , SECONDS , <float> ) ; limiter . acquire ( Integer . MAX_VALUE / <int> ) ; limiter . acquire ( Integer . MAX_VALUE / <int> ) ; limiter . acquire ( Integer . MAX_VALUE ) ; assertEvents ( <str> , <str> , <str> ) ; limiter . setRate ( <float> ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; assertEvents ( <str> , <str> , <str> ) ; limiter . setRate ( Double . POSITIVE_INFINITY ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; limiter . acquire ( ) ; assertEvents ( <str> , <str> , <str> ) ; } public void testInfinity_WarmUpTimeElapsed ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , Double . POSITIVE_INFINITY , <int> , SECONDS , <float> ) ; stopwatch . instant + = <int> ; limiter . setRate ( <float> ) ; for ( int i = <int> ; i < <int> ; i + + ) { limiter . acquire ( ) ; } assertEvents ( <str> , <str> , <str> , <str> , <str> ) ; } public void testWeNeverGetABurstMoreThanOneSec ( ) { RateLimiter limiter = RateLimiter . create ( stopwatch , <float> ) ; int [ ] rates = { <int> , <int> , <int> , <int> , <int> , <int> } ; for ( int rate : rates ) { int oneSecWorthOfWork = rate ; stopwatch . sleepMillis ( rate * <int> ) ; limiter . setRate ( rate ) ; long burst = measureTotalTimeMillis ( limiter , oneSecWorthOfWork , new Random ( ) ) ; assertTrue ( burst < = <int> ) ; long afterBurst = measureTotalTimeMillis ( limiter , oneSecWorthOfWork , new Random ( ) ) ; assertTrue ( afterBurst > = <int> ) ; } } public void testTimeToWarmUpIsHonouredEvenWithWeights ( ) { Random random = new Random ( ) ; int warmupPermits = <int> ; double [ ] coldFactorsToTest = { <float> , <float> , <float> } ; double [ ] qpsToTest = { <float> , <float> , <float> , <float> , <float> } ; for ( int trial = <int> ; trial < <int> ; trial + + ) { for ( double coldFactor : coldFactorsToTest ) { for ( double qps : qpsToTest ) { long warmupMillis = ( long ) ( ( <int> + coldFactor ) * warmupPermits / ( <float> * qps ) * <float> ) ; RateLimiter rateLimiter = RateLimiter . create ( stopwatch , qps , warmupMillis , MILLISECONDS , coldFactor ) ; assertEquals ( warmupMillis , measureTotalTimeMillis ( rateLimiter , warmupPermits , random ) ) ; } } } } public void testNulls ( ) { NullPointerTester tester = new NullPointerTester ( ) . setDefault ( SleepingStopwatch . class , stopwatch ) . setDefault ( int . class , <int> ) . setDefault ( double . class , <float> ) ; tester . testStaticMethods ( RateLimiter . class , Visibility . PACKAGE ) ; tester . testInstanceMethods ( RateLimiter . create ( stopwatch , <float> ) , Visibility . PACKAGE ) ; } private long measureTotalTimeMillis ( RateLimiter rateLimiter , int permits , Random random ) { long startTime = stopwatch . instant ; while ( permits > <int> ) { int nextPermitsToAcquire = Math . max ( <int> , random . nextInt ( permits ) ) ; permits - = nextPermitsToAcquire ; rateLimiter . acquire ( nextPermitsToAcquire ) ; } rateLimiter . acquire ( <int> ) ; return NANOSECONDS . toMillis ( stopwatch . instant - startTime ) ; } private void assertEvents ( String . . . events ) { assertEquals ( Arrays . toString ( events ) , stopwatch . readEventsAndClear ( ) ) ; } static class FakeStopwatch extends SleepingStopwatch { long instant = <int> L ; final List < String > events = Lists . newArrayList ( ) ; @Override public long readMicros ( ) { return NANOSECONDS . toMicros ( instant ) ; } void sleepMillis ( int millis ) { sleepMicros ( <str> , MILLISECONDS . toMicros ( millis ) ) ; } void sleepMicros ( String caption , long micros ) { instant + = MICROSECONDS . toNanos ( micros ) ; events . add ( caption + String . format ( Locale . ROOT , <str> , ( micros / <float> ) ) ) ; } @Override protected void sleepMicrosUninterruptibly ( long micros ) { sleepMicros ( <str> , micros ) ; } String readEventsAndClear ( ) { try { return events . toString ( ) ; } finally { events . clear ( ) ; } } @Override public String toString ( ) { return events . toString ( ) ; } } public void testMockingMockito ( ) throws Exception { RateLimiter mock = Mockito . mock ( RateLimiter . class ) ; doTestMocking ( mock ) ; } @AndroidIncompatible public void testMockingEasyMock ( ) throws Exception { RateLimiter mock = EasyMock . createNiceMock ( RateLimiter . class ) ; EasyMock . replay ( mock ) ; doTestMocking ( mock ) ; } private static void doTestMocking ( RateLimiter mock ) throws Exception { for ( Method method : RateLimiter . class . getMethods ( ) ) { if ( ! isStatic ( method . getModifiers ( ) ) & & ! NOT_WORKING_ON_MOCKS . contains ( method . getName ( ) ) & & ! method . getDeclaringClass ( ) . equals ( Object . class ) ) { method . invoke ( mock , arbitraryParameters ( method ) ) ; } } } private static Object [ ] arbitraryParameters ( Method method ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; Object [ ] params = new Object [ parameterTypes . length ] ; for ( int i = <int> ; i < parameterTypes . length ; i + + ) { params [ i ] = PARAMETER_VALUES . get ( parameterTypes [ i ] ) ; } return params ; } private static final ImmutableSet < String > NOT_WORKING_ON_MOCKS = ImmutableSet . of ( <str> , <str> , <str> ) ; private static final ImmutableClassToInstanceMap < Object > PARAMETER_VALUES = ImmutableClassToInstanceMap . builder ( ) . put ( int . class , <int> ) . put ( long . class , <int> ) . put ( double . class , <float> ) . put ( TimeUnit . class , SECONDS ) . build ( ) ; } 
