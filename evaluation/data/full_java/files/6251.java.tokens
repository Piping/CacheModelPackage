package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . Analyzer ; import org . elasticsearch . Version ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . AbstractIndexComponent ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . mapper . core . StringFieldMapper ; import java . io . Closeable ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; import static java . util . Collections . unmodifiableMap ; public class AnalysisService extends AbstractIndexComponent implements Closeable { private final Map < String , NamedAnalyzer > analyzers ; private final Map < String , TokenizerFactory > tokenizers ; private final Map < String , CharFilterFactory > charFilters ; private final Map < String , TokenFilterFactory > tokenFilters ; private final NamedAnalyzer defaultIndexAnalyzer ; private final NamedAnalyzer defaultSearchAnalyzer ; private final NamedAnalyzer defaultSearchQuoteAnalyzer ; public AnalysisService ( IndexSettings indexSettings , Map < String , AnalyzerProvider > analyzerProviders , Map < String , TokenizerFactory > tokenizerFactoryFactories , Map < String , CharFilterFactory > charFilterFactoryFactories , Map < String , TokenFilterFactory > tokenFilterFactoryFactories ) { super ( indexSettings ) ; this . tokenizers = unmodifiableMap ( tokenizerFactoryFactories ) ; this . charFilters = unmodifiableMap ( charFilterFactoryFactories ) ; this . tokenFilters = unmodifiableMap ( tokenFilterFactoryFactories ) ; analyzerProviders = new HashMap < > ( analyzerProviders ) ; if ( ! analyzerProviders . containsKey ( <str> ) ) { analyzerProviders . put ( <str> , new StandardAnalyzerProvider ( indexSettings , null , <str> , Settings . Builder . EMPTY_SETTINGS ) ) ; } if ( ! analyzerProviders . containsKey ( <str> ) ) { analyzerProviders . put ( <str> , analyzerProviders . get ( <str> ) ) ; } if ( ! analyzerProviders . containsKey ( <str> ) ) { analyzerProviders . put ( <str> , analyzerProviders . get ( <str> ) ) ; } Map < String , NamedAnalyzer > analyzers = new HashMap < > ( ) ; for ( Map . Entry < String , AnalyzerProvider > entry : analyzerProviders . entrySet ( ) ) { AnalyzerProvider analyzerFactory = entry . getValue ( ) ; String name = entry . getKey ( ) ; int overridePositionIncrementGap = StringFieldMapper . Defaults . positionIncrementGap ( indexSettings . getIndexVersionCreated ( ) ) ; if ( analyzerFactory instanceof CustomAnalyzerProvider ) { ( ( CustomAnalyzerProvider ) analyzerFactory ) . build ( this ) ; overridePositionIncrementGap = Integer . MIN_VALUE ; } Analyzer analyzerF = analyzerFactory . get ( ) ; if ( analyzerF = = null ) { throw new IllegalArgumentException ( <str> + analyzerFactory . name ( ) + <str> ) ; } NamedAnalyzer analyzer ; if ( analyzerF instanceof NamedAnalyzer ) { analyzer = ( NamedAnalyzer ) analyzerF ; if ( overridePositionIncrementGap > = <int> & & analyzer . getPositionIncrementGap ( analyzer . name ( ) ) ! = overridePositionIncrementGap ) { analyzer = new NamedAnalyzer ( analyzer , overridePositionIncrementGap ) ; } } else { analyzer = new NamedAnalyzer ( name , analyzerFactory . scope ( ) , analyzerF , overridePositionIncrementGap ) ; } if ( analyzers . containsKey ( name ) ) { throw new IllegalStateException ( <str> + name ) ; } analyzers . put ( name , analyzer ) ; String strAliases = this . indexSettings . getSettings ( ) . get ( <str> + analyzerFactory . name ( ) + <str> ) ; if ( strAliases ! = null ) { for ( String alias : Strings . commaDelimitedListToStringArray ( strAliases ) ) { analyzers . put ( alias , analyzer ) ; } } String [ ] aliases = this . indexSettings . getSettings ( ) . getAsArray ( <str> + analyzerFactory . name ( ) + <str> ) ; for ( String alias : aliases ) { analyzers . put ( alias , analyzer ) ; } } NamedAnalyzer defaultAnalyzer = analyzers . get ( <str> ) ; if ( defaultAnalyzer = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( analyzers . containsKey ( <str> ) ) { final Version createdVersion = indexSettings . getIndexVersionCreated ( ) ; if ( createdVersion . onOrAfter ( Version . V_3_0_0 ) ) { throw new IllegalArgumentException ( <str> + index ( ) . getName ( ) + <str> ) ; } else { deprecationLogger . deprecated ( <str> , index ( ) . getName ( ) ) ; } } defaultIndexAnalyzer = analyzers . containsKey ( <str> ) ? analyzers . get ( <str> ) : defaultAnalyzer ; defaultSearchAnalyzer = analyzers . containsKey ( <str> ) ? analyzers . get ( <str> ) : defaultAnalyzer ; defaultSearchQuoteAnalyzer = analyzers . containsKey ( <str> ) ? analyzers . get ( <str> ) : defaultSearchAnalyzer ; for ( Map . Entry < String , NamedAnalyzer > analyzer : analyzers . entrySet ( ) ) { if ( analyzer . getKey ( ) . startsWith ( <str> ) ) { throw new IllegalArgumentException ( <str> + analyzer . getKey ( ) + <str> ) ; } } this . analyzers = unmodifiableMap ( analyzers ) ; } @Override public void close ( ) { for ( NamedAnalyzer analyzer : analyzers . values ( ) ) { if ( analyzer . scope ( ) = = AnalyzerScope . INDEX ) { try { analyzer . close ( ) ; } catch ( NullPointerException e ) { } catch ( Exception e ) { logger . debug ( <str> + analyzer ) ; } } } } public NamedAnalyzer analyzer ( String name ) { return analyzers . get ( name ) ; } public NamedAnalyzer defaultIndexAnalyzer ( ) { return defaultIndexAnalyzer ; } public NamedAnalyzer defaultSearchAnalyzer ( ) { return defaultSearchAnalyzer ; } public NamedAnalyzer defaultSearchQuoteAnalyzer ( ) { return defaultSearchQuoteAnalyzer ; } public TokenizerFactory tokenizer ( String name ) { return tokenizers . get ( name ) ; } public CharFilterFactory charFilter ( String name ) { return charFilters . get ( name ) ; } public TokenFilterFactory tokenFilter ( String name ) { return tokenFilters . get ( name ) ; } } 
