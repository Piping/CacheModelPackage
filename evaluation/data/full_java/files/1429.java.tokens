package org . apache . cassandra . db ; import java . nio . ByteBuffer ; import java . util . List ; import com . google . common . collect . Lists ; import junit . framework . Assert ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . marshal . IntegerType ; import org . apache . cassandra . db . marshal . MapType ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; public class CellTest { private static final String KEYSPACE1 = <str> ; private static final String CF_STANDARD1 = <str> ; private static final String CF_COLLECTION = <str> ; private static final CFMetaData cfm = SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) ; private static final CFMetaData cfm2 = CFMetaData . Builder . create ( KEYSPACE1 , CF_COLLECTION ) . addPartitionKey ( <str> , IntegerType . instance ) . addClusteringColumn ( <str> , IntegerType . instance ) . addRegularColumn ( <str> , IntegerType . instance ) . addRegularColumn ( <str> , MapType . getInstance ( IntegerType . instance , IntegerType . instance , true ) ) . build ( ) ; @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , cfm , cfm2 ) ; } @Test public void testConflictingTypeEquality ( ) { boolean [ ] tf = new boolean [ ] { true , false } ; for ( boolean lhs : tf ) { for ( boolean rhs : tf ) { if ( lhs & & rhs ) continue ; Cell a = expiring ( cfm , <str> , <str> , <int> , <int> ) ; Cell b = regular ( cfm , <str> , <str> , <int> ) ; Assert . assertNotSame ( a , b ) ; Assert . assertNotSame ( b , a ) ; a = deleted ( cfm , <str> , <int> , <int> ) ; Assert . assertNotSame ( a , b ) ; Assert . assertNotSame ( b , a ) ; } } } @Test public void testExpiringCellReconile ( ) { Assert . assertEquals ( <int> , testExpiring ( <str> , <str> , <int> , <int> , null , null , null , null ) ) ; Assert . assertEquals ( - <int> , testExpiring ( <str> , <str> , <int> , <int> , null , null , <int> , null ) ) ; Assert . assertEquals ( - <int> , testExpiring ( <str> , <str> , <int> , <int> , null , <str> , <int> , <int> ) ) ; Assert . assertEquals ( - <int> , testExpiring ( <str> , <str> , <int> , <int> , null , null , null , <int> ) ) ; Assert . assertEquals ( <int> , testExpiring ( <str> , <str> , <int> , <int> , null , <str> , null , <int> ) ) ; Assert . assertEquals ( - <int> , testExpiring ( <str> , <str> , <int> , <int> , null , <str> , null , null ) ) ; Assert . assertEquals ( - <int> , testExpiring ( <str> , <str> , <int> , <int> , null , <str> , null , <int> ) ) ; } private static ByteBuffer bb ( int i ) { return ByteBufferUtil . bytes ( i ) ; } @Test public void testComplexCellReconcile ( ) { ColumnDefinition m = cfm2 . getColumnDefinition ( new ColumnIdentifier ( <str> , false ) ) ; int now1 = FBUtilities . nowInSeconds ( ) ; long ts1 = now1 * <int> ; Cell r1m1 = BufferCell . live ( cfm2 , m , ts1 , bb ( <int> ) , CellPath . create ( bb ( <int> ) ) ) ; Cell r1m2 = BufferCell . live ( cfm2 , m , ts1 , bb ( <int> ) , CellPath . create ( bb ( <int> ) ) ) ; List < Cell > cells1 = Lists . newArrayList ( r1m1 , r1m2 ) ; int now2 = now1 + <int> ; long ts2 = now2 * <int> ; Cell r2m2 = BufferCell . live ( cfm2 , m , ts2 , bb ( <int> ) , CellPath . create ( bb ( <int> ) ) ) ; Cell r2m3 = BufferCell . live ( cfm2 , m , ts2 , bb ( <int> ) , CellPath . create ( bb ( <int> ) ) ) ; Cell r2m4 = BufferCell . live ( cfm2 , m , ts2 , bb ( <int> ) , CellPath . create ( bb ( <int> ) ) ) ; List < Cell > cells2 = Lists . newArrayList ( r2m2 , r2m3 , r2m4 ) ; RowBuilder builder = new RowBuilder ( ) ; Cells . reconcileComplex ( m , cells1 . iterator ( ) , cells2 . iterator ( ) , DeletionTime . LIVE , builder , now2 + <int> ) ; Assert . assertEquals ( Lists . newArrayList ( r1m1 , r2m2 , r2m3 , r2m4 ) , builder . cells ) ; } private int testExpiring ( String n1 , String v1 , long t1 , int et1 , String n2 , String v2 , Long t2 , Integer et2 ) { if ( n2 = = null ) n2 = n1 ; if ( v2 = = null ) v2 = v1 ; if ( t2 = = null ) t2 = t1 ; if ( et2 = = null ) et2 = et1 ; Cell c1 = expiring ( cfm , n1 , v1 , t1 , et1 ) ; Cell c2 = expiring ( cfm , n2 , v2 , t2 , et2 ) ; int now = FBUtilities . nowInSeconds ( ) ; if ( Cells . reconcile ( c1 , c2 , now ) = = c1 ) return Cells . reconcile ( c2 , c1 , now ) = = c1 ? - <int> : <int> ; return Cells . reconcile ( c2 , c1 , now ) = = c2 ? <int> : <int> ; } private Cell regular ( CFMetaData cfm , String columnName , String value , long timestamp ) { ColumnDefinition cdef = cfm . getColumnDefinition ( ByteBufferUtil . bytes ( columnName ) ) ; return BufferCell . live ( cfm , cdef , timestamp , ByteBufferUtil . bytes ( value ) ) ; } private Cell expiring ( CFMetaData cfm , String columnName , String value , long timestamp , int localExpirationTime ) { ColumnDefinition cdef = cfm . getColumnDefinition ( ByteBufferUtil . bytes ( columnName ) ) ; return new BufferCell ( cdef , timestamp , <int> , localExpirationTime , ByteBufferUtil . bytes ( value ) , null ) ; } private Cell deleted ( CFMetaData cfm , String columnName , int localDeletionTime , long timestamp ) { ColumnDefinition cdef = cfm . getColumnDefinition ( ByteBufferUtil . bytes ( columnName ) ) ; return BufferCell . tombstone ( cdef , timestamp , localDeletionTime ) ; } } 
