package org . gradle . internal . typeconversion ; import java . util . Collection ; import java . util . LinkedList ; import java . util . List ; import java . util . Set ; public class NotationParserBuilder < T > { private TypeInfo < T > resultingType ; private String invalidNotationMessage ; private String typeDisplayName ; private boolean implicitConverters = true ; private boolean allowNullInput ; private final Collection < NotationConverter < Object , ? extends T > > notationParsers = new LinkedList < NotationConverter < Object , ? extends T > > ( ) ; public static < T > NotationParserBuilder < T > toType ( Class < T > resultingType ) { return new NotationParserBuilder < T > ( new TypeInfo < T > ( resultingType ) ) ; } public static < T > NotationParserBuilder < T > toType ( TypeInfo < T > resultingType ) { return new NotationParserBuilder < T > ( resultingType ) ; } private NotationParserBuilder ( TypeInfo < T > resultingType ) { this . resultingType = resultingType ; typeDisplayName = resultingType . getTargetType ( ) . equals ( String . class ) ? <str> : <str> . concat ( resultingType . getTargetType ( ) . getSimpleName ( ) ) ; } public NotationParserBuilder < T > typeDisplayName ( String name ) { this . typeDisplayName = name ; return this ; } public NotationParserBuilder < T > noImplicitConverters ( ) { implicitConverters = false ; return this ; } public NotationParserBuilder < T > allowNullInput ( ) { allowNullInput = true ; return this ; } public NotationParserBuilder < T > converter ( NotationConverter < Object , ? extends T > converter ) { this . notationParsers . add ( converter ) ; return this ; } public < S > NotationParserBuilder < T > fromType ( Class < S > notationType , NotationConverter < ? super S , ? extends T > converter ) { this . notationParsers . add ( new TypeFilteringNotationConverter < Object , S , T > ( notationType , converter ) ) ; return this ; } public NotationParserBuilder < T > fromCharSequence ( NotationConverter < String , ? extends T > converter ) { this . notationParsers . add ( new CharSequenceNotationConverter < Object , T > ( converter ) ) ; return this ; } public NotationParserBuilder < T > fromCharSequence ( ) { if ( ! resultingType . getTargetType ( ) . equals ( String . class ) ) { throw new UnsupportedOperationException ( <str> ) ; } NotationConverter notationParser = new CharSequenceNotationParser ( ) ; fromCharSequence ( notationParser ) ; return this ; } public NotationParserBuilder < T > invalidNotationMessage ( String invalidNotationMessage ) { this . invalidNotationMessage = invalidNotationMessage ; return this ; } public NotationParser < Object , Set < T > > toFlatteningComposite ( ) { return wrapInErrorHandling ( new FlatteningNotationParser < T > ( create ( ) ) ) ; } public NotationParser < Object , T > toComposite ( ) { return wrapInErrorHandling ( create ( ) ) ; } private < S > NotationParser < Object , S > wrapInErrorHandling ( NotationParser < Object , S > parser ) { return new ErrorHandlingNotationParser < Object , S > ( typeDisplayName , invalidNotationMessage , allowNullInput , parser ) ; } private NotationParser < Object , T > create ( ) { List < NotationConverter < Object , ? extends T > > composites = new LinkedList < NotationConverter < Object , ? extends T > > ( ) ; if ( ! resultingType . getTargetType ( ) . equals ( Object . class ) & & implicitConverters ) { composites . add ( new JustReturningConverter < Object , T > ( resultingType . getTargetType ( ) ) ) ; } composites . addAll ( this . notationParsers ) ; return new NotationConverterToNotationParserAdapter < Object , T > ( composites . size ( ) = = <int> ? composites . get ( <int> ) : new CompositeNotationConverter < Object , T > ( composites ) ) ; } } 
