package org . elasticsearch . repositories . s3 ; import com . amazonaws . services . s3 . AmazonS3 ; import com . amazonaws . services . s3 . model . DeleteObjectsRequest ; import com . amazonaws . services . s3 . model . ObjectListing ; import com . amazonaws . services . s3 . model . S3ObjectSummary ; import org . elasticsearch . action . admin . cluster . repositories . put . PutRepositoryResponse ; import org . elasticsearch . action . admin . cluster . snapshots . create . CreateSnapshotResponse ; import org . elasticsearch . action . admin . cluster . snapshots . restore . RestoreSnapshotResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . ClusterAdminClient ; import org . elasticsearch . cloud . aws . AbstractAwsTestCase ; import org . elasticsearch . cloud . aws . AwsS3Service ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . plugin . repository . s3 . S3RepositoryPlugin ; import org . elasticsearch . repositories . RepositoryMissingException ; import org . elasticsearch . repositories . RepositoryVerificationException ; import org . elasticsearch . snapshots . SnapshotMissingException ; import org . elasticsearch . snapshots . SnapshotState ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import org . elasticsearch . test . store . MockFSDirectoryService ; import org . junit . After ; import org . junit . Before ; import java . util . ArrayList ; import java . util . List ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . notNullValue ; @ClusterScope ( scope = Scope . SUITE , numDataNodes = <int> , numClientNodes = <int> , transportClientRatio = <float> ) abstract public class AbstractS3SnapshotRestoreTest extends AbstractAwsTestCase { @Override public Settings indexSettings ( ) { return Settings . builder ( ) . put ( super . indexSettings ( ) ) . put ( MockFSDirectoryService . RANDOM_PREVENT_DOUBLE_WRITE , false ) . put ( MockFSDirectoryService . RANDOM_NO_DELETE_OPEN_FILE , false ) . put ( <str> , true ) . put ( <str> , S3RepositoryPlugin . class . getName ( ) ) . put ( <str> , basePath ) . build ( ) ; } private String basePath ; @Before public final void wipeBefore ( ) { wipeRepositories ( ) ; basePath = <str> + randomInt ( ) ; cleanRepositoryFiles ( basePath ) ; } @After public final void wipeAfter ( ) { wipeRepositories ( ) ; cleanRepositoryFiles ( basePath ) ; } @AwaitsFix ( bugUrl = <str> ) public void testSimpleWorkflow ( ) { Client client = client ( ) ; Settings . Builder settings = Settings . settingsBuilder ( ) . put ( <str> , randomIntBetween ( <int> , <int> ) ) ; if ( usually ( ) ) { settings . put ( <str> , basePath ) ; } logger . info ( <str> , internalCluster ( ) . getInstance ( Settings . class ) . get ( <str> ) , basePath ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( settings ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; createIndex ( <str> , <str> , <str> ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } refresh ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; CreateSnapshotResponse createSnapshotResponse = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> , <str> ) . get ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { client . prepareDelete ( <str> , <str> , Integer . toString ( i ) ) . get ( ) ; } for ( int i = <int> ; i < <int> ; i + + ) { client . prepareDelete ( <str> , <str> , Integer . toString ( i ) ) . get ( ) ; } for ( int i = <int> ; i < <int> ; i + = <int> ) { client . prepareDelete ( <str> , <str> , Integer . toString ( i ) ) . get ( ) ; } refresh ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; client . admin ( ) . indices ( ) . prepareClose ( <str> , <str> ) . get ( ) ; logger . info ( <str> ) ; RestoreSnapshotResponse restoreSnapshotResponse = client . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; ensureGreen ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; cluster ( ) . wipeIndices ( <str> , <str> ) ; logger . info ( <str> ) ; restoreSnapshotResponse = client . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; ensureGreen ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; ClusterState clusterState = client . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; assertThat ( clusterState . getMetaData ( ) . hasIndex ( <str> ) , equalTo ( true ) ) ; assertThat ( clusterState . getMetaData ( ) . hasIndex ( <str> ) , equalTo ( false ) ) ; } @AwaitsFix ( bugUrl = <str> ) public void testEncryption ( ) { Client client = client ( ) ; logger . info ( <str> , internalCluster ( ) . getInstance ( Settings . class ) . get ( <str> ) , basePath ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , basePath ) . put ( <str> , randomIntBetween ( <int> , <int> ) ) . put ( <str> , true ) ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; createIndex ( <str> , <str> , <str> ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } refresh ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; CreateSnapshotResponse createSnapshotResponse = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> , <str> ) . get ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( <str> ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; Settings settings = internalCluster ( ) . getInstance ( Settings . class ) ; Settings bucket = settings . getByPrefix ( <str> ) ; AmazonS3 s3Client = internalCluster ( ) . getInstance ( AwsS3Service . class ) . client ( null , null , bucket . get ( <str> , settings . get ( <str> ) ) , bucket . get ( <str> , settings . get ( <str> ) ) , bucket . get ( <str> , settings . get ( <str> ) ) ) ; String bucketName = bucket . get ( <str> ) ; logger . info ( <str> , bucketName , basePath ) ; List < S3ObjectSummary > summaries = s3Client . listObjects ( bucketName , basePath ) . getObjectSummaries ( ) ; for ( S3ObjectSummary summary : summaries ) { assertThat ( s3Client . getObjectMetadata ( bucketName , summary . getKey ( ) ) . getSSEAlgorithm ( ) , equalTo ( <str> ) ) ; } logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { client . prepareDelete ( <str> , <str> , Integer . toString ( i ) ) . get ( ) ; } for ( int i = <int> ; i < <int> ; i + + ) { client . prepareDelete ( <str> , <str> , Integer . toString ( i ) ) . get ( ) ; } for ( int i = <int> ; i < <int> ; i + = <int> ) { client . prepareDelete ( <str> , <str> , Integer . toString ( i ) ) . get ( ) ; } refresh ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; client . admin ( ) . indices ( ) . prepareClose ( <str> , <str> ) . get ( ) ; logger . info ( <str> ) ; RestoreSnapshotResponse restoreSnapshotResponse = client . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; ensureGreen ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; cluster ( ) . wipeIndices ( <str> , <str> ) ; logger . info ( <str> ) ; restoreSnapshotResponse = client . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; ensureGreen ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; ClusterState clusterState = client . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) . getState ( ) ; assertThat ( clusterState . getMetaData ( ) . hasIndex ( <str> ) , equalTo ( true ) ) ; assertThat ( clusterState . getMetaData ( ) . hasIndex ( <str> ) , equalTo ( false ) ) ; } public void testRepositoryWithCustomCredentialsIsNotAccessibleByDefaultCredentials ( ) { Client client = client ( ) ; Settings bucketSettings = internalCluster ( ) . getInstance ( Settings . class ) . getByPrefix ( <str> ) ; logger . info ( <str> , bucketSettings . get ( <str> ) , basePath ) ; try { client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , basePath ) . put ( <str> , bucketSettings . get ( <str> ) ) ) . get ( ) ; fail ( <str> ) ; } catch ( RepositoryVerificationException e ) { } } public void testRepositoryWithCustomCredentials ( ) { Client client = client ( ) ; Settings bucketSettings = internalCluster ( ) . getInstance ( Settings . class ) . getByPrefix ( <str> ) ; logger . info ( <str> , bucketSettings . get ( <str> ) , basePath ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , basePath ) . put ( <str> , bucketSettings . get ( <str> ) ) . put ( <str> , bucketSettings . get ( <str> ) ) . put ( <str> , bucketSettings . get ( <str> ) ) . put ( <str> , bucketSettings . get ( <str> ) ) ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; assertRepositoryIsOperational ( client , <str> ) ; } @AwaitsFix ( bugUrl = <str> ) public void testRepositoryWithCustomEndpointProtocol ( ) { Client client = client ( ) ; Settings bucketSettings = internalCluster ( ) . getInstance ( Settings . class ) . getByPrefix ( <str> ) ; logger . info ( <str> , bucketSettings . get ( <str> ) , bucketSettings . get ( <str> ) , basePath ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , bucketSettings . get ( <str> ) ) . put ( <str> , bucketSettings . get ( <str> ) ) . put ( <str> , bucketSettings . get ( <str> ) ) . put ( <str> , bucketSettings . get ( <str> ) ) . put ( <str> , basePath ) ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; assertRepositoryIsOperational ( client , <str> ) ; } public void testRepositoryInRemoteRegionIsRemote ( ) { Client client = client ( ) ; Settings bucketSettings = internalCluster ( ) . getInstance ( Settings . class ) . getByPrefix ( <str> ) ; logger . info ( <str> , bucketSettings . get ( <str> ) , basePath ) ; try { client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , basePath ) . put ( <str> , bucketSettings . get ( <str> ) ) ) . get ( ) ; fail ( <str> ) ; } catch ( RepositoryVerificationException e ) { } } @AwaitsFix ( bugUrl = <str> ) public void testRepositoryInRemoteRegion ( ) { Client client = client ( ) ; Settings settings = internalCluster ( ) . getInstance ( Settings . class ) ; Settings bucketSettings = settings . getByPrefix ( <str> ) ; logger . info ( <str> , bucketSettings . get ( <str> ) , basePath ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , basePath ) . put ( <str> , bucketSettings . get ( <str> ) ) . put ( <str> , bucketSettings . get ( <str> ) ) ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; assertRepositoryIsOperational ( client , <str> ) ; } public void testNonExistingRepo86 ( ) { Client client = client ( ) ; logger . info ( <str> , internalCluster ( ) . getInstance ( Settings . class ) . get ( <str> ) , basePath ) ; PutRepositoryResponse putRepositoryResponse = client . admin ( ) . cluster ( ) . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , basePath ) ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; logger . info ( <str> ) ; try { client . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( <str> , <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SnapshotMissingException ex ) { } } public void testGetDeleteNonExistingSnapshot86 ( ) { ClusterAdminClient client = client ( ) . admin ( ) . cluster ( ) ; logger . info ( <str> ) ; PutRepositoryResponse putRepositoryResponse = client . preparePutRepository ( <str> ) . setType ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , basePath ) ) . get ( ) ; assertThat ( putRepositoryResponse . isAcknowledged ( ) , equalTo ( true ) ) ; try { client . prepareGetSnapshots ( <str> ) . addSnapshots ( <str> ) . get ( ) ; fail ( <str> ) ; } catch ( SnapshotMissingException ex ) { } try { client . prepareDeleteSnapshot ( <str> , <str> ) . get ( ) ; fail ( <str> ) ; } catch ( SnapshotMissingException ex ) { } } private void assertRepositoryIsOperational ( Client client , String repository ) { createIndex ( <str> ) ; ensureGreen ( ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( <str> , <str> , Integer . toString ( i ) , <str> , <str> + i ) ; } refresh ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; CreateSnapshotResponse createSnapshotResponse = client . admin ( ) . cluster ( ) . prepareCreateSnapshot ( repository , <str> ) . setWaitForCompletion ( true ) . setIndices ( <str> ) . get ( ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , greaterThan ( <int> ) ) ; assertThat ( createSnapshotResponse . getSnapshotInfo ( ) . successfulShards ( ) , equalTo ( createSnapshotResponse . getSnapshotInfo ( ) . totalShards ( ) ) ) ; assertThat ( client . admin ( ) . cluster ( ) . prepareGetSnapshots ( repository ) . setSnapshots ( <str> ) . get ( ) . getSnapshots ( ) . get ( <int> ) . state ( ) , equalTo ( SnapshotState . SUCCESS ) ) ; logger . info ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { client . prepareDelete ( <str> , <str> , Integer . toString ( i ) ) . get ( ) ; } refresh ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; logger . info ( <str> ) ; client . admin ( ) . indices ( ) . prepareClose ( <str> ) . get ( ) ; logger . info ( <str> ) ; RestoreSnapshotResponse restoreSnapshotResponse = client . admin ( ) . cluster ( ) . prepareRestoreSnapshot ( repository , <str> ) . setWaitForCompletion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( restoreSnapshotResponse . getRestoreInfo ( ) . totalShards ( ) , greaterThan ( <int> ) ) ; ensureGreen ( ) ; assertThat ( client . prepareSearch ( <str> ) . setSize ( <int> ) . get ( ) . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; } public static void wipeRepositories ( String . . . repositories ) { if ( repositories . length = = <int> ) { repositories = new String [ ] { <str> } ; } for ( String repository : repositories ) { try { client ( ) . admin ( ) . cluster ( ) . prepareDeleteRepository ( repository ) . execute ( ) . actionGet ( ) ; } catch ( RepositoryMissingException ex ) { } } } public void cleanRepositoryFiles ( String basePath ) { Settings settings = internalCluster ( ) . getInstance ( Settings . class ) ; Settings [ ] buckets = { settings . getByPrefix ( <str> ) , settings . getByPrefix ( <str> ) , settings . getByPrefix ( <str> ) , settings . getByPrefix ( <str> ) } ; for ( Settings bucket : buckets ) { String endpoint = bucket . get ( <str> , settings . get ( <str> ) ) ; String protocol = bucket . get ( <str> , settings . get ( <str> ) ) ; String region = bucket . get ( <str> , settings . get ( <str> ) ) ; String accessKey = bucket . get ( <str> , settings . get ( <str> ) ) ; String secretKey = bucket . get ( <str> , settings . get ( <str> ) ) ; String bucketName = bucket . get ( <str> ) ; assertThat ( <str> , bucketName , notNullValue ( ) ) ; AmazonS3 client = internalCluster ( ) . getInstance ( AwsS3Service . class ) . client ( endpoint , protocol , region , accessKey , secretKey ) ; try { ObjectListing prevListing = null ; DeleteObjectsRequest multiObjectDeleteRequest = null ; ArrayList < DeleteObjectsRequest . KeyVersion > keys = new ArrayList < DeleteObjectsRequest . KeyVersion > ( ) ; while ( true ) { ObjectListing list ; if ( prevListing ! = null ) { list = client . listNextBatchOfObjects ( prevListing ) ; } else { list = client . listObjects ( bucketName , basePath ) ; multiObjectDeleteRequest = new DeleteObjectsRequest ( list . getBucketName ( ) ) ; } for ( S3ObjectSummary summary : list . getObjectSummaries ( ) ) { keys . add ( new DeleteObjectsRequest . KeyVersion ( summary . getKey ( ) ) ) ; if ( keys . size ( ) > <int> ) { multiObjectDeleteRequest . setKeys ( keys ) ; client . deleteObjects ( multiObjectDeleteRequest ) ; multiObjectDeleteRequest = new DeleteObjectsRequest ( list . getBucketName ( ) ) ; keys . clear ( ) ; } } if ( list . isTruncated ( ) ) { prevListing = list ; } else { break ; } } if ( ! keys . isEmpty ( ) ) { multiObjectDeleteRequest . setKeys ( keys ) ; client . deleteObjects ( multiObjectDeleteRequest ) ; } } catch ( Throwable ex ) { logger . warn ( <str> , ex , bucketName , region ) ; } } } } 
