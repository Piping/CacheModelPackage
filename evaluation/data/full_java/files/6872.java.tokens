package org . elasticsearch . indices . recovery ; import org . apache . lucene . store . RateLimiter ; import org . apache . lucene . store . RateLimiter . SimpleRateLimiter ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeUnit ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . EsExecutors ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . threadpool . ThreadPool ; import java . io . Closeable ; import java . util . Objects ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; public class RecoverySettings extends AbstractComponent implements Closeable { public static final String INDICES_RECOVERY_CONCURRENT_STREAMS = <str> ; public static final String INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS = <str> ; public static final String INDICES_RECOVERY_MAX_BYTES_PER_SEC = <str> ; public static final String INDICES_RECOVERY_RETRY_DELAY_STATE_SYNC = <str> ; public static final String INDICES_RECOVERY_RETRY_DELAY_NETWORK = <str> ; public static final String INDICES_RECOVERY_ACTIVITY_TIMEOUT = <str> ; public static final String INDICES_RECOVERY_INTERNAL_ACTION_TIMEOUT = <str> ; public static final String INDICES_RECOVERY_INTERNAL_LONG_ACTION_TIMEOUT = <str> ; public static final long SMALL_FILE_CUTOFF_BYTES = ByteSizeValue . parseBytesSizeValue ( <str> , <str> ) . bytes ( ) ; public static final ByteSizeValue DEFAULT_CHUNK_SIZE = new ByteSizeValue ( <int> , ByteSizeUnit . KB ) ; private volatile int concurrentStreams ; private volatile int concurrentSmallFileStreams ; private final ThreadPoolExecutor concurrentStreamPool ; private final ThreadPoolExecutor concurrentSmallFileStreamPool ; private volatile ByteSizeValue maxBytesPerSec ; private volatile SimpleRateLimiter rateLimiter ; private volatile TimeValue retryDelayStateSync ; private volatile TimeValue retryDelayNetwork ; private volatile TimeValue activityTimeout ; private volatile TimeValue internalActionTimeout ; private volatile TimeValue internalActionLongTimeout ; private volatile ByteSizeValue chunkSize = DEFAULT_CHUNK_SIZE ; @Inject public RecoverySettings ( Settings settings , NodeSettingsService nodeSettingsService ) { super ( settings ) ; this . retryDelayStateSync = settings . getAsTime ( INDICES_RECOVERY_RETRY_DELAY_STATE_SYNC , TimeValue . timeValueMillis ( <int> ) ) ; this . retryDelayNetwork = settings . getAsTime ( INDICES_RECOVERY_RETRY_DELAY_NETWORK , TimeValue . timeValueSeconds ( <int> ) ) ; this . internalActionTimeout = settings . getAsTime ( INDICES_RECOVERY_INTERNAL_ACTION_TIMEOUT , TimeValue . timeValueMinutes ( <int> ) ) ; this . internalActionLongTimeout = settings . getAsTime ( INDICES_RECOVERY_INTERNAL_LONG_ACTION_TIMEOUT , new TimeValue ( internalActionTimeout . millis ( ) * <int> ) ) ; this . activityTimeout = settings . getAsTime ( INDICES_RECOVERY_ACTIVITY_TIMEOUT , internalActionLongTimeout ) ; this . concurrentStreams = settings . getAsInt ( INDICES_RECOVERY_CONCURRENT_STREAMS , <int> ) ; this . concurrentStreamPool = EsExecutors . newScaling ( <str> , <int> , concurrentStreams , <int> , TimeUnit . SECONDS , EsExecutors . daemonThreadFactory ( settings , <str> ) ) ; this . concurrentSmallFileStreams = settings . getAsInt ( INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS , <int> ) ; this . concurrentSmallFileStreamPool = EsExecutors . newScaling ( <str> , <int> , concurrentSmallFileStreams , <int> , TimeUnit . SECONDS , EsExecutors . daemonThreadFactory ( settings , <str> ) ) ; this . maxBytesPerSec = settings . getAsBytesSize ( INDICES_RECOVERY_MAX_BYTES_PER_SEC , new ByteSizeValue ( <int> , ByteSizeUnit . MB ) ) ; if ( maxBytesPerSec . bytes ( ) < = <int> ) { rateLimiter = null ; } else { rateLimiter = new SimpleRateLimiter ( maxBytesPerSec . mbFrac ( ) ) ; } logger . debug ( <str> , maxBytesPerSec , concurrentStreams ) ; nodeSettingsService . addListener ( new ApplySettings ( ) ) ; } @Override public void close ( ) { ThreadPool . terminate ( concurrentStreamPool , <int> , TimeUnit . SECONDS ) ; ThreadPool . terminate ( concurrentSmallFileStreamPool , <int> , TimeUnit . SECONDS ) ; } public ThreadPoolExecutor concurrentStreamPool ( ) { return concurrentStreamPool ; } public ThreadPoolExecutor concurrentSmallFileStreamPool ( ) { return concurrentSmallFileStreamPool ; } public RateLimiter rateLimiter ( ) { return rateLimiter ; } public TimeValue retryDelayNetwork ( ) { return retryDelayNetwork ; } public TimeValue retryDelayStateSync ( ) { return retryDelayStateSync ; } public TimeValue activityTimeout ( ) { return activityTimeout ; } public TimeValue internalActionTimeout ( ) { return internalActionTimeout ; } public TimeValue internalActionLongTimeout ( ) { return internalActionLongTimeout ; } public ByteSizeValue getChunkSize ( ) { return chunkSize ; } void setChunkSize ( ByteSizeValue chunkSize ) { if ( chunkSize . bytesAsInt ( ) < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } this . chunkSize = chunkSize ; } class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { ByteSizeValue maxSizePerSec = settings . getAsBytesSize ( INDICES_RECOVERY_MAX_BYTES_PER_SEC , RecoverySettings . this . maxBytesPerSec ) ; if ( ! Objects . equals ( maxSizePerSec , RecoverySettings . this . maxBytesPerSec ) ) { logger . info ( <str> , INDICES_RECOVERY_MAX_BYTES_PER_SEC , RecoverySettings . this . maxBytesPerSec , maxSizePerSec ) ; RecoverySettings . this . maxBytesPerSec = maxSizePerSec ; if ( maxSizePerSec . bytes ( ) < = <int> ) { rateLimiter = null ; } else if ( rateLimiter ! = null ) { rateLimiter . setMBPerSec ( maxSizePerSec . mbFrac ( ) ) ; } else { rateLimiter = new SimpleRateLimiter ( maxSizePerSec . mbFrac ( ) ) ; } } int concurrentStreams = settings . getAsInt ( INDICES_RECOVERY_CONCURRENT_STREAMS , RecoverySettings . this . concurrentStreams ) ; if ( concurrentStreams ! = RecoverySettings . this . concurrentStreams ) { logger . info ( <str> , RecoverySettings . this . concurrentStreams , concurrentStreams ) ; RecoverySettings . this . concurrentStreams = concurrentStreams ; RecoverySettings . this . concurrentStreamPool . setMaximumPoolSize ( concurrentStreams ) ; } int concurrentSmallFileStreams = settings . getAsInt ( INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS , RecoverySettings . this . concurrentSmallFileStreams ) ; if ( concurrentSmallFileStreams ! = RecoverySettings . this . concurrentSmallFileStreams ) { logger . info ( <str> , RecoverySettings . this . concurrentSmallFileStreams , concurrentSmallFileStreams ) ; RecoverySettings . this . concurrentSmallFileStreams = concurrentSmallFileStreams ; RecoverySettings . this . concurrentSmallFileStreamPool . setMaximumPoolSize ( concurrentSmallFileStreams ) ; } RecoverySettings . this . retryDelayNetwork = maybeUpdate ( RecoverySettings . this . retryDelayNetwork , settings , INDICES_RECOVERY_RETRY_DELAY_NETWORK ) ; RecoverySettings . this . retryDelayStateSync = maybeUpdate ( RecoverySettings . this . retryDelayStateSync , settings , INDICES_RECOVERY_RETRY_DELAY_STATE_SYNC ) ; RecoverySettings . this . activityTimeout = maybeUpdate ( RecoverySettings . this . activityTimeout , settings , INDICES_RECOVERY_ACTIVITY_TIMEOUT ) ; RecoverySettings . this . internalActionTimeout = maybeUpdate ( RecoverySettings . this . internalActionTimeout , settings , INDICES_RECOVERY_INTERNAL_ACTION_TIMEOUT ) ; RecoverySettings . this . internalActionLongTimeout = maybeUpdate ( RecoverySettings . this . internalActionLongTimeout , settings , INDICES_RECOVERY_INTERNAL_LONG_ACTION_TIMEOUT ) ; } private TimeValue maybeUpdate ( final TimeValue currentValue , final Settings settings , final String key ) { final TimeValue value = settings . getAsTime ( key , currentValue ) ; if ( value . equals ( currentValue ) ) { return currentValue ; } logger . info ( <str> , key , currentValue , value ) ; return value ; } } } 
