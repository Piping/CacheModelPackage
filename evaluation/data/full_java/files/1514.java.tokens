package org . apache . cassandra . db . rows ; import java . nio . ByteBuffer ; import java . util . * ; import java . security . MessageDigest ; import org . junit . Test ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . CQLTester ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . context . CounterContext ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . CounterId ; import org . apache . cassandra . utils . FBUtilities ; import static org . junit . Assert . assertEquals ; public class DigestBackwardCompatibilityTest extends CQLTester { private ByteBuffer readAndDigest ( String partitionKey ) { ImmutableBTreePartition partition = Util . getOnlyPartitionUnfiltered ( Util . cmd ( getCurrentColumnFamilyStore ( ) , partitionKey ) . build ( ) ) ; MessageDigest digest = FBUtilities . threadLocalMD5Digest ( ) ; UnfilteredRowIterators . digest ( partition . unfilteredIterator ( ) , digest , MessagingService . VERSION_22 ) ; return ByteBuffer . wrap ( digest . digest ( ) ) ; } private void assertDigest ( String expected , ByteBuffer actual ) { String toTest = ByteBufferUtil . bytesToHex ( actual ) ; assertEquals ( String . format ( <str> , expected , toTest ) , expected , toTest ) ; } @Test public void testCQLTable ( ) throws Throwable { createTable ( <str> ) ; String key = <str> ; int N = <int> ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , key , i , <str> + i , i , <int> , <int> ) ; assertDigest ( <str> , readAndDigest ( key ) ) ; execute ( <str> , <int> , key , <int> ) ; execute ( <str> , <int> , key , <int> ) ; execute ( <str> , <int> L , key ) ; assertDigest ( <str> , readAndDigest ( key ) ) ; } @Test public void testCompactTable ( ) throws Throwable { createTable ( <str> ) ; String key = <str> ; int N = <int> ; for ( int i = <int> ; i < <int> ; i + + ) execute ( <str> , key , i , <str> + i , <int> , <int> ) ; assertDigest ( <str> , readAndDigest ( key ) ) ; execute ( <str> , <int> , key , <int> ) ; execute ( <str> , <int> L , key ) ; assertDigest ( <str> , readAndDigest ( key ) ) ; } @Test public void testStaticCompactTable ( ) throws Throwable { createTable ( <str> ) ; String key = <str> ; execute ( <str> , key , <str> , <int> , <int> ) ; assertDigest ( <str> , readAndDigest ( key ) ) ; } @Test public void testTableWithCollection ( ) throws Throwable { createTable ( <str> ) ; String key = <str> ; execute ( <str> , key , <int> ) ; assertDigest ( <str> , readAndDigest ( key ) ) ; execute ( <str> , <int> , key ) ; assertDigest ( <str> , readAndDigest ( key ) ) ; } @Test public void testCounterTable ( ) throws Throwable { createTable ( <str> ) ; String key = <str> ; CFMetaData metadata = getCurrentColumnFamilyStore ( ) . metadata ; ColumnDefinition column = metadata . getColumnDefinition ( ByteBufferUtil . bytes ( <str> ) ) ; ByteBuffer value = CounterContext . instance ( ) . createGlobal ( CounterId . fromInt ( <int> ) , <int> , <int> ) ; Row row = BTreeRow . singleCellRow ( Clustering . STATIC_CLUSTERING , BufferCell . live ( metadata , column , <int> L , value ) ) ; new Mutation ( PartitionUpdate . singleRowUpdate ( metadata , Util . dk ( key ) , row ) ) . applyUnsafe ( ) ; assertDigest ( <str> , readAndDigest ( key ) ) ; } } 
