package org . nd4j . linalg . util ; import static org . junit . Assert . * ; import java . util . Random ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . factory . Nd4jBackend ; public class TestArrayUtils extends BaseNd4jTest { public TestArrayUtils ( ) { } public TestArrayUtils ( Nd4jBackend backend ) { super ( backend ) ; } public TestArrayUtils ( String name ) { super ( name ) ; } public TestArrayUtils ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } @Test public void testFlattenDoubleArray ( ) { assertArrayEquals ( new double [ <int> ] , ArrayUtil . flattenDoubleArray ( new double [ <int> ] ) , <float> ) ; Random r = new Random ( <int> ) ; double [ ] d1 = new double [ <int> ] ; for ( int i = <int> ; i < d1 . length ; i + + ) d1 [ i ] = r . nextDouble ( ) ; assertArrayEquals ( d1 , ArrayUtil . flattenDoubleArray ( d1 ) , <float> ) ; double [ ] [ ] d2 = new double [ <int> ] [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) for ( int j = <int> ; j < <int> ; j + + ) d2 [ i ] [ j ] = r . nextDouble ( ) ; assertArrayEquals ( ArrayUtil . flatten ( d2 ) , ArrayUtil . flattenDoubleArray ( d2 ) , <float> ) ; double [ ] [ ] [ ] d3 = new double [ <int> ] [ <int> ] [ <int> ] ; double [ ] exp3 = new double [ <int> * <int> * <int> ] ; int c = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { for ( int j = <int> ; j < <int> ; j + + ) { for ( int k = <int> ; k < <int> ; k + + ) { double d = r . nextDouble ( ) ; exp3 [ c + + ] = d ; d3 [ i ] [ j ] [ k ] = d ; } } } assertArrayEquals ( exp3 , ArrayUtil . flattenDoubleArray ( d3 ) , <float> ) ; double [ ] [ ] [ ] [ ] d4 = new double [ <int> ] [ <int> ] [ <int> ] [ <int> ] ; double [ ] exp4 = new double [ <int> * <int> * <int> * <int> ] ; c = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { for ( int j = <int> ; j < <int> ; j + + ) { for ( int k = <int> ; k < <int> ; k + + ) { for ( int l = <int> ; l < <int> ; l + + ) { double d = r . nextDouble ( ) ; exp4 [ c + + ] = d ; d4 [ i ] [ j ] [ k ] [ l ] = d ; } } } } assertArrayEquals ( exp4 , ArrayUtil . flattenDoubleArray ( d4 ) , <float> ) ; } @Test public void testFlattenFloatArray ( ) { assertArrayEquals ( new float [ <int> ] , ArrayUtil . flattenFloatArray ( new float [ <int> ] ) , <float> ) ; Random r = new Random ( <int> ) ; float [ ] f1 = new float [ <int> ] ; for ( int i = <int> ; i < f1 . length ; i + + ) f1 [ i ] = r . nextFloat ( ) ; assertArrayEquals ( f1 , ArrayUtil . flattenFloatArray ( f1 ) , <float> ) ; float [ ] [ ] f2 = new float [ <int> ] [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) for ( int j = <int> ; j < <int> ; j + + ) f2 [ i ] [ j ] = r . nextFloat ( ) ; assertArrayEquals ( ArrayUtil . flatten ( f2 ) , ArrayUtil . flattenFloatArray ( f2 ) , <float> ) ; float [ ] [ ] [ ] f3 = new float [ <int> ] [ <int> ] [ <int> ] ; float [ ] exp3 = new float [ <int> * <int> * <int> ] ; int c = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { for ( int j = <int> ; j < <int> ; j + + ) { for ( int k = <int> ; k < <int> ; k + + ) { float d = r . nextFloat ( ) ; exp3 [ c + + ] = d ; f3 [ i ] [ j ] [ k ] = d ; } } } assertArrayEquals ( exp3 , ArrayUtil . flattenFloatArray ( f3 ) , <float> ) ; float [ ] [ ] [ ] [ ] f4 = new float [ <int> ] [ <int> ] [ <int> ] [ <int> ] ; float [ ] exp4 = new float [ <int> * <int> * <int> * <int> ] ; c = <int> ; for ( int i = <int> ; i < <int> ; i + + ) { for ( int j = <int> ; j < <int> ; j + + ) { for ( int k = <int> ; k < <int> ; k + + ) { for ( int l = <int> ; l < <int> ; l + + ) { float d = r . nextFloat ( ) ; exp4 [ c + + ] = d ; f4 [ i ] [ j ] [ k ] [ l ] = d ; } } } } assertArrayEquals ( exp4 , ArrayUtil . flattenFloatArray ( f4 ) , <float> ) ; } @Test public void testArrayShape ( ) { assertArrayEquals ( ArrayUtil . arrayShape ( new int [ <int> ] ) , new int [ ] { <int> } ) ; assertArrayEquals ( ArrayUtil . arrayShape ( new int [ <int> ] [ <int> ] [ <int> ] ) , new int [ ] { <int> , <int> , <int> } ) ; assertArrayEquals ( ArrayUtil . arrayShape ( new Object [ <int> ] [ <int> ] [ <int> ] [ <int> ] [ <int> ] ) , new int [ ] { <int> , <int> , <int> , <int> , <int> } ) ; assertArrayEquals ( ArrayUtil . arrayShape ( new double [ <int> ] [ <int> ] [ <int> ] [ <int> ] ) , new int [ ] { <int> , <int> , <int> , <int> } ) ; assertArrayEquals ( ArrayUtil . arrayShape ( new double [ <int> ] [ <int> ] [ <int> ] [ <int> ] ) , new int [ ] { <int> , <int> , <int> , <int> } ) ; assertArrayEquals ( ArrayUtil . arrayShape ( new char [ <int> ] [ <int> ] [ <int> ] ) , new int [ ] { <int> , <int> , <int> } ) ; assertArrayEquals ( ArrayUtil . arrayShape ( new String [ <int> ] [ <int> ] [ <int> ] ) , new int [ ] { <int> , <int> , <int> } ) ; } @Test public void testArgMinOfMaxMethods ( ) { int [ ] first = { <int> , <int> , <int> , <int> } ; int [ ] second = { <int> , <int> , <int> , <int> } ; assertEquals ( <int> , ArrayUtil . argMinOfMax ( first , second ) ) ; int [ ] third = { <int> , <int> , <int> , <int> } ; assertEquals ( <int> , ArrayUtil . argMinOfMax ( first , second , third ) ) ; } @Override public char ordering ( ) { return <str> ; } } 
