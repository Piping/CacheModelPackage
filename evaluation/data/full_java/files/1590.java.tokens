package org . apache . cassandra . locator ; import java . io . IOException ; import java . net . InetAddress ; import java . nio . charset . StandardCharsets ; import java . nio . file . Files ; import java . nio . file . Path ; import java . nio . file . Paths ; import java . nio . file . StandardOpenOption ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . UUID ; import com . google . common . net . InetAddresses ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . RandomPartitioner ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . gms . ApplicationState ; import org . apache . cassandra . gms . Gossiper ; import org . apache . cassandra . gms . VersionedValue ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . FBUtilities ; import org . junit . Before ; import org . junit . Test ; import static org . junit . Assert . * ; public class PropertyFileSnitchTest { private Path effectiveFile ; private Path backupFile ; private VersionedValue . VersionedValueFactory valueFactory ; private Map < InetAddress , Set < Token > > tokenMap ; @Before public void setup ( ) throws ConfigurationException , IOException { String confFile = FBUtilities . resourceToFile ( PropertyFileSnitch . SNITCH_PROPERTIES_FILENAME ) ; effectiveFile = Paths . get ( confFile ) ; backupFile = Paths . get ( confFile + <str> ) ; restoreOrigConfigFile ( ) ; InetAddress [ ] hosts = { InetAddress . getByName ( <str> ) , InetAddress . getByName ( <str> ) , InetAddress . getByName ( <str> ) , } ; IPartitioner partitioner = new RandomPartitioner ( ) ; valueFactory = new VersionedValue . VersionedValueFactory ( partitioner ) ; tokenMap = new HashMap < > ( ) ; for ( InetAddress host : hosts ) { Set < Token > tokens = Collections . singleton ( partitioner . getRandomToken ( ) ) ; Gossiper . instance . initializeNodeUnsafe ( host , UUID . randomUUID ( ) , <int> ) ; Gossiper . instance . injectApplicationState ( host , ApplicationState . TOKENS , valueFactory . tokens ( tokens ) ) ; setNodeShutdown ( host ) ; tokenMap . put ( host , tokens ) ; } } private void restoreOrigConfigFile ( ) throws IOException { if ( Files . exists ( backupFile ) ) { Files . copy ( backupFile , effectiveFile , java . nio . file . StandardCopyOption . REPLACE_EXISTING ) ; Files . delete ( backupFile ) ; } } private void replaceConfigFile ( Map < String , String > replacements ) throws IOException { List < String > lines = Files . readAllLines ( effectiveFile , StandardCharsets . UTF_8 ) ; List < String > newLines = new ArrayList < > ( lines . size ( ) ) ; Set < String > replaced = new HashSet < > ( ) ; for ( String line : lines ) { String [ ] info = line . split ( <str> ) ; if ( info . length = = <int> & & replacements . containsKey ( info [ <int> ] ) ) { String replacement = replacements . get ( info [ <int> ] ) ; if ( ! replacement . isEmpty ( ) ) newLines . add ( info [ <int> ] + <str> + replacement ) ; replaced . add ( info [ <int> ] ) ; } else { newLines . add ( line ) ; } } for ( Map . Entry < String , String > replacement : replacements . entrySet ( ) ) { if ( replaced . contains ( replacement . getKey ( ) ) ) continue ; if ( ! replacement . getValue ( ) . isEmpty ( ) ) newLines . add ( replacement . getKey ( ) + <str> + replacement . getValue ( ) ) ; } Files . write ( effectiveFile , newLines , StandardCharsets . UTF_8 , StandardOpenOption . TRUNCATE_EXISTING ) ; } private void setNodeShutdown ( InetAddress host ) { StorageService . instance . getTokenMetadata ( ) . removeEndpoint ( host ) ; Gossiper . instance . injectApplicationState ( host , ApplicationState . STATUS , valueFactory . shutdown ( true ) ) ; Gossiper . instance . markDead ( host , Gossiper . instance . getEndpointStateForEndpoint ( host ) ) ; } private void setNodeLive ( InetAddress host ) { Gossiper . instance . injectApplicationState ( host , ApplicationState . STATUS , valueFactory . normal ( tokenMap . get ( host ) ) ) ; Gossiper . instance . realMarkAlive ( host , Gossiper . instance . getEndpointStateForEndpoint ( host ) ) ; StorageService . instance . getTokenMetadata ( ) . updateNormalTokens ( tokenMap . get ( host ) , host ) ; } private static void checkEndpoint ( final AbstractNetworkTopologySnitch snitch , final String endpointString , final String expectedDatacenter , final String expectedRack ) { final InetAddress endpoint = InetAddresses . forString ( endpointString ) ; assertEquals ( expectedDatacenter , snitch . getDatacenter ( endpoint ) ) ; assertEquals ( expectedRack , snitch . getRack ( endpoint ) ) ; } @Test public void testChangeHostRack ( ) throws Exception { final InetAddress host = InetAddress . getByName ( <str> ) ; final PropertyFileSnitch snitch = new PropertyFileSnitch ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; try { setNodeLive ( host ) ; Files . copy ( effectiveFile , backupFile ) ; replaceConfigFile ( Collections . singletonMap ( host . getHostAddress ( ) , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; setNodeShutdown ( host ) ; replaceConfigFile ( Collections . singletonMap ( host . getHostAddress ( ) , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; } finally { restoreOrigConfigFile ( ) ; setNodeShutdown ( host ) ; } } @Test public void testChangeHostDc ( ) throws Exception { final InetAddress host = InetAddress . getByName ( <str> ) ; final PropertyFileSnitch snitch = new PropertyFileSnitch ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; try { setNodeLive ( host ) ; Files . copy ( effectiveFile , backupFile ) ; replaceConfigFile ( Collections . singletonMap ( host . getHostAddress ( ) , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; setNodeShutdown ( host ) ; replaceConfigFile ( Collections . singletonMap ( host . getHostAddress ( ) , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; } finally { restoreOrigConfigFile ( ) ; setNodeShutdown ( host ) ; } } @Test public void testAddHost ( ) throws Exception { final InetAddress host = InetAddress . getByName ( <str> ) ; final PropertyFileSnitch snitch = new PropertyFileSnitch ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; try { setNodeLive ( host ) ; Files . copy ( effectiveFile , backupFile ) ; replaceConfigFile ( Collections . singletonMap ( host . getHostAddress ( ) , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; setNodeShutdown ( host ) ; replaceConfigFile ( Collections . singletonMap ( host . getHostAddress ( ) , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; } finally { restoreOrigConfigFile ( ) ; setNodeShutdown ( host ) ; } } @Test public void testRemoveHost ( ) throws Exception { final InetAddress host = InetAddress . getByName ( <str> ) ; final PropertyFileSnitch snitch = new PropertyFileSnitch ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; try { setNodeLive ( host ) ; Files . copy ( effectiveFile , backupFile ) ; replaceConfigFile ( Collections . singletonMap ( host . getHostAddress ( ) , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; setNodeShutdown ( host ) ; replaceConfigFile ( Collections . singletonMap ( host . getHostAddress ( ) , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; } finally { restoreOrigConfigFile ( ) ; setNodeShutdown ( host ) ; } } @Test public void testChangeDefault ( ) throws Exception { final InetAddress host = InetAddress . getByName ( <str> ) ; final PropertyFileSnitch snitch = new PropertyFileSnitch ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; try { setNodeLive ( host ) ; Files . copy ( effectiveFile , backupFile ) ; replaceConfigFile ( Collections . singletonMap ( <str> , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; setNodeShutdown ( host ) ; replaceConfigFile ( Collections . singletonMap ( <str> , <str> ) ) ; Thread . sleep ( <int> ) ; checkEndpoint ( snitch , host . getHostAddress ( ) , <str> , <str> ) ; } finally { restoreOrigConfigFile ( ) ; setNodeShutdown ( host ) ; } } } 
