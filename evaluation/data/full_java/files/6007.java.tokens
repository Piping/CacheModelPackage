package org . elasticsearch . common . lucene . uid ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . LeafReader ; import org . apache . lucene . index . LeafReader . CoreClosedListener ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . Term ; import org . apache . lucene . util . CloseableThreadLocal ; import org . elasticsearch . common . util . concurrent . ConcurrentCollections ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import java . io . IOException ; import java . util . List ; import java . util . concurrent . ConcurrentMap ; public class Versions { public static final long MATCH_ANY = - <int> ; public static final long NOT_FOUND = - <int> ; public static final long NOT_SET = - <int> ; public static final long MATCH_DELETED = - <int> ; static final ConcurrentMap < Object , CloseableThreadLocal < PerThreadIDAndVersionLookup > > lookupStates = ConcurrentCollections . newConcurrentMapWithAggressiveConcurrency ( ) ; private static final CoreClosedListener removeLookupState = new CoreClosedListener ( ) { @Override public void onClose ( Object key ) { CloseableThreadLocal < PerThreadIDAndVersionLookup > ctl = lookupStates . remove ( key ) ; if ( ctl ! = null ) { ctl . close ( ) ; } } } ; private static PerThreadIDAndVersionLookup getLookupState ( LeafReader reader ) throws IOException { Object key = reader . getCoreCacheKey ( ) ; CloseableThreadLocal < PerThreadIDAndVersionLookup > ctl = lookupStates . get ( key ) ; if ( ctl = = null ) { ctl = new CloseableThreadLocal < > ( ) ; CloseableThreadLocal < PerThreadIDAndVersionLookup > other = lookupStates . putIfAbsent ( key , ctl ) ; if ( other = = null ) { reader . addCoreClosedListener ( removeLookupState ) ; } else { ctl = other ; } } PerThreadIDAndVersionLookup lookupState = ctl . get ( ) ; if ( lookupState = = null ) { lookupState = new PerThreadIDAndVersionLookup ( reader ) ; ctl . set ( lookupState ) ; } return lookupState ; } private Versions ( ) { } public static class DocIdAndVersion { public final int docId ; public final long version ; public final LeafReaderContext context ; public DocIdAndVersion ( int docId , long version , LeafReaderContext context ) { this . docId = docId ; this . version = version ; this . context = context ; } } public static DocIdAndVersion loadDocIdAndVersion ( IndexReader reader , Term term ) throws IOException { assert term . field ( ) . equals ( UidFieldMapper . NAME ) ; List < LeafReaderContext > leaves = reader . leaves ( ) ; if ( leaves . isEmpty ( ) ) { return null ; } for ( int i = leaves . size ( ) - <int> ; i > = <int> ; i - - ) { LeafReaderContext context = leaves . get ( i ) ; LeafReader leaf = context . reader ( ) ; PerThreadIDAndVersionLookup lookup = getLookupState ( leaf ) ; DocIdAndVersion result = lookup . lookup ( term . bytes ( ) , leaf . getLiveDocs ( ) , context ) ; if ( result ! = null ) { return result ; } } return null ; } public static long loadVersion ( IndexReader reader , Term term ) throws IOException { final DocIdAndVersion docIdAndVersion = loadDocIdAndVersion ( reader , term ) ; return docIdAndVersion = = null ? NOT_FOUND : docIdAndVersion . version ; } } 
