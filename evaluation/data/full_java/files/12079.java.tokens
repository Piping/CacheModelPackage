package org . gradle . internal . filewatch . jdk7 ; import com . google . common . util . concurrent . FutureCallback ; import com . google . common . util . concurrent . Futures ; import com . google . common . util . concurrent . ListenableFuture ; import com . google . common . util . concurrent . ListeningExecutorService ; import org . gradle . api . Action ; import org . gradle . api . internal . file . FileSystemSubset ; import org . gradle . internal . filewatch . FileWatcher ; import org . gradle . internal . filewatch . FileWatcherEvent ; import org . gradle . internal . filewatch . FileWatcherListener ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . IOException ; import java . nio . file . ClosedWatchServiceException ; import java . nio . file . WatchService ; import java . util . List ; import java . util . concurrent . atomic . AtomicBoolean ; public class WatchServiceFileWatcherBacking { private static final Logger LOGGER = LoggerFactory . getLogger ( WatchServiceFileWatcherBacking . class ) ; private final AtomicBoolean started = new AtomicBoolean ( ) ; private final AtomicBoolean running = new AtomicBoolean ( ) ; private final AtomicBoolean stopped = new AtomicBoolean ( ) ; private final Action < ? super Throwable > onError ; private final WatchServiceRegistrar watchServiceRegistrar ; private final WatchService watchService ; private final WatchServicePoller poller ; private final FileWatcher fileWatcher = new FileWatcher ( ) { @Override public boolean isRunning ( ) { return running . get ( ) ; } @Override public void watch ( FileSystemSubset fileSystemSubset ) throws IOException { WatchServiceFileWatcherBacking . this . watchServiceRegistrar . watch ( fileSystemSubset ) ; } @Override public void stop ( ) { WatchServiceFileWatcherBacking . this . stop ( ) ; } } ; WatchServiceFileWatcherBacking ( Action < ? super Throwable > onError , FileWatcherListener listener , WatchService watchService ) throws IOException { this . onError = onError ; this . watchServiceRegistrar = new WatchServiceRegistrar ( watchService , listener ) ; this . watchService = watchService ; this . poller = new WatchServicePoller ( watchService ) ; } public FileWatcher start ( ListeningExecutorService executorService ) { if ( started . compareAndSet ( false , true ) ) { final ListenableFuture < ? > runLoopFuture = executorService . submit ( new Runnable ( ) { @Override public void run ( ) { if ( ! stopped . get ( ) ) { running . set ( true ) ; try { try { pumpEvents ( ) ; } catch ( InterruptedException e ) { } catch ( Throwable t ) { stop ( ) ; onError . execute ( t ) ; } } finally { stop ( ) ; } } } } ) ; Futures . addCallback ( runLoopFuture , new FutureCallback < Object > ( ) { @Override public void onSuccess ( Object result ) { running . set ( false ) ; } @Override public void onFailure ( Throwable t ) { running . set ( false ) ; } } ) ; return fileWatcher ; } else { throw new IllegalStateException ( <str> ) ; } } private void pumpEvents ( ) throws InterruptedException { while ( isRunning ( ) ) { try { List < FileWatcherEvent > events = poller . takeEvents ( ) ; if ( events ! = null ) { deliverEvents ( events ) ; } } catch ( ClosedWatchServiceException e ) { stop ( ) ; } } } private void deliverEvents ( List < FileWatcherEvent > events ) { for ( FileWatcherEvent event : events ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( <str> , event ) ; } if ( ! isRunning ( ) ) { break ; } watchServiceRegistrar . onChange ( fileWatcher , event ) ; } } private boolean isRunning ( ) { return running . get ( ) & & ! Thread . currentThread ( ) . isInterrupted ( ) ; } private void stop ( ) { if ( stopped . compareAndSet ( false , true ) ) { if ( running . compareAndSet ( true , false ) ) { try { watchService . close ( ) ; } catch ( IOException e ) { } catch ( ClosedWatchServiceException e ) { } } } } } 
