package org . eclipse . debug . examples . pdavm ; import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintStream ; import java . io . StringWriter ; import java . net . ServerSocket ; import java . net . Socket ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Iterator ; import java . util . LinkedHashMap ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . StringTokenizer ; import java . util . TreeSet ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class PDAVirtualMachine { static class Stack extends LinkedList < Object > { private static final long serialVersionUID = <int> ; @Override public Object pop ( ) { return isEmpty ( ) ? Integer . valueOf ( <int> ) : remove ( size ( ) - <int> ) ; } @Override public void push ( Object value ) { add ( value ) ; } } static class Register { Register ( String name ) { fName = name ; } String fName ; String fGroup = <str> ; boolean fIsWriteable = true ; Map < String , BitField > fBitFields = new LinkedHashMap < String , BitField > ( <int> ) ; int fValue ; } static class BitField { BitField ( String name ) { fName = name ; } String fName ; int fBitOffset ; int fBitCount ; Map < String , Integer > fMnemonics = new LinkedHashMap < String , Integer > ( <int> ) ; } Map < String , Register > fRegisters = new LinkedHashMap < String , Register > ( <int> ) ; class Args { final String [ ] fArgs ; int next = <int> ; Args ( String [ ] args ) { fArgs = args ; } boolean hasNextArg ( ) { return fArgs . length > next ; } String getNextStringArg ( ) { if ( fArgs . length > next ) { return fArgs [ next + + ] ; } return <str> ; } int getNextIntArg ( ) { String arg = getNextStringArg ( ) ; try { return Integer . parseInt ( arg ) ; } catch ( NumberFormatException e ) { } return <int> ; } boolean getNextBooleanArg ( ) { String arg = getNextStringArg ( ) ; try { return Boolean . getBoolean ( arg ) ; } catch ( NumberFormatException e ) { } return false ; } Object getNextIntOrStringArg ( ) { String arg = getNextStringArg ( ) ; try { return Integer . valueOf ( arg ) ; } catch ( NumberFormatException e ) { } return arg ; } PDAThread getThreadArg ( ) { int id = getNextIntArg ( ) ; return fThreads . get ( Integer . valueOf ( id ) ) ; } } class PDAThread { final int fID ; final Stack fStack = new Stack ( ) ; String [ ] fThreadCode ; Map < String , Integer > fThreadLabels ; final List < Frame > fFrames = new LinkedList < Frame > ( ) ; Frame fCurrentFrame ; boolean fRun = true ; String fSuspend = null ; boolean fStep = false ; boolean fStepReturn = false ; int fSavedPC ; boolean fPerformingEval = false ; PDAThread ( int id , String function , int pc ) { fID = id ; fCurrentFrame = new Frame ( function , pc ) ; fThreadCode = fCode ; fThreadLabels = fLabels ; } } final Map < Integer , PDAThread > fThreads = new LinkedHashMap < Integer , PDAThread > ( ) ; int fNextThreadId = <int> ; boolean fStarted = true ; final String [ ] fCode ; final Map < String , Integer > fLabels ; class Frame { final Map < String , Object > fLocalVariables = new LinkedHashMap < String , Object > ( ) ; final String fFunction ; int fPC ; Frame ( String function , int pc ) { fFunction = function ; fPC = pc ; } void set ( String name , Object value ) { if ( name . startsWith ( <str> ) ) { setRegisterValue ( name , value ) ; } else { fLocalVariables . put ( name , value ) ; } } Object get ( String name ) { if ( name . startsWith ( <str> ) ) { return getRegisterValue ( name ) ; } else { return fLocalVariables . get ( name ) ; } } } void setRegisterValue ( String name , Object value ) { Register reg = fRegisters . get ( getRegisterPartOfName ( name ) ) ; if ( reg = = null ) { return ; } String bitFieldName = getBitFieldPartOfName ( name ) ; if ( bitFieldName ! = null ) { BitField bitField = reg . fBitFields . get ( bitFieldName ) ; if ( bitField = = null ) { return ; } Integer intValue = null ; if ( value instanceof Integer ) { intValue = ( Integer ) value ; } else if ( value instanceof String ) { intValue = bitField . fMnemonics . get ( value ) ; } if ( intValue ! = null ) { int bitFieldMask = <int> ^ ( bitField . fBitCount - <int> ) ; int registerMask = ~ ( bitFieldMask < < bitField . fBitOffset ) ; int bitFieldValue = intValue . intValue ( ) & bitFieldMask ; reg . fValue = ( reg . fValue & registerMask ) | ( bitFieldValue < < bitField . fBitOffset ) ; } } else if ( value instanceof Integer ) { reg . fValue = ( ( Integer ) value ) . intValue ( ) ; } } Object getRegisterValue ( String name ) { Register reg = fRegisters . get ( getRegisterPartOfName ( name ) ) ; if ( reg = = null ) { return null ; } String bitFieldName = getBitFieldPartOfName ( name ) ; if ( bitFieldName ! = null ) { BitField bitField = reg . fBitFields . get ( bitFieldName ) ; if ( bitField = = null ) { return null ; } int bitFieldMask = <int> ^ ( bitField . fBitCount - <int> ) ; int registerMask = bitFieldMask < < bitField . fBitOffset ; return Integer . valueOf ( ( reg . fValue & registerMask ) > > bitField . fBitOffset ) ; } else { return Integer . valueOf ( reg . fValue ) ; } } final Map < Integer , Boolean > fBreakpoints = new HashMap < Integer , Boolean > ( ) ; String fSuspendVM ; boolean fStepVM = false ; boolean fStepReturnVM = false ; int fSteppingThread = <int> ; final String fFilename ; final boolean fDebug ; final int fCommandPort ; Socket fCommandSocket ; BufferedReader fCommandReceiveStream ; OutputStream fCommandResponseStream ; final int fEventPort ; Socket fEventSocket ; OutputStream fEventStream ; final Map < String , Boolean > fEventStops = new HashMap < String , Boolean > ( ) ; { fEventStops . put ( <str> , Boolean . FALSE ) ; fEventStops . put ( <str> , Boolean . FALSE ) ; } final Map < String , Integer > fWatchpoints = new HashMap < String , Integer > ( ) ; public static void main ( String [ ] args ) { String programFile = args . length > = <int> ? args [ <int> ] : null ; if ( programFile = = null ) { System . err . println ( <str> ) ; return ; } String debugFlag = args . length > = <int> ? args [ <int> ] : <str> ; boolean debug = <str> . equals ( debugFlag ) ; int commandPort = <int> ; int eventPort = <int> ; if ( debug ) { String commandPortStr = args . length > = <int> ? args [ <int> ] : <str> ; try { commandPort = Integer . parseInt ( commandPortStr ) ; } catch ( NumberFormatException e ) { System . err . println ( <str> ) ; return ; } String eventPortStr = args . length > = <int> ? args [ <int> ] : <str> ; try { eventPort = Integer . parseInt ( eventPortStr ) ; } catch ( NumberFormatException e ) { System . err . println ( <str> ) ; return ; } } PDAVirtualMachine pdaVM = null ; try { pdaVM = new PDAVirtualMachine ( programFile , debug , commandPort , eventPort ) ; pdaVM . startDebugger ( ) ; } catch ( IOException e ) { System . err . println ( <str> + e . toString ( ) ) ; return ; } pdaVM . run ( ) ; } PDAVirtualMachine ( String inputFile , boolean debug , int commandPort , int eventPort ) throws IOException { fFilename = inputFile ; StringWriter stringWriter = new StringWriter ( ) ; List < String > code = new LinkedList < String > ( ) ; try ( FileReader fileReader = new FileReader ( inputFile ) ) { int c = fileReader . read ( ) ; while ( c ! = - <int> ) { if ( c = = <str> ) { code . add ( stringWriter . toString ( ) . trim ( ) ) ; stringWriter = new StringWriter ( ) ; } else { stringWriter . write ( c ) ; } c = fileReader . read ( ) ; } } code . add ( stringWriter . toString ( ) . trim ( ) ) ; fCode = code . toArray ( new String [ code . size ( ) ] ) ; fLabels = mapLabels ( fCode ) ; fDebug = debug ; fCommandPort = commandPort ; fEventPort = eventPort ; } Map < String , Integer > mapLabels ( String [ ] code ) { Map < String , Integer > labels = new HashMap < String , Integer > ( ) ; for ( int i = <int> ; i < code . length ; i + + ) { if ( code [ i ] . length ( ) ! = <int> & & code [ i ] . charAt ( <int> ) = = <str> ) { labels . put ( code [ i ] . substring ( <int> ) , Integer . valueOf ( i ) ) ; } } return labels ; } void sendCommandResponse ( String response ) { try { fCommandResponseStream . write ( response . getBytes ( ) ) ; fCommandResponseStream . flush ( ) ; } catch ( IOException e ) { } } void sendDebugEvent ( String event , boolean error ) { if ( fDebug ) { try { fEventStream . write ( event . getBytes ( ) ) ; fEventStream . write ( <str> ) ; fEventStream . flush ( ) ; } catch ( IOException e ) { System . err . println ( <str> + e ) ; System . exit ( <int> ) ; } } else if ( error ) { System . err . println ( <str> + event ) ; } } void startDebugger ( ) throws IOException { if ( fDebug ) { System . out . println ( <str> + fCommandPort + <str> + fEventPort ) ; } try ( ServerSocket commandServerSocket = new ServerSocket ( fCommandPort ) ) { fCommandSocket = commandServerSocket . accept ( ) ; fCommandReceiveStream = new BufferedReader ( new InputStreamReader ( fCommandSocket . getInputStream ( ) ) ) ; fCommandResponseStream = new PrintStream ( fCommandSocket . getOutputStream ( ) ) ; } try ( ServerSocket eventServerSocket = new ServerSocket ( fEventPort ) ) { fEventSocket = eventServerSocket . accept ( ) ; fEventStream = new PrintStream ( fEventSocket . getOutputStream ( ) ) ; } System . out . println ( <str> ) ; fSuspendVM = <str> ; } void run ( ) { int id = fNextThreadId + + ; sendDebugEvent ( <str> , false ) ; fThreads . put ( Integer . valueOf ( id ) , new PDAThread ( id , <str> , <int> ) ) ; if ( fDebug ) { sendDebugEvent ( <str> + id , false ) ; } boolean allThreadsSuspended = false ; while ( ! fThreads . isEmpty ( ) ) { checkForBreakpoint ( ) ; if ( fSuspendVM ! = null ) { debugUI ( ) ; } else { yieldToDebug ( allThreadsSuspended ) ; if ( fSuspendVM ! = null ) { continue ; } } PDAThread [ ] threadsCopy = fThreads . values ( ) . toArray ( new PDAThread [ fThreads . size ( ) ] ) ; allThreadsSuspended = true ; for ( int i = <int> ; i < threadsCopy . length ; i + + ) { PDAThread thread = threadsCopy [ i ] ; if ( thread . fSuspend = = null ) { allThreadsSuspended = false ; String instruction = thread . fThreadCode [ thread . fCurrentFrame . fPC ] ; thread . fCurrentFrame . fPC + + ; doOneInstruction ( thread , instruction ) ; if ( thread . fCurrentFrame . fPC > = thread . fThreadCode . length ) { thread . fRun = false ; } else if ( thread . fStepReturn ) { instruction = thread . fThreadCode [ thread . fCurrentFrame . fPC ] ; if ( <str> . equals ( instruction ) ) { if ( fStepReturnVM ) { fSuspendVM = thread . fID + <str> ; } else { thread . fSuspend = <str> ; } } } if ( ! thread . fRun ) { sendDebugEvent ( <str> + thread . fID , false ) ; fThreads . remove ( Integer . valueOf ( thread . fID ) ) ; } else if ( thread . fSuspend ! = null ) { sendDebugEvent ( <str> + thread . fID + <str> + thread . fSuspend , false ) ; thread . fStep = thread . fStepReturn = thread . fPerformingEval = false ; } } } Thread . yield ( ) ; } sendDebugEvent ( <str> , false ) ; if ( fDebug ) { try { fCommandReceiveStream . close ( ) ; fCommandResponseStream . close ( ) ; fCommandSocket . close ( ) ; fEventStream . close ( ) ; fEventSocket . close ( ) ; } catch ( IOException e ) { System . out . println ( <str> + e ) ; } } } void doOneInstruction ( PDAThread thread , String instr ) { StringTokenizer tokenizer = new StringTokenizer ( instr ) ; String op = tokenizer . nextToken ( ) ; List < String > tokens = new LinkedList < String > ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { tokens . add ( tokenizer . nextToken ( ) ) ; } Args args = new Args ( tokens . toArray ( new String [ tokens . size ( ) ] ) ) ; boolean opValid = true ; if ( op . equals ( <str> ) ) { iAdd ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iBranchNotZero ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iCall ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iDec ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iDef ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iDup ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iExec ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iHalt ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iOutput ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iPop ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iPush ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iReturn ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iVar ( thread , args ) ; } else if ( op . equals ( <str> ) ) { iInternalEndEval ( thread , args ) ; } else if ( op . startsWith ( <str> ) ) { } else if ( op . startsWith ( <str> ) ) { } else { opValid = false ; } if ( ! opValid ) { sendDebugEvent ( <str> + op , true ) ; if ( fEventStops . get ( <str> ) . booleanValue ( ) ) { fSuspendVM = thread . fID + <str> ; thread . fCurrentFrame . fPC - - ; } } else if ( thread . fStep ) { if ( fStepVM ) { fSuspendVM = thread . fID + <str> ; fStepVM = false ; } else { thread . fSuspend = <str> ; } thread . fStep = false ; } } void checkForBreakpoint ( ) { if ( fDebug ) { for ( Iterator < PDAThread > itr = fThreads . values ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { PDAThread thread = itr . next ( ) ; Integer pc = Integer . valueOf ( thread . fCurrentFrame . fPC ) ; if ( fSuspendVM = = null & & thread . fSuspend = = null & & ! thread . fPerformingEval & & fBreakpoints . containsKey ( pc ) ) { if ( fBreakpoints . get ( pc ) . booleanValue ( ) ) { fSuspendVM = thread . fID + <str> + pc ; } else { thread . fSuspend = <str> + pc ; thread . fStep = thread . fStepReturn = false ; sendDebugEvent ( <str> + thread . fID + <str> + thread . fSuspend , false ) ; } } } } } void yieldToDebug ( boolean allThreadsSuspended ) { if ( fDebug ) { String line = <str> ; try { if ( allThreadsSuspended | | fCommandReceiveStream . ready ( ) ) { line = fCommandReceiveStream . readLine ( ) ; processDebugCommand ( line ) ; } } catch ( IOException e ) { System . err . println ( <str> + e ) ; System . exit ( <int> ) ; } } } void debugUI ( ) { if ( ! fStarted ) { sendDebugEvent ( <str> + fSuspendVM , false ) ; } else { fStarted = false ; } fStepVM = fStepReturnVM = false ; for ( Iterator < PDAThread > itr = fThreads . values ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { PDAThread thread = itr . next ( ) ; thread . fSuspend = null ; thread . fStep = thread . fStepReturn = thread . fPerformingEval = false ; } while ( fSuspendVM ! = null ) { String line = <str> ; try { line = fCommandReceiveStream . readLine ( ) ; } catch ( IOException e ) { System . err . println ( <str> + e ) ; System . exit ( <int> ) ; return ; } processDebugCommand ( line ) ; } if ( fStepVM | | fStepReturnVM ) { sendDebugEvent ( <str> , false ) ; } else { sendDebugEvent ( <str> , false ) ; } } void processDebugCommand ( String line ) { StringTokenizer tokenizer = new StringTokenizer ( line . trim ( ) ) ; if ( line . length ( ) = = <int> ) { return ; } String command = tokenizer . nextToken ( ) ; List < String > tokens = new LinkedList < String > ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { tokens . add ( tokenizer . nextToken ( ) ) ; } Args args = new Args ( tokens . toArray ( new String [ tokens . size ( ) ] ) ) ; if ( <str> . equals ( command ) ) { debugChildren ( args ) ; } else if ( <str> . equals ( command ) ) { debugClearBreakpoint ( args ) ; } else if ( <str> . equals ( command ) ) { debugData ( args ) ; } else if ( <str> . equals ( command ) ) { debugDropFrame ( args ) ; } else if ( <str> . equals ( command ) ) { debugEval ( args ) ; } else if ( <str> . equals ( command ) ) { debugEventStop ( args ) ; } else if ( <str> . equals ( command ) ) { debugFrame ( args ) ; } else if ( <str> . equals ( command ) ) { debugGroups ( args ) ; } else if ( <str> . equals ( command ) ) { debugPopData ( args ) ; } else if ( <str> . equals ( command ) ) { debugPushData ( args ) ; } else if ( <str> . equals ( command ) ) { debugRegisters ( args ) ; } else if ( <str> . equals ( command ) ) { debugRestart ( args ) ; } else if ( <str> . equals ( command ) ) { debugResume ( args ) ; } else if ( <str> . equals ( command ) ) { debugSetBreakpoint ( args ) ; } else if ( <str> . equals ( command ) ) { debugSetData ( args ) ; } else if ( <str> . equals ( command ) ) { debugSetVariable ( args ) ; } else if ( <str> . equals ( command ) ) { debugStack ( args ) ; } else if ( <str> . equals ( command ) ) { debugStackDepth ( args ) ; } else if ( <str> . equals ( command ) ) { debugState ( args ) ; } else if ( <str> . equals ( command ) ) { debugStep ( args ) ; } else if ( <str> . equals ( command ) ) { debugStepReturn ( args ) ; } else if ( <str> . equals ( command ) ) { debugSuspend ( args ) ; } else if ( <str> . equals ( command ) ) { debugTerminate ( ) ; } else if ( <str> . equals ( command ) ) { debugThreads ( ) ; } else if ( <str> . equals ( command ) ) { debugVar ( args ) ; } else if ( <str> . equals ( command ) ) { debugVMResume ( ) ; } else if ( <str> . equals ( command ) ) { debugVMSuspend ( ) ; } else if ( <str> . equals ( command ) ) { debugWatch ( args ) ; } else { sendCommandResponse ( <str> ) ; } } void debugChildren ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } int sfnumber = args . getNextIntArg ( ) ; String var = args . getNextStringArg ( ) ; Frame frame = sfnumber > = thread . fFrames . size ( ) ? thread . fCurrentFrame : ( Frame ) thread . fFrames . get ( sfnumber ) ; String varDot = var + <str> ; List < String > children = new ArrayList < String > ( ) ; for ( Iterator < String > itr = frame . fLocalVariables . keySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { String localVar = itr . next ( ) ; if ( localVar . startsWith ( varDot ) & & localVar . indexOf ( <str> , varDot . length ( ) + <int> ) = = - <int> ) { children . add ( localVar ) ; } } StringBuffer result = new StringBuffer ( ) ; for ( Iterator < String > itr = children . iterator ( ) ; itr . hasNext ( ) ; ) { result . append ( itr . next ( ) ) ; result . append ( <str> ) ; } result . append ( <str> ) ; sendCommandResponse ( result . toString ( ) ) ; } void debugClearBreakpoint ( Args args ) { int line = args . getNextIntArg ( ) ; fBreakpoints . remove ( Integer . valueOf ( line ) ) ; sendCommandResponse ( <str> ) ; } private static Pattern fPackPattern = Pattern . compile ( <str> ) ; void debugData ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } StringBuffer result = new StringBuffer ( ) ; for ( Iterator < ? > itr = thread . fStack . iterator ( ) ; itr . hasNext ( ) ; ) { result . append ( itr . next ( ) ) ; result . append ( <str> ) ; } result . append ( <str> ) ; sendCommandResponse ( result . toString ( ) ) ; } void debugDropFrame ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } if ( ! thread . fFrames . isEmpty ( ) ) { thread . fCurrentFrame = thread . fFrames . remove ( thread . fFrames . size ( ) - <int> ) ; } thread . fCurrentFrame . fPC - - ; sendCommandResponse ( <str> ) ; if ( fSuspendVM ! = null ) { sendDebugEvent ( <str> , false ) ; sendDebugEvent ( <str> + thread . fID + <str> , false ) ; } else { sendDebugEvent ( <str> + thread . fID + <str> , false ) ; sendDebugEvent ( <str> + thread . fID + <str> , false ) ; } } void debugEval ( Args args ) { if ( fSuspendVM ! = null ) { sendCommandResponse ( <str> ) ; return ; } PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } if ( thread . fSuspend = = null ) { sendCommandResponse ( <str> ) ; return ; } StringTokenizer tokenizer = new StringTokenizer ( args . getNextStringArg ( ) , <str> ) ; tokenizer . countTokens ( ) ; int numEvalLines = tokenizer . countTokens ( ) ; thread . fThreadCode = new String [ fCode . length + numEvalLines + <int> ] ; System . arraycopy ( fCode , <int> , thread . fThreadCode , <int> , fCode . length ) ; for ( int i = <int> ; i < numEvalLines ; i + + ) { String line = tokenizer . nextToken ( ) ; StringBuffer lineBuf = new StringBuffer ( line . length ( ) ) ; Matcher matcher = fPackPattern . matcher ( line ) ; int lastMatchEnd = <int> ; while ( matcher . find ( ) ) { lineBuf . append ( line . substring ( lastMatchEnd , matcher . start ( ) ) ) ; String charCode = line . substring ( matcher . start ( ) + <int> , matcher . start ( ) + <int> ) ; try { lineBuf . append ( ( char ) Integer . parseInt ( charCode , <int> ) ) ; } catch ( NumberFormatException e ) { } lastMatchEnd = matcher . end ( ) ; } if ( lastMatchEnd < line . length ( ) ) { lineBuf . append ( line . substring ( lastMatchEnd ) ) ; } thread . fThreadCode [ fCode . length + i ] = lineBuf . toString ( ) ; } thread . fThreadCode [ fCode . length + numEvalLines ] = <str> ; thread . fThreadLabels = mapLabels ( fCode ) ; thread . fSavedPC = thread . fCurrentFrame . fPC ; thread . fCurrentFrame . fPC = fCode . length ; thread . fPerformingEval = true ; thread . fSuspend = null ; sendCommandResponse ( <str> ) ; sendDebugEvent ( <str> + thread . fID + <str> , false ) ; } void debugEventStop ( Args args ) { String event = args . getNextStringArg ( ) ; int stop = args . getNextIntArg ( ) ; fEventStops . put ( event , Boolean . valueOf ( stop > <int> ) ) ; sendCommandResponse ( <str> ) ; } void debugTerminate ( ) { sendCommandResponse ( <str> ) ; sendDebugEvent ( <str> , false ) ; System . exit ( <int> ) ; } void debugFrame ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } int sfnumber = args . getNextIntArg ( ) ; Frame frame = null ; if ( sfnumber > = thread . fFrames . size ( ) ) { frame = thread . fCurrentFrame ; } else { frame = thread . fFrames . get ( sfnumber ) ; } sendCommandResponse ( printFrame ( frame ) + <str> ) ; } void debugGroups ( Args args ) { TreeSet < String > groups = new TreeSet < String > ( ) ; for ( Iterator < Register > itr = fRegisters . values ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { Register reg = itr . next ( ) ; groups . add ( reg . fGroup ) ; } StringBuffer response = new StringBuffer ( ) ; for ( Iterator < String > itr = groups . iterator ( ) ; itr . hasNext ( ) ; ) { response . append ( itr . next ( ) ) ; response . append ( <str> ) ; } response . append ( <str> ) ; sendCommandResponse ( response . toString ( ) ) ; } void debugPopData ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } thread . fStack . pop ( ) ; sendCommandResponse ( <str> ) ; } void debugPushData ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } Object val = args . getNextIntOrStringArg ( ) ; thread . fStack . push ( val ) ; sendCommandResponse ( <str> ) ; } void debugRegisters ( Args args ) { String group = args . getNextStringArg ( ) ; StringBuffer response = new StringBuffer ( ) ; for ( Iterator < Register > itr = fRegisters . values ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { Register reg = itr . next ( ) ; if ( group . equals ( reg . fGroup ) ) { response . append ( reg . fName ) ; response . append ( <str> ) ; response . append ( reg . fIsWriteable ) ; for ( Iterator < BitField > itr2 = reg . fBitFields . values ( ) . iterator ( ) ; itr2 . hasNext ( ) ; ) { BitField bitField = itr2 . next ( ) ; response . append ( <str> ) ; response . append ( bitField . fName ) ; response . append ( <str> ) ; response . append ( bitField . fBitOffset ) ; response . append ( <str> ) ; response . append ( bitField . fBitCount ) ; response . append ( <str> ) ; for ( Iterator < Entry < String , Integer > > itr3 = bitField . fMnemonics . entrySet ( ) . iterator ( ) ; itr3 . hasNext ( ) ; ) { Entry < String , Integer > mnemonicEntry = itr3 . next ( ) ; response . append ( mnemonicEntry . getKey ( ) ) ; response . append ( <str> ) ; response . append ( mnemonicEntry . getValue ( ) ) ; response . append ( <str> ) ; } } response . append ( <str> ) ; } } response . append ( <str> ) ; sendCommandResponse ( response . toString ( ) ) ; } void debugRestart ( Args args ) { fSuspendVM = <str> ; for ( Iterator < Integer > itr = fThreads . keySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { Integer id = itr . next ( ) ; sendDebugEvent ( <str> + id , false ) ; } fThreads . clear ( ) ; int id = fNextThreadId + + ; fThreads . put ( Integer . valueOf ( id ) , new PDAThread ( id , <str> , <int> ) ) ; sendDebugEvent ( <str> + id , false ) ; fRegisters . clear ( ) ; sendCommandResponse ( <str> ) ; } void debugResume ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } if ( fSuspendVM ! = null ) { sendCommandResponse ( <str> ) ; return ; } if ( thread . fSuspend = = null ) { sendCommandResponse ( <str> ) ; return ; } thread . fSuspend = null ; sendDebugEvent ( <str> + thread . fID + <str> , false ) ; sendCommandResponse ( <str> ) ; } void debugSetBreakpoint ( Args args ) { int line = args . getNextIntArg ( ) ; int stopVM = args . getNextIntArg ( ) ; fBreakpoints . put ( Integer . valueOf ( line ) , Boolean . valueOf ( stopVM ! = <int> ) ) ; sendCommandResponse ( <str> ) ; } void debugSetData ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } int offset = args . getNextIntArg ( ) ; Object val = args . getNextIntOrStringArg ( ) ; if ( offset < thread . fStack . size ( ) ) { thread . fStack . set ( offset , val ) ; } else { thread . fStack . add ( <int> , val ) ; } sendCommandResponse ( <str> ) ; } void debugSetVariable ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } int sfnumber = args . getNextIntArg ( ) ; String var = args . getNextStringArg ( ) ; Object val = args . getNextIntOrStringArg ( ) ; while ( args . hasNextArg ( ) ) { val = val . toString ( ) + <str> + args . getNextStringArg ( ) ; } if ( sfnumber > = thread . fFrames . size ( ) ) { thread . fCurrentFrame . set ( var , val ) ; } else { thread . fFrames . get ( sfnumber ) . set ( var , val ) ; } sendCommandResponse ( <str> ) ; } void debugStack ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } StringBuffer result = new StringBuffer ( ) ; for ( Iterator < Frame > itr = thread . fFrames . iterator ( ) ; itr . hasNext ( ) ; ) { Frame frame = itr . next ( ) ; result . append ( printFrame ( frame ) ) ; result . append ( <str> ) ; } result . append ( printFrame ( thread . fCurrentFrame ) ) ; result . append ( <str> ) ; sendCommandResponse ( result . toString ( ) ) ; } void debugStackDepth ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } sendCommandResponse ( Integer . toString ( thread . fFrames . size ( ) + <int> ) + <str> ) ; } private String printFrame ( Frame frame ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( fFilename ) ; buf . append ( <str> ) ; buf . append ( frame . fPC ) ; buf . append ( <str> ) ; buf . append ( frame . fFunction ) ; for ( Iterator < String > itr = frame . fLocalVariables . keySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { String var = itr . next ( ) ; if ( var . indexOf ( <str> ) = = - <int> ) { buf . append ( <str> ) ; buf . append ( var ) ; } } return buf . toString ( ) ; } void debugState ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; String response = null ; if ( thread = = null ) { response = fSuspendVM = = null ? <str> : fSuspendVM ; } else if ( fSuspendVM ! = null ) { response = <str> ; } else { response = thread . fSuspend = = null ? <str> : thread . fSuspend ; } sendCommandResponse ( response + <str> ) ; } void debugStep ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } if ( fSuspendVM ! = null ) { fSuspendVM = null ; fStepVM = true ; thread . fStep = true ; } else { if ( thread . fSuspend = = null ) { sendCommandResponse ( <str> ) ; return ; } thread . fSuspend = null ; thread . fStep = true ; sendDebugEvent ( <str> + thread . fID + <str> , false ) ; } sendCommandResponse ( <str> ) ; } void debugStepReturn ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } if ( fSuspendVM ! = null ) { fSuspendVM = null ; fStepReturnVM = true ; thread . fStepReturn = true ; } else { if ( thread . fSuspend = = null ) { sendCommandResponse ( <str> ) ; return ; } thread . fSuspend = null ; thread . fStepReturn = true ; sendDebugEvent ( <str> + thread . fID + <str> , false ) ; } sendCommandResponse ( <str> ) ; } void debugSuspend ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } if ( fSuspendVM ! = null ) { sendCommandResponse ( <str> ) ; return ; } if ( thread . fSuspend ! = null ) { sendCommandResponse ( <str> ) ; return ; } thread . fSuspend = <str> ; sendDebugEvent ( <str> + thread . fID + <str> , false ) ; sendCommandResponse ( <str> ) ; } void debugThreads ( ) { StringBuffer response = new StringBuffer ( ) ; for ( Iterator < Integer > itr = fThreads . keySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { response . append ( itr . next ( ) ) ; response . append ( <str> ) ; } sendCommandResponse ( response . toString ( ) . trim ( ) + <str> ) ; } void debugVar ( Args args ) { PDAThread thread = args . getThreadArg ( ) ; if ( thread = = null ) { sendCommandResponse ( <str> ) ; return ; } int sfnumber = args . getNextIntArg ( ) ; String var = args . getNextStringArg ( ) ; Frame frame = sfnumber > = thread . fFrames . size ( ) ? thread . fCurrentFrame : ( Frame ) thread . fFrames . get ( sfnumber ) ; Object val = frame . get ( var ) ; if ( val = = null ) { sendCommandResponse ( <str> ) ; } else { sendCommandResponse ( val . toString ( ) + <str> ) ; } } void debugVMResume ( ) { if ( fSuspendVM = = null ) { sendCommandResponse ( <str> ) ; return ; } fSuspendVM = null ; sendCommandResponse ( <str> ) ; } void debugVMSuspend ( ) { if ( fSuspendVM ! = null ) { sendCommandResponse ( <str> ) ; return ; } fSuspendVM = <str> ; sendCommandResponse ( <str> ) ; } void debugWatch ( Args args ) { String funcAndVar = args . getNextStringArg ( ) ; int flags = args . getNextIntArg ( ) ; fWatchpoints . put ( funcAndVar , Integer . valueOf ( flags ) ) ; sendCommandResponse ( <str> ) ; } void iAdd ( PDAThread thread , Args args ) { Object val1 = thread . fStack . pop ( ) ; Object val2 = thread . fStack . pop ( ) ; if ( val1 instanceof Integer & & val2 instanceof Integer ) { int intVal1 = ( ( Integer ) val1 ) . intValue ( ) ; int intVal2 = ( ( Integer ) val2 ) . intValue ( ) ; thread . fStack . push ( Integer . valueOf ( intVal1 + intVal2 ) ) ; } else { thread . fStack . push ( Integer . valueOf ( - <int> ) ) ; } } void iBranchNotZero ( PDAThread thread , Args args ) { Object val = thread . fStack . pop ( ) ; if ( val instanceof Integer & & ( ( Integer ) val ) . intValue ( ) ! = <int> ) { String label = args . getNextStringArg ( ) ; if ( thread . fThreadLabels . containsKey ( label ) ) { thread . fCurrentFrame . fPC = thread . fThreadLabels . get ( label ) . intValue ( ) ; } else { sendDebugEvent ( <str> + label , true ) ; if ( fEventStops . get ( <str> ) . booleanValue ( ) ) { fSuspendVM = thread . fID + <str> ; thread . fStack . push ( val ) ; thread . fCurrentFrame . fPC - - ; } } } } void iCall ( PDAThread thread , Args args ) { String label = args . getNextStringArg ( ) ; if ( thread . fThreadLabels . containsKey ( label ) ) { thread . fFrames . add ( thread . fCurrentFrame ) ; thread . fCurrentFrame = new Frame ( label , thread . fThreadLabels . get ( label ) . intValue ( ) ) ; } else { sendDebugEvent ( <str> + label , true ) ; if ( fEventStops . get ( <str> ) . booleanValue ( ) ) { fSuspendVM = thread . fID + <str> ; thread . fCurrentFrame . fPC - - ; } } } void iDec ( PDAThread thread , Args args ) { Object val = thread . fStack . pop ( ) ; if ( val instanceof Integer ) { val = Integer . valueOf ( ( ( Integer ) val ) . intValue ( ) - <int> ) ; } thread . fStack . push ( val ) ; } void iDef ( PDAThread thread , Args args ) { String type = args . getNextStringArg ( ) ; String name = args . getNextStringArg ( ) ; String regName = getRegisterPartOfName ( name ) ; String bitFieldName = getBitFieldPartOfName ( name ) ; if ( <str> . equals ( type ) ) { Register reg = new Register ( regName ) ; reg . fGroup = args . getNextStringArg ( ) ; fRegisters . put ( regName , reg ) ; reg . fIsWriteable = args . getNextBooleanArg ( ) ; } else if ( <str> . equals ( type ) ) { Register reg = fRegisters . get ( regName ) ; if ( reg = = null ) { return ; } BitField bitField = new BitField ( bitFieldName ) ; bitField . fBitOffset = args . getNextIntArg ( ) ; bitField . fBitCount = args . getNextIntArg ( ) ; reg . fBitFields . put ( bitFieldName , bitField ) ; } else if ( <str> . equals ( type ) ) { Register reg = fRegisters . get ( regName ) ; if ( reg = = null ) { return ; } BitField bitField = reg . fBitFields . get ( bitFieldName ) ; if ( bitField = = null ) { return ; } bitField . fMnemonics . put ( args . getNextStringArg ( ) , Integer . valueOf ( args . getNextIntArg ( ) ) ) ; } sendDebugEvent ( <str> , false ) ; } private String getRegisterPartOfName ( String name ) { if ( name . startsWith ( <str> ) ) { int end = name . indexOf ( <str> ) ; end = end ! = - <int> ? end : name . length ( ) ; return name . substring ( <int> , end ) ; } return null ; } private String getBitFieldPartOfName ( String name ) { int start = name . indexOf ( <str> ) ; if ( name . startsWith ( <str> ) & & start ! = - <int> ) { return name . substring ( start + <int> , name . length ( ) ) ; } return null ; } void iDup ( PDAThread thread , Args args ) { Object val = thread . fStack . pop ( ) ; thread . fStack . push ( val ) ; thread . fStack . push ( val ) ; } void iExec ( PDAThread thread , Args args ) { String label = args . getNextStringArg ( ) ; if ( fLabels . containsKey ( label ) ) { int id = fNextThreadId + + ; fThreads . put ( Integer . valueOf ( id ) , new PDAThread ( id , label , fLabels . get ( label ) . intValue ( ) ) ) ; sendDebugEvent ( <str> + id , false ) ; } else { sendDebugEvent ( <str> + label , true ) ; if ( fEventStops . get ( <str> ) . booleanValue ( ) ) { thread . fSuspend = <str> ; thread . fCurrentFrame . fPC - - ; } } } void iHalt ( PDAThread thread , Args args ) { thread . fRun = false ; } void iOutput ( PDAThread thread , Args args ) { System . out . println ( thread . fStack . pop ( ) ) ; } void iPop ( PDAThread thread , Args args ) { String arg = args . getNextStringArg ( ) ; if ( arg . startsWith ( <str> ) ) { String var = arg . substring ( <int> ) ; thread . fCurrentFrame . set ( var , thread . fStack . pop ( ) ) ; String key = thread . fCurrentFrame . fFunction + <str> + var ; if ( fWatchpoints . containsKey ( key ) & & ( fWatchpoints . get ( key ) . intValue ( ) & <int> ) ! = <int> ) { fSuspendVM = thread . fID + <str> + key ; } } else { thread . fStack . pop ( ) ; } } void iPush ( PDAThread thread , Args args ) { String arg = args . getNextStringArg ( ) ; while ( arg . length ( ) ! = <int> ) { if ( arg . startsWith ( <str> ) ) { String var = arg . substring ( <int> ) ; Object val = thread . fCurrentFrame . get ( var ) ; if ( val = = null ) { val = <str> ; } thread . fStack . push ( val ) ; String key = thread . fCurrentFrame . fFunction + <str> + var ; if ( fWatchpoints . containsKey ( key ) & & ( fWatchpoints . get ( key ) . intValue ( ) & <int> ) ! = <int> ) { fSuspendVM = thread . fID + <str> + key ; } } else { Object val = arg ; if ( args . hasNextArg ( ) ) { while ( args . hasNextArg ( ) ) { val = val . toString ( ) + <str> + args . getNextStringArg ( ) ; } } else { try { val = Integer . valueOf ( arg ) ; } catch ( NumberFormatException e ) { } } thread . fStack . push ( val ) ; } arg = args . getNextStringArg ( ) ; } } void iReturn ( PDAThread thread , Args args ) { if ( ! thread . fFrames . isEmpty ( ) ) { thread . fCurrentFrame = thread . fFrames . remove ( thread . fFrames . size ( ) - <int> ) ; } else { thread . fRun = false ; } } void iVar ( PDAThread thread , Args args ) { String var = args . getNextStringArg ( ) ; thread . fCurrentFrame . set ( var , Integer . valueOf ( <int> ) ) ; } void iInternalEndEval ( PDAThread thread , Args args ) { Object result = thread . fStack . pop ( ) ; thread . fThreadCode = fCode ; thread . fThreadLabels = fLabels ; thread . fCurrentFrame . fPC = thread . fSavedPC ; sendDebugEvent ( <str> + result , false ) ; thread . fSuspend = <str> ; thread . fPerformingEval = false ; } } 
