package org . elasticsearch . discovery . zen . publish ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . compress . Compressor ; import org . elasticsearch . common . compress . CompressorFactory ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . AckClusterStatePublishResponseHandler ; import org . elasticsearch . discovery . BlockingClusterStatePublishResponseHandler ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . discovery . zen . DiscoveryNodesProvider ; import org . elasticsearch . discovery . zen . ZenDiscovery ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . io . IOException ; import java . util . * ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicBoolean ; public class PublishClusterStateAction extends AbstractComponent { public static final String SEND_ACTION_NAME = <str> ; public static final String COMMIT_ACTION_NAME = <str> ; public static final String SETTINGS_MAX_PENDING_CLUSTER_STATES = <str> ; public interface NewPendingClusterStateListener { void onNewClusterState ( String reason ) ; } private final TransportService transportService ; private final DiscoveryNodesProvider nodesProvider ; private final NewPendingClusterStateListener newPendingClusterStatelistener ; private final DiscoverySettings discoverySettings ; private final ClusterName clusterName ; private final PendingClusterStatesQueue pendingStatesQueue ; public PublishClusterStateAction ( Settings settings , TransportService transportService , DiscoveryNodesProvider nodesProvider , NewPendingClusterStateListener listener , DiscoverySettings discoverySettings , ClusterName clusterName ) { super ( settings ) ; this . transportService = transportService ; this . nodesProvider = nodesProvider ; this . newPendingClusterStatelistener = listener ; this . discoverySettings = discoverySettings ; this . clusterName = clusterName ; this . pendingStatesQueue = new PendingClusterStatesQueue ( logger , settings . getAsInt ( SETTINGS_MAX_PENDING_CLUSTER_STATES , <int> ) ) ; transportService . registerRequestHandler ( SEND_ACTION_NAME , BytesTransportRequest : : new , ThreadPool . Names . SAME , new SendClusterStateRequestHandler ( ) ) ; transportService . registerRequestHandler ( COMMIT_ACTION_NAME , CommitClusterStateRequest : : new , ThreadPool . Names . SAME , new CommitClusterStateRequestHandler ( ) ) ; } public void close ( ) { transportService . removeHandler ( SEND_ACTION_NAME ) ; transportService . removeHandler ( COMMIT_ACTION_NAME ) ; } public PendingClusterStatesQueue pendingStatesQueue ( ) { return pendingStatesQueue ; } public void publish ( final ClusterChangedEvent clusterChangedEvent , final int minMasterNodes , final Discovery . AckListener ackListener ) throws Discovery . FailedToCommitClusterStateException { final DiscoveryNodes nodes ; final SendingController sendingController ; final Set < DiscoveryNode > nodesToPublishTo ; final Map < Version , BytesReference > serializedStates ; final Map < Version , BytesReference > serializedDiffs ; final boolean sendFullVersion ; try { nodes = clusterChangedEvent . state ( ) . nodes ( ) ; nodesToPublishTo = new HashSet < > ( nodes . size ( ) ) ; DiscoveryNode localNode = nodes . localNode ( ) ; final int totalMasterNodes = nodes . masterNodes ( ) . size ( ) ; for ( final DiscoveryNode node : nodes ) { if ( node . equals ( localNode ) = = false ) { nodesToPublishTo . add ( node ) ; } } sendFullVersion = ! discoverySettings . getPublishDiff ( ) | | clusterChangedEvent . previousState ( ) = = null ; serializedStates = new HashMap < > ( ) ; serializedDiffs = new HashMap < > ( ) ; buildDiffAndSerializeStates ( clusterChangedEvent . state ( ) , clusterChangedEvent . previousState ( ) , nodesToPublishTo , sendFullVersion , serializedStates , serializedDiffs ) ; final BlockingClusterStatePublishResponseHandler publishResponseHandler = new AckClusterStatePublishResponseHandler ( nodesToPublishTo , ackListener ) ; sendingController = new SendingController ( clusterChangedEvent . state ( ) , minMasterNodes , totalMasterNodes , publishResponseHandler ) ; } catch ( Throwable t ) { throw new Discovery . FailedToCommitClusterStateException ( <str> , t ) ; } try { innerPublish ( clusterChangedEvent , nodesToPublishTo , sendingController , sendFullVersion , serializedStates , serializedDiffs ) ; } catch ( Discovery . FailedToCommitClusterStateException t ) { throw t ; } catch ( Throwable t ) { if ( sendingController . markAsFailed ( <str> , t ) ) { throw new Discovery . FailedToCommitClusterStateException ( <str> , t ) ; } else { throw t ; } } } private void innerPublish ( final ClusterChangedEvent clusterChangedEvent , final Set < DiscoveryNode > nodesToPublishTo , final SendingController sendingController , final boolean sendFullVersion , final Map < Version , BytesReference > serializedStates , final Map < Version , BytesReference > serializedDiffs ) { final ClusterState clusterState = clusterChangedEvent . state ( ) ; final ClusterState previousState = clusterChangedEvent . previousState ( ) ; final TimeValue publishTimeout = discoverySettings . getPublishTimeout ( ) ; final long publishingStartInNanos = System . nanoTime ( ) ; for ( final DiscoveryNode node : nodesToPublishTo ) { if ( sendFullVersion | | ! previousState . nodes ( ) . nodeExists ( node . id ( ) ) ) { sendFullClusterState ( clusterState , serializedStates , node , publishTimeout , sendingController ) ; } else { sendClusterStateDiff ( clusterState , serializedDiffs , serializedStates , node , publishTimeout , sendingController ) ; } } sendingController . waitForCommit ( discoverySettings . getCommitTimeout ( ) ) ; try { long timeLeftInNanos = Math . max ( <int> , publishTimeout . nanos ( ) - ( System . nanoTime ( ) - publishingStartInNanos ) ) ; final BlockingClusterStatePublishResponseHandler publishResponseHandler = sendingController . getPublishResponseHandler ( ) ; sendingController . setPublishingTimedOut ( ! publishResponseHandler . awaitAllNodes ( TimeValue . timeValueNanos ( timeLeftInNanos ) ) ) ; if ( sendingController . getPublishingTimedOut ( ) ) { DiscoveryNode [ ] pendingNodes = publishResponseHandler . pendingNodes ( ) ; if ( pendingNodes . length > <int> ) { logger . warn ( <str> , clusterState . version ( ) , publishTimeout , pendingNodes ) ; } } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } } private void buildDiffAndSerializeStates ( ClusterState clusterState , ClusterState previousState , Set < DiscoveryNode > nodesToPublishTo , boolean sendFullVersion , Map < Version , BytesReference > serializedStates , Map < Version , BytesReference > serializedDiffs ) { Diff < ClusterState > diff = null ; for ( final DiscoveryNode node : nodesToPublishTo ) { try { if ( sendFullVersion | | ! previousState . nodes ( ) . nodeExists ( node . id ( ) ) ) { if ( serializedStates . containsKey ( node . version ( ) ) = = false ) { serializedStates . put ( node . version ( ) , serializeFullClusterState ( clusterState , node . version ( ) ) ) ; } } else { if ( diff = = null ) { diff = clusterState . diff ( previousState ) ; } if ( serializedDiffs . containsKey ( node . version ( ) ) = = false ) { serializedDiffs . put ( node . version ( ) , serializeDiffClusterState ( diff , node . version ( ) ) ) ; } } } catch ( IOException e ) { throw new ElasticsearchException ( <str> , e , node ) ; } } } private void sendFullClusterState ( ClusterState clusterState , Map < Version , BytesReference > serializedStates , DiscoveryNode node , TimeValue publishTimeout , SendingController sendingController ) { BytesReference bytes = serializedStates . get ( node . version ( ) ) ; if ( bytes = = null ) { try { bytes = serializeFullClusterState ( clusterState , node . version ( ) ) ; serializedStates . put ( node . version ( ) , bytes ) ; } catch ( Throwable e ) { logger . warn ( <str> , e , node ) ; sendingController . onNodeSendFailed ( node , e ) ; return ; } } sendClusterStateToNode ( clusterState , bytes , node , publishTimeout , sendingController , false , serializedStates ) ; } private void sendClusterStateDiff ( ClusterState clusterState , Map < Version , BytesReference > serializedDiffs , Map < Version , BytesReference > serializedStates , DiscoveryNode node , TimeValue publishTimeout , SendingController sendingController ) { BytesReference bytes = serializedDiffs . get ( node . version ( ) ) ; assert bytes ! = null : <str> + node + <str> + node . version ( ) + <str> ; sendClusterStateToNode ( clusterState , bytes , node , publishTimeout , sendingController , true , serializedStates ) ; } private void sendClusterStateToNode ( final ClusterState clusterState , BytesReference bytes , final DiscoveryNode node , final TimeValue publishTimeout , final SendingController sendingController , final boolean sendDiffs , final Map < Version , BytesReference > serializedStates ) { try { TransportRequestOptions options = TransportRequestOptions . builder ( ) . withType ( TransportRequestOptions . Type . STATE ) . withCompress ( false ) . build ( ) ; transportService . sendRequest ( node , SEND_ACTION_NAME , new BytesTransportRequest ( bytes , node . version ( ) ) , options , new EmptyTransportResponseHandler ( ThreadPool . Names . SAME ) { @Override public void handleResponse ( TransportResponse . Empty response ) { if ( sendingController . getPublishingTimedOut ( ) ) { logger . debug ( <str> , node , clusterState . version ( ) , publishTimeout ) ; } sendingController . onNodeSendAck ( node ) ; } @Override public void handleException ( TransportException exp ) { if ( sendDiffs & & exp . unwrapCause ( ) instanceof IncompatibleClusterStateVersionException ) { logger . debug ( <str> , node , exp . getDetailedMessage ( ) ) ; sendFullClusterState ( clusterState , serializedStates , node , publishTimeout , sendingController ) ; } else { logger . debug ( <str> , exp , node ) ; sendingController . onNodeSendFailed ( node , exp ) ; } } } ) ; } catch ( Throwable t ) { logger . warn ( <str> , t , node ) ; sendingController . onNodeSendFailed ( node , t ) ; } } private void sendCommitToNode ( final DiscoveryNode node , final ClusterState clusterState , final SendingController sendingController ) { try { logger . trace ( <str> , clusterState . stateUUID ( ) , clusterState . version ( ) , node ) ; TransportRequestOptions options = TransportRequestOptions . builder ( ) . withType ( TransportRequestOptions . Type . STATE ) . build ( ) ; transportService . sendRequest ( node , COMMIT_ACTION_NAME , new CommitClusterStateRequest ( clusterState . stateUUID ( ) ) , options , new EmptyTransportResponseHandler ( ThreadPool . Names . SAME ) { @Override public void handleResponse ( TransportResponse . Empty response ) { if ( sendingController . getPublishingTimedOut ( ) ) { logger . debug ( <str> , node , clusterState . version ( ) ) ; } sendingController . getPublishResponseHandler ( ) . onResponse ( node ) ; } @Override public void handleException ( TransportException exp ) { logger . debug ( <str> , exp , clusterState . stateUUID ( ) , clusterState . version ( ) , node ) ; sendingController . getPublishResponseHandler ( ) . onFailure ( node , exp ) ; } } ) ; } catch ( Throwable t ) { logger . warn ( <str> , t , clusterState . stateUUID ( ) , clusterState . version ( ) , node ) ; sendingController . getPublishResponseHandler ( ) . onFailure ( node , t ) ; } } public static BytesReference serializeFullClusterState ( ClusterState clusterState , Version nodeVersion ) throws IOException { BytesStreamOutput bStream = new BytesStreamOutput ( ) ; try ( StreamOutput stream = CompressorFactory . defaultCompressor ( ) . streamOutput ( bStream ) ) { stream . setVersion ( nodeVersion ) ; stream . writeBoolean ( true ) ; clusterState . writeTo ( stream ) ; } return bStream . bytes ( ) ; } public static BytesReference serializeDiffClusterState ( Diff diff , Version nodeVersion ) throws IOException { BytesStreamOutput bStream = new BytesStreamOutput ( ) ; try ( StreamOutput stream = CompressorFactory . defaultCompressor ( ) . streamOutput ( bStream ) ) { stream . setVersion ( nodeVersion ) ; stream . writeBoolean ( false ) ; diff . writeTo ( stream ) ; } return bStream . bytes ( ) ; } private Object lastSeenClusterStateMutex = new Object ( ) ; private ClusterState lastSeenClusterState ; protected void handleIncomingClusterStateRequest ( BytesTransportRequest request , TransportChannel channel ) throws IOException { Compressor compressor = CompressorFactory . compressor ( request . bytes ( ) ) ; StreamInput in ; if ( compressor ! = null ) { in = compressor . streamInput ( request . bytes ( ) . streamInput ( ) ) ; } else { in = request . bytes ( ) . streamInput ( ) ; } in . setVersion ( request . version ( ) ) ; synchronized ( lastSeenClusterStateMutex ) { final ClusterState incomingState ; if ( in . readBoolean ( ) ) { incomingState = ClusterState . Builder . readFrom ( in , nodesProvider . nodes ( ) . localNode ( ) ) ; logger . debug ( <str> , incomingState . version ( ) , request . bytes ( ) . length ( ) ) ; } else if ( lastSeenClusterState ! = null ) { Diff < ClusterState > diff = lastSeenClusterState . readDiffFrom ( in ) ; incomingState = diff . apply ( lastSeenClusterState ) ; logger . debug ( <str> , incomingState . version ( ) , incomingState . stateUUID ( ) , request . bytes ( ) . length ( ) ) ; } else { logger . debug ( <str> ) ; throw new IncompatibleClusterStateVersionException ( <str> ) ; } validateIncomingState ( incomingState , lastSeenClusterState ) ; pendingStatesQueue . addPending ( incomingState ) ; lastSeenClusterState = incomingState ; lastSeenClusterState . status ( ClusterState . ClusterStateStatus . RECEIVED ) ; } channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } void validateIncomingState ( ClusterState incomingState , ClusterState lastSeenClusterState ) { final ClusterName incomingClusterName = incomingState . getClusterName ( ) ; if ( ! incomingClusterName . equals ( this . clusterName ) ) { logger . warn ( <str> , incomingState . nodes ( ) . masterNode ( ) , incomingClusterName ) ; throw new IllegalStateException ( <str> ) ; } final DiscoveryNodes currentNodes = nodesProvider . nodes ( ) ; if ( currentNodes . localNode ( ) . equals ( incomingState . nodes ( ) . localNode ( ) ) = = false ) { logger . warn ( <str> , incomingState . nodes ( ) . masterNode ( ) ) ; throw new IllegalStateException ( <str> ) ; } ZenDiscovery . validateStateIsFromCurrentMaster ( logger , currentNodes , incomingState ) ; } protected void handleCommitRequest ( CommitClusterStateRequest request , final TransportChannel channel ) { final ClusterState state = pendingStatesQueue . markAsCommitted ( request . stateUUID , new PendingClusterStatesQueue . StateProcessedListener ( ) { @Override public void onNewClusterStateProcessed ( ) { try { channel . sendResponse ( TransportResponse . Empty . INSTANCE ) ; } catch ( Throwable e ) { logger . debug ( <str> , e ) ; onNewClusterStateFailed ( e ) ; } } @Override public void onNewClusterStateFailed ( Throwable t ) { try { channel . sendResponse ( t ) ; } catch ( Throwable e ) { logger . debug ( <str> , e ) ; } } } ) ; if ( state ! = null ) { newPendingClusterStatelistener . onNewClusterState ( <str> + state . nodes ( ) . masterNode ( ) + <str> + state . version ( ) + <str> ) ; } } private class SendClusterStateRequestHandler implements TransportRequestHandler < BytesTransportRequest > { @Override public void messageReceived ( BytesTransportRequest request , final TransportChannel channel ) throws Exception { handleIncomingClusterStateRequest ( request , channel ) ; } } private class CommitClusterStateRequestHandler implements TransportRequestHandler < CommitClusterStateRequest > { @Override public void messageReceived ( CommitClusterStateRequest request , final TransportChannel channel ) throws Exception { handleCommitRequest ( request , channel ) ; } } protected static class CommitClusterStateRequest extends TransportRequest { String stateUUID ; public CommitClusterStateRequest ( ) { } public CommitClusterStateRequest ( String stateUUID ) { this . stateUUID = stateUUID ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; stateUUID = in . readString ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeString ( stateUUID ) ; } } class SendingController { private final ClusterState clusterState ; public BlockingClusterStatePublishResponseHandler getPublishResponseHandler ( ) { return publishResponseHandler ; } private final BlockingClusterStatePublishResponseHandler publishResponseHandler ; final ArrayList < DiscoveryNode > sendAckedBeforeCommit = new ArrayList < > ( ) ; final CountDownLatch committedOrFailedLatch ; boolean committed ; int neededMastersToCommit ; int pendingMasterNodes ; final AtomicBoolean publishingTimedOut = new AtomicBoolean ( ) ; private SendingController ( ClusterState clusterState , int minMasterNodes , int totalMasterNodes , BlockingClusterStatePublishResponseHandler publishResponseHandler ) { this . clusterState = clusterState ; this . publishResponseHandler = publishResponseHandler ; this . neededMastersToCommit = Math . max ( <int> , minMasterNodes - <int> ) ; this . pendingMasterNodes = totalMasterNodes - <int> ; if ( this . neededMastersToCommit > this . pendingMasterNodes ) { throw new Discovery . FailedToCommitClusterStateException ( <str> , neededMastersToCommit , pendingMasterNodes ) ; } this . committed = neededMastersToCommit = = <int> ; this . committedOrFailedLatch = new CountDownLatch ( committed ? <int> : <int> ) ; } public void waitForCommit ( TimeValue commitTimeout ) { boolean timedout = false ; try { timedout = committedOrFailedLatch . await ( commitTimeout . millis ( ) , TimeUnit . MILLISECONDS ) = = false ; } catch ( InterruptedException e ) { } if ( timedout ) { markAsFailed ( <str> + commitTimeout + <str> ) ; } if ( isCommitted ( ) = = false ) { throw new Discovery . FailedToCommitClusterStateException ( <str> , timedout ? <str> : <str> , neededMastersToCommit ) ; } } synchronized public boolean isCommitted ( ) { return committed ; } synchronized public void onNodeSendAck ( DiscoveryNode node ) { if ( committed ) { assert sendAckedBeforeCommit . isEmpty ( ) ; sendCommitToNode ( node , clusterState , this ) ; } else if ( committedOrFailed ( ) ) { logger . trace ( <str> , node , clusterState . version ( ) ) ; } else { sendAckedBeforeCommit . add ( node ) ; if ( node . isMasterNode ( ) ) { checkForCommitOrFailIfNoPending ( node ) ; } } } private synchronized boolean committedOrFailed ( ) { return committedOrFailedLatch . getCount ( ) = = <int> ; } synchronized private void checkForCommitOrFailIfNoPending ( DiscoveryNode masterNode ) { logger . trace ( <str> , masterNode , clusterState . version ( ) , pendingMasterNodes , neededMastersToCommit ) ; neededMastersToCommit - - ; if ( neededMastersToCommit = = <int> ) { if ( markAsCommitted ( ) ) { for ( DiscoveryNode nodeToCommit : sendAckedBeforeCommit ) { sendCommitToNode ( nodeToCommit , clusterState , this ) ; } sendAckedBeforeCommit . clear ( ) ; } } decrementPendingMasterAcksAndChangeForFailure ( ) ; } synchronized private void decrementPendingMasterAcksAndChangeForFailure ( ) { pendingMasterNodes - - ; if ( pendingMasterNodes = = <int> & & neededMastersToCommit > <int> ) { markAsFailed ( <str> + neededMastersToCommit + <str> ) ; } } synchronized public void onNodeSendFailed ( DiscoveryNode node , Throwable t ) { if ( node . isMasterNode ( ) ) { logger . trace ( <str> , node , clusterState . version ( ) , pendingMasterNodes , neededMastersToCommit ) ; decrementPendingMasterAcksAndChangeForFailure ( ) ; } publishResponseHandler . onFailure ( node , t ) ; } synchronized private boolean markAsCommitted ( ) { if ( committedOrFailed ( ) ) { return committed ; } logger . trace ( <str> , clusterState . version ( ) ) ; committed = true ; committedOrFailedLatch . countDown ( ) ; return true ; } synchronized private boolean markAsFailed ( String details , Throwable reason ) { if ( committedOrFailed ( ) ) { return committed = = false ; } logger . trace ( <str> , reason , clusterState . version ( ) , details ) ; committed = false ; committedOrFailedLatch . countDown ( ) ; return true ; } synchronized private boolean markAsFailed ( String reason ) { if ( committedOrFailed ( ) ) { return committed = = false ; } logger . trace ( <str> , clusterState . version ( ) , reason ) ; committed = false ; committedOrFailedLatch . countDown ( ) ; return true ; } public boolean getPublishingTimedOut ( ) { return publishingTimedOut . get ( ) ; } public void setPublishingTimedOut ( boolean isTimedOut ) { publishingTimedOut . set ( isTimedOut ) ; } } } 
