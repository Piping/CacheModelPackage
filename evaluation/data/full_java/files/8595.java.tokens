package org . elasticsearch . script . expression ; import org . apache . lucene . expressions . Expression ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . ExecutableScript ; import org . elasticsearch . script . ScriptException ; import java . util . HashMap ; import java . util . Map ; public class ExpressionExecutableScript implements ExecutableScript { private final int NO_DOCUMENT = - <int> ; public final CompiledScript compiledScript ; public final Map < String , ReplaceableConstFunctionValues > functionValuesMap ; public final ReplaceableConstFunctionValues [ ] functionValuesArray ; public ExpressionExecutableScript ( CompiledScript compiledScript , Map < String , Object > vars ) { this . compiledScript = compiledScript ; Expression expression = ( Expression ) this . compiledScript . compiled ( ) ; int functionValuesLength = expression . variables . length ; if ( vars . size ( ) ! = functionValuesLength ) { throw new ScriptException ( <str> + compiledScript + <str> + <str> + functionValuesLength + <str> + <str> + vars . size ( ) + <str> ) ; } functionValuesArray = new ReplaceableConstFunctionValues [ functionValuesLength ] ; functionValuesMap = new HashMap < > ( ) ; for ( int functionValuesIndex = <int> ; functionValuesIndex < functionValuesLength ; + + functionValuesIndex ) { String variableName = expression . variables [ functionValuesIndex ] ; functionValuesArray [ functionValuesIndex ] = new ReplaceableConstFunctionValues ( ) ; functionValuesMap . put ( variableName , functionValuesArray [ functionValuesIndex ] ) ; } for ( String varsName : vars . keySet ( ) ) { setNextVar ( varsName , vars . get ( varsName ) ) ; } } @Override public void setNextVar ( String name , Object value ) { if ( functionValuesMap . containsKey ( name ) ) { if ( value instanceof Number ) { double doubleValue = ( ( Number ) value ) . doubleValue ( ) ; functionValuesMap . get ( name ) . setValue ( doubleValue ) ; } else { throw new ScriptException ( <str> + compiledScript + <str> + <str> + <str> + name + <str> ) ; } } else { throw new ScriptException ( <str> + compiledScript + <str> + <str> + name + <str> ) ; } } @Override public Object run ( ) { try { return ( ( Expression ) compiledScript . compiled ( ) ) . evaluate ( NO_DOCUMENT , functionValuesArray ) ; } catch ( Exception exception ) { throw new ScriptException ( <str> + compiledScript , exception ) ; } } @Override public Object unwrap ( Object value ) { return value ; } } 
