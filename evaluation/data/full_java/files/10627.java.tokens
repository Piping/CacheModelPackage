package com . google . common . util . concurrent ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . collect . Iterables ; import com . google . common . collect . Range ; import com . google . common . collect . Sets ; import junit . framework . AssertionFailedError ; import junit . framework . TestCase ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Set ; import java . util . concurrent . Callable ; import java . util . concurrent . CancellationException ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . CyclicBarrier ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import java . util . concurrent . locks . LockSupport ; public class AbstractFutureTest extends TestCase { public void testSuccess ( ) throws ExecutionException , InterruptedException { final Object value = new Object ( ) ; assertSame ( value , new AbstractFuture < Object > ( ) { { set ( value ) ; } } . get ( ) ) ; } public void testException ( ) throws InterruptedException { final Throwable failure = new Throwable ( ) ; AbstractFuture < String > future = new AbstractFuture < String > ( ) { { setException ( failure ) ; } } ; ExecutionException ee1 = getExpectingExecutionException ( future ) ; ExecutionException ee2 = getExpectingExecutionException ( future ) ; assertNotSame ( ee1 , ee2 ) ; assertSame ( failure , ee1 . getCause ( ) ) ; assertSame ( failure , ee2 . getCause ( ) ) ; checkStackTrace ( ee1 ) ; checkStackTrace ( ee2 ) ; } public void testCancel_notDoneNoInterrupt ( ) throws Exception { InterruptibleFuture future = new InterruptibleFuture ( ) ; assertTrue ( future . cancel ( false ) ) ; assertTrue ( future . isCancelled ( ) ) ; assertTrue ( future . isDone ( ) ) ; assertFalse ( future . wasInterrupted ( ) ) ; assertFalse ( future . interruptTaskWasCalled ) ; try { future . get ( ) ; fail ( <str> ) ; } catch ( CancellationException e ) { assertNull ( e . getCause ( ) ) ; } } public void testCancel_notDoneInterrupt ( ) throws Exception { InterruptibleFuture future = new InterruptibleFuture ( ) ; assertTrue ( future . cancel ( true ) ) ; assertTrue ( future . isCancelled ( ) ) ; assertTrue ( future . isDone ( ) ) ; assertTrue ( future . wasInterrupted ( ) ) ; assertTrue ( future . interruptTaskWasCalled ) ; try { future . get ( ) ; fail ( <str> ) ; } catch ( CancellationException e ) { assertNull ( e . getCause ( ) ) ; } } public void testCancel_done ( ) throws Exception { AbstractFuture < String > future = new AbstractFuture < String > ( ) { { set ( <str> ) ; } } ; assertFalse ( future . cancel ( true ) ) ; assertFalse ( future . isCancelled ( ) ) ; assertTrue ( future . isDone ( ) ) ; } public void testGetWithTimeoutDoneFuture ( ) throws Exception { AbstractFuture < String > future = new AbstractFuture < String > ( ) { { set ( <str> ) ; } } ; assertEquals ( <str> , future . get ( <int> , TimeUnit . SECONDS ) ) ; } public void testEvilFuture_setFuture ( ) throws Exception { final RuntimeException exception = new RuntimeException ( <str> ) ; AbstractFuture < String > evilFuture = new AbstractFuture < String > ( ) { @Override public void addListener ( Runnable r , Executor e ) { throw exception ; } } ; AbstractFuture < String > normalFuture = new AbstractFuture < String > ( ) { } ; normalFuture . setFuture ( evilFuture ) ; assertTrue ( normalFuture . isDone ( ) ) ; try { normalFuture . get ( ) ; fail ( ) ; } catch ( ExecutionException e ) { assertSame ( exception , e . getCause ( ) ) ; } } public void testRemoveWaiter_interruption ( ) throws Exception { final AbstractFuture < String > future = new AbstractFuture < String > ( ) { } ; WaiterThread waiter1 = new WaiterThread ( future ) ; waiter1 . start ( ) ; waiter1 . awaitWaiting ( ) ; WaiterThread waiter2 = new WaiterThread ( future ) ; waiter2 . start ( ) ; waiter2 . awaitWaiting ( ) ; waiter1 . interrupt ( ) ; waiter1 . join ( ) ; waiter2 . awaitWaiting ( ) ; LockSupport . unpark ( waiter2 ) ; waiter2 . awaitWaiting ( ) ; future . set ( null ) ; waiter2 . join ( ) ; } public void testRemoveWaiter_polling ( ) throws Exception { final AbstractFuture < String > future = new AbstractFuture < String > ( ) { } ; WaiterThread waiter = new WaiterThread ( future ) ; waiter . start ( ) ; waiter . awaitWaiting ( ) ; PollingThread poller = new PollingThread ( future ) ; poller . start ( ) ; PollingThread poller2 = new PollingThread ( future ) ; poller2 . start ( ) ; PollingThread poller3 = new PollingThread ( future ) ; poller3 . start ( ) ; poller . awaitInLoop ( ) ; poller2 . awaitInLoop ( ) ; poller3 . awaitInLoop ( ) ; waiter . interrupt ( ) ; waiter . join ( ) ; future . set ( null ) ; poller . join ( ) ; } public void testCompletionFinishesWithDone ( ) { ExecutorService executor = Executors . newFixedThreadPool ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { final AbstractFuture < String > future = new AbstractFuture < String > ( ) { } ; final AtomicReference < String > errorMessage = Atomics . newReference ( ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { future . set ( <str> ) ; if ( ! future . isDone ( ) ) { errorMessage . set ( <str> ) ; } } } ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { future . setException ( new IllegalArgumentException ( <str> ) ) ; if ( ! future . isDone ( ) ) { errorMessage . set ( <str> ) ; } } } ) ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { future . cancel ( true ) ; if ( ! future . isDone ( ) ) { errorMessage . set ( <str> ) ; } } } ) ; try { future . get ( ) ; } catch ( Throwable t ) { } String error = errorMessage . get ( ) ; assertNull ( error , error ) ; } executor . shutdown ( ) ; } public void testFutureBash ( ) { final CyclicBarrier barrier = new CyclicBarrier ( <int> + <int> + <int> + <int> ) ; final ExecutorService executor = Executors . newFixedThreadPool ( barrier . getParties ( ) ) ; final AtomicReference < AbstractFuture < String > > currentFuture = Atomics . newReference ( ) ; final AtomicInteger numSuccessfulSetCalls = new AtomicInteger ( ) ; Callable < Void > completeSucessFullyRunnable = new Callable < Void > ( ) { @Override public Void call ( ) { if ( currentFuture . get ( ) . set ( <str> ) ) { numSuccessfulSetCalls . incrementAndGet ( ) ; } awaitUnchecked ( barrier ) ; return null ; } } ; Callable < Void > completeExceptionallyRunnable = new Callable < Void > ( ) { Exception failureCause = new Exception ( <str> ) ; @Override public Void call ( ) { if ( currentFuture . get ( ) . setException ( failureCause ) ) { numSuccessfulSetCalls . incrementAndGet ( ) ; } awaitUnchecked ( barrier ) ; return null ; } } ; Callable < Void > cancelRunnable = new Callable < Void > ( ) { @Override public Void call ( ) { if ( currentFuture . get ( ) . cancel ( true ) ) { numSuccessfulSetCalls . incrementAndGet ( ) ; } awaitUnchecked ( barrier ) ; return null ; } } ; Callable < Void > setFutureCompleteSucessFullyRunnable = new Callable < Void > ( ) { ListenableFuture < String > future = Futures . immediateFuture ( <str> ) ; @Override public Void call ( ) { if ( currentFuture . get ( ) . setFuture ( future ) ) { numSuccessfulSetCalls . incrementAndGet ( ) ; } awaitUnchecked ( barrier ) ; return null ; } } ; Callable < Void > setFutureCompleteExceptionallyRunnable = new Callable < Void > ( ) { ListenableFuture < String > future = Futures . immediateFailedFuture ( new Exception ( <str> ) ) ; @Override public Void call ( ) { if ( currentFuture . get ( ) . setFuture ( future ) ) { numSuccessfulSetCalls . incrementAndGet ( ) ; } awaitUnchecked ( barrier ) ; return null ; } } ; Callable < Void > setFutureCancelRunnable = new Callable < Void > ( ) { ListenableFuture < String > future = Futures . immediateCancelledFuture ( ) ; @Override public Void call ( ) { if ( currentFuture . get ( ) . setFuture ( future ) ) { numSuccessfulSetCalls . incrementAndGet ( ) ; } awaitUnchecked ( barrier ) ; return null ; } } ; final Set < Object > finalResults = Collections . synchronizedSet ( Sets . newIdentityHashSet ( ) ) ; Runnable collectResultsRunnable = new Runnable ( ) { @Override public void run ( ) { try { String result = Uninterruptibles . getUninterruptibly ( currentFuture . get ( ) ) ; finalResults . add ( result ) ; } catch ( ExecutionException e ) { finalResults . add ( e . getCause ( ) ) ; } catch ( CancellationException e ) { finalResults . add ( e . getCause ( ) ) ; } finally { awaitUnchecked ( barrier ) ; } } } ; Runnable collectResultsTimedGetRunnable = new Runnable ( ) { @Override public void run ( ) { Future < String > future = currentFuture . get ( ) ; while ( true ) { try { String result = Uninterruptibles . getUninterruptibly ( future , <int> , TimeUnit . SECONDS ) ; finalResults . add ( result ) ; break ; } catch ( ExecutionException e ) { finalResults . add ( e . getCause ( ) ) ; break ; } catch ( CancellationException e ) { finalResults . add ( e . getCause ( ) ) ; break ; } catch ( TimeoutException e ) { } } awaitUnchecked ( barrier ) ; } } ; List < Callable < ? > > allTasks = new ArrayList < Callable < ? > > ( ) ; allTasks . add ( completeSucessFullyRunnable ) ; allTasks . add ( completeExceptionallyRunnable ) ; allTasks . add ( cancelRunnable ) ; allTasks . add ( setFutureCompleteSucessFullyRunnable ) ; allTasks . add ( setFutureCompleteExceptionallyRunnable ) ; allTasks . add ( setFutureCancelRunnable ) ; for ( int k = <int> ; k < <int> ; k + + ) { final Runnable listener = k % <int> = = <int> ? collectResultsRunnable : collectResultsTimedGetRunnable ; allTasks . add ( Executors . callable ( listener ) ) ; allTasks . add ( new Callable < Void > ( ) { @Override public Void call ( ) throws Exception { currentFuture . get ( ) . addListener ( listener , executor ) ; return null ; } } ) ; } assertEquals ( allTasks . size ( ) + <int> , barrier . getParties ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Collections . shuffle ( allTasks ) ; final AbstractFuture < String > future = new AbstractFuture < String > ( ) { } ; currentFuture . set ( future ) ; for ( Callable < ? > task : allTasks ) { executor . submit ( task ) ; } awaitUnchecked ( barrier ) ; assertThat ( future . isDone ( ) ) . isTrue ( ) ; Object result = Iterables . getOnlyElement ( finalResults ) ; if ( result instanceof CancellationException ) { assertTrue ( future . isCancelled ( ) ) ; if ( future . wasInterrupted ( ) ) { assertThat ( numSuccessfulSetCalls . get ( ) ) . isIn ( Range . closed ( <int> , <int> ) ) ; } else { assertThat ( numSuccessfulSetCalls . get ( ) ) . isEqualTo ( <int> ) ; } } else { assertThat ( numSuccessfulSetCalls . get ( ) ) . isEqualTo ( <int> ) ; } numSuccessfulSetCalls . set ( <int> ) ; finalResults . clear ( ) ; } executor . shutdown ( ) ; } public void testSetFutureCancelBash ( ) { final CyclicBarrier barrier = new CyclicBarrier ( <int> + <int> + <int> + <int> ) ; final ExecutorService executor = Executors . newFixedThreadPool ( barrier . getParties ( ) ) ; final AtomicReference < AbstractFuture < String > > currentFuture = Atomics . newReference ( ) ; final AtomicReference < AbstractFuture < String > > setFutureFuture = Atomics . newReference ( ) ; final AtomicBoolean setFutureSetSucess = new AtomicBoolean ( ) ; final AtomicBoolean setFutureCompletionSucess = new AtomicBoolean ( ) ; final AtomicBoolean cancellationSucess = new AtomicBoolean ( ) ; Callable < Void > cancelRunnable = new Callable < Void > ( ) { @Override public Void call ( ) { cancellationSucess . set ( currentFuture . get ( ) . cancel ( true ) ) ; awaitUnchecked ( barrier ) ; return null ; } } ; Callable < Void > setFutureCompleteSucessFullyRunnable = new Callable < Void > ( ) { @Override public Void call ( ) { AbstractFuture < String > future = setFutureFuture . get ( ) ; setFutureSetSucess . set ( currentFuture . get ( ) . setFuture ( future ) ) ; setFutureCompletionSucess . set ( future . set ( <str> ) ) ; awaitUnchecked ( barrier ) ; return null ; } } ; final Set < Object > finalResults = Collections . synchronizedSet ( Sets . newIdentityHashSet ( ) ) ; Runnable collectResultsRunnable = new Runnable ( ) { @Override public void run ( ) { try { String result = Uninterruptibles . getUninterruptibly ( currentFuture . get ( ) ) ; finalResults . add ( result ) ; } catch ( ExecutionException e ) { finalResults . add ( e . getCause ( ) ) ; } catch ( CancellationException e ) { finalResults . add ( CancellationException . class ) ; } finally { awaitUnchecked ( barrier ) ; } } } ; Runnable collectResultsTimedGetRunnable = new Runnable ( ) { @Override public void run ( ) { Future < String > future = currentFuture . get ( ) ; while ( true ) { try { String result = Uninterruptibles . getUninterruptibly ( future , <int> , TimeUnit . SECONDS ) ; finalResults . add ( result ) ; break ; } catch ( ExecutionException e ) { finalResults . add ( e . getCause ( ) ) ; break ; } catch ( CancellationException e ) { finalResults . add ( CancellationException . class ) ; break ; } catch ( TimeoutException e ) { } } awaitUnchecked ( barrier ) ; } } ; List < Callable < ? > > allTasks = new ArrayList < Callable < ? > > ( ) ; allTasks . add ( cancelRunnable ) ; allTasks . add ( setFutureCompleteSucessFullyRunnable ) ; for ( int k = <int> ; k < <int> ; k + + ) { final Runnable listener = k % <int> = = <int> ? collectResultsRunnable : collectResultsTimedGetRunnable ; allTasks . add ( Executors . callable ( listener ) ) ; allTasks . add ( new Callable < Void > ( ) { @Override public Void call ( ) throws Exception { currentFuture . get ( ) . addListener ( listener , executor ) ; return null ; } } ) ; } assertEquals ( allTasks . size ( ) + <int> , barrier . getParties ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Collections . shuffle ( allTasks ) ; final AbstractFuture < String > future = new AbstractFuture < String > ( ) { } ; final AbstractFuture < String > setFuture = new AbstractFuture < String > ( ) { } ; currentFuture . set ( future ) ; setFutureFuture . set ( setFuture ) ; for ( Callable < ? > task : allTasks ) { executor . submit ( task ) ; } awaitUnchecked ( barrier ) ; assertThat ( future . isDone ( ) ) . isTrue ( ) ; Object result = Iterables . getOnlyElement ( finalResults ) ; if ( result = = CancellationException . class ) { assertTrue ( future . isCancelled ( ) ) ; assertTrue ( cancellationSucess . get ( ) ) ; if ( ! setFutureSetSucess . get ( ) | | ! setFutureCompletionSucess . get ( ) ) { assertTrue ( setFuture . isCancelled ( ) ) ; assertTrue ( setFuture . wasInterrupted ( ) ) ; } } else { assertFalse ( cancellationSucess . get ( ) ) ; assertTrue ( setFutureSetSucess . get ( ) ) ; assertTrue ( setFutureCompletionSucess . get ( ) ) ; } setFutureSetSucess . set ( false ) ; setFutureCompletionSucess . set ( false ) ; cancellationSucess . set ( false ) ; finalResults . clear ( ) ; } executor . shutdown ( ) ; } public void testSetFutureCancelBash_withDoneFuture ( ) { final CyclicBarrier barrier = new CyclicBarrier ( <int> + <int> + <int> ) ; final ExecutorService executor = Executors . newFixedThreadPool ( barrier . getParties ( ) ) ; final AtomicReference < AbstractFuture < String > > currentFuture = Atomics . newReference ( ) ; final AtomicBoolean setFutureSuccess = new AtomicBoolean ( ) ; final AtomicBoolean cancellationSucess = new AtomicBoolean ( ) ; Callable < Void > cancelRunnable = new Callable < Void > ( ) { @Override public Void call ( ) { cancellationSucess . set ( currentFuture . get ( ) . cancel ( true ) ) ; awaitUnchecked ( barrier ) ; return null ; } } ; Callable < Void > setFutureCompleteSucessFullyRunnable = new Callable < Void > ( ) { final ListenableFuture < String > future = Futures . immediateFuture ( <str> ) ; @Override public Void call ( ) { setFutureSuccess . set ( currentFuture . get ( ) . setFuture ( future ) ) ; awaitUnchecked ( barrier ) ; return null ; } } ; final Set < Object > finalResults = Collections . synchronizedSet ( Sets . newIdentityHashSet ( ) ) ; final Runnable collectResultsRunnable = new Runnable ( ) { @Override public void run ( ) { try { String result = Uninterruptibles . getUninterruptibly ( currentFuture . get ( ) ) ; finalResults . add ( result ) ; } catch ( ExecutionException e ) { finalResults . add ( e . getCause ( ) ) ; } catch ( CancellationException e ) { finalResults . add ( CancellationException . class ) ; } finally { awaitUnchecked ( barrier ) ; } } } ; List < Callable < ? > > allTasks = new ArrayList < Callable < ? > > ( ) ; allTasks . add ( cancelRunnable ) ; allTasks . add ( setFutureCompleteSucessFullyRunnable ) ; allTasks . add ( Executors . callable ( collectResultsRunnable ) ) ; assertEquals ( allTasks . size ( ) + <int> , barrier . getParties ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Collections . shuffle ( allTasks ) ; final AbstractFuture < String > future = new AbstractFuture < String > ( ) { } ; currentFuture . set ( future ) ; for ( Callable < ? > task : allTasks ) { executor . submit ( task ) ; } awaitUnchecked ( barrier ) ; assertThat ( future . isDone ( ) ) . isTrue ( ) ; Object result = Iterables . getOnlyElement ( finalResults ) ; if ( result = = CancellationException . class ) { assertTrue ( future . isCancelled ( ) ) ; assertTrue ( cancellationSucess . get ( ) ) ; assertFalse ( setFutureSuccess . get ( ) ) ; } else { assertTrue ( setFutureSuccess . get ( ) ) ; assertFalse ( cancellationSucess . get ( ) ) ; } setFutureSuccess . set ( false ) ; cancellationSucess . set ( false ) ; finalResults . clear ( ) ; } executor . shutdown ( ) ; } private static int awaitUnchecked ( final CyclicBarrier barrier ) { try { return barrier . await ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } private void checkStackTrace ( ExecutionException e ) { int index = findStackFrame ( e , getClass ( ) . getName ( ) , <str> ) ; assertThat ( index ) . isNotEqualTo ( <int> ) ; assertThat ( e . getStackTrace ( ) [ index - <int> ] . getMethodName ( ) ) . isEqualTo ( <str> ) ; } private static int findStackFrame ( ExecutionException e , String clazz , String method ) { StackTraceElement [ ] elements = e . getStackTrace ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { StackTraceElement element = elements [ i ] ; if ( element . getClassName ( ) . equals ( clazz ) & & element . getMethodName ( ) . equals ( method ) ) { return i ; } } AssertionFailedError failure = new AssertionFailedError ( <str> + clazz + <str> + method + <str> ) ; failure . initCause ( e ) ; throw failure ; } private ExecutionException getExpectingExecutionException ( AbstractFuture < String > future ) throws InterruptedException { try { String got = future . get ( ) ; fail ( <str> + got ) ; } catch ( ExecutionException e ) { return e ; } return null ; } private final class WaiterThread extends Thread { private final AbstractFuture < String > future ; private WaiterThread ( AbstractFuture < String > future ) { this . future = future ; } @Override public void run ( ) { try { future . get ( ) ; } catch ( Exception e ) { } } void awaitWaiting ( ) { while ( LockSupport . getBlocker ( this ) ! = future ) { if ( getState ( ) = = State . TERMINATED ) { throw new RuntimeException ( <str> ) ; } Thread . yield ( ) ; } } } private final class PollingThread extends Thread { private final AbstractFuture < String > future ; private final CountDownLatch completedIteration = new CountDownLatch ( <int> ) ; private PollingThread ( AbstractFuture < String > future ) { this . future = future ; } @Override public void run ( ) { while ( true ) { try { future . get ( <int> , TimeUnit . SECONDS ) ; return ; } catch ( InterruptedException e ) { return ; } catch ( ExecutionException e ) { return ; } catch ( TimeoutException e ) { } finally { completedIteration . countDown ( ) ; } } } void awaitInLoop ( ) { Uninterruptibles . awaitUninterruptibly ( completedIteration ) ; } } private static final class InterruptibleFuture extends AbstractFuture < String > { boolean interruptTaskWasCalled ; @Override protected void interruptTask ( ) { assertFalse ( interruptTaskWasCalled ) ; interruptTaskWasCalled = true ; } } } 
