package org . gradle . model . internal . manage . schema . cache ; import com . google . common . collect . Maps ; import net . jcip . annotations . ThreadSafe ; import org . gradle . api . Nullable ; import org . gradle . internal . Cast ; import org . gradle . model . internal . manage . schema . ModelSchema ; import org . gradle . model . internal . type . ModelType ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; @ThreadSafe public class ModelSchemaCache { private final HashMap < WeakClassSet , Map < ModelType < ? > , ModelSchema < ? > > > cache = Maps . newHashMap ( ) ; private final Lock lock = new ReentrantLock ( ) ; @Nullable public < T > ModelSchema < T > get ( ModelType < T > type ) { lock . lock ( ) ; try { Map < ModelType < ? > , ModelSchema < ? > > typeCache = cache . get ( WeakClassSet . of ( type ) ) ; if ( typeCache = = null ) { return null ; } else { return Cast . uncheckedCast ( typeCache . get ( type ) ) ; } } finally { lock . unlock ( ) ; } } public < T > void set ( ModelType < T > type , ModelSchema < T > schema ) { lock . lock ( ) ; try { Map < ModelType < ? > , ModelSchema < ? > > typeCache = cache . get ( WeakClassSet . of ( type ) ) ; if ( typeCache = = null ) { typeCache = Maps . newHashMap ( ) ; cache . put ( WeakClassSet . of ( type ) , typeCache ) ; } typeCache . put ( type , schema ) ; } finally { lock . unlock ( ) ; } } public long size ( ) { lock . lock ( ) ; cleanUp ( ) ; try { long size = <int> ; for ( Map < ModelType < ? > , ModelSchema < ? > > values : cache . values ( ) ) { size + = values . size ( ) ; } return size ; } finally { lock . unlock ( ) ; } } public void cleanUp ( ) { lock . lock ( ) ; try { Iterator < Map . Entry < WeakClassSet , Map < ModelType < ? > , ModelSchema < ? > > > > iterator = cache . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { if ( iterator . next ( ) . getKey ( ) . isCollected ( ) ) { iterator . remove ( ) ; } } } finally { lock . unlock ( ) ; } } } 
