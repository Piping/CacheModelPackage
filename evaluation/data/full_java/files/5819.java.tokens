package org . elasticsearch . common . inject . assistedinject ; import org . elasticsearch . common . inject . ConfigurationException ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . Injector ; import org . elasticsearch . common . inject . Key ; import org . elasticsearch . common . inject . Provider ; import org . elasticsearch . common . inject . TypeLiteral ; import org . elasticsearch . common . inject . internal . Errors ; import org . elasticsearch . common . inject . spi . Dependency ; import org . elasticsearch . common . inject . spi . HasDependencies ; import org . elasticsearch . common . inject . spi . Message ; import java . lang . annotation . Annotation ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; import java . lang . reflect . Proxy ; import java . lang . reflect . Type ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import static java . util . Collections . emptyMap ; import static java . util . Collections . singleton ; import static java . util . Collections . unmodifiableSet ; public class FactoryProvider < F > implements Provider < F > , HasDependencies { private Injector injector ; private final TypeLiteral < F > factoryType ; private final Map < Method , AssistedConstructor < ? > > factoryMethodToConstructor ; public static < F > Provider < F > newFactory ( Class < F > factoryType , Class < ? > implementationType ) { return newFactory ( TypeLiteral . get ( factoryType ) , TypeLiteral . get ( implementationType ) ) ; } public static < F > Provider < F > newFactory ( TypeLiteral < F > factoryType , TypeLiteral < ? > implementationType ) { Map < Method , AssistedConstructor < ? > > factoryMethodToConstructor = createMethodMapping ( factoryType , implementationType ) ; if ( ! factoryMethodToConstructor . isEmpty ( ) ) { return new FactoryProvider < > ( factoryType , factoryMethodToConstructor ) ; } else { return new FactoryProvider2 < > ( factoryType , Key . get ( implementationType ) ) ; } } private FactoryProvider ( TypeLiteral < F > factoryType , Map < Method , AssistedConstructor < ? > > factoryMethodToConstructor ) { this . factoryType = factoryType ; this . factoryMethodToConstructor = factoryMethodToConstructor ; checkDeclaredExceptionsMatch ( ) ; } @Inject void setInjectorAndCheckUnboundParametersAreInjectable ( Injector injector ) { this . injector = injector ; for ( AssistedConstructor < ? > c : factoryMethodToConstructor . values ( ) ) { for ( Parameter p : c . getAllParameters ( ) ) { if ( ! p . isProvidedByFactory ( ) & & ! paramCanBeInjected ( p , injector ) ) { throw newConfigurationException ( <str> + <str> , p , c ) ; } } } } private void checkDeclaredExceptionsMatch ( ) { for ( Map . Entry < Method , AssistedConstructor < ? > > entry : factoryMethodToConstructor . entrySet ( ) ) { for ( Class < ? > constructorException : entry . getValue ( ) . getDeclaredExceptions ( ) ) { if ( ! isConstructorExceptionCompatibleWithFactoryExeception ( constructorException , entry . getKey ( ) . getExceptionTypes ( ) ) ) { throw newConfigurationException ( <str> + <str> , entry . getValue ( ) , entry . getKey ( ) ) ; } } } } private boolean isConstructorExceptionCompatibleWithFactoryExeception ( Class < ? > constructorException , Class < ? > [ ] factoryExceptions ) { for ( Class < ? > factoryException : factoryExceptions ) { if ( factoryException . isAssignableFrom ( constructorException ) ) { return true ; } } return false ; } private boolean paramCanBeInjected ( Parameter parameter , Injector injector ) { return parameter . isBound ( injector ) ; } private static Map < Method , AssistedConstructor < ? > > createMethodMapping ( TypeLiteral < ? > factoryType , TypeLiteral < ? > implementationType ) { List < AssistedConstructor < ? > > constructors = new ArrayList < > ( ) ; for ( Constructor < ? > constructor : implementationType . getRawType ( ) . getConstructors ( ) ) { if ( constructor . getAnnotation ( AssistedInject . class ) ! = null ) { @SuppressWarnings ( <str> ) AssistedConstructor assistedConstructor = new AssistedConstructor ( constructor , implementationType . getParameterTypes ( constructor ) ) ; constructors . add ( assistedConstructor ) ; } } if ( constructors . isEmpty ( ) ) { return emptyMap ( ) ; } Method [ ] factoryMethods = factoryType . getRawType ( ) . getMethods ( ) ; if ( constructors . size ( ) ! = factoryMethods . length ) { throw newConfigurationException ( <str> + <str> , implementationType , constructors . size ( ) , factoryType , factoryMethods . length ) ; } Map < ParameterListKey , AssistedConstructor > paramsToConstructor = new HashMap < > ( ) ; for ( AssistedConstructor c : constructors ) { if ( paramsToConstructor . containsKey ( c . getAssistedParameters ( ) ) ) { throw new RuntimeException ( <str> + c ) ; } paramsToConstructor . put ( c . getAssistedParameters ( ) , c ) ; } Map < Method , AssistedConstructor < ? > > result = new HashMap < > ( ) ; for ( Method method : factoryMethods ) { if ( ! method . getReturnType ( ) . isAssignableFrom ( implementationType . getRawType ( ) ) ) { throw newConfigurationException ( <str> , method , implementationType ) ; } List < Type > parameterTypes = new ArrayList < > ( ) ; for ( TypeLiteral < ? > parameterType : factoryType . getParameterTypes ( method ) ) { parameterTypes . add ( parameterType . getType ( ) ) ; } ParameterListKey methodParams = new ParameterListKey ( parameterTypes ) ; if ( ! paramsToConstructor . containsKey ( methodParams ) ) { throw newConfigurationException ( <str> + <str> , implementationType , methodParams , paramsToConstructor . values ( ) ) ; } method . getParameterAnnotations ( ) ; for ( Annotation [ ] parameterAnnotations : method . getParameterAnnotations ( ) ) { for ( Annotation parameterAnnotation : parameterAnnotations ) { if ( parameterAnnotation . annotationType ( ) = = Assisted . class ) { throw newConfigurationException ( <str> + <str> + <str> , method , implementationType ) ; } } } AssistedConstructor matchingConstructor = paramsToConstructor . remove ( methodParams ) ; result . put ( method , matchingConstructor ) ; } return result ; } @Override public Set < Dependency < ? > > getDependencies ( ) { Set < Dependency < ? > > dependencies = new HashSet < > ( ) ; for ( AssistedConstructor < ? > constructor : factoryMethodToConstructor . values ( ) ) { for ( Parameter parameter : constructor . getAllParameters ( ) ) { if ( ! parameter . isProvidedByFactory ( ) ) { dependencies . add ( Dependency . get ( parameter . getPrimaryBindingKey ( ) ) ) ; } } } return unmodifiableSet ( dependencies ) ; } @Override public F get ( ) { InvocationHandler invocationHandler = new InvocationHandler ( ) { @Override public Object invoke ( Object proxy , Method method , Object [ ] creationArgs ) throws Throwable { if ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { return method . invoke ( this , creationArgs ) ; } AssistedConstructor < ? > constructor = factoryMethodToConstructor . get ( method ) ; Object [ ] constructorArgs = gatherArgsForConstructor ( constructor , creationArgs ) ; Object objectToReturn = constructor . newInstance ( constructorArgs ) ; injector . injectMembers ( objectToReturn ) ; return objectToReturn ; } public Object [ ] gatherArgsForConstructor ( AssistedConstructor < ? > constructor , Object [ ] factoryArgs ) { int numParams = constructor . getAllParameters ( ) . size ( ) ; int argPosition = <int> ; Object [ ] result = new Object [ numParams ] ; for ( int i = <int> ; i < numParams ; i + + ) { Parameter parameter = constructor . getAllParameters ( ) . get ( i ) ; if ( parameter . isProvidedByFactory ( ) ) { result [ i ] = factoryArgs [ argPosition ] ; argPosition + + ; } else { result [ i ] = parameter . getValue ( injector ) ; } } return result ; } } ; @SuppressWarnings ( <str> ) Class < F > factoryRawType = ( Class ) factoryType . getRawType ( ) ; return factoryRawType . cast ( Proxy . newProxyInstance ( factoryRawType . getClassLoader ( ) , new Class [ ] { factoryRawType } , invocationHandler ) ) ; } private static ConfigurationException newConfigurationException ( String format , Object . . . args ) { return new ConfigurationException ( singleton ( new Message ( Errors . format ( format , args ) ) ) ) ; } } 
