package com . badlogic . gdx . graphics . g3d . utils ; import com . badlogic . gdx . graphics . g3d . ModelInstance ; import com . badlogic . gdx . graphics . g3d . model . Animation ; import com . badlogic . gdx . graphics . g3d . model . Node ; import com . badlogic . gdx . graphics . g3d . model . NodeAnimation ; import com . badlogic . gdx . graphics . g3d . model . NodeKeyframe ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Quaternion ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . ObjectMap ; import com . badlogic . gdx . utils . ObjectMap . Entry ; import com . badlogic . gdx . utils . Pool ; import com . badlogic . gdx . utils . Pool . Poolable ; public class BaseAnimationController { public final static class Transform implements Poolable { public final Vector3 translation = new Vector3 ( ) ; public final Quaternion rotation = new Quaternion ( ) ; public final Vector3 scale = new Vector3 ( <int> , <int> , <int> ) ; public Transform ( ) { } public Transform idt ( ) { translation . set ( <int> , <int> , <int> ) ; rotation . idt ( ) ; scale . set ( <int> , <int> , <int> ) ; return this ; } public Transform set ( final Vector3 t , final Quaternion r , final Vector3 s ) { translation . set ( t ) ; rotation . set ( r ) ; scale . set ( s ) ; return this ; } public Transform set ( final Transform other ) { return set ( other . translation , other . rotation , other . scale ) ; } public Transform lerp ( final Transform target , final float alpha ) { return lerp ( target . translation , target . rotation , target . scale , alpha ) ; } public Transform lerp ( final Vector3 targetT , final Quaternion targetR , final Vector3 targetS , final float alpha ) { translation . lerp ( targetT , alpha ) ; rotation . slerp ( targetR , alpha ) ; scale . lerp ( targetS , alpha ) ; return this ; } public Matrix4 toMatrix4 ( final Matrix4 out ) { return out . set ( translation , rotation , scale ) ; } @Override public void reset ( ) { idt ( ) ; } @Override public String toString ( ) { return translation . toString ( ) + <str> + rotation . toString ( ) + <str> + scale . toString ( ) ; } } private final Pool < Transform > transformPool = new Pool < Transform > ( ) { @Override protected Transform newObject ( ) { return new Transform ( ) ; } } ; private final static ObjectMap < Node , Transform > transforms = new ObjectMap < Node , Transform > ( ) ; private boolean applying = false ; public final ModelInstance target ; public BaseAnimationController ( final ModelInstance target ) { this . target = target ; } protected void begin ( ) { if ( applying ) throw new GdxRuntimeException ( <str> ) ; applying = true ; } protected void apply ( final Animation animation , final float time , final float weight ) { if ( ! applying ) throw new GdxRuntimeException ( <str> ) ; applyAnimation ( transforms , transformPool , weight , animation , time ) ; } protected void end ( ) { if ( ! applying ) throw new GdxRuntimeException ( <str> ) ; for ( Entry < Node , Transform > entry : transforms . entries ( ) ) { entry . value . toMatrix4 ( entry . key . localTransform ) ; transformPool . free ( entry . value ) ; } transforms . clear ( ) ; target . calculateTransforms ( ) ; applying = false ; } protected void applyAnimation ( final Animation animation , final float time ) { if ( applying ) throw new GdxRuntimeException ( <str> ) ; applyAnimation ( null , null , <float> , animation , time ) ; target . calculateTransforms ( ) ; } protected void applyAnimations ( final Animation anim1 , final float time1 , final Animation anim2 , final float time2 , final float weight ) { if ( anim2 = = null | | weight = = <float> ) applyAnimation ( anim1 , time1 ) ; else if ( anim1 = = null | | weight = = <float> ) applyAnimation ( anim2 , time2 ) ; else if ( applying ) throw new GdxRuntimeException ( <str> ) ; else { begin ( ) ; apply ( anim1 , time1 , <float> ) ; apply ( anim2 , time2 , weight ) ; end ( ) ; } } private final static Transform tmpT = new Transform ( ) ; private final static < T > int getFirstKeyframeIndexAtTime ( final Array < NodeKeyframe < T > > arr , final float time ) { final int n = arr . size - <int> ; for ( int i = <int> ; i < n ; i + + ) { if ( time > = arr . get ( i ) . keytime & & time < = arr . get ( i + <int> ) . keytime ) { return i ; } } return <int> ; } private final static Vector3 getTranslationAtTime ( final NodeAnimation nodeAnim , final float time , final Vector3 out ) { if ( nodeAnim . translation = = null ) return out . set ( nodeAnim . node . translation ) ; if ( nodeAnim . translation . size = = <int> ) return out . set ( nodeAnim . translation . get ( <int> ) . value ) ; int index = getFirstKeyframeIndexAtTime ( nodeAnim . translation , time ) ; final NodeKeyframe firstKeyframe = nodeAnim . translation . get ( index ) ; out . set ( ( Vector3 ) firstKeyframe . value ) ; if ( + + index < nodeAnim . translation . size ) { final NodeKeyframe < Vector3 > secondKeyframe = nodeAnim . translation . get ( index ) ; final float t = ( time - firstKeyframe . keytime ) / ( secondKeyframe . keytime - firstKeyframe . keytime ) ; out . lerp ( secondKeyframe . value , t ) ; } return out ; } private final static Quaternion getRotationAtTime ( final NodeAnimation nodeAnim , final float time , final Quaternion out ) { if ( nodeAnim . rotation = = null ) return out . set ( nodeAnim . node . rotation ) ; if ( nodeAnim . rotation . size = = <int> ) return out . set ( nodeAnim . rotation . get ( <int> ) . value ) ; int index = getFirstKeyframeIndexAtTime ( nodeAnim . rotation , time ) ; final NodeKeyframe firstKeyframe = nodeAnim . rotation . get ( index ) ; out . set ( ( Quaternion ) firstKeyframe . value ) ; if ( + + index < nodeAnim . rotation . size ) { final NodeKeyframe < Quaternion > secondKeyframe = nodeAnim . rotation . get ( index ) ; final float t = ( time - firstKeyframe . keytime ) / ( secondKeyframe . keytime - firstKeyframe . keytime ) ; out . slerp ( secondKeyframe . value , t ) ; } return out ; } private final static Vector3 getScalingAtTime ( final NodeAnimation nodeAnim , final float time , final Vector3 out ) { if ( nodeAnim . scaling = = null ) return out . set ( nodeAnim . node . scale ) ; if ( nodeAnim . scaling . size = = <int> ) return out . set ( nodeAnim . scaling . get ( <int> ) . value ) ; int index = getFirstKeyframeIndexAtTime ( nodeAnim . scaling , time ) ; final NodeKeyframe firstKeyframe = nodeAnim . scaling . get ( index ) ; out . set ( ( Vector3 ) firstKeyframe . value ) ; if ( + + index < nodeAnim . scaling . size ) { final NodeKeyframe < Vector3 > secondKeyframe = nodeAnim . scaling . get ( index ) ; final float t = ( time - firstKeyframe . keytime ) / ( secondKeyframe . keytime - firstKeyframe . keytime ) ; out . lerp ( secondKeyframe . value , t ) ; } return out ; } private final static Transform getNodeAnimationTransform ( final NodeAnimation nodeAnim , final float time ) { final Transform transform = tmpT ; getTranslationAtTime ( nodeAnim , time , transform . translation ) ; getRotationAtTime ( nodeAnim , time , transform . rotation ) ; getScalingAtTime ( nodeAnim , time , transform . scale ) ; return transform ; } private final static void applyNodeAnimationDirectly ( final NodeAnimation nodeAnim , final float time ) { final Node node = nodeAnim . node ; node . isAnimated = true ; final Transform transform = getNodeAnimationTransform ( nodeAnim , time ) ; transform . toMatrix4 ( node . localTransform ) ; } private final static void applyNodeAnimationBlending ( final NodeAnimation nodeAnim , final ObjectMap < Node , Transform > out , final Pool < Transform > pool , final float alpha , final float time ) { final Node node = nodeAnim . node ; node . isAnimated = true ; final Transform transform = getNodeAnimationTransform ( nodeAnim , time ) ; Transform t = out . get ( node , null ) ; if ( t ! = null ) { if ( alpha > <float> ) t . set ( transform ) ; else t . lerp ( transform , alpha ) ; } else { if ( alpha > <float> ) out . put ( node , pool . obtain ( ) . set ( transform ) ) ; else out . put ( node , pool . obtain ( ) . set ( node . translation , node . rotation , node . scale ) . lerp ( transform , alpha ) ) ; } } protected static void applyAnimation ( final ObjectMap < Node , Transform > out , final Pool < Transform > pool , final float alpha , final Animation animation , final float time ) { if ( out = = null ) { for ( final NodeAnimation nodeAnim : animation . nodeAnimations ) applyNodeAnimationDirectly ( nodeAnim , time ) ; } else { for ( final Node node : out . keys ( ) ) node . isAnimated = false ; for ( final NodeAnimation nodeAnim : animation . nodeAnimations ) applyNodeAnimationBlending ( nodeAnim , out , pool , alpha , time ) ; for ( final ObjectMap . Entry < Node , Transform > e : out . entries ( ) ) { if ( ! e . key . isAnimated ) { e . key . isAnimated = true ; e . value . lerp ( e . key . translation , e . key . rotation , e . key . scale , alpha ) ; } } } } protected void removeAnimation ( final Animation animation ) { for ( final NodeAnimation nodeAnim : animation . nodeAnimations ) { nodeAnim . node . isAnimated = false ; } } } 
