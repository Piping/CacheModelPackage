package org . elasticsearch . cluster . service ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . * ; import org . elasticsearch . cluster . ClusterState . Builder ; import org . elasticsearch . cluster . block . ClusterBlock ; import org . elasticsearch . cluster . block . ClusterBlocks ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . ProcessClusterEventTimeoutException ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodeService ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . OperationRouting ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . text . StringText ; import org . elasticsearch . common . transport . TransportAddress ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . util . concurrent . * ; import org . elasticsearch . common . util . iterable . Iterables ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . discovery . DiscoveryService ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportService ; import java . util . * ; import java . util . concurrent . * ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . stream . Collectors ; import static org . elasticsearch . common . util . concurrent . EsExecutors . daemonThreadFactory ; public class InternalClusterService extends AbstractLifecycleComponent < ClusterService > implements ClusterService { public static final String SETTING_CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD = <str> ; public static final String SETTING_CLUSTER_SERVICE_RECONNECT_INTERVAL = <str> ; public static final String UPDATE_THREAD_NAME = <str> ; private final ThreadPool threadPool ; private final DiscoveryService discoveryService ; private final OperationRouting operationRouting ; private final TransportService transportService ; private final NodeSettingsService nodeSettingsService ; private final DiscoveryNodeService discoveryNodeService ; private final Version version ; private final TimeValue reconnectInterval ; private TimeValue slowTaskLoggingThreshold ; private volatile PrioritizedEsThreadPoolExecutor updateTasksExecutor ; private final Collection < ClusterStateListener > priorityClusterStateListeners = new CopyOnWriteArrayList < > ( ) ; private final Collection < ClusterStateListener > clusterStateListeners = new CopyOnWriteArrayList < > ( ) ; private final Collection < ClusterStateListener > lastClusterStateListeners = new CopyOnWriteArrayList < > ( ) ; private final Map < ClusterStateTaskExecutor , List < UpdateTask > > updateTasksPerExecutor = new HashMap < > ( ) ; private final Collection < ClusterStateListener > postAppliedListeners = new CopyOnWriteArrayList < > ( ) ; private final Iterable < ClusterStateListener > preAppliedListeners = Iterables . concat ( priorityClusterStateListeners , clusterStateListeners , lastClusterStateListeners ) ; private final LocalNodeMasterListeners localNodeMasterListeners ; private final Queue < NotifyTimeout > onGoingTimeouts = ConcurrentCollections . newQueue ( ) ; private volatile ClusterState clusterState ; private final ClusterBlocks . Builder initialBlocks ; private volatile ScheduledFuture reconnectToNodes ; @Inject public InternalClusterService ( Settings settings , DiscoveryService discoveryService , OperationRouting operationRouting , TransportService transportService , NodeSettingsService nodeSettingsService , ThreadPool threadPool , ClusterName clusterName , DiscoveryNodeService discoveryNodeService , Version version ) { super ( settings ) ; this . operationRouting = operationRouting ; this . transportService = transportService ; this . discoveryService = discoveryService ; this . threadPool = threadPool ; this . nodeSettingsService = nodeSettingsService ; this . discoveryNodeService = discoveryNodeService ; this . version = version ; this . clusterState = ClusterState . builder ( clusterName ) . build ( ) ; this . nodeSettingsService . setClusterService ( this ) ; this . nodeSettingsService . addListener ( new ApplySettings ( ) ) ; this . reconnectInterval = this . settings . getAsTime ( SETTING_CLUSTER_SERVICE_RECONNECT_INTERVAL , TimeValue . timeValueSeconds ( <int> ) ) ; this . slowTaskLoggingThreshold = this . settings . getAsTime ( SETTING_CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD , TimeValue . timeValueSeconds ( <int> ) ) ; localNodeMasterListeners = new LocalNodeMasterListeners ( threadPool ) ; initialBlocks = ClusterBlocks . builder ( ) . addGlobalBlock ( discoveryService . getNoMasterBlock ( ) ) ; } public NodeSettingsService settingsService ( ) { return this . nodeSettingsService ; } @Override public void addInitialStateBlock ( ClusterBlock block ) throws IllegalStateException { if ( lifecycle . started ( ) ) { throw new IllegalStateException ( <str> ) ; } initialBlocks . addGlobalBlock ( block ) ; } @Override public void removeInitialStateBlock ( ClusterBlock block ) throws IllegalStateException { if ( lifecycle . started ( ) ) { throw new IllegalStateException ( <str> ) ; } initialBlocks . removeGlobalBlock ( block ) ; } @Override protected void doStart ( ) { add ( localNodeMasterListeners ) ; this . clusterState = ClusterState . builder ( clusterState ) . blocks ( initialBlocks ) . build ( ) ; this . updateTasksExecutor = EsExecutors . newSinglePrioritizing ( UPDATE_THREAD_NAME , daemonThreadFactory ( settings , UPDATE_THREAD_NAME ) ) ; this . reconnectToNodes = threadPool . schedule ( reconnectInterval , ThreadPool . Names . GENERIC , new ReconnectToNodes ( ) ) ; Map < String , String > nodeAttributes = discoveryNodeService . buildAttributes ( ) ; final String nodeId = DiscoveryService . generateNodeId ( settings ) ; final TransportAddress publishAddress = transportService . boundAddress ( ) . publishAddress ( ) ; DiscoveryNode localNode = new DiscoveryNode ( settings . get ( <str> ) , nodeId , publishAddress , nodeAttributes , version ) ; DiscoveryNodes . Builder nodeBuilder = DiscoveryNodes . builder ( ) . put ( localNode ) . localNodeId ( localNode . id ( ) ) ; this . clusterState = ClusterState . builder ( clusterState ) . nodes ( nodeBuilder ) . blocks ( initialBlocks ) . build ( ) ; this . transportService . setLocalNode ( localNode ) ; } @Override protected void doStop ( ) { FutureUtils . cancel ( this . reconnectToNodes ) ; for ( NotifyTimeout onGoingTimeout : onGoingTimeouts ) { onGoingTimeout . cancel ( ) ; onGoingTimeout . listener . onClose ( ) ; } ThreadPool . terminate ( updateTasksExecutor , <int> , TimeUnit . SECONDS ) ; remove ( localNodeMasterListeners ) ; } @Override protected void doClose ( ) { } @Override public DiscoveryNode localNode ( ) { return clusterState . getNodes ( ) . localNode ( ) ; } @Override public OperationRouting operationRouting ( ) { return operationRouting ; } @Override public ClusterState state ( ) { return this . clusterState ; } @Override public void addFirst ( ClusterStateListener listener ) { priorityClusterStateListeners . add ( listener ) ; } @Override public void addLast ( ClusterStateListener listener ) { lastClusterStateListeners . add ( listener ) ; } @Override public void add ( ClusterStateListener listener ) { clusterStateListeners . add ( listener ) ; } @Override public void remove ( ClusterStateListener listener ) { clusterStateListeners . remove ( listener ) ; priorityClusterStateListeners . remove ( listener ) ; lastClusterStateListeners . remove ( listener ) ; postAppliedListeners . remove ( listener ) ; for ( Iterator < NotifyTimeout > it = onGoingTimeouts . iterator ( ) ; it . hasNext ( ) ; ) { NotifyTimeout timeout = it . next ( ) ; if ( timeout . listener . equals ( listener ) ) { timeout . cancel ( ) ; it . remove ( ) ; } } } @Override public void add ( LocalNodeMasterListener listener ) { localNodeMasterListeners . add ( listener ) ; } @Override public void remove ( LocalNodeMasterListener listener ) { localNodeMasterListeners . remove ( listener ) ; } @Override public void add ( @Nullable final TimeValue timeout , final TimeoutClusterStateListener listener ) { if ( lifecycle . stoppedOrClosed ( ) ) { listener . onClose ( ) ; return ; } try { updateTasksExecutor . execute ( new SourcePrioritizedRunnable ( Priority . HIGH , <str> ) { @Override public void run ( ) { if ( timeout ! = null ) { NotifyTimeout notifyTimeout = new NotifyTimeout ( listener , timeout ) ; notifyTimeout . future = threadPool . schedule ( timeout , ThreadPool . Names . GENERIC , notifyTimeout ) ; onGoingTimeouts . add ( notifyTimeout ) ; } postAppliedListeners . add ( listener ) ; listener . postAdded ( ) ; } } ) ; } catch ( EsRejectedExecutionException e ) { if ( lifecycle . stoppedOrClosed ( ) ) { listener . onClose ( ) ; } else { throw e ; } } } @Override public void submitStateUpdateTask ( final String source , final ClusterStateUpdateTask updateTask ) { submitStateUpdateTask ( source , updateTask , updateTask , updateTask , updateTask ) ; } @Override public < T > void submitStateUpdateTask ( final String source , final T task , final ClusterStateTaskConfig config , final ClusterStateTaskExecutor < T > executor , final ClusterStateTaskListener listener ) { if ( ! lifecycle . started ( ) ) { return ; } try { final UpdateTask < T > updateTask = new UpdateTask < > ( source , task , config , executor , listener ) ; synchronized ( updateTasksPerExecutor ) { updateTasksPerExecutor . computeIfAbsent ( executor , k - > new ArrayList < > ( ) ) . add ( updateTask ) ; } if ( config . timeout ( ) ! = null ) { updateTasksExecutor . execute ( updateTask , threadPool . scheduler ( ) , config . timeout ( ) , ( ) - > threadPool . generic ( ) . execute ( ( ) - > { if ( updateTask . processed . getAndSet ( true ) = = false ) { listener . onFailure ( source , new ProcessClusterEventTimeoutException ( config . timeout ( ) , source ) ) ; } } ) ) ; } else { updateTasksExecutor . execute ( updateTask ) ; } } catch ( EsRejectedExecutionException e ) { if ( ! lifecycle . stoppedOrClosed ( ) ) { throw e ; } } } @Override public List < PendingClusterTask > pendingTasks ( ) { PrioritizedEsThreadPoolExecutor . Pending [ ] pendings = updateTasksExecutor . getPending ( ) ; List < PendingClusterTask > pendingClusterTasks = new ArrayList < > ( pendings . length ) ; for ( PrioritizedEsThreadPoolExecutor . Pending pending : pendings ) { final String source ; final long timeInQueue ; final Object task = pending . task ; if ( task = = null ) { continue ; } else if ( task instanceof SourcePrioritizedRunnable ) { SourcePrioritizedRunnable runnable = ( SourcePrioritizedRunnable ) task ; source = runnable . source ( ) ; timeInQueue = runnable . getAgeInMillis ( ) ; } else { assert false : <str> + task . getClass ( ) ; source = <str> + task . getClass ( ) + <str> ; timeInQueue = <int> ; } pendingClusterTasks . add ( new PendingClusterTask ( pending . insertionOrder , pending . priority , new StringText ( source ) , timeInQueue , pending . executing ) ) ; } return pendingClusterTasks ; } @Override public int numberOfPendingTasks ( ) { return updateTasksExecutor . getNumberOfPendingTasks ( ) ; } @Override public TimeValue getMaxTaskWaitTime ( ) { return updateTasksExecutor . getMaxTaskWaitTime ( ) ; } public boolean assertClusterStateThread ( ) { assert Thread . currentThread ( ) . getName ( ) . contains ( InternalClusterService . UPDATE_THREAD_NAME ) : <str> ; return true ; } static abstract class SourcePrioritizedRunnable extends PrioritizedRunnable { protected final String source ; public SourcePrioritizedRunnable ( Priority priority , String source ) { super ( priority ) ; this . source = source ; } public String source ( ) { return source ; } } < T > void runTasksForExecutor ( ClusterStateTaskExecutor < T > executor ) { final ArrayList < UpdateTask < T > > toExecute = new ArrayList < > ( ) ; final ArrayList < String > sources = new ArrayList < > ( ) ; synchronized ( updateTasksPerExecutor ) { List < UpdateTask > pending = updateTasksPerExecutor . remove ( executor ) ; if ( pending ! = null ) { for ( UpdateTask < T > task : pending ) { if ( task . processed . getAndSet ( true ) = = false ) { logger . trace ( <str> , task . source ) ; toExecute . add ( task ) ; sources . add ( task . source ) ; } else { logger . trace ( <str> , task . source ) ; } } } } if ( toExecute . isEmpty ( ) ) { return ; } final String source = Strings . collectionToCommaDelimitedString ( sources ) ; if ( ! lifecycle . started ( ) ) { logger . debug ( <str> , source ) ; return ; } logger . debug ( <str> , source ) ; ClusterState previousClusterState = clusterState ; if ( ! previousClusterState . nodes ( ) . localNodeMaster ( ) & & executor . runOnlyOnMaster ( ) ) { logger . debug ( <str> , source ) ; toExecute . stream ( ) . forEach ( task - > task . listener . onNoLongerMaster ( task . source ) ) ; return ; } ClusterStateTaskExecutor . BatchResult < T > batchResult ; long startTimeNS = System . nanoTime ( ) ; try { List < T > inputs = toExecute . stream ( ) . map ( tUpdateTask - > tUpdateTask . task ) . collect ( Collectors . toList ( ) ) ; batchResult = executor . execute ( previousClusterState , inputs ) ; } catch ( Throwable e ) { TimeValue executionTime = TimeValue . timeValueMillis ( Math . max ( <int> , TimeValue . nsecToMSec ( System . nanoTime ( ) - startTimeNS ) ) ) ; if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( <str> ) . append ( executionTime ) . append ( <str> ) . append ( previousClusterState . version ( ) ) . append ( <str> ) . append ( source ) . append ( <str> ) ; sb . append ( previousClusterState . nodes ( ) . prettyPrint ( ) ) ; sb . append ( previousClusterState . routingTable ( ) . prettyPrint ( ) ) ; sb . append ( previousClusterState . getRoutingNodes ( ) . prettyPrint ( ) ) ; logger . trace ( sb . toString ( ) , e ) ; } warnAboutSlowTaskIfNeeded ( executionTime , source ) ; batchResult = ClusterStateTaskExecutor . BatchResult . < T > builder ( ) . failures ( toExecute . stream ( ) . map ( updateTask - > updateTask . task ) : : iterator , e ) . build ( previousClusterState ) ; } assert batchResult . executionResults ! = null ; ClusterState newClusterState = batchResult . resultingState ; final ArrayList < UpdateTask < T > > proccessedListeners = new ArrayList < > ( ) ; for ( UpdateTask < T > updateTask : toExecute ) { assert batchResult . executionResults . containsKey ( updateTask . task ) : <str> + updateTask . task . toString ( ) ; final ClusterStateTaskExecutor . TaskResult executionResult = batchResult . executionResults . get ( updateTask . task ) ; executionResult . handle ( ( ) - > proccessedListeners . add ( updateTask ) , ex - > updateTask . listener . onFailure ( updateTask . source , ex ) ) ; } if ( previousClusterState = = newClusterState ) { for ( UpdateTask < T > task : proccessedListeners ) { if ( task . listener instanceof AckedClusterStateTaskListener ) { ( ( AckedClusterStateTaskListener ) task . listener ) . onAllNodesAcked ( null ) ; } task . listener . clusterStateProcessed ( task . source , previousClusterState , newClusterState ) ; } TimeValue executionTime = TimeValue . timeValueMillis ( Math . max ( <int> , TimeValue . nsecToMSec ( System . nanoTime ( ) - startTimeNS ) ) ) ; logger . debug ( <str> , source , executionTime ) ; warnAboutSlowTaskIfNeeded ( executionTime , source ) ; return ; } try { ArrayList < Discovery . AckListener > ackListeners = new ArrayList < > ( ) ; if ( newClusterState . nodes ( ) . localNodeMaster ( ) ) { Builder builder = ClusterState . builder ( newClusterState ) . incrementVersion ( ) ; if ( previousClusterState . routingTable ( ) ! = newClusterState . routingTable ( ) ) { builder . routingTable ( RoutingTable . builder ( newClusterState . routingTable ( ) ) . version ( newClusterState . routingTable ( ) . version ( ) + <int> ) . build ( ) ) ; } if ( previousClusterState . metaData ( ) ! = newClusterState . metaData ( ) ) { builder . metaData ( MetaData . builder ( newClusterState . metaData ( ) ) . version ( newClusterState . metaData ( ) . version ( ) + <int> ) ) ; } newClusterState = builder . build ( ) ; for ( UpdateTask < T > task : proccessedListeners ) { if ( task . listener instanceof AckedClusterStateTaskListener ) { final AckedClusterStateTaskListener ackedListener = ( AckedClusterStateTaskListener ) task . listener ; if ( ackedListener . ackTimeout ( ) = = null | | ackedListener . ackTimeout ( ) . millis ( ) = = <int> ) { ackedListener . onAckTimeout ( ) ; } else { try { ackListeners . add ( new AckCountDownListener ( ackedListener , newClusterState . version ( ) , newClusterState . nodes ( ) , threadPool ) ) ; } catch ( EsRejectedExecutionException ex ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , ex ) ; } ackedListener . onAckTimeout ( ) ; } } } } } final Discovery . AckListener ackListener = new DelegetingAckListener ( ackListeners ) ; newClusterState . status ( ClusterState . ClusterStateStatus . BEING_APPLIED ) ; if ( logger . isTraceEnabled ( ) ) { StringBuilder sb = new StringBuilder ( <str> ) . append ( source ) . append ( <str> ) ; sb . append ( newClusterState . prettyPrint ( ) ) ; logger . trace ( sb . toString ( ) ) ; } else if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , newClusterState . version ( ) , source ) ; } ClusterChangedEvent clusterChangedEvent = new ClusterChangedEvent ( source , newClusterState , previousClusterState ) ; final DiscoveryNodes . Delta nodesDelta = clusterChangedEvent . nodesDelta ( ) ; if ( nodesDelta . hasChanges ( ) & & logger . isInfoEnabled ( ) ) { String summary = nodesDelta . shortSummary ( ) ; if ( summary . length ( ) > <int> ) { logger . info ( <str> , summary , source ) ; } } for ( DiscoveryNode node : nodesDelta . addedNodes ( ) ) { if ( ! nodeRequiresConnection ( node ) ) { continue ; } try { transportService . connectToNode ( node ) ; } catch ( Throwable e ) { logger . warn ( <str> + node + <str> , e ) ; } } if ( newClusterState . nodes ( ) . localNodeMaster ( ) ) { logger . debug ( <str> , newClusterState . version ( ) ) ; try { discoveryService . publish ( clusterChangedEvent , ackListener ) ; } catch ( Discovery . FailedToCommitClusterStateException t ) { logger . warn ( <str> , t , source , newClusterState . version ( ) ) ; proccessedListeners . forEach ( task - > task . listener . onFailure ( task . source , t ) ) ; return ; } } clusterState = newClusterState ; logger . debug ( <str> , newClusterState . version ( ) ) ; for ( ClusterStateListener listener : preAppliedListeners ) { try { listener . clusterChanged ( clusterChangedEvent ) ; } catch ( Exception ex ) { logger . warn ( <str> , ex ) ; } } for ( DiscoveryNode node : nodesDelta . removedNodes ( ) ) { try { transportService . disconnectFromNode ( node ) ; } catch ( Throwable e ) { logger . warn ( <str> + node + <str> , e ) ; } } newClusterState . status ( ClusterState . ClusterStateStatus . APPLIED ) ; for ( ClusterStateListener listener : postAppliedListeners ) { try { listener . clusterChanged ( clusterChangedEvent ) ; } catch ( Exception ex ) { logger . warn ( <str> , ex ) ; } } if ( newClusterState . nodes ( ) . localNodeMaster ( ) ) { try { ackListener . onNodeAck ( newClusterState . nodes ( ) . localNode ( ) , null ) ; } catch ( Throwable t ) { logger . debug ( <str> , t , newClusterState . nodes ( ) . localNode ( ) ) ; } } for ( UpdateTask < T > task : proccessedListeners ) { task . listener . clusterStateProcessed ( task . source , previousClusterState , newClusterState ) ; } TimeValue executionTime = TimeValue . timeValueMillis ( Math . max ( <int> , TimeValue . nsecToMSec ( System . nanoTime ( ) - startTimeNS ) ) ) ; logger . debug ( <str> , source , executionTime , newClusterState . version ( ) , newClusterState . stateUUID ( ) ) ; warnAboutSlowTaskIfNeeded ( executionTime , source ) ; } catch ( Throwable t ) { TimeValue executionTime = TimeValue . timeValueMillis ( Math . max ( <int> , TimeValue . nsecToMSec ( System . nanoTime ( ) - startTimeNS ) ) ) ; StringBuilder sb = new StringBuilder ( <str> ) . append ( executionTime ) . append ( <str> ) . append ( newClusterState . version ( ) ) . append ( <str> ) . append ( newClusterState . stateUUID ( ) ) . append ( <str> ) . append ( source ) . append ( <str> ) ; sb . append ( newClusterState . nodes ( ) . prettyPrint ( ) ) ; sb . append ( newClusterState . routingTable ( ) . prettyPrint ( ) ) ; sb . append ( newClusterState . getRoutingNodes ( ) . prettyPrint ( ) ) ; logger . warn ( sb . toString ( ) , t ) ; } } class UpdateTask < T > extends SourcePrioritizedRunnable { public final T task ; public final ClusterStateTaskConfig config ; public final ClusterStateTaskExecutor < T > executor ; public final ClusterStateTaskListener listener ; public final AtomicBoolean processed = new AtomicBoolean ( ) ; UpdateTask ( String source , T task , ClusterStateTaskConfig config , ClusterStateTaskExecutor < T > executor , ClusterStateTaskListener listener ) { super ( config . priority ( ) , source ) ; this . task = task ; this . config = config ; this . executor = executor ; this . listener = listener ; } @Override public void run ( ) { runTasksForExecutor ( executor ) ; } } private void warnAboutSlowTaskIfNeeded ( TimeValue executionTime , String source ) { if ( executionTime . getMillis ( ) > slowTaskLoggingThreshold . getMillis ( ) ) { logger . warn ( <str> , source , executionTime , slowTaskLoggingThreshold ) ; } } class NotifyTimeout implements Runnable { final TimeoutClusterStateListener listener ; final TimeValue timeout ; volatile ScheduledFuture future ; NotifyTimeout ( TimeoutClusterStateListener listener , TimeValue timeout ) { this . listener = listener ; this . timeout = timeout ; } public void cancel ( ) { FutureUtils . cancel ( future ) ; } @Override public void run ( ) { if ( future ! = null & & future . isCancelled ( ) ) { return ; } if ( lifecycle . stoppedOrClosed ( ) ) { listener . onClose ( ) ; } else { listener . onTimeout ( this . timeout ) ; } } } private class ReconnectToNodes implements Runnable { private ConcurrentMap < DiscoveryNode , Integer > failureCount = ConcurrentCollections . newConcurrentMap ( ) ; @Override public void run ( ) { for ( DiscoveryNode node : clusterState . nodes ( ) ) { if ( lifecycle . stoppedOrClosed ( ) ) { return ; } if ( ! nodeRequiresConnection ( node ) ) { continue ; } if ( clusterState . nodes ( ) . nodeExists ( node . id ( ) ) ) { if ( ! transportService . nodeConnected ( node ) ) { try { transportService . connectToNode ( node ) ; } catch ( Exception e ) { if ( lifecycle . stoppedOrClosed ( ) ) { return ; } if ( clusterState . nodes ( ) . nodeExists ( node . id ( ) ) ) { Integer nodeFailureCount = failureCount . get ( node ) ; if ( nodeFailureCount = = null ) { nodeFailureCount = <int> ; } else { nodeFailureCount = nodeFailureCount + <int> ; } if ( ( nodeFailureCount % <int> ) = = <int> ) { nodeFailureCount = <int> ; logger . warn ( <str> , e , node ) ; } failureCount . put ( node , nodeFailureCount ) ; } } } } } DiscoveryNodes nodes = clusterState . nodes ( ) ; for ( Iterator < DiscoveryNode > failedNodesIt = failureCount . keySet ( ) . iterator ( ) ; failedNodesIt . hasNext ( ) ; ) { DiscoveryNode failedNode = failedNodesIt . next ( ) ; if ( ! nodes . nodeExists ( failedNode . id ( ) ) ) { failedNodesIt . remove ( ) ; } } if ( lifecycle . started ( ) ) { reconnectToNodes = threadPool . schedule ( reconnectInterval , ThreadPool . Names . GENERIC , this ) ; } } } private boolean nodeRequiresConnection ( DiscoveryNode node ) { return localNode ( ) . shouldConnectTo ( node ) ; } private static class LocalNodeMasterListeners implements ClusterStateListener { private final List < LocalNodeMasterListener > listeners = new CopyOnWriteArrayList < > ( ) ; private final ThreadPool threadPool ; private volatile boolean master = false ; private LocalNodeMasterListeners ( ThreadPool threadPool ) { this . threadPool = threadPool ; } @Override public void clusterChanged ( ClusterChangedEvent event ) { if ( ! master & & event . localNodeMaster ( ) ) { master = true ; for ( LocalNodeMasterListener listener : listeners ) { Executor executor = threadPool . executor ( listener . executorName ( ) ) ; executor . execute ( new OnMasterRunnable ( listener ) ) ; } return ; } if ( master & & ! event . localNodeMaster ( ) ) { master = false ; for ( LocalNodeMasterListener listener : listeners ) { Executor executor = threadPool . executor ( listener . executorName ( ) ) ; executor . execute ( new OffMasterRunnable ( listener ) ) ; } } } private void add ( LocalNodeMasterListener listener ) { listeners . add ( listener ) ; } private void remove ( LocalNodeMasterListener listener ) { listeners . remove ( listener ) ; } private void clear ( ) { listeners . clear ( ) ; } } private static class OnMasterRunnable implements Runnable { private final LocalNodeMasterListener listener ; private OnMasterRunnable ( LocalNodeMasterListener listener ) { this . listener = listener ; } @Override public void run ( ) { listener . onMaster ( ) ; } } private static class OffMasterRunnable implements Runnable { private final LocalNodeMasterListener listener ; private OffMasterRunnable ( LocalNodeMasterListener listener ) { this . listener = listener ; } @Override public void run ( ) { listener . offMaster ( ) ; } } private static class DelegetingAckListener implements Discovery . AckListener { final private List < Discovery . AckListener > listeners ; private DelegetingAckListener ( List < Discovery . AckListener > listeners ) { this . listeners = listeners ; } @Override public void onNodeAck ( DiscoveryNode node , @Nullable Throwable t ) { for ( Discovery . AckListener listener : listeners ) { listener . onNodeAck ( node , t ) ; } } @Override public void onTimeout ( ) { throw new UnsupportedOperationException ( <str> ) ; } } private static class AckCountDownListener implements Discovery . AckListener { private static final ESLogger logger = Loggers . getLogger ( AckCountDownListener . class ) ; private final AckedClusterStateTaskListener ackedTaskListener ; private final CountDown countDown ; private final DiscoveryNodes nodes ; private final long clusterStateVersion ; private final Future < ? > ackTimeoutCallback ; private Throwable lastFailure ; AckCountDownListener ( AckedClusterStateTaskListener ackedTaskListener , long clusterStateVersion , DiscoveryNodes nodes , ThreadPool threadPool ) { this . ackedTaskListener = ackedTaskListener ; this . clusterStateVersion = clusterStateVersion ; this . nodes = nodes ; int countDown = <int> ; for ( DiscoveryNode node : nodes ) { if ( ackedTaskListener . mustAck ( node ) ) { countDown + + ; } } countDown = Math . max ( <int> , countDown ) ; logger . trace ( <str> , countDown , clusterStateVersion ) ; this . countDown = new CountDown ( countDown ) ; this . ackTimeoutCallback = threadPool . schedule ( ackedTaskListener . ackTimeout ( ) , ThreadPool . Names . GENERIC , new Runnable ( ) { @Override public void run ( ) { onTimeout ( ) ; } } ) ; } @Override public void onNodeAck ( DiscoveryNode node , @Nullable Throwable t ) { if ( ! ackedTaskListener . mustAck ( node ) ) { if ( ! node . equals ( nodes . masterNode ( ) ) ) { return ; } } if ( t = = null ) { logger . trace ( <str> , node , clusterStateVersion ) ; } else { this . lastFailure = t ; logger . debug ( <str> , t , node , clusterStateVersion ) ; } if ( countDown . countDown ( ) ) { logger . trace ( <str> , clusterStateVersion ) ; FutureUtils . cancel ( ackTimeoutCallback ) ; ackedTaskListener . onAllNodesAcked ( lastFailure ) ; } } @Override public void onTimeout ( ) { if ( countDown . fastForward ( ) ) { logger . trace ( <str> , clusterStateVersion ) ; ackedTaskListener . onAckTimeout ( ) ; } } } class ApplySettings implements NodeSettingsService . Listener { @Override public void onRefreshSettings ( Settings settings ) { final TimeValue slowTaskLoggingThreshold = settings . getAsTime ( SETTING_CLUSTER_SERVICE_SLOW_TASK_LOGGING_THRESHOLD , InternalClusterService . this . slowTaskLoggingThreshold ) ; InternalClusterService . this . slowTaskLoggingThreshold = slowTaskLoggingThreshold ; } } } 
