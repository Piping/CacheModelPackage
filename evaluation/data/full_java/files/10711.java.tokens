package org . gradle . build . docs . dsl . docbook ; import org . gradle . api . GradleException ; import org . gradle . build . docs . dsl . source . model . ClassMetaData ; import org . gradle . build . docs . dsl . source . model . MethodMetaData ; import org . gradle . build . docs . dsl . source . model . PropertyMetaData ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . Text ; import java . util . * ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class JavadocConverter { private static final Pattern HEADER_PATTERN = Pattern . compile ( <str> , Pattern . CASE_INSENSITIVE ) ; private final Document document ; private final JavadocLinkConverter linkConverter ; public JavadocConverter ( Document document , JavadocLinkConverter linkConverter ) { this . document = document ; this . linkConverter = linkConverter ; } public DocComment parse ( ClassMetaData classMetaData , GenerationListener listener ) { listener . start ( String . format ( <str> , classMetaData ) ) ; try { String rawCommentText = classMetaData . getRawCommentText ( ) ; try { return parse ( rawCommentText , classMetaData , new NoOpCommentSource ( ) , listener ) ; } catch ( Exception e ) { throw new GradleException ( String . format ( <str> , classMetaData , rawCommentText ) , e ) ; } } finally { listener . finish ( ) ; } } public DocComment parse ( final PropertyMetaData propertyMetaData , final GenerationListener listener ) { listener . start ( String . format ( <str> , propertyMetaData ) ) ; try { ClassMetaData ownerClass = propertyMetaData . getOwnerClass ( ) ; String rawCommentText = propertyMetaData . getRawCommentText ( ) ; try { CommentSource commentSource = new InheritedPropertyCommentSource ( propertyMetaData , listener ) ; DocCommentImpl docComment = parse ( rawCommentText , ownerClass , commentSource , listener ) ; adjustGetterComment ( docComment ) ; return docComment ; } catch ( Exception e ) { throw new GradleException ( String . format ( <str> , ownerClass . getClassName ( ) , propertyMetaData . getName ( ) , rawCommentText ) , e ) ; } } finally { listener . finish ( ) ; } } public DocComment parse ( final MethodMetaData methodMetaData , final GenerationListener listener ) { listener . start ( String . format ( <str> , methodMetaData ) ) ; try { ClassMetaData ownerClass = methodMetaData . getOwnerClass ( ) ; String rawCommentText = methodMetaData . getRawCommentText ( ) ; try { CommentSource commentSource = new InheritedMethodCommentSource ( listener , methodMetaData ) ; return parse ( rawCommentText , ownerClass , commentSource , listener ) ; } catch ( Exception e ) { throw new GradleException ( String . format ( <str> , ownerClass . getClassName ( ) , methodMetaData . getSignature ( ) , rawCommentText ) , e ) ; } } finally { listener . finish ( ) ; } } private void adjustGetterComment ( DocCommentImpl docComment ) { List < Element > nodes = docComment . getDocbook ( ) ; if ( nodes . isEmpty ( ) ) { return ; } Element firstNode = nodes . get ( <int> ) ; if ( ! firstNode . getNodeName ( ) . equals ( <str> ) | | ! ( firstNode . getFirstChild ( ) instanceof Text ) ) { return ; } Text comment = ( Text ) firstNode . getFirstChild ( ) ; Pattern getterPattern = Pattern . compile ( <str> , Pattern . CASE_INSENSITIVE ) ; Matcher matcher = getterPattern . matcher ( comment . getData ( ) ) ; if ( matcher . lookingAt ( ) ) { comment . setData ( <str> + comment . getData ( ) . substring ( matcher . end ( ) ) ) ; } } private DocCommentImpl parse ( String rawCommentText , ClassMetaData classMetaData , CommentSource inheritedCommentSource , GenerationListener listener ) { JavadocLexer lexer = new HtmlToXmlJavadocLexer ( new BasicJavadocLexer ( new JavadocScanner ( rawCommentText ) ) ) ; DocBookBuilder nodes = new DocBookBuilder ( document ) ; final HtmlGeneratingTokenHandler handler = new HtmlGeneratingTokenHandler ( nodes , document ) ; handler . add ( new HtmlElementTranslatingHandler ( nodes , document ) ) ; handler . add ( new PreElementHandler ( nodes , document ) ) ; handler . add ( new JavadocTagToElementTranslatingHandler ( nodes , document ) ) ; handler . add ( new HeaderHandler ( nodes , document ) ) ; handler . add ( new LinkHandler ( nodes , linkConverter , classMetaData , listener ) ) ; handler . add ( new InheritDocHandler ( nodes , inheritedCommentSource ) ) ; handler . add ( new ValueTagHandler ( nodes , linkConverter , classMetaData , listener ) ) ; handler . add ( new LiteralTagHandler ( nodes ) ) ; handler . add ( new TableHandler ( nodes , document ) ) ; handler . add ( new DlElementHandler ( nodes , document ) ) ; handler . add ( new AnchorElementHandler ( nodes , document , classMetaData ) ) ; handler . add ( new AToLinkTranslatingHandler ( nodes , document , classMetaData ) ) ; handler . add ( new AToUlinkTranslatingHandler ( nodes , document ) ) ; handler . add ( new UnknownJavadocTagHandler ( nodes , document , listener ) ) ; handler . add ( new UnknownHtmlElementHandler ( nodes , document , listener ) ) ; lexer . visit ( handler ) ; return new DocCommentImpl ( nodes . getElements ( ) ) ; } private static class DocCommentImpl implements DocComment { private final List < Element > nodes ; public DocCommentImpl ( List < Element > nodes ) { this . nodes = nodes ; } public List < Element > getDocbook ( ) { return nodes ; } } private static class HtmlGeneratingTokenHandler extends JavadocLexer . TokenVisitor { final DocBookBuilder nodes ; final List < HtmlElementHandler > elementHandlers = new ArrayList < HtmlElementHandler > ( ) ; final List < JavadocTagHandler > tagHandlers = new ArrayList < JavadocTagHandler > ( ) ; final LinkedList < HtmlElementHandler > handlerStack = new LinkedList < HtmlElementHandler > ( ) ; final LinkedList < String > tagStack = new LinkedList < String > ( ) ; final Map < String , String > attributes = new HashMap < String , String > ( ) ; StringBuilder tagValue ; final Document document ; public HtmlGeneratingTokenHandler ( DocBookBuilder nodes , Document document ) { this . nodes = nodes ; this . document = document ; } public void add ( HtmlElementHandler handler ) { elementHandlers . add ( handler ) ; } public void add ( JavadocTagHandler handler ) { tagHandlers . add ( handler ) ; } @Override void onStartHtmlElement ( String name ) { attributes . clear ( ) ; } @Override void onHtmlElementAttribute ( String name , String value ) { attributes . put ( name , value ) ; } @Override void onStartHtmlElementComplete ( String name ) { for ( HtmlElementHandler handler : elementHandlers ) { if ( handler . onStartElement ( name , attributes ) ) { handlerStack . addFirst ( handler ) ; tagStack . addFirst ( name ) ; return ; } } throw new UnsupportedOperationException ( ) ; } @Override void onEndHtmlElement ( String name ) { if ( ! tagStack . isEmpty ( ) & & tagStack . getFirst ( ) . equals ( name ) ) { tagStack . removeFirst ( ) ; handlerStack . removeFirst ( ) . onEndElement ( name ) ; } } @Override void onStartJavadocTag ( String name ) { tagValue = new StringBuilder ( ) ; } public void onText ( String text ) { if ( tagValue ! = null ) { tagValue . append ( text ) ; return ; } if ( ! handlerStack . isEmpty ( ) ) { handlerStack . getFirst ( ) . onText ( text ) ; return ; } nodes . appendChild ( text ) ; } @Override void onEndJavadocTag ( String name ) { for ( JavadocTagHandler handler : tagHandlers ) { if ( handler . onJavadocTag ( name , tagValue . toString ( ) ) ) { tagValue = null ; return ; } } throw new UnsupportedOperationException ( ) ; } } private interface JavadocTagHandler { boolean onJavadocTag ( String tag , String value ) ; } private interface HtmlElementHandler { boolean onStartElement ( String element , Map < String , String > attributes ) ; void onText ( String text ) ; void onEndElement ( String element ) ; } private static class UnknownJavadocTagHandler implements JavadocTagHandler { private final DocBookBuilder nodes ; private final Document document ; private final GenerationListener listener ; private UnknownJavadocTagHandler ( DocBookBuilder nodes , Document document , GenerationListener listener ) { this . nodes = nodes ; this . document = document ; this . listener = listener ; } public boolean onJavadocTag ( String tag , String value ) { listener . warning ( String . format ( <str> , tag ) ) ; Element element = document . createElement ( <str> ) ; element . appendChild ( document . createTextNode ( String . format ( <str> , tag , value ) ) ) ; nodes . appendChild ( element ) ; return true ; } } private static class UnknownHtmlElementHandler implements HtmlElementHandler { private final DocBookBuilder nodes ; private final Document document ; private final GenerationListener listener ; private UnknownHtmlElementHandler ( DocBookBuilder nodes , Document document , GenerationListener listener ) { this . nodes = nodes ; this . document = document ; this . listener = listener ; } public boolean onStartElement ( String elementName , Map < String , String > attributes ) { listener . warning ( String . format ( <str> , elementName ) ) ; Element element = document . createElement ( <str> ) ; element . appendChild ( document . createTextNode ( String . format ( <str> , elementName ) ) ) ; nodes . push ( element ) ; return true ; } public void onText ( String text ) { nodes . appendChild ( text ) ; } public void onEndElement ( String elementName ) { nodes . appendChild ( String . format ( <str> , elementName ) ) ; nodes . pop ( ) ; } } private static class JavadocTagToElementTranslatingHandler implements JavadocTagHandler { private final DocBookBuilder nodes ; private final Document document ; private final Map < String , String > tagToElementMap = new HashMap < String , String > ( ) ; private JavadocTagToElementTranslatingHandler ( DocBookBuilder nodes , Document document ) { this . nodes = nodes ; this . document = document ; tagToElementMap . put ( <str> , <str> ) ; } public boolean onJavadocTag ( String tag , String value ) { String elementName = tagToElementMap . get ( tag ) ; if ( elementName = = null ) { return false ; } Element element = document . createElement ( elementName ) ; element . appendChild ( document . createTextNode ( value ) ) ; nodes . appendChild ( element ) ; return true ; } } private static class HtmlElementTranslatingHandler implements HtmlElementHandler { private final DocBookBuilder nodes ; private final Document document ; private final Map < String , String > elementToElementMap = new HashMap < String , String > ( ) ; private HtmlElementTranslatingHandler ( DocBookBuilder nodes , Document document ) { this . nodes = nodes ; this . document = document ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; elementToElementMap . put ( <str> , <str> ) ; } public boolean onStartElement ( String element , Map < String , String > attributes ) { String newElementName = elementToElementMap . get ( element ) ; if ( newElementName = = null ) { return false ; } nodes . push ( document . createElement ( newElementName ) ) ; return true ; } public void onText ( String text ) { nodes . appendChild ( text ) ; } public void onEndElement ( String element ) { nodes . pop ( ) ; } } private static class PreElementHandler implements HtmlElementHandler { private final DocBookBuilder nodes ; private final Document document ; private PreElementHandler ( DocBookBuilder nodes , Document document ) { this . nodes = nodes ; this . document = document ; } public boolean onStartElement ( String element , Map < String , String > attributes ) { if ( ! <str> . equals ( element ) ) { return false ; } Element newElement = document . createElement ( <str> ) ; newElement . setAttribute ( <str> , <str> ) ; nodes . push ( newElement ) ; return true ; } public void onText ( String text ) { nodes . appendChild ( text ) ; } public void onEndElement ( String element ) { nodes . pop ( ) ; } } private static class HeaderHandler implements HtmlElementHandler { final DocBookBuilder nodes ; final Document document ; int sectionDepth ; private HeaderHandler ( DocBookBuilder nodes , Document document ) { this . nodes = nodes ; this . document = document ; } public boolean onStartElement ( String element , Map < String , String > attributes ) { Matcher matcher = HEADER_PATTERN . matcher ( element ) ; if ( ! matcher . matches ( ) ) { return false ; } int depth = Integer . parseInt ( matcher . group ( <int> ) ) ; if ( sectionDepth = = <int> ) { sectionDepth = depth - <int> ; } while ( sectionDepth > = depth ) { nodes . pop ( ) ; sectionDepth - - ; } Element section = document . createElement ( <str> ) ; while ( sectionDepth < depth ) { nodes . push ( section ) ; sectionDepth + + ; } nodes . push ( document . createElement ( <str> ) ) ; sectionDepth = depth ; return true ; } public void onText ( String text ) { nodes . appendChild ( text ) ; } public void onEndElement ( String element ) { nodes . pop ( ) ; } } private static class TableHandler implements HtmlElementHandler { private final DocBookBuilder nodes ; private final Document document ; private Element currentTable ; private Element currentRow ; private Element header ; public TableHandler ( DocBookBuilder nodes , Document document ) { this . nodes = nodes ; this . document = document ; } public boolean onStartElement ( String elementName , Map < String , String > attributes ) { if ( elementName . equals ( <str> ) ) { if ( currentTable ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } currentTable = document . createElement ( <str> ) ; nodes . push ( currentTable ) ; return true ; } if ( elementName . equals ( <str> ) ) { currentRow = document . createElement ( <str> ) ; nodes . push ( currentRow ) ; return true ; } if ( elementName . equals ( <str> ) ) { if ( header = = null ) { header = document . createElement ( <str> ) ; currentTable . insertBefore ( header , null ) ; header . appendChild ( currentRow ) ; } nodes . push ( document . createElement ( <str> ) ) ; return true ; } if ( elementName . equals ( <str> ) ) { nodes . push ( document . createElement ( <str> ) ) ; return true ; } return false ; } public void onEndElement ( String elementName ) { if ( elementName . equals ( <str> ) ) { currentTable = null ; header = null ; } if ( elementName . equals ( <str> ) ) { currentRow = null ; } nodes . pop ( ) ; } public void onText ( String text ) { nodes . appendChild ( text ) ; } } private static class AnchorElementHandler implements HtmlElementHandler { private final DocBookBuilder nodes ; private final Document document ; private final ClassMetaData classMetaData ; private AnchorElementHandler ( DocBookBuilder nodes , Document document , ClassMetaData classMetaData ) { this . nodes = nodes ; this . document = document ; this . classMetaData = classMetaData ; } public boolean onStartElement ( String elementName , Map < String , String > attributes ) { if ( ! elementName . equals ( <str> ) | | ! attributes . containsKey ( <str> ) ) { return false ; } Element element = document . createElement ( <str> ) ; String id = String . format ( <str> , classMetaData . getClassName ( ) , attributes . get ( <str> ) ) ; element . setAttribute ( <str> , id ) ; nodes . appendChild ( element ) ; return true ; } public void onEndElement ( String element ) { } public void onText ( String text ) { } } private static class AToLinkTranslatingHandler implements HtmlElementHandler { private final DocBookBuilder nodes ; private final Document document ; private final ClassMetaData classMetaData ; private AToLinkTranslatingHandler ( DocBookBuilder nodes , Document document , ClassMetaData classMetaData ) { this . nodes = nodes ; this . document = document ; this . classMetaData = classMetaData ; } public boolean onStartElement ( String elementName , Map < String , String > attributes ) { if ( ! elementName . equals ( <str> ) | | ! attributes . containsKey ( <str> ) ) { return false ; } String href = attributes . get ( <str> ) ; if ( ! href . startsWith ( <str> ) ) { return false ; } Element element = document . createElement ( <str> ) ; String targetId = String . format ( <str> , classMetaData . getClassName ( ) , href . substring ( <int> ) ) ; element . setAttribute ( <str> , targetId ) ; nodes . push ( element ) ; return true ; } public void onEndElement ( String element ) { nodes . pop ( ) ; } public void onText ( String text ) { nodes . appendChild ( text ) ; } } private static class AToUlinkTranslatingHandler implements HtmlElementHandler { private final DocBookBuilder nodes ; private final Document document ; private AToUlinkTranslatingHandler ( DocBookBuilder nodes , Document document ) { this . nodes = nodes ; this . document = document ; } public boolean onStartElement ( String elementName , Map < String , String > attributes ) { if ( ! elementName . equals ( <str> ) | | ! attributes . containsKey ( <str> ) ) { return false ; } String href = attributes . get ( <str> ) ; if ( href . startsWith ( <str> ) ) { return false ; } Element element = document . createElement ( <str> ) ; element . setAttribute ( <str> , href ) ; nodes . push ( element ) ; return true ; } public void onEndElement ( String element ) { nodes . pop ( ) ; } public void onText ( String text ) { nodes . appendChild ( text ) ; } } private static class DlElementHandler implements HtmlElementHandler { private final DocBookBuilder nodes ; private final Document document ; private Element currentList ; private Element currentItem ; public DlElementHandler ( DocBookBuilder nodes , Document document ) { this . nodes = nodes ; this . document = document ; } public boolean onStartElement ( String elementName , Map < String , String > attributes ) { if ( elementName . equals ( <str> ) ) { if ( currentList ! = null ) { throw new UnsupportedOperationException ( <str> ) ; } currentList = document . createElement ( <str> ) ; nodes . push ( currentList ) ; return true ; } if ( elementName . equals ( <str> ) ) { if ( currentItem ! = null ) { nodes . pop ( ) ; } currentItem = document . createElement ( <str> ) ; nodes . push ( currentItem ) ; nodes . push ( document . createElement ( <str> ) ) ; return true ; } if ( elementName . equals ( <str> ) ) { if ( currentItem = = null ) { throw new IllegalStateException ( <str> ) ; } nodes . push ( document . createElement ( <str> ) ) ; return true ; } return false ; } public void onEndElement ( String element ) { if ( element . equals ( <str> ) ) { currentList = null ; if ( currentItem ! = null ) { currentItem = null ; nodes . pop ( ) ; } nodes . pop ( ) ; } if ( element . equals ( <str> ) ) { nodes . pop ( ) ; } if ( element . equals ( <str> ) ) { nodes . pop ( ) ; } } public void onText ( String text ) { nodes . appendChild ( text ) ; } } private static class ValueTagHandler implements JavadocTagHandler { private final JavadocLinkConverter linkConverter ; private final ClassMetaData classMetaData ; private final DocBookBuilder nodes ; private final GenerationListener listener ; public ValueTagHandler ( DocBookBuilder nodes , JavadocLinkConverter linkConverter , ClassMetaData classMetaData , GenerationListener listener ) { this . nodes = nodes ; this . linkConverter = linkConverter ; this . classMetaData = classMetaData ; this . listener = listener ; } public boolean onJavadocTag ( String tag , String value ) { if ( ! tag . equals ( <str> ) ) { return false ; } nodes . appendChild ( linkConverter . resolveValue ( value , classMetaData , listener ) ) ; return true ; } } private static class LiteralTagHandler implements JavadocTagHandler { private final DocBookBuilder nodes ; private LiteralTagHandler ( DocBookBuilder nodes ) { this . nodes = nodes ; } public boolean onJavadocTag ( String tag , String value ) { if ( ! tag . equals ( <str> ) ) { return false ; } nodes . appendChild ( value ) ; return true ; } } private static class LinkHandler implements JavadocTagHandler { private final DocBookBuilder nodes ; private final JavadocLinkConverter linkConverter ; private final ClassMetaData classMetaData ; private final GenerationListener listener ; private LinkHandler ( DocBookBuilder nodes , JavadocLinkConverter linkConverter , ClassMetaData classMetaData , GenerationListener listener ) { this . nodes = nodes ; this . linkConverter = linkConverter ; this . classMetaData = classMetaData ; this . listener = listener ; } public boolean onJavadocTag ( String tag , String value ) { if ( ! tag . equals ( <str> ) ) { return false ; } nodes . appendChild ( linkConverter . resolve ( value , classMetaData , listener ) ) ; return true ; } } private static class InheritDocHandler implements JavadocTagHandler { private final CommentSource source ; private final DocBookBuilder nodeStack ; private InheritDocHandler ( DocBookBuilder nodeStack , CommentSource source ) { this . nodeStack = nodeStack ; this . source = source ; } public boolean onJavadocTag ( String tag , String value ) { if ( ! tag . equals ( <str> ) ) { return false ; } for ( Node node : source . getCommentText ( ) ) { nodeStack . appendChild ( node ) ; } return true ; } } private interface CommentSource { Iterable < ? extends Node > getCommentText ( ) ; } private static class NoOpCommentSource implements CommentSource { public List < ? extends Node > getCommentText ( ) { throw new UnsupportedOperationException ( ) ; } } private class InheritedPropertyCommentSource implements CommentSource { private final PropertyMetaData propertyMetaData ; private final GenerationListener listener ; public InheritedPropertyCommentSource ( PropertyMetaData propertyMetaData , GenerationListener listener ) { this . propertyMetaData = propertyMetaData ; this . listener = listener ; } public Iterable < ? extends Node > getCommentText ( ) { PropertyMetaData overriddenProperty = propertyMetaData . getOverriddenProperty ( ) ; if ( overriddenProperty = = null ) { listener . warning ( <str> ) ; return Arrays . asList ( document . createTextNode ( <str> ) ) ; } return parse ( overriddenProperty , listener ) . getDocbook ( ) ; } } private class InheritedMethodCommentSource implements CommentSource { private final GenerationListener listener ; private final MethodMetaData methodMetaData ; public InheritedMethodCommentSource ( GenerationListener listener , MethodMetaData methodMetaData ) { this . listener = listener ; this . methodMetaData = methodMetaData ; } public Iterable < ? extends Node > getCommentText ( ) { MethodMetaData overriddenMethod = methodMetaData . getOverriddenMethod ( ) ; if ( overriddenMethod = = null ) { listener . warning ( <str> ) ; return Arrays . asList ( document . createTextNode ( <str> ) ) ; } return parse ( overriddenMethod , listener ) . getDocbook ( ) ; } } } 
