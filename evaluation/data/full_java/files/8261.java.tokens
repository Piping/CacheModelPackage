package org . elasticsearch . index . query ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . * ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . metadata . MetaData ; import java . io . IOException ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Locale ; import java . util . Map ; import java . util . Set ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . notNullValue ; public class SimpleQueryStringBuilderTests extends AbstractQueryTestCase < SimpleQueryStringBuilder > { @Override protected SimpleQueryStringBuilder doCreateTestQueryBuilder ( ) { SimpleQueryStringBuilder result = new SimpleQueryStringBuilder ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; if ( randomBoolean ( ) ) { result . analyzeWildcard ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { result . lenient ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { result . lowercaseExpandedTerms ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { result . locale ( randomLocale ( getRandom ( ) ) ) ; } if ( randomBoolean ( ) ) { result . minimumShouldMatch ( randomMinimumShouldMatch ( ) ) ; } if ( randomBoolean ( ) ) { result . analyzer ( randomAnalyzer ( ) ) ; } if ( randomBoolean ( ) ) { result . defaultOperator ( randomFrom ( Operator . values ( ) ) ) ; } if ( randomBoolean ( ) ) { Set < SimpleQueryStringFlag > flagSet = new HashSet < > ( ) ; int size = randomIntBetween ( <int> , SimpleQueryStringFlag . values ( ) . length ) ; for ( int i = <int> ; i < size ; i + + ) { flagSet . add ( randomFrom ( SimpleQueryStringFlag . values ( ) ) ) ; } if ( flagSet . size ( ) > <int> ) { result . flags ( flagSet . toArray ( new SimpleQueryStringFlag [ flagSet . size ( ) ] ) ) ; } } int fieldCount = randomIntBetween ( <int> , <int> ) ; Map < String , Float > fields = new HashMap < > ( ) ; for ( int i = <int> ; i < fieldCount ; i + + ) { if ( randomBoolean ( ) ) { fields . put ( randomAsciiOfLengthBetween ( <int> , <int> ) , AbstractQueryBuilder . DEFAULT_BOOST ) ; } else { fields . put ( randomBoolean ( ) ? STRING_FIELD_NAME : randomAsciiOfLengthBetween ( <int> , <int> ) , <float> / randomIntBetween ( <int> , <int> ) ) ; } } result . fields ( fields ) ; return result ; } public void testDefaults ( ) { SimpleQueryStringBuilder qb = new SimpleQueryStringBuilder ( <str> ) ; assertEquals ( <str> , AbstractQueryBuilder . DEFAULT_BOOST , qb . boost ( ) , <float> ) ; assertEquals ( <str> , AbstractQueryBuilder . DEFAULT_BOOST , SimpleQueryStringBuilder . DEFAULT_BOOST , <float> ) ; assertEquals ( <str> , SimpleQueryStringFlag . ALL . value , qb . flags ( ) ) ; assertEquals ( <str> , SimpleQueryStringFlag . ALL . value ( ) , SimpleQueryStringBuilder . DEFAULT_FLAGS ) ; assertEquals ( <str> , Operator . OR , qb . defaultOperator ( ) ) ; assertEquals ( <str> , Operator . OR , SimpleQueryStringBuilder . DEFAULT_OPERATOR ) ; assertEquals ( <str> , Locale . ROOT , qb . locale ( ) ) ; assertEquals ( <str> , Locale . ROOT , SimpleQueryStringBuilder . DEFAULT_LOCALE ) ; assertEquals ( <str> , false , qb . analyzeWildcard ( ) ) ; assertEquals ( <str> , false , SimpleQueryStringBuilder . DEFAULT_ANALYZE_WILDCARD ) ; assertEquals ( <str> , true , qb . lowercaseExpandedTerms ( ) ) ; assertEquals ( <str> , true , SimpleQueryStringBuilder . DEFAULT_LOWERCASE_EXPANDED_TERMS ) ; assertEquals ( <str> , false , qb . lenient ( ) ) ; assertEquals ( <str> , false , SimpleQueryStringBuilder . DEFAULT_LENIENT ) ; assertEquals ( <str> , Locale . ROOT , qb . locale ( ) ) ; assertEquals ( <str> , Locale . ROOT , SimpleQueryStringBuilder . DEFAULT_LOCALE ) ; } public void testDefaultNullLocale ( ) { SimpleQueryStringBuilder qb = new SimpleQueryStringBuilder ( <str> ) ; qb . locale ( null ) ; assertEquals ( <str> , SimpleQueryStringBuilder . DEFAULT_LOCALE , qb . locale ( ) ) ; } public void testDefaultNullComplainFlags ( ) { SimpleQueryStringBuilder qb = new SimpleQueryStringBuilder ( <str> ) ; qb . flags ( ( SimpleQueryStringFlag [ ] ) null ) ; assertEquals ( <str> , SimpleQueryStringBuilder . DEFAULT_FLAGS , qb . flags ( ) ) ; } public void testDefaultEmptyComplainFlags ( ) { SimpleQueryStringBuilder qb = new SimpleQueryStringBuilder ( <str> ) ; qb . flags ( new SimpleQueryStringFlag [ ] { } ) ; assertEquals ( <str> , SimpleQueryStringBuilder . DEFAULT_FLAGS , qb . flags ( ) ) ; } public void testDefaultNullComplainOp ( ) { SimpleQueryStringBuilder qb = new SimpleQueryStringBuilder ( <str> ) ; qb . defaultOperator ( null ) ; assertEquals ( <str> , SimpleQueryStringBuilder . DEFAULT_OPERATOR , qb . defaultOperator ( ) ) ; } public void testDefaultOperatorHandling ( ) throws IOException { SimpleQueryStringBuilder qb = new SimpleQueryStringBuilder ( <str> ) . field ( STRING_FIELD_NAME ) ; QueryShardContext shardContext = createShardContext ( ) ; shardContext . setAllowUnmappedFields ( true ) ; BooleanQuery boolQuery = ( BooleanQuery ) qb . toQuery ( shardContext ) ; assertThat ( shouldClauses ( boolQuery ) , is ( <int> ) ) ; qb . defaultOperator ( Operator . AND ) ; boolQuery = ( BooleanQuery ) qb . toQuery ( shardContext ) ; assertThat ( shouldClauses ( boolQuery ) , is ( <int> ) ) ; qb . defaultOperator ( Operator . OR ) ; boolQuery = ( BooleanQuery ) qb . toQuery ( shardContext ) ; assertThat ( shouldClauses ( boolQuery ) , is ( <int> ) ) ; } public void testIllegalConstructorArg ( ) { try { new SimpleQueryStringBuilder ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testFieldCannotBeNull ( ) { SimpleQueryStringBuilder qb = createTestQueryBuilder ( ) ; try { qb . field ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testFieldCannotBeNullAndWeighted ( ) { SimpleQueryStringBuilder qb = createTestQueryBuilder ( ) ; try { qb . field ( null , AbstractQueryBuilder . DEFAULT_BOOST ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testFieldCannotBeEmpty ( ) { SimpleQueryStringBuilder qb = createTestQueryBuilder ( ) ; try { qb . field ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testFieldCannotBeEmptyAndWeighted ( ) { SimpleQueryStringBuilder qb = createTestQueryBuilder ( ) ; try { qb . field ( <str> , AbstractQueryBuilder . DEFAULT_BOOST ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testFieldsCannotBeSetToNull ( ) { SimpleQueryStringBuilder qb = createTestQueryBuilder ( ) ; try { qb . fields ( null ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testDefaultFieldParsing ( ) throws IOException { String query = randomAsciiOfLengthBetween ( <int> , <int> ) . toLowerCase ( Locale . ROOT ) ; String contentString = <str> + <str> + <str> + query + <str> + <str> + <str> ; SimpleQueryStringBuilder queryBuilder = ( SimpleQueryStringBuilder ) parseQuery ( contentString ) ; assertThat ( queryBuilder . value ( ) , equalTo ( query ) ) ; assertThat ( queryBuilder . fields ( ) , notNullValue ( ) ) ; assertThat ( queryBuilder . fields ( ) . size ( ) , equalTo ( <int> ) ) ; QueryShardContext shardContext = createShardContext ( ) ; if ( getCurrentTypes ( ) . length > <int> | | shardContext . indexVersionCreated ( ) . before ( Version . V_1_4_0_Beta1 ) ) { Query luceneQuery = queryBuilder . toQuery ( shardContext ) ; assertThat ( luceneQuery , instanceOf ( TermQuery . class ) ) ; TermQuery termQuery = ( TermQuery ) luceneQuery ; assertThat ( termQuery . getTerm ( ) , equalTo ( new Term ( MetaData . ALL , query ) ) ) ; } } @Override protected void doAssertLuceneQuery ( SimpleQueryStringBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { assertThat ( query , notNullValue ( ) ) ; if ( <str> . equals ( queryBuilder . value ( ) ) ) { assertThat ( query , instanceOf ( MatchNoDocsQuery . class ) ) ; } else if ( queryBuilder . fields ( ) . size ( ) > <int> ) { assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery boolQuery = ( BooleanQuery ) query ; if ( queryBuilder . lowercaseExpandedTerms ( ) ) { for ( BooleanClause clause : boolQuery . clauses ( ) ) { if ( clause . getQuery ( ) instanceof TermQuery ) { TermQuery inner = ( TermQuery ) clause . getQuery ( ) ; assertThat ( inner . getTerm ( ) . bytes ( ) . toString ( ) , is ( inner . getTerm ( ) . bytes ( ) . toString ( ) . toLowerCase ( Locale . ROOT ) ) ) ; } } } assertThat ( boolQuery . clauses ( ) . size ( ) , equalTo ( queryBuilder . fields ( ) . size ( ) ) ) ; Iterator < Map . Entry < String , Float > > fieldsIterator = queryBuilder . fields ( ) . entrySet ( ) . iterator ( ) ; for ( BooleanClause booleanClause : boolQuery ) { Map . Entry < String , Float > field = fieldsIterator . next ( ) ; assertTermOrBoostQuery ( booleanClause . getQuery ( ) , field . getKey ( ) , queryBuilder . value ( ) , field . getValue ( ) ) ; } if ( queryBuilder . minimumShouldMatch ( ) ! = null ) { assertThat ( boolQuery . getMinimumNumberShouldMatch ( ) , greaterThan ( <int> ) ) ; } } else if ( queryBuilder . fields ( ) . size ( ) = = <int> ) { Map . Entry < String , Float > field = queryBuilder . fields ( ) . entrySet ( ) . iterator ( ) . next ( ) ; assertTermOrBoostQuery ( query , field . getKey ( ) , queryBuilder . value ( ) , field . getValue ( ) ) ; } else if ( queryBuilder . fields ( ) . size ( ) = = <int> ) { assertTermQuery ( query , MetaData . ALL , queryBuilder . value ( ) ) ; } else { fail ( <str> + SimpleQueryStringBuilderTests . class . getSimpleName ( ) ) ; } } private static int shouldClauses ( BooleanQuery query ) { int result = <int> ; for ( BooleanClause c : query . clauses ( ) ) { if ( c . getOccur ( ) = = BooleanClause . Occur . SHOULD ) { result + + ; } } return result ; } public void testToQueryBoost ( ) throws IOException { assumeTrue ( <str> , getCurrentTypes ( ) . length > <int> ) ; QueryShardContext shardContext = createShardContext ( ) ; SimpleQueryStringBuilder simpleQueryStringBuilder = new SimpleQueryStringBuilder ( <str> ) ; simpleQueryStringBuilder . field ( STRING_FIELD_NAME , <int> ) ; Query query = simpleQueryStringBuilder . toQuery ( shardContext ) ; assertThat ( query , instanceOf ( BoostQuery . class ) ) ; BoostQuery boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; assertThat ( boostQuery . getQuery ( ) , instanceOf ( TermQuery . class ) ) ; simpleQueryStringBuilder = new SimpleQueryStringBuilder ( <str> ) ; simpleQueryStringBuilder . field ( STRING_FIELD_NAME , <int> ) ; simpleQueryStringBuilder . boost ( <int> ) ; query = simpleQueryStringBuilder . toQuery ( shardContext ) ; boostQuery = ( BoostQuery ) query ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; assertThat ( boostQuery . getQuery ( ) , instanceOf ( BoostQuery . class ) ) ; boostQuery = ( BoostQuery ) boostQuery . getQuery ( ) ; assertThat ( boostQuery . getBoost ( ) , equalTo ( <float> ) ) ; assertThat ( boostQuery . getQuery ( ) , instanceOf ( TermQuery . class ) ) ; } public void testNegativeFlags ( ) throws IOException { String query = <str> ; SimpleQueryStringBuilder builder = new SimpleQueryStringBuilder ( <str> ) ; builder . flags ( SimpleQueryStringFlag . ALL ) ; assertParsedQuery ( query , builder ) ; SimpleQueryStringBuilder otherBuilder = new SimpleQueryStringBuilder ( <str> ) ; otherBuilder . flags ( - <int> ) ; assertThat ( builder , equalTo ( otherBuilder ) ) ; } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; SimpleQueryStringBuilder parsed = ( SimpleQueryStringBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <str> , parsed . value ( ) ) ; assertEquals ( json , <int> , parsed . fields ( ) . size ( ) ) ; assertEquals ( json , <str> , parsed . analyzer ( ) ) ; } } 
