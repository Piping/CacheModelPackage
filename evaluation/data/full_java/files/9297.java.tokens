package com . google . common . collect ; import static com . google . common . base . Preconditions . checkArgument ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . CollectPreconditions . checkNonnegative ; import static com . google . common . collect . CollectPreconditions . checkRemove ; import com . google . common . annotations . Beta ; import com . google . common . annotations . GwtCompatible ; import com . google . common . base . Objects ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . collect . Multiset . Entry ; import com . google . common . primitives . Ints ; import java . io . Serializable ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . NoSuchElementException ; import java . util . Set ; import javax . annotation . CheckReturnValue ; import javax . annotation . Nullable ; @GwtCompatible public final class Multisets { private Multisets ( ) { } public static < E > Multiset < E > unmodifiableMultiset ( Multiset < ? extends E > multiset ) { if ( multiset instanceof UnmodifiableMultiset | | multiset instanceof ImmutableMultiset ) { @SuppressWarnings ( <str> ) Multiset < E > result = ( Multiset < E > ) multiset ; return result ; } return new UnmodifiableMultiset < E > ( checkNotNull ( multiset ) ) ; } @Deprecated public static < E > Multiset < E > unmodifiableMultiset ( ImmutableMultiset < E > multiset ) { return checkNotNull ( multiset ) ; } static class UnmodifiableMultiset < E > extends ForwardingMultiset < E > implements Serializable { final Multiset < ? extends E > delegate ; UnmodifiableMultiset ( Multiset < ? extends E > delegate ) { this . delegate = delegate ; } @SuppressWarnings ( <str> ) @Override protected Multiset < E > delegate ( ) { return ( Multiset < E > ) delegate ; } transient Set < E > elementSet ; Set < E > createElementSet ( ) { return Collections . < E > unmodifiableSet ( delegate . elementSet ( ) ) ; } @Override public Set < E > elementSet ( ) { Set < E > es = elementSet ; return ( es = = null ) ? elementSet = createElementSet ( ) : es ; } transient Set < Multiset . Entry < E > > entrySet ; @SuppressWarnings ( <str> ) @Override public Set < Multiset . Entry < E > > entrySet ( ) { Set < Multiset . Entry < E > > es = entrySet ; return ( es = = null ) ? entrySet = ( Set ) Collections . unmodifiableSet ( delegate . entrySet ( ) ) : es ; } @SuppressWarnings ( <str> ) @Override public Iterator < E > iterator ( ) { return ( Iterator < E > ) Iterators . unmodifiableIterator ( delegate . iterator ( ) ) ; } @Override public boolean add ( E element ) { throw new UnsupportedOperationException ( ) ; } @Override public int add ( E element , int occurences ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean addAll ( Collection < ? extends E > elementsToAdd ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean remove ( Object element ) { throw new UnsupportedOperationException ( ) ; } @Override public int remove ( Object element , int occurrences ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean removeAll ( Collection < ? > elementsToRemove ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean retainAll ( Collection < ? > elementsToRetain ) { throw new UnsupportedOperationException ( ) ; } @Override public void clear ( ) { throw new UnsupportedOperationException ( ) ; } @Override public int setCount ( E element , int count ) { throw new UnsupportedOperationException ( ) ; } @Override public boolean setCount ( E element , int oldCount , int newCount ) { throw new UnsupportedOperationException ( ) ; } private static final long serialVersionUID = <int> ; } @Beta public static < E > SortedMultiset < E > unmodifiableSortedMultiset ( SortedMultiset < E > sortedMultiset ) { return new UnmodifiableSortedMultiset < E > ( checkNotNull ( sortedMultiset ) ) ; } public static < E > Multiset . Entry < E > immutableEntry ( @Nullable E e , int n ) { return new ImmutableEntry < E > ( e , n ) ; } static class ImmutableEntry < E > extends AbstractEntry < E > implements Serializable { @Nullable private final E element ; private final int count ; ImmutableEntry ( @Nullable E element , int count ) { this . element = element ; this . count = count ; checkNonnegative ( count , <str> ) ; } @Override @Nullable public final E getElement ( ) { return element ; } @Override public final int getCount ( ) { return count ; } public ImmutableEntry < E > nextInBucket ( ) { return null ; } private static final long serialVersionUID = <int> ; } @Beta @CheckReturnValue public static < E > Multiset < E > filter ( Multiset < E > unfiltered , Predicate < ? super E > predicate ) { if ( unfiltered instanceof FilteredMultiset ) { FilteredMultiset < E > filtered = ( FilteredMultiset < E > ) unfiltered ; Predicate < E > combinedPredicate = Predicates . < E > and ( filtered . predicate , predicate ) ; return new FilteredMultiset < E > ( filtered . unfiltered , combinedPredicate ) ; } return new FilteredMultiset < E > ( unfiltered , predicate ) ; } private static final class FilteredMultiset < E > extends AbstractMultiset < E > { final Multiset < E > unfiltered ; final Predicate < ? super E > predicate ; FilteredMultiset ( Multiset < E > unfiltered , Predicate < ? super E > predicate ) { this . unfiltered = checkNotNull ( unfiltered ) ; this . predicate = checkNotNull ( predicate ) ; } @Override public UnmodifiableIterator < E > iterator ( ) { return Iterators . filter ( unfiltered . iterator ( ) , predicate ) ; } @Override Set < E > createElementSet ( ) { return Sets . filter ( unfiltered . elementSet ( ) , predicate ) ; } @Override Set < Entry < E > > createEntrySet ( ) { return Sets . filter ( unfiltered . entrySet ( ) , new Predicate < Entry < E > > ( ) { @Override public boolean apply ( Entry < E > entry ) { return predicate . apply ( entry . getElement ( ) ) ; } } ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { throw new AssertionError ( <str> ) ; } @Override int distinctElements ( ) { return elementSet ( ) . size ( ) ; } @Override public int count ( @Nullable Object element ) { int count = unfiltered . count ( element ) ; if ( count > <int> ) { @SuppressWarnings ( <str> ) E e = ( E ) element ; return predicate . apply ( e ) ? count : <int> ; } return <int> ; } @Override public int add ( @Nullable E element , int occurrences ) { checkArgument ( predicate . apply ( element ) , <str> , element , predicate ) ; return unfiltered . add ( element , occurrences ) ; } @Override public int remove ( @Nullable Object element , int occurrences ) { checkNonnegative ( occurrences , <str> ) ; if ( occurrences = = <int> ) { return count ( element ) ; } else { return contains ( element ) ? unfiltered . remove ( element , occurrences ) : <int> ; } } @Override public void clear ( ) { elementSet ( ) . clear ( ) ; } } static int inferDistinctElements ( Iterable < ? > elements ) { if ( elements instanceof Multiset ) { return ( ( Multiset < ? > ) elements ) . elementSet ( ) . size ( ) ; } return <int> ; } @Beta public static < E > Multiset < E > union ( final Multiset < ? extends E > multiset1 , final Multiset < ? extends E > multiset2 ) { checkNotNull ( multiset1 ) ; checkNotNull ( multiset2 ) ; return new AbstractMultiset < E > ( ) { @Override public boolean contains ( @Nullable Object element ) { return multiset1 . contains ( element ) | | multiset2 . contains ( element ) ; } @Override public boolean isEmpty ( ) { return multiset1 . isEmpty ( ) & & multiset2 . isEmpty ( ) ; } @Override public int count ( Object element ) { return Math . max ( multiset1 . count ( element ) , multiset2 . count ( element ) ) ; } @Override Set < E > createElementSet ( ) { return Sets . union ( multiset1 . elementSet ( ) , multiset2 . elementSet ( ) ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < ? extends Entry < ? extends E > > iterator1 = multiset1 . entrySet ( ) . iterator ( ) ; final Iterator < ? extends Entry < ? extends E > > iterator2 = multiset2 . entrySet ( ) . iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { if ( iterator1 . hasNext ( ) ) { Entry < ? extends E > entry1 = iterator1 . next ( ) ; E element = entry1 . getElement ( ) ; int count = Math . max ( entry1 . getCount ( ) , multiset2 . count ( element ) ) ; return immutableEntry ( element , count ) ; } while ( iterator2 . hasNext ( ) ) { Entry < ? extends E > entry2 = iterator2 . next ( ) ; E element = entry2 . getElement ( ) ; if ( ! multiset1 . contains ( element ) ) { return immutableEntry ( element , entry2 . getCount ( ) ) ; } } return endOfData ( ) ; } } ; } @Override int distinctElements ( ) { return elementSet ( ) . size ( ) ; } } ; } public static < E > Multiset < E > intersection ( final Multiset < E > multiset1 , final Multiset < ? > multiset2 ) { checkNotNull ( multiset1 ) ; checkNotNull ( multiset2 ) ; return new AbstractMultiset < E > ( ) { @Override public int count ( Object element ) { int count1 = multiset1 . count ( element ) ; return ( count1 = = <int> ) ? <int> : Math . min ( count1 , multiset2 . count ( element ) ) ; } @Override Set < E > createElementSet ( ) { return Sets . intersection ( multiset1 . elementSet ( ) , multiset2 . elementSet ( ) ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < Entry < E > > iterator1 = multiset1 . entrySet ( ) . iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { while ( iterator1 . hasNext ( ) ) { Entry < E > entry1 = iterator1 . next ( ) ; E element = entry1 . getElement ( ) ; int count = Math . min ( entry1 . getCount ( ) , multiset2 . count ( element ) ) ; if ( count > <int> ) { return immutableEntry ( element , count ) ; } } return endOfData ( ) ; } } ; } @Override int distinctElements ( ) { return elementSet ( ) . size ( ) ; } } ; } @Beta public static < E > Multiset < E > sum ( final Multiset < ? extends E > multiset1 , final Multiset < ? extends E > multiset2 ) { checkNotNull ( multiset1 ) ; checkNotNull ( multiset2 ) ; return new AbstractMultiset < E > ( ) { @Override public boolean contains ( @Nullable Object element ) { return multiset1 . contains ( element ) | | multiset2 . contains ( element ) ; } @Override public boolean isEmpty ( ) { return multiset1 . isEmpty ( ) & & multiset2 . isEmpty ( ) ; } @Override public int size ( ) { return multiset1 . size ( ) + multiset2 . size ( ) ; } @Override public int count ( Object element ) { return multiset1 . count ( element ) + multiset2 . count ( element ) ; } @Override Set < E > createElementSet ( ) { return Sets . union ( multiset1 . elementSet ( ) , multiset2 . elementSet ( ) ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < ? extends Entry < ? extends E > > iterator1 = multiset1 . entrySet ( ) . iterator ( ) ; final Iterator < ? extends Entry < ? extends E > > iterator2 = multiset2 . entrySet ( ) . iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { if ( iterator1 . hasNext ( ) ) { Entry < ? extends E > entry1 = iterator1 . next ( ) ; E element = entry1 . getElement ( ) ; int count = entry1 . getCount ( ) + multiset2 . count ( element ) ; return immutableEntry ( element , count ) ; } while ( iterator2 . hasNext ( ) ) { Entry < ? extends E > entry2 = iterator2 . next ( ) ; E element = entry2 . getElement ( ) ; if ( ! multiset1 . contains ( element ) ) { return immutableEntry ( element , entry2 . getCount ( ) ) ; } } return endOfData ( ) ; } } ; } @Override int distinctElements ( ) { return elementSet ( ) . size ( ) ; } } ; } @Beta public static < E > Multiset < E > difference ( final Multiset < E > multiset1 , final Multiset < ? > multiset2 ) { checkNotNull ( multiset1 ) ; checkNotNull ( multiset2 ) ; return new AbstractMultiset < E > ( ) { @Override public int count ( @Nullable Object element ) { int count1 = multiset1 . count ( element ) ; return ( count1 = = <int> ) ? <int> : Math . max ( <int> , count1 - multiset2 . count ( element ) ) ; } @Override Iterator < Entry < E > > entryIterator ( ) { final Iterator < Entry < E > > iterator1 = multiset1 . entrySet ( ) . iterator ( ) ; return new AbstractIterator < Entry < E > > ( ) { @Override protected Entry < E > computeNext ( ) { while ( iterator1 . hasNext ( ) ) { Entry < E > entry1 = iterator1 . next ( ) ; E element = entry1 . getElement ( ) ; int count = entry1 . getCount ( ) - multiset2 . count ( element ) ; if ( count > <int> ) { return immutableEntry ( element , count ) ; } } return endOfData ( ) ; } } ; } @Override int distinctElements ( ) { return Iterators . size ( entryIterator ( ) ) ; } } ; } public static boolean containsOccurrences ( Multiset < ? > superMultiset , Multiset < ? > subMultiset ) { checkNotNull ( superMultiset ) ; checkNotNull ( subMultiset ) ; for ( Entry < ? > entry : subMultiset . entrySet ( ) ) { int superCount = superMultiset . count ( entry . getElement ( ) ) ; if ( superCount < entry . getCount ( ) ) { return false ; } } return true ; } public static boolean retainOccurrences ( Multiset < ? > multisetToModify , Multiset < ? > multisetToRetain ) { return retainOccurrencesImpl ( multisetToModify , multisetToRetain ) ; } private static < E > boolean retainOccurrencesImpl ( Multiset < E > multisetToModify , Multiset < ? > occurrencesToRetain ) { checkNotNull ( multisetToModify ) ; checkNotNull ( occurrencesToRetain ) ; Iterator < Entry < E > > entryIterator = multisetToModify . entrySet ( ) . iterator ( ) ; boolean changed = false ; while ( entryIterator . hasNext ( ) ) { Entry < E > entry = entryIterator . next ( ) ; int retainCount = occurrencesToRetain . count ( entry . getElement ( ) ) ; if ( retainCount = = <int> ) { entryIterator . remove ( ) ; changed = true ; } else if ( retainCount < entry . getCount ( ) ) { multisetToModify . setCount ( entry . getElement ( ) , retainCount ) ; changed = true ; } } return changed ; } public static boolean removeOccurrences ( Multiset < ? > multisetToModify , Iterable < ? > occurrencesToRemove ) { if ( occurrencesToRemove instanceof Multiset ) { return removeOccurrences ( multisetToModify , ( Multiset < ? > ) occurrencesToRemove ) ; } else { checkNotNull ( multisetToModify ) ; checkNotNull ( occurrencesToRemove ) ; boolean changed = false ; for ( Object o : occurrencesToRemove ) { changed | = multisetToModify . remove ( o ) ; } return changed ; } } public static boolean removeOccurrences ( Multiset < ? > multisetToModify , Multiset < ? > occurrencesToRemove ) { checkNotNull ( multisetToModify ) ; checkNotNull ( occurrencesToRemove ) ; boolean changed = false ; Iterator < ? extends Entry < ? > > entryIterator = multisetToModify . entrySet ( ) . iterator ( ) ; while ( entryIterator . hasNext ( ) ) { Entry < ? > entry = entryIterator . next ( ) ; int removeCount = occurrencesToRemove . count ( entry . getElement ( ) ) ; if ( removeCount > = entry . getCount ( ) ) { entryIterator . remove ( ) ; changed = true ; } else if ( removeCount > <int> ) { multisetToModify . remove ( entry . getElement ( ) , removeCount ) ; changed = true ; } } return changed ; } abstract static class AbstractEntry < E > implements Multiset . Entry < E > { @Override public boolean equals ( @Nullable Object object ) { if ( object instanceof Multiset . Entry ) { Multiset . Entry < ? > that = ( Multiset . Entry < ? > ) object ; return this . getCount ( ) = = that . getCount ( ) & & Objects . equal ( this . getElement ( ) , that . getElement ( ) ) ; } return false ; } @Override public int hashCode ( ) { E e = getElement ( ) ; return ( ( e = = null ) ? <int> : e . hashCode ( ) ) ^ getCount ( ) ; } @Override public String toString ( ) { String text = String . valueOf ( getElement ( ) ) ; int n = getCount ( ) ; return ( n = = <int> ) ? text : ( text + <str> + n ) ; } } static boolean equalsImpl ( Multiset < ? > multiset , @Nullable Object object ) { if ( object = = multiset ) { return true ; } if ( object instanceof Multiset ) { Multiset < ? > that = ( Multiset < ? > ) object ; if ( multiset . size ( ) ! = that . size ( ) | | multiset . entrySet ( ) . size ( ) ! = that . entrySet ( ) . size ( ) ) { return false ; } for ( Entry < ? > entry : that . entrySet ( ) ) { if ( multiset . count ( entry . getElement ( ) ) ! = entry . getCount ( ) ) { return false ; } } return true ; } return false ; } static < E > boolean addAllImpl ( Multiset < E > self , Collection < ? extends E > elements ) { if ( elements . isEmpty ( ) ) { return false ; } if ( elements instanceof Multiset ) { Multiset < ? extends E > that = cast ( elements ) ; for ( Entry < ? extends E > entry : that . entrySet ( ) ) { self . add ( entry . getElement ( ) , entry . getCount ( ) ) ; } } else { Iterators . addAll ( self , elements . iterator ( ) ) ; } return true ; } static boolean removeAllImpl ( Multiset < ? > self , Collection < ? > elementsToRemove ) { Collection < ? > collection = ( elementsToRemove instanceof Multiset ) ? ( ( Multiset < ? > ) elementsToRemove ) . elementSet ( ) : elementsToRemove ; return self . elementSet ( ) . removeAll ( collection ) ; } static boolean retainAllImpl ( Multiset < ? > self , Collection < ? > elementsToRetain ) { checkNotNull ( elementsToRetain ) ; Collection < ? > collection = ( elementsToRetain instanceof Multiset ) ? ( ( Multiset < ? > ) elementsToRetain ) . elementSet ( ) : elementsToRetain ; return self . elementSet ( ) . retainAll ( collection ) ; } static < E > int setCountImpl ( Multiset < E > self , E element , int count ) { checkNonnegative ( count , <str> ) ; int oldCount = self . count ( element ) ; int delta = count - oldCount ; if ( delta > <int> ) { self . add ( element , delta ) ; } else if ( delta < <int> ) { self . remove ( element , - delta ) ; } return oldCount ; } static < E > boolean setCountImpl ( Multiset < E > self , E element , int oldCount , int newCount ) { checkNonnegative ( oldCount , <str> ) ; checkNonnegative ( newCount , <str> ) ; if ( self . count ( element ) = = oldCount ) { self . setCount ( element , newCount ) ; return true ; } else { return false ; } } abstract static class ElementSet < E > extends Sets . ImprovedAbstractSet < E > { abstract Multiset < E > multiset ( ) ; @Override public void clear ( ) { multiset ( ) . clear ( ) ; } @Override public boolean contains ( Object o ) { return multiset ( ) . contains ( o ) ; } @Override public boolean containsAll ( Collection < ? > c ) { return multiset ( ) . containsAll ( c ) ; } @Override public boolean isEmpty ( ) { return multiset ( ) . isEmpty ( ) ; } @Override public Iterator < E > iterator ( ) { return new TransformedIterator < Entry < E > , E > ( multiset ( ) . entrySet ( ) . iterator ( ) ) { @Override E transform ( Entry < E > entry ) { return entry . getElement ( ) ; } } ; } @Override public boolean remove ( Object o ) { return multiset ( ) . remove ( o , Integer . MAX_VALUE ) > <int> ; } @Override public int size ( ) { return multiset ( ) . entrySet ( ) . size ( ) ; } } abstract static class EntrySet < E > extends Sets . ImprovedAbstractSet < Entry < E > > { abstract Multiset < E > multiset ( ) ; @Override public boolean contains ( @Nullable Object o ) { if ( o instanceof Entry ) { @SuppressWarnings ( <str> ) Entry < ? > entry = ( Entry < ? > ) o ; if ( entry . getCount ( ) < = <int> ) { return false ; } int count = multiset ( ) . count ( entry . getElement ( ) ) ; return count = = entry . getCount ( ) ; } return false ; } @SuppressWarnings ( <str> ) @Override public boolean remove ( Object object ) { if ( object instanceof Multiset . Entry ) { Entry < ? > entry = ( Entry < ? > ) object ; Object element = entry . getElement ( ) ; int entryCount = entry . getCount ( ) ; if ( entryCount ! = <int> ) { @SuppressWarnings ( <str> ) Multiset < Object > multiset = ( Multiset ) multiset ( ) ; return multiset . setCount ( element , entryCount , <int> ) ; } } return false ; } @Override public void clear ( ) { multiset ( ) . clear ( ) ; } } static < E > Iterator < E > iteratorImpl ( Multiset < E > multiset ) { return new MultisetIteratorImpl < E > ( multiset , multiset . entrySet ( ) . iterator ( ) ) ; } static final class MultisetIteratorImpl < E > implements Iterator < E > { private final Multiset < E > multiset ; private final Iterator < Entry < E > > entryIterator ; private Entry < E > currentEntry ; private int laterCount ; private int totalCount ; private boolean canRemove ; MultisetIteratorImpl ( Multiset < E > multiset , Iterator < Entry < E > > entryIterator ) { this . multiset = multiset ; this . entryIterator = entryIterator ; } @Override public boolean hasNext ( ) { return laterCount > <int> | | entryIterator . hasNext ( ) ; } @Override public E next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } if ( laterCount = = <int> ) { currentEntry = entryIterator . next ( ) ; totalCount = laterCount = currentEntry . getCount ( ) ; } laterCount - - ; canRemove = true ; return currentEntry . getElement ( ) ; } @Override public void remove ( ) { checkRemove ( canRemove ) ; if ( totalCount = = <int> ) { entryIterator . remove ( ) ; } else { multiset . remove ( currentEntry . getElement ( ) ) ; } totalCount - - ; canRemove = false ; } } static int sizeImpl ( Multiset < ? > multiset ) { long size = <int> ; for ( Entry < ? > entry : multiset . entrySet ( ) ) { size + = entry . getCount ( ) ; } return Ints . saturatedCast ( size ) ; } static < T > Multiset < T > cast ( Iterable < T > iterable ) { return ( Multiset < T > ) iterable ; } private static final Ordering < Entry < ? > > DECREASING_COUNT_ORDERING = new Ordering < Entry < ? > > ( ) { @Override public int compare ( Entry < ? > entry1 , Entry < ? > entry2 ) { return Ints . compare ( entry2 . getCount ( ) , entry1 . getCount ( ) ) ; } } ; @Beta public static < E > ImmutableMultiset < E > copyHighestCountFirst ( Multiset < E > multiset ) { List < Entry < E > > sortedEntries = Multisets . DECREASING_COUNT_ORDERING . immutableSortedCopy ( multiset . entrySet ( ) ) ; return ImmutableMultiset . copyFromEntries ( sortedEntries ) ; } } 
