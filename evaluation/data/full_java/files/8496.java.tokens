package org . elasticsearch . search . basic ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . search . MultiSearchResponse ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . client . Requests ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . GeohashCellQuery ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . index . query . functionscore . script . ScriptScoreFunctionBuilder ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . search . Scroll ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . search . aggregations . AggregationBuilders ; import org . elasticsearch . search . aggregations . bucket . filter . Filter ; import org . elasticsearch . search . aggregations . bucket . global . Global ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . HashSet ; import java . util . Set ; import java . util . TreeSet ; import static org . elasticsearch . action . search . SearchType . DFS_QUERY_AND_FETCH ; import static org . elasticsearch . action . search . SearchType . DFS_QUERY_THEN_FETCH ; import static org . elasticsearch . action . search . SearchType . QUERY_AND_FETCH ; import static org . elasticsearch . action . search . SearchType . QUERY_THEN_FETCH ; import static org . elasticsearch . client . Requests . createIndexRequest ; import static org . elasticsearch . client . Requests . searchRequest ; import static org . elasticsearch . cluster . metadata . IndexMetaData . SETTING_NUMBER_OF_SHARDS ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . unit . TimeValue . timeValueMinutes ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . search . builder . SearchSourceBuilder . searchSource ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class TransportTwoNodesSearchIT extends ESIntegTestCase { @Override protected int numberOfReplicas ( ) { return <int> ; } private Set < String > prepareData ( ) throws Exception { return prepareData ( - <int> ) ; } private Set < String > prepareData ( int numShards ) throws Exception { Set < String > fullExpectedIds = new TreeSet < > ( ) ; Settings . Builder settingsBuilder = settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( <str> , <str> ) ; if ( numShards > <int> ) { settingsBuilder . put ( SETTING_NUMBER_OF_SHARDS , numShards ) ; } client ( ) . admin ( ) . indices ( ) . create ( createIndexRequest ( <str> ) . settings ( settingsBuilder ) ) . actionGet ( ) ; ensureGreen ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( Integer . toString ( i ) , <str> , i ) ; fullExpectedIds . add ( Integer . toString ( i ) ) ; } refresh ( ) ; return fullExpectedIds ; } private void index ( String id , String nameValue , int age ) throws IOException { client ( ) . index ( Requests . indexRequest ( <str> ) . type ( <str> ) . id ( id ) . source ( source ( id , nameValue , age ) ) ) . actionGet ( ) ; } private XContentBuilder source ( String id , String nameValue , int age ) throws IOException { StringBuilder multi = new StringBuilder ( ) . append ( nameValue ) ; for ( int i = <int> ; i < age ; i + + ) { multi . append ( <str> ) . append ( nameValue ) ; } return jsonBuilder ( ) . startObject ( ) . field ( <str> , id ) . field ( <str> , Integer . parseInt ( id ) ) . field ( <str> , nameValue + id ) . field ( <str> , age ) . field ( <str> , multi . toString ( ) ) . endObject ( ) ; } public void testDfsQueryThenFetch ( ) throws Exception { Settings . Builder settingsBuilder = settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( <str> , <str> ) ; client ( ) . admin ( ) . indices ( ) . create ( createIndexRequest ( <str> ) . settings ( settingsBuilder ) ) . actionGet ( ) ; ensureGreen ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( Integer . toString ( i - <int> ) , <str> , i ) ; } refresh ( ) ; int total = <int> ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setSearchType ( DFS_QUERY_THEN_FETCH ) . setQuery ( termQuery ( <str> , <str> ) ) . setSize ( <int> ) . setExplain ( true ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; while ( true ) { assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; SearchHit [ ] hits = searchResponse . getHits ( ) . hits ( ) ; if ( hits . length = = <int> ) { break ; } for ( int i = <int> ; i < hits . length ; + + i ) { SearchHit hit = hits [ i ] ; assertThat ( hit . explanation ( ) , notNullValue ( ) ) ; assertThat ( <str> + hit . id ( ) + <str> + hit . explanation ( ) . toString ( ) , hit . id ( ) , equalTo ( Integer . toString ( <int> - total - i - <int> ) ) ) ; } total + = hits . length ; searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; } clearScroll ( searchResponse . getScrollId ( ) ) ; assertEquals ( <int> , total ) ; } public void testDfsQueryThenFetchWithSort ( ) throws Exception { prepareData ( ) ; int total = <int> ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setSearchType ( DFS_QUERY_THEN_FETCH ) . setQuery ( termQuery ( <str> , <str> ) ) . setSize ( <int> ) . setExplain ( true ) . addSort ( <str> , SortOrder . ASC ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; while ( true ) { assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; SearchHit [ ] hits = searchResponse . getHits ( ) . hits ( ) ; if ( hits . length = = <int> ) { break ; } for ( int i = <int> ; i < hits . length ; + + i ) { SearchHit hit = hits [ i ] ; assertThat ( hit . explanation ( ) , notNullValue ( ) ) ; assertThat ( <str> + hit . id ( ) + <str> , hit . id ( ) , equalTo ( Integer . toString ( total + i ) ) ) ; } total + = hits . length ; searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; } clearScroll ( searchResponse . getScrollId ( ) ) ; assertEquals ( <int> , total ) ; } public void testQueryThenFetch ( ) throws Exception { prepareData ( ) ; int total = <int> ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setSearchType ( QUERY_THEN_FETCH ) . setQuery ( termQuery ( <str> , <str> ) ) . setSize ( <int> ) . setExplain ( true ) . addSort ( <str> , SortOrder . DESC ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; while ( true ) { assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; SearchHit [ ] hits = searchResponse . getHits ( ) . hits ( ) ; if ( hits . length = = <int> ) { break ; } for ( int i = <int> ; i < hits . length ; + + i ) { SearchHit hit = hits [ i ] ; assertThat ( hit . explanation ( ) , notNullValue ( ) ) ; assertThat ( <str> + hit . id ( ) + <str> , hit . id ( ) , equalTo ( Integer . toString ( <int> - total - i - <int> ) ) ) ; } total + = hits . length ; searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; } clearScroll ( searchResponse . getScrollId ( ) ) ; assertEquals ( <int> , total ) ; } public void testQueryThenFetchWithFrom ( ) throws Exception { Set < String > fullExpectedIds = prepareData ( ) ; SearchSourceBuilder source = searchSource ( ) . query ( matchAllQuery ( ) ) . explain ( true ) ; Set < String > collectedIds = new TreeSet < > ( ) ; SearchResponse searchResponse = client ( ) . search ( searchRequest ( <str> ) . source ( source . from ( <int> ) . size ( <int> ) ) . searchType ( QUERY_THEN_FETCH ) ) . actionGet ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { SearchHit hit = searchResponse . getHits ( ) . hits ( ) [ i ] ; collectedIds . add ( hit . id ( ) ) ; } searchResponse = client ( ) . search ( searchRequest ( <str> ) . source ( source . from ( <int> ) . size ( <int> ) ) . searchType ( QUERY_THEN_FETCH ) ) . actionGet ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { SearchHit hit = searchResponse . getHits ( ) . hits ( ) [ i ] ; collectedIds . add ( hit . id ( ) ) ; } assertThat ( collectedIds , equalTo ( fullExpectedIds ) ) ; } public void testQueryThenFetchWithSort ( ) throws Exception { prepareData ( ) ; int total = <int> ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( termQuery ( <str> , <str> ) ) . setSize ( <int> ) . setExplain ( true ) . addSort ( <str> , SortOrder . ASC ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; while ( true ) { assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; SearchHit [ ] hits = searchResponse . getHits ( ) . hits ( ) ; if ( hits . length = = <int> ) { break ; } for ( int i = <int> ; i < hits . length ; + + i ) { SearchHit hit = hits [ i ] ; assertThat ( hit . explanation ( ) , notNullValue ( ) ) ; assertThat ( <str> + hit . id ( ) + <str> , hit . id ( ) , equalTo ( Integer . toString ( total + i ) ) ) ; } total + = hits . length ; searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( TimeValue . timeValueSeconds ( <int> ) ) . get ( ) ; } clearScroll ( searchResponse . getScrollId ( ) ) ; assertEquals ( <int> , total ) ; } public void testQueryAndFetch ( ) throws Exception { prepareData ( <int> ) ; SearchSourceBuilder source = searchSource ( ) . query ( termQuery ( <str> , <str> ) ) . from ( <int> ) . size ( <int> ) . explain ( true ) ; Set < String > expectedIds = new HashSet < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { expectedIds . add ( Integer . toString ( i ) ) ; } SearchResponse searchResponse = client ( ) . search ( searchRequest ( <str> ) . source ( source ) . searchType ( QUERY_AND_FETCH ) . scroll ( new Scroll ( timeValueMinutes ( <int> ) ) ) ) . actionGet ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { SearchHit hit = searchResponse . getHits ( ) . hits ( ) [ i ] ; assertThat ( hit . explanation ( ) , notNullValue ( ) ) ; assertThat ( <str> , expectedIds . remove ( hit . id ( ) ) , notNullValue ( ) ) ; } do { searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( <str> ) . get ( ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) . length , lessThanOrEqualTo ( <int> ) ) ; for ( int i = <int> ; i < searchResponse . getHits ( ) . hits ( ) . length ; i + + ) { SearchHit hit = searchResponse . getHits ( ) . hits ( ) [ i ] ; assertThat ( <str> , expectedIds . remove ( hit . id ( ) ) , notNullValue ( ) ) ; } } while ( searchResponse . getHits ( ) . getHits ( ) . length > <int> ) ; clearScroll ( searchResponse . getScrollId ( ) ) ; assertThat ( <str> + expectedIds + <str> , expectedIds . size ( ) , equalTo ( <int> ) ) ; } public void testDfsQueryAndFetch ( ) throws Exception { prepareData ( <int> ) ; SearchSourceBuilder source = searchSource ( ) . query ( termQuery ( <str> , <str> ) ) . from ( <int> ) . size ( <int> ) . explain ( true ) ; Set < String > expectedIds = new HashSet < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { expectedIds . add ( Integer . toString ( i ) ) ; } SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setSearchType ( DFS_QUERY_AND_FETCH ) . setScroll ( <str> ) . setSource ( source ) . get ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { SearchHit hit = searchResponse . getHits ( ) . hits ( ) [ i ] ; assertThat ( hit . explanation ( ) , notNullValue ( ) ) ; assertThat ( <str> , expectedIds . remove ( hit . id ( ) ) , notNullValue ( ) ) ; } do { searchResponse = client ( ) . prepareSearchScroll ( searchResponse . getScrollId ( ) ) . setScroll ( <str> ) . get ( ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getHits ( ) . hits ( ) . length , lessThanOrEqualTo ( <int> ) ) ; for ( int i = <int> ; i < searchResponse . getHits ( ) . hits ( ) . length ; i + + ) { SearchHit hit = searchResponse . getHits ( ) . hits ( ) [ i ] ; assertThat ( <str> , expectedIds . remove ( hit . id ( ) ) , notNullValue ( ) ) ; } } while ( searchResponse . getHits ( ) . hits ( ) . length > <int> ) ; clearScroll ( searchResponse . getScrollId ( ) ) ; assertThat ( <str> + expectedIds + <str> , expectedIds . size ( ) , equalTo ( <int> ) ) ; } public void testSimpleFacets ( ) throws Exception { prepareData ( ) ; SearchSourceBuilder sourceBuilder = searchSource ( ) . query ( termQuery ( <str> , <str> ) ) . from ( <int> ) . size ( <int> ) . explain ( true ) . aggregation ( AggregationBuilders . global ( <str> ) . subAggregation ( AggregationBuilders . filter ( <str> ) . filter ( termQuery ( <str> , <str> ) ) ) ) . aggregation ( AggregationBuilders . filter ( <str> ) . filter ( termQuery ( <str> , <str> ) ) ) ; SearchResponse searchResponse = client ( ) . search ( searchRequest ( <str> ) . source ( sourceBuilder ) ) . actionGet ( ) ; assertNoFailures ( searchResponse ) ; assertThat ( searchResponse . getHits ( ) . totalHits ( ) , equalTo ( <int> ) ) ; Global global = searchResponse . getAggregations ( ) . get ( <str> ) ; Filter all = global . getAggregations ( ) . get ( <str> ) ; Filter test1 = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( test1 . getDocCount ( ) , equalTo ( <int> ) ) ; assertThat ( all . getDocCount ( ) , equalTo ( <int> ) ) ; } public void testFailedSearchWithWrongQuery ( ) throws Exception { prepareData ( ) ; NumShards test = getNumShards ( <str> ) ; logger . info ( <str> ) ; try { SearchResponse searchResponse = client ( ) . search ( searchRequest ( <str> ) . source ( new SearchSourceBuilder ( ) . query ( new GeohashCellQuery . Builder ( <str> , <str> ) ) ) ) . actionGet ( ) ; assertThat ( searchResponse . getTotalShards ( ) , equalTo ( test . numPrimaries ) ) ; assertThat ( searchResponse . getSuccessfulShards ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getFailedShards ( ) , equalTo ( test . numPrimaries ) ) ; fail ( <str> ) ; } catch ( ElasticsearchException e ) { assertThat ( e . unwrapCause ( ) , instanceOf ( SearchPhaseExecutionException . class ) ) ; } logger . info ( <str> ) ; } public void testFailedSearchWithWrongFrom ( ) throws Exception { prepareData ( ) ; NumShards test = getNumShards ( <str> ) ; logger . info ( <str> ) ; SearchSourceBuilder source = searchSource ( ) . query ( termQuery ( <str> , <str> ) ) . from ( <int> ) . size ( <int> ) . explain ( true ) ; SearchResponse response = client ( ) . search ( searchRequest ( <str> ) . searchType ( DFS_QUERY_AND_FETCH ) . source ( source ) ) . actionGet ( ) ; assertThat ( response . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; assertThat ( response . getTotalShards ( ) , equalTo ( test . numPrimaries ) ) ; assertThat ( response . getSuccessfulShards ( ) , equalTo ( test . numPrimaries ) ) ; assertThat ( response . getFailedShards ( ) , equalTo ( <int> ) ) ; response = client ( ) . search ( searchRequest ( <str> ) . searchType ( QUERY_THEN_FETCH ) . source ( source ) ) . actionGet ( ) ; assertNoFailures ( response ) ; assertThat ( response . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; response = client ( ) . search ( searchRequest ( <str> ) . searchType ( DFS_QUERY_AND_FETCH ) . source ( source ) ) . actionGet ( ) ; assertNoFailures ( response ) ; assertThat ( response . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; response = client ( ) . search ( searchRequest ( <str> ) . searchType ( DFS_QUERY_THEN_FETCH ) . source ( source ) ) . actionGet ( ) ; assertNoFailures ( response ) ; assertThat ( response . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; logger . info ( <str> ) ; } public void testFailedMultiSearchWithWrongQuery ( ) throws Exception { prepareData ( ) ; logger . info ( <str> ) ; MultiSearchResponse response = client ( ) . prepareMultiSearch ( ) . add ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . geoDistanceRangeQuery ( <str> , <int> , <int> ) . from ( <int> ) . to ( <int> ) ) ) . add ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , <int> ) ) ) . add ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( response . getResponses ( ) . length , equalTo ( <int> ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getFailureMessage ( ) , notNullValue ( ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getFailureMessage ( ) , nullValue ( ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getResponse ( ) . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getFailureMessage ( ) , nullValue ( ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getResponse ( ) . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; logger . info ( <str> ) ; } public void testFailedMultiSearchWithWrongQueryWithFunctionScore ( ) throws Exception { prepareData ( ) ; logger . info ( <str> ) ; MultiSearchResponse response = client ( ) . prepareMultiSearch ( ) . add ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . functionScoreQuery ( QueryBuilders . termQuery ( <str> , <int> ) , new ScriptScoreFunctionBuilder ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) ) ) ) . add ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . termQuery ( <str> , <int> ) ) ) . add ( client ( ) . prepareSearch ( <str> ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( response . getResponses ( ) . length , equalTo ( <int> ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getFailureMessage ( ) , notNullValue ( ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getFailureMessage ( ) , nullValue ( ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getResponse ( ) . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getFailureMessage ( ) , nullValue ( ) ) ; assertThat ( response . getResponses ( ) [ <int> ] . getResponse ( ) . getHits ( ) . hits ( ) . length , equalTo ( <int> ) ) ; logger . info ( <str> ) ; } } 
