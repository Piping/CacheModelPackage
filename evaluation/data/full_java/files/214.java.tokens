package org . apache . cassandra . cql3 . restrictions ; import java . util . Collections ; import com . google . common . collect . Iterables ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . cql3 . Term ; import org . apache . cassandra . cql3 . functions . Function ; import org . apache . cassandra . cql3 . statements . Bound ; import org . apache . cassandra . index . Index ; final class TermSlice { private final Term [ ] bounds ; private final boolean [ ] boundInclusive ; private TermSlice ( Term start , boolean includeStart , Term end , boolean includeEnd ) { bounds = new Term [ ] { start , end } ; boundInclusive = new boolean [ ] { includeStart , includeEnd } ; } public static TermSlice newInstance ( Bound bound , boolean include , Term term ) { return bound . isStart ( ) ? new TermSlice ( term , include , null , false ) : new TermSlice ( null , false , term , include ) ; } public Term bound ( Bound bound ) { return bounds [ bound . idx ] ; } public boolean hasBound ( Bound b ) { return bounds [ b . idx ] ! = null ; } public boolean isInclusive ( Bound b ) { return bounds [ b . idx ] = = null | | boundInclusive [ b . idx ] ; } public TermSlice merge ( TermSlice otherSlice ) { if ( hasBound ( Bound . START ) ) { assert ! otherSlice . hasBound ( Bound . START ) ; return new TermSlice ( bound ( Bound . START ) , isInclusive ( Bound . START ) , otherSlice . bound ( Bound . END ) , otherSlice . isInclusive ( Bound . END ) ) ; } assert ! otherSlice . hasBound ( Bound . END ) ; return new TermSlice ( otherSlice . bound ( Bound . START ) , otherSlice . isInclusive ( Bound . START ) , bound ( Bound . END ) , isInclusive ( Bound . END ) ) ; } @Override public String toString ( ) { return String . format ( <str> , boundInclusive [ <int> ] ? <str> : <str> , bounds [ <int> ] , boundInclusive [ <int> ] ? <str> : <str> , bounds [ <int> ] ) ; } public Operator getIndexOperator ( Bound b ) { if ( b . isStart ( ) ) return boundInclusive [ b . idx ] ? Operator . GTE : Operator . GT ; return boundInclusive [ b . idx ] ? Operator . LTE : Operator . LT ; } public boolean isSupportedBy ( ColumnDefinition column , Index index ) { boolean supported = false ; if ( hasBound ( Bound . START ) ) supported | = isInclusive ( Bound . START ) ? index . supportsExpression ( column , Operator . GTE ) : index . supportsExpression ( column , Operator . GT ) ; if ( hasBound ( Bound . END ) ) supported | = isInclusive ( Bound . END ) ? index . supportsExpression ( column , Operator . LTE ) : index . supportsExpression ( column , Operator . LT ) ; return supported ; } public Iterable < Function > getFunctions ( ) { if ( hasBound ( Bound . START ) & & hasBound ( Bound . END ) ) return Iterables . concat ( bound ( Bound . START ) . getFunctions ( ) , bound ( Bound . END ) . getFunctions ( ) ) ; else if ( hasBound ( Bound . START ) ) return bound ( Bound . START ) . getFunctions ( ) ; else if ( hasBound ( Bound . END ) ) return bound ( Bound . END ) . getFunctions ( ) ; else return Collections . emptySet ( ) ; } } 
