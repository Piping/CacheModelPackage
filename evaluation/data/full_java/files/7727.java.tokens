package org . elasticsearch . action . admin . indices . create ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . admin . cluster . state . ClusterStateResponse ; import org . elasticsearch . action . admin . indices . delete . DeleteIndexResponse ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . collect . ImmutableOpenMap ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . query . RangeQueryBuilder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . elasticsearch . test . ESIntegTestCase . Scope ; import java . util . HashMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertBlocked ; import static org . hamcrest . Matchers . allOf ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . core . IsNull . notNullValue ; @ClusterScope ( scope = Scope . TEST ) public class CreateIndexIT extends ESIntegTestCase { public void testCreationDateGiven ( ) { prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_CREATION_DATE , <int> ) ) . get ( ) ; ClusterStateResponse response = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; ClusterState state = response . getState ( ) ; assertThat ( state , notNullValue ( ) ) ; MetaData metadata = state . getMetaData ( ) ; assertThat ( metadata , notNullValue ( ) ) ; ImmutableOpenMap < String , IndexMetaData > indices = metadata . getIndices ( ) ; assertThat ( indices , notNullValue ( ) ) ; assertThat ( indices . size ( ) , equalTo ( <int> ) ) ; IndexMetaData index = indices . get ( <str> ) ; assertThat ( index , notNullValue ( ) ) ; assertThat ( index . getCreationDate ( ) , equalTo ( <int> ) ) ; } public void testCreationDateGenerated ( ) { long timeBeforeRequest = System . currentTimeMillis ( ) ; prepareCreate ( <str> ) . get ( ) ; long timeAfterRequest = System . currentTimeMillis ( ) ; ClusterStateResponse response = client ( ) . admin ( ) . cluster ( ) . prepareState ( ) . get ( ) ; ClusterState state = response . getState ( ) ; assertThat ( state , notNullValue ( ) ) ; MetaData metadata = state . getMetaData ( ) ; assertThat ( metadata , notNullValue ( ) ) ; ImmutableOpenMap < String , IndexMetaData > indices = metadata . getIndices ( ) ; assertThat ( indices , notNullValue ( ) ) ; assertThat ( indices . size ( ) , equalTo ( <int> ) ) ; IndexMetaData index = indices . get ( <str> ) ; assertThat ( index , notNullValue ( ) ) ; assertThat ( index . getCreationDate ( ) , allOf ( lessThanOrEqualTo ( timeAfterRequest ) , greaterThanOrEqualTo ( timeBeforeRequest ) ) ) ; } public void testDoubleAddMapping ( ) throws Exception { try { prepareCreate ( <str> ) . addMapping ( <str> , <str> , <str> ) . addMapping ( <str> , <str> , <str> ) ; fail ( <str> ) ; } catch ( IllegalStateException ise ) { } try { prepareCreate ( <str> ) . addMapping ( <str> , new HashMap < String , Object > ( ) ) . addMapping ( <str> , new HashMap < String , Object > ( ) ) ; fail ( <str> ) ; } catch ( IllegalStateException ise ) { } try { prepareCreate ( <str> ) . addMapping ( <str> , jsonBuilder ( ) ) . addMapping ( <str> , jsonBuilder ( ) ) ; fail ( <str> ) ; } catch ( IllegalStateException ise ) { } } public void testInvalidShardCountSettings ( ) throws Exception { try { prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , randomIntBetween ( - <int> , <int> ) ) . build ( ) ) . get ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , randomIntBetween ( - <int> , - <int> ) ) . build ( ) ) . get ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS , randomIntBetween ( - <int> , <int> ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS , randomIntBetween ( - <int> , - <int> ) ) . build ( ) ) . get ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } } public void testCreateIndexWithBlocks ( ) { try { setClusterReadOnly ( true ) ; assertBlocked ( prepareCreate ( <str> ) ) ; } finally { setClusterReadOnly ( false ) ; } } public void testCreateIndexWithMetadataBlocks ( ) { assertAcked ( prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_BLOCKS_METADATA , true ) ) ) ; assertBlocked ( client ( ) . admin ( ) . indices ( ) . prepareGetSettings ( <str> ) , IndexMetaData . INDEX_METADATA_BLOCK ) ; disableIndexBlock ( <str> , IndexMetaData . SETTING_BLOCKS_METADATA ) ; } public void testInvalidShardCountSettingsWithoutPrefix ( ) throws Exception { try { prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS . substring ( IndexMetaData . INDEX_SETTING_PREFIX . length ( ) ) , randomIntBetween ( - <int> , <int> ) ) . build ( ) ) . get ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS . substring ( IndexMetaData . INDEX_SETTING_PREFIX . length ( ) ) , randomIntBetween ( - <int> , - <int> ) ) . build ( ) ) . get ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } try { prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( IndexMetaData . SETTING_NUMBER_OF_SHARDS . substring ( IndexMetaData . INDEX_SETTING_PREFIX . length ( ) ) , randomIntBetween ( - <int> , <int> ) ) . put ( IndexMetaData . SETTING_NUMBER_OF_REPLICAS . substring ( IndexMetaData . INDEX_SETTING_PREFIX . length ( ) ) , randomIntBetween ( - <int> , - <int> ) ) . build ( ) ) . get ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; assertThat ( <str> + e . getMessage ( ) , e . getMessage ( ) . contains ( <str> ) , equalTo ( true ) ) ; } } public void testCreateAndDeleteIndexConcurrently ( ) throws InterruptedException { createIndex ( <str> ) ; final AtomicInteger indexVersion = new AtomicInteger ( <int> ) ; final Object indexVersionLock = new Object ( ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; int numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , indexVersion . get ( ) ) . get ( ) ; } synchronized ( indexVersionLock ) { indexVersion . incrementAndGet ( ) ; } client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . execute ( new ActionListener < DeleteIndexResponse > ( ) { @Override public void onResponse ( DeleteIndexResponse deleteIndexResponse ) { Thread thread = new Thread ( ) { @Override public void run ( ) { try { client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , indexVersion . get ( ) ) . get ( ) ; synchronized ( indexVersionLock ) { indexVersion . incrementAndGet ( ) ; } assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareDelete ( <str> ) . get ( ) ) ; } finally { latch . countDown ( ) ; } } } ; thread . start ( ) ; } @Override public void onFailure ( Throwable e ) { throw new RuntimeException ( e ) ; } } ) ; numDocs = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numDocs ; i + + ) { try { synchronized ( indexVersionLock ) { client ( ) . prepareIndex ( <str> , <str> ) . setSource ( <str> , indexVersion . get ( ) ) . get ( ) ; } } catch ( IndexNotFoundException inf ) { } } latch . await ( ) ; refresh ( ) ; SearchResponse expected = client ( ) . prepareSearch ( <str> ) . setIndicesOptions ( IndicesOptions . lenientExpandOpen ( ) ) . setQuery ( new RangeQueryBuilder ( <str> ) . from ( indexVersion . get ( ) , true ) ) . get ( ) ; SearchResponse all = client ( ) . prepareSearch ( <str> ) . setIndicesOptions ( IndicesOptions . lenientExpandOpen ( ) ) . get ( ) ; assertEquals ( expected + <str> + all , expected . getHits ( ) . getTotalHits ( ) , all . getHits ( ) . getTotalHits ( ) ) ; logger . info ( <str> , expected . getHits ( ) . getTotalHits ( ) ) ; } public void testMappingConflictRootCause ( ) throws Exception { CreateIndexRequestBuilder b = prepareCreate ( <str> ) ; b . addMapping ( <str> , jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ) ; b . addMapping ( <str> , jsonBuilder ( ) . humanReadable ( true ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ) ; try { b . get ( ) ; } catch ( MapperParsingException e ) { StringBuilder messages = new StringBuilder ( ) ; for ( Exception rootCause : e . guessRootCauses ( ) ) { messages . append ( rootCause . getMessage ( ) ) ; } assertThat ( messages . toString ( ) , containsString ( <str> ) ) ; } } } 
