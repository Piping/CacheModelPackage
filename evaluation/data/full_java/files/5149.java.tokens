package org . elasticsearch . action . admin . indices . mapping . put ; import com . carrotsearch . hppc . ObjectHashSet ; import org . elasticsearch . ElasticsearchGenerationException ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . IndicesRequest ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . action . support . master . AcknowledgedRequest ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentType ; import java . io . IOException ; import java . util . Map ; import static org . elasticsearch . action . ValidateActions . addValidationError ; public class PutMappingRequest extends AcknowledgedRequest < PutMappingRequest > implements IndicesRequest . Replaceable { private static ObjectHashSet < String > RESERVED_FIELDS = ObjectHashSet . from ( <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> ) ; private String [ ] indices ; private IndicesOptions indicesOptions = IndicesOptions . fromOptions ( false , false , true , true ) ; private String type ; private String source ; private boolean updateAllTypes = false ; public PutMappingRequest ( ) { } public PutMappingRequest ( String . . . indices ) { this . indices = indices ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = null ; if ( type = = null ) { validationException = addValidationError ( <str> , validationException ) ; } else if ( type . isEmpty ( ) ) { validationException = addValidationError ( <str> , validationException ) ; } if ( source = = null ) { validationException = addValidationError ( <str> , validationException ) ; } else if ( source . isEmpty ( ) ) { validationException = addValidationError ( <str> , validationException ) ; } return validationException ; } @Override public PutMappingRequest indices ( String [ ] indices ) { this . indices = indices ; return this ; } @Override public String [ ] indices ( ) { return indices ; } @Override public IndicesOptions indicesOptions ( ) { return indicesOptions ; } public PutMappingRequest indicesOptions ( IndicesOptions indicesOptions ) { this . indicesOptions = indicesOptions ; return this ; } public String type ( ) { return type ; } public PutMappingRequest type ( String type ) { this . type = type ; return this ; } public String source ( ) { return source ; } public PutMappingRequest source ( Object . . . source ) { return source ( buildFromSimplifiedDef ( type , source ) ) ; } public static XContentBuilder buildFromSimplifiedDef ( String type , Object . . . source ) { try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) ; builder . startObject ( ) ; if ( type ! = null ) { builder . startObject ( type ) ; } for ( int i = <int> ; i < source . length ; i + + ) { String fieldName = source [ i + + ] . toString ( ) ; if ( RESERVED_FIELDS . contains ( fieldName ) ) { builder . startObject ( fieldName ) ; String [ ] s1 = Strings . splitStringByCommaToArray ( source [ i ] . toString ( ) ) ; for ( String s : s1 ) { String [ ] s2 = Strings . split ( s , <str> ) ; if ( s2 . length ! = <int> ) { throw new IllegalArgumentException ( <str> + s ) ; } builder . field ( s2 [ <int> ] , s2 [ <int> ] ) ; } builder . endObject ( ) ; } } builder . startObject ( <str> ) ; for ( int i = <int> ; i < source . length ; i + + ) { String fieldName = source [ i + + ] . toString ( ) ; if ( RESERVED_FIELDS . contains ( fieldName ) ) { continue ; } builder . startObject ( fieldName ) ; String [ ] s1 = Strings . splitStringByCommaToArray ( source [ i ] . toString ( ) ) ; for ( String s : s1 ) { String [ ] s2 = Strings . split ( s , <str> ) ; if ( s2 . length ! = <int> ) { throw new IllegalArgumentException ( <str> + s ) ; } builder . field ( s2 [ <int> ] , s2 [ <int> ] ) ; } builder . endObject ( ) ; } builder . endObject ( ) ; if ( type ! = null ) { builder . endObject ( ) ; } builder . endObject ( ) ; return builder ; } catch ( Exception e ) { throw new IllegalArgumentException ( <str> , e ) ; } } public PutMappingRequest source ( XContentBuilder mappingBuilder ) { try { return source ( mappingBuilder . string ( ) ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( <str> , e ) ; } } @SuppressWarnings ( <str> ) public PutMappingRequest source ( Map mappingSource ) { try { XContentBuilder builder = XContentFactory . contentBuilder ( XContentType . JSON ) ; builder . map ( mappingSource ) ; return source ( builder . string ( ) ) ; } catch ( IOException e ) { throw new ElasticsearchGenerationException ( <str> + mappingSource + <str> , e ) ; } } public PutMappingRequest source ( String mappingSource ) { this . source = mappingSource ; return this ; } public boolean updateAllTypes ( ) { return updateAllTypes ; } public PutMappingRequest updateAllTypes ( boolean updateAllTypes ) { this . updateAllTypes = updateAllTypes ; return this ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; indices = in . readStringArray ( ) ; indicesOptions = IndicesOptions . readIndicesOptions ( in ) ; type = in . readOptionalString ( ) ; source = in . readString ( ) ; updateAllTypes = in . readBoolean ( ) ; readTimeout ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeStringArrayNullable ( indices ) ; indicesOptions . writeIndicesOptions ( out ) ; out . writeOptionalString ( type ) ; out . writeString ( source ) ; out . writeBoolean ( updateAllTypes ) ; writeTimeout ( out ) ; } } 
