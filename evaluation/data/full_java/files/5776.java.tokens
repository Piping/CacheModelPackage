package org . elasticsearch . common . inject ; import org . elasticsearch . common . Classes ; import org . elasticsearch . common . inject . internal . Annotations ; import org . elasticsearch . common . inject . internal . BindingImpl ; import org . elasticsearch . common . inject . internal . Errors ; import org . elasticsearch . common . inject . internal . ErrorsException ; import org . elasticsearch . common . inject . internal . InstanceBindingImpl ; import org . elasticsearch . common . inject . internal . InternalContext ; import org . elasticsearch . common . inject . internal . InternalFactory ; import org . elasticsearch . common . inject . internal . LinkedBindingImpl ; import org . elasticsearch . common . inject . internal . LinkedProviderBindingImpl ; import org . elasticsearch . common . inject . internal . MatcherAndConverter ; import org . elasticsearch . common . inject . internal . Nullable ; import org . elasticsearch . common . inject . internal . Scoping ; import org . elasticsearch . common . inject . internal . SourceProvider ; import org . elasticsearch . common . inject . internal . ToStringBuilder ; import org . elasticsearch . common . inject . spi . BindingTargetVisitor ; import org . elasticsearch . common . inject . spi . ConvertedConstantBinding ; import org . elasticsearch . common . inject . spi . Dependency ; import org . elasticsearch . common . inject . spi . ProviderBinding ; import org . elasticsearch . common . inject . spi . ProviderKeyBinding ; import org . elasticsearch . common . inject . util . Providers ; import java . lang . annotation . Annotation ; import java . lang . reflect . GenericArrayType ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Modifier ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import static java . util . Collections . emptySet ; import static java . util . Collections . singleton ; import static org . elasticsearch . common . inject . internal . Annotations . findScopeAnnotation ; class InjectorImpl implements Injector , Lookups { final State state ; final InjectorImpl parent ; boolean readOnly ; BindingsMultimap bindingsMultimap = new BindingsMultimap ( ) ; final Initializer initializer ; Map < Key < ? > , BindingImpl < ? > > jitBindings = new HashMap < > ( ) ; Lookups lookups = new DeferredLookups ( this ) ; InjectorImpl ( @Nullable InjectorImpl parent , State state , Initializer initializer ) { this . parent = parent ; this . state = state ; this . initializer = initializer ; if ( parent ! = null ) { localContext = parent . localContext ; } else { localContext = new ThreadLocal < Object [ ] > ( ) { @Override protected Object [ ] initialValue ( ) { return new Object [ <int> ] ; } } ; } } void index ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { index ( binding ) ; } } < T > void index ( Binding < T > binding ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } @Override public < T > List < Binding < T > > findBindingsByType ( TypeLiteral < T > type ) { return bindingsMultimap . getAll ( type ) ; } @Override public < T > BindingImpl < T > getBinding ( Key < T > key ) { Errors errors = new Errors ( key ) ; try { BindingImpl < T > result = getBindingOrThrow ( key , errors ) ; errors . throwConfigurationExceptionIfErrorsExist ( ) ; return result ; } catch ( ErrorsException e ) { throw new ConfigurationException ( errors . merge ( e . getErrors ( ) ) . getMessages ( ) ) ; } } public < T > BindingImpl < T > getBindingOrThrow ( Key < T > key , Errors errors ) throws ErrorsException { BindingImpl < T > binding = state . getExplicitBinding ( key ) ; if ( binding ! = null ) { return binding ; } return getJustInTimeBinding ( key , errors ) ; } @Override public < T > Binding < T > getBinding ( Class < T > type ) { return getBinding ( Key . get ( type ) ) ; } @Override public Injector getParent ( ) { return parent ; } @Override public Injector createChildInjector ( Iterable < ? extends Module > modules ) { return new InjectorBuilder ( ) . parentInjector ( this ) . addModules ( modules ) . build ( ) ; } @Override public Injector createChildInjector ( Module . . . modules ) { return createChildInjector ( Arrays . asList ( modules ) ) ; } private < T > BindingImpl < T > getJustInTimeBinding ( Key < T > key , Errors errors ) throws ErrorsException { synchronized ( state . lock ( ) ) { for ( InjectorImpl injector = this ; injector ! = null ; injector = injector . parent ) { @SuppressWarnings ( <str> ) BindingImpl < T > binding = ( BindingImpl < T > ) injector . jitBindings . get ( key ) ; if ( binding ! = null ) { return binding ; } } return createJustInTimeBindingRecursive ( key , errors ) ; } } static boolean isProvider ( Key < ? > key ) { return key . getTypeLiteral ( ) . getRawType ( ) . equals ( Provider . class ) ; } static boolean isMembersInjector ( Key < ? > key ) { return key . getTypeLiteral ( ) . getRawType ( ) . equals ( MembersInjector . class ) & & ! key . hasAnnotationType ( ) ; } private < T > BindingImpl < MembersInjector < T > > createMembersInjectorBinding ( Key < MembersInjector < T > > key , Errors errors ) throws ErrorsException { Type membersInjectorType = key . getTypeLiteral ( ) . getType ( ) ; if ( ! ( membersInjectorType instanceof ParameterizedType ) ) { throw errors . cannotInjectRawMembersInjector ( ) . toException ( ) ; } @SuppressWarnings ( <str> ) TypeLiteral < T > instanceType = ( TypeLiteral < T > ) TypeLiteral . get ( ( ( ParameterizedType ) membersInjectorType ) . getActualTypeArguments ( ) [ <int> ] ) ; MembersInjector < T > membersInjector = membersInjectorStore . get ( instanceType , errors ) ; InternalFactory < MembersInjector < T > > factory = new ConstantFactory < > ( Initializables . of ( membersInjector ) ) ; return new InstanceBindingImpl < > ( this , key , SourceProvider . UNKNOWN_SOURCE , factory , emptySet ( ) , membersInjector ) ; } private < T > BindingImpl < Provider < T > > createProviderBinding ( Key < Provider < T > > key , Errors errors ) throws ErrorsException { Type providerType = key . getTypeLiteral ( ) . getType ( ) ; if ( ! ( providerType instanceof ParameterizedType ) ) { throw errors . cannotInjectRawProvider ( ) . toException ( ) ; } Type entryType = ( ( ParameterizedType ) providerType ) . getActualTypeArguments ( ) [ <int> ] ; @SuppressWarnings ( <str> ) Key < T > providedKey = ( Key < T > ) key . ofType ( entryType ) ; BindingImpl < T > delegate = getBindingOrThrow ( providedKey , errors ) ; return new ProviderBindingImpl < > ( this , key , delegate ) ; } static class ProviderBindingImpl < T > extends BindingImpl < Provider < T > > implements ProviderBinding < Provider < T > > { final BindingImpl < T > providedBinding ; ProviderBindingImpl ( InjectorImpl injector , Key < Provider < T > > key , Binding < T > providedBinding ) { super ( injector , key , providedBinding . getSource ( ) , createInternalFactory ( providedBinding ) , Scoping . UNSCOPED ) ; this . providedBinding = ( BindingImpl < T > ) providedBinding ; } static < T > InternalFactory < Provider < T > > createInternalFactory ( Binding < T > providedBinding ) { final Provider < T > provider = providedBinding . getProvider ( ) ; return new InternalFactory < Provider < T > > ( ) { @Override public Provider < T > get ( Errors errors , InternalContext context , Dependency dependency ) { return provider ; } } ; } @Override public Key < ? extends T > getProvidedKey ( ) { return providedBinding . getKey ( ) ; } @Override public < V > V acceptTargetVisitor ( BindingTargetVisitor < ? super Provider < T > , V > visitor ) { return visitor . visit ( this ) ; } @Override public void applyTo ( Binder binder ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public String toString ( ) { return new ToStringBuilder ( ProviderKeyBinding . class ) . add ( <str> , getKey ( ) ) . add ( <str> , getProvidedKey ( ) ) . toString ( ) ; } } private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException { Key < String > stringKey = key . ofType ( String . class ) ; BindingImpl < String > stringBinding = state . getExplicitBinding ( stringKey ) ; if ( stringBinding = = null | | ! stringBinding . isConstant ( ) ) { return null ; } String stringValue = stringBinding . getProvider ( ) . get ( ) ; Object source = stringBinding . getSource ( ) ; TypeLiteral < T > type = key . getTypeLiteral ( ) ; MatcherAndConverter matchingConverter = state . getConverter ( stringValue , type , errors , source ) ; if ( matchingConverter = = null ) { return null ; } try { @SuppressWarnings ( <str> ) T converted = ( T ) matchingConverter . getTypeConverter ( ) . convert ( stringValue , type ) ; if ( converted = = null ) { throw errors . converterReturnedNull ( stringValue , source , type , matchingConverter ) . toException ( ) ; } if ( ! type . getRawType ( ) . isInstance ( converted ) ) { throw errors . conversionTypeError ( stringValue , source , type , matchingConverter , converted ) . toException ( ) ; } return new ConvertedConstantBindingImpl < > ( this , key , converted , stringBinding ) ; } catch ( ErrorsException e ) { throw e ; } catch ( RuntimeException e ) { throw errors . conversionError ( stringValue , source , type , matchingConverter , e ) . toException ( ) ; } } private static class ConvertedConstantBindingImpl < T > extends BindingImpl < T > implements ConvertedConstantBinding < T > { final T value ; final Provider < T > provider ; final Binding < String > originalBinding ; ConvertedConstantBindingImpl ( Injector injector , Key < T > key , T value , Binding < String > originalBinding ) { super ( injector , key , originalBinding . getSource ( ) , new ConstantFactory < > ( Initializables . of ( value ) ) , Scoping . UNSCOPED ) ; this . value = value ; provider = Providers . of ( value ) ; this . originalBinding = originalBinding ; } @Override public Provider < T > getProvider ( ) { return provider ; } @Override public < V > V acceptTargetVisitor ( BindingTargetVisitor < ? super T , V > visitor ) { return visitor . visit ( this ) ; } @Override public T getValue ( ) { return value ; } @Override public Key < String > getSourceKey ( ) { return originalBinding . getKey ( ) ; } @Override public Set < Dependency < ? > > getDependencies ( ) { return singleton ( Dependency . get ( getSourceKey ( ) ) ) ; } @Override public void applyTo ( Binder binder ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public String toString ( ) { return new ToStringBuilder ( ConvertedConstantBinding . class ) . add ( <str> , getKey ( ) ) . add ( <str> , getSourceKey ( ) ) . add ( <str> , value ) . toString ( ) ; } } < T > void initializeBinding ( BindingImpl < T > binding , Errors errors ) throws ErrorsException { if ( binding instanceof ConstructorBindingImpl < ? > ) { Key < T > key = binding . getKey ( ) ; jitBindings . put ( key , binding ) ; boolean successful = false ; try { ( ( ConstructorBindingImpl ) binding ) . initialize ( this , errors ) ; successful = true ; } finally { if ( ! successful ) { jitBindings . remove ( key ) ; } } } } < T > BindingImpl < T > createUnitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; if ( rawType . isArray ( ) | | rawType . isEnum ( ) ) { throw errors . missingImplementation ( key ) . toException ( ) ; } if ( rawType = = TypeLiteral . class ) { @SuppressWarnings ( <str> ) BindingImpl < T > binding = ( BindingImpl < T > ) createTypeLiteralBinding ( ( Key < TypeLiteral < Object > > ) key , errors ) ; return binding ; } ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ; if ( implementedBy ! = null ) { Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; return createImplementedByBinding ( key , scoping , implementedBy , errors ) ; } ProvidedBy providedBy = rawType . getAnnotation ( ProvidedBy . class ) ; if ( providedBy ! = null ) { Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; return createProvidedByBinding ( key , scoping , providedBy , errors ) ; } if ( Modifier . isAbstract ( rawType . getModifiers ( ) ) ) { throw errors . missingImplementation ( key ) . toException ( ) ; } if ( Classes . isInnerClass ( rawType ) ) { throw errors . cannotInjectInnerClass ( rawType ) . toException ( ) ; } if ( ! scoping . isExplicitlyScoped ( ) ) { Class < ? extends Annotation > scopeAnnotation = findScopeAnnotation ( errors , rawType ) ; if ( scopeAnnotation ! = null ) { scoping = Scopes . makeInjectable ( Scoping . forAnnotation ( scopeAnnotation ) , this , errors . withSource ( rawType ) ) ; } } return ConstructorBindingImpl . create ( this , key , source , scoping ) ; } private < T > BindingImpl < TypeLiteral < T > > createTypeLiteralBinding ( Key < TypeLiteral < T > > key , Errors errors ) throws ErrorsException { Type typeLiteralType = key . getTypeLiteral ( ) . getType ( ) ; if ( ! ( typeLiteralType instanceof ParameterizedType ) ) { throw errors . cannotInjectRawTypeLiteral ( ) . toException ( ) ; } ParameterizedType parameterizedType = ( ParameterizedType ) typeLiteralType ; Type innerType = parameterizedType . getActualTypeArguments ( ) [ <int> ] ; if ( ! ( innerType instanceof Class ) & & ! ( innerType instanceof GenericArrayType ) & & ! ( innerType instanceof ParameterizedType ) ) { throw errors . cannotInjectTypeLiteralOf ( innerType ) . toException ( ) ; } @SuppressWarnings ( <str> ) TypeLiteral < T > value = ( TypeLiteral < T > ) TypeLiteral . get ( innerType ) ; InternalFactory < TypeLiteral < T > > factory = new ConstantFactory < > ( Initializables . of ( value ) ) ; return new InstanceBindingImpl < > ( this , key , SourceProvider . UNKNOWN_SOURCE , factory , emptySet ( ) , value ) ; } < T > BindingImpl < T > createProvidedByBinding ( Key < T > key , Scoping scoping , ProvidedBy providedBy , Errors errors ) throws ErrorsException { final Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; final Class < ? extends Provider < ? > > providerType = providedBy . value ( ) ; if ( providerType = = rawType ) { throw errors . recursiveProviderType ( ) . toException ( ) ; } @SuppressWarnings ( <str> ) final Key < ? extends Provider < T > > providerKey = ( Key < ? extends Provider < T > > ) Key . get ( providerType ) ; final BindingImpl < ? extends Provider < ? > > providerBinding = getBindingOrThrow ( providerKey , errors ) ; InternalFactory < T > internalFactory = new InternalFactory < T > ( ) { @Override public T get ( Errors errors , InternalContext context , Dependency dependency ) throws ErrorsException { errors = errors . withSource ( providerKey ) ; Provider < ? > provider = providerBinding . getInternalFactory ( ) . get ( errors , context , dependency ) ; try { Object o = provider . get ( ) ; if ( o ! = null & & ! rawType . isInstance ( o ) ) { throw errors . subtypeNotProvided ( providerType , rawType ) . toException ( ) ; } @SuppressWarnings ( <str> ) T t = ( T ) o ; return t ; } catch ( RuntimeException e ) { throw errors . errorInProvider ( e ) . toException ( ) ; } } } ; return new LinkedProviderBindingImpl < > ( this , key , rawType , Scopes . < T > scope ( key , this , internalFactory , scoping ) , scoping , providerKey ) ; } < T > BindingImpl < T > createImplementedByBinding ( Key < T > key , Scoping scoping , ImplementedBy implementedBy , Errors errors ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; Class < ? > implementationType = implementedBy . value ( ) ; if ( implementationType = = rawType ) { throw errors . recursiveImplementationType ( ) . toException ( ) ; } if ( ! rawType . isAssignableFrom ( implementationType ) ) { throw errors . notASubtype ( implementationType , rawType ) . toException ( ) ; } @SuppressWarnings ( <str> ) Class < ? extends T > subclass = ( Class < ? extends T > ) implementationType ; final Key < ? extends T > targetKey = Key . get ( subclass ) ; final BindingImpl < ? extends T > targetBinding = getBindingOrThrow ( targetKey , errors ) ; InternalFactory < T > internalFactory = new InternalFactory < T > ( ) { @Override public T get ( Errors errors , InternalContext context , Dependency < ? > dependency ) throws ErrorsException { return targetBinding . getInternalFactory ( ) . get ( errors . withSource ( targetKey ) , context , dependency ) ; } } ; return new LinkedBindingImpl < > ( this , key , rawType , Scopes . < T > scope ( key , this , internalFactory , scoping ) , scoping , targetKey ) ; } private < T > BindingImpl < T > createJustInTimeBindingRecursive ( Key < T > key , Errors errors ) throws ErrorsException { if ( parent ! = null & & ! parent . readOnly ) { try { return parent . createJustInTimeBindingRecursive ( key , new Errors ( ) ) ; } catch ( ErrorsException ignored ) { } } if ( state . isBlacklisted ( key ) ) { throw errors . childBindingAlreadySet ( key ) . toException ( ) ; } BindingImpl < T > binding = createJustInTimeBinding ( key , errors ) ; state . parent ( ) . blacklist ( key ) ; jitBindings . put ( key , binding ) ; return binding ; } < T > BindingImpl < T > createJustInTimeBinding ( Key < T > key , Errors errors ) throws ErrorsException { if ( state . isBlacklisted ( key ) ) { throw errors . childBindingAlreadySet ( key ) . toException ( ) ; } if ( isProvider ( key ) ) { @SuppressWarnings ( <str> ) BindingImpl binding = createProviderBinding ( ( Key ) key , errors ) ; return binding ; } if ( isMembersInjector ( key ) ) { @SuppressWarnings ( <str> ) BindingImpl binding = createMembersInjectorBinding ( ( Key ) key , errors ) ; return binding ; } BindingImpl < T > convertedBinding = convertConstantStringBinding ( key , errors ) ; if ( convertedBinding ! = null ) { return convertedBinding ; } if ( key . hasAnnotationType ( ) ) { if ( key . hasAttributes ( ) ) { try { Errors ignored = new Errors ( ) ; return getBindingOrThrow ( key . withoutAttributes ( ) , ignored ) ; } catch ( ErrorsException ignored ) { } } throw errors . missingImplementation ( key ) . toException ( ) ; } Object source = key . getTypeLiteral ( ) . getRawType ( ) ; BindingImpl < T > binding = createUnitializedBinding ( key , Scoping . UNSCOPED , source , errors ) ; initializeBinding ( binding , errors ) ; return binding ; } < T > InternalFactory < ? extends T > getInternalFactory ( Key < T > key , Errors errors ) throws ErrorsException { return getBindingOrThrow ( key , errors ) . getInternalFactory ( ) ; } @Override public Map < Key < ? > , Binding < ? > > getBindings ( ) { return state . getExplicitBindingsThisLevel ( ) ; } private static class BindingsMultimap { final Map < TypeLiteral < ? > , List < Binding < ? > > > multimap = new HashMap < > ( ) ; < T > void put ( TypeLiteral < T > type , Binding < T > binding ) { List < Binding < ? > > bindingsForType = multimap . get ( type ) ; if ( bindingsForType = = null ) { bindingsForType = new ArrayList < > ( ) ; multimap . put ( type , bindingsForType ) ; } bindingsForType . add ( binding ) ; } @SuppressWarnings ( <str> ) < T > List < Binding < T > > getAll ( TypeLiteral < T > type ) { List < Binding < ? > > bindings = multimap . get ( type ) ; return bindings ! = null ? Collections . < Binding < T > > unmodifiableList ( ( List ) multimap . get ( type ) ) : Collections . < Binding < T > > emptyList ( ) ; } } SingleParameterInjector < ? > [ ] getParametersInjectors ( List < Dependency < ? > > parameters , Errors errors ) throws ErrorsException { if ( parameters . isEmpty ( ) ) { return null ; } int numErrorsBefore = errors . size ( ) ; SingleParameterInjector < ? > [ ] result = new SingleParameterInjector < ? > [ parameters . size ( ) ] ; int i = <int> ; for ( Dependency < ? > parameter : parameters ) { try { result [ i + + ] = createParameterInjector ( parameter , errors . withSource ( parameter ) ) ; } catch ( ErrorsException rethrownBelow ) { } } errors . throwIfNewErrors ( numErrorsBefore ) ; return result ; } < T > SingleParameterInjector < T > createParameterInjector ( final Dependency < T > dependency , final Errors errors ) throws ErrorsException { InternalFactory < ? extends T > factory = getInternalFactory ( dependency . getKey ( ) , errors ) ; return new SingleParameterInjector < > ( dependency , factory ) ; } interface MethodInvoker { Object invoke ( Object target , Object . . . parameters ) throws IllegalAccessException , InvocationTargetException ; } ConstructorInjectorStore constructors = new ConstructorInjectorStore ( this ) ; MembersInjectorStore membersInjectorStore ; @Override @SuppressWarnings ( <str> ) public void injectMembers ( Object instance ) { MembersInjector membersInjector = getMembersInjector ( instance . getClass ( ) ) ; membersInjector . injectMembers ( instance ) ; } @Override public < T > MembersInjector < T > getMembersInjector ( TypeLiteral < T > typeLiteral ) { Errors errors = new Errors ( typeLiteral ) ; try { return membersInjectorStore . get ( typeLiteral , errors ) ; } catch ( ErrorsException e ) { throw new ConfigurationException ( errors . merge ( e . getErrors ( ) ) . getMessages ( ) ) ; } } @Override public < T > MembersInjector < T > getMembersInjector ( Class < T > type ) { return getMembersInjector ( TypeLiteral . get ( type ) ) ; } @Override public < T > Provider < T > getProvider ( Class < T > type ) { return getProvider ( Key . get ( type ) ) ; } < T > Provider < T > getProviderOrThrow ( final Key < T > key , Errors errors ) throws ErrorsException { final InternalFactory < ? extends T > factory = getInternalFactory ( key , errors ) ; if ( factory instanceof InternalFactory . Instance ) { return new Provider < T > ( ) { @Override public T get ( ) { try { return ( T ) ( ( InternalFactory . Instance ) factory ) . get ( null , null , null ) ; } catch ( ErrorsException e ) { } assert false ; return null ; } } ; } final Dependency < T > dependency = Dependency . get ( key ) ; return new Provider < T > ( ) { @Override public T get ( ) { final Errors errors = new Errors ( dependency ) ; try { T t = callInContext ( new ContextualCallable < T > ( ) { @Override public T call ( InternalContext context ) throws ErrorsException { context . setDependency ( dependency ) ; try { return factory . get ( errors , context , dependency ) ; } finally { context . setDependency ( null ) ; } } } ) ; errors . throwIfNewErrors ( <int> ) ; return t ; } catch ( ErrorsException e ) { throw new ProvisionException ( errors . merge ( e . getErrors ( ) ) . getMessages ( ) ) ; } } @Override public String toString ( ) { return factory . toString ( ) ; } } ; } @Override public < T > Provider < T > getProvider ( final Key < T > key ) { Errors errors = new Errors ( key ) ; try { Provider < T > result = getProviderOrThrow ( key , errors ) ; errors . throwIfNewErrors ( <int> ) ; return result ; } catch ( ErrorsException e ) { throw new ConfigurationException ( errors . merge ( e . getErrors ( ) ) . getMessages ( ) ) ; } } @Override public < T > T getInstance ( Key < T > key ) { return getProvider ( key ) . get ( ) ; } @Override public < T > T getInstance ( Class < T > type ) { return getProvider ( type ) . get ( ) ; } final ThreadLocal < Object [ ] > localContext ; < T > T callInContext ( ContextualCallable < T > callable ) throws ErrorsException { Object [ ] reference = localContext . get ( ) ; if ( reference [ <int> ] = = null ) { reference [ <int> ] = new InternalContext ( ) ; try { return callable . call ( ( InternalContext ) reference [ <int> ] ) ; } finally { reference [ <int> ] = null ; } } else { return callable . call ( ( InternalContext ) reference [ <int> ] ) ; } } @Override public String toString ( ) { return new ToStringBuilder ( Injector . class ) . add ( <str> , state . getExplicitBindingsThisLevel ( ) . values ( ) ) . toString ( ) ; } public void clearCache ( ) { state . clearBlacklisted ( ) ; constructors = new ConstructorInjectorStore ( this ) ; membersInjectorStore = new MembersInjectorStore ( this , state . getTypeListenerBindings ( ) ) ; jitBindings = new HashMap < > ( ) ; } public void readOnlyAllSingletons ( ) { readOnly = true ; state . makeAllBindingsToEagerSingletons ( this ) ; bindingsMultimap = new BindingsMultimap ( ) ; index ( ) ; } } 
