package org . elasticsearch . index . mapper ; import org . elasticsearch . Version ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . compress . CompressedXContent ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . analysis . AnalysisService ; import org . elasticsearch . index . mapper . object . RootObjectMapper ; import org . elasticsearch . index . similarity . SimilarityService ; import org . elasticsearch . indices . mapper . MapperRegistry ; import java . util . * ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . index . mapper . MapperBuilders . doc ; public class DocumentMapperParser { private final Settings indexSettings ; final MapperService mapperService ; final AnalysisService analysisService ; private static final ESLogger logger = Loggers . getLogger ( DocumentMapperParser . class ) ; private final SimilarityService similarityService ; private final RootObjectMapper . TypeParser rootObjectTypeParser = new RootObjectMapper . TypeParser ( ) ; private final Version indexVersionCreated ; private final ParseFieldMatcher parseFieldMatcher ; private final Map < String , Mapper . TypeParser > typeParsers ; private final Map < String , MetadataFieldMapper . TypeParser > rootTypeParsers ; public DocumentMapperParser ( IndexSettings indexSettings , MapperService mapperService , AnalysisService analysisService , SimilarityService similarityService , MapperRegistry mapperRegistry ) { this . indexSettings = indexSettings . getSettings ( ) ; this . parseFieldMatcher = new ParseFieldMatcher ( this . indexSettings ) ; this . mapperService = mapperService ; this . analysisService = analysisService ; this . similarityService = similarityService ; this . typeParsers = mapperRegistry . getMapperParsers ( ) ; this . rootTypeParsers = mapperRegistry . getMetadataMapperParsers ( ) ; indexVersionCreated = indexSettings . getIndexVersionCreated ( ) ; } public Mapper . TypeParser . ParserContext parserContext ( String type ) { return new Mapper . TypeParser . ParserContext ( type , analysisService , similarityService : : getSimilarity , mapperService , typeParsers : : get , indexVersionCreated , parseFieldMatcher ) ; } public DocumentMapper parse ( String source ) throws MapperParsingException { return parse ( null , source ) ; } public DocumentMapper parse ( @Nullable String type , String source ) throws MapperParsingException { return parse ( type , source , null ) ; } public DocumentMapper parse ( @Nullable String type , String source , String defaultSource ) throws MapperParsingException { Map < String , Object > mapping = null ; if ( source ! = null ) { Tuple < String , Map < String , Object > > t = extractMapping ( type , source ) ; type = t . v1 ( ) ; mapping = t . v2 ( ) ; } if ( mapping = = null ) { mapping = new HashMap < > ( ) ; } return parse ( type , mapping , defaultSource ) ; } public DocumentMapper parseCompressed ( @Nullable String type , CompressedXContent source ) throws MapperParsingException { return parseCompressed ( type , source , null ) ; } public DocumentMapper parseCompressed ( @Nullable String type , CompressedXContent source , String defaultSource ) throws MapperParsingException { Map < String , Object > mapping = null ; if ( source ! = null ) { Map < String , Object > root = XContentHelper . convertToMap ( source . compressedReference ( ) , true ) . v2 ( ) ; Tuple < String , Map < String , Object > > t = extractMapping ( type , root ) ; type = t . v1 ( ) ; mapping = t . v2 ( ) ; } if ( mapping = = null ) { mapping = new HashMap < > ( ) ; } return parse ( type , mapping , defaultSource ) ; } @SuppressWarnings ( { <str> } ) private DocumentMapper parse ( String type , Map < String , Object > mapping , String defaultSource ) throws MapperParsingException { if ( type = = null ) { throw new MapperParsingException ( <str> ) ; } if ( defaultSource ! = null ) { Tuple < String , Map < String , Object > > t = extractMapping ( MapperService . DEFAULT_MAPPING , defaultSource ) ; if ( t . v2 ( ) ! = null ) { XContentHelper . mergeDefaults ( mapping , t . v2 ( ) ) ; } } Mapper . TypeParser . ParserContext parserContext = parserContext ( type ) ; DocumentMapper . Builder docBuilder = doc ( indexSettings , ( RootObjectMapper . Builder ) rootObjectTypeParser . parse ( type , mapping , parserContext ) , mapperService ) ; Iterator < Map . Entry < String , Object > > iterator = mapping . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String fieldName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object fieldNode = entry . getValue ( ) ; MetadataFieldMapper . TypeParser typeParser = rootTypeParsers . get ( fieldName ) ; if ( typeParser ! = null ) { iterator . remove ( ) ; Map < String , Object > fieldNodeMap = ( Map < String , Object > ) fieldNode ; docBuilder . put ( typeParser . parse ( fieldName , fieldNodeMap , parserContext ) ) ; fieldNodeMap . remove ( <str> ) ; checkNoRemainingFields ( fieldName , fieldNodeMap , parserContext . indexVersionCreated ( ) ) ; } } Map < String , Object > meta = ( Map < String , Object > ) mapping . remove ( <str> ) ; if ( meta ! = null ) { docBuilder . meta ( unmodifiableMap ( new HashMap < > ( meta ) ) ) ; } checkNoRemainingFields ( mapping , parserContext . indexVersionCreated ( ) , <str> ) ; return docBuilder . build ( mapperService , this ) ; } public static void checkNoRemainingFields ( String fieldName , Map < String , Object > fieldNodeMap , Version indexVersionCreated ) { checkNoRemainingFields ( fieldNodeMap , indexVersionCreated , <str> + fieldName + <str> ) ; } public static void checkNoRemainingFields ( Map < String , Object > fieldNodeMap , Version indexVersionCreated , String message ) { if ( ! fieldNodeMap . isEmpty ( ) ) { if ( indexVersionCreated . onOrAfter ( Version . V_2_0_0_beta1 ) ) { throw new MapperParsingException ( message + getRemainingFields ( fieldNodeMap ) ) ; } else { logger . debug ( message + <str> , getRemainingFields ( fieldNodeMap ) ) ; } } } private static String getRemainingFields ( Map < String , ? > map ) { StringBuilder remainingFields = new StringBuilder ( ) ; for ( String key : map . keySet ( ) ) { remainingFields . append ( <str> ) . append ( key ) . append ( <str> ) . append ( map . get ( key ) ) . append ( <str> ) ; } return remainingFields . toString ( ) ; } private Tuple < String , Map < String , Object > > extractMapping ( String type , String source ) throws MapperParsingException { Map < String , Object > root ; try ( XContentParser parser = XContentFactory . xContent ( source ) . createParser ( source ) ) { root = parser . mapOrdered ( ) ; } catch ( Exception e ) { throw new MapperParsingException ( <str> , e ) ; } return extractMapping ( type , root ) ; } @SuppressWarnings ( { <str> } ) private Tuple < String , Map < String , Object > > extractMapping ( String type , Map < String , Object > root ) throws MapperParsingException { if ( root . size ( ) = = <int> ) { throw new MapperParsingException ( <str> ) ; } String rootName = root . keySet ( ) . iterator ( ) . next ( ) ; Tuple < String , Map < String , Object > > mapping ; if ( type = = null | | type . equals ( rootName ) ) { mapping = new Tuple < > ( rootName , ( Map < String , Object > ) root . get ( rootName ) ) ; } else { mapping = new Tuple < > ( type , root ) ; } return mapping ; } } 
