package org . gradle . api . tasks . diagnostics . internal ; import org . apache . commons . lang . StringUtils ; import org . gradle . api . Project ; import org . gradle . api . Rule ; import org . gradle . initialization . BuildClientMetaData ; import org . gradle . logging . StyledTextOutput ; import org . gradle . util . CollectionUtils ; import org . gradle . util . GUtil ; import org . gradle . util . Path ; import java . util . List ; import java . util . SortedSet ; import java . util . TreeSet ; import static org . gradle . logging . StyledTextOutput . Style . * ; public class TaskReportRenderer extends TextReportRenderer { private boolean currentProjectHasTasks ; private boolean currentProjectHasRules ; private boolean hasContent ; private boolean detail ; @Override public void startProject ( Project project ) { currentProjectHasTasks = false ; currentProjectHasRules = false ; hasContent = false ; detail = false ; super . startProject ( project ) ; } @Override protected String createHeader ( Project project ) { String header = super . createHeader ( project ) ; return <str> + StringUtils . uncapitalize ( header ) ; } public void showDetail ( boolean detail ) { this . detail = detail ; } public void addDefaultTasks ( List < String > defaultTaskNames ) { if ( defaultTaskNames . size ( ) > <int> ) { getTextOutput ( ) . formatln ( <str> , CollectionUtils . join ( <str> , defaultTaskNames ) ) ; hasContent = true ; } } public void startTaskGroup ( String taskGroup ) { if ( ! GUtil . isTrue ( taskGroup ) ) { addSubheading ( <str> ) ; } else { addSubheading ( StringUtils . capitalize ( taskGroup ) + <str> ) ; } currentProjectHasTasks = true ; } public void addTask ( TaskDetails task ) { writeTask ( task , <str> ) ; } public void addChildTask ( TaskDetails task ) { if ( detail ) { writeTask ( task , <str> ) ; } } private void writeTask ( TaskDetails task , String prefix ) { getTextOutput ( ) . text ( prefix ) ; getTextOutput ( ) . withStyle ( Identifier ) . text ( task . getPath ( ) ) ; if ( GUtil . isTrue ( task . getDescription ( ) ) ) { getTextOutput ( ) . withStyle ( Description ) . format ( <str> , task . getDescription ( ) ) ; } if ( detail ) { SortedSet < Path > sortedDependencies = new TreeSet < Path > ( ) ; for ( TaskDetails dependency : task . getDependencies ( ) ) { sortedDependencies . add ( dependency . getPath ( ) ) ; } if ( sortedDependencies . size ( ) > <int> ) { getTextOutput ( ) . withStyle ( Info ) . format ( <str> , CollectionUtils . join ( <str> , sortedDependencies ) ) ; } } getTextOutput ( ) . println ( ) ; } private void addSubheading ( String header ) { if ( hasContent ) { getTextOutput ( ) . println ( ) ; } hasContent = true ; getBuilder ( ) . subheading ( header ) ; } public void completeTasks ( ) { if ( ! currentProjectHasTasks ) { getTextOutput ( ) . withStyle ( Info ) . println ( <str> ) ; hasContent = true ; } } public void addRule ( Rule rule ) { if ( ! currentProjectHasRules ) { addSubheading ( <str> ) ; } getTextOutput ( ) . println ( GUtil . elvis ( rule . getDescription ( ) , <str> ) ) ; currentProjectHasRules = true ; } @Override public void complete ( ) { if ( ! detail ) { StyledTextOutput output = getTextOutput ( ) ; BuildClientMetaData clientMetaData = getClientMetaData ( ) ; output . println ( ) ; output . text ( <str> ) ; clientMetaData . describeCommand ( output . withStyle ( UserInput ) , <str> ) ; output . println ( ) ; output . println ( ) ; output . text ( <str> ) ; clientMetaData . describeCommand ( output . withStyle ( UserInput ) , <str> ) ; output . println ( ) ; } super . complete ( ) ; } } 
