package org . gradle . api . plugins . antlr . internal . antlr2 ; import antlr . collections . impl . IndexedVector ; import antlr . preprocessor . GrammarFile ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; public class GrammarDelegate { public static List < GrammarDelegate > extractGrammarDelegates ( GrammarFile antlrGrammarFile ) { List < GrammarDelegate > grammarDelegates = new ArrayList < GrammarDelegate > ( ) ; Enumeration grammarFileGramars = antlrGrammarFile . getGrammars ( ) . elements ( ) ; while ( grammarFileGramars . hasMoreElements ( ) ) { grammarDelegates . add ( new GrammarDelegate ( grammarFileGramars . nextElement ( ) ) ) ; } return grammarDelegates ; } private final String className ; private final String importVocab ; private final String exportVocab ; private final GrammarDelegate superGrammarDelegate ; public GrammarDelegate ( Object antlrGrammarMetadata ) { try { final Method getNameMethod = ANTLR_GRAMMAR_CLASS . getDeclaredMethod ( <str> , NO_ARG_SIGNATURE ) ; getNameMethod . setAccessible ( true ) ; this . className = ( String ) getNameMethod . invoke ( antlrGrammarMetadata , NO_ARGS ) ; final Method getSuperGrammarMethod = ANTLR_GRAMMAR_CLASS . getMethod ( <str> , NO_ARG_SIGNATURE ) ; getSuperGrammarMethod . setAccessible ( true ) ; final Object antlrSuperGrammarGrammarMetadata = getSuperGrammarMethod . invoke ( antlrGrammarMetadata , NO_ARGS ) ; this . superGrammarDelegate = antlrSuperGrammarGrammarMetadata = = null ? null : new GrammarDelegate ( antlrSuperGrammarGrammarMetadata ) ; Method getOptionsMethod = ANTLR_GRAMMAR_CLASS . getMethod ( <str> , NO_ARG_SIGNATURE ) ; getOptionsMethod . setAccessible ( true ) ; IndexedVector options = ( IndexedVector ) getOptionsMethod . invoke ( antlrGrammarMetadata , NO_ARGS ) ; Method getRHSMethod = ANTLR_OPTION_CLASS . getMethod ( <str> , NO_ARG_SIGNATURE ) ; getRHSMethod . setAccessible ( true ) ; final Object importVocabOption = options = = null ? null : options . getElement ( <str> ) ; this . importVocab = importVocabOption = = null ? null : vocabName ( ( String ) getRHSMethod . invoke ( importVocabOption , NO_ARGS ) ) ; final Object exportVocabOption = options = = null ? null : options . getElement ( <str> ) ; this . exportVocab = exportVocabOption = = null ? null : vocabName ( ( String ) getRHSMethod . invoke ( exportVocabOption , NO_ARGS ) ) ; } catch ( Throwable t ) { throw new IllegalStateException ( <str> , t ) ; } } public String getClassName ( ) { return className ; } public String getImportVocab ( ) { return importVocab ; } public String getExportVocab ( ) { return exportVocab ; } public GrammarDelegate getSuperGrammarDelegate ( ) { return superGrammarDelegate ; } private GrammarMetadata associatedGrammarMetadata ; public void associateWith ( GrammarMetadata associatedGrammarMetadata ) { this . associatedGrammarMetadata = associatedGrammarMetadata ; } public GrammarMetadata getAssociatedGrammarMetadata ( ) { return associatedGrammarMetadata ; } private String vocabName ( String vocabName ) { if ( vocabName = = null ) { return null ; } vocabName = vocabName . trim ( ) ; if ( vocabName . endsWith ( <str> ) ) { vocabName = vocabName . substring ( <int> , vocabName . length ( ) - <int> ) ; } return vocabName ; } private static final Class ANTLR_GRAMMAR_CLASS ; private static final Class ANTLR_OPTION_CLASS ; static { ANTLR_GRAMMAR_CLASS = loadAntlrClass ( <str> ) ; ANTLR_OPTION_CLASS = loadAntlrClass ( <str> ) ; } public static final Class [ ] NO_ARG_SIGNATURE = new Class [ <int> ] ; public static final Object [ ] NO_ARGS = new Object [ <int> ] ; private static Class loadAntlrClass ( String className ) { try { return Class . forName ( className , true , GrammarDelegate . class . getClassLoader ( ) ) ; } catch ( ClassNotFoundException e ) { throw new IllegalStateException ( <str> + className + <str> , e ) ; } } } 
