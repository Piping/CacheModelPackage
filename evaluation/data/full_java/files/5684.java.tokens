package org . elasticsearch . common . breaker ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . unit . ByteSizeValue ; import java . util . concurrent . atomic . AtomicLong ; public class MemoryCircuitBreaker implements CircuitBreaker { private final long memoryBytesLimit ; private final double overheadConstant ; private final AtomicLong used ; private final AtomicLong trippedCount ; private final ESLogger logger ; public MemoryCircuitBreaker ( ByteSizeValue limit , double overheadConstant , ESLogger logger ) { this ( limit , overheadConstant , null , logger ) ; } public MemoryCircuitBreaker ( ByteSizeValue limit , double overheadConstant , MemoryCircuitBreaker oldBreaker , ESLogger logger ) { this . memoryBytesLimit = limit . bytes ( ) ; this . overheadConstant = overheadConstant ; if ( oldBreaker = = null ) { this . used = new AtomicLong ( <int> ) ; this . trippedCount = new AtomicLong ( <int> ) ; } else { this . used = oldBreaker . used ; this . trippedCount = oldBreaker . trippedCount ; } this . logger = logger ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , this . memoryBytesLimit , limit , this . overheadConstant ) ; } } @Override public void circuitBreak ( String fieldName , long bytesNeeded ) throws CircuitBreakingException { this . trippedCount . incrementAndGet ( ) ; final String message = <str> + fieldName + <str> + memoryBytesLimit + <str> + new ByteSizeValue ( memoryBytesLimit ) + <str> ; logger . debug ( message ) ; throw new CircuitBreakingException ( message ) ; } @Override public double addEstimateBytesAndMaybeBreak ( long bytes , String label ) throws CircuitBreakingException { if ( memoryBytesLimit = = <int> ) { circuitBreak ( label , bytes ) ; } long newUsed ; if ( this . memoryBytesLimit = = - <int> ) { newUsed = this . used . addAndGet ( bytes ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , new ByteSizeValue ( bytes ) , label , new ByteSizeValue ( newUsed ) ) ; } return newUsed ; } long currentUsed ; do { currentUsed = this . used . get ( ) ; newUsed = currentUsed + bytes ; long newUsedWithOverhead = ( long ) ( newUsed * overheadConstant ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , new ByteSizeValue ( bytes ) , label , new ByteSizeValue ( newUsed ) , memoryBytesLimit , new ByteSizeValue ( memoryBytesLimit ) , newUsedWithOverhead , new ByteSizeValue ( newUsedWithOverhead ) ) ; } if ( memoryBytesLimit > <int> & & newUsedWithOverhead > memoryBytesLimit ) { logger . warn ( <str> , newUsedWithOverhead , new ByteSizeValue ( newUsedWithOverhead ) , label , memoryBytesLimit , new ByteSizeValue ( memoryBytesLimit ) ) ; circuitBreak ( label , newUsedWithOverhead ) ; } } while ( ! this . used . compareAndSet ( currentUsed , newUsed ) ) ; return newUsed ; } @Override public long addWithoutBreaking ( long bytes ) { long u = used . addAndGet ( bytes ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( <str> , bytes , u ) ; } assert u > = <int> : <str> + u + <str> ; return u ; } @Override public long getUsed ( ) { return this . used . get ( ) ; } @Override public long getLimit ( ) { return this . memoryBytesLimit ; } @Override public double getOverhead ( ) { return this . overheadConstant ; } @Override public long getTrippedCount ( ) { return this . trippedCount . get ( ) ; } @Override public String getName ( ) { return FIELDDATA ; } } 
