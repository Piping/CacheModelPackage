package org . elasticsearch . discovery ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . discovery . zen . fd . FaultDetection ; import org . elasticsearch . discovery . zen . fd . MasterFaultDetection ; import org . elasticsearch . discovery . zen . fd . NodesFaultDetection ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . cluster . NoopClusterService ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportConnectionListener ; import org . elasticsearch . transport . local . LocalTransport ; import org . hamcrest . Matcher ; import org . hamcrest . Matchers ; import org . junit . After ; import org . junit . Before ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import static java . util . Collections . emptyMap ; import static org . hamcrest . Matchers . equalTo ; public class ZenFaultDetectionTests extends ESTestCase { protected ThreadPool threadPool ; protected static final Version version0 = Version . fromId ( <int> ) ; protected DiscoveryNode nodeA ; protected MockTransportService serviceA ; protected static final Version version1 = Version . fromId ( <int> ) ; protected DiscoveryNode nodeB ; protected MockTransportService serviceB ; @Override @Before public void setUp ( ) throws Exception { super . setUp ( ) ; threadPool = new ThreadPool ( getClass ( ) . getName ( ) ) ; serviceA = build ( Settings . builder ( ) . put ( <str> , <str> ) . build ( ) , version0 ) ; nodeA = new DiscoveryNode ( <str> , <str> , serviceA . boundAddress ( ) . publishAddress ( ) , emptyMap ( ) , version0 ) ; serviceB = build ( Settings . builder ( ) . put ( <str> , <str> ) . build ( ) , version1 ) ; nodeB = new DiscoveryNode ( <str> , <str> , serviceB . boundAddress ( ) . publishAddress ( ) , emptyMap ( ) , version1 ) ; final CountDownLatch latch = new CountDownLatch ( <int> ) ; TransportConnectionListener waitForConnection = new TransportConnectionListener ( ) { @Override public void onNodeConnected ( DiscoveryNode node ) { latch . countDown ( ) ; } @Override public void onNodeDisconnected ( DiscoveryNode node ) { fail ( <str> + node ) ; } } ; serviceA . addConnectionListener ( waitForConnection ) ; serviceB . addConnectionListener ( waitForConnection ) ; serviceA . connectToNode ( nodeB ) ; serviceA . connectToNode ( nodeA ) ; serviceB . connectToNode ( nodeA ) ; serviceB . connectToNode ( nodeB ) ; assertThat ( <str> , latch . await ( <int> , TimeUnit . SECONDS ) , equalTo ( true ) ) ; serviceA . removeConnectionListener ( waitForConnection ) ; serviceB . removeConnectionListener ( waitForConnection ) ; } @Override @After public void tearDown ( ) throws Exception { super . tearDown ( ) ; serviceA . close ( ) ; serviceB . close ( ) ; terminate ( threadPool ) ; } protected MockTransportService build ( Settings settings , Version version ) { MockTransportService transportService = new MockTransportService ( Settings . EMPTY , new LocalTransport ( settings , threadPool , version , new NamedWriteableRegistry ( ) ) , threadPool ) ; transportService . start ( ) ; return transportService ; } private DiscoveryNodes buildNodesForA ( boolean master ) { DiscoveryNodes . Builder builder = DiscoveryNodes . builder ( ) ; builder . put ( nodeA ) ; builder . put ( nodeB ) ; builder . localNodeId ( nodeA . id ( ) ) ; builder . masterNodeId ( master ? nodeA . id ( ) : nodeB . id ( ) ) ; return builder . build ( ) ; } private DiscoveryNodes buildNodesForB ( boolean master ) { DiscoveryNodes . Builder builder = DiscoveryNodes . builder ( ) ; builder . put ( nodeA ) ; builder . put ( nodeB ) ; builder . localNodeId ( nodeB . id ( ) ) ; builder . masterNodeId ( master ? nodeB . id ( ) : nodeA . id ( ) ) ; return builder . build ( ) ; } public void testNodesFaultDetectionConnectOnDisconnect ( ) throws InterruptedException { Settings . Builder settings = Settings . builder ( ) ; boolean shouldRetry = randomBoolean ( ) ; settings . put ( FaultDetection . SETTING_CONNECT_ON_NETWORK_DISCONNECT , shouldRetry ) . put ( FaultDetection . SETTING_PING_INTERVAL , <str> ) ; ClusterState clusterState = ClusterState . builder ( new ClusterName ( <str> ) ) . nodes ( buildNodesForA ( true ) ) . build ( ) ; NodesFaultDetection nodesFDA = new NodesFaultDetection ( settings . build ( ) , threadPool , serviceA , clusterState . getClusterName ( ) ) ; nodesFDA . setLocalNode ( nodeA ) ; NodesFaultDetection nodesFDB = new NodesFaultDetection ( settings . build ( ) , threadPool , serviceB , clusterState . getClusterName ( ) ) ; nodesFDB . setLocalNode ( nodeB ) ; final CountDownLatch pingSent = new CountDownLatch ( <int> ) ; nodesFDB . addListener ( new NodesFaultDetection . Listener ( ) { @Override public void onPingReceived ( NodesFaultDetection . PingRequest pingRequest ) { pingSent . countDown ( ) ; } } ) ; nodesFDA . updateNodesAndPing ( clusterState ) ; pingSent . await ( <int> , TimeUnit . SECONDS ) ; final String [ ] failureReason = new String [ <int> ] ; final DiscoveryNode [ ] failureNode = new DiscoveryNode [ <int> ] ; final CountDownLatch notified = new CountDownLatch ( <int> ) ; nodesFDA . addListener ( new NodesFaultDetection . Listener ( ) { @Override public void onNodeFailure ( DiscoveryNode node , String reason ) { failureNode [ <int> ] = node ; failureReason [ <int> ] = reason ; notified . countDown ( ) ; } } ) ; serviceB . stop ( ) ; notified . await ( <int> , TimeUnit . SECONDS ) ; assertEquals ( nodeB , failureNode [ <int> ] ) ; Matcher < String > matcher = Matchers . containsString ( <str> ) ; if ( ! shouldRetry ) { matcher = Matchers . not ( matcher ) ; } assertThat ( failureReason [ <int> ] , matcher ) ; } public void testMasterFaultDetectionConnectOnDisconnect ( ) throws InterruptedException { Settings . Builder settings = Settings . builder ( ) ; boolean shouldRetry = randomBoolean ( ) ; settings . put ( FaultDetection . SETTING_CONNECT_ON_NETWORK_DISCONNECT , shouldRetry ) . put ( FaultDetection . SETTING_PING_INTERVAL , <str> ) ; ClusterName clusterName = new ClusterName ( randomAsciiOfLengthBetween ( <int> , <int> ) ) ; final ClusterState state = ClusterState . builder ( clusterName ) . nodes ( buildNodesForA ( false ) ) . build ( ) ; MasterFaultDetection masterFD = new MasterFaultDetection ( settings . build ( ) , threadPool , serviceA , clusterName , new NoopClusterService ( state ) ) ; masterFD . start ( nodeB , <str> ) ; final String [ ] failureReason = new String [ <int> ] ; final DiscoveryNode [ ] failureNode = new DiscoveryNode [ <int> ] ; final CountDownLatch notified = new CountDownLatch ( <int> ) ; masterFD . addListener ( new MasterFaultDetection . Listener ( ) { @Override public void onMasterFailure ( DiscoveryNode masterNode , Throwable cause , String reason ) { failureNode [ <int> ] = masterNode ; failureReason [ <int> ] = reason ; notified . countDown ( ) ; } } ) ; serviceB . stop ( ) ; notified . await ( <int> , TimeUnit . SECONDS ) ; assertEquals ( nodeB , failureNode [ <int> ] ) ; Matcher < String > matcher = Matchers . containsString ( <str> ) ; if ( ! shouldRetry ) { matcher = Matchers . not ( matcher ) ; } assertThat ( failureReason [ <int> ] , matcher ) ; } } 
