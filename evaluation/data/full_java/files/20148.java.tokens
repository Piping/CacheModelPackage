package io . netty . testsuite . transport . socket ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelOption ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . socket . ChannelInputShutdownEvent ; import io . netty . channel . socket . SocketChannel ; import org . junit . Test ; import java . net . Socket ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . atomic . AtomicInteger ; import static org . junit . Assert . * ; public class SocketShutdownOutputByPeerTest extends AbstractServerSocketTest { @Test ( timeout = <int> ) public void testShutdownOutput ( ) throws Throwable { run ( ) ; } public void testShutdownOutput ( ServerBootstrap sb ) throws Throwable { TestHandler h = new TestHandler ( ) ; Socket s = new Socket ( ) ; try { sb . childHandler ( h ) . childOption ( ChannelOption . ALLOW_HALF_CLOSURE , true ) . bind ( ) . sync ( ) ; s . connect ( addr , <int> ) ; s . getOutputStream ( ) . write ( <int> ) ; assertEquals ( <int> , ( int ) h . queue . take ( ) ) ; assertTrue ( h . ch . isOpen ( ) ) ; assertTrue ( h . ch . isActive ( ) ) ; assertFalse ( h . ch . isInputShutdown ( ) ) ; assertFalse ( h . ch . isOutputShutdown ( ) ) ; s . shutdownOutput ( ) ; h . halfClosure . await ( ) ; assertTrue ( h . ch . isOpen ( ) ) ; assertTrue ( h . ch . isActive ( ) ) ; assertTrue ( h . ch . isInputShutdown ( ) ) ; assertFalse ( h . ch . isOutputShutdown ( ) ) ; assertEquals ( <int> , h . closure . getCount ( ) ) ; Thread . sleep ( <int> ) ; assertEquals ( <int> , h . halfClosureCount . intValue ( ) ) ; } finally { s . close ( ) ; } } @Test ( timeout = <int> ) public void testShutdownOutputWithoutOption ( ) throws Throwable { run ( ) ; } public void testShutdownOutputWithoutOption ( ServerBootstrap sb ) throws Throwable { TestHandler h = new TestHandler ( ) ; Socket s = new Socket ( ) ; try { sb . childHandler ( h ) . bind ( ) . sync ( ) ; s . connect ( addr , <int> ) ; s . getOutputStream ( ) . write ( <int> ) ; assertEquals ( <int> , ( int ) h . queue . take ( ) ) ; assertTrue ( h . ch . isOpen ( ) ) ; assertTrue ( h . ch . isActive ( ) ) ; assertFalse ( h . ch . isInputShutdown ( ) ) ; assertFalse ( h . ch . isOutputShutdown ( ) ) ; s . shutdownOutput ( ) ; h . closure . await ( ) ; assertFalse ( h . ch . isOpen ( ) ) ; assertFalse ( h . ch . isActive ( ) ) ; assertTrue ( h . ch . isInputShutdown ( ) ) ; assertTrue ( h . ch . isOutputShutdown ( ) ) ; assertEquals ( <int> , h . halfClosure . getCount ( ) ) ; Thread . sleep ( <int> ) ; assertEquals ( <int> , h . halfClosureCount . intValue ( ) ) ; } finally { s . close ( ) ; } } private static class TestHandler extends SimpleChannelInboundHandler < ByteBuf > { volatile SocketChannel ch ; final BlockingQueue < Byte > queue = new LinkedBlockingQueue < Byte > ( ) ; final CountDownLatch halfClosure = new CountDownLatch ( <int> ) ; final CountDownLatch closure = new CountDownLatch ( <int> ) ; final AtomicInteger halfClosureCount = new AtomicInteger ( ) ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { ch = ( SocketChannel ) ctx . channel ( ) ; } @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { closure . countDown ( ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , ByteBuf msg ) throws Exception { queue . offer ( msg . readByte ( ) ) ; } @Override public void userEventTriggered ( ChannelHandlerContext ctx , Object evt ) throws Exception { if ( evt instanceof ChannelInputShutdownEvent ) { halfClosureCount . incrementAndGet ( ) ; halfClosure . countDown ( ) ; } } } } 
