package org . gradle . gradleplugin . userinterface . swing . standalone ; import org . gradle . gradleplugin . foundation . DOM4JSerializer ; import org . gradle . gradleplugin . foundation . ExtensionFileFilter ; import org . gradle . gradleplugin . foundation . settings . DOM4JSettingsNode ; import org . gradle . gradleplugin . userinterface . AlternateUIInteraction ; import org . gradle . gradleplugin . userinterface . swing . common . PreferencesAssistant ; import org . gradle . gradleplugin . userinterface . swing . generic . SinglePaneUIInstance ; import org . gradle . internal . SystemProperties ; import org . gradle . internal . UncheckedException ; import javax . swing . * ; import javax . swing . filechooser . FileFilter ; import java . awt . * ; import java . awt . event . WindowAdapter ; import java . awt . event . WindowEvent ; import java . io . File ; import java . lang . reflect . Method ; import java . net . URI ; public class Application implements AlternateUIInteraction { private static final int DEFAULT_WIDTH = <int> ; private static final int DEFAULT_HEIGHT = <int> ; private static final String WINDOW_PREFERENCES_ID = <str> ; private static final String SETTINGS_EXTENSION = <str> ; private JFrame frame ; private SinglePaneUIInstance singlePaneUIInstance ; private boolean doesSupportEditingFiles ; private LifecycleListener lifecycleListener ; private DOM4JSettingsNode rootSettingsNode ; public interface LifecycleListener { public void hasShutDown ( ) ; } public Application ( LifecycleListener lifecycleListener ) { this . lifecycleListener = lifecycleListener ; try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName ( ) ) ; } catch ( Exception e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } this . doesSupportEditingFiles = determineIfSupportsEditingFiles ( ) ; rootSettingsNode = DOM4JSerializer . readSettingsFile ( new SettingsImportInteraction ( ) , createFileFilter ( ) ) ; if ( rootSettingsNode = = null ) { rootSettingsNode = DOM4JSerializer . createBlankSettings ( ) ; } singlePaneUIInstance = new SinglePaneUIInstance ( ) ; singlePaneUIInstance . initialize ( rootSettingsNode , this ) ; setupUI ( ) ; restoreSettings ( ) ; frame . setVisible ( true ) ; } private void setupUI ( ) { frame = new JFrame ( <str> ) ; JPanel mainPanel = new JPanel ( new BorderLayout ( ) ) ; frame . getContentPane ( ) . add ( mainPanel ) ; mainPanel . add ( singlePaneUIInstance . getComponent ( ) ) ; mainPanel . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; singlePaneUIInstance . aboutToShow ( ) ; frame . setDefaultCloseOperation ( JFrame . DO_NOTHING_ON_CLOSE ) ; frame . addWindowListener ( new WindowAdapter ( ) { public void windowClosing ( WindowEvent e ) { close ( ) ; } } ) ; frame . setSize ( DEFAULT_WIDTH , DEFAULT_HEIGHT ) ; frame . setLocationByPlatform ( true ) ; } private void close ( ) { boolean canClose = singlePaneUIInstance . canClose ( new SinglePaneUIInstance . CloseInteraction ( ) { public boolean promptUserToConfirmClosingWhileBusy ( ) { int result = JOptionPane . showConfirmDialog ( frame , <str> , <str> , JOptionPane . YES_NO_OPTION , JOptionPane . QUESTION_MESSAGE ) ; return result = = JOptionPane . YES_OPTION ; } } ) ; if ( ! canClose ) { return ; } singlePaneUIInstance . close ( ) ; saveSettings ( ) ; frame . setVisible ( false ) ; if ( lifecycleListener ! = null ) { lifecycleListener . hasShutDown ( ) ; } else { System . exit ( <int> ) ; } } private void saveSettings ( ) { PreferencesAssistant . saveSettings ( rootSettingsNode , frame , WINDOW_PREFERENCES_ID , Application . class ) ; DOM4JSerializer . exportToFile ( new SettingsExportInteraction ( ) , createFileFilter ( ) , rootSettingsNode ) ; } private void restoreSettings ( ) { PreferencesAssistant . restoreSettings ( rootSettingsNode , frame , WINDOW_PREFERENCES_ID , Application . class ) ; } public void openFile ( File file , int line ) { String name = file . getName ( ) . toLowerCase ( ) ; if ( name . endsWith ( <str> ) | | name . endsWith ( <str> ) ) { browseFile ( file ) ; } else { editFile ( file , line ) ; } } public void browseFile ( File file ) { if ( ! file . exists ( ) ) { JOptionPane . showMessageDialog ( frame , <str> + file . getAbsolutePath ( ) + <str> ) ; } else { if ( ! invokeDesktopFunction ( <str> , URI . class , file . toURI ( ) ) ) { String extension = getFileNameExtension ( file . getName ( ) ) ; JOptionPane . showMessageDialog ( frame , <str> + extension + <str> ) ; } } } public void editFile ( File file , int line ) { editFileInExternalApplication ( file , true ) ; } public void editFileInExternalApplication ( File file , boolean attemptToOpen ) { if ( ! file . exists ( ) ) { JOptionPane . showMessageDialog ( frame , <str> + file . getAbsolutePath ( ) + <str> ) ; } else { if ( ! invokeDesktopFunction ( <str> , File . class , file ) ) { openFileInExternalApplication ( file ) ; } } } public void openFileInExternalApplication ( File file ) { if ( ! file . exists ( ) ) { JOptionPane . showMessageDialog ( frame , <str> + file . getAbsolutePath ( ) + <str> ) ; } else { if ( ! invokeDesktopFunction ( <str> , File . class , file ) ) { String extension = getFileNameExtension ( file . getName ( ) ) ; JOptionPane . showMessageDialog ( frame , <str> + extension + <str> ) ; } } } public boolean invokeDesktopFunction ( String name , Class argumentClass , Object argument ) { try { Class < ? > desktopClass = Class . forName ( <str> ) ; Method getDesktopMethod = desktopClass . getDeclaredMethod ( <str> , ( Class < ? > [ ] ) null ) ; Object desktopObject = getDesktopMethod . invoke ( null , ( Object [ ] ) null ) ; if ( desktopObject ! = null ) { Method method = desktopClass . getMethod ( name , new Class [ ] { argumentClass } ) ; method . invoke ( desktopObject , argument ) ; return true ; } } catch ( Exception e ) { } return false ; } public static String getFileNameExtension ( String fileName ) { String result = fileName ; int indexOfDot = fileName . lastIndexOf ( <str> ) ; if ( indexOfDot > <int> ) { result = fileName . substring ( indexOfDot + <int> , result . length ( ) ) ; } return result ; } public boolean doesSupportEditingOpeningFiles ( ) { return doesSupportEditingFiles ; } public boolean determineIfSupportsEditingFiles ( ) { try { Class < ? > desktopClass = Class . forName ( <str> ) ; Method getDesktopMethod = desktopClass . getDeclaredMethod ( <str> , ( Class < ? > [ ] ) null ) ; Object desktopObject = getDesktopMethod . invoke ( null , ( Object [ ] ) null ) ; return ( Boolean ) desktopObject ; } catch ( Exception e ) { return false ; } } private ExtensionFileFilter createFileFilter ( ) { return new ExtensionFileFilter ( SETTINGS_EXTENSION , <str> ) ; } private File getSettingsFile ( ) { return new File ( SystemProperties . getInstance ( ) . getCurrentDir ( ) , <str> + SETTINGS_EXTENSION ) ; } private class SettingsImportInteraction implements DOM4JSerializer . ImportInteraction { public File promptForFile ( FileFilter fileFilters ) { File settingsFile = getSettingsFile ( ) ; if ( ! settingsFile . exists ( ) ) { return null ; } return settingsFile ; } public void reportError ( String error ) { JOptionPane . showMessageDialog ( frame , <str> + error ) ; } } private class SettingsExportInteraction implements DOM4JSerializer . ExportInteraction { public File promptForFile ( FileFilter fileFilters ) { return getSettingsFile ( ) ; } public boolean confirmOverwritingExistingFile ( File file ) { return true ; } public void reportError ( String error ) { JOptionPane . showMessageDialog ( frame , <str> + error ) ; } } } 
