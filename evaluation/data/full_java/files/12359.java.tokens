package org . gradle . api . internal ; import groovy . lang . Closure ; import groovy . lang . GroovyObject ; import groovy . lang . MissingMethodException ; import org . gradle . api . Action ; import org . gradle . api . GradleException ; import org . gradle . api . JavaVersion ; import org . gradle . api . file . FileCollection ; import org . gradle . api . internal . plugins . DslObject ; import org . gradle . api . plugins . Convention ; import org . gradle . api . plugins . ExtensionAware ; import org . gradle . api . plugins . ExtensionContainer ; import org . gradle . internal . reflect . ObjectInstantiationException ; import org . junit . Test ; import spock . lang . Issue ; import javax . inject . Inject ; import java . io . IOException ; import java . lang . annotation . ElementType ; import java . lang . annotation . Retention ; import java . lang . annotation . RetentionPolicy ; import java . lang . annotation . Target ; import java . lang . reflect . * ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . Callable ; import static org . gradle . api . internal . AbstractClassGeneratorTestGroovy . BeanWithGroovyBoolean ; import static org . gradle . util . Matchers . isEmpty ; import static org . gradle . util . TestUtil . TEST_CLOSURE ; import static org . gradle . util . TestUtil . call ; import static org . gradle . util . WrapUtil . toList ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . * ; public class AsmBackedClassGeneratorTest { private final AbstractClassGenerator generator = new AsmBackedClassGenerator ( ) ; @Test public void mixesInConventionAwareInterface ( ) throws Exception { Class < ? extends Bean > generatedClass = generator . generate ( Bean . class ) ; assertTrue ( IConventionAware . class . isAssignableFrom ( generatedClass ) ) ; Bean bean = generatedClass . newInstance ( ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; assertThat ( conventionAware . getConventionMapping ( ) , instanceOf ( ConventionAwareHelper . class ) ) ; conventionAware . getConventionMapping ( ) . map ( <str> , TEST_CLOSURE ) ; } @Test public void mixesInDynamicObjectAwareInterface ( ) throws Exception { Class < ? extends Bean > generatedClass = generator . generate ( Bean . class ) ; assertTrue ( DynamicObjectAware . class . isAssignableFrom ( generatedClass ) ) ; Bean bean = generatedClass . newInstance ( ) ; DynamicObjectAware dynamicBean = ( DynamicObjectAware ) bean ; dynamicBean . getAsDynamicObject ( ) . setProperty ( <str> , <str> ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; assertThat ( bean . doStuff ( <str> ) , equalTo ( <str> ) ) ; } @Test public void mixesInExtensionAwareInterface ( ) throws Exception { Class < ? extends Bean > generatedClass = generator . generate ( Bean . class ) ; assertTrue ( ExtensionAware . class . isAssignableFrom ( generatedClass ) ) ; Bean bean = generatedClass . newInstance ( ) ; ExtensionAware dynamicBean = ( ExtensionAware ) bean ; assertThat ( dynamicBean . getExtensions ( ) , notNullValue ( ) ) ; } @Test public void mixesInGroovyObjectInterface ( ) throws Exception { Class < ? extends Bean > generatedClass = generator . generate ( Bean . class ) ; assertTrue ( GroovyObject . class . isAssignableFrom ( generatedClass ) ) ; Bean bean = generatedClass . newInstance ( ) ; GroovyObject groovyObject = ( GroovyObject ) bean ; assertThat ( groovyObject . getMetaClass ( ) , notNullValue ( ) ) ; groovyObject . setProperty ( <str> , <str> ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; assertThat ( groovyObject . getProperty ( <str> ) , equalTo ( ( Object ) <str> ) ) ; assertThat ( groovyObject . invokeMethod ( <str> , new Object [ ] { <str> } ) , equalTo ( ( Object ) <str> ) ) ; } @Test public void cachesGeneratedSubclass ( ) { assertSame ( generator . generate ( Bean . class ) , generator . generate ( Bean . class ) ) ; } @Test public void doesNotDecorateAlreadyDecoratedClass ( ) { Class < ? extends Bean > generatedClass = generator . generate ( Bean . class ) ; assertSame ( generatedClass , generator . generate ( generatedClass ) ) ; } @Test public void overridesPublicConstructors ( ) throws Exception { Class < ? extends Bean > generatedClass = generator . generate ( BeanWithConstructor . class ) ; Bean bean = generatedClass . getConstructor ( String . class ) . newInstance ( <str> ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; bean = generatedClass . getConstructor ( ) . newInstance ( ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; } @Test public void includesGenericTypeInformationForOverriddenConstructor ( ) throws Exception { Class < ? > generatedClass = generator . generate ( BeanWithComplexConstructor . class ) ; Constructor < ? > constructor = generatedClass . getDeclaredConstructors ( ) [ <int> ] ; assertThat ( constructor . getTypeParameters ( ) . length , equalTo ( <int> ) ) ; assertThat ( constructor . getGenericParameterTypes ( ) . length , equalTo ( <int> ) ) ; Type paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , equalTo ( ( Type ) Callable . class ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( ParameterizedType . class ) ) ; ParameterizedType parameterizedType = ( ParameterizedType ) paramType ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) Callable . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , equalTo ( ( Type ) String . class ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( ParameterizedType . class ) ) ; parameterizedType = ( ParameterizedType ) paramType ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) Callable . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , instanceOf ( WildcardType . class ) ) ; WildcardType wildcard = ( WildcardType ) parameterizedType . getActualTypeArguments ( ) [ <int> ] ; assertThat ( wildcard . getUpperBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getUpperBounds ( ) [ <int> ] , equalTo ( ( Type ) String . class ) ) ; assertThat ( wildcard . getLowerBounds ( ) . length , equalTo ( <int> ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( ParameterizedType . class ) ) ; parameterizedType = ( ParameterizedType ) paramType ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) Callable . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , instanceOf ( WildcardType . class ) ) ; wildcard = ( WildcardType ) parameterizedType . getActualTypeArguments ( ) [ <int> ] ; assertThat ( wildcard . getUpperBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getUpperBounds ( ) [ <int> ] , equalTo ( ( Type ) Object . class ) ) ; assertThat ( wildcard . getLowerBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getLowerBounds ( ) [ <int> ] , equalTo ( ( Type ) String . class ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( ParameterizedType . class ) ) ; parameterizedType = ( ParameterizedType ) paramType ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) Callable . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , instanceOf ( WildcardType . class ) ) ; wildcard = ( WildcardType ) parameterizedType . getActualTypeArguments ( ) [ <int> ] ; assertThat ( wildcard . getUpperBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getUpperBounds ( ) [ <int> ] , equalTo ( ( Type ) Object . class ) ) ; assertThat ( wildcard . getLowerBounds ( ) . length , equalTo ( <int> ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( ParameterizedType . class ) ) ; parameterizedType = ( ParameterizedType ) paramType ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) Callable . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , instanceOf ( WildcardType . class ) ) ; wildcard = ( WildcardType ) parameterizedType . getActualTypeArguments ( ) [ <int> ] ; assertThat ( wildcard . getUpperBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getLowerBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getUpperBounds ( ) [ <int> ] , instanceOf ( ParameterizedType . class ) ) ; parameterizedType = ( ParameterizedType ) wildcard . getUpperBounds ( ) [ <int> ] ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) Callable . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , instanceOf ( WildcardType . class ) ) ; wildcard = ( WildcardType ) parameterizedType . getActualTypeArguments ( ) [ <int> ] ; assertThat ( wildcard . getUpperBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getUpperBounds ( ) [ <int> ] , equalTo ( ( Type ) Object . class ) ) ; assertThat ( wildcard . getLowerBounds ( ) . length , equalTo ( <int> ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( ParameterizedType . class ) ) ; parameterizedType = ( ParameterizedType ) paramType ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) Callable . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , instanceOf ( TypeVariable . class ) ) ; TypeVariable typeVariable = ( TypeVariable ) parameterizedType . getActualTypeArguments ( ) [ <int> ] ; assertThat ( typeVariable . getName ( ) , equalTo ( <str> ) ) ; assertThat ( typeVariable . getBounds ( ) [ <int> ] , instanceOf ( ParameterizedType . class ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( ParameterizedType . class ) ) ; parameterizedType = ( ParameterizedType ) paramType ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) Callable . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , instanceOf ( WildcardType . class ) ) ; wildcard = ( WildcardType ) parameterizedType . getActualTypeArguments ( ) [ <int> ] ; assertThat ( wildcard . getUpperBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getLowerBounds ( ) . length , equalTo ( <int> ) ) ; assertThat ( wildcard . getUpperBounds ( ) [ <int> ] , instanceOf ( TypeVariable . class ) ) ; typeVariable = ( TypeVariable ) wildcard . getUpperBounds ( ) [ <int> ] ; assertThat ( typeVariable . getName ( ) , equalTo ( <str> ) ) ; assertThat ( typeVariable . getBounds ( ) [ <int> ] , equalTo ( ( Type ) IOException . class ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( TypeVariable . class ) ) ; typeVariable = ( TypeVariable ) paramType ; assertThat ( typeVariable . getName ( ) , equalTo ( <str> ) ) ; assertThat ( typeVariable . getBounds ( ) [ <int> ] , equalTo ( ( Type ) Object . class ) ) ; GenericArrayType arrayType ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; if ( JavaVersion . current ( ) . isJava7Compatible ( ) ) { assertThat ( paramType , equalTo ( ( Type ) String [ ] . class ) ) ; assertThat ( ( ( Class < ? > ) paramType ) . getComponentType ( ) , equalTo ( ( Type ) String . class ) ) ; } else { assertThat ( paramType , instanceOf ( GenericArrayType . class ) ) ; arrayType = ( GenericArrayType ) paramType ; assertThat ( arrayType . getGenericComponentType ( ) , equalTo ( ( Type ) String . class ) ) ; } paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , instanceOf ( GenericArrayType . class ) ) ; arrayType = ( GenericArrayType ) paramType ; assertThat ( arrayType . getGenericComponentType ( ) , instanceOf ( ParameterizedType . class ) ) ; parameterizedType = ( ParameterizedType ) arrayType . getGenericComponentType ( ) ; assertThat ( parameterizedType . getRawType ( ) , equalTo ( ( Type ) List . class ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) . length , equalTo ( <int> ) ) ; assertThat ( parameterizedType . getActualTypeArguments ( ) [ <int> ] , instanceOf ( WildcardType . class ) ) ; paramType = constructor . getGenericParameterTypes ( ) [ <int> ] ; assertThat ( paramType , equalTo ( ( Type ) Boolean . TYPE ) ) ; assertThat ( constructor . getGenericExceptionTypes ( ) . length , equalTo ( <int> ) ) ; Type exceptionType = constructor . getGenericExceptionTypes ( ) [ <int> ] ; assertThat ( exceptionType , equalTo ( ( Type ) Exception . class ) ) ; exceptionType = constructor . getGenericExceptionTypes ( ) [ <int> ] ; assertThat ( exceptionType , instanceOf ( TypeVariable . class ) ) ; typeVariable = ( TypeVariable ) exceptionType ; assertThat ( typeVariable . getName ( ) , equalTo ( <str> ) ) ; } @Test public void includesAnnotationInformationForOverriddenConstructor ( ) throws Exception { Class < ? > generatedClass = generator . generate ( BeanWithAnnotatedConstructor . class ) ; Constructor < ? > constructor = generatedClass . getDeclaredConstructors ( ) [ <int> ] ; assertThat ( constructor . getAnnotation ( Inject . class ) , notNullValue ( ) ) ; } @Test public void canConstructInstance ( ) throws Exception { Bean bean = generator . newInstance ( BeanWithConstructor . class , <str> ) ; assertThat ( bean . getClass ( ) , sameInstance ( ( Object ) generator . generate ( BeanWithConstructor . class ) ) ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; bean = generator . newInstance ( BeanWithConstructor . class ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; bean = generator . newInstance ( BeanWithConstructor . class , <int> ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; } @Test public void reportsConstructionFailure ( ) { try { generator . newInstance ( UnconstructibleBean . class ) ; fail ( ) ; } catch ( ObjectInstantiationException e ) { assertThat ( e . getCause ( ) , sameInstance ( UnconstructibleBean . failure ) ) ; } try { generator . newInstance ( Bean . class , <str> , <int> ) ; fail ( ) ; } catch ( ObjectInstantiationException e ) { } try { generator . newInstance ( AbstractBean . class ) ; fail ( ) ; } catch ( GradleException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> ) ) ; } try { generator . newInstance ( PrivateBean . class ) ; fail ( ) ; } catch ( GradleException e ) { assertThat ( e . getMessage ( ) , equalTo ( <str> ) ) ; } } @Test public void appliesConventionMappingToEachProperty ( ) throws Exception { Class < ? extends Bean > generatedClass = generator . generate ( Bean . class ) ; assertTrue ( IConventionAware . class . isAssignableFrom ( generatedClass ) ) ; Bean bean = generatedClass . newInstance ( ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; assertThat ( bean . getProp ( ) , nullValue ( ) ) ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < String > ( ) { public String call ( ) { return <str> ; } } ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; bean . setProp ( <str> ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; bean . setProp ( null ) ; assertThat ( bean . getProp ( ) , nullValue ( ) ) ; } @Test public void appliesConventionMappingToPropertyWithMultipleSetters ( ) throws Exception { BeanWithVariousGettersAndSetters bean = generator . newInstance ( BeanWithVariousGettersAndSetters . class ) ; new DslObject ( bean ) . getConventionMapping ( ) . map ( <str> , new Callable < String > ( ) { public String call ( ) { return <str> ; } } ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; bean . setOverloaded ( <str> ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; bean = generator . newInstance ( BeanWithVariousGettersAndSetters . class ) ; new DslObject ( bean ) . getConventionMapping ( ) . map ( <str> , new Callable < String > ( ) { public String call ( ) { return <str> ; } } ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; bean . setOverloaded ( <int> ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; bean = generator . newInstance ( BeanWithVariousGettersAndSetters . class ) ; new DslObject ( bean ) . getConventionMapping ( ) . map ( <str> , new Callable < String > ( ) { public String call ( ) { return <str> ; } } ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; bean . setOverloaded ( true ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; } @Test public void appliesConventionMappingToPropertyWithGetterCovariantType ( ) throws Exception { CovariantPropertyTypes bean = generator . newInstance ( CovariantPropertyTypes . class ) ; new DslObject ( bean ) . getConventionMapping ( ) . map ( <str> , new Callable < String > ( ) { public String call ( ) { return <str> ; } } ) ; assertThat ( bean . getValue ( ) , equalTo ( <str> ) ) ; bean . setValue ( <int> ) ; assertThat ( bean . getValue ( ) , equalTo ( <str> ) ) ; } @Test public void appliesConventionMappingToProtectedMethods ( ) throws Exception { BeanWithNonPublicProperties bean = generator . newInstance ( BeanWithNonPublicProperties . class ) ; assertThat ( bean . getPackageProtected ( ) , equalTo ( <str> ) ) ; assertThat ( bean . getProtected ( ) , equalTo ( <str> ) ) ; assertThat ( bean . getPrivate ( ) , equalTo ( <str> ) ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < String > ( ) { public String call ( ) { return <str> ; } } ) ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < String > ( ) { public String call ( ) { return <str> ; } } ) ; assertThat ( bean . getPackageProtected ( ) , equalTo ( <str> ) ) ; assertThat ( bean . getProtected ( ) , equalTo ( <str> ) ) ; } @Test @Issue ( <str> ) public void appliesConventionMappingToGroovyBoolean ( ) throws Exception { BeanWithGroovyBoolean bean = generator . generate ( BeanWithGroovyBoolean . class ) . newInstance ( ) ; assertTrue ( bean instanceof IConventionAware ) ; assertThat ( bean . getSmallB ( ) , equalTo ( false ) ) ; assertThat ( bean . getBigB ( ) , nullValue ( ) ) ; assertThat ( bean . getMixedB ( ) , equalTo ( false ) ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return true ; } } ) ; assertThat ( bean . isSmallB ( ) , equalTo ( true ) ) ; assertThat ( bean . getSmallB ( ) , equalTo ( true ) ) ; bean . setSmallB ( false ) ; assertThat ( bean . isSmallB ( ) , equalTo ( false ) ) ; assertThat ( bean . getSmallB ( ) , equalTo ( false ) ) ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return Boolean . TRUE ; } } ) ; assertThat ( bean . getBigB ( ) , equalTo ( Boolean . TRUE ) ) ; bean . setBigB ( Boolean . FALSE ) ; assertThat ( bean . getBigB ( ) , equalTo ( Boolean . FALSE ) ) ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return Boolean . TRUE ; } } ) ; assertThat ( bean . getMixedB ( ) , equalTo ( true ) ) ; assertThat ( bean . isMixedB ( ) , equalTo ( Boolean . TRUE ) ) ; } @Test public void appliesConventionMappingToCollectionGetter ( ) throws Exception { Class < ? extends CollectionBean > generatedClass = generator . generate ( CollectionBean . class ) ; CollectionBean bean = generatedClass . newInstance ( ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; final List < String > conventionValue = toList ( <str> ) ; assertThat ( bean . getProp ( ) , isEmpty ( ) ) ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) { return conventionValue ; } } ) ; assertThat ( bean . getProp ( ) , sameInstance ( conventionValue ) ) ; bean . setProp ( toList ( <str> ) ) ; assertThat ( bean . getProp ( ) , equalTo ( toList ( <str> ) ) ) ; bean . setProp ( Collections . < String > emptyList ( ) ) ; assertThat ( bean . getProp ( ) , equalTo ( Collections . < String > emptyList ( ) ) ) ; bean . setProp ( null ) ; assertThat ( bean . getProp ( ) , nullValue ( ) ) ; } @Test public void handlesVariousPropertyTypes ( ) throws Exception { BeanWithVariousPropertyTypes bean = generator . generate ( BeanWithVariousPropertyTypes . class ) . newInstance ( ) ; assertThat ( bean . getArrayProperty ( ) , notNullValue ( ) ) ; assertThat ( bean . getBooleanProperty ( ) , equalTo ( false ) ) ; assertThat ( bean . getLongProperty ( ) , equalTo ( <int> ) ) ; assertThat ( bean . setReturnValueProperty ( <str> ) , sameInstance ( bean ) ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return true ; } } ) ; assertThat ( bean . getBooleanProperty ( ) , equalTo ( true ) ) ; bean . setBooleanProperty ( false ) ; assertThat ( bean . getBooleanProperty ( ) , equalTo ( false ) ) ; } @Test public void doesNotOverrideMethodsFromConventionAwareInterface ( ) throws Exception { Class < ? extends ConventionAwareBean > generatedClass = generator . generate ( ConventionAwareBean . class ) ; assertTrue ( IConventionAware . class . isAssignableFrom ( generatedClass ) ) ; ConventionAwareBean bean = generatedClass . newInstance ( ) ; assertSame ( bean , bean . getConventionMapping ( ) ) ; bean . setProp ( <str> ) ; assertEquals ( <str> , bean . getProp ( ) ) ; } @Test public void doesNotOverrideMethodsFromSuperclassesMarkedWithAnnotation ( ) throws Exception { BeanSubClass bean = generator . generate ( BeanSubClass . class ) . newInstance ( ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } } ) ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } } ) ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return <str> ; } } ) ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return <str> ; } } ) ; assertEquals ( null , bean . getProperty ( ) ) ; assertEquals ( null , bean . getInterfaceProperty ( ) ) ; assertEquals ( <str> , bean . getOverriddenProperty ( ) ) ; assertEquals ( <str> , bean . getOtherProperty ( ) ) ; } @Test public void doesNotMixInConventionMappingToClassWithAnnotation ( ) throws Exception { NoMappingBean bean = generator . generate ( NoMappingBean . class ) . newInstance ( ) ; assertFalse ( bean instanceof IConventionAware ) ; assertNull ( bean . getInterfaceProperty ( ) ) ; assertTrue ( bean instanceof DynamicObjectAware ) ; } @Test public void doesNotOverrideMethodsFromDynamicObjectAwareInterface ( ) throws Exception { DynamicObjectAwareBean bean = generator . generate ( DynamicObjectAwareBean . class ) . newInstance ( ) ; assertThat ( bean . getConvention ( ) , sameInstance ( bean . conv ) ) ; assertThat ( bean . getAsDynamicObject ( ) , sameInstance ( bean . conv . getExtensionsAsDynamicObject ( ) ) ) ; } @Test public void canAddDynamicPropertiesAndMethodsToJavaObject ( ) throws Exception { Bean bean = generator . generate ( Bean . class ) . newInstance ( ) ; DynamicObjectAware dynamicObjectAware = ( DynamicObjectAware ) bean ; ConventionObject conventionObject = new ConventionObject ( ) ; new DslObject ( dynamicObjectAware ) . getConvention ( ) . getPlugins ( ) . put ( <str> , conventionObject ) ; call ( <str> , bean ) ; assertThat ( conventionObject . getConventionProperty ( ) , equalTo ( <str> ) ) ; assertThat ( call ( <str> , bean ) , notNullValue ( ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; } @Test public void canAddDynamicPropertiesAndMethodsToGroovyObject ( ) throws Exception { TestDecoratedGroovyBean bean = generator . generate ( TestDecoratedGroovyBean . class ) . newInstance ( ) ; DynamicObjectAware dynamicObjectAware = ( DynamicObjectAware ) bean ; ConventionObject conventionObject = new ConventionObject ( ) ; new DslObject ( dynamicObjectAware ) . getConvention ( ) . getPlugins ( ) . put ( <str> , conventionObject ) ; call ( <str> , bean ) ; assertThat ( conventionObject . getConventionProperty ( ) , equalTo ( <str> ) ) ; assertThat ( call ( <str> , bean ) , notNullValue ( ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; } @Test public void respectsPropertiesAddedToMetaClassOfJavaObject ( ) throws Exception { Bean bean = generator . generate ( Bean . class ) . newInstance ( ) ; call ( <str> , bean ) ; assertThat ( call ( <str> , bean ) , notNullValue ( ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; } @Test public void respectsPropertiesAddedToMetaClassOfGroovyObject ( ) throws Exception { TestDecoratedGroovyBean bean = generator . generate ( TestDecoratedGroovyBean . class ) . newInstance ( ) ; call ( <str> , bean ) ; assertThat ( call ( <str> , bean ) , notNullValue ( ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; } @Test public void usesExistingGetAsDynamicObjectMethod ( ) throws Exception { DynamicObjectBean bean = generator . generate ( DynamicObjectBean . class ) . newInstance ( ) ; call ( <str> , bean ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; bean . getAsDynamicObject ( ) . setProperty ( <str> , <str> ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; call ( <str> , bean ) ; assertThat ( bean . getAsDynamicObject ( ) . getProperty ( <str> ) , equalTo ( ( Object ) <int> ) ) ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <int> ) ) ; } @Test public void constructorCanCallGetter ( ) throws Exception { BeanUsesPropertiesInConstructor bean = generator . newInstance ( BeanUsesPropertiesInConstructor . class ) ; assertThat ( bean . name , equalTo ( <str> ) ) ; } @Test public void mixesInSetValueMethodForSingleValuedProperty ( ) throws Exception { BeanWithVariousGettersAndSetters bean = generator . generate ( BeanWithVariousGettersAndSetters . class ) . newInstance ( ) ; call ( <str> , bean ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; call ( <str> , bean ) ; assertThat ( bean . getFinalGetter ( ) , equalTo ( <str> ) ) ; call ( <str> , bean ) ; assertThat ( bean . writeOnly , equalTo ( <int> ) ) ; call ( <str> , bean ) ; assertThat ( bean . getPrimitive ( ) , equalTo ( <int> ) ) ; call ( <str> , bean ) ; assertThat ( bean . isBool ( ) , equalTo ( true ) ) ; call ( <str> , bean ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; call ( <str> , bean ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; call ( <str> , bean ) ; assertThat ( bean . getOverloaded ( ) , equalTo ( <str> ) ) ; } @Test public void doesNotUseConventionValueOnceSetValueMethodHasBeenCalled ( ) throws Exception { Bean bean = generator . generate ( Bean . class ) . newInstance ( ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return <str> ; } } ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; call ( <str> , bean ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; } @Test public void doesNotMixInSetValueMethodForReadOnlyProperty ( ) throws Exception { BeanWithReadOnlyProperties bean = generator . generate ( BeanWithReadOnlyProperties . class ) . newInstance ( ) ; try { call ( <str> , bean ) ; fail ( ) ; } catch ( MissingMethodException e ) { assertThat ( e . getMethod ( ) , equalTo ( <str> ) ) ; } } @Test public void doesNotMixInSetValueMethodForMultiValueProperty ( ) throws Exception { CollectionBean bean = generator . generate ( CollectionBean . class ) . newInstance ( ) ; try { call ( <str> , bean ) ; fail ( ) ; } catch ( MissingMethodException e ) { assertThat ( e . getMethod ( ) , equalTo ( <str> ) ) ; } } @Test public void overridesExistingSetValueMethod ( ) throws Exception { BeanWithDslMethods bean = generator . generate ( BeanWithDslMethods . class ) . newInstance ( ) ; IConventionAware conventionAware = ( IConventionAware ) bean ; conventionAware . getConventionMapping ( ) . map ( <str> , new Callable < Object > ( ) { public Object call ( ) throws Exception { return <str> ; } } ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; assertThat ( call ( <str> , bean ) , sameInstance ( ( Object ) bean ) ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; assertThat ( call ( <str> , bean ) , sameInstance ( ( Object ) bean ) ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; assertThat ( call ( <str> , bean ) , nullValue ( ) ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; } @Test public void addsInsteadOfOverridesSetValueMethodIfOnlyMultiArgMethods ( ) throws Exception { BeanWithMultiArgDslMethods bean = generator . generate ( BeanWithMultiArgDslMethods . class ) . newInstance ( ) ; call ( <str> , bean ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; } @Test public void doesNotOverrideSetValueMethodForPropertyThatIsNotConventionMappingAware ( ) throws Exception { BeanWithMultiArgDslMethodsAndNoConventionMapping bean = generator . generate ( BeanWithMultiArgDslMethodsAndNoConventionMapping . class ) . newInstance ( ) ; call ( <str> , bean ) ; assertThat ( bean . getProp ( ) , equalTo ( <str> ) ) ; } @Test public void mixesInClosureOverloadForActionMethod ( ) throws Exception { Bean bean = generator . generate ( Bean . class ) . newInstance ( ) ; bean . prop = <str> ; call ( <str> , bean ) ; BeanWithOverriddenMethods subBean = generator . generate ( BeanWithOverriddenMethods . class ) . newInstance ( ) ; call ( <str> , subBean ) ; } @Test public void doesNotOverrideExistingClosureOverload ( ) throws IllegalAccessException , InstantiationException { BeanWithDslMethods bean = generator . generate ( BeanWithDslMethods . class ) . newInstance ( ) ; bean . prop = <str> ; assertThat ( call ( <str> , bean ) , equalTo ( ( Object ) <str> ) ) ; } @Test public void generatesDslObjectCompatibleObject ( ) throws Exception { new DslObject ( generator . generate ( Bean . class ) . newInstance ( ) ) ; } @Test public void includesNotInheritedTypeAnnotations ( ) throws IllegalAccessException , InstantiationException { Class < ? extends AnnotatedBean > generatedClass = generator . generate ( AnnotatedBean . class ) ; BeanAnnotation annotation = generatedClass . getAnnotation ( BeanAnnotation . class ) ; assertThat ( annotation , notNullValue ( ) ) ; assertThat ( annotation . value ( ) , equalTo ( <str> ) ) ; assertThat ( annotation . values ( ) , equalTo ( new String [ ] { <str> , <str> } ) ) ; assertThat ( annotation . enumValue ( ) , equalTo ( AnnotationEnum . A ) ) ; assertThat ( annotation . enumValues ( ) , equalTo ( new AnnotationEnum [ ] { AnnotationEnum . A , AnnotationEnum . B } ) ) ; assertThat ( annotation . number ( ) , equalTo ( <int> ) ) ; assertThat ( annotation . numbers ( ) , equalTo ( new int [ ] { <int> , <int> } ) ) ; assertThat ( annotation . clazz ( ) . equals ( Integer . class ) , equalTo ( true ) ) ; assertThat ( annotation . classes ( ) , equalTo ( new Class < ? > [ ] { Integer . class } ) ) ; assertThat ( annotation . annotation ( ) . value ( ) , equalTo ( <str> ) ) ; assertThat ( annotation . annotations ( ) [ <int> ] . value ( ) , equalTo ( <str> ) ) ; } public static class Bean { private String prop ; public String getProp ( ) { return prop ; } public void setProp ( String prop ) { this . prop = prop ; } public String doStuff ( String value ) { return <str> + value + <str> ; } public void doStuff ( Action < String > action ) { action . execute ( getProp ( ) ) ; } } public static class BeanWithOverriddenMethods extends Bean { @Override public String getProp ( ) { return super . getProp ( ) ; } @Override public void setProp ( String prop ) { super . setProp ( prop ) ; } @Override public String doStuff ( String value ) { return super . doStuff ( value ) ; } @Override public void doStuff ( Action < String > action ) { action . execute ( <str> ) ; } } public static class ParentBean { Object value ; public Object getValue ( ) { return value ; } public void setValue ( Object value ) { this . value = value ; } } public static class CovariantPropertyTypes extends ParentBean { @Override public String getValue ( ) { return String . valueOf ( super . getValue ( ) ) ; } } public static class BeanWithReadOnlyProperties { public String getProp ( ) { return <str> ; } } public static class BeanWithNonPublicProperties { String getPackageProtected ( ) { return <str> ; } protected String getProtected ( ) { return <str> ; } private String getPrivate ( ) { return <str> ; } } public static class CollectionBean { private List < String > prop = new ArrayList < String > ( ) ; public List < String > getProp ( ) { return prop ; } public void setProp ( List < String > prop ) { this . prop = prop ; } } public static class BeanWithConstructor extends Bean { public BeanWithConstructor ( ) { this ( <str> ) ; } public BeanWithConstructor ( String value ) { setProp ( value ) ; } public BeanWithConstructor ( int value ) { setProp ( String . valueOf ( value ) ) ; } } public static class BeanWithComplexConstructor { public < T extends IOException , S extends Callable < String > , V > BeanWithComplexConstructor ( Callable rawValue , Callable < String > value , Callable < ? extends String > subType , Callable < ? super String > superType , Callable < ? > wildcard , Callable < ? extends Callable < ? > > nested , Callable < S > typeVar , Callable < ? extends T > typeVarWithBounds , V genericVar , String [ ] array , List < ? extends String > [ ] genericArray , boolean primitive ) throws Exception , T { } } public static class BeanWithAnnotatedConstructor { @Inject public BeanWithAnnotatedConstructor ( ) { } } public static class BeanWithDslMethods extends Bean { private String prop ; private FileCollection files ; private List < Object > things ; public String getProp ( ) { return prop ; } public void setProp ( String prop ) { this . prop = prop ; } public FileCollection getFiles ( ) { return files ; } public void setFiles ( FileCollection files ) { this . files = files ; } public List < Object > getThings ( ) { return things ; } public void setThings ( List < Object > things ) { this . things = things ; } public BeanWithDslMethods prop ( String property ) { this . prop = String . format ( <str> , property ) ; return this ; } public BeanWithDslMethods prop ( Object property ) { this . prop = String . format ( <str> , property ) ; return this ; } public void prop ( int property ) { this . prop = String . format ( <str> , property ) ; } public void doStuff ( Closure cl ) { cl . call ( String . format ( <str> , getProp ( ) ) ) ; } } public static class BeanWithMultiArgDslMethods extends Bean { private String prop ; public String getProp ( ) { return prop ; } public void setProp ( String prop ) { this . prop = prop ; } public BeanWithMultiArgDslMethods prop ( String part1 , String part2 ) { this . prop = String . format ( <str> , part1 , part2 ) ; return this ; } public BeanWithMultiArgDslMethods prop ( String part1 , String part2 , String part3 ) { this . prop = String . format ( <str> , part1 , part2 , part3 ) ; return this ; } } @NoConventionMapping public static class BeanWithMultiArgDslMethodsAndNoConventionMapping extends Bean { private String prop ; public String getProp ( ) { return prop ; } public void setProp ( String prop ) { this . prop = prop ; } public void prop ( String value ) { this . prop = String . format ( <str> , value ) ; } public void prop ( String part1 , String part2 ) { this . prop = String . format ( <str> , part1 , part2 ) ; } public void prop ( String part1 , String part2 , String part3 ) { this . prop = String . format ( <str> , part1 , part2 , part3 ) ; } } public static class ConventionAwareBean extends Bean implements IConventionAware , ConventionMapping { public Convention getConvention ( ) { throw new UnsupportedOperationException ( ) ; } public void setConvention ( Convention convention ) { throw new UnsupportedOperationException ( ) ; } public MappedProperty map ( String propertyName , Closure value ) { throw new UnsupportedOperationException ( ) ; } public MappedProperty map ( String propertyName , Callable < ? > value ) { throw new UnsupportedOperationException ( ) ; } public < T > T getConventionValue ( T actualValue , String propertyName ) { if ( actualValue instanceof String ) { return ( T ) ( <str> + actualValue + <str> ) ; } else { throw new UnsupportedOperationException ( ) ; } } public < T > T getConventionValue ( T actualValue , String propertyName , boolean isExplicitValue ) { return getConventionValue ( actualValue , propertyName ) ; } public ConventionMapping getConventionMapping ( ) { return this ; } public void setConventionMapping ( ConventionMapping conventionMapping ) { throw new UnsupportedOperationException ( ) ; } } public static class DynamicObjectAwareBean extends Bean implements DynamicObjectAware { Convention conv = new ExtensibleDynamicObject ( this , ThreadGlobalInstantiator . getOrCreate ( ) ) . getConvention ( ) ; public Convention getConvention ( ) { return conv ; } public ExtensionContainer getExtensions ( ) { return conv ; } public DynamicObject getAsDynamicObject ( ) { return conv . getExtensionsAsDynamicObject ( ) ; } } public static class ConventionObject { private String conventionProperty ; public String getConventionProperty ( ) { return conventionProperty ; } public void setConventionProperty ( String conventionProperty ) { this . conventionProperty = conventionProperty ; } public Object conventionMethod ( String value ) { return <str> + value + <str> ; } } public static class BeanWithVariousPropertyTypes { private boolean b ; public String [ ] getArrayProperty ( ) { return new String [ <int> ] ; } public boolean getBooleanProperty ( ) { return b ; } public long getLongProperty ( ) { return <int> ; } public String getReturnValueProperty ( ) { return <str> ; } public BeanWithVariousPropertyTypes setReturnValueProperty ( String val ) { return this ; } public void setBooleanProperty ( boolean b ) { this . b = b ; } } public static class BeanWithVariousGettersAndSetters extends Bean { private int primitive ; private boolean bool ; private String finalGetter ; private Integer writeOnly ; private String overloaded ; public int getPrimitive ( ) { return primitive ; } public void setPrimitive ( int primitive ) { this . primitive = primitive ; } public boolean isBool ( ) { return bool ; } public void setBool ( boolean bool ) { this . bool = bool ; } public final String getFinalGetter ( ) { return finalGetter ; } public void setFinalGetter ( String value ) { finalGetter = value ; } public void setWriteOnly ( Integer value ) { writeOnly = value ; } public String getOverloaded ( ) { return overloaded ; } public void setOverloaded ( Number overloaded ) { this . overloaded = String . format ( <str> , overloaded ) ; } public void setOverloaded ( CharSequence overloaded ) { this . overloaded = String . format ( <str> , overloaded ) ; } public void setOverloaded ( Object overloaded ) { this . overloaded = String . format ( <str> , overloaded ) ; } } public interface SomeType { String getInterfaceProperty ( ) ; } @NoConventionMapping public static class NoMappingBean implements SomeType { public String getProperty ( ) { return null ; } public String getInterfaceProperty ( ) { return null ; } public String getOverriddenProperty ( ) { return null ; } } public static class DynamicObjectBean { private final BeanDynamicObject dynamicObject = new BeanDynamicObject ( new Bean ( ) ) ; public DynamicObject getAsDynamicObject ( ) { return dynamicObject ; } } public static class BeanSubClass extends NoMappingBean { @Override public String getOverriddenProperty ( ) { return null ; } public String getOtherProperty ( ) { return null ; } } public static class BeanUsesPropertiesInConstructor { final String name ; public BeanUsesPropertiesInConstructor ( ) { name = getName ( ) ; } public String getName ( ) { return <str> ; } } public static class UnconstructibleBean { static Throwable failure = new UnsupportedOperationException ( ) ; public UnconstructibleBean ( ) throws Throwable { throw failure ; } } public static abstract class AbstractBean { abstract void implementMe ( ) ; } private static class PrivateBean { } public enum AnnotationEnum { A , B } @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . TYPE ) public static @interface NestedBeanAnnotation { String value ( ) ; } @Retention ( RetentionPolicy . RUNTIME ) @Target ( ElementType . TYPE ) public static @interface BeanAnnotation { String value ( ) ; String [ ] values ( ) ; AnnotationEnum enumValue ( ) ; AnnotationEnum [ ] enumValues ( ) ; int number ( ) ; int [ ] numbers ( ) ; Class < ? > clazz ( ) ; Class < ? > [ ] classes ( ) ; NestedBeanAnnotation annotation ( ) ; NestedBeanAnnotation [ ] annotations ( ) ; } @BeanAnnotation ( value = <str> , values = { <str> , <str> } , enumValue = AnnotationEnum . A , enumValues = { AnnotationEnum . A , AnnotationEnum . B } , number = <int> , numbers = { <int> , <int> } , clazz = Integer . class , classes = { Integer . class } , annotation = @NestedBeanAnnotation ( <str> ) , annotations = { @NestedBeanAnnotation ( <str> ) } ) public static class AnnotatedBean { } } 
