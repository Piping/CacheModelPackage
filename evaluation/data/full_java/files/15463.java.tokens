package org . gradle . api . tasks . scala ; import org . gradle . api . InvalidUserDataException ; import org . gradle . api . file . FileVisitor ; import org . gradle . api . internal . ConventionTask ; import org . gradle . api . internal . file . FileTreeInternal ; import org . gradle . api . internal . tasks . scala . ScalaJavaJointCompileSpec ; import org . gradle . api . tasks . TaskExecutionException ; import org . gradle . api . tasks . compile . AbstractCompile ; import org . gradle . api . tasks . compile . AbstractCompileTest ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . util . GFileUtils ; import org . gradle . util . JUnit4GroovyMockery ; import org . hamcrest . BaseMatcher ; import org . hamcrest . Description ; import org . hamcrest . core . IsNull ; import org . jmock . Expectations ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Before ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . ExpectedException ; import java . io . File ; import java . util . HashSet ; public class ScalaCompileTest extends AbstractCompileTest { @Rule public ExpectedException thrown = ExpectedException . none ( ) ; private ScalaCompile scalaCompile ; private Compiler < ScalaJavaJointCompileSpec > scalaCompiler ; private JUnit4Mockery context = new JUnit4GroovyMockery ( ) ; private FileTreeInternal scalaClasspath ; @Override public AbstractCompile getCompile ( ) { return scalaCompile ; } @Override public ConventionTask getTask ( ) { return scalaCompile ; } @Before public void setUp ( ) { scalaCompile = createTask ( ScalaCompile . class ) ; scalaCompiler = context . mock ( Compiler . class ) ; scalaCompile . setCompiler ( scalaCompiler ) ; GFileUtils . touch ( new File ( srcDir , <str> ) ) ; GFileUtils . touch ( new File ( srcDir , <str> ) ) ; } @Test public void testExecuteDoingWork ( ) { setUpMocksAndAttributes ( scalaCompile ) ; context . checking ( new Expectations ( ) { { allowing ( scalaClasspath ) . isEmpty ( ) ; will ( returnValue ( false ) ) ; one ( scalaCompiler ) . execute ( ( ScalaJavaJointCompileSpec ) with ( IsNull . notNullValue ( ) ) ) ; } } ) ; scalaCompile . execute ( ) ; } @Test public void testMoansIfScalaClasspathIsEmpty ( ) { setUpMocksAndAttributes ( scalaCompile ) ; context . checking ( new Expectations ( ) { { allowing ( scalaClasspath ) . isEmpty ( ) ; will ( returnValue ( true ) ) ; } } ) ; thrown . expect ( TaskExecutionException . class ) ; thrown . expectCause ( new CauseMatcher ( InvalidUserDataException . class , <str> ) ) ; scalaCompile . execute ( ) ; } protected void setUpMocksAndAttributes ( final ScalaCompile compile ) { compile . source ( srcDir ) ; compile . setIncludes ( TEST_INCLUDES ) ; compile . setExcludes ( TEST_EXCLUDES ) ; compile . setSourceCompatibility ( <str> ) ; compile . setTargetCompatibility ( <str> ) ; compile . setDestinationDir ( destDir ) ; scalaClasspath = context . mock ( FileTreeInternal . class ) ; compile . setScalaClasspath ( scalaClasspath ) ; final FileTreeInternal classpath = context . mock ( FileTreeInternal . class ) ; final FileTreeInternal zincClasspath = context . mock ( FileTreeInternal . class ) ; context . checking ( new Expectations ( ) { { allowing ( scalaClasspath ) . getFiles ( ) ; will ( returnValue ( new HashSet < File > ( ) ) ) ; allowing ( scalaClasspath ) . visit ( ( FileVisitor ) with ( anything ( ) ) ) ; allowing ( scalaClasspath ) . visitTreeOrBackingFile ( ( FileVisitor ) with ( anything ( ) ) ) ; allowing ( classpath ) . getFiles ( ) ; will ( returnValue ( new HashSet < File > ( ) ) ) ; allowing ( classpath ) . visit ( ( FileVisitor ) with ( anything ( ) ) ) ; allowing ( classpath ) . visitTreeOrBackingFile ( ( FileVisitor ) with ( anything ( ) ) ) ; allowing ( zincClasspath ) . getFiles ( ) ; will ( returnValue ( new HashSet < File > ( ) ) ) ; allowing ( zincClasspath ) . visit ( ( FileVisitor ) with ( anything ( ) ) ) ; allowing ( zincClasspath ) . visitTreeOrBackingFile ( ( FileVisitor ) with ( anything ( ) ) ) ; } } ) ; compile . setClasspath ( classpath ) ; compile . setZincClasspath ( zincClasspath ) ; compile . getScalaCompileOptions ( ) . getIncrementalOptions ( ) . setAnalysisFile ( new File ( <str> ) ) ; } private class CauseMatcher < T extends Exception > extends BaseMatcher < T > { private final Class < T > throwableClass ; private final String expectedMessage ; public CauseMatcher ( Class < T > throwableClass , String expectedMessage ) { this . throwableClass = throwableClass ; this . expectedMessage = expectedMessage ; } public boolean matches ( Object item ) { return item . getClass ( ) . isAssignableFrom ( throwableClass ) & & ( ( T ) item ) . getMessage ( ) . contains ( expectedMessage ) ; } public void describeTo ( Description description ) { } } } 
