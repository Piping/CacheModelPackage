package org . apache . cassandra . utils ; import java . util . List ; import com . google . common . collect . Ordering ; import net . nicoulaj . compilecommand . annotations . Inline ; public abstract class AsymmetricOrdering < T1 , T2 > extends Ordering < T1 > { public abstract int compareAsymmetric ( T1 left , T2 right ) ; public static enum Op { LOWER , FLOOR , CEIL , HIGHER } public int binarySearchAsymmetric ( List < ? extends T1 > searchIn , T2 searchFor , Op op ) { final int strictnessOfLessThan = strictnessOfLessThan ( op ) ; int lb = - <int> ; int ub = searchIn . size ( ) ; while ( lb + <int> < ub ) { int m = ( lb + ub ) / <int> ; int c = compareAsymmetric ( searchIn . get ( m ) , searchFor ) ; if ( c < strictnessOfLessThan ) lb = m ; else ub = m ; } return selectBoundary ( op , lb , ub ) ; } @Inline private static int strictnessOfLessThan ( Op op ) { switch ( op ) { case FLOOR : case HIGHER : return <int> ; case CEIL : case LOWER : return <int> ; } throw new IllegalStateException ( ) ; } @Inline private static int selectBoundary ( Op op , int lb , int ub ) { switch ( op ) { case CEIL : case HIGHER : return ub ; case FLOOR : case LOWER : return lb ; } throw new IllegalStateException ( ) ; } private class Reversed extends AsymmetricOrdering < T1 , T2 > { public int compareAsymmetric ( T1 left , T2 right ) { return - AsymmetricOrdering . this . compareAsymmetric ( left , right ) ; } public int compare ( T1 left , T1 right ) { return AsymmetricOrdering . this . compare ( right , left ) ; } public AsymmetricOrdering < T1 , T2 > reverse ( ) { return AsymmetricOrdering . this ; } } public AsymmetricOrdering < T1 , T2 > reverse ( ) { return new Reversed ( ) ; } } 
