package org . gradle . api . internal . file . pattern ; import org . gradle . api . file . RelativePath ; import org . gradle . api . specs . Spec ; import java . util . ArrayList ; import java . util . List ; public class PatternMatcherFactory { public static final EndOfPathMatcher END_OF_PATH_MATCHER = new EndOfPathMatcher ( ) ; public static Spec < RelativePath > getPatternMatcher ( boolean partialMatchDirs , boolean caseSensitive , String pattern ) { PathMatcher pathMatcher = compile ( caseSensitive , pattern ) ; return new PathMatcherBackedSpec ( partialMatchDirs , pathMatcher ) ; } private static PathMatcher compile ( boolean caseSensitive , String pattern ) { if ( pattern . length ( ) = = <int> ) { return END_OF_PATH_MATCHER ; } if ( pattern . endsWith ( <str> ) | | pattern . endsWith ( <str> ) ) { pattern = pattern + <str> ; } String [ ] parts = pattern . split ( <str> ) ; return compile ( parts , <int> , caseSensitive ) ; } private static PathMatcher compile ( String [ ] parts , int startIndex , boolean caseSensitive ) { if ( startIndex > = parts . length ) { return END_OF_PATH_MATCHER ; } int pos = startIndex ; while ( pos < parts . length & & parts [ pos ] . equals ( <str> ) ) { pos + + ; } if ( pos > startIndex ) { return new GreedyPathMatcher ( compile ( parts , pos , caseSensitive ) ) ; } List < PatternStep > steps = new ArrayList < PatternStep > ( parts . length - startIndex ) ; while ( pos < parts . length & & ! parts [ pos ] . equals ( <str> ) ) { steps . add ( PatternStepFactory . getStep ( parts [ pos ] , caseSensitive ) ) ; pos + + ; } return new FixedStepsPathMatcher ( steps , compile ( parts , pos , caseSensitive ) ) ; } private static class PathMatcherBackedSpec implements Spec < RelativePath > { private final boolean partialMatchDirs ; private final PathMatcher pathMatcher ; public PathMatcherBackedSpec ( boolean partialMatchDirs , PathMatcher pathMatcher ) { this . partialMatchDirs = partialMatchDirs ; this . pathMatcher = pathMatcher ; } public boolean isSatisfiedBy ( RelativePath element ) { if ( element . isFile ( ) | | ! partialMatchDirs ) { return pathMatcher . matches ( element . getSegments ( ) , <int> ) ; } else { return pathMatcher . isPrefix ( element . getSegments ( ) , <int> ) ; } } } } 
