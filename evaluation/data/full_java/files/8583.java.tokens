package org . elasticsearch . versioning ; import org . apache . lucene . util . TestUtil ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . action . delete . DeleteResponse ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . engine . FlushNotAllowedEngineException ; import org . elasticsearch . index . engine . VersionConflictEngineException ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Locale ; import java . util . Map ; import java . util . Random ; import java . util . Set ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . atomic . AtomicInteger ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertThrows ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; public class SimpleVersioningIT extends ESIntegTestCase { public void testExternalVersioningInitialDelete ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; DeleteResponse deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( false ) ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) , VersionConflictEngineException . class ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; } public void testForce ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( <str> ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . FORCE ) . get ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . FORCE ) . get ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . FORCE ) . get ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . FORCE ) . get ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; if ( randomBoolean ( ) ) { refresh ( ) ; } for ( int i = <int> ; i < <int> ; i + + ) { assertThat ( client ( ) . prepareGet ( <str> , <str> , <str> ) . get ( ) . getVersion ( ) , equalTo ( <int> ) ) ; } long v = randomIntBetween ( <int> , <int> ) ; DeleteResponse deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( v ) . setVersionType ( VersionType . FORCE ) . get ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( true ) ) ; assertThat ( deleteResponse . getVersion ( ) , equalTo ( v ) ) ; } public void testExternalGTE ( ) throws Exception { createIndex ( <str> ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL_GTE ) . get ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL_GTE ) . get ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL_GTE ) . get ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL_GTE ) , VersionConflictEngineException . class ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; if ( randomBoolean ( ) ) { refresh ( ) ; } for ( int i = <int> ; i < <int> ; i + + ) { assertThat ( client ( ) . prepareGet ( <str> , <str> , <str> ) . get ( ) . getVersion ( ) , equalTo ( <int> ) ) ; } assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL_GTE ) , VersionConflictEngineException . class ) ; long v = randomIntBetween ( <int> , <int> ) ; DeleteResponse deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( v ) . setVersionType ( VersionType . EXTERNAL_GTE ) . execute ( ) . actionGet ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( true ) ) ; assertThat ( deleteResponse . getVersion ( ) , equalTo ( v ) ) ; assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL_GTE ) . execute ( ) , VersionConflictEngineException . class ) ; deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL_GTE ) . execute ( ) . actionGet ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( false ) ) ; assertThat ( deleteResponse . getVersion ( ) , equalTo ( <int> ) ) ; } public void testExternalVersioning ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) , VersionConflictEngineException . class ) ; if ( randomBoolean ( ) ) { refresh ( ) ; } for ( int i = <int> ; i < <int> ; i + + ) { assertThat ( client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) . getVersion ( ) , equalTo ( <int> ) ) ; } assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) , VersionConflictEngineException . class ) ; DeleteResponse deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( true ) ) ; assertThat ( deleteResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) , VersionConflictEngineException . class ) ; deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( false ) ) ; assertThat ( deleteResponse . getVersion ( ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( true ) ) ; assertThat ( deleteResponse . getVersion ( ) , equalTo ( <int> ) ) ; HashMap < String , Object > newSettings = new HashMap < > ( ) ; newSettings . put ( <str> , - <int> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( newSettings ) . execute ( ) . actionGet ( ) ; Thread . sleep ( <int> ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; } public void testRequireUnitsOnUpdateSettings ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; HashMap < String , Object > newSettings = new HashMap < > ( ) ; newSettings . put ( <str> , <str> ) ; try { client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( newSettings ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( IllegalArgumentException iae ) { assertTrue ( iae . getMessage ( ) . contains ( <str> ) ) ; } } public void testInternalVersioningInitialDelete ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setCreate ( true ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; } public void testInternalVersioning ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setCreate ( true ) . setSource ( <str> , <str> ) . execute ( ) , VersionConflictEngineException . class ) ; assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertThat ( client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) . getVersion ( ) , equalTo ( <int> ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setVersion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getAt ( <int> ) . version ( ) , equalTo ( <int> ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getAt ( <int> ) . version ( ) , equalTo ( Versions . NOT_FOUND ) ) ; } DeleteResponse deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( true ) ) ; assertThat ( deleteResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; deleteResponse = client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( deleteResponse . isFound ( ) , equalTo ( false ) ) ; assertThat ( deleteResponse . getVersion ( ) , equalTo ( <int> ) ) ; } public void testSimpleVersioningWithFlush ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . execute ( ) . actionGet ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; client ( ) . admin ( ) . indices ( ) . prepareFlush ( ) . execute ( ) . actionGet ( ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; assertThrows ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setCreate ( true ) . setSource ( <str> , <str> ) . execute ( ) , VersionConflictEngineException . class ) ; assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; assertThrows ( client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; client ( ) . admin ( ) . indices ( ) . prepareRefresh ( ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { assertThat ( client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) . getVersion ( ) , equalTo ( <int> ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setVersion ( true ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getAt ( <int> ) . version ( ) , equalTo ( <int> ) ) ; } } public void testVersioningWithBulk ( ) { createIndex ( <str> ) ; ensureGreen ( ) ; BulkResponse bulkResponse = client ( ) . prepareBulk ( ) . add ( client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) ) . execute ( ) . actionGet ( ) ; assertThat ( bulkResponse . hasFailures ( ) , equalTo ( false ) ) ; assertThat ( bulkResponse . getItems ( ) . length , equalTo ( <int> ) ) ; IndexResponse indexResponse = bulkResponse . getItems ( ) [ <int> ] . getResponse ( ) ; assertThat ( indexResponse . getVersion ( ) , equalTo ( <int> ) ) ; } private interface IDSource { String next ( ) ; } private IDSource getRandomIDs ( ) { IDSource ids ; final Random random = getRandom ( ) ; switch ( random . nextInt ( <int> ) ) { case <int> : if ( VERBOSE ) { System . out . println ( <str> ) ; } ids = new IDSource ( ) { @Override public String next ( ) { return TestUtil . randomSimpleString ( random ) ; } } ; break ; case <int> : if ( VERBOSE ) { System . out . println ( <str> ) ; } ids = new IDSource ( ) { @Override public String next ( ) { return TestUtil . randomRealisticUnicodeString ( random ) ; } } ; break ; case <int> : if ( VERBOSE ) { System . out . println ( <str> ) ; } ids = new IDSource ( ) { int upto ; @Override public String next ( ) { return Integer . toString ( upto + + ) ; } } ; break ; case <int> : if ( VERBOSE ) { System . out . println ( <str> ) ; } ids = new IDSource ( ) { final int radix = TestUtil . nextInt ( random , Character . MIN_RADIX , Character . MAX_RADIX ) ; final String zeroPad = String . format ( Locale . ROOT , <str> + TestUtil . nextInt ( random , <int> , <int> ) + <str> , <int> ) ; int upto ; @Override public String next ( ) { String s = Integer . toString ( upto + + ) ; return zeroPad . substring ( zeroPad . length ( ) - s . length ( ) ) + s ; } } ; break ; case <int> : if ( VERBOSE ) { System . out . println ( <str> ) ; } ids = new IDSource ( ) { final int radix = TestUtil . nextInt ( random , Character . MIN_RADIX , Character . MAX_RADIX ) ; int upto ; @Override public String next ( ) { return Long . toString ( random . nextLong ( ) & <hex> , radix ) ; } } ; break ; case <int> : if ( VERBOSE ) { System . out . println ( <str> ) ; } ids = new IDSource ( ) { final int radix = TestUtil . nextInt ( random , Character . MIN_RADIX , Character . MAX_RADIX ) ; final String zeroPad = String . format ( Locale . ROOT , <str> , <int> ) ; int upto ; @Override public String next ( ) { return Long . toString ( random . nextLong ( ) & <hex> , radix ) ; } } ; break ; default : throw new AssertionError ( ) ; } return ids ; } private static class IDAndVersion { public String id ; public long version ; public boolean delete ; public int threadID = - <int> ; public long indexStartTime ; public long indexFinishTime ; public boolean versionConflict ; public boolean alreadyExists ; public ActionResponse response ; @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; sb . append ( id ) ; sb . append ( <str> ) ; sb . append ( version ) ; sb . append ( <str> ) ; sb . append ( delete ) ; sb . append ( <str> ) ; sb . append ( threadID ) ; sb . append ( <str> ) ; sb . append ( indexStartTime ) ; sb . append ( <str> ) ; sb . append ( indexFinishTime ) ; sb . append ( <str> ) ; sb . append ( versionConflict ) ; sb . append ( <str> ) ; sb . append ( alreadyExists ) ; if ( response ! = null ) { if ( response instanceof DeleteResponse ) { DeleteResponse deleteResponse = ( DeleteResponse ) response ; sb . append ( <str> ) ; sb . append ( <str> ) ; sb . append ( deleteResponse . getIndex ( ) ) ; sb . append ( <str> ) ; sb . append ( deleteResponse . getId ( ) ) ; sb . append ( <str> ) ; sb . append ( deleteResponse . getType ( ) ) ; sb . append ( <str> ) ; sb . append ( deleteResponse . getVersion ( ) ) ; sb . append ( <str> ) ; sb . append ( deleteResponse . isFound ( ) ) ; } else if ( response instanceof IndexResponse ) { IndexResponse indexResponse = ( IndexResponse ) response ; sb . append ( <str> ) ; sb . append ( indexResponse . getIndex ( ) ) ; sb . append ( <str> ) ; sb . append ( indexResponse . getId ( ) ) ; sb . append ( <str> ) ; sb . append ( indexResponse . getType ( ) ) ; sb . append ( <str> ) ; sb . append ( indexResponse . getVersion ( ) ) ; sb . append ( <str> ) ; sb . append ( indexResponse . isCreated ( ) ) ; } else { sb . append ( <str> + response ) ; } } else { sb . append ( <str> ) ; } return sb . toString ( ) ; } } public void testRandomIDsAndVersions ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; HashMap < String , Object > newSettings = new HashMap < > ( ) ; newSettings . put ( <str> , <str> ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( newSettings ) . execute ( ) . actionGet ( ) ) ; Random random = getRandom ( ) ; IDSource idSource = getRandomIDs ( ) ; Set < String > idsSet = new HashSet < > ( ) ; String idPrefix ; if ( randomBoolean ( ) ) { idPrefix = <str> ; } else { idPrefix = TestUtil . randomSimpleString ( random ) ; if ( VERBOSE ) { System . out . println ( <str> + idPrefix ) ; } } int numIDs ; if ( TEST_NIGHTLY ) { numIDs = scaledRandomIntBetween ( <int> , <int> ) ; } else { numIDs = scaledRandomIntBetween ( <int> , <int> ) ; } while ( idsSet . size ( ) < numIDs ) { idsSet . add ( idPrefix + idSource . next ( ) ) ; } String [ ] ids = idsSet . toArray ( new String [ numIDs ] ) ; boolean useMonotonicVersion = randomBoolean ( ) ; long version = <int> ; final IDAndVersion [ ] idVersions = new IDAndVersion [ TestUtil . nextInt ( random , numIDs / <int> , numIDs * ( TEST_NIGHTLY ? <int> : <int> ) ) ] ; final Map < String , IDAndVersion > truth = new HashMap < > ( ) ; if ( VERBOSE ) { System . out . println ( <str> + numIDs + <str> + idVersions . length + <str> ) ; } for ( int i = <int> ; i < idVersions . length ; i + + ) { if ( useMonotonicVersion ) { version + = TestUtil . nextInt ( random , <int> , <int> ) ; } else { version = random . nextLong ( ) & <hex> ; } idVersions [ i ] = new IDAndVersion ( ) ; idVersions [ i ] . id = ids [ random . nextInt ( numIDs ) ] ; idVersions [ i ] . version = version ; idVersions [ i ] . delete = random . nextInt ( <int> ) = = <int> ; IDAndVersion curVersion = truth . get ( idVersions [ i ] . id ) ; if ( curVersion = = null | | idVersions [ i ] . version > curVersion . version ) { truth . put ( idVersions [ i ] . id , idVersions [ i ] ) ; } } for ( int i = idVersions . length - <int> ; i > <int> ; i - - ) { int index = random . nextInt ( i + <int> ) ; IDAndVersion x = idVersions [ index ] ; idVersions [ index ] = idVersions [ i ] ; idVersions [ i ] = x ; } if ( VERBOSE ) { for ( IDAndVersion idVersion : idVersions ) { System . out . println ( <str> + idVersion . id + <str> + idVersion . version + <str> + idVersion . delete + <str> + ( truth . get ( idVersion . id ) = = idVersion ) ) ; } } final AtomicInteger upto = new AtomicInteger ( ) ; final CountDownLatch startingGun = new CountDownLatch ( <int> ) ; Thread [ ] threads = new Thread [ TestUtil . nextInt ( random , <int> , TEST_NIGHTLY ? <int> : <int> ) ] ; final long startTime = System . nanoTime ( ) ; for ( int i = <int> ; i < threads . length ; i + + ) { final int threadID = i ; threads [ i ] = new Thread ( ) { @Override public void run ( ) { try { final Random threadRandom = getRandom ( ) ; startingGun . await ( ) ; while ( true ) { int index = upto . getAndIncrement ( ) ; if ( index > = idVersions . length ) { break ; } if ( VERBOSE & & index % <int> = = <int> ) { System . out . println ( Thread . currentThread ( ) . getName ( ) + <str> + index ) ; } IDAndVersion idVersion = idVersions [ index ] ; String id = idVersion . id ; idVersion . threadID = threadID ; idVersion . indexStartTime = System . nanoTime ( ) - startTime ; long version = idVersion . version ; if ( idVersion . delete ) { try { idVersion . response = client ( ) . prepareDelete ( <str> , <str> , id ) . setVersion ( version ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; } catch ( VersionConflictEngineException vcee ) { assertThat ( version , lessThanOrEqualTo ( truth . get ( id ) . version ) ) ; idVersion . versionConflict = true ; } } else { try { idVersion . response = client ( ) . prepareIndex ( <str> , <str> , id ) . setSource ( <str> , <str> ) . setVersion ( version ) . setVersionType ( VersionType . EXTERNAL ) . get ( ) ; } catch ( VersionConflictEngineException vcee ) { assertThat ( version , lessThanOrEqualTo ( truth . get ( id ) . version ) ) ; idVersion . versionConflict = true ; } } idVersion . indexFinishTime = System . nanoTime ( ) - startTime ; if ( threadRandom . nextInt ( <int> ) = = <int> ) { System . out . println ( threadID + <str> + ( System . nanoTime ( ) - startTime ) ) ; refresh ( ) ; System . out . println ( threadID + <str> + ( System . nanoTime ( ) - startTime ) ) ; } if ( threadRandom . nextInt ( <int> ) = = <int> ) { System . out . println ( threadID + <str> + ( System . nanoTime ( ) - startTime ) ) ; try { flush ( ) ; } catch ( FlushNotAllowedEngineException fnaee ) { } System . out . println ( threadID + <str> + ( System . nanoTime ( ) - startTime ) ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } ; threads [ i ] . start ( ) ; } startingGun . countDown ( ) ; for ( Thread thread : threads ) { thread . join ( ) ; } boolean failed = false ; for ( String id : ids ) { long expected ; IDAndVersion idVersion = truth . get ( id ) ; if ( idVersion ! = null & & idVersion . delete = = false ) { expected = idVersion . version ; } else { expected = - <int> ; } long actualVersion = client ( ) . prepareGet ( <str> , <str> , id ) . execute ( ) . actionGet ( ) . getVersion ( ) ; if ( actualVersion ! = expected ) { System . out . println ( <str> + idVersion + <str> + actualVersion ) ; failed = true ; } } if ( failed ) { System . out . println ( <str> ) ; for ( int i = <int> ; i < idVersions . length ; i + + ) { System . out . println ( <str> + i + <str> + idVersions [ i ] ) ; } fail ( <str> ) ; } } public void testDeleteNotLost ( ) throws Exception { client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( Settings . settingsBuilder ( ) . put ( <str> , <int> ) ) . execute ( ) . actionGet ( ) ; ensureGreen ( ) ; HashMap < String , Object > newSettings = new HashMap < > ( ) ; newSettings . put ( <str> , <str> ) ; newSettings . put ( <str> , <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( newSettings ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setOpType ( IndexRequest . OpType . INDEX ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; if ( randomBoolean ( ) ) { refresh ( ) ; } client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( <str> , client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) . getVersion ( ) , equalTo ( - <int> ) ) ; Thread . sleep ( <int> ) ; client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( <str> , client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) . getVersion ( ) , equalTo ( - <int> ) ) ; } public void testGCDeletesZero ( ) throws Exception { createIndex ( <str> ) ; ensureGreen ( ) ; HashMap < String , Object > newSettings = new HashMap < > ( ) ; newSettings . put ( <str> , <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareUpdateSettings ( <str> ) . setSettings ( newSettings ) . execute ( ) . actionGet ( ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setOpType ( IndexRequest . OpType . INDEX ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; if ( randomBoolean ( ) ) { refresh ( ) ; } client ( ) . prepareDelete ( <str> , <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) . actionGet ( ) ; assertThat ( <str> , client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) . getVersion ( ) , equalTo ( - <int> ) ) ; } } 
