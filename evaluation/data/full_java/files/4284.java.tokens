package org . eclipse . debug . internal . ui . model . elements ; import java . util . ArrayList ; import java . util . List ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IDebugEventSetListener ; import org . eclipse . debug . core . ILogicalStructureType ; import org . eclipse . debug . core . model . IDebugElement ; import org . eclipse . debug . core . model . IIndexedValue ; import org . eclipse . debug . core . model . IValue ; import org . eclipse . debug . core . model . IVariable ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IPresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . views . variables . IndexedVariablePartition ; import org . eclipse . debug . internal . ui . views . variables . LogicalStructureCache ; import org . eclipse . debug . internal . ui . views . variables . VariablesView ; import org . eclipse . debug . ui . IDebugUIConstants ; public class VariableContentProvider extends ElementContentProvider { private static LogicalStructureCache fgLogicalCache ; @Override protected int getChildCount ( Object element , IPresentationContext context , IViewerUpdate monitor ) throws CoreException { return getAllChildren ( element , context ) . length ; } @Override protected Object [ ] getChildren ( Object parent , int index , int length , IPresentationContext context , IViewerUpdate monitor ) throws CoreException { return getElements ( getAllChildren ( parent , context ) , index , length ) ; } @Override protected boolean hasChildren ( Object element , IPresentationContext context , IViewerUpdate monitor ) throws CoreException { return ( ( IVariable ) element ) . getValue ( ) . hasVariables ( ) ; } @Override protected boolean supportsContextId ( String id ) { return id . equals ( IDebugUIConstants . ID_EXPRESSION_VIEW ) | | id . equals ( IDebugUIConstants . ID_VARIABLE_VIEW ) | | id . equals ( IDebugUIConstants . ID_REGISTER_VIEW ) ; } protected Object [ ] getAllChildren ( Object parent , IPresentationContext context ) throws CoreException { IVariable variable = ( IVariable ) parent ; IValue value = variable . getValue ( ) ; if ( value ! = null ) { return getValueChildren ( variable , value , context ) ; } return EMPTY ; } protected boolean isShowLogicalStructure ( IPresentationContext context ) { Boolean show = ( Boolean ) context . getProperty ( VariablesView . PRESENTATION_SHOW_LOGICAL_STRUCTURES ) ; return show ! = null & & show . booleanValue ( ) ; } protected int getArrayPartitionSize ( ) { return <int> ; } protected IValue getLogicalValue ( IValue value , IPresentationContext context ) throws CoreException { return getLogicalValue ( value , new ArrayList < String > ( ) , context ) ; } protected Object [ ] getValueChildren ( IDebugElement parent , IValue value , IPresentationContext context ) throws CoreException { if ( value = = null ) { return EMPTY ; } IValue logicalValue = getLogicalValue ( value , context ) ; if ( logicalValue instanceof IIndexedValue ) { IIndexedValue indexedValue = ( IIndexedValue ) logicalValue ; int partitionSize = computeParitionSize ( indexedValue ) ; if ( partitionSize > <int> ) { int offset = indexedValue . getInitialOffset ( ) ; int length = indexedValue . getSize ( ) ; int numPartitions = length / partitionSize ; int remainder = length % partitionSize ; if ( remainder > <int> ) { numPartitions + + ; } IVariable [ ] partitions = new IVariable [ numPartitions ] ; for ( int i = <int> ; i < ( numPartitions - <int> ) ; i + + ) { partitions [ i ] = new IndexedVariablePartition ( parent , indexedValue , offset , partitionSize ) ; offset = offset + partitionSize ; } if ( remainder = = <int> ) { remainder = partitionSize ; } partitions [ numPartitions - <int> ] = new IndexedVariablePartition ( parent , indexedValue , offset , remainder ) ; return partitions ; } } if ( logicalValue = = null ) { logicalValue = value ; } return logicalValue . getVariables ( ) ; } protected int computeParitionSize ( IIndexedValue value ) { int partitionSize = <int> ; try { int length = value . getSize ( ) ; int partitionDepth = <int> ; int preferredSize = getArrayPartitionSize ( ) ; int remainder = length % preferredSize ; length = length / preferredSize ; while ( length > <int> ) { if ( remainder = = <int> & & length = = <int> ) { break ; } partitionDepth + + ; remainder = length % preferredSize ; length = length / preferredSize ; } for ( int i = <int> ; i < partitionDepth ; i + + ) { partitionSize = partitionSize * preferredSize ; } } catch ( DebugException e ) { } return partitionSize ; } protected IValue getLogicalValue ( IValue value , List < String > previousStructureIds , IPresentationContext context ) throws CoreException { if ( isShowLogicalStructure ( context ) ) { ILogicalStructureType [ ] types = DebugPlugin . getLogicalStructureTypes ( value ) ; if ( types . length > <int> ) { ILogicalStructureType type = DebugPlugin . getDefaultStructureType ( types ) ; if ( type ! = null & & ! previousStructureIds . contains ( type . getId ( ) ) ) { IValue logicalValue = getLogicalStructureCache ( ) . getLogicalStructure ( type , value ) ; previousStructureIds . add ( type . getId ( ) ) ; return getLogicalValue ( logicalValue , previousStructureIds , context ) ; } } } return value ; } protected synchronized LogicalStructureCache getLogicalStructureCache ( ) { if ( fgLogicalCache = = null ) { fgLogicalCache = new LogicalStructureCache ( ) ; DebugPlugin . getDefault ( ) . addDebugEventListener ( new IDebugEventSetListener ( ) { @Override public void handleDebugEvents ( DebugEvent [ ] events ) { for ( int i = <int> ; i < events . length ; i + + ) { if ( events [ i ] . getKind ( ) = = DebugEvent . TERMINATE ) { fgLogicalCache . clear ( ) ; break ; } else if ( events [ i ] . getKind ( ) = = DebugEvent . RESUME & & events [ i ] . getDetail ( ) ! = DebugEvent . EVALUATION_IMPLICIT ) { fgLogicalCache . clear ( ) ; break ; } else if ( events [ i ] . getKind ( ) = = DebugEvent . SUSPEND & & events [ i ] . getDetail ( ) ! = DebugEvent . EVALUATION_IMPLICIT ) { fgLogicalCache . clear ( ) ; break ; } else if ( events [ i ] . getKind ( ) = = DebugEvent . CHANGE & & events [ i ] . getDetail ( ) = = DebugEvent . CONTENT ) { fgLogicalCache . clear ( ) ; break ; } } } } ) ; } return fgLogicalCache ; } } 
