package org . apache . cassandra . io . sstable ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . UUID ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . compaction . CompactionInfo ; import org . apache . cassandra . db . compaction . CompactionInterruptedException ; import org . apache . cassandra . db . compaction . OperationType ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . utils . Pair ; import static org . apache . cassandra . io . sstable . Downsampling . BASE_SAMPLING_LEVEL ; public class IndexSummaryRedistribution extends CompactionInfo . Holder { private static final Logger logger = LoggerFactory . getLogger ( IndexSummaryRedistribution . class ) ; static final double UPSAMPLE_THRESHOLD = <float> ; static final double DOWNSAMPLE_THESHOLD = <float> ; private final List < SSTableReader > compacting ; private final Map < UUID , LifecycleTransaction > transactions ; private final long memoryPoolBytes ; private final UUID compactionId ; private volatile long remainingSpace ; public IndexSummaryRedistribution ( List < SSTableReader > compacting , Map < UUID , LifecycleTransaction > transactions , long memoryPoolBytes ) { this . compacting = compacting ; this . transactions = transactions ; this . memoryPoolBytes = memoryPoolBytes ; this . compactionId = UUID . randomUUID ( ) ; } public List < SSTableReader > redistributeSummaries ( ) throws IOException { logger . info ( <str> ) ; List < SSTableReader > oldFormatSSTables = new ArrayList < > ( ) ; List < SSTableReader > redistribute = new ArrayList < > ( ) ; for ( LifecycleTransaction txn : transactions . values ( ) ) { for ( SSTableReader sstable : ImmutableList . copyOf ( txn . originals ( ) ) ) { logger . trace ( <str> , sstable ) ; if ( ! sstable . descriptor . version . hasSamplingLevel ( ) ) { oldFormatSSTables . add ( sstable ) ; txn . cancel ( sstable ) ; } } redistribute . addAll ( txn . originals ( ) ) ; } long total = <int> ; for ( SSTableReader sstable : Iterables . concat ( compacting , redistribute ) ) total + = sstable . getIndexSummaryOffHeapSize ( ) ; logger . trace ( <str> , redistribute . size ( ) , memoryPoolBytes / <int> / <int> , total / <float> / <float> ) ; final Map < SSTableReader , Double > readRates = new HashMap < > ( redistribute . size ( ) ) ; double totalReadsPerSec = <float> ; for ( SSTableReader sstable : redistribute ) { if ( isStopRequested ( ) ) throw new CompactionInterruptedException ( getCompactionInfo ( ) ) ; if ( sstable . getReadMeter ( ) ! = null ) { Double readRate = sstable . getReadMeter ( ) . fifteenMinuteRate ( ) ; totalReadsPerSec + = readRate ; readRates . put ( sstable , readRate ) ; } } logger . trace ( <str> , totalReadsPerSec ) ; List < SSTableReader > sstablesByHotness = new ArrayList < > ( redistribute ) ; Collections . sort ( sstablesByHotness , new ReadRateComparator ( readRates ) ) ; long remainingBytes = memoryPoolBytes ; for ( SSTableReader sstable : Iterables . concat ( compacting , oldFormatSSTables ) ) remainingBytes - = sstable . getIndexSummaryOffHeapSize ( ) ; logger . trace ( <str> , ( memoryPoolBytes - remainingBytes ) / <float> / <float> ) ; List < SSTableReader > newSSTables = adjustSamplingLevels ( sstablesByHotness , transactions , totalReadsPerSec , remainingBytes ) ; for ( LifecycleTransaction txn : transactions . values ( ) ) txn . finish ( ) ; total = <int> ; for ( SSTableReader sstable : Iterables . concat ( compacting , oldFormatSSTables , newSSTables ) ) total + = sstable . getIndexSummaryOffHeapSize ( ) ; logger . trace ( <str> , total / <float> / <float> ) ; return newSSTables ; } private List < SSTableReader > adjustSamplingLevels ( List < SSTableReader > sstables , Map < UUID , LifecycleTransaction > transactions , double totalReadsPerSec , long memoryPoolCapacity ) throws IOException { List < ResampleEntry > toDownsample = new ArrayList < > ( sstables . size ( ) / <int> ) ; List < ResampleEntry > toUpsample = new ArrayList < > ( sstables . size ( ) / <int> ) ; List < ResampleEntry > forceResample = new ArrayList < > ( ) ; List < ResampleEntry > forceUpsample = new ArrayList < > ( ) ; List < SSTableReader > newSSTables = new ArrayList < > ( sstables . size ( ) ) ; remainingSpace = memoryPoolCapacity ; for ( SSTableReader sstable : sstables ) { if ( isStopRequested ( ) ) throw new CompactionInterruptedException ( getCompactionInfo ( ) ) ; int minIndexInterval = sstable . metadata . params . minIndexInterval ; int maxIndexInterval = sstable . metadata . params . maxIndexInterval ; double readsPerSec = sstable . getReadMeter ( ) = = null ? <float> : sstable . getReadMeter ( ) . fifteenMinuteRate ( ) ; long idealSpace = Math . round ( remainingSpace * ( readsPerSec / totalReadsPerSec ) ) ; int currentNumEntries = sstable . getIndexSummarySize ( ) ; double avgEntrySize = sstable . getIndexSummaryOffHeapSize ( ) / ( double ) currentNumEntries ; long targetNumEntries = Math . max ( <int> , Math . round ( idealSpace / avgEntrySize ) ) ; int currentSamplingLevel = sstable . getIndexSummarySamplingLevel ( ) ; int maxSummarySize = sstable . getMaxIndexSummarySize ( ) ; if ( sstable . getMinIndexInterval ( ) ! = minIndexInterval ) { int effectiveSamplingLevel = ( int ) Math . round ( currentSamplingLevel * ( minIndexInterval / ( double ) sstable . getMinIndexInterval ( ) ) ) ; maxSummarySize = ( int ) Math . round ( maxSummarySize * ( sstable . getMinIndexInterval ( ) / ( double ) minIndexInterval ) ) ; logger . trace ( <str> , sstable . getMinIndexInterval ( ) , minIndexInterval , sstable , effectiveSamplingLevel , currentSamplingLevel ) ; currentSamplingLevel = effectiveSamplingLevel ; } int newSamplingLevel = IndexSummaryBuilder . calculateSamplingLevel ( currentSamplingLevel , currentNumEntries , targetNumEntries , minIndexInterval , maxIndexInterval ) ; int numEntriesAtNewSamplingLevel = IndexSummaryBuilder . entriesAtSamplingLevel ( newSamplingLevel , maxSummarySize ) ; double effectiveIndexInterval = sstable . getEffectiveIndexInterval ( ) ; logger . trace ( <str> + <str> , sstable . getFilename ( ) , readsPerSec , idealSpace , targetNumEntries , currentSamplingLevel , currentNumEntries , currentNumEntries * avgEntrySize , newSamplingLevel , numEntriesAtNewSamplingLevel , numEntriesAtNewSamplingLevel * avgEntrySize ) ; if ( effectiveIndexInterval < minIndexInterval ) { logger . trace ( <str> , sstable , effectiveIndexInterval , minIndexInterval ) ; long spaceUsed = ( long ) Math . ceil ( avgEntrySize * numEntriesAtNewSamplingLevel ) ; forceResample . add ( new ResampleEntry ( sstable , spaceUsed , newSamplingLevel ) ) ; remainingSpace - = spaceUsed ; } else if ( effectiveIndexInterval > maxIndexInterval ) { logger . trace ( <str> , sstable , effectiveIndexInterval , maxIndexInterval ) ; newSamplingLevel = Math . max ( <int> , ( BASE_SAMPLING_LEVEL * minIndexInterval ) / maxIndexInterval ) ; numEntriesAtNewSamplingLevel = IndexSummaryBuilder . entriesAtSamplingLevel ( newSamplingLevel , sstable . getMaxIndexSummarySize ( ) ) ; long spaceUsed = ( long ) Math . ceil ( avgEntrySize * numEntriesAtNewSamplingLevel ) ; forceUpsample . add ( new ResampleEntry ( sstable , spaceUsed , newSamplingLevel ) ) ; remainingSpace - = avgEntrySize * numEntriesAtNewSamplingLevel ; } else if ( targetNumEntries > = currentNumEntries * UPSAMPLE_THRESHOLD & & newSamplingLevel > currentSamplingLevel ) { long spaceUsed = ( long ) Math . ceil ( avgEntrySize * numEntriesAtNewSamplingLevel ) ; toUpsample . add ( new ResampleEntry ( sstable , spaceUsed , newSamplingLevel ) ) ; remainingSpace - = avgEntrySize * numEntriesAtNewSamplingLevel ; } else if ( targetNumEntries < currentNumEntries * DOWNSAMPLE_THESHOLD & & newSamplingLevel < currentSamplingLevel ) { long spaceUsed = ( long ) Math . ceil ( avgEntrySize * numEntriesAtNewSamplingLevel ) ; toDownsample . add ( new ResampleEntry ( sstable , spaceUsed , newSamplingLevel ) ) ; remainingSpace - = spaceUsed ; } else { logger . trace ( <str> , sstable ) ; remainingSpace - = sstable . getIndexSummaryOffHeapSize ( ) ; newSSTables . add ( sstable ) ; transactions . get ( sstable . metadata . cfId ) . cancel ( sstable ) ; } totalReadsPerSec - = readsPerSec ; } if ( remainingSpace > <int> ) { Pair < List < SSTableReader > , List < ResampleEntry > > result = distributeRemainingSpace ( toDownsample , remainingSpace ) ; toDownsample = result . right ; newSSTables . addAll ( result . left ) ; for ( SSTableReader sstable : result . left ) transactions . get ( sstable . metadata . cfId ) . cancel ( sstable ) ; } toDownsample . addAll ( forceResample ) ; toDownsample . addAll ( toUpsample ) ; toDownsample . addAll ( forceUpsample ) ; for ( ResampleEntry entry : toDownsample ) { if ( isStopRequested ( ) ) throw new CompactionInterruptedException ( getCompactionInfo ( ) ) ; SSTableReader sstable = entry . sstable ; logger . trace ( <str> , sstable , sstable . getIndexSummarySamplingLevel ( ) , Downsampling . BASE_SAMPLING_LEVEL , entry . newSamplingLevel , Downsampling . BASE_SAMPLING_LEVEL ) ; ColumnFamilyStore cfs = Keyspace . open ( sstable . metadata . ksName ) . getColumnFamilyStore ( sstable . metadata . cfId ) ; SSTableReader replacement = sstable . cloneWithNewSummarySamplingLevel ( cfs , entry . newSamplingLevel ) ; newSSTables . add ( replacement ) ; transactions . get ( sstable . metadata . cfId ) . update ( replacement , true ) ; } return newSSTables ; } @VisibleForTesting static Pair < List < SSTableReader > , List < ResampleEntry > > distributeRemainingSpace ( List < ResampleEntry > toDownsample , long remainingSpace ) { Collections . sort ( toDownsample , new Comparator < ResampleEntry > ( ) { public int compare ( ResampleEntry o1 , ResampleEntry o2 ) { return Double . compare ( o1 . sstable . getIndexSummaryOffHeapSize ( ) - o1 . newSpaceUsed , o2 . sstable . getIndexSummaryOffHeapSize ( ) - o2 . newSpaceUsed ) ; } } ) ; int noDownsampleCutoff = <int> ; List < SSTableReader > willNotDownsample = new ArrayList < > ( ) ; while ( remainingSpace > <int> & & noDownsampleCutoff < toDownsample . size ( ) ) { ResampleEntry entry = toDownsample . get ( noDownsampleCutoff ) ; long extraSpaceRequired = entry . sstable . getIndexSummaryOffHeapSize ( ) - entry . newSpaceUsed ; if ( extraSpaceRequired < = remainingSpace ) { logger . trace ( <str> , entry . sstable , entry . sstable . getIndexSummarySamplingLevel ( ) ) ; willNotDownsample . add ( entry . sstable ) ; remainingSpace - = extraSpaceRequired ; } else { break ; } noDownsampleCutoff + + ; } return Pair . create ( willNotDownsample , toDownsample . subList ( noDownsampleCutoff , toDownsample . size ( ) ) ) ; } public CompactionInfo getCompactionInfo ( ) { return new CompactionInfo ( OperationType . INDEX_SUMMARY , ( memoryPoolBytes - remainingSpace ) , memoryPoolBytes , <str> , compactionId ) ; } private static class ReadRateComparator implements Comparator < SSTableReader > { private final Map < SSTableReader , Double > readRates ; ReadRateComparator ( Map < SSTableReader , Double > readRates ) { this . readRates = readRates ; } @Override public int compare ( SSTableReader o1 , SSTableReader o2 ) { Double readRate1 = readRates . get ( o1 ) ; Double readRate2 = readRates . get ( o2 ) ; if ( readRate1 = = null & & readRate2 = = null ) return <int> ; else if ( readRate1 = = null ) return - <int> ; else if ( readRate2 = = null ) return <int> ; else return Double . compare ( readRate1 , readRate2 ) ; } } private static class ResampleEntry { public final SSTableReader sstable ; public final long newSpaceUsed ; public final int newSamplingLevel ; ResampleEntry ( SSTableReader sstable , long newSpaceUsed , int newSamplingLevel ) { this . sstable = sstable ; this . newSpaceUsed = newSpaceUsed ; this . newSamplingLevel = newSamplingLevel ; } } } 
