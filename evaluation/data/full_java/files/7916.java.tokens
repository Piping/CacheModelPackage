package org . elasticsearch . common . geo . builders ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . NamedWriteableAwareStreamInput ; import org . elasticsearch . common . io . stream . NamedWriteableRegistry ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . xcontent . * ; import org . elasticsearch . test . ESTestCase ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import java . io . IOException ; import static org . hamcrest . Matchers . * ; public abstract class AbstractShapeBuilderTestCase < SB extends ShapeBuilder > extends ESTestCase { private static final int NUMBER_OF_TESTBUILDERS = <int> ; private static NamedWriteableRegistry namedWriteableRegistry ; @BeforeClass public static void init ( ) { if ( namedWriteableRegistry = = null ) { namedWriteableRegistry = new NamedWriteableRegistry ( ) ; namedWriteableRegistry . registerPrototype ( ShapeBuilder . class , PointBuilder . PROTOTYPE ) ; namedWriteableRegistry . registerPrototype ( ShapeBuilder . class , CircleBuilder . PROTOTYPE ) ; namedWriteableRegistry . registerPrototype ( ShapeBuilder . class , EnvelopeBuilder . PROTOTYPE ) ; } } @AfterClass public static void afterClass ( ) throws Exception { namedWriteableRegistry = null ; } protected abstract SB createTestShapeBuilder ( ) ; protected abstract SB mutate ( SB original ) throws IOException ; public void testFromXContent ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTBUILDERS ; runs + + ) { SB testShape = createTestShapeBuilder ( ) ; XContentBuilder contentBuilder = XContentFactory . contentBuilder ( randomFrom ( XContentType . values ( ) ) ) ; if ( randomBoolean ( ) ) { contentBuilder . prettyPrint ( ) ; } XContentBuilder builder = testShape . toXContent ( contentBuilder , ToXContent . EMPTY_PARAMS ) ; XContentParser shapeParser = XContentHelper . createParser ( builder . bytes ( ) ) ; XContentHelper . createParser ( builder . bytes ( ) ) ; shapeParser . nextToken ( ) ; ShapeBuilder parsedShape = ShapeBuilder . parse ( shapeParser ) ; assertNotSame ( testShape , parsedShape ) ; assertEquals ( testShape , parsedShape ) ; assertEquals ( testShape . hashCode ( ) , parsedShape . hashCode ( ) ) ; } } public void testSerialization ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTBUILDERS ; runs + + ) { SB testShape = createTestShapeBuilder ( ) ; SB deserializedShape = copyShape ( testShape ) ; assertEquals ( deserializedShape , testShape ) ; assertEquals ( deserializedShape . hashCode ( ) , testShape . hashCode ( ) ) ; assertNotSame ( deserializedShape , testShape ) ; } } public void testEqualsAndHashcode ( ) throws IOException { for ( int runs = <int> ; runs < NUMBER_OF_TESTBUILDERS ; runs + + ) { SB firstShape = createTestShapeBuilder ( ) ; assertFalse ( <str> , firstShape . equals ( null ) ) ; assertFalse ( <str> , firstShape . equals ( <str> ) ) ; assertTrue ( <str> , firstShape . equals ( firstShape ) ) ; assertThat ( <str> , firstShape . hashCode ( ) , equalTo ( firstShape . hashCode ( ) ) ) ; assertThat ( <str> , mutate ( firstShape ) , not ( equalTo ( firstShape ) ) ) ; SB secondShape = copyShape ( firstShape ) ; assertTrue ( <str> , secondShape . equals ( secondShape ) ) ; assertTrue ( <str> , firstShape . equals ( secondShape ) ) ; assertTrue ( <str> , secondShape . equals ( firstShape ) ) ; assertThat ( <str> , secondShape . hashCode ( ) , equalTo ( firstShape . hashCode ( ) ) ) ; SB thirdShape = copyShape ( secondShape ) ; assertTrue ( <str> , thirdShape . equals ( thirdShape ) ) ; assertTrue ( <str> , secondShape . equals ( thirdShape ) ) ; assertThat ( <str> , secondShape . hashCode ( ) , equalTo ( thirdShape . hashCode ( ) ) ) ; assertTrue ( <str> , firstShape . equals ( thirdShape ) ) ; assertThat ( <str> , firstShape . hashCode ( ) , equalTo ( thirdShape . hashCode ( ) ) ) ; assertTrue ( <str> , thirdShape . equals ( secondShape ) ) ; assertTrue ( <str> , thirdShape . equals ( firstShape ) ) ; } } protected SB copyShape ( SB original ) throws IOException { try ( BytesStreamOutput output = new BytesStreamOutput ( ) ) { original . writeTo ( output ) ; try ( StreamInput in = new NamedWriteableAwareStreamInput ( StreamInput . wrap ( output . bytes ( ) ) , namedWriteableRegistry ) ) { ShapeBuilder prototype = ( ShapeBuilder ) namedWriteableRegistry . getPrototype ( ShapeBuilder . class , original . getWriteableName ( ) ) ; @SuppressWarnings ( <str> ) SB copy = ( SB ) prototype . readFrom ( in ) ; return copy ; } } } } 
