package org . elasticsearch . search . aggregations . pipeline . moving . avg ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . collect . EvictingQueue ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram ; import org . elasticsearch . search . aggregations . bucket . histogram . InternalHistogram . Bucket ; import org . elasticsearch . search . aggregations . metrics . ValuesSourceMetricsAggregationBuilder ; import org . elasticsearch . search . aggregations . metrics . avg . Avg ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregationHelperTests ; import org . elasticsearch . search . aggregations . pipeline . SimpleValue ; import org . elasticsearch . search . aggregations . pipeline . derivative . Derivative ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . EwmaModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . HoltLinearModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . HoltWintersModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . LinearModel ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . MovAvgModelBuilder ; import org . elasticsearch . search . aggregations . pipeline . movavg . models . SimpleModel ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . search . aggregations . AggregationBuilders . avg ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . max ; import static org . elasticsearch . search . aggregations . AggregationBuilders . min ; import static org . elasticsearch . search . aggregations . AggregationBuilders . range ; import static org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilders . derivative ; import static org . elasticsearch . search . aggregations . pipeline . PipelineAggregatorBuilders . movingAvg ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . core . IsNull . notNullValue ; import static org . hamcrest . core . IsNull . nullValue ; @ESIntegTestCase.SuiteScopeTestCase public class MovAvgIT extends ESIntegTestCase { private static final String INTERVAL_FIELD = <str> ; private static final String VALUE_FIELD = <str> ; static int interval ; static int numBuckets ; static int windowSize ; static double alpha ; static double beta ; static double gamma ; static int period ; static HoltWintersModel . SeasonalityType seasonalityType ; static BucketHelpers . GapPolicy gapPolicy ; static ValuesSourceMetricsAggregationBuilder metric ; static List < PipelineAggregationHelperTests . MockBucket > mockHisto ; static Map < String , ArrayList < Double > > testValues ; enum MovAvgType { SIMPLE ( <str> ) , LINEAR ( <str> ) , EWMA ( <str> ) , HOLT ( <str> ) , HOLT_WINTERS ( <str> ) , HOLT_BIG_MINIMIZE ( <str> ) ; private final String name ; MovAvgType ( String s ) { name = s ; } @Override public String toString ( ) { return name ; } } enum MetricTarget { VALUE ( <str> ) , COUNT ( <str> ) , METRIC ( <str> ) ; private final String name ; MetricTarget ( String s ) { name = s ; } @Override public String toString ( ) { return name ; } } @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; interval = <int> ; numBuckets = randomIntBetween ( <int> , <int> ) ; period = randomIntBetween ( <int> , <int> ) ; windowSize = randomIntBetween ( period * <int> , <int> ) ; alpha = randomDouble ( ) ; beta = randomDouble ( ) ; gamma = randomDouble ( ) ; seasonalityType = randomBoolean ( ) ? HoltWintersModel . SeasonalityType . ADDITIVE : HoltWintersModel . SeasonalityType . MULTIPLICATIVE ; gapPolicy = randomBoolean ( ) ? BucketHelpers . GapPolicy . SKIP : BucketHelpers . GapPolicy . INSERT_ZEROS ; metric = randomMetric ( <str> , VALUE_FIELD ) ; mockHisto = PipelineAggregationHelperTests . generateHistogram ( interval , numBuckets , randomDouble ( ) , randomDouble ( ) ) ; testValues = new HashMap < > ( <int> ) ; for ( MovAvgType type : MovAvgType . values ( ) ) { for ( MetricTarget target : MetricTarget . values ( ) ) { if ( type . equals ( MovAvgType . HOLT_BIG_MINIMIZE ) ) { setupExpected ( type , target , numBuckets ) ; } else { setupExpected ( type , target , windowSize ) ; } } } for ( PipelineAggregationHelperTests . MockBucket mockBucket : mockHisto ) { for ( double value : mockBucket . docValues ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( INTERVAL_FIELD , mockBucket . key ) . field ( VALUE_FIELD , value ) . endObject ( ) ) ) ; } } for ( int i = - <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( INTERVAL_FIELD , i ) . field ( VALUE_FIELD , <int> ) . endObject ( ) ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( INTERVAL_FIELD , i ) . field ( VALUE_FIELD , <int> ) . endObject ( ) ) ) ; } indexRandom ( true , builders ) ; ensureSearchable ( ) ; } private void setupExpected ( MovAvgType type , MetricTarget target , int windowSize ) { ArrayList < Double > values = new ArrayList < > ( numBuckets ) ; EvictingQueue < Double > window = new EvictingQueue < > ( windowSize ) ; for ( PipelineAggregationHelperTests . MockBucket mockBucket : mockHisto ) { double metricValue ; double [ ] docValues = mockBucket . docValues ; if ( mockBucket . count = = <int> & & target . equals ( MetricTarget . VALUE ) ) { if ( gapPolicy . equals ( BucketHelpers . GapPolicy . SKIP ) ) { values . add ( null ) ; continue ; } else if ( gapPolicy . equals ( BucketHelpers . GapPolicy . INSERT_ZEROS ) ) { metricValue = <float> ; } else { metricValue = PipelineAggregationHelperTests . calculateMetric ( docValues , metric ) ; } } else { metricValue = target . equals ( MetricTarget . VALUE ) ? PipelineAggregationHelperTests . calculateMetric ( docValues , metric ) : mockBucket . count ; } if ( window . size ( ) > <int> ) { switch ( type ) { case SIMPLE : values . add ( simple ( window ) ) ; break ; case LINEAR : values . add ( linear ( window ) ) ; break ; case EWMA : values . add ( ewma ( window ) ) ; break ; case HOLT : values . add ( holt ( window ) ) ; break ; case HOLT_BIG_MINIMIZE : values . add ( holt ( window ) ) ; break ; case HOLT_WINTERS : if ( window . size ( ) > = period * <int> ) { values . add ( holtWinters ( window ) ) ; } else { values . add ( null ) ; } break ; } } else { values . add ( null ) ; } window . offer ( metricValue ) ; } testValues . put ( type . name ( ) + <str> + target . name ( ) , values ) ; } private double simple ( Collection < Double > window ) { double movAvg = <int> ; for ( double value : window ) { movAvg + = value ; } movAvg / = window . size ( ) ; return movAvg ; } private double linear ( Collection < Double > window ) { double avg = <int> ; long totalWeight = <int> ; long current = <int> ; for ( double value : window ) { avg + = value * current ; totalWeight + = current ; current + = <int> ; } return avg / totalWeight ; } private double ewma ( Collection < Double > window ) { double avg = <int> ; boolean first = true ; for ( double value : window ) { if ( first ) { avg = value ; first = false ; } else { avg = ( value * alpha ) + ( avg * ( <int> - alpha ) ) ; } } return avg ; } private double holt ( Collection < Double > window ) { double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; int counter = <int> ; double last ; for ( double value : window ) { last = value ; if ( counter = = <int> ) { s = value ; b = value - last ; } else { s = alpha * value + ( <float> - alpha ) * ( last_s + last_b ) ; b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; } counter + = <int> ; last_s = s ; last_b = b ; } return s + ( <int> * b ) ; } private double holtWinters ( Collection < Double > window ) { double s = <int> ; double last_s = <int> ; double b = <int> ; double last_b = <int> ; double [ ] seasonal = new double [ window . size ( ) ] ; double padding = seasonalityType . equals ( HoltWintersModel . SeasonalityType . MULTIPLICATIVE ) ? <float> : <int> ; int counter = <int> ; double [ ] vs = new double [ window . size ( ) ] ; for ( double v : window ) { vs [ counter ] = v + padding ; counter + = <int> ; } for ( int i = <int> ; i < period ; i + + ) { s + = vs [ i ] ; b + = ( vs [ i + period ] - vs [ i ] ) / period ; } s / = period ; b / = period ; last_s = s ; if ( Double . compare ( s , <float> ) = = <int> | | Double . compare ( s , - <float> ) = = <int> ) { Arrays . fill ( seasonal , <float> ) ; } else { for ( int i = <int> ; i < period ; i + + ) { seasonal [ i ] = vs [ i ] / s ; } } for ( int i = period ; i < vs . length ; i + + ) { if ( seasonalityType . equals ( HoltWintersModel . SeasonalityType . MULTIPLICATIVE ) ) { s = alpha * ( vs [ i ] / seasonal [ i - period ] ) + ( <float> - alpha ) * ( last_s + last_b ) ; } else { s = alpha * ( vs [ i ] - seasonal [ i - period ] ) + ( <float> - alpha ) * ( last_s + last_b ) ; } b = beta * ( s - last_s ) + ( <int> - beta ) * last_b ; if ( seasonalityType . equals ( HoltWintersModel . SeasonalityType . MULTIPLICATIVE ) ) { seasonal [ i ] = gamma * ( vs [ i ] / ( last_s + last_b ) ) + ( <int> - gamma ) * seasonal [ i - period ] ; } else { seasonal [ i ] = gamma * ( vs [ i ] - ( last_s - last_b ) ) + ( <int> - gamma ) * seasonal [ i - period ] ; } last_s = s ; last_b = b ; } int idx = window . size ( ) - period + ( <int> % period ) ; if ( seasonalityType . equals ( HoltWintersModel . SeasonalityType . MULTIPLICATIVE ) ) { return ( s + ( <int> * b ) ) * seasonal [ idx ] ; } else { return s + ( <int> * b ) + seasonal [ idx ] ; } } public void testSimpleSingleValuedField ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( mockHisto . size ( ) ) ) ; List < Double > expectedCounts = testValues . get ( MovAvgType . SIMPLE . name ( ) + <str> + MetricTarget . COUNT . name ( ) ) ; List < Double > expectedValues = testValues . get ( MovAvgType . SIMPLE . name ( ) + <str> + MetricTarget . VALUE . name ( ) ) ; Iterator < ? extends Histogram . Bucket > actualIter = buckets . iterator ( ) ; Iterator < PipelineAggregationHelperTests . MockBucket > expectedBucketIter = mockHisto . iterator ( ) ; Iterator < Double > expectedCountsIter = expectedCounts . iterator ( ) ; Iterator < Double > expectedValuesIter = expectedValues . iterator ( ) ; while ( actualIter . hasNext ( ) ) { assertValidIterators ( expectedBucketIter , expectedCountsIter , expectedValuesIter ) ; Histogram . Bucket actual = actualIter . next ( ) ; PipelineAggregationHelperTests . MockBucket expected = expectedBucketIter . next ( ) ; Double expectedCount = expectedCountsIter . next ( ) ; Double expectedValue = expectedValuesIter . next ( ) ; assertThat ( <str> , ( ( Number ) actual . getKey ( ) ) . longValue ( ) , equalTo ( expected . key ) ) ; assertThat ( <str> , actual . getDocCount ( ) , equalTo ( ( long ) expected . count ) ) ; assertBucketContents ( actual , expectedCount , expectedValue ) ; } } public void testLinearSingleValuedField ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new LinearModel . LinearModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new LinearModel . LinearModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( mockHisto . size ( ) ) ) ; List < Double > expectedCounts = testValues . get ( MovAvgType . LINEAR . name ( ) + <str> + MetricTarget . COUNT . name ( ) ) ; List < Double > expectedValues = testValues . get ( MovAvgType . LINEAR . name ( ) + <str> + MetricTarget . VALUE . name ( ) ) ; Iterator < ? extends Histogram . Bucket > actualIter = buckets . iterator ( ) ; Iterator < PipelineAggregationHelperTests . MockBucket > expectedBucketIter = mockHisto . iterator ( ) ; Iterator < Double > expectedCountsIter = expectedCounts . iterator ( ) ; Iterator < Double > expectedValuesIter = expectedValues . iterator ( ) ; while ( actualIter . hasNext ( ) ) { assertValidIterators ( expectedBucketIter , expectedCountsIter , expectedValuesIter ) ; Histogram . Bucket actual = actualIter . next ( ) ; PipelineAggregationHelperTests . MockBucket expected = expectedBucketIter . next ( ) ; Double expectedCount = expectedCountsIter . next ( ) ; Double expectedValue = expectedValuesIter . next ( ) ; assertThat ( <str> , ( ( Number ) actual . getKey ( ) ) . longValue ( ) , equalTo ( expected . key ) ) ; assertThat ( <str> , actual . getDocCount ( ) , equalTo ( ( long ) expected . count ) ) ; assertBucketContents ( actual , expectedCount , expectedValue ) ; } } public void testEwmaSingleValuedField ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new EwmaModel . EWMAModelBuilder ( ) . alpha ( alpha ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new EwmaModel . EWMAModelBuilder ( ) . alpha ( alpha ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( mockHisto . size ( ) ) ) ; List < Double > expectedCounts = testValues . get ( MovAvgType . EWMA . name ( ) + <str> + MetricTarget . COUNT . name ( ) ) ; List < Double > expectedValues = testValues . get ( MovAvgType . EWMA . name ( ) + <str> + MetricTarget . VALUE . name ( ) ) ; Iterator < ? extends Histogram . Bucket > actualIter = buckets . iterator ( ) ; Iterator < PipelineAggregationHelperTests . MockBucket > expectedBucketIter = mockHisto . iterator ( ) ; Iterator < Double > expectedCountsIter = expectedCounts . iterator ( ) ; Iterator < Double > expectedValuesIter = expectedValues . iterator ( ) ; while ( actualIter . hasNext ( ) ) { assertValidIterators ( expectedBucketIter , expectedCountsIter , expectedValuesIter ) ; Histogram . Bucket actual = actualIter . next ( ) ; PipelineAggregationHelperTests . MockBucket expected = expectedBucketIter . next ( ) ; Double expectedCount = expectedCountsIter . next ( ) ; Double expectedValue = expectedValuesIter . next ( ) ; assertThat ( <str> , ( ( Number ) actual . getKey ( ) ) . longValue ( ) , equalTo ( expected . key ) ) ; assertThat ( <str> , actual . getDocCount ( ) , equalTo ( ( long ) expected . count ) ) ; assertBucketContents ( actual , expectedCount , expectedValue ) ; } } public void testHoltSingleValuedField ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new HoltLinearModel . HoltLinearModelBuilder ( ) . alpha ( alpha ) . beta ( beta ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new HoltLinearModel . HoltLinearModelBuilder ( ) . alpha ( alpha ) . beta ( beta ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( mockHisto . size ( ) ) ) ; List < Double > expectedCounts = testValues . get ( MovAvgType . HOLT . name ( ) + <str> + MetricTarget . COUNT . name ( ) ) ; List < Double > expectedValues = testValues . get ( MovAvgType . HOLT . name ( ) + <str> + MetricTarget . VALUE . name ( ) ) ; Iterator < ? extends Histogram . Bucket > actualIter = buckets . iterator ( ) ; Iterator < PipelineAggregationHelperTests . MockBucket > expectedBucketIter = mockHisto . iterator ( ) ; Iterator < Double > expectedCountsIter = expectedCounts . iterator ( ) ; Iterator < Double > expectedValuesIter = expectedValues . iterator ( ) ; while ( actualIter . hasNext ( ) ) { assertValidIterators ( expectedBucketIter , expectedCountsIter , expectedValuesIter ) ; Histogram . Bucket actual = actualIter . next ( ) ; PipelineAggregationHelperTests . MockBucket expected = expectedBucketIter . next ( ) ; Double expectedCount = expectedCountsIter . next ( ) ; Double expectedValue = expectedValuesIter . next ( ) ; assertThat ( <str> , ( ( Number ) actual . getKey ( ) ) . longValue ( ) , equalTo ( expected . key ) ) ; assertThat ( <str> , actual . getDocCount ( ) , equalTo ( ( long ) expected . count ) ) ; assertBucketContents ( actual , expectedCount , expectedValue ) ; } } public void testHoltWintersValuedField ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new HoltWintersModel . HoltWintersModelBuilder ( ) . alpha ( alpha ) . beta ( beta ) . gamma ( gamma ) . period ( period ) . seasonalityType ( seasonalityType ) ) . gapPolicy ( gapPolicy ) . minimize ( false ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new HoltWintersModel . HoltWintersModelBuilder ( ) . alpha ( alpha ) . beta ( beta ) . gamma ( gamma ) . period ( period ) . seasonalityType ( seasonalityType ) ) . gapPolicy ( gapPolicy ) . minimize ( false ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( mockHisto . size ( ) ) ) ; List < Double > expectedCounts = testValues . get ( MovAvgType . HOLT_WINTERS . name ( ) + <str> + MetricTarget . COUNT . name ( ) ) ; List < Double > expectedValues = testValues . get ( MovAvgType . HOLT_WINTERS . name ( ) + <str> + MetricTarget . VALUE . name ( ) ) ; Iterator < ? extends Histogram . Bucket > actualIter = buckets . iterator ( ) ; Iterator < PipelineAggregationHelperTests . MockBucket > expectedBucketIter = mockHisto . iterator ( ) ; Iterator < Double > expectedCountsIter = expectedCounts . iterator ( ) ; Iterator < Double > expectedValuesIter = expectedValues . iterator ( ) ; while ( actualIter . hasNext ( ) ) { assertValidIterators ( expectedBucketIter , expectedCountsIter , expectedValuesIter ) ; Histogram . Bucket actual = actualIter . next ( ) ; PipelineAggregationHelperTests . MockBucket expected = expectedBucketIter . next ( ) ; Double expectedCount = expectedCountsIter . next ( ) ; Double expectedValue = expectedValuesIter . next ( ) ; assertThat ( <str> , ( ( Number ) actual . getKey ( ) ) . longValue ( ) , equalTo ( expected . key ) ) ; assertThat ( <str> , actual . getDocCount ( ) , equalTo ( ( long ) expected . count ) ) ; assertBucketContents ( actual , expectedCount , expectedValue ) ; } } public void testPredictNegativeKeysAtStart ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( <int> ) . subAggregation ( avg ( <str> ) . field ( VALUE_FIELD ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . predict ( <int> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( <int> ) ) ; SimpleValue current = buckets . get ( <int> ) . getAggregations ( ) . get ( <str> ) ; assertThat ( current , nullValue ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( long ) bucket . getKey ( ) , equalTo ( ( long ) i - <int> ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Avg avgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgAgg , notNullValue ( ) ) ; assertThat ( avgAgg . value ( ) , equalTo ( <int> d ) ) ; SimpleValue movAvgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( movAvgAgg , notNullValue ( ) ) ; assertThat ( movAvgAgg . value ( ) , equalTo ( <int> d ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( long ) bucket . getKey ( ) , equalTo ( ( long ) i - <int> ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> l ) ) ; Avg avgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgAgg , nullValue ( ) ) ; SimpleValue movAvgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( movAvgAgg , notNullValue ( ) ) ; assertThat ( movAvgAgg . value ( ) , equalTo ( <int> d ) ) ; } } public void testSizeZeroWindow ( ) { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( randomMetric ( <str> , VALUE_FIELD ) ) . subAggregation ( movingAvg ( <str> ) . window ( <int> ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testBadParent ( ) { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( range ( <str> ) . field ( INTERVAL_FIELD ) . addRange ( <int> , <int> ) . subAggregation ( randomMetric ( <str> , VALUE_FIELD ) ) . subAggregation ( movingAvg ( <str> ) . window ( <int> ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException exception ) { } } public void testNegativeWindow ( ) { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( randomMetric ( <str> , VALUE_FIELD ) ) . subAggregation ( movingAvg ( <str> ) . window ( - <int> ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException exception ) { } } public void testNoBucketsInHistogram ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( <str> ) . interval ( interval ) . subAggregation ( randomMetric ( <str> , VALUE_FIELD ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; } public void testNoBucketsInHistogramWithPredict ( ) { int numPredictions = randomIntBetween ( <int> , <int> ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( <str> ) . interval ( interval ) . subAggregation ( randomMetric ( <str> , VALUE_FIELD ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) . predict ( numPredictions ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( <int> ) ) ; } public void testZeroPrediction ( ) { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( randomMetric ( <str> , VALUE_FIELD ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( randomModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . predict ( <int> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException exception ) { } } public void testNegativePrediction ( ) { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( randomMetric ( <str> , VALUE_FIELD ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( randomModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . predict ( - <int> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException exception ) { } } public void testHoltWintersNotEnoughData ( ) { try { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( <int> ) . modelBuilder ( new HoltWintersModel . HoltWintersModelBuilder ( ) . alpha ( alpha ) . beta ( beta ) . gamma ( gamma ) . period ( <int> ) . seasonalityType ( seasonalityType ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new HoltWintersModel . HoltWintersModelBuilder ( ) . alpha ( alpha ) . beta ( beta ) . gamma ( gamma ) . period ( <int> ) . seasonalityType ( seasonalityType ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; } catch ( SearchPhaseExecutionException e ) { } } public void testTwoMovAvgsWithPredictions ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( <int> ) . subAggregation ( avg ( <str> ) . field ( VALUE_FIELD ) ) . subAggregation ( derivative ( <str> ) . setBucketsPaths ( <str> ) . gapPolicy ( gapPolicy ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . predict ( <int> ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . predict ( <int> ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( <int> ) ) ; Bucket bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( long ) bucket . getKey ( ) , equalTo ( ( long ) <int> ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Avg avgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgAgg , notNullValue ( ) ) ; assertThat ( avgAgg . value ( ) , equalTo ( <int> d ) ) ; SimpleValue movAvgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( movAvgAgg , nullValue ( ) ) ; Derivative deriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , nullValue ( ) ) ; SimpleValue derivMovAvg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( derivMovAvg , nullValue ( ) ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( long ) bucket . getKey ( ) , equalTo ( <int> ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; avgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgAgg , notNullValue ( ) ) ; assertThat ( avgAgg . value ( ) , equalTo ( <int> d ) ) ; deriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . value ( ) , equalTo ( <float> ) ) ; movAvgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( movAvgAgg , notNullValue ( ) ) ; assertThat ( movAvgAgg . value ( ) , equalTo ( <int> d ) ) ; derivMovAvg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( derivMovAvg , Matchers . nullValue ( ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( long ) bucket . getKey ( ) , equalTo ( ( long ) i ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; avgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgAgg , notNullValue ( ) ) ; assertThat ( avgAgg . value ( ) , equalTo ( <int> d ) ) ; deriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , notNullValue ( ) ) ; assertThat ( deriv . value ( ) , equalTo ( <float> ) ) ; movAvgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( movAvgAgg , notNullValue ( ) ) ; assertThat ( movAvgAgg . value ( ) , equalTo ( <int> d ) ) ; derivMovAvg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( derivMovAvg , notNullValue ( ) ) ; assertThat ( derivMovAvg . value ( ) , equalTo ( <float> ) ) ; } for ( int i = <int> ; i < <int> ; i + + ) { bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( long ) bucket . getKey ( ) , equalTo ( ( long ) i ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> l ) ) ; avgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( avgAgg , nullValue ( ) ) ; deriv = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( deriv , nullValue ( ) ) ; movAvgAgg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( movAvgAgg , notNullValue ( ) ) ; assertThat ( movAvgAgg . value ( ) , equalTo ( <int> d ) ) ; derivMovAvg = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( derivMovAvg , notNullValue ( ) ) ; assertThat ( derivMovAvg . value ( ) , equalTo ( <float> ) ) ; } } public void testBadModelParams ( ) { try { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( <int> ) . modelBuilder ( randomModelBuilder ( <int> ) ) . gapPolicy ( gapPolicy ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; } catch ( SearchPhaseExecutionException e ) { } } public void testHoltWintersMinimization ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new HoltWintersModel . HoltWintersModelBuilder ( ) . period ( period ) . seasonalityType ( seasonalityType ) ) . gapPolicy ( gapPolicy ) . minimize ( true ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( windowSize ) . modelBuilder ( new HoltWintersModel . HoltWintersModelBuilder ( ) . period ( period ) . seasonalityType ( seasonalityType ) ) . gapPolicy ( gapPolicy ) . minimize ( true ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( mockHisto . size ( ) ) ) ; List < Double > expectedCounts = testValues . get ( MovAvgType . HOLT_WINTERS . name ( ) + <str> + MetricTarget . COUNT . name ( ) ) ; List < Double > expectedValues = testValues . get ( MovAvgType . HOLT_WINTERS . name ( ) + <str> + MetricTarget . VALUE . name ( ) ) ; Iterator < ? extends Histogram . Bucket > actualIter = buckets . iterator ( ) ; Iterator < PipelineAggregationHelperTests . MockBucket > expectedBucketIter = mockHisto . iterator ( ) ; Iterator < Double > expectedCountsIter = expectedCounts . iterator ( ) ; Iterator < Double > expectedValueIter = expectedValues . iterator ( ) ; while ( actualIter . hasNext ( ) ) { Histogram . Bucket actual = actualIter . next ( ) ; PipelineAggregationHelperTests . MockBucket expected = expectedBucketIter . next ( ) ; Double expectedCount = expectedCountsIter . next ( ) ; Double expectedValue = expectedValueIter . next ( ) ; assertThat ( <str> , ( ( Number ) actual . getKey ( ) ) . longValue ( ) , equalTo ( expected . key ) ) ; assertThat ( <str> , actual . getDocCount ( ) , equalTo ( ( long ) expected . count ) ) ; SimpleValue countMovAvg = actual . getAggregations ( ) . get ( <str> ) ; SimpleValue valuesMovAvg = actual . getAggregations ( ) . get ( <str> ) ; if ( expectedCount = = null ) { assertThat ( countMovAvg , nullValue ( ) ) ; } else { assertThat ( countMovAvg , notNullValue ( ) ) ; } if ( expectedValue = = null ) { assertThat ( valuesMovAvg , nullValue ( ) ) ; } else { assertThat ( valuesMovAvg , notNullValue ( ) ) ; } } } public void testMinimizeNotEnoughData ( ) { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( numBuckets ) . modelBuilder ( new HoltLinearModel . HoltLinearModelBuilder ( ) . alpha ( alpha ) . beta ( beta ) ) . gapPolicy ( gapPolicy ) . minimize ( true ) . setBucketsPaths ( <str> ) ) . subAggregation ( movingAvg ( <str> ) . window ( numBuckets ) . modelBuilder ( new HoltLinearModel . HoltLinearModelBuilder ( ) . alpha ( alpha ) . beta ( beta ) ) . gapPolicy ( gapPolicy ) . minimize ( true ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; InternalHistogram < Bucket > histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( <str> , buckets . size ( ) , equalTo ( mockHisto . size ( ) ) ) ; List < Double > expectedCounts = testValues . get ( MovAvgType . HOLT_BIG_MINIMIZE . name ( ) + <str> + MetricTarget . COUNT . name ( ) ) ; List < Double > expectedValues = testValues . get ( MovAvgType . HOLT_BIG_MINIMIZE . name ( ) + <str> + MetricTarget . VALUE . name ( ) ) ; Iterator < ? extends Histogram . Bucket > actualIter = buckets . iterator ( ) ; Iterator < PipelineAggregationHelperTests . MockBucket > expectedBucketIter = mockHisto . iterator ( ) ; Iterator < Double > expectedCountsIter = expectedCounts . iterator ( ) ; Iterator < Double > expectedValuesIter = expectedValues . iterator ( ) ; while ( actualIter . hasNext ( ) ) { assertValidIterators ( expectedBucketIter , expectedCountsIter , expectedValuesIter ) ; Histogram . Bucket actual = actualIter . next ( ) ; PipelineAggregationHelperTests . MockBucket expected = expectedBucketIter . next ( ) ; Double expectedCount = expectedCountsIter . next ( ) ; Double expectedValue = expectedValuesIter . next ( ) ; assertThat ( <str> , ( ( Number ) actual . getKey ( ) ) . longValue ( ) , equalTo ( expected . key ) ) ; assertThat ( <str> , actual . getDocCount ( ) , equalTo ( ( long ) expected . count ) ) ; assertBucketContents ( actual , expectedCount , expectedValue ) ; } } public void testCheckIfNonTunableCanBeMinimized ( ) { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( numBuckets ) . modelBuilder ( new SimpleModel . SimpleModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . minimize ( true ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException e ) { } try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( numBuckets ) . modelBuilder ( new LinearModel . LinearModelBuilder ( ) ) . gapPolicy ( gapPolicy ) . minimize ( true ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( SearchPhaseExecutionException e ) { } } public void testCheckIfTunableCanBeMinimized ( ) { MovAvgModelBuilder [ ] builders = new MovAvgModelBuilder [ ] { new EwmaModel . EWMAModelBuilder ( ) , new HoltLinearModel . HoltLinearModelBuilder ( ) , new HoltWintersModel . HoltWintersModelBuilder ( ) } ; for ( MovAvgModelBuilder builder : builders ) { try { client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( numBuckets ) . modelBuilder ( builder ) . gapPolicy ( gapPolicy ) . minimize ( true ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; } catch ( SearchPhaseExecutionException e ) { fail ( <str> + builder . toString ( ) + <str> ) ; } } } public void testUnrecognizedParams ( ) { MovAvgModelBuilder [ ] builders = new MovAvgModelBuilder [ ] { new SimpleModel . SimpleModelBuilder ( ) , new LinearModel . LinearModelBuilder ( ) , new EwmaModel . EWMAModelBuilder ( ) , new HoltLinearModel . HoltLinearModelBuilder ( ) , new HoltWintersModel . HoltWintersModelBuilder ( ) } ; Map < String , Object > badSettings = new HashMap < > ( <int> ) ; badSettings . put ( <str> , <float> ) ; for ( MovAvgModelBuilder builder : builders ) { try { SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( histogram ( <str> ) . field ( INTERVAL_FIELD ) . interval ( interval ) . extendedBounds ( <int> L , ( long ) ( interval * ( numBuckets - <int> ) ) ) . subAggregation ( metric ) . subAggregation ( movingAvg ( <str> ) . window ( <int> ) . modelBuilder ( builder ) . gapPolicy ( gapPolicy ) . settings ( badSettings ) . setBucketsPaths ( <str> ) ) ) . execute ( ) . actionGet ( ) ; } catch ( SearchPhaseExecutionException e ) { } } } private void assertValidIterators ( Iterator expectedBucketIter , Iterator expectedCountsIter , Iterator expectedValuesIter ) { if ( ! expectedBucketIter . hasNext ( ) ) { fail ( <str> ) ; } if ( ! expectedCountsIter . hasNext ( ) ) { fail ( <str> ) ; } if ( ! expectedValuesIter . hasNext ( ) ) { fail ( <str> ) ; } } private void assertBucketContents ( Histogram . Bucket actual , Double expectedCount , Double expectedValue ) { SimpleValue countMovAvg = actual . getAggregations ( ) . get ( <str> ) ; if ( expectedCount = = null ) { assertThat ( <str> , countMovAvg , nullValue ( ) ) ; } else if ( Double . isNaN ( expectedCount ) ) { assertThat ( <str> + countMovAvg . value ( ) + <str> , countMovAvg . value ( ) , equalTo ( Double . NaN ) ) ; } else { assertThat ( <str> , countMovAvg , notNullValue ( ) ) ; assertTrue ( <str> + countMovAvg . value ( ) + <str> + expectedCount + <str> , nearlyEqual ( countMovAvg . value ( ) , expectedCount , <float> ) ) ; } SimpleValue valuesMovAvg = actual . getAggregations ( ) . get ( <str> ) ; if ( expectedValue = = null ) { assertThat ( <str> , valuesMovAvg , Matchers . nullValue ( ) ) ; } else if ( Double . isNaN ( expectedValue ) ) { assertThat ( <str> + valuesMovAvg . value ( ) + <str> , valuesMovAvg . value ( ) , equalTo ( Double . NaN ) ) ; } else { assertThat ( <str> , valuesMovAvg , notNullValue ( ) ) ; assertTrue ( <str> + valuesMovAvg . value ( ) + <str> + expectedValue + <str> , nearlyEqual ( valuesMovAvg . value ( ) , expectedValue , <float> ) ) ; } } private static boolean nearlyEqual ( double a , double b , double epsilon ) { final double absA = Math . abs ( a ) ; final double absB = Math . abs ( b ) ; final double diff = Math . abs ( a - b ) ; if ( a = = b ) { return true ; } else if ( a = = <int> | | b = = <int> | | diff < Double . MIN_NORMAL ) { return diff < ( epsilon * Double . MIN_NORMAL ) ; } else { return diff / Math . min ( ( absA + absB ) , Double . MAX_VALUE ) < epsilon ; } } private MovAvgModelBuilder randomModelBuilder ( ) { return randomModelBuilder ( <int> ) ; } private MovAvgModelBuilder randomModelBuilder ( double padding ) { int rand = randomIntBetween ( <int> , <int> ) ; switch ( rand ) { case <int> : return new SimpleModel . SimpleModelBuilder ( ) ; case <int> : return new LinearModel . LinearModelBuilder ( ) ; case <int> : return new EwmaModel . EWMAModelBuilder ( ) . alpha ( alpha + padding ) ; case <int> : return new HoltLinearModel . HoltLinearModelBuilder ( ) . alpha ( alpha + padding ) . beta ( beta + padding ) ; default : return new SimpleModel . SimpleModelBuilder ( ) ; } } private ValuesSourceMetricsAggregationBuilder randomMetric ( String name , String field ) { int rand = randomIntBetween ( <int> , <int> ) ; switch ( rand ) { case <int> : return min ( name ) . field ( field ) ; case <int> : return max ( name ) . field ( field ) ; case <int> : return avg ( name ) . field ( field ) ; default : return avg ( name ) . field ( field ) ; } } } 
