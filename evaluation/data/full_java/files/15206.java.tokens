package org . gradle . play . tasks ; import com . google . common . collect . Lists ; import org . gradle . api . Action ; import org . gradle . api . Incubating ; import org . gradle . api . file . FileVisitDetails ; import org . gradle . api . file . FileVisitor ; import org . gradle . api . internal . file . RelativeFile ; import org . gradle . api . tasks . Input ; import org . gradle . api . tasks . OutputDirectory ; import org . gradle . api . tasks . SourceTask ; import org . gradle . api . tasks . TaskAction ; import org . gradle . api . tasks . compile . BaseForkOptions ; import org . gradle . api . tasks . incremental . IncrementalTaskInputs ; import org . gradle . api . tasks . incremental . InputFileDetails ; import org . gradle . language . base . internal . compile . Compiler ; import org . gradle . platform . base . internal . toolchain . ToolProvider ; import org . gradle . play . internal . CleaningPlayToolCompiler ; import org . gradle . play . internal . toolchain . PlayToolChainInternal ; import org . gradle . play . internal . twirl . DefaultTwirlCompileSpec ; import org . gradle . play . internal . twirl . TwirlCompileSpec ; import org . gradle . play . internal . twirl . TwirlCompilerFactory ; import org . gradle . play . platform . PlayPlatform ; import org . gradle . play . toolchain . PlayToolChain ; import javax . inject . Inject ; import java . io . File ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; @Incubating public class TwirlCompile extends SourceTask { private File outputDirectory ; private BaseForkOptions forkOptions ; private TwirlStaleOutputCleaner cleaner ; private PlayPlatform platform ; public BaseForkOptions getForkOptions ( ) { if ( forkOptions = = null ) { forkOptions = new BaseForkOptions ( ) ; } return forkOptions ; } @OutputDirectory public File getOutputDirectory ( ) { return outputDirectory ; } @Input public Object getDependencyNotation ( ) { return TwirlCompilerFactory . createAdapter ( platform ) . getDependencyNotation ( ) ; } public void setOutputDirectory ( File outputDirectory ) { this . outputDirectory = outputDirectory ; } @TaskAction void compile ( IncrementalTaskInputs inputs ) { RelativeFileCollector relativeFileCollector = new RelativeFileCollector ( ) ; getSource ( ) . visit ( relativeFileCollector ) ; TwirlCompileSpec spec = new DefaultTwirlCompileSpec ( relativeFileCollector . relativeFiles , getOutputDirectory ( ) , getForkOptions ( ) , useJavaDefaults ( ) ) ; if ( ! inputs . isIncremental ( ) ) { new CleaningPlayToolCompiler < TwirlCompileSpec > ( getCompiler ( ) , getOutputs ( ) ) . execute ( spec ) ; } else { final Set < File > sourcesToCompile = new HashSet < File > ( ) ; inputs . outOfDate ( new Action < InputFileDetails > ( ) { public void execute ( InputFileDetails inputFileDetails ) { sourcesToCompile . add ( inputFileDetails . getFile ( ) ) ; } } ) ; final Set < File > staleOutputFiles = new HashSet < File > ( ) ; inputs . removed ( new Action < InputFileDetails > ( ) { public void execute ( InputFileDetails inputFileDetails ) { staleOutputFiles . add ( inputFileDetails . getFile ( ) ) ; } } ) ; if ( cleaner = = null ) { cleaner = new TwirlStaleOutputCleaner ( getOutputDirectory ( ) ) ; } cleaner . execute ( staleOutputFiles ) ; getCompiler ( ) . execute ( spec ) ; } } private Compiler < TwirlCompileSpec > getCompiler ( ) { ToolProvider toolProvider = ( ( PlayToolChainInternal ) getToolChain ( ) ) . select ( platform ) ; return toolProvider . newCompiler ( TwirlCompileSpec . class ) ; } private boolean useJavaDefaults ( ) { return false ; } void setCleaner ( TwirlStaleOutputCleaner cleaner ) { this . cleaner = cleaner ; } public void setPlatform ( PlayPlatform platform ) { this . platform = platform ; } @Incubating @Inject public PlayToolChain getToolChain ( ) { throw new UnsupportedOperationException ( ) ; } @Incubating public void setToolChain ( PlayToolChain toolChain ) { throw new UnsupportedOperationException ( ) ; } private static class TwirlStaleOutputCleaner { private final File destinationDir ; public TwirlStaleOutputCleaner ( File destinationDir ) { this . destinationDir = destinationDir ; } public void execute ( Set < File > staleSources ) { for ( File removedInputFile : staleSources ) { File staleOuputFile = calculateOutputFile ( removedInputFile ) ; staleOuputFile . delete ( ) ; } } File calculateOutputFile ( File inputFile ) { String inputFileName = inputFile . getName ( ) ; String [ ] splits = inputFileName . split ( <str> ) ; String relativeOutputFilePath = String . format ( <str> , splits [ <int> ] , splits [ <int> ] ) ; return new File ( destinationDir , relativeOutputFilePath ) ; } } private static class RelativeFileCollector implements FileVisitor { List < RelativeFile > relativeFiles = Lists . newArrayList ( ) ; @Override public void visitDir ( FileVisitDetails dirDetails ) { } @Override public void visitFile ( FileVisitDetails fileDetails ) { relativeFiles . add ( new RelativeFile ( fileDetails . getFile ( ) , fileDetails . getRelativePath ( ) ) ) ; } } } 
