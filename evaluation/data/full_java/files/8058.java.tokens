package org . elasticsearch . http . netty ; import org . elasticsearch . cache . recycler . MockPageCacheRecycler ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . network . NetworkService ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . MockBigArrays ; import org . elasticsearch . indices . breaker . NoneCircuitBreakerService ; import org . elasticsearch . rest . RestResponse ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . threadpool . ThreadPool ; import org . jboss . netty . buffer . ChannelBuffer ; import org . jboss . netty . buffer . ChannelBuffers ; import org . jboss . netty . channel . Channel ; import org . jboss . netty . channel . ChannelConfig ; import org . jboss . netty . channel . ChannelFactory ; import org . jboss . netty . channel . ChannelFuture ; import org . jboss . netty . channel . ChannelPipeline ; import org . jboss . netty . handler . codec . http . DefaultHttpHeaders ; import org . jboss . netty . handler . codec . http . HttpHeaders ; import org . jboss . netty . handler . codec . http . HttpMethod ; import org . jboss . netty . handler . codec . http . HttpRequest ; import org . jboss . netty . handler . codec . http . HttpResponse ; import org . jboss . netty . handler . codec . http . HttpVersion ; import org . junit . After ; import org . junit . Before ; import java . net . SocketAddress ; import java . util . ArrayList ; import java . util . List ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class NettyHttpChannelTests extends ESTestCase { private NetworkService networkService ; private ThreadPool threadPool ; private MockBigArrays bigArrays ; private NettyHttpServerTransport httpServerTransport ; @Before public void setup ( ) throws Exception { networkService = new NetworkService ( Settings . EMPTY ) ; threadPool = new ThreadPool ( <str> ) ; MockPageCacheRecycler mockPageCacheRecycler = new MockPageCacheRecycler ( Settings . EMPTY , threadPool ) ; bigArrays = new MockBigArrays ( mockPageCacheRecycler , new NoneCircuitBreakerService ( ) ) ; } @After public void shutdown ( ) throws Exception { if ( threadPool ! = null ) { threadPool . shutdownNow ( ) ; } if ( httpServerTransport ! = null ) { httpServerTransport . close ( ) ; } } public void testCorsEnabledWithoutAllowOrigins ( ) { Settings settings = Settings . builder ( ) . put ( NettyHttpServerTransport . SETTING_CORS_ENABLED , true ) . build ( ) ; httpServerTransport = new NettyHttpServerTransport ( settings , networkService , bigArrays ) ; HttpRequest httpRequest = new TestHttpRequest ( ) ; httpRequest . headers ( ) . add ( HttpHeaders . Names . ORIGIN , <str> ) ; httpRequest . headers ( ) . add ( HttpHeaders . Names . USER_AGENT , <str> ) ; WriteCapturingChannel writeCapturingChannel = new WriteCapturingChannel ( ) ; NettyHttpRequest request = new NettyHttpRequest ( httpRequest , writeCapturingChannel ) ; NettyHttpChannel channel = new NettyHttpChannel ( httpServerTransport , request , null , randomBoolean ( ) ) ; channel . sendResponse ( new TestReponse ( ) ) ; List < Object > writtenObjects = writeCapturingChannel . getWrittenObjects ( ) ; assertThat ( writtenObjects . size ( ) , is ( <int> ) ) ; HttpResponse response = ( HttpResponse ) writtenObjects . get ( <int> ) ; assertThat ( response . headers ( ) . get ( HttpHeaders . Names . ACCESS_CONTROL_ALLOW_ORIGIN ) , nullValue ( ) ) ; } public void testCorsEnabledWithAllowOrigins ( ) { Settings settings = Settings . builder ( ) . put ( NettyHttpServerTransport . SETTING_CORS_ENABLED , true ) . put ( NettyHttpServerTransport . SETTING_CORS_ALLOW_ORIGIN , <str> ) . build ( ) ; httpServerTransport = new NettyHttpServerTransport ( settings , networkService , bigArrays ) ; HttpRequest httpRequest = new TestHttpRequest ( ) ; httpRequest . headers ( ) . add ( HttpHeaders . Names . ORIGIN , <str> ) ; httpRequest . headers ( ) . add ( HttpHeaders . Names . USER_AGENT , <str> ) ; WriteCapturingChannel writeCapturingChannel = new WriteCapturingChannel ( ) ; NettyHttpRequest request = new NettyHttpRequest ( httpRequest , writeCapturingChannel ) ; NettyHttpChannel channel = new NettyHttpChannel ( httpServerTransport , request , null , randomBoolean ( ) ) ; channel . sendResponse ( new TestReponse ( ) ) ; List < Object > writtenObjects = writeCapturingChannel . getWrittenObjects ( ) ; assertThat ( writtenObjects . size ( ) , is ( <int> ) ) ; HttpResponse response = ( HttpResponse ) writtenObjects . get ( <int> ) ; assertThat ( response . headers ( ) . get ( HttpHeaders . Names . ACCESS_CONTROL_ALLOW_ORIGIN ) , notNullValue ( ) ) ; String allowedOrigins = response . headers ( ) . get ( HttpHeaders . Names . ACCESS_CONTROL_ALLOW_ORIGIN ) ; assertThat ( allowedOrigins , is ( <str> ) ) ; } private static class WriteCapturingChannel implements Channel { private List < Object > writtenObjects = new ArrayList < > ( ) ; @Override public Integer getId ( ) { return null ; } @Override public ChannelFactory getFactory ( ) { return null ; } @Override public Channel getParent ( ) { return null ; } @Override public ChannelConfig getConfig ( ) { return null ; } @Override public ChannelPipeline getPipeline ( ) { return null ; } @Override public boolean isOpen ( ) { return false ; } @Override public boolean isBound ( ) { return false ; } @Override public boolean isConnected ( ) { return false ; } @Override public SocketAddress getLocalAddress ( ) { return null ; } @Override public SocketAddress getRemoteAddress ( ) { return null ; } @Override public ChannelFuture write ( Object message ) { writtenObjects . add ( message ) ; return null ; } @Override public ChannelFuture write ( Object message , SocketAddress remoteAddress ) { writtenObjects . add ( message ) ; return null ; } @Override public ChannelFuture bind ( SocketAddress localAddress ) { return null ; } @Override public ChannelFuture connect ( SocketAddress remoteAddress ) { return null ; } @Override public ChannelFuture disconnect ( ) { return null ; } @Override public ChannelFuture unbind ( ) { return null ; } @Override public ChannelFuture close ( ) { return null ; } @Override public ChannelFuture getCloseFuture ( ) { return null ; } @Override public int getInterestOps ( ) { return <int> ; } @Override public boolean isReadable ( ) { return false ; } @Override public boolean isWritable ( ) { return false ; } @Override public ChannelFuture setInterestOps ( int interestOps ) { return null ; } @Override public ChannelFuture setReadable ( boolean readable ) { return null ; } @Override public boolean getUserDefinedWritability ( int index ) { return false ; } @Override public void setUserDefinedWritability ( int index , boolean isWritable ) { } @Override public Object getAttachment ( ) { return null ; } @Override public void setAttachment ( Object attachment ) { } @Override public int compareTo ( Channel o ) { return <int> ; } public List < Object > getWrittenObjects ( ) { return writtenObjects ; } } private static class TestHttpRequest implements HttpRequest { private HttpHeaders headers = new DefaultHttpHeaders ( ) ; @Override public HttpMethod getMethod ( ) { return null ; } @Override public void setMethod ( HttpMethod method ) { } @Override public String getUri ( ) { return <str> ; } @Override public void setUri ( String uri ) { } @Override public HttpVersion getProtocolVersion ( ) { return HttpVersion . HTTP_1_1 ; } @Override public void setProtocolVersion ( HttpVersion version ) { } @Override public HttpHeaders headers ( ) { return headers ; } @Override public ChannelBuffer getContent ( ) { return ChannelBuffers . EMPTY_BUFFER ; } @Override public void setContent ( ChannelBuffer content ) { } @Override public boolean isChunked ( ) { return false ; } @Override public void setChunked ( boolean chunked ) { } } private static class TestReponse extends RestResponse { @Override public String contentType ( ) { return <str> ; } @Override public BytesReference content ( ) { return BytesArray . EMPTY ; } @Override public RestStatus status ( ) { return RestStatus . OK ; } } } 
