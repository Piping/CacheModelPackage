package com . badlogic . gdx . utils ; import com . badlogic . gdx . math . MathUtils ; import java . util . NoSuchElementException ; public class IntSet { private static final int PRIME1 = <hex> ; private static final int PRIME2 = <hex> ; private static final int PRIME3 = <hex> ; private static final int EMPTY = <int> ; public int size ; int [ ] keyTable ; int capacity , stashSize ; boolean hasZeroValue ; private float loadFactor ; private int hashShift , mask , threshold ; private int stashCapacity ; private int pushIterations ; private IntSetIterator iterator1 , iterator2 ; public IntSet ( ) { this ( <int> , <float> ) ; } public IntSet ( int initialCapacity ) { this ( initialCapacity , <float> ) ; } public IntSet ( int initialCapacity , float loadFactor ) { if ( initialCapacity < <int> ) throw new IllegalArgumentException ( <str> + initialCapacity ) ; initialCapacity = MathUtils . nextPowerOfTwo ( ( int ) Math . ceil ( initialCapacity / loadFactor ) ) ; if ( initialCapacity > <int> < < <int> ) throw new IllegalArgumentException ( <str> + initialCapacity ) ; capacity = initialCapacity ; if ( loadFactor < = <int> ) throw new IllegalArgumentException ( <str> + loadFactor ) ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity * loadFactor ) ; mask = capacity - <int> ; hashShift = <int> - Integer . numberOfTrailingZeros ( capacity ) ; stashCapacity = Math . max ( <int> , ( int ) Math . ceil ( Math . log ( capacity ) ) * <int> ) ; pushIterations = Math . max ( Math . min ( capacity , <int> ) , ( int ) Math . sqrt ( capacity ) / <int> ) ; keyTable = new int [ capacity + stashCapacity ] ; } public IntSet ( IntSet set ) { this ( set . capacity , set . loadFactor ) ; stashSize = set . stashSize ; System . arraycopy ( set . keyTable , <int> , keyTable , <int> , set . keyTable . length ) ; size = set . size ; hasZeroValue = set . hasZeroValue ; } public boolean add ( int key ) { if ( key = = <int> ) { if ( hasZeroValue ) return false ; hasZeroValue = true ; size + + ; return true ; } int [ ] keyTable = this . keyTable ; int index1 = key & mask ; int key1 = keyTable [ index1 ] ; if ( key1 = = key ) return false ; int index2 = hash2 ( key ) ; int key2 = keyTable [ index2 ] ; if ( key2 = = key ) return false ; int index3 = hash3 ( key ) ; int key3 = keyTable [ index3 ] ; if ( key3 = = key ) return false ; for ( int i = capacity , n = i + stashSize ; i < n ; i + + ) if ( keyTable [ i ] = = key ) return false ; if ( key1 = = EMPTY ) { keyTable [ index1 ] = key ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return true ; } if ( key2 = = EMPTY ) { keyTable [ index2 ] = key ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return true ; } if ( key3 = = EMPTY ) { keyTable [ index3 ] = key ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return true ; } push ( key , index1 , key1 , index2 , key2 , index3 , key3 ) ; return true ; } public void addAll ( IntArray array ) { addAll ( array , <int> , array . size ) ; } public void addAll ( IntArray array , int offset , int length ) { if ( offset + length > array . size ) throw new IllegalArgumentException ( <str> + offset + <str> + length + <str> + array . size ) ; addAll ( array . items , offset , length ) ; } public void addAll ( int . . . array ) { addAll ( array , <int> , array . length ) ; } public void addAll ( int [ ] array , int offset , int length ) { ensureCapacity ( length ) ; for ( int i = offset , n = i + length ; i < n ; i + + ) add ( array [ i ] ) ; } public void addAll ( IntSet set ) { ensureCapacity ( set . size ) ; IntSetIterator iterator = set . iterator ( ) ; while ( iterator . hasNext ) add ( iterator . next ( ) ) ; } private void addResize ( int key ) { if ( key = = <int> ) { hasZeroValue = true ; return ; } int index1 = key & mask ; int key1 = keyTable [ index1 ] ; if ( key1 = = EMPTY ) { keyTable [ index1 ] = key ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return ; } int index2 = hash2 ( key ) ; int key2 = keyTable [ index2 ] ; if ( key2 = = EMPTY ) { keyTable [ index2 ] = key ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return ; } int index3 = hash3 ( key ) ; int key3 = keyTable [ index3 ] ; if ( key3 = = EMPTY ) { keyTable [ index3 ] = key ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return ; } push ( key , index1 , key1 , index2 , key2 , index3 , key3 ) ; } private void push ( int insertKey , int index1 , int key1 , int index2 , int key2 , int index3 , int key3 ) { int [ ] keyTable = this . keyTable ; int mask = this . mask ; int evictedKey ; int i = <int> , pushIterations = this . pushIterations ; do { switch ( MathUtils . random ( <int> ) ) { case <int> : evictedKey = key1 ; keyTable [ index1 ] = insertKey ; break ; case <int> : evictedKey = key2 ; keyTable [ index2 ] = insertKey ; break ; default : evictedKey = key3 ; keyTable [ index3 ] = insertKey ; break ; } index1 = evictedKey & mask ; key1 = keyTable [ index1 ] ; if ( key1 = = EMPTY ) { keyTable [ index1 ] = evictedKey ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return ; } index2 = hash2 ( evictedKey ) ; key2 = keyTable [ index2 ] ; if ( key2 = = EMPTY ) { keyTable [ index2 ] = evictedKey ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return ; } index3 = hash3 ( evictedKey ) ; key3 = keyTable [ index3 ] ; if ( key3 = = EMPTY ) { keyTable [ index3 ] = evictedKey ; if ( size + + > = threshold ) resize ( capacity < < <int> ) ; return ; } if ( + + i = = pushIterations ) break ; insertKey = evictedKey ; } while ( true ) ; addStash ( evictedKey ) ; } private void addStash ( int key ) { if ( stashSize = = stashCapacity ) { resize ( capacity < < <int> ) ; add ( key ) ; return ; } int index = capacity + stashSize ; keyTable [ index ] = key ; stashSize + + ; size + + ; } public boolean remove ( int key ) { if ( key = = <int> ) { if ( ! hasZeroValue ) return false ; hasZeroValue = false ; size - - ; return true ; } int index = key & mask ; if ( keyTable [ index ] = = key ) { keyTable [ index ] = EMPTY ; size - - ; return true ; } index = hash2 ( key ) ; if ( keyTable [ index ] = = key ) { keyTable [ index ] = EMPTY ; size - - ; return true ; } index = hash3 ( key ) ; if ( keyTable [ index ] = = key ) { keyTable [ index ] = EMPTY ; size - - ; return true ; } return removeStash ( key ) ; } boolean removeStash ( int key ) { int [ ] keyTable = this . keyTable ; for ( int i = capacity , n = i + stashSize ; i < n ; i + + ) { if ( keyTable [ i ] = = key ) { removeStashIndex ( i ) ; size - - ; return true ; } } return false ; } void removeStashIndex ( int index ) { stashSize - - ; int lastIndex = capacity + stashSize ; if ( index < lastIndex ) keyTable [ index ] = keyTable [ lastIndex ] ; } public void shrink ( int maximumCapacity ) { if ( maximumCapacity < <int> ) throw new IllegalArgumentException ( <str> + maximumCapacity ) ; if ( size > maximumCapacity ) maximumCapacity = size ; if ( capacity < = maximumCapacity ) return ; maximumCapacity = MathUtils . nextPowerOfTwo ( maximumCapacity ) ; resize ( maximumCapacity ) ; } public void clear ( int maximumCapacity ) { if ( capacity < = maximumCapacity ) { clear ( ) ; return ; } hasZeroValue = false ; size = <int> ; resize ( maximumCapacity ) ; } public void clear ( ) { if ( size = = <int> ) return ; int [ ] keyTable = this . keyTable ; for ( int i = capacity + stashSize ; i - - > <int> ; ) keyTable [ i ] = EMPTY ; size = <int> ; stashSize = <int> ; hasZeroValue = false ; } public boolean contains ( int key ) { if ( key = = <int> ) return hasZeroValue ; int index = key & mask ; if ( keyTable [ index ] ! = key ) { index = hash2 ( key ) ; if ( keyTable [ index ] ! = key ) { index = hash3 ( key ) ; if ( keyTable [ index ] ! = key ) return containsKeyStash ( key ) ; } } return true ; } private boolean containsKeyStash ( int key ) { int [ ] keyTable = this . keyTable ; for ( int i = capacity , n = i + stashSize ; i < n ; i + + ) if ( keyTable [ i ] = = key ) return true ; return false ; } public int first ( ) { if ( hasZeroValue ) return <int> ; int [ ] keyTable = this . keyTable ; for ( int i = <int> , n = capacity + stashSize ; i < n ; i + + ) if ( keyTable [ i ] ! = EMPTY ) return keyTable [ i ] ; throw new IllegalStateException ( <str> ) ; } public void ensureCapacity ( int additionalCapacity ) { int sizeNeeded = size + additionalCapacity ; if ( sizeNeeded > = threshold ) resize ( MathUtils . nextPowerOfTwo ( ( int ) Math . ceil ( sizeNeeded / loadFactor ) ) ) ; } private void resize ( int newSize ) { int oldEndIndex = capacity + stashSize ; capacity = newSize ; threshold = ( int ) ( newSize * loadFactor ) ; mask = newSize - <int> ; hashShift = <int> - Integer . numberOfTrailingZeros ( newSize ) ; stashCapacity = Math . max ( <int> , ( int ) Math . ceil ( Math . log ( newSize ) ) * <int> ) ; pushIterations = Math . max ( Math . min ( newSize , <int> ) , ( int ) Math . sqrt ( newSize ) / <int> ) ; int [ ] oldKeyTable = keyTable ; keyTable = new int [ newSize + stashCapacity ] ; int oldSize = size ; size = hasZeroValue ? <int> : <int> ; stashSize = <int> ; if ( oldSize > <int> ) { for ( int i = <int> ; i < oldEndIndex ; i + + ) { int key = oldKeyTable [ i ] ; if ( key ! = EMPTY ) addResize ( key ) ; } } } private int hash2 ( int h ) { h * = PRIME2 ; return ( h ^ h > > > hashShift ) & mask ; } private int hash3 ( int h ) { h * = PRIME3 ; return ( h ^ h > > > hashShift ) & mask ; } public int hashCode ( ) { int h = <int> ; for ( int i = <int> , n = capacity + stashSize ; i < n ; i + + ) if ( keyTable [ i ] ! = EMPTY ) h + = keyTable [ i ] ; return h ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof IntSet ) ) return false ; IntSet other = ( IntSet ) obj ; if ( other . size ! = size ) return false ; if ( other . hasZeroValue ! = hasZeroValue ) return false ; for ( int i = <int> , n = capacity + stashSize ; i < n ; i + + ) if ( keyTable [ i ] ! = EMPTY & & ! other . contains ( keyTable [ i ] ) ) return false ; return true ; } public String toString ( ) { if ( size = = <int> ) return <str> ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( <str> ) ; int [ ] keyTable = this . keyTable ; int i = keyTable . length ; if ( hasZeroValue ) buffer . append ( <str> ) ; else { while ( i - - > <int> ) { int key = keyTable [ i ] ; if ( key = = EMPTY ) continue ; buffer . append ( key ) ; break ; } } while ( i - - > <int> ) { int key = keyTable [ i ] ; if ( key = = EMPTY ) continue ; buffer . append ( <str> ) ; buffer . append ( key ) ; } buffer . append ( <str> ) ; return buffer . toString ( ) ; } public IntSetIterator iterator ( ) { if ( iterator1 = = null ) { iterator1 = new IntSetIterator ( this ) ; iterator2 = new IntSetIterator ( this ) ; } if ( ! iterator1 . valid ) { iterator1 . reset ( ) ; iterator1 . valid = true ; iterator2 . valid = false ; return iterator1 ; } iterator2 . reset ( ) ; iterator2 . valid = true ; iterator1 . valid = false ; return iterator2 ; } static public IntSet with ( int . . . array ) { IntSet set = new IntSet ( ) ; set . addAll ( array ) ; return set ; } static public class IntSetIterator { static final int INDEX_ILLEGAL = - <int> ; static final int INDEX_ZERO = - <int> ; public boolean hasNext ; final IntSet set ; int nextIndex , currentIndex ; boolean valid = true ; public IntSetIterator ( IntSet set ) { this . set = set ; reset ( ) ; } public void reset ( ) { currentIndex = INDEX_ILLEGAL ; nextIndex = INDEX_ZERO ; if ( set . hasZeroValue ) hasNext = true ; else findNextIndex ( ) ; } void findNextIndex ( ) { hasNext = false ; int [ ] keyTable = set . keyTable ; for ( int n = set . capacity + set . stashSize ; + + nextIndex < n ; ) { if ( keyTable [ nextIndex ] ! = EMPTY ) { hasNext = true ; break ; } } } public void remove ( ) { if ( currentIndex = = INDEX_ZERO & & set . hasZeroValue ) { set . hasZeroValue = false ; } else if ( currentIndex < <int> ) { throw new IllegalStateException ( <str> ) ; } else if ( currentIndex > = set . capacity ) { set . removeStashIndex ( currentIndex ) ; nextIndex = currentIndex - <int> ; findNextIndex ( ) ; } else { set . keyTable [ currentIndex ] = EMPTY ; } currentIndex = INDEX_ILLEGAL ; set . size - - ; } public int next ( ) { if ( ! hasNext ) throw new NoSuchElementException ( ) ; if ( ! valid ) throw new GdxRuntimeException ( <str> ) ; int key = nextIndex = = INDEX_ZERO ? <int> : set . keyTable [ nextIndex ] ; currentIndex = nextIndex ; findNextIndex ( ) ; return key ; } public IntArray toArray ( ) { IntArray array = new IntArray ( true , set . size ) ; while ( hasNext ) array . add ( next ( ) ) ; return array ; } } } 
