package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . g2d . BitmapFont ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . maps . MapLayer ; import com . badlogic . gdx . maps . MapObject ; import com . badlogic . gdx . maps . MapProperties ; import com . badlogic . gdx . maps . objects . EllipseMapObject ; import com . badlogic . gdx . maps . objects . PolygonMapObject ; import com . badlogic . gdx . maps . objects . RectangleMapObject ; import com . badlogic . gdx . maps . objects . TextureMapObject ; import com . badlogic . gdx . maps . tiled . TiledMap ; import com . badlogic . gdx . maps . tiled . TmxMapLoader ; import com . badlogic . gdx . maps . tiled . objects . TiledMapTileMapObject ; import com . badlogic . gdx . maps . tiled . tiles . AnimatedTiledMapTile ; import com . badlogic . gdx . math . Ellipse ; import com . badlogic . gdx . math . Polygon ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . tests . utils . OrthoCamController ; public class TiledMapObjectLoadingTest extends GdxTest { private TiledMap map ; private ShapeRenderer shapeRenderer ; private OrthographicCamera camera ; private OrthoCamController cameraController ; private BitmapFont font ; private SpriteBatch batch ; @Override public void create ( ) { float w = Gdx . graphics . getWidth ( ) ; float h = Gdx . graphics . getHeight ( ) ; camera = new OrthographicCamera ( ) ; camera . setToOrtho ( false , ( w / h ) * <int> , <int> ) ; camera . zoom = <int> ; camera . update ( ) ; cameraController = new OrthoCamController ( camera ) ; Gdx . input . setInputProcessor ( cameraController ) ; font = new BitmapFont ( ) ; batch = new SpriteBatch ( ) ; map = new TmxMapLoader ( ) . load ( <str> ) ; MapProperties properties = map . getProperties ( ) ; shapeRenderer = new ShapeRenderer ( ) ; } @Override public void render ( ) { Gdx . gl . glClearColor ( <float> , <float> , <float> , <float> ) ; Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; camera . update ( ) ; shapeRenderer . setProjectionMatrix ( camera . combined ) ; batch . setProjectionMatrix ( camera . combined ) ; shapeRenderer . setColor ( Color . BLUE ) ; Gdx . gl20 . glLineWidth ( <int> ) ; MapLayer layer = map . getLayers ( ) . get ( <str> ) ; AnimatedTiledMapTile . updateAnimationBaseTime ( ) ; for ( MapObject mapObject : layer . getObjects ( ) ) { if ( mapObject instanceof TiledMapTileMapObject ) { batch . begin ( ) ; TiledMapTileMapObject tmtObject = ( TiledMapTileMapObject ) mapObject ; TextureRegion textureRegion = tmtObject . getTile ( ) . getTextureRegion ( ) ; float rotation = - tmtObject . getRotation ( ) ; float scaleX = tmtObject . getScaleX ( ) ; float scaleY = tmtObject . getScaleY ( ) ; float xPos = tmtObject . getX ( ) ; float yPos = tmtObject . getY ( ) ; textureRegion . flip ( tmtObject . isFlipHorizontally ( ) , tmtObject . isFlipVertically ( ) ) ; batch . draw ( textureRegion , xPos , yPos , tmtObject . getOriginX ( ) * scaleX , tmtObject . getOriginY ( ) * scaleY , textureRegion . getRegionWidth ( ) * scaleX , textureRegion . getRegionHeight ( ) * scaleY , <float> , <float> , rotation ) ; textureRegion . flip ( tmtObject . isFlipHorizontally ( ) , tmtObject . isFlipVertically ( ) ) ; batch . end ( ) ; } else if ( mapObject instanceof EllipseMapObject ) { shapeRenderer . begin ( ShapeRenderer . ShapeType . Filled ) ; Ellipse ellipse = ( ( EllipseMapObject ) mapObject ) . getEllipse ( ) ; shapeRenderer . ellipse ( ellipse . x , ellipse . y , ellipse . width , ellipse . height ) ; shapeRenderer . end ( ) ; } else if ( mapObject instanceof RectangleMapObject ) { shapeRenderer . begin ( ShapeRenderer . ShapeType . Filled ) ; Rectangle rectangle = ( ( RectangleMapObject ) mapObject ) . getRectangle ( ) ; shapeRenderer . rect ( rectangle . x , rectangle . y , rectangle . width , rectangle . height ) ; shapeRenderer . end ( ) ; } else if ( mapObject instanceof PolygonMapObject ) { shapeRenderer . begin ( ShapeRenderer . ShapeType . Line ) ; Polygon polygon = ( ( PolygonMapObject ) mapObject ) . getPolygon ( ) ; shapeRenderer . polygon ( polygon . getTransformedVertices ( ) ) ; shapeRenderer . end ( ) ; } } batch . begin ( ) ; font . draw ( batch , <str> + Gdx . graphics . getFramesPerSecond ( ) , <int> , <int> ) ; batch . end ( ) ; } @Override public void dispose ( ) { map . dispose ( ) ; shapeRenderer . dispose ( ) ; } } 
