package com . badlogic . gdx . setup ; import static java . awt . GridBagConstraints . BOTH ; import static java . awt . GridBagConstraints . CENTER ; import static java . awt . GridBagConstraints . HORIZONTAL ; import static java . awt . GridBagConstraints . NONE ; import static java . awt . GridBagConstraints . NORTH ; import static java . awt . GridBagConstraints . SOUTH ; import static java . awt . GridBagConstraints . SOUTHEAST ; import java . awt . Color ; import java . awt . Desktop ; import java . awt . GridBagConstraints ; import java . awt . GridBagLayout ; import java . awt . Insets ; import java . awt . event . ActionEvent ; import java . awt . event . ActionListener ; import java . awt . event . MouseAdapter ; import java . awt . event . MouseEvent ; import java . io . IOException ; import java . net . URI ; import java . net . URISyntaxException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import javax . swing . BorderFactory ; import javax . swing . JDialog ; import javax . swing . JLabel ; import javax . swing . JPanel ; import javax . swing . JScrollPane ; import javax . swing . JSeparator ; import javax . swing . JTable ; import javax . swing . event . TableModelEvent ; import javax . swing . event . TableModelListener ; import javax . swing . table . DefaultTableModel ; import javax . xml . parsers . DocumentBuilder ; import javax . xml . parsers . DocumentBuilderFactory ; import javax . xml . parsers . ParserConfigurationException ; import org . w3c . dom . Document ; import org . w3c . dom . Element ; import org . w3c . dom . Node ; import org . w3c . dom . NodeList ; import org . xml . sax . SAXException ; import com . badlogic . gdx . setup . GdxSetupUI . SetupButton ; public class ExternalExtensionsDialog extends JDialog implements TableModelListener { private JPanel contentPane ; private SetupButton buttonOK ; private SetupButton buttonCancel ; private JPanel topPanel ; private ExtensionTableModel tableModel ; JTable table ; private JPanel bottomPanel ; private JPanel buttonPanel ; private JScrollPane scrollPane ; private JLabel warningNotice ; private JLabel warningNotice2 ; private List < Dependency > mainDependenciesSnapshot = new ArrayList < Dependency > ( ) ; List < Dependency > mainDependencies ; public ExternalExtensionsDialog ( List < Dependency > mainDependencies ) { this . mainDependencies = mainDependencies ; contentPane = new JPanel ( new GridBagLayout ( ) ) ; setContentPane ( contentPane ) ; setModal ( true ) ; getRootPane ( ) . setDefaultButton ( buttonOK ) ; uiLayout ( ) ; uiStyle ( ) ; buttonOK . addActionListener ( new ActionListener ( ) { public void actionPerformed ( ActionEvent e ) { onOK ( ) ; } } ) ; buttonCancel . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent e ) { onCancel ( ) ; } } ) ; setTitle ( <str> ) ; setSize ( <int> , <int> ) ; setLocationRelativeTo ( null ) ; } public void showDialog ( ) { takeSnapshot ( ) ; setVisible ( true ) ; } private void uiLayout ( ) { topPanel = new JPanel ( new GridBagLayout ( ) ) ; topPanel . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; warningNotice = new JLabel ( <str> ) ; warningNotice2 = new JLabel ( <str> ) ; warningNotice . setHorizontalAlignment ( JLabel . CENTER ) ; warningNotice2 . setHorizontalAlignment ( JLabel . CENTER ) ; topPanel . add ( warningNotice , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , NORTH , HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; topPanel . add ( warningNotice2 , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , NORTH , HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; JSeparator separator = new JSeparator ( ) ; separator . setForeground ( new Color ( <int> , <int> , <int> ) ) ; separator . setBackground ( new Color ( <int> , <int> , <int> ) ) ; topPanel . add ( separator , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , NORTH , HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; tableModel = new ExtensionTableModel ( ) ; table = new JTable ( tableModel ) { @Override public String getToolTipText ( MouseEvent e ) { return ( ( ExtensionTableModel ) getModel ( ) ) . getToolTip ( e ) ; } } ; table . getColumnModel ( ) . getColumn ( <int> ) . setPreferredWidth ( <int> ) ; table . getColumnModel ( ) . getColumn ( <int> ) . setPreferredWidth ( <int> ) ; table . getColumnModel ( ) . getColumn ( <int> ) . setPreferredWidth ( <int> ) ; table . getColumnModel ( ) . getColumn ( <int> ) . setPreferredWidth ( <int> ) ; table . getColumnModel ( ) . getColumn ( <int> ) . setPreferredWidth ( <int> ) ; table . setAutoResizeMode ( JTable . AUTO_RESIZE_LAST_COLUMN ) ; table . getTableHeader ( ) . setReorderingAllowed ( false ) ; table . getModel ( ) . addTableModelListener ( this ) ; table . addMouseListener ( new MouseAdapter ( ) { public void mouseClicked ( MouseEvent e ) { int row = table . getSelectedRow ( ) ; int column = table . getSelectedColumn ( ) ; if ( column = = <int> ) { URI uri = ( ( ExtensionTableModel ) table . getModel ( ) ) . getURI ( row , column ) ; if ( uri ! = null ) { try { Desktop . getDesktop ( ) . browse ( uri ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } } } ) ; scrollPane = new JScrollPane ( table ) ; bottomPanel = new JPanel ( new GridBagLayout ( ) ) ; buttonPanel = new JPanel ( new GridBagLayout ( ) ) ; buttonPanel . setBorder ( BorderFactory . createEmptyBorder ( <int> , <int> , <int> , <int> ) ) ; buttonOK = new SetupButton ( <str> ) ; buttonCancel = new SetupButton ( <str> ) ; buttonPanel . add ( buttonOK , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , CENTER , HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; buttonPanel . add ( buttonCancel , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , CENTER , HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; bottomPanel . add ( buttonPanel , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , SOUTHEAST , NONE , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; contentPane . add ( topPanel , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <float> , NORTH , BOTH , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; contentPane . add ( scrollPane , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , NORTH , BOTH , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; contentPane . add ( bottomPanel , new GridBagConstraints ( <int> , <int> , <int> , <int> , <int> , <int> , SOUTH , HORIZONTAL , new Insets ( <int> , <int> , <int> , <int> ) , <int> , <int> ) ) ; try { initData ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } private void initData ( ) throws ParserConfigurationException , IOException , SAXException { DocumentBuilderFactory dbFactory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = dbFactory . newDocumentBuilder ( ) ; Document doc = builder . parse ( ExternalExtensionsDialog . class . getResourceAsStream ( <str> ) ) ; doc . getDocumentElement ( ) . normalize ( ) ; NodeList nList = doc . getElementsByTagName ( <str> ) ; for ( int i = <int> ; i < nList . getLength ( ) ; i + + ) { Node nNode = nList . item ( i ) ; if ( nNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element eElement = ( Element ) nNode ; String name = eElement . getElementsByTagName ( <str> ) . item ( <int> ) . getTextContent ( ) ; String description = eElement . getElementsByTagName ( <str> ) . item ( <int> ) . getTextContent ( ) ; String version = eElement . getElementsByTagName ( <str> ) . item ( <int> ) . getTextContent ( ) ; String compatibility = eElement . getElementsByTagName ( <str> ) . item ( <int> ) . getTextContent ( ) ; String url = eElement . getElementsByTagName ( <str> ) . item ( <int> ) . getTextContent ( ) ; String [ ] gwtInherits = null ; NodeList inheritsNode = eElement . getElementsByTagName ( <str> ) ; gwtInherits = new String [ inheritsNode . getLength ( ) ] ; for ( int j = <int> ; j < inheritsNode . getLength ( ) ; j + + ) gwtInherits [ j ] = inheritsNode . item ( j ) . getTextContent ( ) ; final HashMap < String , List < String > > dependencies = new HashMap < String , List < String > > ( ) ; addToDependencyMapFromXML ( dependencies , eElement , <str> ) ; addToDependencyMapFromXML ( dependencies , eElement , <str> ) ; addToDependencyMapFromXML ( dependencies , eElement , <str> ) ; addToDependencyMapFromXML ( dependencies , eElement , <str> ) ; addToDependencyMapFromXML ( dependencies , eElement , <str> ) ; URI uri = null ; try { uri = new URI ( url ) ; } catch ( URISyntaxException e ) { e . printStackTrace ( ) ; } if ( uri ! = null ) { final ExternalExtension extension = new ExternalExtension ( name , gwtInherits , description , version ) ; extension . setDependencies ( dependencies ) ; tableModel . addExtension ( extension , false , name , description , version , compatibility , uri ) ; } } } } private void uiStyle ( ) { contentPane . setBackground ( new Color ( <int> , <int> , <int> ) ) ; topPanel . setBackground ( new Color ( <int> , <int> , <int> ) ) ; topPanel . setForeground ( new Color ( <int> , <int> , <int> ) ) ; table . setBackground ( new Color ( <int> , <int> , <int> ) ) ; table . setForeground ( new Color ( <int> , <int> , <int> ) ) ; bottomPanel . setBackground ( new Color ( <int> , <int> , <int> ) ) ; bottomPanel . setForeground ( new Color ( <int> , <int> , <int> ) ) ; buttonPanel . setBackground ( new Color ( <int> , <int> , <int> ) ) ; buttonPanel . setForeground ( new Color ( <int> , <int> , <int> ) ) ; scrollPane . setBorder ( BorderFactory . createEmptyBorder ( ) ) ; scrollPane . setBackground ( new Color ( <int> , <int> , <int> ) ) ; scrollPane . getViewport ( ) . setBackground ( new Color ( <int> , <int> , <int> ) ) ; warningNotice . setForeground ( new Color ( <int> , <int> , <int> ) ) ; warningNotice2 . setForeground ( new Color ( <int> , <int> , <int> ) ) ; } void onOK ( ) { setVisible ( false ) ; } void onCancel ( ) { setVisible ( false ) ; restore ( ) ; } private void takeSnapshot ( ) { mainDependenciesSnapshot . clear ( ) ; for ( int i = <int> ; i < mainDependencies . size ( ) ; i + + ) { mainDependenciesSnapshot . add ( mainDependencies . get ( i ) ) ; } } private void restore ( ) { mainDependencies . clear ( ) ; ( ( ExtensionTableModel ) table . getModel ( ) ) . unselectAll ( ) ; for ( int i = <int> ; i < mainDependenciesSnapshot . size ( ) ; i + + ) { mainDependencies . add ( mainDependenciesSnapshot . get ( i ) ) ; String extensionName = mainDependenciesSnapshot . get ( i ) . getName ( ) ; if ( ( ( ExtensionTableModel ) table . getModel ( ) ) . hasExtension ( extensionName ) ) { ( ( ExtensionTableModel ) table . getModel ( ) ) . setSelected ( extensionName , true ) ; } else { } } } private void addToDependencyMapFromXML ( Map < String , List < String > > dependencies , Element eElement , String platform ) { if ( eElement . getElementsByTagName ( platform ) . item ( <int> ) ! = null ) { Element project = ( Element ) eElement . getElementsByTagName ( platform ) . item ( <int> ) ; ArrayList < String > deps = new ArrayList < String > ( ) ; if ( project . getTextContent ( ) . trim ( ) . equals ( <str> ) ) { } else if ( project . getTextContent ( ) . trim ( ) . equals ( <str> ) ) { deps = null ; } else { NodeList nList = project . getElementsByTagName ( <str> ) ; for ( int i = <int> ; i < nList . getLength ( ) ; i + + ) { Node nNode = nList . item ( i ) ; if ( nNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element dependencyNode = ( Element ) nNode ; deps . add ( dependencyNode . getTextContent ( ) ) ; } } } dependencies . put ( platform , deps ) ; } } class ExtensionTableModel extends DefaultTableModel { private HashMap < Integer , ExternalExtension > extensions = new HashMap < Integer , ExternalExtension > ( ) ; private int rowCount = <int> ; public ExtensionTableModel ( ) { addColumn ( <str> ) ; addColumn ( <str> ) ; addColumn ( <str> ) ; addColumn ( <str> ) ; addColumn ( <str> ) ; addColumn ( <str> ) ; } public ExternalExtension getExtension ( int row ) { return extensions . get ( row ) ; } public URI getURI ( int row , int column ) { if ( column ! = <int> ) return null ; return ( URI ) getValueAt ( row , column ) ; } @Override public Class getColumnClass ( int column ) { if ( column = = <int> ) return Boolean . class ; if ( column = = <int> ) return URI . class ; return super . getColumnClass ( column ) ; } @Override public boolean isCellEditable ( int x , int y ) { return y = = <int> ; } public String getToolTip ( MouseEvent e ) { int row = table . rowAtPoint ( e . getPoint ( ) ) ; int column = table . columnAtPoint ( e . getPoint ( ) ) ; if ( column = = <int> ) { return <str> ; } else if ( column ! = <int> ) { return getValueAt ( row , column ) . toString ( ) ; } else { return <str> ; } } public void unselectAll ( ) { for ( int row : extensions . keySet ( ) ) { table . setValueAt ( false , row , <int> ) ; } } public boolean hasExtension ( String extensionName ) { for ( ExternalExtension extension : extensions . values ( ) ) { if ( extension . getName ( ) . equals ( extensionName ) ) return true ; } return false ; } public void setSelected ( String extensionName , boolean selected ) { int row = - <int> ; for ( int i : extensions . keySet ( ) ) { if ( extensions . get ( i ) . getName ( ) . equals ( extensionName ) ) { row = i ; break ; } } if ( row ! = - <int> ) table . setValueAt ( selected , row , <int> ) ; } public void addExtension ( ExternalExtension extension , Boolean checkbox , String name , String description , String version , String compatibility , URI support ) { addRow ( new Object [ ] { checkbox , name , description , version , compatibility , support } ) ; extensions . put ( rowCount + + , extension ) ; } } @Override public void tableChanged ( TableModelEvent e ) { int row = e . getFirstRow ( ) ; int column = e . getColumn ( ) ; if ( column = = <int> ) { ExternalExtension extension = ( ( ExtensionTableModel ) table . getModel ( ) ) . getExtension ( row ) ; Dependency dep = extension . generateDependency ( ) ; boolean selected = ( Boolean ) table . getModel ( ) . getValueAt ( row , <int> ) ; if ( selected ) { if ( ! mainDependencies . contains ( dep ) ) { mainDependencies . add ( dep ) ; } } else { mainDependencies . remove ( dep ) ; } } } } 
