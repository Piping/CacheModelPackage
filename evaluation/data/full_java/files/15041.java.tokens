package org . gradle . nativeplatform . toolchain . internal . gcc ; import com . google . common . collect . Maps ; import org . gradle . api . Action ; import org . gradle . api . internal . file . FileResolver ; import org . gradle . internal . Actions ; import org . gradle . internal . operations . BuildOperationProcessor ; import org . gradle . internal . os . OperatingSystem ; import org . gradle . internal . reflect . Instantiator ; import org . gradle . nativeplatform . platform . NativePlatform ; import org . gradle . nativeplatform . platform . internal . NativePlatformInternal ; import org . gradle . nativeplatform . toolchain . GccCompatibleToolChain ; import org . gradle . nativeplatform . toolchain . GccPlatformToolChain ; import org . gradle . nativeplatform . toolchain . NativePlatformToolChain ; import org . gradle . nativeplatform . toolchain . internal . ExtendableToolChain ; import org . gradle . nativeplatform . toolchain . internal . PlatformToolProvider ; import org . gradle . nativeplatform . toolchain . internal . ToolType ; import org . gradle . nativeplatform . toolchain . internal . UnavailablePlatformToolProvider ; import org . gradle . nativeplatform . toolchain . internal . gcc . version . CompilerMetaDataProvider ; import org . gradle . nativeplatform . toolchain . internal . gcc . version . GccVersionResult ; import org . gradle . nativeplatform . toolchain . internal . tools . CommandLineToolSearchResult ; import org . gradle . nativeplatform . toolchain . internal . tools . DefaultGccCommandLineToolConfiguration ; import org . gradle . nativeplatform . toolchain . internal . tools . GccCommandLineToolConfigurationInternal ; import org . gradle . nativeplatform . toolchain . internal . tools . ToolSearchPath ; import org . gradle . platform . base . internal . toolchain . ToolChainAvailability ; import org . gradle . process . internal . ExecActionFactory ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . io . File ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . Map ; import static java . util . Arrays . asList ; public abstract class AbstractGccCompatibleToolChain extends ExtendableToolChain < GccPlatformToolChain > implements GccCompatibleToolChain { private static final Logger LOGGER = LoggerFactory . getLogger ( AbstractGccCompatibleToolChain . class ) ; private final ExecActionFactory execActionFactory ; private final ToolSearchPath toolSearchPath ; private final List < TargetPlatformConfiguration > platformConfigs = new ArrayList < TargetPlatformConfiguration > ( ) ; private final Map < NativePlatform , PlatformToolProvider > toolProviders = Maps . newHashMap ( ) ; private final CompilerMetaDataProvider metaDataProvider ; private final Instantiator instantiator ; private int configInsertLocation ; public AbstractGccCompatibleToolChain ( String name , BuildOperationProcessor buildOperationProcessor , OperatingSystem operatingSystem , FileResolver fileResolver , ExecActionFactory execActionFactory , CompilerMetaDataProvider metaDataProvider , Instantiator instantiator ) { this ( name , buildOperationProcessor , operatingSystem , fileResolver , execActionFactory , new ToolSearchPath ( operatingSystem ) , metaDataProvider , instantiator ) ; } AbstractGccCompatibleToolChain ( String name , BuildOperationProcessor buildOperationProcessor , OperatingSystem operatingSystem , FileResolver fileResolver , ExecActionFactory execActionFactory , ToolSearchPath tools , CompilerMetaDataProvider metaDataProvider , Instantiator instantiator ) { super ( name , buildOperationProcessor , operatingSystem , fileResolver ) ; this . execActionFactory = execActionFactory ; this . toolSearchPath = tools ; this . metaDataProvider = metaDataProvider ; this . instantiator = instantiator ; target ( new Intel32Architecture ( ) ) ; target ( new Intel64Architecture ( ) ) ; configInsertLocation = <int> ; } protected CommandLineToolSearchResult locate ( GccCommandLineToolConfigurationInternal gccTool ) { return toolSearchPath . locate ( gccTool . getToolType ( ) , gccTool . getExecutable ( ) ) ; } public List < File > getPath ( ) { return toolSearchPath . getPath ( ) ; } public void path ( Object . . . pathEntries ) { for ( Object path : pathEntries ) { toolSearchPath . path ( resolve ( path ) ) ; } } protected CompilerMetaDataProvider getMetaDataProvider ( ) { return metaDataProvider ; } public void target ( String platformName ) { target ( platformName , Actions . < NativePlatformToolChain > doNothing ( ) ) ; } public void target ( String platformName , Action < ? super GccPlatformToolChain > action ) { target ( new DefaultTargetPlatformConfiguration ( asList ( platformName ) , action ) ) ; } public void target ( List < String > platformNames , Action < ? super GccPlatformToolChain > action ) { target ( new DefaultTargetPlatformConfiguration ( platformNames , action ) ) ; } private void target ( TargetPlatformConfiguration targetPlatformConfiguration ) { platformConfigs . add ( configInsertLocation , targetPlatformConfiguration ) ; configInsertLocation + + ; } public PlatformToolProvider select ( NativePlatformInternal targetPlatform ) { PlatformToolProvider toolProvider = toolProviders . get ( targetPlatform ) ; if ( toolProvider = = null ) { toolProvider = createPlatformToolProvider ( targetPlatform ) ; toolProviders . put ( targetPlatform , toolProvider ) ; } return toolProvider ; } private PlatformToolProvider createPlatformToolProvider ( NativePlatformInternal targetPlatform ) { TargetPlatformConfiguration targetPlatformConfigurationConfiguration = getPlatformConfiguration ( targetPlatform ) ; ToolChainAvailability result = new ToolChainAvailability ( ) ; if ( targetPlatformConfigurationConfiguration = = null ) { result . unavailable ( String . format ( <str> , targetPlatform . getName ( ) ) ) ; return new UnavailablePlatformToolProvider ( targetPlatform . getOperatingSystem ( ) , result ) ; } DefaultGccPlatformToolChain configurableToolChain = instantiator . newInstance ( DefaultGccPlatformToolChain . class , targetPlatform ) ; addDefaultTools ( configurableToolChain ) ; configureDefaultTools ( configurableToolChain ) ; targetPlatformConfigurationConfiguration . apply ( configurableToolChain ) ; configureActions . execute ( configurableToolChain ) ; initTools ( configurableToolChain , result ) ; if ( ! result . isAvailable ( ) ) { return new UnavailablePlatformToolProvider ( targetPlatform . getOperatingSystem ( ) , result ) ; } return new GccPlatformToolProvider ( buildOperationProcessor , targetPlatform . getOperatingSystem ( ) , toolSearchPath , configurableToolChain , execActionFactory , configurableToolChain . isCanUseCommandFile ( ) ) ; } protected void initTools ( DefaultGccPlatformToolChain platformToolChain , ToolChainAvailability availability ) { boolean found = false ; for ( GccCommandLineToolConfigurationInternal tool : platformToolChain . getCompilers ( ) ) { CommandLineToolSearchResult compiler = locate ( tool ) ; if ( compiler . isAvailable ( ) ) { GccVersionResult versionResult = getMetaDataProvider ( ) . getGccMetaData ( compiler . getTool ( ) , platformToolChain . getCompilerProbeArgs ( ) ) ; availability . mustBeAvailable ( versionResult ) ; if ( ! versionResult . isAvailable ( ) ) { return ; } LOGGER . debug ( <str> , ToolType . C_COMPILER . getToolName ( ) , versionResult ) ; found = true ; initForImplementation ( platformToolChain , versionResult ) ; break ; } } for ( GccCommandLineToolConfigurationInternal tool : platformToolChain . getTools ( ) ) { found | = toolSearchPath . locate ( tool . getToolType ( ) , tool . getExecutable ( ) ) . isAvailable ( ) ; } if ( ! found ) { GccCommandLineToolConfigurationInternal cCompiler = platformToolChain . getcCompiler ( ) ; availability . mustBeAvailable ( locate ( cCompiler ) ) ; } } protected void initForImplementation ( DefaultGccPlatformToolChain platformToolChain , GccVersionResult versionResult ) { } private void addDefaultTools ( DefaultGccPlatformToolChain toolChain ) { toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class , ToolType . C_COMPILER , <str> ) ) ; toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class , ToolType . CPP_COMPILER , <str> ) ) ; toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class , ToolType . LINKER , <str> ) ) ; toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class , ToolType . STATIC_LIB_ARCHIVER , <str> ) ) ; toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class , ToolType . OBJECTIVECPP_COMPILER , <str> ) ) ; toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class , ToolType . OBJECTIVEC_COMPILER , <str> ) ) ; toolChain . add ( instantiator . newInstance ( DefaultGccCommandLineToolConfiguration . class , ToolType . ASSEMBLER , <str> ) ) ; } protected void configureDefaultTools ( DefaultGccPlatformToolChain toolChain ) { } protected TargetPlatformConfiguration getPlatformConfiguration ( NativePlatformInternal targetPlatform ) { for ( TargetPlatformConfiguration platformConfig : platformConfigs ) { if ( platformConfig . supportsPlatform ( targetPlatform ) ) { return platformConfig ; } } return null ; } private class Intel32Architecture implements TargetPlatformConfiguration { public boolean supportsPlatform ( NativePlatformInternal targetPlatform ) { return targetPlatform . getOperatingSystem ( ) . isCurrent ( ) & & targetPlatform . getArchitecture ( ) . isI386 ( ) ; } public void apply ( DefaultGccPlatformToolChain gccToolChain ) { gccToolChain . compilerProbeArgs ( <str> ) ; Action < List < String > > m32args = new Action < List < String > > ( ) { public void execute ( List < String > args ) { args . add ( <str> ) ; } } ; gccToolChain . getCppCompiler ( ) . withArguments ( m32args ) ; gccToolChain . getcCompiler ( ) . withArguments ( m32args ) ; gccToolChain . getObjcCompiler ( ) . withArguments ( m32args ) ; gccToolChain . getObjcppCompiler ( ) . withArguments ( m32args ) ; gccToolChain . getLinker ( ) . withArguments ( m32args ) ; gccToolChain . getAssembler ( ) . withArguments ( m32args ) ; } } private class Intel64Architecture implements TargetPlatformConfiguration { public boolean supportsPlatform ( NativePlatformInternal targetPlatform ) { return targetPlatform . getOperatingSystem ( ) . isCurrent ( ) & & targetPlatform . getArchitecture ( ) . isAmd64 ( ) ; } public void apply ( DefaultGccPlatformToolChain gccToolChain ) { gccToolChain . compilerProbeArgs ( <str> ) ; Action < List < String > > m64args = new Action < List < String > > ( ) { public void execute ( List < String > args ) { args . add ( <str> ) ; } } ; gccToolChain . getCppCompiler ( ) . withArguments ( m64args ) ; gccToolChain . getcCompiler ( ) . withArguments ( m64args ) ; gccToolChain . getObjcCompiler ( ) . withArguments ( m64args ) ; gccToolChain . getObjcppCompiler ( ) . withArguments ( m64args ) ; gccToolChain . getLinker ( ) . withArguments ( m64args ) ; gccToolChain . getAssembler ( ) . withArguments ( m64args ) ; } } private static class DefaultTargetPlatformConfiguration implements TargetPlatformConfiguration { private final Collection < String > platformNames ; private Action < ? super GccPlatformToolChain > configurationAction ; public DefaultTargetPlatformConfiguration ( Collection < String > targetPlatformNames , Action < ? super GccPlatformToolChain > configurationAction ) { this . platformNames = targetPlatformNames ; this . configurationAction = configurationAction ; } public boolean supportsPlatform ( NativePlatformInternal targetPlatform ) { return platformNames . contains ( targetPlatform . getName ( ) ) ; } public void apply ( DefaultGccPlatformToolChain platformToolChain ) { configurationAction . execute ( platformToolChain ) ; } } } 
