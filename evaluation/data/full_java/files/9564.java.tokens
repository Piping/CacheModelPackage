package com . google . common . util . concurrent ; import com . google . common . annotations . Beta ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . MoreObjects ; import com . google . common . base . Preconditions ; import com . google . common . base . Supplier ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterables ; import com . google . common . collect . MapMaker ; import com . google . common . math . IntMath ; import com . google . common . primitives . Ints ; import java . lang . ref . Reference ; import java . lang . ref . ReferenceQueue ; import java . lang . ref . WeakReference ; import java . math . RoundingMode ; import java . util . Arrays ; import java . util . Collections ; import java . util . List ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . Semaphore ; import java . util . concurrent . atomic . AtomicReferenceArray ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReadWriteLock ; import java . util . concurrent . locks . ReentrantLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; @Beta public abstract class Striped < L > { private static final int LARGE_LAZY_CUTOFF = <int> ; private Striped ( ) { } public abstract L get ( Object key ) ; public abstract L getAt ( int index ) ; abstract int indexFor ( Object key ) ; public abstract int size ( ) ; public Iterable < L > bulkGet ( Iterable < ? > keys ) { final Object [ ] array = Iterables . toArray ( keys , Object . class ) ; if ( array . length = = <int> ) { return ImmutableList . of ( ) ; } int [ ] stripes = new int [ array . length ] ; for ( int i = <int> ; i < array . length ; i + + ) { stripes [ i ] = indexFor ( array [ i ] ) ; } Arrays . sort ( stripes ) ; int previousStripe = stripes [ <int> ] ; array [ <int> ] = getAt ( previousStripe ) ; for ( int i = <int> ; i < array . length ; i + + ) { int currentStripe = stripes [ i ] ; if ( currentStripe = = previousStripe ) { array [ i ] = array [ i - <int> ] ; } else { array [ i ] = getAt ( currentStripe ) ; previousStripe = currentStripe ; } } @SuppressWarnings ( <str> ) List < L > asList = ( List < L > ) Arrays . asList ( array ) ; return Collections . unmodifiableList ( asList ) ; } public static Striped < Lock > lock ( int stripes ) { return new CompactStriped < Lock > ( stripes , new Supplier < Lock > ( ) { @Override public Lock get ( ) { return new PaddedLock ( ) ; } } ) ; } public static Striped < Lock > lazyWeakLock ( int stripes ) { return lazy ( stripes , new Supplier < Lock > ( ) { @Override public Lock get ( ) { return new ReentrantLock ( false ) ; } } ) ; } private static < L > Striped < L > lazy ( int stripes , Supplier < L > supplier ) { return stripes < LARGE_LAZY_CUTOFF ? new SmallLazyStriped < L > ( stripes , supplier ) : new LargeLazyStriped < L > ( stripes , supplier ) ; } public static Striped < Semaphore > semaphore ( int stripes , final int permits ) { return new CompactStriped < Semaphore > ( stripes , new Supplier < Semaphore > ( ) { @Override public Semaphore get ( ) { return new PaddedSemaphore ( permits ) ; } } ) ; } public static Striped < Semaphore > lazyWeakSemaphore ( int stripes , final int permits ) { return lazy ( stripes , new Supplier < Semaphore > ( ) { @Override public Semaphore get ( ) { return new Semaphore ( permits , false ) ; } } ) ; } public static Striped < ReadWriteLock > readWriteLock ( int stripes ) { return new CompactStriped < ReadWriteLock > ( stripes , READ_WRITE_LOCK_SUPPLIER ) ; } public static Striped < ReadWriteLock > lazyWeakReadWriteLock ( int stripes ) { return lazy ( stripes , READ_WRITE_LOCK_SUPPLIER ) ; } private static final Supplier < ReadWriteLock > READ_WRITE_LOCK_SUPPLIER = new Supplier < ReadWriteLock > ( ) { @Override public ReadWriteLock get ( ) { return new ReentrantReadWriteLock ( ) ; } } ; private abstract static class PowerOfTwoStriped < L > extends Striped < L > { final int mask ; PowerOfTwoStriped ( int stripes ) { Preconditions . checkArgument ( stripes > <int> , <str> ) ; this . mask = stripes > Ints . MAX_POWER_OF_TWO ? ALL_SET : ceilToPowerOfTwo ( stripes ) - <int> ; } @Override final int indexFor ( Object key ) { int hash = smear ( key . hashCode ( ) ) ; return hash & mask ; } @Override public final L get ( Object key ) { return getAt ( indexFor ( key ) ) ; } } private static class CompactStriped < L > extends PowerOfTwoStriped < L > { private final Object [ ] array ; private CompactStriped ( int stripes , Supplier < L > supplier ) { super ( stripes ) ; Preconditions . checkArgument ( stripes < = Ints . MAX_POWER_OF_TWO , <str> ) ; this . array = new Object [ mask + <int> ] ; for ( int i = <int> ; i < array . length ; i + + ) { array [ i ] = supplier . get ( ) ; } } @SuppressWarnings ( <str> ) @Override public L getAt ( int index ) { return ( L ) array [ index ] ; } @Override public int size ( ) { return array . length ; } } @VisibleForTesting static class SmallLazyStriped < L > extends PowerOfTwoStriped < L > { final AtomicReferenceArray < ArrayReference < ? extends L > > locks ; final Supplier < L > supplier ; final int size ; final ReferenceQueue < L > queue = new ReferenceQueue < L > ( ) ; SmallLazyStriped ( int stripes , Supplier < L > supplier ) { super ( stripes ) ; this . size = ( mask = = ALL_SET ) ? Integer . MAX_VALUE : mask + <int> ; this . locks = new AtomicReferenceArray < ArrayReference < ? extends L > > ( size ) ; this . supplier = supplier ; } @Override public L getAt ( int index ) { if ( size ! = Integer . MAX_VALUE ) { Preconditions . checkElementIndex ( index , size ( ) ) ; } ArrayReference < ? extends L > existingRef = locks . get ( index ) ; L existing = existingRef = = null ? null : existingRef . get ( ) ; if ( existing ! = null ) { return existing ; } L created = supplier . get ( ) ; ArrayReference < L > newRef = new ArrayReference < L > ( created , index , queue ) ; while ( ! locks . compareAndSet ( index , existingRef , newRef ) ) { existingRef = locks . get ( index ) ; existing = existingRef = = null ? null : existingRef . get ( ) ; if ( existing ! = null ) { return existing ; } } drainQueue ( ) ; return created ; } private void drainQueue ( ) { Reference < ? extends L > ref ; while ( ( ref = queue . poll ( ) ) ! = null ) { ArrayReference < ? extends L > arrayRef = ( ArrayReference < ? extends L > ) ref ; locks . compareAndSet ( arrayRef . index , arrayRef , null ) ; } } @Override public int size ( ) { return size ; } private static final class ArrayReference < L > extends WeakReference < L > { final int index ; ArrayReference ( L referent , int index , ReferenceQueue < L > queue ) { super ( referent , queue ) ; this . index = index ; } } } @VisibleForTesting static class LargeLazyStriped < L > extends PowerOfTwoStriped < L > { final ConcurrentMap < Integer , L > locks ; final Supplier < L > supplier ; final int size ; LargeLazyStriped ( int stripes , Supplier < L > supplier ) { super ( stripes ) ; this . size = ( mask = = ALL_SET ) ? Integer . MAX_VALUE : mask + <int> ; this . supplier = supplier ; this . locks = new MapMaker ( ) . weakValues ( ) . makeMap ( ) ; } @Override public L getAt ( int index ) { if ( size ! = Integer . MAX_VALUE ) { Preconditions . checkElementIndex ( index , size ( ) ) ; } L existing = locks . get ( index ) ; if ( existing ! = null ) { return existing ; } L created = supplier . get ( ) ; existing = locks . putIfAbsent ( index , created ) ; return MoreObjects . firstNonNull ( existing , created ) ; } @Override public int size ( ) { return size ; } } private static final int ALL_SET = ~ <int> ; private static int ceilToPowerOfTwo ( int x ) { return <int> < < IntMath . log2 ( x , RoundingMode . CEILING ) ; } private static int smear ( int hashCode ) { hashCode ^ = ( hashCode > > > <int> ) ^ ( hashCode > > > <int> ) ; return hashCode ^ ( hashCode > > > <int> ) ^ ( hashCode > > > <int> ) ; } private static class PaddedLock extends ReentrantLock { long unused1 ; long unused2 ; long unused3 ; PaddedLock ( ) { super ( false ) ; } } private static class PaddedSemaphore extends Semaphore { long unused1 ; long unused2 ; long unused3 ; PaddedSemaphore ( int permits ) { super ( permits , false ) ; } } } 
