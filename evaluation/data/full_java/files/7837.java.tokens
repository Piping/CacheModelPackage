package org . elasticsearch . cluster . routing ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . test . ESTestCase ; import java . io . IOException ; public class ShardRoutingTests extends ESTestCase { public void testFrozenAfterRead ( ) throws IOException { ShardRouting routing = TestShardRouting . newShardRouting ( <str> , <int> , <str> , null , null , false , ShardRoutingState . INITIALIZING , <int> ) ; routing . moveToPrimary ( ) ; assertTrue ( routing . primary ( ) ) ; routing . moveFromPrimary ( ) ; assertFalse ( routing . primary ( ) ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; routing . writeTo ( out ) ; ShardRouting newRouting = ShardRouting . readShardRoutingEntry ( StreamInput . wrap ( out . bytes ( ) ) ) ; try { newRouting . moveToPrimary ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } } public void testIsSameAllocation ( ) { ShardRouting unassignedShard0 = TestShardRouting . newShardRouting ( <str> , <int> , null , false , ShardRoutingState . UNASSIGNED , <int> ) ; ShardRouting unassignedShard1 = TestShardRouting . newShardRouting ( <str> , <int> , null , false , ShardRoutingState . UNASSIGNED , <int> ) ; ShardRouting initializingShard0 = TestShardRouting . newShardRouting ( <str> , <int> , <str> , randomBoolean ( ) , ShardRoutingState . INITIALIZING , <int> ) ; ShardRouting initializingShard1 = TestShardRouting . newShardRouting ( <str> , <int> , <str> , randomBoolean ( ) , ShardRoutingState . INITIALIZING , <int> ) ; ShardRouting startedShard0 = new ShardRouting ( initializingShard0 ) ; startedShard0 . moveToStarted ( ) ; ShardRouting startedShard1 = new ShardRouting ( initializingShard1 ) ; startedShard1 . moveToStarted ( ) ; assertTrue ( initializingShard0 . isSameAllocation ( initializingShard0 ) ) ; assertTrue ( initializingShard0 . isSameAllocation ( startedShard0 ) ) ; assertFalse ( unassignedShard0 . isSameAllocation ( unassignedShard0 ) ) ; assertFalse ( unassignedShard0 . isSameAllocation ( unassignedShard1 ) ) ; assertFalse ( unassignedShard0 . isSameAllocation ( initializingShard0 ) ) ; assertFalse ( unassignedShard0 . isSameAllocation ( initializingShard1 ) ) ; assertFalse ( unassignedShard0 . isSameAllocation ( startedShard1 ) ) ; } public void testIsSameShard ( ) { ShardRouting index1Shard0a = randomShardRouting ( <str> , <int> ) ; ShardRouting index1Shard0b = randomShardRouting ( <str> , <int> ) ; ShardRouting index1Shard1 = randomShardRouting ( <str> , <int> ) ; ShardRouting index2Shard0 = randomShardRouting ( <str> , <int> ) ; ShardRouting index2Shard1 = randomShardRouting ( <str> , <int> ) ; assertTrue ( index1Shard0a . isSameShard ( index1Shard0a ) ) ; assertTrue ( index1Shard0a . isSameShard ( index1Shard0b ) ) ; assertFalse ( index1Shard0a . isSameShard ( index1Shard1 ) ) ; assertFalse ( index1Shard0a . isSameShard ( index2Shard0 ) ) ; assertFalse ( index1Shard0a . isSameShard ( index2Shard1 ) ) ; } private ShardRouting randomShardRouting ( String index , int shard ) { ShardRoutingState state = randomFrom ( ShardRoutingState . values ( ) ) ; return TestShardRouting . newShardRouting ( index , shard , state = = ShardRoutingState . UNASSIGNED ? null : <str> , state ! = ShardRoutingState . UNASSIGNED & & randomBoolean ( ) , state , randomInt ( <int> ) ) ; } public void testIsSourceTargetRelocation ( ) { ShardRouting unassignedShard0 = TestShardRouting . newShardRouting ( <str> , <int> , null , false , ShardRoutingState . UNASSIGNED , <int> ) ; ShardRouting initializingShard0 = TestShardRouting . newShardRouting ( <str> , <int> , <str> , randomBoolean ( ) , ShardRoutingState . INITIALIZING , <int> ) ; ShardRouting initializingShard1 = TestShardRouting . newShardRouting ( <str> , <int> , <str> , randomBoolean ( ) , ShardRoutingState . INITIALIZING , <int> ) ; ShardRouting startedShard0 = new ShardRouting ( initializingShard0 ) ; assertFalse ( startedShard0 . isRelocationTarget ( ) ) ; startedShard0 . moveToStarted ( ) ; assertFalse ( startedShard0 . isRelocationTarget ( ) ) ; ShardRouting startedShard1 = new ShardRouting ( initializingShard1 ) ; assertFalse ( startedShard1 . isRelocationTarget ( ) ) ; startedShard1 . moveToStarted ( ) ; assertFalse ( startedShard1 . isRelocationTarget ( ) ) ; ShardRouting sourceShard0a = new ShardRouting ( startedShard0 ) ; sourceShard0a . relocate ( <str> , - <int> ) ; assertFalse ( sourceShard0a . isRelocationTarget ( ) ) ; ShardRouting targetShard0a = sourceShard0a . buildTargetRelocatingShard ( ) ; assertTrue ( targetShard0a . isRelocationTarget ( ) ) ; ShardRouting sourceShard0b = new ShardRouting ( startedShard0 ) ; sourceShard0b . relocate ( <str> , - <int> ) ; ShardRouting sourceShard1 = new ShardRouting ( startedShard1 ) ; sourceShard1 . relocate ( <str> , - <int> ) ; assertTrue ( targetShard0a . isRelocationTargetOf ( sourceShard0a ) ) ; assertTrue ( sourceShard0a . isRelocationSourceOf ( targetShard0a ) ) ; assertFalse ( targetShard0a . isRelocationTargetOf ( sourceShard1 ) ) ; assertFalse ( sourceShard1 . isRelocationSourceOf ( targetShard0a ) ) ; assertFalse ( targetShard0a . isRelocationTargetOf ( sourceShard0b ) ) ; assertFalse ( sourceShard0b . isRelocationSourceOf ( targetShard0a ) ) ; assertFalse ( targetShard0a . isRelocationTargetOf ( unassignedShard0 ) ) ; assertFalse ( sourceShard0a . isRelocationTargetOf ( unassignedShard0 ) ) ; assertFalse ( unassignedShard0 . isRelocationSourceOf ( targetShard0a ) ) ; assertFalse ( unassignedShard0 . isRelocationSourceOf ( sourceShard0a ) ) ; assertFalse ( targetShard0a . isRelocationTargetOf ( initializingShard0 ) ) ; assertFalse ( sourceShard0a . isRelocationTargetOf ( initializingShard0 ) ) ; assertFalse ( initializingShard0 . isRelocationSourceOf ( targetShard0a ) ) ; assertFalse ( initializingShard0 . isRelocationSourceOf ( sourceShard0a ) ) ; assertFalse ( targetShard0a . isRelocationTargetOf ( startedShard0 ) ) ; assertFalse ( sourceShard0a . isRelocationTargetOf ( startedShard0 ) ) ; assertFalse ( startedShard0 . isRelocationSourceOf ( targetShard0a ) ) ; assertFalse ( startedShard0 . isRelocationSourceOf ( sourceShard0a ) ) ; } public void testEqualsIgnoringVersion ( ) { ShardRouting routing = randomShardRouting ( <str> , <int> ) ; ShardRouting otherRouting = new ShardRouting ( routing ) ; assertTrue ( <str> + routing + <str> + otherRouting , routing . equalsIgnoringMetaData ( otherRouting ) ) ; otherRouting = new ShardRouting ( routing , <int> ) ; assertTrue ( <str> + routing + <str> + otherRouting , routing . equalsIgnoringMetaData ( otherRouting ) ) ; otherRouting = new ShardRouting ( routing ) ; Integer [ ] changeIds = new Integer [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; for ( int changeId : randomSubsetOf ( randomIntBetween ( <int> , changeIds . length ) , changeIds ) ) { switch ( changeId ) { case <int> : otherRouting = TestShardRouting . newShardRouting ( otherRouting . index ( ) + <str> , otherRouting . id ( ) , otherRouting . currentNodeId ( ) , otherRouting . relocatingNodeId ( ) , otherRouting . restoreSource ( ) , otherRouting . primary ( ) , otherRouting . state ( ) , otherRouting . version ( ) , otherRouting . unassignedInfo ( ) ) ; break ; case <int> : otherRouting = TestShardRouting . newShardRouting ( otherRouting . index ( ) , otherRouting . id ( ) + <int> , otherRouting . currentNodeId ( ) , otherRouting . relocatingNodeId ( ) , otherRouting . restoreSource ( ) , otherRouting . primary ( ) , otherRouting . state ( ) , otherRouting . version ( ) , otherRouting . unassignedInfo ( ) ) ; break ; case <int> : otherRouting = TestShardRouting . newShardRouting ( otherRouting . index ( ) , otherRouting . id ( ) , otherRouting . currentNodeId ( ) = = null ? <str> : otherRouting . currentNodeId ( ) + <str> , otherRouting . relocatingNodeId ( ) , otherRouting . restoreSource ( ) , otherRouting . primary ( ) , otherRouting . state ( ) , otherRouting . version ( ) , otherRouting . unassignedInfo ( ) ) ; break ; case <int> : otherRouting = TestShardRouting . newShardRouting ( otherRouting . index ( ) , otherRouting . id ( ) , otherRouting . currentNodeId ( ) , otherRouting . relocatingNodeId ( ) = = null ? <str> : otherRouting . relocatingNodeId ( ) + <str> , otherRouting . restoreSource ( ) , otherRouting . primary ( ) , otherRouting . state ( ) , otherRouting . version ( ) , otherRouting . unassignedInfo ( ) ) ; break ; case <int> : otherRouting = TestShardRouting . newShardRouting ( otherRouting . index ( ) , otherRouting . id ( ) , otherRouting . currentNodeId ( ) , otherRouting . relocatingNodeId ( ) , otherRouting . restoreSource ( ) = = null ? new RestoreSource ( new SnapshotId ( <str> , <str> ) , Version . CURRENT , <str> ) : new RestoreSource ( otherRouting . restoreSource ( ) . snapshotId ( ) , Version . CURRENT , otherRouting . index ( ) + <str> ) , otherRouting . primary ( ) , otherRouting . state ( ) , otherRouting . version ( ) , otherRouting . unassignedInfo ( ) ) ; break ; case <int> : otherRouting = TestShardRouting . newShardRouting ( otherRouting . index ( ) , otherRouting . id ( ) , otherRouting . currentNodeId ( ) , otherRouting . relocatingNodeId ( ) , otherRouting . restoreSource ( ) , otherRouting . primary ( ) = = false , otherRouting . state ( ) , otherRouting . version ( ) , otherRouting . unassignedInfo ( ) ) ; break ; case <int> : ShardRoutingState newState ; do { newState = randomFrom ( ShardRoutingState . values ( ) ) ; } while ( newState = = otherRouting . state ( ) ) ; UnassignedInfo unassignedInfo = otherRouting . unassignedInfo ( ) ; if ( unassignedInfo = = null & & ( newState = = ShardRoutingState . UNASSIGNED | | newState = = ShardRoutingState . INITIALIZING ) ) { unassignedInfo = new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) ; } otherRouting = TestShardRouting . newShardRouting ( otherRouting . index ( ) , otherRouting . id ( ) , otherRouting . currentNodeId ( ) , otherRouting . relocatingNodeId ( ) , otherRouting . restoreSource ( ) , otherRouting . primary ( ) , newState , otherRouting . version ( ) , unassignedInfo ) ; break ; } if ( randomBoolean ( ) ) { otherRouting = new ShardRouting ( otherRouting , otherRouting . version ( ) + <int> ) ; } if ( randomBoolean ( ) ) { otherRouting = TestShardRouting . newShardRouting ( otherRouting . index ( ) , otherRouting . id ( ) , otherRouting . currentNodeId ( ) , otherRouting . relocatingNodeId ( ) , otherRouting . restoreSource ( ) , otherRouting . primary ( ) , otherRouting . state ( ) , otherRouting . version ( ) , otherRouting . unassignedInfo ( ) = = null ? new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , <str> ) : new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , otherRouting . unassignedInfo ( ) . getMessage ( ) + <str> ) ) ; } logger . debug ( <str> , routing , otherRouting ) ; assertFalse ( <str> + routing + <str> + otherRouting , routing . equalsIgnoringMetaData ( otherRouting ) ) ; } } public void testFrozenOnRoutingTable ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTable = RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; for ( ShardRouting routing : clusterState . routingTable ( ) . allShards ( ) ) { long version = routing . version ( ) ; assertTrue ( routing . isFrozen ( ) ) ; try { routing . moveToPrimary ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } try { routing . moveToStarted ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } try { routing . moveFromPrimary ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } try { routing . initialize ( <str> , - <int> ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } try { routing . cancelRelocation ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } try { routing . moveToUnassigned ( new UnassignedInfo ( UnassignedInfo . Reason . REPLICA_ADDED , <str> ) ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } try { routing . relocate ( <str> , - <int> ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } try { routing . reinitializeShard ( ) ; fail ( <str> ) ; } catch ( IllegalStateException ex ) { } assertEquals ( version , routing . version ( ) ) ; } } public void testExpectedSize ( ) throws IOException { final int iters = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < iters ; i + + ) { ShardRouting routing = randomShardRouting ( <str> , <int> ) ; long byteSize = randomIntBetween ( <int> , Integer . MAX_VALUE ) ; if ( routing . unassigned ( ) ) { ShardRoutingHelper . initialize ( routing , <str> , byteSize ) ; } else if ( routing . started ( ) ) { ShardRoutingHelper . relocate ( routing , <str> , byteSize ) ; } else { byteSize = - <int> ; } if ( randomBoolean ( ) ) { BytesStreamOutput out = new BytesStreamOutput ( ) ; routing . writeTo ( out ) ; routing = ShardRouting . readShardRoutingEntry ( StreamInput . wrap ( out . bytes ( ) ) ) ; } if ( routing . initializing ( ) | | routing . relocating ( ) ) { assertEquals ( routing . toString ( ) , byteSize , routing . getExpectedShardSize ( ) ) ; if ( byteSize > = <int> ) { assertTrue ( routing . toString ( ) , routing . toString ( ) . contains ( <str> + byteSize + <str> ) ) ; } if ( routing . initializing ( ) ) { routing = new ShardRouting ( routing ) ; routing . moveToStarted ( ) ; assertEquals ( - <int> , routing . getExpectedShardSize ( ) ) ; assertFalse ( routing . toString ( ) , routing . toString ( ) . contains ( <str> + byteSize + <str> ) ) ; } } else { assertFalse ( routing . toString ( ) , routing . toString ( ) . contains ( <str> + byteSize + <str> ) ) ; assertEquals ( byteSize , routing . getExpectedShardSize ( ) ) ; } } } } 
