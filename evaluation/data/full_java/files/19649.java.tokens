package io . netty . util ; import io . netty . util . internal . MathUtil ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . SystemPropertyUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . lang . ref . PhantomReference ; import java . lang . ref . ReferenceQueue ; import java . util . ArrayDeque ; import java . util . Deque ; import java . util . EnumSet ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . atomic . AtomicBoolean ; import static io . netty . util . internal . StringUtil . * ; public final class ResourceLeakDetector < T > { private static final String PROP_LEVEL_OLD = <str> ; private static final String PROP_LEVEL = <str> ; private static final Level DEFAULT_LEVEL = Level . SIMPLE ; private static final String PROP_MAX_RECORDS = <str> ; private static final int DEFAULT_MAX_RECORDS = <int> ; private static final int MAX_RECORDS ; public enum Level { DISABLED , SIMPLE , ADVANCED , PARANOID } private static Level level ; private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ResourceLeakDetector . class ) ; static { final boolean disabled ; if ( SystemPropertyUtil . get ( <str> ) ! = null ) { disabled = SystemPropertyUtil . getBoolean ( <str> , false ) ; logger . debug ( <str> , disabled ) ; logger . warn ( <str> , PROP_LEVEL , DEFAULT_LEVEL . name ( ) . toLowerCase ( ) ) ; } else { disabled = false ; } Level defaultLevel = disabled ? Level . DISABLED : DEFAULT_LEVEL ; String levelStr = SystemPropertyUtil . get ( PROP_LEVEL_OLD , defaultLevel . name ( ) ) . trim ( ) . toUpperCase ( ) ; levelStr = SystemPropertyUtil . get ( PROP_LEVEL , levelStr ) . trim ( ) . toUpperCase ( ) ; Level level = DEFAULT_LEVEL ; for ( Level l : EnumSet . allOf ( Level . class ) ) { if ( levelStr . equals ( l . name ( ) ) | | levelStr . equals ( String . valueOf ( l . ordinal ( ) ) ) ) { level = l ; } } MAX_RECORDS = SystemPropertyUtil . getInt ( PROP_MAX_RECORDS , DEFAULT_MAX_RECORDS ) ; ResourceLeakDetector . level = level ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , PROP_LEVEL , level . name ( ) . toLowerCase ( ) ) ; logger . debug ( <str> , PROP_MAX_RECORDS , MAX_RECORDS ) ; } } private static final int DEFAULT_SAMPLING_INTERVAL = <int> ; @Deprecated public static void setEnabled ( boolean enabled ) { setLevel ( enabled ? Level . SIMPLE : Level . DISABLED ) ; } public static boolean isEnabled ( ) { return getLevel ( ) . ordinal ( ) > Level . DISABLED . ordinal ( ) ; } public static void setLevel ( Level level ) { if ( level = = null ) { throw new NullPointerException ( <str> ) ; } ResourceLeakDetector . level = level ; } public static Level getLevel ( ) { return level ; } private final DefaultResourceLeak head = new DefaultResourceLeak ( null ) ; private final DefaultResourceLeak tail = new DefaultResourceLeak ( null ) ; private final ReferenceQueue < Object > refQueue = new ReferenceQueue < Object > ( ) ; private final ConcurrentMap < String , Boolean > reportedLeaks = PlatformDependent . newConcurrentHashMap ( ) ; private final String resourceType ; private final int samplingInterval ; private final int mask ; private final long maxActive ; private long active ; private final AtomicBoolean loggedTooManyActive = new AtomicBoolean ( ) ; private long leakCheckCnt ; public ResourceLeakDetector ( Class < ? > resourceType ) { this ( simpleClassName ( resourceType ) ) ; } public ResourceLeakDetector ( String resourceType ) { this ( resourceType , DEFAULT_SAMPLING_INTERVAL , Long . MAX_VALUE ) ; } public ResourceLeakDetector ( Class < ? > resourceType , int samplingInterval , long maxActive ) { this ( simpleClassName ( resourceType ) , samplingInterval , maxActive ) ; } public ResourceLeakDetector ( String resourceType , int samplingInterval , long maxActive ) { if ( resourceType = = null ) { throw new NullPointerException ( <str> ) ; } if ( samplingInterval < = <int> ) { throw new IllegalArgumentException ( <str> + samplingInterval + <str> ) ; } if ( maxActive < = <int> ) { throw new IllegalArgumentException ( <str> + maxActive + <str> ) ; } this . resourceType = resourceType ; this . samplingInterval = MathUtil . findNextPositivePowerOfTwo ( samplingInterval ) ; mask = this . samplingInterval - <int> ; this . maxActive = maxActive ; head . next = tail ; tail . prev = head ; } public ResourceLeak open ( T obj ) { Level level = ResourceLeakDetector . level ; if ( level = = Level . DISABLED ) { return null ; } if ( level . ordinal ( ) < Level . PARANOID . ordinal ( ) ) { if ( ( leakCheckCnt + + & mask ) = = <int> ) { reportLeak ( level ) ; return new DefaultResourceLeak ( obj ) ; } else { return null ; } } else { reportLeak ( level ) ; return new DefaultResourceLeak ( obj ) ; } } private void reportLeak ( Level level ) { if ( ! logger . isErrorEnabled ( ) ) { for ( ; ; ) { @SuppressWarnings ( <str> ) DefaultResourceLeak ref = ( DefaultResourceLeak ) refQueue . poll ( ) ; if ( ref = = null ) { break ; } ref . close ( ) ; } return ; } int samplingInterval = level = = Level . PARANOID ? <int> : this . samplingInterval ; if ( active * samplingInterval > maxActive & & loggedTooManyActive . compareAndSet ( false , true ) ) { logger . error ( <str> + resourceType + <str> + resourceType + <str> + <str> ) ; } for ( ; ; ) { @SuppressWarnings ( <str> ) DefaultResourceLeak ref = ( DefaultResourceLeak ) refQueue . poll ( ) ; if ( ref = = null ) { break ; } ref . clear ( ) ; if ( ! ref . close ( ) ) { continue ; } String records = ref . toString ( ) ; if ( reportedLeaks . putIfAbsent ( records , Boolean . TRUE ) = = null ) { if ( records . isEmpty ( ) ) { logger . error ( <str> + <str> + <str> + <str> + <str> , resourceType , PROP_LEVEL , Level . ADVANCED . name ( ) . toLowerCase ( ) , simpleClassName ( this ) ) ; } else { logger . error ( <str> + <str> , resourceType , records ) ; } } } } private final class DefaultResourceLeak extends PhantomReference < Object > implements ResourceLeak { private final String creationRecord ; private final Deque < String > lastRecords = new ArrayDeque < String > ( ) ; private final AtomicBoolean freed ; private DefaultResourceLeak prev ; private DefaultResourceLeak next ; DefaultResourceLeak ( Object referent ) { super ( referent , referent ! = null ? refQueue : null ) ; if ( referent ! = null ) { Level level = getLevel ( ) ; if ( level . ordinal ( ) > = Level . ADVANCED . ordinal ( ) ) { creationRecord = newRecord ( null , <int> ) ; } else { creationRecord = null ; } synchronized ( head ) { prev = head ; next = head . next ; head . next . prev = this ; head . next = this ; active + + ; } freed = new AtomicBoolean ( ) ; } else { creationRecord = null ; freed = new AtomicBoolean ( true ) ; } } @Override public void record ( ) { record0 ( null , <int> ) ; } @Override public void record ( Object hint ) { record0 ( hint , <int> ) ; } private void record0 ( Object hint , int recordsToSkip ) { if ( creationRecord ! = null ) { String value = newRecord ( hint , recordsToSkip ) ; synchronized ( lastRecords ) { int size = lastRecords . size ( ) ; if ( size = = <int> | | ! lastRecords . getLast ( ) . equals ( value ) ) { lastRecords . add ( value ) ; } if ( size > MAX_RECORDS ) { lastRecords . removeFirst ( ) ; } } } } @Override public boolean close ( ) { if ( freed . compareAndSet ( false , true ) ) { synchronized ( head ) { active - - ; prev . next = next ; next . prev = prev ; prev = null ; next = null ; } return true ; } return false ; } @Override public String toString ( ) { if ( creationRecord = = null ) { return <str> ; } Object [ ] array ; synchronized ( lastRecords ) { array = lastRecords . toArray ( ) ; } StringBuilder buf = new StringBuilder ( <int> ) . append ( NEWLINE ) . append ( <str> ) . append ( array . length ) . append ( NEWLINE ) ; if ( array . length > <int> ) { for ( int i = array . length - <int> ; i > = <int> ; i - - ) { buf . append ( <str> ) . append ( i + <int> ) . append ( <str> ) . append ( NEWLINE ) . append ( array [ i ] ) ; } } buf . append ( <str> ) . append ( NEWLINE ) . append ( creationRecord ) ; buf . setLength ( buf . length ( ) - NEWLINE . length ( ) ) ; return buf . toString ( ) ; } } private static final String [ ] STACK_TRACE_ELEMENT_EXCLUSIONS = { <str> , <str> , <str> , <str> } ; static String newRecord ( Object hint , int recordsToSkip ) { StringBuilder buf = new StringBuilder ( <int> ) ; if ( hint ! = null ) { buf . append ( <str> ) ; if ( hint instanceof ResourceLeakHint ) { buf . append ( ( ( ResourceLeakHint ) hint ) . toHintString ( ) ) ; } else { buf . append ( hint ) ; } buf . append ( NEWLINE ) ; } StackTraceElement [ ] array = new Throwable ( ) . getStackTrace ( ) ; for ( StackTraceElement e : array ) { if ( recordsToSkip > <int> ) { recordsToSkip - - ; } else { String estr = e . toString ( ) ; boolean excluded = false ; for ( String exclusion : STACK_TRACE_ELEMENT_EXCLUSIONS ) { if ( estr . startsWith ( exclusion ) ) { excluded = true ; break ; } } if ( ! excluded ) { buf . append ( <str> ) ; buf . append ( estr ) ; buf . append ( NEWLINE ) ; } } } return buf . toString ( ) ; } } 
