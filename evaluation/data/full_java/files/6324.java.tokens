package org . elasticsearch . index . analysis ; import com . carrotsearch . hppc . IntObjectHashMap ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . joda . time . format . DateTimeFormatter ; import java . io . IOException ; import java . util . HashMap ; import java . util . Map ; public class NumericDateAnalyzer extends NumericAnalyzer < NumericDateTokenizer > { private static final Map < String , IntObjectHashMap < NamedAnalyzer > > globalAnalyzers = new HashMap < > ( ) ; public static synchronized NamedAnalyzer buildNamedAnalyzer ( FormatDateTimeFormatter formatter , int precisionStep ) { IntObjectHashMap < NamedAnalyzer > precisionMap = globalAnalyzers . get ( formatter . format ( ) ) ; if ( precisionMap = = null ) { precisionMap = new IntObjectHashMap < > ( ) ; globalAnalyzers . put ( formatter . format ( ) , precisionMap ) ; } NamedAnalyzer namedAnalyzer = precisionMap . get ( precisionStep ) ; if ( namedAnalyzer = = null ) { String name = <str> + ( ( precisionStep = = Integer . MAX_VALUE ) ? <str> : precisionStep ) ; namedAnalyzer = new NamedAnalyzer ( name , AnalyzerScope . GLOBAL , new NumericDateAnalyzer ( precisionStep , formatter . parser ( ) ) ) ; precisionMap . put ( precisionStep , namedAnalyzer ) ; } return namedAnalyzer ; } private final int precisionStep ; private final DateTimeFormatter dateTimeFormatter ; public NumericDateAnalyzer ( int precisionStep , DateTimeFormatter dateTimeFormatter ) { this . precisionStep = precisionStep ; this . dateTimeFormatter = dateTimeFormatter ; } @Override protected NumericDateTokenizer createNumericTokenizer ( char [ ] buffer ) throws IOException { return new NumericDateTokenizer ( precisionStep , buffer , dateTimeFormatter ) ; } } 
