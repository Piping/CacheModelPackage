package org . elasticsearch . action . support . single . instance ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionResponse ; import org . elasticsearch . action . UnavailableShardsException ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . HandledTransportAction ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateObserver ; import org . elasticsearch . cluster . block . ClusterBlockException ; import org . elasticsearch . cluster . block . ClusterBlockLevel ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . ShardIterator ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . logging . support . LoggerMessageFormat ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . node . NodeClosedException ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . * ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . function . Supplier ; public abstract class TransportInstanceSingleOperationAction < Request extends InstanceShardOperationRequest , Response extends ActionResponse > extends HandledTransportAction < Request , Response > { protected final ClusterService clusterService ; protected final TransportService transportService ; final String executor ; final String shardActionName ; protected TransportInstanceSingleOperationAction ( Settings settings , String actionName , ThreadPool threadPool , ClusterService clusterService , TransportService transportService , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver , Supplier < Request > request ) { super ( settings , actionName , threadPool , transportService , actionFilters , indexNameExpressionResolver , request ) ; this . clusterService = clusterService ; this . transportService = transportService ; this . executor = executor ( ) ; this . shardActionName = actionName + <str> ; transportService . registerRequestHandler ( shardActionName , request , executor , new ShardTransportHandler ( ) ) ; } @Override protected void doExecute ( Request request , ActionListener < Response > listener ) { new AsyncSingleAction ( request , listener ) . start ( ) ; } protected abstract String executor ( ) ; protected abstract void shardOperation ( Request request , ActionListener < Response > listener ) ; protected abstract Response newResponse ( ) ; protected ClusterBlockException checkGlobalBlock ( ClusterState state ) { return state . blocks ( ) . globalBlockedException ( ClusterBlockLevel . WRITE ) ; } protected ClusterBlockException checkRequestBlock ( ClusterState state , Request request ) { return state . blocks ( ) . indexBlockedException ( ClusterBlockLevel . WRITE , request . concreteIndex ( ) ) ; } protected abstract boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) ; protected boolean retryOnFailure ( Throwable e ) { return false ; } protected TransportRequestOptions transportOptions ( ) { return TransportRequestOptions . EMPTY ; } protected abstract ShardIterator shards ( ClusterState clusterState , Request request ) ; class AsyncSingleAction { private final ActionListener < Response > listener ; private final Request request ; private volatile ClusterStateObserver observer ; private ShardIterator shardIt ; private DiscoveryNodes nodes ; AsyncSingleAction ( Request request , ActionListener < Response > listener ) { this . request = request ; this . listener = listener ; } public void start ( ) { this . observer = new ClusterStateObserver ( clusterService , request . timeout ( ) , logger ) ; doStart ( ) ; } protected void doStart ( ) { nodes = observer . observedState ( ) . nodes ( ) ; try { ClusterBlockException blockException = checkGlobalBlock ( observer . observedState ( ) ) ; if ( blockException ! = null ) { if ( blockException . retryable ( ) ) { retry ( blockException ) ; return ; } else { throw blockException ; } } request . concreteIndex ( indexNameExpressionResolver . concreteSingleIndex ( observer . observedState ( ) , request ) ) ; if ( ! resolveRequest ( observer . observedState ( ) , request , listener ) ) { listener . onFailure ( new IllegalStateException ( LoggerMessageFormat . format ( <str> , new ShardId ( request . index , request . shardId ) , actionName ) ) ) ; return ; } blockException = checkRequestBlock ( observer . observedState ( ) , request ) ; if ( blockException ! = null ) { if ( blockException . retryable ( ) ) { retry ( blockException ) ; return ; } else { throw blockException ; } } shardIt = shards ( observer . observedState ( ) , request ) ; } catch ( Throwable e ) { listener . onFailure ( e ) ; return ; } if ( shardIt . size ( ) = = <int> ) { retry ( null ) ; return ; } assert shardIt . size ( ) = = <int> ; ShardRouting shard = shardIt . nextOrNull ( ) ; assert shard ! = null ; if ( ! shard . active ( ) ) { retry ( null ) ; return ; } request . shardId = shardIt . shardId ( ) . id ( ) ; DiscoveryNode node = nodes . get ( shard . currentNodeId ( ) ) ; transportService . sendRequest ( node , shardActionName , request , transportOptions ( ) , new BaseTransportResponseHandler < Response > ( ) { @Override public Response newInstance ( ) { return newResponse ( ) ; } @Override public String executor ( ) { return ThreadPool . Names . SAME ; } @Override public void handleResponse ( Response response ) { listener . onResponse ( response ) ; } @Override public void handleException ( TransportException exp ) { Throwable cause = exp . unwrapCause ( ) ; if ( cause instanceof ConnectTransportException | | cause instanceof NodeClosedException | | retryOnFailure ( exp ) ) { retry ( cause ) ; } else { listener . onFailure ( exp ) ; } } } ) ; } void retry ( final @Nullable Throwable failure ) { if ( observer . isTimedOut ( ) ) { Throwable listenFailure = failure ; if ( listenFailure = = null ) { if ( shardIt = = null ) { listenFailure = new UnavailableShardsException ( new ShardId ( request . concreteIndex ( ) , - <int> ) , <str> , request . timeout ( ) , actionName ) ; } else { listenFailure = new UnavailableShardsException ( shardIt . shardId ( ) , <str> , shardIt . size ( ) , shardIt . sizeActive ( ) , request . timeout ( ) , actionName ) ; } } listener . onFailure ( listenFailure ) ; return ; } observer . waitForNextChange ( new ClusterStateObserver . Listener ( ) { @Override public void onNewClusterState ( ClusterState state ) { doStart ( ) ; } @Override public void onClusterServiceClose ( ) { listener . onFailure ( new NodeClosedException ( nodes . localNode ( ) ) ) ; } @Override public void onTimeout ( TimeValue timeout ) { doStart ( ) ; } } , request . timeout ( ) ) ; } } private class ShardTransportHandler implements TransportRequestHandler < Request > { @Override public void messageReceived ( final Request request , final TransportChannel channel ) throws Exception { shardOperation ( request , new ActionListener < Response > ( ) { @Override public void onResponse ( Response response ) { try { channel . sendResponse ( response ) ; } catch ( Throwable e ) { onFailure ( e ) ; } } @Override public void onFailure ( Throwable e ) { try { channel . sendResponse ( e ) ; } catch ( Exception e1 ) { logger . warn ( <str> , e1 ) ; } } } ) ; } } } 
