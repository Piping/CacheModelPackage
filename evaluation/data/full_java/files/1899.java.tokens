package clojure . lang ; import java . io . IOException ; import java . io . PushbackReader ; import java . io . Reader ; import java . lang . Character ; import java . lang . Class ; import java . lang . Exception ; import java . lang . IllegalArgumentException ; import java . lang . IllegalStateException ; import java . lang . Integer ; import java . lang . Number ; import java . lang . NumberFormatException ; import java . lang . Object ; import java . lang . RuntimeException ; import java . lang . String ; import java . lang . StringBuilder ; import java . lang . Throwable ; import java . lang . UnsupportedOperationException ; import java . lang . reflect . Constructor ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class LispReader { static final Symbol QUOTE = Symbol . intern ( <str> ) ; static final Symbol THE_VAR = Symbol . intern ( <str> ) ; static Symbol UNQUOTE = Symbol . intern ( <str> , <str> ) ; static Symbol UNQUOTE_SPLICING = Symbol . intern ( <str> , <str> ) ; static Symbol CONCAT = Symbol . intern ( <str> , <str> ) ; static Symbol SEQ = Symbol . intern ( <str> , <str> ) ; static Symbol LIST = Symbol . intern ( <str> , <str> ) ; static Symbol APPLY = Symbol . intern ( <str> , <str> ) ; static Symbol HASHMAP = Symbol . intern ( <str> , <str> ) ; static Symbol HASHSET = Symbol . intern ( <str> , <str> ) ; static Symbol VECTOR = Symbol . intern ( <str> , <str> ) ; static Symbol WITH_META = Symbol . intern ( <str> , <str> ) ; static Symbol META = Symbol . intern ( <str> , <str> ) ; static Symbol DEREF = Symbol . intern ( <str> , <str> ) ; static Symbol READ_COND = Symbol . intern ( <str> , <str> ) ; static Symbol READ_COND_SPLICING = Symbol . intern ( <str> , <str> ) ; static Keyword UNKNOWN = Keyword . intern ( null , <str> ) ; static IFn [ ] macros = new IFn [ <int> ] ; static IFn [ ] dispatchMacros = new IFn [ <int> ] ; static Pattern symbolPat = Pattern . compile ( <str> ) ; static Pattern intPat = Pattern . compile ( <str> ) ; static Pattern ratioPat = Pattern . compile ( <str> ) ; static Pattern floatPat = Pattern . compile ( <str> ) ; static Var GENSYM_ENV = Var . create ( null ) . setDynamic ( ) ; static Var ARG_ENV = Var . create ( null ) . setDynamic ( ) ; static IFn ctorReader = new CtorReader ( ) ; static Var READ_COND_ENV = Var . create ( null ) . setDynamic ( ) ; static { macros [ <str> ] = new StringReader ( ) ; macros [ <str> ] = new CommentReader ( ) ; macros [ <str> ] = new WrappingReader ( QUOTE ) ; macros [ <str> ] = new WrappingReader ( DEREF ) ; macros [ <str> ] = new MetaReader ( ) ; macros [ <str> ] = new SyntaxQuoteReader ( ) ; macros [ <str> ] = new UnquoteReader ( ) ; macros [ <str> ] = new ListReader ( ) ; macros [ <str> ] = new UnmatchedDelimiterReader ( ) ; macros [ <str> ] = new VectorReader ( ) ; macros [ <str> ] = new UnmatchedDelimiterReader ( ) ; macros [ <str> ] = new MapReader ( ) ; macros [ <str> ] = new UnmatchedDelimiterReader ( ) ; macros [ <str> ] = new CharacterReader ( ) ; macros [ <str> ] = new ArgReader ( ) ; macros [ <str> ] = new DispatchReader ( ) ; dispatchMacros [ <str> ] = new MetaReader ( ) ; dispatchMacros [ <str> ] = new VarReader ( ) ; dispatchMacros [ <str> ] = new RegexReader ( ) ; dispatchMacros [ <str> ] = new FnReader ( ) ; dispatchMacros [ <str> ] = new SetReader ( ) ; dispatchMacros [ <str> ] = new EvalReader ( ) ; dispatchMacros [ <str> ] = new CommentReader ( ) ; dispatchMacros [ <str> ] = new UnreadableReader ( ) ; dispatchMacros [ <str> ] = new DiscardReader ( ) ; dispatchMacros [ <str> ] = new ConditionalReader ( ) ; } static boolean isWhitespace ( int ch ) { return Character . isWhitespace ( ch ) | | ch = = <str> ; } static void unread ( PushbackReader r , int ch ) { if ( ch ! = - <int> ) try { r . unread ( ch ) ; } catch ( IOException e ) { throw Util . sneakyThrow ( e ) ; } } public static class ReaderException extends RuntimeException { final int line ; final int column ; public ReaderException ( int line , int column , Throwable cause ) { super ( cause ) ; this . line = line ; this . column = column ; } } static public int read1 ( Reader r ) { try { return r . read ( ) ; } catch ( IOException e ) { throw Util . sneakyThrow ( e ) ; } } static public final Keyword OPT_EOF = Keyword . intern ( null , <str> ) ; static public final Keyword OPT_FEATURES = Keyword . intern ( null , <str> ) ; static public final Keyword OPT_READ_COND = Keyword . intern ( null , <str> ) ; static public final Keyword EOFTHROW = Keyword . intern ( null , <str> ) ; static private final Keyword PLATFORM_KEY = Keyword . intern ( null , <str> ) ; static private final Object PLATFORM_FEATURES = PersistentHashSet . create ( PLATFORM_KEY ) ; static public final Keyword COND_ALLOW = Keyword . intern ( null , <str> ) ; static public final Keyword COND_PRESERVE = Keyword . intern ( null , <str> ) ; static public Object read ( PushbackReader r , Object opts ) { boolean eofIsError = true ; Object eofValue = null ; if ( opts ! = null & & opts instanceof IPersistentMap ) { Object eof = ( ( IPersistentMap ) opts ) . valAt ( OPT_EOF , EOFTHROW ) ; if ( ! EOFTHROW . equals ( eof ) ) { eofIsError = false ; eofValue = eof ; } } return read ( r , eofIsError , eofValue , false , opts ) ; } static public Object read ( PushbackReader r , boolean eofIsError , Object eofValue , boolean isRecursive ) { return read ( r , eofIsError , eofValue , isRecursive , PersistentHashMap . EMPTY ) ; } static public Object read ( PushbackReader r , boolean eofIsError , Object eofValue , boolean isRecursive , Object opts ) { return read ( r , eofIsError , eofValue , null , null , isRecursive , opts , null ) ; } static private Object read ( PushbackReader r , boolean eofIsError , Object eofValue , boolean isRecursive , Object opts , Object pendingForms ) { return read ( r , eofIsError , eofValue , null , null , isRecursive , opts , ensurePending ( pendingForms ) ) ; } static private Object ensurePending ( Object pendingForms ) { if ( pendingForms = = null ) return new LinkedList ( ) ; else return pendingForms ; } static private Object installPlatformFeature ( Object opts ) { if ( opts = = null ) return RT . mapUniqueKeys ( LispReader . OPT_FEATURES , PLATFORM_FEATURES ) ; else { IPersistentMap mopts = ( IPersistentMap ) opts ; Object features = mopts . valAt ( OPT_FEATURES ) ; if ( features = = null ) return mopts . assoc ( LispReader . OPT_FEATURES , PLATFORM_FEATURES ) ; else return mopts . assoc ( LispReader . OPT_FEATURES , RT . conj ( ( IPersistentSet ) features , PLATFORM_KEY ) ) ; } } static private Object read ( PushbackReader r , boolean eofIsError , Object eofValue , Character returnOn , Object returnOnValue , boolean isRecursive , Object opts , Object pendingForms ) { if ( RT . READEVAL . deref ( ) = = UNKNOWN ) throw Util . runtimeException ( <str> ) ; opts = installPlatformFeature ( opts ) ; try { for ( ; ; ) { if ( pendingForms instanceof List & & ! ( ( List ) pendingForms ) . isEmpty ( ) ) return ( ( List ) pendingForms ) . remove ( <int> ) ; int ch = read1 ( r ) ; while ( isWhitespace ( ch ) ) ch = read1 ( r ) ; if ( ch = = - <int> ) { if ( eofIsError ) throw Util . runtimeException ( <str> ) ; return eofValue ; } if ( returnOn ! = null & & ( returnOn . charValue ( ) = = ch ) ) { return returnOnValue ; } if ( Character . isDigit ( ch ) ) { Object n = readNumber ( r , ( char ) ch ) ; return n ; } IFn macroFn = getMacro ( ch ) ; if ( macroFn ! = null ) { Object ret = macroFn . invoke ( r , ( char ) ch , opts , pendingForms ) ; if ( ret = = r ) continue ; return ret ; } if ( ch = = <str> | | ch = = <str> ) { int ch2 = read1 ( r ) ; if ( Character . isDigit ( ch2 ) ) { unread ( r , ch2 ) ; Object n = readNumber ( r , ( char ) ch ) ; return n ; } unread ( r , ch2 ) ; } String token = readToken ( r , ( char ) ch ) ; return interpretToken ( token ) ; } } catch ( Exception e ) { if ( isRecursive | | ! ( r instanceof LineNumberingPushbackReader ) ) throw Util . sneakyThrow ( e ) ; LineNumberingPushbackReader rdr = ( LineNumberingPushbackReader ) r ; throw new ReaderException ( rdr . getLineNumber ( ) , rdr . getColumnNumber ( ) , e ) ; } } static private String readToken ( PushbackReader r , char initch ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( initch ) ; for ( ; ; ) { int ch = read1 ( r ) ; if ( ch = = - <int> | | isWhitespace ( ch ) | | isTerminatingMacro ( ch ) ) { unread ( r , ch ) ; return sb . toString ( ) ; } sb . append ( ( char ) ch ) ; } } static private Object readNumber ( PushbackReader r , char initch ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( initch ) ; for ( ; ; ) { int ch = read1 ( r ) ; if ( ch = = - <int> | | isWhitespace ( ch ) | | isMacro ( ch ) ) { unread ( r , ch ) ; break ; } sb . append ( ( char ) ch ) ; } String s = sb . toString ( ) ; Object n = matchNumber ( s ) ; if ( n = = null ) throw new NumberFormatException ( <str> + s ) ; return n ; } static private int readUnicodeChar ( String token , int offset , int length , int base ) { if ( token . length ( ) ! = offset + length ) throw new IllegalArgumentException ( <str> + token ) ; int uc = <int> ; for ( int i = offset ; i < offset + length ; + + i ) { int d = Character . digit ( token . charAt ( i ) , base ) ; if ( d = = - <int> ) throw new IllegalArgumentException ( <str> + token . charAt ( i ) ) ; uc = uc * base + d ; } return ( char ) uc ; } static private int readUnicodeChar ( PushbackReader r , int initch , int base , int length , boolean exact ) { int uc = Character . digit ( initch , base ) ; if ( uc = = - <int> ) throw new IllegalArgumentException ( <str> + ( char ) initch ) ; int i = <int> ; for ( ; i < length ; + + i ) { int ch = read1 ( r ) ; if ( ch = = - <int> | | isWhitespace ( ch ) | | isMacro ( ch ) ) { unread ( r , ch ) ; break ; } int d = Character . digit ( ch , base ) ; if ( d = = - <int> ) throw new IllegalArgumentException ( <str> + ( char ) ch ) ; uc = uc * base + d ; } if ( i ! = length & & exact ) throw new IllegalArgumentException ( <str> + i + <str> + length ) ; return uc ; } static private Object interpretToken ( String s ) { if ( s . equals ( <str> ) ) { return null ; } else if ( s . equals ( <str> ) ) { return RT . T ; } else if ( s . equals ( <str> ) ) { return RT . F ; } Object ret = null ; ret = matchSymbol ( s ) ; if ( ret ! = null ) return ret ; throw Util . runtimeException ( <str> + s ) ; } private static Object matchSymbol ( String s ) { Matcher m = symbolPat . matcher ( s ) ; if ( m . matches ( ) ) { int gc = m . groupCount ( ) ; String ns = m . group ( <int> ) ; String name = m . group ( <int> ) ; if ( ns ! = null & & ns . endsWith ( <str> ) | | name . endsWith ( <str> ) | | s . indexOf ( <str> , <int> ) ! = - <int> ) return null ; if ( s . startsWith ( <str> ) ) { Symbol ks = Symbol . intern ( s . substring ( <int> ) ) ; Namespace kns ; if ( ks . ns ! = null ) kns = Compiler . namespaceFor ( ks ) ; else kns = Compiler . currentNS ( ) ; if ( kns ! = null ) return Keyword . intern ( kns . name . name , ks . name ) ; else return null ; } boolean isKeyword = s . charAt ( <int> ) = = <str> ; Symbol sym = Symbol . intern ( s . substring ( isKeyword ? <int> : <int> ) ) ; if ( isKeyword ) return Keyword . intern ( sym ) ; return sym ; } return null ; } private static Object matchNumber ( String s ) { Matcher m = intPat . matcher ( s ) ; if ( m . matches ( ) ) { if ( m . group ( <int> ) ! = null ) { if ( m . group ( <int> ) ! = null ) return BigInt . ZERO ; return Numbers . num ( <int> ) ; } boolean negate = ( m . group ( <int> ) . equals ( <str> ) ) ; String n ; int radix = <int> ; if ( ( n = m . group ( <int> ) ) ! = null ) radix = <int> ; else if ( ( n = m . group ( <int> ) ) ! = null ) radix = <int> ; else if ( ( n = m . group ( <int> ) ) ! = null ) radix = <int> ; else if ( ( n = m . group ( <int> ) ) ! = null ) radix = Integer . parseInt ( m . group ( <int> ) ) ; if ( n = = null ) return null ; BigInteger bn = new BigInteger ( n , radix ) ; if ( negate ) bn = bn . negate ( ) ; if ( m . group ( <int> ) ! = null ) return BigInt . fromBigInteger ( bn ) ; return bn . bitLength ( ) < <int> ? Numbers . num ( bn . longValue ( ) ) : BigInt . fromBigInteger ( bn ) ; } m = floatPat . matcher ( s ) ; if ( m . matches ( ) ) { if ( m . group ( <int> ) ! = null ) return new BigDecimal ( m . group ( <int> ) ) ; return Double . parseDouble ( s ) ; } m = ratioPat . matcher ( s ) ; if ( m . matches ( ) ) { String numerator = m . group ( <int> ) ; if ( numerator . startsWith ( <str> ) ) numerator = numerator . substring ( <int> ) ; return Numbers . divide ( Numbers . reduceBigInt ( BigInt . fromBigInteger ( new BigInteger ( numerator ) ) ) , Numbers . reduceBigInt ( BigInt . fromBigInteger ( new BigInteger ( m . group ( <int> ) ) ) ) ) ; } return null ; } static private IFn getMacro ( int ch ) { if ( ch < macros . length ) return macros [ ch ] ; return null ; } static private boolean isMacro ( int ch ) { return ( ch < macros . length & & macros [ ch ] ! = null ) ; } static private boolean isTerminatingMacro ( int ch ) { return ( ch ! = <str> & & ch ! = <str> & & ch ! = <str> & & isMacro ( ch ) ) ; } public static class RegexReader extends AFn { static StringReader stringrdr = new StringReader ( ) ; public Object invoke ( Object reader , Object doublequote , Object opts , Object pendingForms ) { StringBuilder sb = new StringBuilder ( ) ; Reader r = ( Reader ) reader ; for ( int ch = read1 ( r ) ; ch ! = <str> ; ch = read1 ( r ) ) { if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; sb . append ( ( char ) ch ) ; if ( ch = = <str> ) { ch = read1 ( r ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; sb . append ( ( char ) ch ) ; } } return Pattern . compile ( sb . toString ( ) ) ; } } public static class StringReader extends AFn { public Object invoke ( Object reader , Object doublequote , Object opts , Object pendingForms ) { StringBuilder sb = new StringBuilder ( ) ; Reader r = ( Reader ) reader ; for ( int ch = read1 ( r ) ; ch ! = <str> ; ch = read1 ( r ) ) { if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; if ( ch = = <str> ) { ch = read1 ( r ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; switch ( ch ) { case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : break ; case <str> : break ; case <str> : ch = <str> ; break ; case <str> : ch = <str> ; break ; case <str> : { ch = read1 ( r ) ; if ( Character . digit ( ch , <int> ) = = - <int> ) throw Util . runtimeException ( <str> + ( char ) ch ) ; ch = readUnicodeChar ( ( PushbackReader ) r , ch , <int> , <int> , true ) ; break ; } default : { if ( Character . isDigit ( ch ) ) { ch = readUnicodeChar ( ( PushbackReader ) r , ch , <int> , <int> , false ) ; if ( ch > <oct> ) throw Util . runtimeException ( <str> ) ; } else throw Util . runtimeException ( <str> + ( char ) ch ) ; } } } sb . append ( ( char ) ch ) ; } return sb . toString ( ) ; } } public static class CommentReader extends AFn { public Object invoke ( Object reader , Object semicolon , Object opts , Object pendingForms ) { Reader r = ( Reader ) reader ; int ch ; do { ch = read1 ( r ) ; } while ( ch ! = - <int> & & ch ! = <str> & & ch ! = <str> ) ; return r ; } } public static class DiscardReader extends AFn { public Object invoke ( Object reader , Object underscore , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; return r ; } } public static class WrappingReader extends AFn { final Symbol sym ; public WrappingReader ( Symbol sym ) { this . sym = sym ; } public Object invoke ( Object reader , Object quote , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; Object o = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; return RT . list ( sym , o ) ; } } public static class DeprecatedWrappingReader extends AFn { final Symbol sym ; final String macro ; public DeprecatedWrappingReader ( Symbol sym , String macro ) { this . sym = sym ; this . macro = macro ; } public Object invoke ( Object reader , Object quote , Object opts , Object pendingForms ) { System . out . println ( <str> + macro + <str> + sym . getName ( ) + <str> ) ; PushbackReader r = ( PushbackReader ) reader ; Object o = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; return RT . list ( sym , o ) ; } } public static class VarReader extends AFn { public Object invoke ( Object reader , Object quote , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; Object o = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; return RT . list ( THE_VAR , o ) ; } } public static class DispatchReader extends AFn { public Object invoke ( Object reader , Object hash , Object opts , Object pendingForms ) { int ch = read1 ( ( Reader ) reader ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; IFn fn = dispatchMacros [ ch ] ; if ( fn = = null ) { unread ( ( PushbackReader ) reader , ch ) ; pendingForms = ensurePending ( pendingForms ) ; Object result = ctorReader . invoke ( reader , ch , opts , pendingForms ) ; if ( result ! = null ) return result ; else throw Util . runtimeException ( String . format ( <str> , ( char ) ch ) ) ; } return fn . invoke ( reader , ch , opts , pendingForms ) ; } } static Symbol garg ( int n ) { return Symbol . intern ( null , ( n = = - <int> ? <str> : ( <str> + n ) ) + <str> + RT . nextID ( ) + <str> ) ; } public static class FnReader extends AFn { public Object invoke ( Object reader , Object lparen , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; if ( ARG_ENV . deref ( ) ! = null ) throw new IllegalStateException ( <str> ) ; try { Var . pushThreadBindings ( RT . map ( ARG_ENV , PersistentTreeMap . EMPTY ) ) ; unread ( r , <str> ) ; Object form = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; PersistentVector args = PersistentVector . EMPTY ; PersistentTreeMap argsyms = ( PersistentTreeMap ) ARG_ENV . deref ( ) ; ISeq rargs = argsyms . rseq ( ) ; if ( rargs ! = null ) { int higharg = ( Integer ) ( ( Map . Entry ) rargs . first ( ) ) . getKey ( ) ; if ( higharg > <int> ) { for ( int i = <int> ; i < = higharg ; + + i ) { Object sym = argsyms . valAt ( i ) ; if ( sym = = null ) sym = garg ( i ) ; args = args . cons ( sym ) ; } } Object restsym = argsyms . valAt ( - <int> ) ; if ( restsym ! = null ) { args = args . cons ( Compiler . _AMP_ ) ; args = args . cons ( restsym ) ; } } return RT . list ( Compiler . FN , args , form ) ; } finally { Var . popThreadBindings ( ) ; } } } static Symbol registerArg ( int n ) { PersistentTreeMap argsyms = ( PersistentTreeMap ) ARG_ENV . deref ( ) ; if ( argsyms = = null ) { throw new IllegalStateException ( <str> ) ; } Symbol ret = ( Symbol ) argsyms . valAt ( n ) ; if ( ret = = null ) { ret = garg ( n ) ; ARG_ENV . set ( argsyms . assoc ( n , ret ) ) ; } return ret ; } static class ArgReader extends AFn { public Object invoke ( Object reader , Object pct , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; if ( ARG_ENV . deref ( ) = = null ) { return interpretToken ( readToken ( r , <str> ) ) ; } int ch = read1 ( r ) ; unread ( r , ch ) ; if ( ch = = - <int> | | isWhitespace ( ch ) | | isTerminatingMacro ( ch ) ) { return registerArg ( <int> ) ; } Object n = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; if ( n . equals ( Compiler . _AMP_ ) ) return registerArg ( - <int> ) ; if ( ! ( n instanceof Number ) ) throw new IllegalStateException ( <str> ) ; return registerArg ( ( ( Number ) n ) . intValue ( ) ) ; } } public static class MetaReader extends AFn { public Object invoke ( Object reader , Object caret , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; int line = - <int> ; int column = - <int> ; if ( r instanceof LineNumberingPushbackReader ) { line = ( ( LineNumberingPushbackReader ) r ) . getLineNumber ( ) ; column = ( ( LineNumberingPushbackReader ) r ) . getColumnNumber ( ) - <int> ; } pendingForms = ensurePending ( pendingForms ) ; Object meta = read ( r , true , null , true , opts , pendingForms ) ; if ( meta instanceof Symbol | | meta instanceof String ) meta = RT . map ( RT . TAG_KEY , meta ) ; else if ( meta instanceof Keyword ) meta = RT . map ( meta , RT . T ) ; else if ( ! ( meta instanceof IPersistentMap ) ) throw new IllegalArgumentException ( <str> ) ; Object o = read ( r , true , null , true , opts , pendingForms ) ; if ( o instanceof IMeta ) { if ( line ! = - <int> & & o instanceof ISeq ) { meta = ( ( IPersistentMap ) meta ) . assoc ( RT . LINE_KEY , line ) . assoc ( RT . COLUMN_KEY , column ) ; } if ( o instanceof IReference ) { ( ( IReference ) o ) . resetMeta ( ( IPersistentMap ) meta ) ; return o ; } Object ometa = RT . meta ( o ) ; for ( ISeq s = RT . seq ( meta ) ; s ! = null ; s = s . next ( ) ) { IMapEntry kv = ( IMapEntry ) s . first ( ) ; ometa = RT . assoc ( ometa , kv . getKey ( ) , kv . getValue ( ) ) ; } return ( ( IObj ) o ) . withMeta ( ( IPersistentMap ) ometa ) ; } else throw new IllegalArgumentException ( <str> ) ; } } public static class SyntaxQuoteReader extends AFn { public Object invoke ( Object reader , Object backquote , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; try { Var . pushThreadBindings ( RT . map ( GENSYM_ENV , PersistentHashMap . EMPTY ) ) ; Object form = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; return syntaxQuote ( form ) ; } finally { Var . popThreadBindings ( ) ; } } static Object syntaxQuote ( Object form ) { Object ret ; if ( Compiler . isSpecial ( form ) ) ret = RT . list ( Compiler . QUOTE , form ) ; else if ( form instanceof Symbol ) { Symbol sym = ( Symbol ) form ; if ( sym . ns = = null & & sym . name . endsWith ( <str> ) ) { IPersistentMap gmap = ( IPersistentMap ) GENSYM_ENV . deref ( ) ; if ( gmap = = null ) throw new IllegalStateException ( <str> ) ; Symbol gs = ( Symbol ) gmap . valAt ( sym ) ; if ( gs = = null ) GENSYM_ENV . set ( gmap . assoc ( sym , gs = Symbol . intern ( null , sym . name . substring ( <int> , sym . name . length ( ) - <int> ) + <str> + RT . nextID ( ) + <str> ) ) ) ; sym = gs ; } else if ( sym . ns = = null & & sym . name . endsWith ( <str> ) ) { Symbol csym = Symbol . intern ( null , sym . name . substring ( <int> , sym . name . length ( ) - <int> ) ) ; csym = Compiler . resolveSymbol ( csym ) ; sym = Symbol . intern ( null , csym . name . concat ( <str> ) ) ; } else if ( sym . ns = = null & & sym . name . startsWith ( <str> ) ) { } else { Object maybeClass = null ; if ( sym . ns ! = null ) maybeClass = Compiler . currentNS ( ) . getMapping ( Symbol . intern ( null , sym . ns ) ) ; if ( maybeClass instanceof Class ) { sym = Symbol . intern ( ( ( Class ) maybeClass ) . getName ( ) , sym . name ) ; } else sym = Compiler . resolveSymbol ( sym ) ; } ret = RT . list ( Compiler . QUOTE , sym ) ; } else if ( isUnquote ( form ) ) return RT . second ( form ) ; else if ( isUnquoteSplicing ( form ) ) throw new IllegalStateException ( <str> ) ; else if ( form instanceof IPersistentCollection ) { if ( form instanceof IRecord ) ret = form ; else if ( form instanceof IPersistentMap ) { IPersistentVector keyvals = flattenMap ( form ) ; ret = RT . list ( APPLY , HASHMAP , RT . list ( SEQ , RT . cons ( CONCAT , sqExpandList ( keyvals . seq ( ) ) ) ) ) ; } else if ( form instanceof IPersistentVector ) { ret = RT . list ( APPLY , VECTOR , RT . list ( SEQ , RT . cons ( CONCAT , sqExpandList ( ( ( IPersistentVector ) form ) . seq ( ) ) ) ) ) ; } else if ( form instanceof IPersistentSet ) { ret = RT . list ( APPLY , HASHSET , RT . list ( SEQ , RT . cons ( CONCAT , sqExpandList ( ( ( IPersistentSet ) form ) . seq ( ) ) ) ) ) ; } else if ( form instanceof ISeq | | form instanceof IPersistentList ) { ISeq seq = RT . seq ( form ) ; if ( seq = = null ) ret = RT . cons ( LIST , null ) ; else ret = RT . list ( SEQ , RT . cons ( CONCAT , sqExpandList ( seq ) ) ) ; } else throw new UnsupportedOperationException ( <str> ) ; } else if ( form instanceof Keyword | | form instanceof Number | | form instanceof Character | | form instanceof String ) ret = form ; else ret = RT . list ( Compiler . QUOTE , form ) ; if ( form instanceof IObj & & RT . meta ( form ) ! = null ) { IPersistentMap newMeta = ( ( IObj ) form ) . meta ( ) . without ( RT . LINE_KEY ) . without ( RT . COLUMN_KEY ) ; if ( newMeta . count ( ) > <int> ) return RT . list ( WITH_META , ret , syntaxQuote ( ( ( IObj ) form ) . meta ( ) ) ) ; } return ret ; } private static ISeq sqExpandList ( ISeq seq ) { PersistentVector ret = PersistentVector . EMPTY ; for ( ; seq ! = null ; seq = seq . next ( ) ) { Object item = seq . first ( ) ; if ( isUnquote ( item ) ) ret = ret . cons ( RT . list ( LIST , RT . second ( item ) ) ) ; else if ( isUnquoteSplicing ( item ) ) ret = ret . cons ( RT . second ( item ) ) ; else ret = ret . cons ( RT . list ( LIST , syntaxQuote ( item ) ) ) ; } return ret . seq ( ) ; } private static IPersistentVector flattenMap ( Object form ) { IPersistentVector keyvals = PersistentVector . EMPTY ; for ( ISeq s = RT . seq ( form ) ; s ! = null ; s = s . next ( ) ) { IMapEntry e = ( IMapEntry ) s . first ( ) ; keyvals = ( IPersistentVector ) keyvals . cons ( e . key ( ) ) ; keyvals = ( IPersistentVector ) keyvals . cons ( e . val ( ) ) ; } return keyvals ; } } static boolean isUnquoteSplicing ( Object form ) { return form instanceof ISeq & & Util . equals ( RT . first ( form ) , UNQUOTE_SPLICING ) ; } static boolean isUnquote ( Object form ) { return form instanceof ISeq & & Util . equals ( RT . first ( form ) , UNQUOTE ) ; } static class UnquoteReader extends AFn { public Object invoke ( Object reader , Object comma , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; int ch = read1 ( r ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; pendingForms = ensurePending ( pendingForms ) ; if ( ch = = <str> ) { Object o = read ( r , true , null , true , opts , pendingForms ) ; return RT . list ( UNQUOTE_SPLICING , o ) ; } else { unread ( r , ch ) ; Object o = read ( r , true , null , true , opts , pendingForms ) ; return RT . list ( UNQUOTE , o ) ; } } } public static class CharacterReader extends AFn { public Object invoke ( Object reader , Object backslash , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; int ch = read1 ( r ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; String token = readToken ( r , ( char ) ch ) ; if ( token . length ( ) = = <int> ) return Character . valueOf ( token . charAt ( <int> ) ) ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . equals ( <str> ) ) return <str> ; else if ( token . startsWith ( <str> ) ) { char c = ( char ) readUnicodeChar ( token , <int> , <int> , <int> ) ; if ( c > = <str> & & c < = <str> ) throw Util . runtimeException ( <str> + Integer . toString ( c , <int> ) ) ; return c ; } else if ( token . startsWith ( <str> ) ) { int len = token . length ( ) - <int> ; if ( len > <int> ) throw Util . runtimeException ( <str> + len ) ; int uc = readUnicodeChar ( token , <int> , len , <int> ) ; if ( uc > <oct> ) throw Util . runtimeException ( <str> ) ; return ( char ) uc ; } throw Util . runtimeException ( <str> + token ) ; } } public static class ListReader extends AFn { public Object invoke ( Object reader , Object leftparen , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; int line = - <int> ; int column = - <int> ; if ( r instanceof LineNumberingPushbackReader ) { line = ( ( LineNumberingPushbackReader ) r ) . getLineNumber ( ) ; column = ( ( LineNumberingPushbackReader ) r ) . getColumnNumber ( ) - <int> ; } List list = readDelimitedList ( <str> , r , true , opts , ensurePending ( pendingForms ) ) ; if ( list . isEmpty ( ) ) return PersistentList . EMPTY ; IObj s = ( IObj ) PersistentList . create ( list ) ; if ( line ! = - <int> ) { return s . withMeta ( RT . map ( RT . LINE_KEY , line , RT . COLUMN_KEY , column ) ) ; } else return s ; } } public static class EvalReader extends AFn { public Object invoke ( Object reader , Object eq , Object opts , Object pendingForms ) { if ( ! RT . booleanCast ( RT . READEVAL . deref ( ) ) ) { throw Util . runtimeException ( <str> ) ; } PushbackReader r = ( PushbackReader ) reader ; Object o = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; if ( o instanceof Symbol ) { return RT . classForName ( o . toString ( ) ) ; } else if ( o instanceof IPersistentList ) { Symbol fs = ( Symbol ) RT . first ( o ) ; if ( fs . equals ( THE_VAR ) ) { Symbol vs = ( Symbol ) RT . second ( o ) ; return RT . var ( vs . ns , vs . name ) ; } if ( fs . name . endsWith ( <str> ) ) { Object [ ] args = RT . toArray ( RT . next ( o ) ) ; return Reflector . invokeConstructor ( RT . classForName ( fs . name . substring ( <int> , fs . name . length ( ) - <int> ) ) , args ) ; } if ( Compiler . namesStaticMember ( fs ) ) { Object [ ] args = RT . toArray ( RT . next ( o ) ) ; return Reflector . invokeStaticMethod ( fs . ns , fs . name , args ) ; } Object v = Compiler . maybeResolveIn ( Compiler . currentNS ( ) , fs ) ; if ( v instanceof Var ) { return ( ( IFn ) v ) . applyTo ( RT . next ( o ) ) ; } throw Util . runtimeException ( <str> + fs ) ; } else throw new IllegalArgumentException ( <str> ) ; } } public static class VectorReader extends AFn { public Object invoke ( Object reader , Object leftparen , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; return LazilyPersistentVector . create ( readDelimitedList ( <str> , r , true , opts , ensurePending ( pendingForms ) ) ) ; } } public static class MapReader extends AFn { public Object invoke ( Object reader , Object leftparen , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; Object [ ] a = readDelimitedList ( <str> , r , true , opts , ensurePending ( pendingForms ) ) . toArray ( ) ; if ( ( a . length & <int> ) = = <int> ) throw Util . runtimeException ( <str> ) ; return RT . map ( a ) ; } } public static class SetReader extends AFn { public Object invoke ( Object reader , Object leftbracket , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; return PersistentHashSet . createWithCheck ( readDelimitedList ( <str> , r , true , opts , ensurePending ( pendingForms ) ) ) ; } } public static class UnmatchedDelimiterReader extends AFn { public Object invoke ( Object reader , Object rightdelim , Object opts , Object pendingForms ) { throw Util . runtimeException ( <str> + rightdelim ) ; } } public static class UnreadableReader extends AFn { public Object invoke ( Object reader , Object leftangle , Object opts , Object pendingForms ) { throw Util . runtimeException ( <str> ) ; } } private static final Object READ_EOF = new Object ( ) ; private static final Object READ_FINISHED = new Object ( ) ; public static List readDelimitedList ( char delim , PushbackReader r , boolean isRecursive , Object opts , Object pendingForms ) { final int firstline = ( r instanceof LineNumberingPushbackReader ) ? ( ( LineNumberingPushbackReader ) r ) . getLineNumber ( ) : - <int> ; ArrayList a = new ArrayList ( ) ; for ( ; ; ) { Object form = read ( r , false , READ_EOF , delim , READ_FINISHED , isRecursive , opts , pendingForms ) ; if ( form = = READ_EOF ) { if ( firstline < <int> ) throw Util . runtimeException ( <str> ) ; else throw Util . runtimeException ( <str> + firstline ) ; } else if ( form = = READ_FINISHED ) { return a ; } a . add ( form ) ; } } public static class CtorReader extends AFn { public Object invoke ( Object reader , Object firstChar , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; pendingForms = ensurePending ( pendingForms ) ; Object name = read ( r , true , null , false , opts , pendingForms ) ; if ( ! ( name instanceof Symbol ) ) throw new RuntimeException ( <str> ) ; Symbol sym = ( Symbol ) name ; Object form = read ( r , true , null , true , opts , pendingForms ) ; if ( isPreserveReadCond ( opts ) | | RT . suppressRead ( ) ) { return TaggedLiteral . create ( sym , form ) ; } else { return sym . getName ( ) . contains ( <str> ) ? readRecord ( form , sym , opts , pendingForms ) : readTagged ( form , sym , opts , pendingForms ) ; } } private Object readTagged ( Object o , Symbol tag , Object opts , Object pendingForms ) { ILookup data_readers = ( ILookup ) RT . DATA_READERS . deref ( ) ; IFn data_reader = ( IFn ) RT . get ( data_readers , tag ) ; if ( data_reader = = null ) { data_readers = ( ILookup ) RT . DEFAULT_DATA_READERS . deref ( ) ; data_reader = ( IFn ) RT . get ( data_readers , tag ) ; if ( data_reader = = null ) { IFn default_reader = ( IFn ) RT . DEFAULT_DATA_READER_FN . deref ( ) ; if ( default_reader ! = null ) return default_reader . invoke ( tag , o ) ; else throw new RuntimeException ( <str> + tag . toString ( ) ) ; } } return data_reader . invoke ( o ) ; } private Object readRecord ( Object form , Symbol recordName , Object opts , Object pendingForms ) { boolean readeval = RT . booleanCast ( RT . READEVAL . deref ( ) ) ; if ( ! readeval ) { throw Util . runtimeException ( <str> ) ; } Class recordClass = RT . classForNameNonLoading ( recordName . toString ( ) ) ; boolean shortForm = true ; if ( form instanceof IPersistentMap ) { shortForm = false ; } else if ( form instanceof IPersistentVector ) { shortForm = true ; } else { throw Util . runtimeException ( <str> + recordName + <str> ) ; } Object ret = null ; Constructor [ ] allctors = ( ( Class ) recordClass ) . getConstructors ( ) ; if ( shortForm ) { IPersistentVector recordEntries = ( IPersistentVector ) form ; boolean ctorFound = false ; for ( Constructor ctor : allctors ) if ( ctor . getParameterTypes ( ) . length = = recordEntries . count ( ) ) ctorFound = true ; if ( ! ctorFound ) throw Util . runtimeException ( <str> + recordClass . toString ( ) + <str> + recordEntries . count ( ) ) ; ret = Reflector . invokeConstructor ( recordClass , RT . toArray ( recordEntries ) ) ; } else { IPersistentMap vals = ( IPersistentMap ) form ; for ( ISeq s = RT . keys ( vals ) ; s ! = null ; s = s . next ( ) ) { if ( ! ( s . first ( ) instanceof Keyword ) ) throw Util . runtimeException ( <str> + s . first ( ) . toString ( ) ) ; } ret = Reflector . invokeStaticMethod ( recordClass , <str> , new Object [ ] { vals } ) ; } return ret ; } } static boolean isPreserveReadCond ( Object opts ) { if ( RT . booleanCast ( READ_COND_ENV . deref ( ) ) & & opts instanceof IPersistentMap ) { Object readCond = ( ( IPersistentMap ) opts ) . valAt ( OPT_READ_COND ) ; return COND_PRESERVE . equals ( readCond ) ; } else return false ; } public static class ConditionalReader extends AFn { final static private Object READ_STARTED = new Object ( ) ; final static public Keyword DEFAULT_FEATURE = Keyword . intern ( null , <str> ) ; final static public IPersistentSet RESERVED_FEATURES = RT . set ( Keyword . intern ( null , <str> ) , Keyword . intern ( null , <str> ) ) ; public static boolean hasFeature ( Object feature , Object opts ) { if ( ! ( feature instanceof Keyword ) ) throw Util . runtimeException ( <str> + feature ) ; if ( DEFAULT_FEATURE . equals ( feature ) ) return true ; IPersistentSet custom = ( IPersistentSet ) ( ( IPersistentMap ) opts ) . valAt ( OPT_FEATURES ) ; return custom ! = null & & custom . contains ( feature ) ; } public static Object readCondDelimited ( PushbackReader r , boolean splicing , Object opts , Object pendingForms ) { Object result = READ_STARTED ; Object form ; boolean toplevel = ( pendingForms = = null ) ; pendingForms = ensurePending ( pendingForms ) ; final int firstline = ( r instanceof LineNumberingPushbackReader ) ? ( ( LineNumberingPushbackReader ) r ) . getLineNumber ( ) : - <int> ; for ( ; ; ) { if ( result = = READ_STARTED ) { form = read ( r , false , READ_EOF , <str> , READ_FINISHED , true , opts , pendingForms ) ; if ( form = = READ_EOF ) { if ( firstline < <int> ) throw Util . runtimeException ( <str> ) ; else throw Util . runtimeException ( <str> + firstline ) ; } else if ( form = = READ_FINISHED ) { break ; } if ( RESERVED_FEATURES . contains ( form ) ) throw Util . runtimeException ( <str> + form + <str> ) ; if ( hasFeature ( form , opts ) ) { form = read ( r , false , READ_EOF , <str> , READ_FINISHED , true , opts , pendingForms ) ; if ( form = = READ_EOF ) { if ( firstline < <int> ) throw Util . runtimeException ( <str> ) ; else throw Util . runtimeException ( <str> + firstline ) ; } else if ( form = = READ_FINISHED ) { if ( firstline < <int> ) throw Util . runtimeException ( <str> ) ; else throw Util . runtimeException ( <str> + firstline + <str> ) ; } else { result = form ; } } } try { Var . pushThreadBindings ( RT . map ( RT . SUPPRESS_READ , RT . T ) ) ; form = read ( r , false , READ_EOF , <str> , READ_FINISHED , true , opts , pendingForms ) ; if ( form = = READ_EOF ) { if ( firstline < <int> ) throw Util . runtimeException ( <str> ) ; else throw Util . runtimeException ( <str> + firstline ) ; } else if ( form = = READ_FINISHED ) { break ; } } finally { Var . popThreadBindings ( ) ; } } if ( result = = READ_STARTED ) return r ; if ( splicing ) { if ( ! ( result instanceof List ) ) throw Util . runtimeException ( <str> ) ; if ( toplevel ) throw Util . runtimeException ( <str> ) ; ( ( List ) pendingForms ) . addAll ( <int> , ( List ) result ) ; return r ; } else { return result ; } } ; private static void checkConditionalAllowed ( Object opts ) { IPersistentMap mopts = ( IPersistentMap ) opts ; if ( ! ( opts ! = null & & ( COND_ALLOW . equals ( mopts . valAt ( OPT_READ_COND ) ) | | COND_PRESERVE . equals ( mopts . valAt ( OPT_READ_COND ) ) ) ) ) throw Util . runtimeException ( <str> ) ; } public Object invoke ( Object reader , Object mode , Object opts , Object pendingForms ) { checkConditionalAllowed ( opts ) ; PushbackReader r = ( PushbackReader ) reader ; int ch = read1 ( r ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; boolean splicing = false ; if ( ch = = <str> ) { splicing = true ; ch = read1 ( r ) ; } while ( isWhitespace ( ch ) ) ch = read1 ( r ) ; if ( ch = = - <int> ) throw Util . runtimeException ( <str> ) ; if ( ch ! = <str> ) throw Util . runtimeException ( <str> ) ; try { Var . pushThreadBindings ( RT . map ( READ_COND_ENV , RT . T ) ) ; if ( isPreserveReadCond ( opts ) ) { IFn listReader = getMacro ( ch ) ; Object form = listReader . invoke ( r , ch , opts , ensurePending ( pendingForms ) ) ; return ReaderConditional . create ( form , splicing ) ; } else { return readCondDelimited ( r , splicing , opts , pendingForms ) ; } } finally { Var . popThreadBindings ( ) ; } } } } 
