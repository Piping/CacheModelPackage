package org . elasticsearch . cluster . routing . allocation ; import com . carrotsearch . hppc . cursors . ObjectCursor ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . EmptyClusterInfoService ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . RoutingNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . ShardRoutingState ; import org . elasticsearch . cluster . routing . allocation . allocator . BalancedShardsAllocator ; import org . elasticsearch . cluster . routing . allocation . allocator . ShardsAllocator ; import org . elasticsearch . cluster . routing . allocation . allocator . ShardsAllocators ; import org . elasticsearch . cluster . routing . allocation . decider . ClusterRebalanceAllocationDecider ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . test . ESAllocationTestCase ; import org . elasticsearch . test . gateway . NoopGatewayAllocator ; import org . hamcrest . Matchers ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . cluster . routing . ShardRoutingState . STARTED ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; public class BalanceConfigurationTests extends ESAllocationTestCase { private final ESLogger logger = Loggers . getLogger ( BalanceConfigurationTests . class ) ; final int numberOfNodes = <int> ; final int numberOfIndices = <int> ; final int numberOfShards = <int> ; final int numberOfReplicas = <int> ; public void testIndexBalance ( ) { final float indexBalance = <float> ; final float replicaBalance = <float> ; final float balanceTreshold = <float> ; Settings . Builder settings = settingsBuilder ( ) ; settings . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , ClusterRebalanceAllocationDecider . ClusterRebalanceType . ALWAYS . toString ( ) ) ; settings . put ( BalancedShardsAllocator . SETTING_INDEX_BALANCE_FACTOR , indexBalance ) ; settings . put ( BalancedShardsAllocator . SETTING_SHARD_BALANCE_FACTOR , replicaBalance ) ; settings . put ( BalancedShardsAllocator . SETTING_THRESHOLD , balanceTreshold ) ; AllocationService strategy = createAllocationService ( settings . build ( ) ) ; ClusterState clusterState = initCluster ( strategy ) ; assertIndexBalance ( logger , clusterState . getRoutingNodes ( ) , numberOfNodes , numberOfIndices , numberOfReplicas , numberOfShards , balanceTreshold ) ; clusterState = addNode ( clusterState , strategy ) ; assertIndexBalance ( logger , clusterState . getRoutingNodes ( ) , numberOfNodes + <int> , numberOfIndices , numberOfReplicas , numberOfShards , balanceTreshold ) ; clusterState = removeNodes ( clusterState , strategy ) ; assertIndexBalance ( logger , clusterState . getRoutingNodes ( ) , ( numberOfNodes + <int> ) - ( numberOfNodes + <int> ) / <int> , numberOfIndices , numberOfReplicas , numberOfShards , balanceTreshold ) ; } public void testReplicaBalance ( ) { final float indexBalance = <float> ; final float replicaBalance = <float> ; final float balanceTreshold = <float> ; Settings . Builder settings = settingsBuilder ( ) ; settings . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , ClusterRebalanceAllocationDecider . ClusterRebalanceType . ALWAYS . toString ( ) ) ; settings . put ( BalancedShardsAllocator . SETTING_INDEX_BALANCE_FACTOR , indexBalance ) ; settings . put ( BalancedShardsAllocator . SETTING_SHARD_BALANCE_FACTOR , replicaBalance ) ; settings . put ( BalancedShardsAllocator . SETTING_THRESHOLD , balanceTreshold ) ; AllocationService strategy = createAllocationService ( settings . build ( ) ) ; ClusterState clusterState = initCluster ( strategy ) ; assertReplicaBalance ( logger , clusterState . getRoutingNodes ( ) , numberOfNodes , numberOfIndices , numberOfReplicas , numberOfShards , balanceTreshold ) ; clusterState = addNode ( clusterState , strategy ) ; assertReplicaBalance ( logger , clusterState . getRoutingNodes ( ) , numberOfNodes + <int> , numberOfIndices , numberOfReplicas , numberOfShards , balanceTreshold ) ; clusterState = removeNodes ( clusterState , strategy ) ; assertReplicaBalance ( logger , clusterState . getRoutingNodes ( ) , ( numberOfNodes + <int> ) - ( numberOfNodes + <int> ) / <int> , numberOfIndices , numberOfReplicas , numberOfShards , balanceTreshold ) ; } private ClusterState initCluster ( AllocationService strategy ) { MetaData . Builder metaDataBuilder = MetaData . builder ( ) ; RoutingTable . Builder routingTableBuilder = RoutingTable . builder ( ) ; for ( int i = <int> ; i < numberOfIndices ; i + + ) { IndexMetaData . Builder index = IndexMetaData . builder ( <str> + i ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( numberOfShards ) . numberOfReplicas ( numberOfReplicas ) ; metaDataBuilder = metaDataBuilder . put ( index ) ; } MetaData metaData = metaDataBuilder . build ( ) ; for ( ObjectCursor < IndexMetaData > cursor : metaData . indices ( ) . values ( ) ) { routingTableBuilder . addAsNew ( cursor . value ) ; } RoutingTable routingTable = routingTableBuilder . build ( ) ; logger . info ( <str> + numberOfNodes + <str> ) ; DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( ) ; for ( int i = <int> ; i < numberOfNodes ; i + + ) { nodes . put ( newNode ( <str> + i ) ) ; } ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . nodes ( nodes ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; logger . info ( <str> ) ; routingNodes = clusterState . getRoutingNodes ( ) ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; logger . info ( <str> ) ; routingNodes = clusterState . getRoutingNodes ( ) ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; logger . info ( <str> ) ; RoutingTable prev = routingTable ; while ( true ) { routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; if ( routingTable = = prev ) break ; prev = routingTable ; } return clusterState ; } private ClusterState addNode ( ClusterState clusterState , AllocationService strategy ) { logger . info ( <str> ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . put ( newNode ( <str> + numberOfNodes ) ) ) . build ( ) ; RoutingTable routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; RoutingTable prev = routingTable ; while ( true ) { routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; if ( routingTable = = prev ) break ; prev = routingTable ; } return clusterState ; } private ClusterState removeNodes ( ClusterState clusterState , AllocationService strategy ) { logger . info ( <str> + ( numberOfNodes + <int> ) / <int> + <str> ) ; DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( clusterState . nodes ( ) ) ; for ( int i = ( numberOfNodes + <int> ) / <int> ; i < = numberOfNodes ; i + + ) { nodes . remove ( <str> + i ) ; } clusterState = ClusterState . builder ( clusterState ) . nodes ( nodes . build ( ) ) . build ( ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; logger . info ( <str> ) ; RoutingTable routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; logger . info ( <str> ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; logger . info ( <str> ) ; RoutingTable prev = routingTable ; while ( true ) { routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; if ( routingTable = = prev ) break ; prev = routingTable ; } return clusterState ; } private void assertReplicaBalance ( ESLogger logger , RoutingNodes nodes , int numberOfNodes , int numberOfIndices , int numberOfReplicas , int numberOfShards , float treshold ) { final int numShards = numberOfIndices * numberOfShards * ( numberOfReplicas + <int> ) ; final float avgNumShards = ( float ) ( numShards ) / ( float ) ( numberOfNodes ) ; final int minAvgNumberOfShards = Math . round ( Math . round ( Math . floor ( avgNumShards - treshold ) ) ) ; final int maxAvgNumberOfShards = Math . round ( Math . round ( Math . ceil ( avgNumShards + treshold ) ) ) ; for ( RoutingNode node : nodes ) { assertThat ( node . shardsWithState ( STARTED ) . size ( ) , Matchers . greaterThanOrEqualTo ( minAvgNumberOfShards ) ) ; assertThat ( node . shardsWithState ( STARTED ) . size ( ) , Matchers . lessThanOrEqualTo ( maxAvgNumberOfShards ) ) ; } } private void assertIndexBalance ( ESLogger logger , RoutingNodes nodes , int numberOfNodes , int numberOfIndices , int numberOfReplicas , int numberOfShards , float treshold ) { final int numShards = numberOfShards * ( numberOfReplicas + <int> ) ; final float avgNumShards = ( float ) ( numShards ) / ( float ) ( numberOfNodes ) ; final int minAvgNumberOfShards = Math . round ( Math . round ( Math . floor ( avgNumShards - treshold ) ) ) ; final int maxAvgNumberOfShards = Math . round ( Math . round ( Math . ceil ( avgNumShards + treshold ) ) ) ; for ( ObjectCursor < String > index : nodes . getRoutingTable ( ) . indicesRouting ( ) . keys ( ) ) { for ( RoutingNode node : nodes ) { assertThat ( node . shardsWithState ( index . value , STARTED ) . size ( ) , Matchers . greaterThanOrEqualTo ( minAvgNumberOfShards ) ) ; assertThat ( node . shardsWithState ( index . value , STARTED ) . size ( ) , Matchers . lessThanOrEqualTo ( maxAvgNumberOfShards ) ) ; } } } private void assertPrimaryBalance ( ESLogger logger , RoutingNodes nodes , int numberOfNodes , int numberOfIndices , int numberOfReplicas , int numberOfShards , float treshold ) { final int numShards = numberOfShards ; final float avgNumShards = ( float ) ( numShards ) / ( float ) ( numberOfNodes ) ; final int minAvgNumberOfShards = Math . round ( Math . round ( Math . floor ( avgNumShards - treshold ) ) ) ; final int maxAvgNumberOfShards = Math . round ( Math . round ( Math . ceil ( avgNumShards + treshold ) ) ) ; for ( ObjectCursor < String > index : nodes . getRoutingTable ( ) . indicesRouting ( ) . keys ( ) ) { for ( RoutingNode node : nodes ) { int primaries = <int> ; for ( ShardRouting shard : node . shardsWithState ( index . value , STARTED ) ) { primaries + = shard . primary ( ) ? <int> : <int> ; } assertThat ( primaries , Matchers . greaterThanOrEqualTo ( minAvgNumberOfShards ) ) ; assertThat ( primaries , Matchers . lessThanOrEqualTo ( maxAvgNumberOfShards ) ) ; } } } public void testPersistedSettings ( ) { Settings . Builder settings = settingsBuilder ( ) ; settings . put ( BalancedShardsAllocator . SETTING_INDEX_BALANCE_FACTOR , <float> ) ; settings . put ( BalancedShardsAllocator . SETTING_SHARD_BALANCE_FACTOR , <float> ) ; settings . put ( BalancedShardsAllocator . SETTING_THRESHOLD , <float> ) ; final NodeSettingsService . Listener [ ] listeners = new NodeSettingsService . Listener [ <int> ] ; NodeSettingsService service = new NodeSettingsService ( settingsBuilder ( ) . build ( ) ) { @Override public void addListener ( Listener listener ) { assertNull ( <str> , listeners [ <int> ] ) ; listeners [ <int> ] = listener ; } } ; BalancedShardsAllocator allocator = new BalancedShardsAllocator ( settings . build ( ) , service ) ; assertThat ( allocator . getIndexBalance ( ) , Matchers . equalTo ( <float> ) ) ; assertThat ( allocator . getShardBalance ( ) , Matchers . equalTo ( <float> ) ) ; assertThat ( allocator . getThreshold ( ) , Matchers . equalTo ( <float> ) ) ; settings = settingsBuilder ( ) ; settings . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , ClusterRebalanceAllocationDecider . ClusterRebalanceType . ALWAYS . toString ( ) ) ; listeners [ <int> ] . onRefreshSettings ( settings . build ( ) ) ; assertThat ( allocator . getIndexBalance ( ) , Matchers . equalTo ( <float> ) ) ; assertThat ( allocator . getShardBalance ( ) , Matchers . equalTo ( <float> ) ) ; assertThat ( allocator . getThreshold ( ) , Matchers . equalTo ( <float> ) ) ; settings = settingsBuilder ( ) ; settings . put ( BalancedShardsAllocator . SETTING_INDEX_BALANCE_FACTOR , <float> ) ; settings . put ( BalancedShardsAllocator . SETTING_SHARD_BALANCE_FACTOR , <float> ) ; settings . put ( BalancedShardsAllocator . SETTING_THRESHOLD , <float> ) ; listeners [ <int> ] . onRefreshSettings ( settings . build ( ) ) ; assertThat ( allocator . getIndexBalance ( ) , Matchers . equalTo ( <float> ) ) ; assertThat ( allocator . getShardBalance ( ) , Matchers . equalTo ( <float> ) ) ; assertThat ( allocator . getThreshold ( ) , Matchers . equalTo ( <float> ) ) ; } public void testNoRebalanceOnPrimaryOverload ( ) { Settings . Builder settings = settingsBuilder ( ) ; AllocationService strategy = new AllocationService ( settings . build ( ) , randomAllocationDeciders ( settings . build ( ) , new NodeSettingsService ( Settings . Builder . EMPTY_SETTINGS ) , getRandom ( ) ) , new ShardsAllocators ( settings . build ( ) , NoopGatewayAllocator . INSTANCE , new ShardsAllocator ( ) { @Override public boolean rebalance ( RoutingAllocation allocation ) { return false ; } @Override public boolean move ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return false ; } @Override public void applyStartedShards ( StartedRerouteAllocation allocation ) { } @Override public void applyFailedShards ( FailedRerouteAllocation allocation ) { } @Override public boolean allocateUnassigned ( RoutingAllocation allocation ) { RoutingNodes . UnassignedShards unassigned = allocation . routingNodes ( ) . unassigned ( ) ; boolean changed = ! unassigned . isEmpty ( ) ; for ( ShardRouting sr : unassigned . drain ( ) ) { switch ( sr . id ( ) ) { case <int> : if ( sr . primary ( ) ) { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } else { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } break ; case <int> : if ( sr . primary ( ) ) { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } else { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } break ; case <int> : if ( sr . primary ( ) ) { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } else { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } break ; case <int> : if ( sr . primary ( ) ) { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } else { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } break ; case <int> : if ( sr . primary ( ) ) { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } else { allocation . routingNodes ( ) . initialize ( sr , <str> , - <int> ) ; } break ; } } return changed ; } } ) , EmptyClusterInfoService . INSTANCE ) ; MetaData . Builder metaDataBuilder = MetaData . builder ( ) ; RoutingTable . Builder routingTableBuilder = RoutingTable . builder ( ) ; IndexMetaData . Builder indexMeta = IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ; metaDataBuilder = metaDataBuilder . put ( indexMeta ) ; MetaData metaData = metaDataBuilder . build ( ) ; for ( ObjectCursor < IndexMetaData > cursor : metaData . indices ( ) . values ( ) ) { routingTableBuilder . addAsNew ( cursor . value ) ; } RoutingTable routingTable = routingTableBuilder . build ( ) ; DiscoveryNodes . Builder nodes = DiscoveryNodes . builder ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { DiscoveryNode node = newNode ( <str> + i ) ; nodes . put ( node ) ; } ClusterState clusterState = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . nodes ( nodes ) . metaData ( metaData ) . routingTable ( routingTable ) . build ( ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; RoutingNodes routingNodes = clusterState . getRoutingNodes ( ) ; for ( RoutingNode routingNode : routingNodes ) { for ( ShardRouting shardRouting : routingNode ) { assertThat ( shardRouting . state ( ) , Matchers . equalTo ( ShardRoutingState . INITIALIZING ) ) ; } } strategy = createAllocationService ( settings . build ( ) ) ; logger . info ( <str> ) ; routingNodes = clusterState . getRoutingNodes ( ) ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( RoutingNode routingNode : routingNodes ) { for ( ShardRouting shardRouting : routingNode ) { assertThat ( shardRouting . state ( ) , Matchers . equalTo ( ShardRoutingState . STARTED ) ) ; } } logger . info ( <str> ) ; routingTable = strategy . applyStartedShards ( clusterState , routingNodes . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( RoutingNode routingNode : routingNodes ) { for ( ShardRouting shardRouting : routingNode ) { assertThat ( shardRouting . state ( ) , Matchers . equalTo ( ShardRoutingState . STARTED ) ) ; } } logger . info ( <str> ) ; routingTable = strategy . reroute ( clusterState , <str> ) . routingTable ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( routingTable ) . build ( ) ; routingNodes = clusterState . getRoutingNodes ( ) ; for ( RoutingNode routingNode : routingNodes ) { for ( ShardRouting shardRouting : routingNode ) { assertThat ( shardRouting . state ( ) , Matchers . equalTo ( ShardRoutingState . STARTED ) ) ; } } } } 
