package io . netty . handler . codec . http2 ; import static io . netty . handler . codec . http2 . Http2CodecUtil . CONNECTION_STREAM_ID ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_PRIORITY_WEIGHT ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_WINDOW_SIZE ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertNotNull ; import static org . junit . Assert . assertSame ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . mockito . Matchers . any ; import static org . mockito . Matchers . anyInt ; import static org . mockito . Mockito . atLeastOnce ; import static org . mockito . Mockito . doAnswer ; import static org . mockito . Mockito . doThrow ; import static org . mockito . Mockito . mock ; import static org . mockito . Mockito . never ; import static org . mockito . Mockito . reset ; import static org . mockito . Mockito . times ; import static org . mockito . Mockito . verify ; import static org . mockito . Mockito . verifyNoMoreInteractions ; import static org . mockito . Mockito . verifyZeroInteractions ; import static org . mockito . Mockito . when ; import io . netty . buffer . ByteBuf ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelPromise ; import io . netty . handler . codec . http2 . Http2FrameWriter . Configuration ; import io . netty . util . concurrent . EventExecutor ; import junit . framework . AssertionFailedError ; import org . junit . Before ; import org . junit . Test ; import org . mockito . Mock ; import org . mockito . MockitoAnnotations ; import org . mockito . invocation . InvocationOnMock ; import org . mockito . stubbing . Answer ; import java . util . concurrent . atomic . AtomicInteger ; public class DefaultHttp2RemoteFlowControllerTest { private static final int STREAM_A = <int> ; private static final int STREAM_B = <int> ; private static final int STREAM_C = <int> ; private static final int STREAM_D = <int> ; private DefaultHttp2RemoteFlowController controller ; @Mock private ByteBuf buffer ; @Mock private Http2FrameSizePolicy frameWriterSizePolicy ; @Mock private Configuration frameWriterConfiguration ; @Mock private ChannelHandlerContext ctx ; @Mock private Channel channel ; @Mock private ChannelConfig config ; @Mock private EventExecutor executor ; @Mock private ChannelPromise promise ; @Mock private Http2RemoteFlowController . Listener listener ; private DefaultHttp2Connection connection ; @Before public void setup ( ) throws Http2Exception { MockitoAnnotations . initMocks ( this ) ; when ( ctx . newPromise ( ) ) . thenReturn ( promise ) ; when ( ctx . flush ( ) ) . thenThrow ( new AssertionFailedError ( <str> ) ) ; setChannelWritability ( true ) ; when ( channel . config ( ) ) . thenReturn ( config ) ; when ( executor . inEventLoop ( ) ) . thenReturn ( true ) ; initConnectionAndController ( ) ; resetCtx ( ) ; controller . channelHandlerContext ( ctx ) ; assertWritabilityChanged ( <int> , true ) ; reset ( listener ) ; } private void initConnectionAndController ( ) throws Http2Exception { connection = new DefaultHttp2Connection ( false ) ; controller = new DefaultHttp2RemoteFlowController ( connection , listener ) ; connection . remote ( ) . flowController ( controller ) ; connection . local ( ) . createStream ( STREAM_A , false ) ; connection . local ( ) . createStream ( STREAM_B , false ) ; Http2Stream streamC = connection . local ( ) . createStream ( STREAM_C , false ) ; Http2Stream streamD = connection . local ( ) . createStream ( STREAM_D , false ) ; streamC . setPriority ( STREAM_A , DEFAULT_PRIORITY_WEIGHT , false ) ; streamD . setPriority ( STREAM_A , DEFAULT_PRIORITY_WEIGHT , false ) ; } @Test public void initialWindowSizeShouldOnlyChangeStreams ( ) throws Http2Exception { controller . initialWindowSize ( <int> ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( <int> , window ( STREAM_A ) ) ; assertEquals ( <int> , window ( STREAM_B ) ) ; assertEquals ( <int> , window ( STREAM_C ) ) ; assertEquals ( <int> , window ( STREAM_D ) ) ; assertWritabilityChanged ( <int> , false ) ; } @Test public void windowUpdateShouldChangeConnectionWindow ( ) throws Http2Exception { incrementWindowSize ( CONNECTION_STREAM_ID , <int> ) ; assertEquals ( DEFAULT_WINDOW_SIZE + <int> , window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_A ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_B ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_C ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_D ) ) ; verifyZeroInteractions ( listener ) ; } @Test public void windowUpdateShouldChangeStreamWindow ( ) throws Http2Exception { incrementWindowSize ( STREAM_A , <int> ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE + <int> , window ( STREAM_A ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_B ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_C ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_D ) ) ; verifyZeroInteractions ( listener ) ; } @Test public void payloadSmallerThanWindowShouldBeWrittenImmediately ( ) throws Http2Exception { FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; data . assertNotWritten ( ) ; verifyZeroInteractions ( listener ) ; controller . writePendingBytes ( ) ; data . assertFullyWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; verifyZeroInteractions ( listener ) ; } @Test public void emptyPayloadShouldBeWrittenImmediately ( ) throws Http2Exception { FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; data . assertNotWritten ( ) ; controller . writePendingBytes ( ) ; data . assertFullyWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; verifyZeroInteractions ( listener ) ; } @Test public void unflushedPayloadsShouldBeDroppedOnCancel ( ) throws Http2Exception { FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; connection . stream ( STREAM_A ) . close ( ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; } @Test public void payloadsShouldMerge ( ) throws Http2Exception { controller . initialWindowSize ( <int> ) ; FakeFlowControlled data1 = new FakeFlowControlled ( <int> , true ) ; FakeFlowControlled data2 = new FakeFlowControlled ( <int> , true ) ; sendData ( STREAM_A , data1 ) ; sendData ( STREAM_A , data2 ) ; data1 . assertNotWritten ( ) ; data1 . assertNotWritten ( ) ; data2 . assertMerged ( ) ; controller . writePendingBytes ( ) ; data1 . assertFullyWritten ( ) ; data2 . assertNotWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; } @Test public void stalledStreamShouldQueuePayloads ( ) throws Http2Exception { controller . initialWindowSize ( <int> ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; FakeFlowControlled moreData = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; sendData ( STREAM_A , moreData ) ; controller . writePendingBytes ( ) ; moreData . assertNotWritten ( ) ; verifyZeroInteractions ( listener ) ; } @Test public void queuedPayloadsReceiveErrorOnStreamClose ( ) throws Http2Exception { controller . initialWindowSize ( <int> ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; FakeFlowControlled moreData = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; sendData ( STREAM_A , moreData ) ; controller . writePendingBytes ( ) ; moreData . assertNotWritten ( ) ; connection . stream ( STREAM_A ) . close ( ) ; data . assertError ( ) ; moreData . assertError ( ) ; verifyZeroInteractions ( listener ) ; } @Test public void payloadLargerThanWindowShouldWritePartial ( ) throws Http2Exception { controller . initialWindowSize ( <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_A ) ) ) ; reset ( listener ) ; final FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertPartiallyWritten ( <int> ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; verifyNoMoreInteractions ( listener ) ; } @Test public void windowUpdateAndFlushShouldTriggerWrite ( ) throws Http2Exception { controller . initialWindowSize ( <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_A ) ) ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; FakeFlowControlled moreData = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; sendData ( STREAM_A , moreData ) ; controller . writePendingBytes ( ) ; data . assertPartiallyWritten ( <int> ) ; moreData . assertNotWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; reset ( listener ) ; resetCtx ( ) ; incrementWindowSize ( STREAM_A , <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; reset ( listener ) ; controller . writePendingBytes ( ) ; data . assertFullyWritten ( ) ; moreData . assertPartiallyWritten ( <int> ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE - <int> , window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( <int> , window ( STREAM_A ) ) ; assertEquals ( <int> , window ( STREAM_B ) ) ; assertEquals ( <int> , window ( STREAM_C ) ) ; assertEquals ( <int> , window ( STREAM_D ) ) ; } @Test public void initialWindowUpdateShouldSendPayload ( ) throws Http2Exception { incrementWindowSize ( CONNECTION_STREAM_ID , - window ( CONNECTION_STREAM_ID ) + <int> ) ; assertWritabilityChanged ( <int> , true ) ; reset ( listener ) ; controller . initialWindowSize ( <int> ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; controller . initialWindowSize ( <int> ) ; data . assertFullyWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; assertWritabilityChanged ( <int> , false ) ; } @Test public void successiveSendsShouldNotInteract ( ) throws Http2Exception { incrementWindowSize ( CONNECTION_STREAM_ID , - window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( <int> , window ( CONNECTION_STREAM_ID ) ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; FakeFlowControlled dataA = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , dataA ) ; controller . writePendingBytes ( ) ; dataA . assertNotWritten ( ) ; incrementWindowSize ( CONNECTION_STREAM_ID , <int> ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; controller . writePendingBytes ( ) ; dataA . assertPartiallyWritten ( <int> ) ; assertEquals ( <int> , window ( STREAM_A ) ) ; assertEquals ( <int> , window ( CONNECTION_STREAM_ID ) ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; FakeFlowControlled dataB = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_B , dataB ) ; controller . writePendingBytes ( ) ; dataB . assertNotWritten ( ) ; incrementWindowSize ( CONNECTION_STREAM_ID , <int> ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; controller . writePendingBytes ( ) ; assertEquals ( <int> , window ( CONNECTION_STREAM_ID ) ) ; assertWritabilityChanged ( <int> , false ) ; dataA . assertFullyWritten ( ) ; assertEquals ( <int> , window ( STREAM_A ) ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; dataB . assertFullyWritten ( ) ; assertEquals ( <int> , window ( STREAM_B ) ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_B ) , <int> ) ; verifyNoMoreInteractions ( listener ) ; } @Test public void negativeWindowShouldNotThrowException ( ) throws Http2Exception { final int initWindow = <int> ; final int secondWindowSize = <int> ; controller . initialWindowSize ( initWindow ) ; assertWritabilityChanged ( <int> , true ) ; reset ( listener ) ; FakeFlowControlled data1 = new FakeFlowControlled ( initWindow ) ; FakeFlowControlled data2 = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data1 ) ; controller . writePendingBytes ( ) ; data1 . assertFullyWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; assertTrue ( window ( CONNECTION_STREAM_ID ) > <int> ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; controller . initialWindowSize ( initWindow - secondWindowSize ) ; assertEquals ( - secondWindowSize , window ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; sendData ( STREAM_A , data2 ) ; controller . writePendingBytes ( ) ; data2 . assertNotWritten ( ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; incrementWindowSize ( STREAM_A , <int> ) ; controller . writePendingBytes ( ) ; assertEquals ( - <int> , window ( STREAM_A ) ) ; data2 . assertNotWritten ( ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; incrementWindowSize ( STREAM_A , <int> ) ; controller . writePendingBytes ( ) ; assertEquals ( <int> , window ( STREAM_A ) ) ; data2 . assertNotWritten ( ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; incrementWindowSize ( STREAM_A , <int> ) ; controller . writePendingBytes ( ) ; data2 . assertFullyWritten ( ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; } @Test public void initialWindowUpdateShouldSendEmptyFrame ( ) throws Http2Exception { controller . initialWindowSize ( <int> ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> , false ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; FakeFlowControlled data2 = new FakeFlowControlled ( <int> , false ) ; sendData ( STREAM_A , data2 ) ; controller . writePendingBytes ( ) ; data2 . assertNotWritten ( ) ; controller . initialWindowSize ( <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; data . assertFullyWritten ( ) ; data2 . assertFullyWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; } @Test public void initialWindowUpdateShouldSendPartialFrame ( ) throws Http2Exception { controller . initialWindowSize ( <int> ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; controller . initialWindowSize ( <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; data . assertPartiallyWritten ( <int> ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; } @Test public void connectionWindowUpdateShouldSendFrame ( ) throws Http2Exception { exhaustStreamWindow ( CONNECTION_STREAM_ID ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; incrementWindowSize ( CONNECTION_STREAM_ID , <int> ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; data . assertNotWritten ( ) ; controller . writePendingBytes ( ) ; data . assertFullyWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; assertWritabilityChanged ( <int> , false ) ; assertEquals ( <int> , window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE - <int> , window ( STREAM_A ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_B ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_C ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_D ) ) ; } @Test public void connectionWindowUpdateShouldSendPartialFrame ( ) throws Http2Exception { exhaustStreamWindow ( CONNECTION_STREAM_ID ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; incrementWindowSize ( CONNECTION_STREAM_ID , <int> ) ; data . assertNotWritten ( ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; controller . writePendingBytes ( ) ; data . assertPartiallyWritten ( <int> ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; assertWritabilityChanged ( <int> , false ) ; assertEquals ( <int> , window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE - <int> , window ( STREAM_A ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_B ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_C ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_D ) ) ; } @Test public void streamWindowUpdateShouldSendFrame ( ) throws Http2Exception { exhaustStreamWindow ( STREAM_A ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; incrementWindowSize ( STREAM_A , <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; data . assertNotWritten ( ) ; controller . writePendingBytes ( ) ; data . assertFullyWritten ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE - <int> , window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( <int> , window ( STREAM_A ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_B ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_C ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_D ) ) ; } @Test public void streamWindowUpdateShouldSendPartialFrame ( ) throws Http2Exception { exhaustStreamWindow ( STREAM_A ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; FakeFlowControlled data = new FakeFlowControlled ( <int> ) ; sendData ( STREAM_A , data ) ; controller . writePendingBytes ( ) ; data . assertNotWritten ( ) ; incrementWindowSize ( STREAM_A , <int> ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; reset ( listener ) ; data . assertNotWritten ( ) ; controller . writePendingBytes ( ) ; data . assertPartiallyWritten ( <int> ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; assertEquals ( DEFAULT_WINDOW_SIZE - <int> , window ( CONNECTION_STREAM_ID ) ) ; assertEquals ( <int> , window ( STREAM_A ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_B ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_C ) ) ; assertEquals ( DEFAULT_WINDOW_SIZE , window ( STREAM_D ) ) ; } @Test public void flowControlledWriteThrowsAnException ( ) throws Exception { final Http2RemoteFlowController . FlowControlled flowControlled = mockedFlowControlledThatThrowsOnWrite ( ) ; final Http2Stream stream = stream ( STREAM_A ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock invocationOnMock ) { stream . closeLocalSide ( ) ; return null ; } } ) . when ( flowControlled ) . error ( any ( ChannelHandlerContext . class ) , any ( Throwable . class ) ) ; int windowBefore = window ( STREAM_A ) ; controller . addFlowControlled ( stream , flowControlled ) ; controller . writePendingBytes ( ) ; verify ( flowControlled , atLeastOnce ( ) ) . write ( any ( ChannelHandlerContext . class ) , anyInt ( ) ) ; verify ( flowControlled ) . error ( any ( ChannelHandlerContext . class ) , any ( Throwable . class ) ) ; verify ( flowControlled , never ( ) ) . writeComplete ( ) ; assertEquals ( <int> , windowBefore - window ( STREAM_A ) ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; assertWritabilityChanged ( <int> , true ) ; } @Test public void flowControlledWriteAndErrorThrowAnException ( ) throws Exception { final Http2RemoteFlowController . FlowControlled flowControlled = mockedFlowControlledThatThrowsOnWrite ( ) ; final Http2Stream stream = stream ( STREAM_A ) ; final RuntimeException fakeException = new RuntimeException ( <str> ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock invocationOnMock ) { throw fakeException ; } } ) . when ( flowControlled ) . error ( any ( ChannelHandlerContext . class ) , any ( Throwable . class ) ) ; int windowBefore = window ( STREAM_A ) ; try { controller . addFlowControlled ( stream , flowControlled ) ; controller . writePendingBytes ( ) ; fail ( ) ; } catch ( Http2Exception e ) { assertSame ( fakeException , e . getCause ( ) ) ; } catch ( Throwable t ) { fail ( ) ; } verify ( flowControlled , atLeastOnce ( ) ) . write ( any ( ChannelHandlerContext . class ) , anyInt ( ) ) ; verify ( flowControlled ) . error ( any ( ChannelHandlerContext . class ) , any ( Throwable . class ) ) ; verify ( flowControlled , never ( ) ) . writeComplete ( ) ; assertEquals ( <int> , windowBefore - window ( STREAM_A ) ) ; verifyZeroInteractions ( listener ) ; } @Test public void flowControlledWriteCompleteThrowsAnException ( ) throws Exception { final Http2RemoteFlowController . FlowControlled flowControlled = mock ( Http2RemoteFlowController . FlowControlled . class ) ; final AtomicInteger size = new AtomicInteger ( <int> ) ; doAnswer ( new Answer < Integer > ( ) { @Override public Integer answer ( InvocationOnMock invocationOnMock ) throws Throwable { return size . get ( ) ; } } ) . when ( flowControlled ) . size ( ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock invocationOnMock ) throws Throwable { size . addAndGet ( - <int> ) ; return null ; } } ) . when ( flowControlled ) . write ( any ( ChannelHandlerContext . class ) , anyInt ( ) ) ; final Http2Stream stream = stream ( STREAM_A ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock invocationOnMock ) { throw new RuntimeException ( <str> ) ; } } ) . when ( flowControlled ) . writeComplete ( ) ; int windowBefore = window ( STREAM_A ) ; try { controller . addFlowControlled ( stream , flowControlled ) ; controller . writePendingBytes ( ) ; } catch ( Exception e ) { fail ( ) ; } verify ( flowControlled , times ( <int> ) ) . write ( any ( ChannelHandlerContext . class ) , anyInt ( ) ) ; verify ( flowControlled , never ( ) ) . error ( any ( ChannelHandlerContext . class ) , any ( Throwable . class ) ) ; verify ( flowControlled ) . writeComplete ( ) ; assertEquals ( <int> , windowBefore - window ( STREAM_A ) ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; assertWritabilityChanged ( <int> , true ) ; } @Test public void closeStreamInFlowControlledError ( ) throws Exception { final Http2RemoteFlowController . FlowControlled flowControlled = mock ( Http2RemoteFlowController . FlowControlled . class ) ; final Http2Stream stream = stream ( STREAM_A ) ; when ( flowControlled . size ( ) ) . thenReturn ( <int> ) ; doThrow ( new RuntimeException ( <str> ) ) . when ( flowControlled ) . write ( any ( ChannelHandlerContext . class ) , anyInt ( ) ) ; doAnswer ( new Answer < Void > ( ) { @Override public Void answer ( InvocationOnMock invocationOnMock ) { stream . close ( ) ; return null ; } } ) . when ( flowControlled ) . error ( any ( ChannelHandlerContext . class ) , any ( Throwable . class ) ) ; controller . addFlowControlled ( stream , flowControlled ) ; controller . writePendingBytes ( ) ; verify ( flowControlled ) . write ( any ( ChannelHandlerContext . class ) , anyInt ( ) ) ; verify ( flowControlled ) . error ( any ( ChannelHandlerContext . class ) , any ( Throwable . class ) ) ; verify ( flowControlled , never ( ) ) . writeComplete ( ) ; verify ( listener , times ( <int> ) ) . streamWritten ( stream ( STREAM_A ) , <int> ) ; verify ( listener , times ( <int> ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , never ( ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; } @Test public void nonWritableChannelDoesNotAttemptToWrite ( ) throws Exception { setChannelWritability ( false ) ; assertWritabilityChanged ( <int> , false ) ; reset ( listener ) ; FakeFlowControlled dataA = new FakeFlowControlled ( <int> ) ; FakeFlowControlled dataB = new FakeFlowControlled ( <int> ) ; final Http2Stream stream = stream ( STREAM_A ) ; controller . addFlowControlled ( stream , dataA ) ; controller . writePendingBytes ( ) ; dataA . assertNotWritten ( ) ; controller . incrementWindowSize ( stream , <int> ) ; controller . writePendingBytes ( ) ; dataA . assertNotWritten ( ) ; controller . addFlowControlled ( stream , dataB ) ; controller . writePendingBytes ( ) ; dataA . assertNotWritten ( ) ; dataB . assertNotWritten ( ) ; assertWritabilityChanged ( <int> , false ) ; setChannelWritability ( true ) ; assertWritabilityChanged ( <int> , true ) ; controller . writePendingBytes ( ) ; dataA . assertFullyWritten ( ) ; dataB . assertFullyWritten ( ) ; } @Test public void contextShouldSendQueuedFramesWhenSet ( ) throws Exception { initConnectionAndController ( ) ; FakeFlowControlled dataA = new FakeFlowControlled ( <int> ) ; final Http2Stream stream = stream ( STREAM_A ) ; controller . addFlowControlled ( stream , dataA ) ; dataA . assertNotWritten ( ) ; controller . incrementWindowSize ( stream , <int> ) ; dataA . assertNotWritten ( ) ; assertWritabilityChanged ( <int> , false ) ; controller . channelHandlerContext ( ctx ) ; dataA . assertFullyWritten ( ) ; assertWritabilityChanged ( <int> , true ) ; } @Test public void initialWindowSizeWithNoContextShouldNotThrow ( ) throws Exception { initConnectionAndController ( ) ; FakeFlowControlled dataA = new FakeFlowControlled ( <int> ) ; final Http2Stream stream = stream ( STREAM_A ) ; controller . addFlowControlled ( stream , dataA ) ; dataA . assertNotWritten ( ) ; controller . channelHandlerContext ( ctx ) ; dataA . assertFullyWritten ( ) ; } private void assertWritabilityChanged ( int amt , boolean writable ) { verify ( listener , times ( amt ) ) . writabilityChanged ( stream ( STREAM_A ) ) ; verify ( listener , times ( amt ) ) . writabilityChanged ( stream ( STREAM_B ) ) ; verify ( listener , times ( amt ) ) . writabilityChanged ( stream ( STREAM_C ) ) ; verify ( listener , times ( amt ) ) . writabilityChanged ( stream ( STREAM_D ) ) ; if ( writable ) { assertTrue ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertTrue ( controller . isWritable ( stream ( STREAM_D ) ) ) ; } else { assertFalse ( controller . isWritable ( stream ( STREAM_A ) ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_B ) ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_C ) ) ) ; assertFalse ( controller . isWritable ( stream ( STREAM_D ) ) ) ; } } private static Http2RemoteFlowController . FlowControlled mockedFlowControlledThatThrowsOnWrite ( ) throws Exception { final Http2RemoteFlowController . FlowControlled flowControlled = mock ( Http2RemoteFlowController . FlowControlled . class ) ; when ( flowControlled . size ( ) ) . thenReturn ( <int> ) ; doAnswer ( new Answer < Void > ( ) { private int invocationCount ; @Override public Void answer ( InvocationOnMock in ) throws Throwable { when ( flowControlled . size ( ) ) . thenReturn ( <int> ) ; throw new RuntimeException ( <str> ) ; } } ) . when ( flowControlled ) . write ( any ( ChannelHandlerContext . class ) , anyInt ( ) ) ; return flowControlled ; } private void sendData ( int streamId , FakeFlowControlled data ) throws Http2Exception { Http2Stream stream = stream ( streamId ) ; controller . addFlowControlled ( stream , data ) ; } private void exhaustStreamWindow ( int streamId ) throws Http2Exception { incrementWindowSize ( streamId , - window ( streamId ) ) ; } private int window ( int streamId ) throws Http2Exception { return controller . windowSize ( stream ( streamId ) ) ; } private void incrementWindowSize ( int streamId , int delta ) throws Http2Exception { controller . incrementWindowSize ( stream ( streamId ) , delta ) ; } private Http2Stream stream ( int streamId ) { return connection . stream ( streamId ) ; } private void resetCtx ( ) { reset ( ctx ) ; when ( ctx . channel ( ) ) . thenReturn ( channel ) ; when ( ctx . executor ( ) ) . thenReturn ( executor ) ; } private void setChannelWritability ( boolean isWritable ) throws Http2Exception { when ( channel . bytesBeforeUnwritable ( ) ) . thenReturn ( isWritable ? Long . MAX_VALUE : <int> ) ; when ( channel . isWritable ( ) ) . thenReturn ( isWritable ) ; if ( controller ! = null ) { controller . channelWritabilityChanged ( ) ; } } private static final class FakeFlowControlled implements Http2RemoteFlowController . FlowControlled { private int currentSize ; private int originalSize ; private boolean writeCalled ; private final boolean mergeable ; private boolean merged ; private Throwable t ; private FakeFlowControlled ( int size ) { this . currentSize = size ; this . originalSize = size ; this . mergeable = false ; } private FakeFlowControlled ( int size , boolean mergeable ) { this . currentSize = size ; this . originalSize = size ; this . mergeable = mergeable ; } @Override public int size ( ) { return currentSize ; } @Override public void error ( ChannelHandlerContext ctx , Throwable t ) { this . t = t ; } @Override public void writeComplete ( ) { } @Override public void write ( ChannelHandlerContext ctx , int allowedBytes ) { if ( allowedBytes < = <int> & & currentSize ! = <int> ) { return ; } writeCalled = true ; int written = Math . min ( currentSize , allowedBytes ) ; currentSize - = written ; } @Override public boolean merge ( ChannelHandlerContext ctx , Http2RemoteFlowController . FlowControlled next ) { if ( mergeable & & next instanceof FakeFlowControlled ) { this . originalSize + = ( ( FakeFlowControlled ) next ) . originalSize ; this . currentSize + = ( ( FakeFlowControlled ) next ) . originalSize ; ( ( FakeFlowControlled ) next ) . merged = true ; return true ; } return false ; } public int written ( ) { return originalSize - currentSize ; } public void assertNotWritten ( ) { assertFalse ( writeCalled ) ; } public void assertPartiallyWritten ( int expectedWritten ) { assertPartiallyWritten ( expectedWritten , <int> ) ; } public void assertPartiallyWritten ( int expectedWritten , int delta ) { assertTrue ( writeCalled ) ; assertEquals ( expectedWritten , written ( ) , delta ) ; } public void assertFullyWritten ( ) { assertTrue ( writeCalled ) ; assertEquals ( <int> , currentSize ) ; } public boolean assertMerged ( ) { return merged ; } public void assertError ( ) { assertNotNull ( t ) ; } } } 
