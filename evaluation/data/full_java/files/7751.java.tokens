package org . elasticsearch . action . index ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . test . ESTestCase ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import static org . hamcrest . Matchers . * ; public class IndexRequestTests extends ESTestCase { public void testIndexRequestOpTypeFromString ( ) throws Exception { String create = <str> ; String index = <str> ; String createUpper = <str> ; String indexUpper = <str> ; assertThat ( IndexRequest . OpType . fromString ( create ) , equalTo ( IndexRequest . OpType . CREATE ) ) ; assertThat ( IndexRequest . OpType . fromString ( index ) , equalTo ( IndexRequest . OpType . INDEX ) ) ; assertThat ( IndexRequest . OpType . fromString ( createUpper ) , equalTo ( IndexRequest . OpType . CREATE ) ) ; assertThat ( IndexRequest . OpType . fromString ( indexUpper ) , equalTo ( IndexRequest . OpType . INDEX ) ) ; } public void testReadBogusString ( ) { try { IndexRequest . OpType . fromString ( <str> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testCreateOperationRejectsVersions ( ) { Set < VersionType > allButInternalSet = new HashSet < > ( Arrays . asList ( VersionType . values ( ) ) ) ; allButInternalSet . remove ( VersionType . INTERNAL ) ; VersionType [ ] allButInternal = allButInternalSet . toArray ( new VersionType [ ] { } ) ; IndexRequest request = new IndexRequest ( <str> , <str> , <str> ) ; request . opType ( IndexRequest . OpType . CREATE ) ; request . versionType ( randomFrom ( allButInternal ) ) ; assertThat ( request . validate ( ) . validationErrors ( ) , not ( empty ( ) ) ) ; request . versionType ( VersionType . INTERNAL ) ; request . version ( randomIntBetween ( <int> , Integer . MAX_VALUE ) ) ; assertThat ( request . validate ( ) . validationErrors ( ) , not ( empty ( ) ) ) ; } public void testSetTTLAsTimeValue ( ) { IndexRequest indexRequest = new IndexRequest ( ) ; TimeValue ttl = TimeValue . parseTimeValue ( randomTimeValue ( ) , null , <str> ) ; indexRequest . ttl ( ttl ) ; assertThat ( indexRequest . ttl ( ) , equalTo ( ttl ) ) ; } public void testSetTTLAsString ( ) { IndexRequest indexRequest = new IndexRequest ( ) ; String ttlAsString = randomTimeValue ( ) ; TimeValue ttl = TimeValue . parseTimeValue ( ttlAsString , null , <str> ) ; indexRequest . ttl ( ttlAsString ) ; assertThat ( indexRequest . ttl ( ) , equalTo ( ttl ) ) ; } public void testSetTTLAsLong ( ) { IndexRequest indexRequest = new IndexRequest ( ) ; String ttlAsString = randomTimeValue ( ) ; TimeValue ttl = TimeValue . parseTimeValue ( ttlAsString , null , <str> ) ; indexRequest . ttl ( ttl . millis ( ) ) ; assertThat ( indexRequest . ttl ( ) , equalTo ( ttl ) ) ; } public void testValidateTTL ( ) { IndexRequest indexRequest = new IndexRequest ( <str> , <str> ) ; if ( randomBoolean ( ) ) { indexRequest . ttl ( randomIntBetween ( Integer . MIN_VALUE , - <int> ) ) ; } else { if ( randomBoolean ( ) ) { indexRequest . ttl ( new TimeValue ( randomIntBetween ( Integer . MIN_VALUE , - <int> ) ) ) ; } else { indexRequest . ttl ( randomIntBetween ( Integer . MIN_VALUE , - <int> ) + <str> ) ; } } ActionRequestValidationException validate = indexRequest . validate ( ) ; assertThat ( validate , notNullValue ( ) ) ; assertThat ( validate . getMessage ( ) , containsString ( <str> ) ) ; } } 
