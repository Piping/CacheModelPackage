package org . elasticsearch . search . basic ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . FilterDirectoryReader ; import org . apache . lucene . index . LeafReader ; import org . apache . lucene . util . English ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . admin . indices . refresh . RefreshResponse ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . Settings . Builder ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . MockEngineFactoryPlugin ; import org . elasticsearch . index . query . QueryBuilders ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . engine . MockEngineSupport ; import org . elasticsearch . test . engine . ThrowingLeafReaderWrapper ; import java . io . IOException ; import java . util . Collection ; import java . util . Random ; import java . util . concurrent . ExecutionException ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; public class SearchWithRandomExceptionsIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( RandomExceptionDirectoryReaderWrapper . TestPlugin . class ) ; } public void testRandomExceptions ( ) throws IOException , InterruptedException , ExecutionException { String mapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; final double lowLevelRate ; final double topLevelRate ; if ( frequently ( ) ) { if ( randomBoolean ( ) ) { if ( randomBoolean ( ) ) { lowLevelRate = <float> / between ( <int> , <int> ) ; topLevelRate = <float> ; } else { topLevelRate = <float> / between ( <int> , <int> ) ; lowLevelRate = <float> ; } } else { lowLevelRate = <float> / between ( <int> , <int> ) ; topLevelRate = <float> / between ( <int> , <int> ) ; } } else { topLevelRate = <float> ; lowLevelRate = <float> ; } Builder settings = settingsBuilder ( ) . put ( indexSettings ( ) ) . put ( EXCEPTION_TOP_LEVEL_RATIO_KEY , topLevelRate ) . put ( EXCEPTION_LOW_LEVEL_RATIO_KEY , lowLevelRate ) . put ( MockEngineSupport . WRAP_READER_RATIO , <float> ) ; logger . info ( <str> , settings . build ( ) . getAsMap ( ) ) ; assertAcked ( prepareCreate ( <str> ) . setSettings ( settings ) . addMapping ( <str> , mapping ) ) ; ensureSearchable ( ) ; final int numDocs = between ( <int> , <int> ) ; int numCreated = <int> ; boolean [ ] added = new boolean [ numDocs ] ; for ( int i = <int> ; i < numDocs ; i + + ) { try { IndexResponse indexResponse = client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setTimeout ( TimeValue . timeValueSeconds ( <int> ) ) . setSource ( <str> , English . intToEnglish ( i ) ) . get ( ) ; if ( indexResponse . isCreated ( ) ) { numCreated + + ; added [ i ] = true ; } } catch ( ElasticsearchException ex ) { } } logger . info ( <str> ) ; RefreshResponse refreshResponse = client ( ) . admin ( ) . indices ( ) . prepareRefresh ( <str> ) . execute ( ) . get ( ) ; final boolean refreshFailed = refreshResponse . getShardFailures ( ) . length ! = <int> | | refreshResponse . getFailedShards ( ) ! = <int> ; logger . info ( <str> , refreshFailed , refreshResponse . getFailedShards ( ) , refreshResponse . getShardFailures ( ) . length , refreshResponse . getSuccessfulShards ( ) , refreshResponse . getTotalShards ( ) ) ; NumShards test = getNumShards ( <str> ) ; final int numSearches = scaledRandomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < numSearches ; i + + ) { try { int docToQuery = between ( <int> , numDocs - <int> ) ; int expectedResults = added [ docToQuery ] ? <int> : <int> ; logger . info ( <str> , English . intToEnglish ( docToQuery ) ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( ) . setQuery ( QueryBuilders . matchQuery ( <str> , English . intToEnglish ( docToQuery ) ) ) . setSize ( expectedResults ) . get ( ) ; logger . info ( <str> , searchResponse . getSuccessfulShards ( ) , test . numPrimaries ) ; if ( searchResponse . getSuccessfulShards ( ) = = test . numPrimaries & & ! refreshFailed ) { assertResultsAndLogOnFailure ( expectedResults , searchResponse ) ; } searchResponse = client ( ) . prepareSearch ( ) . setQuery ( QueryBuilders . matchAllQuery ( ) ) . setSize ( numCreated ) . addSort ( <str> , SortOrder . ASC ) . get ( ) ; logger . info ( <str> , searchResponse . getSuccessfulShards ( ) , test . numPrimaries ) ; if ( searchResponse . getSuccessfulShards ( ) = = test . numPrimaries & & ! refreshFailed ) { assertResultsAndLogOnFailure ( numCreated , searchResponse ) ; } } catch ( SearchPhaseExecutionException ex ) { logger . info ( <str> , ex . getMessage ( ) ) ; } } } public static final String EXCEPTION_TOP_LEVEL_RATIO_KEY = <str> ; public static final String EXCEPTION_LOW_LEVEL_RATIO_KEY = <str> ; public static class RandomExceptionDirectoryReaderWrapper extends MockEngineSupport . DirectoryReaderWrapper { public static class TestPlugin extends Plugin { @Override public String name ( ) { return <str> ; } @Override public String description ( ) { return <str> ; } public void onModule ( MockEngineFactoryPlugin . MockEngineReaderModule module ) { module . setReaderClass ( RandomExceptionDirectoryReaderWrapper . class ) ; } } private final Settings settings ; static class ThrowingSubReaderWrapper extends FilterDirectoryReader . SubReaderWrapper implements ThrowingLeafReaderWrapper . Thrower { private final Random random ; private final double topLevelRatio ; private final double lowLevelRatio ; ThrowingSubReaderWrapper ( Settings settings ) { final long seed = settings . getAsLong ( SETTING_INDEX_SEED , <int> l ) ; this . topLevelRatio = settings . getAsDouble ( EXCEPTION_TOP_LEVEL_RATIO_KEY , <float> ) ; this . lowLevelRatio = settings . getAsDouble ( EXCEPTION_LOW_LEVEL_RATIO_KEY , <float> ) ; this . random = new Random ( seed ) ; } @Override public LeafReader wrap ( LeafReader reader ) { return new ThrowingLeafReaderWrapper ( reader , this ) ; } @Override public void maybeThrow ( ThrowingLeafReaderWrapper . Flags flag ) throws IOException { switch ( flag ) { case Fields : case TermVectors : case Terms : case TermsEnum : case Intersect : case Norms : case NumericDocValues : case BinaryDocValues : case SortedDocValues : case SortedSetDocValues : if ( random . nextDouble ( ) < topLevelRatio ) { throw new IOException ( <str> + flag . name ( ) + <str> ) ; } break ; case DocsEnum : case DocsAndPositionsEnum : if ( random . nextDouble ( ) < lowLevelRatio ) { throw new IOException ( <str> + flag . name ( ) + <str> ) ; } break ; } } @Override public boolean wrapTerms ( String field ) { return true ; } } public RandomExceptionDirectoryReaderWrapper ( DirectoryReader in , Settings settings ) throws IOException { super ( in , new ThrowingSubReaderWrapper ( settings ) ) ; this . settings = settings ; } @Override protected DirectoryReader doWrapDirectoryReader ( DirectoryReader in ) throws IOException { return new RandomExceptionDirectoryReaderWrapper ( in , settings ) ; } } } 
