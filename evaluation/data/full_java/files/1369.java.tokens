package org . apache . cassandra . cql3 . functions ; import java . nio . ByteBuffer ; import java . util . Arrays ; import java . util . List ; import org . junit . Test ; import org . apache . cassandra . db . marshal . LongType ; import org . apache . cassandra . db . marshal . SimpleDateType ; import org . apache . cassandra . db . marshal . TimeUUIDType ; import org . apache . cassandra . db . marshal . TimestampType ; import org . apache . cassandra . transport . Server ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . UUIDGen ; import org . joda . time . DateTime ; import org . joda . time . DateTimeZone ; import org . joda . time . format . DateTimeFormat ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertNull ; public class TimeFctsTest { @Test public void testMinTimeUuid ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; long timeInMillis = dateTime . getMillis ( ) ; ByteBuffer input = TimestampType . instance . fromString ( <str> ) ; ByteBuffer output = executeFunction ( TimeFcts . minTimeuuidFct , input ) ; assertEquals ( UUIDGen . minTimeUUID ( timeInMillis ) , TimeUUIDType . instance . compose ( output ) ) ; } @Test public void testMaxTimeUuid ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; long timeInMillis = dateTime . getMillis ( ) ; ByteBuffer input = TimestampType . instance . fromString ( <str> ) ; ByteBuffer output = executeFunction ( TimeFcts . maxTimeuuidFct , input ) ; assertEquals ( UUIDGen . maxTimeUUID ( timeInMillis ) , TimeUUIDType . instance . compose ( output ) ) ; } @Test public void testDateOf ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; long timeInMillis = dateTime . getMillis ( ) ; ByteBuffer input = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( timeInMillis , <int> ) ) ; ByteBuffer output = executeFunction ( TimeFcts . dateOfFct , input ) ; assertEquals ( dateTime . toDate ( ) , TimestampType . instance . compose ( output ) ) ; } @Test public void testTimeUuidToTimestamp ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; long timeInMillis = dateTime . getMillis ( ) ; ByteBuffer input = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( timeInMillis , <int> ) ) ; ByteBuffer output = executeFunction ( TimeFcts . timeUuidToTimestamp , input ) ; assertEquals ( dateTime . toDate ( ) , TimestampType . instance . compose ( output ) ) ; } @Test public void testUnixTimestampOfFct ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; long timeInMillis = dateTime . getMillis ( ) ; ByteBuffer input = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( timeInMillis , <int> ) ) ; ByteBuffer output = executeFunction ( TimeFcts . unixTimestampOfFct , input ) ; assertEquals ( timeInMillis , LongType . instance . compose ( output ) . longValue ( ) ) ; } @Test public void testTimeUuidToUnixTimestamp ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; long timeInMillis = dateTime . getMillis ( ) ; ByteBuffer input = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( timeInMillis , <int> ) ) ; ByteBuffer output = executeFunction ( TimeFcts . timeUuidToUnixTimestamp , input ) ; assertEquals ( timeInMillis , LongType . instance . compose ( output ) . longValue ( ) ) ; } @Test public void testTimeUuidToDate ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; long timeInMillis = dateTime . getMillis ( ) ; ByteBuffer input = ByteBuffer . wrap ( UUIDGen . getTimeUUIDBytes ( timeInMillis , <int> ) ) ; ByteBuffer output = executeFunction ( TimeFcts . timeUuidtoDate , input ) ; long expectedTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) . getMillis ( ) ; assertEquals ( expectedTime , SimpleDateType . instance . toTimeInMillis ( output ) ) ; } @Test public void testDateToTimestamp ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; ByteBuffer input = SimpleDateType . instance . fromString ( <str> ) ; ByteBuffer output = executeFunction ( TimeFcts . dateToTimestamp , input ) ; assertEquals ( dateTime . toDate ( ) , TimestampType . instance . compose ( output ) ) ; } @Test public void testDateToUnixTimestamp ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; ByteBuffer input = SimpleDateType . instance . fromString ( <str> ) ; ByteBuffer output = executeFunction ( TimeFcts . dateToUnixTimestamp , input ) ; assertEquals ( dateTime . getMillis ( ) , LongType . instance . compose ( output ) . longValue ( ) ) ; } @Test public void testTimestampToDate ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; ByteBuffer input = TimestampType . instance . fromString ( <str> ) ; ByteBuffer output = executeFunction ( TimeFcts . timestampToDate , input ) ; assertEquals ( dateTime . getMillis ( ) , SimpleDateType . instance . toTimeInMillis ( output ) ) ; } @Test public void testTimestampToDateWithEmptyInput ( ) { ByteBuffer output = executeFunction ( TimeFcts . timestampToDate , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; assertNull ( output ) ; } @Test public void testTimestampToUnixTimestamp ( ) { DateTime dateTime = DateTimeFormat . forPattern ( <str> ) . withZone ( DateTimeZone . UTC ) . parseDateTime ( <str> ) ; ByteBuffer input = TimestampType . instance . decompose ( dateTime . toDate ( ) ) ; ByteBuffer output = executeFunction ( TimeFcts . timestampToUnixTimestamp , input ) ; assertEquals ( dateTime . getMillis ( ) , LongType . instance . compose ( output ) . longValue ( ) ) ; } @Test public void testTimestampToUnixTimestampWithEmptyInput ( ) { ByteBuffer output = executeFunction ( TimeFcts . timestampToUnixTimestamp , ByteBufferUtil . EMPTY_BYTE_BUFFER ) ; assertNull ( output ) ; } private static ByteBuffer executeFunction ( Function function , ByteBuffer input ) { List < ByteBuffer > params = Arrays . asList ( input ) ; return ( ( ScalarFunction ) function ) . execute ( Server . CURRENT_VERSION , params ) ; } } 
