package org . elasticsearch . search . aggregations . bucket . sampler ; import org . apache . lucene . index . DocValues ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . index . NumericDocValues ; import org . apache . lucene . index . RandomAccessOrds ; import org . apache . lucene . index . SortedDocValues ; import org . apache . lucene . search . DiversifiedTopDocsCollector ; import org . apache . lucene . search . DiversifiedTopDocsCollector . ScoreDocKey ; import org . apache . lucene . search . TopDocsCollector ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactories ; import org . elasticsearch . search . aggregations . bucket . BestDocsDeferringCollector ; import org . elasticsearch . search . aggregations . bucket . DeferringBucketCollector ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . aggregations . support . ValuesSource ; import java . io . IOException ; import java . util . List ; import java . util . Map ; public class DiversifiedOrdinalsSamplerAggregator extends SamplerAggregator { private ValuesSource . Bytes . WithOrdinals . FieldData valuesSource ; private int maxDocsPerValue ; public DiversifiedOrdinalsSamplerAggregator ( String name , int shardSize , AggregatorFactories factories , AggregationContext aggregationContext , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData , ValuesSource . Bytes . WithOrdinals . FieldData valuesSource , int maxDocsPerValue ) throws IOException { super ( name , shardSize , factories , aggregationContext , parent , pipelineAggregators , metaData ) ; this . valuesSource = valuesSource ; this . maxDocsPerValue = maxDocsPerValue ; } @Override public DeferringBucketCollector getDeferringCollector ( ) { bdd = new DiverseDocsDeferringCollector ( ) ; return bdd ; } class DiverseDocsDeferringCollector extends BestDocsDeferringCollector { public DiverseDocsDeferringCollector ( ) { super ( shardSize , context . bigArrays ( ) ) ; } @Override protected TopDocsCollector < ScoreDocKey > createTopDocsCollector ( int size ) { return new ValuesDiversifiedTopDocsCollector ( size , maxDocsPerValue ) ; } class ValuesDiversifiedTopDocsCollector extends DiversifiedTopDocsCollector { public ValuesDiversifiedTopDocsCollector ( int numHits , int maxHitsPerKey ) { super ( numHits , maxHitsPerKey ) ; } @Override protected NumericDocValues getKeys ( LeafReaderContext context ) { final RandomAccessOrds globalOrds = valuesSource . globalOrdinalsValues ( context ) ; final SortedDocValues singleValues = DocValues . unwrapSingleton ( globalOrds ) ; if ( singleValues ! = null ) { return new NumericDocValues ( ) { @Override public long get ( int doc ) { return singleValues . getOrd ( doc ) ; } } ; } return new NumericDocValues ( ) { @Override public long get ( int doc ) { globalOrds . setDocument ( doc ) ; final long valuesCount = globalOrds . cardinality ( ) ; if ( valuesCount > <int> ) { throw new IllegalArgumentException ( <str> ) ; } if ( valuesCount = = <int> ) { long result = globalOrds . ordAt ( <int> ) ; return result ; } return Long . MIN_VALUE ; } } ; } } } } 
