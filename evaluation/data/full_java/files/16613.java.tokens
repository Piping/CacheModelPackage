package org . junit . tests . experimental . rules ; import static org . hamcrest . CoreMatchers . containsString ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import static org . junit . experimental . results . PrintableResult . testResult ; import static org . junit . experimental . results . ResultMatchers . hasSingleFailureContaining ; import static org . junit . experimental . results . ResultMatchers . isSuccessful ; import org . junit . After ; import org . junit . Before ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . MethodRule ; import org . junit . rules . TestName ; import org . junit . rules . TestRule ; import org . junit . rules . TestWatchman ; import org . junit . runner . Description ; import org . junit . runner . JUnitCore ; import org . junit . runner . Result ; import org . junit . runners . model . FrameworkMethod ; import org . junit . runners . model . Statement ; @SuppressWarnings ( <str> ) public class MethodRulesTest { private static boolean wasRun ; public static class ExampleTest { @Rule public MethodRule example = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } ; } ; } } ; @Test public void nothing ( ) { } } @Test public void ruleIsIntroducedAndEvaluated ( ) { wasRun = false ; JUnitCore . runClasses ( ExampleTest . class ) ; assertTrue ( wasRun ) ; } public static class SonOfExampleTest extends ExampleTest { } @Test public void ruleIsIntroducedAndEvaluatedOnSubclass ( ) { wasRun = false ; JUnitCore . runClasses ( SonOfExampleTest . class ) ; assertTrue ( wasRun ) ; } private static int runCount ; private static class Increment implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @Override public void evaluate ( ) throws Throwable { runCount + + ; base . evaluate ( ) ; } } ; } } public static class MultipleRuleTest { @Rule public MethodRule incrementor1 = new Increment ( ) ; @Rule public MethodRule incrementor2 = new Increment ( ) ; @Test public void nothing ( ) { } } @Test public void multipleRulesAreRun ( ) { runCount = <int> ; JUnitCore . runClasses ( MultipleRuleTest . class ) ; assertEquals ( <int> , runCount ) ; } public static class NoRulesTest { public int x ; @Test public void nothing ( ) { } } @Test public void ignoreNonRules ( ) { Result result = JUnitCore . runClasses ( NoRulesTest . class ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; } private static String log ; public static class OnFailureTest { @Rule public MethodRule watchman = new TestWatchman ( ) { @Override public void failed ( Throwable e , FrameworkMethod method ) { log + = method . getName ( ) + <str> + e . getClass ( ) . getSimpleName ( ) ; } } ; @Test public void nothing ( ) { fail ( ) ; } } @Test public void onFailure ( ) { log = <str> ; Result result = JUnitCore . runClasses ( OnFailureTest . class ) ; assertEquals ( <str> , log ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; } public static class WatchmanTest { private static String watchedLog ; @Rule public MethodRule watchman = new TestWatchman ( ) { @Override public void failed ( Throwable e , FrameworkMethod method ) { watchedLog + = method . getName ( ) + <str> + e . getClass ( ) . getSimpleName ( ) + <str> ; } @Override public void succeeded ( FrameworkMethod method ) { watchedLog + = method . getName ( ) + <str> + <str> ; } } ; @Test public void fails ( ) { fail ( ) ; } @Test public void succeeds ( ) { } } @Test public void succeeded ( ) { WatchmanTest . watchedLog = <str> ; JUnitCore . runClasses ( WatchmanTest . class ) ; assertThat ( WatchmanTest . watchedLog , containsString ( <str> ) ) ; assertThat ( WatchmanTest . watchedLog , containsString ( <str> ) ) ; } public static class BeforesAndAfters { private static String watchedLog ; @Before public void before ( ) { watchedLog + = <str> ; } @Rule public MethodRule watchman = new TestWatchman ( ) { @Override public void starting ( FrameworkMethod method ) { watchedLog + = <str> ; } @Override public void finished ( FrameworkMethod method ) { watchedLog + = <str> ; } @Override public void succeeded ( FrameworkMethod method ) { watchedLog + = <str> ; } } ; @After public void after ( ) { watchedLog + = <str> ; } @Test public void succeeds ( ) { watchedLog + = <str> ; } } @Test public void beforesAndAfters ( ) { BeforesAndAfters . watchedLog = <str> ; JUnitCore . runClasses ( BeforesAndAfters . class ) ; assertThat ( BeforesAndAfters . watchedLog , is ( <str> ) ) ; } public static class WrongTypedField { @Rule public int x = <int> ; @Test public void foo ( ) { } } @Test public void validateWrongTypedField ( ) { assertThat ( testResult ( WrongTypedField . class ) , hasSingleFailureContaining ( <str> ) ) ; } public static class SonOfWrongTypedField extends WrongTypedField { } @Test public void validateWrongTypedFieldInSuperclass ( ) { assertThat ( testResult ( SonOfWrongTypedField . class ) , hasSingleFailureContaining ( <str> ) ) ; } public static class PrivateRule { @Rule private TestRule rule = new TestName ( ) ; @Test public void foo ( ) { } } @Test public void validatePrivateRule ( ) { assertThat ( testResult ( PrivateRule . class ) , hasSingleFailureContaining ( <str> ) ) ; } public static class CustomTestName implements TestRule { public String name = null ; public Statement apply ( final Statement base , final Description description ) { return new Statement ( ) { @Override public void evaluate ( ) throws Throwable { name = description . getMethodName ( ) ; base . evaluate ( ) ; } } ; } } public static class UsesCustomMethodRule { @Rule public CustomTestName counter = new CustomTestName ( ) ; @Test public void foo ( ) { assertEquals ( <str> , counter . name ) ; } } @Test public void useCustomMethodRule ( ) { assertThat ( testResult ( UsesCustomMethodRule . class ) , isSuccessful ( ) ) ; } public static class HasMethodReturningMethodRule { private MethodRule methodRule = new MethodRule ( ) { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @Override public void evaluate ( ) throws Throwable { wasRun = true ; base . evaluate ( ) ; } } ; } } ; @Rule public MethodRule methodRule ( ) { return methodRule ; } @Test public void doNothing ( ) { } } @Test public void runsMethodRuleThatIsReturnedByMethod ( ) { wasRun = false ; JUnitCore . runClasses ( HasMethodReturningMethodRule . class ) ; assertTrue ( wasRun ) ; } public static class HasMultipleMethodsReturningMethodRule { @Rule public Increment methodRule1 ( ) { return new Increment ( ) ; } @Rule public Increment methodRule2 ( ) { return new Increment ( ) ; } @Test public void doNothing ( ) { } } @Test public void runsAllMethodRulesThatAreReturnedByMethods ( ) { runCount = <int> ; JUnitCore . runClasses ( HasMultipleMethodsReturningMethodRule . class ) ; assertEquals ( <int> , runCount ) ; } public static class CallsMethodReturningRuleOnlyOnce { int callCount = <int> ; private static class Dummy implements MethodRule { public Statement apply ( final Statement base , FrameworkMethod method , Object target ) { return new Statement ( ) { @Override public void evaluate ( ) throws Throwable { base . evaluate ( ) ; } } ; } } ; @Rule public MethodRule methodRule ( ) { callCount + + ; return new Dummy ( ) ; } @Test public void doNothing ( ) { assertEquals ( <int> , callCount ) ; } } @Test public void callsMethodReturningRuleOnlyOnce ( ) { assertTrue ( JUnitCore . runClasses ( CallsMethodReturningRuleOnlyOnce . class ) . wasSuccessful ( ) ) ; } } 
