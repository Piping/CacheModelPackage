package org . apache . cassandra . utils ; import java . util . Arrays ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import com . google . common . base . Objects ; import org . apache . commons . lang3 . StringUtils ; public class CassandraVersion implements Comparable < CassandraVersion > { private static final String VERSION_REGEXP = <str> ; private static final Pattern pattern = Pattern . compile ( VERSION_REGEXP ) ; private static final Pattern SNAPSHOT = Pattern . compile ( <str> ) ; public final int major ; public final int minor ; public final int patch ; private final String [ ] preRelease ; private final String [ ] build ; private CassandraVersion ( int major , int minor , int patch , String [ ] preRelease , String [ ] build ) { this . major = major ; this . minor = minor ; this . patch = patch ; this . preRelease = preRelease ; this . build = build ; } public CassandraVersion ( String version ) { String stripped = SNAPSHOT . matcher ( version ) . replaceFirst ( <str> ) ; Matcher matcher = pattern . matcher ( stripped ) ; if ( ! matcher . matches ( ) ) throw new IllegalArgumentException ( <str> + version ) ; try { this . major = Integer . parseInt ( matcher . group ( <int> ) ) ; this . minor = Integer . parseInt ( matcher . group ( <int> ) ) ; this . patch = Integer . parseInt ( matcher . group ( <int> ) ) ; String pr = matcher . group ( <int> ) ; String bld = matcher . group ( <int> ) ; this . preRelease = pr = = null | | pr . isEmpty ( ) ? null : parseIdentifiers ( stripped , pr ) ; this . build = bld = = null | | bld . isEmpty ( ) ? null : parseIdentifiers ( stripped , bld ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( <str> + version ) ; } } private static String [ ] parseIdentifiers ( String version , String str ) { str = str . substring ( <int> ) ; String [ ] parts = str . split ( <str> ) ; for ( String part : parts ) { if ( ! part . matches ( <str> ) ) throw new IllegalArgumentException ( <str> + version ) ; } return parts ; } public int compareTo ( CassandraVersion other ) { if ( major < other . major ) return - <int> ; if ( major > other . major ) return <int> ; if ( minor < other . minor ) return - <int> ; if ( minor > other . minor ) return <int> ; if ( patch < other . patch ) return - <int> ; if ( patch > other . patch ) return <int> ; int c = compareIdentifiers ( preRelease , other . preRelease , <int> ) ; if ( c ! = <int> ) return c ; return compareIdentifiers ( build , other . build , - <int> ) ; } public CassandraVersion findSupportingVersion ( CassandraVersion . . . versions ) { for ( CassandraVersion version : versions ) { if ( isSupportedBy ( version ) ) return version ; } return null ; } public boolean isSupportedBy ( CassandraVersion version ) { return major = = version . major & & this . compareTo ( version ) < = <int> ; } private static int compareIdentifiers ( String [ ] ids1 , String [ ] ids2 , int defaultPred ) { if ( ids1 = = null ) return ids2 = = null ? <int> : defaultPred ; else if ( ids2 = = null ) return - defaultPred ; int min = Math . min ( ids1 . length , ids2 . length ) ; for ( int i = <int> ; i < min ; i + + ) { Integer i1 = tryParseInt ( ids1 [ i ] ) ; Integer i2 = tryParseInt ( ids2 [ i ] ) ; if ( i1 ! = null ) { if ( i2 = = null | | i1 < i2 ) return - <int> ; else if ( i1 > i2 ) return <int> ; } else { if ( i2 ! = null ) return <int> ; int c = ids1 [ i ] . compareTo ( ids2 [ i ] ) ; if ( c ! = <int> ) return c ; } } if ( ids1 . length < ids2 . length ) return - <int> ; if ( ids1 . length > ids2 . length ) return <int> ; return <int> ; } private static Integer tryParseInt ( String str ) { try { return Integer . valueOf ( str ) ; } catch ( NumberFormatException e ) { return null ; } } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof CassandraVersion ) ) return false ; CassandraVersion that = ( CassandraVersion ) o ; return major = = that . major & & minor = = that . minor & & patch = = that . patch & & Arrays . equals ( preRelease , that . preRelease ) & & Arrays . equals ( build , that . build ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( major , minor , patch , preRelease , build ) ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( major ) . append ( <str> ) . append ( minor ) . append ( <str> ) . append ( patch ) ; if ( preRelease ! = null ) sb . append ( <str> ) . append ( StringUtils . join ( preRelease , <str> ) ) ; if ( build ! = null ) sb . append ( <str> ) . append ( StringUtils . join ( build , <str> ) ) ; return sb . toString ( ) ; } } 
