package io . netty . util ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . net . Inet4Address ; import java . net . Inet6Address ; import java . net . InetAddress ; import java . net . NetworkInterface ; import java . net . SocketException ; import java . net . UnknownHostException ; import java . security . AccessController ; import java . security . PrivilegedAction ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . List ; import java . util . StringTokenizer ; public final class NetUtil { public static final Inet4Address LOCALHOST4 ; public static final Inet6Address LOCALHOST6 ; public static final InetAddress LOCALHOST ; public static final NetworkInterface LOOPBACK_IF ; public static final int SOMAXCONN ; private static final int IPV6_WORD_COUNT = <int> ; private static final int IPV6_MAX_CHAR_COUNT = <int> ; private static final int IPV6_BYTE_COUNT = <int> ; private static final int IPV6_MAX_CHAR_BETWEEN_SEPARATOR = <int> ; private static final int IPV6_MIN_SEPARATORS = <int> ; private static final int IPV6_MAX_SEPARATORS = <int> ; private static final int IPV4_BYTE_COUNT = <int> ; private static final int IPV4_MAX_CHAR_BETWEEN_SEPARATOR = <int> ; private static final int IPV4_SEPARATORS = <int> ; private static final boolean IPV4_PREFERRED = Boolean . getBoolean ( <str> ) ; private static final InternalLogger logger = InternalLoggerFactory . getInstance ( NetUtil . class ) ; static { byte [ ] LOCALHOST4_BYTES = { <int> , <int> , <int> , <int> } ; byte [ ] LOCALHOST6_BYTES = { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> } ; Inet4Address localhost4 = null ; try { localhost4 = ( Inet4Address ) InetAddress . getByAddress ( LOCALHOST4_BYTES ) ; } catch ( Exception e ) { PlatformDependent . throwException ( e ) ; } LOCALHOST4 = localhost4 ; Inet6Address localhost6 = null ; try { localhost6 = ( Inet6Address ) InetAddress . getByAddress ( LOCALHOST6_BYTES ) ; } catch ( Exception e ) { PlatformDependent . throwException ( e ) ; } LOCALHOST6 = localhost6 ; List < NetworkInterface > ifaces = new ArrayList < NetworkInterface > ( ) ; try { for ( Enumeration < NetworkInterface > i = NetworkInterface . getNetworkInterfaces ( ) ; i . hasMoreElements ( ) ; ) { NetworkInterface iface = i . nextElement ( ) ; if ( iface . getInetAddresses ( ) . hasMoreElements ( ) ) { ifaces . add ( iface ) ; } } } catch ( SocketException e ) { logger . warn ( <str> , e ) ; } NetworkInterface loopbackIface = null ; InetAddress loopbackAddr = null ; loop : for ( NetworkInterface iface : ifaces ) { for ( Enumeration < InetAddress > i = iface . getInetAddresses ( ) ; i . hasMoreElements ( ) ; ) { InetAddress addr = i . nextElement ( ) ; if ( addr . isLoopbackAddress ( ) ) { loopbackIface = iface ; loopbackAddr = addr ; break loop ; } } } if ( loopbackIface = = null ) { try { for ( NetworkInterface iface : ifaces ) { if ( iface . isLoopback ( ) ) { Enumeration < InetAddress > i = iface . getInetAddresses ( ) ; if ( i . hasMoreElements ( ) ) { loopbackIface = iface ; loopbackAddr = i . nextElement ( ) ; break ; } } } if ( loopbackIface = = null ) { logger . warn ( <str> ) ; } } catch ( SocketException e ) { logger . warn ( <str> , e ) ; } } if ( loopbackIface ! = null ) { logger . debug ( <str> , loopbackIface . getName ( ) , loopbackIface . getDisplayName ( ) , loopbackAddr . getHostAddress ( ) ) ; } else { if ( loopbackAddr = = null ) { try { if ( NetworkInterface . getByInetAddress ( LOCALHOST6 ) ! = null ) { logger . debug ( <str> , localhost6 ) ; loopbackAddr = localhost6 ; } } catch ( Exception e ) { } finally { if ( loopbackAddr = = null ) { logger . debug ( <str> , localhost4 ) ; loopbackAddr = localhost4 ; } } } } LOOPBACK_IF = loopbackIface ; LOCALHOST = loopbackAddr ; SOMAXCONN = AccessController . doPrivileged ( new PrivilegedAction < Integer > ( ) { @Override public Integer run ( ) { int somaxconn = PlatformDependent . isWindows ( ) ? <int> : <int> ; File file = new File ( <str> ) ; if ( file . exists ( ) ) { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; somaxconn = Integer . parseInt ( in . readLine ( ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , file , somaxconn ) ; } } catch ( Exception e ) { logger . debug ( <str> , file , e ) ; } finally { if ( in ! = null ) { try { in . close ( ) ; } catch ( Exception e ) { } } } } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , file , somaxconn ) ; } } return somaxconn ; } } ) ; } public static boolean isIpV4StackPreferred ( ) { return IPV4_PREFERRED ; } public static byte [ ] createByteArrayFromIpAddressString ( String ipAddressString ) { if ( isValidIpV4Address ( ipAddressString ) ) { StringTokenizer tokenizer = new StringTokenizer ( ipAddressString , <str> ) ; String token ; int tempInt ; byte [ ] byteAddress = new byte [ IPV4_BYTE_COUNT ] ; for ( int i = <int> ; i < IPV4_BYTE_COUNT ; i + + ) { token = tokenizer . nextToken ( ) ; tempInt = Integer . parseInt ( token ) ; byteAddress [ i ] = ( byte ) tempInt ; } return byteAddress ; } if ( isValidIpV6Address ( ipAddressString ) ) { if ( ipAddressString . charAt ( <int> ) = = <str> ) { ipAddressString = ipAddressString . substring ( <int> , ipAddressString . length ( ) - <int> ) ; } int percentPos = ipAddressString . indexOf ( <str> ) ; if ( percentPos > = <int> ) { ipAddressString = ipAddressString . substring ( <int> , percentPos ) ; } StringTokenizer tokenizer = new StringTokenizer ( ipAddressString , <str> , true ) ; ArrayList < String > hexStrings = new ArrayList < String > ( ) ; ArrayList < String > decStrings = new ArrayList < String > ( ) ; String token = <str> ; String prevToken = <str> ; int doubleColonIndex = - <int> ; while ( tokenizer . hasMoreTokens ( ) ) { prevToken = token ; token = tokenizer . nextToken ( ) ; if ( <str> . equals ( token ) ) { if ( <str> . equals ( prevToken ) ) { doubleColonIndex = hexStrings . size ( ) ; } else if ( ! prevToken . isEmpty ( ) ) { hexStrings . add ( prevToken ) ; } } else if ( <str> . equals ( token ) ) { decStrings . add ( prevToken ) ; } } if ( <str> . equals ( prevToken ) ) { if ( <str> . equals ( token ) ) { doubleColonIndex = hexStrings . size ( ) ; } else { hexStrings . add ( token ) ; } } else if ( <str> . equals ( prevToken ) ) { decStrings . add ( token ) ; } int hexStringsLength = <int> ; if ( ! decStrings . isEmpty ( ) ) { hexStringsLength - = <int> ; } if ( doubleColonIndex ! = - <int> ) { int numberToInsert = hexStringsLength - hexStrings . size ( ) ; for ( int i = <int> ; i < numberToInsert ; i + + ) { hexStrings . add ( doubleColonIndex , <str> ) ; } } byte [ ] ipByteArray = new byte [ IPV6_BYTE_COUNT ] ; for ( int i = <int> ; i < hexStrings . size ( ) ; i + + ) { convertToBytes ( hexStrings . get ( i ) , ipByteArray , i < < <int> ) ; } for ( int i = <int> ; i < decStrings . size ( ) ; i + + ) { ipByteArray [ i + <int> ] = ( byte ) ( Integer . parseInt ( decStrings . get ( i ) ) & <int> ) ; } return ipByteArray ; } return null ; } private static void convertToBytes ( String hexWord , byte [ ] ipByteArray , int byteIndex ) { int hexWordLength = hexWord . length ( ) ; int hexWordIndex = <int> ; ipByteArray [ byteIndex ] = <int> ; ipByteArray [ byteIndex + <int> ] = <int> ; int charValue ; if ( hexWordLength > <int> ) { charValue = getIntValue ( hexWord . charAt ( hexWordIndex + + ) ) ; ipByteArray [ byteIndex ] | = charValue < < <int> ; } if ( hexWordLength > <int> ) { charValue = getIntValue ( hexWord . charAt ( hexWordIndex + + ) ) ; ipByteArray [ byteIndex ] | = charValue ; } if ( hexWordLength > <int> ) { charValue = getIntValue ( hexWord . charAt ( hexWordIndex + + ) ) ; ipByteArray [ byteIndex + <int> ] | = charValue < < <int> ; } charValue = getIntValue ( hexWord . charAt ( hexWordIndex ) ) ; ipByteArray [ byteIndex + <int> ] | = charValue & <int> ; } private static int getIntValue ( char c ) { switch ( c ) { case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; } c = Character . toLowerCase ( c ) ; switch ( c ) { case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; case <str> : return <int> ; } return <int> ; } public static String intToIpAddress ( int i ) { StringBuilder buf = new StringBuilder ( <int> ) ; buf . append ( i > > <int> & <hex> ) ; buf . append ( <str> ) ; buf . append ( i > > <int> & <hex> ) ; buf . append ( <str> ) ; buf . append ( i > > <int> & <hex> ) ; buf . append ( <str> ) ; buf . append ( i & <hex> ) ; return buf . toString ( ) ; } public static String bytesToIpAddress ( byte [ ] bytes , int offset , int length ) { if ( length = = <int> ) { StringBuilder buf = new StringBuilder ( <int> ) ; buf . append ( bytes [ offset + + ] > > <int> & <hex> ) ; buf . append ( <str> ) ; buf . append ( bytes [ offset + + ] > > <int> & <hex> ) ; buf . append ( <str> ) ; buf . append ( bytes [ offset + + ] > > <int> & <hex> ) ; buf . append ( <str> ) ; buf . append ( bytes [ offset ] & <hex> ) ; return buf . toString ( ) ; } if ( length = = <int> ) { final StringBuilder sb = new StringBuilder ( <int> ) ; final int endOffset = offset + <int> ; for ( ; offset < endOffset ; offset + = <int> ) { StringUtil . toHexString ( sb , bytes , offset , <int> ) ; sb . append ( <str> ) ; } StringUtil . toHexString ( sb , bytes , offset , <int> ) ; return sb . toString ( ) ; } throw new IllegalArgumentException ( <str> + length + <str> ) ; } public static boolean isValidIpV6Address ( String ipAddress ) { int length = ipAddress . length ( ) ; boolean doubleColon = false ; int numberOfColons = <int> ; int numberOfPeriods = <int> ; StringBuilder word = new StringBuilder ( ) ; char c = <int> ; char prevChar ; int startOffset = <int> ; int endOffset = ipAddress . length ( ) ; if ( endOffset < <int> ) { return false ; } if ( ipAddress . charAt ( <int> ) = = <str> ) { if ( ipAddress . charAt ( endOffset - <int> ) ! = <str> ) { return false ; } startOffset = <int> ; endOffset - - ; } int percentIdx = ipAddress . indexOf ( <str> , startOffset ) ; if ( percentIdx > = <int> ) { endOffset = percentIdx ; } for ( int i = startOffset ; i < endOffset ; i + + ) { prevChar = c ; c = ipAddress . charAt ( i ) ; switch ( c ) { case <str> : numberOfPeriods + + ; if ( numberOfPeriods > <int> ) { return false ; } if ( ! isValidIp4Word ( word . toString ( ) ) ) { return false ; } if ( numberOfColons ! = <int> & & ! doubleColon ) { return false ; } if ( numberOfColons = = <int> & & ipAddress . charAt ( startOffset ) ! = <str> & & ipAddress . charAt ( <int> + startOffset ) ! = <str> ) { return false ; } word . delete ( <int> , word . length ( ) ) ; break ; case <str> : if ( i = = startOffset & & ( ipAddress . length ( ) < = i | | ipAddress . charAt ( i + <int> ) ! = <str> ) ) { return false ; } numberOfColons + + ; if ( numberOfColons > <int> ) { return false ; } if ( numberOfPeriods > <int> ) { return false ; } if ( prevChar = = <str> ) { if ( doubleColon ) { return false ; } doubleColon = true ; } word . delete ( <int> , word . length ( ) ) ; break ; default: if ( word ! = null & & word . length ( ) > <int> ) { return false ; } if ( ! isValidHexChar ( c ) ) { return false ; } word . append ( c ) ; } } if ( numberOfPeriods > <int> ) { if ( numberOfPeriods ! = <int> | | ! ( isValidIp4Word ( word . toString ( ) ) & & numberOfColons < <int> ) ) { return false ; } } else { if ( numberOfColons ! = <int> & & ! doubleColon ) { return false ; } if ( word . length ( ) = = <int> & & ipAddress . charAt ( length - <int> - startOffset ) = = <str> & & ipAddress . charAt ( length - <int> - startOffset ) ! = <str> ) { return false ; } } return true ; } private static boolean isValidIp4Word ( String word ) { char c ; if ( word . length ( ) < <int> | | word . length ( ) > <int> ) { return false ; } for ( int i = <int> ; i < word . length ( ) ; i + + ) { c = word . charAt ( i ) ; if ( ! ( c > = <str> & & c < = <str> ) ) { return false ; } } return Integer . parseInt ( word ) < = <int> ; } private static boolean isValidHexChar ( char c ) { return c > = <str> & & c < = <str> | | c > = <str> & & c < = <str> | | c > = <str> & & c < = <str> ; } private static boolean isValidNumericChar ( char c ) { return c > = <str> & & c < = <str> ; } public static boolean isValidIpV4Address ( String value ) { int periods = <int> ; int i ; int length = value . length ( ) ; if ( length > <int> ) { return false ; } char c ; StringBuilder word = new StringBuilder ( ) ; for ( i = <int> ; i < length ; i + + ) { c = value . charAt ( i ) ; if ( c = = <str> ) { periods + + ; if ( periods > <int> ) { return false ; } if ( word . length ( ) = = <int> ) { return false ; } if ( Integer . parseInt ( word . toString ( ) ) > <int> ) { return false ; } word . delete ( <int> , word . length ( ) ) ; } else if ( ! Character . isDigit ( c ) ) { return false ; } else { if ( word . length ( ) > <int> ) { return false ; } word . append ( c ) ; } } if ( word . length ( ) = = <int> | | Integer . parseInt ( word . toString ( ) ) > <int> ) { return false ; } return periods = = <int> ; } public static Inet6Address getByName ( CharSequence ip ) { return getByName ( ip , true ) ; } public static Inet6Address getByName ( CharSequence ip , boolean ipv4Mapped ) { final byte [ ] bytes = new byte [ IPV6_BYTE_COUNT ] ; final int ipLength = ip . length ( ) ; int compressBegin = <int> ; int compressLength = <int> ; int currentIndex = <int> ; int value = <int> ; int begin = - <int> ; int i = <int> ; int ipv6Seperators = <int> ; int ipv4Seperators = <int> ; int tmp ; boolean needsShift = false ; for ( ; i < ipLength ; + + i ) { final char c = ip . charAt ( i ) ; switch ( c ) { case <str> : + + ipv6Seperators ; if ( i - begin > IPV6_MAX_CHAR_BETWEEN_SEPARATOR | | ipv4Seperators > <int> | | ipv6Seperators > IPV6_MAX_SEPARATORS | | currentIndex + <int> > = bytes . length ) { return null ; } value < < = ( IPV6_MAX_CHAR_BETWEEN_SEPARATOR - ( i - begin ) ) < < <int> ; if ( compressLength > <int> ) { compressLength - = <int> ; } bytes [ currentIndex + + ] = ( byte ) ( ( ( value & <hex> ) < < <int> ) | ( ( value > > <int> ) & <hex> ) ) ; bytes [ currentIndex + + ] = ( byte ) ( ( ( ( value > > <int> ) & <hex> ) < < <int> ) | ( ( value > > <int> ) & <hex> ) ) ; tmp = i + <int> ; if ( tmp < ipLength & & ip . charAt ( tmp ) = = <str> ) { + + tmp ; if ( compressBegin ! = <int> | | ( tmp < ipLength & & ip . charAt ( tmp ) = = <str> ) ) { return null ; } + + ipv6Seperators ; needsShift = ipv6Seperators = = <int> & & value = = <int> ; compressBegin = currentIndex ; compressLength = bytes . length - compressBegin - <int> ; + + i ; } value = <int> ; begin = - <int> ; break ; case <str> : + + ipv4Seperators ; if ( i - begin > IPV4_MAX_CHAR_BETWEEN_SEPARATOR | | ipv4Seperators > IPV4_SEPARATORS | | ( ipv6Seperators > <int> & & ( currentIndex + compressLength < <int> ) ) | | i + <int> > = ipLength | | currentIndex > = bytes . length | | begin < <int> | | ( begin = = <int> & & ( i = = <int> & & ( ! isValidNumericChar ( ip . charAt ( <int> ) ) | | ! isValidNumericChar ( ip . charAt ( <int> ) ) | | ! isValidNumericChar ( ip . charAt ( <int> ) ) ) | | i = = <int> & & ( ! isValidNumericChar ( ip . charAt ( <int> ) ) | | ! isValidNumericChar ( ip . charAt ( <int> ) ) ) | | i = = <int> & & ! isValidNumericChar ( ip . charAt ( <int> ) ) ) ) ) { return null ; } value < < = ( IPV4_MAX_CHAR_BETWEEN_SEPARATOR - ( i - begin ) ) < < <int> ; begin = ( value & <hex> ) * <int> + ( ( value > > <int> ) & <hex> ) * <int> + ( ( value > > <int> ) & <hex> ) ; if ( begin < <int> | | begin > <int> ) { return null ; } bytes [ currentIndex + + ] = ( byte ) begin ; value = <int> ; begin = - <int> ; break ; default : if ( ! isValidHexChar ( c ) | | ( ipv4Seperators > <int> & & ! isValidNumericChar ( c ) ) ) { return null ; } if ( begin < <int> ) { begin = i ; } else if ( i - begin > IPV6_MAX_CHAR_BETWEEN_SEPARATOR ) { return null ; } value + = getIntValue ( c ) < < ( ( i - begin ) < < <int> ) ; break ; } } final boolean isCompressed = compressBegin > <int> ; if ( ipv4Seperators > <int> ) { if ( begin > <int> & & i - begin > IPV4_MAX_CHAR_BETWEEN_SEPARATOR | | ipv4Seperators ! = IPV4_SEPARATORS | | currentIndex > = bytes . length ) { return null ; } if ( ipv6Seperators = = <int> ) { compressLength = <int> ; } else if ( ipv6Seperators > = IPV6_MIN_SEPARATORS & & ip . charAt ( ipLength - <int> ) ! = <str> & & ( ! isCompressed & & ( ipv6Seperators = = <int> & & ip . charAt ( <int> ) ! = <str> ) | | isCompressed & & ( ipv6Seperators + <int> < IPV6_MAX_SEPARATORS & & ( ip . charAt ( <int> ) ! = <str> | | compressBegin < = <int> ) ) ) ) { compressLength - = <int> ; } else { return null ; } value < < = ( IPV4_MAX_CHAR_BETWEEN_SEPARATOR - ( i - begin ) ) < < <int> ; begin = ( value & <hex> ) * <int> + ( ( value > > <int> ) & <hex> ) * <int> + ( ( value > > <int> ) & <hex> ) ; if ( begin < <int> | | begin > <int> ) { return null ; } bytes [ currentIndex + + ] = ( byte ) begin ; } else { tmp = ipLength - <int> ; if ( begin > <int> & & i - begin > IPV6_MAX_CHAR_BETWEEN_SEPARATOR | | ipv6Seperators < IPV6_MIN_SEPARATORS | | ! isCompressed & & ( ipv6Seperators + <int> ! = IPV6_MAX_SEPARATORS | | ip . charAt ( <int> ) = = <str> | | ip . charAt ( tmp ) = = <str> ) | | isCompressed & & ( ipv6Seperators > IPV6_MAX_SEPARATORS | | ( ipv6Seperators = = IPV6_MAX_SEPARATORS & & ( compressBegin < = <int> & & ip . charAt ( <int> ) ! = <str> | | compressBegin > = <int> & & ip . charAt ( tmp ) ! = <str> ) ) ) | | currentIndex + <int> > = bytes . length ) { return null ; } if ( begin > = <int> & & i - begin < = IPV6_MAX_CHAR_BETWEEN_SEPARATOR ) { value < < = ( IPV6_MAX_CHAR_BETWEEN_SEPARATOR - ( i - begin ) ) < < <int> ; } bytes [ currentIndex + + ] = ( byte ) ( ( ( value & <hex> ) < < <int> ) | ( ( value > > <int> ) & <hex> ) ) ; bytes [ currentIndex + + ] = ( byte ) ( ( ( ( value > > <int> ) & <hex> ) < < <int> ) | ( ( value > > <int> ) & <hex> ) ) ; } i = currentIndex + compressLength ; if ( needsShift | | i > = bytes . length ) { if ( i > = bytes . length ) { + + compressBegin ; } for ( i = currentIndex ; i < bytes . length ; + + i ) { for ( begin = bytes . length - <int> ; begin > = compressBegin ; - - begin ) { bytes [ begin ] = bytes [ begin - <int> ] ; } bytes [ begin ] = <int> ; + + compressBegin ; } } else { for ( i = <int> ; i < compressLength ; + + i ) { begin = i + compressBegin ; currentIndex = begin + compressLength ; if ( currentIndex < bytes . length ) { bytes [ currentIndex ] = bytes [ begin ] ; bytes [ begin ] = <int> ; } else { break ; } } } if ( ipv4Mapped & & ipv4Seperators > <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> & & bytes [ <int> ] = = <int> ) { bytes [ <int> ] = bytes [ <int> ] = ( byte ) <hex> ; } try { return Inet6Address . getByAddress ( null , bytes , - <int> ) ; } catch ( UnknownHostException e ) { throw new RuntimeException ( e ) ; } } public static String toAddressString ( InetAddress ip ) { return toAddressString ( ip , false ) ; } public static String toAddressString ( InetAddress ip , boolean ipv4Mapped ) { if ( ip instanceof Inet4Address ) { return ip . getHostAddress ( ) ; } if ( ! ( ip instanceof Inet6Address ) ) { throw new IllegalArgumentException ( <str> + ip . getClass ( ) ) ; } final byte [ ] bytes = ip . getAddress ( ) ; final int [ ] words = new int [ IPV6_WORD_COUNT ] ; int i ; for ( i = <int> ; i < words . length ; + + i ) { words [ i ] = ( ( bytes [ i < < <int> ] & <hex> ) < < <int> ) | ( bytes [ ( i < < <int> ) + <int> ] & <hex> ) ; } int currentStart = - <int> ; int currentLength = <int> ; int shortestStart = - <int> ; int shortestLength = <int> ; for ( i = <int> ; i < words . length ; + + i ) { if ( words [ i ] = = <int> ) { if ( currentStart < <int> ) { currentStart = i ; } } else if ( currentStart > = <int> ) { currentLength = i - currentStart ; if ( currentLength > shortestLength ) { shortestStart = currentStart ; shortestLength = currentLength ; } currentStart = - <int> ; } } if ( currentStart > = <int> ) { currentLength = i - currentStart ; if ( currentLength > shortestLength ) { shortestStart = currentStart ; shortestLength = currentLength ; } } if ( shortestLength = = <int> ) { shortestLength = <int> ; shortestStart = - <int> ; } final int shortestEnd = shortestStart + shortestLength ; final StringBuilder b = new StringBuilder ( IPV6_MAX_CHAR_COUNT ) ; if ( shortestEnd < <int> ) { b . append ( Integer . toHexString ( words [ <int> ] ) ) ; for ( i = <int> ; i < words . length ; + + i ) { b . append ( <str> ) ; b . append ( Integer . toHexString ( words [ i ] ) ) ; } } else { final boolean isIpv4Mapped ; if ( inRangeEndExclusive ( <int> , shortestStart , shortestEnd ) ) { b . append ( <str> ) ; isIpv4Mapped = ipv4Mapped & & ( shortestEnd = = <int> & & words [ <int> ] = = <hex> ) ; } else { b . append ( Integer . toHexString ( words [ <int> ] ) ) ; isIpv4Mapped = false ; } for ( i = <int> ; i < words . length ; + + i ) { if ( ! inRangeEndExclusive ( i , shortestStart , shortestEnd ) ) { if ( ! inRangeEndExclusive ( i - <int> , shortestStart , shortestEnd ) ) { if ( ! isIpv4Mapped | | i = = <int> ) { b . append ( <str> ) ; } else { b . append ( <str> ) ; } } if ( isIpv4Mapped & & i > <int> ) { b . append ( words [ i ] > > <int> ) ; b . append ( <str> ) ; b . append ( words [ i ] & <hex> ) ; } else { b . append ( Integer . toHexString ( words [ i ] ) ) ; } } else if ( ! inRangeEndExclusive ( i - <int> , shortestStart , shortestEnd ) ) { b . append ( <str> ) ; } } } return b . toString ( ) ; } private static boolean inRangeEndExclusive ( int value , int start , int end ) { return value > = start & & value < end ; } private NetUtil ( ) { } } 
