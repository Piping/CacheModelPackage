package org . elasticsearch . index . analysis ; import org . apache . lucene . analysis . charfilter . MappingCharFilter ; import org . apache . lucene . analysis . charfilter . NormalizeCharMap ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . index . IndexSettings ; import java . io . Reader ; import java . util . List ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class MappingCharFilterFactory extends AbstractCharFilterFactory { private final NormalizeCharMap normMap ; public MappingCharFilterFactory ( IndexSettings indexSettings , Environment env , String name , Settings settings ) { super ( indexSettings , name ) ; List < String > rules = Analysis . getWordList ( env , settings , <str> ) ; if ( rules = = null ) { throw new IllegalArgumentException ( <str> ) ; } NormalizeCharMap . Builder normMapBuilder = new NormalizeCharMap . Builder ( ) ; parseRules ( rules , normMapBuilder ) ; normMap = normMapBuilder . build ( ) ; } @Override public Reader create ( Reader tokenStream ) { return new MappingCharFilter ( normMap , tokenStream ) ; } private static Pattern rulePattern = Pattern . compile ( <str> ) ; private void parseRules ( List < String > rules , NormalizeCharMap . Builder map ) { for ( String rule : rules ) { Matcher m = rulePattern . matcher ( rule ) ; if ( ! m . find ( ) ) throw new RuntimeException ( <str> + rule + <str> ) ; String lhs = parseString ( m . group ( <int> ) . trim ( ) ) ; String rhs = parseString ( m . group ( <int> ) . trim ( ) ) ; if ( lhs = = null | | rhs = = null ) throw new RuntimeException ( <str> + rule + <str> ) ; map . add ( lhs , rhs ) ; } } char [ ] out = new char [ <int> ] ; private String parseString ( String s ) { int readPos = <int> ; int len = s . length ( ) ; int writePos = <int> ; while ( readPos < len ) { char c = s . charAt ( readPos + + ) ; if ( c = = <str> ) { if ( readPos > = len ) throw new RuntimeException ( <str> + s + <str> ) ; c = s . charAt ( readPos + + ) ; switch ( c ) { case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : c = <str> ; break ; case <str> : if ( readPos + <int> > = len ) throw new RuntimeException ( <str> + s + <str> ) ; c = ( char ) Integer . parseInt ( s . substring ( readPos , readPos + <int> ) , <int> ) ; readPos + = <int> ; break ; } } out [ writePos + + ] = c ; } return new String ( out , <int> , writePos ) ; } } 
