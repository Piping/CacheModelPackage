package org . gradle . api . tasks . diagnostics . internal . dsl ; import groovy . lang . Closure ; import org . gradle . api . artifacts . result . DependencyResult ; import org . gradle . api . specs . Spec ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . typeconversion . * ; public class DependencyResultSpecNotationConverter implements NotationConverter < String , Spec < DependencyResult > > { public void convert ( String notation , NotationConvertResult < ? super Spec < DependencyResult > > result ) throws TypeConversionException { final String stringNotation = notation . trim ( ) ; if ( stringNotation . length ( ) > <int> ) { result . converted ( new DependencyResultSpec ( stringNotation ) ) ; } } @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) . example ( <str> ) ; } public static NotationParser < Object , Spec < DependencyResult > > parser ( ) { return NotationParserBuilder . toType ( new TypeInfo < Spec < DependencyResult > > ( Spec . class ) ) . invalidNotationMessage ( <str> ) . fromType ( Closure . class , new ClosureToSpecNotationConverter < DependencyResult > ( DependencyResult . class ) ) . fromCharSequence ( new DependencyResultSpecNotationConverter ( ) ) . toComposite ( ) ; } } 
