package jcuda . jcublas . context ; import static jcuda . runtime . JCuda . cudaDeviceSynchronize ; import static jcuda . runtime . JCuda . cudaEventCreate ; import static jcuda . runtime . JCuda . cudaEventDestroy ; import static jcuda . runtime . JCuda . cudaEventElapsedTime ; import static jcuda . runtime . JCuda . cudaEventRecord ; import static jcuda . runtime . JCuda . cudaFree ; import static jcuda . runtime . JCuda . cudaFreeHost ; import static jcuda . runtime . JCuda . cudaHostAlloc ; import static jcuda . runtime . JCuda . cudaHostAllocWriteCombined ; import static jcuda . runtime . JCuda . cudaMalloc ; import static jcuda . runtime . JCuda . cudaMemcpyAsync ; import static jcuda . runtime . JCuda . cudaSetDevice ; import static jcuda . runtime . cudaMemcpyKind . cudaMemcpyHostToDevice ; import java . nio . ByteBuffer ; import java . util . Locale ; import jcuda . Pointer ; import jcuda . runtime . cudaEvent_t ; public class JCudaBandwidthTest { enum HostMemoryMode { PINNED , PAGEABLE_ARRAY , PAGEABLE_DIRECT_BUFFER , } public static void main ( String [ ] args ) { int device = <int> ; cudaSetDevice ( device ) ; int hostAllocFlags = cudaHostAllocWriteCombined ; runTest ( HostMemoryMode . PINNED , hostAllocFlags ) ; runTest ( HostMemoryMode . PAGEABLE_ARRAY , hostAllocFlags ) ; runTest ( HostMemoryMode . PAGEABLE_DIRECT_BUFFER , hostAllocFlags ) ; System . out . println ( <str> ) ; } static void runTest ( HostMemoryMode hostMemoryMode , int hostAllocFlags ) { int minExponent = <int> ; int maxExponent = <int> ; int count = maxExponent - minExponent ; int memorySizes [ ] = new int [ count ] ; float bandwidths [ ] = new float [ memorySizes . length ] ; System . out . print ( <str> ) ; for ( int i = <int> ; i < count ; i + + ) { System . out . print ( <str> ) ; memorySizes [ i ] = ( <int> < < minExponent + i ) ; float bandwidth = computeBandwidth ( hostMemoryMode , hostAllocFlags , memorySizes [ i ] ) ; bandwidths [ i ] = bandwidth ; } System . out . println ( ) ; System . out . println ( <str> + hostMemoryMode ) ; for ( int i = <int> ; i < memorySizes . length ; i + + ) { String s = String . format ( <str> , memorySizes [ i ] ) ; String b = String . format ( Locale . ENGLISH , <str> , bandwidths [ i ] ) ; System . out . println ( s + <str> + b + <str> ) ; } System . out . println ( <str> ) ; } static void computeBandwidths ( HostMemoryMode hostMemoryMode , int hostAllocFlags , int memorySizes [ ] , float bandwidths [ ] ) { for ( int i = <int> ; i < memorySizes . length ; i + + ) { int memorySize = memorySizes [ i ] ; float bandwidth = computeBandwidth ( hostMemoryMode , hostAllocFlags , memorySize ) ; bandwidths [ i ] = bandwidth ; } } static float computeBandwidth ( HostMemoryMode hostMemoryMode , int hostAllocFlags , int memorySize ) { Pointer hostData = null ; ByteBuffer hostDataBuffer = null ; if ( hostMemoryMode = = HostMemoryMode . PINNED ) { hostData = new Pointer ( ) ; cudaHostAlloc ( hostData , memorySize , hostAllocFlags ) ; hostDataBuffer = hostData . getByteBuffer ( <int> , memorySize ) ; } else if ( hostMemoryMode = = HostMemoryMode . PAGEABLE_ARRAY ) { byte array [ ] = new byte [ memorySize ] ; hostDataBuffer = ByteBuffer . wrap ( array ) ; hostData = Pointer . to ( array ) ; } else { hostDataBuffer = ByteBuffer . allocateDirect ( memorySize ) ; hostData = Pointer . to ( hostDataBuffer ) ; } for ( int i = <int> ; i < memorySize ; i + + ) { hostDataBuffer . put ( i , ( byte ) i ) ; } Pointer deviceData = new Pointer ( ) ; cudaMalloc ( deviceData , memorySize ) ; final int runs = <int> ; float bandwidth = computeBandwidth ( deviceData , hostData , cudaMemcpyHostToDevice , memorySize , runs ) ; if ( hostMemoryMode = = HostMemoryMode . PINNED ) { cudaFreeHost ( hostData ) ; } cudaFree ( deviceData ) ; return bandwidth ; } static float computeBandwidth ( Pointer dstData , Pointer srcData , int memcopyKind , int memSize , int runs ) { cudaEvent_t start = new cudaEvent_t ( ) ; cudaEvent_t stop = new cudaEvent_t ( ) ; cudaEventCreate ( start ) ; cudaEventCreate ( stop ) ; cudaEventRecord ( start , null ) ; for ( int i = <int> ; i < runs ; i + + ) { cudaMemcpyAsync ( dstData , srcData , memSize , memcopyKind , null ) ; } cudaEventRecord ( stop , null ) ; cudaDeviceSynchronize ( ) ; float elapsedTimeMsArray [ ] = { Float . NaN } ; cudaEventElapsedTime ( elapsedTimeMsArray , start , stop ) ; float elapsedTimeMs = elapsedTimeMsArray [ <int> ] ; float bandwidthInBytesPerMs = ( ( float ) memSize * runs ) / elapsedTimeMs ; float bandwidth = bandwidthInBytesPerMs / <int> ; cudaEventDestroy ( stop ) ; cudaEventDestroy ( start ) ; return bandwidth ; } } 
