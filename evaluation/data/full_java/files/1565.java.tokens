package org . apache . cassandra . io . sstable ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . List ; import com . google . common . collect . Iterables ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DataRange ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . db . RowUpdateBuilder ; import org . apache . cassandra . db . Slices ; import org . apache . cassandra . db . filter . ClusteringIndexSliceFilter ; import org . apache . cassandra . db . filter . ColumnFilter ; import org . apache . cassandra . dht . AbstractBounds ; import org . apache . cassandra . dht . ByteOrderedPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . apache . cassandra . dht . AbstractBounds . isEmpty ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; public class SSTableScannerTest { public static final String KEYSPACE = <str> ; public static final String TABLE = <str> ; @BeforeClass public static void defineSchema ( ) throws Exception { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE , TABLE ) ) ; } private static String toKey ( int key ) { return String . format ( <str> , key ) ; } private static Iterable < DataRange > dataRanges ( CFMetaData metadata , int start , int end ) { if ( end < start ) return dataRanges ( metadata , start , end , false , true ) ; return Iterables . concat ( dataRanges ( metadata , start , end , false , false ) , dataRanges ( metadata , start , end , false , true ) , dataRanges ( metadata , start , end , true , false ) , dataRanges ( metadata , start , end , true , true ) ) ; } private static Iterable < DataRange > dataRanges ( CFMetaData metadata , int start , int end , boolean inclusiveStart , boolean inclusiveEnd ) { List < DataRange > ranges = new ArrayList < > ( ) ; if ( start = = end + <int> ) { assert ! inclusiveStart & & inclusiveEnd ; ranges . add ( dataRange ( metadata , min ( start ) , false , max ( end ) , true ) ) ; ranges . add ( dataRange ( metadata , min ( start ) , false , min ( end + <int> ) , true ) ) ; ranges . add ( dataRange ( metadata , max ( start - <int> ) , false , max ( end ) , true ) ) ; ranges . add ( dataRange ( metadata , dk ( start - <int> ) , false , dk ( start - <int> ) , true ) ) ; } else { for ( PartitionPosition s : starts ( start , inclusiveStart ) ) { for ( PartitionPosition e : ends ( end , inclusiveEnd ) ) { if ( end < start & & e . compareTo ( s ) > <int> ) continue ; if ( ! isEmpty ( new AbstractBounds . Boundary < > ( s , inclusiveStart ) , new AbstractBounds . Boundary < > ( e , inclusiveEnd ) ) ) continue ; ranges . add ( dataRange ( metadata , s , inclusiveStart , e , inclusiveEnd ) ) ; } } } return ranges ; } private static Iterable < PartitionPosition > starts ( int key , boolean inclusive ) { return Arrays . asList ( min ( key ) , max ( key - <int> ) , dk ( inclusive ? key : key - <int> ) ) ; } private static Iterable < PartitionPosition > ends ( int key , boolean inclusive ) { return Arrays . asList ( max ( key ) , min ( key + <int> ) , dk ( inclusive ? key : key + <int> ) ) ; } private static DecoratedKey dk ( int key ) { return Util . dk ( toKey ( key ) ) ; } private static Token token ( int key ) { return key = = Integer . MIN_VALUE ? ByteOrderedPartitioner . MINIMUM : new ByteOrderedPartitioner . BytesToken ( toKey ( key ) . getBytes ( ) ) ; } private static PartitionPosition min ( int key ) { return token ( key ) . minKeyBound ( ) ; } private static PartitionPosition max ( int key ) { return token ( key ) . maxKeyBound ( ) ; } private static DataRange dataRange ( CFMetaData metadata , PartitionPosition start , boolean startInclusive , PartitionPosition end , boolean endInclusive ) { Slices . Builder sb = new Slices . Builder ( metadata . comparator ) ; ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter ( sb . build ( ) , false ) ; return new DataRange ( AbstractBounds . bounds ( start , startInclusive , end , endInclusive ) , filter ) ; } private static Range < Token > rangeFor ( int start , int end ) { return new Range < Token > ( new ByteOrderedPartitioner . BytesToken ( toKey ( start ) . getBytes ( ) ) , end = = Integer . MIN_VALUE ? ByteOrderedPartitioner . MINIMUM : new ByteOrderedPartitioner . BytesToken ( toKey ( end ) . getBytes ( ) ) ) ; } private static Collection < Range < Token > > makeRanges ( int . . . keys ) { Collection < Range < Token > > ranges = new ArrayList < Range < Token > > ( keys . length / <int> ) ; for ( int i = <int> ; i < keys . length ; i + = <int> ) ranges . add ( rangeFor ( keys [ i ] , keys [ i + <int> ] ) ) ; return ranges ; } private static void insertRowWithKey ( CFMetaData metadata , int key ) { long timestamp = System . currentTimeMillis ( ) ; new RowUpdateBuilder ( metadata , timestamp , toKey ( key ) ) . clustering ( <str> ) . add ( <str> , ByteBufferUtil . EMPTY_BYTE_BUFFER ) . build ( ) . applyUnsafe ( ) ; } private static void assertScanMatches ( SSTableReader sstable , int scanStart , int scanEnd , int . . . boundaries ) { assert boundaries . length % <int> = = <int> ; for ( DataRange range : dataRanges ( sstable . metadata , scanStart , scanEnd ) ) { try ( ISSTableScanner scanner = sstable . getScanner ( ColumnFilter . all ( sstable . metadata ) , range , false ) ) { for ( int b = <int> ; b < boundaries . length ; b + = <int> ) for ( int i = boundaries [ b ] ; i < = boundaries [ b + <int> ] ; i + + ) assertEquals ( toKey ( i ) , new String ( scanner . next ( ) . partitionKey ( ) . getKey ( ) . array ( ) ) ) ; assertFalse ( scanner . hasNext ( ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } private static void assertScanEmpty ( SSTableReader sstable , int scanStart , int scanEnd ) { assertScanMatches ( sstable , scanStart , scanEnd ) ; } @Test public void testSingleDataRange ( ) throws IOException { Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( TABLE ) ; store . clearUnsafe ( ) ; store . disableAutoCompaction ( ) ; for ( int i = <int> ; i < <int> ; i + + ) insertRowWithKey ( store . metadata , i ) ; store . forceBlockingFlush ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; ISSTableScanner scanner = sstable . getScanner ( null ) ; for ( int i = <int> ; i < <int> ; i + + ) assertEquals ( toKey ( i ) , new String ( scanner . next ( ) . partitionKey ( ) . getKey ( ) . array ( ) ) ) ; scanner . close ( ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanEmpty ( sstable , <int> , <int> ) ; assertScanEmpty ( sstable , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , Integer . MIN_VALUE , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , Integer . MIN_VALUE , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , Integer . MIN_VALUE , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanEmpty ( sstable , <int> , <int> ) ; assertScanEmpty ( sstable , <int> , Integer . MIN_VALUE ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanEmpty ( sstable , <int> , <int> ) ; assertScanEmpty ( sstable , <int> , Integer . MIN_VALUE ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , Integer . MIN_VALUE , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , Integer . MIN_VALUE , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , Integer . MIN_VALUE , <int> , <int> ) ; assertScanMatches ( sstable , <int> , - <int> , <int> , <int> ) ; assertScanMatches ( sstable , <int> , Integer . MIN_VALUE , <int> , <int> ) ; assertScanMatches ( sstable , <int> , <int> , <int> , <int> ) ; } private static void assertScanContainsRanges ( ISSTableScanner scanner , int . . . rangePairs ) throws IOException { assert rangePairs . length % <int> = = <int> ; for ( int pairIdx = <int> ; pairIdx < rangePairs . length ; pairIdx + = <int> ) { int rangeStart = rangePairs [ pairIdx ] ; int rangeEnd = rangePairs [ pairIdx + <int> ] ; for ( int expected = rangeStart ; expected < = rangeEnd ; expected + + ) { assertTrue ( String . format ( <str> , expected ) , scanner . hasNext ( ) ) ; assertEquals ( toKey ( expected ) , new String ( scanner . next ( ) . partitionKey ( ) . getKey ( ) . array ( ) ) ) ; } } assertFalse ( scanner . hasNext ( ) ) ; scanner . close ( ) ; } @Test public void testMultipleRanges ( ) throws IOException { Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( TABLE ) ; store . clearUnsafe ( ) ; store . disableAutoCompaction ( ) ; for ( int i = <int> ; i < <int> ; i + + ) for ( int j = <int> ; j < <int> ; j + + ) insertRowWithKey ( store . metadata , i * <int> + j ) ; store . forceBlockingFlush ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; ISSTableScanner fullScanner = sstable . getScanner ( null ) ; assertScanContainsRanges ( fullScanner , <int> , <int> , <int> , <int> , <int> , <int> ) ; ISSTableScanner scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> , <int> , <int> , <int> , <int> ) ; scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> , <int> , <int> ) , null ) ; assertFalse ( scanner . hasNext ( ) ) ; scanner = sstable . getScanner ( new ArrayList < Range < Token > > ( ) , null ) ; assertFalse ( scanner . hasNext ( ) ) ; } @Test public void testSingleKeyMultipleRanges ( ) throws IOException { Keyspace keyspace = Keyspace . open ( KEYSPACE ) ; ColumnFamilyStore store = keyspace . getColumnFamilyStore ( TABLE ) ; store . clearUnsafe ( ) ; store . disableAutoCompaction ( ) ; insertRowWithKey ( store . metadata , <int> ) ; store . forceBlockingFlush ( ) ; assertEquals ( <int> , store . getLiveSSTables ( ) . size ( ) ) ; SSTableReader sstable = store . getLiveSSTables ( ) . iterator ( ) . next ( ) ; ISSTableScanner fullScanner = sstable . getScanner ( null ) ; assertScanContainsRanges ( fullScanner , <int> , <int> ) ; ISSTableScanner scanner = sstable . getScanner ( makeRanges ( <int> , <int> , <int> , <int> ) , null ) ; assertScanContainsRanges ( scanner , <int> , <int> ) ; } } 
