package com . google . common . math ; import static com . google . common . base . Preconditions . checkArgument ; import static java . lang . Double . NEGATIVE_INFINITY ; import static java . lang . Double . NaN ; import static java . lang . Double . POSITIVE_INFINITY ; import static java . util . Arrays . sort ; import static java . util . Collections . unmodifiableMap ; import com . google . common . annotations . Beta ; import com . google . common . primitives . Doubles ; import com . google . common . primitives . Ints ; import java . math . RoundingMode ; import java . util . Collection ; import java . util . HashMap ; import java . util . Map ; @Beta public final class Quantiles { public static ScaleAndIndex median ( ) { return scale ( <int> ) . index ( <int> ) ; } public static Scale quartiles ( ) { return scale ( <int> ) ; } public static Scale percentiles ( ) { return scale ( <int> ) ; } public static Scale scale ( int scale ) { return new Scale ( scale ) ; } public static final class Scale { private final int scale ; private Scale ( int scale ) { checkArgument ( scale > <int> , <str> ) ; this . scale = scale ; } public ScaleAndIndex index ( int index ) { return new ScaleAndIndex ( scale , index ) ; } public ScaleAndIndexes indexes ( int . . . indexes ) { return new ScaleAndIndexes ( scale , indexes . clone ( ) ) ; } public ScaleAndIndexes indexes ( Collection < Integer > indexes ) { return new ScaleAndIndexes ( scale , Ints . toArray ( indexes ) ) ; } } public static final class ScaleAndIndex { private final int scale ; private final int index ; private ScaleAndIndex ( int scale , int index ) { checkIndex ( index , scale ) ; this . scale = scale ; this . index = index ; } public double compute ( Collection < ? extends Number > dataset ) { return computeInPlace ( Doubles . toArray ( dataset ) ) ; } public double compute ( double . . . dataset ) { return computeInPlace ( dataset . clone ( ) ) ; } public double compute ( long . . . dataset ) { return computeInPlace ( longsToDoubles ( dataset ) ) ; } public double compute ( int . . . dataset ) { return computeInPlace ( intsToDoubles ( dataset ) ) ; } public double computeInPlace ( double . . . dataset ) { checkArgument ( dataset . length > <int> , <str> ) ; if ( containsNaN ( dataset ) ) { return NaN ; } long numerator = ( long ) index * ( dataset . length - <int> ) ; int quotient = ( int ) LongMath . divide ( numerator , scale , RoundingMode . DOWN ) ; int remainder = ( int ) ( numerator - ( long ) quotient * scale ) ; selectInPlace ( quotient , dataset , <int> , dataset . length - <int> ) ; if ( remainder = = <int> ) { return dataset [ quotient ] ; } else { selectInPlace ( quotient + <int> , dataset , quotient + <int> , dataset . length - <int> ) ; return interpolate ( dataset [ quotient ] , dataset [ quotient + <int> ] , remainder , scale ) ; } } } public static final class ScaleAndIndexes { private final int scale ; private final int [ ] indexes ; private ScaleAndIndexes ( int scale , int [ ] indexes ) { for ( int index : indexes ) { checkIndex ( index , scale ) ; } this . scale = scale ; this . indexes = indexes ; } public Map < Integer , Double > compute ( Collection < ? extends Number > dataset ) { return computeInPlace ( Doubles . toArray ( dataset ) ) ; } public Map < Integer , Double > compute ( double . . . dataset ) { return computeInPlace ( dataset . clone ( ) ) ; } public Map < Integer , Double > compute ( long . . . dataset ) { return computeInPlace ( longsToDoubles ( dataset ) ) ; } public Map < Integer , Double > compute ( int . . . dataset ) { return computeInPlace ( intsToDoubles ( dataset ) ) ; } public Map < Integer , Double > computeInPlace ( double . . . dataset ) { checkArgument ( dataset . length > <int> , <str> ) ; if ( containsNaN ( dataset ) ) { Map < Integer , Double > nanMap = new HashMap < Integer , Double > ( ) ; for ( int index : indexes ) { nanMap . put ( index , NaN ) ; } return unmodifiableMap ( nanMap ) ; } int [ ] quotients = new int [ indexes . length ] ; int [ ] remainders = new int [ indexes . length ] ; int [ ] requiredSelections = new int [ indexes . length * <int> ] ; int requiredSelectionsCount = <int> ; for ( int i = <int> ; i < indexes . length ; i + + ) { long numerator = ( long ) indexes [ i ] * ( dataset . length - <int> ) ; int quotient = ( int ) LongMath . divide ( numerator , scale , RoundingMode . DOWN ) ; int remainder = ( int ) ( numerator - ( long ) quotient * scale ) ; quotients [ i ] = quotient ; remainders [ i ] = remainder ; requiredSelections [ requiredSelectionsCount ] = quotient ; requiredSelectionsCount + + ; if ( remainder ! = <int> ) { requiredSelections [ requiredSelectionsCount ] = quotient + <int> ; requiredSelectionsCount + + ; } } sort ( requiredSelections , <int> , requiredSelectionsCount ) ; selectAllInPlace ( requiredSelections , <int> , requiredSelectionsCount - <int> , dataset , <int> , dataset . length - <int> ) ; Map < Integer , Double > ret = new HashMap < Integer , Double > ( ) ; for ( int i = <int> ; i < indexes . length ; i + + ) { int quotient = quotients [ i ] ; int remainder = remainders [ i ] ; if ( remainder = = <int> ) { ret . put ( indexes [ i ] , dataset [ quotient ] ) ; } else { ret . put ( indexes [ i ] , interpolate ( dataset [ quotient ] , dataset [ quotient + <int> ] , remainder , scale ) ) ; } } return unmodifiableMap ( ret ) ; } } private static boolean containsNaN ( double . . . dataset ) { for ( double value : dataset ) { if ( Double . isNaN ( value ) ) { return true ; } } return false ; } private static double interpolate ( double lower , double upper , double remainder , double scale ) { if ( lower = = NEGATIVE_INFINITY ) { if ( upper = = POSITIVE_INFINITY ) { return NaN ; } return NEGATIVE_INFINITY ; } if ( upper = = POSITIVE_INFINITY ) { return POSITIVE_INFINITY ; } return lower + ( upper - lower ) * remainder / scale ; } private static void checkIndex ( int index , int scale ) { if ( index < <int> | | index > scale ) { throw new IllegalArgumentException ( <str> + scale ) ; } } private static double [ ] longsToDoubles ( long [ ] longs ) { int len = longs . length ; double [ ] doubles = new double [ len ] ; for ( int i = <int> ; i < len ; i + + ) { doubles [ i ] = longs [ i ] ; } return doubles ; } private static double [ ] intsToDoubles ( int [ ] ints ) { int len = ints . length ; double [ ] doubles = new double [ len ] ; for ( int i = <int> ; i < len ; i + + ) { doubles [ i ] = ints [ i ] ; } return doubles ; } private static void selectInPlace ( int required , double [ ] array , int from , int to ) { if ( required = = from ) { int min = from ; for ( int index = from + <int> ; index < = to ; index + + ) { if ( array [ min ] > array [ index ] ) { min = index ; } } if ( min ! = from ) { swap ( array , min , from ) ; } return ; } while ( to > from ) { int partitionPoint = partition ( array , from , to ) ; if ( partitionPoint > = required ) { to = partitionPoint - <int> ; } if ( partitionPoint < = required ) { from = partitionPoint + <int> ; } } } private static int partition ( double [ ] array , int from , int to ) { movePivotToStartOfSlice ( array , from , to ) ; double pivot = array [ from ] ; int partitionPoint = to ; for ( int i = to ; i > from ; i - - ) { if ( array [ i ] > pivot ) { swap ( array , partitionPoint , i ) ; partitionPoint - - ; } } swap ( array , from , partitionPoint ) ; return partitionPoint ; } private static void movePivotToStartOfSlice ( double [ ] array , int from , int to ) { int mid = ( from + to ) > > > <int> ; boolean toLessThanMid = ( array [ to ] < array [ mid ] ) ; boolean midLessThanFrom = ( array [ mid ] < array [ from ] ) ; boolean toLessThanFrom = ( array [ to ] < array [ from ] ) ; if ( toLessThanMid = = midLessThanFrom ) { swap ( array , mid , from ) ; } else if ( toLessThanMid ! = toLessThanFrom ) { swap ( array , from , to ) ; } } private static void selectAllInPlace ( int [ ] allRequired , int requiredFrom , int requiredTo , double [ ] array , int from , int to ) { int requiredChosen = chooseNextSelection ( allRequired , requiredFrom , requiredTo , from , to ) ; int required = allRequired [ requiredChosen ] ; selectInPlace ( required , array , from , to ) ; int requiredBelow = requiredChosen - <int> ; while ( requiredBelow > = requiredFrom & & allRequired [ requiredBelow ] = = required ) { requiredBelow - - ; } if ( requiredBelow > = requiredFrom ) { selectAllInPlace ( allRequired , requiredFrom , requiredBelow , array , from , required - <int> ) ; } int requiredAbove = requiredChosen + <int> ; while ( requiredAbove < = requiredTo & & allRequired [ requiredAbove ] = = required ) { requiredAbove + + ; } if ( requiredAbove < = requiredTo ) { selectAllInPlace ( allRequired , requiredAbove , requiredTo , array , required + <int> , to ) ; } } private static int chooseNextSelection ( int [ ] allRequired , int requiredFrom , int requiredTo , int from , int to ) { if ( requiredFrom = = requiredTo ) { return requiredFrom ; } int centerFloor = ( from + to ) > > > <int> ; int low = requiredFrom ; int high = requiredTo ; while ( high > low + <int> ) { int mid = ( low + high ) > > > <int> ; if ( allRequired [ mid ] > centerFloor ) { high = mid ; } else if ( allRequired [ mid ] < centerFloor ) { low = mid ; } else { return mid ; } } if ( from + to - allRequired [ low ] - allRequired [ high ] > <int> ) { return high ; } else { return low ; } } private static void swap ( double [ ] array , int i , int j ) { double temp = array [ i ] ; array [ i ] = array [ j ] ; array [ j ] = temp ; } } 
