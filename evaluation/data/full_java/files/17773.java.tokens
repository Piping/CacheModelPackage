package com . badlogic . gdx . jnigen ; import java . io . BufferedReader ; import java . io . File ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class BuildExecutor { public static boolean executeAnt ( String buildFile , String params ) { FileDescriptor build = new FileDescriptor ( buildFile ) ; String ant = System . getProperty ( <str> ) . contains ( <str> ) ? <str> : <str> ; String command = ant + <str> + build . file ( ) . getAbsolutePath ( ) + <str> + params ; System . out . println ( <str> + command + <str> ) ; return startProcess ( command , build . parent ( ) . file ( ) ) ; } public static void executeNdk ( String directory ) { FileDescriptor build = new FileDescriptor ( directory ) ; String command = <str> ; startProcess ( command , build . file ( ) ) ; } private static boolean startProcess ( String command , File directory ) { try { final Process process = new ProcessBuilder ( command . split ( <str> ) ) . redirectErrorStream ( true ) . start ( ) ; Thread t = new Thread ( new Runnable ( ) { @Override public void run ( ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; String line = null ; try { while ( ( line = reader . readLine ( ) ) ! = null ) { printFileLineNumber ( line ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } private void printFileLineNumber ( String line ) { if ( line . contains ( <str> ) | | line . contains ( <str> ) ) { try { String fileName = getFileName ( line ) ; String error = getError ( line ) ; int lineNumber = getLineNumber ( line ) - <int> ; if ( fileName ! = null & & lineNumber > = <int> ) { FileDescriptor file = new FileDescriptor ( fileName ) ; if ( file . exists ( ) ) { String [ ] content = file . readString ( ) . split ( <str> ) ; if ( lineNumber < content . length ) { for ( int i = lineNumber ; i > = <int> ; i - - ) { String contentLine = content [ i ] ; if ( contentLine . startsWith ( <str> ) ) { int javaLineNumber = Integer . parseInt ( contentLine . split ( <str> ) [ <int> ] . trim ( ) ) ; System . out . flush ( ) ; if ( line . contains ( <str> ) ) { System . out . println ( <str> + file . nameWithoutExtension ( ) + <str> + ( javaLineNumber + ( lineNumber - i ) - <int> ) + <str> + error + <str> + line ) ; System . out . flush ( ) ; } else { System . err . println ( <str> + file . nameWithoutExtension ( ) + <str> + ( javaLineNumber + ( lineNumber - i ) - <int> ) + <str> + error + <str> + line ) ; System . err . flush ( ) ; } return ; } } } } else { System . out . println ( line ) ; } } } catch ( Throwable t ) { System . out . println ( line ) ; } } else { System . out . println ( line ) ; } } private String getFileName ( String line ) { Pattern pattern = Pattern . compile ( <str> ) ; Matcher matcher = pattern . matcher ( line ) ; matcher . find ( ) ; String fileName = matcher . groupCount ( ) > = <int> ? matcher . group ( <int> ) . trim ( ) : null ; if ( fileName = = null ) return null ; int index = fileName . indexOf ( <str> ) ; if ( index ! = - <int> ) return fileName . substring ( index ) . trim ( ) ; else return fileName ; } private String getError ( String line ) { Pattern pattern = Pattern . compile ( <str> ) ; Matcher matcher = pattern . matcher ( line ) ; matcher . find ( ) ; return matcher . groupCount ( ) > = <int> ? matcher . group ( <int> ) . trim ( ) : null ; } private int getLineNumber ( String line ) { Pattern pattern = Pattern . compile ( <str> ) ; Matcher matcher = pattern . matcher ( line ) ; matcher . find ( ) ; return matcher . groupCount ( ) > = <int> ? Integer . parseInt ( matcher . group ( <int> ) ) : - <int> ; } } ) ; t . setDaemon ( true ) ; t . start ( ) ; process . waitFor ( ) ; return process . exitValue ( ) = = <int> ; } catch ( Exception e ) { e . printStackTrace ( ) ; return false ; } } } 
