package org . gradle . api . internal . file . archive ; import org . apache . commons . io . IOUtils ; import org . gradle . api . GradleException ; import org . gradle . api . file . RelativePath ; import org . gradle . api . internal . file . CopyActionProcessingStreamAction ; import org . gradle . api . internal . file . FileResource ; import org . gradle . api . internal . file . archive . compression . ArchiveOutputStreamFactory ; import org . gradle . api . internal . file . archive . compression . Bzip2Archiver ; import org . gradle . api . internal . file . archive . compression . GzipArchiver ; import org . gradle . api . internal . file . archive . compression . SimpleCompressor ; import org . gradle . api . internal . file . copy . CopyActionProcessingStream ; import org . gradle . api . internal . file . copy . FileCopyDetailsInternal ; import org . gradle . test . fixtures . file . TestFile ; import org . gradle . test . fixtures . file . TestNameTestDirectoryProvider ; import org . hamcrest . Description ; import org . jmock . Expectations ; import org . jmock . api . Invocation ; import org . jmock . integration . junit4 . JMock ; import org . jmock . integration . junit4 . JUnit4Mockery ; import org . junit . Rule ; import org . junit . Test ; import org . junit . runner . RunWith ; import java . io . OutputStream ; import java . util . HashMap ; import java . util . Map ; import static org . gradle . api . file . FileVisitorUtil . assertVisitsPermissions ; import static org . gradle . api . internal . file . TestFiles . fileSystem ; import static org . gradle . api . internal . file . copy . CopyActionExecuterUtil . visit ; import static org . hamcrest . Matchers . * ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . fail ; @RunWith ( JMock . class ) public class TarCopyActionTest { @Rule public final TestNameTestDirectoryProvider tmpDir = new TestNameTestDirectoryProvider ( ) ; private final JUnit4Mockery context = new JUnit4Mockery ( ) ; private TarCopyAction action ; @Test public void createsTarFile ( ) { final TestFile tarFile = initializeTarFile ( tmpDir . getTestDirectory ( ) . file ( <str> ) , new SimpleCompressor ( ) ) ; tarAndUntarAndCheckFileContents ( tarFile ) ; } private void tarAndUntarAndCheckFileContents ( TestFile tarFile ) { tar ( file ( <str> ) , file ( <str> ) ) ; TestFile expandDir = tmpDir . getTestDirectory ( ) . file ( <str> ) ; tarFile . untarTo ( expandDir ) ; expandDir . file ( <str> ) . assertContents ( equalTo ( <str> ) ) ; expandDir . file ( <str> ) . assertContents ( equalTo ( <str> ) ) ; } @Test public void createsGzipCompressedTarFile ( ) { final TestFile tarFile = initializeTarFile ( tmpDir . getTestDirectory ( ) . file ( <str> ) , GzipArchiver . getCompressor ( ) ) ; tarAndUntarAndCheckFileContents ( tarFile ) ; } @Test public void createsBzip2CompressedTarFile ( ) { final TestFile tarFile = initializeTarFile ( tmpDir . getTestDirectory ( ) . file ( <str> ) , Bzip2Archiver . getCompressor ( ) ) ; tarAndUntarAndCheckFileContents ( tarFile ) ; } @Test public void tarFileContainsExpectedPermissions ( ) { final TestFile tarFile = initializeTarFile ( tmpDir . getTestDirectory ( ) . file ( <str> ) , new SimpleCompressor ( ) ) ; tar ( dir ( <str> ) , file ( <str> ) ) ; Map < String , Integer > expected = new HashMap < String , Integer > ( ) ; expected . put ( <str> , <int> ) ; expected . put ( <str> , <int> ) ; assertVisitsPermissions ( new TarFileTree ( tarFile , new FileResource ( tarFile ) , null , fileSystem ( ) ) , expected ) ; } @Test public void wrapsFailureToOpenOutputFile ( ) { final TestFile tarFile = initializeTarFile ( tmpDir . createDir ( <str> ) , new SimpleCompressor ( ) ) ; try { action . execute ( new CopyActionProcessingStream ( ) { public void process ( CopyActionProcessingStreamAction action ) { } } ) ; fail ( ) ; } catch ( GradleException e ) { assertThat ( e . getMessage ( ) , equalTo ( String . format ( <str> , tarFile ) ) ) ; } } @Test public void wrapsFailureToAddElement ( ) { final TestFile tarFile = initializeTarFile ( tmpDir . getTestDirectory ( ) . file ( <str> ) , new SimpleCompressor ( ) ) ; Throwable failure = new RuntimeException ( <str> ) ; try { visit ( action , brokenFile ( <str> , failure ) ) ; fail ( ) ; } catch ( GradleException e ) { assertThat ( e . getMessage ( ) , equalTo ( String . format ( <str> , tarFile ) ) ) ; assertThat ( e . getCause ( ) , sameInstance ( failure ) ) ; } } private TestFile initializeTarFile ( final TestFile tarFile , final ArchiveOutputStreamFactory compressor ) { action = new TarCopyAction ( tarFile , compressor ) ; return tarFile ; } private void tar ( final FileCopyDetailsInternal . . . files ) { action . execute ( new CopyActionProcessingStream ( ) { public void process ( CopyActionProcessingStreamAction action ) { for ( FileCopyDetailsInternal f : files ) { if ( f . isDirectory ( ) ) { action . processFile ( f ) ; } else { action . processFile ( f ) ; } } } } ) ; } private FileCopyDetailsInternal file ( final String path ) { final FileCopyDetailsInternal details = context . mock ( FileCopyDetailsInternal . class , path ) ; final String content = String . format ( <str> , path ) ; context . checking ( new Expectations ( ) { { allowing ( details ) . getRelativePath ( ) ; will ( returnValue ( RelativePath . parse ( true , path ) ) ) ; allowing ( details ) . getLastModified ( ) ; will ( returnValue ( <int> ) ) ; allowing ( details ) . getSize ( ) ; will ( returnValue ( ( long ) content . getBytes ( ) . length ) ) ; allowing ( details ) . isDirectory ( ) ; will ( returnValue ( false ) ) ; allowing ( details ) . getMode ( ) ; will ( returnValue ( <int> ) ) ; allowing ( details ) . copyTo ( with ( notNullValue ( OutputStream . class ) ) ) ; will ( new org . jmock . api . Action ( ) { public void describeTo ( Description description ) { description . appendText ( <str> ) ; } public Object invoke ( Invocation invocation ) throws Throwable { IOUtils . write ( content , ( OutputStream ) invocation . getParameter ( <int> ) ) ; return null ; } } ) ; } } ) ; return details ; } private FileCopyDetailsInternal dir ( final String path ) { final FileCopyDetailsInternal details = context . mock ( FileCopyDetailsInternal . class , path ) ; context . checking ( new Expectations ( ) { { allowing ( details ) . getRelativePath ( ) ; will ( returnValue ( RelativePath . parse ( false , path ) ) ) ; allowing ( details ) . getLastModified ( ) ; will ( returnValue ( <int> ) ) ; allowing ( details ) . isDirectory ( ) ; will ( returnValue ( true ) ) ; allowing ( details ) . getMode ( ) ; will ( returnValue ( <int> ) ) ; } } ) ; return details ; } private FileCopyDetailsInternal brokenFile ( final String path , final Throwable failure ) { final FileCopyDetailsInternal details = context . mock ( FileCopyDetailsInternal . class , String . format ( <str> , path ) ) ; context . checking ( new Expectations ( ) { { allowing ( details ) . getRelativePath ( ) ; will ( returnValue ( RelativePath . parse ( true , path ) ) ) ; allowing ( details ) . getLastModified ( ) ; will ( returnValue ( <int> ) ) ; allowing ( details ) . getSize ( ) ; will ( returnValue ( <int> ) ) ; allowing ( details ) . isDirectory ( ) ; will ( returnValue ( false ) ) ; allowing ( details ) . getMode ( ) ; will ( returnValue ( <int> ) ) ; allowing ( details ) . copyTo ( with ( notNullValue ( OutputStream . class ) ) ) ; will ( new org . jmock . api . Action ( ) { public void describeTo ( Description description ) { description . appendText ( <str> ) ; } public Object invoke ( Invocation invocation ) throws Throwable { failure . fillInStackTrace ( ) ; throw failure ; } } ) ; } } ) ; return details ; } } 
