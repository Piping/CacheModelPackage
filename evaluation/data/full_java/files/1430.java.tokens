package org . apache . cassandra . db ; import java . io . IOException ; import java . net . InetAddress ; import java . net . UnknownHostException ; import java . nio . ByteBuffer ; import java . util . AbstractMap ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import org . junit . BeforeClass ; import org . junit . Test ; import org . apache . cassandra . SchemaLoader ; import org . apache . cassandra . Util ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . Operator ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . filter . RowFilter ; import org . apache . cassandra . dht . ByteOrderedPartitioner . BytesToken ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . locator . TokenMetadata ; import org . apache . cassandra . schema . KeyspaceParams ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . ByteBufferUtil ; import static org . junit . Assert . assertEquals ; public class CleanupTest { public static final int LOOPS = <int> ; public static final String KEYSPACE1 = <str> ; public static final String CF_INDEXED1 = <str> ; public static final String CF_STANDARD1 = <str> ; public static final ByteBuffer COLUMN = ByteBufferUtil . bytes ( <str> ) ; public static final ByteBuffer VALUE = ByteBuffer . allocate ( <int> ) ; static { VALUE . putLong ( <int> ) ; VALUE . flip ( ) ; } @BeforeClass public static void defineSchema ( ) throws ConfigurationException { SchemaLoader . prepareServer ( ) ; SchemaLoader . createKeyspace ( KEYSPACE1 , KeyspaceParams . simple ( <int> ) , SchemaLoader . standardCFMD ( KEYSPACE1 , CF_STANDARD1 ) , SchemaLoader . compositeIndexCFMD ( KEYSPACE1 , CF_INDEXED1 , true ) ) ; } @Test public void testCleanupWithIndexes ( ) throws IOException , ExecutionException , InterruptedException { Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_INDEXED1 ) ; fillCF ( cfs , <str> , LOOPS ) ; assertEquals ( LOOPS , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; ColumnDefinition cdef = cfs . metadata . getColumnDefinition ( COLUMN ) ; String indexName = <str> ; long start = System . nanoTime ( ) ; while ( ! cfs . getBuiltIndexes ( ) . contains ( indexName ) & & System . nanoTime ( ) - start < TimeUnit . SECONDS . toNanos ( <int> ) ) Thread . sleep ( <int> ) ; RowFilter cf = RowFilter . create ( ) ; cf . add ( cdef , Operator . EQ , VALUE ) ; assertEquals ( LOOPS , Util . getAll ( Util . cmd ( cfs ) . filterOn ( <str> , Operator . EQ , VALUE ) . build ( ) ) . size ( ) ) ; TokenMetadata tmd = StorageService . instance . getTokenMetadata ( ) ; byte [ ] tk1 = new byte [ <int> ] , tk2 = new byte [ <int> ] ; tk1 [ <int> ] = <int> ; tk2 [ <int> ] = <int> ; tmd . updateNormalToken ( new BytesToken ( tk1 ) , InetAddress . getByName ( <str> ) ) ; tmd . updateNormalToken ( new BytesToken ( tk2 ) , InetAddress . getByName ( <str> ) ) ; CompactionManager . instance . performCleanup ( cfs ) ; assertEquals ( <int> , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; assert cfs . getLiveSSTables ( ) . isEmpty ( ) ; assertEquals ( <int> , Util . getAll ( Util . cmd ( cfs ) . filterOn ( <str> , Operator . EQ , VALUE ) . build ( ) ) . size ( ) ) ; } @Test public void testCleanupWithNewToken ( ) throws ExecutionException , InterruptedException , UnknownHostException { StorageService . instance . getTokenMetadata ( ) . clearUnsafe ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD1 ) ; fillCF ( cfs , <str> , LOOPS ) ; assertEquals ( LOOPS , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; TokenMetadata tmd = StorageService . instance . getTokenMetadata ( ) ; byte [ ] tk1 = new byte [ <int> ] , tk2 = new byte [ <int> ] ; tk1 [ <int> ] = <int> ; tk2 [ <int> ] = <int> ; tmd . updateNormalToken ( new BytesToken ( tk1 ) , InetAddress . getByName ( <str> ) ) ; tmd . updateNormalToken ( new BytesToken ( tk2 ) , InetAddress . getByName ( <str> ) ) ; CompactionManager . instance . performCleanup ( cfs ) ; assertEquals ( <int> , Util . getAll ( Util . cmd ( cfs ) . build ( ) ) . size ( ) ) ; } @Test public void testNeedsCleanup ( ) throws Exception { StorageService . instance . getTokenMetadata ( ) . clearUnsafe ( ) ; Keyspace keyspace = Keyspace . open ( KEYSPACE1 ) ; ColumnFamilyStore cfs = keyspace . getColumnFamilyStore ( CF_STANDARD1 ) ; fillCF ( cfs , <str> , LOOPS ) ; SSTableReader ssTable = cfs . getLiveSSTables ( ) . iterator ( ) . next ( ) ; final Token ssTableMin = ssTable . first . getToken ( ) ; final Token ssTableMax = ssTable . last . getToken ( ) ; final Token min = token ( ( byte ) <int> ) ; final Token before1 = token ( ( byte ) <int> ) ; final Token before2 = token ( ( byte ) <int> ) ; final Token before3 = token ( ( byte ) <int> ) ; final Token before4 = token ( ( byte ) <int> ) ; final Token insideSsTable1 = token ( ( byte ) <int> ) ; final Token insideSsTable2 = token ( ( byte ) <int> ) ; final Token max = token ( ( byte ) <int> , ( byte ) <int> , ( byte ) <int> , ( byte ) <int> ) ; assert ( min . compareTo ( ssTableMin ) < <int> ) ; assert ( before1 . compareTo ( ssTableMin ) < <int> ) ; assert ( before2 . compareTo ( ssTableMin ) < <int> ) ; assert ( before3 . compareTo ( ssTableMin ) < <int> ) ; assert ( before4 . compareTo ( ssTableMin ) < <int> ) ; assert ( ssTableMin . compareTo ( insideSsTable1 ) < <int> ) ; assert ( insideSsTable1 . compareTo ( ssTableMax ) < <int> ) ; assert ( ssTableMin . compareTo ( insideSsTable2 ) < <int> ) ; assert ( insideSsTable2 . compareTo ( ssTableMax ) < <int> ) ; assert ( ssTableMax . compareTo ( max ) < <int> ) ; List < Map . Entry < Boolean , List < Range < Token > > > > testCases = new LinkedList < Map . Entry < Boolean , List < Range < Token > > > > ( ) { { add ( entry ( false , Arrays . asList ( range ( min , max ) ) ) ) ; add ( entry ( true , Arrays . asList ( range ( min , insideSsTable1 ) ) ) ) ; add ( entry ( true , Arrays . asList ( range ( insideSsTable1 , max ) ) ) ) ; add ( entry ( true , Arrays . asList ( range ( min , ssTableMin ) ) ) ) ; add ( entry ( true , Arrays . asList ( range ( ssTableMax , max ) ) ) ) ; add ( entry ( true , Arrays . asList ( range ( min , insideSsTable1 ) , range ( insideSsTable2 , max ) ) ) ) ; add ( entry ( true , Arrays . asList ( range ( ssTableMin , ssTableMax ) ) ) ) ; add ( entry ( false , Arrays . asList ( range ( before4 , max ) ) ) ) ; add ( entry ( false , Arrays . asList ( range ( min , before1 ) , range ( before2 , before3 ) , range ( before4 , max ) ) ) ) ; } } ; for ( Map . Entry < Boolean , List < Range < Token > > > testCase : testCases ) { assertEquals ( testCase . getKey ( ) , CompactionManager . needsCleanup ( ssTable , testCase . getValue ( ) ) ) ; } } private static BytesToken token ( byte . . . value ) { return new BytesToken ( value ) ; } private static < K , V > Map . Entry < K , V > entry ( K k , V v ) { return new AbstractMap . SimpleEntry < K , V > ( k , v ) ; } private static Range < Token > range ( Token from , Token to ) { return new Range < > ( from , to ) ; } protected void fillCF ( ColumnFamilyStore cfs , String colName , int rowsPerSSTable ) { CompactionManager . instance . disableAutoCompaction ( ) ; for ( int i = <int> ; i < rowsPerSSTable ; i + + ) { String key = String . valueOf ( i ) ; new RowUpdateBuilder ( cfs . metadata , System . currentTimeMillis ( ) , ByteBufferUtil . bytes ( key ) ) . clustering ( COLUMN ) . add ( colName , VALUE ) . build ( ) . applyUnsafe ( ) ; } cfs . forceBlockingFlush ( ) ; } protected List < Long > getMaxTimestampList ( ColumnFamilyStore cfs ) { List < Long > list = new LinkedList < Long > ( ) ; for ( SSTableReader sstable : cfs . getLiveSSTables ( ) ) list . add ( sstable . getMaxTimestamp ( ) ) ; return list ; } } 
