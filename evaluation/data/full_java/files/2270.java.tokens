package org . nd4j . linalg . util ; import com . google . common . primitives . Ints ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . factory . Nd4j ; import java . io . DataInputStream ; import java . io . DataOutputStream ; import java . io . IOException ; import java . lang . reflect . Array ; import java . util . * ; public class ArrayUtil { private ArrayUtil ( ) { } public static int [ ] nTimes ( int n , int toReplicate ) { int [ ] ret = new int [ n ] ; Arrays . fill ( ret , toReplicate ) ; return ret ; } public static boolean allUnique ( int [ ] toTest ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i : toTest ) { if ( ! set . contains ( i ) ) set . add ( i ) ; else return false ; } return true ; } public static int [ ] randomPermutation ( int size ) { Random r = new Random ( ) ; int [ ] result = new int [ size ] ; for ( int j = <int> ; j < size ; j + + ) { result [ j ] = j + <int> ; } for ( int j = size - <int> ; j > <int> ; j - - ) { int k = r . nextInt ( j ) ; int temp = result [ j ] ; result [ j ] = result [ k ] ; result [ k ] = temp ; } return result ; } public static INDArray toNDArray ( int [ ] [ ] nums ) { if ( Nd4j . dataType ( ) = = DataBuffer . Type . DOUBLE ) { double [ ] doubles = toDoubles ( nums ) ; INDArray create = Nd4j . create ( doubles , new int [ ] { <int> , nums . length } ) ; return create ; } else { float [ ] doubles = toFloats ( nums ) ; INDArray create = Nd4j . create ( doubles , new int [ ] { <int> , nums . length } ) ; return create ; } } public static INDArray toNDArray ( int [ ] nums ) { if ( Nd4j . dataType ( ) = = DataBuffer . Type . DOUBLE ) { double [ ] doubles = toDoubles ( nums ) ; INDArray create = Nd4j . create ( doubles , new int [ ] { <int> , nums . length } ) ; return create ; } else { float [ ] doubles = toFloats ( nums ) ; INDArray create = Nd4j . create ( doubles , new int [ ] { <int> , nums . length } ) ; return create ; } } public static int [ ] toInts ( INDArray n ) { if ( n instanceof IComplexNDArray ) throw new IllegalArgumentException ( <str> ) ; n = n . linearView ( ) ; int [ ] ret = new int [ n . length ( ) ] ; for ( int i = <int> ; i < n . length ( ) ; i + + ) ret [ i ] = ( int ) n . getFloat ( i ) ; return ret ; } public static int [ ] toInts ( float [ ] data ) { int [ ] ret = new int [ data . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) ret [ i ] = ( int ) data [ i ] ; return ret ; } public static int [ ] toInts ( double [ ] data ) { int [ ] ret = new int [ data . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) ret [ i ] = ( int ) data [ i ] ; return ret ; } public static int offsetFor ( int [ ] stride , int i ) { int ret = <int> ; for ( int j = <int> ; j < stride . length ; j + + ) ret + = ( i * stride [ j ] ) ; return ret ; } public static int sum ( List < Integer > add ) { if ( add . size ( ) < <int> ) return <int> ; int ret = <int> ; for ( int i = <int> ; i < add . size ( ) ; i + + ) ret + = add . get ( i ) ; return ret ; } public static int sum ( int [ ] add ) { if ( add . length < <int> ) return <int> ; int ret = <int> ; for ( int i = <int> ; i < add . length ; i + + ) ret + = add [ i ] ; return ret ; } public static int prod ( List < Integer > mult ) { if ( mult . size ( ) < <int> ) return <int> ; int ret = <int> ; for ( int i = <int> ; i < mult . size ( ) ; i + + ) ret * = mult . get ( i ) ; return ret ; } public static int prod ( int [ ] mult ) { if ( mult . length < <int> ) return <int> ; int ret = <int> ; for ( int i = <int> ; i < mult . length ; i + + ) ret * = mult [ i ] ; return ret ; } public static boolean equals ( float [ ] data , double [ ] data2 ) { if ( data . length ! = data2 . length ) return false ; for ( int i = <int> ; i < data . length ; i + + ) { double equals = Math . abs ( data2 [ i ] - data [ i ] ) ; if ( equals > <float> ) return false ; } return true ; } public static int [ ] consArray ( int a , int [ ] as ) { int len = as . length ; int [ ] nas = new int [ len + <int> ] ; nas [ <int> ] = a ; System . arraycopy ( as , <int> , nas , <int> , len ) ; return nas ; } public static boolean isZero ( int [ ] as ) { for ( int i = <int> ; i < as . length ; i + + ) { if ( as [ i ] = = <int> ) return true ; } return false ; } public static boolean anyMore ( int [ ] target , int [ ] test ) { assert target . length = = test . length : <str> ; for ( int i = <int> ; i < target . length ; i + + ) { if ( target [ i ] > test [ i ] ) return true ; } return false ; } public static boolean anyLess ( int [ ] target , int [ ] test ) { assert target . length = = test . length : <str> ; for ( int i = <int> ; i < target . length ; i + + ) { if ( target [ i ] < test [ i ] ) return true ; } return false ; } public static int calcOffset ( List < Integer > shape , List < Integer > offsets , List < Integer > strides ) { if ( shape . size ( ) ! = offsets . size ( ) | | shape . size ( ) ! = strides . size ( ) ) throw new IllegalArgumentException ( <str> ) ; int ret = <int> ; for ( int i = <int> ; i < offsets . size ( ) ; i + + ) { if ( shape . get ( i ) = = <int> & & offsets . size ( ) > <int> & & i > <int> ) continue ; ret + = offsets . get ( i ) * strides . get ( i ) ; } return ret ; } public static int calcOffset ( int [ ] shape , int [ ] offsets , int [ ] strides ) { if ( shape . length ! = offsets . length | | shape . length ! = strides . length ) throw new IllegalArgumentException ( <str> ) ; int ret = <int> ; for ( int i = <int> ; i < offsets . length ; i + + ) { if ( shape [ i ] = = <int> ) continue ; ret + = offsets [ i ] * strides [ i ] ; } return ret ; } public static int dotProduct ( List < Integer > xs , List < Integer > ys ) { int result = <int> ; int n = xs . size ( ) ; if ( ys . size ( ) ! = n ) throw new IllegalArgumentException ( <str> ) ; for ( int i = <int> ; i < n ; i + + ) { result + = xs . get ( i ) * ys . get ( i ) ; } return result ; } public static int dotProduct ( int [ ] xs , int [ ] ys ) { int result = <int> ; int n = xs . length ; if ( ys . length ! = n ) throw new IllegalArgumentException ( <str> ) ; for ( int i = <int> ; i < n ; i + + ) { result + = xs [ i ] * ys [ i ] ; } return result ; } public static int [ ] empty ( ) { return new int [ <int> ] ; } public static int [ ] of ( int . . . arr ) { return arr ; } public static int [ ] copy ( int [ ] copy ) { int [ ] ret = new int [ copy . length ] ; System . arraycopy ( copy , <int> , ret , <int> , ret . length ) ; return ret ; } public static double [ ] doubleCopyOf ( float [ ] data ) { double [ ] ret = new double [ data . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) ret [ i ] = data [ i ] ; return ret ; } public static float [ ] floatCopyOf ( double [ ] data ) { if ( data . length = = <int> ) return new float [ <int> ] ; float [ ] ret = new float [ data . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) ret [ i ] = ( float ) data [ i ] ; return ret ; } public static double [ ] range ( double [ ] data , int to ) { return range ( data , to , <int> ) ; } public static double [ ] range ( double [ ] data , int to , int stride ) { return range ( data , to , stride , <int> ) ; } public static double [ ] range ( double [ ] data , int to , int stride , int numElementsEachStride ) { double [ ] ret = new double [ to / stride ] ; if ( ret . length < <int> ) ret = new double [ <int> ] ; int count = <int> ; for ( int i = <int> ; i < data . length ; i + = stride ) { for ( int j = <int> ; j < numElementsEachStride ; j + + ) { if ( i + j > = data . length | | count > = ret . length ) break ; ret [ count + + ] = data [ i + j ] ; } } return ret ; } public static int [ ] toArray ( List < Integer > list ) { int [ ] ret = new int [ list . size ( ) ] ; for ( int i = <int> ; i < list . size ( ) ; i + + ) ret [ i ] = list . get ( i ) ; return ret ; } public static double [ ] toArrayDouble ( List < Double > list ) { double [ ] ret = new double [ list . size ( ) ] ; for ( int i = <int> ; i < list . size ( ) ; i + + ) ret [ i ] = list . get ( i ) ; return ret ; } public static int [ ] range ( int from , int to , int increment ) { int diff = Math . abs ( from - to ) ; int [ ] ret = new int [ diff / increment ] ; if ( ret . length < <int> ) ret = new int [ <int> ] ; if ( from < to ) { int count = <int> ; for ( int i = from ; i < to ; i + = increment ) { if ( count > = ret . length ) break ; ret [ count + + ] = i ; } } else if ( from > to ) { int count = <int> ; for ( int i = from - <int> ; i > = to ; i - = increment ) { if ( count > = ret . length ) break ; ret [ count + + ] = i ; } } return ret ; } public static int [ ] range ( int from , int to ) { if ( from = = to ) return new int [ <int> ] ; return range ( from , to , <int> ) ; } public static double [ ] toDoubles ( int [ ] ints ) { double [ ] ret = new double [ ints . length ] ; for ( int i = <int> ; i < ints . length ; i + + ) ret [ i ] = ( double ) ints [ i ] ; return ret ; } public static double [ ] toDoubles ( float [ ] ints ) { double [ ] ret = new double [ ints . length ] ; for ( int i = <int> ; i < ints . length ; i + + ) ret [ i ] = ( double ) ints [ i ] ; return ret ; } public static float [ ] toFloats ( int [ ] [ ] ints ) { return toFloats ( Ints . concat ( ints ) ) ; } public static double [ ] toDoubles ( int [ ] [ ] ints ) { return toDoubles ( Ints . concat ( ints ) ) ; } public static float [ ] toFloats ( int [ ] ints ) { float [ ] ret = new float [ ints . length ] ; for ( int i = <int> ; i < ints . length ; i + + ) ret [ i ] = ( float ) ints [ i ] ; return ret ; } public static float [ ] toFloats ( double [ ] ints ) { float [ ] ret = new float [ ints . length ] ; for ( int i = <int> ; i < ints . length ; i + + ) ret [ i ] = ( float ) ints [ i ] ; return ret ; } public static int [ ] replace ( int [ ] data , int index , int newValue ) { int [ ] copy = copy ( data ) ; copy [ index ] = newValue ; return copy ; } public static int [ ] keep ( int [ ] data , int . . . index ) { int [ ] ret = new int [ index . length ] ; int count = <int> ; for ( int i = <int> ; i < data . length ; i + + ) if ( Ints . contains ( index , i ) ) ret [ count + + ] = data [ i ] ; return ret ; } public static int [ ] removeIndex ( int [ ] data , int . . . index ) { int [ ] ret = new int [ data . length - index . length ] ; int count = <int> ; for ( int i = <int> ; i < data . length ; i + + ) if ( ! Ints . contains ( index , i ) ) ret [ count + + ] = data [ i ] ; return ret ; } public static int [ ] removeIndex ( int [ ] data , int index ) { if ( data = = null ) return null ; if ( index > = data . length ) throw new IllegalArgumentException ( <str> + index + <str> ) ; if ( data = = null ) return null ; if ( data . length < <int> ) return data ; if ( index < <int> ) return data ; int len = data . length ; int [ ] result = new int [ len - <int> ] ; System . arraycopy ( data , <int> , result , <int> , index ) ; System . arraycopy ( data , index + <int> , result , index , len - index - <int> ) ; return result ; } public static int [ ] valueStartingAt ( int valueStarting , int [ ] copy , int idxFrom , int idxAt , int length ) { int [ ] ret = new int [ length ] ; Arrays . fill ( ret , valueStarting ) ; for ( int i = <int> ; i < length ; i + + ) { if ( i + idxFrom > = copy . length | | i + idxAt > = ret . length ) break ; ret [ i + idxAt ] = copy [ i + idxFrom ] ; } return ret ; } public static Integer [ ] removeIndex ( Integer [ ] data , int index ) { if ( data = = null ) return null ; if ( data . length < <int> ) return data ; int len = data . length ; Integer [ ] result = new Integer [ len - <int> ] ; System . arraycopy ( data , <int> , result , <int> , index ) ; System . arraycopy ( data , index + <int> , result , index , len - index - <int> ) ; return result ; } public static int [ ] calcStridesFortran ( int [ ] shape , int startNum ) { if ( Shape . isVector ( shape ) ) { int [ ] ret = new int [ <int> ] ; Arrays . fill ( ret , startNum ) ; return ret ; } int dimensions = shape . length ; int [ ] stride = new int [ dimensions ] ; int st = startNum ; for ( int j = <int> ; j < stride . length ; j + + ) { stride [ j ] = st ; st * = shape [ j ] ; } return stride ; } public static int [ ] calcStridesFortran ( int [ ] shape ) { return calcStridesFortran ( shape , <int> ) ; } public static int [ ] calcStrides ( int [ ] shape , int startValue ) { if ( Shape . isVector ( shape ) ) { int [ ] ret = new int [ <int> ] ; Arrays . fill ( ret , startValue ) ; return ret ; } int dimensions = shape . length ; int [ ] stride = new int [ dimensions ] ; int st = startValue ; for ( int j = dimensions - <int> ; j > = <int> ; j - - ) { stride [ j ] = st ; st * = shape [ j ] ; } return stride ; } public static boolean isInverse ( int [ ] first , int [ ] second ) { int backWardCount = second . length - <int> ; for ( int i = <int> ; i < first . length ; i + + ) { if ( first [ i ] ! = second [ backWardCount - - ] ) return false ; } return true ; } public static int [ ] plus ( int [ ] ints , int mult ) { int [ ] ret = new int [ ints . length ] ; for ( int i = <int> ; i < ints . length ; i + + ) ret [ i ] = ints [ i ] + mult ; return ret ; } public static int [ ] plus ( int [ ] ints , int [ ] mult ) { if ( ints . length ! = mult . length ) throw new IllegalArgumentException ( <str> ) ; int [ ] ret = new int [ ints . length ] ; for ( int i = <int> ; i < ints . length ; i + + ) ret [ i ] = ints [ i ] + mult [ i ] ; return ret ; } public static int [ ] times ( int [ ] ints , int mult ) { int [ ] ret = new int [ ints . length ] ; for ( int i = <int> ; i < ints . length ; i + + ) ret [ i ] = ints [ i ] * mult ; return ret ; } public static int [ ] times ( int [ ] ints , int [ ] mult ) { assert ints . length = = mult . length : <str> ; int [ ] ret = new int [ ints . length ] ; for ( int i = <int> ; i < ints . length ; i + + ) ret [ i ] = ints [ i ] * mult [ i ] ; return ret ; } public static int nonOneStride ( int [ ] arr ) { for ( int i = <int> ; i < arr . length ; i + + ) if ( arr [ i ] ! = <int> ) return arr [ i ] ; return <int> ; } public static int [ ] calcStrides ( int [ ] shape ) { return calcStrides ( shape , <int> ) ; } public static int [ ] reverseCopy ( int [ ] e ) { if ( e . length < <int> ) return e ; int [ ] copy = new int [ e . length ] ; for ( int i = <int> ; i < = e . length / <int> ; i + + ) { int temp = e [ i ] ; copy [ i ] = e [ e . length - i - <int> ] ; copy [ e . length - i - <int> ] = temp ; } return copy ; } public static double [ ] read ( int length , DataInputStream dis ) throws IOException { double [ ] ret = new double [ length ] ; for ( int i = <int> ; i < length ; i + + ) ret [ i ] = dis . readDouble ( ) ; return ret ; } public static void write ( double [ ] data , DataOutputStream dos ) throws IOException { for ( int i = <int> ; i < data . length ; i + + ) dos . writeDouble ( data [ i ] ) ; } public static double [ ] readDouble ( int length , DataInputStream dis ) throws IOException { double [ ] ret = new double [ length ] ; for ( int i = <int> ; i < length ; i + + ) ret [ i ] = dis . readDouble ( ) ; return ret ; } public static float [ ] readFloat ( int length , DataInputStream dis ) throws IOException { float [ ] ret = new float [ length ] ; for ( int i = <int> ; i < length ; i + + ) ret [ i ] = dis . readFloat ( ) ; return ret ; } public static void write ( float [ ] data , DataOutputStream dos ) throws IOException { for ( int i = <int> ; i < data . length ; i + + ) dos . writeFloat ( data [ i ] ) ; } public static void assertSquare ( double [ ] . . . d ) { if ( d . length > <int> ) { for ( int i = <int> ; i < d . length ; i + + ) { assertSquare ( d [ i ] ) ; } } else { int firstLength = d [ <int> ] . length ; for ( int i = <int> ; i < d . length ; i + + ) { assert d [ i ] . length = = firstLength ; } } } public static void multiplyBy ( int [ ] arr , int mult ) { for ( int i = <int> ; i < arr . length ; i + + ) arr [ i ] * = mult ; } public static void reverse ( int [ ] e ) { for ( int i = <int> ; i < = e . length / <int> ; i + + ) { int temp = e [ i ] ; e [ i ] = e [ e . length - i - <int> ] ; e [ e . length - i - <int> ] = temp ; } } public static List < double [ ] > zerosMatrix ( int . . . dimensions ) { List < double [ ] > ret = new ArrayList < > ( ) ; for ( int i = <int> ; i < dimensions . length ; i + + ) { ret . add ( new double [ dimensions [ i ] ] ) ; } return ret ; } public static float [ ] reverseCopy ( float [ ] e ) { float [ ] copy = new float [ e . length ] ; for ( int i = <int> ; i < = e . length / <int> ; i + + ) { float temp = e [ i ] ; copy [ i ] = e [ e . length - i - <int> ] ; copy [ e . length - i - <int> ] = temp ; } return copy ; } public static < E > E [ ] reverseCopy ( E [ ] e ) { E [ ] copy = ( E [ ] ) new Object [ e . length ] ; for ( int i = <int> ; i < = e . length / <int> ; i + + ) { E temp = e [ i ] ; copy [ i ] = e [ e . length - i - <int> ] ; copy [ e . length - i - <int> ] = temp ; } return copy ; } public static < E > void reverse ( E [ ] e ) { for ( int i = <int> ; i < = e . length / <int> ; i + + ) { E temp = e [ i ] ; e [ i ] = e [ e . length - i - <int> ] ; e [ e . length - i - <int> ] = temp ; } } public static float [ ] flatten ( float [ ] [ ] arr ) { float [ ] ret = new float [ arr . length * arr [ <int> ] . length ] ; int count = <int> ; for ( int i = <int> ; i < arr . length ; i + + ) for ( int j = <int> ; j < arr [ i ] . length ; j + + ) ret [ count + + ] = arr [ i ] [ j ] ; return ret ; } public static int [ ] flatten ( int [ ] [ ] arr ) { int [ ] ret = new int [ arr . length * arr [ <int> ] . length ] ; int count = <int> ; for ( int i = <int> ; i < arr . length ; i + + ) for ( int j = <int> ; j < arr [ i ] . length ; j + + ) ret [ count + + ] = arr [ i ] [ j ] ; return ret ; } public static double [ ] flatten ( double [ ] [ ] arr ) { double [ ] ret = new double [ arr . length * arr [ <int> ] . length ] ; int count = <int> ; for ( int i = <int> ; i < arr . length ; i + + ) for ( int j = <int> ; j < arr [ i ] . length ; j + + ) ret [ count + + ] = arr [ i ] [ j ] ; return ret ; } public static double [ ] [ ] toDouble ( int [ ] [ ] arr ) { double [ ] [ ] ret = new double [ arr . length ] [ arr [ <int> ] . length ] ; for ( int i = <int> ; i < arr . length ; i + + ) { for ( int j = <int> ; j < arr [ i ] . length ; j + + ) ret [ i ] [ j ] = arr [ i ] [ j ] ; } return ret ; } public static float [ ] combineFloat ( List < float [ ] > nums ) { int length = <int> ; for ( int i = <int> ; i < nums . size ( ) ; i + + ) length + = nums . get ( i ) . length ; float [ ] ret = new float [ length ] ; int count = <int> ; for ( float [ ] i : nums ) { for ( int j = <int> ; j < i . length ; j + + ) { ret [ count + + ] = i [ j ] ; } } return ret ; } public static float [ ] combine ( List < float [ ] > nums ) { int length = <int> ; for ( int i = <int> ; i < nums . size ( ) ; i + + ) length + = nums . get ( i ) . length ; float [ ] ret = new float [ length ] ; int count = <int> ; for ( float [ ] i : nums ) { for ( int j = <int> ; j < i . length ; j + + ) { ret [ count + + ] = i [ j ] ; } } return ret ; } public static double [ ] combineDouble ( List < double [ ] > nums ) { int length = <int> ; for ( int i = <int> ; i < nums . size ( ) ; i + + ) length + = nums . get ( i ) . length ; double [ ] ret = new double [ length ] ; int count = <int> ; for ( double [ ] i : nums ) { for ( int j = <int> ; j < i . length ; j + + ) { ret [ count + + ] = i [ j ] ; } } return ret ; } public static double [ ] combine ( float [ ] . . . ints ) { int length = <int> ; for ( int i = <int> ; i < ints . length ; i + + ) length + = ints [ i ] . length ; double [ ] ret = new double [ length ] ; int count = <int> ; for ( float [ ] i : ints ) { for ( int j = <int> ; j < i . length ; j + + ) { ret [ count + + ] = i [ j ] ; } } return ret ; } public static int [ ] combine ( int [ ] . . . ints ) { int length = <int> ; for ( int i = <int> ; i < ints . length ; i + + ) length + = ints [ i ] . length ; int [ ] ret = new int [ length ] ; int count = <int> ; for ( int [ ] i : ints ) { for ( int j = <int> ; j < i . length ; j + + ) { ret [ count + + ] = i [ j ] ; } } return ret ; } public static < E > E [ ] combine ( E [ ] . . . arrs ) { int length = <int> ; for ( int i = <int> ; i < arrs . length ; i + + ) length + = arrs [ i ] . length ; E [ ] ret = ( E [ ] ) Array . newInstance ( arrs [ <int> ] [ <int> ] . getClass ( ) , length ) ; int count = <int> ; for ( E [ ] i : arrs ) { for ( int j = <int> ; j < i . length ; j + + ) { ret [ count + + ] = i [ j ] ; } } return ret ; } public static int [ ] toOutcomeArray ( int outcome , int numOutcomes ) { int [ ] nums = new int [ numOutcomes ] ; nums [ outcome ] = <int> ; return nums ; } public static double [ ] toDouble ( int [ ] data ) { double [ ] ret = new double [ data . length ] ; for ( int i = <int> ; i < ret . length ; i + + ) ret [ i ] = data [ i ] ; return ret ; } public static float [ ] copy ( float [ ] data ) { float [ ] result = new float [ data . length ] ; System . arraycopy ( data , <int> , result , <int> , data . length ) ; return result ; } public static double [ ] copy ( double [ ] data ) { double [ ] result = new double [ data . length ] ; System . arraycopy ( data , <int> , result , <int> , data . length ) ; return result ; } public static double [ ] flattenDoubleArray ( Object doubleArray ) { if ( doubleArray instanceof double [ ] ) return ( double [ ] ) doubleArray ; LinkedList < Object > stack = new LinkedList < > ( ) ; stack . push ( doubleArray ) ; int [ ] shape = arrayShape ( doubleArray ) ; int length = ArrayUtil . prod ( shape ) ; double [ ] flat = new double [ length ] ; int count = <int> ; while ( ! stack . isEmpty ( ) ) { Object current = stack . pop ( ) ; if ( current instanceof double [ ] ) { double [ ] arr = ( double [ ] ) current ; for ( int i = <int> ; i < arr . length ; i + + ) flat [ count + + ] = arr [ i ] ; } else if ( current instanceof Object [ ] ) { Object [ ] o = ( Object [ ] ) current ; for ( int i = o . length - <int> ; i > = <int> ; i - - ) stack . push ( o [ i ] ) ; } else throw new IllegalArgumentException ( <str> ) ; } if ( count ! = flat . length ) throw new IllegalArgumentException ( <str> ) ; return flat ; } public static float [ ] flattenFloatArray ( Object floatArray ) { if ( floatArray instanceof float [ ] ) return ( float [ ] ) floatArray ; LinkedList < Object > stack = new LinkedList < > ( ) ; stack . push ( floatArray ) ; int [ ] shape = arrayShape ( floatArray ) ; int length = ArrayUtil . prod ( shape ) ; float [ ] flat = new float [ length ] ; int count = <int> ; while ( ! stack . isEmpty ( ) ) { Object current = stack . pop ( ) ; if ( current instanceof float [ ] ) { float [ ] arr = ( float [ ] ) current ; for ( int i = <int> ; i < arr . length ; i + + ) flat [ count + + ] = arr [ i ] ; } else if ( current instanceof Object [ ] ) { Object [ ] o = ( Object [ ] ) current ; for ( int i = o . length - <int> ; i > = <int> ; i - - ) stack . push ( o [ i ] ) ; } else throw new IllegalArgumentException ( <str> ) ; } if ( count ! = flat . length ) throw new IllegalArgumentException ( <str> ) ; return flat ; } public static int [ ] arrayShape ( Object array ) { int nDimensions = <int> ; Class < ? > c = array . getClass ( ) . getComponentType ( ) ; while ( c ! = null ) { nDimensions + + ; c = c . getComponentType ( ) ; } int [ ] shape = new int [ nDimensions ] ; Object current = array ; for ( int i = <int> ; i < shape . length - <int> ; i + + ) { shape [ i ] = ( ( Object [ ] ) current ) . length ; current = ( ( Object [ ] ) current ) [ <int> ] ; } if ( current instanceof Object [ ] ) { shape [ shape . length - <int> ] = ( ( Object [ ] ) current ) . length ; } else if ( current instanceof double [ ] ) { shape [ shape . length - <int> ] = ( ( double [ ] ) current ) . length ; } else if ( current instanceof float [ ] ) { shape [ shape . length - <int> ] = ( ( float [ ] ) current ) . length ; } else if ( current instanceof long [ ] ) { shape [ shape . length - <int> ] = ( ( long [ ] ) current ) . length ; } else if ( current instanceof int [ ] ) { shape [ shape . length - <int> ] = ( ( int [ ] ) current ) . length ; } else if ( current instanceof byte [ ] ) { shape [ shape . length - <int> ] = ( ( byte [ ] ) current ) . length ; } else if ( current instanceof char [ ] ) { shape [ shape . length - <int> ] = ( ( char [ ] ) current ) . length ; } else if ( current instanceof boolean [ ] ) { shape [ shape . length - <int> ] = ( ( boolean [ ] ) current ) . length ; } else if ( current instanceof short [ ] ) { shape [ shape . length - <int> ] = ( ( short [ ] ) current ) . length ; } else throw new IllegalStateException ( <str> ) ; return shape ; } public static int max ( int [ ] in ) { int max = Integer . MIN_VALUE ; for ( int i = <int> ; i < in . length ; i + + ) if ( in [ i ] > max ) max = in [ i ] ; return max ; } public static int min ( int [ ] in ) { int min = Integer . MAX_VALUE ; for ( int i = <int> ; i < in . length ; i + + ) if ( in [ i ] < min ) min = in [ i ] ; return min ; } public static int argMax ( int [ ] in ) { int maxIdx = <int> ; for ( int i = <int> ; i < in . length ; i + + ) if ( in [ i ] > in [ maxIdx ] ) maxIdx = i ; return maxIdx ; } public static int argMin ( int [ ] in ) { int minIdx = <int> ; for ( int i = <int> ; i < in . length ; i + + ) if ( in [ i ] < in [ minIdx ] ) minIdx = i ; return minIdx ; } public static int argMax ( long [ ] in ) { int maxIdx = <int> ; for ( int i = <int> ; i < in . length ; i + + ) if ( in [ i ] > in [ maxIdx ] ) maxIdx = i ; return maxIdx ; } public static int argMin ( long [ ] in ) { int minIdx = <int> ; for ( int i = <int> ; i < in . length ; i + + ) if ( in [ i ] < in [ minIdx ] ) minIdx = i ; return minIdx ; } public static int argMinOfMax ( int [ ] first , int [ ] second ) { int minIdx = <int> ; int maxAtMinIdx = Math . max ( first [ <int> ] , second [ <int> ] ) ; for ( int i = <int> ; i < first . length ; i + + ) { int maxAtIndex = Math . max ( first [ i ] , second [ i ] ) ; if ( maxAtMinIdx > maxAtIndex ) { maxAtMinIdx = maxAtIndex ; minIdx = i ; } } return minIdx ; } public static int argMinOfMax ( int [ ] . . . arrays ) { int minIdx = <int> ; int maxAtMinIdx = Integer . MAX_VALUE ; for ( int i = <int> ; i < arrays [ <int> ] . length ; i + + ) { int maxAtIndex = Integer . MIN_VALUE ; for ( int j = <int> ; j < arrays . length ; j + + ) { maxAtIndex = Math . max ( maxAtIndex , arrays [ j ] [ i ] ) ; } if ( maxAtMinIdx > maxAtIndex ) { maxAtMinIdx = maxAtIndex ; minIdx = i ; } } return minIdx ; } public static int argMinOfSum ( int [ ] first , int [ ] second ) { int minIdx = <int> ; int sumAtMinIdx = first [ <int> ] + second [ <int> ] ; for ( int i = <int> ; i < first . length ; i + + ) { int sumAtIndex = first [ i ] + second [ i ] ; if ( sumAtMinIdx > sumAtIndex ) { sumAtMinIdx = sumAtIndex ; minIdx = i ; } } return minIdx ; } } 
