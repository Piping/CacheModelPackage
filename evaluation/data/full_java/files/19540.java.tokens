package io . netty . handler . codec . socksx . v5 ; import io . netty . buffer . ByteBuf ; import io . netty . handler . codec . DecoderException ; import io . netty . util . CharsetUtil ; import io . netty . util . NetUtil ; public interface Socks5AddressDecoder { Socks5AddressDecoder DEFAULT = new Socks5AddressDecoder ( ) { private static final int IPv6_LEN = <int> ; @Override public String decodeAddress ( Socks5AddressType addrType , ByteBuf in ) throws Exception { if ( addrType = = Socks5AddressType . IPv4 ) { return NetUtil . intToIpAddress ( in . readInt ( ) ) ; } if ( addrType = = Socks5AddressType . DOMAIN ) { final int length = in . readUnsignedByte ( ) ; final String domain = in . toString ( in . readerIndex ( ) , length , CharsetUtil . US_ASCII ) ; in . skipBytes ( length ) ; return domain ; } if ( addrType = = Socks5AddressType . IPv6 ) { if ( in . hasArray ( ) ) { final int readerIdx = in . readerIndex ( ) ; in . readerIndex ( readerIdx + IPv6_LEN ) ; return NetUtil . bytesToIpAddress ( in . array ( ) , in . arrayOffset ( ) + readerIdx , IPv6_LEN ) ; } else { byte [ ] tmp = new byte [ IPv6_LEN ] ; in . readBytes ( tmp ) ; return NetUtil . bytesToIpAddress ( tmp , <int> , IPv6_LEN ) ; } } else { throw new DecoderException ( <str> + ( addrType . byteValue ( ) & <hex> ) ) ; } } } ; String decodeAddress ( Socks5AddressType addrType , ByteBuf in ) throws Exception ; } 
