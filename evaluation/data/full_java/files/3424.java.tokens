package org . nd4j . linalg ; import java . io . * ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . UUID ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . TimeUnit ; import org . apache . commons . math3 . util . Pair ; import org . junit . After ; import org . junit . Before ; import org . junit . Test ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . iter . NdIndexIterator ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . BroadcastOp ; import org . nd4j . linalg . api . ops . executioner . OpExecutionerUtil ; import org . nd4j . linalg . api . ops . impl . transforms . comparison . Eps ; import org . nd4j . linalg . api . ops . impl . broadcast . * ; import org . nd4j . linalg . checkutil . NDArrayCreationUtil ; import org . nd4j . linalg . executors . ExecutorServiceProvider ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import org . nd4j . linalg . ops . transforms . Transforms ; import org . nd4j . linalg . api . shape . Shape ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import static org . junit . Assert . * ; public class NDArrayTestsFortran extends BaseNd4jTest { private static Logger log = LoggerFactory . getLogger ( NDArrayTestsFortran . class ) ; public NDArrayTestsFortran ( ) { } public NDArrayTestsFortran ( String name ) { super ( name ) ; } public NDArrayTestsFortran ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } public NDArrayTestsFortran ( Nd4jBackend backend ) { super ( backend ) ; } @Before public void before ( ) { super . before ( ) ; } @After public void after ( ) { super . after ( ) ; } @Test public void testScalarOps ( ) throws Exception { INDArray n = Nd4j . create ( Nd4j . ones ( <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; assertEquals ( <int> d , n . length ( ) , <float> ) ; n . checkDimensions ( n . addi ( Nd4j . scalar ( <float> ) ) ) ; n . checkDimensions ( n . subi ( Nd4j . scalar ( <float> ) ) ) ; n . checkDimensions ( n . muli ( Nd4j . scalar ( <float> ) ) ) ; n . checkDimensions ( n . divi ( Nd4j . scalar ( <float> ) ) ) ; n = Nd4j . create ( Nd4j . ones ( <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; assertEquals ( <int> , n . sumNumber ( ) . doubleValue ( ) , <float> ) ; INDArray a = n . slice ( <int> ) ; assertEquals ( true , Arrays . equals ( new int [ ] { <int> , <int> } , a . shape ( ) ) ) ; } @Test public void testColumnMmul ( ) { DataBuffer data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; INDArray x2 = Nd4j . create ( data , new int [ ] { <int> , <int> , <int> } ) ; data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; INDArray y2 = Nd4j . create ( data , new int [ ] { <int> , <int> } ) ; INDArray z2 = Nd4j . create ( <int> , <int> ) ; z2 . putColumn ( <int> , y2 . getColumn ( <int> ) ) ; z2 . putColumn ( <int> , y2 . getColumn ( <int> ) ) ; INDArray nofOffset = Nd4j . create ( <int> , <int> ) ; nofOffset . assign ( x2 . slice ( <int> ) ) ; assertEquals ( getFailureMessage ( ) , nofOffset , x2 . slice ( <int> ) ) ; INDArray slice = x2 . slice ( <int> ) ; INDArray zeroOffsetResult = slice . mmul ( z2 ) ; INDArray offsetResult = nofOffset . mmul ( z2 ) ; assertEquals ( getFailureMessage ( ) , zeroOffsetResult , offsetResult ) ; INDArray slice1 = x2 . slice ( <int> ) ; INDArray noOffset2 = Nd4j . create ( slice1 . shape ( ) ) ; noOffset2 . assign ( slice1 ) ; assertEquals ( getFailureMessage ( ) , slice1 , noOffset2 ) ; INDArray noOffsetResult = noOffset2 . mmul ( z2 ) ; INDArray slice1OffsetResult = slice1 . mmul ( z2 ) ; assertEquals ( getFailureMessage ( ) , noOffsetResult , slice1OffsetResult ) ; } @Test public void testRowVectorGemm ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray other = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray result = linspace . mmul ( other ) ; INDArray assertion = Nd4j . create ( new double [ ] { <float> , <float> , <float> , <float> } ) ; assertEquals ( assertion , result ) ; } @Test public void testRepmat ( ) { INDArray rowVector = Nd4j . create ( <int> , <int> ) ; INDArray repmat = rowVector . repmat ( <int> , <int> ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> } , repmat . shape ( ) ) ) ; } @Test public void testReadWrite ( ) throws Exception { INDArray write = Nd4j . linspace ( <int> , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( bos ) ; Nd4j . write ( write , dos ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; DataInputStream dis = new DataInputStream ( bis ) ; INDArray read = Nd4j . read ( dis ) ; assertEquals ( write , read ) ; } @Test public void testReadWriteTxt ( ) throws Exception { INDArray write = Nd4j . create ( <int> ) ; File writeTo = new File ( UUID . randomUUID ( ) . toString ( ) ) ; Nd4j . writeTxt ( write , writeTo . getAbsolutePath ( ) , <str> ) ; INDArray read = Nd4j . readTxt ( writeTo . getAbsolutePath ( ) ) ; assertEquals ( write , read ) ; } @Test public void testReadWriteDouble ( ) throws Exception { INDArray write = Nd4j . linspace ( <int> , <int> , <int> ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( bos ) ; Nd4j . write ( write , dos ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; DataInputStream dis = new DataInputStream ( bis ) ; INDArray read = Nd4j . read ( dis ) ; assertEquals ( write , read ) ; } @Test public void testMultiThreading ( ) throws Exception { ExecutorService ex = ExecutorServiceProvider . getExecutorService ( ) ; List < Future < ? > > list = new ArrayList < > ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { Future < ? > future = ex . submit ( new Runnable ( ) { @Override public void run ( ) { INDArray dot = Nd4j . linspace ( <int> , <int> , <int> ) ; System . out . println ( Transforms . sigmoid ( dot ) ) ; } } ) ; list . add ( future ) ; } for ( Future < ? > future : list ) { future . get ( <int> , TimeUnit . MINUTES ) ; } } @Test public void testBroadCasting ( ) { INDArray first = Nd4j . arange ( <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray ret = first . broadcast ( <int> , <int> ) ; INDArray testRet = Nd4j . create ( new double [ ] [ ] { { <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> } } ) ; assertEquals ( testRet , ret ) ; INDArray r = Nd4j . arange ( <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray r2 = r . broadcast ( <int> , <int> ) ; INDArray testR2 = Nd4j . create ( new double [ ] [ ] { { <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> } , { <int> , <int> , <int> , <int> } } ) ; assertEquals ( testR2 , r2 ) ; } @Test public void testSortWithIndicesDescending ( ) { INDArray toSort = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray [ ] sorted = Nd4j . sortWithIndices ( toSort . dup ( ) , <int> , false ) ; INDArray sorted2 = Nd4j . sort ( toSort . dup ( ) , <int> , false ) ; assertEquals ( sorted [ <int> ] , sorted2 ) ; INDArray shouldIndex = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( getFailureMessage ( ) , shouldIndex , sorted [ <int> ] ) ; } @Test public void testSortWithIndices ( ) { INDArray toSort = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray [ ] sorted = Nd4j . sortWithIndices ( toSort . dup ( ) , <int> , true ) ; INDArray sorted2 = Nd4j . sort ( toSort . dup ( ) , <int> , true ) ; assertEquals ( sorted [ <int> ] , sorted2 ) ; INDArray shouldIndex = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( getFailureMessage ( ) , shouldIndex , sorted [ <int> ] ) ; } @Test public void testSwapAxesFortranOrder ( ) { INDArray n = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; for ( int i = <int> ; i < n . slices ( ) ; i + + ) { INDArray nSlice = n . slice ( i ) ; for ( int j = <int> ; j < nSlice . slices ( ) ; j + + ) { INDArray sliceJ = nSlice . slice ( j ) ; System . out . println ( sliceJ ) ; } System . out . println ( nSlice ) ; } INDArray slice = n . swapAxes ( <int> , <int> ) ; INDArray assertion = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> } ) ; INDArray test = slice . slice ( <int> ) . slice ( <int> ) ; assertEquals ( assertion , test ) ; } @Test public void testDimShuffle ( ) { INDArray n = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray twoOneTwo = n . dimShuffle ( new Object [ ] { <int> , <str> , <int> } , new int [ ] { <int> , <int> } , new boolean [ ] { false , false } ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> , <int> } , twoOneTwo . shape ( ) ) ) ; INDArray reverse = n . dimShuffle ( new Object [ ] { <int> , <str> , <int> } , new int [ ] { <int> , <int> } , new boolean [ ] { false , false } ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> , <int> } , reverse . shape ( ) ) ) ; } @Test public void testGetVsGetScalar ( ) { INDArray a = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; float element = a . getFloat ( <int> , <int> ) ; double element2 = a . getDouble ( <int> , <int> ) ; assertEquals ( element , element2 , <float> ) ; INDArray a2 = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; float element23 = a2 . getFloat ( <int> , <int> ) ; double element22 = a2 . getDouble ( <int> , <int> ) ; assertEquals ( element23 , element22 , <float> ) ; } @Test public void testDivide ( ) { INDArray two = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } ) ; INDArray div = two . div ( two ) ; assertEquals ( getFailureMessage ( ) , Nd4j . ones ( <int> ) , div ) ; INDArray half = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } , new int [ ] { <int> , <int> } ) ; INDArray divi = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } , new int [ ] { <int> , <int> } ) ; INDArray assertion = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray result = half . div ( divi ) ; assertEquals ( getFailureMessage ( ) , assertion , result ) ; } @Test public void testSigmoid ( ) { INDArray n = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } ) ; INDArray assertion = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } ) ; INDArray sigmoid = Transforms . sigmoid ( n , false ) ; assertEquals ( getFailureMessage ( ) , assertion , sigmoid ) ; } @Test public void testNeg ( ) { INDArray n = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } ) ; INDArray assertion = Nd4j . create ( new float [ ] { - <int> , - <int> , - <int> , - <int> } ) ; INDArray neg = Transforms . neg ( n ) ; assertEquals ( getFailureMessage ( ) , assertion , neg ) ; } @Test public void testCosineSim ( ) { INDArray vec1 = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } ) ; INDArray vec2 = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } ) ; double sim = Transforms . cosineSim ( vec1 , vec2 ) ; assertEquals ( getFailureMessage ( ) , <int> , sim , <float> ) ; INDArray vec3 = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } ) ; INDArray vec4 = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } ) ; sim = Transforms . cosineSim ( vec3 , vec4 ) ; assertEquals ( getFailureMessage ( ) , <float> , sim , <float> ) ; } @Test public void testExp ( ) { INDArray n = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } ) ; INDArray assertion = Nd4j . create ( new double [ ] { <float> , <float> , <float> , <float> } ) ; INDArray exped = Transforms . exp ( n ) ; assertEquals ( assertion , exped ) ; } @Test public void testScalar ( ) { INDArray a = Nd4j . scalar ( <float> ) ; assertEquals ( true , a . isScalar ( ) ) ; INDArray n = Nd4j . create ( new float [ ] { <float> } , new int [ ] { <int> , <int> } ) ; assertEquals ( n , a ) ; assertTrue ( n . isScalar ( ) ) ; } @Test public void testWrap ( ) throws Exception { int [ ] shape = { <int> , <int> } ; INDArray d = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( shape [ <int> ] , shape [ <int> ] ) ; INDArray n = d ; assertEquals ( d . rows ( ) , n . rows ( ) ) ; assertEquals ( d . columns ( ) , n . columns ( ) ) ; INDArray vector = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray testVector = vector ; for ( int i = <int> ; i < vector . length ( ) ; i + + ) assertEquals ( vector . getDouble ( i ) , testVector . getDouble ( i ) , <float> ) ; assertEquals ( <int> , testVector . length ( ) ) ; assertEquals ( true , testVector . isVector ( ) ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> } , testVector . shape ( ) ) ) ; INDArray row12 = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray row22 = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; assertEquals ( row12 . rows ( ) , <int> ) ; assertEquals ( row12 . columns ( ) , <int> ) ; assertEquals ( row22 . rows ( ) , <int> ) ; assertEquals ( row22 . columns ( ) , <int> ) ; } @Test public void testGetRowFortran ( ) throws Exception { INDArray n = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ; INDArray column = Nd4j . create ( new float [ ] { <int> , <int> } ) ; INDArray column2 = Nd4j . create ( new float [ ] { <int> , <int> } ) ; INDArray testColumn = n . getRow ( <int> ) ; INDArray testColumn1 = n . getRow ( <int> ) ; assertEquals ( column , testColumn ) ; assertEquals ( column2 , testColumn1 ) ; } @Test public void testGetColumnFortran ( ) { INDArray n = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ; INDArray column = Nd4j . create ( new float [ ] { <int> , <int> } ) ; INDArray column2 = Nd4j . create ( new float [ ] { <int> , <int> } ) ; INDArray testColumn = n . getColumn ( <int> ) ; INDArray testColumn1 = n . getColumn ( <int> ) ; assertEquals ( column , testColumn ) ; assertEquals ( column2 , testColumn1 ) ; } @Test public void testGetColumns ( ) { INDArray matrix = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray matrixGet = matrix . getColumns ( new int [ ] { <int> , <int> } ) ; INDArray matrixAssertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; assertEquals ( matrixAssertion , matrixGet ) ; } @Test public void testVectorInit ( ) { DataBuffer data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; INDArray arr = Nd4j . create ( data , new int [ ] { <int> } ) ; assertEquals ( true , arr . isRowVector ( ) ) ; INDArray arr2 = Nd4j . create ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( true , arr2 . isRowVector ( ) ) ; INDArray columnVector = Nd4j . create ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( true , columnVector . isColumnVector ( ) ) ; } @Test public void testAssignOffset ( ) { INDArray arr = Nd4j . ones ( <int> , <int> ) ; INDArray row = arr . slice ( <int> ) ; row . assign ( <int> ) ; assertEquals ( Nd4j . ones ( <int> ) , row ) ; } @Test public void testColumns ( ) { INDArray arr = Nd4j . create ( new int [ ] { <int> , <int> } ) ; INDArray column2 = arr . getColumn ( <int> ) ; INDArray column = Nd4j . create ( new double [ ] { <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; arr . putColumn ( <int> , column ) ; INDArray firstColumn = arr . getColumn ( <int> ) ; assertEquals ( column , firstColumn ) ; INDArray column1 = Nd4j . create ( new double [ ] { <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; arr . putColumn ( <int> , column1 ) ; INDArray testRow1 = arr . getColumn ( <int> ) ; assertEquals ( column1 , testRow1 ) ; INDArray evenArr = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray put = Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; evenArr . putColumn ( <int> , put ) ; INDArray testColumn = evenArr . getColumn ( <int> ) ; assertEquals ( put , testColumn ) ; INDArray n = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ; INDArray column23 = n . getColumn ( <int> ) ; INDArray column12 = Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( column23 , column12 ) ; INDArray column0 = n . getColumn ( <int> ) ; INDArray column01 = Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( column0 , column01 ) ; } @Test public void testPutRow ( ) { INDArray d = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray n = d . dup ( ) ; float nFirst = <int> ; float dFirst = d . getFloat ( <int> , <int> ) ; assertEquals ( nFirst , dFirst , <float> ) ; assertEquals ( d . data ( ) , n . data ( ) ) ; assertEquals ( true , Arrays . equals ( new int [ ] { <int> , <int> } , n . shape ( ) ) ) ; INDArray newRow = Nd4j . linspace ( <int> , <int> , <int> ) ; n . putRow ( <int> , newRow ) ; d . putRow ( <int> , newRow ) ; INDArray testRow = n . getRow ( <int> ) ; assertEquals ( newRow . length ( ) , testRow . length ( ) ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> , <int> } , testRow . shape ( ) ) ) ; INDArray nLast = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ; INDArray row = nLast . getRow ( <int> ) ; INDArray row1 = Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( row , row1 ) ; INDArray arr = Nd4j . create ( new int [ ] { <int> , <int> } ) ; INDArray evenRow = Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; arr . putRow ( <int> , evenRow ) ; INDArray firstRow = arr . getRow ( <int> ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> , <int> } , firstRow . shape ( ) ) ) ; INDArray testRowEven = arr . getRow ( <int> ) ; assertEquals ( evenRow , testRowEven ) ; INDArray row12 = Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; arr . putRow ( <int> , row12 ) ; assertEquals ( true , Shape . shapeEquals ( new int [ ] { <int> , <int> } , arr . getRow ( <int> ) . shape ( ) ) ) ; INDArray testRow1 = arr . getRow ( <int> ) ; assertEquals ( row12 , testRow1 ) ; INDArray multiSliceTest = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; INDArray test = Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray test2 = Nd4j . create ( new double [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray multiSliceRow1 = multiSliceTest . slice ( <int> ) . getRow ( <int> ) ; INDArray multiSliceRow2 = multiSliceTest . slice ( <int> ) . getRow ( <int> ) ; assertEquals ( test , multiSliceRow1 ) ; assertEquals ( test2 , multiSliceRow2 ) ; } @Test public void testInplaceTranspose ( ) { INDArray test = Nd4j . rand ( <int> , <int> ) ; INDArray transposei = test . transposei ( ) ; for ( int i = <int> ; i < test . rows ( ) ; i + + ) { for ( int j = <int> ; j < test . columns ( ) ; j + + ) { assertEquals ( test . getDouble ( i , j ) , transposei . getDouble ( j , i ) , <float> ) ; } } } @Test public void testMmulF ( ) { DataBuffer data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; INDArray n = Nd4j . create ( data , new int [ ] { <int> , <int> } ) ; INDArray transposed = n . transpose ( ) ; assertEquals ( true , n . isRowVector ( ) ) ; assertEquals ( true , transposed . isColumnVector ( ) ) ; INDArray innerProduct = n . mmul ( transposed ) ; INDArray scalar = Nd4j . scalar ( <int> ) ; assertEquals ( getFailureMessage ( ) , scalar , innerProduct ) ; } @Test public void testRowsColumns ( ) { DataBuffer data = Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) ; INDArray rows = Nd4j . create ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( <int> , rows . rows ( ) ) ; assertEquals ( <int> , rows . columns ( ) ) ; INDArray columnVector = Nd4j . create ( data , new int [ ] { <int> , <int> } ) ; assertEquals ( <int> , columnVector . rows ( ) ) ; assertEquals ( <int> , columnVector . columns ( ) ) ; INDArray rowVector = Nd4j . create ( data , new int [ ] { <int> } ) ; assertEquals ( <int> , rowVector . rows ( ) ) ; assertEquals ( <int> , rowVector . columns ( ) ) ; } @Test public void testTranspose ( ) { INDArray n = Nd4j . create ( Nd4j . ones ( <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; INDArray transpose = n . transpose ( ) ; assertEquals ( n . length ( ) , transpose . length ( ) ) ; assertEquals ( true , Arrays . equals ( new int [ ] { <int> , <int> , <int> } , transpose . shape ( ) ) ) ; INDArray rowVector = Nd4j . linspace ( <int> , <int> , <int> ) ; assertTrue ( rowVector . isRowVector ( ) ) ; INDArray columnVector = rowVector . transpose ( ) ; assertTrue ( columnVector . isColumnVector ( ) ) ; INDArray linspaced = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray transposed = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( transposed , linspaced . transpose ( ) ) ; linspaced = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray transposed2 = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; transposed = linspaced . transpose ( ) ; assertEquals ( transposed , transposed2 ) ; } @Test public void testAddMatrix ( ) { INDArray five = Nd4j . ones ( <int> ) ; five . addi ( five . dup ( ) ) ; INDArray twos = Nd4j . valueArrayOf ( <int> , <int> ) ; assertEquals ( getFailureMessage ( ) , twos , five ) ; } @Test public void testMMul ( ) { INDArray arr = Nd4j . create ( new double [ ] [ ] { { <int> , <int> , <int> } , { <int> , <int> , <int> } } ) ; INDArray assertion = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; INDArray test = arr . mmul ( arr . transpose ( ) ) ; assertEquals ( getFailureMessage ( ) , assertion , test ) ; } @Test public void testPutSlice ( ) { INDArray n = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray newSlice = Nd4j . zeros ( <int> , <int> ) ; n . putSlice ( <int> , newSlice ) ; assertEquals ( getFailureMessage ( ) , newSlice , n . slice ( <int> ) ) ; } @Test public void testRowVectorMultipleIndices ( ) { INDArray linear = Nd4j . create ( <int> , <int> ) ; linear . putScalar ( new int [ ] { <int> , <int> } , <int> ) ; assertEquals ( getFailureMessage ( ) , linear . getDouble ( <int> , <int> ) , <int> , <float> ) ; } @Test public void testDim1 ( ) { INDArray sum = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray same = sum . dup ( ) ; assertEquals ( same . sum ( <int> ) , sum ) ; } @Test public void testEps ( ) { INDArray ones = Nd4j . ones ( <int> ) ; double sum = Nd4j . getExecutioner ( ) . exec ( new Eps ( ones , ones , ones , ones . length ( ) ) ) . z ( ) . sumNumber ( ) . doubleValue ( ) ; assertEquals ( <int> , sum , <float> ) ; } @Test public void testLogDouble ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray log = Transforms . log ( linspace ) ; INDArray assertion = Nd4j . create ( new double [ ] { <int> , <float> , <float> , <float> , <float> , <float> } ) ; assertEquals ( assertion , log ) ; } @Test public void testSmallSum ( ) { INDArray base = Nd4j . create ( new double [ ] { <float> , <float> } ) ; base . addi ( <float> ) ; INDArray assertion = Nd4j . create ( new double [ ] { <float> , <float> } ) ; assertEquals ( assertion , base ) ; } @Test public void testPermute ( ) { INDArray n = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> } ) ; INDArray transpose = n . transpose ( ) ; INDArray permute = n . permute ( <int> , <int> ) ; assertEquals ( permute , transpose ) ; assertEquals ( transpose . length ( ) , permute . length ( ) , <float> ) ; INDArray toPermute = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; INDArray permuted = toPermute . permute ( <int> , <int> , <int> ) ; assertNotEquals ( toPermute , permuted ) ; INDArray permuteOther = toPermute . permute ( <int> , <int> , <int> ) ; for ( int i = <int> ; i < permuteOther . slices ( ) ; i + + ) { INDArray toPermutesliceI = toPermute . slice ( i ) ; INDArray permuteOtherSliceI = permuteOther . slice ( i ) ; permuteOtherSliceI . toString ( ) ; assertNotEquals ( toPermutesliceI , permuteOtherSliceI ) ; } assertArrayEquals ( permuteOther . shape ( ) , toPermute . shape ( ) ) ; assertNotEquals ( toPermute , permuteOther ) ; } @Test public void testAppendBias ( ) { INDArray rand = Nd4j . linspace ( <int> , <int> , <int> ) . transpose ( ) ; INDArray test = Nd4j . appendBias ( rand ) ; INDArray assertion = Nd4j . toFlattened ( rand , Nd4j . scalar ( <int> ) ) ; assertEquals ( assertion , test ) ; } @Test public void testRand ( ) { INDArray rand = Nd4j . randn ( <int> , <int> ) ; Nd4j . getDistributions ( ) . createUniform ( <float> , <int> ) . sample ( <int> ) ; Nd4j . getDistributions ( ) . createNormal ( <int> , <int> ) . sample ( <int> ) ; Nd4j . getDistributions ( ) . createNormal ( rand , <int> ) . sample ( rand . shape ( ) ) ; } @Test public void testIdentity ( ) { INDArray eye = Nd4j . eye ( <int> ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> } , eye . shape ( ) ) ) ; eye = Nd4j . eye ( <int> ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> } , eye . shape ( ) ) ) ; } @Test public void testColumnVectorOpsFortran ( ) { INDArray twoByTwo = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray toAdd = Nd4j . create ( new float [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; twoByTwo . addiColumnVector ( toAdd ) ; INDArray assertion = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; assertEquals ( assertion , twoByTwo ) ; } @Test public void testRSubi ( ) { INDArray n2 = Nd4j . ones ( <int> ) ; INDArray n2Assertion = Nd4j . zeros ( <int> ) ; INDArray nRsubi = n2 . rsubi ( <int> ) ; assertEquals ( n2Assertion , nRsubi ) ; } @Test public void testAssign ( ) { INDArray vector = Nd4j . linspace ( <int> , <int> , <int> ) ; vector . assign ( <int> ) ; assertEquals ( Nd4j . ones ( <int> ) , vector ) ; INDArray twos = Nd4j . ones ( <int> , <int> ) ; INDArray rand = Nd4j . rand ( <int> , <int> ) ; twos . assign ( rand ) ; assertEquals ( rand , twos ) ; INDArray tensor = Nd4j . rand ( ( long ) <int> , <int> , <int> , <int> ) ; INDArray ones = Nd4j . ones ( <int> , <int> , <int> ) ; assertTrue ( Arrays . equals ( tensor . shape ( ) , ones . shape ( ) ) ) ; ones . assign ( tensor ) ; assertEquals ( tensor , ones ) ; } @Test public void testAddScalar ( ) { INDArray div = Nd4j . valueArrayOf ( new int [ ] { <int> , <int> } , <int> ) ; INDArray rdiv = div . add ( <int> ) ; INDArray answer = Nd4j . valueArrayOf ( new int [ ] { <int> , <int> } , <int> ) ; assertEquals ( answer , rdiv ) ; } @Test public void testRdivScalar ( ) { INDArray div = Nd4j . valueArrayOf ( <int> , <int> ) ; INDArray rdiv = div . rdiv ( <int> ) ; INDArray answer = Nd4j . valueArrayOf ( new int [ ] { <int> , <int> } , <float> ) ; assertEquals ( rdiv , answer ) ; } @Test public void testRDivi ( ) { INDArray n2 = Nd4j . valueArrayOf ( new int [ ] { <int> , <int> } , <int> ) ; INDArray n2Assertion = Nd4j . valueArrayOf ( new int [ ] { <int> , <int> } , <float> ) ; INDArray nRsubi = n2 . rdivi ( <int> ) ; assertEquals ( n2Assertion , nRsubi ) ; } @Test public void testNumVectorsAlongDimension ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; assertEquals ( <int> , arr . vectorsAlongDimension ( <int> ) ) ; } @Test public void testBroadCast ( ) { INDArray n = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray broadCasted = n . broadcast ( <int> , <int> ) ; for ( int i = <int> ; i < broadCasted . rows ( ) ; i + + ) { assertEquals ( n , broadCasted . getRow ( i ) ) ; } INDArray broadCast2 = broadCasted . getRow ( <int> ) . broadcast ( <int> , <int> ) ; assertEquals ( broadCasted , broadCast2 ) ; INDArray columnBroadcast = n . transpose ( ) . broadcast ( <int> , <int> ) ; for ( int i = <int> ; i < columnBroadcast . columns ( ) ; i + + ) { assertEquals ( columnBroadcast . getColumn ( i ) , n . transpose ( ) ) ; } INDArray fourD = Nd4j . create ( <int> , <int> , <int> , <int> ) ; INDArray broadCasted3 = fourD . broadcast ( <int> , <int> , <int> , <int> ) ; assertTrue ( Arrays . equals ( new int [ ] { <int> , <int> , <int> , <int> } , broadCasted3 . shape ( ) ) ) ; } @Test public void testMatrix ( ) { INDArray arr = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray brr = Nd4j . create ( new float [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray row = arr . getRow ( <int> ) ; row . subi ( brr ) ; assertEquals ( Nd4j . create ( new double [ ] { - <int> , - <int> } ) , arr . getRow ( <int> ) ) ; } @Test public void testPutRowGetRowOrdering ( ) { INDArray row1 = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray put = Nd4j . create ( new double [ ] { <int> , <int> } ) ; row1 . putRow ( <int> , put ) ; INDArray row1Fortran = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray putFortran = Nd4j . create ( new double [ ] { <int> , <int> } ) ; row1Fortran . putRow ( <int> , putFortran ) ; assertEquals ( row1 , row1Fortran ) ; INDArray row1CTest = row1 . getRow ( <int> ) ; INDArray row1FortranTest = row1Fortran . getRow ( <int> ) ; assertEquals ( row1CTest , row1FortranTest ) ; } @Test public void testSumWithRow1 ( ) { INDArray array2d = Nd4j . ones ( <int> , <int> ) ; array2d . sum ( <int> ) ; array2d . sum ( <int> ) ; INDArray array3d = Nd4j . ones ( <int> , <int> , <int> ) ; array3d . sum ( <int> ) ; array3d . sum ( <int> ) ; array3d . sum ( <int> ) ; INDArray array4d = Nd4j . ones ( <int> , <int> , <int> , <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; INDArray array5d = Nd4j . ones ( <int> , <int> , <int> , <int> , <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; } @Test public void testSumWithRow2 ( ) { INDArray array3d = Nd4j . ones ( <int> , <int> , <int> ) ; array3d . sum ( <int> ) ; array3d . sum ( <int> ) ; array3d . sum ( <int> ) ; INDArray array4d = Nd4j . ones ( <int> , <int> , <int> , <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; array4d . sum ( <int> ) ; INDArray array5d = Nd4j . ones ( <int> , <int> , <int> , <int> , <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; array5d . sum ( <int> ) ; } @Test public void testPutRowFortran ( ) { INDArray row1 = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray put = Nd4j . create ( new double [ ] { <int> , <int> } ) ; row1 . putRow ( <int> , put ) ; INDArray row1Fortran = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; INDArray putFortran = Nd4j . create ( new double [ ] { <int> , <int> } ) ; row1Fortran . putRow ( <int> , putFortran ) ; assertEquals ( row1 , row1Fortran ) ; } @Test public void testElementWiseOps ( ) { INDArray n1 = Nd4j . scalar ( <int> ) ; INDArray n2 = Nd4j . scalar ( <int> ) ; INDArray nClone = n1 . add ( n2 ) ; assertEquals ( Nd4j . scalar ( <int> ) , nClone ) ; INDArray n1PlusN2 = n1 . add ( n2 ) ; assertFalse ( getFailureMessage ( ) , n1PlusN2 . equals ( n1 ) ) ; INDArray n3 = Nd4j . scalar ( <int> ) ; INDArray n4 = Nd4j . scalar ( <int> ) ; INDArray subbed = n4 . sub ( n3 ) ; INDArray mulled = n4 . mul ( n3 ) ; INDArray div = n4 . div ( n3 ) ; assertFalse ( subbed . equals ( n4 ) ) ; assertFalse ( mulled . equals ( n4 ) ) ; assertEquals ( Nd4j . scalar ( <int> ) , subbed ) ; assertEquals ( Nd4j . scalar ( <int> ) , mulled ) ; assertEquals ( Nd4j . scalar ( <float> ) , div ) ; } @Test public void testRollAxis ( ) { INDArray toRoll = Nd4j . ones ( <int> , <int> , <int> , <int> ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> , <int> } , Nd4j . rollAxis ( toRoll , <int> , <int> ) . shape ( ) ) ; int [ ] shape = Nd4j . rollAxis ( toRoll , <int> ) . shape ( ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> , <int> } , shape ) ; } @Test public void testTensorDot ( ) { INDArray oneThroughSixty = Nd4j . arange ( <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray oneThroughTwentyFour = Nd4j . arange ( <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray result = Nd4j . tensorMmul ( oneThroughSixty , oneThroughTwentyFour , new int [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , result . shape ( ) ) ; INDArray assertion = Nd4j . create ( new double [ ] [ ] { { <float> , <float> } , { <float> , <float> } , { <float> , <float> } , { <float> , <float> } , { <float> , <float> } } ) ; assertEquals ( assertion , result ) ; } @Test public void testNegativeShape ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray reshaped = linspace . reshape ( - <int> , <int> ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , reshaped . shape ( ) ) ; INDArray linspace6 = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray reshaped2 = linspace6 . reshape ( - <int> , <int> ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , reshaped2 . shape ( ) ) ; } @Test public void testGetColumnGetRow ( ) { INDArray row = Nd4j . ones ( <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { INDArray col = row . getColumn ( i ) ; assertArrayEquals ( col . shape ( ) , new int [ ] { <int> , <int> } ) ; } INDArray col = Nd4j . ones ( <int> , <int> ) ; for ( int i = <int> ; i < <int> ; i + + ) { INDArray row2 = col . getRow ( i ) ; assertArrayEquals ( row2 . shape ( ) , new int [ ] { <int> , <int> } ) ; } } @Test public void testDupAndDupWithOrder ( ) { List < Pair < INDArray , String > > testInputs = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , <int> ) ; for ( Pair < INDArray , String > pair : testInputs ) { String msg = pair . getSecond ( ) ; INDArray in = pair . getFirst ( ) ; INDArray dup = in . dup ( ) ; INDArray dupc = in . dup ( <str> ) ; INDArray dupf = in . dup ( <str> ) ; assertEquals ( msg , in , dup ) ; assertEquals ( msg , dup . ordering ( ) , ( char ) Nd4j . order ( ) ) ; assertEquals ( msg , dupc . ordering ( ) , <str> ) ; assertEquals ( msg , dupf . ordering ( ) , <str> ) ; assertEquals ( msg , in , dupc ) ; assertEquals ( msg , in , dupf ) ; } } @Test public void testToOffsetZeroCopy ( ) { List < Pair < INDArray , String > > testInputs = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , <int> ) ; for ( Pair < INDArray , String > pair : testInputs ) { String msg = pair . getSecond ( ) ; INDArray in = pair . getFirst ( ) ; INDArray dup = Shape . toOffsetZeroCopy ( in ) ; INDArray dupc = Shape . toOffsetZeroCopy ( in , <str> ) ; INDArray dupf = Shape . toOffsetZeroCopy ( in , <str> ) ; INDArray dupany = Shape . toOffsetZeroCopyAnyOrder ( in ) ; assertEquals ( msg , in , dup ) ; assertEquals ( msg , in , dupc ) ; assertEquals ( msg , in , dupf ) ; assertEquals ( msg , dupc . ordering ( ) , <str> ) ; assertEquals ( msg , dupf . ordering ( ) , <str> ) ; assertEquals ( msg , in , dupany ) ; assertEquals ( dup . offset ( ) , <int> ) ; assertEquals ( dupc . offset ( ) , <int> ) ; assertEquals ( dupf . offset ( ) , <int> ) ; assertEquals ( dupany . offset ( ) , <int> ) ; assertEquals ( dup . length ( ) , dup . data ( ) . length ( ) ) ; assertEquals ( dupc . length ( ) , dupc . data ( ) . length ( ) ) ; assertEquals ( dupf . length ( ) , dupf . data ( ) . length ( ) ) ; assertEquals ( dupany . length ( ) , dupany . data ( ) . length ( ) ) ; } } @Test public void testTensorStats ( ) { List < Pair < INDArray , String > > testInputs = NDArrayCreationUtil . getAllTestMatricesWithShape ( <int> , <int> , <int> ) ; for ( Pair < INDArray , String > pair : testInputs ) { INDArray arr = pair . getFirst ( ) ; String msg = pair . getSecond ( ) ; int nTAD0 = arr . tensorssAlongDimension ( <int> ) ; int nTAD1 = arr . tensorssAlongDimension ( <int> ) ; OpExecutionerUtil . Tensor1DStats t0 = OpExecutionerUtil . get1DTensorStats ( arr , <int> ) ; OpExecutionerUtil . Tensor1DStats t1 = OpExecutionerUtil . get1DTensorStats ( arr , <int> ) ; assertEquals ( nTAD0 , t0 . getNumTensors ( ) ) ; assertEquals ( nTAD1 , t1 . getNumTensors ( ) ) ; INDArray tFirst0 = arr . tensorAlongDimension ( <int> , <int> ) ; INDArray tSecond0 = arr . tensorAlongDimension ( <int> , <int> ) ; INDArray tFirst1 = arr . tensorAlongDimension ( <int> , <int> ) ; INDArray tSecond1 = arr . tensorAlongDimension ( <int> , <int> ) ; assertEquals ( tFirst0 . offset ( ) , t0 . getFirstTensorOffset ( ) ) ; assertEquals ( tFirst1 . offset ( ) , t1 . getFirstTensorOffset ( ) ) ; int separation0 = tSecond0 . offset ( ) - tFirst0 . offset ( ) ; int separation1 = tSecond1 . offset ( ) - tFirst1 . offset ( ) ; assertEquals ( separation0 , t0 . getTensorStartSeparation ( ) ) ; assertEquals ( separation1 , t1 . getTensorStartSeparation ( ) ) ; for ( int i = <int> ; i < nTAD0 ; i + + ) { INDArray tad0 = arr . tensorAlongDimension ( i , <int> ) ; assertEquals ( tad0 . length ( ) , t0 . getTensorLength ( ) ) ; assertEquals ( tad0 . elementWiseStride ( ) , t0 . getElementWiseStride ( ) ) ; int offset = tad0 . offset ( ) ; int calcOffset = t0 . getFirstTensorOffset ( ) + i * t0 . getTensorStartSeparation ( ) ; assertEquals ( offset , calcOffset ) ; } for ( int i = <int> ; i < nTAD1 ; i + + ) { INDArray tad1 = arr . tensorAlongDimension ( i , <int> ) ; assertEquals ( tad1 . length ( ) , t1 . getTensorLength ( ) ) ; assertEquals ( tad1 . elementWiseStride ( ) , t1 . getElementWiseStride ( ) ) ; int offset = tad1 . offset ( ) ; int calcOffset = t1 . getFirstTensorOffset ( ) + i * t1 . getTensorStartSeparation ( ) ; assertEquals ( offset , calcOffset ) ; } } } @Test public void testNdVectorOp ( ) { Nd4j . getRandom ( ) . setSeed ( <int> ) ; int [ ] maxShape = new int [ ] { <int> , <int> , <int> , <int> , <int> , <int> } ; for ( int opNum = <int> ; opNum < <int> ; opNum + + ) { for ( int rank = <int> ; rank < maxShape . length ; rank + + ) { int [ ] shape = Arrays . copyOfRange ( maxShape , <int> , rank ) ; INDArray orig = Nd4j . rand ( shape ) ; for ( int i = <int> ; i < rank ; i + + ) { INDArray arr = orig . dup ( ) ; INDArray vector = Nd4j . rand ( <int> , shape [ i ] ) ; BroadcastOp op ; switch ( opNum ) { case <int> : op = new BroadcastAddOp ( arr , vector , arr , i ) ; break ; case <int> : op = new BroadcastCopyOp ( arr , vector , arr , i ) ; break ; case <int> : op = new BroadcastDivOp ( arr , vector , arr , i ) ; break ; case <int> : op = new BroadcastMulOp ( arr , vector , arr , i ) ; break ; case <int> : op = new BroadcastRDivOp ( arr , vector , arr , i ) ; break ; case <int> : op = new BroadcastRSubOp ( arr , vector , arr , i ) ; break ; case <int> : op = new BroadcastSubOp ( arr , vector , arr , i ) ; break ; default : throw new RuntimeException ( ) ; } Nd4j . getExecutioner ( ) . exec ( op ) ; NdIndexIterator iter = new NdIndexIterator ( orig . shape ( ) ) ; while ( iter . hasNext ( ) ) { int [ ] next = iter . next ( ) ; double origValue = orig . getDouble ( next ) ; double vectorValue = vector . getDouble ( next [ i ] ) ; double exp ; switch ( opNum ) { case <int> : exp = origValue + vectorValue ; break ; case <int> : exp = vectorValue ; break ; case <int> : exp = origValue / vectorValue ; break ; case <int> : exp = origValue * vectorValue ; break ; case <int> : exp = vectorValue / origValue ; break ; case <int> : exp = vectorValue - origValue ; break ; case <int> : exp = origValue - vectorValue ; break ; default : throw new RuntimeException ( ) ; } double actual = arr . getDouble ( next ) ; double relError = Math . abs ( exp - actual ) / ( Math . abs ( exp ) + Math . abs ( actual ) ) ; assertTrue ( relError < <float> ) ; } } } } } @Override public char ordering ( ) { return <str> ; } } 
