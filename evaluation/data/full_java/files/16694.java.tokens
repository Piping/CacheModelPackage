package org . junit . tests . running . methods ; import static org . hamcrest . CoreMatchers . containsString ; import static org . hamcrest . CoreMatchers . not ; import static org . hamcrest . CoreMatchers . is ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertThat ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import java . io . PrintWriter ; import java . io . StringWriter ; import java . io . Writer ; import java . util . concurrent . TimeUnit ; import junit . framework . JUnit4TestAdapter ; import junit . framework . TestResult ; import org . junit . After ; import org . junit . Ignore ; import org . junit . Rule ; import org . junit . Test ; import org . junit . rules . TestRule ; import org . junit . rules . Timeout ; import org . junit . runner . JUnitCore ; import org . junit . runner . Result ; public class TimeoutTest { public static class FailureWithTimeoutTest { @Test ( timeout = <int> ) public void failure ( ) { fail ( ) ; } } @Test public void failureWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( FailureWithTimeoutTest . class ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; assertEquals ( AssertionError . class , result . getFailures ( ) . get ( <int> ) . getException ( ) . getClass ( ) ) ; } public static class FailureWithTimeoutRunTimeExceptionTest { @Test ( timeout = <int> ) public void failure ( ) { throw new NullPointerException ( ) ; } } @Test public void failureWithTimeoutRunTimeException ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( FailureWithTimeoutRunTimeExceptionTest . class ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; assertEquals ( NullPointerException . class , result . getFailures ( ) . get ( <int> ) . getException ( ) . getClass ( ) ) ; } public static class SuccessWithTimeoutTest { @Test ( timeout = <int> ) public void success ( ) { } } @Test public void successWithTimeout ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( SuccessWithTimeoutTest . class ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; } public static class TimeoutFailureTest { @Test ( timeout = <int> ) public void success ( ) throws InterruptedException { Thread . sleep ( <int> ) ; } } @Ignore ( <str> ) @Test public void timeoutFailure ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeoutFailureTest . class ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; assertEquals ( InterruptedException . class , result . getFailures ( ) . get ( <int> ) . getException ( ) . getClass ( ) ) ; } public static class InfiniteLoopTest { @Test ( timeout = <int> ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } } @Test public void infiniteLoop ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( <int> ) . getException ( ) ; assertTrue ( exception . getMessage ( ) . contains ( <str> ) ) ; } public static class ImpatientLoopTest { @Test ( timeout = <int> ) public void failure ( ) { infiniteLoop ( ) ; } private void infiniteLoop ( ) { for ( ; ; ) ; } } @Ignore ( <str> ) @Test public void infiniteLoopRunsForApproximatelyLengthOfTimeout ( ) throws Exception { JUnitCore . runClasses ( InfiniteLoopTest . class , ImpatientLoopTest . class ) ; long longTime = runAndTime ( InfiniteLoopTest . class ) ; long shortTime = runAndTime ( ImpatientLoopTest . class ) ; long difference = longTime - shortTime ; assertTrue ( String . format ( <str> , difference ) , difference < <int> ) ; } private long runAndTime ( Class < ? > clazz ) { JUnitCore core = new JUnitCore ( ) ; long startTime = System . currentTimeMillis ( ) ; core . run ( clazz ) ; long totalTime = System . currentTimeMillis ( ) - startTime ; return totalTime ; } private String stackForException ( Throwable exception ) { Writer buffer = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( buffer ) ; exception . printStackTrace ( writer ) ; return buffer . toString ( ) ; } @Test public void stalledThreadAppearsInStackTrace ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopTest . class ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( <int> ) . getException ( ) ; assertThat ( stackForException ( exception ) , containsString ( <str> ) ) ; } public static class InfiniteLoopMultithreaded { private static class ThreadTest implements Runnable { private boolean fStall ; public ThreadTest ( boolean stall ) { fStall = stall ; } public void run ( ) { if ( fStall ) for ( ; ; ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } public void failure ( boolean mainThreadStalls ) throws Exception { Thread t1 = new Thread ( new ThreadTest ( false ) , <str> ) ; Thread t2 = new Thread ( new ThreadTest ( ! mainThreadStalls ) , <str> ) ; Thread t3 = new Thread ( new ThreadTest ( false ) , <str> ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; if ( mainThreadStalls ) for ( ; ; ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; } } public static class InfiniteLoopWithStuckThreadTest { @Rule public TestRule globalTimeout = Timeout . builder ( ) . withTimeout ( <int> , TimeUnit . MILLISECONDS ) . withLookingForStuckThread ( true ) . build ( ) ; @Test public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( false ) ; } } public static class InfiniteLoopStuckInMainThreadTest { @Rule public TestRule globalTimeout = Timeout . builder ( ) . withTimeout ( <int> , TimeUnit . MILLISECONDS ) . withLookingForStuckThread ( true ) . build ( ) ; @Test public void failure ( ) throws Exception { ( new InfiniteLoopMultithreaded ( ) ) . failure ( true ) ; } } @Test public void timeoutFailureMultithreaded ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopWithStuckThreadTest . class ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; Throwable exception [ ] = new Throwable [ <int> ] ; for ( int i = <int> ; i < <int> ; i + + ) exception [ i ] = result . getFailures ( ) . get ( i ) . getException ( ) ; assertThat ( exception [ <int> ] . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( stackForException ( exception [ <int> ] ) , containsString ( <str> ) ) ; assertThat ( exception [ <int> ] . getMessage ( ) , containsString ( <str> ) ) ; } @Test public void timeoutFailureMultithreadedStuckInMain ( ) throws Exception { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( InfiniteLoopStuckInMainThreadTest . class ) ; assertEquals ( <int> , result . getRunCount ( ) ) ; assertEquals ( <int> , result . getFailureCount ( ) ) ; Throwable exception = result . getFailures ( ) . get ( <int> ) . getException ( ) ; assertThat ( exception . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( exception . getMessage ( ) , not ( containsString ( <str> ) ) ) ; } @Test public void compatibility ( ) { TestResult result = new TestResult ( ) ; new JUnit4TestAdapter ( InfiniteLoopTest . class ) . run ( result ) ; assertEquals ( <int> , result . errorCount ( ) ) ; } public static class WillTimeOut { static boolean afterWasCalled = false ; @Test ( timeout = <int> ) public void test ( ) { for ( ; ; ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } @After public void after ( ) { afterWasCalled = true ; } } @Test public void makeSureAfterIsCalledAfterATimeout ( ) { JUnitCore . runClasses ( WillTimeOut . class ) ; assertThat ( WillTimeOut . afterWasCalled , is ( true ) ) ; } public static class TimeOutZero { @Rule public Timeout timeout = Timeout . seconds ( <int> ) ; @Test public void test ( ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } } } @Test public void testZeroTimeoutIsIgnored ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeOutZero . class ) ; assertEquals ( <str> , <int> , result . getRunCount ( ) ) ; assertEquals ( <str> , <int> , result . getFailureCount ( ) ) ; } private static class TimeoutSubclass extends Timeout { public TimeoutSubclass ( long timeout , TimeUnit timeUnit ) { super ( timeout , timeUnit ) ; } public long getTimeoutFromSuperclass ( TimeUnit unit ) { return super . getTimeout ( unit ) ; } } public static class TimeOutOneSecond { @Rule public TimeoutSubclass timeout = new TimeoutSubclass ( <int> , TimeUnit . SECONDS ) ; @Test public void test ( ) { assertEquals ( <int> , timeout . getTimeoutFromSuperclass ( TimeUnit . MILLISECONDS ) ) ; } } @Test public void testGetTimeout ( ) { JUnitCore core = new JUnitCore ( ) ; Result result = core . run ( TimeOutOneSecond . class ) ; assertEquals ( <str> , <int> , result . getRunCount ( ) ) ; assertEquals ( <str> , <int> , result . getFailureCount ( ) ) ; } } 
