package org . nd4j . linalg . api . blas ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . complex . IComplexNDArray ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . factory . NDArrayFactory ; public class BlasBufferUtil { public static int getBlasOffset ( INDArray arr ) { return arr . offset ( ) ; } public static int getBlasStride ( INDArray arr ) { if ( arr instanceof IComplexNDArray ) return arr . elementWiseStride ( ) / <int> ; return arr . elementWiseStride ( ) ; } public static float [ ] getFloatData ( INDArray buf ) { if ( buf . data ( ) . dataType ( ) ! = DataBuffer . Type . FLOAT ) throw new IllegalArgumentException ( <str> ) ; if ( buf . data ( ) . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { return buf . data ( ) . asFloat ( ) ; } else { float [ ] ret = new float [ buf . length ( ) ] ; INDArray linear = buf . linearView ( ) ; for ( int i = <int> ; i < buf . length ( ) ; i + + ) ret [ i ] = linear . getFloat ( i ) ; return ret ; } } public static double [ ] getDoubleData ( INDArray buf ) { if ( buf . data ( ) . dataType ( ) ! = DataBuffer . Type . DOUBLE ) throw new IllegalArgumentException ( <str> ) ; if ( buf . data ( ) . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { return buf . data ( ) . asDouble ( ) ; } else { double [ ] ret = new double [ buf . length ( ) ] ; INDArray linear = buf . linearView ( ) ; for ( int i = <int> ; i < buf . length ( ) ; i + + ) ret [ i ] = linear . getDouble ( i ) ; return ret ; } } public static char getCharForTranspose ( INDArray arr ) { return <str> ; } public static int getStrideForOrdering ( INDArray arr ) { if ( arr . ordering ( ) = = NDArrayFactory . FORTRAN ) { return getBlasStride ( arr ) ; } else { if ( arr instanceof IComplexNDArray ) return arr . stride ( <int> ) / <int> ; return arr . stride ( <int> ) ; } } public static int getDimension ( INDArray arr , boolean defaultRows ) { if ( arr . isVector ( ) ) { return defaultRows ? arr . rows ( ) : arr . columns ( ) ; } if ( arr . ordering ( ) = = NDArrayFactory . C ) return defaultRows ? arr . columns ( ) : arr . rows ( ) ; return defaultRows ? arr . rows ( ) : arr . columns ( ) ; } public static int getLd ( INDArray arr ) { if ( arr . isVector ( ) ) { return arr . size ( <int> ) ; } return arr . ordering ( ) = = NDArrayFactory . C ? arr . size ( <int> ) : arr . size ( <int> ) ; } public static float [ ] getFloatData ( DataBuffer buf ) { if ( buf . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { return buf . asFloat ( ) ; } else { float [ ] ret = new float [ ( int ) buf . length ( ) ] ; for ( int i = <int> ; i < buf . length ( ) ; i + + ) ret [ i ] = buf . getFloat ( i ) ; return ret ; } } public static double [ ] getDoubleData ( DataBuffer buf ) { if ( buf . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) return buf . asDouble ( ) ; else { double [ ] ret = new double [ ( int ) buf . length ( ) ] ; for ( int i = <int> ; i < buf . length ( ) ; i + + ) ret [ i ] = buf . getDouble ( i ) ; return ret ; } } public static void setData ( float [ ] data , INDArray toSet ) { if ( toSet . data ( ) . dataType ( ) ! = DataBuffer . Type . FLOAT ) { throw new IllegalArgumentException ( <str> + toSet . data ( ) . dataType ( ) ) ; } if ( toSet . data ( ) . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { Object array = toSet . data ( ) . array ( ) ; if ( array = = data ) return ; else { float [ ] d = ( float [ ] ) array ; if ( toSet . offset ( ) = = <int> & & toSet . length ( ) = = data . length ) System . arraycopy ( data , <int> , d , <int> , d . length ) ; else { int count = <int> ; for ( int i = <int> ; i < data . length ; i + + ) { int dIndex = toSet . offset ( ) + ( i * toSet . majorStride ( ) ) ; d [ dIndex ] = data [ count + + ] ; } } } } else { DataBuffer underlyingData = toSet . data ( ) ; if ( data . length = = toSet . length ( ) & & toSet . offset ( ) = = <int> ) { for ( int i = <int> ; i < toSet . length ( ) ; i + + ) { underlyingData . put ( i , data [ i ] ) ; } } else { int count = <int> ; for ( int i = <int> ; i < data . length ; i + + ) { int dIndex = toSet . offset ( ) + ( i * toSet . majorStride ( ) ) ; underlyingData . put ( dIndex , data [ count + + ] ) ; } } } } public static void setData ( double [ ] data , INDArray toSet ) { if ( toSet . data ( ) . dataType ( ) ! = DataBuffer . Type . DOUBLE ) { throw new IllegalArgumentException ( <str> + toSet . data ( ) . dataType ( ) ) ; } if ( toSet . data ( ) . allocationMode ( ) = = DataBuffer . AllocationMode . HEAP ) { Object array = toSet . data ( ) . array ( ) ; if ( array = = data ) return ; else { double [ ] d = ( double [ ] ) array ; if ( toSet . offset ( ) = = <int> & & toSet . length ( ) = = data . length ) System . arraycopy ( data , <int> , d , <int> , d . length ) ; else { int count = <int> ; for ( int i = <int> ; i < data . length ; i + + ) { int dIndex = toSet . offset ( ) + ( i * toSet . majorStride ( ) ) ; d [ dIndex ] = data [ count + + ] ; } } } } else { DataBuffer underlyingData = toSet . data ( ) ; if ( data . length = = toSet . length ( ) & & toSet . offset ( ) = = <int> ) { for ( int i = <int> ; i < toSet . length ( ) ; i + + ) { underlyingData . put ( i , data [ i ] ) ; } } else { int count = <int> ; for ( int i = <int> ; i < data . length ; i + + ) { int dIndex = toSet . offset ( ) + ( i * toSet . majorStride ( ) ) ; underlyingData . put ( dIndex , data [ count + + ] ) ; } } } } } 
