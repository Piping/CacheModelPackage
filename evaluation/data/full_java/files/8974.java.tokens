package org . elasticsearch . test ; import org . elasticsearch . Version ; import java . lang . reflect . Field ; import java . lang . reflect . Modifier ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . List ; import java . util . Random ; import java . util . Set ; public class VersionUtils { private static final List < Version > SORTED_VERSIONS ; static { Field [ ] declaredFields = Version . class . getFields ( ) ; Set < Integer > ids = new HashSet < > ( ) ; for ( Field field : declaredFields ) { final int mod = field . getModifiers ( ) ; if ( Modifier . isStatic ( mod ) & & Modifier . isFinal ( mod ) & & Modifier . isPublic ( mod ) ) { if ( field . getType ( ) = = Version . class ) { try { Version object = ( Version ) field . get ( null ) ; ids . add ( object . id ) ; } catch ( Throwable e ) { throw new RuntimeException ( e ) ; } } } } List < Integer > idList = new ArrayList < > ( ids ) ; Collections . sort ( idList ) ; List < Version > version = new ArrayList < > ( ) ; for ( Integer integer : idList ) { version . add ( Version . fromId ( integer ) ) ; } SORTED_VERSIONS = Collections . unmodifiableList ( version ) ; } public static List < Version > allVersions ( ) { return Collections . unmodifiableList ( SORTED_VERSIONS ) ; } public static Version getPreviousVersion ( Version version ) { int index = SORTED_VERSIONS . indexOf ( version ) ; assert index > <int> ; return SORTED_VERSIONS . get ( index - <int> ) ; } public static Version getPreviousVersion ( ) { Version version = getPreviousVersion ( Version . CURRENT ) ; assert version . before ( Version . CURRENT ) ; return version ; } public static Version getFirstVersion ( ) { return SORTED_VERSIONS . get ( <int> ) ; } public static Version randomVersion ( Random random ) { return SORTED_VERSIONS . get ( random . nextInt ( SORTED_VERSIONS . size ( ) ) ) ; } public static Version randomVersionBetween ( Random random , Version minVersion , Version maxVersion ) { int minVersionIndex = <int> ; if ( minVersion ! = null ) { minVersionIndex = SORTED_VERSIONS . indexOf ( minVersion ) ; } int maxVersionIndex = SORTED_VERSIONS . size ( ) - <int> ; if ( maxVersion ! = null ) { maxVersionIndex = SORTED_VERSIONS . indexOf ( maxVersion ) ; } if ( minVersionIndex = = - <int> ) { throw new IllegalArgumentException ( <str> + minVersion + <str> ) ; } else if ( maxVersionIndex = = - <int> ) { throw new IllegalArgumentException ( <str> + maxVersion + <str> ) ; } else if ( minVersionIndex > maxVersionIndex ) { throw new IllegalArgumentException ( <str> + maxVersion + <str> + minVersion + <str> ) ; } else { int range = maxVersionIndex + <int> - minVersionIndex ; return SORTED_VERSIONS . get ( minVersionIndex + random . nextInt ( range ) ) ; } } } 
