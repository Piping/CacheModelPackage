package com . badlogic . gdx . tests . g3d . shadows . utils ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . g3d . Renderable ; import com . badlogic . gdx . graphics . g3d . RenderableProvider ; import com . badlogic . gdx . graphics . g3d . environment . BaseLight ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . BoundingBox ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Pool ; public class AABBNearFarAnalyzer implements NearFarAnalyzer { public static float CAMERA_NEAR = <int> ; public static float CAMERA_FAR = <int> ; protected static class RenderablePool extends Pool < Renderable > { protected Array < Renderable > obtained = new Array < Renderable > ( ) ; @Override protected Renderable newObject ( ) { return new Renderable ( ) ; } @Override public Renderable obtain ( ) { Renderable renderable = super . obtain ( ) ; renderable . environment = null ; renderable . material = null ; renderable . meshPart . set ( <str> , null , <int> , <int> , <int> ) ; renderable . shader = null ; obtained . add ( renderable ) ; return renderable ; } public void flush ( ) { super . freeAll ( obtained ) ; obtained . clear ( ) ; } } protected final RenderablePool renderablesPool = new RenderablePool ( ) ; protected final Array < Renderable > renderables = new Array < Renderable > ( ) ; protected BoundingBox bb1 = new BoundingBox ( ) ; protected Vector3 tmpV = new Vector3 ( ) ; @Override public < T extends RenderableProvider > void analyze ( BaseLight light , Camera camera , Iterable < T > renderableProviders ) { getRenderables ( renderableProviders ) ; prepareCamera ( camera ) ; bb1 . inf ( ) ; for ( Renderable renderable : renderables ) { renderable . worldTransform . getTranslation ( tmpV ) ; tmpV . add ( renderable . meshPart . center ) ; if ( camera . frustum . sphereInFrustum ( tmpV , renderable . meshPart . radius ) ) { bb1 . ext ( tmpV , renderable . meshPart . radius ) ; } } computeResult ( bb1 , camera ) ; renderablesPool . flush ( ) ; renderables . clear ( ) ; } protected < T extends RenderableProvider > void getRenderables ( Iterable < T > renderableProviders ) { for ( RenderableProvider renderableProvider : renderableProviders ) { renderableProvider . getRenderables ( renderables , renderablesPool ) ; } } protected void prepareCamera ( Camera camera ) { camera . near = AABBNearFarAnalyzer . CAMERA_NEAR ; camera . far = AABBNearFarAnalyzer . CAMERA_FAR ; camera . update ( ) ; } protected void computeResult ( BoundingBox bb , Camera camera ) { float radius = bb1 . getDimensions ( tmpV ) . len ( ) * <float> ; bb1 . getCenter ( tmpV ) ; float distance = tmpV . dst ( camera . position ) ; float near = distance - radius ; float far = distance + radius ; if ( near < = <int> ) near = CAMERA_NEAR ; if ( far < = <int> ) far = CAMERA_FAR ; camera . near = near ; camera . far = far ; camera . update ( ) ; } } 
