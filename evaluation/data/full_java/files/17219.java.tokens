package org . jbox2d . dynamics . joints ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . Body ; import org . jbox2d . dynamics . SolverData ; import org . jbox2d . dynamics . World ; import org . jbox2d . pooling . IWorldPool ; public abstract class Joint { public static Joint create ( World world , JointDef def ) { switch ( def . type ) { case MOUSE : return new MouseJoint ( world . getPool ( ) , ( MouseJointDef ) def ) ; case DISTANCE : return new DistanceJoint ( world . getPool ( ) , ( DistanceJointDef ) def ) ; case PRISMATIC : return new PrismaticJoint ( world . getPool ( ) , ( PrismaticJointDef ) def ) ; case REVOLUTE : return new RevoluteJoint ( world . getPool ( ) , ( RevoluteJointDef ) def ) ; case WELD : return new WeldJoint ( world . getPool ( ) , ( WeldJointDef ) def ) ; case FRICTION : return new FrictionJoint ( world . getPool ( ) , ( FrictionJointDef ) def ) ; case WHEEL : return new WheelJoint ( world . getPool ( ) , ( WheelJointDef ) def ) ; case GEAR : return new GearJoint ( world . getPool ( ) , ( GearJointDef ) def ) ; case PULLEY : return new PulleyJoint ( world . getPool ( ) , ( PulleyJointDef ) def ) ; case CONSTANT_VOLUME : return new ConstantVolumeJoint ( world , ( ConstantVolumeJointDef ) def ) ; case ROPE : return new RopeJoint ( world . getPool ( ) , ( RopeJointDef ) def ) ; case MOTOR : return new MotorJoint ( world . getPool ( ) , ( MotorJointDef ) def ) ; case UNKNOWN : default : return null ; } } public static void destroy ( Joint joint ) { joint . destructor ( ) ; } private final JointType m_type ; public Joint m_prev ; public Joint m_next ; public JointEdge m_edgeA ; public JointEdge m_edgeB ; protected Body m_bodyA ; protected Body m_bodyB ; public boolean m_islandFlag ; private boolean m_collideConnected ; public Object m_userData ; protected IWorldPool pool ; protected Joint ( IWorldPool worldPool , JointDef def ) { assert ( def . bodyA ! = def . bodyB ) ; pool = worldPool ; m_type = def . type ; m_prev = null ; m_next = null ; m_bodyA = def . bodyA ; m_bodyB = def . bodyB ; m_collideConnected = def . collideConnected ; m_islandFlag = false ; m_userData = def . userData ; m_edgeA = new JointEdge ( ) ; m_edgeA . joint = null ; m_edgeA . other = null ; m_edgeA . prev = null ; m_edgeA . next = null ; m_edgeB = new JointEdge ( ) ; m_edgeB . joint = null ; m_edgeB . other = null ; m_edgeB . prev = null ; m_edgeB . next = null ; } public JointType getType ( ) { return m_type ; } public final Body getBodyA ( ) { return m_bodyA ; } public final Body getBodyB ( ) { return m_bodyB ; } public abstract void getAnchorA ( Vec2 out ) ; public abstract void getAnchorB ( Vec2 out ) ; public abstract void getReactionForce ( float inv_dt , Vec2 out ) ; public abstract float getReactionTorque ( float inv_dt ) ; public Joint getNext ( ) { return m_next ; } public Object getUserData ( ) { return m_userData ; } public void setUserData ( Object data ) { m_userData = data ; } public final boolean getCollideConnected ( ) { return m_collideConnected ; } public boolean isActive ( ) { return m_bodyA . isActive ( ) & & m_bodyB . isActive ( ) ; } public abstract void initVelocityConstraints ( SolverData data ) ; public abstract void solveVelocityConstraints ( SolverData data ) ; public abstract boolean solvePositionConstraints ( SolverData data ) ; public void destructor ( ) { } } 
