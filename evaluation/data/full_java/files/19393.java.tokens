package io . netty . handler . codec . http2 ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . handler . codec . http2 . hpack . Encoder ; import io . netty . util . AsciiString ; import org . junit . Before ; import org . junit . Test ; import java . io . ByteArrayOutputStream ; import static io . netty . handler . codec . http2 . Http2CodecUtil . DEFAULT_MAX_HEADER_SIZE ; import static io . netty . handler . codec . http2 . Http2CodecUtil . MAX_HEADER_TABLE_SIZE ; import static io . netty . handler . codec . http2 . Http2TestUtil . randomBytes ; import static io . netty . util . CharsetUtil . UTF_8 ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . fail ; public class DefaultHttp2HeadersDecoderTest { private DefaultHttp2HeadersDecoder decoder ; @Before public void setup ( ) { decoder = new DefaultHttp2HeadersDecoder ( false ) ; } @Test public void decodeShouldSucceed ( ) throws Exception { ByteBuf buf = encode ( b ( <str> ) , b ( <str> ) , b ( <str> ) , b ( <str> ) , randomBytes ( ) , randomBytes ( ) ) ; try { Http2Headers headers = decoder . decodeHeaders ( buf ) ; assertEquals ( <int> , headers . size ( ) ) ; assertEquals ( <str> , headers . method ( ) . toString ( ) ) ; assertEquals ( <str> , headers . get ( new AsciiString ( <str> ) ) . toString ( ) ) ; } finally { buf . release ( ) ; } } @Test ( expected = Http2Exception . class ) public void testExceedHeaderSize ( ) throws Exception { ByteBuf buf = encode ( randomBytes ( DEFAULT_MAX_HEADER_SIZE ) , randomBytes ( <int> ) ) ; try { decoder . decodeHeaders ( buf ) ; fail ( ) ; } finally { buf . release ( ) ; } } private static byte [ ] b ( String string ) { return string . getBytes ( UTF_8 ) ; } private static ByteBuf encode ( byte [ ] . . . entries ) throws Exception { Encoder encoder = new Encoder ( MAX_HEADER_TABLE_SIZE ) ; ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; for ( int ix = <int> ; ix < entries . length ; ) { byte [ ] key = entries [ ix + + ] ; byte [ ] value = entries [ ix + + ] ; encoder . encodeHeader ( stream , key , value , false ) ; } return Unpooled . wrappedBuffer ( stream . toByteArray ( ) ) ; } } 
