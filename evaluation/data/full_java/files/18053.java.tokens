package com . badlogic . gdx . graphics . g3d . particles . influencers ; import java . util . Arrays ; import com . badlogic . gdx . graphics . g3d . particles . ParallelArray . FloatChannel ; import com . badlogic . gdx . graphics . g3d . particles . ParticleChannels ; import com . badlogic . gdx . graphics . g3d . particles . ParticleController ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Json ; import com . badlogic . gdx . utils . JsonValue ; public class DynamicsInfluencer extends Influencer { public Array < DynamicsModifier > velocities ; private FloatChannel accellerationChannel , positionChannel , previousPositionChannel , rotationChannel , angularVelocityChannel ; boolean hasAcceleration , has2dAngularVelocity , has3dAngularVelocity ; public DynamicsInfluencer ( ) { this . velocities = new Array < DynamicsModifier > ( true , <int> , DynamicsModifier . class ) ; } public DynamicsInfluencer ( DynamicsModifier . . . velocities ) { this . velocities = new Array < DynamicsModifier > ( true , velocities . length , DynamicsModifier . class ) ; for ( DynamicsModifier value : velocities ) { this . velocities . add ( ( DynamicsModifier ) value . copy ( ) ) ; } } public DynamicsInfluencer ( DynamicsInfluencer velocityInfluencer ) { this ( ( DynamicsModifier [ ] ) velocityInfluencer . velocities . toArray ( DynamicsModifier . class ) ) ; } @Override public void allocateChannels ( ) { for ( int k = <int> ; k < velocities . size ; + + k ) { velocities . items [ k ] . allocateChannels ( ) ; } accellerationChannel = controller . particles . getChannel ( ParticleChannels . Acceleration ) ; hasAcceleration = accellerationChannel ! = null ; if ( hasAcceleration ) { positionChannel = controller . particles . addChannel ( ParticleChannels . Position ) ; previousPositionChannel = controller . particles . addChannel ( ParticleChannels . PreviousPosition ) ; } angularVelocityChannel = controller . particles . getChannel ( ParticleChannels . AngularVelocity2D ) ; has2dAngularVelocity = angularVelocityChannel ! = null ; if ( has2dAngularVelocity ) { rotationChannel = controller . particles . addChannel ( ParticleChannels . Rotation2D ) ; has3dAngularVelocity = false ; } else { angularVelocityChannel = controller . particles . getChannel ( ParticleChannels . AngularVelocity3D ) ; has3dAngularVelocity = angularVelocityChannel ! = null ; if ( has3dAngularVelocity ) rotationChannel = controller . particles . addChannel ( ParticleChannels . Rotation3D ) ; } } @Override public void set ( ParticleController particleController ) { super . set ( particleController ) ; for ( int k = <int> ; k < velocities . size ; + + k ) { velocities . items [ k ] . set ( particleController ) ; } } @Override public void init ( ) { for ( int k = <int> ; k < velocities . size ; + + k ) { velocities . items [ k ] . init ( ) ; } } public void activateParticles ( int startIndex , int count ) { if ( hasAcceleration ) { for ( int i = startIndex * positionChannel . strideSize , c = i + count * positionChannel . strideSize ; i < c ; i + = positionChannel . strideSize ) { previousPositionChannel . data [ i + ParticleChannels . XOffset ] = positionChannel . data [ i + ParticleChannels . XOffset ] ; previousPositionChannel . data [ i + ParticleChannels . YOffset ] = positionChannel . data [ i + ParticleChannels . YOffset ] ; previousPositionChannel . data [ i + ParticleChannels . ZOffset ] = positionChannel . data [ i + ParticleChannels . ZOffset ] ; } } if ( has2dAngularVelocity ) { for ( int i = startIndex * rotationChannel . strideSize , c = i + count * rotationChannel . strideSize ; i < c ; i + = rotationChannel . strideSize ) { rotationChannel . data [ i + ParticleChannels . CosineOffset ] = <int> ; rotationChannel . data [ i + ParticleChannels . SineOffset ] = <int> ; } } else if ( has3dAngularVelocity ) { for ( int i = startIndex * rotationChannel . strideSize , c = i + count * rotationChannel . strideSize ; i < c ; i + = rotationChannel . strideSize ) { rotationChannel . data [ i + ParticleChannels . XOffset ] = <int> ; rotationChannel . data [ i + ParticleChannels . YOffset ] = <int> ; rotationChannel . data [ i + ParticleChannels . ZOffset ] = <int> ; rotationChannel . data [ i + ParticleChannels . WOffset ] = <int> ; } } for ( int k = <int> ; k < velocities . size ; + + k ) { velocities . items [ k ] . activateParticles ( startIndex , count ) ; } } public void update ( ) { if ( hasAcceleration ) Arrays . fill ( accellerationChannel . data , <int> , controller . particles . size * accellerationChannel . strideSize , <int> ) ; if ( has2dAngularVelocity | | has3dAngularVelocity ) Arrays . fill ( angularVelocityChannel . data , <int> , controller . particles . size * angularVelocityChannel . strideSize , <int> ) ; for ( int k = <int> ; k < velocities . size ; + + k ) { velocities . items [ k ] . update ( ) ; } if ( hasAcceleration ) { for ( int i = <int> , offset = <int> ; i < controller . particles . size ; + + i , offset + = positionChannel . strideSize ) { float x = positionChannel . data [ offset + ParticleChannels . XOffset ] , y = positionChannel . data [ offset + ParticleChannels . YOffset ] , z = positionChannel . data [ offset + ParticleChannels . ZOffset ] ; positionChannel . data [ offset + ParticleChannels . XOffset ] = <int> * x - previousPositionChannel . data [ offset + ParticleChannels . XOffset ] + accellerationChannel . data [ offset + ParticleChannels . XOffset ] * controller . deltaTimeSqr ; positionChannel . data [ offset + ParticleChannels . YOffset ] = <int> * y - previousPositionChannel . data [ offset + ParticleChannels . YOffset ] + accellerationChannel . data [ offset + ParticleChannels . YOffset ] * controller . deltaTimeSqr ; positionChannel . data [ offset + ParticleChannels . ZOffset ] = <int> * z - previousPositionChannel . data [ offset + ParticleChannels . ZOffset ] + accellerationChannel . data [ offset + ParticleChannels . ZOffset ] * controller . deltaTimeSqr ; previousPositionChannel . data [ offset + ParticleChannels . XOffset ] = x ; previousPositionChannel . data [ offset + ParticleChannels . YOffset ] = y ; previousPositionChannel . data [ offset + ParticleChannels . ZOffset ] = z ; } } if ( has2dAngularVelocity ) { for ( int i = <int> , offset = <int> ; i < controller . particles . size ; + + i , offset + = rotationChannel . strideSize ) { float rotation = angularVelocityChannel . data [ i ] * controller . deltaTime ; if ( rotation ! = <int> ) { float cosBeta = MathUtils . cosDeg ( rotation ) , sinBeta = MathUtils . sinDeg ( rotation ) ; float currentCosine = rotationChannel . data [ offset + ParticleChannels . CosineOffset ] ; float currentSine = rotationChannel . data [ offset + ParticleChannels . SineOffset ] ; float newCosine = currentCosine * cosBeta - currentSine * sinBeta , newSine = currentSine * cosBeta + currentCosine * sinBeta ; rotationChannel . data [ offset + ParticleChannels . CosineOffset ] = newCosine ; rotationChannel . data [ offset + ParticleChannels . SineOffset ] = newSine ; } } } else if ( has3dAngularVelocity ) { for ( int i = <int> , offset = <int> , angularOffset = <int> ; i < controller . particles . size ; + + i , offset + = rotationChannel . strideSize , angularOffset + = angularVelocityChannel . strideSize ) { float wx = angularVelocityChannel . data [ angularOffset + ParticleChannels . XOffset ] , wy = angularVelocityChannel . data [ angularOffset + ParticleChannels . YOffset ] , wz = angularVelocityChannel . data [ angularOffset + ParticleChannels . ZOffset ] , qx = rotationChannel . data [ offset + ParticleChannels . XOffset ] , qy = rotationChannel . data [ offset + ParticleChannels . YOffset ] , qz = rotationChannel . data [ offset + ParticleChannels . ZOffset ] , qw = rotationChannel . data [ offset + ParticleChannels . WOffset ] ; TMP_Q . set ( wx , wy , wz , <int> ) . mul ( qx , qy , qz , qw ) . mul ( <float> * controller . deltaTime ) . add ( qx , qy , qz , qw ) . nor ( ) ; rotationChannel . data [ offset + ParticleChannels . XOffset ] = TMP_Q . x ; rotationChannel . data [ offset + ParticleChannels . YOffset ] = TMP_Q . y ; rotationChannel . data [ offset + ParticleChannels . ZOffset ] = TMP_Q . z ; rotationChannel . data [ offset + ParticleChannels . WOffset ] = TMP_Q . w ; } } } @Override public DynamicsInfluencer copy ( ) { return new DynamicsInfluencer ( this ) ; } @Override public void write ( Json json ) { json . writeValue ( <str> , velocities , Array . class , DynamicsModifier . class ) ; } @Override public void read ( Json json , JsonValue jsonData ) { velocities . addAll ( json . readValue ( <str> , Array . class , DynamicsModifier . class , jsonData ) ) ; } } 
