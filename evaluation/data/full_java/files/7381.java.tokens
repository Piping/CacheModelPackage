package org . elasticsearch . search . aggregations . pipeline . bucketmetrics ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . search . aggregations . Aggregation ; import org . elasticsearch . search . aggregations . Aggregations ; import org . elasticsearch . search . aggregations . InternalAggregation ; import org . elasticsearch . search . aggregations . InternalAggregation . ReduceContext ; import org . elasticsearch . search . aggregations . InternalMultiBucketAggregation ; import org . elasticsearch . search . aggregations . bucket . MultiBucketsAggregation . Bucket ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers ; import org . elasticsearch . search . aggregations . pipeline . BucketHelpers . GapPolicy ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . pipeline . SiblingPipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationPath ; import org . elasticsearch . search . aggregations . support . format . ValueFormatter ; import org . elasticsearch . search . aggregations . support . format . ValueFormatterStreams ; import java . io . IOException ; import java . util . Collections ; import java . util . List ; import java . util . Map ; public abstract class BucketMetricsPipelineAggregator extends SiblingPipelineAggregator { protected ValueFormatter formatter ; protected GapPolicy gapPolicy ; public BucketMetricsPipelineAggregator ( ) { super ( ) ; } protected BucketMetricsPipelineAggregator ( String name , String [ ] bucketsPaths , GapPolicy gapPolicy , ValueFormatter formatter , Map < String , Object > metaData ) { super ( name , bucketsPaths , metaData ) ; this . gapPolicy = gapPolicy ; this . formatter = formatter ; } @Override public final InternalAggregation doReduce ( Aggregations aggregations , ReduceContext context ) { preCollection ( ) ; List < String > bucketsPath = AggregationPath . parse ( bucketsPaths ( ) [ <int> ] ) . getPathElementsAsStringList ( ) ; for ( Aggregation aggregation : aggregations ) { if ( aggregation . getName ( ) . equals ( bucketsPath . get ( <int> ) ) ) { bucketsPath = bucketsPath . subList ( <int> , bucketsPath . size ( ) ) ; InternalMultiBucketAggregation multiBucketsAgg = ( InternalMultiBucketAggregation ) aggregation ; List < ? extends Bucket > buckets = multiBucketsAgg . getBuckets ( ) ; for ( int i = <int> ; i < buckets . size ( ) ; i + + ) { Bucket bucket = buckets . get ( i ) ; Double bucketValue = BucketHelpers . resolveBucketValue ( multiBucketsAgg , bucket , bucketsPath , gapPolicy ) ; if ( bucketValue ! = null & & ! Double . isNaN ( bucketValue ) ) { collectBucketValue ( bucket . getKeyAsString ( ) , bucketValue ) ; } } } } return buildAggregation ( Collections . emptyList ( ) , metaData ( ) ) ; } protected void preCollection ( ) { } protected abstract InternalAggregation buildAggregation ( List < PipelineAggregator > pipelineAggregators , Map < String , Object > metadata ) ; protected abstract void collectBucketValue ( String bucketKey , Double bucketValue ) ; @Override public void doReadFrom ( StreamInput in ) throws IOException { formatter = ValueFormatterStreams . readOptional ( in ) ; gapPolicy = GapPolicy . readFrom ( in ) ; } @Override public void doWriteTo ( StreamOutput out ) throws IOException { ValueFormatterStreams . writeOptional ( formatter , out ) ; gapPolicy . writeTo ( out ) ; } } 
