package io . netty . handler . codec . http2 ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . http . DefaultHttpHeaders ; import io . netty . handler . codec . http . FullHttpMessage ; import io . netty . handler . codec . http . HttpHeaders ; import io . netty . util . AsciiString ; import io . netty . util . collection . IntObjectHashMap ; import io . netty . util . collection . IntObjectMap ; import java . util . Iterator ; import java . util . Map . Entry ; import static io . netty . handler . codec . http2 . Http2Error . PROTOCOL_ERROR ; import static io . netty . handler . codec . http2 . Http2Exception . connectionError ; public final class InboundHttp2ToHttpPriorityAdapter extends InboundHttp2ToHttpAdapter { private static final AsciiString OUT_OF_MESSAGE_SEQUENCE_METHOD = new AsciiString ( HttpConversionUtil . OUT_OF_MESSAGE_SEQUENCE_METHOD . toString ( ) ) ; private static final AsciiString OUT_OF_MESSAGE_SEQUENCE_PATH = new AsciiString ( HttpConversionUtil . OUT_OF_MESSAGE_SEQUENCE_PATH ) ; private static final AsciiString OUT_OF_MESSAGE_SEQUENCE_RETURN_CODE = new AsciiString ( HttpConversionUtil . OUT_OF_MESSAGE_SEQUENCE_RETURN_CODE . toString ( ) ) ; private final IntObjectMap < HttpHeaders > outOfMessageFlowHeaders ; public static final class Builder extends InboundHttp2ToHttpAdapter . Builder { public Builder ( Http2Connection connection ) { super ( connection ) ; } @Override public InboundHttp2ToHttpPriorityAdapter build ( ) { final InboundHttp2ToHttpPriorityAdapter instance = new InboundHttp2ToHttpPriorityAdapter ( this ) ; instance . connection . addListener ( instance ) ; return instance ; } } InboundHttp2ToHttpPriorityAdapter ( Builder builder ) { super ( builder ) ; outOfMessageFlowHeaders = new IntObjectHashMap < HttpHeaders > ( ) ; } @Override protected void removeMessage ( int streamId ) { super . removeMessage ( streamId ) ; outOfMessageFlowHeaders . remove ( streamId ) ; } private static HttpHeaders getActiveHeaders ( FullHttpMessage msg ) { return msg . content ( ) . isReadable ( ) ? msg . trailingHeaders ( ) : msg . headers ( ) ; } private void importOutOfMessageFlowHeaders ( int streamId , HttpHeaders headers ) { final HttpHeaders outOfMessageFlowHeader = outOfMessageFlowHeaders . get ( streamId ) ; if ( outOfMessageFlowHeader = = null ) { outOfMessageFlowHeaders . put ( streamId , headers ) ; } else { outOfMessageFlowHeader . setAll ( headers ) ; } } private void exportOutOfMessageFlowHeaders ( int streamId , final HttpHeaders headers ) { final HttpHeaders outOfMessageFlowHeader = outOfMessageFlowHeaders . get ( streamId ) ; if ( outOfMessageFlowHeader ! = null ) { headers . setAll ( outOfMessageFlowHeader ) ; } } private static void removePriorityRelatedHeaders ( HttpHeaders headers ) { headers . remove ( HttpConversionUtil . ExtensionHeaderNames . STREAM_DEPENDENCY_ID . text ( ) ) ; headers . remove ( HttpConversionUtil . ExtensionHeaderNames . STREAM_WEIGHT . text ( ) ) ; } private void initializePseudoHeaders ( Http2Headers headers ) { if ( connection . isServer ( ) ) { headers . method ( OUT_OF_MESSAGE_SEQUENCE_METHOD ) . path ( OUT_OF_MESSAGE_SEQUENCE_PATH ) ; } else { headers . status ( OUT_OF_MESSAGE_SEQUENCE_RETURN_CODE ) ; } } private static void addHttpHeadersToHttp2Headers ( HttpHeaders httpHeaders , final Http2Headers http2Headers ) { Iterator < Entry < CharSequence , CharSequence > > iter = httpHeaders . iteratorCharSequence ( ) ; while ( iter . hasNext ( ) ) { Entry < CharSequence , CharSequence > entry = iter . next ( ) ; http2Headers . add ( AsciiString . of ( entry . getKey ( ) ) , AsciiString . of ( entry . getValue ( ) ) ) ; } } @Override protected void fireChannelRead ( ChannelHandlerContext ctx , FullHttpMessage msg , int streamId ) { exportOutOfMessageFlowHeaders ( streamId , getActiveHeaders ( msg ) ) ; super . fireChannelRead ( ctx , msg , streamId ) ; } @Override protected FullHttpMessage processHeadersBegin ( ChannelHandlerContext ctx , int streamId , Http2Headers headers , boolean endOfStream , boolean allowAppend , boolean appendToTrailer ) throws Http2Exception { FullHttpMessage msg = super . processHeadersBegin ( ctx , streamId , headers , endOfStream , allowAppend , appendToTrailer ) ; if ( msg ! = null ) { exportOutOfMessageFlowHeaders ( streamId , getActiveHeaders ( msg ) ) ; } return msg ; } @Override public void onPriorityTreeParentChanged ( Http2Stream stream , Http2Stream oldParent ) { Http2Stream parent = stream . parent ( ) ; FullHttpMessage msg = messageMap . get ( stream . id ( ) ) ; if ( msg = = null ) { if ( parent ! = null & & ! parent . equals ( connection . connectionStream ( ) ) ) { HttpHeaders headers = new DefaultHttpHeaders ( ) ; headers . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_DEPENDENCY_ID . text ( ) , parent . id ( ) ) ; importOutOfMessageFlowHeaders ( stream . id ( ) , headers ) ; } } else { if ( parent = = null ) { removePriorityRelatedHeaders ( msg . headers ( ) ) ; removePriorityRelatedHeaders ( msg . trailingHeaders ( ) ) ; } else if ( ! parent . equals ( connection . connectionStream ( ) ) ) { HttpHeaders headers = getActiveHeaders ( msg ) ; headers . setInt ( HttpConversionUtil . ExtensionHeaderNames . STREAM_DEPENDENCY_ID . text ( ) , parent . id ( ) ) ; } } } @Override public void onWeightChanged ( Http2Stream stream , short oldWeight ) { FullHttpMessage msg = messageMap . get ( stream . id ( ) ) ; final HttpHeaders headers ; if ( msg = = null ) { headers = new DefaultHttpHeaders ( ) ; importOutOfMessageFlowHeaders ( stream . id ( ) , headers ) ; } else { headers = getActiveHeaders ( msg ) ; } headers . setShort ( HttpConversionUtil . ExtensionHeaderNames . STREAM_WEIGHT . text ( ) , stream . weight ( ) ) ; } @Override public void onPriorityRead ( ChannelHandlerContext ctx , int streamId , int streamDependency , short weight , boolean exclusive ) throws Http2Exception { FullHttpMessage msg = messageMap . get ( streamId ) ; if ( msg = = null ) { HttpHeaders httpHeaders = outOfMessageFlowHeaders . remove ( streamId ) ; if ( httpHeaders = = null ) { throw connectionError ( PROTOCOL_ERROR , <str> , streamId ) ; } Http2Headers http2Headers = new DefaultHttp2Headers ( validateHttpHeaders , httpHeaders . size ( ) ) ; initializePseudoHeaders ( http2Headers ) ; addHttpHeadersToHttp2Headers ( httpHeaders , http2Headers ) ; msg = newMessage ( streamId , http2Headers , validateHttpHeaders ) ; fireChannelRead ( ctx , msg , streamId ) ; } } } 
