package io . netty . handler . codec . memcache . binary ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import org . junit . Test ; import static org . hamcrest . CoreMatchers . * ; import static org . hamcrest . MatcherAssert . * ; import static org . hamcrest . core . IsNull . notNullValue ; import static org . hamcrest . core . IsNull . nullValue ; public class BinaryMemcacheObjectAggregatorTest { private static final byte [ ] SET_REQUEST_WITH_CONTENT = { ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; public static final int MAX_CONTENT_SIZE = <int> < < <int> ; private EmbeddedChannel channel ; @Test public void shouldAggregateChunksOnDecode ( ) { int smallBatchSize = <int> ; channel = new EmbeddedChannel ( new BinaryMemcacheRequestDecoder ( smallBatchSize ) , new BinaryMemcacheObjectAggregator ( MAX_CONTENT_SIZE ) ) ; ByteBuf incoming = Unpooled . buffer ( ) ; incoming . writeBytes ( SET_REQUEST_WITH_CONTENT ) ; channel . writeInbound ( incoming ) ; FullBinaryMemcacheRequest request = channel . readInbound ( ) ; assertThat ( request , instanceOf ( FullBinaryMemcacheRequest . class ) ) ; assertThat ( request , notNullValue ( ) ) ; assertThat ( request . key ( ) , notNullValue ( ) ) ; assertThat ( request . extras ( ) , nullValue ( ) ) ; assertThat ( request . content ( ) . readableBytes ( ) , is ( <int> ) ) ; assertThat ( request . content ( ) . readByte ( ) , is ( ( byte ) <hex> ) ) ; assertThat ( request . content ( ) . readByte ( ) , is ( ( byte ) <hex> ) ) ; request . release ( ) ; assertThat ( channel . readInbound ( ) , nullValue ( ) ) ; channel . finish ( ) ; } } 
