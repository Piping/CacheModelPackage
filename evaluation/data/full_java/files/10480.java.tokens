package com . google . common . graph ; import static com . google . common . truth . Truth . assertThat ; import static org . junit . Assert . assertEquals ; import static org . junit . Assert . assertFalse ; import static org . junit . Assert . assertTrue ; import static org . junit . Assert . fail ; import com . google . common . collect . ImmutableSet ; import com . google . common . testing . EqualsTester ; import org . junit . Test ; import org . junit . runner . RunWith ; import org . junit . runners . JUnit4 ; @RunWith ( JUnit4 . class ) public class IncidenceSetUndirectedGraphTest extends IncidenceSetSimpleUndirectedGraphTest { @Override public UndirectedGraph < Integer , String > createGraph ( ) { return Graphs . createUndirected ( ) ; } @Test public void edges_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( graph . edges ( ) ) . containsExactly ( E11 ) ; } @Test public void incidentEdges_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( graph . incidentEdges ( N1 ) ) . containsExactly ( E11 ) ; } @Test public void incidentNodes_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( graph . incidentNodes ( E11 ) ) . containsExactly ( N1 ) ; } @Test public void adjacentNodes_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; addEdge ( E12 , N1 , N2 ) ; assertThat ( graph . adjacentNodes ( N1 ) ) . containsExactly ( N1 , N2 ) . inOrder ( ) ; } @Test public void adjacentEdges_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( graph . adjacentEdges ( E11 ) ) . isEmpty ( ) ; addEdge ( E12 , N1 , N2 ) ; assertThat ( graph . adjacentEdges ( E11 ) ) . containsExactly ( E12 ) ; } @Test public void edgesConnecting_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( undirectedGraph . edgesConnecting ( N1 , N1 ) ) . containsExactly ( E11 ) ; addEdge ( E12 , N1 , N2 ) ; assertThat ( undirectedGraph . edgesConnecting ( N1 , N2 ) ) . containsExactly ( E12 ) ; assertThat ( undirectedGraph . edgesConnecting ( N2 , N1 ) ) . containsExactly ( E12 ) ; assertThat ( undirectedGraph . edgesConnecting ( N1 , N1 ) ) . containsExactly ( E11 ) ; } @Test public void inEdges_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( undirectedGraph . inEdges ( N1 ) ) . containsExactly ( E11 ) ; addEdge ( E12 , N1 , N2 ) ; assertThat ( undirectedGraph . inEdges ( N1 ) ) . containsExactly ( E11 , E12 ) . inOrder ( ) ; } @Test public void outEdges_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( undirectedGraph . outEdges ( N1 ) ) . containsExactly ( E11 ) ; addEdge ( E12 , N2 , N1 ) ; assertThat ( undirectedGraph . outEdges ( N1 ) ) . containsExactly ( E11 , E12 ) . inOrder ( ) ; } @Test public void predecessors_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( undirectedGraph . predecessors ( N1 ) ) . containsExactly ( N1 ) ; addEdge ( E12 , N1 , N2 ) ; assertThat ( undirectedGraph . predecessors ( N1 ) ) . containsExactly ( N1 , N2 ) . inOrder ( ) ; } @Test public void successors_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( undirectedGraph . successors ( N1 ) ) . containsExactly ( N1 ) ; addEdge ( E12 , N2 , N1 ) ; assertThat ( undirectedGraph . successors ( N1 ) ) . containsExactly ( N1 , N2 ) . inOrder ( ) ; } @Test public void degree_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertEquals ( <int> , graph . degree ( N1 ) ) ; addEdge ( E12 , N1 , N2 ) ; assertEquals ( <int> , graph . degree ( N1 ) ) ; } @Test public void inDegree_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertEquals ( <int> , undirectedGraph . inDegree ( N1 ) ) ; addEdge ( E12 , N1 , N2 ) ; assertEquals ( <int> , undirectedGraph . inDegree ( N1 ) ) ; } @Test public void outDegree_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertEquals ( <int> , undirectedGraph . outDegree ( N1 ) ) ; addEdge ( E12 , N2 , N1 ) ; assertEquals ( <int> , undirectedGraph . outDegree ( N1 ) ) ; } @Override public void addEdge_selfLoop ( ) { assertTrue ( addEdge ( E11 , N1 , N1 ) ) ; assertThat ( graph . edges ( ) ) . contains ( E11 ) ; assertThat ( graph . edgesConnecting ( N1 , N1 ) ) . containsExactly ( E11 ) ; } @Test public void addEdge_existingSelfLoopEdgeBetweenSameNodes ( ) { addEdge ( E11 , N1 , N1 ) ; ImmutableSet < String > edges = ImmutableSet . copyOf ( graph . edges ( ) ) ; assertFalse ( addEdge ( E11 , N1 , N1 ) ) ; assertThat ( graph . edges ( ) ) . containsExactlyElementsIn ( edges ) ; } @Test public void addEdge_existingEdgeBetweenDifferentNodes_selfLoops ( ) { addEdge ( E11 , N1 , N1 ) ; try { addEdge ( E11 , N1 , N2 ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_REUSE_EDGE ) ; } try { addEdge ( E11 , N2 , N2 ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_REUSE_EDGE ) ; } addEdge ( E12 , N1 , N2 ) ; try { addEdge ( E12 , N1 , N1 ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_REUSE_EDGE ) ; } } @Test public void addEdge_parallelSelfLoopEdge ( ) { addEdge ( E11 , N1 , N1 ) ; try { addEdge ( EDGE_NOT_IN_GRAPH , N1 , N1 ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) ) . contains ( ERROR_PARALLEL_EDGE ) ; } } @Test public void removeNode_existingNodeWithSelfLoopEdge ( ) { addNode ( N1 ) ; addEdge ( E11 , N1 , N1 ) ; assertTrue ( graph . removeNode ( N1 ) ) ; assertThat ( graph . nodes ( ) ) . isEmpty ( ) ; assertThat ( graph . edges ( ) ) . doesNotContain ( E11 ) ; } @Test public void removeEdge_existingSelfLoopEdge ( ) { addEdge ( E11 , N1 , N1 ) ; assertTrue ( graph . removeEdge ( E11 ) ) ; assertThat ( graph . edges ( ) ) . doesNotContain ( E11 ) ; assertThat ( graph . edgesConnecting ( N1 , N1 ) ) . isEmpty ( ) ; } @Test public void testEquals ( ) { UndirectedGraph < Integer , String > graphA = createGraph ( ) ; graphA . addNode ( N1 ) ; UndirectedGraph < Integer , String > graphB = createGraph ( ) ; graphA . addNode ( N2 ) ; new EqualsTester ( ) . addEqualityGroup ( graphA ) . addEqualityGroup ( graphB ) . testEquals ( ) ; } @Test public void toString_selfLoop ( ) { addEdge ( E11 , N1 , N1 ) ; assertThat ( graph . toString ( ) ) . isEqualTo ( String . format ( <str> , graph . config ( ) , graph . nodes ( ) , E11 , N1 ) ) ; } } 
