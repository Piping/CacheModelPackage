package org . elasticsearch . indices ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . IndexShardState ; import org . elasticsearch . threadpool . ThreadPool ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . Executor ; import java . util . concurrent . TimeUnit ; public final class IndicesWarmer extends AbstractComponent { public static final String INDEX_WARMER_ENABLED = <str> ; private final ThreadPool threadPool ; private final CopyOnWriteArrayList < Listener > listeners = new CopyOnWriteArrayList < > ( ) ; @Inject public IndicesWarmer ( Settings settings , ThreadPool threadPool ) { super ( settings ) ; this . threadPool = threadPool ; } public void addListener ( Listener listener ) { listeners . add ( listener ) ; } public void removeListener ( Listener listener ) { listeners . remove ( listener ) ; } public void warm ( Engine . Searcher searcher , IndexShard shard , IndexSettings settings , boolean isTopReader ) { if ( shard . state ( ) = = IndexShardState . CLOSED ) { return ; } final Settings indexSettings = settings . getSettings ( ) ; if ( ! indexSettings . getAsBoolean ( INDEX_WARMER_ENABLED , settings . getNodeSettings ( ) . getAsBoolean ( INDEX_WARMER_ENABLED , true ) ) ) { return ; } if ( logger . isTraceEnabled ( ) ) { if ( isTopReader ) { logger . trace ( <str> , shard . shardId ( ) , searcher . reader ( ) ) ; } else { logger . trace ( <str> , shard . shardId ( ) , searcher . reader ( ) ) ; } } shard . warmerService ( ) . onPreWarm ( ) ; long time = System . nanoTime ( ) ; final List < TerminationHandle > terminationHandles = new ArrayList < > ( ) ; for ( final Listener listener : listeners ) { if ( isTopReader ) { terminationHandles . add ( listener . warmTopReader ( shard , searcher ) ) ; } else { terminationHandles . add ( listener . warmNewReaders ( shard , searcher ) ) ; } } for ( TerminationHandle terminationHandle : terminationHandles ) { try { terminationHandle . awaitTermination ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; if ( isTopReader ) { logger . warn ( <str> , e ) ; } else { logger . warn ( <str> , e ) ; } break ; } } long took = System . nanoTime ( ) - time ; shard . warmerService ( ) . onPostWarm ( took ) ; if ( shard . warmerService ( ) . logger ( ) . isTraceEnabled ( ) ) { if ( isTopReader ) { shard . warmerService ( ) . logger ( ) . trace ( <str> , new TimeValue ( took , TimeUnit . NANOSECONDS ) ) ; } else { shard . warmerService ( ) . logger ( ) . trace ( <str> , new TimeValue ( took , TimeUnit . NANOSECONDS ) ) ; } } } public Executor getExecutor ( ) { return threadPool . executor ( ThreadPool . Names . WARMER ) ; } public interface TerminationHandle { TerminationHandle NO_WAIT = ( ) - > { } ; void awaitTermination ( ) throws InterruptedException ; } public interface Listener { TerminationHandle warmNewReaders ( IndexShard indexShard , Engine . Searcher searcher ) ; TerminationHandle warmTopReader ( IndexShard indexShard , Engine . Searcher searcher ) ; } } 
