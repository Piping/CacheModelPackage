package org . elasticsearch . rest . action . search ; import org . elasticsearch . action . search . SearchRequest ; import org . elasticsearch . action . search . SearchType ; import org . elasticsearch . action . support . IndicesOptions ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . QueryBuilder ; import org . elasticsearch . index . query . QueryParseContext ; import org . elasticsearch . index . query . TemplateQueryParser ; import org . elasticsearch . indices . query . IndicesQueriesRegistry ; import org . elasticsearch . rest . BaseRestHandler ; import org . elasticsearch . rest . RestChannel ; import org . elasticsearch . rest . RestController ; import org . elasticsearch . rest . RestRequest ; import org . elasticsearch . rest . action . support . RestActions ; import org . elasticsearch . rest . action . support . RestStatusToXContentListener ; import org . elasticsearch . script . Template ; import org . elasticsearch . search . Scroll ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import org . elasticsearch . search . fetch . source . FetchSourceContext ; import org . elasticsearch . search . internal . SearchContext ; import org . elasticsearch . search . sort . SortOrder ; import org . elasticsearch . search . suggest . SuggestBuilder ; import java . io . IOException ; import java . util . Arrays ; import static org . elasticsearch . common . unit . TimeValue . parseTimeValue ; import static org . elasticsearch . rest . RestRequest . Method . GET ; import static org . elasticsearch . rest . RestRequest . Method . POST ; import static org . elasticsearch . search . suggest . SuggestBuilders . termSuggestion ; public class RestSearchAction extends BaseRestHandler { private final IndicesQueriesRegistry queryRegistry ; @Inject public RestSearchAction ( Settings settings , RestController controller , Client client , IndicesQueriesRegistry queryRegistry ) { super ( settings , controller , client ) ; this . queryRegistry = queryRegistry ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( POST , <str> , this ) ; } @Override public void handleRequest ( final RestRequest request , final RestChannel channel , final Client client ) throws IOException { SearchRequest searchRequest ; searchRequest = RestSearchAction . parseSearchRequest ( queryRegistry , request , parseFieldMatcher ) ; client . search ( searchRequest , new RestStatusToXContentListener < > ( channel ) ) ; } public static SearchRequest parseSearchRequest ( IndicesQueriesRegistry indicesQueriesRegistry , RestRequest request , ParseFieldMatcher parseFieldMatcher ) throws IOException { String [ ] indices = Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ; SearchRequest searchRequest = new SearchRequest ( indices ) ; boolean isTemplateRequest = request . path ( ) . endsWith ( <str> ) ; final SearchSourceBuilder builder ; if ( RestActions . hasBodyContent ( request ) ) { BytesReference restContent = RestActions . getRestContent ( request ) ; QueryParseContext context = new QueryParseContext ( indicesQueriesRegistry ) ; if ( isTemplateRequest ) { try ( XContentParser parser = XContentFactory . xContent ( restContent ) . createParser ( restContent ) ) { context . reset ( parser ) ; context . parseFieldMatcher ( parseFieldMatcher ) ; Template template = TemplateQueryParser . parse ( parser , context . parseFieldMatcher ( ) , <str> , <str> ) ; searchRequest . template ( template ) ; } builder = null ; } else { builder = RestActions . getRestSearchSource ( restContent , indicesQueriesRegistry , parseFieldMatcher ) ; } } else { builder = null ; } String searchType = request . param ( <str> ) ; if ( SearchType . fromString ( searchType , parseFieldMatcher ) . equals ( SearchType . QUERY_AND_FETCH ) | | SearchType . fromString ( searchType , parseFieldMatcher ) . equals ( SearchType . DFS_QUERY_AND_FETCH ) ) { throw new IllegalArgumentException ( <str> + searchType + <str> ) ; } else { searchRequest . searchType ( searchType ) ; } if ( builder = = null ) { SearchSourceBuilder extraBuilder = new SearchSourceBuilder ( ) ; if ( parseSearchSource ( extraBuilder , request ) ) { searchRequest . source ( extraBuilder ) ; } } else { parseSearchSource ( builder , request ) ; searchRequest . source ( builder ) ; } searchRequest . requestCache ( request . paramAsBoolean ( <str> , null ) ) ; String scroll = request . param ( <str> ) ; if ( scroll ! = null ) { searchRequest . scroll ( new Scroll ( parseTimeValue ( scroll , null , <str> ) ) ) ; } searchRequest . types ( Strings . splitStringByCommaToArray ( request . param ( <str> ) ) ) ; searchRequest . routing ( request . param ( <str> ) ) ; searchRequest . preference ( request . param ( <str> ) ) ; searchRequest . indicesOptions ( IndicesOptions . fromRequest ( request , searchRequest . indicesOptions ( ) ) ) ; return searchRequest ; } private static boolean parseSearchSource ( final SearchSourceBuilder searchSourceBuilder , RestRequest request ) { boolean modified = false ; QueryBuilder < ? > queryBuilder = RestActions . urlParamsToQueryBuilder ( request ) ; if ( queryBuilder ! = null ) { searchSourceBuilder . query ( queryBuilder ) ; modified = true ; } int from = request . paramAsInt ( <str> , - <int> ) ; if ( from ! = - <int> ) { searchSourceBuilder . from ( from ) ; modified = true ; } int size = request . paramAsInt ( <str> , - <int> ) ; if ( size ! = - <int> ) { searchSourceBuilder . size ( size ) ; modified = true ; } if ( request . hasParam ( <str> ) ) { searchSourceBuilder . explain ( request . paramAsBoolean ( <str> , null ) ) ; modified = true ; } if ( request . hasParam ( <str> ) ) { searchSourceBuilder . version ( request . paramAsBoolean ( <str> , null ) ) ; modified = true ; } if ( request . hasParam ( <str> ) ) { searchSourceBuilder . timeout ( request . paramAsTime ( <str> , null ) ) ; modified = true ; } if ( request . hasParam ( <str> ) ) { int terminateAfter = request . paramAsInt ( <str> , SearchContext . DEFAULT_TERMINATE_AFTER ) ; if ( terminateAfter < <int> ) { throw new IllegalArgumentException ( <str> ) ; } else if ( terminateAfter > <int> ) { searchSourceBuilder . terminateAfter ( terminateAfter ) ; modified = true ; } } String sField = request . param ( <str> ) ; if ( sField ! = null ) { if ( ! Strings . hasText ( sField ) ) { searchSourceBuilder . noFields ( ) ; modified = true ; } else { String [ ] sFields = Strings . splitStringByCommaToArray ( sField ) ; if ( sFields ! = null ) { for ( String field : sFields ) { searchSourceBuilder . field ( field ) ; modified = true ; } } } } String sFieldDataFields = request . param ( <str> ) ; if ( sFieldDataFields ! = null ) { if ( Strings . hasText ( sFieldDataFields ) ) { String [ ] sFields = Strings . splitStringByCommaToArray ( sFieldDataFields ) ; if ( sFields ! = null ) { for ( String field : sFields ) { searchSourceBuilder . fieldDataField ( field ) ; modified = true ; } } } } FetchSourceContext fetchSourceContext = FetchSourceContext . parseFromRestRequest ( request ) ; if ( fetchSourceContext ! = null ) { searchSourceBuilder . fetchSource ( fetchSourceContext ) ; modified = true ; } if ( request . hasParam ( <str> ) ) { searchSourceBuilder . trackScores ( request . paramAsBoolean ( <str> , false ) ) ; modified = true ; } String sSorts = request . param ( <str> ) ; if ( sSorts ! = null ) { String [ ] sorts = Strings . splitStringByCommaToArray ( sSorts ) ; for ( String sort : sorts ) { int delimiter = sort . lastIndexOf ( <str> ) ; if ( delimiter ! = - <int> ) { String sortField = sort . substring ( <int> , delimiter ) ; String reverse = sort . substring ( delimiter + <int> ) ; if ( <str> . equals ( reverse ) ) { searchSourceBuilder . sort ( sortField , SortOrder . ASC ) ; modified = true ; } else if ( <str> . equals ( reverse ) ) { searchSourceBuilder . sort ( sortField , SortOrder . DESC ) ; modified = true ; } } else { searchSourceBuilder . sort ( sort ) ; modified = true ; } } } String sStats = request . param ( <str> ) ; if ( sStats ! = null ) { searchSourceBuilder . stats ( Arrays . asList ( Strings . splitStringByCommaToArray ( sStats ) ) ) ; modified = true ; } String suggestField = request . param ( <str> ) ; if ( suggestField ! = null ) { String suggestText = request . param ( <str> , request . param ( <str> ) ) ; int suggestSize = request . paramAsInt ( <str> , <int> ) ; String suggestMode = request . param ( <str> ) ; searchSourceBuilder . suggest ( new SuggestBuilder ( ) . addSuggestion ( termSuggestion ( suggestField ) . field ( suggestField ) . text ( suggestText ) . size ( suggestSize ) . suggestMode ( suggestMode ) ) ) ; modified = true ; } return modified ; } } 
