package org . elasticsearch . action . support . master ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . discovery . DiscoverySettings ; import org . elasticsearch . discovery . zen . elect . ElectMasterService ; import org . elasticsearch . discovery . zen . fd . FaultDetection ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . disruption . NetworkDisconnectPartition ; import org . elasticsearch . test . disruption . NetworkPartition ; import org . elasticsearch . test . transport . MockTransportService ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . BrokenBarrierException ; import java . util . concurrent . CyclicBarrier ; import static org . hamcrest . Matchers . equalTo ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST , numDataNodes = <int> ) @ESIntegTestCase.SuppressLocalMode public class IndexingMasterFailoverIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { final HashSet < Class < ? extends Plugin > > classes = new HashSet < > ( super . nodePlugins ( ) ) ; classes . add ( MockTransportService . TestPlugin . class ) ; return classes ; } public void testMasterFailoverDuringIndexingWithMappingChanges ( ) throws Throwable { logger . info ( <str> ) ; final Settings sharedSettings = Settings . builder ( ) . put ( FaultDetection . SETTING_PING_TIMEOUT , <str> ) . put ( FaultDetection . SETTING_PING_RETRIES , <str> ) . put ( <str> , <str> ) . put ( DiscoverySettings . PUBLISH_TIMEOUT , <str> ) . put ( ElectMasterService . DISCOVERY_ZEN_MINIMUM_MASTER_NODES , <int> ) . build ( ) ; internalCluster ( ) . startMasterOnlyNodesAsync ( <int> , sharedSettings ) . get ( ) ; String dataNode = internalCluster ( ) . startDataOnlyNode ( sharedSettings ) ; logger . info ( <str> ) ; ensureStableCluster ( <int> ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( Settings . builder ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ) . get ( ) ; ensureGreen ( <str> ) ; final CyclicBarrier barrier = new CyclicBarrier ( <int> ) ; Thread indexingThread = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { barrier . await ( ) ; } catch ( InterruptedException e ) { logger . warn ( <str> , e ) ; return ; } catch ( BrokenBarrierException e ) { logger . warn ( <str> , e ) ; return ; } for ( int i = <int> ; i < <int> ; i + + ) { IndexResponse response = client ( dataNode ) . prepareIndex ( <str> , <str> ) . setSource ( <str> + i , <str> ) . get ( ) ; assertThat ( response . isCreated ( ) , equalTo ( true ) ) ; } } } ) ; indexingThread . setName ( <str> ) ; indexingThread . start ( ) ; barrier . await ( ) ; String master = internalCluster ( ) . getMasterName ( ) ; Set < String > otherNodes = new HashSet < > ( Arrays . asList ( internalCluster ( ) . getNodeNames ( ) ) ) ; otherNodes . remove ( master ) ; NetworkPartition partition = new NetworkDisconnectPartition ( Collections . singleton ( master ) , otherNodes , random ( ) ) ; internalCluster ( ) . setDisruptionScheme ( partition ) ; logger . info ( <str> ) ; partition . startDisrupting ( ) ; logger . info ( <str> ) ; ensureStableCluster ( <int> , dataNode ) ; partition . stopDisrupting ( ) ; logger . info ( <str> ) ; ensureStableCluster ( <int> ) ; indexingThread . join ( ) ; ensureGreen ( <str> ) ; refresh ( ) ; assertThat ( client ( ) . prepareSearch ( <str> ) . get ( ) . getHits ( ) . getTotalHits ( ) , equalTo ( <int> ) ) ; } } 
