package com . google . common . collect ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import com . google . common . annotations . GwtCompatible ; import junit . framework . TestCase ; import java . util . AbstractCollection ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . RandomAccess ; import java . util . Set ; import java . util . SortedSet ; @GwtCompatible public class ConstraintsTest extends TestCase { private static final String TEST_ELEMENT = <str> ; private static final class TestElementException extends IllegalArgumentException { private static final long serialVersionUID = <int> ; } private static final Constraint < String > TEST_CONSTRAINT = new Constraint < String > ( ) { @Override public String checkElement ( String element ) { if ( TEST_ELEMENT . equals ( element ) ) { throw new TestElementException ( ) ; } return element ; } } ; public void testConstrainedCollectionLegal ( ) { Collection < String > collection = Lists . newArrayList ( <str> , <str> ) ; Collection < String > constrained = Constraints . constrainedCollection ( collection , TEST_CONSTRAINT ) ; collection . add ( TEST_ELEMENT ) ; constrained . add ( <str> ) ; constrained . addAll ( asList ( <str> , <str> ) ) ; assertThat ( collection ) . containsExactly ( <str> , <str> , TEST_ELEMENT , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( constrained ) . containsExactly ( <str> , <str> , TEST_ELEMENT , <str> , <str> , <str> ) . inOrder ( ) ; } public void testConstrainedCollectionIllegal ( ) { Collection < String > collection = Lists . newArrayList ( <str> , <str> ) ; Collection < String > constrained = Constraints . constrainedCollection ( collection , TEST_CONSTRAINT ) ; try { constrained . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . addAll ( asList ( <str> , TEST_ELEMENT ) ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } assertThat ( constrained ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( collection ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testConstrainedSetLegal ( ) { Set < String > set = Sets . newLinkedHashSet ( asList ( <str> , <str> ) ) ; Set < String > constrained = Constraints . constrainedSet ( set , TEST_CONSTRAINT ) ; set . add ( TEST_ELEMENT ) ; constrained . add ( <str> ) ; constrained . addAll ( asList ( <str> , <str> ) ) ; assertTrue ( set . equals ( constrained ) ) ; assertTrue ( constrained . equals ( set ) ) ; assertEquals ( set . toString ( ) , constrained . toString ( ) ) ; assertEquals ( set . hashCode ( ) , constrained . hashCode ( ) ) ; assertThat ( set ) . containsExactly ( <str> , <str> , TEST_ELEMENT , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( constrained ) . containsExactly ( <str> , <str> , TEST_ELEMENT , <str> , <str> , <str> ) . inOrder ( ) ; } public void testConstrainedSetIllegal ( ) { Set < String > set = Sets . newLinkedHashSet ( asList ( <str> , <str> ) ) ; Set < String > constrained = Constraints . constrainedSet ( set , TEST_CONSTRAINT ) ; try { constrained . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . addAll ( asList ( <str> , TEST_ELEMENT ) ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } assertThat ( constrained ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( set ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testConstrainedSortedSetLegal ( ) { SortedSet < String > sortedSet = Sets . newTreeSet ( asList ( <str> , <str> ) ) ; SortedSet < String > constrained = Constraints . constrainedSortedSet ( sortedSet , TEST_CONSTRAINT ) ; sortedSet . add ( TEST_ELEMENT ) ; constrained . add ( <str> ) ; constrained . addAll ( asList ( <str> , <str> ) ) ; assertTrue ( sortedSet . equals ( constrained ) ) ; assertTrue ( constrained . equals ( sortedSet ) ) ; assertEquals ( sortedSet . toString ( ) , constrained . toString ( ) ) ; assertEquals ( sortedSet . hashCode ( ) , constrained . hashCode ( ) ) ; assertThat ( sortedSet ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , TEST_ELEMENT ) . inOrder ( ) ; assertThat ( constrained ) . containsExactly ( <str> , <str> , <str> , <str> , <str> , TEST_ELEMENT ) . inOrder ( ) ; assertNull ( constrained . comparator ( ) ) ; assertEquals ( <str> , constrained . first ( ) ) ; assertEquals ( TEST_ELEMENT , constrained . last ( ) ) ; } public void testConstrainedSortedSetIllegal ( ) { SortedSet < String > sortedSet = Sets . newTreeSet ( asList ( <str> , <str> ) ) ; SortedSet < String > constrained = Constraints . constrainedSortedSet ( sortedSet , TEST_CONSTRAINT ) ; try { constrained . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . subSet ( <str> , <str> ) . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . headSet ( <str> ) . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . tailSet ( <str> ) . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . addAll ( asList ( <str> , TEST_ELEMENT ) ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } assertThat ( constrained ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( sortedSet ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testConstrainedListLegal ( ) { List < String > list = Lists . newArrayList ( <str> , <str> ) ; List < String > constrained = Constraints . constrainedList ( list , TEST_CONSTRAINT ) ; list . add ( TEST_ELEMENT ) ; constrained . add ( <str> ) ; constrained . addAll ( asList ( <str> , <str> ) ) ; constrained . add ( <int> , <str> ) ; constrained . addAll ( <int> , asList ( <str> , <str> ) ) ; constrained . set ( <int> , <str> ) ; assertTrue ( list . equals ( constrained ) ) ; assertTrue ( constrained . equals ( list ) ) ; assertEquals ( list . toString ( ) , constrained . toString ( ) ) ; assertEquals ( list . hashCode ( ) , constrained . hashCode ( ) ) ; assertThat ( list ) . containsExactly ( <str> , <str> , <str> , TEST_ELEMENT , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( constrained ) . containsExactly ( <str> , <str> , <str> , TEST_ELEMENT , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; ListIterator < String > iterator = constrained . listIterator ( ) ; iterator . next ( ) ; iterator . set ( <str> ) ; constrained . listIterator ( <int> ) . add ( <str> ) ; assertThat ( list ) . containsExactly ( <str> , <str> , <str> , <str> , TEST_ELEMENT , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( constrained ) . containsExactly ( <str> , <str> , <str> , <str> , TEST_ELEMENT , <str> , <str> , <str> , <str> , <str> ) . inOrder ( ) ; assertTrue ( constrained instanceof RandomAccess ) ; } public void testConstrainedListRandomAccessFalse ( ) { List < String > list = Lists . newLinkedList ( asList ( <str> , <str> ) ) ; List < String > constrained = Constraints . constrainedList ( list , TEST_CONSTRAINT ) ; list . add ( TEST_ELEMENT ) ; constrained . add ( <str> ) ; assertThat ( constrained ) . isNotInstanceOf ( RandomAccess . class ) ; } public void testConstrainedListIllegal ( ) { List < String > list = Lists . newArrayList ( <str> , <str> ) ; List < String > constrained = Constraints . constrainedList ( list , TEST_CONSTRAINT ) ; try { constrained . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . listIterator ( ) . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . listIterator ( <int> ) . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . listIterator ( ) . set ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . listIterator ( <int> ) . set ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . subList ( <int> , <int> ) . add ( TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . add ( <int> , TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . set ( <int> , TEST_ELEMENT ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . addAll ( asList ( <str> , TEST_ELEMENT ) ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } try { constrained . addAll ( <int> , asList ( <str> , TEST_ELEMENT ) ) ; fail ( <str> ) ; } catch ( TestElementException expected ) { } assertThat ( constrained ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertThat ( list ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; } public void testNefariousAddAll ( ) { List < String > list = Lists . newArrayList ( <str> , <str> ) ; List < String > constrained = Constraints . constrainedList ( list , TEST_CONSTRAINT ) ; Collection < String > onceIterable = onceIterableCollection ( <str> ) ; constrained . addAll ( onceIterable ) ; assertThat ( constrained ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertThat ( list ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; } static < E > Collection < E > onceIterableCollection ( final E element ) { return new AbstractCollection < E > ( ) { boolean iteratorCalled ; @Override public int size ( ) { return <int> ; } @Override public Iterator < E > iterator ( ) { assertFalse ( <str> , iteratorCalled ) ; iteratorCalled = true ; return Collections . singleton ( element ) . iterator ( ) ; } } ; } } 
