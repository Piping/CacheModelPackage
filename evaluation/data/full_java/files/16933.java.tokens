package java . nio ; import com . google . gwt . corp . compatibility . Endianness ; import com . google . gwt . corp . compatibility . Numbers ; import com . google . gwt . typedarrays . client . ArrayBufferNative ; import com . google . gwt . typedarrays . client . Int8ArrayNative ; import com . google . gwt . typedarrays . shared . ArrayBuffer ; import com . google . gwt . typedarrays . shared . ArrayBufferView ; import com . google . gwt . typedarrays . shared . Int8Array ; abstract class DirectByteBuffer extends BaseByteBuffer implements HasArrayBufferView { Int8Array byteArray ; DirectByteBuffer ( int capacity ) { this ( ArrayBufferNative . create ( capacity ) , capacity , <int> ) ; } DirectByteBuffer ( ArrayBuffer buf ) { this ( buf , buf . byteLength ( ) , <int> ) ; } DirectByteBuffer ( ArrayBuffer buffer , int capacity , int offset ) { super ( capacity ) ; byteArray = Int8ArrayNative . create ( buffer , offset , capacity ) ; } public ArrayBufferView getTypedArray ( ) { return byteArray ; } public int getElementSize ( ) { return <int> ; } public final ByteBuffer get ( byte [ ] dest , int off , int len ) { int length = dest . length ; if ( off < <int> | | len < <int> | | ( long ) off + ( long ) len > length ) { throw new IndexOutOfBoundsException ( ) ; } if ( len > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } for ( int i = <int> ; i < len ; i + + ) { dest [ i + off ] = get ( position + i ) ; } position + = len ; return this ; } public final byte get ( ) { return ( byte ) byteArray . get ( position + + ) ; } public final byte get ( int index ) { return ( byte ) byteArray . get ( index ) ; } public final double getDouble ( ) { return Numbers . longBitsToDouble ( getLong ( ) ) ; } public final double getDouble ( int index ) { return Numbers . longBitsToDouble ( getLong ( index ) ) ; } public final float getFloat ( ) { return Numbers . intBitsToFloat ( getInt ( ) ) ; } public final float getFloat ( int index ) { return Numbers . intBitsToFloat ( getInt ( index ) ) ; } public final int getInt ( ) { int newPosition = position + <int> ; int result = loadInt ( position ) ; position = newPosition ; return result ; } public final int getInt ( int index ) { return loadInt ( index ) ; } public final long getLong ( ) { int newPosition = position + <int> ; long result = loadLong ( position ) ; position = newPosition ; return result ; } public final long getLong ( int index ) { return loadLong ( index ) ; } public final short getShort ( ) { int newPosition = position + <int> ; short result = loadShort ( position ) ; position = newPosition ; return result ; } public final short getShort ( int index ) { return loadShort ( index ) ; } public final boolean isDirect ( ) { return false ; } protected final int loadInt ( int baseOffset ) { int bytes = <int> ; if ( order = = Endianness . BIG_ENDIAN ) { for ( int i = <int> ; i < <int> ; i + + ) { bytes = bytes < < <int> ; bytes = bytes | ( byteArray . get ( baseOffset + i ) & <hex> ) ; } } else { for ( int i = <int> ; i > = <int> ; i - - ) { bytes = bytes < < <int> ; bytes = bytes | ( byteArray . get ( baseOffset + i ) & <hex> ) ; } } return bytes ; } protected final long loadLong ( int baseOffset ) { long bytes = <int> ; if ( order = = Endianness . BIG_ENDIAN ) { for ( int i = <int> ; i < <int> ; i + + ) { bytes = bytes < < <int> ; bytes = bytes | ( byteArray . get ( baseOffset + i ) & <hex> ) ; } } else { for ( int i = <int> ; i > = <int> ; i - - ) { bytes = bytes < < <int> ; bytes = bytes | ( byteArray . get ( baseOffset + i ) & <hex> ) ; } } return bytes ; } protected final short loadShort ( int baseOffset ) { short bytes = <int> ; if ( order = = Endianness . BIG_ENDIAN ) { bytes = ( short ) ( byteArray . get ( baseOffset ) < < <int> ) ; bytes | = ( byteArray . get ( baseOffset + <int> ) & <hex> ) ; } else { bytes = ( short ) ( byteArray . get ( baseOffset + <int> ) < < <int> ) ; bytes | = ( byteArray . get ( baseOffset ) & <hex> ) ; } return bytes ; } protected final void store ( int baseOffset , int value ) { if ( order = = Endianness . BIG_ENDIAN ) { for ( int i = <int> ; i > = <int> ; i - - ) { byteArray . set ( baseOffset + i , ( byte ) ( value & <hex> ) ) ; value = value > > <int> ; } } else { for ( int i = <int> ; i < = <int> ; i + + ) { byteArray . set ( baseOffset + i , ( byte ) ( value & <hex> ) ) ; value = value > > <int> ; } } } protected final void store ( int baseOffset , long value ) { if ( order = = Endianness . BIG_ENDIAN ) { for ( int i = <int> ; i > = <int> ; i - - ) { byteArray . set ( baseOffset + i , ( byte ) ( value & <hex> ) ) ; value = value > > <int> ; } } else { for ( int i = <int> ; i < = <int> ; i + + ) { byteArray . set ( baseOffset + i , ( byte ) ( value & <hex> ) ) ; value = value > > <int> ; } } } protected final void store ( int baseOffset , short value ) { if ( order = = Endianness . BIG_ENDIAN ) { byteArray . set ( baseOffset , ( byte ) ( ( value > > <int> ) & <hex> ) ) ; byteArray . set ( baseOffset + <int> , ( byte ) ( value & <hex> ) ) ; } else { byteArray . set ( baseOffset + <int> , ( byte ) ( ( value > > <int> ) & <hex> ) ) ; byteArray . set ( baseOffset , ( byte ) ( value & <hex> ) ) ; } } } 
