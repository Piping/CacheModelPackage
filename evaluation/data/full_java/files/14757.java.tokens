package org . gradle . platform . base . internal . registry ; import org . gradle . model . ModelMap ; import org . gradle . model . internal . core . ModelReference ; import org . gradle . model . internal . inspect . AbstractAnnotationDrivenModelRuleExtractor ; import org . gradle . model . internal . inspect . MethodRuleDefinition ; import org . gradle . model . internal . type . ModelType ; import org . gradle . platform . base . InvalidModelException ; import java . lang . annotation . Annotation ; import java . security . InvalidParameterException ; import java . util . HashMap ; import java . util . List ; public abstract class AbstractAnnotationDrivenComponentModelRuleExtractor < T extends Annotation > extends AbstractAnnotationDrivenModelRuleExtractor < T > { protected void assertIsVoidMethod ( MethodRuleDefinition < ? , ? > ruleDefinition ) { if ( ! ModelType . of ( Void . TYPE ) . equals ( ruleDefinition . getReturnType ( ) ) ) { throw new InvalidModelException ( String . format ( <str> , getDescription ( ) ) ) ; } } protected < V > void visitSubject ( RuleMethodDataCollector dataCollector , MethodRuleDefinition < ? , ? > ruleDefinition , Class < V > typeParameter ) { if ( ruleDefinition . getReferences ( ) . size ( ) = = <int> ) { throw new InvalidModelException ( String . format ( <str> , getDescription ( ) , ModelMap . class . getName ( ) ) ) ; } @SuppressWarnings ( <str> ) ModelType < ? > builder = ruleDefinition . getSubjectReference ( ) . getType ( ) ; @SuppressWarnings ( <str> ) Class < ? > containerClass = org . gradle . model . collection . CollectionBuilder . class ; if ( ! ModelType . of ( containerClass ) . isAssignableFrom ( builder ) ) { throw new InvalidModelException ( String . format ( <str> , getDescription ( ) , ModelMap . class . getName ( ) ) ) ; } if ( builder . getTypeVariables ( ) . size ( ) ! = <int> ) { throw new InvalidModelException ( String . format ( <str> , ModelMap . class . getSimpleName ( ) , typeParameter . getSimpleName ( ) ) ) ; } ModelType < ? > subType = builder . getTypeVariables ( ) . get ( <int> ) ; if ( subType . isWildcard ( ) ) { throw new InvalidModelException ( String . format ( <str> , typeParameter . getName ( ) , subType . toString ( ) ) ) ; } dataCollector . parameterTypes . put ( typeParameter , subType . getConcreteClass ( ) ) ; } protected class RuleMethodDataCollector { private HashMap < Class < ? > , Class < ? > > parameterTypes = new HashMap < Class < ? > , Class < ? > > ( ) ; @SuppressWarnings ( <str> ) public < S , R extends S > Class < R > getParameterType ( Class < S > baseClass ) { return ( Class < R > ) parameterTypes . get ( baseClass ) ; } public < S > void put ( Class < S > baseClass , Class < ? extends S > concreteClass ) { if ( ! baseClass . isAssignableFrom ( concreteClass ) ) { throw new InvalidParameterException ( String . format ( <str> , baseClass . getName ( ) , concreteClass . getName ( ) ) ) ; } parameterTypes . put ( baseClass , concreteClass ) ; } } protected < S > void visitDependency ( RuleMethodDataCollector dataCollector , MethodRuleDefinition < ? , ? > ruleDefinition , ModelType < S > expectedDependency ) { List < ModelReference < ? > > references = ruleDefinition . getReferences ( ) ; ModelType < ? extends S > dependency = null ; for ( ModelReference < ? > reference : references ) { if ( expectedDependency . isAssignableFrom ( reference . getType ( ) ) ) { if ( dependency ! = null ) { throw new InvalidModelException ( String . format ( <str> , getDescription ( ) , expectedDependency . getConcreteClass ( ) . getSimpleName ( ) , expectedDependency . getConcreteClass ( ) . getSimpleName ( ) ) ) ; } dependency = reference . getType ( ) . asSubtype ( expectedDependency ) ; } } if ( dependency = = null ) { throw new InvalidModelException ( String . format ( <str> , getDescription ( ) , expectedDependency . getConcreteClass ( ) . getSimpleName ( ) , expectedDependency . getConcreteClass ( ) . getSimpleName ( ) ) ) ; } dataCollector . put ( expectedDependency . getConcreteClass ( ) , dependency . getConcreteClass ( ) ) ; } } 
