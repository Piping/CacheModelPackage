package org . gradle . internal . service ; import org . gradle . api . Action ; import org . gradle . api . Nullable ; import org . gradle . api . specs . Spec ; import org . gradle . internal . Factory ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . Stoppable ; import org . gradle . internal . reflect . JavaReflectionUtil ; import org . gradle . internal . util . BiFunction ; import java . io . Closeable ; import java . lang . reflect . * ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; public class DefaultServiceRegistry implements ServiceRegistry , Closeable { private static final ConcurrentMap < Class < ? > , RelevantMethods > METHODS_CACHE = new ConcurrentHashMap < Class < ? > , RelevantMethods > ( ) ; private static final ConcurrentMap < Type , BiFunction < ServiceProvider , LookupContext , Provider > > SERVICE_TYPE_PROVIDER_CACHE = new ConcurrentHashMap < Type , BiFunction < ServiceProvider , LookupContext , Provider > > ( ) ; private final Map < Type , ServiceProvider > providerCache = new HashMap < Type , ServiceProvider > ( ) ; private final Object lock = new Object ( ) ; private final CompositeProvider allServices = new CompositeProvider ( ) ; private final OwnServices ownServices ; private final CompositeProvider parentServices ; private final String displayName ; private boolean closed ; private boolean mutable = true ; public DefaultServiceRegistry ( ) { this ( null , Collections . < ServiceRegistry > emptyList ( ) ) ; } public DefaultServiceRegistry ( String displayName ) { this ( displayName , Collections . < ServiceRegistry > emptyList ( ) ) ; } public DefaultServiceRegistry ( ServiceRegistry . . . parents ) { this ( null , parents ) ; } public DefaultServiceRegistry ( String displayName , ServiceRegistry . . . parents ) { this ( displayName , Arrays . asList ( parents ) ) ; } public DefaultServiceRegistry ( String displayName , Collection < ? extends ServiceRegistry > parents ) { this . displayName = displayName ! = null ? displayName : getClass ( ) . getSimpleName ( ) . intern ( ) ; this . parentServices = parents . isEmpty ( ) ? null : new CompositeProvider ( ) ; this . ownServices = new OwnServices ( ) ; allServices . providers . add ( ownServices ) ; if ( parentServices ! = null ) { allServices . providers . add ( parentServices ) ; for ( ServiceRegistry parent : parents ) { parentServices . providers . add ( new ParentServices ( parent ) ) ; } } findProviderMethods ( this ) ; } public static ServiceRegistry create ( Object . . . providers ) { DefaultServiceRegistry registry = new DefaultServiceRegistry ( ) ; for ( Object provider : providers ) { registry . addProvider ( provider ) ; } return registry ; } @Override public String toString ( ) { return displayName ; } static class RelevantMethods { final List < Method > decorators ; final List < Method > factories ; final List < Method > configurers ; public RelevantMethods ( List < Method > decorators , List < Method > factories , List < Method > configurers ) { this . decorators = decorators ; this . factories = factories ; this . configurers = configurers ; } } static class RelevantMethodsBuilder { final List < Method > remainingMethods ; final Class < ? > type ; final LinkedList < Method > decorators = new LinkedList < Method > ( ) ; final LinkedList < Method > factories = new LinkedList < Method > ( ) ; final LinkedList < Method > configurers = new LinkedList < Method > ( ) ; final Set < String > seen = new HashSet < String > ( ) ; public RelevantMethodsBuilder ( Class < ? > type ) { this . type = type ; this . remainingMethods = new LinkedList < Method > ( ) ; for ( Class < ? > clazz = type ; clazz ! = Object . class & & clazz ! = DefaultServiceRegistry . class ; clazz = clazz . getSuperclass ( ) ) { remainingMethods . addAll ( Arrays . asList ( clazz . getDeclaredMethods ( ) ) ) ; } } void add ( Iterator < Method > iterator , List < Method > builder , Method method ) { if ( seen . add ( method . getName ( ) ) ) { builder . add ( method ) ; } iterator . remove ( ) ; } RelevantMethods build ( ) { return new RelevantMethods ( decorators , factories , configurers ) ; } } private void findProviderMethods ( Object target ) { Class < ? > type = target . getClass ( ) ; RelevantMethods methods = getMethods ( type ) ; for ( Method method : methods . decorators ) { if ( parentServices = = null ) { throw new ServiceLookupException ( String . format ( <str> , type . getSimpleName ( ) , method . getName ( ) ) ) ; } ownServices . add ( new DecoratorMethodService ( target , method ) ) ; } for ( Method method : methods . factories ) { ownServices . add ( new FactoryMethodService ( target , method ) ) ; } for ( Method method : methods . configurers ) { applyConfigureMethod ( method , target ) ; } } private RelevantMethods getMethods ( Class < ? > type ) { RelevantMethods relevantMethods = METHODS_CACHE . get ( type ) ; if ( relevantMethods = = null ) { relevantMethods = buildRelevantMethods ( type ) ; METHODS_CACHE . putIfAbsent ( type , relevantMethods ) ; } return relevantMethods ; } private RelevantMethods buildRelevantMethods ( Class < ? > type ) { RelevantMethods relevantMethods ; RelevantMethodsBuilder builder = new RelevantMethodsBuilder ( type ) ; addDecoratorMethods ( builder ) ; addFactoryMethods ( builder ) ; addConfigureMethods ( builder ) ; relevantMethods = builder . build ( ) ; return relevantMethods ; } private void applyConfigureMethod ( Method method , Object target ) { Object [ ] params = new Object [ method . getGenericParameterTypes ( ) . length ] ; DefaultLookupContext context = new DefaultLookupContext ( ) ; for ( int i = <int> ; i < method . getGenericParameterTypes ( ) . length ; i + + ) { Type paramType = method . getGenericParameterTypes ( ) [ i ] ; if ( paramType . equals ( ServiceRegistration . class ) ) { params [ i ] = newRegistration ( ) ; } else { ServiceProvider paramProvider = context . find ( paramType , allServices ) ; if ( paramProvider = = null ) { throw new ServiceLookupException ( String . format ( <str> , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) , format ( paramType ) ) ) ; } params [ i ] = paramProvider . get ( ) ; } } try { invoke ( method , target , params ) ; } catch ( Exception e ) { throw new ServiceLookupException ( String . format ( <str> , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) ) , e ) ; } } private static void addConfigureMethods ( RelevantMethodsBuilder builder ) { Class < ? > type = builder . type ; Iterator < Method > iterator = builder . remainingMethods . iterator ( ) ; while ( iterator . hasNext ( ) ) { Method method = iterator . next ( ) ; if ( method . getName ( ) . equals ( <str> ) ) { if ( ! method . getReturnType ( ) . equals ( Void . TYPE ) ) { throw new ServiceLookupException ( String . format ( <str> , type . getSimpleName ( ) , method . getName ( ) ) ) ; } builder . add ( iterator , builder . configurers , method ) ; } } } private static void addFactoryMethods ( RelevantMethodsBuilder builder ) { Class < ? > type = builder . type ; Iterator < Method > iterator = builder . remainingMethods . iterator ( ) ; while ( iterator . hasNext ( ) ) { Method method = iterator . next ( ) ; if ( method . getName ( ) . startsWith ( <str> ) & & ! Modifier . isStatic ( method . getModifiers ( ) ) ) { if ( method . getReturnType ( ) . equals ( Void . TYPE ) ) { throw new ServiceLookupException ( String . format ( <str> , type . getSimpleName ( ) , method . getName ( ) ) ) ; } builder . add ( iterator , builder . factories , method ) ; } } } private static void addDecoratorMethods ( RelevantMethodsBuilder builder ) { Class < ? > type = builder . type ; Iterator < Method > iterator = builder . remainingMethods . iterator ( ) ; while ( iterator . hasNext ( ) ) { Method method = iterator . next ( ) ; if ( method . getName ( ) . startsWith ( <str> ) & & method . getParameterTypes ( ) . length = = <int> & & method . getParameterTypes ( ) [ <int> ] . equals ( method . getReturnType ( ) ) ) { if ( method . getReturnType ( ) . equals ( Void . TYPE ) ) { throw new ServiceLookupException ( String . format ( <str> , type . getSimpleName ( ) , method . getName ( ) ) ) ; } builder . add ( iterator , builder . decorators , method ) ; } } } public void register ( Action < ? super ServiceRegistration > action ) { assertMutable ( ) ; action . execute ( newRegistration ( ) ) ; } private void assertMutable ( ) { if ( ! mutable ) { throw new IllegalStateException ( <str> + this + <str> ) ; } } private ServiceRegistration newRegistration ( ) { return new ServiceRegistration ( ) { public < T > void add ( Class < T > serviceType , T serviceInstance ) { DefaultServiceRegistry . this . add ( serviceType , serviceInstance ) ; } public void add ( Class < ? > serviceType ) { ownServices . add ( new ConstructorService ( serviceType ) ) ; } public void addProvider ( Object provider ) { DefaultServiceRegistry . this . addProvider ( provider ) ; } } ; } public < T > DefaultServiceRegistry add ( Class < T > serviceType , final T serviceInstance ) { assertMutable ( ) ; ownServices . add ( new FixedInstanceService < T > ( serviceType , serviceInstance ) ) ; return this ; } public DefaultServiceRegistry addProvider ( Object provider ) { assertMutable ( ) ; findProviderMethods ( provider ) ; return this ; } public void close ( ) { synchronized ( lock ) { try { CompositeStoppable . stoppable ( allServices ) . stop ( ) ; } finally { closed = true ; } } } public boolean isClosed ( ) { return closed ; } private static String format ( Type type ) { if ( type instanceof Class ) { Class < ? > aClass = ( Class ) type ; return aClass . getSimpleName ( ) ; } else if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( format ( parameterizedType . getRawType ( ) ) ) ; builder . append ( <str> ) ; for ( int i = <int> ; i < parameterizedType . getActualTypeArguments ( ) . length ; i + + ) { Type typeParam = parameterizedType . getActualTypeArguments ( ) [ i ] ; if ( i > <int> ) { builder . append ( <str> ) ; } builder . append ( format ( typeParam ) ) ; } builder . append ( <str> ) ; return builder . toString ( ) ; } return type . toString ( ) ; } public < T > List < T > getAll ( Class < T > serviceType ) throws ServiceLookupException { synchronized ( lock ) { mutable = false ; if ( closed ) { throw new IllegalStateException ( String . format ( <str> , format ( serviceType ) , displayName ) ) ; } List < T > result = new ArrayList < T > ( ) ; DefaultLookupContext context = new DefaultLookupContext ( ) ; allServices . getAll ( context , serviceType , result ) ; return result ; } } public < T > T get ( Class < T > serviceType ) throws UnknownServiceException , ServiceLookupException { return serviceType . cast ( doGet ( serviceType ) ) ; } public Object get ( Type serviceType ) throws UnknownServiceException , ServiceLookupException { return doGet ( serviceType ) ; } private Object doGet ( Type serviceType ) throws IllegalArgumentException { synchronized ( lock ) { mutable = false ; if ( closed ) { throw new IllegalStateException ( String . format ( <str> , format ( serviceType ) , displayName ) ) ; } ServiceProvider provider = providerCache . get ( serviceType ) ; if ( provider = = null ) { provider = getServiceProvider ( serviceType ) ; providerCache . put ( serviceType , provider ) ; } return provider . get ( ) ; } } private ServiceProvider getServiceProvider ( Type serviceType ) { ServiceProvider provider = new DefaultLookupContext ( ) . find ( serviceType , allServices ) ; if ( provider = = null ) { throw new UnknownServiceException ( serviceType , String . format ( <str> , format ( serviceType ) , displayName ) ) ; } return provider ; } public < T > Factory < T > getFactory ( Class < T > type ) { synchronized ( lock ) { if ( closed ) { throw new IllegalStateException ( String . format ( <str> , format ( type ) , displayName ) ) ; } DefaultLookupContext context = new DefaultLookupContext ( ) ; ServiceProvider factory = allServices . getFactory ( context , type ) ; if ( factory ! = null ) { return ( Factory < T > ) factory . get ( ) ; } throw new UnknownServiceException ( type , String . format ( <str> , format ( type ) , displayName ) ) ; } } public < T > T newInstance ( Class < T > type ) { return getFactory ( type ) . create ( ) ; } private static Object invoke ( Method method , Object target , Object . . . args ) { return JavaReflectionUtil . method ( target , Object . class , method ) . invoke ( target , args ) ; } interface ServiceProvider { String getDisplayName ( ) ; Object get ( ) ; void requiredBy ( Provider provider ) ; } interface Provider extends Stoppable { ServiceProvider getService ( LookupContext context , TypeSpec serviceType ) ; ServiceProvider getFactory ( LookupContext context , Class < ? > type ) ; < T > void getAll ( LookupContext context , Class < T > serviceType , List < T > result ) ; } private class OwnServices implements Provider { private final List < Provider > providers = new ArrayList < Provider > ( ) ; public ServiceProvider getFactory ( LookupContext context , Class < ? > type ) { List < ServiceProvider > candidates = new ArrayList < ServiceProvider > ( ) ; for ( Provider provider : providers ) { ServiceProvider factory = provider . getFactory ( context , type ) ; if ( factory ! = null ) { candidates . add ( factory ) ; } } if ( candidates . size ( ) = = <int> ) { return null ; } if ( candidates . size ( ) = = <int> ) { return candidates . get ( <int> ) ; } Set < String > descriptions = new TreeSet < String > ( ) ; for ( ServiceProvider candidate : candidates ) { descriptions . add ( candidate . getDisplayName ( ) ) ; } Formatter formatter = new Formatter ( ) ; formatter . format ( <str> , format ( type ) , displayName ) ; for ( String description : descriptions ) { formatter . format ( <str> , description ) ; } throw new ServiceLookupException ( formatter . toString ( ) ) ; } public ServiceProvider getService ( LookupContext context , TypeSpec serviceType ) { List < ServiceProvider > candidates = new ArrayList < ServiceProvider > ( ) ; for ( Provider provider : providers ) { ServiceProvider service = provider . getService ( context , serviceType ) ; if ( service ! = null ) { candidates . add ( service ) ; } } if ( candidates . size ( ) = = <int> ) { return null ; } if ( candidates . size ( ) = = <int> ) { return candidates . get ( <int> ) ; } Set < String > descriptions = new TreeSet < String > ( ) ; for ( ServiceProvider candidate : candidates ) { descriptions . add ( candidate . getDisplayName ( ) ) ; } Formatter formatter = new Formatter ( ) ; formatter . format ( <str> , format ( serviceType . getType ( ) ) , displayName ) ; for ( String description : descriptions ) { formatter . format ( <str> , description ) ; } throw new ServiceLookupException ( formatter . toString ( ) ) ; } public < T > void getAll ( LookupContext context , Class < T > serviceType , List < T > result ) { for ( Provider provider : providers ) { provider . getAll ( context , serviceType , result ) ; } } public void stop ( ) { CompositeStoppable . stoppable ( providers ) . stop ( ) ; } public void add ( Provider provider ) { this . providers . add ( provider ) ; } } private static abstract class ManagedObjectProvider < T > implements Provider { private T instance ; private final Set < Provider > dependents = new HashSet < Provider > ( ) ; protected void setInstance ( T instance ) { this . instance = instance ; } public T getInstance ( ) { if ( instance = = null ) { instance = create ( ) ; assert instance ! = null : String . format ( <str> , toString ( ) ) ; } return instance ; } protected abstract T create ( ) ; public void requiredBy ( Provider provider ) { dependents . add ( provider ) ; } public void stop ( ) { try { if ( instance ! = null ) { CompositeStoppable . stoppable ( dependents ) . add ( instance ) . stop ( ) ; } } finally { dependents . clear ( ) ; instance = null ; } } } private static abstract class SingletonService extends ManagedObjectProvider < Object > implements ServiceProvider { final Type serviceType ; final Class serviceClass ; boolean bound ; SingletonService ( Type serviceType ) { this . serviceType = serviceType ; serviceClass = toClass ( serviceType ) ; } @Override public String toString ( ) { return getDisplayName ( ) ; } public Object get ( ) { return getInstance ( ) ; } private ServiceProvider prepare ( LookupContext context ) { if ( ! bound ) { bind ( context ) ; bound = true ; } return this ; } protected void bind ( LookupContext context ) { } public ServiceProvider getService ( LookupContext context , TypeSpec serviceType ) { if ( ! serviceType . isSatisfiedBy ( this . serviceType ) ) { return null ; } return prepare ( context ) ; } public < T > void getAll ( LookupContext context , Class < T > serviceType , List < T > result ) { if ( serviceType . isAssignableFrom ( this . serviceClass ) ) { result . add ( serviceType . cast ( prepare ( context ) . get ( ) ) ) ; } } public ServiceProvider getFactory ( LookupContext context , Class < ? > elementType ) { if ( ! isFactory ( serviceType , elementType ) ) { return null ; } return prepare ( context ) ; } private boolean isFactory ( Type type , Class < ? > elementType ) { Class c = toClass ( type ) ; if ( ! Factory . class . isAssignableFrom ( c ) ) { return false ; } if ( type instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; if ( parameterizedType . getRawType ( ) . equals ( Factory . class ) ) { Type actualType = parameterizedType . getActualTypeArguments ( ) [ <int> ] ; if ( actualType instanceof Class < ? > & & elementType . isAssignableFrom ( ( Class < ? > ) actualType ) ) { return true ; } } } for ( Type interfaceType : c . getGenericInterfaces ( ) ) { if ( isFactory ( interfaceType , elementType ) ) { return true ; } } return false ; } private Class toClass ( Type type ) { if ( type instanceof Class ) { return ( Class ) type ; } else { ParameterizedType parameterizedType = ( ParameterizedType ) type ; return ( Class ) parameterizedType . getRawType ( ) ; } } } private abstract class FactoryService extends SingletonService { private ServiceProvider [ ] paramProviders ; protected FactoryService ( Type serviceType ) { super ( serviceType ) ; } protected abstract Type [ ] getParameterTypes ( ) ; protected abstract Member getFactory ( ) ; @Override protected void bind ( LookupContext context ) { Type [ ] parameterTypes = getParameterTypes ( ) ; paramProviders = new ServiceProvider [ parameterTypes . length ] ; for ( int i = <int> ; i < parameterTypes . length ; i + + ) { Type paramType = parameterTypes [ i ] ; try { if ( paramType . equals ( ServiceRegistry . class ) ) { paramProviders [ i ] = getThisAsProvider ( ) ; } else { ServiceProvider paramProvider = context . find ( paramType , allServices ) ; if ( paramProvider = = null ) { throw new ServiceCreationException ( String . format ( <str> , format ( serviceType ) , getFactory ( ) . getDeclaringClass ( ) . getSimpleName ( ) , getFactory ( ) . getName ( ) , format ( paramType ) ) ) ; } paramProviders [ i ] = paramProvider ; paramProvider . requiredBy ( this ) ; } } catch ( ServiceValidationException e ) { throw new ServiceCreationException ( String . format ( <str> , format ( serviceType ) , getFactory ( ) . getDeclaringClass ( ) . getSimpleName ( ) , getFactory ( ) . getName ( ) , i + <int> , format ( paramType ) ) , e ) ; } } } @Override protected Object create ( ) { Object [ ] params = assembleParameters ( ) ; Object result = invokeMethod ( params ) ; paramProviders = null ; return result ; } private Object [ ] assembleParameters ( ) { Object [ ] params = new Object [ paramProviders . length ] ; for ( int i = <int> ; i < paramProviders . length ; i + + ) { ServiceProvider paramProvider = paramProviders [ i ] ; params [ i ] = paramProvider . get ( ) ; } return params ; } protected abstract Object invokeMethod ( Object [ ] params ) ; } private class FactoryMethodService extends FactoryService { private final Method method ; private Object target ; public FactoryMethodService ( Object target , Method method ) { super ( method . getGenericReturnType ( ) ) ; this . target = target ; this . method = method ; } public String getDisplayName ( ) { return String . format ( <str> , format ( method . getGenericReturnType ( ) ) , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) ) ; } protected Type [ ] getParameterTypes ( ) { return method . getGenericParameterTypes ( ) ; } @Override protected Member getFactory ( ) { return method ; } protected Object invokeMethod ( Object [ ] params ) { Object result ; try { result = invoke ( method , target , params ) ; } catch ( Exception e ) { throw new ServiceCreationException ( String . format ( <str> , format ( serviceType ) , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) ) , e ) ; } try { if ( result = = null ) { throw new ServiceCreationException ( String . format ( <str> , format ( serviceType ) , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) ) ) ; } return result ; } finally { target = null ; } } } private ServiceProvider getThisAsProvider ( ) { return new ServiceProvider ( ) { public String getDisplayName ( ) { return String . format ( <str> , displayName ) ; } public Object get ( ) { return DefaultServiceRegistry . this ; } public void requiredBy ( Provider provider ) { } } ; } private static class FixedInstanceService < T > extends SingletonService { public FixedInstanceService ( Class < T > serviceType , T serviceInstance ) { super ( serviceType ) ; setInstance ( serviceInstance ) ; } public String getDisplayName ( ) { return String . format ( <str> , format ( serviceType ) , getInstance ( ) ) ; } @Override protected Object create ( ) { throw new UnsupportedOperationException ( ) ; } } private class ConstructorService extends FactoryService { private final Constructor < ? > constructor ; private ConstructorService ( Class < ? > serviceType ) { super ( serviceType ) ; Constructor < ? > [ ] constructors = serviceType . getDeclaredConstructors ( ) ; if ( constructors . length ! = <int> ) { throw new ServiceValidationException ( String . format ( <str> , format ( serviceType ) ) ) ; } this . constructor = constructors [ <int> ] ; } @Override protected Type [ ] getParameterTypes ( ) { return constructor . getGenericParameterTypes ( ) ; } @Override protected Member getFactory ( ) { return constructor ; } @Override protected Object invokeMethod ( Object [ ] params ) { try { return constructor . newInstance ( params ) ; } catch ( InvocationTargetException e ) { throw new ServiceCreationException ( String . format ( <str> , format ( serviceType ) ) , e . getCause ( ) ) ; } catch ( Exception e ) { throw new ServiceCreationException ( String . format ( <str> , format ( serviceType ) ) , e ) ; } } public String getDisplayName ( ) { return String . format ( <str> , format ( serviceType ) ) ; } } private class DecoratorMethodService extends SingletonService { private final Method method ; private Object target ; private ServiceProvider paramProvider ; public DecoratorMethodService ( Object target , Method method ) { super ( method . getGenericReturnType ( ) ) ; this . target = target ; this . method = method ; } public String getDisplayName ( ) { return String . format ( <str> , format ( method . getGenericReturnType ( ) ) , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) ) ; } @Override protected void bind ( LookupContext context ) { Type paramType = method . getGenericParameterTypes ( ) [ <int> ] ; DefaultLookupContext parentLookupContext = new DefaultLookupContext ( ) ; paramProvider = parentLookupContext . find ( paramType , parentServices ) ; if ( paramProvider = = null ) { throw new ServiceCreationException ( String . format ( <str> , format ( method . getGenericReturnType ( ) ) , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) , format ( paramType ) ) ) ; } } @Override protected Object create ( ) { Object param = paramProvider . get ( ) ; Object result ; try { result = invoke ( method , target , param ) ; } catch ( Exception e ) { throw new ServiceCreationException ( String . format ( <str> , format ( method . getGenericReturnType ( ) ) , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) ) , e ) ; } try { if ( result = = null ) { throw new ServiceCreationException ( String . format ( <str> , format ( method . getGenericReturnType ( ) ) , method . getDeclaringClass ( ) . getSimpleName ( ) , method . getName ( ) ) ) ; } return result ; } finally { paramProvider = null ; target = null ; } } } private class CompositeProvider implements Provider { private final List < Provider > providers = new LinkedList < Provider > ( ) ; public ServiceProvider getService ( LookupContext context , TypeSpec serviceType ) { for ( Provider provider : providers ) { ServiceProvider service = provider . getService ( context , serviceType ) ; if ( service ! = null ) { return service ; } } return null ; } public ServiceProvider getFactory ( LookupContext context , Class < ? > type ) { for ( Provider provider : providers ) { ServiceProvider factory = provider . getFactory ( context , type ) ; if ( factory ! = null ) { return factory ; } } return null ; } public < T > void getAll ( LookupContext context , Class < T > serviceType , List < T > result ) { for ( Provider provider : providers ) { provider . getAll ( context , serviceType , result ) ; } } public void stop ( ) { try { CompositeStoppable . stoppable ( providers ) . stop ( ) ; } finally { providers . clear ( ) ; } } } private class ParentServices implements Provider { private final ServiceRegistry parent ; private ParentServices ( ServiceRegistry parent ) { this . parent = parent ; } public ServiceProvider getFactory ( LookupContext context , Class < ? > type ) { try { Factory < ? > factory = parent . getFactory ( type ) ; assert factory ! = null : String . format ( <str> , type . getName ( ) ) ; return wrap ( factory ) ; } catch ( UnknownServiceException e ) { if ( ! e . getType ( ) . equals ( type ) ) { throw e ; } } return null ; } public ServiceProvider getService ( LookupContext context , TypeSpec serviceType ) { try { Object service = parent . get ( serviceType . getType ( ) ) ; assert service ! = null : String . format ( <str> , format ( serviceType . getType ( ) ) ) ; return wrap ( service ) ; } catch ( UnknownServiceException e ) { if ( ! e . getType ( ) . equals ( serviceType . getType ( ) ) ) { throw e ; } } return null ; } private ServiceProvider wrap ( final Object instance ) { return new ServiceProvider ( ) { public String getDisplayName ( ) { return String . format ( <str> , parent ) ; } public Object get ( ) { return instance ; } public void requiredBy ( Provider provider ) { } } ; } public < T > void getAll ( LookupContext context , Class < T > serviceType , List < T > result ) { List < T > services = parent . getAll ( serviceType ) ; assert services ! = null : String . format ( <str> , format ( serviceType ) ) ; result . addAll ( services ) ; } public void stop ( ) { } } interface LookupContext { @Nullable ServiceProvider find ( Type type , Provider provider ) ; } interface TypeSpec extends Spec < Type > { Type getType ( ) ; } private static class ClassSpec implements TypeSpec { private final Class < ? > type ; private ClassSpec ( Class < ? > type ) { this . type = type ; } public Type getType ( ) { return type ; } public boolean isSatisfiedBy ( Type element ) { if ( element instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) element ; if ( parameterizedType . getRawType ( ) instanceof Class ) { return type . isAssignableFrom ( ( Class ) parameterizedType . getRawType ( ) ) ; } } else if ( element instanceof Class ) { Class < ? > other = ( Class < ? > ) element ; return type . isAssignableFrom ( other ) ; } return false ; } } private static class ParameterizedTypeSpec implements TypeSpec { private final Type type ; private final TypeSpec rawType ; private final List < TypeSpec > paramSpecs ; private ParameterizedTypeSpec ( Type type , TypeSpec rawType , List < TypeSpec > paramSpecs ) { this . type = type ; this . rawType = rawType ; this . paramSpecs = paramSpecs ; } public Type getType ( ) { return type ; } public boolean isSatisfiedBy ( Type element ) { if ( element instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) element ; if ( ! rawType . isSatisfiedBy ( parameterizedType . getRawType ( ) ) ) { return false ; } for ( int i = <int> ; i < parameterizedType . getActualTypeArguments ( ) . length ; i + + ) { Type type = parameterizedType . getActualTypeArguments ( ) [ i ] ; if ( ! paramSpecs . get ( i ) . isSatisfiedBy ( type ) ) { return false ; } } return true ; } return false ; } } private static class DefaultLookupContext implements LookupContext { private final Set < Type > visiting = new HashSet < Type > ( ) ; public ServiceProvider find ( Type serviceType , Provider provider ) { if ( ! visiting . add ( serviceType ) ) { throw new ServiceValidationException ( String . format ( <str> , format ( serviceType ) ) ) ; } try { return getServiceProvider ( serviceType , provider ) ; } finally { visiting . remove ( serviceType ) ; } } public ServiceProvider getServiceProvider ( Type serviceType , Provider provider ) { BiFunction < ServiceProvider , LookupContext , Provider > function = SERVICE_TYPE_PROVIDER_CACHE . get ( serviceType ) ; if ( function = = null ) { function = createServiceProviderFactory ( serviceType ) ; SERVICE_TYPE_PROVIDER_CACHE . putIfAbsent ( serviceType , function ) ; } return function . apply ( this , provider ) ; } private static BiFunction < ServiceProvider , LookupContext , Provider > createServiceProviderFactory ( final Type serviceType ) { if ( serviceType instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) serviceType ; if ( parameterizedType . getRawType ( ) . equals ( Factory . class ) ) { final Type typeArg = parameterizedType . getActualTypeArguments ( ) [ <int> ] ; if ( typeArg instanceof Class ) { return new BiFunction < ServiceProvider , LookupContext , Provider > ( ) { @Override public ServiceProvider apply ( LookupContext lookupContext , Provider provider ) { return provider . getFactory ( lookupContext , ( Class ) typeArg ) ; } } ; } if ( typeArg instanceof WildcardType ) { final WildcardType wildcardType = ( WildcardType ) typeArg ; if ( wildcardType . getLowerBounds ( ) . length = = <int> & & wildcardType . getUpperBounds ( ) . length = = <int> ) { if ( wildcardType . getLowerBounds ( ) [ <int> ] instanceof Class & & wildcardType . getUpperBounds ( ) [ <int> ] . equals ( Object . class ) ) { return new BiFunction < ServiceProvider , LookupContext , Provider > ( ) { @Override public ServiceProvider apply ( LookupContext lookupContext , Provider provider ) { return provider . getFactory ( lookupContext , ( Class < ? > ) wildcardType . getLowerBounds ( ) [ <int> ] ) ; } } ; } } if ( wildcardType . getLowerBounds ( ) . length = = <int> & & wildcardType . getUpperBounds ( ) . length = = <int> ) { if ( wildcardType . getUpperBounds ( ) [ <int> ] instanceof Class ) { return new BiFunction < ServiceProvider , LookupContext , Provider > ( ) { @Override public ServiceProvider apply ( LookupContext lookupContext , Provider provider ) { return provider . getFactory ( lookupContext , ( Class < ? > ) wildcardType . getUpperBounds ( ) [ <int> ] ) ; } } ; } } } } } final TypeSpec serviceTypeSpec = toSpec ( serviceType ) ; return new BiFunction < ServiceProvider , LookupContext , Provider > ( ) { @Override public ServiceProvider apply ( LookupContext lookupContext , Provider provider ) { return provider . getService ( lookupContext , serviceTypeSpec ) ; } } ; } static TypeSpec toSpec ( Type serviceType ) { if ( serviceType instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) serviceType ; List < TypeSpec > paramSpecs = new ArrayList < TypeSpec > ( ) ; for ( Type paramType : parameterizedType . getActualTypeArguments ( ) ) { paramSpecs . add ( toSpec ( paramType ) ) ; } return new ParameterizedTypeSpec ( serviceType , toSpec ( parameterizedType . getRawType ( ) ) , paramSpecs ) ; } else if ( serviceType instanceof Class ) { Class < ? > serviceClass = ( Class < ? > ) serviceType ; if ( serviceClass . isArray ( ) ) { throw new ServiceValidationException ( <str> ) ; } if ( serviceClass . isAnnotation ( ) ) { throw new ServiceValidationException ( <str> ) ; } return new ClassSpec ( serviceClass ) ; } throw new ServiceValidationException ( String . format ( <str> , format ( serviceType ) ) ) ; } } } 
