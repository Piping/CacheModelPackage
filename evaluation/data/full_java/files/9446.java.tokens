package com . google . common . io ; import com . google . common . annotations . Beta ; import com . google . common . base . Preconditions ; import com . google . common . primitives . Ints ; import com . google . common . primitives . Longs ; import java . io . DataInput ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . FilterInputStream ; import java . io . IOException ; import java . io . InputStream ; @Beta public final class LittleEndianDataInputStream extends FilterInputStream implements DataInput { public LittleEndianDataInputStream ( InputStream in ) { super ( Preconditions . checkNotNull ( in ) ) ; } @Override public String readLine ( ) { throw new UnsupportedOperationException ( <str> ) ; } @Override public void readFully ( byte [ ] b ) throws IOException { ByteStreams . readFully ( this , b ) ; } @Override public void readFully ( byte [ ] b , int off , int len ) throws IOException { ByteStreams . readFully ( this , b , off , len ) ; } @Override public int skipBytes ( int n ) throws IOException { return ( int ) in . skip ( n ) ; } @Override public int readUnsignedByte ( ) throws IOException { int b1 = in . read ( ) ; if ( <int> > b1 ) { throw new EOFException ( ) ; } return b1 ; } @Override public int readUnsignedShort ( ) throws IOException { byte b1 = readAndCheckByte ( ) ; byte b2 = readAndCheckByte ( ) ; return Ints . fromBytes ( ( byte ) <int> , ( byte ) <int> , b2 , b1 ) ; } @Override public int readInt ( ) throws IOException { byte b1 = readAndCheckByte ( ) ; byte b2 = readAndCheckByte ( ) ; byte b3 = readAndCheckByte ( ) ; byte b4 = readAndCheckByte ( ) ; return Ints . fromBytes ( b4 , b3 , b2 , b1 ) ; } @Override public long readLong ( ) throws IOException { byte b1 = readAndCheckByte ( ) ; byte b2 = readAndCheckByte ( ) ; byte b3 = readAndCheckByte ( ) ; byte b4 = readAndCheckByte ( ) ; byte b5 = readAndCheckByte ( ) ; byte b6 = readAndCheckByte ( ) ; byte b7 = readAndCheckByte ( ) ; byte b8 = readAndCheckByte ( ) ; return Longs . fromBytes ( b8 , b7 , b6 , b5 , b4 , b3 , b2 , b1 ) ; } @Override public float readFloat ( ) throws IOException { return Float . intBitsToFloat ( readInt ( ) ) ; } @Override public double readDouble ( ) throws IOException { return Double . longBitsToDouble ( readLong ( ) ) ; } @Override public String readUTF ( ) throws IOException { return new DataInputStream ( in ) . readUTF ( ) ; } @Override public short readShort ( ) throws IOException { return ( short ) readUnsignedShort ( ) ; } @Override public char readChar ( ) throws IOException { return ( char ) readUnsignedShort ( ) ; } @Override public byte readByte ( ) throws IOException { return ( byte ) readUnsignedByte ( ) ; } @Override public boolean readBoolean ( ) throws IOException { return readUnsignedByte ( ) ! = <int> ; } private byte readAndCheckByte ( ) throws IOException , EOFException { int b1 = in . read ( ) ; if ( - <int> = = b1 ) { throw new EOFException ( ) ; } return ( byte ) b1 ; } } 
