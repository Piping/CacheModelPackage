package org . apache . cassandra . db . filter ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . db . transform . Transformation ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . SearchIterator ; import org . apache . cassandra . utils . btree . BTreeSet ; public class ClusteringIndexNamesFilter extends AbstractClusteringIndexFilter { static final InternalDeserializer deserializer = new NamesDeserializer ( ) ; private final NavigableSet < Clustering > clusterings ; private final NavigableSet < Clustering > clusteringsInQueryOrder ; public ClusteringIndexNamesFilter ( NavigableSet < Clustering > clusterings , boolean reversed ) { super ( reversed ) ; assert ! clusterings . contains ( Clustering . STATIC_CLUSTERING ) ; this . clusterings = clusterings ; this . clusteringsInQueryOrder = reversed ? clusterings . descendingSet ( ) : clusterings ; } public NavigableSet < Clustering > requestedRows ( ) { return clusterings ; } public boolean selectsAllPartition ( ) { return false ; } public boolean selects ( Clustering clustering ) { return clusterings . contains ( clustering ) ; } public ClusteringIndexNamesFilter forPaging ( ClusteringComparator comparator , Clustering lastReturned , boolean inclusive ) { NavigableSet < Clustering > newClusterings = reversed ? clusterings . headSet ( lastReturned , inclusive ) : clusterings . tailSet ( lastReturned , inclusive ) ; return new ClusteringIndexNamesFilter ( newClusterings , reversed ) ; } public boolean isFullyCoveredBy ( CachedPartition partition ) { if ( partition . isEmpty ( ) ) return false ; return clusterings . comparator ( ) . compare ( clusterings . last ( ) , partition . lastRow ( ) . clustering ( ) ) < = <int> ; } public boolean isHeadFilter ( ) { return false ; } public UnfilteredRowIterator filterNotIndexed ( ColumnFilter columnFilter , UnfilteredRowIterator iterator ) { class FilterNotIndexed extends Transformation { @Override public Row applyToStatic ( Row row ) { return columnFilter . fetchedColumns ( ) . statics . isEmpty ( ) ? null : row . filter ( columnFilter , iterator . metadata ( ) ) ; } @Override public Row applyToRow ( Row row ) { return clusterings . contains ( row . clustering ( ) ) ? row . filter ( columnFilter , iterator . metadata ( ) ) : null ; } } return Transformation . apply ( iterator , new FilterNotIndexed ( ) ) ; } public UnfilteredRowIterator filter ( final SliceableUnfilteredRowIterator iter ) { return new WrappingUnfilteredRowIterator ( iter ) { private final Iterator < Clustering > clusteringIter = clusteringsInQueryOrder . iterator ( ) ; private Iterator < Unfiltered > currentClustering ; private Unfiltered next ; @Override public boolean hasNext ( ) { if ( next ! = null ) return true ; if ( currentClustering ! = null & & currentClustering . hasNext ( ) ) { next = currentClustering . next ( ) ; return true ; } while ( clusteringIter . hasNext ( ) ) { Clustering nextClustering = clusteringIter . next ( ) ; currentClustering = iter . slice ( Slice . make ( nextClustering ) ) ; if ( currentClustering . hasNext ( ) ) { next = currentClustering . next ( ) ; return true ; } } return false ; } @Override public Unfiltered next ( ) { if ( next = = null & & ! hasNext ( ) ) throw new NoSuchElementException ( ) ; Unfiltered toReturn = next ; next = null ; return toReturn ; } } ; } public UnfilteredRowIterator getUnfilteredRowIterator ( final ColumnFilter columnFilter , final Partition partition ) { final SearchIterator < Clustering , Row > searcher = partition . searchIterator ( columnFilter , reversed ) ; return new AbstractUnfilteredRowIterator ( partition . metadata ( ) , partition . partitionKey ( ) , partition . partitionLevelDeletion ( ) , columnFilter . fetchedColumns ( ) , searcher . next ( Clustering . STATIC_CLUSTERING ) , reversed , partition . stats ( ) ) { private final Iterator < Clustering > clusteringIter = clusteringsInQueryOrder . iterator ( ) ; protected Unfiltered computeNext ( ) { while ( clusteringIter . hasNext ( ) & & searcher . hasNext ( ) ) { Row row = searcher . next ( clusteringIter . next ( ) ) ; if ( row ! = null ) return row ; } return endOfData ( ) ; } } ; } public boolean shouldInclude ( SSTableReader sstable ) { ClusteringComparator comparator = sstable . metadata . comparator ; List < ByteBuffer > minClusteringValues = sstable . getSSTableMetadata ( ) . minClusteringValues ; List < ByteBuffer > maxClusteringValues = sstable . getSSTableMetadata ( ) . maxClusteringValues ; for ( Clustering clustering : clusterings ) { if ( Slice . make ( clustering ) . intersects ( comparator , minClusteringValues , maxClusteringValues ) ) return true ; } return false ; } public String toString ( CFMetaData metadata ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) ; int i = <int> ; for ( Clustering clustering : clusterings ) sb . append ( i + + = = <int> ? <str> : <str> ) . append ( clustering . toString ( metadata ) ) ; if ( reversed ) sb . append ( <str> ) ; return sb . append ( <str> ) . toString ( ) ; } public String toCQLString ( CFMetaData metadata ) { if ( metadata . clusteringColumns ( ) . isEmpty ( ) | | clusterings . size ( ) < = <int> ) return <str> ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( <str> ) . append ( ColumnDefinition . toCQLString ( metadata . clusteringColumns ( ) ) ) . append ( <str> ) ; sb . append ( clusterings . size ( ) = = <int> ? <str> : <str> ) ; int i = <int> ; for ( Clustering clustering : clusterings ) sb . append ( i + + = = <int> ? <str> : <str> ) . append ( <str> ) . append ( clustering . toCQLString ( metadata ) ) . append ( <str> ) ; sb . append ( clusterings . size ( ) = = <int> ? <str> : <str> ) ; appendOrderByToCQLString ( metadata , sb ) ; return sb . toString ( ) ; } public Kind kind ( ) { return Kind . NAMES ; } protected void serializeInternal ( DataOutputPlus out , int version ) throws IOException { ClusteringComparator comparator = ( ClusteringComparator ) clusterings . comparator ( ) ; out . writeUnsignedVInt ( clusterings . size ( ) ) ; for ( Clustering clustering : clusterings ) Clustering . serializer . serialize ( clustering , out , version , comparator . subtypes ( ) ) ; } protected long serializedSizeInternal ( int version ) { ClusteringComparator comparator = ( ClusteringComparator ) clusterings . comparator ( ) ; long size = TypeSizes . sizeofUnsignedVInt ( clusterings . size ( ) ) ; for ( Clustering clustering : clusterings ) size + = Clustering . serializer . serializedSize ( clustering , version , comparator . subtypes ( ) ) ; return size ; } private static class NamesDeserializer implements InternalDeserializer { public ClusteringIndexFilter deserialize ( DataInputPlus in , int version , CFMetaData metadata , boolean reversed ) throws IOException { ClusteringComparator comparator = metadata . comparator ; BTreeSet . Builder < Clustering > clusterings = BTreeSet . builder ( comparator ) ; int size = ( int ) in . readUnsignedVInt ( ) ; for ( int i = <int> ; i < size ; i + + ) clusterings . add ( Clustering . serializer . deserialize ( in , version , comparator . subtypes ( ) ) ) ; return new ClusteringIndexNamesFilter ( clusterings . build ( ) , reversed ) ; } } } 
