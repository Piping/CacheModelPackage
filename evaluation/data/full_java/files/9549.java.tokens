package com . google . common . util . concurrent ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . base . Preconditions ; import com . google . common . collect . Queues ; import java . util . Queue ; import java . util . concurrent . Executor ; import java . util . logging . Level ; import java . util . logging . Logger ; import javax . annotation . concurrent . GuardedBy ; final class ListenerCallQueue < L > implements Runnable { private static final Logger logger = Logger . getLogger ( ListenerCallQueue . class . getName ( ) ) ; abstract static class Callback < L > { private final String methodCall ; Callback ( String methodCall ) { this . methodCall = methodCall ; } abstract void call ( L listener ) ; void enqueueOn ( Iterable < ListenerCallQueue < L > > queues ) { for ( ListenerCallQueue < L > queue : queues ) { queue . add ( this ) ; } } } private final L listener ; private final Executor executor ; @GuardedBy ( <str> ) private final Queue < Callback < L > > waitQueue = Queues . newArrayDeque ( ) ; @GuardedBy ( <str> ) private boolean isThreadScheduled ; ListenerCallQueue ( L listener , Executor executor ) { this . listener = checkNotNull ( listener ) ; this . executor = checkNotNull ( executor ) ; } synchronized void add ( Callback < L > callback ) { waitQueue . add ( callback ) ; } void execute ( ) { boolean scheduleTaskRunner = false ; synchronized ( this ) { if ( ! isThreadScheduled ) { isThreadScheduled = true ; scheduleTaskRunner = true ; } } if ( scheduleTaskRunner ) { try { executor . execute ( this ) ; } catch ( RuntimeException e ) { synchronized ( this ) { isThreadScheduled = false ; } logger . log ( Level . SEVERE , <str> + listener + <str> + executor , e ) ; throw e ; } } } @Override public void run ( ) { boolean stillRunning = true ; try { while ( true ) { Callback < L > nextToRun ; synchronized ( ListenerCallQueue . this ) { Preconditions . checkState ( isThreadScheduled ) ; nextToRun = waitQueue . poll ( ) ; if ( nextToRun = = null ) { isThreadScheduled = false ; stillRunning = false ; break ; } } try { nextToRun . call ( listener ) ; } catch ( RuntimeException e ) { logger . log ( Level . SEVERE , <str> + listener + <str> + nextToRun . methodCall , e ) ; } } } finally { if ( stillRunning ) { synchronized ( ListenerCallQueue . this ) { isThreadScheduled = false ; } } } } } 
