package org . elasticsearch . search . highlight ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Streamable ; import org . elasticsearch . common . text . StringText ; import org . elasticsearch . common . text . Text ; import java . io . IOException ; import java . util . Arrays ; public class HighlightField implements Streamable { private String name ; private Text [ ] fragments ; HighlightField ( ) { } public HighlightField ( String name , Text [ ] fragments ) { this . name = name ; this . fragments = fragments ; } public String name ( ) { return name ; } public String getName ( ) { return name ( ) ; } public Text [ ] fragments ( ) { return fragments ; } public Text [ ] getFragments ( ) { return fragments ( ) ; } @Override public String toString ( ) { return <str> + name + <str> + Arrays . toString ( fragments ) + <str> ; } public static HighlightField readHighlightField ( StreamInput in ) throws IOException { HighlightField field = new HighlightField ( ) ; field . readFrom ( in ) ; return field ; } @Override public void readFrom ( StreamInput in ) throws IOException { name = in . readString ( ) ; if ( in . readBoolean ( ) ) { int size = in . readVInt ( ) ; if ( size = = <int> ) { fragments = StringText . EMPTY_ARRAY ; } else { fragments = new Text [ size ] ; for ( int i = <int> ; i < size ; i + + ) { fragments [ i ] = in . readText ( ) ; } } } } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( name ) ; if ( fragments = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeVInt ( fragments . length ) ; for ( Text fragment : fragments ) { out . writeText ( fragment ) ; } } } } 
