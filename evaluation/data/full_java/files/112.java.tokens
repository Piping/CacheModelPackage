package org . apache . cassandra . config ; import java . io . IOException ; import java . lang . reflect . Constructor ; import java . lang . reflect . InvocationTargetException ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . TimeUnit ; import java . util . stream . Collectors ; import com . google . common . annotations . VisibleForTesting ; import com . google . common . base . MoreObjects ; import com . google . common . base . Objects ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Sets ; import org . apache . commons . lang3 . ArrayUtils ; import org . apache . commons . lang3 . builder . HashCodeBuilder ; import org . apache . commons . lang3 . builder . ToStringBuilder ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . auth . DataResource ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . statements . CFStatement ; import org . apache . cassandra . cql3 . statements . CreateTableStatement ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . compaction . AbstractCompactionStrategy ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . schema . * ; import org . apache . cassandra . utils . * ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; import org . apache . cassandra . utils . UUIDGen ; import org . github . jamm . Unmetered ; @Unmetered public final class CFMetaData { public enum Flag { SUPER , COUNTER , DENSE , COMPOUND } private static final Logger logger = LoggerFactory . getLogger ( CFMetaData . class ) ; public static final Serializer serializer = new Serializer ( ) ; public final UUID cfId ; public final String ksName ; public final String cfName ; public final Pair < String , String > ksAndCFName ; public final byte [ ] ksAndCFBytes ; private final ImmutableSet < Flag > flags ; private final boolean isDense ; private final boolean isCompound ; private final boolean isSuper ; private final boolean isCounter ; private final boolean isView ; private final boolean isIndex ; public volatile ClusteringComparator comparator ; public final IPartitioner partitioner ; private final Serializers serializers ; public volatile TableParams params = TableParams . DEFAULT ; private volatile AbstractType < ? > keyValidator = BytesType . instance ; private volatile Map < ByteBuffer , DroppedColumn > droppedColumns = new HashMap < > ( ) ; private volatile Triggers triggers = Triggers . none ( ) ; private volatile Indexes indexes = Indexes . none ( ) ; private final Map < ByteBuffer , ColumnDefinition > columnMetadata = new ConcurrentHashMap < > ( ) ; private volatile List < ColumnDefinition > partitionKeyColumns ; private volatile List < ColumnDefinition > clusteringColumns ; private volatile PartitionColumns partitionColumns ; private volatile ColumnDefinition compactValueColumn ; public final DataResource resource ; public CFMetaData params ( TableParams params ) { this . params = params ; return this ; } public CFMetaData bloomFilterFpChance ( double prop ) { params = TableParams . builder ( params ) . bloomFilterFpChance ( prop ) . build ( ) ; return this ; } public CFMetaData caching ( CachingParams prop ) { params = TableParams . builder ( params ) . caching ( prop ) . build ( ) ; return this ; } public CFMetaData comment ( String prop ) { params = TableParams . builder ( params ) . comment ( prop ) . build ( ) ; return this ; } public CFMetaData compaction ( CompactionParams prop ) { params = TableParams . builder ( params ) . compaction ( prop ) . build ( ) ; return this ; } public CFMetaData compression ( CompressionParams prop ) { params = TableParams . builder ( params ) . compression ( prop ) . build ( ) ; return this ; } public CFMetaData dcLocalReadRepairChance ( double prop ) { params = TableParams . builder ( params ) . dcLocalReadRepairChance ( prop ) . build ( ) ; return this ; } public CFMetaData defaultTimeToLive ( int prop ) { params = TableParams . builder ( params ) . defaultTimeToLive ( prop ) . build ( ) ; return this ; } public CFMetaData gcGraceSeconds ( int prop ) { params = TableParams . builder ( params ) . gcGraceSeconds ( prop ) . build ( ) ; return this ; } public CFMetaData maxIndexInterval ( int prop ) { params = TableParams . builder ( params ) . maxIndexInterval ( prop ) . build ( ) ; return this ; } public CFMetaData memtableFlushPeriod ( int prop ) { params = TableParams . builder ( params ) . memtableFlushPeriodInMs ( prop ) . build ( ) ; return this ; } public CFMetaData minIndexInterval ( int prop ) { params = TableParams . builder ( params ) . minIndexInterval ( prop ) . build ( ) ; return this ; } public CFMetaData readRepairChance ( double prop ) { params = TableParams . builder ( params ) . readRepairChance ( prop ) . build ( ) ; return this ; } public CFMetaData crcCheckChance ( double prop ) { params = TableParams . builder ( params ) . crcCheckChance ( prop ) . build ( ) ; return this ; } public CFMetaData speculativeRetry ( SpeculativeRetryParam prop ) { params = TableParams . builder ( params ) . speculativeRetry ( prop ) . build ( ) ; return this ; } public CFMetaData extensions ( Map < String , ByteBuffer > extensions ) { params = TableParams . builder ( params ) . extensions ( extensions ) . build ( ) ; return this ; } public CFMetaData droppedColumns ( Map < ByteBuffer , DroppedColumn > cols ) { droppedColumns = cols ; return this ; } public CFMetaData triggers ( Triggers prop ) { triggers = prop ; return this ; } public CFMetaData indexes ( Indexes indexes ) { this . indexes = indexes ; return this ; } private CFMetaData ( String keyspace , String name , UUID cfId , boolean isSuper , boolean isCounter , boolean isDense , boolean isCompound , boolean isView , List < ColumnDefinition > partitionKeyColumns , List < ColumnDefinition > clusteringColumns , PartitionColumns partitionColumns , IPartitioner partitioner ) { this . cfId = cfId ; this . ksName = keyspace ; this . cfName = name ; ksAndCFName = Pair . create ( keyspace , name ) ; byte [ ] ksBytes = FBUtilities . toWriteUTFBytes ( ksName ) ; byte [ ] cfBytes = FBUtilities . toWriteUTFBytes ( cfName ) ; ksAndCFBytes = Arrays . copyOf ( ksBytes , ksBytes . length + cfBytes . length ) ; System . arraycopy ( cfBytes , <int> , ksAndCFBytes , ksBytes . length , cfBytes . length ) ; this . isDense = isDense ; this . isCompound = isCompound ; this . isSuper = isSuper ; this . isCounter = isCounter ; this . isView = isView ; EnumSet < Flag > flags = EnumSet . noneOf ( Flag . class ) ; if ( isSuper ) flags . add ( Flag . SUPER ) ; if ( isCounter ) flags . add ( Flag . COUNTER ) ; if ( isDense ) flags . add ( Flag . DENSE ) ; if ( isCompound ) flags . add ( Flag . COMPOUND ) ; this . flags = Sets . immutableEnumSet ( flags ) ; isIndex = cfName . contains ( <str> ) ; assert partitioner ! = null : <str> + <str> ; this . partitioner = partitioner ; assert isCQLTable ( ) | | ! clusteringColumns . isEmpty ( ) : String . format ( <str> , ksName , cfName , isDense , isCompound , clusteringColumns ) ; this . partitionKeyColumns = partitionKeyColumns ; this . clusteringColumns = clusteringColumns ; this . partitionColumns = partitionColumns ; this . serializers = new Serializers ( this ) ; this . resource = DataResource . table ( ksName , cfName ) ; rebuild ( ) ; } private void rebuild ( ) { this . comparator = new ClusteringComparator ( extractTypes ( clusteringColumns ) ) ; this . columnMetadata . clear ( ) ; for ( ColumnDefinition def : partitionKeyColumns ) this . columnMetadata . put ( def . name . bytes , def ) ; for ( ColumnDefinition def : clusteringColumns ) { this . columnMetadata . put ( def . name . bytes , def ) ; def . type . checkComparable ( ) ; } for ( ColumnDefinition def : partitionColumns ) this . columnMetadata . put ( def . name . bytes , def ) ; List < AbstractType < ? > > keyTypes = extractTypes ( partitionKeyColumns ) ; this . keyValidator = keyTypes . size ( ) = = <int> ? keyTypes . get ( <int> ) : CompositeType . getInstance ( keyTypes ) ; if ( isCompactTable ( ) ) this . compactValueColumn = CompactTables . getCompactValueColumn ( partitionColumns , isSuper ( ) ) ; } public Indexes getIndexes ( ) { return indexes ; } public static CFMetaData create ( String ksName , String name , UUID cfId , boolean isDense , boolean isCompound , boolean isSuper , boolean isCounter , boolean isView , List < ColumnDefinition > columns , IPartitioner partitioner ) { List < ColumnDefinition > partitions = new ArrayList < > ( ) ; List < ColumnDefinition > clusterings = new ArrayList < > ( ) ; PartitionColumns . Builder builder = PartitionColumns . builder ( ) ; for ( ColumnDefinition column : columns ) { switch ( column . kind ) { case PARTITION_KEY : partitions . add ( column ) ; break ; case CLUSTERING : clusterings . add ( column ) ; break ; default : builder . add ( column ) ; break ; } } Collections . sort ( partitions ) ; Collections . sort ( clusterings ) ; return new CFMetaData ( ksName , name , cfId , isSuper , isCounter , isDense , isCompound , isView , partitions , clusterings , builder . build ( ) , partitioner ) ; } private static List < AbstractType < ? > > extractTypes ( List < ColumnDefinition > clusteringColumns ) { List < AbstractType < ? > > types = new ArrayList < > ( clusteringColumns . size ( ) ) ; for ( ColumnDefinition def : clusteringColumns ) types . add ( def . type ) ; return types ; } public Set < Flag > flags ( ) { return flags ; } public static CFMetaData createFake ( String keyspace , String name ) { return CFMetaData . Builder . create ( keyspace , name ) . addPartitionKey ( <str> , BytesType . instance ) . build ( ) ; } public Triggers getTriggers ( ) { return triggers ; } public static CFMetaData compile ( String cql , String keyspace ) { CFStatement parsed = ( CFStatement ) QueryProcessor . parseStatement ( cql ) ; parsed . prepareKeyspace ( keyspace ) ; CreateTableStatement statement = ( CreateTableStatement ) ( ( CreateTableStatement . RawStatement ) parsed ) . prepare ( Types . none ( ) ) . statement ; return statement . metadataBuilder ( ) . withId ( generateLegacyCfId ( keyspace , statement . columnFamily ( ) ) ) . build ( ) . params ( statement . params ( ) ) . readRepairChance ( <float> ) . dcLocalReadRepairChance ( <float> ) . gcGraceSeconds ( <int> ) . memtableFlushPeriod ( ( int ) TimeUnit . HOURS . toMillis ( <int> ) ) ; } public static UUID generateLegacyCfId ( String ksName , String cfName ) { return UUID . nameUUIDFromBytes ( ArrayUtils . addAll ( ksName . getBytes ( ) , cfName . getBytes ( ) ) ) ; } public CFMetaData reloadIndexMetadataProperties ( CFMetaData parent ) { TableParams . Builder indexParams = TableParams . builder ( parent . params ) ; if ( parent . params . caching . cacheKeys ( ) ) indexParams . caching ( CachingParams . CACHE_KEYS ) ; else indexParams . caching ( CachingParams . CACHE_NOTHING ) ; indexParams . readRepairChance ( <float> ) . dcLocalReadRepairChance ( <float> ) . gcGraceSeconds ( <int> ) ; return params ( indexParams . build ( ) ) ; } public CFMetaData copy ( ) { return copy ( cfId ) ; } public CFMetaData copy ( UUID newCfId ) { return copyOpts ( new CFMetaData ( ksName , cfName , newCfId , isSuper ( ) , isCounter ( ) , isDense ( ) , isCompound ( ) , isView ( ) , copy ( partitionKeyColumns ) , copy ( clusteringColumns ) , copy ( partitionColumns ) , partitioner ) , this ) ; } public CFMetaData copy ( IPartitioner partitioner ) { return copyOpts ( new CFMetaData ( ksName , cfName , cfId , isSuper , isCounter , isDense , isCompound , isView , copy ( partitionKeyColumns ) , copy ( clusteringColumns ) , copy ( partitionColumns ) , partitioner ) , this ) ; } private static List < ColumnDefinition > copy ( List < ColumnDefinition > l ) { List < ColumnDefinition > copied = new ArrayList < > ( l . size ( ) ) ; for ( ColumnDefinition cd : l ) copied . add ( cd . copy ( ) ) ; return copied ; } private static PartitionColumns copy ( PartitionColumns columns ) { PartitionColumns . Builder newColumns = PartitionColumns . builder ( ) ; for ( ColumnDefinition cd : columns ) newColumns . add ( cd . copy ( ) ) ; return newColumns . build ( ) ; } @VisibleForTesting public static CFMetaData copyOpts ( CFMetaData newCFMD , CFMetaData oldCFMD ) { return newCFMD . params ( oldCFMD . params ) . droppedColumns ( new HashMap < > ( oldCFMD . droppedColumns ) ) . triggers ( oldCFMD . triggers ) . indexes ( oldCFMD . indexes ) ; } public String indexColumnFamilyName ( IndexMetadata info ) { return cfName + Directories . SECONDARY_INDEX_NAME_SEPARATOR + info . name ; } public boolean isIndex ( ) { return isIndex ; } public DecoratedKey decorateKey ( ByteBuffer key ) { return partitioner . decorateKey ( key ) ; } public Map < ByteBuffer , ColumnDefinition > getColumnMetadata ( ) { return columnMetadata ; } public String getParentColumnFamilyName ( ) { return isIndex ? cfName . substring ( <int> , cfName . indexOf ( <str> ) ) : null ; } public ReadRepairDecision newReadRepairDecision ( ) { double chance = ThreadLocalRandom . current ( ) . nextDouble ( ) ; if ( params . readRepairChance > chance ) return ReadRepairDecision . GLOBAL ; if ( params . dcLocalReadRepairChance > chance ) return ReadRepairDecision . DC_LOCAL ; return ReadRepairDecision . NONE ; } public AbstractType < ? > getColumnDefinitionNameComparator ( ColumnDefinition . Kind kind ) { return ( isSuper ( ) & & kind = = ColumnDefinition . Kind . REGULAR ) | | ( isStaticCompactTable ( ) & & kind = = ColumnDefinition . Kind . STATIC ) ? thriftColumnNameType ( ) : UTF8Type . instance ; } public AbstractType < ? > getKeyValidator ( ) { return keyValidator ; } public Collection < ColumnDefinition > allColumns ( ) { return columnMetadata . values ( ) ; } public Iterator < ColumnDefinition > allColumnsInSelectOrder ( ) { final boolean isStaticCompactTable = isStaticCompactTable ( ) ; final boolean noNonPkColumns = isCompactTable ( ) & & CompactTables . hasEmptyCompactValue ( this ) ; return new AbstractIterator < ColumnDefinition > ( ) { private final Iterator < ColumnDefinition > partitionKeyIter = partitionKeyColumns . iterator ( ) ; private final Iterator < ColumnDefinition > clusteringIter = isStaticCompactTable ? Collections . < ColumnDefinition > emptyIterator ( ) : clusteringColumns . iterator ( ) ; private final Iterator < ColumnDefinition > otherColumns = noNonPkColumns ? Collections . < ColumnDefinition > emptyIterator ( ) : ( isStaticCompactTable ? partitionColumns . statics . selectOrderIterator ( ) : partitionColumns . selectOrderIterator ( ) ) ; protected ColumnDefinition computeNext ( ) { if ( partitionKeyIter . hasNext ( ) ) return partitionKeyIter . next ( ) ; if ( clusteringIter . hasNext ( ) ) return clusteringIter . next ( ) ; return otherColumns . hasNext ( ) ? otherColumns . next ( ) : endOfData ( ) ; } } ; } public List < ColumnDefinition > partitionKeyColumns ( ) { return partitionKeyColumns ; } public List < ColumnDefinition > clusteringColumns ( ) { return clusteringColumns ; } public PartitionColumns partitionColumns ( ) { return partitionColumns ; } public ColumnDefinition compactValueColumn ( ) { return compactValueColumn ; } public ClusteringComparator getKeyValidatorAsClusteringComparator ( ) { boolean isCompound = keyValidator instanceof CompositeType ; List < AbstractType < ? > > types = isCompound ? ( ( CompositeType ) keyValidator ) . types : Collections . < AbstractType < ? > > singletonList ( keyValidator ) ; return new ClusteringComparator ( types ) ; } public static ByteBuffer serializePartitionKey ( ClusteringPrefix keyAsClustering ) { if ( keyAsClustering . size ( ) = = <int> ) return keyAsClustering . get ( <int> ) ; ByteBuffer [ ] values = new ByteBuffer [ keyAsClustering . size ( ) ] ; for ( int i = <int> ; i < keyAsClustering . size ( ) ; i + + ) values [ i ] = keyAsClustering . get ( i ) ; return CompositeType . build ( values ) ; } public Map < ByteBuffer , DroppedColumn > getDroppedColumns ( ) { return droppedColumns ; } public ColumnDefinition getDroppedColumnDefinition ( ByteBuffer name ) { DroppedColumn dropped = droppedColumns . get ( name ) ; if ( dropped = = null ) return null ; AbstractType < ? > type = dropped . type = = null ? BytesType . instance : dropped . type ; return ColumnDefinition . regularDef ( this , name , type ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof CFMetaData ) ) return false ; CFMetaData other = ( CFMetaData ) o ; return Objects . equal ( cfId , other . cfId ) & & Objects . equal ( flags , other . flags ) & & Objects . equal ( ksName , other . ksName ) & & Objects . equal ( cfName , other . cfName ) & & Objects . equal ( params , other . params ) & & Objects . equal ( comparator , other . comparator ) & & Objects . equal ( keyValidator , other . keyValidator ) & & Objects . equal ( columnMetadata , other . columnMetadata ) & & Objects . equal ( droppedColumns , other . droppedColumns ) & & Objects . equal ( triggers , other . triggers ) & & Objects . equal ( indexes , other . indexes ) ; } @Override public int hashCode ( ) { return new HashCodeBuilder ( <int> , <int> ) . append ( cfId ) . append ( ksName ) . append ( cfName ) . append ( flags ) . append ( comparator ) . append ( params ) . append ( keyValidator ) . append ( columnMetadata ) . append ( droppedColumns ) . append ( triggers ) . append ( indexes ) . toHashCode ( ) ; } @VisibleForTesting public boolean apply ( CFMetaData cfm ) throws ConfigurationException { logger . debug ( <str> , cfm , this ) ; validateCompatibility ( cfm ) ; partitionKeyColumns = cfm . partitionKeyColumns ; clusteringColumns = cfm . clusteringColumns ; boolean changeAffectsStatements = ! partitionColumns . equals ( cfm . partitionColumns ) ; partitionColumns = cfm . partitionColumns ; rebuild ( ) ; params = cfm . params ; keyValidator = cfm . keyValidator ; if ( ! cfm . droppedColumns . isEmpty ( ) ) droppedColumns = cfm . droppedColumns ; triggers = cfm . triggers ; changeAffectsStatements | = ! indexes . equals ( cfm . indexes ) ; indexes = cfm . indexes ; logger . debug ( <str> , this ) ; return changeAffectsStatements ; } public void validateCompatibility ( CFMetaData cfm ) throws ConfigurationException { if ( ! cfm . ksName . equals ( ksName ) ) throw new ConfigurationException ( String . format ( <str> , cfm . ksName , ksName ) ) ; if ( ! cfm . cfName . equals ( cfName ) ) throw new ConfigurationException ( String . format ( <str> , cfm . cfName , cfName ) ) ; if ( ! cfm . cfId . equals ( cfId ) ) throw new ConfigurationException ( String . format ( <str> , cfm . cfId , cfId ) ) ; if ( ! cfm . flags . equals ( flags ) ) throw new ConfigurationException ( <str> ) ; if ( ! cfm . comparator . isCompatibleWith ( comparator ) ) throw new ConfigurationException ( String . format ( <str> , cfm . comparator . toString ( ) , comparator . toString ( ) ) ) ; } public static Class < ? extends AbstractCompactionStrategy > createCompactionStrategy ( String className ) throws ConfigurationException { className = className . contains ( <str> ) ? className : <str> + className ; Class < AbstractCompactionStrategy > strategyClass = FBUtilities . classForName ( className , <str> ) ; if ( ! AbstractCompactionStrategy . class . isAssignableFrom ( strategyClass ) ) throw new ConfigurationException ( String . format ( <str> , className ) ) ; return strategyClass ; } public static AbstractCompactionStrategy createCompactionStrategyInstance ( ColumnFamilyStore cfs , CompactionParams compactionParams ) { try { Constructor < ? extends AbstractCompactionStrategy > constructor = compactionParams . klass ( ) . getConstructor ( ColumnFamilyStore . class , Map . class ) ; return constructor . newInstance ( cfs , compactionParams . options ( ) ) ; } catch ( NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e ) { throw new RuntimeException ( e ) ; } } public ColumnDefinition getColumnDefinition ( ColumnIdentifier name ) { return columnMetadata . get ( name . bytes ) ; } public ColumnDefinition getColumnDefinition ( ByteBuffer name ) { return columnMetadata . get ( name ) ; } public static boolean isNameValid ( String name ) { return name ! = null & & ! name . isEmpty ( ) & & name . length ( ) < = Schema . NAME_LENGTH & & name . matches ( <str> ) ; } public CFMetaData validate ( ) throws ConfigurationException { rebuild ( ) ; if ( ! isNameValid ( ksName ) ) throw new ConfigurationException ( String . format ( <str> , Schema . NAME_LENGTH , ksName ) ) ; if ( ! isNameValid ( cfName ) ) throw new ConfigurationException ( String . format ( <str> , Schema . NAME_LENGTH , cfName ) ) ; params . validate ( ) ; for ( int i = <int> ; i < comparator . size ( ) ; i + + ) { if ( comparator . subtype ( i ) instanceof CounterColumnType ) throw new ConfigurationException ( <str> ) ; } if ( keyValidator instanceof CounterColumnType ) throw new ConfigurationException ( <str> ) ; if ( isCounter ( ) ) { for ( ColumnDefinition def : partitionColumns ( ) ) if ( ! ( def . type instanceof CounterColumnType ) & & ! CompactTables . isSuperColumnMapColumn ( def ) ) throw new ConfigurationException ( <str> + def . name + <str> ) ; } else { for ( ColumnDefinition def : allColumns ( ) ) if ( def . type instanceof CounterColumnType ) throw new ConfigurationException ( <str> + def . name + <str> ) ; } if ( ! indexes . isEmpty ( ) & & isSuper ( ) ) throw new ConfigurationException ( <str> ) ; KeyspaceMetadata ksm = Schema . instance . getKSMetaData ( ksName ) ; Set < String > indexNames = ksm = = null ? new HashSet < > ( ) : ksm . existingIndexNames ( cfName ) ; for ( IndexMetadata index : indexes ) { if ( indexNames . contains ( index . name ) ) throw new ConfigurationException ( <str> + index . name ) ; indexNames . add ( index . name ) ; index . validate ( ) ; } return this ; } public AbstractType < ? > thriftColumnNameType ( ) { if ( isSuper ( ) ) { ColumnDefinition def = compactValueColumn ( ) ; assert def ! = null & & def . type instanceof MapType ; return ( ( MapType ) def . type ) . nameComparator ( ) ; } assert isStaticCompactTable ( ) ; return clusteringColumns . get ( <int> ) . type ; } public CFMetaData addColumnDefinition ( ColumnDefinition def ) throws ConfigurationException { if ( columnMetadata . containsKey ( def . name . bytes ) ) throw new ConfigurationException ( String . format ( <str> , def . name ) ) ; return addOrReplaceColumnDefinition ( def ) ; } public CFMetaData addOrReplaceColumnDefinition ( ColumnDefinition def ) { switch ( def . kind ) { case PARTITION_KEY : partitionKeyColumns . set ( def . position ( ) , def ) ; List < AbstractType < ? > > keyTypes = extractTypes ( partitionKeyColumns ) ; keyValidator = keyTypes . size ( ) = = <int> ? keyTypes . get ( <int> ) : CompositeType . getInstance ( keyTypes ) ; break ; case CLUSTERING : clusteringColumns . set ( def . position ( ) , def ) ; comparator = new ClusteringComparator ( extractTypes ( clusteringColumns ) ) ; break ; case REGULAR : case STATIC : PartitionColumns . Builder builder = PartitionColumns . builder ( ) ; for ( ColumnDefinition column : partitionColumns ) if ( ! column . name . equals ( def . name ) ) builder . add ( column ) ; builder . add ( def ) ; partitionColumns = builder . build ( ) ; if ( isDense ( ) ) this . compactValueColumn = def ; break ; } this . columnMetadata . put ( def . name . bytes , def ) ; return this ; } public boolean removeColumnDefinition ( ColumnDefinition def ) { assert ! def . isPartitionKey ( ) ; boolean removed = columnMetadata . remove ( def . name . bytes ) ! = null ; if ( removed ) partitionColumns = partitionColumns . without ( def ) ; return removed ; } public void recordColumnDrop ( ColumnDefinition def ) { droppedColumns . put ( def . name . bytes , new DroppedColumn ( def . name . toString ( ) , def . type , FBUtilities . timestampMicros ( ) ) ) ; } public void renameColumn ( ColumnIdentifier from , ColumnIdentifier to ) throws InvalidRequestException { ColumnDefinition def = getColumnDefinition ( from ) ; if ( def = = null ) throw new InvalidRequestException ( String . format ( <str> , from , cfName ) ) ; if ( getColumnDefinition ( to ) ! = null ) throw new InvalidRequestException ( String . format ( <str> , from , to , cfName ) ) ; if ( def . isPartOfCellName ( isCQLTable ( ) , isSuper ( ) ) ) { throw new InvalidRequestException ( String . format ( <str> , from ) ) ; } if ( ! getIndexes ( ) . isEmpty ( ) ) { ColumnFamilyStore store = Keyspace . openAndGetStore ( this ) ; Set < IndexMetadata > dependentIndexes = store . indexManager . getDependentIndexes ( def ) ; if ( ! dependentIndexes . isEmpty ( ) ) throw new InvalidRequestException ( String . format ( <str> + <str> , from , dependentIndexes . stream ( ) . map ( i - > i . name ) . collect ( Collectors . joining ( <str> ) ) ) ) ; } ColumnDefinition newDef = def . withNewName ( to ) ; addOrReplaceColumnDefinition ( newDef ) ; if ( def . isPartitionKey ( ) ) columnMetadata . remove ( def . name . bytes ) ; else removeColumnDefinition ( def ) ; } public boolean isCQLTable ( ) { return ! isSuper ( ) & & ! isDense ( ) & & isCompound ( ) ; } public boolean isCompactTable ( ) { return ! isCQLTable ( ) ; } public boolean isStaticCompactTable ( ) { return ! isSuper ( ) & & ! isDense ( ) & & ! isCompound ( ) ; } public boolean isThriftCompatible ( ) { return isCompactTable ( ) ; } public boolean hasStaticColumns ( ) { return ! partitionColumns . statics . isEmpty ( ) ; } public boolean hasCollectionColumns ( ) { for ( ColumnDefinition def : partitionColumns ( ) ) if ( def . type instanceof CollectionType & & def . type . isMultiCell ( ) ) return true ; return false ; } public boolean hasComplexColumns ( ) { for ( ColumnDefinition def : partitionColumns ( ) ) if ( def . isComplex ( ) ) return true ; return false ; } public boolean hasDroppedCollectionColumns ( ) { for ( DroppedColumn def : getDroppedColumns ( ) . values ( ) ) if ( def . type instanceof CollectionType & & def . type . isMultiCell ( ) ) return true ; return false ; } public boolean isSuper ( ) { return isSuper ; } public boolean isCounter ( ) { return isCounter ; } public boolean isDense ( ) { return isDense ; } public boolean isCompound ( ) { return isCompound ; } public boolean isView ( ) { return isView ; } public Serializers serializers ( ) { return serializers ; } public AbstractType < ? > makeLegacyDefaultValidator ( ) { return isCounter ( ) ? CounterColumnType . instance : ( isCompactTable ( ) ? compactValueColumn ( ) . type : BytesType . instance ) ; } public static Set < Flag > flagsFromStrings ( Set < String > strings ) { return strings . stream ( ) . map ( String : : toUpperCase ) . map ( Flag : : valueOf ) . collect ( Collectors . toSet ( ) ) ; } public static Set < String > flagsToStrings ( Set < Flag > flags ) { return flags . stream ( ) . map ( Flag : : toString ) . map ( String : : toLowerCase ) . collect ( Collectors . toSet ( ) ) ; } @Override public String toString ( ) { return new ToStringBuilder ( this ) . append ( <str> , cfId ) . append ( <str> , ksName ) . append ( <str> , cfName ) . append ( <str> , flags ) . append ( <str> , params ) . append ( <str> , comparator ) . append ( <str> , partitionColumns ) . append ( <str> , partitionKeyColumns ) . append ( <str> , clusteringColumns ) . append ( <str> , keyValidator ) . append ( <str> , columnMetadata . values ( ) ) . append ( <str> , droppedColumns ) . append ( <str> , triggers ) . append ( <str> , indexes ) . toString ( ) ; } public static class Builder { private final String keyspace ; private final String table ; private final boolean isDense ; private final boolean isCompound ; private final boolean isSuper ; private final boolean isCounter ; private final boolean isView ; private IPartitioner partitioner ; private UUID tableId ; private final List < Pair < ColumnIdentifier , AbstractType > > partitionKeys = new ArrayList < > ( ) ; private final List < Pair < ColumnIdentifier , AbstractType > > clusteringColumns = new ArrayList < > ( ) ; private final List < Pair < ColumnIdentifier , AbstractType > > staticColumns = new ArrayList < > ( ) ; private final List < Pair < ColumnIdentifier , AbstractType > > regularColumns = new ArrayList < > ( ) ; private Builder ( String keyspace , String table , boolean isDense , boolean isCompound , boolean isSuper , boolean isCounter , boolean isView ) { this . keyspace = keyspace ; this . table = table ; this . isDense = isDense ; this . isCompound = isCompound ; this . isSuper = isSuper ; this . isCounter = isCounter ; this . isView = isView ; this . partitioner = DatabaseDescriptor . getPartitioner ( ) ; } public static Builder create ( String keyspace , String table ) { return create ( keyspace , table , false , true , false ) ; } public static Builder create ( String keyspace , String table , boolean isDense , boolean isCompound , boolean isCounter ) { return create ( keyspace , table , isDense , isCompound , false , isCounter ) ; } public static Builder create ( String keyspace , String table , boolean isDense , boolean isCompound , boolean isSuper , boolean isCounter ) { return new Builder ( keyspace , table , isDense , isCompound , isSuper , isCounter , false ) ; } public static Builder createView ( String keyspace , String table ) { return new Builder ( keyspace , table , false , true , false , false , true ) ; } public static Builder createDense ( String keyspace , String table , boolean isCompound , boolean isCounter ) { return create ( keyspace , table , true , isCompound , isCounter ) ; } public static Builder createSuper ( String keyspace , String table , boolean isCounter ) { return create ( keyspace , table , false , false , true , isCounter ) ; } public Builder withPartitioner ( IPartitioner partitioner ) { this . partitioner = partitioner ; return this ; } public Builder withId ( UUID tableId ) { this . tableId = tableId ; return this ; } public Builder addPartitionKey ( String name , AbstractType type ) { return addPartitionKey ( ColumnIdentifier . getInterned ( name , false ) , type ) ; } public Builder addPartitionKey ( ColumnIdentifier name , AbstractType type ) { this . partitionKeys . add ( Pair . create ( name , type ) ) ; return this ; } public Builder addClusteringColumn ( String name , AbstractType type ) { return addClusteringColumn ( ColumnIdentifier . getInterned ( name , false ) , type ) ; } public Builder addClusteringColumn ( ColumnIdentifier name , AbstractType type ) { this . clusteringColumns . add ( Pair . create ( name , type ) ) ; return this ; } public Builder addRegularColumn ( String name , AbstractType type ) { return addRegularColumn ( ColumnIdentifier . getInterned ( name , false ) , type ) ; } public Builder addRegularColumn ( ColumnIdentifier name , AbstractType type ) { this . regularColumns . add ( Pair . create ( name , type ) ) ; return this ; } public boolean hasRegulars ( ) { return ! this . regularColumns . isEmpty ( ) ; } public Builder addStaticColumn ( String name , AbstractType type ) { return addStaticColumn ( ColumnIdentifier . getInterned ( name , false ) , type ) ; } public Builder addStaticColumn ( ColumnIdentifier name , AbstractType type ) { this . staticColumns . add ( Pair . create ( name , type ) ) ; return this ; } public Set < String > usedColumnNames ( ) { Set < String > usedNames = new HashSet < > ( ) ; for ( Pair < ColumnIdentifier , AbstractType > p : partitionKeys ) usedNames . add ( p . left . toString ( ) ) ; for ( Pair < ColumnIdentifier , AbstractType > p : clusteringColumns ) usedNames . add ( p . left . toString ( ) ) ; for ( Pair < ColumnIdentifier , AbstractType > p : staticColumns ) usedNames . add ( p . left . toString ( ) ) ; for ( Pair < ColumnIdentifier , AbstractType > p : regularColumns ) usedNames . add ( p . left . toString ( ) ) ; return usedNames ; } public CFMetaData build ( ) { if ( tableId = = null ) tableId = UUIDGen . getTimeUUID ( ) ; List < ColumnDefinition > partitions = new ArrayList < > ( partitionKeys . size ( ) ) ; List < ColumnDefinition > clusterings = new ArrayList < > ( clusteringColumns . size ( ) ) ; PartitionColumns . Builder builder = PartitionColumns . builder ( ) ; for ( int i = <int> ; i < partitionKeys . size ( ) ; i + + ) { Pair < ColumnIdentifier , AbstractType > p = partitionKeys . get ( i ) ; partitions . add ( new ColumnDefinition ( keyspace , table , p . left , p . right , i , ColumnDefinition . Kind . PARTITION_KEY ) ) ; } for ( int i = <int> ; i < clusteringColumns . size ( ) ; i + + ) { Pair < ColumnIdentifier , AbstractType > p = clusteringColumns . get ( i ) ; clusterings . add ( new ColumnDefinition ( keyspace , table , p . left , p . right , i , ColumnDefinition . Kind . CLUSTERING ) ) ; } for ( Pair < ColumnIdentifier , AbstractType > p : regularColumns ) builder . add ( new ColumnDefinition ( keyspace , table , p . left , p . right , ColumnDefinition . NO_POSITION , ColumnDefinition . Kind . REGULAR ) ) ; for ( Pair < ColumnIdentifier , AbstractType > p : staticColumns ) builder . add ( new ColumnDefinition ( keyspace , table , p . left , p . right , ColumnDefinition . NO_POSITION , ColumnDefinition . Kind . STATIC ) ) ; return new CFMetaData ( keyspace , table , tableId , isSuper , isCounter , isDense , isCompound , isView , partitions , clusterings , builder . build ( ) , partitioner ) ; } } public static class Serializer { public void serialize ( CFMetaData metadata , DataOutputPlus out , int version ) throws IOException { UUIDSerializer . serializer . serialize ( metadata . cfId , out , version ) ; } public CFMetaData deserialize ( DataInputPlus in , int version ) throws IOException { UUID cfId = UUIDSerializer . serializer . deserialize ( in , version ) ; CFMetaData metadata = Schema . instance . getCFMetaData ( cfId ) ; if ( metadata = = null ) { String message = String . format ( <str> + <str> + <str> , cfId ) ; throw new UnknownColumnFamilyException ( message , cfId ) ; } return metadata ; } public long serializedSize ( CFMetaData metadata , int version ) { return UUIDSerializer . serializer . serializedSize ( metadata . cfId , version ) ; } } public static class DroppedColumn { public final String name ; public final AbstractType < ? > type ; public final long droppedTime ; public DroppedColumn ( String name , AbstractType < ? > type , long droppedTime ) { this . name = name ; this . type = type ; this . droppedTime = droppedTime ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof DroppedColumn ) ) return false ; DroppedColumn dc = ( DroppedColumn ) o ; return name . equals ( dc . name ) & & type . equals ( dc . type ) & & droppedTime = = dc . droppedTime ; } @Override public int hashCode ( ) { return Objects . hashCode ( name , type , droppedTime ) ; } @Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( <str> , name ) . add ( <str> , type ) . add ( <str> , droppedTime ) . toString ( ) ; } } } 
