package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . MessageToMessageEncoder ; import io . netty . handler . codec . TooLongFrameException ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . util . List ; public class WebSocket08FrameEncoder extends MessageToMessageEncoder < WebSocketFrame > implements WebSocketFrameEncoder { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( WebSocket08FrameEncoder . class ) ; private static final byte OPCODE_CONT = <hex> ; private static final byte OPCODE_TEXT = <hex> ; private static final byte OPCODE_BINARY = <hex> ; private static final byte OPCODE_CLOSE = <hex> ; private static final byte OPCODE_PING = <hex> ; private static final byte OPCODE_PONG = <hex> ; private static final int GATHERING_WRITE_TRESHOLD = <int> ; private final boolean maskPayload ; public WebSocket08FrameEncoder ( boolean maskPayload ) { this . maskPayload = maskPayload ; } @Override protected void encode ( ChannelHandlerContext ctx , WebSocketFrame msg , List < Object > out ) throws Exception { final ByteBuf data = msg . content ( ) ; byte [ ] mask ; byte opcode ; if ( msg instanceof TextWebSocketFrame ) { opcode = OPCODE_TEXT ; } else if ( msg instanceof PingWebSocketFrame ) { opcode = OPCODE_PING ; } else if ( msg instanceof PongWebSocketFrame ) { opcode = OPCODE_PONG ; } else if ( msg instanceof CloseWebSocketFrame ) { opcode = OPCODE_CLOSE ; } else if ( msg instanceof BinaryWebSocketFrame ) { opcode = OPCODE_BINARY ; } else if ( msg instanceof ContinuationWebSocketFrame ) { opcode = OPCODE_CONT ; } else { throw new UnsupportedOperationException ( <str> + msg . getClass ( ) . getName ( ) ) ; } int length = data . readableBytes ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + opcode + <str> + length ) ; } int b0 = <int> ; if ( msg . isFinalFragment ( ) ) { b0 | = <int> < < <int> ; } b0 | = msg . rsv ( ) % <int> < < <int> ; b0 | = opcode % <int> ; if ( opcode = = OPCODE_PING & & length > <int> ) { throw new TooLongFrameException ( <str> + length ) ; } boolean release = true ; ByteBuf buf = null ; try { int maskLength = maskPayload ? <int> : <int> ; if ( length < = <int> ) { int size = <int> + maskLength ; if ( maskPayload | | length < = GATHERING_WRITE_TRESHOLD ) { size + = length ; } buf = ctx . alloc ( ) . buffer ( size ) ; buf . writeByte ( b0 ) ; byte b = ( byte ) ( maskPayload ? <hex> | ( byte ) length : ( byte ) length ) ; buf . writeByte ( b ) ; } else if ( length < = <hex> ) { int size = <int> + maskLength ; if ( maskPayload | | length < = GATHERING_WRITE_TRESHOLD ) { size + = length ; } buf = ctx . alloc ( ) . buffer ( size ) ; buf . writeByte ( b0 ) ; buf . writeByte ( maskPayload ? <hex> : <int> ) ; buf . writeByte ( length > > > <int> & <hex> ) ; buf . writeByte ( length & <hex> ) ; } else { int size = <int> + maskLength ; if ( maskPayload | | length < = GATHERING_WRITE_TRESHOLD ) { size + = length ; } buf = ctx . alloc ( ) . buffer ( size ) ; buf . writeByte ( b0 ) ; buf . writeByte ( maskPayload ? <hex> : <int> ) ; buf . writeLong ( length ) ; } if ( maskPayload ) { int random = ( int ) ( Math . random ( ) * Integer . MAX_VALUE ) ; mask = ByteBuffer . allocate ( <int> ) . putInt ( random ) . array ( ) ; buf . writeBytes ( mask ) ; ByteOrder srcOrder = data . order ( ) ; ByteOrder dstOrder = buf . order ( ) ; int counter = <int> ; int i = data . readerIndex ( ) ; int end = data . writerIndex ( ) ; if ( srcOrder = = dstOrder ) { int intMask = ( ( mask [ <int> ] & <hex> ) < < <int> ) | ( ( mask [ <int> ] & <hex> ) < < <int> ) | ( ( mask [ <int> ] & <hex> ) < < <int> ) | ( mask [ <int> ] & <hex> ) ; if ( srcOrder = = ByteOrder . LITTLE_ENDIAN ) { intMask = Integer . reverseBytes ( intMask ) ; } for ( ; i + <int> < end ; i + = <int> ) { int intData = data . getInt ( i ) ; buf . writeInt ( intData ^ intMask ) ; } } for ( ; i < end ; i + + ) { byte byteData = data . getByte ( i ) ; buf . writeByte ( byteData ^ mask [ counter + + % <int> ] ) ; } out . add ( buf ) ; } else { if ( buf . writableBytes ( ) > = data . readableBytes ( ) ) { buf . writeBytes ( data ) ; out . add ( buf ) ; } else { out . add ( buf ) ; out . add ( data . retain ( ) ) ; } } release = false ; } finally { if ( release & & buf ! = null ) { buf . release ( ) ; } } } } 
