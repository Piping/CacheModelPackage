package com . google . common . eventbus ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Lists ; import junit . framework . TestCase ; import java . util . List ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . atomic . AtomicInteger ; public class EventBusTest extends TestCase { private static final String EVENT = <str> ; private static final String BUS_IDENTIFIER = <str> ; private EventBus bus ; @Override protected void setUp ( ) throws Exception { super . setUp ( ) ; bus = new EventBus ( BUS_IDENTIFIER ) ; } public void testBasicCatcherDistribution ( ) { StringCatcher catcher = new StringCatcher ( ) ; bus . register ( catcher ) ; bus . post ( EVENT ) ; List < String > events = catcher . getEvents ( ) ; assertEquals ( <str> , <int> , events . size ( ) ) ; assertEquals ( <str> , EVENT , events . get ( <int> ) ) ; } public void testPolymorphicDistribution ( ) { StringCatcher stringCatcher = new StringCatcher ( ) ; final List < Object > objectEvents = Lists . newArrayList ( ) ; Object objCatcher = new Object ( ) { @SuppressWarnings ( <str> ) @Subscribe public void eat ( Object food ) { objectEvents . add ( food ) ; } } ; final List < Comparable < ? > > compEvents = Lists . newArrayList ( ) ; Object compCatcher = new Object ( ) { @SuppressWarnings ( <str> ) @Subscribe public void eat ( Comparable < ? > food ) { compEvents . add ( food ) ; } } ; bus . register ( stringCatcher ) ; bus . register ( objCatcher ) ; bus . register ( compCatcher ) ; Object objEvent = new Object ( ) ; Object compEvent = new Integer ( <int> ) ; bus . post ( EVENT ) ; bus . post ( objEvent ) ; bus . post ( compEvent ) ; List < String > stringEvents = stringCatcher . getEvents ( ) ; assertEquals ( <str> , <int> , stringEvents . size ( ) ) ; assertEquals ( <str> , EVENT , stringEvents . get ( <int> ) ) ; assertEquals ( <str> , <int> , objectEvents . size ( ) ) ; assertEquals ( <str> , EVENT , objectEvents . get ( <int> ) ) ; assertEquals ( <str> , objEvent , objectEvents . get ( <int> ) ) ; assertEquals ( <str> , compEvent , objectEvents . get ( <int> ) ) ; assertEquals ( <str> , <int> , compEvents . size ( ) ) ; assertEquals ( <str> , EVENT , compEvents . get ( <int> ) ) ; assertEquals ( <str> , compEvent , compEvents . get ( <int> ) ) ; } public void testSubscriberThrowsException ( ) throws Exception { final RecordingSubscriberExceptionHandler handler = new RecordingSubscriberExceptionHandler ( ) ; final EventBus eventBus = new EventBus ( handler ) ; final RuntimeException exception = new RuntimeException ( <str> ) ; final Object subscriber = new Object ( ) { @Subscribe public void throwExceptionOn ( String message ) { throw exception ; } } ; eventBus . register ( subscriber ) ; eventBus . post ( EVENT ) ; assertEquals ( <str> , exception , handler . exception ) ; assertEquals ( <str> , eventBus , handler . context . getEventBus ( ) ) ; assertEquals ( <str> , EVENT , handler . context . getEvent ( ) ) ; assertEquals ( <str> , subscriber , handler . context . getSubscriber ( ) ) ; assertEquals ( <str> , subscriber . getClass ( ) . getMethod ( <str> , String . class ) , handler . context . getSubscriberMethod ( ) ) ; } public void testSubscriberThrowsExceptionHandlerThrowsException ( ) throws Exception { final EventBus eventBus = new EventBus ( new SubscriberExceptionHandler ( ) { @Override public void handleException ( Throwable exception , SubscriberExceptionContext context ) { throw new RuntimeException ( ) ; } } ) ; final Object subscriber = new Object ( ) { @Subscribe public void throwExceptionOn ( String message ) { throw new RuntimeException ( ) ; } } ; eventBus . register ( subscriber ) ; try { eventBus . post ( EVENT ) ; } catch ( RuntimeException e ) { fail ( <str> ) ; } } public void testDeadEventForwarding ( ) { GhostCatcher catcher = new GhostCatcher ( ) ; bus . register ( catcher ) ; bus . post ( EVENT ) ; List < DeadEvent > events = catcher . getEvents ( ) ; assertEquals ( <str> , <int> , events . size ( ) ) ; assertEquals ( <str> , EVENT , events . get ( <int> ) . getEvent ( ) ) ; } public void testDeadEventPosting ( ) { GhostCatcher catcher = new GhostCatcher ( ) ; bus . register ( catcher ) ; bus . post ( new DeadEvent ( this , EVENT ) ) ; List < DeadEvent > events = catcher . getEvents ( ) ; assertEquals ( <str> , <int> , events . size ( ) ) ; assertEquals ( <str> , EVENT , events . get ( <int> ) . getEvent ( ) ) ; } public void testMissingSubscribe ( ) { bus . register ( new Object ( ) ) ; } public void testUnregister ( ) { StringCatcher catcher1 = new StringCatcher ( ) ; StringCatcher catcher2 = new StringCatcher ( ) ; try { bus . unregister ( catcher1 ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } bus . register ( catcher1 ) ; bus . post ( EVENT ) ; bus . register ( catcher2 ) ; bus . post ( EVENT ) ; List < String > expectedEvents = Lists . newArrayList ( ) ; expectedEvents . add ( EVENT ) ; expectedEvents . add ( EVENT ) ; assertEquals ( <str> , expectedEvents , catcher1 . getEvents ( ) ) ; assertEquals ( <str> , Lists . newArrayList ( EVENT ) , catcher2 . getEvents ( ) ) ; bus . unregister ( catcher1 ) ; bus . post ( EVENT ) ; assertEquals ( <str> , expectedEvents , catcher1 . getEvents ( ) ) ; assertEquals ( <str> , expectedEvents , catcher2 . getEvents ( ) ) ; try { bus . unregister ( catcher1 ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } bus . unregister ( catcher2 ) ; bus . post ( EVENT ) ; assertEquals ( <str> , expectedEvents , catcher1 . getEvents ( ) ) ; assertEquals ( <str> , expectedEvents , catcher2 . getEvents ( ) ) ; } public void testRegisterThreadSafety ( ) throws Exception { List < StringCatcher > catchers = Lists . newCopyOnWriteArrayList ( ) ; List < Future < ? > > futures = Lists . newArrayList ( ) ; ExecutorService executor = Executors . newFixedThreadPool ( <int> ) ; int numberOfCatchers = <int> ; for ( int i = <int> ; i < numberOfCatchers ; i + + ) { futures . add ( executor . submit ( new Registrator ( bus , catchers ) ) ) ; } for ( int i = <int> ; i < numberOfCatchers ; i + + ) { futures . get ( i ) . get ( ) ; } assertEquals ( <str> , numberOfCatchers , catchers . size ( ) ) ; bus . post ( EVENT ) ; List < String > expectedEvents = ImmutableList . of ( EVENT ) ; for ( StringCatcher catcher : catchers ) { assertEquals ( <str> , expectedEvents , catcher . getEvents ( ) ) ; } } public void testRegistrationWithBridgeMethod ( ) { final AtomicInteger calls = new AtomicInteger ( ) ; bus . register ( new Callback < String > ( ) { @Subscribe @Override public void call ( String s ) { calls . incrementAndGet ( ) ; } } ) ; bus . post ( <str> ) ; assertEquals ( <int> , calls . get ( ) ) ; } private static final class RecordingSubscriberExceptionHandler implements SubscriberExceptionHandler { public SubscriberExceptionContext context ; public Throwable exception ; @Override public void handleException ( Throwable exception , SubscriberExceptionContext context ) { this . exception = exception ; this . context = context ; } } private static class Registrator implements Runnable { private final EventBus bus ; private final List < StringCatcher > catchers ; Registrator ( EventBus bus , List < StringCatcher > catchers ) { this . bus = bus ; this . catchers = catchers ; } @Override public void run ( ) { StringCatcher catcher = new StringCatcher ( ) ; bus . register ( catcher ) ; catchers . add ( catcher ) ; } } public static class GhostCatcher { private List < DeadEvent > events = Lists . newArrayList ( ) ; @Subscribe public void ohNoesIHaveDied ( DeadEvent event ) { events . add ( event ) ; } public List < DeadEvent > getEvents ( ) { return events ; } } private interface Callback < T > { void call ( T t ) ; } } 
