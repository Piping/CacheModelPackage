package org . elasticsearch . mapper . attachments ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . MapperTestUtils ; import org . elasticsearch . index . mapper . DocumentMapper ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . ParseContext ; import java . io . IOException ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . StreamsUtils . copyToBytesFromClasspath ; import static org . elasticsearch . test . StreamsUtils . copyToStringFromClasspath ; import static org . hamcrest . Matchers . * ; public class EncryptedDocMapperTests extends AttachmentUnitTestCase { public void testMultipleDocsEncryptedLast ( ) throws IOException { DocumentMapperParser mapperParser = MapperTestUtils . newMapperService ( createTempDir ( ) , Settings . EMPTY , getIndicesModuleWithRegisteredAttachmentMapper ( ) ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = mapperParser . parse ( mapping ) ; byte [ ] html = copyToBytesFromClasspath ( <str> ) ; byte [ ] pdf = copyToBytesFromClasspath ( <str> ) ; BytesReference json = jsonBuilder ( ) . startObject ( ) . field ( <str> , html ) . field ( <str> , pdf ) . endObject ( ) . bytes ( ) ; ParseContext . Document doc = docMapper . parse ( <str> , <str> , <str> , json ) . rootDoc ( ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , containsString ( <str> ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , equalTo ( <str> ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , equalTo ( <str> ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , equalTo ( <str> ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , startsWith ( <str> ) ) ; assertThat ( doc . getField ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) . numericValue ( ) . longValue ( ) , greaterThan ( <int> L ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . getField ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; } public void testMultipleDocsEncryptedFirst ( ) throws IOException { DocumentMapperParser mapperParser = MapperTestUtils . newMapperService ( createTempDir ( ) , Settings . EMPTY , getIndicesModuleWithRegisteredAttachmentMapper ( ) ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = mapperParser . parse ( mapping ) ; byte [ ] html = copyToBytesFromClasspath ( <str> ) ; byte [ ] pdf = copyToBytesFromClasspath ( <str> ) ; BytesReference json = jsonBuilder ( ) . startObject ( ) . field ( <str> , pdf ) . field ( <str> , html ) . endObject ( ) . bytes ( ) ; ParseContext . Document doc = docMapper . parse ( <str> , <str> , <str> , json ) . rootDoc ( ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . getField ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , nullValue ( ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , containsString ( <str> ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , equalTo ( <str> ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , equalTo ( <str> ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , equalTo ( <str> ) ) ; assertThat ( doc . get ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) , startsWith ( <str> ) ) ; assertThat ( doc . getField ( docMapper . mappers ( ) . getMapper ( <str> ) . fieldType ( ) . names ( ) . indexName ( ) ) . numericValue ( ) . longValue ( ) , greaterThan ( <int> L ) ) ; } public void testMultipleDocsEncryptedNotIgnoringErrors ( ) throws IOException { try { DocumentMapperParser mapperParser = MapperTestUtils . newMapperService ( createTempDir ( ) , Settings . builder ( ) . put ( <str> , false ) . build ( ) , getIndicesModuleWithRegisteredAttachmentMapper ( ) ) . documentMapperParser ( ) ; String mapping = copyToStringFromClasspath ( <str> ) ; DocumentMapper docMapper = mapperParser . parse ( mapping ) ; byte [ ] html = copyToBytesFromClasspath ( <str> ) ; byte [ ] pdf = copyToBytesFromClasspath ( <str> ) ; BytesReference json = jsonBuilder ( ) . startObject ( ) . field ( <str> , pdf ) . field ( <str> , html ) . endObject ( ) . bytes ( ) ; docMapper . parse ( <str> , <str> , <str> , json ) ; fail ( <str> ) ; } catch ( MapperParsingException e ) { if ( e . getMessage ( ) = = null | | e . getMessage ( ) . contains ( <str> ) = = false ) { throw e ; } } } } 
