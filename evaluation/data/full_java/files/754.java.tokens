package org . apache . cassandra . io . util ; import java . io . Closeable ; import java . io . DataInputStream ; import java . io . EOFException ; import java . io . IOException ; import java . io . InputStream ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import net . nicoulaj . compilecommand . annotations . DontInline ; import org . apache . cassandra . utils . FastByteOperations ; import org . apache . cassandra . utils . vint . VIntCoding ; import com . google . common . base . Preconditions ; public abstract class RebufferingInputStream extends InputStream implements DataInputPlus , Closeable { protected ByteBuffer buffer ; protected RebufferingInputStream ( ByteBuffer buffer ) { Preconditions . checkArgument ( buffer = = null | | buffer . order ( ) = = ByteOrder . BIG_ENDIAN , <str> ) ; this . buffer = buffer ; } protected abstract void reBuffer ( ) throws IOException ; @Override public void readFully ( byte [ ] b ) throws IOException { readFully ( b , <int> , b . length ) ; } @Override public void readFully ( byte [ ] b , int off , int len ) throws IOException { int read = read ( b , off , len ) ; if ( read < len ) throw new EOFException ( ) ; } @Override public int read ( byte [ ] b , int off , int len ) throws IOException { if ( off < <int> | | off > b . length | | len < <int> | | len > b . length - off ) throw new IndexOutOfBoundsException ( ) ; if ( len = = <int> ) return <int> ; int copied = <int> ; while ( copied < len ) { int position = buffer . position ( ) ; int remaining = buffer . limit ( ) - position ; if ( remaining = = <int> ) { reBuffer ( ) ; position = buffer . position ( ) ; remaining = buffer . limit ( ) - position ; if ( remaining = = <int> ) return copied = = <int> ? - <int> : copied ; } int toCopy = Math . min ( len - copied , remaining ) ; FastByteOperations . copy ( buffer , position , b , off + copied , toCopy ) ; buffer . position ( position + toCopy ) ; copied + = toCopy ; } return copied ; } @DontInline protected long readPrimitiveSlowly ( int bytes ) throws IOException { long result = <int> ; for ( int i = <int> ; i < bytes ; i + + ) result = ( result < < <int> ) | ( readByte ( ) & <hex> ) ; return result ; } @Override public int skipBytes ( int n ) throws IOException { if ( n < <int> ) return <int> ; int requested = n ; int position = buffer . position ( ) , limit = buffer . limit ( ) , remaining ; while ( ( remaining = limit - position ) < n ) { n - = remaining ; buffer . position ( limit ) ; reBuffer ( ) ; position = buffer . position ( ) ; limit = buffer . limit ( ) ; if ( position = = limit ) return requested - n ; } buffer . position ( position + n ) ; return requested ; } @Override public boolean readBoolean ( ) throws IOException { return readByte ( ) ! = <int> ; } @Override public byte readByte ( ) throws IOException { if ( ! buffer . hasRemaining ( ) ) { reBuffer ( ) ; if ( ! buffer . hasRemaining ( ) ) throw new EOFException ( ) ; } return buffer . get ( ) ; } @Override public int readUnsignedByte ( ) throws IOException { return readByte ( ) & <hex> ; } @Override public short readShort ( ) throws IOException { if ( buffer . remaining ( ) > = <int> ) return buffer . getShort ( ) ; else return ( short ) readPrimitiveSlowly ( <int> ) ; } @Override public int readUnsignedShort ( ) throws IOException { return readShort ( ) & <hex> ; } @Override public char readChar ( ) throws IOException { if ( buffer . remaining ( ) > = <int> ) return buffer . getChar ( ) ; else return ( char ) readPrimitiveSlowly ( <int> ) ; } @Override public int readInt ( ) throws IOException { if ( buffer . remaining ( ) > = <int> ) return buffer . getInt ( ) ; else return ( int ) readPrimitiveSlowly ( <int> ) ; } @Override public long readLong ( ) throws IOException { if ( buffer . remaining ( ) > = <int> ) return buffer . getLong ( ) ; else return readPrimitiveSlowly ( <int> ) ; } public long readVInt ( ) throws IOException { return VIntCoding . decodeZigZag64 ( readUnsignedVInt ( ) ) ; } public long readUnsignedVInt ( ) throws IOException { if ( buffer . remaining ( ) < <int> ) return VIntCoding . readUnsignedVInt ( this ) ; byte firstByte = buffer . get ( ) ; if ( firstByte > = <int> ) return firstByte ; int extraBytes = VIntCoding . numberOfExtraBytesToRead ( firstByte ) ; int position = buffer . position ( ) ; int extraBits = extraBytes * <int> ; long retval = buffer . getLong ( position ) ; if ( buffer . order ( ) = = ByteOrder . LITTLE_ENDIAN ) retval = Long . reverseBytes ( retval ) ; buffer . position ( position + extraBytes ) ; retval > > > = <int> - extraBits ; firstByte & = VIntCoding . firstByteValueMask ( extraBytes ) ; retval | = ( long ) firstByte < < extraBits ; return retval ; } @Override public float readFloat ( ) throws IOException { if ( buffer . remaining ( ) > = <int> ) return buffer . getFloat ( ) ; else return Float . intBitsToFloat ( ( int ) readPrimitiveSlowly ( <int> ) ) ; } @Override public double readDouble ( ) throws IOException { if ( buffer . remaining ( ) > = <int> ) return buffer . getDouble ( ) ; else return Double . longBitsToDouble ( readPrimitiveSlowly ( <int> ) ) ; } @Override public String readLine ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } @Override public String readUTF ( ) throws IOException { return DataInputStream . readUTF ( this ) ; } @Override public int read ( ) throws IOException { try { return readUnsignedByte ( ) ; } catch ( EOFException ex ) { return - <int> ; } } @Override public void reset ( ) throws IOException { throw new IOException ( <str> ) ; } @Override public boolean markSupported ( ) { return false ; } } 
