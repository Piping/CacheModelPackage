package org . elasticsearch . update ; import org . elasticsearch . ElasticsearchTimeoutException ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . admin . indices . alias . Alias ; import org . elasticsearch . action . delete . DeleteRequest ; import org . elasticsearch . action . delete . DeleteResponse ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . action . update . UpdateRequest ; import org . elasticsearch . action . update . UpdateRequestBuilder ; import org . elasticsearch . action . update . UpdateResponse ; import org . elasticsearch . client . transport . NoNodeAvailableException ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . engine . DocumentMissingException ; import org . elasticsearch . index . engine . VersionConflictEngineException ; import org . elasticsearch . index . shard . MergePolicyConfig ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . script . CompiledScript ; import org . elasticsearch . script . ExecutableScript ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptEngineService ; import org . elasticsearch . script . ScriptModule ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . script . SearchScript ; import org . elasticsearch . search . lookup . SearchLookup ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . concurrent . CopyOnWriteArrayList ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Semaphore ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertThrows ; import static org . hamcrest . Matchers . allOf ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . Matchers . notNullValue ; import static org . hamcrest . Matchers . nullValue ; public class UpdateIT extends ESIntegTestCase { public static class PutFieldValuesScriptPlugin extends Plugin { public PutFieldValuesScriptPlugin ( ) { } @Override public String name ( ) { return PutFieldValuesScriptEngine . NAME ; } @Override public String description ( ) { return <str> + UpdateIT . class ; } public void onModule ( ScriptModule module ) { module . addScriptEngine ( PutFieldValuesScriptEngine . class ) ; } } public static class PutFieldValuesScriptEngine implements ScriptEngineService { public static final String NAME = <str> ; @Override public void close ( ) throws IOException { } @Override public String [ ] types ( ) { return new String [ ] { NAME } ; } @Override public String [ ] extensions ( ) { return types ( ) ; } @Override public boolean sandboxed ( ) { return true ; } @Override public Object compile ( String script ) { return new Object ( ) ; } @Override public ExecutableScript executable ( CompiledScript compiledScript , Map < String , Object > originalParams ) { return new ExecutableScript ( ) { Map < String , Object > vars = new HashMap < > ( ) ; @Override public void setNextVar ( String name , Object value ) { vars . put ( name , value ) ; } @Override public Object run ( ) { Map < String , Object > ctx = ( Map < String , Object > ) vars . get ( <str> ) ; assertNotNull ( ctx ) ; Map < String , Object > params = new HashMap < > ( originalParams ) ; Map < String , Object > newCtx = ( Map < String , Object > ) params . remove ( <str> ) ; if ( newCtx ! = null ) { assertFalse ( newCtx . containsKey ( <str> ) ) ; ctx . putAll ( newCtx ) ; } Map < String , Object > source = ( Map < String , Object > ) ctx . get ( <str> ) ; source . putAll ( params ) ; return ctx ; } @Override public Object unwrap ( Object value ) { return value ; } } ; } @Override public SearchScript search ( CompiledScript compiledScript , SearchLookup lookup , Map < String , Object > vars ) { throw new UnsupportedOperationException ( ) ; } @Override public void scriptRemoved ( CompiledScript script ) { } } public static class FieldIncrementScriptPlugin extends Plugin { public FieldIncrementScriptPlugin ( ) { } @Override public String name ( ) { return FieldIncrementScriptEngine . NAME ; } @Override public String description ( ) { return <str> + UpdateIT . class ; } public void onModule ( ScriptModule module ) { module . addScriptEngine ( FieldIncrementScriptEngine . class ) ; } } public static class FieldIncrementScriptEngine implements ScriptEngineService { public static final String NAME = <str> ; @Override public void close ( ) throws IOException { } @Override public String [ ] types ( ) { return new String [ ] { NAME } ; } @Override public String [ ] extensions ( ) { return types ( ) ; } @Override public boolean sandboxed ( ) { return true ; } @Override public Object compile ( String script ) { return script ; } @Override public ExecutableScript executable ( CompiledScript compiledScript , Map < String , Object > params ) { final String field = ( String ) compiledScript . compiled ( ) ; return new ExecutableScript ( ) { Map < String , Object > vars = new HashMap < > ( ) ; @Override public void setNextVar ( String name , Object value ) { vars . put ( name , value ) ; } @Override public Object run ( ) { Map < String , Object > ctx = ( Map < String , Object > ) vars . get ( <str> ) ; assertNotNull ( ctx ) ; Map < String , Object > source = ( Map < String , Object > ) ctx . get ( <str> ) ; Number currentValue = ( Number ) source . get ( field ) ; Number inc = params = = null ? <int> : ( Number ) params . getOrDefault ( <str> , <int> ) ; source . put ( field , currentValue . longValue ( ) + inc . longValue ( ) ) ; return ctx ; } @Override public Object unwrap ( Object value ) { return value ; } } ; } @Override public SearchScript search ( CompiledScript compiledScript , SearchLookup lookup , Map < String , Object > vars ) { throw new UnsupportedOperationException ( ) ; } @Override public void scriptRemoved ( CompiledScript script ) { } } public static class ScriptedUpsertScriptPlugin extends Plugin { public ScriptedUpsertScriptPlugin ( ) { } @Override public String name ( ) { return ScriptedUpsertScriptEngine . NAME ; } @Override public String description ( ) { return <str> + UpdateIT . class + <str> ; } public void onModule ( ScriptModule module ) { module . addScriptEngine ( ScriptedUpsertScriptEngine . class ) ; } } public static class ScriptedUpsertScriptEngine implements ScriptEngineService { public static final String NAME = <str> ; @Override public void close ( ) throws IOException { } @Override public String [ ] types ( ) { return new String [ ] { NAME } ; } @Override public String [ ] extensions ( ) { return types ( ) ; } @Override public boolean sandboxed ( ) { return true ; } @Override public Object compile ( String script ) { return new Object ( ) ; } @Override public ExecutableScript executable ( CompiledScript compiledScript , Map < String , Object > params ) { return new ExecutableScript ( ) { Map < String , Object > vars = new HashMap < > ( ) ; @Override public void setNextVar ( String name , Object value ) { vars . put ( name , value ) ; } @Override public Object run ( ) { Map < String , Object > ctx = ( Map < String , Object > ) vars . get ( <str> ) ; assertNotNull ( ctx ) ; Map < String , Object > source = ( Map < String , Object > ) ctx . get ( <str> ) ; Number payment = ( Number ) params . get ( <str> ) ; Number oldBalance = ( Number ) source . get ( <str> ) ; int deduction = <str> . equals ( ctx . get ( <str> ) ) ? payment . intValue ( ) / <int> : payment . intValue ( ) ; source . put ( <str> , oldBalance . intValue ( ) - deduction ) ; return ctx ; } @Override public Object unwrap ( Object value ) { return value ; } } ; } @Override public SearchScript search ( CompiledScript compiledScript , SearchLookup lookup , Map < String , Object > vars ) { throw new UnsupportedOperationException ( ) ; } @Override public void scriptRemoved ( CompiledScript script ) { } } public static class ExtractContextInSourceScriptPlugin extends Plugin { public ExtractContextInSourceScriptPlugin ( ) { } @Override public String name ( ) { return ExtractContextInSourceScriptEngine . NAME ; } @Override public String description ( ) { return <str> + UpdateIT . class ; } public void onModule ( ScriptModule module ) { module . addScriptEngine ( ExtractContextInSourceScriptEngine . class ) ; } } public static class ExtractContextInSourceScriptEngine implements ScriptEngineService { public static final String NAME = <str> ; @Override public void close ( ) throws IOException { } @Override public String [ ] types ( ) { return new String [ ] { NAME } ; } @Override public String [ ] extensions ( ) { return types ( ) ; } @Override public boolean sandboxed ( ) { return true ; } @Override public Object compile ( String script ) { return new Object ( ) ; } @Override public ExecutableScript executable ( CompiledScript compiledScript , Map < String , Object > params ) { return new ExecutableScript ( ) { Map < String , Object > vars = new HashMap < > ( ) ; @Override public void setNextVar ( String name , Object value ) { vars . put ( name , value ) ; } @Override public Object run ( ) { Map < String , Object > ctx = ( Map < String , Object > ) vars . get ( <str> ) ; assertNotNull ( ctx ) ; Map < String , Object > source = ( Map < String , Object > ) ctx . get ( <str> ) ; Map < String , Object > ctxWithoutSource = new HashMap < > ( ctx ) ; ctxWithoutSource . remove ( <str> ) ; source . put ( <str> , ctxWithoutSource ) ; return ctx ; } @Override public Object unwrap ( Object value ) { return value ; } } ; } @Override public SearchScript search ( CompiledScript compiledScript , SearchLookup lookup , Map < String , Object > vars ) { throw new UnsupportedOperationException ( ) ; } @Override public void scriptRemoved ( CompiledScript script ) { } } @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return Arrays . asList ( PutFieldValuesScriptPlugin . class , FieldIncrementScriptPlugin . class , ScriptedUpsertScriptPlugin . class , ExtractContextInSourceScriptPlugin . class ) ; } private void createTestIndex ( ) throws Exception { logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> ) . addAlias ( new Alias ( <str> ) ) . addMapping ( <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; } public void testUpsert ( ) throws Exception { createTestIndex ( ) ; ensureGreen ( ) ; UpdateResponse updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setUpsert ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . execute ( ) . actionGet ( ) ; assertTrue ( updateResponse . isCreated ( ) ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setUpsert ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . execute ( ) . actionGet ( ) ; assertFalse ( updateResponse . isCreated ( ) ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } } public void testScriptedUpsert ( ) throws Exception { createTestIndex ( ) ; ensureGreen ( ) ; int openingBalance = <int> ; Map < String , Object > params = new HashMap < > ( ) ; params . put ( <str> , <int> ) ; UpdateResponse updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setUpsert ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , openingBalance ) . endObject ( ) ) . setScriptedUpsert ( true ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , params ) ) . execute ( ) . actionGet ( ) ; assertTrue ( updateResponse . isCreated ( ) ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setUpsert ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , openingBalance ) . endObject ( ) ) . setScriptedUpsert ( true ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , params ) ) . execute ( ) . actionGet ( ) ; assertFalse ( updateResponse . isCreated ( ) ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } } public void testUpsertDoc ( ) throws Exception { createTestIndex ( ) ; ensureGreen ( ) ; UpdateResponse updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setDoc ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . setDocAsUpsert ( true ) . setFields ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) , notNullValue ( ) ) ; assertThat ( updateResponse . getGetResult ( ) . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } public void testNotUpsertDoc ( ) throws Exception { createTestIndex ( ) ; ensureGreen ( ) ; assertThrows ( client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setDoc ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . setDocAsUpsert ( false ) . setFields ( <str> ) . execute ( ) , DocumentMissingException . class ) ; } public void testUpsertFields ( ) throws Exception { createTestIndex ( ) ; ensureGreen ( ) ; UpdateResponse updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setUpsert ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setFields ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) , notNullValue ( ) ) ; assertThat ( updateResponse . getGetResult ( ) . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) . sourceAsMap ( ) . get ( <str> ) , nullValue ( ) ) ; updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setUpsert ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setFields ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) , notNullValue ( ) ) ; assertThat ( updateResponse . getGetResult ( ) . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } public void testVersionedUpdate ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addAlias ( new Alias ( <str> ) ) ) ; ensureGreen ( ) ; index ( <str> , <str> , <str> , <str> , <str> ) ; assertThrows ( client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setVersion ( <int> ) . execute ( ) , VersionConflictEngineException . class ) ; client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setVersion ( <int> ) . get ( ) ; assertThat ( client ( ) . prepareGet ( <str> , <str> , <str> ) . get ( ) . getVersion ( ) , equalTo ( <int> ) ) ; client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setVersion ( <int> ) . get ( ) ; assertThat ( client ( ) . prepareGet ( <str> , <str> , <str> ) . get ( ) . getVersion ( ) , equalTo ( <int> ) ) ; client ( ) . prepareDelete ( <str> , <str> , <str> ) . get ( ) ; assertThrows ( client ( ) . prepareUpdate ( <str> , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setVersion ( <int> ) . execute ( ) , DocumentMissingException . class ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . get ( ) ; assertThrows ( client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setVersion ( <int> ) . setVersionType ( VersionType . EXTERNAL ) . execute ( ) , ActionRequestValidationException . class ) ; client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setVersion ( <int> ) . setVersionType ( VersionType . FORCE ) . get ( ) ; GetResponse get = get ( <str> , <str> , <str> ) ; assertThat ( get . getVersion ( ) , equalTo ( <int> ) ) ; assertThat ( ( String ) get . getSource ( ) . get ( <str> ) , equalTo ( <str> ) ) ; client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setVersion ( <int> ) . setUpsert ( <str> ) . get ( ) ; get = get ( <str> , <str> , <str> ) ; assertThat ( get . getVersion ( ) , equalTo ( <int> ) ) ; assertThat ( ( String ) get . getSource ( ) . get ( <str> ) , equalTo ( <str> ) ) ; assertThrows ( client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setVersion ( <int> ) . setRetryOnConflict ( <int> ) , ActionRequestValidationException . class ) ; } public void testIndexAutoCreation ( ) throws Exception { UpdateResponse updateResponse = client ( ) . prepareUpdate ( <str> , <str> , <str> ) . setUpsert ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , <str> ) ) ) . setFields ( <str> ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) , notNullValue ( ) ) ; assertThat ( updateResponse . getGetResult ( ) . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) . sourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) . sourceAsMap ( ) . get ( <str> ) , nullValue ( ) ) ; } public void testUpdate ( ) throws Exception { createTestIndex ( ) ; ensureGreen ( ) ; try { client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . execute ( ) . actionGet ( ) ; fail ( ) ; } catch ( DocumentMissingException e ) { } client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . execute ( ) . actionGet ( ) ; UpdateResponse updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertFalse ( updateResponse . isCreated ( ) ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } Map < String , Object > params = new HashMap < > ( ) ; params . put ( <str> , <int> ) ; updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , params ) ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertFalse ( updateResponse . isCreated ( ) ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , Collections . singletonMap ( <str> , <str> ) ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertFalse ( updateResponse . isCreated ( ) ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , Collections . singletonMap ( <str> , <str> ) ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getVersion ( ) , equalTo ( <int> ) ) ; assertFalse ( updateResponse . isCreated ( ) ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . isExists ( ) , equalTo ( false ) ) ; } client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . setTTL ( <int> ) . setRefresh ( true ) . execute ( ) . actionGet ( ) ; GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . setFields ( <str> ) . execute ( ) . actionGet ( ) ; long ttl = ( ( Number ) getResponse . getField ( <str> ) . getValue ( ) ) . longValue ( ) ; assertThat ( ttl , greaterThan ( <int> L ) ) ; client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . execute ( ) . actionGet ( ) ; getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . setFields ( <str> ) . execute ( ) . actionGet ( ) ; ttl = ( ( Number ) getResponse . getField ( <str> ) . getValue ( ) ) . longValue ( ) ; assertThat ( ttl , greaterThan ( <int> L ) ) ; client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , Collections . singletonMap ( <str> , <int> ) ) ) ) . execute ( ) . actionGet ( ) ; getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . setFields ( <str> ) . execute ( ) . actionGet ( ) ; ttl = ( ( Number ) getResponse . getField ( <str> ) . getValue ( ) ) . longValue ( ) ; assertThat ( ttl , greaterThan ( <int> L ) ) ; assertThat ( ttl , lessThanOrEqualTo ( <int> ) ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . setRefresh ( true ) . execute ( ) . actionGet ( ) ; client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , Collections . singletonMap ( <str> , Collections . singletonMap ( <str> , <str> ) ) ) ) . execute ( ) . actionGet ( ) ; getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . setFields ( <str> ) . execute ( ) . actionGet ( ) ; long timestamp = ( ( Number ) getResponse . getField ( <str> ) . getValue ( ) ) . longValue ( ) ; assertThat ( timestamp , equalTo ( <int> ) ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . execute ( ) . actionGet ( ) ; updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . setFields ( <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( updateResponse . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) , notNullValue ( ) ) ; assertThat ( updateResponse . getGetResult ( ) . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( updateResponse . getGetResult ( ) . sourceRef ( ) , notNullValue ( ) ) ; assertThat ( updateResponse . getGetResult ( ) . field ( <str> ) . getValue ( ) , notNullValue ( ) ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <int> ) . execute ( ) . actionGet ( ) ; updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setDoc ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setDoc ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; assertThat ( getResponse . getSourceAsMap ( ) . get ( <str> ) . toString ( ) , equalTo ( <str> ) ) ; } Map < String , Object > testMap = new HashMap < > ( ) ; Map < String , Object > testMap2 = new HashMap < > ( ) ; Map < String , Object > testMap3 = new HashMap < > ( ) ; testMap3 . put ( <str> , testMap ) ; testMap3 . put ( <str> , <int> ) ; testMap2 . put ( <str> , <int> ) ; testMap . put ( <str> , testMap2 ) ; testMap . put ( <str> , <int> ) ; client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , testMap ) . execute ( ) . actionGet ( ) ; updateResponse = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setDoc ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , testMap3 ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; Map map1 = ( Map ) getResponse . getSourceAsMap ( ) . get ( <str> ) ; assertThat ( map1 . size ( ) , equalTo ( <int> ) ) ; assertThat ( map1 . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( map1 . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( map1 . containsKey ( <str> ) , equalTo ( true ) ) ; Map map2 = ( Map ) map1 . get ( <str> ) ; assertThat ( map2 . size ( ) , equalTo ( <int> ) ) ; assertThat ( map2 . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( map2 . containsKey ( <str> ) , equalTo ( true ) ) ; assertThat ( map2 . containsKey ( <str> ) , equalTo ( true ) ) ; } } public void testUpdateRequestWithBothScriptAndDoc ( ) throws Exception { createTestIndex ( ) ; ensureGreen ( ) ; try { client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setDoc ( XContentFactory . jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( ActionRequestValidationException e ) { assertThat ( e . validationErrors ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( e . validationErrors ( ) . get ( <int> ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testUpdateRequestWithScriptAndShouldUpsertDoc ( ) throws Exception { createTestIndex ( ) ; ensureGreen ( ) ; try { client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . setDocAsUpsert ( true ) . execute ( ) . actionGet ( ) ; fail ( <str> ) ; } catch ( ActionRequestValidationException e ) { assertThat ( e . validationErrors ( ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( e . validationErrors ( ) . get ( <int> ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } public void testContextVariables ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addAlias ( new Alias ( <str> ) ) . addMapping ( <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) ) . addMapping ( <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) ) ) ; ensureGreen ( ) ; long timestamp = System . currentTimeMillis ( ) ; client ( ) . prepareIndex ( ) . setIndex ( <str> ) . setType ( <str> ) . setId ( <str> ) . setTimestamp ( String . valueOf ( timestamp - <int> ) ) . setSource ( <str> , <int> , <str> , <str> ) . execute ( ) . actionGet ( ) ; long ttl = <int> ; client ( ) . prepareIndex ( ) . setIndex ( <str> ) . setType ( <str> ) . setId ( <str> ) . setParent ( <str> ) . setRouting ( <str> ) . setTimestamp ( String . valueOf ( timestamp ) ) . setTTL ( ttl ) . setSource ( <str> , <int> , <str> , <str> ) . execute ( ) . actionGet ( ) ; UpdateResponse updateResponse = client ( ) . prepareUpdate ( <str> , <str> , <str> ) . setRouting ( <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . execute ( ) . actionGet ( ) ; assertEquals ( <int> , updateResponse . getVersion ( ) ) ; GetResponse getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . setRouting ( <str> ) . execute ( ) . actionGet ( ) ; Map < String , Object > updateContext = ( Map < String , Object > ) getResponse . getSourceAsMap ( ) . get ( <str> ) ; assertEquals ( <str> , updateContext . get ( <str> ) ) ; assertEquals ( <str> , updateContext . get ( <str> ) ) ; assertEquals ( <str> , updateContext . get ( <str> ) ) ; assertEquals ( <int> , updateContext . get ( <str> ) ) ; assertEquals ( <str> , updateContext . get ( <str> ) ) ; assertEquals ( <str> , updateContext . get ( <str> ) ) ; assertThat ( ( ( Integer ) updateContext . get ( <str> ) ) . longValue ( ) , allOf ( greaterThanOrEqualTo ( ttl - <int> ) , lessThanOrEqualTo ( ttl ) ) ) ; updateResponse = client ( ) . prepareUpdate ( <str> , <str> , <str> ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . execute ( ) . actionGet ( ) ; assertEquals ( <int> , updateResponse . getVersion ( ) ) ; getResponse = client ( ) . prepareGet ( <str> , <str> , <str> ) . execute ( ) . actionGet ( ) ; updateContext = ( Map < String , Object > ) getResponse . getSourceAsMap ( ) . get ( <str> ) ; assertEquals ( <str> , updateContext . get ( <str> ) ) ; assertEquals ( <str> , updateContext . get ( <str> ) ) ; assertEquals ( <str> , updateContext . get ( <str> ) ) ; assertEquals ( <int> , updateContext . get ( <str> ) ) ; assertNull ( updateContext . get ( <str> ) ) ; assertNull ( updateContext . get ( <str> ) ) ; assertNull ( updateContext . get ( <str> ) ) ; } public void testConcurrentUpdateWithRetryOnConflict ( ) throws Exception { final boolean useBulkApi = randomBoolean ( ) ; createTestIndex ( ) ; ensureGreen ( ) ; int numberOfThreads = scaledRandomIntBetween ( <int> , <int> ) ; final CountDownLatch latch = new CountDownLatch ( numberOfThreads ) ; final CountDownLatch startLatch = new CountDownLatch ( <int> ) ; final int numberOfUpdatesPerThread = scaledRandomIntBetween ( <int> , <int> ) ; final List < Throwable > failures = new CopyOnWriteArrayList < > ( ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { Runnable r = new Runnable ( ) { @Override public void run ( ) { try { startLatch . await ( ) ; for ( int i = <int> ; i < numberOfUpdatesPerThread ; i + + ) { if ( i % <int> = = <int> ) { logger . debug ( <str> , Thread . currentThread ( ) . getName ( ) , i , numberOfUpdatesPerThread ) ; } if ( useBulkApi ) { UpdateRequestBuilder updateRequestBuilder = client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , Integer . toString ( i ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . setRetryOnConflict ( Integer . MAX_VALUE ) . setUpsert ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) ; client ( ) . prepareBulk ( ) . add ( updateRequestBuilder ) . execute ( ) . actionGet ( ) ; } else { client ( ) . prepareUpdate ( indexOrAlias ( ) , <str> , Integer . toString ( i ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . setRetryOnConflict ( Integer . MAX_VALUE ) . setUpsert ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; } } logger . info ( <str> , Thread . currentThread ( ) . getName ( ) , numberOfUpdatesPerThread ) ; } catch ( InterruptedException e ) { logger . warn ( <str> , Thread . currentThread ( ) . getName ( ) ) ; failures . add ( e ) ; Thread . currentThread ( ) . interrupt ( ) ; } catch ( Throwable e ) { failures . add ( e ) ; } finally { latch . countDown ( ) ; } } } ; Thread updater = new Thread ( r ) ; updater . setName ( <str> + i ) ; updater . start ( ) ; } startLatch . countDown ( ) ; latch . await ( ) ; for ( Throwable throwable : failures ) { logger . info ( <str> , throwable ) ; } assertThat ( failures . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < numberOfUpdatesPerThread ; i + + ) { GetResponse response = client ( ) . prepareGet ( <str> , <str> , Integer . toString ( i ) ) . execute ( ) . actionGet ( ) ; assertThat ( response . getId ( ) , equalTo ( Integer . toString ( i ) ) ) ; assertThat ( response . isExists ( ) , equalTo ( true ) ) ; assertThat ( response . getVersion ( ) , equalTo ( ( long ) numberOfThreads ) ) ; assertThat ( ( Integer ) response . getSource ( ) . get ( <str> ) , equalTo ( numberOfThreads ) ) ; } } public void testStressUpdateDeleteConcurrency ( ) throws Exception { assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) ) . setSettings ( Settings . builder ( ) . put ( MergePolicyConfig . INDEX_MERGE_ENABLED , false ) ) ) ; ensureGreen ( ) ; final int numberOfThreads = scaledRandomIntBetween ( <int> , <int> ) ; final int numberOfIdsPerThread = scaledRandomIntBetween ( <int> , <int> ) ; final int numberOfUpdatesPerId = scaledRandomIntBetween ( <int> , <int> ) ; final int retryOnConflict = randomIntBetween ( <int> , <int> ) ; final CountDownLatch latch = new CountDownLatch ( numberOfThreads ) ; final CountDownLatch startLatch = new CountDownLatch ( <int> ) ; final List < Throwable > failures = new CopyOnWriteArrayList < > ( ) ; final class UpdateThread extends Thread { final Map < Integer , Integer > failedMap = new HashMap < > ( ) ; final int numberOfIds ; final int updatesPerId ; final int maxUpdateRequests = numberOfIdsPerThread * numberOfUpdatesPerId ; final int maxDeleteRequests = numberOfIdsPerThread * numberOfUpdatesPerId ; private final Semaphore updateRequestsOutstanding = new Semaphore ( maxUpdateRequests ) ; private final Semaphore deleteRequestsOutstanding = new Semaphore ( maxDeleteRequests ) ; public UpdateThread ( int numberOfIds , int updatesPerId ) { this . numberOfIds = numberOfIds ; this . updatesPerId = updatesPerId ; } final class UpdateListener implements ActionListener < UpdateResponse > { int id ; public UpdateListener ( int id ) { this . id = id ; } @Override public void onResponse ( UpdateResponse updateResponse ) { updateRequestsOutstanding . release ( <int> ) ; } @Override public void onFailure ( Throwable e ) { synchronized ( failedMap ) { incrementMapValue ( id , failedMap ) ; } updateRequestsOutstanding . release ( <int> ) ; } } final class DeleteListener implements ActionListener < DeleteResponse > { int id ; public DeleteListener ( int id ) { this . id = id ; } @Override public void onResponse ( DeleteResponse deleteResponse ) { deleteRequestsOutstanding . release ( <int> ) ; } @Override public void onFailure ( Throwable e ) { synchronized ( failedMap ) { incrementMapValue ( id , failedMap ) ; } deleteRequestsOutstanding . release ( <int> ) ; } } @Override public void run ( ) { try { startLatch . await ( ) ; boolean hasWaitedForNoNode = false ; for ( int j = <int> ; j < numberOfIds ; j + + ) { for ( int k = <int> ; k < numberOfUpdatesPerId ; + + k ) { updateRequestsOutstanding . acquire ( ) ; try { UpdateRequest ur = client ( ) . prepareUpdate ( <str> , <str> , Integer . toString ( j ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . setRetryOnConflict ( retryOnConflict ) . setUpsert ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . request ( ) ; client ( ) . update ( ur , new UpdateListener ( j ) ) ; } catch ( NoNodeAvailableException nne ) { updateRequestsOutstanding . release ( ) ; synchronized ( failedMap ) { incrementMapValue ( j , failedMap ) ; } if ( hasWaitedForNoNode ) { throw nne ; } logger . warn ( <str> ) ; hasWaitedForNoNode = true ; Thread . sleep ( <int> ) ; } try { deleteRequestsOutstanding . acquire ( ) ; DeleteRequest dr = client ( ) . prepareDelete ( <str> , <str> , Integer . toString ( j ) ) . request ( ) ; client ( ) . delete ( dr , new DeleteListener ( j ) ) ; } catch ( NoNodeAvailableException nne ) { deleteRequestsOutstanding . release ( ) ; synchronized ( failedMap ) { incrementMapValue ( j , failedMap ) ; } if ( hasWaitedForNoNode ) { throw nne ; } logger . warn ( <str> ) ; hasWaitedForNoNode = true ; Thread . sleep ( <int> ) ; } } } } catch ( Throwable e ) { logger . error ( <str> , e ) ; failures . add ( e ) ; } finally { try { waitForOutstandingRequests ( TimeValue . timeValueSeconds ( <int> ) , updateRequestsOutstanding , maxUpdateRequests , <str> ) ; waitForOutstandingRequests ( TimeValue . timeValueSeconds ( <int> ) , deleteRequestsOutstanding , maxDeleteRequests , <str> ) ; } catch ( ElasticsearchTimeoutException ete ) { failures . add ( ete ) ; } latch . countDown ( ) ; } } private void incrementMapValue ( int j , Map < Integer , Integer > map ) { if ( ! map . containsKey ( j ) ) { map . put ( j , <int> ) ; } map . put ( j , map . get ( j ) + <int> ) ; } private void waitForOutstandingRequests ( TimeValue timeOut , Semaphore requestsOutstanding , int maxRequests , String name ) { long start = System . currentTimeMillis ( ) ; do { long msRemaining = timeOut . getMillis ( ) - ( System . currentTimeMillis ( ) - start ) ; logger . info ( <str> , name , maxRequests , msRemaining , requestsOutstanding . availablePermits ( ) ) ; try { requestsOutstanding . tryAcquire ( maxRequests , msRemaining , TimeUnit . MILLISECONDS ) ; return ; } catch ( InterruptedException ie ) { } } while ( ( System . currentTimeMillis ( ) - start ) < timeOut . getMillis ( ) ) ; throw new ElasticsearchTimeoutException ( <str> + timeOut + <str> + name + <str> ) ; } } final List < UpdateThread > threads = new ArrayList < > ( ) ; for ( int i = <int> ; i < numberOfThreads ; i + + ) { UpdateThread ut = new UpdateThread ( numberOfIdsPerThread , numberOfUpdatesPerId ) ; ut . start ( ) ; threads . add ( ut ) ; } startLatch . countDown ( ) ; latch . await ( ) ; for ( UpdateThread ut : threads ) { ut . join ( ) ; } for ( Throwable throwable : failures ) { logger . info ( <str> , throwable ) ; } assertThat ( failures . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < numberOfIdsPerThread ; + + i ) { UpdateResponse ur = client ( ) . prepareUpdate ( <str> , <str> , Integer . toString ( i ) ) . setScript ( new Script ( <str> , ScriptService . ScriptType . INLINE , <str> , null ) ) . setRetryOnConflict ( Integer . MAX_VALUE ) . setUpsert ( jsonBuilder ( ) . startObject ( ) . field ( <str> , <int> ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; } refresh ( ) ; for ( int i = <int> ; i < numberOfIdsPerThread ; + + i ) { int totalFailures = <int> ; GetResponse response = client ( ) . prepareGet ( <str> , <str> , Integer . toString ( i ) ) . execute ( ) . actionGet ( ) ; if ( response . isExists ( ) ) { assertThat ( response . getId ( ) , equalTo ( Integer . toString ( i ) ) ) ; int expectedVersion = ( numberOfThreads * numberOfUpdatesPerId * <int> ) + <int> ; for ( UpdateThread ut : threads ) { if ( ut . failedMap . containsKey ( i ) ) { totalFailures + = ut . failedMap . get ( i ) ; } } expectedVersion - = totalFailures ; logger . error ( <str> , response . getVersion ( ) , expectedVersion , totalFailures ) ; assertThat ( response . getVersion ( ) , equalTo ( ( long ) expectedVersion ) ) ; assertThat ( response . getVersion ( ) + totalFailures , equalTo ( ( long ) ( ( numberOfUpdatesPerId * numberOfThreads * <int> ) + <int> ) ) ) ; } } } private static String indexOrAlias ( ) { return randomBoolean ( ) ? <str> : <str> ; } } 
