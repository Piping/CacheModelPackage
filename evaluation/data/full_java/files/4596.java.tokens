package org . eclipse . debug . internal . ui . views . memory . renderings ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . IDebugEventSetListener ; import org . eclipse . jface . viewers . IStructuredContentProvider ; import org . eclipse . jface . viewers . StructuredViewer ; import org . eclipse . jface . viewers . Viewer ; import org . eclipse . swt . widgets . Control ; public abstract class BasicDebugViewContentProvider implements IStructuredContentProvider , IDebugEventSetListener { protected StructuredViewer fViewer ; protected boolean fDisposed = false ; @Override public void dispose ( ) { fDisposed = true ; } protected boolean isDisposed ( ) { return fDisposed ; } @Override public void inputChanged ( Viewer viewer , Object oldInput , Object newInput ) { fViewer = ( StructuredViewer ) viewer ; } protected void asyncExec ( Runnable r ) { if ( fViewer ! = null ) { Control ctrl = fViewer . getControl ( ) ; if ( ctrl ! = null & & ! ctrl . isDisposed ( ) ) { ctrl . getDisplay ( ) . asyncExec ( r ) ; } } } protected void syncExec ( Runnable r ) { if ( fViewer ! = null ) { Control ctrl = fViewer . getControl ( ) ; if ( ctrl ! = null & & ! ctrl . isDisposed ( ) ) { ctrl . getDisplay ( ) . syncExec ( r ) ; } } } protected void refresh ( ) { if ( fViewer ! = null ) { fViewer . refresh ( ) ; } } protected void refresh ( Object element ) { if ( fViewer ! = null ) { fViewer . refresh ( element ) ; } } public void handleDebugEvent ( final DebugEvent event ) { if ( fViewer = = null ) { return ; } Object element = event . getSource ( ) ; if ( element = = null ) { return ; } Runnable r = new Runnable ( ) { @Override public void run ( ) { if ( ! isDisposed ( ) ) { doHandleDebugEvent ( event ) ; } } } ; asyncExec ( r ) ; } @Override public void handleDebugEvents ( DebugEvent [ ] events ) { for ( int i = <int> ; i < events . length ; i + + ) handleDebugEvent ( events [ i ] ) ; } protected abstract void doHandleDebugEvent ( DebugEvent event ) ; } 
