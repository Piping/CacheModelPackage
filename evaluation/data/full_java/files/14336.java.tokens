package org . gradle . model . internal . inspect ; import net . jcip . annotations . NotThreadSafe ; import org . gradle . internal . BiAction ; import org . gradle . internal . Cast ; import org . gradle . model . InvalidModelRuleDeclarationException ; import org . gradle . model . internal . core . * ; import org . gradle . model . internal . core . rule . describe . ModelRuleDescriptor ; import org . gradle . model . internal . manage . schema . ModelSchema ; import org . gradle . model . internal . manage . schema . ModelSchemaStore ; import org . gradle . model . internal . manage . schema . ScalarValueSchema ; import org . gradle . model . internal . manage . schema . SpecializedMapSchema ; import org . gradle . model . internal . manage . schema . extract . InvalidManagedModelElementTypeException ; import org . gradle . model . internal . manage . schema . extract . SpecializedMapNodeInitializer ; import org . gradle . model . internal . type . ModelType ; import java . util . Collections ; import java . util . List ; import java . util . Map ; import static org . gradle . model . internal . core . NodeInitializerContext . forType ; @NotThreadSafe public class ManagedModelCreationRuleExtractor extends AbstractModelCreationRuleExtractor { private final ModelSchemaStore schemaStore ; public ManagedModelCreationRuleExtractor ( ModelSchemaStore schemaStore ) { this . schemaStore = schemaStore ; } public String getDescription ( ) { return String . format ( <str> , super . getDescription ( ) ) ; } @Override public boolean isSatisfiedBy ( MethodRuleDefinition < ? , ? > element ) { return super . isSatisfiedBy ( element ) & & element . getReturnType ( ) . equals ( ModelType . of ( Void . TYPE ) ) ; } @Override protected < T , S > void buildRegistration ( MethodRuleDefinition < T , S > ruleDefinition , final ModelPath modelPath , ModelRegistrations . Builder registration ) { List < ModelReference < ? > > references = ruleDefinition . getReferences ( ) ; if ( references . isEmpty ( ) ) { throw new InvalidModelRuleDeclarationException ( ruleDefinition . getDescriptor ( ) , <str> ) ; } ModelType < T > modelType = Cast . uncheckedCast ( references . get ( <int> ) . getType ( ) ) ; final ModelSchema < T > modelSchema = getModelSchema ( modelType , ruleDefinition ) ; if ( modelSchema instanceof ScalarValueSchema ) { throw new InvalidModelRuleDeclarationException ( ruleDefinition . getDescriptor ( ) , <str> ) ; } List < ModelReference < ? > > bindings = ruleDefinition . getReferences ( ) ; List < ModelReference < ? > > inputs = bindings . subList ( <int> , bindings . size ( ) ) ; final ModelRuleDescriptor descriptor = ruleDefinition . getDescriptor ( ) ; if ( modelSchema instanceof SpecializedMapSchema ) { registration . actions ( SpecializedMapNodeInitializer . getActions ( ModelReference . of ( modelPath ) , descriptor , ( SpecializedMapSchema < T , ? > ) modelSchema ) ) ; } else { registration . action ( ModelActionRole . Discover , Collections . singletonList ( ModelReference . of ( NodeInitializerRegistry . class ) ) , new BiAction < MutableModelNode , List < ModelView < ? > > > ( ) { @Override public void execute ( MutableModelNode node , List < ModelView < ? > > modelViews ) { NodeInitializerRegistry nodeInitializerRegistry = ( NodeInitializerRegistry ) modelViews . get ( <int> ) . getInstance ( ) ; NodeInitializer initializer = getNodeInitializer ( descriptor , modelSchema , nodeInitializerRegistry ) ; for ( Map . Entry < ModelActionRole , ModelAction < ? > > actionInRole : initializer . getActions ( ModelReference . of ( modelPath ) , descriptor ) . entries ( ) ) { ModelActionRole role = actionInRole . getKey ( ) ; ModelAction < ? > action = actionInRole . getValue ( ) ; node . applyToSelf ( role , action ) ; } } } ) ; } registration . action ( ModelActionRole . Initialize , InputUsingModelAction . of ( ModelReference . of ( modelPath , modelType ) , descriptor , inputs , new RuleMethodBackedMutationAction < T > ( ruleDefinition . getRuleInvoker ( ) ) ) ) ; } private static NodeInitializer getNodeInitializer ( ModelRuleDescriptor descriptor , ModelSchema < ? > modelSchema , NodeInitializerRegistry nodeInitializerRegistry ) { try { return nodeInitializerRegistry . getNodeInitializer ( forType ( modelSchema . getType ( ) ) ) ; } catch ( ModelTypeInitializationException e ) { throw new InvalidModelRuleDeclarationException ( descriptor , e ) ; } } private < T > ModelSchema < T > getModelSchema ( ModelType < T > managedType , MethodRuleDefinition < ? , ? > ruleDefinition ) { try { return schemaStore . getSchema ( managedType ) ; } catch ( InvalidManagedModelElementTypeException e ) { throw new InvalidModelRuleDeclarationException ( ruleDefinition . getDescriptor ( ) , e ) ; } } } 
