package org . apache . cassandra . io . util ; import java . io . IOException ; import java . io . OutputStream ; import java . nio . ByteBuffer ; import java . nio . channels . WritableByteChannel ; import org . apache . cassandra . config . Config ; import org . apache . cassandra . utils . ByteBufferUtil ; public abstract class DataOutputStreamPlus extends OutputStream implements DataOutputPlus { protected final WritableByteChannel channel ; protected DataOutputStreamPlus ( ) { this . channel = newDefaultChannel ( ) ; } protected DataOutputStreamPlus ( WritableByteChannel channel ) { this . channel = channel ; } private static int MAX_BUFFER_SIZE = Integer . getInteger ( Config . PROPERTY_PREFIX + <str> , <int> ) ; protected static byte [ ] retrieveTemporaryBuffer ( int minSize ) { byte [ ] bytes = tempBuffer . get ( ) ; if ( bytes . length < Math . min ( minSize , MAX_BUFFER_SIZE ) ) { bytes = new byte [ Math . min ( MAX_BUFFER_SIZE , <int> * Integer . highestOneBit ( minSize ) ) ] ; tempBuffer . set ( bytes ) ; } return bytes ; } private static final ThreadLocal < byte [ ] > tempBuffer = new ThreadLocal < byte [ ] > ( ) { @Override public byte [ ] initialValue ( ) { return new byte [ <int> ] ; } } ; protected WritableByteChannel newDefaultChannel ( ) { return new WritableByteChannel ( ) { @Override public boolean isOpen ( ) { return true ; } @Override public void close ( ) throws IOException { } @Override public int write ( ByteBuffer src ) throws IOException { int toWrite = src . remaining ( ) ; if ( src . hasArray ( ) ) { DataOutputStreamPlus . this . write ( src . array ( ) , src . arrayOffset ( ) + src . position ( ) , src . remaining ( ) ) ; src . position ( src . limit ( ) ) ; return toWrite ; } if ( toWrite < <int> ) { int offset = src . position ( ) ; for ( int i = <int> ; i < toWrite ; i + + ) DataOutputStreamPlus . this . write ( src . get ( i + offset ) ) ; src . position ( src . limit ( ) ) ; return toWrite ; } byte [ ] buf = retrieveTemporaryBuffer ( toWrite ) ; int totalWritten = <int> ; while ( totalWritten < toWrite ) { int toWriteThisTime = Math . min ( buf . length , toWrite - totalWritten ) ; ByteBufferUtil . arrayCopy ( src , src . position ( ) + totalWritten , buf , <int> , toWriteThisTime ) ; DataOutputStreamPlus . this . write ( buf , <int> , toWriteThisTime ) ; totalWritten + = toWriteThisTime ; } src . position ( src . limit ( ) ) ; return totalWritten ; } } ; } } 
