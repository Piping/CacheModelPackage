package org . elasticsearch . common . geo . builders ; import com . spatial4j . core . context . jts . JtsSpatialContext ; import com . spatial4j . core . exception . InvalidShapeException ; import com . spatial4j . core . shape . Shape ; import com . spatial4j . core . shape . jts . JtsGeometry ; import com . vividsolutions . jts . geom . Coordinate ; import com . vividsolutions . jts . geom . Geometry ; import com . vividsolutions . jts . geom . GeometryFactory ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . action . support . ToXContentToBytes ; import org . elasticsearch . common . io . stream . NamedWriteable ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . ESLoggerFactory ; import org . elasticsearch . common . unit . DistanceUnit . Distance ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . mapper . geo . GeoShapeFieldMapper ; import java . io . IOException ; import java . util . * ; public abstract class ShapeBuilder extends ToXContentToBytes implements NamedWriteable < ShapeBuilder > { protected static final ESLogger LOGGER = ESLoggerFactory . getLogger ( ShapeBuilder . class . getName ( ) ) ; private static final boolean DEBUG ; static { boolean debug = false ; assert debug = true ; DEBUG = debug ; } public static final double DATELINE = <int> ; public static final JtsSpatialContext SPATIAL_CONTEXT = JtsSpatialContext . GEO ; public static final GeometryFactory FACTORY = SPATIAL_CONTEXT . getGeometryFactory ( ) ; protected final boolean wrapdateline = SPATIAL_CONTEXT . isGeo ( ) ; protected final boolean multiPolygonMayOverlap = false ; protected final boolean autoValidateJtsGeometry = true ; protected final boolean autoIndexJtsGeometry = true ; protected Orientation orientation = Orientation . RIGHT ; protected ShapeBuilder ( ) { } protected ShapeBuilder ( Orientation orientation ) { this . orientation = orientation ; } protected static Coordinate coordinate ( double longitude , double latitude ) { return new Coordinate ( longitude , latitude ) ; } protected JtsGeometry jtsGeometry ( Geometry geom ) { JtsGeometry jtsGeometry = new JtsGeometry ( geom , SPATIAL_CONTEXT , false , multiPolygonMayOverlap ) ; if ( autoValidateJtsGeometry ) jtsGeometry . validate ( ) ; if ( autoIndexJtsGeometry ) jtsGeometry . index ( ) ; return jtsGeometry ; } public abstract Shape build ( ) ; private static CoordinateNode parseCoordinates ( XContentParser parser ) throws IOException { XContentParser . Token token = parser . nextToken ( ) ; if ( token ! = XContentParser . Token . START_ARRAY & & token ! = XContentParser . Token . END_ARRAY & & token ! = XContentParser . Token . VALUE_NULL ) { double lon = parser . doubleValue ( ) ; token = parser . nextToken ( ) ; double lat = parser . doubleValue ( ) ; token = parser . nextToken ( ) ; while ( token = = XContentParser . Token . VALUE_NUMBER ) { token = parser . nextToken ( ) ; } return new CoordinateNode ( new Coordinate ( lon , lat ) ) ; } else if ( token = = XContentParser . Token . VALUE_NULL ) { throw new IllegalArgumentException ( <str> ) ; } List < CoordinateNode > nodes = new ArrayList < > ( ) ; while ( token ! = XContentParser . Token . END_ARRAY ) { nodes . add ( parseCoordinates ( parser ) ) ; token = parser . nextToken ( ) ; } return new CoordinateNode ( nodes ) ; } public static ShapeBuilder parse ( XContentParser parser ) throws IOException { return GeoShapeType . parse ( parser , null ) ; } public static ShapeBuilder parse ( XContentParser parser , GeoShapeFieldMapper geoDocMapper ) throws IOException { return GeoShapeType . parse ( parser , geoDocMapper ) ; } protected static XContentBuilder toXContent ( XContentBuilder builder , Coordinate coordinate ) throws IOException { return builder . startArray ( ) . value ( coordinate . x ) . value ( coordinate . y ) . endArray ( ) ; } protected static void writeCoordinateTo ( Coordinate coordinate , StreamOutput out ) throws IOException { out . writeDouble ( coordinate . x ) ; out . writeDouble ( coordinate . y ) ; } protected Coordinate readCoordinateFrom ( StreamInput in ) throws IOException { return new Coordinate ( in . readDouble ( ) , in . readDouble ( ) ) ; } public static Orientation orientationFromString ( String orientation ) { orientation = orientation . toLowerCase ( Locale . ROOT ) ; switch ( orientation ) { case <str> : case <str> : case <str> : return Orientation . RIGHT ; case <str> : case <str> : case <str> : return Orientation . LEFT ; default : throw new IllegalArgumentException ( <str> + orientation + <str> ) ; } } protected static Coordinate shift ( Coordinate coordinate , double dateline ) { if ( dateline = = <int> ) { return coordinate ; } else { return new Coordinate ( - <int> * dateline + coordinate . x , coordinate . y ) ; } } public abstract GeoShapeType type ( ) ; protected static final double intersection ( Coordinate p1 , Coordinate p2 , double dateline ) { if ( p1 . x = = p2 . x & & p1 . x ! = dateline ) { return Double . NaN ; } else if ( p1 . x = = p2 . x & & p1 . x = = dateline ) { return <float> ; } else { final double t = ( dateline - p1 . x ) / ( p2 . x - p1 . x ) ; if ( t > <int> | | t < = <int> ) { return Double . NaN ; } else { return t ; } } } protected static int intersections ( double dateline , Edge [ ] edges ) { int numIntersections = <int> ; assert ! Double . isNaN ( dateline ) ; for ( int i = <int> ; i < edges . length ; i + + ) { Coordinate p1 = edges [ i ] . coordinate ; Coordinate p2 = edges [ i ] . next . coordinate ; assert ! Double . isNaN ( p2 . x ) & & ! Double . isNaN ( p1 . x ) ; edges [ i ] . intersect = Edge . MAX_COORDINATE ; double position = intersection ( p1 , p2 , dateline ) ; if ( ! Double . isNaN ( position ) ) { edges [ i ] . intersection ( position ) ; numIntersections + + ; } } Arrays . sort ( edges , INTERSECTION_ORDER ) ; return numIntersections ; } protected static class CoordinateNode implements ToXContent { protected final Coordinate coordinate ; protected final List < CoordinateNode > children ; protected CoordinateNode ( Coordinate coordinate ) { this . coordinate = coordinate ; this . children = null ; } protected CoordinateNode ( List < CoordinateNode > children ) { this . children = children ; this . coordinate = null ; } protected boolean isEmpty ( ) { return ( coordinate = = null & & ( children = = null | | children . isEmpty ( ) ) ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { if ( children = = null ) { builder . startArray ( ) . value ( coordinate . x ) . value ( coordinate . y ) . endArray ( ) ; } else { builder . startArray ( ) ; for ( CoordinateNode child : children ) { child . toXContent ( builder , params ) ; } builder . endArray ( ) ; } return builder ; } } protected static final class Edge { Coordinate coordinate ; Edge next ; Coordinate intersect ; int component = - <int> ; public static final Coordinate MAX_COORDINATE = new Coordinate ( Double . POSITIVE_INFINITY , Double . POSITIVE_INFINITY ) ; protected Edge ( Coordinate coordinate , Edge next , Coordinate intersection ) { this . coordinate = coordinate ; this . setNext ( next ) ; this . intersect = intersection ; if ( next ! = null ) { this . component = next . component ; } } protected Edge ( Coordinate coordinate , Edge next ) { this ( coordinate , next , Edge . MAX_COORDINATE ) ; } protected void setNext ( Edge next ) { if ( next ! = null ) { if ( this . coordinate . equals ( next . coordinate ) ) { throw new InvalidShapeException ( <str> + this . coordinate ) ; } this . next = next ; } } protected Coordinate intersection ( double position ) { return intersect = position ( coordinate , next . coordinate , position ) ; } protected static Coordinate position ( Coordinate p1 , Coordinate p2 , double position ) { if ( position = = <int> ) { return p1 ; } else if ( position = = <int> ) { return p2 ; } else { final double x = p1 . x + position * ( p2 . x - p1 . x ) ; final double y = p1 . y + position * ( p2 . y - p1 . y ) ; return new Coordinate ( x , y ) ; } } @Override public String toString ( ) { return <str> + component + <str> + coordinate + <str> + <str> + intersect + <str> ; } } protected static final IntersectionOrder INTERSECTION_ORDER = new IntersectionOrder ( ) ; private static final class IntersectionOrder implements Comparator < Edge > { @Override public int compare ( Edge o1 , Edge o2 ) { return Double . compare ( o1 . intersect . y , o2 . intersect . y ) ; } } public static enum Orientation { LEFT , RIGHT ; public static final Orientation CLOCKWISE = Orientation . LEFT ; public static final Orientation COUNTER_CLOCKWISE = Orientation . RIGHT ; public static final Orientation CW = Orientation . LEFT ; public static final Orientation CCW = Orientation . RIGHT ; } public static final String FIELD_TYPE = <str> ; public static final String FIELD_COORDINATES = <str> ; public static final String FIELD_GEOMETRIES = <str> ; public static final String FIELD_ORIENTATION = <str> ; protected static final boolean debugEnabled ( ) { return LOGGER . isDebugEnabled ( ) | | DEBUG ; } public static enum GeoShapeType { POINT ( <str> ) , MULTIPOINT ( <str> ) , LINESTRING ( <str> ) , MULTILINESTRING ( <str> ) , POLYGON ( <str> ) , MULTIPOLYGON ( <str> ) , GEOMETRYCOLLECTION ( <str> ) , ENVELOPE ( <str> ) , CIRCLE ( <str> ) ; private final String shapename ; private GeoShapeType ( String shapename ) { this . shapename = shapename ; } protected String shapeName ( ) { return shapename ; } public static GeoShapeType forName ( String geoshapename ) { String typename = geoshapename . toLowerCase ( Locale . ROOT ) ; for ( GeoShapeType type : values ( ) ) { if ( type . shapename . equals ( typename ) ) { return type ; } } throw new IllegalArgumentException ( <str> + geoshapename + <str> ) ; } public static ShapeBuilder parse ( XContentParser parser ) throws IOException { return parse ( parser , null ) ; } public static ShapeBuilder parse ( XContentParser parser , GeoShapeFieldMapper shapeMapper ) throws IOException { if ( parser . currentToken ( ) = = XContentParser . Token . VALUE_NULL ) { return null ; } else if ( parser . currentToken ( ) ! = XContentParser . Token . START_OBJECT ) { throw new ElasticsearchParseException ( <str> ) ; } GeoShapeType shapeType = null ; Distance radius = null ; CoordinateNode node = null ; GeometryCollectionBuilder geometryCollections = null ; Orientation requestedOrientation = ( shapeMapper = = null ) ? Orientation . RIGHT : shapeMapper . fieldType ( ) . orientation ( ) ; boolean coerce = ( shapeMapper = = null ) ? GeoShapeFieldMapper . Defaults . COERCE . value ( ) : shapeMapper . coerce ( ) . value ( ) ; XContentParser . Token token ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { String fieldName = parser . currentName ( ) ; if ( FIELD_TYPE . equals ( fieldName ) ) { parser . nextToken ( ) ; shapeType = GeoShapeType . forName ( parser . text ( ) ) ; } else if ( FIELD_COORDINATES . equals ( fieldName ) ) { parser . nextToken ( ) ; node = parseCoordinates ( parser ) ; } else if ( FIELD_GEOMETRIES . equals ( fieldName ) ) { parser . nextToken ( ) ; geometryCollections = parseGeometries ( parser , shapeMapper ) ; } else if ( CircleBuilder . FIELD_RADIUS . equals ( fieldName ) ) { parser . nextToken ( ) ; radius = Distance . parseDistance ( parser . text ( ) ) ; } else if ( FIELD_ORIENTATION . equals ( fieldName ) ) { parser . nextToken ( ) ; requestedOrientation = orientationFromString ( parser . text ( ) ) ; } else { parser . nextToken ( ) ; parser . skipChildren ( ) ; } } } if ( shapeType = = null ) { throw new ElasticsearchParseException ( <str> ) ; } else if ( node = = null & & GeoShapeType . GEOMETRYCOLLECTION ! = shapeType ) { throw new ElasticsearchParseException ( <str> ) ; } else if ( geometryCollections = = null & & GeoShapeType . GEOMETRYCOLLECTION = = shapeType ) { throw new ElasticsearchParseException ( <str> ) ; } else if ( radius ! = null & & GeoShapeType . CIRCLE ! = shapeType ) { throw new ElasticsearchParseException ( <str> , CircleBuilder . FIELD_RADIUS , CircleBuilder . TYPE ) ; } switch ( shapeType ) { case POINT : return parsePoint ( node ) ; case MULTIPOINT : return parseMultiPoint ( node ) ; case LINESTRING : return parseLineString ( node ) ; case MULTILINESTRING : return parseMultiLine ( node ) ; case POLYGON : return parsePolygon ( node , requestedOrientation , coerce ) ; case MULTIPOLYGON : return parseMultiPolygon ( node , requestedOrientation , coerce ) ; case CIRCLE : return parseCircle ( node , radius ) ; case ENVELOPE : return parseEnvelope ( node , requestedOrientation ) ; case GEOMETRYCOLLECTION : return geometryCollections ; default : throw new ElasticsearchParseException ( <str> , shapeType ) ; } } protected static void validatePointNode ( CoordinateNode node ) { if ( node . isEmpty ( ) ) { throw new ElasticsearchParseException ( <str> ) ; } else if ( node . coordinate = = null ) { if ( node . children . isEmpty ( ) = = false ) { throw new ElasticsearchParseException ( <str> ) ; } } } protected static PointBuilder parsePoint ( CoordinateNode node ) { validatePointNode ( node ) ; return ShapeBuilders . newPoint ( node . coordinate ) ; } protected static CircleBuilder parseCircle ( CoordinateNode coordinates , Distance radius ) { return ShapeBuilders . newCircleBuilder ( ) . center ( coordinates . coordinate ) . radius ( radius ) ; } protected static EnvelopeBuilder parseEnvelope ( CoordinateNode coordinates , final Orientation orientation ) { if ( coordinates . children . size ( ) ! = <int> ) { throw new ElasticsearchParseException ( <str> + <str> , coordinates . children . size ( ) , GeoShapeType . ENVELOPE . shapename ) ; } Coordinate uL = coordinates . children . get ( <int> ) . coordinate ; Coordinate lR = coordinates . children . get ( <int> ) . coordinate ; if ( ( ( lR . x < uL . x ) | | ( uL . y < lR . y ) ) ) { Coordinate uLtmp = uL ; uL = new Coordinate ( Math . min ( uL . x , lR . x ) , Math . max ( uL . y , lR . y ) ) ; lR = new Coordinate ( Math . max ( uLtmp . x , lR . x ) , Math . min ( uLtmp . y , lR . y ) ) ; } return ShapeBuilders . newEnvelope ( orientation ) . topLeft ( uL ) . bottomRight ( lR ) ; } protected static void validateMultiPointNode ( CoordinateNode coordinates ) { if ( coordinates . children = = null | | coordinates . children . isEmpty ( ) ) { if ( coordinates . coordinate ! = null ) { throw new ElasticsearchParseException ( <str> + <str> ) ; } throw new ElasticsearchParseException ( <str> + <str> ) ; } else { for ( CoordinateNode point : coordinates . children ) { validatePointNode ( point ) ; } } } protected static MultiPointBuilder parseMultiPoint ( CoordinateNode coordinates ) { validateMultiPointNode ( coordinates ) ; MultiPointBuilder points = new MultiPointBuilder ( ) ; for ( CoordinateNode node : coordinates . children ) { points . point ( node . coordinate ) ; } return points ; } protected static LineStringBuilder parseLineString ( CoordinateNode coordinates ) { if ( coordinates . children . size ( ) < <int> ) { throw new ElasticsearchParseException ( <str> , coordinates . children . size ( ) ) ; } LineStringBuilder line = ShapeBuilders . newLineString ( ) ; for ( CoordinateNode node : coordinates . children ) { line . point ( node . coordinate ) ; } return line ; } protected static MultiLineStringBuilder parseMultiLine ( CoordinateNode coordinates ) { MultiLineStringBuilder multiline = ShapeBuilders . newMultiLinestring ( ) ; for ( CoordinateNode node : coordinates . children ) { multiline . linestring ( parseLineString ( node ) ) ; } return multiline ; } protected static LineStringBuilder parseLinearRing ( CoordinateNode coordinates , boolean coerce ) { if ( coordinates . children = = null ) { String error = <str> ; error + = ( coordinates . coordinate = = null ) ? <str> : <str> ; throw new ElasticsearchParseException ( error ) ; } int numValidPts ; if ( coordinates . children . size ( ) < ( numValidPts = ( coerce ) ? <int> : <int> ) ) { throw new ElasticsearchParseException ( <str> + numValidPts + <str> , coordinates . children . size ( ) ) ; } if ( ! coordinates . children . get ( <int> ) . coordinate . equals ( coordinates . children . get ( coordinates . children . size ( ) - <int> ) . coordinate ) ) { if ( coerce ) { coordinates . children . add ( coordinates . children . get ( <int> ) ) ; } else { throw new ElasticsearchParseException ( <str> ) ; } } return parseLineString ( coordinates ) ; } protected static PolygonBuilder parsePolygon ( CoordinateNode coordinates , final Orientation orientation , final boolean coerce ) { if ( coordinates . children = = null | | coordinates . children . isEmpty ( ) ) { throw new ElasticsearchParseException ( <str> ) ; } LineStringBuilder shell = parseLinearRing ( coordinates . children . get ( <int> ) , coerce ) ; PolygonBuilder polygon = new PolygonBuilder ( shell . points , orientation ) ; for ( int i = <int> ; i < coordinates . children . size ( ) ; i + + ) { polygon . hole ( parseLinearRing ( coordinates . children . get ( i ) , coerce ) ) ; } return polygon ; } protected static MultiPolygonBuilder parseMultiPolygon ( CoordinateNode coordinates , final Orientation orientation , final boolean coerce ) { MultiPolygonBuilder polygons = ShapeBuilders . newMultiPolygon ( orientation ) ; for ( CoordinateNode node : coordinates . children ) { polygons . polygon ( parsePolygon ( node , orientation , coerce ) ) ; } return polygons ; } protected static GeometryCollectionBuilder parseGeometries ( XContentParser parser , GeoShapeFieldMapper mapper ) throws IOException { if ( parser . currentToken ( ) ! = XContentParser . Token . START_ARRAY ) { throw new ElasticsearchParseException ( <str> ) ; } XContentParser . Token token = parser . nextToken ( ) ; GeometryCollectionBuilder geometryCollection = ShapeBuilders . newGeometryCollection ( ( mapper = = null ) ? Orientation . RIGHT : mapper . fieldType ( ) . orientation ( ) ) ; while ( token ! = XContentParser . Token . END_ARRAY ) { ShapeBuilder shapeBuilder = GeoShapeType . parse ( parser ) ; geometryCollection . shape ( shapeBuilder ) ; token = parser . nextToken ( ) ; } return geometryCollection ; } } @Override public String getWriteableName ( ) { return type ( ) . shapeName ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { } @Override public ShapeBuilder readFrom ( StreamInput in ) throws IOException { return null ; } } 
