package org . apache . cassandra . transport ; import java . nio . ByteBuffer ; import java . util . * ; import io . netty . buffer . Unpooled ; import io . netty . buffer . ByteBuf ; import org . junit . Test ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . serializers . CollectionSerializer ; import org . apache . cassandra . transport . Event . TopologyChange ; import org . apache . cassandra . transport . Event . SchemaChange ; import org . apache . cassandra . transport . Event . StatusChange ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; import static org . junit . Assert . assertEquals ; import static org . apache . cassandra . utils . ByteBufferUtil . bytes ; import static org . junit . Assert . assertNotSame ; public class SerDeserTest { @Test public void collectionSerDeserTest ( ) throws Exception { collectionSerDeserTest ( <int> ) ; collectionSerDeserTest ( <int> ) ; } public void collectionSerDeserTest ( int version ) throws Exception { ListType < ? > lt = ListType . getInstance ( Int32Type . instance , true ) ; List < Integer > l = Arrays . asList ( <int> , <int> , <int> , <int> ) ; List < ByteBuffer > lb = new ArrayList < > ( l . size ( ) ) ; for ( Integer i : l ) lb . add ( Int32Type . instance . decompose ( i ) ) ; assertEquals ( l , lt . getSerializer ( ) . deserializeForNativeProtocol ( CollectionSerializer . pack ( lb , lb . size ( ) , version ) , version ) ) ; SetType < ? > st = SetType . getInstance ( UTF8Type . instance , true ) ; Set < String > s = new LinkedHashSet < > ( ) ; s . addAll ( Arrays . asList ( <str> , <str> , <str> ) ) ; List < ByteBuffer > sb = new ArrayList < > ( s . size ( ) ) ; for ( String t : s ) sb . add ( UTF8Type . instance . decompose ( t ) ) ; assertEquals ( s , st . getSerializer ( ) . deserializeForNativeProtocol ( CollectionSerializer . pack ( sb , sb . size ( ) , version ) , version ) ) ; MapType < ? , ? > mt = MapType . getInstance ( UTF8Type . instance , LongType . instance , true ) ; Map < String , Long > m = new LinkedHashMap < > ( ) ; m . put ( <str> , <int> ) ; m . put ( <str> , <int> ) ; m . put ( <str> , <int> ) ; List < ByteBuffer > mb = new ArrayList < > ( m . size ( ) * <int> ) ; for ( Map . Entry < String , Long > entry : m . entrySet ( ) ) { mb . add ( UTF8Type . instance . decompose ( entry . getKey ( ) ) ) ; mb . add ( LongType . instance . decompose ( entry . getValue ( ) ) ) ; } assertEquals ( m , mt . getSerializer ( ) . deserializeForNativeProtocol ( CollectionSerializer . pack ( mb , m . size ( ) , version ) , version ) ) ; } @Test public void eventSerDeserTest ( ) throws Exception { eventSerDeserTest ( <int> ) ; eventSerDeserTest ( <int> ) ; } public void eventSerDeserTest ( int version ) throws Exception { List < Event > events = new ArrayList < > ( ) ; events . add ( TopologyChange . newNode ( FBUtilities . getBroadcastAddress ( ) , <int> ) ) ; events . add ( TopologyChange . removedNode ( FBUtilities . getBroadcastAddress ( ) , <int> ) ) ; events . add ( TopologyChange . movedNode ( FBUtilities . getBroadcastAddress ( ) , <int> ) ) ; events . add ( StatusChange . nodeUp ( FBUtilities . getBroadcastAddress ( ) , <int> ) ) ; events . add ( StatusChange . nodeDown ( FBUtilities . getBroadcastAddress ( ) , <int> ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . CREATED , <str> ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . UPDATED , <str> ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . DROPPED , <str> ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . CREATED , SchemaChange . Target . TABLE , <str> , <str> ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . UPDATED , SchemaChange . Target . TABLE , <str> , <str> ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . DROPPED , SchemaChange . Target . TABLE , <str> , <str> ) ) ; if ( version > = <int> ) { events . add ( new SchemaChange ( SchemaChange . Change . CREATED , SchemaChange . Target . TYPE , <str> , <str> ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . UPDATED , SchemaChange . Target . TYPE , <str> , <str> ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . DROPPED , SchemaChange . Target . TYPE , <str> , <str> ) ) ; } if ( version > = <int> ) { List < String > moreTypes = Arrays . asList ( <str> , <str> ) ; events . add ( new SchemaChange ( SchemaChange . Change . CREATED , SchemaChange . Target . FUNCTION , <str> , <str> , Collections . < String > emptyList ( ) ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . UPDATED , SchemaChange . Target . FUNCTION , <str> , <str> , moreTypes ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . DROPPED , SchemaChange . Target . FUNCTION , <str> , <str> , moreTypes ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . CREATED , SchemaChange . Target . AGGREGATE , <str> , <str> , Collections . < String > emptyList ( ) ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . UPDATED , SchemaChange . Target . AGGREGATE , <str> , <str> , moreTypes ) ) ; events . add ( new SchemaChange ( SchemaChange . Change . DROPPED , SchemaChange . Target . AGGREGATE , <str> , <str> , moreTypes ) ) ; } for ( Event ev : events ) { ByteBuf buf = Unpooled . buffer ( ev . serializedSize ( version ) ) ; ev . serialize ( buf , version ) ; assertEquals ( ev , Event . deserialize ( buf , version ) ) ; } } private static ByteBuffer bb ( String str ) { return UTF8Type . instance . decompose ( str ) ; } private static ColumnIdentifier ci ( String name ) { return new ColumnIdentifier ( name , false ) ; } private static Constants . Literal lit ( long v ) { return Constants . Literal . integer ( String . valueOf ( v ) ) ; } private static Constants . Literal lit ( String v ) { return Constants . Literal . string ( v ) ; } private static ColumnSpecification columnSpec ( String name , AbstractType < ? > type ) { return new ColumnSpecification ( <str> , <str> , ci ( name ) , type ) ; } @Test public void udtSerDeserTest ( ) throws Exception { udtSerDeserTest ( <int> ) ; udtSerDeserTest ( <int> ) ; } public void udtSerDeserTest ( int version ) throws Exception { ListType < ? > lt = ListType . getInstance ( Int32Type . instance , true ) ; SetType < ? > st = SetType . getInstance ( UTF8Type . instance , true ) ; MapType < ? , ? > mt = MapType . getInstance ( UTF8Type . instance , LongType . instance , true ) ; UserType udt = new UserType ( <str> , bb ( <str> ) , Arrays . asList ( bb ( <str> ) , bb ( <str> ) , bb ( <str> ) , bb ( <str> ) ) , Arrays . asList ( LongType . instance , lt , st , mt ) ) ; Map < ColumnIdentifier , Term . Raw > value = new HashMap < > ( ) ; value . put ( ci ( <str> ) , lit ( <int> ) ) ; value . put ( ci ( <str> ) , new Lists . Literal ( Arrays . < Term . Raw > asList ( lit ( <int> ) , lit ( <int> ) ) ) ) ; value . put ( ci ( <str> ) , new Sets . Literal ( Arrays . < Term . Raw > asList ( lit ( <str> ) , lit ( <str> ) ) ) ) ; value . put ( ci ( <str> ) , new Maps . Literal ( Arrays . < Pair < Term . Raw , Term . Raw > > asList ( Pair . < Term . Raw , Term . Raw > create ( lit ( <str> ) , lit ( <int> ) ) , Pair . < Term . Raw , Term . Raw > create ( lit ( <str> ) , lit ( <int> ) ) ) ) ) ; UserTypes . Literal u = new UserTypes . Literal ( value ) ; Term t = u . prepare ( <str> , columnSpec ( <str> , udt ) ) ; QueryOptions options = QueryOptions . DEFAULT ; ByteBuffer serialized = t . bindAndGet ( options ) ; ByteBuffer [ ] fields = udt . split ( serialized ) ; assertEquals ( <int> , fields . length ) ; assertEquals ( bytes ( <int> ) , fields [ <int> ] ) ; assertEquals ( Arrays . asList ( <int> , <int> ) , lt . getSerializer ( ) . deserializeForNativeProtocol ( fields [ <int> ] , <int> ) ) ; LinkedHashSet < String > s = new LinkedHashSet < > ( ) ; s . addAll ( Arrays . asList ( <str> , <str> ) ) ; assertEquals ( s , st . getSerializer ( ) . deserializeForNativeProtocol ( fields [ <int> ] , <int> ) ) ; LinkedHashMap < String , Long > m = new LinkedHashMap < > ( ) ; m . put ( <str> , <int> ) ; m . put ( <str> , <int> ) ; assertEquals ( m , mt . getSerializer ( ) . deserializeForNativeProtocol ( fields [ <int> ] , <int> ) ) ; } @Test public void preparedMetadataSerializationTest ( ) { List < ColumnSpecification > columnNames = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) columnNames . add ( new ColumnSpecification ( <str> , <str> , new ColumnIdentifier ( <str> + i , false ) , Int32Type . instance ) ) ; ResultSet . PreparedMetadata meta = new ResultSet . PreparedMetadata ( columnNames , new Short [ ] { <int> , <int> } ) ; ByteBuf buf = Unpooled . buffer ( meta . codec . encodedSize ( meta , Server . VERSION_4 ) ) ; meta . codec . encode ( meta , buf , Server . VERSION_4 ) ; ResultSet . PreparedMetadata decodedMeta = meta . codec . decode ( buf , Server . VERSION_4 ) ; assertEquals ( meta , decodedMeta ) ; buf = Unpooled . buffer ( meta . codec . encodedSize ( meta , Server . VERSION_3 ) ) ; meta . codec . encode ( meta , buf , Server . VERSION_3 ) ; decodedMeta = meta . codec . decode ( buf , Server . VERSION_3 ) ; assertNotSame ( meta , decodedMeta ) ; ResultSet . PreparedMetadata metaWithoutIndexes = new ResultSet . PreparedMetadata ( columnNames , null ) ; buf = Unpooled . buffer ( metaWithoutIndexes . codec . encodedSize ( metaWithoutIndexes , Server . VERSION_4 ) ) ; metaWithoutIndexes . codec . encode ( metaWithoutIndexes , buf , Server . VERSION_4 ) ; ResultSet . PreparedMetadata decodedMetaWithoutIndexes = metaWithoutIndexes . codec . decode ( buf , Server . VERSION_4 ) ; assertEquals ( decodedMeta , decodedMetaWithoutIndexes ) ; } } 
