package com . badlogic . gdx . utils ; import java . nio . Buffer ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . CharBuffer ; import java . nio . DoubleBuffer ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import java . nio . LongBuffer ; import java . nio . ShortBuffer ; import com . badlogic . gdx . math . Matrix3 ; import com . badlogic . gdx . math . Matrix4 ; public final class BufferUtils { static Array < ByteBuffer > unsafeBuffers = new Array < ByteBuffer > ( ) ; static int allocatedUnsafe = <int> ; public static void copy ( float [ ] src , Buffer dst , int numFloats , int offset ) { if ( dst instanceof ByteBuffer ) dst . limit ( numFloats < < <int> ) ; else if ( dst instanceof FloatBuffer ) dst . limit ( numFloats ) ; copyJni ( src , dst , numFloats , offset ) ; dst . position ( <int> ) ; } public static void copy ( byte [ ] src , int srcOffset , Buffer dst , int numElements ) { dst . limit ( dst . position ( ) + bytesToElements ( dst , numElements ) ) ; copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements ) ; } public static void copy ( short [ ] src , int srcOffset , Buffer dst , int numElements ) { dst . limit ( dst . position ( ) + bytesToElements ( dst , numElements < < <int> ) ) ; copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( char [ ] src , int srcOffset , int numElements , Buffer dst ) { copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( int [ ] src , int srcOffset , int numElements , Buffer dst ) { copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( long [ ] src , int srcOffset , int numElements , Buffer dst ) { copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( float [ ] src , int srcOffset , int numElements , Buffer dst ) { copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( double [ ] src , int srcOffset , int numElements , Buffer dst ) { copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( char [ ] src , int srcOffset , Buffer dst , int numElements ) { dst . limit ( dst . position ( ) + bytesToElements ( dst , numElements < < <int> ) ) ; copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( int [ ] src , int srcOffset , Buffer dst , int numElements ) { dst . limit ( dst . position ( ) + bytesToElements ( dst , numElements < < <int> ) ) ; copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( long [ ] src , int srcOffset , Buffer dst , int numElements ) { dst . limit ( dst . position ( ) + bytesToElements ( dst , numElements < < <int> ) ) ; copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( float [ ] src , int srcOffset , Buffer dst , int numElements ) { dst . limit ( dst . position ( ) + bytesToElements ( dst , numElements < < <int> ) ) ; copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( double [ ] src , int srcOffset , Buffer dst , int numElements ) { dst . limit ( dst . position ( ) + bytesToElements ( dst , numElements < < <int> ) ) ; copyJni ( src , srcOffset , dst , positionInBytes ( dst ) , numElements < < <int> ) ; } public static void copy ( Buffer src , Buffer dst , int numElements ) { int numBytes = elementsToBytes ( src , numElements ) ; dst . limit ( dst . position ( ) + bytesToElements ( dst , numBytes ) ) ; copyJni ( src , positionInBytes ( src ) , dst , positionInBytes ( dst ) , numBytes ) ; } public static void transform ( Buffer data , int dimensions , int strideInBytes , int count , Matrix4 matrix ) { transform ( data , dimensions , strideInBytes , count , matrix , <int> ) ; } public static void transform ( float [ ] data , int dimensions , int strideInBytes , int count , Matrix4 matrix ) { transform ( data , dimensions , strideInBytes , count , matrix , <int> ) ; } public static void transform ( Buffer data , int dimensions , int strideInBytes , int count , Matrix4 matrix , int offset ) { switch ( dimensions ) { case <int> : transformV4M4Jni ( data , strideInBytes , count , matrix . val , positionInBytes ( data ) + offset ) ; break ; case <int> : transformV3M4Jni ( data , strideInBytes , count , matrix . val , positionInBytes ( data ) + offset ) ; break ; case <int> : transformV2M4Jni ( data , strideInBytes , count , matrix . val , positionInBytes ( data ) + offset ) ; break ; default : throw new IllegalArgumentException ( ) ; } } public static void transform ( float [ ] data , int dimensions , int strideInBytes , int count , Matrix4 matrix , int offset ) { switch ( dimensions ) { case <int> : transformV4M4Jni ( data , strideInBytes , count , matrix . val , offset ) ; break ; case <int> : transformV3M4Jni ( data , strideInBytes , count , matrix . val , offset ) ; break ; case <int> : transformV2M4Jni ( data , strideInBytes , count , matrix . val , offset ) ; break ; default : throw new IllegalArgumentException ( ) ; } } public static void transform ( Buffer data , int dimensions , int strideInBytes , int count , Matrix3 matrix ) { transform ( data , dimensions , strideInBytes , count , matrix , <int> ) ; } public static void transform ( float [ ] data , int dimensions , int strideInBytes , int count , Matrix3 matrix ) { transform ( data , dimensions , strideInBytes , count , matrix , <int> ) ; } public static void transform ( Buffer data , int dimensions , int strideInBytes , int count , Matrix3 matrix , int offset ) { switch ( dimensions ) { case <int> : transformV3M3Jni ( data , strideInBytes , count , matrix . val , positionInBytes ( data ) + offset ) ; break ; case <int> : transformV2M3Jni ( data , strideInBytes , count , matrix . val , positionInBytes ( data ) + offset ) ; break ; default : throw new IllegalArgumentException ( ) ; } } public static void transform ( float [ ] data , int dimensions , int strideInBytes , int count , Matrix3 matrix , int offset ) { switch ( dimensions ) { case <int> : transformV3M3Jni ( data , strideInBytes , count , matrix . val , offset ) ; break ; case <int> : transformV2M3Jni ( data , strideInBytes , count , matrix . val , offset ) ; break ; default : throw new IllegalArgumentException ( ) ; } } public static long findFloats ( Buffer vertex , int strideInBytes , Buffer vertices , int numVertices ) { return find ( vertex , positionInBytes ( vertex ) , strideInBytes , vertices , positionInBytes ( vertices ) , numVertices ) ; } public static long findFloats ( float [ ] vertex , int strideInBytes , Buffer vertices , int numVertices ) { return find ( vertex , <int> , strideInBytes , vertices , positionInBytes ( vertices ) , numVertices ) ; } public static long findFloats ( Buffer vertex , int strideInBytes , float [ ] vertices , int numVertices ) { return find ( vertex , positionInBytes ( vertex ) , strideInBytes , vertices , <int> , numVertices ) ; } public static long findFloats ( float [ ] vertex , int strideInBytes , float [ ] vertices , int numVertices ) { return find ( vertex , <int> , strideInBytes , vertices , <int> , numVertices ) ; } public static long findFloats ( Buffer vertex , int strideInBytes , Buffer vertices , int numVertices , float epsilon ) { return find ( vertex , positionInBytes ( vertex ) , strideInBytes , vertices , positionInBytes ( vertices ) , numVertices , epsilon ) ; } public static long findFloats ( float [ ] vertex , int strideInBytes , Buffer vertices , int numVertices , float epsilon ) { return find ( vertex , <int> , strideInBytes , vertices , positionInBytes ( vertices ) , numVertices , epsilon ) ; } public static long findFloats ( Buffer vertex , int strideInBytes , float [ ] vertices , int numVertices , float epsilon ) { return find ( vertex , positionInBytes ( vertex ) , strideInBytes , vertices , <int> , numVertices , epsilon ) ; } public static long findFloats ( float [ ] vertex , int strideInBytes , float [ ] vertices , int numVertices , float epsilon ) { return find ( vertex , <int> , strideInBytes , vertices , <int> , numVertices , epsilon ) ; } private static int positionInBytes ( Buffer dst ) { if ( dst instanceof ByteBuffer ) return dst . position ( ) ; else if ( dst instanceof ShortBuffer ) return dst . position ( ) < < <int> ; else if ( dst instanceof CharBuffer ) return dst . position ( ) < < <int> ; else if ( dst instanceof IntBuffer ) return dst . position ( ) < < <int> ; else if ( dst instanceof LongBuffer ) return dst . position ( ) < < <int> ; else if ( dst instanceof FloatBuffer ) return dst . position ( ) < < <int> ; else if ( dst instanceof DoubleBuffer ) return dst . position ( ) < < <int> ; else throw new GdxRuntimeException ( <str> + dst . getClass ( ) . getName ( ) + <str> ) ; } private static int bytesToElements ( Buffer dst , int bytes ) { if ( dst instanceof ByteBuffer ) return bytes ; else if ( dst instanceof ShortBuffer ) return bytes > > > <int> ; else if ( dst instanceof CharBuffer ) return bytes > > > <int> ; else if ( dst instanceof IntBuffer ) return bytes > > > <int> ; else if ( dst instanceof LongBuffer ) return bytes > > > <int> ; else if ( dst instanceof FloatBuffer ) return bytes > > > <int> ; else if ( dst instanceof DoubleBuffer ) return bytes > > > <int> ; else throw new GdxRuntimeException ( <str> + dst . getClass ( ) . getName ( ) + <str> ) ; } private static int elementsToBytes ( Buffer dst , int elements ) { if ( dst instanceof ByteBuffer ) return elements ; else if ( dst instanceof ShortBuffer ) return elements < < <int> ; else if ( dst instanceof CharBuffer ) return elements < < <int> ; else if ( dst instanceof IntBuffer ) return elements < < <int> ; else if ( dst instanceof LongBuffer ) return elements < < <int> ; else if ( dst instanceof FloatBuffer ) return elements < < <int> ; else if ( dst instanceof DoubleBuffer ) return elements < < <int> ; else throw new GdxRuntimeException ( <str> + dst . getClass ( ) . getName ( ) + <str> ) ; } public static FloatBuffer newFloatBuffer ( int numFloats ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numFloats * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asFloatBuffer ( ) ; } public static DoubleBuffer newDoubleBuffer ( int numDoubles ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numDoubles * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asDoubleBuffer ( ) ; } public static ByteBuffer newByteBuffer ( int numBytes ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numBytes ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer ; } public static ShortBuffer newShortBuffer ( int numShorts ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numShorts * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asShortBuffer ( ) ; } public static CharBuffer newCharBuffer ( int numChars ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numChars * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asCharBuffer ( ) ; } public static IntBuffer newIntBuffer ( int numInts ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numInts * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asIntBuffer ( ) ; } public static LongBuffer newLongBuffer ( int numLongs ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( numLongs * <int> ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; return buffer . asLongBuffer ( ) ; } public static void disposeUnsafeByteBuffer ( ByteBuffer buffer ) { int size = buffer . capacity ( ) ; synchronized ( unsafeBuffers ) { if ( ! unsafeBuffers . removeValue ( buffer , true ) ) throw new IllegalArgumentException ( <str> ) ; } allocatedUnsafe - = size ; freeMemory ( buffer ) ; } public static ByteBuffer newUnsafeByteBuffer ( int numBytes ) { ByteBuffer buffer = newDisposableByteBuffer ( numBytes ) ; buffer . order ( ByteOrder . nativeOrder ( ) ) ; allocatedUnsafe + = numBytes ; synchronized ( unsafeBuffers ) { unsafeBuffers . add ( buffer ) ; } return buffer ; } public static long getUnsafeBufferAddress ( Buffer buffer ) { return getBufferAddress ( buffer ) + buffer . position ( ) ; } public static ByteBuffer newUnsafeByteBuffer ( ByteBuffer buffer ) { allocatedUnsafe + = buffer . capacity ( ) ; synchronized ( unsafeBuffers ) { unsafeBuffers . add ( buffer ) ; } return buffer ; } public static int getAllocatedBytesUnsafe ( ) { return allocatedUnsafe ; } private static native void freeMemory ( ByteBuffer buffer ) ; private static native ByteBuffer newDisposableByteBuffer ( int numBytes ) ; private static native long getBufferAddress ( Buffer buffer ) ; public static native void clear ( ByteBuffer buffer , int numBytes ) ; private native static void copyJni ( float [ ] src , Buffer dst , int numFloats , int offset ) ; private native static void copyJni ( byte [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) ; private native static void copyJni ( char [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) ; private native static void copyJni ( short [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) ; private native static void copyJni ( int [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) ; private native static void copyJni ( long [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) ; private native static void copyJni ( float [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) ; private native static void copyJni ( double [ ] src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) ; private native static void copyJni ( Buffer src , int srcOffset , Buffer dst , int dstOffset , int numBytes ) ; private native static void transformV4M4Jni ( Buffer data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV4M4Jni ( float [ ] data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV3M4Jni ( Buffer data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV3M4Jni ( float [ ] data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV2M4Jni ( Buffer data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV2M4Jni ( float [ ] data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV3M3Jni ( Buffer data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV3M3Jni ( float [ ] data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV2M3Jni ( Buffer data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static void transformV2M3Jni ( float [ ] data , int strideInBytes , int count , float [ ] matrix , int offsetInBytes ) ; private native static long find ( Buffer vertex , int vertexOffsetInBytes , int strideInBytes , Buffer vertices , int verticesOffsetInBytes , int numVertices ) ; private native static long find ( float [ ] vertex , int vertexOffsetInBytes , int strideInBytes , Buffer vertices , int verticesOffsetInBytes , int numVertices ) ; private native static long find ( Buffer vertex , int vertexOffsetInBytes , int strideInBytes , float [ ] vertices , int verticesOffsetInBytes , int numVertices ) ; private native static long find ( float [ ] vertex , int vertexOffsetInBytes , int strideInBytes , float [ ] vertices , int verticesOffsetInBytes , int numVertices ) ; private native static long find ( Buffer vertex , int vertexOffsetInBytes , int strideInBytes , Buffer vertices , int verticesOffsetInBytes , int numVertices , float epsilon ) ; private native static long find ( float [ ] vertex , int vertexOffsetInBytes , int strideInBytes , Buffer vertices , int verticesOffsetInBytes , int numVertices , float epsilon ) ; private native static long find ( Buffer vertex , int vertexOffsetInBytes , int strideInBytes , float [ ] vertices , int verticesOffsetInBytes , int numVertices , float epsilon ) ; private native static long find ( float [ ] vertex , int vertexOffsetInBytes , int strideInBytes , float [ ] vertices , int verticesOffsetInBytes , int numVertices , float epsilon ) ; } 
