package org . elasticsearch . index . query . functionscore ; import org . apache . lucene . search . MatchAllDocsQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . lucene . search . function . CombineFunction ; import org . elasticsearch . common . lucene . search . function . FiltersFunctionScoreQuery ; import org . elasticsearch . common . lucene . search . function . FunctionScoreQuery ; import org . elasticsearch . common . lucene . search . function . ScoreFunction ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . * ; import org . elasticsearch . index . query . functionscore . random . RandomScoreFunctionBuilder ; import java . io . IOException ; import java . util . Arrays ; import java . util . Locale ; import java . util . Objects ; public class FunctionScoreQueryBuilder extends AbstractQueryBuilder < FunctionScoreQueryBuilder > { public static final String NAME = <str> ; public static final CombineFunction DEFAULT_BOOST_MODE = CombineFunction . MULTIPLY ; public static final FiltersFunctionScoreQuery . ScoreMode DEFAULT_SCORE_MODE = FiltersFunctionScoreQuery . ScoreMode . MULTIPLY ; private final QueryBuilder < ? > query ; private float maxBoost = FunctionScoreQuery . DEFAULT_MAX_BOOST ; private FiltersFunctionScoreQuery . ScoreMode scoreMode = DEFAULT_SCORE_MODE ; private CombineFunction boostMode ; private Float minScore = null ; private final FilterFunctionBuilder [ ] filterFunctionBuilders ; public FunctionScoreQueryBuilder ( QueryBuilder < ? > query ) { this ( query , new FilterFunctionBuilder [ <int> ] ) ; } public FunctionScoreQueryBuilder ( FilterFunctionBuilder [ ] filterFunctionBuilders ) { this ( new MatchAllQueryBuilder ( ) , filterFunctionBuilders ) ; } public FunctionScoreQueryBuilder ( ScoreFunctionBuilder scoreFunctionBuilder ) { this ( new MatchAllQueryBuilder ( ) , new FilterFunctionBuilder [ ] { new FilterFunctionBuilder ( scoreFunctionBuilder ) } ) ; } public FunctionScoreQueryBuilder ( QueryBuilder < ? > query , ScoreFunctionBuilder scoreFunctionBuilder ) { this ( query , new FilterFunctionBuilder [ ] { new FilterFunctionBuilder ( scoreFunctionBuilder ) } ) ; } public FunctionScoreQueryBuilder ( QueryBuilder < ? > query , FilterFunctionBuilder [ ] filterFunctionBuilders ) { if ( query = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( filterFunctionBuilders = = null ) { throw new IllegalArgumentException ( <str> ) ; } for ( FilterFunctionBuilder filterFunctionBuilder : filterFunctionBuilders ) { if ( filterFunctionBuilder = = null ) { throw new IllegalArgumentException ( <str> ) ; } } this . query = query ; this . filterFunctionBuilders = filterFunctionBuilders ; } public QueryBuilder < ? > query ( ) { return this . query ; } public FilterFunctionBuilder [ ] filterFunctionBuilders ( ) { return this . filterFunctionBuilders ; } public FunctionScoreQueryBuilder scoreMode ( FiltersFunctionScoreQuery . ScoreMode scoreMode ) { if ( scoreMode = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . scoreMode = scoreMode ; return this ; } public FiltersFunctionScoreQuery . ScoreMode scoreMode ( ) { return this . scoreMode ; } public FunctionScoreQueryBuilder boostMode ( CombineFunction combineFunction ) { if ( combineFunction = = null ) { throw new IllegalArgumentException ( <str> + NAME + <str> ) ; } this . boostMode = combineFunction ; return this ; } public CombineFunction boostMode ( ) { return this . boostMode ; } public FunctionScoreQueryBuilder maxBoost ( float maxBoost ) { this . maxBoost = maxBoost ; return this ; } public float maxBoost ( ) { return this . maxBoost ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; if ( query ! = null ) { builder . field ( <str> ) ; query . toXContent ( builder , params ) ; } builder . startArray ( <str> ) ; for ( FilterFunctionBuilder filterFunctionBuilder : filterFunctionBuilders ) { filterFunctionBuilder . toXContent ( builder , params ) ; } builder . endArray ( ) ; builder . field ( <str> , scoreMode . name ( ) . toLowerCase ( Locale . ROOT ) ) ; if ( boostMode ! = null ) { builder . field ( <str> , boostMode . name ( ) . toLowerCase ( Locale . ROOT ) ) ; } builder . field ( <str> , maxBoost ) ; if ( minScore ! = null ) { builder . field ( <str> , minScore ) ; } printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } public FunctionScoreQueryBuilder setMinScore ( float minScore ) { this . minScore = minScore ; return this ; } public Float getMinScore ( ) { return this . minScore ; } @Override public String getWriteableName ( ) { return FunctionScoreQueryBuilder . NAME ; } @Override protected boolean doEquals ( FunctionScoreQueryBuilder other ) { return Objects . equals ( this . query , other . query ) & & Arrays . equals ( this . filterFunctionBuilders , other . filterFunctionBuilders ) & & Objects . equals ( this . boostMode , other . boostMode ) & & Objects . equals ( this . scoreMode , other . scoreMode ) & & Objects . equals ( this . minScore , other . minScore ) & & Objects . equals ( this . maxBoost , other . maxBoost ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( this . query , Arrays . hashCode ( this . filterFunctionBuilders ) , this . boostMode , this . scoreMode , this . minScore , this . maxBoost ) ; } @Override protected FunctionScoreQueryBuilder doReadFrom ( StreamInput in ) throws IOException { QueryBuilder < ? > query = in . readQuery ( ) ; int size = in . readVInt ( ) ; FilterFunctionBuilder [ ] filterFunctionBuilders = new FilterFunctionBuilder [ size ] ; for ( int i = <int> ; i < size ; i + + ) { filterFunctionBuilders [ i ] = FilterFunctionBuilder . PROTOTYPE . readFrom ( in ) ; } FunctionScoreQueryBuilder functionScoreQueryBuilder = new FunctionScoreQueryBuilder ( query , filterFunctionBuilders ) ; functionScoreQueryBuilder . maxBoost ( in . readFloat ( ) ) ; if ( in . readBoolean ( ) ) { functionScoreQueryBuilder . setMinScore ( in . readFloat ( ) ) ; } if ( in . readBoolean ( ) ) { functionScoreQueryBuilder . boostMode ( CombineFunction . readCombineFunctionFrom ( in ) ) ; } functionScoreQueryBuilder . scoreMode ( FiltersFunctionScoreQuery . ScoreMode . readScoreModeFrom ( in ) ) ; return functionScoreQueryBuilder ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeQuery ( query ) ; out . writeVInt ( filterFunctionBuilders . length ) ; for ( FilterFunctionBuilder filterFunctionBuilder : filterFunctionBuilders ) { filterFunctionBuilder . writeTo ( out ) ; } out . writeFloat ( maxBoost ) ; if ( minScore = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; out . writeFloat ( minScore ) ; } if ( boostMode = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; boostMode . writeTo ( out ) ; } scoreMode . writeTo ( out ) ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { FiltersFunctionScoreQuery . FilterFunction [ ] filterFunctions = new FiltersFunctionScoreQuery . FilterFunction [ filterFunctionBuilders . length ] ; int i = <int> ; for ( FilterFunctionBuilder filterFunctionBuilder : filterFunctionBuilders ) { Query filter = filterFunctionBuilder . getFilter ( ) . toQuery ( context ) ; ScoreFunction scoreFunction = filterFunctionBuilder . getScoreFunction ( ) . toFunction ( context ) ; filterFunctions [ i + + ] = new FiltersFunctionScoreQuery . FilterFunction ( filter , scoreFunction ) ; } Query query = this . query . toQuery ( context ) ; if ( query = = null ) { query = new MatchAllDocsQuery ( ) ; } if ( filterFunctions . length = = <int> | | filterFunctions . length = = <int> & & ( this . filterFunctionBuilders [ <int> ] . getFilter ( ) . getName ( ) . equals ( MatchAllQueryBuilder . NAME ) ) ) { ScoreFunction function = filterFunctions . length = = <int> ? null : filterFunctions [ <int> ] . function ; CombineFunction combineFunction = this . boostMode ; if ( combineFunction = = null ) { if ( function ! = null ) { combineFunction = function . getDefaultScoreCombiner ( ) ; } else { combineFunction = DEFAULT_BOOST_MODE ; } } return new FunctionScoreQuery ( query , function , minScore , combineFunction , maxBoost ) ; } return new FiltersFunctionScoreQuery ( query , scoreMode , filterFunctions , maxBoost , minScore , boostMode = = null ? DEFAULT_BOOST_MODE : boostMode ) ; } public static class FilterFunctionBuilder implements ToXContent , Writeable < FilterFunctionBuilder > { private static final FilterFunctionBuilder PROTOTYPE = new FilterFunctionBuilder ( EmptyQueryBuilder . PROTOTYPE , new RandomScoreFunctionBuilder ( ) ) ; private final QueryBuilder < ? > filter ; private final ScoreFunctionBuilder scoreFunction ; public FilterFunctionBuilder ( ScoreFunctionBuilder scoreFunctionBuilder ) { this ( new MatchAllQueryBuilder ( ) , scoreFunctionBuilder ) ; } public FilterFunctionBuilder ( QueryBuilder < ? > filter , ScoreFunctionBuilder scoreFunction ) { if ( filter = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( scoreFunction = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . filter = filter ; this . scoreFunction = scoreFunction ; } public QueryBuilder < ? > getFilter ( ) { return filter ; } public ScoreFunctionBuilder < ? > getScoreFunction ( ) { return scoreFunction ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( ) ; builder . field ( <str> ) ; filter . toXContent ( builder , params ) ; scoreFunction . toXContent ( builder , params ) ; builder . endObject ( ) ; return builder ; } @Override public int hashCode ( ) { return Objects . hash ( filter , scoreFunction ) ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null | | getClass ( ) ! = obj . getClass ( ) ) { return false ; } FilterFunctionBuilder that = ( FilterFunctionBuilder ) obj ; return Objects . equals ( this . filter , that . filter ) & & Objects . equals ( this . scoreFunction , that . scoreFunction ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeQuery ( filter ) ; out . writeScoreFunction ( scoreFunction ) ; } @Override public FilterFunctionBuilder readFrom ( StreamInput in ) throws IOException { return new FilterFunctionBuilder ( in . readQuery ( ) , in . readScoreFunction ( ) ) ; } } } 
