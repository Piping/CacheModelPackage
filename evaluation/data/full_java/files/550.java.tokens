package org . apache . cassandra . dht ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . nio . ByteBuffer ; import java . util . * ; import com . google . common . annotations . VisibleForTesting ; import org . apache . cassandra . db . CachedHashDecoratedKey ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . IntegerType ; import org . apache . cassandra . db . marshal . PartitionerDefinedOrder ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . GuidGenerator ; import org . apache . cassandra . utils . ObjectSizes ; import org . apache . cassandra . utils . Pair ; public class RandomPartitioner implements IPartitioner { public static final BigInteger ZERO = new BigInteger ( <str> ) ; public static final BigIntegerToken MINIMUM = new BigIntegerToken ( <str> ) ; public static final BigInteger MAXIMUM = new BigInteger ( <str> ) . pow ( <int> ) ; private static final int HEAP_SIZE = ( int ) ObjectSizes . measureDeep ( new BigIntegerToken ( FBUtilities . hashToBigInteger ( ByteBuffer . allocate ( <int> ) ) ) ) ; public static final RandomPartitioner instance = new RandomPartitioner ( ) ; public static final AbstractType < ? > partitionOrdering = new PartitionerDefinedOrder ( instance ) ; public DecoratedKey decorateKey ( ByteBuffer key ) { return new CachedHashDecoratedKey ( getToken ( key ) , key ) ; } public Token midpoint ( Token ltoken , Token rtoken ) { BigInteger left = ltoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) ltoken ) . token ; BigInteger right = rtoken . equals ( MINIMUM ) ? ZERO : ( ( BigIntegerToken ) rtoken ) . token ; Pair < BigInteger , Boolean > midpair = FBUtilities . midpoint ( left , right , <int> ) ; return new BigIntegerToken ( midpair . left ) ; } public BigIntegerToken getMinimumToken ( ) { return MINIMUM ; } public BigIntegerToken getRandomToken ( ) { BigInteger token = FBUtilities . hashToBigInteger ( GuidGenerator . guidAsBytes ( ) ) ; if ( token . signum ( ) = = - <int> ) token = token . multiply ( BigInteger . valueOf ( - <int> ) ) ; return new BigIntegerToken ( token ) ; } private final Token . TokenFactory tokenFactory = new Token . TokenFactory ( ) { public ByteBuffer toByteArray ( Token token ) { BigIntegerToken bigIntegerToken = ( BigIntegerToken ) token ; return ByteBuffer . wrap ( bigIntegerToken . token . toByteArray ( ) ) ; } public Token fromByteArray ( ByteBuffer bytes ) { return new BigIntegerToken ( new BigInteger ( ByteBufferUtil . getArray ( bytes ) ) ) ; } public String toString ( Token token ) { BigIntegerToken bigIntegerToken = ( BigIntegerToken ) token ; return bigIntegerToken . token . toString ( ) ; } public void validate ( String token ) throws ConfigurationException { try { BigInteger i = new BigInteger ( token ) ; if ( i . compareTo ( ZERO ) < <int> ) throw new ConfigurationException ( <str> ) ; if ( i . compareTo ( MAXIMUM ) > <int> ) throw new ConfigurationException ( <str> ) ; } catch ( NumberFormatException e ) { throw new ConfigurationException ( e . getMessage ( ) ) ; } } public Token fromString ( String string ) { return new BigIntegerToken ( new BigInteger ( string ) ) ; } } ; public Token . TokenFactory getTokenFactory ( ) { return tokenFactory ; } public boolean preservesOrder ( ) { return false ; } public static class BigIntegerToken extends ComparableObjectToken < BigInteger > { static final long serialVersionUID = - <int> ; public BigIntegerToken ( BigInteger token ) { super ( token ) ; } @VisibleForTesting public BigIntegerToken ( String token ) { this ( new BigInteger ( token ) ) ; } @Override public IPartitioner getPartitioner ( ) { return instance ; } @Override public long getHeapSize ( ) { return HEAP_SIZE ; } } public BigIntegerToken getToken ( ByteBuffer key ) { if ( key . remaining ( ) = = <int> ) return MINIMUM ; return new BigIntegerToken ( FBUtilities . hashToBigInteger ( key ) ) ; } public Map < Token , Float > describeOwnership ( List < Token > sortedTokens ) { Map < Token , Float > ownerships = new HashMap < Token , Float > ( ) ; Iterator < Token > i = sortedTokens . iterator ( ) ; if ( ! i . hasNext ( ) ) { throw new RuntimeException ( <str> ) ; } if ( sortedTokens . size ( ) = = <int> ) { ownerships . put ( i . next ( ) , new Float ( <float> ) ) ; } else { final BigInteger ri = MAXIMUM ; final BigDecimal r = new BigDecimal ( ri ) ; Token start = i . next ( ) ; BigInteger ti = ( ( BigIntegerToken ) start ) . token ; Token t ; BigInteger tim1 = ti ; while ( i . hasNext ( ) ) { t = i . next ( ) ; ti = ( ( BigIntegerToken ) t ) . token ; float x = new BigDecimal ( ti . subtract ( tim1 ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; ownerships . put ( t , x ) ; tim1 = ti ; } float x = new BigDecimal ( ( ( BigIntegerToken ) start ) . token . subtract ( ti ) . add ( ri ) . mod ( ri ) ) . divide ( r ) . floatValue ( ) ; ownerships . put ( start , x ) ; } return ownerships ; } public AbstractType < ? > getTokenValidator ( ) { return IntegerType . instance ; } public AbstractType < ? > partitionOrdering ( ) { return partitionOrdering ; } } 
