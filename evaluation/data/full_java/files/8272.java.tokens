package org . elasticsearch . index . query ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . BooleanClause ; import org . apache . lucene . search . BooleanQuery ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . TermQuery ; import org . apache . lucene . util . CollectionUtil ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . get . GetRequest ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . get . GetResult ; import org . elasticsearch . indices . cache . query . terms . TermsLookup ; import org . hamcrest . Matchers ; import org . junit . Before ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . containsString ; public class TermsQueryBuilderTests extends AbstractQueryTestCase < TermsQueryBuilder > { private List < Object > randomTerms ; private String termsPath ; @Before public void randomTerms ( ) { List < Object > randomTerms = new ArrayList < > ( ) ; String [ ] strings = generateRandomStringArray ( <int> , <int> , false , true ) ; for ( String string : strings ) { randomTerms . add ( string ) ; if ( rarely ( ) ) { randomTerms . add ( null ) ; } } this . randomTerms = randomTerms ; termsPath = randomAsciiOfLength ( <int> ) . replace ( <str> , <str> ) ; } @Override protected TermsQueryBuilder doCreateTestQueryBuilder ( ) { TermsQueryBuilder query ; if ( randomBoolean ( ) ) { String fieldName = getRandomFieldName ( ) ; Object [ ] values = new Object [ randomInt ( <int> ) ] ; for ( int i = <int> ; i < values . length ; i + + ) { values [ i ] = getRandomValueForFieldName ( fieldName ) ; } query = new TermsQueryBuilder ( fieldName , values ) ; } else { query = new TermsQueryBuilder ( randomBoolean ( ) ? randomAsciiOfLengthBetween ( <int> , <int> ) : STRING_FIELD_NAME , randomTermsLookup ( ) ) ; } return query ; } private TermsLookup randomTermsLookup ( ) { return new TermsLookup ( randomBoolean ( ) ? randomAsciiOfLength ( <int> ) : null , randomAsciiOfLength ( <int> ) , randomAsciiOfLength ( <int> ) , termsPath ) . routing ( randomBoolean ( ) ? randomAsciiOfLength ( <int> ) : null ) ; } @Override protected void doAssertLuceneQuery ( TermsQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery booleanQuery = ( BooleanQuery ) query ; if ( queryBuilder . fieldName ( ) . equals ( INT_FIELD_NAME ) | | queryBuilder . fieldName ( ) . equals ( DOUBLE_FIELD_NAME ) | | queryBuilder . fieldName ( ) . equals ( BOOLEAN_FIELD_NAME ) | | queryBuilder . fieldName ( ) . equals ( DATE_FIELD_NAME ) ) { return ; } List < Object > terms ; if ( queryBuilder . termsLookup ( ) ! = null ) { terms = randomTerms ; } else { terms = queryBuilder . values ( ) ; } final List < Term > booleanTerms = new ArrayList < > ( ) ; for ( BooleanClause booleanClause : booleanQuery ) { assertThat ( booleanClause . getOccur ( ) , equalTo ( BooleanClause . Occur . SHOULD ) ) ; assertThat ( booleanClause . getQuery ( ) , instanceOf ( TermQuery . class ) ) ; Term term = ( ( TermQuery ) booleanClause . getQuery ( ) ) . getTerm ( ) ; booleanTerms . add ( term ) ; } CollectionUtil . timSort ( booleanTerms ) ; List < Term > expectedTerms = new ArrayList < > ( ) ; for ( Object term : terms ) { if ( term ! = null ) { expectedTerms . add ( new Term ( queryBuilder . fieldName ( ) , term . toString ( ) ) ) ; } } CollectionUtil . timSort ( expectedTerms ) ; assertEquals ( expectedTerms + <str> + booleanTerms , expectedTerms . size ( ) , booleanTerms . size ( ) ) ; assertEquals ( expectedTerms + <str> + booleanTerms , expectedTerms , booleanTerms ) ; } public void testEmtpyFieldName ( ) { try { if ( randomBoolean ( ) ) { new TermsQueryBuilder ( null , <str> ) ; } else { new TermsQueryBuilder ( <str> , <str> ) ; } fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testEmtpyTermsLookup ( ) { try { new TermsQueryBuilder ( <str> , ( TermsLookup ) null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , is ( <str> ) ) ; } } public void testNullValues ( ) { try { switch ( randomInt ( <int> ) ) { case <int> : new TermsQueryBuilder ( <str> , ( String [ ] ) null ) ; break ; case <int> : new TermsQueryBuilder ( <str> , ( int [ ] ) null ) ; break ; case <int> : new TermsQueryBuilder ( <str> , ( long [ ] ) null ) ; break ; case <int> : new TermsQueryBuilder ( <str> , ( float [ ] ) null ) ; break ; case <int> : new TermsQueryBuilder ( <str> , ( double [ ] ) null ) ; break ; case <int> : new TermsQueryBuilder ( <str> , ( Object [ ] ) null ) ; break ; default : new TermsQueryBuilder ( <str> , ( Iterable < ? > ) null ) ; break ; } fail ( <str> ) ; } catch ( IllegalArgumentException e ) { assertThat ( e . getMessage ( ) , Matchers . containsString ( <str> ) ) ; } } public void testBothValuesAndLookupSet ( ) throws IOException { String query = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; try { parseQuery ( query ) ; fail ( <str> ) ; } catch ( ParsingException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> + TermsQueryBuilder . NAME + <str> ) ) ; } } @Override public GetResponse executeGet ( GetRequest getRequest ) { String json ; try { XContentBuilder builder = XContentFactory . jsonBuilder ( ) . prettyPrint ( ) ; builder . startObject ( ) ; builder . array ( termsPath , randomTerms . toArray ( new Object [ randomTerms . size ( ) ] ) ) ; builder . endObject ( ) ; json = builder . string ( ) ; } catch ( IOException ex ) { throw new ElasticsearchException ( <str> , ex ) ; } return new GetResponse ( new GetResult ( getRequest . index ( ) , getRequest . type ( ) , getRequest . id ( ) , <int> , true , new BytesArray ( json ) , null ) ) ; } public void testNumeric ( ) throws IOException { { TermsQueryBuilder builder = new TermsQueryBuilder ( <str> , new int [ ] { <int> , <int> , <int> } ) ; TermsQueryBuilder copy = assertSerialization ( builder ) ; List < Object > values = copy . values ( ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> ) , values ) ; } { TermsQueryBuilder builder = new TermsQueryBuilder ( <str> , new double [ ] { <int> , <int> , <int> } ) ; TermsQueryBuilder copy = assertSerialization ( builder ) ; List < Object > values = copy . values ( ) ; assertEquals ( Arrays . asList ( <float> , <float> , <float> ) , values ) ; } { TermsQueryBuilder builder = new TermsQueryBuilder ( <str> , new float [ ] { <int> , <int> , <int> } ) ; TermsQueryBuilder copy = assertSerialization ( builder ) ; List < Object > values = copy . values ( ) ; assertEquals ( Arrays . asList ( <float> , <float> , <float> ) , values ) ; } { TermsQueryBuilder builder = new TermsQueryBuilder ( <str> , new long [ ] { <int> , <int> , <int> } ) ; TermsQueryBuilder copy = assertSerialization ( builder ) ; List < Object > values = copy . values ( ) ; assertEquals ( Arrays . asList ( <int> , <int> , <int> ) , values ) ; } } public void testTermsQueryWithMultipleFields ( ) throws IOException { String query = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . array ( <str> , <int> ) . array ( <str> , <int> ) . endObject ( ) . endObject ( ) . string ( ) ; try { parseQuery ( query ) ; fail ( <str> ) ; } catch ( ParsingException ex ) { assertThat ( ex . getMessage ( ) , equalTo ( <str> + TermsQueryBuilder . NAME + <str> ) ) ; } } public void testFromJson ( ) throws IOException { String json = <str> + <str> + <str> + <str> + <str> + <str> ; TermsQueryBuilder parsed = ( TermsQueryBuilder ) parseQuery ( json ) ; checkGeneratedJson ( json , parsed ) ; assertEquals ( json , <int> , parsed . values ( ) . size ( ) ) ; } } 
