package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import net . jpountz . lz4 . LZ4BlockOutputStream ; import org . junit . Test ; import java . io . ByteArrayOutputStream ; import java . util . Arrays ; import static io . netty . handler . codec . compression . Lz4Constants . * ; public class Lz4FrameDecoderTest extends AbstractDecoderTest { private static final byte [ ] DATA = { <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , ( byte ) <hex> , ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> } ; public Lz4FrameDecoderTest ( ) throws Exception { } @Override public void initChannel ( ) { channel = new EmbeddedChannel ( new Lz4FrameDecoder ( true ) ) ; } @Test public void testUnexpectedBlockIdentifier ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testInvalidCompressedLength ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = ( byte ) <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testInvalidDecompressedLength ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = ( byte ) <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testDecompressedAndCompressedLengthMismatch ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testUnexpectedBlockType ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testMismatchingChecksum ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = <hex> ; ByteBuf in = Unpooled . wrappedBuffer ( data ) ; channel . writeInbound ( in ) ; } @Test public void testChecksumErrorOfLastBlock ( ) throws Exception { expected . expect ( DecompressionException . class ) ; expected . expectMessage ( <str> ) ; final byte [ ] data = Arrays . copyOf ( DATA , DATA . length ) ; data [ <int> ] = <hex> ; tryDecodeAndCatchBufLeaks ( channel , Unpooled . wrappedBuffer ( data ) ) ; } @Override protected byte [ ] compress ( byte [ ] data ) throws Exception { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; LZ4BlockOutputStream lz4Os = new LZ4BlockOutputStream ( os , rand . nextInt ( MIN_BLOCK_SIZE , MAX_BLOCK_SIZE + <int> ) ) ; lz4Os . write ( data ) ; lz4Os . close ( ) ; return os . toByteArray ( ) ; } } 
