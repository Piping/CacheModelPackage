package org . elasticsearch . index . mapper . core ; import org . apache . lucene . index . IndexOptions ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . Version ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . joda . FormatDateTimeFormatter ; import org . elasticsearch . common . joda . Joda ; import org . elasticsearch . common . logging . ESLoggerFactory ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . settings . loader . SettingsLoader ; import org . elasticsearch . index . analysis . NamedAnalyzer ; import org . elasticsearch . index . mapper . ContentPath ; import org . elasticsearch . index . mapper . DocumentMapperParser ; import org . elasticsearch . index . mapper . FieldMapper ; import org . elasticsearch . index . mapper . MappedFieldType . Loading ; import org . elasticsearch . index . mapper . Mapper ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . index . mapper . object . ObjectMapper ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . isArray ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeBooleanValue ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeFloatValue ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeIntegerValue ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeMapValue ; import static org . elasticsearch . common . xcontent . support . XContentMapValues . nodeStringValue ; public class TypeParsers { public static final String MULTI_FIELD_CONTENT_TYPE = <str> ; public static final Mapper . TypeParser multiFieldConverterTypeParser = new Mapper . TypeParser ( ) { @Override public Mapper . Builder < ? , ? > parse ( String name , Map < String , Object > node , ParserContext parserContext ) throws MapperParsingException { ContentPath . Type pathType = null ; FieldMapper . Builder mainFieldBuilder = null ; List < FieldMapper . Builder > fields = null ; String firstType = null ; for ( Iterator < Map . Entry < String , Object > > iterator = node . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String fieldName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object fieldNode = entry . getValue ( ) ; if ( fieldName . equals ( <str> ) & & parserContext . indexVersionCreated ( ) . before ( Version . V_2_0_0_beta1 ) ) { pathType = parsePathType ( name , fieldNode . toString ( ) ) ; iterator . remove ( ) ; } else if ( fieldName . equals ( <str> ) ) { Map < String , Object > fieldsNode = ( Map < String , Object > ) fieldNode ; for ( Iterator < Map . Entry < String , Object > > fieldsIterator = fieldsNode . entrySet ( ) . iterator ( ) ; fieldsIterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry1 = fieldsIterator . next ( ) ; String propName = entry1 . getKey ( ) ; Map < String , Object > propNode = ( Map < String , Object > ) entry1 . getValue ( ) ; String type ; Object typeNode = propNode . get ( <str> ) ; if ( typeNode ! = null ) { type = typeNode . toString ( ) ; if ( firstType = = null ) { firstType = type ; } } else { throw new MapperParsingException ( <str> + propName + <str> ) ; } Mapper . TypeParser typeParser = parserContext . typeParser ( type ) ; if ( typeParser = = null ) { throw new MapperParsingException ( <str> + type + <str> + fieldName + <str> ) ; } if ( propName . equals ( name ) ) { mainFieldBuilder = ( FieldMapper . Builder ) typeParser . parse ( propName , propNode , parserContext ) ; fieldsIterator . remove ( ) ; } else { if ( fields = = null ) { fields = new ArrayList < > ( <int> ) ; } fields . add ( ( FieldMapper . Builder ) typeParser . parse ( propName , propNode , parserContext ) ) ; fieldsIterator . remove ( ) ; } } fieldsNode . remove ( <str> ) ; DocumentMapperParser . checkNoRemainingFields ( fieldName , fieldsNode , parserContext . indexVersionCreated ( ) ) ; iterator . remove ( ) ; } } if ( mainFieldBuilder = = null ) { if ( fields = = null ) { return new StringFieldMapper . Builder ( name ) . index ( false ) ; } Mapper . TypeParser typeParser = parserContext . typeParser ( firstType ) ; if ( typeParser = = null ) { mainFieldBuilder = new StringFieldMapper . Builder ( name ) . index ( false ) ; } else { Mapper . Builder substitute = typeParser . parse ( name , Collections . < String , Object > emptyMap ( ) , parserContext ) ; if ( substitute instanceof FieldMapper . Builder ) { mainFieldBuilder = ( ( FieldMapper . Builder ) substitute ) . index ( false ) ; } else { mainFieldBuilder = new StringFieldMapper . Builder ( name ) . index ( false ) ; } } } if ( fields ! = null & & pathType ! = null ) { for ( Mapper . Builder field : fields ) { mainFieldBuilder . addMultiField ( field ) ; } mainFieldBuilder . multiFieldPathType ( pathType ) ; } else if ( fields ! = null ) { for ( Mapper . Builder field : fields ) { mainFieldBuilder . addMultiField ( field ) ; } } else if ( pathType ! = null ) { mainFieldBuilder . multiFieldPathType ( pathType ) ; } return mainFieldBuilder ; } } ; public static final String DOC_VALUES = <str> ; public static final String INDEX_OPTIONS_DOCS = <str> ; public static final String INDEX_OPTIONS_FREQS = <str> ; public static final String INDEX_OPTIONS_POSITIONS = <str> ; public static final String INDEX_OPTIONS_OFFSETS = <str> ; public static void parseNumberField ( NumberFieldMapper . Builder builder , String name , Map < String , Object > numberNode , Mapper . TypeParser . ParserContext parserContext ) { parseField ( builder , name , numberNode , parserContext ) ; for ( Iterator < Map . Entry < String , Object > > iterator = numberNode . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; Object propNode = entry . getValue ( ) ; if ( propName . equals ( <str> ) ) { builder . precisionStep ( nodeIntegerValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . ignoreMalformed ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . coerce ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . omitNorms ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . similarity ( parserContext . getSimilarity ( propNode . toString ( ) ) ) ; iterator . remove ( ) ; } else if ( parseMultiField ( builder , name , parserContext , propName , propNode ) ) { iterator . remove ( ) ; } } } private static void parseAnalyzersAndTermVectors ( FieldMapper . Builder builder , String name , Map < String , Object > fieldNode , Mapper . TypeParser . ParserContext parserContext ) { NamedAnalyzer indexAnalyzer = builder . fieldType ( ) . indexAnalyzer ( ) ; NamedAnalyzer searchAnalyzer = builder . fieldType ( ) . searchAnalyzer ( ) ; for ( Iterator < Map . Entry < String , Object > > iterator = fieldNode . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; final String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; final Object propNode = entry . getValue ( ) ; if ( propName . equals ( <str> ) ) { parseTermVector ( name , propNode . toString ( ) , builder ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . storeTermVectors ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . storeTermVectorOffsets ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . storeTermVectorPositions ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . storeTermVectorPayloads ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) | | propName . equals ( <str> ) & & parserContext . indexVersionCreated ( ) . before ( Version . V_2_0_0_beta1 ) ) { NamedAnalyzer analyzer = parserContext . analysisService ( ) . analyzer ( propNode . toString ( ) ) ; if ( analyzer = = null ) { throw new MapperParsingException ( <str> + propNode . toString ( ) + <str> + name + <str> ) ; } indexAnalyzer = analyzer ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { NamedAnalyzer analyzer = parserContext . analysisService ( ) . analyzer ( propNode . toString ( ) ) ; if ( analyzer = = null ) { throw new MapperParsingException ( <str> + propNode . toString ( ) + <str> + name + <str> ) ; } searchAnalyzer = analyzer ; iterator . remove ( ) ; } } if ( indexAnalyzer = = null ) { if ( searchAnalyzer ! = null ) { throw new MapperParsingException ( <str> + name + <str> ) ; } } else if ( searchAnalyzer = = null ) { searchAnalyzer = indexAnalyzer ; } builder . indexAnalyzer ( indexAnalyzer ) ; builder . searchAnalyzer ( searchAnalyzer ) ; } public static void parseTextField ( FieldMapper . Builder builder , String name , Map < String , Object > fieldNode , Mapper . TypeParser . ParserContext parserContext ) { parseField ( builder , name , fieldNode , parserContext ) ; parseAnalyzersAndTermVectors ( builder , name , fieldNode , parserContext ) ; } public static void parseField ( FieldMapper . Builder builder , String name , Map < String , Object > fieldNode , Mapper . TypeParser . ParserContext parserContext ) { Version indexVersionCreated = parserContext . indexVersionCreated ( ) ; for ( Iterator < Map . Entry < String , Object > > iterator = fieldNode . entrySet ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { Map . Entry < String , Object > entry = iterator . next ( ) ; final String propName = Strings . toUnderscoreCase ( entry . getKey ( ) ) ; final Object propNode = entry . getValue ( ) ; if ( propName . equals ( <str> ) & & indexVersionCreated . before ( Version . V_2_0_0_beta1 ) ) { builder . indexName ( propNode . toString ( ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . store ( parseStore ( name , propNode . toString ( ) ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { parseIndex ( name , propNode . toString ( ) , builder ) ; iterator . remove ( ) ; } else if ( propName . equals ( DOC_VALUES ) ) { builder . docValues ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . boost ( nodeFloatValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . omitNorms ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { final Map < String , Object > properties = nodeMapValue ( propNode , <str> ) ; for ( Iterator < Entry < String , Object > > propsIterator = properties . entrySet ( ) . iterator ( ) ; propsIterator . hasNext ( ) ; ) { Entry < String , Object > entry2 = propsIterator . next ( ) ; final String propName2 = Strings . toUnderscoreCase ( entry2 . getKey ( ) ) ; final Object propNode2 = entry2 . getValue ( ) ; if ( propName2 . equals ( <str> ) ) { builder . omitNorms ( ! nodeBooleanValue ( propNode2 ) ) ; propsIterator . remove ( ) ; } else if ( propName2 . equals ( Loading . KEY ) ) { builder . normsLoading ( Loading . parse ( nodeStringValue ( propNode2 , null ) , null ) ) ; propsIterator . remove ( ) ; } } DocumentMapperParser . checkNoRemainingFields ( propName , properties , parserContext . indexVersionCreated ( ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { final IndexOptions op = nodeBooleanValue ( propNode ) ? IndexOptions . DOCS : IndexOptions . DOCS_AND_FREQS_AND_POSITIONS ; if ( indexVersionCreated . onOrAfter ( Version . V_1_0_0_RC2 ) ) { throw new ElasticsearchParseException ( <str> ) ; } builder . indexOptions ( op ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . indexOptions ( nodeIndexOptionValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . includeInAll ( nodeBooleanValue ( propNode ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) & & indexVersionCreated . before ( Version . V_2_0_0_beta1 ) ) { iterator . remove ( ) ; } else if ( propName . equals ( <str> ) & & indexVersionCreated . before ( Version . V_2_0_0_beta1 ) ) { iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { builder . similarity ( parserContext . getSimilarity ( propNode . toString ( ) ) ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { final Settings settings = Settings . builder ( ) . put ( SettingsLoader . Helper . loadNestedFromMap ( nodeMapValue ( propNode , <str> ) ) ) . build ( ) ; builder . fieldDataSettings ( settings ) ; iterator . remove ( ) ; } else if ( propName . equals ( <str> ) ) { if ( parserContext . isWithinMultiField ( ) ) { if ( indexVersionCreated . after ( Version . V_2_1_0 ) | | ( indexVersionCreated . after ( Version . V_2_0_1 ) & & indexVersionCreated . before ( Version . V_2_1_0 ) ) ) { throw new MapperParsingException ( <str> + name + <str> ) ; } else { ESLoggerFactory . getLogger ( <str> + parserContext . type ( ) + <str> ) . warn ( <str> + name + <str> ) ; } } else { parseCopyFields ( propNode , builder ) ; } iterator . remove ( ) ; } } if ( indexVersionCreated . before ( Version . V_2_2_0 ) ) { parseAnalyzersAndTermVectors ( builder , name , fieldNode , parserContext ) ; } } public static boolean parseMultiField ( FieldMapper . Builder builder , String name , Mapper . TypeParser . ParserContext parserContext , String propName , Object propNode ) { parserContext = parserContext . createMultiFieldContext ( parserContext ) ; if ( propName . equals ( <str> ) & & parserContext . indexVersionCreated ( ) . before ( Version . V_2_0_0_beta1 ) ) { builder . multiFieldPathType ( parsePathType ( name , propNode . toString ( ) ) ) ; return true ; } else if ( propName . equals ( <str> ) ) { final Map < String , Object > multiFieldsPropNodes ; if ( propNode instanceof List & & ( ( List < ? > ) propNode ) . isEmpty ( ) ) { multiFieldsPropNodes = Collections . emptyMap ( ) ; } else if ( propNode instanceof Map ) { multiFieldsPropNodes = ( Map < String , Object > ) propNode ; } else { throw new MapperParsingException ( <str> + propNode + <str> + <str> + propName + <str> + propNode . getClass ( ) ) ; } for ( Map . Entry < String , Object > multiFieldEntry : multiFieldsPropNodes . entrySet ( ) ) { String multiFieldName = multiFieldEntry . getKey ( ) ; if ( multiFieldName . contains ( <str> ) ) { throw new MapperParsingException ( <str> + multiFieldName + <str> + name + <str> ) ; } if ( ! ( multiFieldEntry . getValue ( ) instanceof Map ) ) { throw new MapperParsingException ( <str> + multiFieldName + <str> ) ; } @SuppressWarnings ( <str> ) Map < String , Object > multiFieldNodes = ( Map < String , Object > ) multiFieldEntry . getValue ( ) ; String type ; Object typeNode = multiFieldNodes . get ( <str> ) ; if ( typeNode ! = null ) { type = typeNode . toString ( ) ; } else { throw new MapperParsingException ( <str> + multiFieldName + <str> ) ; } if ( type . equals ( ObjectMapper . CONTENT_TYPE ) | | type . equals ( ObjectMapper . NESTED_CONTENT_TYPE ) ) { throw new MapperParsingException ( <str> + type + <str> ) ; } Mapper . TypeParser typeParser = parserContext . typeParser ( type ) ; if ( typeParser = = null ) { throw new MapperParsingException ( <str> + type + <str> + multiFieldName + <str> ) ; } builder . addMultiField ( typeParser . parse ( multiFieldName , multiFieldNodes , parserContext ) ) ; multiFieldNodes . remove ( <str> ) ; DocumentMapperParser . checkNoRemainingFields ( propName , multiFieldNodes , parserContext . indexVersionCreated ( ) ) ; } return true ; } return false ; } private static IndexOptions nodeIndexOptionValue ( final Object propNode ) { final String value = propNode . toString ( ) ; if ( INDEX_OPTIONS_OFFSETS . equalsIgnoreCase ( value ) ) { return IndexOptions . DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS ; } else if ( INDEX_OPTIONS_POSITIONS . equalsIgnoreCase ( value ) ) { return IndexOptions . DOCS_AND_FREQS_AND_POSITIONS ; } else if ( INDEX_OPTIONS_FREQS . equalsIgnoreCase ( value ) ) { return IndexOptions . DOCS_AND_FREQS ; } else if ( INDEX_OPTIONS_DOCS . equalsIgnoreCase ( value ) ) { return IndexOptions . DOCS ; } else { throw new ElasticsearchParseException ( <str> , value ) ; } } public static FormatDateTimeFormatter parseDateTimeFormatter ( Object node ) { return Joda . forPattern ( node . toString ( ) ) ; } public static void parseTermVector ( String fieldName , String termVector , FieldMapper . Builder builder ) throws MapperParsingException { termVector = Strings . toUnderscoreCase ( termVector ) ; if ( <str> . equals ( termVector ) ) { builder . storeTermVectors ( false ) ; } else if ( <str> . equals ( termVector ) ) { builder . storeTermVectors ( true ) ; } else if ( <str> . equals ( termVector ) ) { builder . storeTermVectorOffsets ( true ) ; } else if ( <str> . equals ( termVector ) ) { builder . storeTermVectorPositions ( true ) ; } else if ( <str> . equals ( termVector ) ) { builder . storeTermVectorPositions ( true ) ; builder . storeTermVectorOffsets ( true ) ; } else if ( <str> . equals ( termVector ) ) { builder . storeTermVectorPositions ( true ) ; builder . storeTermVectorPayloads ( true ) ; } else if ( <str> . equals ( termVector ) ) { builder . storeTermVectorPositions ( true ) ; builder . storeTermVectorOffsets ( true ) ; builder . storeTermVectorPayloads ( true ) ; } else { throw new MapperParsingException ( <str> + termVector + <str> + fieldName + <str> ) ; } } public static void parseIndex ( String fieldName , String index , FieldMapper . Builder builder ) throws MapperParsingException { index = Strings . toUnderscoreCase ( index ) ; if ( <str> . equals ( index ) ) { builder . index ( false ) ; } else if ( <str> . equals ( index ) ) { builder . index ( true ) ; builder . tokenized ( false ) ; } else if ( <str> . equals ( index ) ) { builder . index ( true ) ; builder . tokenized ( true ) ; } else { throw new MapperParsingException ( <str> + index + <str> + fieldName + <str> ) ; } } public static boolean parseStore ( String fieldName , String store ) throws MapperParsingException { if ( <str> . equals ( store ) ) { return false ; } else if ( <str> . equals ( store ) ) { return true ; } else { return nodeBooleanValue ( store ) ; } } public static ContentPath . Type parsePathType ( String name , String path ) throws MapperParsingException { path = Strings . toUnderscoreCase ( path ) ; if ( <str> . equals ( path ) ) { return ContentPath . Type . JUST_NAME ; } else if ( <str> . equals ( path ) ) { return ContentPath . Type . FULL ; } else { throw new MapperParsingException ( <str> + path + <str> + name + <str> ) ; } } @SuppressWarnings ( <str> ) public static void parseCopyFields ( Object propNode , FieldMapper . Builder builder ) { FieldMapper . CopyTo . Builder copyToBuilder = new FieldMapper . CopyTo . Builder ( ) ; if ( isArray ( propNode ) ) { for ( Object node : ( List < Object > ) propNode ) { copyToBuilder . add ( nodeStringValue ( node , null ) ) ; } } else { copyToBuilder . add ( nodeStringValue ( propNode , null ) ) ; } builder . copyTo ( copyToBuilder . build ( ) ) ; } } 
