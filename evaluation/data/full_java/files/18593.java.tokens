package com . badlogic . gdx . tests . box2d ; import com . badlogic . gdx . Input . Keys ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . physics . box2d . Body ; import com . badlogic . gdx . physics . box2d . BodyDef ; import com . badlogic . gdx . physics . box2d . BodyDef . BodyType ; import com . badlogic . gdx . physics . box2d . EdgeShape ; import com . badlogic . gdx . physics . box2d . FixtureDef ; import com . badlogic . gdx . physics . box2d . PolygonShape ; import com . badlogic . gdx . physics . box2d . Transform ; import com . badlogic . gdx . physics . box2d . World ; import com . badlogic . gdx . physics . box2d . joints . FrictionJointDef ; public class ApplyForce extends Box2DTest { Body m_body ; @Override protected void createWorld ( World world ) { world . setGravity ( new Vector2 ( <int> , <int> ) ) ; float k_restitution = <float> ; Body ground ; { BodyDef bd = new BodyDef ( ) ; bd . position . set ( <int> , <int> ) ; ground = world . createBody ( bd ) ; EdgeShape shape = new EdgeShape ( ) ; FixtureDef sd = new FixtureDef ( ) ; sd . shape = shape ; sd . density = <int> ; sd . restitution = k_restitution ; shape . set ( new Vector2 ( - <int> , - <int> ) , new Vector2 ( - <int> , <int> ) ) ; ground . createFixture ( sd ) ; shape . set ( new Vector2 ( <int> , - <int> ) , new Vector2 ( <int> , <int> ) ) ; ground . createFixture ( sd ) ; shape . set ( new Vector2 ( - <int> , <int> ) , new Vector2 ( <int> , <int> ) ) ; ground . createFixture ( sd ) ; shape . set ( new Vector2 ( - <int> , - <int> ) , new Vector2 ( <int> , - <int> ) ) ; ground . createFixture ( sd ) ; shape . dispose ( ) ; } { Transform xf1 = new Transform ( new Vector2 ( ) , <float> * ( float ) Math . PI ) ; xf1 . setPosition ( xf1 . mul ( new Vector2 ( <int> , <int> ) ) ) ; Vector2 [ ] vertices = new Vector2 [ <int> ] ; vertices [ <int> ] = xf1 . mul ( new Vector2 ( - <int> , <int> ) ) ; vertices [ <int> ] = xf1 . mul ( new Vector2 ( <int> , <int> ) ) ; vertices [ <int> ] = xf1 . mul ( new Vector2 ( <int> , <float> ) ) ; PolygonShape poly1 = new PolygonShape ( ) ; poly1 . set ( vertices ) ; FixtureDef sd1 = new FixtureDef ( ) ; sd1 . shape = poly1 ; sd1 . density = <float> ; Transform xf2 = new Transform ( new Vector2 ( ) , - <float> * ( float ) Math . PI ) ; xf2 . setPosition ( xf2 . mul ( new Vector2 ( - <int> , <int> ) ) ) ; vertices [ <int> ] = xf2 . mul ( new Vector2 ( - <int> , <int> ) ) ; vertices [ <int> ] = xf2 . mul ( new Vector2 ( <int> , <int> ) ) ; vertices [ <int> ] = xf2 . mul ( new Vector2 ( <int> , <float> ) ) ; PolygonShape poly2 = new PolygonShape ( ) ; poly2 . set ( vertices ) ; FixtureDef sd2 = new FixtureDef ( ) ; sd2 . shape = poly2 ; sd2 . density = <float> ; BodyDef bd = new BodyDef ( ) ; bd . type = BodyType . DynamicBody ; bd . angularDamping = <float> ; bd . linearDamping = <float> ; bd . position . set ( <int> , <int> ) ; bd . angle = ( float ) Math . PI ; bd . allowSleep = false ; m_body = world . createBody ( bd ) ; m_body . createFixture ( sd1 ) ; m_body . createFixture ( sd2 ) ; poly1 . dispose ( ) ; poly2 . dispose ( ) ; } { PolygonShape shape = new PolygonShape ( ) ; shape . setAsBox ( <float> , <float> ) ; FixtureDef fd = new FixtureDef ( ) ; fd . shape = shape ; fd . density = <float> ; fd . friction = <float> ; for ( int i = <int> ; i < <int> ; i + + ) { BodyDef bd = new BodyDef ( ) ; bd . type = BodyType . DynamicBody ; bd . position . set ( <int> , <int> + <float> * i ) ; Body body = world . createBody ( bd ) ; body . createFixture ( fd ) ; float gravity = <float> ; float I = body . getInertia ( ) ; float mass = body . getMass ( ) ; float radius = ( float ) Math . sqrt ( <int> * I / mass ) ; FrictionJointDef jd = new FrictionJointDef ( ) ; jd . localAnchorA . set ( <int> , <int> ) ; jd . localAnchorB . set ( <int> , <int> ) ; jd . bodyA = ground ; jd . bodyB = body ; jd . collideConnected = true ; jd . maxForce = mass * gravity ; jd . maxTorque = mass * radius * gravity ; world . createJoint ( jd ) ; } shape . dispose ( ) ; } } private final Vector2 tmp = new Vector2 ( ) ; public boolean keyDown ( int keyCode ) { if ( keyCode = = Keys . W ) { Vector2 f = m_body . getWorldVector ( tmp . set ( <int> , - <int> ) ) ; Vector2 p = m_body . getWorldPoint ( tmp . set ( <int> , <int> ) ) ; m_body . applyForce ( f , p , true ) ; } if ( keyCode = = Keys . A ) m_body . applyTorque ( <int> , true ) ; if ( keyCode = = Keys . D ) m_body . applyTorque ( - <int> , true ) ; return false ; } } 
