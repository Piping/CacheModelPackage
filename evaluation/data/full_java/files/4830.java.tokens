package org . eclipse . ui . internal . console ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . OperationCanceledException ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . IJobManager ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . jface . text . BadLocationException ; import org . eclipse . jface . text . DocumentEvent ; import org . eclipse . jface . text . IDocument ; import org . eclipse . jface . text . IDocumentPartitionerExtension ; import org . eclipse . jface . text . IRegion ; import org . eclipse . jface . text . ITypedRegion ; import org . eclipse . jface . text . Region ; import org . eclipse . swt . custom . StyleRange ; import org . eclipse . swt . widgets . Display ; import org . eclipse . ui . console . ConsolePlugin ; import org . eclipse . ui . console . IConsoleDocumentPartitioner ; import org . eclipse . ui . console . IOConsole ; import org . eclipse . ui . console . IOConsoleInputStream ; import org . eclipse . ui . console . IOConsoleOutputStream ; import org . eclipse . ui . progress . UIJob ; import org . eclipse . ui . progress . WorkbenchJob ; public class IOConsolePartitioner implements IConsoleDocumentPartitioner , IDocumentPartitionerExtension { private PendingPartition consoleClosedPartition ; private IDocument document ; private ArrayList < IOConsolePartition > partitions ; private ArrayList < PendingPartition > pendingPartitions ; private ArrayList < PendingPartition > updatePartitions ; private IOConsolePartition lastPartition ; private QueueProcessingJob queueJob ; private IOConsoleInputStream inputStream ; private boolean updateInProgress ; private ArrayList < IOConsolePartition > inputPartitions ; private int firstOffset ; private String [ ] lld ; private int highWaterMark = - <int> ; private int lowWaterMark = - <int> ; private boolean connected = false ; private IOConsole console ; private TrimJob trimJob = new TrimJob ( ) ; private Object overflowLock = new Object ( ) ; private int fBuffer ; public IOConsolePartitioner ( IOConsoleInputStream inputStream , IOConsole console ) { this . inputStream = inputStream ; this . console = console ; trimJob . setRule ( console . getSchedulingRule ( ) ) ; } public IDocument getDocument ( ) { return document ; } @Override public void connect ( IDocument doc ) { document = doc ; document . setDocumentPartitioner ( this ) ; lld = document . getLegalLineDelimiters ( ) ; partitions = new ArrayList < IOConsolePartition > ( ) ; pendingPartitions = new ArrayList < PendingPartition > ( ) ; inputPartitions = new ArrayList < IOConsolePartition > ( ) ; queueJob = new QueueProcessingJob ( ) ; queueJob . setSystem ( true ) ; queueJob . setPriority ( Job . INTERACTIVE ) ; queueJob . setRule ( console . getSchedulingRule ( ) ) ; connected = true ; } public int getHighWaterMark ( ) { return highWaterMark ; } public int getLowWaterMark ( ) { return lowWaterMark ; } public void setWaterMarks ( int low , int high ) { lowWaterMark = low ; highWaterMark = high ; ConsolePlugin . getStandardDisplay ( ) . asyncExec ( new Runnable ( ) { @Override public void run ( ) { checkBufferSize ( ) ; } } ) ; } public void streamsClosed ( ) { consoleClosedPartition = new PendingPartition ( null , null ) ; synchronized ( pendingPartitions ) { pendingPartitions . add ( consoleClosedPartition ) ; } queueJob . schedule ( ) ; } @Override public void disconnect ( ) { synchronized ( overflowLock ) { document = null ; partitions . clear ( ) ; connected = false ; try { inputStream . close ( ) ; } catch ( IOException e ) { } } } @Override public void documentAboutToBeChanged ( DocumentEvent event ) { } @Override public boolean documentChanged ( DocumentEvent event ) { return documentChanged2 ( event ) ! = null ; } @Override public String [ ] getLegalContentTypes ( ) { return new String [ ] { IOConsolePartition . OUTPUT_PARTITION_TYPE , IOConsolePartition . INPUT_PARTITION_TYPE } ; } @Override public String getContentType ( int offset ) { return getPartition ( offset ) . getType ( ) ; } @Override public ITypedRegion [ ] computePartitioning ( int offset , int length ) { int rangeEnd = offset + length ; int left = <int> ; int right = partitions . size ( ) - <int> ; int mid = <int> ; IOConsolePartition position = null ; if ( left = = right ) { return new IOConsolePartition [ ] { partitions . get ( <int> ) } ; } while ( left < right ) { mid = ( left + right ) / <int> ; position = partitions . get ( mid ) ; if ( rangeEnd < position . getOffset ( ) ) { if ( left = = mid ) { right = left ; } else { right = mid - <int> ; } } else if ( offset > ( position . getOffset ( ) + position . getLength ( ) - <int> ) ) { if ( right = = mid ) { left = right ; } else { left = mid + <int> ; } } else { left = right = mid ; } } List < IOConsolePartition > list = new ArrayList < IOConsolePartition > ( ) ; int index = left - <int> ; if ( index > = <int> ) { position = partitions . get ( index ) ; while ( index > = <int> & & ( position . getOffset ( ) + position . getLength ( ) ) > offset ) { index - - ; if ( index > = <int> ) { position = partitions . get ( index ) ; } } } index + + ; position = partitions . get ( index ) ; while ( index < partitions . size ( ) & & ( position . getOffset ( ) < rangeEnd ) ) { list . add ( position ) ; index + + ; if ( index < partitions . size ( ) ) { position = partitions . get ( index ) ; } } return list . toArray ( new IOConsolePartition [ list . size ( ) ] ) ; } @Override public ITypedRegion getPartition ( int offset ) { for ( int i = <int> ; i < partitions . size ( ) ; i + + ) { ITypedRegion partition = partitions . get ( i ) ; int start = partition . getOffset ( ) ; int end = start + partition . getLength ( ) ; if ( offset > = start & & offset < end ) { return partition ; } } if ( lastPartition = = null ) { synchronized ( partitions ) { lastPartition = new IOConsolePartition ( inputStream , <str> ) ; lastPartition . setOffset ( offset ) ; partitions . add ( lastPartition ) ; inputPartitions . add ( lastPartition ) ; } } return lastPartition ; } private void checkBufferSize ( ) { if ( document ! = null & & highWaterMark > <int> ) { int length = document . getLength ( ) ; if ( length > highWaterMark ) { if ( trimJob . getState ( ) = = Job . NONE ) { trimJob . setOffset ( length - lowWaterMark ) ; trimJob . schedule ( ) ; } } } } public void clearBuffer ( ) { synchronized ( overflowLock ) { trimJob . setOffset ( - <int> ) ; trimJob . schedule ( ) ; } } @Override public IRegion documentChanged2 ( DocumentEvent event ) { if ( document = = null ) { return null ; } if ( document . getLength ( ) = = <int> ) { if ( lastPartition ! = null & & lastPartition . getType ( ) . equals ( IOConsolePartition . INPUT_PARTITION_TYPE ) ) { synchronized ( partitions ) { partitions . remove ( lastPartition ) ; inputPartitions . remove ( lastPartition ) ; } } lastPartition = null ; return new Region ( <int> , <int> ) ; } if ( updateInProgress ) { synchronized ( partitions ) { if ( updatePartitions ! = null ) { for ( PendingPartition pp : updatePartitions ) { if ( pp = = consoleClosedPartition ) { continue ; } int ppLen = pp . text . length ( ) ; if ( lastPartition ! = null & & lastPartition . getStream ( ) = = pp . stream ) { int len = lastPartition . getLength ( ) ; lastPartition . setLength ( len + ppLen ) ; } else { IOConsolePartition partition = new IOConsolePartition ( pp . stream , ppLen ) ; partition . setOffset ( firstOffset ) ; lastPartition = partition ; partitions . add ( partition ) ; } firstOffset + = ppLen ; } } } } else { int amountDeleted = event . getLength ( ) ; if ( amountDeleted > <int> ) { int offset = event . fOffset ; IOConsolePartition partition = ( IOConsolePartition ) getPartition ( offset ) ; if ( partition = = lastPartition ) { partition . delete ( event . fOffset - partition . getOffset ( ) , amountDeleted ) ; } } synchronized ( partitions ) { if ( lastPartition = = null | | lastPartition . isReadOnly ( ) ) { lastPartition = new IOConsolePartition ( inputStream , event . fText ) ; lastPartition . setOffset ( event . fOffset ) ; partitions . add ( lastPartition ) ; inputPartitions . add ( lastPartition ) ; } else { lastPartition . insert ( event . fText , ( event . fOffset - lastPartition . getOffset ( ) ) ) ; } int lastLineDelimiter = - <int> ; String partitionText = lastPartition . getString ( ) ; for ( int i = <int> ; i < lld . length ; i + + ) { String ld = lld [ i ] ; int index = partitionText . lastIndexOf ( ld ) ; if ( index ! = - <int> ) { index + = ld . length ( ) ; } if ( index > lastLineDelimiter ) { lastLineDelimiter = index ; } } if ( lastLineDelimiter ! = - <int> ) { StringBuffer input = new StringBuffer ( ) ; Iterator < IOConsolePartition > it = inputPartitions . iterator ( ) ; while ( it . hasNext ( ) ) { IOConsolePartition partition = it . next ( ) ; if ( partition . getOffset ( ) + partition . getLength ( ) < = event . fOffset + lastLineDelimiter ) { if ( partition = = lastPartition ) { lastPartition = null ; } input . append ( partition . getString ( ) ) ; partition . clearBuffer ( ) ; partition . setReadOnly ( ) ; it . remove ( ) ; } else { String contentBefore = partitionText . substring ( <int> , lastLineDelimiter ) ; IOConsolePartition newPartition = new IOConsolePartition ( inputStream , contentBefore ) ; newPartition . setOffset ( partition . getOffset ( ) ) ; newPartition . setReadOnly ( ) ; newPartition . clearBuffer ( ) ; int index = partitions . indexOf ( partition ) ; partitions . add ( index , newPartition ) ; input . append ( contentBefore ) ; partition . delete ( <int> , lastLineDelimiter ) ; partition . setOffset ( lastLineDelimiter + partition . getOffset ( ) ) ; lastLineDelimiter = <int> ; } } if ( input . length ( ) > <int> ) { inputStream . appendData ( input . toString ( ) ) ; } } } } return new Region ( event . fOffset , event . fText . length ( ) ) ; } private void setUpdateInProgress ( boolean b ) { updateInProgress = b ; } public void streamAppended ( IOConsoleOutputStream stream , String s ) throws IOException { if ( document = = null ) { throw new IOException ( <str> ) ; } synchronized ( pendingPartitions ) { PendingPartition last = pendingPartitions . size ( ) > <int> ? pendingPartitions . get ( pendingPartitions . size ( ) - <int> ) : null ; if ( last ! = null & & last . stream = = stream ) { last . append ( s ) ; } else { pendingPartitions . add ( new PendingPartition ( stream , s ) ) ; if ( fBuffer > <int> ) { queueJob . schedule ( ) ; } else { queueJob . schedule ( <int> ) ; } } if ( fBuffer > <int> ) { if ( Display . getCurrent ( ) = = null ) { try { pendingPartitions . wait ( ) ; } catch ( InterruptedException e ) { } } else { processQueue ( ) ; } } } } private class PendingPartition { StringBuffer text = new StringBuffer ( <int> ) ; IOConsoleOutputStream stream ; PendingPartition ( IOConsoleOutputStream stream , String text ) { this . stream = stream ; if ( text ! = null ) { append ( text ) ; } } void append ( String moreText ) { text . append ( moreText ) ; fBuffer + = moreText . length ( ) ; } } private class QueueProcessingJob extends UIJob { QueueProcessingJob ( ) { super ( <str> ) ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { processQueue ( ) ; return Status . OK_STATUS ; } @Override public boolean shouldRun ( ) { boolean shouldRun = connected & & pendingPartitions ! = null & & pendingPartitions . size ( ) > <int> ; return shouldRun ; } } void processQueue ( ) { synchronized ( overflowLock ) { ArrayList < PendingPartition > pendingCopy = new ArrayList < PendingPartition > ( ) ; StringBuffer buffer = null ; boolean consoleClosed = false ; synchronized ( pendingPartitions ) { pendingCopy . addAll ( pendingPartitions ) ; pendingPartitions . clear ( ) ; fBuffer = <int> ; pendingPartitions . notifyAll ( ) ; } int size = <int> ; for ( PendingPartition pp : pendingCopy ) { if ( pp ! = consoleClosedPartition ) { size + = pp . text . length ( ) ; } } buffer = new StringBuffer ( size ) ; for ( PendingPartition pp : pendingCopy ) { if ( pp ! = consoleClosedPartition ) { buffer . append ( pp . text ) ; } else { consoleClosed = true ; } } if ( connected ) { setUpdateInProgress ( true ) ; updatePartitions = pendingCopy ; firstOffset = document . getLength ( ) ; try { if ( buffer ! = null ) { document . replace ( firstOffset , <int> , buffer . toString ( ) ) ; } } catch ( BadLocationException e ) { } updatePartitions = null ; setUpdateInProgress ( false ) ; } if ( consoleClosed ) { console . partitionerFinished ( ) ; } checkBufferSize ( ) ; } } private class TrimJob extends WorkbenchJob { private int truncateOffset ; TrimJob ( ) { super ( <str> ) ; setSystem ( true ) ; } public void setOffset ( int offset ) { truncateOffset = offset ; } @Override public IStatus runInUIThread ( IProgressMonitor monitor ) { IJobManager jobManager = Job . getJobManager ( ) ; try { jobManager . join ( console , monitor ) ; } catch ( OperationCanceledException e1 ) { return Status . CANCEL_STATUS ; } catch ( InterruptedException e1 ) { return Status . CANCEL_STATUS ; } if ( document = = null ) { return Status . OK_STATUS ; } int length = document . getLength ( ) ; if ( truncateOffset < length ) { synchronized ( overflowLock ) { try { if ( truncateOffset < <int> ) { setUpdateInProgress ( true ) ; document . set ( <str> ) ; setUpdateInProgress ( false ) ; partitions . clear ( ) ; } else { int cutoffLine = document . getLineOfOffset ( truncateOffset ) ; int cutOffset = document . getLineOffset ( cutoffLine ) ; IOConsolePartition partition = ( IOConsolePartition ) getPartition ( cutOffset ) ; partition . setLength ( partition . getOffset ( ) + partition . getLength ( ) - cutOffset ) ; setUpdateInProgress ( true ) ; document . replace ( <int> , cutOffset , <str> ) ; setUpdateInProgress ( false ) ; int index = partitions . indexOf ( partition ) ; for ( int i = <int> ; i < index ; i + + ) { partitions . remove ( <int> ) ; } int offset = <int> ; for ( IOConsolePartition p : partitions ) { p . setOffset ( offset ) ; offset + = p . getLength ( ) ; } } } catch ( BadLocationException e ) { } } } return Status . OK_STATUS ; } } @Override public boolean isReadOnly ( int offset ) { return ( ( IOConsolePartition ) getPartition ( offset ) ) . isReadOnly ( ) ; } @Override public StyleRange [ ] getStyleRanges ( int offset , int length ) { if ( ! connected ) { return new StyleRange [ <int> ] ; } IOConsolePartition [ ] computedPartitions = ( IOConsolePartition [ ] ) computePartitioning ( offset , length ) ; StyleRange [ ] styles = new StyleRange [ computedPartitions . length ] ; for ( int i = <int> ; i < computedPartitions . length ; i + + ) { int rangeStart = Math . max ( computedPartitions [ i ] . getOffset ( ) , offset ) ; int rangeLength = computedPartitions [ i ] . getLength ( ) ; styles [ i ] = computedPartitions [ i ] . getStyleRange ( rangeStart , rangeLength ) ; } return styles ; } } 
