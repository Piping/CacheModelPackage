package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import com . google . common . primitives . Ints ; import java . util . Collections ; import java . util . List ; import java . util . Set ; class CollectionBenchmarkSampleData { private final boolean isUserTypeFast ; private final SpecialRandom random ; private final double hitRate ; private final int size ; private final Set < Element > valuesInSet ; private final Element [ ] queries ; CollectionBenchmarkSampleData ( int size ) { this ( true , new SpecialRandom ( ) , <float> , size ) ; } CollectionBenchmarkSampleData ( boolean isUserTypeFast , SpecialRandom random , double hitRate , int size ) { this . isUserTypeFast = isUserTypeFast ; this . random = checkNotNull ( random ) ; this . hitRate = hitRate ; this . size = size ; this . valuesInSet = createData ( ) ; this . queries = createQueries ( valuesInSet , <int> ) ; } Set < Element > getValuesInSet ( ) { return valuesInSet ; } Element [ ] getQueries ( ) { return queries ; } private Element [ ] createQueries ( Set < Element > elementsInSet , int numQueries ) { List < Element > queryList = Lists . newArrayListWithCapacity ( numQueries ) ; int numGoodQueries = ( int ) ( numQueries * hitRate + <float> ) ; int size = elementsInSet . size ( ) ; if ( size > <int> ) { int minCopiesOfEachGoodQuery = numGoodQueries / size ; int extras = numGoodQueries % size ; for ( int i = <int> ; i < minCopiesOfEachGoodQuery ; i + + ) { queryList . addAll ( elementsInSet ) ; } List < Element > tmp = Lists . newArrayList ( elementsInSet ) ; Collections . shuffle ( tmp , random ) ; queryList . addAll ( tmp . subList ( <int> , extras ) ) ; } while ( queryList . size ( ) < numQueries ) { Element candidate = newElement ( ) ; if ( ! elementsInSet . contains ( candidate ) ) { queryList . add ( candidate ) ; } } Collections . shuffle ( queryList , random ) ; return queryList . toArray ( new Element [ <int> ] ) ; } private Set < Element > createData ( ) { Set < Element > set = Sets . newHashSetWithExpectedSize ( size ) ; while ( set . size ( ) < size ) { set . add ( newElement ( ) ) ; } return set ; } private Element newElement ( ) { int value = random . nextInt ( ) ; return isUserTypeFast ? new Element ( value ) : new SlowElement ( value ) ; } static class Element implements Comparable < Element > { final int hash ; Element ( int hash ) { this . hash = hash ; } @Override public boolean equals ( Object obj ) { return this = = obj | | ( obj instanceof Element & & ( ( Element ) obj ) . hash = = hash ) ; } @Override public int hashCode ( ) { return hash ; } @Override public int compareTo ( Element that ) { return Ints . compare ( hash , that . hash ) ; } @Override public String toString ( ) { return String . valueOf ( hash ) ; } } static class SlowElement extends Element { SlowElement ( int hash ) { super ( hash ) ; } @Override public boolean equals ( Object obj ) { return slowItDown ( ) ! = <int> & & super . equals ( obj ) ; } @Override public int hashCode ( ) { return slowItDown ( ) + hash ; } @Override public int compareTo ( Element e ) { int x = slowItDown ( ) ; return x + super . compareTo ( e ) - x ; } static int slowItDown ( ) { int result = <int> ; for ( int i = <int> ; i < = <int> ; i + + ) { result + = i ; } return result ; } } } 
