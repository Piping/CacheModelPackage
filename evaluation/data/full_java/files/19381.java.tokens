package io . netty . handler . codec . http2 . hpack ; import io . netty . handler . codec . http2 . hpack . HpackUtil . IndexType ; import java . io . IOException ; import java . io . OutputStream ; import java . util . Arrays ; public final class Encoder { private static final int BUCKET_SIZE = <int> ; private static final byte [ ] EMPTY = { } ; private final boolean useIndexing ; private final boolean forceHuffmanOn ; private final boolean forceHuffmanOff ; private final HeaderEntry [ ] headerFields = new HeaderEntry [ BUCKET_SIZE ] ; private final HeaderEntry head = new HeaderEntry ( - <int> , EMPTY , EMPTY , Integer . MAX_VALUE , null ) ; private int size ; private int capacity ; public Encoder ( int maxHeaderTableSize ) { this ( maxHeaderTableSize , true , false , false ) ; } Encoder ( int maxHeaderTableSize , boolean useIndexing , boolean forceHuffmanOn , boolean forceHuffmanOff ) { if ( maxHeaderTableSize < <int> ) { throw new IllegalArgumentException ( <str> + maxHeaderTableSize ) ; } this . useIndexing = useIndexing ; this . forceHuffmanOn = forceHuffmanOn ; this . forceHuffmanOff = forceHuffmanOff ; this . capacity = maxHeaderTableSize ; head . before = head . after = head ; } public void encodeHeader ( OutputStream out , byte [ ] name , byte [ ] value , boolean sensitive ) throws IOException { if ( sensitive ) { int nameIndex = getNameIndex ( name ) ; encodeLiteral ( out , name , value , IndexType . NEVER , nameIndex ) ; return ; } if ( capacity = = <int> ) { int staticTableIndex = StaticTable . getIndex ( name , value ) ; if ( staticTableIndex = = - <int> ) { int nameIndex = StaticTable . getIndex ( name ) ; encodeLiteral ( out , name , value , IndexType . NONE , nameIndex ) ; } else { encodeInteger ( out , <hex> , <int> , staticTableIndex ) ; } return ; } int headerSize = HeaderField . sizeOf ( name , value ) ; if ( headerSize > capacity ) { int nameIndex = getNameIndex ( name ) ; encodeLiteral ( out , name , value , IndexType . NONE , nameIndex ) ; return ; } HeaderEntry headerField = getEntry ( name , value ) ; if ( headerField ! = null ) { int index = getIndex ( headerField . index ) + StaticTable . length ; encodeInteger ( out , <hex> , <int> , index ) ; } else { int staticTableIndex = StaticTable . getIndex ( name , value ) ; if ( staticTableIndex ! = - <int> ) { encodeInteger ( out , <hex> , <int> , staticTableIndex ) ; } else { int nameIndex = getNameIndex ( name ) ; if ( useIndexing ) { ensureCapacity ( headerSize ) ; } IndexType indexType = useIndexing ? IndexType . INCREMENTAL : IndexType . NONE ; encodeLiteral ( out , name , value , indexType , nameIndex ) ; if ( useIndexing ) { add ( name , value ) ; } } } } public void setMaxHeaderTableSize ( OutputStream out , int maxHeaderTableSize ) throws IOException { if ( maxHeaderTableSize < <int> ) { throw new IllegalArgumentException ( <str> + maxHeaderTableSize ) ; } if ( capacity = = maxHeaderTableSize ) { return ; } capacity = maxHeaderTableSize ; ensureCapacity ( <int> ) ; encodeInteger ( out , <hex> , <int> , maxHeaderTableSize ) ; } public int getMaxHeaderTableSize ( ) { return capacity ; } private static void encodeInteger ( OutputStream out , int mask , int n , int i ) throws IOException { if ( n < <int> | | n > <int> ) { throw new IllegalArgumentException ( <str> + n ) ; } int nbits = <hex> > > > ( <int> - n ) ; if ( i < nbits ) { out . write ( mask | i ) ; } else { out . write ( mask | nbits ) ; int length = i - nbits ; while ( true ) { if ( ( length & ~ <hex> ) = = <int> ) { out . write ( length ) ; return ; } else { out . write ( ( length & <hex> ) | <hex> ) ; length > > > = <int> ; } } } } private void encodeStringLiteral ( OutputStream out , byte [ ] string ) throws IOException { int huffmanLength = Huffman . ENCODER . getEncodedLength ( string ) ; if ( ( huffmanLength < string . length & & ! forceHuffmanOff ) | | forceHuffmanOn ) { encodeInteger ( out , <hex> , <int> , huffmanLength ) ; Huffman . ENCODER . encode ( out , string ) ; } else { encodeInteger ( out , <hex> , <int> , string . length ) ; out . write ( string , <int> , string . length ) ; } } private void encodeLiteral ( OutputStream out , byte [ ] name , byte [ ] value , IndexType indexType , int nameIndex ) throws IOException { int mask ; int prefixBits ; switch ( indexType ) { case INCREMENTAL : mask = <hex> ; prefixBits = <int> ; break ; case NONE : mask = <hex> ; prefixBits = <int> ; break ; case NEVER : mask = <hex> ; prefixBits = <int> ; break ; default : throw new IllegalStateException ( <str> ) ; } encodeInteger ( out , mask , prefixBits , nameIndex = = - <int> ? <int> : nameIndex ) ; if ( nameIndex = = - <int> ) { encodeStringLiteral ( out , name ) ; } encodeStringLiteral ( out , value ) ; } private int getNameIndex ( byte [ ] name ) { int index = StaticTable . getIndex ( name ) ; if ( index = = - <int> ) { index = getIndex ( name ) ; if ( index > = <int> ) { index + = StaticTable . length ; } } return index ; } private void ensureCapacity ( int headerSize ) throws IOException { while ( size + headerSize > capacity ) { int index = length ( ) ; if ( index = = <int> ) { break ; } remove ( ) ; } } int length ( ) { return size = = <int> ? <int> : head . after . index - head . before . index + <int> ; } int size ( ) { return size ; } HeaderField getHeaderField ( int index ) { HeaderEntry entry = head ; while ( index - - > = <int> ) { entry = entry . before ; } return entry ; } private HeaderEntry getEntry ( byte [ ] name , byte [ ] value ) { if ( length ( ) = = <int> | | name = = null | | value = = null ) { return null ; } int h = hash ( name ) ; int i = index ( h ) ; for ( HeaderEntry e = headerFields [ i ] ; e ! = null ; e = e . next ) { if ( e . hash = = h & & HpackUtil . equals ( name , e . name ) & & HpackUtil . equals ( value , e . value ) ) { return e ; } } return null ; } private int getIndex ( byte [ ] name ) { if ( length ( ) = = <int> | | name = = null ) { return - <int> ; } int h = hash ( name ) ; int i = index ( h ) ; int index = - <int> ; for ( HeaderEntry e = headerFields [ i ] ; e ! = null ; e = e . next ) { if ( e . hash = = h & & HpackUtil . equals ( name , e . name ) ) { index = e . index ; break ; } } return getIndex ( index ) ; } private int getIndex ( int index ) { if ( index = = - <int> ) { return index ; } return index - head . before . index + <int> ; } private void add ( byte [ ] name , byte [ ] value ) { int headerSize = HeaderField . sizeOf ( name , value ) ; if ( headerSize > capacity ) { clear ( ) ; return ; } while ( size + headerSize > capacity ) { remove ( ) ; } name = Arrays . copyOf ( name , name . length ) ; value = Arrays . copyOf ( value , value . length ) ; int h = hash ( name ) ; int i = index ( h ) ; HeaderEntry old = headerFields [ i ] ; HeaderEntry e = new HeaderEntry ( h , name , value , head . before . index - <int> , old ) ; headerFields [ i ] = e ; e . addBefore ( head ) ; size + = headerSize ; } private HeaderField remove ( ) { if ( size = = <int> ) { return null ; } HeaderEntry eldest = head . after ; int h = eldest . hash ; int i = index ( h ) ; HeaderEntry prev = headerFields [ i ] ; HeaderEntry e = prev ; while ( e ! = null ) { HeaderEntry next = e . next ; if ( e = = eldest ) { if ( prev = = eldest ) { headerFields [ i ] = next ; } else { prev . next = next ; } eldest . remove ( ) ; size - = eldest . size ( ) ; return eldest ; } prev = e ; e = next ; } return null ; } private void clear ( ) { Arrays . fill ( headerFields , null ) ; head . before = head . after = head ; this . size = <int> ; } private static int hash ( byte [ ] name ) { int h = <int> ; for ( int i = <int> ; i < name . length ; i + + ) { h = <int> * h + name [ i ] ; } if ( h > <int> ) { return h ; } else if ( h = = Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } else { return - h ; } } private static int index ( int h ) { return h % BUCKET_SIZE ; } private static class HeaderEntry extends HeaderField { HeaderEntry before , after ; HeaderEntry next ; int hash ; int index ; HeaderEntry ( int hash , byte [ ] name , byte [ ] value , int index , HeaderEntry next ) { super ( name , value ) ; this . index = index ; this . hash = hash ; this . next = next ; } private void remove ( ) { before . after = after ; after . before = before ; } private void addBefore ( HeaderEntry existingEntry ) { after = existingEntry ; before = existingEntry . before ; before . after = this ; after . before = this ; } } } 
