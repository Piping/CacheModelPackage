package clojure . asm . commons ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import clojure . asm . Handle ; import clojure . asm . Label ; import clojure . asm . MethodVisitor ; import clojure . asm . Opcodes ; import clojure . asm . Type ; public class AnalyzerAdapter extends MethodVisitor { public List < Object > locals ; public List < Object > stack ; private List < Label > labels ; public Map < Object , Object > uninitializedTypes ; private int maxStack ; private int maxLocals ; private String owner ; public AnalyzerAdapter ( final String owner , final int access , final String name , final String desc , final MethodVisitor mv ) { this ( Opcodes . ASM4 , owner , access , name , desc , mv ) ; } protected AnalyzerAdapter ( final int api , final String owner , final int access , final String name , final String desc , final MethodVisitor mv ) { super ( api , mv ) ; this . owner = owner ; locals = new ArrayList < Object > ( ) ; stack = new ArrayList < Object > ( ) ; uninitializedTypes = new HashMap < Object , Object > ( ) ; if ( ( access & Opcodes . ACC_STATIC ) = = <int> ) { if ( <str> . equals ( name ) ) { locals . add ( Opcodes . UNINITIALIZED_THIS ) ; } else { locals . add ( owner ) ; } } Type [ ] types = Type . getArgumentTypes ( desc ) ; for ( int i = <int> ; i < types . length ; + + i ) { Type type = types [ i ] ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : case Type . CHAR : case Type . BYTE : case Type . SHORT : case Type . INT : locals . add ( Opcodes . INTEGER ) ; break ; case Type . FLOAT : locals . add ( Opcodes . FLOAT ) ; break ; case Type . LONG : locals . add ( Opcodes . LONG ) ; locals . add ( Opcodes . TOP ) ; break ; case Type . DOUBLE : locals . add ( Opcodes . DOUBLE ) ; locals . add ( Opcodes . TOP ) ; break ; case Type . ARRAY : locals . add ( types [ i ] . getDescriptor ( ) ) ; break ; default : locals . add ( types [ i ] . getInternalName ( ) ) ; } } } @Override public void visitFrame ( final int type , final int nLocal , final Object [ ] local , final int nStack , final Object [ ] stack ) { if ( type ! = Opcodes . F_NEW ) { throw new IllegalStateException ( <str> ) ; } if ( mv ! = null ) { mv . visitFrame ( type , nLocal , local , nStack , stack ) ; } if ( this . locals ! = null ) { this . locals . clear ( ) ; this . stack . clear ( ) ; } else { this . locals = new ArrayList < Object > ( ) ; this . stack = new ArrayList < Object > ( ) ; } visitFrameTypes ( nLocal , local , this . locals ) ; visitFrameTypes ( nStack , stack , this . stack ) ; maxStack = Math . max ( maxStack , this . stack . size ( ) ) ; } private static void visitFrameTypes ( final int n , final Object [ ] types , final List < Object > result ) { for ( int i = <int> ; i < n ; + + i ) { Object type = types [ i ] ; result . add ( type ) ; if ( type = = Opcodes . LONG | | type = = Opcodes . DOUBLE ) { result . add ( Opcodes . TOP ) ; } } } @Override public void visitInsn ( final int opcode ) { if ( mv ! = null ) { mv . visitInsn ( opcode ) ; } execute ( opcode , <int> , null ) ; if ( ( opcode > = Opcodes . IRETURN & & opcode < = Opcodes . RETURN ) | | opcode = = Opcodes . ATHROW ) { this . locals = null ; this . stack = null ; } } @Override public void visitIntInsn ( final int opcode , final int operand ) { if ( mv ! = null ) { mv . visitIntInsn ( opcode , operand ) ; } execute ( opcode , operand , null ) ; } @Override public void visitVarInsn ( final int opcode , final int var ) { if ( mv ! = null ) { mv . visitVarInsn ( opcode , var ) ; } execute ( opcode , var , null ) ; } @Override public void visitTypeInsn ( final int opcode , final String type ) { if ( opcode = = Opcodes . NEW ) { if ( labels = = null ) { Label l = new Label ( ) ; labels = new ArrayList < Label > ( <int> ) ; labels . add ( l ) ; if ( mv ! = null ) { mv . visitLabel ( l ) ; } } for ( int i = <int> ; i < labels . size ( ) ; + + i ) { uninitializedTypes . put ( labels . get ( i ) , type ) ; } } if ( mv ! = null ) { mv . visitTypeInsn ( opcode , type ) ; } execute ( opcode , <int> , type ) ; } @Override public void visitFieldInsn ( final int opcode , final String owner , final String name , final String desc ) { if ( mv ! = null ) { mv . visitFieldInsn ( opcode , owner , name , desc ) ; } execute ( opcode , <int> , desc ) ; } @Override public void visitMethodInsn ( final int opcode , final String owner , final String name , final String desc ) { if ( mv ! = null ) { mv . visitMethodInsn ( opcode , owner , name , desc ) ; } if ( this . locals = = null ) { labels = null ; return ; } pop ( desc ) ; if ( opcode ! = Opcodes . INVOKESTATIC ) { Object t = pop ( ) ; if ( opcode = = Opcodes . INVOKESPECIAL & & name . charAt ( <int> ) = = <str> ) { Object u ; if ( t = = Opcodes . UNINITIALIZED_THIS ) { u = this . owner ; } else { u = uninitializedTypes . get ( t ) ; } for ( int i = <int> ; i < locals . size ( ) ; + + i ) { if ( locals . get ( i ) = = t ) { locals . set ( i , u ) ; } } for ( int i = <int> ; i < stack . size ( ) ; + + i ) { if ( stack . get ( i ) = = t ) { stack . set ( i , u ) ; } } } } pushDesc ( desc ) ; labels = null ; } @Override public void visitInvokeDynamicInsn ( String name , String desc , Handle bsm , Object . . . bsmArgs ) { if ( mv ! = null ) { mv . visitInvokeDynamicInsn ( name , desc , bsm , bsmArgs ) ; } if ( this . locals = = null ) { labels = null ; return ; } pop ( desc ) ; pushDesc ( desc ) ; labels = null ; } @Override public void visitJumpInsn ( final int opcode , final Label label ) { if ( mv ! = null ) { mv . visitJumpInsn ( opcode , label ) ; } execute ( opcode , <int> , null ) ; if ( opcode = = Opcodes . GOTO ) { this . locals = null ; this . stack = null ; } } @Override public void visitLabel ( final Label label ) { if ( mv ! = null ) { mv . visitLabel ( label ) ; } if ( labels = = null ) { labels = new ArrayList < Label > ( <int> ) ; } labels . add ( label ) ; } @Override public void visitLdcInsn ( final Object cst ) { if ( mv ! = null ) { mv . visitLdcInsn ( cst ) ; } if ( this . locals = = null ) { labels = null ; return ; } if ( cst instanceof Integer ) { push ( Opcodes . INTEGER ) ; } else if ( cst instanceof Long ) { push ( Opcodes . LONG ) ; push ( Opcodes . TOP ) ; } else if ( cst instanceof Float ) { push ( Opcodes . FLOAT ) ; } else if ( cst instanceof Double ) { push ( Opcodes . DOUBLE ) ; push ( Opcodes . TOP ) ; } else if ( cst instanceof String ) { push ( <str> ) ; } else if ( cst instanceof Type ) { int sort = ( ( Type ) cst ) . getSort ( ) ; if ( sort = = Type . OBJECT | | sort = = Type . ARRAY ) { push ( <str> ) ; } else if ( sort = = Type . METHOD ) { push ( <str> ) ; } else { throw new IllegalArgumentException ( ) ; } } else if ( cst instanceof Handle ) { push ( <str> ) ; } else { throw new IllegalArgumentException ( ) ; } labels = null ; } @Override public void visitIincInsn ( final int var , final int increment ) { if ( mv ! = null ) { mv . visitIincInsn ( var , increment ) ; } execute ( Opcodes . IINC , var , null ) ; } @Override public void visitTableSwitchInsn ( final int min , final int max , final Label dflt , final Label . . . labels ) { if ( mv ! = null ) { mv . visitTableSwitchInsn ( min , max , dflt , labels ) ; } execute ( Opcodes . TABLESWITCH , <int> , null ) ; this . locals = null ; this . stack = null ; } @Override public void visitLookupSwitchInsn ( final Label dflt , final int [ ] keys , final Label [ ] labels ) { if ( mv ! = null ) { mv . visitLookupSwitchInsn ( dflt , keys , labels ) ; } execute ( Opcodes . LOOKUPSWITCH , <int> , null ) ; this . locals = null ; this . stack = null ; } @Override public void visitMultiANewArrayInsn ( final String desc , final int dims ) { if ( mv ! = null ) { mv . visitMultiANewArrayInsn ( desc , dims ) ; } execute ( Opcodes . MULTIANEWARRAY , dims , desc ) ; } @Override public void visitMaxs ( final int maxStack , final int maxLocals ) { if ( mv ! = null ) { this . maxStack = Math . max ( this . maxStack , maxStack ) ; this . maxLocals = Math . max ( this . maxLocals , maxLocals ) ; mv . visitMaxs ( this . maxStack , this . maxLocals ) ; } } private Object get ( final int local ) { maxLocals = Math . max ( maxLocals , local ) ; return local < locals . size ( ) ? locals . get ( local ) : Opcodes . TOP ; } private void set ( final int local , final Object type ) { maxLocals = Math . max ( maxLocals , local ) ; while ( local > = locals . size ( ) ) { locals . add ( Opcodes . TOP ) ; } locals . set ( local , type ) ; } private void push ( final Object type ) { stack . add ( type ) ; maxStack = Math . max ( maxStack , stack . size ( ) ) ; } private void pushDesc ( final String desc ) { int index = desc . charAt ( <int> ) = = <str> ? desc . indexOf ( <str> ) + <int> : <int> ; switch ( desc . charAt ( index ) ) { case <str> : return ; case <str> : case <str> : case <str> : case <str> : case <str> : push ( Opcodes . INTEGER ) ; return ; case <str> : push ( Opcodes . FLOAT ) ; return ; case <str> : push ( Opcodes . LONG ) ; push ( Opcodes . TOP ) ; return ; case <str> : push ( Opcodes . DOUBLE ) ; push ( Opcodes . TOP ) ; return ; case <str> : if ( index = = <int> ) { push ( desc ) ; } else { push ( desc . substring ( index , desc . length ( ) ) ) ; } break ; default : if ( index = = <int> ) { push ( desc . substring ( <int> , desc . length ( ) - <int> ) ) ; } else { push ( desc . substring ( index + <int> , desc . length ( ) - <int> ) ) ; } } } private Object pop ( ) { return stack . remove ( stack . size ( ) - <int> ) ; } private void pop ( final int n ) { int size = stack . size ( ) ; int end = size - n ; for ( int i = size - <int> ; i > = end ; - - i ) { stack . remove ( i ) ; } } private void pop ( final String desc ) { char c = desc . charAt ( <int> ) ; if ( c = = <str> ) { int n = <int> ; Type [ ] types = Type . getArgumentTypes ( desc ) ; for ( int i = <int> ; i < types . length ; + + i ) { n + = types [ i ] . getSize ( ) ; } pop ( n ) ; } else if ( c = = <str> | | c = = <str> ) { pop ( <int> ) ; } else { pop ( <int> ) ; } } private void execute ( final int opcode , final int iarg , final String sarg ) { if ( this . locals = = null ) { labels = null ; return ; } Object t1 , t2 , t3 , t4 ; switch ( opcode ) { case Opcodes . NOP : case Opcodes . INEG : case Opcodes . LNEG : case Opcodes . FNEG : case Opcodes . DNEG : case Opcodes . I2B : case Opcodes . I2C : case Opcodes . I2S : case Opcodes . GOTO : case Opcodes . RETURN : break ; case Opcodes . ACONST_NULL : push ( Opcodes . NULL ) ; break ; case Opcodes . ICONST_M1 : case Opcodes . ICONST_0 : case Opcodes . ICONST_1 : case Opcodes . ICONST_2 : case Opcodes . ICONST_3 : case Opcodes . ICONST_4 : case Opcodes . ICONST_5 : case Opcodes . BIPUSH : case Opcodes . SIPUSH : push ( Opcodes . INTEGER ) ; break ; case Opcodes . LCONST_0 : case Opcodes . LCONST_1 : push ( Opcodes . LONG ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . FCONST_0 : case Opcodes . FCONST_1 : case Opcodes . FCONST_2 : push ( Opcodes . FLOAT ) ; break ; case Opcodes . DCONST_0 : case Opcodes . DCONST_1 : push ( Opcodes . DOUBLE ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . ILOAD : case Opcodes . FLOAD : case Opcodes . ALOAD : push ( get ( iarg ) ) ; break ; case Opcodes . LLOAD : case Opcodes . DLOAD : push ( get ( iarg ) ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . IALOAD : case Opcodes . BALOAD : case Opcodes . CALOAD : case Opcodes . SALOAD : pop ( <int> ) ; push ( Opcodes . INTEGER ) ; break ; case Opcodes . LALOAD : case Opcodes . D2L : pop ( <int> ) ; push ( Opcodes . LONG ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . FALOAD : pop ( <int> ) ; push ( Opcodes . FLOAT ) ; break ; case Opcodes . DALOAD : case Opcodes . L2D : pop ( <int> ) ; push ( Opcodes . DOUBLE ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . AALOAD : pop ( <int> ) ; t1 = pop ( ) ; if ( t1 instanceof String ) { pushDesc ( ( ( String ) t1 ) . substring ( <int> ) ) ; } else { push ( <str> ) ; } break ; case Opcodes . ISTORE : case Opcodes . FSTORE : case Opcodes . ASTORE : t1 = pop ( ) ; set ( iarg , t1 ) ; if ( iarg > <int> ) { t2 = get ( iarg - <int> ) ; if ( t2 = = Opcodes . LONG | | t2 = = Opcodes . DOUBLE ) { set ( iarg - <int> , Opcodes . TOP ) ; } } break ; case Opcodes . LSTORE : case Opcodes . DSTORE : pop ( <int> ) ; t1 = pop ( ) ; set ( iarg , t1 ) ; set ( iarg + <int> , Opcodes . TOP ) ; if ( iarg > <int> ) { t2 = get ( iarg - <int> ) ; if ( t2 = = Opcodes . LONG | | t2 = = Opcodes . DOUBLE ) { set ( iarg - <int> , Opcodes . TOP ) ; } } break ; case Opcodes . IASTORE : case Opcodes . BASTORE : case Opcodes . CASTORE : case Opcodes . SASTORE : case Opcodes . FASTORE : case Opcodes . AASTORE : pop ( <int> ) ; break ; case Opcodes . LASTORE : case Opcodes . DASTORE : pop ( <int> ) ; break ; case Opcodes . POP : case Opcodes . IFEQ : case Opcodes . IFNE : case Opcodes . IFLT : case Opcodes . IFGE : case Opcodes . IFGT : case Opcodes . IFLE : case Opcodes . IRETURN : case Opcodes . FRETURN : case Opcodes . ARETURN : case Opcodes . TABLESWITCH : case Opcodes . LOOKUPSWITCH : case Opcodes . ATHROW : case Opcodes . MONITORENTER : case Opcodes . MONITOREXIT : case Opcodes . IFNULL : case Opcodes . IFNONNULL : pop ( <int> ) ; break ; case Opcodes . POP2 : case Opcodes . IF_ICMPEQ : case Opcodes . IF_ICMPNE : case Opcodes . IF_ICMPLT : case Opcodes . IF_ICMPGE : case Opcodes . IF_ICMPGT : case Opcodes . IF_ICMPLE : case Opcodes . IF_ACMPEQ : case Opcodes . IF_ACMPNE : case Opcodes . LRETURN : case Opcodes . DRETURN : pop ( <int> ) ; break ; case Opcodes . DUP : t1 = pop ( ) ; push ( t1 ) ; push ( t1 ) ; break ; case Opcodes . DUP_X1 : t1 = pop ( ) ; t2 = pop ( ) ; push ( t1 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . DUP_X2 : t1 = pop ( ) ; t2 = pop ( ) ; t3 = pop ( ) ; push ( t1 ) ; push ( t3 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . DUP2 : t1 = pop ( ) ; t2 = pop ( ) ; push ( t2 ) ; push ( t1 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . DUP2_X1 : t1 = pop ( ) ; t2 = pop ( ) ; t3 = pop ( ) ; push ( t2 ) ; push ( t1 ) ; push ( t3 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . DUP2_X2 : t1 = pop ( ) ; t2 = pop ( ) ; t3 = pop ( ) ; t4 = pop ( ) ; push ( t2 ) ; push ( t1 ) ; push ( t4 ) ; push ( t3 ) ; push ( t2 ) ; push ( t1 ) ; break ; case Opcodes . SWAP : t1 = pop ( ) ; t2 = pop ( ) ; push ( t1 ) ; push ( t2 ) ; break ; case Opcodes . IADD : case Opcodes . ISUB : case Opcodes . IMUL : case Opcodes . IDIV : case Opcodes . IREM : case Opcodes . IAND : case Opcodes . IOR : case Opcodes . IXOR : case Opcodes . ISHL : case Opcodes . ISHR : case Opcodes . IUSHR : case Opcodes . L2I : case Opcodes . D2I : case Opcodes . FCMPL : case Opcodes . FCMPG : pop ( <int> ) ; push ( Opcodes . INTEGER ) ; break ; case Opcodes . LADD : case Opcodes . LSUB : case Opcodes . LMUL : case Opcodes . LDIV : case Opcodes . LREM : case Opcodes . LAND : case Opcodes . LOR : case Opcodes . LXOR : pop ( <int> ) ; push ( Opcodes . LONG ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . FADD : case Opcodes . FSUB : case Opcodes . FMUL : case Opcodes . FDIV : case Opcodes . FREM : case Opcodes . L2F : case Opcodes . D2F : pop ( <int> ) ; push ( Opcodes . FLOAT ) ; break ; case Opcodes . DADD : case Opcodes . DSUB : case Opcodes . DMUL : case Opcodes . DDIV : case Opcodes . DREM : pop ( <int> ) ; push ( Opcodes . DOUBLE ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . LSHL : case Opcodes . LSHR : case Opcodes . LUSHR : pop ( <int> ) ; push ( Opcodes . LONG ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . IINC : set ( iarg , Opcodes . INTEGER ) ; break ; case Opcodes . I2L : case Opcodes . F2L : pop ( <int> ) ; push ( Opcodes . LONG ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . I2F : pop ( <int> ) ; push ( Opcodes . FLOAT ) ; break ; case Opcodes . I2D : case Opcodes . F2D : pop ( <int> ) ; push ( Opcodes . DOUBLE ) ; push ( Opcodes . TOP ) ; break ; case Opcodes . F2I : case Opcodes . ARRAYLENGTH : case Opcodes . INSTANCEOF : pop ( <int> ) ; push ( Opcodes . INTEGER ) ; break ; case Opcodes . LCMP : case Opcodes . DCMPL : case Opcodes . DCMPG : pop ( <int> ) ; push ( Opcodes . INTEGER ) ; break ; case Opcodes . JSR : case Opcodes . RET : throw new RuntimeException ( <str> ) ; case Opcodes . GETSTATIC : pushDesc ( sarg ) ; break ; case Opcodes . PUTSTATIC : pop ( sarg ) ; break ; case Opcodes . GETFIELD : pop ( <int> ) ; pushDesc ( sarg ) ; break ; case Opcodes . PUTFIELD : pop ( sarg ) ; pop ( ) ; break ; case Opcodes . NEW : push ( labels . get ( <int> ) ) ; break ; case Opcodes . NEWARRAY : pop ( ) ; switch ( iarg ) { case Opcodes . T_BOOLEAN : pushDesc ( <str> ) ; break ; case Opcodes . T_CHAR : pushDesc ( <str> ) ; break ; case Opcodes . T_BYTE : pushDesc ( <str> ) ; break ; case Opcodes . T_SHORT : pushDesc ( <str> ) ; break ; case Opcodes . T_INT : pushDesc ( <str> ) ; break ; case Opcodes . T_FLOAT : pushDesc ( <str> ) ; break ; case Opcodes . T_DOUBLE : pushDesc ( <str> ) ; break ; default : pushDesc ( <str> ) ; break ; } break ; case Opcodes . ANEWARRAY : pop ( ) ; pushDesc ( <str> + Type . getObjectType ( sarg ) ) ; break ; case Opcodes . CHECKCAST : pop ( ) ; pushDesc ( Type . getObjectType ( sarg ) . getDescriptor ( ) ) ; break ; default : pop ( iarg ) ; pushDesc ( sarg ) ; break ; } labels = null ; } } 
