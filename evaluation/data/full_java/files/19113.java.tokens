package io . netty . handler . codec . http ; import static io . netty . util . AsciiString . containsContentEqualsIgnoreCase ; import static io . netty . util . AsciiString . containsAllContentEqualsIgnoreCase ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . ReferenceCounted ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import static io . netty . handler . codec . http . HttpResponseStatus . SWITCHING_PROTOCOLS ; import static io . netty . handler . codec . http . HttpVersion . HTTP_1_1 ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public class HttpServerUpgradeHandler extends HttpObjectAggregator { public interface SourceCodec { void upgradeFrom ( ChannelHandlerContext ctx ) ; } public interface UpgradeCodec { Collection < CharSequence > requiredUpgradeHeaders ( ) ; void prepareUpgradeResponse ( ChannelHandlerContext ctx , FullHttpRequest upgradeRequest , FullHttpResponse upgradeResponse ) ; void upgradeTo ( ChannelHandlerContext ctx , FullHttpRequest upgradeRequest , FullHttpResponse upgradeResponse ) ; } public interface UpgradeCodecFactory { UpgradeCodec newUpgradeCodec ( CharSequence protocol ) ; } public static final class UpgradeEvent implements ReferenceCounted { private final CharSequence protocol ; private final FullHttpRequest upgradeRequest ; private UpgradeEvent ( CharSequence protocol , FullHttpRequest upgradeRequest ) { this . protocol = protocol ; this . upgradeRequest = upgradeRequest ; } public CharSequence protocol ( ) { return protocol ; } public FullHttpRequest upgradeRequest ( ) { return upgradeRequest ; } @Override public int refCnt ( ) { return upgradeRequest . refCnt ( ) ; } @Override public UpgradeEvent retain ( ) { upgradeRequest . retain ( ) ; return this ; } @Override public UpgradeEvent retain ( int increment ) { upgradeRequest . retain ( increment ) ; return this ; } @Override public UpgradeEvent touch ( ) { upgradeRequest . touch ( ) ; return this ; } @Override public UpgradeEvent touch ( Object hint ) { upgradeRequest . touch ( hint ) ; return this ; } @Override public boolean release ( ) { return upgradeRequest . release ( ) ; } @Override public boolean release ( int decrement ) { return upgradeRequest . release ( ) ; } @Override public String toString ( ) { return <str> + protocol + <str> + upgradeRequest + <str> ; } } private final SourceCodec sourceCodec ; private final UpgradeCodecFactory upgradeCodecFactory ; private boolean handlingUpgrade ; public HttpServerUpgradeHandler ( SourceCodec sourceCodec , UpgradeCodecFactory upgradeCodecFactory ) { this ( sourceCodec , upgradeCodecFactory , <int> ) ; } public HttpServerUpgradeHandler ( SourceCodec sourceCodec , UpgradeCodecFactory upgradeCodecFactory , int maxContentLength ) { super ( maxContentLength ) ; this . sourceCodec = checkNotNull ( sourceCodec , <str> ) ; this . upgradeCodecFactory = checkNotNull ( upgradeCodecFactory , <str> ) ; } @Override protected void decode ( ChannelHandlerContext ctx , HttpObject msg , List < Object > out ) throws Exception { handlingUpgrade | = isUpgradeRequest ( msg ) ; if ( ! handlingUpgrade ) { ReferenceCountUtil . retain ( msg ) ; out . add ( msg ) ; return ; } FullHttpRequest fullRequest ; if ( msg instanceof FullHttpRequest ) { fullRequest = ( FullHttpRequest ) msg ; ReferenceCountUtil . retain ( msg ) ; out . add ( msg ) ; } else { super . decode ( ctx , msg , out ) ; if ( out . isEmpty ( ) ) { return ; } assert out . size ( ) = = <int> ; handlingUpgrade = false ; fullRequest = ( FullHttpRequest ) out . get ( <int> ) ; } if ( upgrade ( ctx , fullRequest ) ) { out . clear ( ) ; } } private static boolean isUpgradeRequest ( HttpObject msg ) { return msg instanceof HttpRequest & & ( ( HttpRequest ) msg ) . headers ( ) . get ( HttpHeaderNames . UPGRADE ) ! = null ; } private boolean upgrade ( final ChannelHandlerContext ctx , final FullHttpRequest request ) { final List < CharSequence > requestedProtocols = splitHeader ( request . headers ( ) . get ( HttpHeaderNames . UPGRADE ) ) ; final int numRequestedProtocols = requestedProtocols . size ( ) ; UpgradeCodec upgradeCodec = null ; CharSequence upgradeProtocol = null ; for ( int i = <int> ; i < numRequestedProtocols ; i + + ) { final CharSequence p = requestedProtocols . get ( i ) ; final UpgradeCodec c = upgradeCodecFactory . newUpgradeCodec ( p ) ; if ( c ! = null ) { upgradeProtocol = p ; upgradeCodec = c ; break ; } } if ( upgradeCodec = = null ) { return false ; } CharSequence connectionHeader = request . headers ( ) . get ( HttpHeaderNames . CONNECTION ) ; if ( connectionHeader = = null ) { return false ; } Collection < CharSequence > requiredHeaders = upgradeCodec . requiredUpgradeHeaders ( ) ; List < CharSequence > values = splitHeader ( connectionHeader ) ; if ( ! containsContentEqualsIgnoreCase ( values , HttpHeaderNames . UPGRADE ) | | ! containsAllContentEqualsIgnoreCase ( values , requiredHeaders ) ) { return false ; } for ( CharSequence requiredHeader : requiredHeaders ) { if ( ! request . headers ( ) . contains ( requiredHeader ) ) { return false ; } } final UpgradeEvent event = new UpgradeEvent ( upgradeProtocol , request ) ; final FullHttpResponse upgradeResponse = createUpgradeResponse ( upgradeProtocol ) ; upgradeCodec . prepareUpgradeResponse ( ctx , request , upgradeResponse ) ; final UpgradeCodec finalUpgradeCodec = upgradeCodec ; ctx . writeAndFlush ( upgradeResponse ) . addListener ( new ChannelFutureListener ( ) { @Override public void operationComplete ( ChannelFuture future ) throws Exception { try { if ( future . isSuccess ( ) ) { sourceCodec . upgradeFrom ( ctx ) ; finalUpgradeCodec . upgradeTo ( ctx , request , upgradeResponse ) ; ctx . fireUserEventTriggered ( event . retain ( ) ) ; ctx . pipeline ( ) . remove ( HttpServerUpgradeHandler . this ) ; } else { future . channel ( ) . close ( ) ; } } finally { event . release ( ) ; } } } ) ; return true ; } private static FullHttpResponse createUpgradeResponse ( CharSequence upgradeProtocol ) { DefaultFullHttpResponse res = new DefaultFullHttpResponse ( HTTP_1_1 , SWITCHING_PROTOCOLS , Unpooled . EMPTY_BUFFER , false ) ; res . headers ( ) . add ( HttpHeaderNames . CONNECTION , HttpHeaderValues . UPGRADE ) ; res . headers ( ) . add ( HttpHeaderNames . UPGRADE , upgradeProtocol ) ; res . headers ( ) . add ( HttpHeaderNames . CONTENT_LENGTH , HttpHeaderValues . ZERO ) ; return res ; } private static List < CharSequence > splitHeader ( CharSequence header ) { final StringBuilder builder = new StringBuilder ( header . length ( ) ) ; final List < CharSequence > protocols = new ArrayList < CharSequence > ( <int> ) ; for ( int i = <int> ; i < header . length ( ) ; + + i ) { char c = header . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { continue ; } if ( c = = <str> ) { protocols . add ( builder . toString ( ) ) ; builder . setLength ( <int> ) ; } else { builder . append ( c ) ; } } if ( builder . length ( ) > <int> ) { protocols . add ( builder . toString ( ) ) ; } return protocols ; } } 
