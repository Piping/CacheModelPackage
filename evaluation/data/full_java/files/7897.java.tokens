package org . elasticsearch . common . breaker ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . indices . breaker . BreakerSettings ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import org . elasticsearch . indices . breaker . HierarchyCircuitBreakerService ; import org . elasticsearch . node . settings . NodeSettingsService ; import org . elasticsearch . test . ESTestCase ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; public class MemoryCircuitBreakerTests extends ESTestCase { public void testThreadedUpdatesToBreaker ( ) throws Exception { final int NUM_THREADS = scaledRandomIntBetween ( <int> , <int> ) ; final int BYTES_PER_THREAD = scaledRandomIntBetween ( <int> , <int> ) ; final Thread [ ] threads = new Thread [ NUM_THREADS ] ; final AtomicBoolean tripped = new AtomicBoolean ( false ) ; final AtomicReference < Throwable > lastException = new AtomicReference < > ( null ) ; final MemoryCircuitBreaker breaker = new MemoryCircuitBreaker ( new ByteSizeValue ( ( BYTES_PER_THREAD * NUM_THREADS ) - <int> ) , <float> , logger ) ; for ( int i = <int> ; i < NUM_THREADS ; i + + ) { threads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { for ( int j = <int> ; j < BYTES_PER_THREAD ; j + + ) { try { breaker . addEstimateBytesAndMaybeBreak ( <int> , <str> ) ; } catch ( CircuitBreakingException e ) { if ( tripped . get ( ) ) { assertThat ( <str> , true , equalTo ( false ) ) ; } else { assertThat ( tripped . compareAndSet ( false , true ) , equalTo ( true ) ) ; } } catch ( Throwable e2 ) { lastException . set ( e2 ) ; } } } } ) ; threads [ i ] . start ( ) ; } for ( Thread t : threads ) { t . join ( ) ; } assertThat ( <str> , lastException . get ( ) , equalTo ( null ) ) ; assertThat ( <str> , tripped . get ( ) , equalTo ( true ) ) ; assertThat ( <str> , breaker . getTrippedCount ( ) , greaterThanOrEqualTo ( <int> ) ) ; } public void testThreadedUpdatesToChildBreaker ( ) throws Exception { final int NUM_THREADS = scaledRandomIntBetween ( <int> , <int> ) ; final int BYTES_PER_THREAD = scaledRandomIntBetween ( <int> , <int> ) ; final Thread [ ] threads = new Thread [ NUM_THREADS ] ; final AtomicBoolean tripped = new AtomicBoolean ( false ) ; final AtomicReference < Throwable > lastException = new AtomicReference < > ( null ) ; final AtomicReference < ChildMemoryCircuitBreaker > breakerRef = new AtomicReference < > ( null ) ; final CircuitBreakerService service = new HierarchyCircuitBreakerService ( Settings . EMPTY , new NodeSettingsService ( Settings . EMPTY ) ) { @Override public CircuitBreaker getBreaker ( String name ) { return breakerRef . get ( ) ; } @Override public void checkParentLimit ( String label ) throws CircuitBreakingException { } } ; final BreakerSettings settings = new BreakerSettings ( CircuitBreaker . REQUEST , ( BYTES_PER_THREAD * NUM_THREADS ) - <int> , <float> ) ; final ChildMemoryCircuitBreaker breaker = new ChildMemoryCircuitBreaker ( settings , logger , ( HierarchyCircuitBreakerService ) service , CircuitBreaker . REQUEST ) ; breakerRef . set ( breaker ) ; for ( int i = <int> ; i < NUM_THREADS ; i + + ) { threads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { for ( int j = <int> ; j < BYTES_PER_THREAD ; j + + ) { try { breaker . addEstimateBytesAndMaybeBreak ( <int> , <str> ) ; } catch ( CircuitBreakingException e ) { if ( tripped . get ( ) ) { assertThat ( <str> , true , equalTo ( false ) ) ; } else { assertThat ( tripped . compareAndSet ( false , true ) , equalTo ( true ) ) ; } } catch ( Throwable e2 ) { lastException . set ( e2 ) ; } } } } ) ; threads [ i ] . start ( ) ; } for ( Thread t : threads ) { t . join ( ) ; } assertThat ( <str> , lastException . get ( ) , equalTo ( null ) ) ; assertThat ( <str> , tripped . get ( ) , equalTo ( true ) ) ; assertThat ( <str> , breaker . getTrippedCount ( ) , greaterThanOrEqualTo ( <int> ) ) ; } public void testThreadedUpdatesToChildBreakerWithParentLimit ( ) throws Exception { final int NUM_THREADS = scaledRandomIntBetween ( <int> , <int> ) ; final int BYTES_PER_THREAD = scaledRandomIntBetween ( <int> , <int> ) ; final int parentLimit = ( BYTES_PER_THREAD * NUM_THREADS ) - <int> ; final int childLimit = parentLimit + <int> ; final Thread [ ] threads = new Thread [ NUM_THREADS ] ; final AtomicInteger tripped = new AtomicInteger ( <int> ) ; final AtomicReference < Throwable > lastException = new AtomicReference < > ( null ) ; final AtomicInteger parentTripped = new AtomicInteger ( <int> ) ; final AtomicReference < ChildMemoryCircuitBreaker > breakerRef = new AtomicReference < > ( null ) ; final CircuitBreakerService service = new HierarchyCircuitBreakerService ( Settings . EMPTY , new NodeSettingsService ( Settings . EMPTY ) ) { @Override public CircuitBreaker getBreaker ( String name ) { return breakerRef . get ( ) ; } @Override public void checkParentLimit ( String label ) throws CircuitBreakingException { if ( getBreaker ( CircuitBreaker . REQUEST ) . getUsed ( ) > parentLimit ) { parentTripped . incrementAndGet ( ) ; logger . info ( <str> ) ; throw new CircuitBreakingException ( <str> ) ; } } } ; final BreakerSettings settings = new BreakerSettings ( CircuitBreaker . REQUEST , childLimit , <float> ) ; final ChildMemoryCircuitBreaker breaker = new ChildMemoryCircuitBreaker ( settings , logger , ( HierarchyCircuitBreakerService ) service , CircuitBreaker . REQUEST ) ; breakerRef . set ( breaker ) ; for ( int i = <int> ; i < NUM_THREADS ; i + + ) { threads [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { for ( int j = <int> ; j < BYTES_PER_THREAD ; j + + ) { try { breaker . addEstimateBytesAndMaybeBreak ( <int> , <str> ) ; } catch ( CircuitBreakingException e ) { tripped . incrementAndGet ( ) ; } catch ( Throwable e2 ) { lastException . set ( e2 ) ; } } } } ) ; } logger . info ( <str> , NUM_THREADS , BYTES_PER_THREAD , ( BYTES_PER_THREAD * NUM_THREADS ) , parentLimit , childLimit ) ; logger . info ( <str> ) ; for ( Thread t : threads ) { t . start ( ) ; } for ( Thread t : threads ) { t . join ( ) ; } logger . info ( <str> , breaker . getUsed ( ) , breaker . getLimit ( ) ) ; logger . info ( <str> , parentTripped . get ( ) , tripped . get ( ) ) ; assertThat ( <str> , lastException . get ( ) , equalTo ( null ) ) ; assertThat ( <str> , breaker . getUsed ( ) , greaterThanOrEqualTo ( ( long ) parentLimit - NUM_THREADS ) ) ; assertThat ( <str> , parentTripped . get ( ) , greaterThanOrEqualTo ( <int> ) ) ; assertThat ( <str> , tripped . get ( ) , greaterThanOrEqualTo ( <int> ) ) ; } public void testConstantFactor ( ) throws Exception { final MemoryCircuitBreaker breaker = new MemoryCircuitBreaker ( new ByteSizeValue ( <int> ) , <float> , logger ) ; String field = <str> ; breaker . addWithoutBreaking ( <int> ) ; try { breaker . addEstimateBytesAndMaybeBreak ( <int> , field ) ; fail ( <str> ) ; } catch ( CircuitBreakingException cbe ) { } breaker . addEstimateBytesAndMaybeBreak ( <int> , field ) ; assertThat ( breaker . getUsed ( ) , equalTo ( <int> ) ) ; breaker . addWithoutBreaking ( <int> ) ; try { breaker . addEstimateBytesAndMaybeBreak ( <int> , field ) ; fail ( <str> ) ; } catch ( CircuitBreakingException cbe ) { assertThat ( <str> , breaker . getTrippedCount ( ) , equalTo ( <int> ) ) ; assertThat ( cbe . getMessage ( ) . contains ( <str> + field + <str> ) , equalTo ( true ) ) ; } } } 
