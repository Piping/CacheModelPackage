package org . elasticsearch . search . suggest . phrase ; import org . apache . lucene . index . IndexReader ; import org . apache . lucene . index . Terms ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . search . suggest . SuggestUtils ; import org . elasticsearch . search . suggest . phrase . DirectCandidateGenerator . Candidate ; import java . io . IOException ; public class StupidBackoffScorer extends WordScorer { public static final WordScorerFactory FACTORY = new WordScorer . WordScorerFactory ( ) { @Override public WordScorer newScorer ( IndexReader reader , Terms terms , String field , double realWordLikelyhood , BytesRef separator ) throws IOException { return new StupidBackoffScorer ( reader , terms , field , realWordLikelyhood , separator , <float> ) ; } } ; private final double discount ; public StupidBackoffScorer ( IndexReader reader , Terms terms , String field , double realWordLikelyhood , BytesRef separator , double discount ) throws IOException { super ( reader , terms , field , realWordLikelyhood , separator ) ; this . discount = discount ; } @Override protected double scoreBigram ( Candidate word , Candidate w_1 ) throws IOException { SuggestUtils . join ( separator , spare , w_1 . term , word . term ) ; final long count = frequency ( spare . get ( ) ) ; if ( count < <int> ) { return discount * scoreUnigram ( word ) ; } return count / ( w_1 . frequency + <float> ) ; } @Override protected double scoreTrigram ( Candidate w , Candidate w_1 , Candidate w_2 ) throws IOException { SuggestUtils . join ( separator , spare , w_1 . term , w . term ) ; long bigramCount = frequency ( spare . get ( ) ) ; if ( bigramCount < <int> ) { return discount * scoreUnigram ( w ) ; } SuggestUtils . join ( separator , spare , w_2 . term , w_1 . term , w . term ) ; long trigramCount = frequency ( spare . get ( ) ) ; if ( trigramCount < <int> ) { return discount * ( bigramCount / ( w_1 . frequency + <float> ) ) ; } return trigramCount / ( bigramCount + <float> ) ; } } 
