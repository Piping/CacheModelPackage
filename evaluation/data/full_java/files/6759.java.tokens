package org . elasticsearch . index . shard ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . env . ShardLock ; import org . elasticsearch . index . IndexSettings ; import java . io . IOException ; import java . nio . file . FileStore ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . HashMap ; import java . util . Map ; public final class ShardPath { public static final String INDEX_FOLDER_NAME = <str> ; public static final String TRANSLOG_FOLDER_NAME = <str> ; private final Path path ; private final String indexUUID ; private final ShardId shardId ; private final Path shardStatePath ; private final boolean isCustomDataPath ; public ShardPath ( boolean isCustomDataPath , Path dataPath , Path shardStatePath , String indexUUID , ShardId shardId ) { assert dataPath . getFileName ( ) . toString ( ) . equals ( Integer . toString ( shardId . id ( ) ) ) : <str> + dataPath . toString ( ) ; assert shardStatePath . getFileName ( ) . toString ( ) . equals ( Integer . toString ( shardId . id ( ) ) ) : <str> + dataPath . toString ( ) ; assert dataPath . getParent ( ) . getFileName ( ) . toString ( ) . equals ( shardId . getIndex ( ) ) : <str> + dataPath . toString ( ) ; assert shardStatePath . getParent ( ) . getFileName ( ) . toString ( ) . equals ( shardId . getIndex ( ) ) : <str> + dataPath . toString ( ) ; if ( isCustomDataPath & & dataPath . equals ( shardStatePath ) ) { throw new IllegalArgumentException ( <str> ) ; } this . isCustomDataPath = isCustomDataPath ; this . path = dataPath ; this . indexUUID = indexUUID ; this . shardId = shardId ; this . shardStatePath = shardStatePath ; } public Path resolveTranslog ( ) { return path . resolve ( TRANSLOG_FOLDER_NAME ) ; } public Path resolveIndex ( ) { return path . resolve ( INDEX_FOLDER_NAME ) ; } public Path getDataPath ( ) { return path ; } public boolean exists ( ) { return Files . exists ( path ) ; } public String getIndexUUID ( ) { return indexUUID ; } public ShardId getShardId ( ) { return shardId ; } public Path getShardStatePath ( ) { return shardStatePath ; } public Path getRootDataPath ( ) { Path noIndexShardId = getDataPath ( ) . getParent ( ) . getParent ( ) ; return isCustomDataPath ? noIndexShardId : noIndexShardId . getParent ( ) ; } public Path getRootStatePath ( ) { return getShardStatePath ( ) . getParent ( ) . getParent ( ) . getParent ( ) ; } public boolean isCustomDataPath ( ) { return isCustomDataPath ; } public static ShardPath loadShardPath ( ESLogger logger , NodeEnvironment env , ShardId shardId , IndexSettings indexSettings ) throws IOException { final String indexUUID = indexSettings . getUUID ( ) ; final Path [ ] paths = env . availableShardPaths ( shardId ) ; Path loadedPath = null ; for ( Path path : paths ) { ShardStateMetaData load = ShardStateMetaData . FORMAT . loadLatestState ( logger , path ) ; if ( load ! = null ) { if ( load . indexUUID . equals ( indexUUID ) = = false & & IndexMetaData . INDEX_UUID_NA_VALUE . equals ( load . indexUUID ) = = false ) { logger . warn ( <str> , shardId , path ) ; throw new IllegalStateException ( shardId + <str> + load . indexUUID + <str> + indexUUID + <str> + path ) ; } if ( loadedPath = = null ) { loadedPath = path ; } else { throw new IllegalStateException ( shardId + <str> ) ; } } } if ( loadedPath = = null ) { return null ; } else { final Path dataPath ; final Path statePath = loadedPath ; if ( indexSettings . hasCustomDataPath ( ) ) { dataPath = env . resolveCustomLocation ( indexSettings , shardId ) ; } else { dataPath = statePath ; } logger . debug ( <str> , shardId , dataPath , statePath ) ; return new ShardPath ( indexSettings . hasCustomDataPath ( ) , dataPath , statePath , indexUUID , shardId ) ; } } public static void deleteLeftoverShardDirectory ( ESLogger logger , NodeEnvironment env , ShardLock lock , IndexSettings indexSettings ) throws IOException { final String indexUUID = indexSettings . getUUID ( ) ; final Path [ ] paths = env . availableShardPaths ( lock . getShardId ( ) ) ; for ( Path path : paths ) { ShardStateMetaData load = ShardStateMetaData . FORMAT . loadLatestState ( logger , path ) ; if ( load ! = null ) { if ( load . indexUUID . equals ( indexUUID ) = = false & & IndexMetaData . INDEX_UUID_NA_VALUE . equals ( load . indexUUID ) = = false ) { logger . warn ( <str> , lock . getShardId ( ) , path ) ; assert Files . isDirectory ( path ) : path + <str> ; NodeEnvironment . acquireFSLockForPaths ( indexSettings , paths ) ; IOUtils . rm ( path ) ; } } } } private static Map < Path , Long > getEstimatedReservedBytes ( NodeEnvironment env , long avgShardSizeInBytes , Iterable < IndexShard > shards ) throws IOException { long totFreeSpace = <int> ; for ( NodeEnvironment . NodePath nodePath : env . nodePaths ( ) ) { totFreeSpace + = nodePath . fileStore . getUsableSpace ( ) ; } long estShardSizeInBytes = Math . max ( avgShardSizeInBytes , ( long ) ( totFreeSpace / <float> ) ) ; Map < Path , Long > reservedBytes = new HashMap < > ( ) ; for ( IndexShard shard : shards ) { Path dataPath = NodeEnvironment . shardStatePathToDataPath ( shard . shardPath ( ) . getShardStatePath ( ) ) ; Long curBytes = reservedBytes . get ( dataPath ) ; if ( curBytes = = null ) { curBytes = <int> L ; } reservedBytes . put ( dataPath , curBytes + estShardSizeInBytes ) ; } return reservedBytes ; } public static ShardPath selectNewPathForShard ( NodeEnvironment env , ShardId shardId , IndexSettings indexSettings , long avgShardSizeInBytes , Map < Path , Integer > dataPathToShardCount ) throws IOException { final Path dataPath ; final Path statePath ; if ( indexSettings . hasCustomDataPath ( ) ) { dataPath = env . resolveCustomLocation ( indexSettings , shardId ) ; statePath = env . nodePaths ( ) [ <int> ] . resolve ( shardId ) ; } else { long totFreeSpace = <int> ; for ( NodeEnvironment . NodePath nodePath : env . nodePaths ( ) ) { totFreeSpace + = nodePath . fileStore . getUsableSpace ( ) ; } long estShardSizeInBytes = Math . max ( avgShardSizeInBytes , ( long ) ( totFreeSpace / <float> ) ) ; final NodeEnvironment . NodePath [ ] paths = env . nodePaths ( ) ; NodeEnvironment . NodePath bestPath = null ; long maxUsableBytes = Long . MIN_VALUE ; for ( NodeEnvironment . NodePath nodePath : paths ) { FileStore fileStore = nodePath . fileStore ; long usableBytes = fileStore . getUsableSpace ( ) ; Integer count = dataPathToShardCount . get ( nodePath . path ) ; if ( count ! = null ) { usableBytes - = estShardSizeInBytes * count ; } if ( usableBytes > maxUsableBytes ) { maxUsableBytes = usableBytes ; bestPath = nodePath ; } } statePath = bestPath . resolve ( shardId ) ; dataPath = statePath ; } final String indexUUID = indexSettings . getUUID ( ) ; return new ShardPath ( indexSettings . hasCustomDataPath ( ) , dataPath , statePath , indexUUID , shardId ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } final ShardPath shardPath = ( ShardPath ) o ; if ( shardId ! = null ? ! shardId . equals ( shardPath . shardId ) : shardPath . shardId ! = null ) { return false ; } if ( indexUUID ! = null ? ! indexUUID . equals ( shardPath . indexUUID ) : shardPath . indexUUID ! = null ) { return false ; } if ( path ! = null ? ! path . equals ( shardPath . path ) : shardPath . path ! = null ) { return false ; } return true ; } @Override public int hashCode ( ) { int result = path ! = null ? path . hashCode ( ) : <int> ; result = <int> * result + ( indexUUID ! = null ? indexUUID . hashCode ( ) : <int> ) ; result = <int> * result + ( shardId ! = null ? shardId . hashCode ( ) : <int> ) ; return result ; } @Override public String toString ( ) { return <str> + <str> + path + <str> + indexUUID + <str> + <str> + shardId + <str> ; } } 
