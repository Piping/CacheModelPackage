package org . elasticsearch . action . admin ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . action . admin . cluster . node . hotthreads . NodeHotThreads ; import org . elasticsearch . action . admin . cluster . node . hotthreads . NodesHotThreadsRequestBuilder ; import org . elasticsearch . action . admin . cluster . node . hotthreads . NodesHotThreadsResponse ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . Map ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . elasticsearch . index . query . QueryBuilders . boolQuery ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . is ; import static org . hamcrest . CoreMatchers . notNullValue ; import static org . hamcrest . Matchers . lessThan ; public class HotThreadsIT extends ESIntegTestCase { public void testHotThreadsDontFail ( ) throws ExecutionException , InterruptedException { createIndex ( <str> ) ; final int iters = scaledRandomIntBetween ( <int> , <int> ) ; final AtomicBoolean hasErrors = new AtomicBoolean ( false ) ; for ( int i = <int> ; i < iters ; i + + ) { final String type ; NodesHotThreadsRequestBuilder nodesHotThreadsRequestBuilder = client ( ) . admin ( ) . cluster ( ) . prepareNodesHotThreads ( ) ; if ( randomBoolean ( ) ) { TimeValue timeValue = new TimeValue ( rarely ( ) ? randomIntBetween ( <int> , <int> ) : randomIntBetween ( <int> , <int> ) ) ; nodesHotThreadsRequestBuilder . setInterval ( timeValue ) ; } if ( randomBoolean ( ) ) { nodesHotThreadsRequestBuilder . setThreads ( rarely ( ) ? randomIntBetween ( <int> , <int> ) : randomIntBetween ( <int> , <int> ) ) ; } nodesHotThreadsRequestBuilder . setIgnoreIdleThreads ( randomBoolean ( ) ) ; if ( randomBoolean ( ) ) { switch ( randomIntBetween ( <int> , <int> ) ) { case <int> : type = <str> ; break ; case <int> : type = <str> ; break ; default : type = <str> ; break ; } assertThat ( type , notNullValue ( ) ) ; nodesHotThreadsRequestBuilder . setType ( type ) ; } else { type = null ; } final CountDownLatch latch = new CountDownLatch ( <int> ) ; nodesHotThreadsRequestBuilder . execute ( new ActionListener < NodesHotThreadsResponse > ( ) { @Override public void onResponse ( NodesHotThreadsResponse nodeHotThreads ) { boolean success = false ; try { assertThat ( nodeHotThreads , notNullValue ( ) ) ; Map < String , NodeHotThreads > nodesMap = nodeHotThreads . getNodesMap ( ) ; assertThat ( nodesMap . size ( ) , equalTo ( cluster ( ) . size ( ) ) ) ; for ( NodeHotThreads ht : nodeHotThreads ) { assertNotNull ( ht . getHotThreads ( ) ) ; } success = true ; } finally { if ( ! success ) { hasErrors . set ( true ) ; } latch . countDown ( ) ; } } @Override public void onFailure ( Throwable e ) { logger . error ( <str> , e ) ; hasErrors . set ( true ) ; latch . countDown ( ) ; fail ( ) ; } } ) ; indexRandom ( true , client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) , client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) , client ( ) . prepareIndex ( <str> , <str> , <str> ) . setSource ( <str> , <str> ) ) ; ensureSearchable ( ) ; while ( latch . getCount ( ) > <int> ) { assertHitCount ( client ( ) . prepareSearch ( ) . setQuery ( matchAllQuery ( ) ) . setPostFilter ( boolQuery ( ) . must ( matchAllQuery ( ) ) . mustNot ( boolQuery ( ) . must ( termQuery ( <str> , <str> ) ) . must ( termQuery ( <str> , <str> ) ) ) ) . get ( ) , <int> ) ; } latch . await ( ) ; assertThat ( hasErrors . get ( ) , is ( false ) ) ; } } public void testIgnoreIdleThreads ( ) throws ExecutionException , InterruptedException { NodesHotThreadsRequestBuilder builder = client ( ) . admin ( ) . cluster ( ) . prepareNodesHotThreads ( ) ; builder . setIgnoreIdleThreads ( false ) ; builder . setThreads ( Integer . MAX_VALUE ) ; NodesHotThreadsResponse response = builder . execute ( ) . get ( ) ; int totSizeAll = <int> ; for ( NodeHotThreads node : response . getNodesMap ( ) . values ( ) ) { totSizeAll + = node . getHotThreads ( ) . length ( ) ; } builder = client ( ) . admin ( ) . cluster ( ) . prepareNodesHotThreads ( ) ; builder . setThreads ( Integer . MAX_VALUE ) ; assertEquals ( true , builder . request ( ) . ignoreIdleThreads ( ) ) ; response = builder . execute ( ) . get ( ) ; int totSizeIgnoreIdle = <int> ; for ( NodeHotThreads node : response . getNodesMap ( ) . values ( ) ) { totSizeIgnoreIdle + = node . getHotThreads ( ) . length ( ) ; } assertThat ( totSizeIgnoreIdle , lessThan ( totSizeAll ) ) ; } public void testTimestampAndParams ( ) throws ExecutionException , InterruptedException { NodesHotThreadsResponse response = client ( ) . admin ( ) . cluster ( ) . prepareNodesHotThreads ( ) . execute ( ) . get ( ) ; for ( NodeHotThreads node : response . getNodesMap ( ) . values ( ) ) { String result = node . getHotThreads ( ) ; assertTrue ( result . indexOf ( <str> ) ! = - <int> ) ; assertTrue ( result . indexOf ( <str> ) ! = - <int> ) ; assertTrue ( result . indexOf ( <str> ) ! = - <int> ) ; assertTrue ( result . indexOf ( <str> ) ! = - <int> ) ; } } } 
