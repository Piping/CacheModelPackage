package io . netty . channel . local ; import io . netty . channel . AbstractChannel ; import io . netty . channel . Channel ; import io . netty . channel . ChannelConfig ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . ChannelPipeline ; import io . netty . channel . ChannelPromise ; import io . netty . channel . DefaultChannelConfig ; import io . netty . channel . EventLoop ; import io . netty . channel . SingleThreadEventLoop ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . SingleThreadEventExecutor ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . InternalThreadLocalMap ; import io . netty . util . internal . OneTimeTask ; import io . netty . util . internal . PlatformDependent ; import java . net . SocketAddress ; import java . nio . channels . AlreadyConnectedException ; import java . nio . channels . ClosedChannelException ; import java . nio . channels . ConnectionPendingException ; import java . nio . channels . NotYetConnectedException ; import java . util . Queue ; import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; public class LocalChannel extends AbstractChannel { private enum State { OPEN , BOUND , CONNECTED , CLOSED } @SuppressWarnings ( { <str> } ) private static final AtomicReferenceFieldUpdater < LocalChannel , Future > FINISH_READ_FUTURE_UPDATER ; private static final ChannelMetadata METADATA = new ChannelMetadata ( false ) ; private static final int MAX_READER_STACK_DEPTH = <int> ; private static final ClosedChannelException CLOSED_CHANNEL_EXCEPTION = new ClosedChannelException ( ) ; private final ChannelConfig config = new DefaultChannelConfig ( this ) ; private final Queue < Object > inboundBuffer = PlatformDependent . newMpscQueue ( ) ; private final Runnable readTask = new Runnable ( ) { @Override public void run ( ) { ChannelPipeline pipeline = pipeline ( ) ; for ( ; ; ) { Object m = inboundBuffer . poll ( ) ; if ( m = = null ) { break ; } pipeline . fireChannelRead ( m ) ; } pipeline . fireChannelReadComplete ( ) ; } } ; private final Runnable shutdownHook = new Runnable ( ) { @Override public void run ( ) { unsafe ( ) . close ( unsafe ( ) . voidPromise ( ) ) ; } } ; private volatile State state ; private volatile LocalChannel peer ; private volatile LocalAddress localAddress ; private volatile LocalAddress remoteAddress ; private volatile ChannelPromise connectPromise ; private volatile boolean readInProgress ; private volatile boolean registerInProgress ; private volatile boolean writeInProgress ; private volatile Future < ? > finishReadFuture ; static { @SuppressWarnings ( { <str> } ) AtomicReferenceFieldUpdater < LocalChannel , Future > finishReadFutureUpdater = PlatformDependent . newAtomicReferenceFieldUpdater ( LocalChannel . class , <str> ) ; if ( finishReadFutureUpdater = = null ) { finishReadFutureUpdater = AtomicReferenceFieldUpdater . newUpdater ( LocalChannel . class , Future . class , <str> ) ; } FINISH_READ_FUTURE_UPDATER = finishReadFutureUpdater ; CLOSED_CHANNEL_EXCEPTION . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; } public LocalChannel ( ) { super ( null ) ; } LocalChannel ( LocalServerChannel parent , LocalChannel peer ) { super ( parent ) ; this . peer = peer ; localAddress = parent . localAddress ( ) ; remoteAddress = peer . localAddress ( ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override public ChannelConfig config ( ) { return config ; } @Override public LocalServerChannel parent ( ) { return ( LocalServerChannel ) super . parent ( ) ; } @Override public LocalAddress localAddress ( ) { return ( LocalAddress ) super . localAddress ( ) ; } @Override public LocalAddress remoteAddress ( ) { return ( LocalAddress ) super . remoteAddress ( ) ; } @Override public boolean isOpen ( ) { return state ! = State . CLOSED ; } @Override public boolean isActive ( ) { return state = = State . CONNECTED ; } @Override protected AbstractUnsafe newUnsafe ( ) { return new LocalUnsafe ( ) ; } @Override protected boolean isCompatible ( EventLoop loop ) { return loop instanceof SingleThreadEventLoop ; } @Override protected SocketAddress localAddress0 ( ) { return localAddress ; } @Override protected SocketAddress remoteAddress0 ( ) { return remoteAddress ; } @Override protected void doRegister ( ) throws Exception { if ( peer ! = null & & parent ( ) ! = null ) { final LocalChannel peer = this . peer ; registerInProgress = true ; state = State . CONNECTED ; peer . remoteAddress = parent ( ) = = null ? null : parent ( ) . localAddress ( ) ; peer . state = State . CONNECTED ; peer . eventLoop ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { registerInProgress = false ; peer . pipeline ( ) . fireChannelActive ( ) ; peer . connectPromise . setSuccess ( ) ; } } ) ; } ( ( SingleThreadEventExecutor ) eventLoop ( ) ) . addShutdownHook ( shutdownHook ) ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { this . localAddress = LocalChannelRegistry . register ( this , this . localAddress , localAddress ) ; state = State . BOUND ; } @Override protected void doDisconnect ( ) throws Exception { doClose ( ) ; } @Override protected void doClose ( ) throws Exception { final LocalChannel peer = this . peer ; if ( state ! = State . CLOSED ) { if ( localAddress ! = null ) { if ( parent ( ) = = null ) { LocalChannelRegistry . unregister ( localAddress ) ; } localAddress = null ; } state = State . CLOSED ; ChannelPromise promise = connectPromise ; if ( promise ! = null ) { promise . tryFailure ( CLOSED_CHANNEL_EXCEPTION ) ; connectPromise = null ; } if ( writeInProgress & & peer ! = null ) { finishPeerRead ( peer ) ; } } if ( peer ! = null & & peer . isActive ( ) ) { if ( peer . eventLoop ( ) . inEventLoop ( ) & & ! registerInProgress ) { doPeerClose ( peer , peer . writeInProgress ) ; } else { final boolean peerWriteInProgress = peer . writeInProgress ; try { peer . eventLoop ( ) . execute ( new OneTimeTask ( ) { @Override public void run ( ) { doPeerClose ( peer , peerWriteInProgress ) ; } } ) ; } catch ( RuntimeException e ) { releaseInboundBuffers ( ) ; throw e ; } } this . peer = null ; } } private void doPeerClose ( LocalChannel peer , boolean peerWriteInProgress ) { if ( peerWriteInProgress ) { finishPeerRead0 ( this ) ; } peer . unsafe ( ) . close ( peer . unsafe ( ) . voidPromise ( ) ) ; } @Override protected void doDeregister ( ) throws Exception { ( ( SingleThreadEventExecutor ) eventLoop ( ) ) . removeShutdownHook ( shutdownHook ) ; } @Override protected void doBeginRead ( ) throws Exception { if ( readInProgress ) { return ; } ChannelPipeline pipeline = pipeline ( ) ; Queue < Object > inboundBuffer = this . inboundBuffer ; if ( inboundBuffer . isEmpty ( ) ) { readInProgress = true ; return ; } final InternalThreadLocalMap threadLocals = InternalThreadLocalMap . get ( ) ; final Integer stackDepth = threadLocals . localChannelReaderStackDepth ( ) ; if ( stackDepth < MAX_READER_STACK_DEPTH ) { threadLocals . setLocalChannelReaderStackDepth ( stackDepth + <int> ) ; try { for ( ; ; ) { Object received = inboundBuffer . poll ( ) ; if ( received = = null ) { break ; } pipeline . fireChannelRead ( received ) ; } pipeline . fireChannelReadComplete ( ) ; } finally { threadLocals . setLocalChannelReaderStackDepth ( stackDepth ) ; } } else { try { eventLoop ( ) . execute ( readTask ) ; } catch ( RuntimeException e ) { releaseInboundBuffers ( ) ; throw e ; } } } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { switch ( state ) { case OPEN : case BOUND : throw new NotYetConnectedException ( ) ; case CLOSED : throw CLOSED_CHANNEL_EXCEPTION ; case CONNECTED : break ; } final LocalChannel peer = this . peer ; writeInProgress = true ; try { for ( ; ; ) { Object msg = in . current ( ) ; if ( msg = = null ) { break ; } try { if ( peer . state = = State . CONNECTED ) { peer . inboundBuffer . add ( ReferenceCountUtil . retain ( msg ) ) ; in . remove ( ) ; } else { in . remove ( CLOSED_CHANNEL_EXCEPTION ) ; } } catch ( Throwable cause ) { in . remove ( cause ) ; } } } finally { writeInProgress = false ; } finishPeerRead ( peer ) ; } private void finishPeerRead ( final LocalChannel peer ) { if ( peer . eventLoop ( ) = = eventLoop ( ) & & ! peer . writeInProgress ) { finishPeerRead0 ( peer ) ; } else { runFinishPeerReadTask ( peer ) ; } } private void runFinishPeerReadTask ( final LocalChannel peer ) { final Runnable finishPeerReadTask = new OneTimeTask ( ) { @Override public void run ( ) { finishPeerRead0 ( peer ) ; } } ; try { if ( peer . writeInProgress ) { peer . finishReadFuture = peer . eventLoop ( ) . submit ( finishPeerReadTask ) ; } else { peer . eventLoop ( ) . execute ( finishPeerReadTask ) ; } } catch ( RuntimeException e ) { peer . releaseInboundBuffers ( ) ; throw e ; } } private void releaseInboundBuffers ( ) { for ( ; ; ) { Object o = inboundBuffer . poll ( ) ; if ( o = = null ) { break ; } ReferenceCountUtil . release ( o ) ; } } private void finishPeerRead0 ( LocalChannel peer ) { Future < ? > peerFinishReadFuture = peer . finishReadFuture ; if ( peerFinishReadFuture ! = null ) { if ( ! peerFinishReadFuture . isDone ( ) ) { runFinishPeerReadTask ( peer ) ; return ; } else { FINISH_READ_FUTURE_UPDATER . compareAndSet ( peer , peerFinishReadFuture , null ) ; } } ChannelPipeline peerPipeline = peer . pipeline ( ) ; if ( peer . readInProgress ) { peer . readInProgress = false ; for ( ; ; ) { Object received = peer . inboundBuffer . poll ( ) ; if ( received = = null ) { break ; } peerPipeline . fireChannelRead ( received ) ; } peerPipeline . fireChannelReadComplete ( ) ; } } private class LocalUnsafe extends AbstractUnsafe { @Override public void connect ( final SocketAddress remoteAddress , SocketAddress localAddress , final ChannelPromise promise ) { if ( ! promise . setUncancellable ( ) | | ! ensureOpen ( promise ) ) { return ; } if ( state = = State . CONNECTED ) { Exception cause = new AlreadyConnectedException ( ) ; safeSetFailure ( promise , cause ) ; pipeline ( ) . fireExceptionCaught ( cause ) ; return ; } if ( connectPromise ! = null ) { throw new ConnectionPendingException ( ) ; } connectPromise = promise ; if ( state ! = State . BOUND ) { if ( localAddress = = null ) { localAddress = new LocalAddress ( LocalChannel . this ) ; } } if ( localAddress ! = null ) { try { doBind ( localAddress ) ; } catch ( Throwable t ) { safeSetFailure ( promise , t ) ; close ( voidPromise ( ) ) ; return ; } } Channel boundChannel = LocalChannelRegistry . get ( remoteAddress ) ; if ( ! ( boundChannel instanceof LocalServerChannel ) ) { Exception cause = new ChannelException ( <str> ) ; safeSetFailure ( promise , cause ) ; close ( voidPromise ( ) ) ; return ; } LocalServerChannel serverChannel = ( LocalServerChannel ) boundChannel ; peer = serverChannel . serve ( LocalChannel . this ) ; } } } 
