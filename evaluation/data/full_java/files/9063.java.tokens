package org . elasticsearch . test . store ; import com . carrotsearch . randomizedtesting . SeedUtils ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import java . nio . charset . StandardCharsets ; import org . apache . lucene . index . CheckIndex ; import org . apache . lucene . index . IndexWriter ; import org . apache . lucene . store . * ; import org . apache . lucene . util . LuceneTestCase ; import org . apache . lucene . util . TestRuleMarkFailure ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . lucene . Lucene ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexModule ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . shard . * ; import org . elasticsearch . index . store . FsDirectoryService ; import org . elasticsearch . index . store . IndexStore ; import org . elasticsearch . index . store . Store ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESTestCase ; import org . junit . Assert ; import java . io . Closeable ; import java . io . IOException ; import java . io . PrintStream ; import java . nio . file . Path ; import java . util . * ; public class MockFSDirectoryService extends FsDirectoryService { public static final String RANDOM_IO_EXCEPTION_RATE_ON_OPEN = <str> ; public static final String RANDOM_PREVENT_DOUBLE_WRITE = <str> ; public static final String RANDOM_NO_DELETE_OPEN_FILE = <str> ; public static final String CRASH_INDEX = <str> ; private final FsDirectoryService delegateService ; private final Random random ; private final double randomIOExceptionRate ; private final double randomIOExceptionRateOnOpen ; private final MockDirectoryWrapper . Throttling throttle ; private final boolean preventDoubleWrite ; private final boolean noDeleteOpenFile ; private final boolean crashIndex ; @Inject public MockFSDirectoryService ( IndexSettings idxSettings , IndexStore indexStore , final ShardPath path ) { super ( idxSettings , indexStore , path ) ; Settings indexSettings = idxSettings . getSettings ( ) ; final long seed = indexSettings . getAsLong ( ESIntegTestCase . SETTING_INDEX_SEED , <int> l ) ; this . random = new Random ( seed ) ; randomIOExceptionRate = indexSettings . getAsDouble ( RANDOM_IO_EXCEPTION_RATE , <float> ) ; randomIOExceptionRateOnOpen = indexSettings . getAsDouble ( RANDOM_IO_EXCEPTION_RATE_ON_OPEN , <float> ) ; preventDoubleWrite = indexSettings . getAsBoolean ( RANDOM_PREVENT_DOUBLE_WRITE , true ) ; noDeleteOpenFile = indexSettings . getAsBoolean ( RANDOM_NO_DELETE_OPEN_FILE , random . nextBoolean ( ) ) ; random . nextInt ( shardId . getId ( ) + <int> ) ; throttle = MockDirectoryWrapper . Throttling . NEVER ; crashIndex = indexSettings . getAsBoolean ( CRASH_INDEX , true ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , SeedUtils . formatSeed ( seed ) , throttle , crashIndex ) ; } delegateService = randomDirectorService ( indexStore , path ) ; } @Override public Directory newDirectory ( ) throws IOException { return wrap ( delegateService . newDirectory ( ) ) ; } @Override protected synchronized Directory newFSDirectory ( Path location , LockFactory lockFactory ) throws IOException { throw new UnsupportedOperationException ( ) ; } public static void checkIndex ( ESLogger logger , Store store , ShardId shardId ) { if ( store . tryIncRef ( ) ) { logger . info ( <str> ) ; try { Directory dir = store . directory ( ) ; if ( ! Lucene . indexExists ( dir ) ) { return ; } if ( IndexWriter . isLocked ( dir ) ) { ESTestCase . checkIndexFailed = true ; throw new IllegalStateException ( <str> + shardId ) ; } try ( CheckIndex checkIndex = new CheckIndex ( dir ) ) { BytesStreamOutput os = new BytesStreamOutput ( ) ; PrintStream out = new PrintStream ( os , false , StandardCharsets . UTF_8 . name ( ) ) ; checkIndex . setInfoStream ( out ) ; out . flush ( ) ; CheckIndex . Status status = checkIndex . checkIndex ( ) ; if ( ! status . clean ) { ESTestCase . checkIndexFailed = true ; logger . warn ( <str> , Arrays . toString ( dir . listAll ( ) ) , new String ( os . bytes ( ) . toBytes ( ) , StandardCharsets . UTF_8 ) ) ; throw new IOException ( <str> ) ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , new String ( os . bytes ( ) . toBytes ( ) , StandardCharsets . UTF_8 ) ) ; } } } } catch ( Exception e ) { logger . warn ( <str> , e ) ; } finally { logger . info ( <str> ) ; store . decRef ( ) ; } } } @Override public void onPause ( long nanos ) { delegateService . onPause ( nanos ) ; } @Override public StoreRateLimiting rateLimiting ( ) { return delegateService . rateLimiting ( ) ; } @Override public long throttleTimeInNanos ( ) { return delegateService . throttleTimeInNanos ( ) ; } public static final String RANDOM_IO_EXCEPTION_RATE = <str> ; private Directory wrap ( Directory dir ) { final ElasticsearchMockDirectoryWrapper w = new ElasticsearchMockDirectoryWrapper ( random , dir , this . crashIndex ) ; w . setRandomIOExceptionRate ( randomIOExceptionRate ) ; w . setRandomIOExceptionRateOnOpen ( randomIOExceptionRateOnOpen ) ; w . setThrottling ( throttle ) ; w . setCheckIndexOnClose ( false ) ; w . setPreventDoubleWrite ( preventDoubleWrite ) ; w . setEnableVirusScanner ( false ) ; w . setNoDeleteOpenFile ( noDeleteOpenFile ) ; w . setUseSlowOpenClosers ( false ) ; LuceneTestCase . closeAfterSuite ( new CloseableDirectory ( w ) ) ; return w ; } private FsDirectoryService randomDirectorService ( IndexStore indexStore , ShardPath path ) { final IndexSettings indexSettings = indexStore . getIndexSettings ( ) ; final IndexMetaData build = IndexMetaData . builder ( indexSettings . getIndexMetaData ( ) ) . settings ( Settings . builder ( ) . put ( indexSettings . getSettings ( ) ) . put ( IndexModule . STORE_TYPE , RandomPicks . randomFrom ( random , IndexModule . Type . values ( ) ) . getSettingsKey ( ) ) ) . build ( ) ; final IndexSettings newIndexSettings = new IndexSettings ( build , indexSettings . getNodeSettings ( ) , Collections . emptyList ( ) ) ; return new FsDirectoryService ( newIndexSettings , indexStore , path ) ; } public static final class ElasticsearchMockDirectoryWrapper extends MockDirectoryWrapper { private final boolean crash ; public ElasticsearchMockDirectoryWrapper ( Random random , Directory delegate , boolean crash ) { super ( random , delegate ) ; this . crash = crash ; } @Override public synchronized void crash ( ) throws IOException { if ( crash ) { super . crash ( ) ; } } } final class CloseableDirectory implements Closeable { private final BaseDirectoryWrapper dir ; private final TestRuleMarkFailure failureMarker ; public CloseableDirectory ( BaseDirectoryWrapper dir ) { this . dir = dir ; this . failureMarker = ESTestCase . getSuiteFailureMarker ( ) ; } @Override public void close ( ) { try { if ( failureMarker . wasSuccessful ( ) & & dir . isOpen ( ) ) { Assert . fail ( <str> + dir ) ; } } finally { } } } } 
