package org . gradle . api . internal . plugins ; import org . gradle . api . internal . * ; import org . gradle . api . plugins . Convention ; import org . gradle . api . plugins . ExtensionAware ; import org . gradle . api . plugins . ExtensionContainer ; public class DslObject implements DynamicObjectAware , ExtensionAware , IConventionAware , HasConvention { private DynamicObject dynamicObject ; private ExtensionContainer extensionContainer ; private ConventionMapping conventionMapping ; private Convention convention ; private final Object object ; public DslObject ( Object object ) { this . object = object ; } public DynamicObject getAsDynamicObject ( ) { if ( dynamicObject = = null ) { this . dynamicObject = toType ( object , DynamicObjectAware . class ) . getAsDynamicObject ( ) ; } return dynamicObject ; } public Convention getConvention ( ) { if ( convention = = null ) { this . convention = toType ( object , HasConvention . class ) . getConvention ( ) ; } return convention ; } public ExtensionContainer getExtensions ( ) { if ( extensionContainer = = null ) { this . extensionContainer = toType ( object , ExtensionAware . class ) . getExtensions ( ) ; } return extensionContainer ; } public ConventionMapping getConventionMapping ( ) { if ( conventionMapping = = null ) { this . conventionMapping = toType ( object , IConventionAware . class ) . getConventionMapping ( ) ; } return conventionMapping ; } public Class getDeclaredType ( ) { if ( object instanceof DynamicObjectAware ) { return object . getClass ( ) . getSuperclass ( ) ; } return object . getClass ( ) ; } private static < T > T toType ( Object delegate , Class < T > type ) { if ( type . isInstance ( delegate ) ) { return type . cast ( delegate ) ; } else { throw new IllegalStateException ( String . format ( <str> , delegate , delegate . getClass ( ) . getSimpleName ( ) , type . getName ( ) ) ) ; } } } 
