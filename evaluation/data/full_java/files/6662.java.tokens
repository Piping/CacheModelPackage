package org . elasticsearch . index . query ; import org . apache . lucene . analysis . Analyzer ; import org . apache . lucene . analysis . CachingTokenFilter ; import org . apache . lucene . analysis . TokenStream ; import org . apache . lucene . analysis . tokenattributes . TermToBytesRefAttribute ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . * ; import org . apache . lucene . util . BytesRef ; import java . io . IOException ; import java . util . Locale ; import java . util . Map ; import java . util . Objects ; public class SimpleQueryParser extends org . apache . lucene . queryparser . simple . SimpleQueryParser { private final Settings settings ; public SimpleQueryParser ( Analyzer analyzer , Map < String , Float > weights , int flags , Settings settings ) { super ( analyzer , weights , flags ) ; this . settings = settings ; } private Query rethrowUnlessLenient ( RuntimeException e ) { if ( settings . lenient ( ) ) { return null ; } throw e ; } @Override public Query newDefaultQuery ( String text ) { BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . setDisableCoord ( true ) ; for ( Map . Entry < String , Float > entry : weights . entrySet ( ) ) { try { Query q = createBooleanQuery ( entry . getKey ( ) , text , super . getDefaultOperator ( ) ) ; if ( q ! = null ) { bq . add ( wrapWithBoost ( q , entry . getValue ( ) ) , BooleanClause . Occur . SHOULD ) ; } } catch ( RuntimeException e ) { rethrowUnlessLenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; } @Override public Query newFuzzyQuery ( String text , int fuzziness ) { if ( settings . lowercaseExpandedTerms ( ) ) { text = text . toLowerCase ( settings . locale ( ) ) ; } BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . setDisableCoord ( true ) ; for ( Map . Entry < String , Float > entry : weights . entrySet ( ) ) { try { Query query = new FuzzyQuery ( new Term ( entry . getKey ( ) , text ) , fuzziness ) ; bq . add ( wrapWithBoost ( query , entry . getValue ( ) ) , BooleanClause . Occur . SHOULD ) ; } catch ( RuntimeException e ) { rethrowUnlessLenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; } @Override public Query newPhraseQuery ( String text , int slop ) { BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . setDisableCoord ( true ) ; for ( Map . Entry < String , Float > entry : weights . entrySet ( ) ) { try { Query q = createPhraseQuery ( entry . getKey ( ) , text , slop ) ; if ( q ! = null ) { bq . add ( wrapWithBoost ( q , entry . getValue ( ) ) , BooleanClause . Occur . SHOULD ) ; } } catch ( RuntimeException e ) { rethrowUnlessLenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; } @Override public Query newPrefixQuery ( String text ) { if ( settings . lowercaseExpandedTerms ( ) ) { text = text . toLowerCase ( settings . locale ( ) ) ; } BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . setDisableCoord ( true ) ; for ( Map . Entry < String , Float > entry : weights . entrySet ( ) ) { try { if ( settings . analyzeWildcard ( ) ) { Query analyzedQuery = newPossiblyAnalyzedQuery ( entry . getKey ( ) , text ) ; if ( analyzedQuery ! = null ) { bq . add ( wrapWithBoost ( analyzedQuery , entry . getValue ( ) ) , BooleanClause . Occur . SHOULD ) ; } } else { Query query = new PrefixQuery ( new Term ( entry . getKey ( ) , text ) ) ; bq . add ( wrapWithBoost ( query , entry . getValue ( ) ) , BooleanClause . Occur . SHOULD ) ; } } catch ( RuntimeException e ) { return rethrowUnlessLenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; } private static Query wrapWithBoost ( Query query , float boost ) { if ( boost ! = AbstractQueryBuilder . DEFAULT_BOOST ) { return new BoostQuery ( query , boost ) ; } return query ; } private Query newPossiblyAnalyzedQuery ( String field , String termStr ) { try ( TokenStream source = getAnalyzer ( ) . tokenStream ( field , termStr ) ) { CachingTokenFilter buffer = new CachingTokenFilter ( source ) ; buffer . reset ( ) ; TermToBytesRefAttribute termAtt = null ; int numTokens = <int> ; boolean hasMoreTokens = false ; termAtt = buffer . getAttribute ( TermToBytesRefAttribute . class ) ; if ( termAtt ! = null ) { try { hasMoreTokens = buffer . incrementToken ( ) ; while ( hasMoreTokens ) { numTokens + + ; hasMoreTokens = buffer . incrementToken ( ) ; } } catch ( IOException e ) { } } buffer . reset ( ) ; if ( numTokens = = <int> ) { return null ; } else if ( numTokens = = <int> ) { try { boolean hasNext = buffer . incrementToken ( ) ; assert hasNext = = true ; } catch ( IOException e ) { } return new PrefixQuery ( new Term ( field , BytesRef . deepCopyOf ( termAtt . getBytesRef ( ) ) ) ) ; } else { BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; for ( int i = <int> ; i < numTokens ; i + + ) { try { boolean hasNext = buffer . incrementToken ( ) ; assert hasNext = = true ; } catch ( IOException e ) { } bq . add ( new BooleanClause ( new PrefixQuery ( new Term ( field , BytesRef . deepCopyOf ( termAtt . getBytesRef ( ) ) ) ) , BooleanClause . Occur . SHOULD ) ) ; } return bq . build ( ) ; } } catch ( IOException e ) { return new PrefixQuery ( new Term ( field , termStr ) ) ; } } static class Settings { private Locale locale = SimpleQueryStringBuilder . DEFAULT_LOCALE ; private boolean lowercaseExpandedTerms = SimpleQueryStringBuilder . DEFAULT_LOWERCASE_EXPANDED_TERMS ; private boolean lenient = SimpleQueryStringBuilder . DEFAULT_LENIENT ; private boolean analyzeWildcard = SimpleQueryStringBuilder . DEFAULT_ANALYZE_WILDCARD ; public Settings ( ) { } public Settings ( Locale locale , Boolean lowercaseExpandedTerms , Boolean lenient , Boolean analyzeWildcard ) { this . locale = locale ; this . lowercaseExpandedTerms = lowercaseExpandedTerms ; this . lenient = lenient ; this . analyzeWildcard = analyzeWildcard ; } public void locale ( Locale locale ) { this . locale = ( locale ! = null ) ? locale : SimpleQueryStringBuilder . DEFAULT_LOCALE ; } public Locale locale ( ) { return this . locale ; } public void lowercaseExpandedTerms ( boolean lowercaseExpandedTerms ) { this . lowercaseExpandedTerms = lowercaseExpandedTerms ; } public boolean lowercaseExpandedTerms ( ) { return this . lowercaseExpandedTerms ; } public void lenient ( boolean lenient ) { this . lenient = lenient ; } public boolean lenient ( ) { return this . lenient ; } public void analyzeWildcard ( boolean analyzeWildcard ) { this . analyzeWildcard = analyzeWildcard ; } public boolean analyzeWildcard ( ) { return analyzeWildcard ; } @Override public int hashCode ( ) { return Objects . hash ( locale . toLanguageTag ( ) , lowercaseExpandedTerms , lenient , analyzeWildcard ) ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null | | getClass ( ) ! = obj . getClass ( ) ) { return false ; } Settings other = ( Settings ) obj ; return ( Objects . equals ( locale . toLanguageTag ( ) , other . locale . toLanguageTag ( ) ) & & Objects . equals ( lowercaseExpandedTerms , other . lowercaseExpandedTerms ) & & Objects . equals ( lenient , other . lenient ) & & Objects . equals ( analyzeWildcard , other . analyzeWildcard ) ) ; } } } 
