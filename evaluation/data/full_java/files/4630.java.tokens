package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Enumeration ; import java . util . Hashtable ; import java . util . List ; import java . util . Vector ; import org . eclipse . core . runtime . Assert ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . model . IMemoryBlock ; import org . eclipse . debug . core . model . IMemoryBlockExtension ; import org . eclipse . debug . core . model . MemoryByte ; import org . eclipse . debug . internal . ui . memory . provisional . AbstractAsyncTableRendering ; import org . eclipse . debug . internal . ui . memory . provisional . MemoryViewPresentationContext ; import org . eclipse . debug . internal . ui . viewers . AsynchronousTableViewer ; import org . eclipse . debug . internal . ui . viewers . ModelNode ; import org . eclipse . debug . internal . ui . views . memory . MemoryViewUtil ; import org . eclipse . debug . ui . memory . IMemoryRendering ; public class TableRenderingModel extends AbstractVirtualContentTableModel implements IContentChangeComputer { private Hashtable < Object , Object > fCache ; private Vector < Object > fOrderedCache ; private boolean fMBSupportsChangeManagement ; private IMemoryBlock fMemoryBlock ; class SupportsChangeMgmtJob extends Job { SupportsChangeMgmtJob ( ) { super ( <str> ) ; setSystem ( true ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { IMemoryBlock mb = getMemoryBlock ( ) ; if ( mb instanceof IMemoryBlockExtension ) { IMemoryBlockExtension mbExt = ( IMemoryBlockExtension ) mb ; fMBSupportsChangeManagement = mbExt . supportsChangeManagement ( ) ; } return Status . OK_STATUS ; } } public TableRenderingModel ( AsynchronousTableViewer viewer ) { super ( viewer ) ; fCache = new Hashtable < Object , Object > ( ) ; fOrderedCache = new Vector < Object > ( ) ; } @Override public int indexOfKey ( Object key ) { if ( key instanceof BigInteger ) { BigInteger address = ( BigInteger ) key ; Object items [ ] = getElements ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { if ( items [ i ] ! = null & & items [ i ] instanceof MemorySegment ) { MemorySegment line = ( MemorySegment ) items [ i ] ; if ( line . containsAddress ( address ) ) { return i ; } } } } return - <int> ; } @Override public int columnOf ( Object element , Object key ) { if ( element instanceof MemorySegment & & key instanceof BigInteger ) { BigInteger address = ( BigInteger ) key ; MemorySegment line = ( MemorySegment ) element ; if ( line . containsAddress ( address ) ) { if ( getAddressableUnitsPerColumn ( ) > <int> ) { BigInteger offset = address . subtract ( line . getAddress ( ) ) ; int colAddressableUnit = getAddressableUnitsPerColumn ( ) ; int col = ( ( offset . intValue ( ) / colAddressableUnit ) + <int> ) ; if ( col = = <int> ) { col = <int> ; } return col ; } } } return - <int> ; } @Override public Object getKey ( int idx ) { Object elmt = getElement ( idx ) ; if ( elmt instanceof MemorySegment ) { return ( ( MemorySegment ) elmt ) . getAddress ( ) ; } return null ; } @Override public Object getKey ( Object element ) { int idx = indexOfElement ( element ) ; if ( idx > = <int> ) { return getKey ( idx ) ; } return null ; } @Override public Object getKey ( int idx , int col ) { Object element = getElement ( idx ) ; if ( element ! = null & & element instanceof MemorySegment ) { MemorySegment segment = ( MemorySegment ) element ; BigInteger rowAddress = segment . getAddress ( ) ; int offset ; if ( col > <int> ) { int addressableUnit = getAddressableUnitsPerColumn ( ) ; offset = ( col - <int> ) * addressableUnit ; } else { offset = <int> ; } return rowAddress . add ( BigInteger . valueOf ( offset ) ) ; } return null ; } private int getAddressableUnitsPerColumn ( ) { AsynchronousTableViewer viewer = getTableViewer ( ) ; if ( viewer . getPresentationContext ( ) instanceof MemoryViewPresentationContext ) { MemoryViewPresentationContext context = ( MemoryViewPresentationContext ) viewer . getPresentationContext ( ) ; if ( getTableRendering ( context ) ! = null ) { return getTableRendering ( context ) . getAddressableUnitPerColumn ( ) ; } } return - <int> ; } @Override public void cache ( Object [ ] elements ) { for ( int i = <int> ; i < elements . length ; i + + ) { Object obj = elements [ i ] ; if ( obj instanceof MemorySegment ) { cache ( ( ( MemorySegment ) obj ) . getAddress ( ) , obj ) ; } } } private void cache ( Object key , Object element ) { fCache . put ( key , element ) ; fOrderedCache . add ( element ) ; } @Override public Object [ ] compare ( Object [ ] newElements ) { if ( fCache . isEmpty ( ) ) { return newElements ; } for ( int j = <int> ; j < newElements . length ; j + + ) { Object obj = newElements [ j ] ; if ( obj instanceof MemorySegment ) { MemorySegment newSegment = ( MemorySegment ) obj ; MemorySegment oldSegment = ( MemorySegment ) fCache . get ( newSegment . getAddress ( ) ) ; if ( oldSegment ! = null ) { if ( oldSegment . getNumAddressableUnits ( ) = = newSegment . getNumAddressableUnits ( ) ) { MemoryByte [ ] newBytes = newSegment . getBytes ( ) ; MemoryByte [ ] oldBytes = oldSegment . getBytes ( ) ; for ( int i = <int> ; i < newBytes . length ; i + + ) { newBytes [ i ] . setHistoryKnown ( true ) ; if ( newBytes [ i ] . isReadable ( ) ! = oldBytes [ i ] . isReadable ( ) ) { newBytes [ i ] . setChanged ( true ) ; continue ; } if ( newBytes [ i ] . isReadable ( ) & & oldBytes [ i ] . isReadable ( ) & & ( newBytes [ i ] . getValue ( ) ! = oldBytes [ i ] . getValue ( ) ) ) { newBytes [ i ] . setChanged ( true ) ; } } } } } } return newElements ; } @Override public void clearCache ( ) { fCache . clear ( ) ; fOrderedCache . clear ( ) ; } @Override public boolean isEmpty ( ) { return fCache . isEmpty ( ) ; } @Override public void handleViewerChanged ( ) { rebuildCache ( ) ; rebuildContent ( ) ; } private void rebuildCache ( ) { if ( isEmpty ( ) ) { return ; } MemoryViewPresentationContext context = ( MemoryViewPresentationContext ) getTableViewer ( ) . getPresentationContext ( ) ; AbstractAsyncTableRendering rendering = getTableRendering ( context ) ; if ( rendering = = null ) { return ; } ArrayList < Object > segments = new ArrayList < Object > ( ) ; Enumeration < Object > enumeration = fOrderedCache . elements ( ) ; BigInteger address = ( ( MemorySegment ) fOrderedCache . get ( <int> ) ) . getAddress ( ) ; while ( enumeration . hasMoreElements ( ) ) { Object element = enumeration . nextElement ( ) ; if ( element instanceof MemorySegment ) { segments . add ( element ) ; } } MemoryByte [ ] bytes = convertSegmentsToBytes ( segments . toArray ( new MemorySegment [ <int> ] ) ) ; int bytesPerLine = rendering . getBytesPerLine ( ) ; int numAddressableUnitPerLine = rendering . getAddressableUnitPerLine ( ) ; int addressableSize = rendering . getAddressableSize ( ) ; clearCache ( ) ; TableRenderingContentDescriptor descriptor = rendering . getAdapter ( TableRenderingContentDescriptor . class ) ; boolean alignAddress = true ; if ( descriptor ! = null & & ! descriptor . isAlignAddressToBoundary ( ) ) { alignAddress = descriptor . isAlignAddressToBoundary ( ) ; } MemorySegment [ ] newSegments = convertMemoryBytesToSegments ( address , bytes , bytesPerLine , numAddressableUnitPerLine , addressableSize , alignAddress ) ; for ( int i = <int> ; i < newSegments . length ; i + + ) { cache ( newSegments [ i ] . getAddress ( ) , newSegments [ i ] ) ; } } private void rebuildContent ( ) { MemoryViewPresentationContext context = ( MemoryViewPresentationContext ) getTableViewer ( ) . getPresentationContext ( ) ; AbstractAsyncTableRendering rendering = getTableRendering ( context ) ; if ( rendering = = null ) { return ; } ArrayList < Object > segments = new ArrayList < Object > ( ) ; Object [ ] elements = getElements ( ) ; for ( int i = <int> ; i < elements . length ; i + + ) { Object element = elements [ i ] ; if ( element instanceof MemorySegment ) { segments . add ( element ) ; } } MemoryByte [ ] bytes = convertSegmentsToBytes ( segments . toArray ( new MemorySegment [ segments . size ( ) ] ) ) ; int bytesPerLine = rendering . getBytesPerLine ( ) ; int numAddressableUnitPerLine = rendering . getAddressableUnitPerLine ( ) ; BigInteger address = ( BigInteger ) getKey ( <int> ) ; if ( address = = null ) { return ; } int addressableSize = rendering . getAddressableSize ( ) ; TableRenderingContentDescriptor descriptor = rendering . getAdapter ( TableRenderingContentDescriptor . class ) ; boolean alignAddress = true ; if ( descriptor ! = null & & ! descriptor . isAlignAddressToBoundary ( ) ) { alignAddress = descriptor . isAlignAddressToBoundary ( ) ; } MemorySegment [ ] newSegments = convertMemoryBytesToSegments ( address , bytes , bytesPerLine , numAddressableUnitPerLine , addressableSize , alignAddress ) ; remove ( getElements ( ) ) ; add ( newSegments ) ; } private MemoryByte [ ] convertSegmentsToBytes ( MemorySegment [ ] segments ) { ArrayList < MemoryByte > toReturn = new ArrayList < MemoryByte > ( ) ; for ( int i = <int> ; i < segments . length ; i + + ) { MemoryByte [ ] temp = segments [ i ] . getBytes ( ) ; for ( int j = <int> ; j < temp . length ; j + + ) { toReturn . add ( temp [ j ] ) ; } } return toReturn . toArray ( new MemoryByte [ <int> ] ) ; } private MemorySegment [ ] convertMemoryBytesToSegments ( BigInteger address , MemoryByte [ ] bytes , int bytesPerLine , int numAddressableUnitPerLine , int addressableSize , boolean alignAddress ) { Assert . isTrue ( bytesPerLine > <int> ) ; Assert . isTrue ( numAddressableUnitPerLine > <int> ) ; ArrayList < MemorySegment > segments = new ArrayList < MemorySegment > ( ) ; MemoryByte [ ] temp = bytes ; if ( alignAddress ) { BigInteger alignedAddress = MemoryViewUtil . alignToBoundary ( address , numAddressableUnitPerLine ) ; if ( ! address . subtract ( alignedAddress ) . equals ( BigInteger . ZERO ) ) { BigInteger unitsToSetBack = address . subtract ( alignedAddress ) ; BigInteger tempAddress = address . subtract ( unitsToSetBack ) ; if ( tempAddress . compareTo ( BigInteger . ZERO ) > = <int> ) { address = alignedAddress ; int numBytesNeeded = unitsToSetBack . intValue ( ) * addressableSize ; temp = new MemoryByte [ bytes . length + numBytesNeeded ] ; for ( int i = <int> ; i < numBytesNeeded ; i + + ) { temp [ i ] = new MemoryByte ( ) ; temp [ i ] . setReadable ( false ) ; temp [ i ] . setWritable ( false ) ; temp [ i ] . setEndianessKnown ( false ) ; } System . arraycopy ( bytes , <int> , temp , numBytesNeeded , bytes . length ) ; bytes = temp ; } } } if ( bytes . length % bytesPerLine ! = <int> ) { int numBytesNeeded = bytesPerLine - ( bytes . length % bytesPerLine ) ; temp = new MemoryByte [ bytes . length + numBytesNeeded ] ; System . arraycopy ( bytes , <int> , temp , <int> , bytes . length ) ; for ( int i = bytes . length ; i < temp . length ; i + + ) { temp [ i ] = new MemoryByte ( ) ; temp [ i ] . setReadable ( false ) ; temp [ i ] . setWritable ( false ) ; temp [ i ] . setEndianessKnown ( false ) ; } bytes = temp ; } int idx = <int> ; while ( idx < bytes . length & & ( idx + bytesPerLine ) < = bytes . length ) { MemoryByte [ ] newBytes = new MemoryByte [ bytesPerLine ] ; System . arraycopy ( bytes , idx , newBytes , <int> , bytesPerLine ) ; MemorySegment segment = new MemorySegment ( address , newBytes , numAddressableUnitPerLine ) ; segments . add ( segment ) ; address = address . add ( BigInteger . valueOf ( numAddressableUnitPerLine ) ) ; idx + = bytesPerLine ; } return segments . toArray ( new MemorySegment [ segments . size ( ) ] ) ; } private AsynchronousTableViewer getTableViewer ( ) { return ( AsynchronousTableViewer ) getViewer ( ) ; } @Override protected void setChildren ( ModelNode parentNode , List < Object > kids ) { if ( computeChanges ( ) ) { Object [ ] newContent = compare ( kids . toArray ( ) ) ; ArrayList < Object > newList = new ArrayList < Object > ( ) ; for ( int i = <int> ; i < newContent . length ; i + + ) { newList . add ( newContent [ i ] ) ; } super . setChildren ( parentNode , newList ) ; } else { super . setChildren ( parentNode , kids ) ; } } private boolean computeChanges ( ) { if ( isEmpty ( ) ) { return false ; } if ( fMBSupportsChangeManagement ) { return false ; } return true ; } private IMemoryBlock getMemoryBlock ( ) { return fMemoryBlock ; } @Override public void init ( Object root ) { if ( root instanceof IMemoryBlock ) { fMemoryBlock = ( IMemoryBlock ) root ; new SupportsChangeMgmtJob ( ) . schedule ( ) ; } super . init ( root ) ; } private AbstractAsyncTableRendering getTableRendering ( MemoryViewPresentationContext context ) { IMemoryRendering memRendering = context . getRendering ( ) ; if ( memRendering ! = null & & memRendering instanceof AbstractAsyncTableRendering ) { return ( AbstractAsyncTableRendering ) memRendering ; } return null ; } } 
