package com . badlogic . gdx . scenes . scene2d ; import com . badlogic . gdx . Application . ApplicationType ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Graphics ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . InputAdapter ; import com . badlogic . gdx . InputMultiplexer ; import com . badlogic . gdx . graphics . Camera ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . OrthographicCamera ; import com . badlogic . gdx . graphics . g2d . Batch ; import com . badlogic . gdx . graphics . g2d . SpriteBatch ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . scenes . scene2d . InputEvent . Type ; import com . badlogic . gdx . scenes . scene2d . ui . Table ; import com . badlogic . gdx . scenes . scene2d . ui . Table . Debug ; import com . badlogic . gdx . scenes . scene2d . utils . FocusListener . FocusEvent ; import com . badlogic . gdx . scenes . scene2d . utils . ScissorStack ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . Pool . Poolable ; import com . badlogic . gdx . utils . Pools ; import com . badlogic . gdx . utils . Scaling ; import com . badlogic . gdx . utils . SnapshotArray ; import com . badlogic . gdx . utils . viewport . ScalingViewport ; import com . badlogic . gdx . utils . viewport . Viewport ; public class Stage extends InputAdapter implements Disposable { static boolean debug ; private Viewport viewport ; private final Batch batch ; private boolean ownsBatch ; private final Group root ; private final Vector2 tempCoords = new Vector2 ( ) ; private final Actor [ ] pointerOverActors = new Actor [ <int> ] ; private final boolean [ ] pointerTouched = new boolean [ <int> ] ; private final int [ ] pointerScreenX = new int [ <int> ] ; private final int [ ] pointerScreenY = new int [ <int> ] ; private int mouseScreenX , mouseScreenY ; private Actor mouseOverActor ; private Actor keyboardFocus , scrollFocus ; private final SnapshotArray < TouchFocus > touchFocuses = new SnapshotArray ( true , <int> , TouchFocus . class ) ; private boolean actionsRequestRendering = true ; private ShapeRenderer debugShapes ; private boolean debugInvisible , debugAll , debugUnderMouse , debugParentUnderMouse ; private Debug debugTableUnderMouse = Debug . none ; private final Color debugColor = new Color ( <int> , <int> , <int> , <float> ) ; public Stage ( ) { this ( new ScalingViewport ( Scaling . stretch , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) , new OrthographicCamera ( ) ) , new SpriteBatch ( ) ) ; ownsBatch = true ; } public Stage ( Viewport viewport ) { this ( viewport , new SpriteBatch ( ) ) ; ownsBatch = true ; } public Stage ( Viewport viewport , Batch batch ) { if ( viewport = = null ) throw new IllegalArgumentException ( <str> ) ; if ( batch = = null ) throw new IllegalArgumentException ( <str> ) ; this . viewport = viewport ; this . batch = batch ; root = new Group ( ) ; root . setStage ( this ) ; viewport . update ( Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) , true ) ; } public void draw ( ) { Camera camera = viewport . getCamera ( ) ; camera . update ( ) ; if ( ! root . isVisible ( ) ) return ; Batch batch = this . batch ; if ( batch ! = null ) { batch . setProjectionMatrix ( camera . combined ) ; batch . begin ( ) ; root . draw ( batch , <int> ) ; batch . end ( ) ; } if ( debug ) drawDebug ( ) ; } private void drawDebug ( ) { if ( debugShapes = = null ) { debugShapes = new ShapeRenderer ( ) ; debugShapes . setAutoShapeType ( true ) ; } if ( debugUnderMouse | | debugParentUnderMouse | | debugTableUnderMouse ! = Debug . none ) { screenToStageCoordinates ( tempCoords . set ( Gdx . input . getX ( ) , Gdx . input . getY ( ) ) ) ; Actor actor = hit ( tempCoords . x , tempCoords . y , true ) ; if ( actor = = null ) return ; if ( debugParentUnderMouse & & actor . parent ! = null ) actor = actor . parent ; if ( debugTableUnderMouse = = Debug . none ) actor . setDebug ( true ) ; else { while ( actor ! = null ) { if ( actor instanceof Table ) break ; actor = actor . parent ; } if ( actor = = null ) return ; ( ( Table ) actor ) . debug ( debugTableUnderMouse ) ; } if ( debugAll & & actor instanceof Group ) ( ( Group ) actor ) . debugAll ( ) ; disableDebug ( root , actor ) ; } else { if ( debugAll ) root . debugAll ( ) ; } Gdx . gl . glEnable ( GL20 . GL_BLEND ) ; debugShapes . setProjectionMatrix ( viewport . getCamera ( ) . combined ) ; debugShapes . begin ( ) ; root . drawDebug ( debugShapes ) ; debugShapes . end ( ) ; } private void disableDebug ( Actor actor , Actor except ) { if ( actor = = except ) return ; actor . setDebug ( false ) ; if ( actor instanceof Group ) { SnapshotArray < Actor > children = ( ( Group ) actor ) . children ; for ( int i = <int> , n = children . size ; i < n ; i + + ) disableDebug ( children . get ( i ) , except ) ; } } public void act ( ) { act ( Math . min ( Gdx . graphics . getDeltaTime ( ) , <int> / <int> f ) ) ; } public void act ( float delta ) { for ( int pointer = <int> , n = pointerOverActors . length ; pointer < n ; pointer + + ) { Actor overLast = pointerOverActors [ pointer ] ; if ( ! pointerTouched [ pointer ] ) { if ( overLast ! = null ) { pointerOverActors [ pointer ] = null ; screenToStageCoordinates ( tempCoords . set ( pointerScreenX [ pointer ] , pointerScreenY [ pointer ] ) ) ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setType ( InputEvent . Type . exit ) ; event . setStage ( this ) ; event . setStageX ( tempCoords . x ) ; event . setStageY ( tempCoords . y ) ; event . setRelatedActor ( overLast ) ; event . setPointer ( pointer ) ; overLast . fire ( event ) ; Pools . free ( event ) ; } continue ; } pointerOverActors [ pointer ] = fireEnterAndExit ( overLast , pointerScreenX [ pointer ] , pointerScreenY [ pointer ] , pointer ) ; } ApplicationType type = Gdx . app . getType ( ) ; if ( type = = ApplicationType . Desktop | | type = = ApplicationType . Applet | | type = = ApplicationType . WebGL ) mouseOverActor = fireEnterAndExit ( mouseOverActor , mouseScreenX , mouseScreenY , - <int> ) ; root . act ( delta ) ; } private Actor fireEnterAndExit ( Actor overLast , int screenX , int screenY , int pointer ) { screenToStageCoordinates ( tempCoords . set ( screenX , screenY ) ) ; Actor over = hit ( tempCoords . x , tempCoords . y , true ) ; if ( over = = overLast ) return overLast ; if ( overLast ! = null ) { InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setStageX ( tempCoords . x ) ; event . setStageY ( tempCoords . y ) ; event . setPointer ( pointer ) ; event . setType ( InputEvent . Type . exit ) ; event . setRelatedActor ( over ) ; overLast . fire ( event ) ; Pools . free ( event ) ; } if ( over ! = null ) { InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setStageX ( tempCoords . x ) ; event . setStageY ( tempCoords . y ) ; event . setPointer ( pointer ) ; event . setType ( InputEvent . Type . enter ) ; event . setRelatedActor ( overLast ) ; over . fire ( event ) ; Pools . free ( event ) ; } return over ; } public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { if ( screenX < viewport . getScreenX ( ) | | screenX > = viewport . getScreenX ( ) + viewport . getScreenWidth ( ) ) return false ; if ( Gdx . graphics . getHeight ( ) - screenY < viewport . getScreenY ( ) | | Gdx . graphics . getHeight ( ) - screenY > = viewport . getScreenY ( ) + viewport . getScreenHeight ( ) ) return false ; pointerTouched [ pointer ] = true ; pointerScreenX [ pointer ] = screenX ; pointerScreenY [ pointer ] = screenY ; screenToStageCoordinates ( tempCoords . set ( screenX , screenY ) ) ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setType ( Type . touchDown ) ; event . setStage ( this ) ; event . setStageX ( tempCoords . x ) ; event . setStageY ( tempCoords . y ) ; event . setPointer ( pointer ) ; event . setButton ( button ) ; Actor target = hit ( tempCoords . x , tempCoords . y , true ) ; if ( target = = null ) { if ( root . getTouchable ( ) = = Touchable . enabled ) root . fire ( event ) ; } else { target . fire ( event ) ; } boolean handled = event . isHandled ( ) ; Pools . free ( event ) ; return handled ; } public boolean touchDragged ( int screenX , int screenY , int pointer ) { pointerScreenX [ pointer ] = screenX ; pointerScreenY [ pointer ] = screenY ; mouseScreenX = screenX ; mouseScreenY = screenY ; if ( touchFocuses . size = = <int> ) return false ; screenToStageCoordinates ( tempCoords . set ( screenX , screenY ) ) ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setType ( Type . touchDragged ) ; event . setStage ( this ) ; event . setStageX ( tempCoords . x ) ; event . setStageY ( tempCoords . y ) ; event . setPointer ( pointer ) ; SnapshotArray < TouchFocus > touchFocuses = this . touchFocuses ; TouchFocus [ ] focuses = touchFocuses . begin ( ) ; for ( int i = <int> , n = touchFocuses . size ; i < n ; i + + ) { TouchFocus focus = focuses [ i ] ; if ( focus . pointer ! = pointer ) continue ; if ( ! touchFocuses . contains ( focus , true ) ) continue ; event . setTarget ( focus . target ) ; event . setListenerActor ( focus . listenerActor ) ; if ( focus . listener . handle ( event ) ) event . handle ( ) ; } touchFocuses . end ( ) ; boolean handled = event . isHandled ( ) ; Pools . free ( event ) ; return handled ; } public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { pointerTouched [ pointer ] = false ; pointerScreenX [ pointer ] = screenX ; pointerScreenY [ pointer ] = screenY ; if ( touchFocuses . size = = <int> ) return false ; screenToStageCoordinates ( tempCoords . set ( screenX , screenY ) ) ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setType ( Type . touchUp ) ; event . setStage ( this ) ; event . setStageX ( tempCoords . x ) ; event . setStageY ( tempCoords . y ) ; event . setPointer ( pointer ) ; event . setButton ( button ) ; SnapshotArray < TouchFocus > touchFocuses = this . touchFocuses ; TouchFocus [ ] focuses = touchFocuses . begin ( ) ; for ( int i = <int> , n = touchFocuses . size ; i < n ; i + + ) { TouchFocus focus = focuses [ i ] ; if ( focus . pointer ! = pointer | | focus . button ! = button ) continue ; if ( ! touchFocuses . removeValue ( focus , true ) ) continue ; event . setTarget ( focus . target ) ; event . setListenerActor ( focus . listenerActor ) ; if ( focus . listener . handle ( event ) ) event . handle ( ) ; Pools . free ( focus ) ; } touchFocuses . end ( ) ; boolean handled = event . isHandled ( ) ; Pools . free ( event ) ; return handled ; } public boolean mouseMoved ( int screenX , int screenY ) { if ( screenX < viewport . getScreenX ( ) | | screenX > = viewport . getScreenX ( ) + viewport . getScreenWidth ( ) ) return false ; if ( Gdx . graphics . getHeight ( ) - screenY < viewport . getScreenY ( ) | | Gdx . graphics . getHeight ( ) - screenY > = viewport . getScreenY ( ) + viewport . getScreenHeight ( ) ) return false ; mouseScreenX = screenX ; mouseScreenY = screenY ; screenToStageCoordinates ( tempCoords . set ( screenX , screenY ) ) ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setType ( Type . mouseMoved ) ; event . setStageX ( tempCoords . x ) ; event . setStageY ( tempCoords . y ) ; Actor target = hit ( tempCoords . x , tempCoords . y , true ) ; if ( target = = null ) target = root ; target . fire ( event ) ; boolean handled = event . isHandled ( ) ; Pools . free ( event ) ; return handled ; } public boolean scrolled ( int amount ) { Actor target = scrollFocus = = null ? root : scrollFocus ; screenToStageCoordinates ( tempCoords . set ( mouseScreenX , mouseScreenY ) ) ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setType ( InputEvent . Type . scrolled ) ; event . setScrollAmount ( amount ) ; event . setStageX ( tempCoords . x ) ; event . setStageY ( tempCoords . y ) ; target . fire ( event ) ; boolean handled = event . isHandled ( ) ; Pools . free ( event ) ; return handled ; } public boolean keyDown ( int keyCode ) { Actor target = keyboardFocus = = null ? root : keyboardFocus ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setType ( InputEvent . Type . keyDown ) ; event . setKeyCode ( keyCode ) ; target . fire ( event ) ; boolean handled = event . isHandled ( ) ; Pools . free ( event ) ; return handled ; } public boolean keyUp ( int keyCode ) { Actor target = keyboardFocus = = null ? root : keyboardFocus ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setType ( InputEvent . Type . keyUp ) ; event . setKeyCode ( keyCode ) ; target . fire ( event ) ; boolean handled = event . isHandled ( ) ; Pools . free ( event ) ; return handled ; } public boolean keyTyped ( char character ) { Actor target = keyboardFocus = = null ? root : keyboardFocus ; InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setType ( InputEvent . Type . keyTyped ) ; event . setCharacter ( character ) ; target . fire ( event ) ; boolean handled = event . isHandled ( ) ; Pools . free ( event ) ; return handled ; } public void addTouchFocus ( EventListener listener , Actor listenerActor , Actor target , int pointer , int button ) { TouchFocus focus = Pools . obtain ( TouchFocus . class ) ; focus . listenerActor = listenerActor ; focus . target = target ; focus . listener = listener ; focus . pointer = pointer ; focus . button = button ; touchFocuses . add ( focus ) ; } public void removeTouchFocus ( EventListener listener , Actor listenerActor , Actor target , int pointer , int button ) { SnapshotArray < TouchFocus > touchFocuses = this . touchFocuses ; for ( int i = touchFocuses . size - <int> ; i > = <int> ; i - - ) { TouchFocus focus = touchFocuses . get ( i ) ; if ( focus . listener = = listener & & focus . listenerActor = = listenerActor & & focus . target = = target & & focus . pointer = = pointer & & focus . button = = button ) { touchFocuses . removeIndex ( i ) ; Pools . free ( focus ) ; } } } public void cancelTouchFocus ( Actor actor ) { InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setType ( InputEvent . Type . touchUp ) ; event . setStageX ( Integer . MIN_VALUE ) ; event . setStageY ( Integer . MIN_VALUE ) ; SnapshotArray < TouchFocus > touchFocuses = this . touchFocuses ; TouchFocus [ ] items = touchFocuses . begin ( ) ; for ( int i = <int> , n = touchFocuses . size ; i < n ; i + + ) { TouchFocus focus = items [ i ] ; if ( focus . listenerActor ! = actor ) continue ; if ( ! touchFocuses . removeValue ( focus , true ) ) continue ; event . setTarget ( focus . target ) ; event . setListenerActor ( focus . listenerActor ) ; event . setPointer ( focus . pointer ) ; event . setButton ( focus . button ) ; focus . listener . handle ( event ) ; } touchFocuses . end ( ) ; Pools . free ( event ) ; } public void cancelTouchFocus ( ) { cancelTouchFocusExcept ( null , null ) ; } public void cancelTouchFocusExcept ( EventListener exceptListener , Actor exceptActor ) { InputEvent event = Pools . obtain ( InputEvent . class ) ; event . setStage ( this ) ; event . setType ( InputEvent . Type . touchUp ) ; event . setStageX ( Integer . MIN_VALUE ) ; event . setStageY ( Integer . MIN_VALUE ) ; SnapshotArray < TouchFocus > touchFocuses = this . touchFocuses ; TouchFocus [ ] items = touchFocuses . begin ( ) ; for ( int i = <int> , n = touchFocuses . size ; i < n ; i + + ) { TouchFocus focus = items [ i ] ; if ( focus . listener = = exceptListener & & focus . listenerActor = = exceptActor ) continue ; if ( ! touchFocuses . removeValue ( focus , true ) ) continue ; event . setTarget ( focus . target ) ; event . setListenerActor ( focus . listenerActor ) ; event . setPointer ( focus . pointer ) ; event . setButton ( focus . button ) ; focus . listener . handle ( event ) ; } touchFocuses . end ( ) ; Pools . free ( event ) ; } public void addActor ( Actor actor ) { root . addActor ( actor ) ; } public void addAction ( Action action ) { root . addAction ( action ) ; } public Array < Actor > getActors ( ) { return root . children ; } public boolean addListener ( EventListener listener ) { return root . addListener ( listener ) ; } public boolean removeListener ( EventListener listener ) { return root . removeListener ( listener ) ; } public boolean addCaptureListener ( EventListener listener ) { return root . addCaptureListener ( listener ) ; } public boolean removeCaptureListener ( EventListener listener ) { return root . removeCaptureListener ( listener ) ; } public void clear ( ) { unfocusAll ( ) ; root . clear ( ) ; } public void unfocusAll ( ) { scrollFocus = null ; keyboardFocus = null ; cancelTouchFocus ( ) ; } public void unfocus ( Actor actor ) { cancelTouchFocus ( actor ) ; if ( scrollFocus ! = null & & scrollFocus . isDescendantOf ( actor ) ) scrollFocus = null ; if ( keyboardFocus ! = null & & keyboardFocus . isDescendantOf ( actor ) ) keyboardFocus = null ; } public void setKeyboardFocus ( Actor actor ) { if ( keyboardFocus = = actor ) return ; FocusEvent event = Pools . obtain ( FocusEvent . class ) ; event . setStage ( this ) ; event . setType ( FocusEvent . Type . keyboard ) ; Actor oldKeyboardFocus = keyboardFocus ; if ( oldKeyboardFocus ! = null ) { event . setFocused ( false ) ; event . setRelatedActor ( actor ) ; oldKeyboardFocus . fire ( event ) ; } if ( ! event . isCancelled ( ) ) { keyboardFocus = actor ; if ( actor ! = null ) { event . setFocused ( true ) ; event . setRelatedActor ( oldKeyboardFocus ) ; actor . fire ( event ) ; if ( event . isCancelled ( ) ) setKeyboardFocus ( oldKeyboardFocus ) ; } } Pools . free ( event ) ; } public Actor getKeyboardFocus ( ) { return keyboardFocus ; } public void setScrollFocus ( Actor actor ) { if ( scrollFocus = = actor ) return ; FocusEvent event = Pools . obtain ( FocusEvent . class ) ; event . setStage ( this ) ; event . setType ( FocusEvent . Type . scroll ) ; Actor oldScrollFocus = scrollFocus ; if ( oldScrollFocus ! = null ) { event . setFocused ( false ) ; event . setRelatedActor ( actor ) ; oldScrollFocus . fire ( event ) ; } if ( ! event . isCancelled ( ) ) { scrollFocus = actor ; if ( actor ! = null ) { event . setFocused ( true ) ; event . setRelatedActor ( oldScrollFocus ) ; actor . fire ( event ) ; if ( event . isCancelled ( ) ) setScrollFocus ( oldScrollFocus ) ; } } Pools . free ( event ) ; } public Actor getScrollFocus ( ) { return scrollFocus ; } public Batch getBatch ( ) { return batch ; } public Viewport getViewport ( ) { return viewport ; } public void setViewport ( Viewport viewport ) { this . viewport = viewport ; } public float getWidth ( ) { return viewport . getWorldWidth ( ) ; } public float getHeight ( ) { return viewport . getWorldHeight ( ) ; } public Camera getCamera ( ) { return viewport . getCamera ( ) ; } public Group getRoot ( ) { return root ; } public Actor hit ( float stageX , float stageY , boolean touchable ) { root . parentToLocalCoordinates ( tempCoords . set ( stageX , stageY ) ) ; return root . hit ( tempCoords . x , tempCoords . y , touchable ) ; } public Vector2 screenToStageCoordinates ( Vector2 screenCoords ) { viewport . unproject ( screenCoords ) ; return screenCoords ; } public Vector2 stageToScreenCoordinates ( Vector2 stageCoords ) { viewport . project ( stageCoords ) ; stageCoords . y = viewport . getScreenHeight ( ) - stageCoords . y ; return stageCoords ; } public Vector2 toScreenCoordinates ( Vector2 coords , Matrix4 transformMatrix ) { return viewport . toScreenCoordinates ( coords , transformMatrix ) ; } public void calculateScissors ( Rectangle localRect , Rectangle scissorRect ) { viewport . calculateScissors ( batch . getTransformMatrix ( ) , localRect , scissorRect ) ; Matrix4 transformMatrix ; if ( debugShapes ! = null & & debugShapes . isDrawing ( ) ) transformMatrix = debugShapes . getTransformMatrix ( ) ; else transformMatrix = batch . getTransformMatrix ( ) ; viewport . calculateScissors ( transformMatrix , localRect , scissorRect ) ; } public void setActionsRequestRendering ( boolean actionsRequestRendering ) { this . actionsRequestRendering = actionsRequestRendering ; } public boolean getActionsRequestRendering ( ) { return actionsRequestRendering ; } public Color getDebugColor ( ) { return debugColor ; } public void setDebugInvisible ( boolean debugInvisible ) { this . debugInvisible = debugInvisible ; } public void setDebugAll ( boolean debugAll ) { if ( this . debugAll = = debugAll ) return ; this . debugAll = debugAll ; if ( debugAll ) debug = true ; else root . setDebug ( false , true ) ; } public void setDebugUnderMouse ( boolean debugUnderMouse ) { if ( this . debugUnderMouse = = debugUnderMouse ) return ; this . debugUnderMouse = debugUnderMouse ; if ( debugUnderMouse ) debug = true ; else root . setDebug ( false , true ) ; } public void setDebugParentUnderMouse ( boolean debugParentUnderMouse ) { if ( this . debugParentUnderMouse = = debugParentUnderMouse ) return ; this . debugParentUnderMouse = debugParentUnderMouse ; if ( debugParentUnderMouse ) debug = true ; else root . setDebug ( false , true ) ; } public void setDebugTableUnderMouse ( Debug debugTableUnderMouse ) { if ( debugTableUnderMouse = = null ) debugTableUnderMouse = Debug . none ; if ( this . debugTableUnderMouse = = debugTableUnderMouse ) return ; this . debugTableUnderMouse = debugTableUnderMouse ; if ( debugTableUnderMouse ! = Debug . none ) debug = true ; else root . setDebug ( false , true ) ; } public void setDebugTableUnderMouse ( boolean debugTableUnderMouse ) { setDebugTableUnderMouse ( debugTableUnderMouse ? Debug . all : Debug . none ) ; } public void dispose ( ) { clear ( ) ; if ( ownsBatch ) batch . dispose ( ) ; } public static final class TouchFocus implements Poolable { EventListener listener ; Actor listenerActor , target ; int pointer , button ; public void reset ( ) { listenerActor = null ; listener = null ; target = null ; } } } 
