package org . eclipse . debug . core . commands ; import java . util . LinkedHashSet ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . IJobChangeEvent ; import org . eclipse . core . runtime . jobs . IJobChangeListener ; import org . eclipse . core . runtime . jobs . ISchedulingRule ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IRequest ; import org . eclipse . debug . internal . core . DebugOptions ; public abstract class AbstractDebugCommand implements IDebugCommandHandler { private class UpdateJob extends Job implements IJobChangeListener { private IEnabledStateRequest request ; private boolean run = false ; UpdateJob ( IEnabledStateRequest stateRequest ) { super ( getEnabledStateTaskName ( ) ) ; request = stateRequest ; setSystem ( true ) ; setRule ( getEnabledStateSchedulingRule ( request ) ) ; getJobManager ( ) . addJobChangeListener ( this ) ; } @Override protected IStatus run ( IProgressMonitor monitor ) { run = true ; if ( DebugOptions . DEBUG_COMMANDS ) { DebugOptions . trace ( <str> + AbstractDebugCommand . this ) ; } if ( monitor . isCanceled ( ) ) { if ( DebugOptions . DEBUG_COMMANDS ) { DebugOptions . trace ( <str> ) ; } request . cancel ( ) ; } Object [ ] elements = request . getElements ( ) ; Object [ ] targets = new Object [ elements . length ] ; if ( ! request . isCanceled ( ) ) { for ( int i = <int> ; i < elements . length ; i + + ) { targets [ i ] = getTarget ( elements [ i ] ) ; if ( targets [ i ] = = null ) { request . setEnabled ( false ) ; request . cancel ( ) ; if ( DebugOptions . DEBUG_COMMANDS ) { DebugOptions . trace ( <str> ) ; } } } if ( monitor . isCanceled ( ) ) { request . cancel ( ) ; } } if ( ! request . isCanceled ( ) ) { targets = coalesce ( targets ) ; monitor . beginTask ( getEnabledStateTaskName ( ) , targets . length ) ; try { boolean executable = isExecutable ( targets , monitor , request ) ; if ( DebugOptions . DEBUG_COMMANDS ) { DebugOptions . trace ( <str> + executable ) ; } request . setEnabled ( executable ) ; } catch ( CoreException e ) { request . setStatus ( e . getStatus ( ) ) ; request . setEnabled ( false ) ; if ( DebugOptions . DEBUG_COMMANDS ) { DebugOptions . trace ( <str> ) ; DebugOptions . trace ( <str> + e . getStatus ( ) . getMessage ( ) ) ; } } } monitor . setCanceled ( request . isCanceled ( ) ) ; request . done ( ) ; monitor . done ( ) ; return Status . OK_STATUS ; } @Override public boolean belongsTo ( Object family ) { Object myFamily = getEnabledStateJobFamily ( request ) ; if ( myFamily ! = null ) { return myFamily . equals ( family ) ; } return false ; } @Override public void aboutToRun ( IJobChangeEvent event ) { } @Override public void awake ( IJobChangeEvent event ) { } @Override public void done ( IJobChangeEvent event ) { if ( event . getJob ( ) = = this ) { if ( ! run ) { request . cancel ( ) ; request . done ( ) ; if ( DebugOptions . DEBUG_COMMANDS ) { DebugOptions . trace ( <str> + AbstractDebugCommand . this ) ; } } getJobManager ( ) . removeJobChangeListener ( this ) ; } } @Override public void running ( IJobChangeEvent event ) { } @Override public void scheduled ( IJobChangeEvent event ) { } @Override public void sleeping ( IJobChangeEvent event ) { } } private class SerialPerObjectRule implements ISchedulingRule { private Object fObject = null ; public SerialPerObjectRule ( Object lock ) { fObject = lock ; } @Override public boolean contains ( ISchedulingRule rule ) { return rule = = this ; } @Override public boolean isConflicting ( ISchedulingRule rule ) { if ( rule instanceof SerialPerObjectRule ) { SerialPerObjectRule vup = ( SerialPerObjectRule ) rule ; return fObject = = vup . fObject ; } return false ; } } @Override public boolean execute ( final IDebugCommandRequest request ) { Job job = new Job ( getExecuteTaskName ( ) ) { @Override protected IStatus run ( IProgressMonitor monitor ) { if ( DebugOptions . DEBUG_COMMANDS ) { DebugOptions . trace ( <str> + AbstractDebugCommand . this ) ; } Object [ ] elements = request . getElements ( ) ; Object [ ] targets = new Object [ elements . length ] ; for ( int i = <int> ; i < elements . length ; i + + ) { targets [ i ] = getTarget ( elements [ i ] ) ; } targets = coalesce ( targets ) ; monitor . beginTask ( getExecuteTaskName ( ) , targets . length ) ; try { doExecute ( targets , monitor , request ) ; } catch ( CoreException e ) { request . setStatus ( e . getStatus ( ) ) ; if ( DebugOptions . DEBUG_COMMANDS ) { DebugOptions . trace ( <str> + e . getStatus ( ) . getMessage ( ) ) ; } } request . done ( ) ; monitor . setCanceled ( request . isCanceled ( ) ) ; monitor . done ( ) ; return Status . OK_STATUS ; } @Override public boolean belongsTo ( Object family ) { Object jobFamily = getExecuteJobFamily ( request ) ; if ( jobFamily ! = null ) { return jobFamily . equals ( family ) ; } return false ; } } ; job . setSystem ( true ) ; job . setRule ( getExecuteSchedulingRule ( request ) ) ; job . schedule ( ) ; return isRemainEnabled ( request ) ; } protected boolean isRemainEnabled ( IDebugCommandRequest request ) { return false ; } @Override public void canExecute ( final IEnabledStateRequest request ) { Job job = new UpdateJob ( request ) ; job . schedule ( ) ; } protected String getEnabledStateTaskName ( ) { return <str> ; } protected String getExecuteTaskName ( ) { return <str> ; } protected abstract void doExecute ( Object [ ] targets , IProgressMonitor monitor , IRequest request ) throws CoreException ; protected abstract boolean isExecutable ( Object [ ] targets , IProgressMonitor monitor , IEnabledStateRequest request ) throws CoreException ; protected abstract Object getTarget ( Object element ) ; protected Object getAdapter ( Object element , Class < ? > type ) { return DebugPlugin . getAdapter ( element , type ) ; } protected ISchedulingRule getEnabledStateSchedulingRule ( IDebugCommandRequest request ) { return new SerialPerObjectRule ( request . getElements ( ) [ <int> ] ) ; } protected ISchedulingRule getExecuteSchedulingRule ( IDebugCommandRequest request ) { return null ; } protected Object getEnabledStateJobFamily ( IDebugCommandRequest request ) { return null ; } protected Object getExecuteJobFamily ( IDebugCommandRequest request ) { return null ; } private Object [ ] coalesce ( Object [ ] objects ) { if ( objects . length = = <int> ) { return objects ; } else { LinkedHashSet < Object > set = new LinkedHashSet < Object > ( objects . length ) ; for ( int i = <int> ; i < objects . length ; i + + ) { set . add ( objects [ i ] ) ; } return set . toArray ( ) ; } } } 
