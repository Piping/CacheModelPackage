package org . apache . cassandra . concurrent ; import org . apache . cassandra . Util ; import org . apache . cassandra . utils . concurrent . WaitQueue ; import org . junit . * ; import java . util . concurrent . ThreadLocalRandom ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . atomic . AtomicInteger ; import static org . junit . Assert . * ; public class WaitQueueTest { @Test public void testSerial ( ) throws InterruptedException { testSerial ( new WaitQueue ( ) ) ; } public void testSerial ( final WaitQueue queue ) throws InterruptedException { final AtomicInteger ready = new AtomicInteger ( ) ; Thread [ ] ts = new Thread [ <int> ] ; for ( int i = <int> ; i < ts . length ; i + + ) ts [ i ] = new Thread ( new Runnable ( ) { @Override public void run ( ) { WaitQueue . Signal wait = queue . register ( ) ; ready . incrementAndGet ( ) ; try { wait . await ( ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } ) ; for ( Thread t : ts ) t . start ( ) ; final ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; while ( ready . get ( ) < ts . length ) random . nextLong ( ) ; for ( Thread t : ts ) queue . signal ( ) ; for ( Thread t : ts ) { Util . joinThread ( t ) ; assertFalse ( queue . getClass ( ) . getName ( ) , t . isAlive ( ) ) ; } } @Test public void testCondition ( ) throws InterruptedException { testCondition ( new WaitQueue ( ) ) ; } public void testCondition ( final WaitQueue queue ) throws InterruptedException { final AtomicBoolean ready = new AtomicBoolean ( false ) ; final AtomicBoolean condition = new AtomicBoolean ( false ) ; final AtomicBoolean fail = new AtomicBoolean ( false ) ; Thread t = new Thread ( new Runnable ( ) { @Override public void run ( ) { WaitQueue . Signal wait = queue . register ( ) ; if ( condition . get ( ) ) { System . err . println ( <str> ) ; fail . set ( true ) ; ready . set ( true ) ; return ; } ready . set ( true ) ; wait . awaitUninterruptibly ( ) ; if ( ! condition . get ( ) ) { System . err . println ( <str> ) ; fail . set ( true ) ; } } } ) ; t . start ( ) ; final ThreadLocalRandom random = ThreadLocalRandom . current ( ) ; while ( ! ready . get ( ) ) random . nextLong ( ) ; condition . set ( true ) ; queue . signal ( ) ; Util . joinThread ( t ) ; assertFalse ( queue . getClass ( ) . getName ( ) , t . isAlive ( ) ) ; assertFalse ( fail . get ( ) ) ; } } 
