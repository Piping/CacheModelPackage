package org . elasticsearch . bootstrap ; import com . sun . jna . Library ; import com . sun . jna . Memory ; import com . sun . jna . Native ; import com . sun . jna . NativeLong ; import com . sun . jna . Pointer ; import com . sun . jna . Structure ; import com . sun . jna . ptr . PointerByReference ; import org . apache . lucene . util . Constants ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . nio . ByteOrder ; import java . nio . file . Files ; import java . nio . file . Path ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; final class Seccomp { private static final ESLogger logger = Loggers . getLogger ( Seccomp . class ) ; static interface LinuxLibrary extends Library { int prctl ( int option , NativeLong arg2 , NativeLong arg3 , NativeLong arg4 , NativeLong arg5 ) ; NativeLong syscall ( NativeLong number , Object . . . args ) ; } ; private static final LinuxLibrary linux_libc ; static { LinuxLibrary lib = null ; if ( Constants . LINUX ) { try { lib = ( LinuxLibrary ) Native . loadLibrary ( <str> , LinuxLibrary . class ) ; } catch ( UnsatisfiedLinkError e ) { logger . warn ( <str> , e ) ; } } linux_libc = lib ; } static final int SECCOMP_SET_MODE_FILTER = <int> ; static final int SECCOMP_FILTER_FLAG_TSYNC = <int> ; static final int PR_GET_NO_NEW_PRIVS = <int> ; static final int PR_SET_NO_NEW_PRIVS = <int> ; static final int PR_GET_SECCOMP = <int> ; static final int PR_SET_SECCOMP = <int> ; static final long SECCOMP_MODE_FILTER = <int> ; static final class SockFilter { short code ; byte jt ; byte jf ; int k ; SockFilter ( short code , byte jt , byte jf , int k ) { this . code = code ; this . jt = jt ; this . jf = jf ; this . k = k ; } } public static final class SockFProg extends Structure implements Structure . ByReference { public short len ; public Pointer filter ; public SockFProg ( SockFilter filters [ ] ) { len = ( short ) filters . length ; Memory filter = new Memory ( len * <int> ) ; ByteBuffer bbuf = filter . getByteBuffer ( <int> , len * <int> ) ; bbuf . order ( ByteOrder . nativeOrder ( ) ) ; for ( SockFilter f : filters ) { bbuf . putShort ( f . code ) ; bbuf . put ( f . jt ) ; bbuf . put ( f . jf ) ; bbuf . putInt ( f . k ) ; } this . filter = filter ; } @Override protected List < String > getFieldOrder ( ) { return Arrays . asList ( new String [ ] { <str> , <str> } ) ; } } static final int BPF_LD = <hex> ; static final int BPF_W = <hex> ; static final int BPF_ABS = <hex> ; static final int BPF_JMP = <hex> ; static final int BPF_JEQ = <hex> ; static final int BPF_JGE = <hex> ; static final int BPF_JGT = <hex> ; static final int BPF_RET = <hex> ; static final int BPF_K = <hex> ; static SockFilter BPF_STMT ( int code , int k ) { return new SockFilter ( ( short ) code , ( byte ) <int> , ( byte ) <int> , k ) ; } static SockFilter BPF_JUMP ( int code , int k , int jt , int jf ) { return new SockFilter ( ( short ) code , ( byte ) jt , ( byte ) jf , k ) ; } static final int SECCOMP_RET_ERRNO = <hex> ; static final int SECCOMP_RET_DATA = <hex> ; static final int SECCOMP_RET_ALLOW = <hex> ; static final int EACCES = <hex> ; static final int EFAULT = <hex> ; static final int EINVAL = <hex> ; static final int ENOSYS = <hex> ; static final int SECCOMP_DATA_NR_OFFSET = <hex> ; static final int SECCOMP_DATA_ARCH_OFFSET = <hex> ; static class Arch { final int audit ; final int limit ; final int fork ; final int vfork ; final int execve ; final int execveat ; final int seccomp ; Arch ( int audit , int limit , int fork , int vfork , int execve , int execveat , int seccomp ) { this . audit = audit ; this . limit = limit ; this . fork = fork ; this . vfork = vfork ; this . execve = execve ; this . execveat = execveat ; this . seccomp = seccomp ; } } private static final Map < String , Arch > ARCHITECTURES ; static { Map < String , Arch > m = new HashMap < > ( ) ; m . put ( <str> , new Arch ( <hex> , <hex> , <int> , <int> , <int> , <int> , <int> ) ) ; m . put ( <str> , new Arch ( <hex> , <hex> , <int> , <int> , <int> , <int> , <int> ) ) ; ARCHITECTURES = Collections . unmodifiableMap ( m ) ; } private static int linux_prctl ( int option , long arg2 , long arg3 , long arg4 , long arg5 ) { return linux_libc . prctl ( option , new NativeLong ( arg2 ) , new NativeLong ( arg3 ) , new NativeLong ( arg4 ) , new NativeLong ( arg5 ) ) ; } private static long linux_syscall ( long number , Object . . . args ) { return linux_libc . syscall ( new NativeLong ( number ) , args ) . longValue ( ) ; } private static int linuxImpl ( ) { final Arch arch = ARCHITECTURES . get ( Constants . OS_ARCH ) ; boolean supported = Constants . LINUX & & arch ! = null ; if ( supported = = false ) { throw new UnsupportedOperationException ( <str> + Constants . OS_ARCH + <str> ) ; } if ( linux_libc = = null ) { throw new UnsupportedOperationException ( <str> ) ; } if ( linux_syscall ( <int> ) > = <int> | | Native . getLastError ( ) ! = ENOSYS ) { throw new UnsupportedOperationException ( <str> ) ; } final int bogusArg = <hex> ; long ret = linux_syscall ( arch . seccomp , bogusArg ) ; if ( ret ! = - <int> ) { throw new UnsupportedOperationException ( <str> + ret ) ; } else { int errno = Native . getLastError ( ) ; switch ( errno ) { case ENOSYS : break ; case EINVAL : break ; default : throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( errno ) ) ; } } ret = linux_syscall ( arch . seccomp , SECCOMP_SET_MODE_FILTER , bogusArg ) ; if ( ret ! = - <int> ) { throw new UnsupportedOperationException ( <str> + ret ) ; } else { int errno = Native . getLastError ( ) ; switch ( errno ) { case ENOSYS : break ; case EINVAL : break ; default : throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( errno ) ) ; } } ret = linux_prctl ( bogusArg , <int> , <int> , <int> , <int> ) ; if ( ret ! = - <int> ) { throw new UnsupportedOperationException ( <str> + ret ) ; } else { int errno = Native . getLastError ( ) ; switch ( errno ) { case ENOSYS : break ; case EINVAL : break ; default : throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( errno ) ) ; } } switch ( linux_prctl ( PR_GET_NO_NEW_PRIVS , <int> , <int> , <int> , <int> ) ) { case <int> : break ; case <int> : break ; default : int errno = Native . getLastError ( ) ; if ( errno = = EINVAL ) { throw new UnsupportedOperationException ( <str> ) ; } else { throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( errno ) ) ; } } switch ( linux_prctl ( PR_GET_SECCOMP , <int> , <int> , <int> , <int> ) ) { case <int> : break ; case <int> : break ; default : int errno = Native . getLastError ( ) ; if ( errno = = EINVAL ) { throw new UnsupportedOperationException ( <str> ) ; } else { throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( errno ) ) ; } } if ( linux_prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , <int> , <int> , <int> ) ! = <int> ) { int errno = Native . getLastError ( ) ; switch ( errno ) { case EFAULT : break ; case EINVAL : throw new UnsupportedOperationException ( <str> ) ; default : throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( errno ) ) ; } } if ( linux_prctl ( PR_SET_NO_NEW_PRIVS , <int> , <int> , <int> , <int> ) ! = <int> ) { throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( Native . getLastError ( ) ) ) ; } if ( linux_prctl ( PR_GET_NO_NEW_PRIVS , <int> , <int> , <int> , <int> ) ! = <int> ) { throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( Native . getLastError ( ) ) ) ; } SockFilter insns [ ] = { BPF_STMT ( BPF_LD + BPF_W + BPF_ABS , SECCOMP_DATA_ARCH_OFFSET ) , BPF_JUMP ( BPF_JMP + BPF_JEQ + BPF_K , arch . audit , <int> , <int> ) , BPF_STMT ( BPF_LD + BPF_W + BPF_ABS , SECCOMP_DATA_NR_OFFSET ) , BPF_JUMP ( BPF_JMP + BPF_JGT + BPF_K , arch . limit , <int> , <int> ) , BPF_JUMP ( BPF_JMP + BPF_JEQ + BPF_K , arch . fork , <int> , <int> ) , BPF_JUMP ( BPF_JMP + BPF_JEQ + BPF_K , arch . vfork , <int> , <int> ) , BPF_JUMP ( BPF_JMP + BPF_JEQ + BPF_K , arch . execve , <int> , <int> ) , BPF_JUMP ( BPF_JMP + BPF_JEQ + BPF_K , arch . execveat , <int> , <int> ) , BPF_STMT ( BPF_RET + BPF_K , SECCOMP_RET_ALLOW ) , BPF_STMT ( BPF_RET + BPF_K , SECCOMP_RET_ERRNO | ( EACCES & SECCOMP_RET_DATA ) ) , } ; SockFProg prog = new SockFProg ( insns ) ; prog . write ( ) ; long pointer = Pointer . nativeValue ( prog . getPointer ( ) ) ; int method = <int> ; if ( linux_syscall ( arch . seccomp , SECCOMP_SET_MODE_FILTER , SECCOMP_FILTER_FLAG_TSYNC , new NativeLong ( pointer ) ) ! = <int> ) { method = <int> ; int errno1 = Native . getLastError ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> + JNACLibrary . strerror ( errno1 ) + <str> ) ; } if ( linux_prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , pointer , <int> , <int> ) ! = <int> ) { int errno2 = Native . getLastError ( ) ; throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( errno1 ) + <str> + JNACLibrary . strerror ( errno2 ) ) ; } } if ( linux_prctl ( PR_GET_SECCOMP , <int> , <int> , <int> , <int> ) ! = <int> ) { throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( Native . getLastError ( ) ) ) ; } logger . debug ( <str> , method = = <int> ? <str> : <str> ) ; return method ; } static interface MacLibrary extends Library { int sandbox_init ( String profile , long flags , PointerByReference errorbuf ) ; void sandbox_free_error ( Pointer errorbuf ) ; } private static final MacLibrary libc_mac ; static { MacLibrary lib = null ; if ( Constants . MAC_OS_X ) { try { lib = ( MacLibrary ) Native . loadLibrary ( <str> , MacLibrary . class ) ; } catch ( UnsatisfiedLinkError e ) { logger . warn ( <str> , e ) ; } } libc_mac = lib ; } static final int SANDBOX_NAMED = <int> ; static final String SANDBOX_RULES = <str> ; private static void macImpl ( Path tmpFile ) throws IOException { boolean supported = Constants . MAC_OS_X ; if ( supported = = false ) { throw new IllegalStateException ( <str> ) ; } if ( libc_mac = = null ) { throw new UnsupportedOperationException ( <str> ) ; } Path rules = Files . createTempFile ( tmpFile , <str> , <str> ) ; Files . write ( rules , Collections . singleton ( SANDBOX_RULES ) ) ; boolean success = false ; try { PointerByReference errorRef = new PointerByReference ( ) ; int ret = libc_mac . sandbox_init ( rules . toAbsolutePath ( ) . toString ( ) , SANDBOX_NAMED , errorRef ) ; if ( ret ! = <int> ) { Pointer errorBuf = errorRef . getValue ( ) ; RuntimeException e = new UnsupportedOperationException ( <str> + errorBuf . getString ( <int> ) ) ; libc_mac . sandbox_free_error ( errorBuf ) ; throw e ; } logger . debug ( <str> ) ; success = true ; } finally { if ( success ) { Files . delete ( rules ) ; } else { IOUtils . deleteFilesIgnoringExceptions ( rules ) ; } } } static interface SolarisLibrary extends Library { int priv_set ( int op , String which , String . . . privs ) ; } private static final SolarisLibrary libc_solaris ; static { SolarisLibrary lib = null ; if ( Constants . SUN_OS ) { try { lib = ( SolarisLibrary ) Native . loadLibrary ( <str> , SolarisLibrary . class ) ; } catch ( UnsatisfiedLinkError e ) { logger . warn ( <str> , e ) ; } } libc_solaris = lib ; } static final int PRIV_OFF = <int> ; static final String PRIV_ALLSETS = null ; static final String PRIV_PROC_FORK = <str> ; static final String PRIV_PROC_EXEC = <str> ; static void solarisImpl ( ) { boolean supported = Constants . SUN_OS ; if ( supported = = false ) { throw new IllegalStateException ( <str> ) ; } if ( libc_solaris = = null ) { throw new UnsupportedOperationException ( <str> ) ; } if ( libc_solaris . priv_set ( PRIV_OFF , PRIV_ALLSETS , PRIV_PROC_FORK , PRIV_PROC_EXEC , null ) ! = <int> ) { throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( Native . getLastError ( ) ) ) ; } logger . debug ( <str> ) ; } static final boolean OPENBSD = Constants . OS_NAME . startsWith ( <str> ) ; static final int RLIMIT_NPROC = <int> ; static void bsdImpl ( ) { boolean supported = Constants . FREE_BSD | | OPENBSD | | Constants . MAC_OS_X ; if ( supported = = false ) { throw new IllegalStateException ( <str> ) ; } JNACLibrary . Rlimit limit = new JNACLibrary . Rlimit ( ) ; limit . rlim_cur . setValue ( <int> ) ; limit . rlim_max . setValue ( <int> ) ; if ( JNACLibrary . setrlimit ( RLIMIT_NPROC , limit ) ! = <int> ) { throw new UnsupportedOperationException ( <str> + JNACLibrary . strerror ( Native . getLastError ( ) ) ) ; } logger . debug ( <str> ) ; } static void windowsImpl ( ) { if ( ! Constants . WINDOWS ) { throw new IllegalStateException ( <str> ) ; } JNAKernel32Library lib = JNAKernel32Library . getInstance ( ) ; Pointer job = lib . CreateJobObjectW ( null , null ) ; if ( job = = null ) { throw new UnsupportedOperationException ( <str> + Native . getLastError ( ) ) ; } try { int clazz = JNAKernel32Library . JOBOBJECT_BASIC_LIMIT_INFORMATION_CLASS ; JNAKernel32Library . JOBOBJECT_BASIC_LIMIT_INFORMATION limits = new JNAKernel32Library . JOBOBJECT_BASIC_LIMIT_INFORMATION ( ) ; limits . write ( ) ; if ( ! lib . QueryInformationJobObject ( job , clazz , limits . getPointer ( ) , limits . size ( ) , null ) ) { throw new UnsupportedOperationException ( <str> + Native . getLastError ( ) ) ; } limits . read ( ) ; limits . ActiveProcessLimit = <int> ; limits . LimitFlags = JNAKernel32Library . JOB_OBJECT_LIMIT_ACTIVE_PROCESS ; limits . write ( ) ; if ( ! lib . SetInformationJobObject ( job , clazz , limits . getPointer ( ) , limits . size ( ) ) ) { throw new UnsupportedOperationException ( <str> + Native . getLastError ( ) ) ; } if ( ! lib . AssignProcessToJobObject ( job , lib . GetCurrentProcess ( ) ) ) { throw new UnsupportedOperationException ( <str> + Native . getLastError ( ) ) ; } } finally { lib . CloseHandle ( job ) ; } logger . debug ( <str> ) ; } static int init ( Path tmpFile ) throws Throwable { if ( Constants . LINUX ) { return linuxImpl ( ) ; } else if ( Constants . MAC_OS_X ) { bsdImpl ( ) ; macImpl ( tmpFile ) ; return <int> ; } else if ( Constants . SUN_OS ) { solarisImpl ( ) ; return <int> ; } else if ( Constants . FREE_BSD | | OPENBSD ) { bsdImpl ( ) ; return <int> ; } else if ( Constants . WINDOWS ) { windowsImpl ( ) ; return <int> ; } else { throw new UnsupportedOperationException ( <str> + Constants . OS_NAME + <str> ) ; } } } 
