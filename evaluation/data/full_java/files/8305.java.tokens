package org . elasticsearch . index . store ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . action . bulk . BulkItemResponse ; import org . elasticsearch . action . bulk . BulkRequestBuilder ; import org . elasticsearch . action . bulk . BulkResponse ; import org . elasticsearch . action . bulk . TransportShardBulkAction ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . discovery . Discovery ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . search . SearchHit ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . transport . MockTransportService ; import org . elasticsearch . transport . ConnectTransportException ; import org . elasticsearch . transport . TransportException ; import org . elasticsearch . transport . TransportRequest ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . Collection ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . termQuery ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertHitCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . Matchers . greaterThan ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . SUITE ) public class ExceptionRetryIT extends ESIntegTestCase { @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return pluginList ( MockTransportService . TestPlugin . class ) ; } @Override protected void beforeIndexDeletion ( ) { } public void testRetryDueToExceptionOnNetworkLayer ( ) throws ExecutionException , InterruptedException , IOException { final AtomicBoolean exceptionThrown = new AtomicBoolean ( false ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; NodesStatsResponse nodeStats = client ( ) . admin ( ) . cluster ( ) . prepareNodesStats ( ) . get ( ) ; NodeStats unluckyNode = randomFrom ( nodeStats . getNodes ( ) ) ; assertAcked ( client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) ) ; ensureGreen ( <str> ) ; for ( NodeStats dataNode : nodeStats . getNodes ( ) ) { MockTransportService mockTransportService = ( ( MockTransportService ) internalCluster ( ) . getInstance ( TransportService . class , dataNode . getNode ( ) . name ( ) ) ) ; mockTransportService . addDelegate ( internalCluster ( ) . getInstance ( TransportService . class , unluckyNode . getNode ( ) . name ( ) ) , new MockTransportService . DelegateTransport ( mockTransportService . original ( ) ) { @Override public void sendRequest ( DiscoveryNode node , long requestId , String action , TransportRequest request , TransportRequestOptions options ) throws IOException , TransportException { super . sendRequest ( node , requestId , action , request , options ) ; if ( action . equals ( TransportShardBulkAction . ACTION_NAME ) & & ! exceptionThrown . get ( ) ) { logger . debug ( <str> ) ; exceptionThrown . set ( true ) ; throw new ConnectTransportException ( node , action ) ; } } } ) ; } BulkRequestBuilder bulkBuilder = client ( ) . prepareBulk ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { XContentBuilder doc = null ; doc = jsonBuilder ( ) . startObject ( ) . field ( <str> , <str> ) . endObject ( ) ; bulkBuilder . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( doc ) ) ; } BulkResponse response = bulkBuilder . get ( ) ; if ( response . hasFailures ( ) ) { for ( BulkItemResponse singleIndexRespons : response . getItems ( ) ) { if ( singleIndexRespons . isFailed ( ) ) { fail ( <str> + singleIndexRespons . getFailureMessage ( ) ) ; } } } refresh ( ) ; SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setSize ( numDocs * <int> ) . addField ( <str> ) . get ( ) ; Set < String > uniqueIds = new HashSet ( ) ; long dupCounter = <int> ; boolean found_duplicate_already = false ; for ( int i = <int> ; i < searchResponse . getHits ( ) . getHits ( ) . length ; i + + ) { if ( ! uniqueIds . add ( searchResponse . getHits ( ) . getHits ( ) [ i ] . getId ( ) ) ) { if ( ! found_duplicate_already ) { SearchResponse dupIdResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( termQuery ( <str> , searchResponse . getHits ( ) . getHits ( ) [ i ] . getId ( ) ) ) . setExplain ( true ) . get ( ) ; assertThat ( dupIdResponse . getHits ( ) . totalHits ( ) , greaterThan ( <int> ) ) ; logger . info ( <str> ) ; for ( SearchHit hit : dupIdResponse . getHits ( ) ) { logger . info ( <str> , hit . getId ( ) , hit . getShard ( ) . getShardId ( ) ) ; } logger . info ( <str> ) ; found_duplicate_already = true ; } dupCounter + + ; } } assertSearchResponse ( searchResponse ) ; assertThat ( dupCounter , equalTo ( <int> l ) ) ; assertHitCount ( searchResponse , numDocs ) ; } } 
