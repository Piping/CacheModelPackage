package org . elasticsearch . common . text ; import org . elasticsearch . common . bytes . BytesReference ; import java . util . Comparator ; public class UTF8SortedAsUnicodeComparator implements Comparator < BytesReference > { public final static Comparator < BytesReference > utf8SortedAsUnicodeSortOrder = new UTF8SortedAsUnicodeComparator ( ) ; private UTF8SortedAsUnicodeComparator ( ) { } @Override public int compare ( BytesReference a , BytesReference b ) { if ( a . hasArray ( ) & & b . hasArray ( ) ) { final byte [ ] aBytes = a . array ( ) ; int aUpto = a . arrayOffset ( ) ; final byte [ ] bBytes = b . array ( ) ; int bUpto = b . arrayOffset ( ) ; final int aStop = aUpto + Math . min ( a . length ( ) , b . length ( ) ) ; while ( aUpto < aStop ) { int aByte = aBytes [ aUpto + + ] & <hex> ; int bByte = bBytes [ bUpto + + ] & <hex> ; int diff = aByte - bByte ; if ( diff ! = <int> ) { return diff ; } } return a . length ( ) - b . length ( ) ; } else { final byte [ ] aBytes = a . toBytes ( ) ; int aUpto = <int> ; final byte [ ] bBytes = b . toBytes ( ) ; int bUpto = <int> ; final int aStop = aUpto + Math . min ( a . length ( ) , b . length ( ) ) ; while ( aUpto < aStop ) { int aByte = aBytes [ aUpto + + ] & <hex> ; int bByte = bBytes [ bUpto + + ] & <hex> ; int diff = aByte - bByte ; if ( diff ! = <int> ) { return diff ; } } return a . length ( ) - b . length ( ) ; } } } 
