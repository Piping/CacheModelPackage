package org . elasticsearch . repositories ; import org . elasticsearch . action . ActionListener ; import org . elasticsearch . cluster . AckedClusterStateUpdateTask ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . ClusterStateListener ; import org . elasticsearch . cluster . ack . ClusterStateUpdateRequest ; import org . elasticsearch . cluster . ack . ClusterStateUpdateResponse ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . RepositoriesMetaData ; import org . elasticsearch . cluster . metadata . RepositoryMetaData ; import org . elasticsearch . cluster . node . DiscoveryNode ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . inject . Injector ; import org . elasticsearch . common . inject . ModulesBuilder ; import org . elasticsearch . common . regex . Regex ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . snapshots . IndexShardRepository ; import org . elasticsearch . snapshots . RestoreService ; import org . elasticsearch . snapshots . SnapshotsService ; import org . elasticsearch . transport . TransportService ; import java . io . IOException ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . stream . Collectors ; import static java . util . Collections . emptyMap ; import static java . util . Collections . unmodifiableMap ; import static org . elasticsearch . common . settings . Settings . Builder . EMPTY_SETTINGS ; public class RepositoriesService extends AbstractComponent implements ClusterStateListener { private final RepositoryTypesRegistry typesRegistry ; private final Injector injector ; private final ClusterService clusterService ; private final VerifyNodeRepositoryAction verifyAction ; private volatile Map < String , RepositoryHolder > repositories = emptyMap ( ) ; @Inject public RepositoriesService ( Settings settings , ClusterService clusterService , TransportService transportService , RepositoryTypesRegistry typesRegistry , Injector injector ) { super ( settings ) ; this . typesRegistry = typesRegistry ; this . injector = injector ; this . clusterService = clusterService ; if ( DiscoveryNode . dataNode ( settings ) | | DiscoveryNode . masterNode ( settings ) ) { clusterService . add ( this ) ; } this . verifyAction = new VerifyNodeRepositoryAction ( settings , transportService , clusterService , this ) ; } public void registerRepository ( final RegisterRepositoryRequest request , final ActionListener < ClusterStateUpdateResponse > listener ) { final RepositoryMetaData newRepositoryMetaData = new RepositoryMetaData ( request . name , request . type , request . settings ) ; final ActionListener < ClusterStateUpdateResponse > registrationListener ; if ( request . verify ) { registrationListener = new VerifyingRegisterRepositoryListener ( request . name , listener ) ; } else { registrationListener = listener ; } clusterService . submitStateUpdateTask ( request . cause , new AckedClusterStateUpdateTask < ClusterStateUpdateResponse > ( request , registrationListener ) { @Override protected ClusterStateUpdateResponse newResponse ( boolean acknowledged ) { return new ClusterStateUpdateResponse ( acknowledged ) ; } @Override public ClusterState execute ( ClusterState currentState ) throws IOException { ensureRepositoryNotInUse ( currentState , request . name ) ; if ( ! registerRepository ( newRepositoryMetaData ) ) { return currentState ; } MetaData metaData = currentState . metaData ( ) ; MetaData . Builder mdBuilder = MetaData . builder ( currentState . metaData ( ) ) ; RepositoriesMetaData repositories = metaData . custom ( RepositoriesMetaData . TYPE ) ; if ( repositories = = null ) { logger . info ( <str> , request . name ) ; repositories = new RepositoriesMetaData ( new RepositoryMetaData ( request . name , request . type , request . settings ) ) ; } else { boolean found = false ; List < RepositoryMetaData > repositoriesMetaData = new ArrayList < > ( repositories . repositories ( ) . size ( ) + <int> ) ; for ( RepositoryMetaData repositoryMetaData : repositories . repositories ( ) ) { if ( repositoryMetaData . name ( ) . equals ( newRepositoryMetaData . name ( ) ) ) { found = true ; repositoriesMetaData . add ( newRepositoryMetaData ) ; } else { repositoriesMetaData . add ( repositoryMetaData ) ; } } if ( ! found ) { logger . info ( <str> , request . name ) ; repositoriesMetaData . add ( new RepositoryMetaData ( request . name , request . type , request . settings ) ) ; } else { logger . info ( <str> , request . name ) ; } repositories = new RepositoriesMetaData ( repositoriesMetaData . toArray ( new RepositoryMetaData [ repositoriesMetaData . size ( ) ] ) ) ; } mdBuilder . putCustom ( RepositoriesMetaData . TYPE , repositories ) ; return ClusterState . builder ( currentState ) . metaData ( mdBuilder ) . build ( ) ; } @Override public void onFailure ( String source , Throwable t ) { logger . warn ( <str> , t , request . name ) ; super . onFailure ( source , t ) ; } @Override public boolean mustAck ( DiscoveryNode discoveryNode ) { return discoveryNode . masterNode ( ) ; } } ) ; } public void unregisterRepository ( final UnregisterRepositoryRequest request , final ActionListener < ClusterStateUpdateResponse > listener ) { clusterService . submitStateUpdateTask ( request . cause , new AckedClusterStateUpdateTask < ClusterStateUpdateResponse > ( request , listener ) { @Override protected ClusterStateUpdateResponse newResponse ( boolean acknowledged ) { return new ClusterStateUpdateResponse ( acknowledged ) ; } @Override public ClusterState execute ( ClusterState currentState ) { ensureRepositoryNotInUse ( currentState , request . name ) ; MetaData metaData = currentState . metaData ( ) ; MetaData . Builder mdBuilder = MetaData . builder ( currentState . metaData ( ) ) ; RepositoriesMetaData repositories = metaData . custom ( RepositoriesMetaData . TYPE ) ; if ( repositories ! = null & & repositories . repositories ( ) . size ( ) > <int> ) { List < RepositoryMetaData > repositoriesMetaData = new ArrayList < > ( repositories . repositories ( ) . size ( ) ) ; boolean changed = false ; for ( RepositoryMetaData repositoryMetaData : repositories . repositories ( ) ) { if ( Regex . simpleMatch ( request . name , repositoryMetaData . name ( ) ) ) { logger . info ( <str> , repositoryMetaData . name ( ) ) ; changed = true ; } else { repositoriesMetaData . add ( repositoryMetaData ) ; } } if ( changed ) { repositories = new RepositoriesMetaData ( repositoriesMetaData . toArray ( new RepositoryMetaData [ repositoriesMetaData . size ( ) ] ) ) ; mdBuilder . putCustom ( RepositoriesMetaData . TYPE , repositories ) ; return ClusterState . builder ( currentState ) . metaData ( mdBuilder ) . build ( ) ; } } if ( Regex . isMatchAllPattern ( request . name ) ) { return currentState ; } throw new RepositoryMissingException ( request . name ) ; } @Override public boolean mustAck ( DiscoveryNode discoveryNode ) { return discoveryNode . masterNode ( ) ; } } ) ; } public void verifyRepository ( final String repositoryName , final ActionListener < VerifyResponse > listener ) { final Repository repository = repository ( repositoryName ) ; try { final String verificationToken = repository . startVerification ( ) ; if ( verificationToken ! = null ) { try { verifyAction . verify ( repositoryName , verificationToken , new ActionListener < VerifyResponse > ( ) { @Override public void onResponse ( VerifyResponse verifyResponse ) { try { repository . endVerification ( verificationToken ) ; } catch ( Throwable t ) { logger . warn ( <str> , t , repositoryName ) ; listener . onFailure ( t ) ; return ; } listener . onResponse ( verifyResponse ) ; } @Override public void onFailure ( Throwable e ) { listener . onFailure ( e ) ; } } ) ; } catch ( Throwable t ) { try { repository . endVerification ( verificationToken ) ; } catch ( Throwable t1 ) { logger . warn ( <str> , t1 , repositoryName ) ; } listener . onFailure ( t ) ; } } else { listener . onResponse ( new VerifyResponse ( new DiscoveryNode [ <int> ] , new VerificationFailure [ <int> ] ) ) ; } } catch ( Throwable t ) { listener . onFailure ( t ) ; } } @Override public void clusterChanged ( ClusterChangedEvent event ) { try { RepositoriesMetaData oldMetaData = event . previousState ( ) . getMetaData ( ) . custom ( RepositoriesMetaData . TYPE ) ; RepositoriesMetaData newMetaData = event . state ( ) . getMetaData ( ) . custom ( RepositoriesMetaData . TYPE ) ; if ( ( oldMetaData = = null & & newMetaData = = null ) | | ( oldMetaData ! = null & & oldMetaData . equals ( newMetaData ) ) ) { return ; } logger . trace ( <str> , event . state ( ) . version ( ) ) ; Map < String , RepositoryHolder > survivors = new HashMap < > ( ) ; for ( Map . Entry < String , RepositoryHolder > entry : repositories . entrySet ( ) ) { if ( newMetaData = = null | | newMetaData . repository ( entry . getKey ( ) ) = = null ) { logger . debug ( <str> , entry . getKey ( ) ) ; closeRepository ( entry . getKey ( ) , entry . getValue ( ) ) ; } else { survivors . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } Map < String , RepositoryHolder > builder = new HashMap < > ( ) ; if ( newMetaData ! = null ) { for ( RepositoryMetaData repositoryMetaData : newMetaData . repositories ( ) ) { RepositoryHolder holder = survivors . get ( repositoryMetaData . name ( ) ) ; if ( holder ! = null ) { if ( ! holder . type . equals ( repositoryMetaData . type ( ) ) | | ! holder . settings . equals ( repositoryMetaData . settings ( ) ) ) { logger . debug ( <str> , repositoryMetaData . name ( ) ) ; closeRepository ( repositoryMetaData . name ( ) , holder ) ; holder = null ; try { holder = createRepositoryHolder ( repositoryMetaData ) ; } catch ( RepositoryException ex ) { logger . warn ( <str> , ex , repositoryMetaData . name ( ) ) ; } } } else { try { holder = createRepositoryHolder ( repositoryMetaData ) ; } catch ( RepositoryException ex ) { logger . warn ( <str> , ex , repositoryMetaData . name ( ) ) ; } } if ( holder ! = null ) { logger . debug ( <str> , repositoryMetaData . name ( ) ) ; builder . put ( repositoryMetaData . name ( ) , holder ) ; } } } repositories = unmodifiableMap ( builder ) ; } catch ( Throwable ex ) { logger . warn ( <str> , ex ) ; } } public Repository repository ( String repository ) { RepositoryHolder holder = repositories . get ( repository ) ; if ( holder ! = null ) { return holder . repository ; } throw new RepositoryMissingException ( repository ) ; } public IndexShardRepository indexShardRepository ( String repository ) { RepositoryHolder holder = repositories . get ( repository ) ; if ( holder ! = null ) { return holder . indexShardRepository ; } throw new RepositoryMissingException ( repository ) ; } private boolean registerRepository ( RepositoryMetaData repositoryMetaData ) throws IOException { RepositoryHolder previous = repositories . get ( repositoryMetaData . name ( ) ) ; if ( previous ! = null ) { if ( ! previous . type . equals ( repositoryMetaData . type ( ) ) & & previous . settings . equals ( repositoryMetaData . settings ( ) ) ) { return false ; } } RepositoryHolder holder = createRepositoryHolder ( repositoryMetaData ) ; if ( previous ! = null ) { closeRepository ( repositoryMetaData . name ( ) , previous ) ; } Map < String , RepositoryHolder > newRepositories = new HashMap < > ( repositories ) ; newRepositories . put ( repositoryMetaData . name ( ) , holder ) ; return true ; } private void closeRepository ( String name , RepositoryHolder holder ) throws IOException { logger . debug ( <str> , holder . type , name ) ; if ( holder . repository ! = null ) { holder . repository . close ( ) ; } } private RepositoryHolder createRepositoryHolder ( RepositoryMetaData repositoryMetaData ) { logger . debug ( <str> , repositoryMetaData . type ( ) , repositoryMetaData . name ( ) ) ; Injector repositoryInjector = null ; try { ModulesBuilder modules = new ModulesBuilder ( ) ; RepositoryName name = new RepositoryName ( repositoryMetaData . type ( ) , repositoryMetaData . name ( ) ) ; modules . add ( new RepositoryNameModule ( name ) ) ; modules . add ( new RepositoryModule ( name , repositoryMetaData . settings ( ) , this . settings , typesRegistry ) ) ; repositoryInjector = modules . createChildInjector ( injector ) ; Repository repository = repositoryInjector . getInstance ( Repository . class ) ; IndexShardRepository indexShardRepository = repositoryInjector . getInstance ( IndexShardRepository . class ) ; repository . start ( ) ; return new RepositoryHolder ( repositoryMetaData . type ( ) , repositoryMetaData . settings ( ) , repositoryInjector , repository , indexShardRepository ) ; } catch ( Throwable t ) { logger . warn ( <str> , t , repositoryMetaData . type ( ) , repositoryMetaData . name ( ) ) ; throw new RepositoryException ( repositoryMetaData . name ( ) , <str> , t ) ; } } private void ensureRepositoryNotInUse ( ClusterState clusterState , String repository ) { if ( SnapshotsService . isRepositoryInUse ( clusterState , repository ) | | RestoreService . isRepositoryInUse ( clusterState , repository ) ) { throw new IllegalStateException ( <str> ) ; } } private class VerifyingRegisterRepositoryListener implements ActionListener < ClusterStateUpdateResponse > { private final String name ; private final ActionListener < ClusterStateUpdateResponse > listener ; public VerifyingRegisterRepositoryListener ( String name , final ActionListener < ClusterStateUpdateResponse > listener ) { this . name = name ; this . listener = listener ; } @Override public void onResponse ( final ClusterStateUpdateResponse clusterStateUpdateResponse ) { if ( clusterStateUpdateResponse . isAcknowledged ( ) ) { verifyRepository ( name , new ActionListener < VerifyResponse > ( ) { @Override public void onResponse ( VerifyResponse verifyResponse ) { if ( verifyResponse . failed ( ) ) { listener . onFailure ( new RepositoryVerificationException ( name , verifyResponse . failureDescription ( ) ) ) ; } else { listener . onResponse ( clusterStateUpdateResponse ) ; } } @Override public void onFailure ( Throwable e ) { listener . onFailure ( e ) ; } } ) ; } else { listener . onResponse ( clusterStateUpdateResponse ) ; } } @Override public void onFailure ( Throwable e ) { listener . onFailure ( e ) ; } } private static class RepositoryHolder { private final String type ; private final Settings settings ; private final Repository repository ; private final IndexShardRepository indexShardRepository ; public RepositoryHolder ( String type , Settings settings , Injector injector , Repository repository , IndexShardRepository indexShardRepository ) { this . type = type ; this . settings = settings ; this . repository = repository ; this . indexShardRepository = indexShardRepository ; } } public static class RegisterRepositoryRequest extends ClusterStateUpdateRequest < RegisterRepositoryRequest > { final String cause ; final String name ; final String type ; final boolean verify ; Settings settings = EMPTY_SETTINGS ; public RegisterRepositoryRequest ( String cause , String name , String type , boolean verify ) { this . cause = cause ; this . name = name ; this . type = type ; this . verify = verify ; } public RegisterRepositoryRequest settings ( Settings settings ) { this . settings = settings ; return this ; } } public static class UnregisterRepositoryRequest extends ClusterStateUpdateRequest < UnregisterRepositoryRequest > { final String cause ; final String name ; public UnregisterRepositoryRequest ( String cause , String name ) { this . cause = cause ; this . name = name ; } } public static class VerifyResponse { private VerificationFailure [ ] failures ; private DiscoveryNode [ ] nodes ; public VerifyResponse ( DiscoveryNode [ ] nodes , VerificationFailure [ ] failures ) { this . nodes = nodes ; this . failures = failures ; } public VerificationFailure [ ] failures ( ) { return failures ; } public DiscoveryNode [ ] nodes ( ) { return nodes ; } public boolean failed ( ) { return failures . length > <int> ; } public String failureDescription ( ) { return Arrays . stream ( failures ) . map ( failure - > failure . toString ( ) ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ; } } } 
