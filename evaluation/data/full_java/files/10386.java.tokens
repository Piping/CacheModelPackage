package com . google . common . collect ; import static com . google . common . base . Preconditions . checkNotNull ; import static com . google . common . collect . testing . IteratorFeature . UNMODIFIABLE ; import static com . google . common . truth . Truth . assertThat ; import static java . util . Arrays . asList ; import static java . util . Collections . singletonList ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Function ; import com . google . common . base . Functions ; import com . google . common . collect . testing . IteratorTester ; import com . google . common . collect . testing . ListTestSuiteBuilder ; import com . google . common . collect . testing . TestStringListGenerator ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . ListFeature ; import com . google . common . collect . testing . google . ListGenerators . CharactersOfCharSequenceGenerator ; import com . google . common . collect . testing . google . ListGenerators . CharactersOfStringGenerator ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import org . easymock . EasyMock ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . LinkedList ; import java . util . List ; import java . util . ListIterator ; import java . util . NoSuchElementException ; import java . util . RandomAccess ; import java . util . concurrent . CopyOnWriteArrayList ; @GwtCompatible ( emulated = true ) public class ListsTest extends TestCase { private static final Collection < Integer > SOME_COLLECTION = asList ( <int> , <int> , <int> ) ; private static final Iterable < Integer > SOME_ITERABLE = new SomeIterable ( ) ; private static final class RemoveFirstFunction implements Function < String , String > , Serializable { @Override public String apply ( String from ) { return ( from . length ( ) = = <int> ) ? from : from . substring ( <int> ) ; } } private static class SomeIterable implements Iterable < Integer > , Serializable { @Override public Iterator < Integer > iterator ( ) { return SOME_COLLECTION . iterator ( ) ; } private static final long serialVersionUID = <int> ; } private static final List < Integer > SOME_LIST = Lists . newArrayList ( <int> , <int> , <int> , <int> ) ; private static final List < Integer > SOME_SEQUENTIAL_LIST = Lists . newLinkedList ( asList ( <int> , <int> , <int> , <int> ) ) ; private static final List < String > SOME_STRING_LIST = asList ( <str> , <str> , <str> , <str> ) ; private static final Function < Number , String > SOME_FUNCTION = new SomeFunction ( ) ; private static class SomeFunction implements Function < Number , String > , Serializable { @Override public String apply ( Number n ) { return String . valueOf ( n ) ; } private static final long serialVersionUID = <int> ; } @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ListsTest . class ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { String [ ] rest = new String [ elements . length - <int> ] ; System . arraycopy ( elements , <int> , rest , <int> , elements . length - <int> ) ; return Lists . asList ( elements [ <int> ] , rest ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . SEVERAL , CollectionSize . ONE , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_VALUES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { String [ ] rest = new String [ elements . length - <int> ] ; System . arraycopy ( elements , <int> , rest , <int> , elements . length - <int> ) ; return Lists . asList ( elements [ <int> ] , elements [ <int> ] , rest ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . SEVERAL , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_VALUES ) . createTestSuite ( ) ) ; final Function < String , String > removeFirst = new RemoveFirstFunction ( ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { List < String > fromList = Lists . newArrayList ( ) ; for ( String element : elements ) { fromList . add ( <str> + checkNotNull ( element ) ) ; } return Lists . transform ( fromList , removeFirst ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , ListFeature . REMOVE_OPERATIONS , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { List < String > fromList = Lists . newLinkedList ( ) ; for ( String element : elements ) { fromList . add ( <str> + checkNotNull ( element ) ) ; } return Lists . transform ( fromList , removeFirst ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , ListFeature . REMOVE_OPERATIONS , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { List < String > fromList = Lists . newArrayList ( elements ) ; return Lists . transform ( fromList , Functions . < String > identity ( ) ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , ListFeature . REMOVE_OPERATIONS , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_VALUES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { List < String > fromList = Lists . newLinkedList ( asList ( elements ) ) ; return Lists . transform ( fromList , Functions . < String > identity ( ) ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , ListFeature . REMOVE_OPERATIONS , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_VALUES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { List < String > list = Lists . newArrayList ( ) ; for ( int i = elements . length - <int> ; i > = <int> ; i - - ) list . add ( elements [ i ] ) ; return Lists . reverse ( list ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES , ListFeature . GENERAL_PURPOSE ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { String [ ] reverseElements = new String [ elements . length ] ; for ( int i = elements . length - <int> , j = <int> ; i > = <int> ; i - - , j + + ) reverseElements [ j ] = elements [ i ] ; return Lists . reverse ( asList ( reverseElements ) ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES , ListFeature . SUPPORTS_SET ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { List < String > list = Lists . newLinkedList ( ) ; for ( int i = elements . length - <int> ; i > = <int> ; i - - ) list . add ( elements [ i ] ) ; return Lists . reverse ( list ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_VALUES , ListFeature . GENERAL_PURPOSE ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new TestStringListGenerator ( ) { @Override protected List < String > create ( String [ ] elements ) { ImmutableList . Builder < String > builder = ImmutableList . builder ( ) ; for ( int i = elements . length - <int> ; i > = <int> ; i - - ) builder . add ( elements [ i ] ) ; return Lists . reverse ( builder . build ( ) ) ; } } ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new CharactersOfStringGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new CharactersOfCharSequenceGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; return suite ; } public void testCharactersOfIsView ( ) { StringBuilder builder = new StringBuilder ( <str> ) ; List < Character > chars = Lists . charactersOf ( builder ) ; assertEquals ( asList ( <str> , <str> , <str> ) , chars ) ; builder . append ( <str> ) ; assertEquals ( asList ( <str> , <str> , <str> , <str> , <str> , <str> ) , chars ) ; builder . deleteCharAt ( <int> ) ; assertEquals ( asList ( <str> , <str> , <str> , <str> , <str> ) , chars ) ; } public void testNewArrayListEmpty ( ) { ArrayList < Integer > list = Lists . newArrayList ( ) ; assertEquals ( Collections . emptyList ( ) , list ) ; } public void testNewArrayListWithCapacity ( ) { ArrayList < Integer > list = Lists . newArrayListWithCapacity ( <int> ) ; assertEquals ( Collections . emptyList ( ) , list ) ; ArrayList < Integer > bigger = Lists . newArrayListWithCapacity ( <int> ) ; assertEquals ( Collections . emptyList ( ) , bigger ) ; } public void testNewArrayListWithCapacity_negative ( ) { try { Lists . newArrayListWithCapacity ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testNewArrayListWithExpectedSize ( ) { ArrayList < Integer > list = Lists . newArrayListWithExpectedSize ( <int> ) ; assertEquals ( Collections . emptyList ( ) , list ) ; ArrayList < Integer > bigger = Lists . newArrayListWithExpectedSize ( <int> ) ; assertEquals ( Collections . emptyList ( ) , bigger ) ; } public void testNewArrayListWithExpectedSize_negative ( ) { try { Lists . newArrayListWithExpectedSize ( - <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testNewArrayListVarArgs ( ) { ArrayList < Integer > list = Lists . newArrayList ( <int> , <int> , <int> ) ; assertEquals ( SOME_COLLECTION , list ) ; } public void testComputeArrayListCapacity ( ) { assertEquals ( <int> , Lists . computeArrayListCapacity ( <int> ) ) ; assertEquals ( <int> , Lists . computeArrayListCapacity ( <int> ) ) ; assertEquals ( <int> , Lists . computeArrayListCapacity ( <int> ) ) ; assertEquals ( <int> , Lists . computeArrayListCapacity ( <int> ) ) ; assertEquals ( Integer . MAX_VALUE , Lists . computeArrayListCapacity ( Integer . MAX_VALUE - <int> ) ) ; } public void testNewArrayListFromCollection ( ) { ArrayList < Integer > list = Lists . newArrayList ( SOME_COLLECTION ) ; assertEquals ( SOME_COLLECTION , list ) ; } public void testNewArrayListFromIterable ( ) { ArrayList < Integer > list = Lists . newArrayList ( SOME_ITERABLE ) ; assertEquals ( SOME_COLLECTION , list ) ; } public void testNewArrayListFromIterator ( ) { ArrayList < Integer > list = Lists . newArrayList ( SOME_COLLECTION . iterator ( ) ) ; assertEquals ( SOME_COLLECTION , list ) ; } public void testNewLinkedListEmpty ( ) { LinkedList < Integer > list = Lists . newLinkedList ( ) ; assertEquals ( Collections . emptyList ( ) , list ) ; } public void testNewLinkedListFromCollection ( ) { LinkedList < Integer > list = Lists . newLinkedList ( SOME_COLLECTION ) ; assertEquals ( SOME_COLLECTION , list ) ; } public void testNewLinkedListFromIterable ( ) { LinkedList < Integer > list = Lists . newLinkedList ( SOME_ITERABLE ) ; assertEquals ( SOME_COLLECTION , list ) ; } @GwtIncompatible ( <str> ) public void testNewCOWALEmpty ( ) { CopyOnWriteArrayList < Integer > list = Lists . newCopyOnWriteArrayList ( ) ; assertEquals ( Collections . emptyList ( ) , list ) ; } @GwtIncompatible ( <str> ) public void testNewCOWALFromIterable ( ) { CopyOnWriteArrayList < Integer > list = Lists . newCopyOnWriteArrayList ( SOME_ITERABLE ) ; assertEquals ( SOME_COLLECTION , list ) ; } @GwtIncompatible ( <str> ) public void testNullPointerExceptions ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( Lists . class ) ; } public void testArraysAsList ( ) { List < String > ourWay = Lists . newArrayList ( <str> , <str> , <str> ) ; List < String > otherWay = asList ( <str> , <str> , <str> ) ; assertEquals ( ourWay , otherWay ) ; otherWay . set ( <int> , <str> ) ; assertEquals ( <str> , otherWay . get ( <int> ) ) ; try { otherWay . add ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } try { otherWay . remove ( <int> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } } @GwtIncompatible ( <str> ) public void testAsList1 ( ) { List < String > list = Lists . asList ( <str> , new String [ ] { <str> , <str> } ) ; checkFooBarBazList ( list ) ; SerializableTester . reserializeAndAssert ( list ) ; assertTrue ( list instanceof RandomAccess ) ; new IteratorTester < String > ( <int> , UNMODIFIABLE , asList ( <str> , <str> , <str> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < String > newTargetIterator ( ) { return Lists . asList ( <str> , new String [ ] { <str> , <str> } ) . iterator ( ) ; } } . test ( ) ; } private void checkFooBarBazList ( List < String > list ) { assertThat ( list ) . containsExactly ( <str> , <str> , <str> ) . inOrder ( ) ; assertEquals ( <int> , list . size ( ) ) ; assertIndexIsOutOfBounds ( list , - <int> ) ; assertEquals ( <str> , list . get ( <int> ) ) ; assertEquals ( <str> , list . get ( <int> ) ) ; assertEquals ( <str> , list . get ( <int> ) ) ; assertIndexIsOutOfBounds ( list , <int> ) ; } public void testAsList1Small ( ) { List < String > list = Lists . asList ( <str> , new String [ <int> ] ) ; assertThat ( list ) . contains ( <str> ) ; assertEquals ( <int> , list . size ( ) ) ; assertIndexIsOutOfBounds ( list , - <int> ) ; assertEquals ( <str> , list . get ( <int> ) ) ; assertIndexIsOutOfBounds ( list , <int> ) ; assertTrue ( list instanceof RandomAccess ) ; new IteratorTester < String > ( <int> , UNMODIFIABLE , singletonList ( <str> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < String > newTargetIterator ( ) { return Lists . asList ( <str> , new String [ <int> ] ) . iterator ( ) ; } } . test ( ) ; } public void testAsList2 ( ) { List < String > list = Lists . asList ( <str> , <str> , new String [ ] { <str> } ) ; checkFooBarBazList ( list ) ; assertTrue ( list instanceof RandomAccess ) ; new IteratorTester < String > ( <int> , UNMODIFIABLE , asList ( <str> , <str> , <str> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < String > newTargetIterator ( ) { return Lists . asList ( <str> , <str> , new String [ ] { <str> } ) . iterator ( ) ; } } . test ( ) ; } @GwtIncompatible ( <str> ) public void testAsList2Small ( ) { List < String > list = Lists . asList ( <str> , <str> , new String [ <int> ] ) ; assertThat ( list ) . containsExactly ( <str> , <str> ) . inOrder ( ) ; assertEquals ( <int> , list . size ( ) ) ; assertIndexIsOutOfBounds ( list , - <int> ) ; assertEquals ( <str> , list . get ( <int> ) ) ; assertEquals ( <str> , list . get ( <int> ) ) ; assertIndexIsOutOfBounds ( list , <int> ) ; SerializableTester . reserializeAndAssert ( list ) ; assertTrue ( list instanceof RandomAccess ) ; new IteratorTester < String > ( <int> , UNMODIFIABLE , asList ( <str> , <str> ) , IteratorTester . KnownOrder . KNOWN_ORDER ) { @Override protected Iterator < String > newTargetIterator ( ) { return Lists . asList ( <str> , <str> , new String [ <int> ] ) . iterator ( ) ; } } . test ( ) ; } private static void assertIndexIsOutOfBounds ( List < String > list , int index ) { try { list . get ( index ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } public void testReverseViewRandomAccess ( ) { List < Integer > fromList = Lists . newArrayList ( SOME_LIST ) ; List < Integer > toList = Lists . reverse ( fromList ) ; assertReverseView ( fromList , toList ) ; } public void testReverseViewSequential ( ) { List < Integer > fromList = Lists . newLinkedList ( SOME_SEQUENTIAL_LIST ) ; List < Integer > toList = Lists . reverse ( fromList ) ; assertReverseView ( fromList , toList ) ; } private static void assertReverseView ( List < Integer > fromList , List < Integer > toList ) { fromList . set ( <int> , <int> ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> ) , toList ) ; fromList . add ( <int> ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> , <int> ) , toList ) ; fromList . add ( <int> , <int> ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> , <int> , <int> ) , toList ) ; fromList . remove ( Integer . valueOf ( <int> ) ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> , <int> ) , toList ) ; fromList . remove ( <int> ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> ) , toList ) ; toList . remove ( <int> ) ; assertEquals ( asList ( <int> , <int> , <int> ) , fromList ) ; toList . add ( <int> ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> ) , fromList ) ; toList . add ( <int> ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> , <int> ) , fromList ) ; toList . remove ( Integer . valueOf ( <int> ) ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> ) , fromList ) ; toList . set ( <int> , <int> ) ; assertEquals ( asList ( <int> , <int> , <int> , <int> ) , fromList ) ; toList . clear ( ) ; assertEquals ( Collections . emptyList ( ) , fromList ) ; } private static < E > List < E > list ( E . . . elements ) { return ImmutableList . copyOf ( elements ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary1x1 ( ) { assertThat ( Lists . cartesianProduct ( list ( <int> ) , list ( <int> ) ) ) . contains ( list ( <int> , <int> ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary1x2 ( ) { assertThat ( Lists . cartesianProduct ( list ( <int> ) , list ( <int> , <int> ) ) ) . containsExactly ( list ( <int> , <int> ) , list ( <int> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_binary2x2 ( ) { assertThat ( Lists . cartesianProduct ( list ( <int> , <int> ) , list ( <int> , <int> ) ) ) . containsExactly ( list ( <int> , <int> ) , list ( <int> , <int> ) , list ( <int> , <int> ) , list ( <int> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_2x2x2 ( ) { assertThat ( Lists . cartesianProduct ( list ( <int> , <int> ) , list ( <int> , <int> ) , list ( <int> , <int> ) ) ) . containsExactly ( list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) , list ( <int> , <int> , <int> ) ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_contains ( ) { List < List < Integer > > actual = Lists . cartesianProduct ( list ( <int> , <int> ) , list ( <int> , <int> ) ) ; assertTrue ( actual . contains ( list ( <int> , <int> ) ) ) ; assertTrue ( actual . contains ( list ( <int> , <int> ) ) ) ; assertTrue ( actual . contains ( list ( <int> , <int> ) ) ) ; assertTrue ( actual . contains ( list ( <int> , <int> ) ) ) ; assertFalse ( actual . contains ( list ( <int> , <int> ) ) ) ; } @SuppressWarnings ( <str> ) public void testCartesianProduct_unrelatedTypes ( ) { List < Integer > x = list ( <int> , <int> ) ; List < String > y = list ( <str> , <str> ) ; List < Object > exp1 = list ( ( Object ) <int> , <str> ) ; List < Object > exp2 = list ( ( Object ) <int> , <str> ) ; List < Object > exp3 = list ( ( Object ) <int> , <str> ) ; List < Object > exp4 = list ( ( Object ) <int> , <str> ) ; assertThat ( Lists . < Object > cartesianProduct ( x , y ) ) . containsExactly ( exp1 , exp2 , exp3 , exp4 ) . inOrder ( ) ; } @SuppressWarnings ( <str> ) public void testCartesianProductTooBig ( ) { List < String > list = Collections . nCopies ( <int> , <str> ) ; try { Lists . cartesianProduct ( list , list , list , list , list ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } } public void testTransformHashCodeRandomAccess ( ) { List < String > list = Lists . transform ( SOME_LIST , SOME_FUNCTION ) ; assertEquals ( SOME_STRING_LIST . hashCode ( ) , list . hashCode ( ) ) ; } public void testTransformHashCodeSequential ( ) { List < String > list = Lists . transform ( SOME_SEQUENTIAL_LIST , SOME_FUNCTION ) ; assertEquals ( SOME_STRING_LIST . hashCode ( ) , list . hashCode ( ) ) ; } public void testTransformModifiableRandomAccess ( ) { List < Integer > fromList = Lists . newArrayList ( SOME_LIST ) ; List < String > list = Lists . transform ( fromList , SOME_FUNCTION ) ; assertTransformModifiable ( list ) ; } public void testTransformModifiableSequential ( ) { List < Integer > fromList = Lists . newLinkedList ( SOME_SEQUENTIAL_LIST ) ; List < String > list = Lists . transform ( fromList , SOME_FUNCTION ) ; assertTransformModifiable ( list ) ; } private static void assertTransformModifiable ( List < String > list ) { try { list . add ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } list . remove ( <int> ) ; assertEquals ( asList ( <str> , <str> , <str> ) , list ) ; list . remove ( <str> ) ; assertEquals ( asList ( <str> , <str> ) , list ) ; try { list . set ( <int> , <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } list . clear ( ) ; assertEquals ( Collections . emptyList ( ) , list ) ; } public void testTransformViewRandomAccess ( ) { List < Integer > fromList = Lists . newArrayList ( SOME_LIST ) ; List < String > toList = Lists . transform ( fromList , SOME_FUNCTION ) ; assertTransformView ( fromList , toList ) ; } public void testTransformViewSequential ( ) { List < Integer > fromList = Lists . newLinkedList ( SOME_SEQUENTIAL_LIST ) ; List < String > toList = Lists . transform ( fromList , SOME_FUNCTION ) ; assertTransformView ( fromList , toList ) ; } private static void assertTransformView ( List < Integer > fromList , List < String > toList ) { fromList . set ( <int> , <int> ) ; assertEquals ( asList ( <str> , <str> , <str> , <str> ) , toList ) ; fromList . add ( <int> ) ; assertEquals ( asList ( <str> , <str> , <str> , <str> , <str> ) , toList ) ; fromList . remove ( Integer . valueOf ( <int> ) ) ; assertEquals ( asList ( <str> , <str> , <str> , <str> ) , toList ) ; fromList . remove ( <int> ) ; assertEquals ( asList ( <str> , <str> , <str> ) , toList ) ; toList . remove ( <int> ) ; assertEquals ( asList ( <int> , <int> ) , fromList ) ; toList . remove ( <str> ) ; assertEquals ( asList ( <int> ) , fromList ) ; toList . clear ( ) ; assertEquals ( Collections . emptyList ( ) , fromList ) ; } public void testTransformRandomAccess ( ) { List < String > list = Lists . transform ( SOME_LIST , SOME_FUNCTION ) ; assertTrue ( list instanceof RandomAccess ) ; } public void testTransformSequential ( ) { List < String > list = Lists . transform ( SOME_SEQUENTIAL_LIST , SOME_FUNCTION ) ; assertThat ( list ) . isNotInstanceOf ( RandomAccess . class ) ; } public void testTransformListIteratorRandomAccess ( ) { List < Integer > fromList = Lists . newArrayList ( SOME_LIST ) ; List < String > list = Lists . transform ( fromList , SOME_FUNCTION ) ; assertTransformListIterator ( list ) ; } public void testTransformListIteratorSequential ( ) { List < Integer > fromList = Lists . newLinkedList ( SOME_SEQUENTIAL_LIST ) ; List < String > list = Lists . transform ( fromList , SOME_FUNCTION ) ; assertTransformListIterator ( list ) ; } public void testTransformPreservesIOOBEsThrownByFunction ( ) { try { Lists . transform ( ImmutableList . of ( <str> , <str> ) , new Function < String , String > ( ) { @Override public String apply ( String input ) { throw new IndexOutOfBoundsException ( ) ; } } ) . toArray ( ) ; fail ( ) ; } catch ( IndexOutOfBoundsException expected ) { } } private static void assertTransformListIterator ( List < String > list ) { ListIterator < String > iterator = list . listIterator ( <int> ) ; assertEquals ( <int> , iterator . nextIndex ( ) ) ; assertEquals ( <str> , iterator . next ( ) ) ; assertEquals ( <str> , iterator . next ( ) ) ; assertEquals ( <str> , iterator . next ( ) ) ; assertEquals ( <int> , iterator . nextIndex ( ) ) ; try { iterator . next ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException expected ) { } assertEquals ( <int> , iterator . previousIndex ( ) ) ; assertEquals ( <str> , iterator . previous ( ) ) ; assertEquals ( <str> , iterator . previous ( ) ) ; assertEquals ( <str> , iterator . previous ( ) ) ; assertTrue ( iterator . hasPrevious ( ) ) ; assertEquals ( <str> , iterator . previous ( ) ) ; assertFalse ( iterator . hasPrevious ( ) ) ; assertEquals ( - <int> , iterator . previousIndex ( ) ) ; try { iterator . previous ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException expected ) { } iterator . remove ( ) ; assertEquals ( asList ( <str> , <str> , <str> ) , list ) ; assertFalse ( list . isEmpty ( ) ) ; try { iterator . add ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } catch ( IllegalStateException expected ) { } try { iterator . set ( <str> ) ; fail ( <str> ) ; } catch ( UnsupportedOperationException expected ) { } catch ( IllegalStateException expected ) { } } public void testTransformIteratorRandomAccess ( ) { List < Integer > fromList = Lists . newArrayList ( SOME_LIST ) ; List < String > list = Lists . transform ( fromList , SOME_FUNCTION ) ; assertTransformIterator ( list ) ; } public void testTransformIteratorSequential ( ) { List < Integer > fromList = Lists . newLinkedList ( SOME_SEQUENTIAL_LIST ) ; List < String > list = Lists . transform ( fromList , SOME_FUNCTION ) ; assertTransformIterator ( list ) ; } private interface IntegerList extends List < Integer > { } @GwtIncompatible ( <str> ) public void testTransformedSequentialIterationUsesBackingListIterationOnly ( ) { List < Integer > randomAccessList = Lists . newArrayList ( SOME_SEQUENTIAL_LIST ) ; ListIterator < Integer > sampleListIterator = SOME_SEQUENTIAL_LIST . listIterator ( ) ; List < Integer > listMock = EasyMock . createMock ( IntegerList . class ) ; EasyMock . expect ( listMock . size ( ) ) . andReturn ( SOME_SEQUENTIAL_LIST . size ( ) ) ; EasyMock . expect ( listMock . listIterator ( <int> ) ) . andReturn ( sampleListIterator ) ; EasyMock . replay ( listMock ) ; List < String > transform = Lists . transform ( listMock , SOME_FUNCTION ) ; assertTrue ( Iterables . elementsEqual ( transform , Lists . transform ( randomAccessList , SOME_FUNCTION ) ) ) ; EasyMock . verify ( listMock ) ; } private static void assertTransformIterator ( List < String > list ) { Iterator < String > iterator = list . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( <str> , iterator . next ( ) ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( <str> , iterator . next ( ) ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( <str> , iterator . next ( ) ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( <str> , iterator . next ( ) ) ; assertFalse ( iterator . hasNext ( ) ) ; try { iterator . next ( ) ; fail ( <str> ) ; } catch ( NoSuchElementException expected ) { } iterator . remove ( ) ; assertEquals ( asList ( <str> , <str> , <str> ) , list ) ; assertFalse ( iterator . hasNext ( ) ) ; } public void testPartition_badSize ( ) { List < Integer > source = Collections . singletonList ( <int> ) ; try { Lists . partition ( source , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testPartition_empty ( ) { List < Integer > source = Collections . emptyList ( ) ; List < List < Integer > > partitions = Lists . partition ( source , <int> ) ; assertTrue ( partitions . isEmpty ( ) ) ; assertEquals ( <int> , partitions . size ( ) ) ; } public void testPartition_1_1 ( ) { List < Integer > source = Collections . singletonList ( <int> ) ; List < List < Integer > > partitions = Lists . partition ( source , <int> ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertEquals ( Collections . singletonList ( <int> ) , partitions . get ( <int> ) ) ; } public void testPartition_1_2 ( ) { List < Integer > source = Collections . singletonList ( <int> ) ; List < List < Integer > > partitions = Lists . partition ( source , <int> ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertEquals ( Collections . singletonList ( <int> ) , partitions . get ( <int> ) ) ; } public void testPartition_2_1 ( ) { List < Integer > source = asList ( <int> , <int> ) ; List < List < Integer > > partitions = Lists . partition ( source , <int> ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertEquals ( Collections . singletonList ( <int> ) , partitions . get ( <int> ) ) ; assertEquals ( Collections . singletonList ( <int> ) , partitions . get ( <int> ) ) ; } public void testPartition_3_2 ( ) { List < Integer > source = asList ( <int> , <int> , <int> ) ; List < List < Integer > > partitions = Lists . partition ( source , <int> ) ; assertEquals ( <int> , partitions . size ( ) ) ; assertEquals ( asList ( <int> , <int> ) , partitions . get ( <int> ) ) ; assertEquals ( asList ( <int> ) , partitions . get ( <int> ) ) ; } @GwtIncompatible ( <str> ) public void testPartitionRandomAccessTrue ( ) { List < Integer > source = asList ( <int> , <int> , <int> ) ; List < List < Integer > > partitions = Lists . partition ( source , <int> ) ; assertTrue ( <str> + partitions . getClass ( ) , partitions instanceof RandomAccess ) ; assertTrue ( <str> + partitions . get ( <int> ) . getClass ( ) , partitions . get ( <int> ) instanceof RandomAccess ) ; assertTrue ( <str> + partitions . get ( <int> ) . getClass ( ) , partitions . get ( <int> ) instanceof RandomAccess ) ; } public void testPartitionRandomAccessFalse ( ) { List < Integer > source = Lists . newLinkedList ( asList ( <int> , <int> , <int> ) ) ; List < List < Integer > > partitions = Lists . partition ( source , <int> ) ; assertThat ( partitions ) . isNotInstanceOf ( RandomAccess . class ) ; assertThat ( partitions . get ( <int> ) ) . isNotInstanceOf ( RandomAccess . class ) ; assertThat ( partitions . get ( <int> ) ) . isNotInstanceOf ( RandomAccess . class ) ; } public void testPartition_view ( ) { List < Integer > list = asList ( <int> , <int> , <int> ) ; List < List < Integer > > partitions = Lists . partition ( list , <int> ) ; list . set ( <int> , <int> ) ; Iterator < List < Integer > > iterator = partitions . iterator ( ) ; list . set ( <int> , <int> ) ; List < Integer > first = iterator . next ( ) ; list . set ( <int> , <int> ) ; assertEquals ( asList ( <int> , <int> , <int> ) , first ) ; first . set ( <int> , <int> ) ; assertEquals ( asList ( <int> , <int> , <int> ) , list ) ; } public void testPartitionSize_1 ( ) { List < Integer > list = asList ( <int> , <int> , <int> ) ; assertEquals ( <int> , Lists . partition ( list , Integer . MAX_VALUE ) . size ( ) ) ; assertEquals ( <int> , Lists . partition ( list , Integer . MAX_VALUE - <int> ) . size ( ) ) ; } @GwtIncompatible ( <str> ) public void testPartitionSize_2 ( ) { assertEquals ( <int> , Lists . partition ( Collections . nCopies ( <hex> , <int> ) , <hex> ) . size ( ) ) ; } } 
