package io . netty . util . internal ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . lang . Thread . UncaughtExceptionHandler ; import java . security . SecureRandom ; import java . util . Random ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicLong ; @SuppressWarnings ( <str> ) public final class ThreadLocalRandom extends Random { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ThreadLocalRandom . class ) ; private static final AtomicLong seedUniquifier = new AtomicLong ( ) ; private static volatile long initialSeedUniquifier = SystemPropertyUtil . getLong ( <str> , <int> ) ; private static final Thread seedGeneratorThread ; private static final BlockingQueue < byte [ ] > seedQueue ; private static final long seedGeneratorStartTime ; private static volatile long seedGeneratorEndTime ; static { if ( initialSeedUniquifier = = <int> ) { seedGeneratorThread = new Thread ( <str> ) { @Override public void run ( ) { final SecureRandom random = new SecureRandom ( ) ; final byte [ ] seed = random . generateSeed ( <int> ) ; seedGeneratorEndTime = System . nanoTime ( ) ; seedQueue . add ( seed ) ; } } ; seedGeneratorThread . setDaemon ( true ) ; seedGeneratorThread . setUncaughtExceptionHandler ( new UncaughtExceptionHandler ( ) { @Override public void uncaughtException ( Thread t , Throwable e ) { logger . debug ( <str> , t . getName ( ) , e ) ; } } ) ; seedQueue = new LinkedBlockingQueue < byte [ ] > ( ) ; seedGeneratorStartTime = System . nanoTime ( ) ; seedGeneratorThread . start ( ) ; } else { seedGeneratorThread = null ; seedQueue = null ; seedGeneratorStartTime = <int> L ; } } public static void setInitialSeedUniquifier ( long initialSeedUniquifier ) { ThreadLocalRandom . initialSeedUniquifier = initialSeedUniquifier ; } public static long getInitialSeedUniquifier ( ) { long initialSeedUniquifier = ThreadLocalRandom . initialSeedUniquifier ; if ( initialSeedUniquifier ! = <int> ) { return initialSeedUniquifier ; } synchronized ( ThreadLocalRandom . class ) { initialSeedUniquifier = ThreadLocalRandom . initialSeedUniquifier ; if ( initialSeedUniquifier ! = <int> ) { return initialSeedUniquifier ; } final long timeoutSeconds = <int> ; final long deadLine = seedGeneratorStartTime + TimeUnit . SECONDS . toNanos ( timeoutSeconds ) ; boolean interrupted = false ; for ( ; ; ) { final long waitTime = deadLine - System . nanoTime ( ) ; try { final byte [ ] seed ; if ( waitTime < = <int> ) { seed = seedQueue . poll ( ) ; } else { seed = seedQueue . poll ( waitTime , TimeUnit . NANOSECONDS ) ; } if ( seed ! = null ) { initialSeedUniquifier = ( ( long ) seed [ <int> ] & <hex> ) < < <int> | ( ( long ) seed [ <int> ] & <hex> ) < < <int> | ( ( long ) seed [ <int> ] & <hex> ) < < <int> | ( ( long ) seed [ <int> ] & <hex> ) < < <int> | ( ( long ) seed [ <int> ] & <hex> ) < < <int> | ( ( long ) seed [ <int> ] & <hex> ) < < <int> | ( ( long ) seed [ <int> ] & <hex> ) < < <int> | ( long ) seed [ <int> ] & <hex> ; break ; } } catch ( InterruptedException e ) { interrupted = true ; logger . warn ( <str> ) ; break ; } if ( waitTime < = <int> ) { seedGeneratorThread . interrupt ( ) ; logger . warn ( <str> + <str> , timeoutSeconds ) ; break ; } } initialSeedUniquifier ^ = <hex> ; initialSeedUniquifier ^ = Long . reverse ( System . nanoTime ( ) ) ; ThreadLocalRandom . initialSeedUniquifier = initialSeedUniquifier ; if ( interrupted ) { Thread . currentThread ( ) . interrupt ( ) ; seedGeneratorThread . interrupt ( ) ; } if ( seedGeneratorEndTime = = <int> ) { seedGeneratorEndTime = System . nanoTime ( ) ; } return initialSeedUniquifier ; } } private static long newSeed ( ) { for ( ; ; ) { final long current = seedUniquifier . get ( ) ; final long actualCurrent = current ! = <int> ? current : getInitialSeedUniquifier ( ) ; final long next = actualCurrent * <int> ; if ( seedUniquifier . compareAndSet ( current , next ) ) { if ( current = = <int> & & logger . isDebugEnabled ( ) ) { if ( seedGeneratorEndTime ! = <int> ) { logger . debug ( String . format ( <str> , actualCurrent , TimeUnit . NANOSECONDS . toMillis ( seedGeneratorEndTime - seedGeneratorStartTime ) ) ) ; } else { logger . debug ( String . format ( <str> , actualCurrent ) ) ; } } return next ^ System . nanoTime ( ) ; } } } private static final long multiplier = <hex> ; private static final long addend = <hex> ; private static final long mask = ( <int> < < <int> ) - <int> ; private long rnd ; boolean initialized ; private long pad0 , pad1 , pad2 , pad3 , pad4 , pad5 , pad6 , pad7 ; ThreadLocalRandom ( ) { super ( newSeed ( ) ) ; initialized = true ; } public static ThreadLocalRandom current ( ) { return InternalThreadLocalMap . get ( ) . random ( ) ; } public void setSeed ( long seed ) { if ( initialized ) { throw new UnsupportedOperationException ( ) ; } rnd = ( seed ^ multiplier ) & mask ; } protected int next ( int bits ) { rnd = ( rnd * multiplier + addend ) & mask ; return ( int ) ( rnd > > > ( <int> - bits ) ) ; } public int nextInt ( int least , int bound ) { if ( least > = bound ) { throw new IllegalArgumentException ( ) ; } return nextInt ( bound - least ) + least ; } public long nextLong ( long n ) { if ( n < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } long offset = <int> ; while ( n > = Integer . MAX_VALUE ) { int bits = next ( <int> ) ; long half = n > > > <int> ; long nextn = ( ( bits & <int> ) = = <int> ) ? half : n - half ; if ( ( bits & <int> ) = = <int> ) { offset + = n - nextn ; } n = nextn ; } return offset + nextInt ( ( int ) n ) ; } public long nextLong ( long least , long bound ) { if ( least > = bound ) { throw new IllegalArgumentException ( ) ; } return nextLong ( bound - least ) + least ; } public double nextDouble ( double n ) { if ( n < = <int> ) { throw new IllegalArgumentException ( <str> ) ; } return nextDouble ( ) * n ; } public double nextDouble ( double least , double bound ) { if ( least > = bound ) { throw new IllegalArgumentException ( ) ; } return nextDouble ( ) * ( bound - least ) + least ; } private static final long serialVersionUID = - <int> ; } 
