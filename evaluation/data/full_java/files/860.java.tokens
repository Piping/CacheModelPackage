package org . apache . cassandra . repair ; import java . net . InetAddress ; import java . security . MessageDigest ; import java . util . ArrayList ; import java . util . List ; import java . util . Random ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . concurrent . Stage ; import org . apache . cassandra . concurrent . StageManager ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . DecoratedKey ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . db . rows . UnfilteredRowIterators ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . repair . messages . ValidationComplete ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . MerkleTree ; import org . apache . cassandra . utils . MerkleTree . RowHash ; import org . apache . cassandra . utils . MerkleTrees ; public class Validator implements Runnable { private static final Logger logger = LoggerFactory . getLogger ( Validator . class ) ; public final RepairJobDesc desc ; public final InetAddress initiator ; public final int gcBefore ; private long validated ; private MerkleTrees trees ; private MerkleTree . TreeRange range ; private MerkleTrees . TreeRangeIterator ranges ; private DecoratedKey lastKey ; public Validator ( RepairJobDesc desc , InetAddress initiator , int gcBefore ) { this . desc = desc ; this . initiator = initiator ; this . gcBefore = gcBefore ; validated = <int> ; range = null ; ranges = null ; } public void prepare ( ColumnFamilyStore cfs , MerkleTrees tree ) { this . trees = tree ; if ( ! tree . partitioner ( ) . preservesOrder ( ) ) { tree . init ( ) ; } else { for ( Range < Token > range : tree . ranges ( ) ) { List < DecoratedKey > keys = new ArrayList < > ( ) ; for ( DecoratedKey sample : cfs . keySamples ( range ) ) { assert range . contains ( sample . getToken ( ) ) : <str> + sample . getToken ( ) + <str> + desc . ranges ; keys . add ( sample ) ; } if ( keys . isEmpty ( ) ) { tree . init ( range ) ; } else { int numKeys = keys . size ( ) ; Random random = new Random ( ) ; while ( true ) { DecoratedKey dk = keys . get ( random . nextInt ( numKeys ) ) ; if ( ! tree . split ( dk . getToken ( ) ) ) break ; } } } } logger . debug ( <str> , trees . size ( ) , desc ) ; ranges = tree . invalids ( ) ; } public void add ( UnfilteredRowIterator partition ) { assert Range . isInRanges ( partition . partitionKey ( ) . getToken ( ) , desc . ranges ) : partition . partitionKey ( ) . getToken ( ) + <str> + desc . ranges ; assert lastKey = = null | | lastKey . compareTo ( partition . partitionKey ( ) ) < <int> : <str> + partition . partitionKey ( ) + <str> + lastKey ; lastKey = partition . partitionKey ( ) ; if ( range = = null ) range = ranges . next ( ) ; if ( ! findCorrectRange ( lastKey . getToken ( ) ) ) { ranges = trees . invalids ( ) ; findCorrectRange ( lastKey . getToken ( ) ) ; } assert range . contains ( lastKey . getToken ( ) ) : <str> + lastKey . getToken ( ) ; RowHash rowHash = rowHash ( partition ) ; if ( rowHash ! = null ) { range . addHash ( rowHash ) ; } } public boolean findCorrectRange ( Token t ) { while ( ! range . contains ( t ) & & ranges . hasNext ( ) ) { range = ranges . next ( ) ; } return range . contains ( t ) ; } static class CountingDigest extends MessageDigest { private long count ; private MessageDigest underlying ; public CountingDigest ( MessageDigest underlying ) { super ( underlying . getAlgorithm ( ) ) ; this . underlying = underlying ; } @Override protected void engineUpdate ( byte input ) { underlying . update ( input ) ; count + = <int> ; } @Override protected void engineUpdate ( byte [ ] input , int offset , int len ) { underlying . update ( input , offset , len ) ; count + = len ; } @Override protected byte [ ] engineDigest ( ) { return underlying . digest ( ) ; } @Override protected void engineReset ( ) { underlying . reset ( ) ; } } private MerkleTree . RowHash rowHash ( UnfilteredRowIterator partition ) { validated + + ; CountingDigest digest = new CountingDigest ( FBUtilities . newMessageDigest ( <str> ) ) ; UnfilteredRowIterators . digest ( partition , digest , MessagingService . current_version ) ; return digest . count > <int> ? new MerkleTree . RowHash ( partition . partitionKey ( ) . getToken ( ) , digest . digest ( ) , digest . count ) : null ; } public void complete ( ) { completeTree ( ) ; StageManager . getStage ( Stage . ANTI_ENTROPY ) . execute ( this ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , validated , desc . sessionId ) ; trees . logRowCountPerLeaf ( logger ) ; logger . debug ( <str> , validated , desc . sessionId ) ; trees . logRowSizePerLeaf ( logger ) ; } } @VisibleForTesting public void completeTree ( ) { assert ranges ! = null : <str> ; ranges = trees . invalids ( ) ; while ( ranges . hasNext ( ) ) { range = ranges . next ( ) ; range . ensureHashInitialised ( ) ; } } public void fail ( ) { logger . error ( <str> , desc , initiator ) ; MessagingService . instance ( ) . sendOneWay ( new ValidationComplete ( desc ) . createMessage ( ) , initiator ) ; } public void run ( ) { if ( ! initiator . equals ( FBUtilities . getBroadcastAddress ( ) ) ) { logger . info ( String . format ( <str> , desc . sessionId , initiator , desc . keyspace , desc . columnFamily ) ) ; Tracing . traceRepair ( <str> , initiator , desc . keyspace , desc . columnFamily ) ; } MessagingService . instance ( ) . sendOneWay ( new ValidationComplete ( desc , trees ) . createMessage ( ) , initiator ) ; } } 
