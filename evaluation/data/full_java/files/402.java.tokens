package org . apache . cassandra . db . compaction . writers ; import java . io . File ; import java . util . Set ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Directories ; import org . apache . cassandra . db . RowIndexEntry ; import org . apache . cassandra . db . SerializationHeader ; import org . apache . cassandra . db . rows . UnfilteredRowIterator ; import org . apache . cassandra . db . compaction . LeveledManifest ; import org . apache . cassandra . db . lifecycle . LifecycleTransaction ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . io . sstable . format . SSTableWriter ; import org . apache . cassandra . io . sstable . metadata . MetadataCollector ; public class MajorLeveledCompactionWriter extends CompactionAwareWriter { private static final Logger logger = LoggerFactory . getLogger ( MajorLeveledCompactionWriter . class ) ; private final long maxSSTableSize ; private final long expectedWriteSize ; private final Set < SSTableReader > allSSTables ; private int currentLevel = <int> ; private long averageEstimatedKeysPerSSTable ; private long partitionsWritten = <int> ; private long totalWrittenInLevel = <int> ; private int sstablesWritten = <int> ; public MajorLeveledCompactionWriter ( ColumnFamilyStore cfs , Directories directories , LifecycleTransaction txn , Set < SSTableReader > nonExpiredSSTables , long maxSSTableSize ) { this ( cfs , directories , txn , nonExpiredSSTables , maxSSTableSize , false , false ) ; } @SuppressWarnings ( <str> ) public MajorLeveledCompactionWriter ( ColumnFamilyStore cfs , Directories directories , LifecycleTransaction txn , Set < SSTableReader > nonExpiredSSTables , long maxSSTableSize , boolean offline , boolean keepOriginals ) { super ( cfs , directories , txn , nonExpiredSSTables , offline , keepOriginals ) ; this . maxSSTableSize = maxSSTableSize ; this . allSSTables = txn . originals ( ) ; expectedWriteSize = Math . min ( maxSSTableSize , cfs . getExpectedCompactedFileSize ( nonExpiredSSTables , txn . opType ( ) ) ) ; } @Override @SuppressWarnings ( <str> ) public boolean realAppend ( UnfilteredRowIterator partition ) { long posBefore = sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) ; RowIndexEntry rie = sstableWriter . append ( partition ) ; totalWrittenInLevel + = sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) - posBefore ; partitionsWritten + + ; if ( sstableWriter . currentWriter ( ) . getOnDiskFilePointer ( ) > maxSSTableSize ) { if ( totalWrittenInLevel > LeveledManifest . maxBytesForLevel ( currentLevel , maxSSTableSize ) ) { totalWrittenInLevel = <int> ; currentLevel + + ; } averageEstimatedKeysPerSSTable = Math . round ( ( ( double ) averageEstimatedKeysPerSSTable * sstablesWritten + partitionsWritten ) / ( sstablesWritten + <int> ) ) ; switchCompactionLocation ( getWriteDirectory ( expectedWriteSize ) ) ; partitionsWritten = <int> ; sstablesWritten + + ; } return rie ! = null ; } public void switchCompactionLocation ( Directories . DataDirectory directory ) { File sstableDirectory = getDirectories ( ) . getLocationForDisk ( directory ) ; @SuppressWarnings ( <str> ) SSTableWriter writer = SSTableWriter . create ( Descriptor . fromFilename ( cfs . getSSTablePath ( sstableDirectory ) ) , averageEstimatedKeysPerSSTable , minRepairedAt , cfs . metadata , new MetadataCollector ( allSSTables , cfs . metadata . comparator , currentLevel ) , SerializationHeader . make ( cfs . metadata , nonExpiredSSTables ) , cfs . indexManager . listIndexes ( ) , txn ) ; sstableWriter . switchWriter ( writer ) ; } } 
