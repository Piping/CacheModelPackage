package org . elasticsearch . test . rest . client ; import com . carrotsearch . randomizedtesting . RandomizedTest ; import org . apache . http . config . Registry ; import org . apache . http . config . RegistryBuilder ; import org . apache . http . conn . socket . ConnectionSocketFactory ; import org . apache . http . conn . socket . PlainConnectionSocketFactory ; import org . apache . http . conn . ssl . SSLConnectionSocketFactory ; import org . apache . http . conn . ssl . SSLContexts ; import org . apache . http . impl . client . CloseableHttpClient ; import org . apache . http . impl . client . HttpClients ; import org . apache . http . impl . conn . PoolingHttpClientConnectionManager ; import org . apache . lucene . util . IOUtils ; import org . elasticsearch . Version ; import org . elasticsearch . client . support . Headers ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . network . NetworkAddress ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . util . set . Sets ; import org . elasticsearch . test . rest . client . http . HttpRequestBuilder ; import org . elasticsearch . test . rest . client . http . HttpResponse ; import org . elasticsearch . test . rest . spec . RestApi ; import org . elasticsearch . test . rest . spec . RestSpec ; import javax . net . ssl . SSLContext ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStream ; import java . net . InetSocketAddress ; import java . nio . file . Files ; import java . nio . file . Path ; import java . security . KeyManagementException ; import java . security . KeyStore ; import java . security . KeyStoreException ; import java . security . NoSuchAlgorithmException ; import java . security . cert . CertificateException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . TimeUnit ; public class RestClient implements Closeable { public static final String PROTOCOL = <str> ; public static final String TRUSTSTORE_PATH = <str> ; public static final String TRUSTSTORE_PASSWORD = <str> ; private static final ESLogger logger = Loggers . getLogger ( RestClient . class ) ; private static final Set < String > ALWAYS_ACCEPTED_QUERY_STRING_PARAMS = Sets . newHashSet ( <str> , <str> , <str> ) ; private final String protocol ; private final RestSpec restSpec ; private final CloseableHttpClient httpClient ; private final Headers headers ; private final InetSocketAddress [ ] addresses ; private final Version esVersion ; public RestClient ( RestSpec restSpec , Settings settings , InetSocketAddress [ ] addresses ) throws IOException , RestException { assert addresses . length > <int> ; this . restSpec = restSpec ; this . headers = new Headers ( settings ) ; this . protocol = settings . get ( PROTOCOL , <str> ) ; this . httpClient = createHttpClient ( settings ) ; this . addresses = addresses ; this . esVersion = readAndCheckVersion ( ) ; logger . info ( <str> , addresses , esVersion ) ; } private Version readAndCheckVersion ( ) throws IOException , RestException { RestApi restApi = restApi ( <str> ) ; assert restApi . getPaths ( ) . size ( ) = = <int> ; assert restApi . getMethods ( ) . size ( ) = = <int> ; String version = null ; for ( InetSocketAddress address : addresses ) { RestResponse restResponse = new RestResponse ( httpRequestBuilder ( address ) . path ( restApi . getPaths ( ) . get ( <int> ) ) . method ( restApi . getMethods ( ) . get ( <int> ) ) . execute ( ) ) ; checkStatusCode ( restResponse ) ; Object latestVersion = restResponse . evaluate ( <str> ) ; if ( latestVersion = = null ) { throw new RuntimeException ( <str> ) ; } if ( version = = null ) { version = latestVersion . toString ( ) ; } else { if ( ! latestVersion . equals ( version ) ) { throw new IllegalArgumentException ( <str> ) ; } } } return Version . fromString ( version ) ; } public Version getEsVersion ( ) { return esVersion ; } public RestResponse callApi ( String apiName , Map < String , String > params , String body , Map < String , String > headers ) throws IOException , RestException { List < Integer > ignores = new ArrayList < > ( ) ; Map < String , String > requestParams = null ; if ( params ! = null ) { requestParams = new HashMap < > ( params ) ; String ignoreString = requestParams . remove ( <str> ) ; if ( Strings . hasLength ( ignoreString ) ) { try { ignores . add ( Integer . valueOf ( ignoreString ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( <str> + ignoreString + <str> ) ; } } } HttpRequestBuilder httpRequestBuilder = callApiBuilder ( apiName , requestParams , body ) ; for ( Map . Entry < String , String > header : headers . entrySet ( ) ) { httpRequestBuilder . addHeader ( header . getKey ( ) , header . getValue ( ) ) ; } logger . debug ( <str> , apiName ) ; HttpResponse httpResponse = httpRequestBuilder . execute ( ) ; if ( ! httpResponse . supportsBody ( ) ) { ignores . add ( <int> ) ; } RestResponse restResponse = new RestResponse ( httpResponse ) ; checkStatusCode ( restResponse , ignores ) ; return restResponse ; } private void checkStatusCode ( RestResponse restResponse , List < Integer > ignores ) throws RestException { if ( ignores . contains ( restResponse . getStatusCode ( ) ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , ignores ) ; } return ; } checkStatusCode ( restResponse ) ; } private void checkStatusCode ( RestResponse restResponse ) throws RestException { if ( restResponse . isError ( ) ) { throw new RestException ( <str> + restResponse . getStatusCode ( ) + <str> , restResponse ) ; } } private HttpRequestBuilder callApiBuilder ( String apiName , Map < String , String > params , String body ) { boolean indexCreateApi = <str> . equals ( apiName ) ; String api = indexCreateApi ? <str> : apiName ; RestApi restApi = restApi ( api ) ; HttpRequestBuilder httpRequestBuilder = httpRequestBuilder ( ) ; Map < String , String > pathParts = new HashMap < > ( ) ; if ( params ! = null ) { for ( Map . Entry < String , String > entry : params . entrySet ( ) ) { if ( restApi . getPathParts ( ) . contains ( entry . getKey ( ) ) ) { pathParts . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } else { if ( restApi . getParams ( ) . contains ( entry . getKey ( ) ) | | ALWAYS_ACCEPTED_QUERY_STRING_PARAMS . contains ( entry . getKey ( ) ) ) { httpRequestBuilder . addParam ( entry . getKey ( ) , entry . getValue ( ) ) ; } else { throw new IllegalArgumentException ( <str> + entry . getKey ( ) + <str> + restApi . getName ( ) + <str> ) ; } } } } if ( indexCreateApi ) { httpRequestBuilder . addParam ( <str> , <str> ) ; } List < String > supportedMethods = restApi . getSupportedMethods ( pathParts . keySet ( ) ) ; if ( Strings . hasLength ( body ) ) { if ( ! restApi . isBodySupported ( ) ) { throw new IllegalArgumentException ( <str> + restApi . getName ( ) + <str> ) ; } if ( supportedMethods . contains ( <str> ) & & RandomizedTest . rarely ( ) ) { logger . debug ( <str> ) ; httpRequestBuilder . addParam ( <str> , body ) . method ( <str> ) ; } else { httpRequestBuilder . body ( body ) . method ( RandomizedTest . randomFrom ( supportedMethods ) ) ; } } else { if ( restApi . isBodyRequired ( ) ) { throw new IllegalArgumentException ( <str> + restApi . getName ( ) + <str> ) ; } httpRequestBuilder . method ( RandomizedTest . randomFrom ( supportedMethods ) ) ; } RestPath restPath = RandomizedTest . randomFrom ( restApi . getFinalPaths ( pathParts ) ) ; return httpRequestBuilder . pathParts ( restPath . getPathParts ( ) ) ; } private RestApi restApi ( String apiName ) { RestApi restApi = restSpec . getApi ( apiName ) ; if ( restApi = = null ) { throw new IllegalArgumentException ( <str> + apiName + <str> ) ; } return restApi ; } protected HttpRequestBuilder httpRequestBuilder ( InetSocketAddress address ) { return new HttpRequestBuilder ( httpClient ) . addHeaders ( headers ) . protocol ( protocol ) . host ( NetworkAddress . formatAddress ( address . getAddress ( ) ) ) . port ( address . getPort ( ) ) ; } protected HttpRequestBuilder httpRequestBuilder ( ) { InetSocketAddress address = RandomizedTest . randomFrom ( addresses ) ; return httpRequestBuilder ( address ) ; } protected CloseableHttpClient createHttpClient ( Settings settings ) throws IOException { SSLConnectionSocketFactory sslsf ; String keystorePath = settings . get ( TRUSTSTORE_PATH ) ; if ( keystorePath ! = null ) { final String keystorePass = settings . get ( TRUSTSTORE_PASSWORD ) ; if ( keystorePass = = null ) { throw new IllegalStateException ( TRUSTSTORE_PATH + <str> + TRUSTSTORE_PASSWORD ) ; } Path path = PathUtils . get ( keystorePath ) ; if ( ! Files . exists ( path ) ) { throw new IllegalStateException ( TRUSTSTORE_PATH + <str> ) ; } try { KeyStore keyStore = KeyStore . getInstance ( <str> ) ; try ( InputStream is = Files . newInputStream ( path ) ) { keyStore . load ( is , keystorePass . toCharArray ( ) ) ; } SSLContext sslcontext = SSLContexts . custom ( ) . loadTrustMaterial ( keyStore , null ) . build ( ) ; sslsf = new SSLConnectionSocketFactory ( sslcontext ) ; } catch ( KeyStoreException | NoSuchAlgorithmException | KeyManagementException | CertificateException e ) { throw new RuntimeException ( e ) ; } } else { sslsf = SSLConnectionSocketFactory . getSocketFactory ( ) ; } Registry < ConnectionSocketFactory > socketFactoryRegistry = RegistryBuilder . < ConnectionSocketFactory > create ( ) . register ( <str> , PlainConnectionSocketFactory . getSocketFactory ( ) ) . register ( <str> , sslsf ) . build ( ) ; return HttpClients . createMinimal ( new PoolingHttpClientConnectionManager ( socketFactoryRegistry , null , null , null , <int> , TimeUnit . SECONDS ) ) ; } @Override public void close ( ) { IOUtils . closeWhileHandlingException ( httpClient ) ; } } 
