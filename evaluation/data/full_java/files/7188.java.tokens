package org . elasticsearch . search . aggregations . bucket . histogram ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . rounding . Rounding ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . search . SearchParseException ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . AggregatorFactory ; import org . elasticsearch . search . aggregations . support . ValueType ; import org . elasticsearch . search . aggregations . support . ValuesSourceParser ; import org . elasticsearch . search . aggregations . support . format . ValueParser ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; public class HistogramParser implements Aggregator . Parser { static final ParseField EXTENDED_BOUNDS = new ParseField ( <str> ) ; @Override public String type ( ) { return InternalHistogram . TYPE . name ( ) ; } @Override public AggregatorFactory parse ( String aggregationName , XContentParser parser , SearchContext context ) throws IOException { ValuesSourceParser vsParser = ValuesSourceParser . numeric ( aggregationName , InternalHistogram . TYPE , context ) . targetValueType ( ValueType . NUMERIC ) . formattable ( true ) . build ( ) ; boolean keyed = false ; long minDocCount = <int> ; InternalOrder order = ( InternalOrder ) InternalOrder . KEY_ASC ; long interval = - <int> ; ExtendedBounds extendedBounds = null ; long offset = <int> ; XContentParser . Token token ; String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( vsParser . token ( currentFieldName , token , parser ) ) { continue ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { interval = parser . longValue ( ) ; } else if ( <str> . equals ( currentFieldName ) | | <str> . equals ( currentFieldName ) ) { minDocCount = parser . longValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { keyed = parser . booleanValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { offset = parser . longValue ( ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else if ( token = = XContentParser . Token . START_OBJECT ) { if ( <str> . equals ( currentFieldName ) ) { while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token = = XContentParser . Token . VALUE_STRING ) { String dir = parser . text ( ) ; boolean asc = <str> . equals ( dir ) ; if ( ! asc & & ! <str> . equals ( dir ) ) { throw new SearchParseException ( context , <str> + dir + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } order = resolveOrder ( currentFieldName , asc ) ; } } } else if ( context . parseFieldMatcher ( ) . match ( currentFieldName , EXTENDED_BOUNDS ) ) { extendedBounds = new ExtendedBounds ( ) ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { if ( <str> . equals ( currentFieldName ) ) { extendedBounds . min = parser . longValue ( true ) ; } else if ( <str> . equals ( currentFieldName ) ) { extendedBounds . max = parser . longValue ( true ) ; } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> + currentFieldName + <str> , parser . getTokenLocation ( ) ) ; } } else { throw new SearchParseException ( context , <str> + token + <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } } if ( interval < <int> ) { throw new SearchParseException ( context , <str> + aggregationName + <str> , parser . getTokenLocation ( ) ) ; } Rounding rounding = new Rounding . Interval ( interval ) ; if ( offset ! = <int> ) { rounding = new Rounding . OffsetRounding ( ( Rounding . Interval ) rounding , offset ) ; } if ( extendedBounds ! = null ) { extendedBounds . processAndValidate ( aggregationName , context , ValueParser . RAW ) ; } return new HistogramAggregator . Factory ( aggregationName , vsParser . config ( ) , rounding , order , keyed , minDocCount , extendedBounds , new InternalHistogram . Factory ( ) ) ; } static InternalOrder resolveOrder ( String key , boolean asc ) { if ( <str> . equals ( key ) ) { return ( InternalOrder ) ( asc ? InternalOrder . KEY_ASC : InternalOrder . KEY_DESC ) ; } if ( <str> . equals ( key ) ) { return ( InternalOrder ) ( asc ? InternalOrder . COUNT_ASC : InternalOrder . COUNT_DESC ) ; } return new InternalOrder . Aggregation ( key , asc ) ; } } 
