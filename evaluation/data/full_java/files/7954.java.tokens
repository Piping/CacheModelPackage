package org . elasticsearch . common . recycler ; import org . elasticsearch . common . recycler . Recycler . V ; import org . elasticsearch . test . ESTestCase ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public abstract class AbstractRecyclerTestCase extends ESTestCase { protected static final byte FRESH = <int> ; protected static final byte RECYCLED = <int> ; protected static final byte DEAD = <int> ; protected static final Recycler . C < byte [ ] > RECYCLER_C = new AbstractRecyclerC < byte [ ] > ( ) { @Override public byte [ ] newInstance ( int sizing ) { byte [ ] value = new byte [ <int> ] ; Arrays . fill ( value , FRESH ) ; return value ; } @Override public void recycle ( byte [ ] value ) { Arrays . fill ( value , RECYCLED ) ; } @Override public void destroy ( byte [ ] value ) { Arrays . fill ( value , DEAD ) ; } } ; protected void assertFresh ( byte [ ] data ) { assertNotNull ( data ) ; for ( int i = <int> ; i < data . length ; + + i ) { assertEquals ( FRESH , data [ i ] ) ; } } protected void assertRecycled ( byte [ ] data ) { assertNotNull ( data ) ; for ( int i = <int> ; i < data . length ; + + i ) { assertEquals ( RECYCLED , data [ i ] ) ; } } protected void assertDead ( byte [ ] data ) { assertNotNull ( data ) ; for ( int i = <int> ; i < data . length ; + + i ) { assertEquals ( DEAD , data [ i ] ) ; } } protected abstract Recycler < byte [ ] > newRecycler ( int limit ) ; protected int limit = randomIntBetween ( <int> , <int> ) ; public void testReuse ( ) { Recycler < byte [ ] > r = newRecycler ( limit ) ; Recycler . V < byte [ ] > o = r . obtain ( ) ; assertFalse ( o . isRecycled ( ) ) ; final byte [ ] b1 = o . v ( ) ; assertFresh ( b1 ) ; o . close ( ) ; assertRecycled ( b1 ) ; o = r . obtain ( ) ; final byte [ ] b2 = o . v ( ) ; if ( o . isRecycled ( ) ) { assertRecycled ( b2 ) ; assertSame ( b1 , b2 ) ; } else { assertFresh ( b2 ) ; assertNotSame ( b1 , b2 ) ; } o . close ( ) ; r . close ( ) ; } public void testRecycle ( ) { Recycler < byte [ ] > r = newRecycler ( limit ) ; Recycler . V < byte [ ] > o = r . obtain ( ) ; assertFresh ( o . v ( ) ) ; getRandom ( ) . nextBytes ( o . v ( ) ) ; o . close ( ) ; o = r . obtain ( ) ; assertRecycled ( o . v ( ) ) ; o . close ( ) ; r . close ( ) ; } public void testDoubleRelease ( ) { final Recycler < byte [ ] > r = newRecycler ( limit ) ; final Recycler . V < byte [ ] > v1 = r . obtain ( ) ; v1 . close ( ) ; try { v1 . close ( ) ; } catch ( IllegalStateException e ) { return ; } final Recycler . V < byte [ ] > v2 = r . obtain ( ) ; final Recycler . V < byte [ ] > v3 = r . obtain ( ) ; assertNotSame ( v2 . v ( ) , v3 . v ( ) ) ; r . close ( ) ; } public void testDestroyWhenOverCapacity ( ) { Recycler < byte [ ] > r = newRecycler ( limit ) ; Recycler . V < byte [ ] > o = r . obtain ( ) ; byte [ ] data = o . v ( ) ; assertFresh ( data ) ; List < V < byte [ ] > > vals = new ArrayList < > ( limit ) ; for ( int i = <int> ; i < limit ; + + i ) { vals . add ( r . obtain ( ) ) ; } for ( V < byte [ ] > v : vals ) { v . close ( ) ; } o . close ( ) ; assertDead ( data ) ; r . close ( ) ; } public void testClose ( ) { Recycler < byte [ ] > r = newRecycler ( limit ) ; Recycler . V < byte [ ] > o = r . obtain ( ) ; byte [ ] data = o . v ( ) ; assertFresh ( data ) ; getRandom ( ) . nextBytes ( data ) ; o . close ( ) ; assertRecycled ( data ) ; r . close ( ) ; assertDead ( data ) ; } } 
