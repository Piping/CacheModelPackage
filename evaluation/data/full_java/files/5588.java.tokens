package org . elasticsearch . cluster . routing ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . allocation . decider . AwarenessAllocationDecider ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . math . MathUtils ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . IndexNotFoundException ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . shard . ShardNotFoundException ; import java . util . ArrayList ; import java . util . Collections ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; public class OperationRouting extends AbstractComponent { private final AwarenessAllocationDecider awarenessAllocationDecider ; @Inject public OperationRouting ( Settings settings , AwarenessAllocationDecider awarenessAllocationDecider ) { super ( settings ) ; this . awarenessAllocationDecider = awarenessAllocationDecider ; } public ShardIterator indexShards ( ClusterState clusterState , String index , String type , String id , @Nullable String routing ) { return shards ( clusterState , index , id , routing ) . shardsIt ( ) ; } public ShardIterator getShards ( ClusterState clusterState , String index , String type , String id , @Nullable String routing , @Nullable String preference ) { return preferenceActiveShardIterator ( shards ( clusterState , index , id , routing ) , clusterState . nodes ( ) . localNodeId ( ) , clusterState . nodes ( ) , preference ) ; } public ShardIterator getShards ( ClusterState clusterState , String index , int shardId , @Nullable String preference ) { final IndexShardRoutingTable indexShard = clusterState . getRoutingTable ( ) . shardRoutingTable ( index , shardId ) ; return preferenceActiveShardIterator ( indexShard , clusterState . nodes ( ) . localNodeId ( ) , clusterState . nodes ( ) , preference ) ; } public GroupShardsIterator broadcastDeleteShards ( ClusterState clusterState , String index ) { return indexRoutingTable ( clusterState , index ) . groupByShardsIt ( ) ; } public int searchShardsCount ( ClusterState clusterState , String [ ] concreteIndices , @Nullable Map < String , Set < String > > routing ) { final Set < IndexShardRoutingTable > shards = computeTargetedShards ( clusterState , concreteIndices , routing ) ; return shards . size ( ) ; } public GroupShardsIterator searchShards ( ClusterState clusterState , String [ ] concreteIndices , @Nullable Map < String , Set < String > > routing , @Nullable String preference ) { final Set < IndexShardRoutingTable > shards = computeTargetedShards ( clusterState , concreteIndices , routing ) ; final Set < ShardIterator > set = new HashSet < > ( shards . size ( ) ) ; for ( IndexShardRoutingTable shard : shards ) { ShardIterator iterator = preferenceActiveShardIterator ( shard , clusterState . nodes ( ) . localNodeId ( ) , clusterState . nodes ( ) , preference ) ; if ( iterator ! = null ) { set . add ( iterator ) ; } } return new GroupShardsIterator ( new ArrayList < > ( set ) ) ; } private static final Map < String , Set < String > > EMPTY_ROUTING = Collections . emptyMap ( ) ; private Set < IndexShardRoutingTable > computeTargetedShards ( ClusterState clusterState , String [ ] concreteIndices , @Nullable Map < String , Set < String > > routing ) { routing = routing = = null ? EMPTY_ROUTING : routing ; final Set < IndexShardRoutingTable > set = new HashSet < > ( ) ; for ( String index : concreteIndices ) { final IndexRoutingTable indexRouting = indexRoutingTable ( clusterState , index ) ; final Set < String > effectiveRouting = routing . get ( index ) ; if ( effectiveRouting ! = null ) { for ( String r : effectiveRouting ) { int shardId = generateShardId ( clusterState , index , null , r ) ; IndexShardRoutingTable indexShard = indexRouting . shard ( shardId ) ; if ( indexShard = = null ) { throw new ShardNotFoundException ( new ShardId ( index , shardId ) ) ; } set . add ( indexShard ) ; } } else { for ( IndexShardRoutingTable indexShard : indexRouting ) { set . add ( indexShard ) ; } } } return set ; } private ShardIterator preferenceActiveShardIterator ( IndexShardRoutingTable indexShard , String localNodeId , DiscoveryNodes nodes , @Nullable String preference ) { if ( preference = = null | | preference . isEmpty ( ) ) { String [ ] awarenessAttributes = awarenessAllocationDecider . awarenessAttributes ( ) ; if ( awarenessAttributes . length = = <int> ) { return indexShard . activeInitializingShardsRandomIt ( ) ; } else { return indexShard . preferAttributesActiveInitializingShardsIt ( awarenessAttributes , nodes ) ; } } if ( preference . charAt ( <int> ) = = <str> ) { Preference preferenceType = Preference . parse ( preference ) ; if ( preferenceType = = Preference . SHARDS ) { int index = preference . indexOf ( <str> ) ; String shards ; if ( index = = - <int> ) { shards = preference . substring ( Preference . SHARDS . type ( ) . length ( ) + <int> ) ; } else { shards = preference . substring ( Preference . SHARDS . type ( ) . length ( ) + <int> , index ) ; } String [ ] ids = Strings . splitStringByCommaToArray ( shards ) ; boolean found = false ; for ( String id : ids ) { if ( Integer . parseInt ( id ) = = indexShard . shardId ( ) . id ( ) ) { found = true ; break ; } } if ( ! found ) { return null ; } if ( index = = - <int> | | index = = preference . length ( ) - <int> ) { String [ ] awarenessAttributes = awarenessAllocationDecider . awarenessAttributes ( ) ; if ( awarenessAttributes . length = = <int> ) { return indexShard . activeInitializingShardsRandomIt ( ) ; } else { return indexShard . preferAttributesActiveInitializingShardsIt ( awarenessAttributes , nodes ) ; } } else { preference = preference . substring ( index + <int> ) ; } } preferenceType = Preference . parse ( preference ) ; switch ( preferenceType ) { case PREFER_NODE : return indexShard . preferNodeActiveInitializingShardsIt ( preference . substring ( Preference . PREFER_NODE . type ( ) . length ( ) + <int> ) ) ; case LOCAL : return indexShard . preferNodeActiveInitializingShardsIt ( localNodeId ) ; case PRIMARY : return indexShard . primaryActiveInitializingShardIt ( ) ; case REPLICA : return indexShard . replicaActiveInitializingShardIt ( ) ; case PRIMARY_FIRST : return indexShard . primaryFirstActiveInitializingShardsIt ( ) ; case REPLICA_FIRST : return indexShard . replicaFirstActiveInitializingShardsIt ( ) ; case ONLY_LOCAL : return indexShard . onlyNodeActiveInitializingShardsIt ( localNodeId ) ; case ONLY_NODE : String nodeId = preference . substring ( Preference . ONLY_NODE . type ( ) . length ( ) + <int> ) ; ensureNodeIdExists ( nodes , nodeId ) ; return indexShard . onlyNodeActiveInitializingShardsIt ( nodeId ) ; case ONLY_NODES : String nodeAttribute = preference . substring ( Preference . ONLY_NODES . type ( ) . length ( ) + <int> ) ; return indexShard . onlyNodeSelectorActiveInitializingShardsIt ( nodeAttribute , nodes ) ; default : throw new IllegalArgumentException ( <str> + preferenceType + <str> ) ; } } String [ ] awarenessAttributes = awarenessAllocationDecider . awarenessAttributes ( ) ; if ( awarenessAttributes . length = = <int> ) { return indexShard . activeInitializingShardsIt ( Murmur3HashFunction . hash ( preference ) ) ; } else { return indexShard . preferAttributesActiveInitializingShardsIt ( awarenessAttributes , nodes , Murmur3HashFunction . hash ( preference ) ) ; } } protected IndexRoutingTable indexRoutingTable ( ClusterState clusterState , String index ) { IndexRoutingTable indexRouting = clusterState . routingTable ( ) . index ( index ) ; if ( indexRouting = = null ) { throw new IndexNotFoundException ( index ) ; } return indexRouting ; } protected IndexShardRoutingTable shards ( ClusterState clusterState , String index , String id , String routing ) { int shardId = generateShardId ( clusterState , index , id , routing ) ; return clusterState . getRoutingTable ( ) . shardRoutingTable ( index , shardId ) ; } public ShardId shardId ( ClusterState clusterState , String index , String id , @Nullable String routing ) { return new ShardId ( index , generateShardId ( clusterState , index , id , routing ) ) ; } private int generateShardId ( ClusterState clusterState , String index , String id , @Nullable String routing ) { IndexMetaData indexMetaData = clusterState . metaData ( ) . index ( index ) ; if ( indexMetaData = = null ) { throw new IndexNotFoundException ( index ) ; } final int hash ; if ( routing = = null ) { hash = Murmur3HashFunction . hash ( id ) ; } else { hash = Murmur3HashFunction . hash ( routing ) ; } return MathUtils . mod ( hash , indexMetaData . getNumberOfShards ( ) ) ; } private void ensureNodeIdExists ( DiscoveryNodes nodes , String nodeId ) { if ( ! nodes . dataNodes ( ) . keys ( ) . contains ( nodeId ) ) { throw new IllegalArgumentException ( <str> + nodeId + <str> ) ; } } } 
