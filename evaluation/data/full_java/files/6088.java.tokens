package org . elasticsearch . common . util ; import org . apache . lucene . store . DataInput ; import org . apache . lucene . store . DataOutput ; import org . apache . lucene . store . IndexInput ; import org . apache . lucene . util . BytesRef ; import org . apache . lucene . util . RamUsageEstimator ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . Strings ; import org . elasticsearch . common . hash . MurmurHash3 ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . unit . SizeValue ; import java . io . IOException ; import java . util . Arrays ; import java . util . Comparator ; public class BloomFilter { public static class Factory { public static final Factory DEFAULT = buildDefault ( ) ; private static Factory buildDefault ( ) { return buildFromString ( <str> ) ; } public static Factory buildFromString ( @Nullable String config ) { if ( config = = null ) { return buildDefault ( ) ; } String [ ] sEntries = Strings . splitStringToArray ( config , <str> ) ; if ( sEntries . length = = <int> ) { if ( config . length ( ) > <int> ) { return new Factory ( new Entry [ ] { new Entry ( <int> , Double . parseDouble ( config ) ) } ) ; } return buildDefault ( ) ; } Entry [ ] entries = new Entry [ sEntries . length ] ; for ( int i = <int> ; i < sEntries . length ; i + + ) { int index = sEntries [ i ] . indexOf ( <str> ) ; entries [ i ] = new Entry ( ( int ) SizeValue . parseSizeValue ( sEntries [ i ] . substring ( <int> , index ) . trim ( ) ) . singles ( ) , Double . parseDouble ( sEntries [ i ] . substring ( index + <int> ) . trim ( ) ) ) ; } return new Factory ( entries ) ; } private final Entry [ ] entries ; public Factory ( Entry [ ] entries ) { this . entries = entries ; Arrays . sort ( this . entries , new Comparator < Entry > ( ) { @Override public int compare ( Entry o1 , Entry o2 ) { return o2 . expectedInsertions - o1 . expectedInsertions ; } } ) ; } public BloomFilter createFilter ( int expectedInsertions ) { for ( Entry entry : entries ) { if ( expectedInsertions > entry . expectedInsertions ) { return BloomFilter . create ( expectedInsertions , entry . fpp ) ; } } return BloomFilter . create ( expectedInsertions , <float> ) ; } public static class Entry { public final int expectedInsertions ; public final double fpp ; Entry ( int expectedInsertions , double fpp ) { this . expectedInsertions = expectedInsertions ; this . fpp = fpp ; } } } public static BloomFilter create ( int expectedInsertions , double fpp ) { return create ( expectedInsertions , fpp , - <int> ) ; } public static BloomFilter create ( int expectedInsertions , double fpp , int numHashFunctions ) { if ( expectedInsertions = = <int> ) { expectedInsertions = <int> ; } long numBits = optimalNumOfBits ( expectedInsertions , fpp ) ; if ( numHashFunctions = = - <int> ) { numHashFunctions = optimalNumOfHashFunctions ( expectedInsertions , numBits ) ; } try { return new BloomFilter ( new BitArray ( numBits ) , numHashFunctions , Hashing . DEFAULT ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( <str> + numBits + <str> , e ) ; } } public static void skipBloom ( IndexInput in ) throws IOException { int version = in . readInt ( ) ; final int numLongs = in . readInt ( ) ; in . seek ( in . getFilePointer ( ) + ( numLongs * <int> ) + <int> + <int> ) ; } public static BloomFilter deserialize ( DataInput in ) throws IOException { int version = in . readInt ( ) ; int numLongs = in . readInt ( ) ; long [ ] data = new long [ numLongs ] ; for ( int i = <int> ; i < numLongs ; i + + ) { data [ i ] = in . readLong ( ) ; } int numberOfHashFunctions = in . readInt ( ) ; int hashType = in . readInt ( ) ; return new BloomFilter ( new BitArray ( data ) , numberOfHashFunctions , Hashing . fromType ( hashType ) ) ; } public static void serilaize ( BloomFilter filter , DataOutput out ) throws IOException { out . writeInt ( <int> ) ; BitArray bits = filter . bits ; out . writeInt ( bits . data . length ) ; for ( long l : bits . data ) { out . writeLong ( l ) ; } out . writeInt ( filter . numHashFunctions ) ; out . writeInt ( filter . hashing . type ( ) ) ; } public static BloomFilter readFrom ( StreamInput in ) throws IOException { int version = in . readVInt ( ) ; int numLongs = in . readVInt ( ) ; long [ ] data = new long [ numLongs ] ; for ( int i = <int> ; i < numLongs ; i + + ) { data [ i ] = in . readLong ( ) ; } int numberOfHashFunctions = in . readVInt ( ) ; int hashType = in . readVInt ( ) ; return new BloomFilter ( new BitArray ( data ) , numberOfHashFunctions , Hashing . fromType ( hashType ) ) ; } public static void writeTo ( BloomFilter filter , StreamOutput out ) throws IOException { out . writeVInt ( <int> ) ; BitArray bits = filter . bits ; out . writeVInt ( bits . data . length ) ; for ( long l : bits . data ) { out . writeLong ( l ) ; } out . writeVInt ( filter . numHashFunctions ) ; out . writeVInt ( filter . hashing . type ( ) ) ; } final BitArray bits ; final int numHashFunctions ; final Hashing hashing ; BloomFilter ( BitArray bits , int numHashFunctions , Hashing hashing ) { this . bits = bits ; this . numHashFunctions = numHashFunctions ; this . hashing = hashing ; if ( numHashFunctions > <int> ) { throw new IllegalArgumentException ( <str> ) ; } } public boolean put ( BytesRef value ) { return hashing . put ( value , numHashFunctions , bits ) ; } public boolean mightContain ( BytesRef value ) { return hashing . mightContain ( value , numHashFunctions , bits ) ; } public int getNumHashFunctions ( ) { return this . numHashFunctions ; } public long getSizeInBytes ( ) { return bits . ramBytesUsed ( ) ; } @Override public int hashCode ( ) { return bits . hashCode ( ) + numHashFunctions ; } static int optimalNumOfHashFunctions ( long n , long m ) { return Math . max ( <int> , ( int ) Math . round ( m / n * Math . log ( <int> ) ) ) ; } static long optimalNumOfBits ( long n , double p ) { if ( p = = <int> ) { p = Double . MIN_VALUE ; } return ( long ) ( - n * Math . log ( p ) / ( Math . log ( <int> ) * Math . log ( <int> ) ) ) ; } static final class BitArray { final long [ ] data ; final long bitSize ; long bitCount ; BitArray ( long bits ) { this ( new long [ size ( bits ) ] ) ; } private static int size ( long bits ) { long quotient = bits / <int> ; long remainder = bits - quotient * <int> ; return Math . toIntExact ( remainder = = <int> ? quotient : <int> + quotient ) ; } BitArray ( long [ ] data ) { this . data = data ; long bitCount = <int> ; for ( long value : data ) { bitCount + = Long . bitCount ( value ) ; } this . bitCount = bitCount ; this . bitSize = data . length * Long . SIZE ; } boolean set ( long index ) { if ( ! get ( index ) ) { data [ ( int ) ( index > > > <int> ) ] | = ( <int> < < index ) ; bitCount + + ; return true ; } return false ; } boolean get ( long index ) { return ( data [ ( int ) ( index > > > <int> ) ] & ( <int> < < index ) ) ! = <int> ; } long bitSize ( ) { return bitSize ; } long bitCount ( ) { return bitCount ; } BitArray copy ( ) { return new BitArray ( data . clone ( ) ) ; } void putAll ( BitArray array ) { bitCount = <int> ; for ( int i = <int> ; i < data . length ; i + + ) { data [ i ] | = array . data [ i ] ; bitCount + = Long . bitCount ( data [ i ] ) ; } } @Override public boolean equals ( Object o ) { if ( o instanceof BitArray ) { BitArray bitArray = ( BitArray ) o ; return Arrays . equals ( data , bitArray . data ) ; } return false ; } @Override public int hashCode ( ) { return Arrays . hashCode ( data ) ; } public long ramBytesUsed ( ) { return RamUsageEstimator . NUM_BYTES_LONG * data . length + RamUsageEstimator . NUM_BYTES_ARRAY_HEADER + <int> ; } } static enum Hashing { V0 ( ) { @Override protected boolean put ( BytesRef value , int numHashFunctions , BitArray bits ) { long bitSize = bits . bitSize ( ) ; long hash64 = hash3_x64_128 ( value . bytes , value . offset , value . length , <int> ) ; int hash1 = ( int ) hash64 ; int hash2 = ( int ) ( hash64 > > > <int> ) ; boolean bitsChanged = false ; for ( int i = <int> ; i < = numHashFunctions ; i + + ) { int nextHash = hash1 + i * hash2 ; if ( nextHash < <int> ) { nextHash = ~ nextHash ; } bitsChanged | = bits . set ( nextHash % bitSize ) ; } return bitsChanged ; } @Override protected boolean mightContain ( BytesRef value , int numHashFunctions , BitArray bits ) { long bitSize = bits . bitSize ( ) ; long hash64 = hash3_x64_128 ( value . bytes , value . offset , value . length , <int> ) ; int hash1 = ( int ) hash64 ; int hash2 = ( int ) ( hash64 > > > <int> ) ; for ( int i = <int> ; i < = numHashFunctions ; i + + ) { int nextHash = hash1 + i * hash2 ; if ( nextHash < <int> ) { nextHash = ~ nextHash ; } if ( ! bits . get ( nextHash % bitSize ) ) { return false ; } } return true ; } @Override protected int type ( ) { return <int> ; } } , V1 ( ) { @Override protected boolean put ( BytesRef value , int numHashFunctions , BitArray bits ) { long bitSize = bits . bitSize ( ) ; MurmurHash3 . Hash128 hash128 = MurmurHash3 . hash128 ( value . bytes , value . offset , value . length , <int> , new MurmurHash3 . Hash128 ( ) ) ; boolean bitsChanged = false ; long combinedHash = hash128 . h1 ; for ( int i = <int> ; i < numHashFunctions ; i + + ) { bitsChanged | = bits . set ( ( combinedHash & Long . MAX_VALUE ) % bitSize ) ; combinedHash + = hash128 . h2 ; } return bitsChanged ; } @Override protected boolean mightContain ( BytesRef value , int numHashFunctions , BitArray bits ) { long bitSize = bits . bitSize ( ) ; MurmurHash3 . Hash128 hash128 = MurmurHash3 . hash128 ( value . bytes , value . offset , value . length , <int> , new MurmurHash3 . Hash128 ( ) ) ; long combinedHash = hash128 . h1 ; for ( int i = <int> ; i < numHashFunctions ; i + + ) { if ( ! bits . get ( ( combinedHash & Long . MAX_VALUE ) % bitSize ) ) { return false ; } combinedHash + = hash128 . h2 ; } return true ; } @Override protected int type ( ) { return <int> ; } } ; protected abstract boolean put ( BytesRef value , int numHashFunctions , BitArray bits ) ; protected abstract boolean mightContain ( BytesRef value , int numHashFunctions , BitArray bits ) ; protected abstract int type ( ) ; public static final Hashing DEFAULT = Hashing . V1 ; public static Hashing fromType ( int type ) { if ( type = = <int> ) { return Hashing . V0 ; } if ( type = = <int> ) { return Hashing . V1 ; } else { throw new IllegalArgumentException ( <str> + type ) ; } } } protected static long getblock ( byte [ ] key , int offset , int index ) { int i_8 = index < < <int> ; int blockOffset = offset + i_8 ; return ( ( long ) key [ blockOffset + <int> ] & <hex> ) + ( ( ( long ) key [ blockOffset + <int> ] & <hex> ) < < <int> ) + ( ( ( long ) key [ blockOffset + <int> ] & <hex> ) < < <int> ) + ( ( ( long ) key [ blockOffset + <int> ] & <hex> ) < < <int> ) + ( ( ( long ) key [ blockOffset + <int> ] & <hex> ) < < <int> ) + ( ( ( long ) key [ blockOffset + <int> ] & <hex> ) < < <int> ) + ( ( ( long ) key [ blockOffset + <int> ] & <hex> ) < < <int> ) + ( ( ( long ) key [ blockOffset + <int> ] & <hex> ) < < <int> ) ; } protected static long rotl64 ( long v , int n ) { return ( ( v < < n ) | ( v > > > ( <int> - n ) ) ) ; } protected static long fmix ( long k ) { k ^ = k > > > <int> ; k * = <hex> ; k ^ = k > > > <int> ; k * = <hex> ; k ^ = k > > > <int> ; return k ; } public static long hash3_x64_128 ( byte [ ] key , int offset , int length , long seed ) { final int nblocks = length > > <int> ; long h1 = seed ; long h2 = seed ; long c1 = <hex> ; long c2 = <hex> ; for ( int i = <int> ; i < nblocks ; i + + ) { long k1 = getblock ( key , offset , i * <int> + <int> ) ; long k2 = getblock ( key , offset , i * <int> + <int> ) ; k1 * = c1 ; k1 = rotl64 ( k1 , <int> ) ; k1 * = c2 ; h1 ^ = k1 ; h1 = rotl64 ( h1 , <int> ) ; h1 + = h2 ; h1 = h1 * <int> + <hex> ; k2 * = c2 ; k2 = rotl64 ( k2 , <int> ) ; k2 * = c1 ; h2 ^ = k2 ; h2 = rotl64 ( h2 , <int> ) ; h2 + = h1 ; h2 = h2 * <int> + <hex> ; } offset + = nblocks * <int> ; long k1 = <int> ; long k2 = <int> ; switch ( length & <int> ) { case <int> : k2 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k2 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k2 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k2 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k2 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k2 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k2 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; k2 * = c2 ; k2 = rotl64 ( k2 , <int> ) ; k2 * = c1 ; h2 ^ = k2 ; case <int> : k1 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k1 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k1 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k1 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k1 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k1 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k1 ^ = ( ( long ) key [ offset + <int> ] ) < < <int> ; case <int> : k1 ^ = ( ( long ) key [ offset ] ) ; k1 * = c1 ; k1 = rotl64 ( k1 , <int> ) ; k1 * = c2 ; h1 ^ = k1 ; } h1 ^ = length ; h2 ^ = length ; h1 + = h2 ; h2 + = h1 ; h1 = fmix ( h1 ) ; h2 = fmix ( h2 ) ; h1 + = h2 ; h2 + = h1 ; return h1 ; } } 
