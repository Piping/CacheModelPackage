package org . apache . cassandra . utils ; import java . io . DataInput ; import java . io . IOException ; import java . io . Serializable ; import java . util . * ; import com . google . common . base . Preconditions ; import com . google . common . collect . PeekingIterator ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . dht . IPartitioner ; import org . apache . cassandra . dht . IPartitionerDependentSerializer ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . exceptions . ConfigurationException ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . net . MessagingService ; public class MerkleTree implements Serializable { public static final MerkleTreeSerializer serializer = new MerkleTreeSerializer ( ) ; private static final long serialVersionUID = <int> ; public static final byte RECOMMENDED_DEPTH = Byte . MAX_VALUE - <int> ; public static final int CONSISTENT = <int> ; public static final int FULLY_INCONSISTENT = <int> ; public static final int PARTIALLY_INCONSISTENT = <int> ; private static final byte [ ] EMPTY_HASH = new byte [ <int> ] ; public final byte hashdepth ; public final Range < Token > fullRange ; private final IPartitioner partitioner ; private long maxsize ; private long size ; private Hashable root ; public static class MerkleTreeSerializer implements IVersionedSerializer < MerkleTree > { public void serialize ( MerkleTree mt , DataOutputPlus out , int version ) throws IOException { out . writeByte ( mt . hashdepth ) ; out . writeLong ( mt . maxsize ) ; out . writeLong ( mt . size ) ; out . writeUTF ( mt . partitioner . getClass ( ) . getCanonicalName ( ) ) ; Token . serializer . serialize ( mt . fullRange . left , out , version ) ; Token . serializer . serialize ( mt . fullRange . right , out , version ) ; Hashable . serializer . serialize ( mt . root , out , version ) ; } public MerkleTree deserialize ( DataInputPlus in , int version ) throws IOException { byte hashdepth = in . readByte ( ) ; long maxsize = in . readLong ( ) ; long size = in . readLong ( ) ; IPartitioner partitioner ; try { partitioner = FBUtilities . newPartitioner ( in . readUTF ( ) ) ; } catch ( ConfigurationException e ) { throw new IOException ( e ) ; } Token left = Token . serializer . deserialize ( in , partitioner , version ) ; Token right = Token . serializer . deserialize ( in , partitioner , version ) ; Range < Token > fullRange = new Range < > ( left , right ) ; MerkleTree mt = new MerkleTree ( partitioner , fullRange , hashdepth , maxsize ) ; mt . size = size ; mt . root = Hashable . serializer . deserialize ( in , partitioner , version ) ; return mt ; } public long serializedSize ( MerkleTree mt , int version ) { long size = <int> + TypeSizes . sizeof ( mt . maxsize ) + TypeSizes . sizeof ( mt . size ) + TypeSizes . sizeof ( mt . partitioner . getClass ( ) . getCanonicalName ( ) ) ; size + = Token . serializer . serializedSize ( mt . fullRange . left , version ) ; size + = Token . serializer . serializedSize ( mt . fullRange . right , version ) ; size + = Hashable . serializer . serializedSize ( mt . root , version ) ; return size ; } } public MerkleTree ( IPartitioner partitioner , Range < Token > range , byte hashdepth , long maxsize ) { assert hashdepth < Byte . MAX_VALUE ; this . fullRange = Preconditions . checkNotNull ( range ) ; this . partitioner = Preconditions . checkNotNull ( partitioner ) ; this . hashdepth = hashdepth ; this . maxsize = maxsize ; size = <int> ; root = new Leaf ( null ) ; } static byte inc ( byte in ) { assert in < Byte . MAX_VALUE ; return ( byte ) ( in + <int> ) ; } public void init ( ) { byte sizedepth = ( byte ) ( Math . log10 ( maxsize ) / Math . log10 ( <int> ) ) ; byte depth = ( byte ) Math . min ( sizedepth , hashdepth ) ; root = initHelper ( fullRange . left , fullRange . right , ( byte ) <int> , depth ) ; size = ( long ) Math . pow ( <int> , depth ) ; } private Hashable initHelper ( Token left , Token right , byte depth , byte max ) { if ( depth = = max ) return new Leaf ( ) ; Token midpoint = partitioner . midpoint ( left , right ) ; if ( midpoint . equals ( left ) | | midpoint . equals ( right ) ) return new Leaf ( ) ; Hashable lchild = initHelper ( left , midpoint , inc ( depth ) , max ) ; Hashable rchild = initHelper ( midpoint , right , inc ( depth ) , max ) ; return new Inner ( midpoint , lchild , rchild ) ; } Hashable root ( ) { return root ; } public IPartitioner partitioner ( ) { return partitioner ; } public long size ( ) { return size ; } public long maxsize ( ) { return maxsize ; } public void maxsize ( long maxsize ) { this . maxsize = maxsize ; } public static List < TreeRange > difference ( MerkleTree ltree , MerkleTree rtree ) { if ( ! ltree . fullRange . equals ( rtree . fullRange ) ) throw new IllegalArgumentException ( <str> + ltree . fullRange + <str> + rtree . fullRange + <str> ) ; List < TreeRange > diff = new ArrayList < > ( ) ; TreeDifference active = new TreeDifference ( ltree . fullRange . left , ltree . fullRange . right , ( byte ) <int> ) ; Hashable lnode = ltree . find ( active ) ; Hashable rnode = rtree . find ( active ) ; byte [ ] lhash = lnode . hash ( ) ; byte [ ] rhash = rnode . hash ( ) ; active . setSize ( lnode . sizeOfRange ( ) , rnode . sizeOfRange ( ) ) ; if ( lhash ! = null & & rhash ! = null & & ! Arrays . equals ( lhash , rhash ) ) { if ( FULLY_INCONSISTENT = = differenceHelper ( ltree , rtree , diff , active ) ) diff . add ( active ) ; } else if ( lhash = = null | | rhash = = null ) diff . add ( active ) ; return diff ; } static int differenceHelper ( MerkleTree ltree , MerkleTree rtree , List < TreeRange > diff , TreeRange active ) { if ( active . depth = = Byte . MAX_VALUE ) return CONSISTENT ; Token midpoint = ltree . partitioner ( ) . midpoint ( active . left , active . right ) ; TreeDifference left = new TreeDifference ( active . left , midpoint , inc ( active . depth ) ) ; TreeDifference right = new TreeDifference ( midpoint , active . right , inc ( active . depth ) ) ; byte [ ] lhash , rhash ; Hashable lnode , rnode ; lnode = ltree . find ( left ) ; rnode = rtree . find ( left ) ; lhash = lnode . hash ( ) ; rhash = rnode . hash ( ) ; left . setSize ( lnode . sizeOfRange ( ) , rnode . sizeOfRange ( ) ) ; left . setRows ( lnode . rowsInRange ( ) , rnode . rowsInRange ( ) ) ; int ldiff = CONSISTENT ; boolean lreso = lhash ! = null & & rhash ! = null ; if ( lreso & & ! Arrays . equals ( lhash , rhash ) ) ldiff = differenceHelper ( ltree , rtree , diff , left ) ; else if ( ! lreso ) ldiff = FULLY_INCONSISTENT ; lnode = ltree . find ( right ) ; rnode = rtree . find ( right ) ; lhash = lnode . hash ( ) ; rhash = rnode . hash ( ) ; right . setSize ( lnode . sizeOfRange ( ) , rnode . sizeOfRange ( ) ) ; right . setRows ( lnode . rowsInRange ( ) , rnode . rowsInRange ( ) ) ; int rdiff = CONSISTENT ; boolean rreso = lhash ! = null & & rhash ! = null ; if ( rreso & & ! Arrays . equals ( lhash , rhash ) ) rdiff = differenceHelper ( ltree , rtree , diff , right ) ; else if ( ! rreso ) rdiff = FULLY_INCONSISTENT ; if ( ldiff = = FULLY_INCONSISTENT & & rdiff = = FULLY_INCONSISTENT ) { return FULLY_INCONSISTENT ; } else if ( ldiff = = FULLY_INCONSISTENT ) { diff . add ( left ) ; return PARTIALLY_INCONSISTENT ; } else if ( rdiff = = FULLY_INCONSISTENT ) { diff . add ( right ) ; return PARTIALLY_INCONSISTENT ; } return PARTIALLY_INCONSISTENT ; } public TreeRange get ( Token t ) { return getHelper ( root , fullRange . left , fullRange . right , ( byte ) <int> , t ) ; } TreeRange getHelper ( Hashable hashable , Token pleft , Token pright , byte depth , Token t ) { if ( hashable instanceof Leaf ) { return new TreeRange ( this , pleft , pright , depth , hashable ) ; } Inner node = ( Inner ) hashable ; if ( Range . contains ( pleft , node . token , t ) ) return getHelper ( node . lchild , pleft , node . token , inc ( depth ) , t ) ; return getHelper ( node . rchild , node . token , pright , inc ( depth ) , t ) ; } public void invalidate ( Token t ) { invalidateHelper ( root , fullRange . left , t ) ; } private void invalidateHelper ( Hashable hashable , Token pleft , Token t ) { hashable . hash ( null ) ; if ( hashable instanceof Leaf ) return ; Inner node = ( Inner ) hashable ; if ( Range . contains ( pleft , node . token , t ) ) invalidateHelper ( node . lchild , pleft , t ) ; else invalidateHelper ( node . rchild , node . token , t ) ; } public byte [ ] hash ( Range < Token > range ) { return find ( range ) . hash ( ) ; } private Hashable find ( Range < Token > range ) { try { return findHelper ( root , new Range < Token > ( fullRange . left , fullRange . right ) , range ) ; } catch ( StopRecursion e ) { return new Leaf ( ) ; } } private Hashable findHelper ( Hashable current , Range < Token > activeRange , Range < Token > find ) throws StopRecursion { if ( current instanceof Leaf ) { if ( ! find . contains ( activeRange ) ) throw new StopRecursion . BadRange ( ) ; return current ; } Inner node = ( Inner ) current ; Range < Token > leftRange = new Range < Token > ( activeRange . left , node . token ) ; Range < Token > rightRange = new Range < Token > ( node . token , activeRange . right ) ; if ( find . contains ( activeRange ) ) return node . calc ( ) ; if ( leftRange . contains ( find ) ) return findHelper ( node . lchild , leftRange , find ) ; else if ( rightRange . contains ( find ) ) return findHelper ( node . rchild , rightRange , find ) ; else throw new StopRecursion . BadRange ( ) ; } public boolean split ( Token t ) { if ( ! ( size < maxsize ) ) return false ; try { root = splitHelper ( root , fullRange . left , fullRange . right , ( byte ) <int> , t ) ; } catch ( StopRecursion . TooDeep e ) { return false ; } return true ; } private Hashable splitHelper ( Hashable hashable , Token pleft , Token pright , byte depth , Token t ) throws StopRecursion . TooDeep { if ( depth > = hashdepth ) throw new StopRecursion . TooDeep ( ) ; if ( hashable instanceof Leaf ) { Token midpoint = partitioner . midpoint ( pleft , pright ) ; if ( midpoint . equals ( pleft ) | | midpoint . equals ( pright ) ) throw new StopRecursion . TooDeep ( ) ; size + + ; return new Inner ( midpoint , new Leaf ( ) , new Leaf ( ) ) ; } Inner node = ( Inner ) hashable ; if ( Range . contains ( pleft , node . token , t ) ) node . lchild ( splitHelper ( node . lchild , pleft , node . token , inc ( depth ) , t ) ) ; else node . rchild ( splitHelper ( node . rchild , node . token , pright , inc ( depth ) , t ) ) ; return node ; } public TreeRangeIterator invalids ( ) { return new TreeRangeIterator ( this ) ; } public EstimatedHistogram histogramOfRowSizePerLeaf ( ) { HistogramBuilder histbuild = new HistogramBuilder ( ) ; for ( TreeRange range : new TreeRangeIterator ( this ) ) { histbuild . add ( range . hashable . sizeOfRange ) ; } return histbuild . buildWithStdevRangesAroundMean ( ) ; } public EstimatedHistogram histogramOfRowCountPerLeaf ( ) { HistogramBuilder histbuild = new HistogramBuilder ( ) ; for ( TreeRange range : new TreeRangeIterator ( this ) ) { histbuild . add ( range . hashable . rowsInRange ) ; } return histbuild . buildWithStdevRangesAroundMean ( ) ; } @Override public String toString ( ) { StringBuilder buff = new StringBuilder ( ) ; buff . append ( <str> ) ; root . toString ( buff , <int> ) ; buff . append ( <str> ) ; return buff . toString ( ) ; } public static class TreeDifference extends TreeRange { private static final long serialVersionUID = <int> ; private long sizeOnLeft ; private long sizeOnRight ; private long rowsOnLeft ; private long rowsOnRight ; void setSize ( long sizeOnLeft , long sizeOnRight ) { this . sizeOnLeft = sizeOnLeft ; this . sizeOnRight = sizeOnRight ; } void setRows ( long rowsOnLeft , long rowsOnRight ) { this . rowsOnLeft = rowsOnLeft ; this . rowsOnRight = rowsOnRight ; } public long sizeOnLeft ( ) { return sizeOnLeft ; } public long sizeOnRight ( ) { return sizeOnRight ; } public long rowsOnLeft ( ) { return rowsOnLeft ; } public long rowsOnRight ( ) { return rowsOnRight ; } public TreeDifference ( Token left , Token right , byte depth ) { super ( null , left , right , depth , null ) ; } public long totalRows ( ) { return rowsOnLeft + rowsOnRight ; } } public static class TreeRange extends Range < Token > { public static final long serialVersionUID = <int> ; private final MerkleTree tree ; public final byte depth ; private final Hashable hashable ; TreeRange ( MerkleTree tree , Token left , Token right , byte depth , Hashable hashable ) { super ( left , right ) ; this . tree = tree ; this . depth = depth ; this . hashable = hashable ; } public void hash ( byte [ ] hash ) { assert tree ! = null : <str> ; hashable . hash ( hash ) ; } public byte [ ] hash ( ) { return hashable . hash ( ) ; } public void addHash ( RowHash entry ) { assert tree ! = null : <str> ; assert hashable instanceof Leaf ; hashable . addHash ( entry . hash , entry . size ) ; } public void ensureHashInitialised ( ) { assert tree ! = null : <str> ; assert hashable instanceof Leaf ; if ( hashable . hash = = null ) hashable . hash = EMPTY_HASH ; } public void addAll ( Iterator < RowHash > entries ) { while ( entries . hasNext ( ) ) addHash ( entries . next ( ) ) ; } @Override public String toString ( ) { StringBuilder buff = new StringBuilder ( <str> ) ; buff . append ( super . toString ( ) ) . append ( <str> ) . append ( depth ) ; return buff . append ( <str> ) . toString ( ) ; } } public static class TreeRangeIterator extends AbstractIterator < TreeRange > implements Iterable < TreeRange > , PeekingIterator < TreeRange > { private final ArrayDeque < TreeRange > tovisit ; private final MerkleTree tree ; TreeRangeIterator ( MerkleTree tree ) { tovisit = new ArrayDeque < TreeRange > ( ) ; tovisit . add ( new TreeRange ( tree , tree . fullRange . left , tree . fullRange . right , ( byte ) <int> , tree . root ) ) ; this . tree = tree ; } public TreeRange computeNext ( ) { while ( ! tovisit . isEmpty ( ) ) { TreeRange active = tovisit . pop ( ) ; if ( active . hashable instanceof Leaf ) { if ( active . isWrapAround ( ) & & ! tovisit . isEmpty ( ) ) tovisit . addLast ( active ) ; return active ; } Inner node = ( Inner ) active . hashable ; TreeRange left = new TreeRange ( tree , active . left , node . token , inc ( active . depth ) , node . lchild ) ; TreeRange right = new TreeRange ( tree , node . token , active . right , inc ( active . depth ) , node . rchild ) ; if ( right . isWrapAround ( ) ) { tovisit . addLast ( left ) ; tovisit . addFirst ( right ) ; } else { tovisit . addFirst ( right ) ; tovisit . addFirst ( left ) ; } } return endOfData ( ) ; } public Iterator < TreeRange > iterator ( ) { return this ; } } static class Inner extends Hashable { public static final long serialVersionUID = <int> ; static final byte IDENT = <int> ; public final Token token ; private Hashable lchild ; private Hashable rchild ; private static final InnerSerializer serializer = new InnerSerializer ( ) ; public Inner ( Token token , Hashable lchild , Hashable rchild ) { super ( null ) ; this . token = token ; this . lchild = lchild ; this . rchild = rchild ; } public Hashable lchild ( ) { return lchild ; } public Hashable rchild ( ) { return rchild ; } public void lchild ( Hashable child ) { lchild = child ; } public void rchild ( Hashable child ) { rchild = child ; } Hashable calc ( ) { if ( hash = = null ) { Hashable lnode = lchild . calc ( ) ; Hashable rnode = rchild . calc ( ) ; hash ( lnode . hash , rnode . hash ) ; sizeOfRange = lnode . sizeOfRange + rnode . sizeOfRange ; rowsInRange = lnode . rowsInRange + rnode . rowsInRange ; } return this ; } public void toString ( StringBuilder buff , int maxdepth ) { buff . append ( <str> ) . append ( getClass ( ) . getSimpleName ( ) ) ; buff . append ( <str> ) . append ( token ) ; buff . append ( <str> ) . append ( Hashable . toString ( hash ( ) ) ) ; buff . append ( <str> ) ; if ( maxdepth < <int> ) { buff . append ( <str> ) ; } else { if ( lchild = = null ) buff . append ( <str> ) ; else lchild . toString ( buff , maxdepth - <int> ) ; buff . append ( <str> ) ; if ( rchild = = null ) buff . append ( <str> ) ; else rchild . toString ( buff , maxdepth - <int> ) ; } buff . append ( <str> ) ; } @Override public String toString ( ) { StringBuilder buff = new StringBuilder ( ) ; toString ( buff , <int> ) ; return buff . toString ( ) ; } private static class InnerSerializer implements IPartitionerDependentSerializer < Inner > { public void serialize ( Inner inner , DataOutputPlus out , int version ) throws IOException { if ( version < MessagingService . VERSION_30 ) { if ( inner . hash = = null ) out . writeInt ( - <int> ) ; else { out . writeInt ( inner . hash . length ) ; out . write ( inner . hash ) ; } } Token . serializer . serialize ( inner . token , out , version ) ; Hashable . serializer . serialize ( inner . lchild , out , version ) ; Hashable . serializer . serialize ( inner . rchild , out , version ) ; } public Inner deserialize ( DataInput in , IPartitioner p , int version ) throws IOException { if ( version < MessagingService . VERSION_30 ) { int hashLen = in . readInt ( ) ; byte [ ] hash = hashLen > = <int> ? new byte [ hashLen ] : null ; if ( hash ! = null ) in . readFully ( hash ) ; } Token token = Token . serializer . deserialize ( in , p , version ) ; Hashable lchild = Hashable . serializer . deserialize ( in , p , version ) ; Hashable rchild = Hashable . serializer . deserialize ( in , p , version ) ; return new Inner ( token , lchild , rchild ) ; } public long serializedSize ( Inner inner , int version ) { long size = <int> ; if ( version < MessagingService . VERSION_30 ) { size + = inner . hash = = null ? TypeSizes . sizeof ( - <int> ) : TypeSizes . sizeof ( inner . hash ( ) . length ) + inner . hash ( ) . length ; } size + = Token . serializer . serializedSize ( inner . token , version ) + Hashable . serializer . serializedSize ( inner . lchild , version ) + Hashable . serializer . serializedSize ( inner . rchild , version ) ; return size ; } } } static class Leaf extends Hashable { public static final long serialVersionUID = <int> ; static final byte IDENT = <int> ; private static final LeafSerializer serializer = new LeafSerializer ( ) ; public Leaf ( ) { super ( null ) ; } public Leaf ( byte [ ] hash ) { super ( hash ) ; } public void toString ( StringBuilder buff , int maxdepth ) { buff . append ( toString ( ) ) ; } @Override public String toString ( ) { return <str> + Hashable . toString ( hash ( ) ) + <str> ; } private static class LeafSerializer implements IPartitionerDependentSerializer < Leaf > { public void serialize ( Leaf leaf , DataOutputPlus out , int version ) throws IOException { if ( leaf . hash = = null ) { if ( version < MessagingService . VERSION_30 ) out . writeInt ( - <int> ) ; else out . writeByte ( - <int> ) ; } else { if ( version < MessagingService . VERSION_30 ) out . writeInt ( leaf . hash . length ) ; else out . writeByte ( leaf . hash . length ) ; out . write ( leaf . hash ) ; } } public Leaf deserialize ( DataInput in , IPartitioner p , int version ) throws IOException { int hashLen = version < MessagingService . VERSION_30 ? in . readInt ( ) : in . readByte ( ) ; byte [ ] hash = hashLen < <int> ? null : new byte [ hashLen ] ; if ( hash ! = null ) in . readFully ( hash ) ; return new Leaf ( hash ) ; } public long serializedSize ( Leaf leaf , int version ) { long size = version < MessagingService . VERSION_30 ? TypeSizes . sizeof ( <int> ) : <int> ; if ( leaf . hash ! = null ) { size + = leaf . hash ( ) . length ; } return size ; } } } public static class RowHash { public final Token token ; public final byte [ ] hash ; public final long size ; public RowHash ( Token token , byte [ ] hash , long size ) { this . token = token ; this . hash = hash ; this . size = size ; } @Override public String toString ( ) { return <str> + token + <str> + Hashable . toString ( hash ) + <str> + size + <str> ; } } static abstract class Hashable implements Serializable { private static final long serialVersionUID = <int> ; private static final IPartitionerDependentSerializer < Hashable > serializer = new HashableSerializer ( ) ; protected byte [ ] hash ; protected long sizeOfRange ; protected long rowsInRange ; protected Hashable ( byte [ ] hash ) { this . hash = hash ; } public byte [ ] hash ( ) { return hash ; } public long sizeOfRange ( ) { return sizeOfRange ; } public long rowsInRange ( ) { return rowsInRange ; } void hash ( byte [ ] hash ) { this . hash = hash ; } Hashable calc ( ) { return this ; } void hash ( byte [ ] lefthash , byte [ ] righthash ) { hash = binaryHash ( lefthash , righthash ) ; } void addHash ( byte [ ] righthash , long sizeOfRow ) { if ( hash = = null ) hash = righthash ; else hash = binaryHash ( hash , righthash ) ; this . sizeOfRange + = sizeOfRow ; this . rowsInRange + = <int> ; } static byte [ ] binaryHash ( final byte [ ] left , final byte [ ] right ) { return FBUtilities . xor ( left , right ) ; } public abstract void toString ( StringBuilder buff , int maxdepth ) ; public static String toString ( byte [ ] hash ) { if ( hash = = null ) return <str> ; return <str> + Hex . bytesToHex ( hash ) + <str> ; } private static class HashableSerializer implements IPartitionerDependentSerializer < Hashable > { public void serialize ( Hashable h , DataOutputPlus out , int version ) throws IOException { if ( h instanceof Inner ) { out . writeByte ( Inner . IDENT ) ; Inner . serializer . serialize ( ( Inner ) h , out , version ) ; } else if ( h instanceof Leaf ) { out . writeByte ( Leaf . IDENT ) ; Leaf . serializer . serialize ( ( Leaf ) h , out , version ) ; } else throw new IOException ( <str> + h . getClass ( ) . getCanonicalName ( ) ) ; } public Hashable deserialize ( DataInput in , IPartitioner p , int version ) throws IOException { byte ident = in . readByte ( ) ; if ( Inner . IDENT = = ident ) return Inner . serializer . deserialize ( in , p , version ) ; else if ( Leaf . IDENT = = ident ) return Leaf . serializer . deserialize ( in , p , version ) ; else throw new IOException ( <str> + ident ) ; } public long serializedSize ( Hashable h , int version ) { if ( h instanceof Inner ) return <int> + Inner . serializer . serializedSize ( ( Inner ) h , version ) ; else if ( h instanceof Leaf ) return <int> + Leaf . serializer . serializedSize ( ( Leaf ) h , version ) ; throw new AssertionError ( h . getClass ( ) ) ; } } } static abstract class StopRecursion extends Exception { static class BadRange extends StopRecursion { public BadRange ( ) { super ( ) ; } } static class InvalidHash extends StopRecursion { public InvalidHash ( ) { super ( ) ; } } static class TooDeep extends StopRecursion { public TooDeep ( ) { super ( ) ; } } } } 
