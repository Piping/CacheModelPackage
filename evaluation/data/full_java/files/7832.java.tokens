package org . elasticsearch . cluster . routing ; import static org . elasticsearch . test . ESTestCase . * ; public final class RandomShardRoutingMutator { private RandomShardRoutingMutator ( ) { } public static void randomChange ( ShardRouting shardRouting , String [ ] nodes ) { switch ( randomInt ( <int> ) ) { case <int> : if ( shardRouting . unassigned ( ) = = false ) { shardRouting . moveToUnassigned ( new UnassignedInfo ( randomReason ( ) , randomAsciiOfLength ( <int> ) ) ) ; } else if ( shardRouting . unassignedInfo ( ) ! = null ) { shardRouting . updateUnassignedInfo ( new UnassignedInfo ( randomReason ( ) , randomAsciiOfLength ( <int> ) ) ) ; } break ; case <int> : if ( shardRouting . unassigned ( ) ) { shardRouting . initialize ( randomFrom ( nodes ) , - <int> ) ; } break ; case <int> : if ( shardRouting . primary ( ) ) { shardRouting . moveFromPrimary ( ) ; } else { shardRouting . moveToPrimary ( ) ; } break ; case <int> : if ( shardRouting . initializing ( ) ) { shardRouting . moveToStarted ( ) ; } break ; } } public static UnassignedInfo . Reason randomReason ( ) { switch ( randomInt ( <int> ) ) { case <int> : return UnassignedInfo . Reason . INDEX_CREATED ; case <int> : return UnassignedInfo . Reason . CLUSTER_RECOVERED ; case <int> : return UnassignedInfo . Reason . INDEX_REOPENED ; case <int> : return UnassignedInfo . Reason . DANGLING_INDEX_IMPORTED ; case <int> : return UnassignedInfo . Reason . NEW_INDEX_RESTORED ; case <int> : return UnassignedInfo . Reason . EXISTING_INDEX_RESTORED ; case <int> : return UnassignedInfo . Reason . REPLICA_ADDED ; case <int> : return UnassignedInfo . Reason . ALLOCATION_FAILED ; case <int> : return UnassignedInfo . Reason . NODE_LEFT ; default : return UnassignedInfo . Reason . REROUTE_CANCELLED ; } } } 
