package com . google . common . reflect ; import static com . google . common . collect . Maps . immutableEntry ; import static com . google . common . truth . Truth . assertThat ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . testing . MapTestSuiteBuilder ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . testers . MapPutTester ; import com . google . common . reflect . ImmutableTypeToInstanceMapTest . TestTypeToInstanceMapGenerator ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . lang . reflect . Method ; import java . util . Map ; import java . util . Map . Entry ; public class MutableTypeToInstanceMapTest extends TestCase { @AndroidIncompatible public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( MutableTypeToInstanceMapTest . class ) ; Method remapTest = null ; try { remapTest = MapPutTester . class . getMethod ( <str> ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( ) ; } suite . addTest ( MapTestSuiteBuilder . using ( new TestTypeToInstanceMapGenerator ( ) { @Override @SuppressWarnings ( <str> ) public Map < TypeToken , Object > create ( Object . . . elements ) { MutableTypeToInstanceMap < Object > map = new MutableTypeToInstanceMap < Object > ( ) ; for ( Object object : elements ) { Entry < TypeToken , Object > entry = ( Entry < TypeToken , Object > ) object ; map . putInstance ( entry . getKey ( ) , entry . getValue ( ) ) ; } return ( Map ) map ; } } ) . named ( <str> ) . withFeatures ( MapFeature . SUPPORTS_REMOVE , MapFeature . RESTRICTS_KEYS , MapFeature . ALLOWS_NULL_VALUES , CollectionFeature . SUPPORTS_ITERATOR_REMOVE , CollectionSize . ANY , MapFeature . ALLOWS_ANY_NULL_QUERIES ) . suppressing ( remapTest ) . createTestSuite ( ) ) ; return suite ; } private TypeToInstanceMap < Object > map ; @Override protected void setUp ( ) throws Exception { map = new MutableTypeToInstanceMap < Object > ( ) ; } public void testPutThrows ( ) { try { map . put ( TypeToken . of ( Integer . class ) , new Integer ( <int> ) ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testPutAllThrows ( ) { try { map . putAll ( ImmutableMap . of ( TypeToken . of ( Integer . class ) , new Integer ( <int> ) ) ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testEntrySetMutationThrows ( ) { map . putInstance ( String . class , <str> ) ; assertEquals ( TypeToken . of ( String . class ) , map . entrySet ( ) . iterator ( ) . next ( ) . getKey ( ) ) ; assertEquals ( <str> , map . entrySet ( ) . iterator ( ) . next ( ) . getValue ( ) ) ; try { map . entrySet ( ) . iterator ( ) . next ( ) . setValue ( <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testEntrySetToArrayMutationThrows ( ) { map . putInstance ( String . class , <str> ) ; @SuppressWarnings ( <str> ) Entry < Object , Object > entry = ( Entry < Object , Object > ) map . entrySet ( ) . toArray ( ) [ <int> ] ; assertEquals ( TypeToken . of ( String . class ) , entry . getKey ( ) ) ; assertEquals ( <str> , entry . getValue ( ) ) ; try { entry . setValue ( <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testEntrySetToTypedArrayMutationThrows ( ) { map . putInstance ( String . class , <str> ) ; @SuppressWarnings ( <str> ) Entry < Object , Object > entry = map . entrySet ( ) . toArray ( new Entry [ <int> ] ) [ <int> ] ; assertEquals ( TypeToken . of ( String . class ) , entry . getKey ( ) ) ; assertEquals ( <str> , entry . getValue ( ) ) ; try { entry . setValue ( <int> ) ; fail ( ) ; } catch ( UnsupportedOperationException expected ) { } } public void testPutAndGetInstance ( ) { assertNull ( map . putInstance ( Integer . class , new Integer ( <int> ) ) ) ; Integer oldValue = map . putInstance ( Integer . class , new Integer ( <int> ) ) ; assertEquals ( <int> , ( int ) oldValue ) ; Integer newValue = map . getInstance ( Integer . class ) ; assertEquals ( <int> , ( int ) newValue ) ; assertEquals ( <int> , ( int ) map . getInstance ( TypeToken . of ( Integer . class ) ) ) ; } public void testNull ( ) { try { map . putInstance ( ( TypeToken ) null , new Integer ( <int> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } map . putInstance ( Integer . class , null ) ; assertTrue ( map . containsKey ( TypeToken . of ( Integer . class ) ) ) ; assertTrue ( map . entrySet ( ) . contains ( immutableEntry ( TypeToken . of ( Integer . class ) , null ) ) ) ; assertNull ( map . get ( TypeToken . of ( Integer . class ) ) ) ; assertNull ( map . getInstance ( Integer . class ) ) ; map . putInstance ( Long . class , null ) ; assertTrue ( map . containsKey ( TypeToken . of ( Long . class ) ) ) ; assertTrue ( map . entrySet ( ) . contains ( immutableEntry ( TypeToken . of ( Long . class ) , null ) ) ) ; assertNull ( map . get ( TypeToken . of ( Long . class ) ) ) ; assertNull ( map . getInstance ( Long . class ) ) ; } public void testPrimitiveAndWrapper ( ) { assertNull ( map . getInstance ( int . class ) ) ; assertNull ( map . getInstance ( Integer . class ) ) ; assertNull ( map . putInstance ( int . class , <int> ) ) ; assertNull ( map . putInstance ( Integer . class , <int> ) ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( <int> , ( int ) map . getInstance ( int . class ) ) ; assertEquals ( <int> , ( int ) map . getInstance ( Integer . class ) ) ; assertEquals ( <int> , ( int ) map . putInstance ( int . class , null ) ) ; assertEquals ( <int> , ( int ) map . putInstance ( Integer . class , null ) ) ; assertNull ( map . getInstance ( int . class ) ) ; assertNull ( map . getInstance ( Integer . class ) ) ; assertEquals ( <int> , map . size ( ) ) ; } public void testParameterizedType ( ) { TypeToken < ImmutableList < Integer > > type = new TypeToken < ImmutableList < Integer > > ( ) { } ; map . putInstance ( type , ImmutableList . of ( <int> ) ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( ImmutableList . of ( <int> ) , map . getInstance ( type ) ) ; } public void testGenericArrayType ( ) { @SuppressWarnings ( <str> ) ImmutableList < Integer > [ ] array = new ImmutableList [ ] { ImmutableList . of ( <int> ) } ; TypeToken < ImmutableList < Integer > [ ] > type = new TypeToken < ImmutableList < Integer > [ ] > ( ) { } ; map . putInstance ( type , array ) ; assertEquals ( <int> , map . size ( ) ) ; assertThat ( map . getInstance ( type ) ) . asList ( ) . containsExactly ( array [ <int> ] ) ; } public void testWildcardType ( ) { TypeToken < ImmutableList < ? > > type = new TypeToken < ImmutableList < ? > > ( ) { } ; map . putInstance ( type , ImmutableList . of ( <int> ) ) ; assertEquals ( <int> , map . size ( ) ) ; assertEquals ( ImmutableList . of ( <int> ) , map . getInstance ( type ) ) ; } public void testGetInstance_withTypeVariable ( ) { try { map . getInstance ( this . < Number > anyIterableType ( ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testPutInstance_withTypeVariable ( ) { try { map . putInstance ( this . < Integer > anyIterableType ( ) , ImmutableList . of ( <int> ) ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } private < T > TypeToken < Iterable < T > > anyIterableType ( ) { return new TypeToken < Iterable < T > > ( ) { } ; } } 
