package org . eclipse . debug . tests . viewer . model ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import java . util . TreeSet ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . jobs . IJobChangeEvent ; import org . eclipse . core . runtime . jobs . IJobChangeListener ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . internal . ui . viewers . model . ElementCompareRequest ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . ILabelUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenCountUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IHasChildrenUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ILabelUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelChangedListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelProxy ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IStateUpdateListener ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdate ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IViewerUpdateListener ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . jface . viewers . ViewerFilter ; import org . junit . Assert ; public class TestModelUpdatesListener implements IViewerUpdateListener , ILabelUpdateListener , IModelChangedListener , ITestModelUpdatesListenerConstants , IStateUpdateListener , IJobChangeListener { public static final ViewerFilter [ ] EMPTY_FILTER_ARRAY = new ViewerFilter [ <int> ] ; private final ITreeModelViewer fViewer ; private IStatus fJobError ; private boolean fFailOnRedundantUpdates ; private boolean fFailOnRedundantLabelUpdates ; private Set < IViewerUpdate > fRedundantUpdates = new HashSet < IViewerUpdate > ( ) ; private Set < ILabelUpdate > fRedundantLabelUpdates = new HashSet < ILabelUpdate > ( ) ; private Set < TreePath > fRedundantHasChildrenUpdateExceptions = new HashSet < TreePath > ( ) ; private Set < TreePath > fRedundantChildCountUpdateExceptions = new HashSet < TreePath > ( ) ; private Set < TreePath > fRedundantChildrenUpdateExceptions = new HashSet < TreePath > ( ) ; private Set < TreePath > fRedundantLabelUpdateExceptions = new HashSet < TreePath > ( ) ; private boolean fFailOnMultipleModelUpdateSequences ; private boolean fFailOnMultipleLabelUpdateSequences ; private Set < TreePath > fHasChildrenUpdatesScheduled = new HashSet < TreePath > ( ) ; private Set < IViewerUpdate > fHasChildrenUpdatesRunning = new HashSet < IViewerUpdate > ( ) ; private Set < IViewerUpdate > fHasChildrenUpdatesCompleted = new HashSet < IViewerUpdate > ( ) ; private Map < TreePath , Set < Integer > > fChildrenUpdatesScheduled = new HashMap < TreePath , Set < Integer > > ( ) ; private Set < IViewerUpdate > fChildrenUpdatesRunning = new HashSet < IViewerUpdate > ( ) ; private Set < IViewerUpdate > fChildrenUpdatesCompleted = new HashSet < IViewerUpdate > ( ) ; private Set < TreePath > fChildCountUpdatesScheduled = new HashSet < TreePath > ( ) ; private Set < IViewerUpdate > fChildCountUpdatesRunning = new HashSet < IViewerUpdate > ( ) ; private Set < IViewerUpdate > fChildCountUpdatesCompleted = new HashSet < IViewerUpdate > ( ) ; private Set < TreePath > fLabelUpdates = new HashSet < TreePath > ( ) ; private Set < ILabelUpdate > fLabelUpdatesRunning = new HashSet < ILabelUpdate > ( ) ; private Set < ILabelUpdate > fLabelUpdatesCompleted = new HashSet < ILabelUpdate > ( ) ; private Set < TestModel > fProxyModels = new HashSet < TestModel > ( ) ; private Set < TreePath > fStateUpdates = new HashSet < TreePath > ( ) ; private int fViewerUpdatesStarted = <int> ; private int fViewerUpdatesComplete = <int> ; private int fViewerUpdatesStartedAtReset ; private int fViewerUpdatesCompleteAtReset ; private int fLabelUpdatesStarted = <int> ; private int fLabelUpdatesComplete = <int> ; private int fLabelUpdatesStartedAtReset ; private int fLabelUpdatesCompleteAtReset ; private boolean fModelChangedComplete ; private boolean fStateSaveStarted ; private boolean fStateSaveComplete ; private boolean fStateRestoreStarted ; private boolean fStateRestoreComplete ; private int fViewerUpdatesCounter ; private int fLabelUpdatesCounter ; private int fTimeoutInterval = <int> ; private long fTimeoutTime ; private boolean fExpectRestoreAfterSaveComplete ; private RuntimeException fFailExpectation ; public TestModelUpdatesListener ( ITreeModelViewer viewer , boolean failOnRedundantUpdates , boolean failOnMultipleModelUpdateSequences ) { this ( viewer ) ; setFailOnRedundantUpdates ( failOnRedundantUpdates ) ; setFailOnMultipleModelUpdateSequences ( failOnMultipleModelUpdateSequences ) ; } public TestModelUpdatesListener ( ITreeModelViewer viewer ) { fViewer = viewer ; Job . getJobManager ( ) . addJobChangeListener ( this ) ; fViewer . addLabelUpdateListener ( this ) ; fViewer . addModelChangedListener ( this ) ; fViewer . addStateUpdateListener ( this ) ; fViewer . addViewerUpdateListener ( this ) ; } public void dispose ( ) { Job . getJobManager ( ) . removeJobChangeListener ( this ) ; fViewer . removeLabelUpdateListener ( this ) ; fViewer . removeModelChangedListener ( this ) ; fViewer . removeStateUpdateListener ( this ) ; fViewer . removeViewerUpdateListener ( this ) ; } @Override public void aboutToRun ( IJobChangeEvent event ) { } @Override public void awake ( IJobChangeEvent event ) { } @Override public void running ( IJobChangeEvent event ) { } @Override public void scheduled ( IJobChangeEvent event ) { } @Override public void sleeping ( IJobChangeEvent event ) { } @Override public void done ( IJobChangeEvent event ) { IStatus result = event . getJob ( ) . getResult ( ) ; if ( result ! = null & & result . getSeverity ( ) = = IStatus . ERROR ) { fJobError = result ; } } public void setFailOnRedundantUpdates ( boolean failOnRedundantUpdates ) { fFailOnRedundantUpdates = failOnRedundantUpdates ; } public void setFailOnRedundantLabelUpdates ( boolean failOnRedundantLabelUpdates ) { fFailOnRedundantLabelUpdates = failOnRedundantLabelUpdates ; } public void setFailOnMultipleModelUpdateSequences ( boolean failOnMultipleLabelUpdateSequences ) { fFailOnMultipleModelUpdateSequences = failOnMultipleLabelUpdateSequences ; } public void setFailOnMultipleLabelUpdateSequences ( boolean failOnMultipleLabelUpdateSequences ) { fFailOnMultipleLabelUpdateSequences = failOnMultipleLabelUpdateSequences ; } public void expectRestoreAfterSaveComplete ( ) { fExpectRestoreAfterSaveComplete = true ; } public void setTimeoutInterval ( int milis ) { fTimeoutInterval = milis ; } public void reset ( TreePath path , TestElement element , int levels , boolean failOnRedundantUpdates , boolean failOnMultipleUpdateSequences ) { reset ( path , element , EMPTY_FILTER_ARRAY , levels , failOnRedundantUpdates , failOnMultipleUpdateSequences ) ; } public void reset ( TreePath path , TestElement element , ViewerFilter [ ] filters , int levels , boolean failOnRedundantUpdates , boolean failOnMultipleUpdateSequences ) { reset ( ) ; addUpdates ( path , element , filters , levels ) ; addProxies ( element ) ; setFailOnRedundantUpdates ( failOnRedundantUpdates ) ; setFailOnMultipleModelUpdateSequences ( failOnMultipleUpdateSequences ) ; setFailOnMultipleLabelUpdateSequences ( false ) ; } public void reset ( boolean failOnRedundantUpdates , boolean failOnMultipleUpdateSequences ) { reset ( ) ; setFailOnRedundantUpdates ( failOnRedundantUpdates ) ; setFailOnMultipleModelUpdateSequences ( failOnMultipleUpdateSequences ) ; setFailOnMultipleLabelUpdateSequences ( false ) ; } public void reset ( ) { fJobError = null ; fFailExpectation = null ; fRedundantUpdates . clear ( ) ; fRedundantLabelUpdates . clear ( ) ; fRedundantHasChildrenUpdateExceptions . clear ( ) ; fRedundantChildCountUpdateExceptions . clear ( ) ; fRedundantChildrenUpdateExceptions . clear ( ) ; fRedundantLabelUpdateExceptions . clear ( ) ; fHasChildrenUpdatesScheduled . clear ( ) ; fHasChildrenUpdatesRunning . clear ( ) ; fHasChildrenUpdatesCompleted . clear ( ) ; fChildrenUpdatesScheduled . clear ( ) ; fChildrenUpdatesRunning . clear ( ) ; fChildrenUpdatesCompleted . clear ( ) ; fChildCountUpdatesScheduled . clear ( ) ; fChildCountUpdatesRunning . clear ( ) ; fChildCountUpdatesCompleted . clear ( ) ; fLabelUpdates . clear ( ) ; fLabelUpdatesRunning . clear ( ) ; fLabelUpdatesCompleted . clear ( ) ; fProxyModels . clear ( ) ; fViewerUpdatesStartedAtReset = fViewerUpdatesStarted ; fViewerUpdatesCompleteAtReset = fViewerUpdatesComplete ; fLabelUpdatesStartedAtReset = fLabelUpdatesStarted ; fLabelUpdatesCompleteAtReset = fLabelUpdatesComplete ; fStateUpdates . clear ( ) ; fStateSaveStarted = false ; fStateSaveComplete = false ; fStateRestoreStarted = false ; fStateRestoreComplete = false ; fExpectRestoreAfterSaveComplete = false ; fTimeoutTime = System . currentTimeMillis ( ) + fTimeoutInterval ; resetModelChanged ( ) ; } public void resetModelChanged ( ) { fModelChangedComplete = false ; } public void addHasChildrenUpdate ( TreePath path ) { fHasChildrenUpdatesScheduled . add ( path ) ; } public void removeHasChildrenUpdate ( TreePath path ) { fHasChildrenUpdatesScheduled . remove ( path ) ; } public void addChildreCountUpdate ( TreePath path ) { fChildCountUpdatesScheduled . add ( path ) ; } public void removeChildreCountUpdate ( TreePath path ) { fChildCountUpdatesScheduled . remove ( path ) ; } public void addChildreUpdate ( TreePath path , int index ) { Set < Integer > childrenIndexes = fChildrenUpdatesScheduled . get ( path ) ; if ( childrenIndexes = = null ) { childrenIndexes = new TreeSet < Integer > ( ) ; fChildrenUpdatesScheduled . put ( path , childrenIndexes ) ; } childrenIndexes . add ( Integer . valueOf ( index ) ) ; } public void removeChildrenUpdate ( TreePath path , int index ) { Set < ? > childrenIndexes = fChildrenUpdatesScheduled . get ( path ) ; if ( childrenIndexes ! = null ) { childrenIndexes . remove ( Integer . valueOf ( index ) ) ; if ( childrenIndexes . isEmpty ( ) ) { fChildrenUpdatesScheduled . remove ( path ) ; } } } public void addLabelUpdate ( TreePath path ) { fLabelUpdates . add ( path ) ; } public void removeLabelUpdate ( TreePath path ) { fLabelUpdates . remove ( path ) ; } public void addUpdates ( TreePath path , TestElement element , int levels ) { addUpdates ( null , path , element , EMPTY_FILTER_ARRAY , levels , ALL_UPDATES_COMPLETE ) ; } public void addUpdates ( TreePath path , TestElement element , ViewerFilter [ ] filters , int levels ) { addUpdates ( null , path , element , filters , levels , ALL_UPDATES_COMPLETE ) ; } public void addStateUpdates ( IInternalTreeModelViewer viewer , TreePath path , TestElement element ) { addUpdates ( viewer , path , element , - <int> , STATE_UPDATES ) ; } public void addStateUpdates ( IInternalTreeModelViewer viewer , IModelDelta pendingDelta , int deltaFlags ) { TreePath treePath = getViewerTreePath ( pendingDelta ) ; if ( ! TreePath . EMPTY . equals ( treePath ) & & ( pendingDelta . getFlags ( ) & deltaFlags ) ! = <int> ) { addUpdates ( viewer , treePath , ( TestElement ) treePath . getLastSegment ( ) , <int> , STATE_UPDATES ) ; } IModelDelta [ ] childDeltas = pendingDelta . getChildDeltas ( ) ; for ( int i = <int> ; i < childDeltas . length ; i + + ) { addStateUpdates ( viewer , childDeltas [ i ] , deltaFlags ) ; } } public void addRedundantExceptionHasChildren ( TreePath path ) { fRedundantHasChildrenUpdateExceptions . add ( path ) ; } public void addRedundantExceptionChildCount ( TreePath path ) { fRedundantChildCountUpdateExceptions . add ( path ) ; } public void addRedundantExceptionChildren ( TreePath path ) { fRedundantChildrenUpdateExceptions . add ( path ) ; } public void addRedundantExceptionLabel ( TreePath path ) { fRedundantLabelUpdateExceptions . add ( path ) ; } public boolean checkCoalesced ( TreePath path , int offset , int length ) { for ( Iterator < IViewerUpdate > itr = fChildrenUpdatesCompleted . iterator ( ) ; itr . hasNext ( ) ; ) { IChildrenUpdate update = ( IChildrenUpdate ) itr . next ( ) ; if ( path . equals ( update . getElementPath ( ) ) & & offset = = update . getOffset ( ) & & length = = update . getLength ( ) ) { return true ; } } return false ; } public Set < IViewerUpdate > getHasChildrenUpdatesCompleted ( ) { return fHasChildrenUpdatesCompleted ; } public Set < IViewerUpdate > getChildCountUpdatesCompleted ( ) { return fChildCountUpdatesCompleted ; } public Set < IViewerUpdate > getChildrenUpdatesCompleted ( ) { return fChildrenUpdatesCompleted ; } private TreePath getViewerTreePath ( IModelDelta node ) { ArrayList < Object > list = new ArrayList < Object > ( ) ; IModelDelta parentDelta = node . getParentDelta ( ) ; while ( parentDelta ! = null ) { list . add ( <int> , node . getElement ( ) ) ; node = parentDelta ; parentDelta = node . getParentDelta ( ) ; } return new TreePath ( list . toArray ( ) ) ; } public void addUpdates ( TreePath path , TestElement element , int levels , int flags ) { addUpdates ( null , path , element , levels , flags ) ; } public void addUpdates ( IInternalTreeModelViewer viewer , TreePath path , TestElement element , int levels , int flags ) { addUpdates ( viewer , path , element , EMPTY_FILTER_ARRAY , levels , flags ) ; } public static boolean isFiltered ( Object element , ViewerFilter [ ] filters ) { for ( int i = <int> ; i < filters . length ; i + + ) { if ( ! filters [ i ] . select ( null , null , element ) ) { return true ; } } return false ; } public void addUpdates ( IInternalTreeModelViewer viewer , TreePath path , TestElement element , ViewerFilter [ ] filters , int levels , int flags ) { if ( isFiltered ( path . getLastSegment ( ) , filters ) ) { return ; } if ( ! path . equals ( TreePath . EMPTY ) ) { if ( ( flags & LABEL_UPDATES ) ! = <int> ) { fLabelUpdates . add ( path ) ; } if ( ( flags & HAS_CHILDREN_UPDATES ) ! = <int> ) { fHasChildrenUpdatesScheduled . add ( path ) ; } if ( ( flags & STATE_UPDATES ) ! = <int> ) { fStateUpdates . add ( path ) ; } } if ( levels - - ! = <int> ) { TestElement [ ] children = element . getChildren ( ) ; if ( children . length > <int> & & ( viewer = = null | | path . getSegmentCount ( ) = = <int> | | viewer . getExpandedState ( path ) ) ) { if ( ( flags & CHILD_COUNT_UPDATES ) ! = <int> ) { fChildCountUpdatesScheduled . add ( path ) ; } if ( ( flags & CHILDREN_UPDATES ) ! = <int> ) { Set < Integer > childrenIndexes = new HashSet < Integer > ( ) ; for ( int i = <int> ; i < children . length ; i + + ) { if ( ! isFiltered ( children [ i ] , filters ) ) { childrenIndexes . add ( Integer . valueOf ( i ) ) ; } } fChildrenUpdatesScheduled . put ( path , childrenIndexes ) ; } for ( int i = <int> ; i < children . length ; i + + ) { addUpdates ( viewer , path . createChildPath ( children [ i ] ) , children [ i ] , filters , levels , flags ) ; } } } } private void addProxies ( TestElement element ) { TestModel model = element . getModel ( ) ; if ( model . getModelProxy ( ) = = null ) { fProxyModels . add ( element . getModel ( ) ) ; } TestElement [ ] children = element . getChildren ( ) ; for ( int i = <int> ; i < children . length ; i + + ) { addProxies ( children [ i ] ) ; } } public boolean isFinished ( ) { return isFinished ( ALL_UPDATES_COMPLETE ) ; } public boolean isTimedOut ( ) { return fTimeoutInterval > <int> & & fTimeoutTime < System . currentTimeMillis ( ) ; } public boolean isFinished ( int flags ) { if ( isTimedOut ( ) ) { throw new RuntimeException ( <str> + toString ( flags ) ) ; } if ( fFailExpectation ! = null ) { throw fFailExpectation ; } if ( fJobError ! = null ) { throw new RuntimeException ( <str> + fJobError ) ; } if ( fFailOnRedundantUpdates & & ! fRedundantUpdates . isEmpty ( ) ) { Assert . fail ( <str> + fRedundantUpdates . toString ( ) ) ; } if ( fFailOnRedundantLabelUpdates & & ! fRedundantLabelUpdates . isEmpty ( ) ) { Assert . fail ( <str> + fRedundantLabelUpdates . toString ( ) ) ; } if ( fFailOnMultipleLabelUpdateSequences & & fLabelUpdatesComplete > ( fLabelUpdatesCompleteAtReset + <int> ) ) { Assert . fail ( <str> ) ; } if ( fFailOnMultipleModelUpdateSequences & & fViewerUpdatesComplete > ( fViewerUpdatesCompleteAtReset + <int> ) ) { Assert . fail ( <str> ) ; } if ( ( flags & LABEL_SEQUENCE_COMPLETE ) ! = <int> ) { if ( fLabelUpdatesComplete = = fLabelUpdatesCompleteAtReset | | fLabelUpdatesComplete ! = fLabelUpdatesStarted ) { return false ; } } if ( ( flags & LABEL_SEQUENCE_STARTED ) ! = <int> ) { if ( fLabelUpdatesStarted = = fLabelUpdatesStartedAtReset ) { return false ; } } if ( ( flags & LABEL_UPDATES ) ! = <int> ) { if ( ! fLabelUpdates . isEmpty ( ) ) { return false ; } } if ( ( flags & CONTENT_SEQUENCE_STARTED ) ! = <int> ) { if ( fViewerUpdatesStarted = = fViewerUpdatesStartedAtReset ) { return false ; } } if ( ( flags & CONTENT_SEQUENCE_COMPLETE ) ! = <int> ) { if ( fViewerUpdatesComplete = = fViewerUpdatesCompleteAtReset | | fViewerUpdatesStarted ! = fViewerUpdatesComplete ) { return false ; } } if ( ( flags & HAS_CHILDREN_UPDATES_STARTED ) ! = <int> ) { if ( fHasChildrenUpdatesRunning . isEmpty ( ) & & fHasChildrenUpdatesCompleted . isEmpty ( ) ) { return false ; } } if ( ( flags & HAS_CHILDREN_UPDATES ) ! = <int> ) { if ( ! fHasChildrenUpdatesScheduled . isEmpty ( ) ) { return false ; } } if ( ( flags & CHILD_COUNT_UPDATES_STARTED ) ! = <int> ) { if ( fChildCountUpdatesRunning . isEmpty ( ) & & fChildCountUpdatesCompleted . isEmpty ( ) ) { return false ; } } if ( ( flags & CHILD_COUNT_UPDATES ) ! = <int> ) { if ( ! fChildCountUpdatesScheduled . isEmpty ( ) ) { return false ; } } if ( ( flags & CHILDREN_UPDATES_STARTED ) ! = <int> ) { if ( fChildrenUpdatesRunning . isEmpty ( ) & & fChildrenUpdatesCompleted . isEmpty ( ) ) { return false ; } } if ( ( flags & CHILDREN_UPDATES_RUNNING ) ! = <int> ) { if ( ! isFinishedChildrenRunning ( ) ) { return false ; } } if ( ( flags & CHILDREN_UPDATES ) ! = <int> ) { if ( ! fChildrenUpdatesScheduled . isEmpty ( ) ) { return false ; } } if ( ( flags & MODEL_CHANGED_COMPLETE ) ! = <int> ) { if ( ! fModelChangedComplete ) { return false ; } } if ( ( flags & STATE_SAVE_COMPLETE ) ! = <int> ) { if ( ! fStateSaveComplete ) { return false ; } } if ( ( flags & STATE_SAVE_STARTED ) ! = <int> ) { if ( ! fStateSaveStarted ) { return false ; } } if ( ( flags & STATE_RESTORE_COMPLETE ) ! = <int> ) { if ( ! fStateRestoreComplete ) { return false ; } } if ( ( flags & STATE_RESTORE_STARTED ) ! = <int> ) { if ( ! fStateRestoreStarted ) { return false ; } } if ( ( flags & STATE_UPDATES ) ! = <int> ) { if ( ! fStateUpdates . isEmpty ( ) ) { return false ; } } if ( ( flags & MODEL_PROXIES_INSTALLED ) ! = <int> ) { if ( fProxyModels . size ( ) ! = <int> ) { return false ; } } if ( ( flags & VIEWER_UPDATES_RUNNING ) ! = <int> ) { if ( fViewerUpdatesCounter ! = <int> ) { return false ; } } if ( ( flags & LABEL_UPDATES_RUNNING ) ! = <int> ) { if ( fLabelUpdatesCounter ! = <int> ) { return false ; } } return true ; } private boolean isFinishedChildrenRunning ( ) { int scheduledCount = <int> ; for ( Iterator < Set < Integer > > itr = fChildrenUpdatesScheduled . values ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { scheduledCount + = ( ( Set < ? > ) itr . next ( ) ) . size ( ) ; } int runningCount = <int> ; for ( Iterator < IViewerUpdate > itr = fChildrenUpdatesRunning . iterator ( ) ; itr . hasNext ( ) ; ) { IChildrenUpdate update = ( ( IChildrenUpdate ) itr . next ( ) ) ; Set < ? > set = fChildrenUpdatesScheduled . get ( update . getElementPath ( ) ) ; for ( int i = update . getOffset ( ) ; set ! = null & & i < update . getOffset ( ) + update . getLength ( ) ; i + + ) { if ( set . contains ( Integer . valueOf ( i ) ) ) { runningCount + + ; } } } for ( Iterator < IViewerUpdate > itr = fChildrenUpdatesCompleted . iterator ( ) ; itr . hasNext ( ) ; ) { IChildrenUpdate update = ( ( IChildrenUpdate ) itr . next ( ) ) ; Set < ? > set = fChildrenUpdatesScheduled . get ( update . getElementPath ( ) ) ; for ( int i = update . getOffset ( ) ; set ! = null & & i < update . getOffset ( ) + update . getLength ( ) ; i + + ) { if ( set . contains ( Integer . valueOf ( i ) ) ) { runningCount + + ; } } } return scheduledCount = = runningCount ; } @Override public void updateStarted ( IViewerUpdate update ) { synchronized ( this ) { fViewerUpdatesCounter + + ; if ( update instanceof IHasChildrenUpdate ) { fHasChildrenUpdatesRunning . add ( update ) ; } if ( update instanceof IChildrenCountUpdate ) { fChildCountUpdatesRunning . add ( update ) ; } else if ( update instanceof IChildrenUpdate ) { fChildrenUpdatesRunning . add ( update ) ; } } } @Override public void updateComplete ( IViewerUpdate update ) { synchronized ( this ) { fViewerUpdatesCounter - - ; } if ( ! update . isCanceled ( ) ) { TreePath updatePath = update . getElementPath ( ) ; if ( update instanceof IHasChildrenUpdate ) { fHasChildrenUpdatesRunning . remove ( update ) ; fHasChildrenUpdatesCompleted . add ( update ) ; if ( ! fHasChildrenUpdatesScheduled . remove ( updatePath ) & & fFailOnRedundantUpdates & & fRedundantHasChildrenUpdateExceptions . contains ( updatePath ) ) { fRedundantUpdates . add ( update ) ; } } if ( update instanceof IChildrenCountUpdate ) { fChildCountUpdatesRunning . remove ( update ) ; fChildCountUpdatesCompleted . add ( update ) ; if ( ! fChildCountUpdatesScheduled . remove ( updatePath ) & & fFailOnRedundantUpdates & & ! fRedundantChildCountUpdateExceptions . contains ( updatePath ) ) { fRedundantUpdates . add ( update ) ; } } else if ( update instanceof IChildrenUpdate ) { fChildrenUpdatesRunning . remove ( update ) ; fChildrenUpdatesCompleted . add ( update ) ; int start = ( ( IChildrenUpdate ) update ) . getOffset ( ) ; int end = start + ( ( IChildrenUpdate ) update ) . getLength ( ) ; Set < ? > childrenIndexes = fChildrenUpdatesScheduled . get ( updatePath ) ; if ( childrenIndexes ! = null ) { for ( int i = start ; i < end ; i + + ) { childrenIndexes . remove ( Integer . valueOf ( i ) ) ; } if ( childrenIndexes . isEmpty ( ) ) { fChildrenUpdatesScheduled . remove ( updatePath ) ; } } else if ( fFailOnRedundantUpdates & & fRedundantChildrenUpdateExceptions . contains ( updatePath ) ) { fRedundantUpdates . add ( update ) ; } } } } @Override public void viewerUpdatesBegin ( ) { if ( fViewerUpdatesStarted > fViewerUpdatesComplete ) { fFailExpectation = new RuntimeException ( <str> ) ; } fViewerUpdatesStarted + + ; } @Override public void viewerUpdatesComplete ( ) { if ( fViewerUpdatesStarted < = fViewerUpdatesComplete ) { fFailExpectation = new RuntimeException ( <str> ) ; } fViewerUpdatesComplete + + ; } @Override public void labelUpdateComplete ( ILabelUpdate update ) { fLabelUpdatesRunning . remove ( update ) ; fLabelUpdatesCompleted . add ( update ) ; fLabelUpdatesCounter - - ; if ( ! fLabelUpdates . remove ( update . getElementPath ( ) ) & & fFailOnRedundantLabelUpdates & & ! fRedundantLabelUpdateExceptions . contains ( update . getElementPath ( ) ) ) { fRedundantLabelUpdates . add ( update ) ; Assert . fail ( <str> + update ) ; } } @Override public void labelUpdateStarted ( ILabelUpdate update ) { fLabelUpdatesRunning . add ( update ) ; fLabelUpdatesCounter + + ; } @Override public void labelUpdatesBegin ( ) { if ( fLabelUpdatesStarted > fLabelUpdatesComplete ) { fFailExpectation = new RuntimeException ( <str> ) ; } fLabelUpdatesStarted + + ; } @Override public void labelUpdatesComplete ( ) { if ( fLabelUpdatesStarted < = fLabelUpdatesComplete ) { fFailExpectation = new RuntimeException ( <str> ) ; } fLabelUpdatesComplete + + ; } @Override public void modelChanged ( IModelDelta delta , IModelProxy proxy ) { fModelChangedComplete = true ; for ( Iterator < TestModel > itr = fProxyModels . iterator ( ) ; itr . hasNext ( ) ; ) { TestModel model = itr . next ( ) ; if ( model . getModelProxy ( ) = = proxy ) { itr . remove ( ) ; break ; } } } @Override public void stateRestoreUpdatesBegin ( Object input ) { if ( fExpectRestoreAfterSaveComplete & & ! fStateSaveComplete ) { fFailExpectation = new RuntimeException ( <str> ) ; } fStateRestoreStarted = true ; } @Override public void stateRestoreUpdatesComplete ( Object input ) { Assert . assertFalse ( <str> , fStateRestoreComplete ) ; fStateRestoreComplete = true ; } @Override public void stateSaveUpdatesBegin ( Object input ) { fStateSaveStarted = true ; } @Override public void stateSaveUpdatesComplete ( Object input ) { fStateSaveComplete = true ; } @Override public void stateUpdateComplete ( Object input , IViewerUpdate update ) { if ( ! ( update instanceof ElementCompareRequest ) | | ( ( ElementCompareRequest ) update ) . isEqual ( ) ) { fStateUpdates . remove ( update . getElementPath ( ) ) ; } } @Override public void stateUpdateStarted ( Object input , IViewerUpdate update ) { } private String toString ( int flags ) { StringBuffer buf = new StringBuffer ( <str> ) ; if ( fJobError ! = null ) { buf . append ( <str> ) ; buf . append ( <str> + fJobError ) ; if ( fJobError . getException ( ) ! = null ) { StackTraceElement [ ] trace = fJobError . getException ( ) . getStackTrace ( ) ; for ( int i = <int> ; i < trace . length ; i + + ) { buf . append ( <str> ) ; buf . append ( trace [ i ] ) ; } } } if ( fFailOnRedundantUpdates ) { buf . append ( <str> ) ; buf . append ( <str> + fRedundantUpdates ) ; } if ( ( flags & LABEL_SEQUENCE_COMPLETE ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fLabelUpdatesComplete ) ; buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fLabelUpdatesCompleteAtReset ) ; } if ( ( flags & LABEL_UPDATES_RUNNING ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fLabelUpdatesCounter ) ; } if ( ( flags & LABEL_SEQUENCE_STARTED ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fLabelUpdatesStarted ) ; buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fLabelUpdatesCompleted ) ; } if ( ( flags & LABEL_UPDATES ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( toString ( fLabelUpdates ) ) ; } if ( ( flags & VIEWER_UPDATES_RUNNING ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fViewerUpdatesStarted ) ; buf . append ( <str> ) ; buf . append ( <str> + fViewerUpdatesCounter ) ; } if ( ( flags & CONTENT_SEQUENCE_COMPLETE ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fViewerUpdatesComplete ) ; buf . append ( <str> ) ; buf . append ( <str> + fViewerUpdatesCompleteAtReset ) ; } if ( ( flags & HAS_CHILDREN_UPDATES_STARTED ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fHasChildrenUpdatesRunning ) ; buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fHasChildrenUpdatesCompleted ) ; } if ( ( flags & HAS_CHILDREN_UPDATES ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( toString ( fHasChildrenUpdatesScheduled ) ) ; } if ( ( flags & CHILD_COUNT_UPDATES_STARTED ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fChildCountUpdatesRunning ) ; buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fChildCountUpdatesCompleted ) ; } if ( ( flags & CHILD_COUNT_UPDATES ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( toString ( fChildCountUpdatesScheduled ) ) ; } if ( ( flags & CHILDREN_UPDATES_STARTED ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fChildrenUpdatesRunning ) ; buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( fChildrenUpdatesCompleted ) ; } if ( ( flags & CHILDREN_UPDATES ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> ) ; buf . append ( toString ( fChildrenUpdatesScheduled ) ) ; } if ( ( flags & MODEL_CHANGED_COMPLETE ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fModelChangedComplete ) ; } if ( ( flags & STATE_SAVE_COMPLETE ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fStateSaveComplete ) ; } if ( ( flags & STATE_RESTORE_COMPLETE ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fStateRestoreComplete ) ; } if ( ( flags & MODEL_PROXIES_INSTALLED ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fProxyModels ) ; } if ( ( flags & STATE_UPDATES ) ! = <int> ) { buf . append ( <str> ) ; buf . append ( <str> + toString ( fStateUpdates ) ) ; } if ( fTimeoutInterval > <int> ) { buf . append ( <str> ) ; buf . append ( <str> + fTimeoutInterval ) ; } return buf . toString ( ) ; } private String toString ( Set < TreePath > set ) { if ( set . isEmpty ( ) ) { return <str> ; } StringBuffer buf = new StringBuffer ( ) ; for ( Iterator < TreePath > itr = set . iterator ( ) ; itr . hasNext ( ) ; ) { buf . append ( <str> ) ; buf . append ( toString ( itr . next ( ) ) ) ; } return buf . toString ( ) ; } private String toString ( Map < TreePath , Set < Integer > > map ) { if ( map . isEmpty ( ) ) { return <str> ; } StringBuffer buf = new StringBuffer ( ) ; for ( Iterator < TreePath > itr = map . keySet ( ) . iterator ( ) ; itr . hasNext ( ) ; ) { buf . append ( <str> ) ; TreePath path = itr . next ( ) ; buf . append ( toString ( path ) ) ; Set < ? > updates = map . get ( path ) ; buf . append ( <str> ) ; buf . append ( updates . toString ( ) ) ; } return buf . toString ( ) ; } private String toString ( TreePath path ) { if ( path . getSegmentCount ( ) = = <int> ) { return <str> ; } StringBuffer buf = new StringBuffer ( ) ; for ( int i = <int> ; i < path . getSegmentCount ( ) ; i + + ) { buf . append ( <str> ) ; buf . append ( path . getSegment ( i ) ) ; } return buf . toString ( ) ; } @Override public String toString ( ) { return toString ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE | STATE_SAVE_COMPLETE | STATE_RESTORE_COMPLETE | ALL_VIEWER_UPDATES_STARTED | LABEL_SEQUENCE_STARTED | STATE_UPDATES ) ; } } 
