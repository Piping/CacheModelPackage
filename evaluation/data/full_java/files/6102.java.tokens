package org . elasticsearch . common . util ; import org . elasticsearch . common . lease . Releasable ; public final class LongHash extends AbstractHash { private LongArray keys ; public LongHash ( long capacity , BigArrays bigArrays ) { this ( capacity , DEFAULT_MAX_LOAD_FACTOR , bigArrays ) ; } public LongHash ( long capacity , float maxLoadFactor , BigArrays bigArrays ) { super ( capacity , maxLoadFactor , bigArrays ) ; keys = bigArrays . newLongArray ( capacity , false ) ; } public long get ( long id ) { return keys . get ( id ) ; } public long find ( long key ) { final long slot = slot ( hash ( key ) , mask ) ; for ( long index = slot ; ; index = nextSlot ( index , mask ) ) { final long id = id ( index ) ; if ( id = = - <int> | | keys . get ( id ) = = key ) { return id ; } } } private long set ( long key , long id ) { assert size < maxSize ; final long slot = slot ( hash ( key ) , mask ) ; for ( long index = slot ; ; index = nextSlot ( index , mask ) ) { final long curId = id ( index ) ; if ( curId = = - <int> ) { id ( index , id ) ; append ( id , key ) ; + + size ; return id ; } else if ( keys . get ( curId ) = = key ) { return - <int> - curId ; } } } private void append ( long id , long key ) { keys = bigArrays . grow ( keys , id + <int> ) ; keys . set ( id , key ) ; } private void reset ( long key , long id ) { final long slot = slot ( hash ( key ) , mask ) ; for ( long index = slot ; ; index = nextSlot ( index , mask ) ) { final long curId = id ( index ) ; if ( curId = = - <int> ) { id ( index , id ) ; append ( id , key ) ; break ; } } } public long add ( long key ) { if ( size > = maxSize ) { assert size = = maxSize ; grow ( ) ; } assert size < maxSize ; return set ( key , size ) ; } @Override protected void removeAndAdd ( long index ) { final long id = id ( index , - <int> ) ; assert id > = <int> ; final long key = keys . set ( id , <int> ) ; reset ( key , id ) ; } @Override public void close ( ) { try ( Releasable releasable = keys ) { super . close ( ) ; } } } 
