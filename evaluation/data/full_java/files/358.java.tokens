package org . apache . cassandra . db ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . PrintWriter ; import java . nio . file . Files ; import java . nio . file . Paths ; import com . google . common . annotations . VisibleForTesting ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . io . util . FileUtils ; public class WindowsFailedSnapshotTracker { private static final Logger logger = LoggerFactory . getLogger ( WindowsFailedSnapshotTracker . class ) ; private static PrintWriter _failedSnapshotFile ; @VisibleForTesting public static final String TODELETEFILE = System . getenv ( <str> ) = = null ? <str> : System . getenv ( <str> ) + File . separator + <str> ; public static void deleteOldSnapshots ( ) { if ( new File ( TODELETEFILE ) . exists ( ) ) { try { try ( BufferedReader reader = new BufferedReader ( new FileReader ( TODELETEFILE ) ) ) { String snapshotDirectory ; while ( ( snapshotDirectory = reader . readLine ( ) ) ! = null ) { File f = new File ( snapshotDirectory ) ; boolean validFolder = FileUtils . isSubDirectory ( new File ( System . getenv ( <str> ) ) , f ) ; for ( String s : DatabaseDescriptor . getAllDataFileLocations ( ) ) validFolder | = FileUtils . isSubDirectory ( new File ( s ) , f ) ; if ( ! validFolder ) { logger . warn ( <str> , f ) ; continue ; } if ( f . exists ( ) ) { logger . warn ( <str> , snapshotDirectory ) ; FileUtils . deleteRecursive ( new File ( snapshotDirectory ) ) ; } } } Files . delete ( Paths . get ( TODELETEFILE ) ) ; } catch ( IOException e ) { logger . warn ( <str> , TODELETEFILE ) ; logger . warn ( <str> + e ) ; } } try { _failedSnapshotFile = new PrintWriter ( new FileWriter ( TODELETEFILE , true ) ) ; } catch ( IOException e ) { throw new RuntimeException ( String . format ( <str> , TODELETEFILE ) ) ; } } public static synchronized void handleFailedSnapshot ( File dir ) { assert _failedSnapshotFile ! = null : <str> ; FileUtils . deleteRecursiveOnExit ( dir ) ; _failedSnapshotFile . println ( dir . toString ( ) ) ; _failedSnapshotFile . flush ( ) ; } @VisibleForTesting public static void resetForTests ( ) { _failedSnapshotFile . close ( ) ; } } 
