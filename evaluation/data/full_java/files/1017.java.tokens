package org . apache . cassandra . streaming . messages ; import java . io . IOException ; import java . util . ArrayList ; import java . util . List ; import java . util . UUID ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . db . SerializationHeader ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . io . IVersionedSerializer ; import org . apache . cassandra . io . compress . CompressionMetadata ; import org . apache . cassandra . io . sstable . format . SSTableFormat ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . io . sstable . format . Version ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . streaming . compress . CompressionInfo ; import org . apache . cassandra . utils . Pair ; import org . apache . cassandra . utils . UUIDSerializer ; public class FileMessageHeader { public static FileMessageHeaderSerializer serializer = new FileMessageHeaderSerializer ( ) ; public final UUID cfId ; public final int sequenceNumber ; public final Version version ; public final SSTableFormat . Type format ; public final long estimatedKeys ; public final List < Pair < Long , Long > > sections ; public final CompressionInfo compressionInfo ; private final CompressionMetadata compressionMetadata ; public final long repairedAt ; public final int sstableLevel ; public final SerializationHeader . Component header ; public FileMessageHeader ( UUID cfId , int sequenceNumber , Version version , SSTableFormat . Type format , long estimatedKeys , List < Pair < Long , Long > > sections , CompressionInfo compressionInfo , long repairedAt , int sstableLevel , SerializationHeader . Component header ) { this . cfId = cfId ; this . sequenceNumber = sequenceNumber ; this . version = version ; this . format = format ; this . estimatedKeys = estimatedKeys ; this . sections = sections ; this . compressionInfo = compressionInfo ; this . compressionMetadata = null ; this . repairedAt = repairedAt ; this . sstableLevel = sstableLevel ; this . header = header ; } public FileMessageHeader ( UUID cfId , int sequenceNumber , Version version , SSTableFormat . Type format , long estimatedKeys , List < Pair < Long , Long > > sections , CompressionMetadata compressionMetadata , long repairedAt , int sstableLevel , SerializationHeader . Component header ) { this . cfId = cfId ; this . sequenceNumber = sequenceNumber ; this . version = version ; this . format = format ; this . estimatedKeys = estimatedKeys ; this . sections = sections ; this . compressionInfo = null ; this . compressionMetadata = compressionMetadata ; this . repairedAt = repairedAt ; this . sstableLevel = sstableLevel ; this . header = header ; } public boolean isCompressed ( ) { return compressionInfo ! = null | | compressionMetadata ! = null ; } public long size ( ) { long size = <int> ; if ( compressionInfo ! = null ) { for ( CompressionMetadata . Chunk chunk : compressionInfo . chunks ) size + = chunk . length + <int> ; } else if ( compressionMetadata ! = null ) { size = compressionMetadata . getTotalSizeForSections ( sections ) ; } else { for ( Pair < Long , Long > section : sections ) size + = section . right - section . left ; } return size ; } @Override public String toString ( ) { final StringBuilder sb = new StringBuilder ( <str> ) ; sb . append ( <str> ) . append ( cfId ) ; sb . append ( <str> ) . append ( sequenceNumber ) ; sb . append ( <str> ) . append ( version ) ; sb . append ( <str> ) . append ( format ) ; sb . append ( <str> ) . append ( estimatedKeys ) ; sb . append ( <str> ) . append ( size ( ) ) ; sb . append ( <str> ) . append ( isCompressed ( ) ) ; sb . append ( <str> ) . append ( repairedAt ) ; sb . append ( <str> ) . append ( sstableLevel ) ; sb . append ( <str> ) ; return sb . toString ( ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; FileMessageHeader that = ( FileMessageHeader ) o ; return sequenceNumber = = that . sequenceNumber & & cfId . equals ( that . cfId ) ; } @Override public int hashCode ( ) { int result = cfId . hashCode ( ) ; result = <int> * result + sequenceNumber ; return result ; } static class FileMessageHeaderSerializer { public CompressionInfo serialize ( FileMessageHeader header , DataOutputPlus out , int version ) throws IOException { UUIDSerializer . serializer . serialize ( header . cfId , out , version ) ; out . writeInt ( header . sequenceNumber ) ; out . writeUTF ( header . version . toString ( ) ) ; if ( version < StreamMessage . VERSION_22 & & header . format ! = SSTableFormat . Type . LEGACY & & header . format ! = SSTableFormat . Type . BIG ) throw new UnsupportedOperationException ( <str> ) ; if ( version > = StreamMessage . VERSION_22 ) out . writeUTF ( header . format . name ) ; out . writeLong ( header . estimatedKeys ) ; out . writeInt ( header . sections . size ( ) ) ; for ( Pair < Long , Long > section : header . sections ) { out . writeLong ( section . left ) ; out . writeLong ( section . right ) ; } CompressionInfo compressionInfo = null ; if ( header . compressionMetadata ! = null ) compressionInfo = new CompressionInfo ( header . compressionMetadata . getChunksForSections ( header . sections ) , header . compressionMetadata . parameters ) ; CompressionInfo . serializer . serialize ( compressionInfo , out , version ) ; out . writeLong ( header . repairedAt ) ; out . writeInt ( header . sstableLevel ) ; if ( version > = StreamMessage . VERSION_30 ) SerializationHeader . serializer . serialize ( header . version , header . header , out ) ; return compressionInfo ; } public FileMessageHeader deserialize ( DataInputPlus in , int version ) throws IOException { UUID cfId = UUIDSerializer . serializer . deserialize ( in , MessagingService . current_version ) ; int sequenceNumber = in . readInt ( ) ; Version sstableVersion = DatabaseDescriptor . getSSTableFormat ( ) . info . getVersion ( in . readUTF ( ) ) ; SSTableFormat . Type format = SSTableFormat . Type . LEGACY ; if ( version > = StreamMessage . VERSION_22 ) format = SSTableFormat . Type . validate ( in . readUTF ( ) ) ; long estimatedKeys = in . readLong ( ) ; int count = in . readInt ( ) ; List < Pair < Long , Long > > sections = new ArrayList < > ( count ) ; for ( int k = <int> ; k < count ; k + + ) sections . add ( Pair . create ( in . readLong ( ) , in . readLong ( ) ) ) ; CompressionInfo compressionInfo = CompressionInfo . serializer . deserialize ( in , MessagingService . current_version ) ; long repairedAt = in . readLong ( ) ; int sstableLevel = in . readInt ( ) ; SerializationHeader . Component header = version > = StreamMessage . VERSION_30 ? SerializationHeader . serializer . deserialize ( sstableVersion , in ) : null ; return new FileMessageHeader ( cfId , sequenceNumber , sstableVersion , format , estimatedKeys , sections , compressionInfo , repairedAt , sstableLevel , header ) ; } public long serializedSize ( FileMessageHeader header , int version ) { long size = UUIDSerializer . serializer . serializedSize ( header . cfId , version ) ; size + = TypeSizes . sizeof ( header . sequenceNumber ) ; size + = TypeSizes . sizeof ( header . version . toString ( ) ) ; if ( version > = StreamMessage . VERSION_22 ) size + = TypeSizes . sizeof ( header . format . name ) ; size + = TypeSizes . sizeof ( header . estimatedKeys ) ; size + = TypeSizes . sizeof ( header . sections . size ( ) ) ; for ( Pair < Long , Long > section : header . sections ) { size + = TypeSizes . sizeof ( section . left ) ; size + = TypeSizes . sizeof ( section . right ) ; } size + = CompressionInfo . serializer . serializedSize ( header . compressionInfo , version ) ; size + = TypeSizes . sizeof ( header . sstableLevel ) ; if ( version > = StreamMessage . VERSION_30 ) size + = SerializationHeader . serializer . serializedSize ( header . version , header . header ) ; return size ; } } } 
