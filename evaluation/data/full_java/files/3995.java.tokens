package org . eclipse . debug . internal . ui ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . IOException ; import java . util . regex . Pattern ; import org . eclipse . core . expressions . PropertyTester ; import org . eclipse . core . resources . IFile ; import org . eclipse . core . resources . IProject ; import org . eclipse . core . resources . IResource ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IAdaptable ; import org . eclipse . core . runtime . IPath ; import org . eclipse . core . runtime . Platform ; import org . eclipse . core . runtime . content . IContentDescription ; import org . eclipse . core . runtime . content . IContentType ; import org . eclipse . ui . IPathEditorInput ; public class ResourceExtender extends PropertyTester { private static final String PROPERTY_MATCHES_PATTERN = <str> ; private static final String PROJECT_NATURE = <str> ; private static final String PROPERTY_MATCHES_CONTENT_TYPE = <str> ; @Override public boolean test ( Object receiver , String method , Object [ ] args , Object expectedValue ) { IResource resource = ( ( IAdaptable ) receiver ) . getAdapter ( IResource . class ) ; if ( resource = = null ) { if ( PROPERTY_MATCHES_CONTENT_TYPE . equals ( method ) ) { IPathEditorInput editorInput = ( ( IAdaptable ) receiver ) . getAdapter ( IPathEditorInput . class ) ; if ( editorInput ! = null ) { IPath path = editorInput . getPath ( ) ; File file = path . toFile ( ) ; if ( file . exists ( ) ) { try ( FileReader reader = new FileReader ( file ) ) { IContentType contentType = Platform . getContentTypeManager ( ) . getContentType ( ( String ) expectedValue ) ; IContentDescription description = contentType . getDescriptionFor ( reader , IContentDescription . ALL ) ; if ( description ! = null ) { return matchesContentType ( description . getContentType ( ) , ( String ) expectedValue ) ; } } catch ( FileNotFoundException e ) { return false ; } catch ( IOException e ) { return false ; } } } } } else { if ( PROPERTY_MATCHES_PATTERN . equals ( method ) ) { String fileName = resource . getName ( ) ; String expected = ( String ) expectedValue ; expected = expected . replaceAll ( <str> , <str> ) ; expected = expected . replaceAll ( <str> , <str> ) ; Pattern pattern = Pattern . compile ( expected ) ; boolean retVal = pattern . matcher ( fileName ) . find ( ) ; return retVal ; } else if ( PROJECT_NATURE . equals ( method ) ) { try { IProject proj = resource . getProject ( ) ; return proj ! = null & & proj . isAccessible ( ) & & proj . hasNature ( ( String ) expectedValue ) ; } catch ( CoreException e ) { return false ; } } else if ( PROPERTY_MATCHES_CONTENT_TYPE . equals ( method ) ) { return matchesContentType ( resource , ( String ) expectedValue ) ; } } return false ; } private boolean matchesContentType ( IContentType type , String typeId ) { while ( type ! = null ) { if ( typeId . equals ( type . getId ( ) ) ) { return true ; } type = type . getBaseType ( ) ; } return false ; } private boolean matchesContentType ( IResource resource , String contentType ) { if ( resource = = null | | ! ( resource instanceof IFile ) | | ! resource . exists ( ) ) { return false ; } IFile file = ( IFile ) resource ; IContentDescription description ; try { description = file . getContentDescription ( ) ; } catch ( CoreException e ) { return false ; } if ( description ! = null ) { return matchesContentType ( description . getContentType ( ) , contentType ) ; } return false ; } } 
