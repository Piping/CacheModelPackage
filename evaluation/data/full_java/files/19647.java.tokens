package io . netty . util ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; public final class ReferenceCountUtil { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( ReferenceCountUtil . class ) ; @SuppressWarnings ( <str> ) public static < T > T retain ( T msg ) { if ( msg instanceof ReferenceCounted ) { return ( T ) ( ( ReferenceCounted ) msg ) . retain ( ) ; } return msg ; } @SuppressWarnings ( <str> ) public static < T > T retain ( T msg , int increment ) { if ( msg instanceof ReferenceCounted ) { return ( T ) ( ( ReferenceCounted ) msg ) . retain ( increment ) ; } return msg ; } @SuppressWarnings ( <str> ) public static < T > T touch ( T msg ) { if ( msg instanceof ReferenceCounted ) { return ( T ) ( ( ReferenceCounted ) msg ) . touch ( ) ; } return msg ; } @SuppressWarnings ( <str> ) public static < T > T touch ( T msg , Object hint ) { if ( msg instanceof ReferenceCounted ) { return ( T ) ( ( ReferenceCounted ) msg ) . touch ( hint ) ; } return msg ; } public static boolean release ( Object msg ) { if ( msg instanceof ReferenceCounted ) { return ( ( ReferenceCounted ) msg ) . release ( ) ; } return false ; } public static boolean release ( Object msg , int decrement ) { if ( msg instanceof ReferenceCounted ) { return ( ( ReferenceCounted ) msg ) . release ( decrement ) ; } return false ; } public static void safeRelease ( Object msg ) { try { release ( msg ) ; } catch ( Throwable t ) { logger . warn ( <str> , msg , t ) ; } } public static void safeRelease ( Object msg , int decrement ) { try { release ( msg , decrement ) ; } catch ( Throwable t ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , msg , decrement , t ) ; } } } public static < T > T releaseLater ( T msg ) { return releaseLater ( msg , <int> ) ; } public static < T > T releaseLater ( T msg , int decrement ) { if ( msg instanceof ReferenceCounted ) { ThreadDeathWatcher . watch ( Thread . currentThread ( ) , new ReleasingTask ( ( ReferenceCounted ) msg , decrement ) ) ; } return msg ; } private static final class ReleasingTask implements Runnable { private final ReferenceCounted obj ; private final int decrement ; ReleasingTask ( ReferenceCounted obj , int decrement ) { this . obj = obj ; this . decrement = decrement ; } @Override public void run ( ) { try { if ( ! obj . release ( decrement ) ) { logger . warn ( <str> , this ) ; } else { logger . debug ( <str> , this ) ; } } catch ( Exception ex ) { logger . warn ( <str> , obj , ex ) ; } } @Override public String toString ( ) { return StringUtil . simpleClassName ( obj ) + <str> + decrement + <str> + obj . refCnt ( ) ; } } private ReferenceCountUtil ( ) { } } 
