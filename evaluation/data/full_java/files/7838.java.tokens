package org . elasticsearch . cluster . routing ; import com . carrotsearch . hppc . IntHashSet ; import com . carrotsearch . randomizedtesting . generators . RandomPicks ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterName ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . metadata . SnapshotId ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . FailedRerouteAllocation ; import org . elasticsearch . common . io . stream . BytesStreamOutput ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . TimeValue ; import org . elasticsearch . test . ESAllocationTestCase ; import java . util . Collections ; import java . util . EnumSet ; import static org . elasticsearch . cluster . routing . ShardRoutingState . * ; import static org . hamcrest . Matchers . * ; public class UnassignedInfoTests extends ESAllocationTestCase { public void testReasonOrdinalOrder ( ) { UnassignedInfo . Reason [ ] order = new UnassignedInfo . Reason [ ] { UnassignedInfo . Reason . INDEX_CREATED , UnassignedInfo . Reason . CLUSTER_RECOVERED , UnassignedInfo . Reason . INDEX_REOPENED , UnassignedInfo . Reason . DANGLING_INDEX_IMPORTED , UnassignedInfo . Reason . NEW_INDEX_RESTORED , UnassignedInfo . Reason . EXISTING_INDEX_RESTORED , UnassignedInfo . Reason . REPLICA_ADDED , UnassignedInfo . Reason . ALLOCATION_FAILED , UnassignedInfo . Reason . NODE_LEFT , UnassignedInfo . Reason . REROUTE_CANCELLED , UnassignedInfo . Reason . REINITIALIZED , UnassignedInfo . Reason . REALLOCATED_REPLICA } ; for ( int i = <int> ; i < order . length ; i + + ) { assertThat ( order [ i ] . ordinal ( ) , equalTo ( i ) ) ; } assertThat ( UnassignedInfo . Reason . values ( ) . length , equalTo ( order . length ) ) ; } public void testSerialization ( ) throws Exception { UnassignedInfo meta = new UnassignedInfo ( RandomPicks . randomFrom ( getRandom ( ) , UnassignedInfo . Reason . values ( ) ) , randomBoolean ( ) ? randomAsciiOfLength ( <int> ) : null ) ; BytesStreamOutput out = new BytesStreamOutput ( ) ; meta . writeTo ( out ) ; out . close ( ) ; UnassignedInfo read = new UnassignedInfo ( StreamInput . wrap ( out . bytes ( ) ) ) ; assertThat ( read . getReason ( ) , equalTo ( meta . getReason ( ) ) ) ; assertThat ( read . getUnassignedTimeInMillis ( ) , equalTo ( meta . getUnassignedTimeInMillis ( ) ) ) ; assertThat ( read . getMessage ( ) , equalTo ( meta . getMessage ( ) ) ) ; assertThat ( read . getDetails ( ) , equalTo ( meta . getDetails ( ) ) ) ; } public void testIndexCreated ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( randomIntBetween ( <int> , <int> ) ) . numberOfReplicas ( randomIntBetween ( <int> , <int> ) ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; for ( ShardRouting shard : clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) ) { assertThat ( shard . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . INDEX_CREATED ) ) ; } } public void testClusterRecovered ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( randomIntBetween ( <int> , <int> ) ) . numberOfReplicas ( randomIntBetween ( <int> , <int> ) ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsRecovery ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; for ( ShardRouting shard : clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) ) { assertThat ( shard . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . CLUSTER_RECOVERED ) ) ; } } public void testIndexReopened ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( randomIntBetween ( <int> , <int> ) ) . numberOfReplicas ( randomIntBetween ( <int> , <int> ) ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsFromCloseToOpen ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; for ( ShardRouting shard : clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) ) { assertThat ( shard . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . INDEX_REOPENED ) ) ; } } public void testNewIndexRestored ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( randomIntBetween ( <int> , <int> ) ) . numberOfReplicas ( randomIntBetween ( <int> , <int> ) ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNewRestore ( metaData . index ( <str> ) , new RestoreSource ( new SnapshotId ( <str> , <str> ) , Version . CURRENT , <str> ) , new IntHashSet ( ) ) . build ( ) ) . build ( ) ; for ( ShardRouting shard : clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) ) { assertThat ( shard . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . NEW_INDEX_RESTORED ) ) ; } } public void testExistingIndexRestored ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( randomIntBetween ( <int> , <int> ) ) . numberOfReplicas ( randomIntBetween ( <int> , <int> ) ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsRestore ( metaData . index ( <str> ) , new RestoreSource ( new SnapshotId ( <str> , <str> ) , Version . CURRENT , <str> ) ) . build ( ) ) . build ( ) ; for ( ShardRouting shard : clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) ) { assertThat ( shard . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . EXISTING_INDEX_RESTORED ) ) ; } } public void testDanglingIndexImported ( ) { MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( randomIntBetween ( <int> , <int> ) ) . numberOfReplicas ( randomIntBetween ( <int> , <int> ) ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsFromDangling ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; for ( ShardRouting shard : clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) ) { assertThat ( shard . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . DANGLING_INDEX_IMPORTED ) ) ; } } public void testReplicaAdded ( ) { AllocationService allocation = createAllocationService ( ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; IndexRoutingTable . Builder builder = IndexRoutingTable . builder ( <str> ) ; for ( IndexShardRoutingTable indexShardRoutingTable : clusterState . routingTable ( ) . index ( <str> ) ) { builder . addIndexShard ( indexShardRoutingTable ) ; } builder . addReplica ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingTable ( RoutingTable . builder ( clusterState . routingTable ( ) ) . add ( builder ) . build ( ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) , notNullValue ( ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . REPLICA_ADDED ) ) ; } public void testStateTransitionMetaHandling ( ) { ShardRouting shard = TestShardRouting . newShardRouting ( <str> , <int> , null , null , null , true , ShardRoutingState . UNASSIGNED , <int> , new UnassignedInfo ( UnassignedInfo . Reason . INDEX_CREATED , null ) ) ; ShardRouting mutable = new ShardRouting ( shard ) ; assertThat ( mutable . unassignedInfo ( ) , notNullValue ( ) ) ; mutable . initialize ( <str> , - <int> ) ; assertThat ( mutable . state ( ) , equalTo ( ShardRoutingState . INITIALIZING ) ) ; assertThat ( mutable . unassignedInfo ( ) , notNullValue ( ) ) ; mutable . moveToStarted ( ) ; assertThat ( mutable . state ( ) , equalTo ( ShardRoutingState . STARTED ) ) ; assertThat ( mutable . unassignedInfo ( ) , nullValue ( ) ) ; } public void testNodeLeave ( ) { AllocationService allocation = createAllocationService ( ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) > <int> , equalTo ( false ) ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . remove ( <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) > <int> , equalTo ( true ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) , notNullValue ( ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . NODE_LEFT ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) . getUnassignedTimeInMillis ( ) , greaterThan ( <int> l ) ) ; } public void testFailedShard ( ) { AllocationService allocation = createAllocationService ( ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) > <int> , equalTo ( false ) ) ; ShardRouting shardToFail = clusterState . getRoutingNodes ( ) . shardsWithState ( STARTED ) . get ( <int> ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyFailedShards ( clusterState , Collections . singletonList ( new FailedRerouteAllocation . FailedShard ( shardToFail , <str> , null ) ) ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) > <int> , equalTo ( true ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . size ( ) , equalTo ( <int> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) , notNullValue ( ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) . getReason ( ) , equalTo ( UnassignedInfo . Reason . ALLOCATION_FAILED ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) . getMessage ( ) , equalTo ( <str> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) . getDetails ( ) , equalTo ( <str> ) ) ; assertThat ( clusterState . getRoutingNodes ( ) . shardsWithState ( UNASSIGNED ) . get ( <int> ) . unassignedInfo ( ) . getUnassignedTimeInMillis ( ) , greaterThan ( <int> l ) ) ; } public void testUnassignedDelayedOnlyOnNodeLeft ( ) throws Exception { final UnassignedInfo unassignedInfo = new UnassignedInfo ( UnassignedInfo . Reason . NODE_LEFT , null ) ; long delay = unassignedInfo . updateDelay ( unassignedInfo . getUnassignedTimeInNanos ( ) + <int> , Settings . builder ( ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , <str> ) . build ( ) , Settings . EMPTY ) ; long cachedDelay = unassignedInfo . getLastComputedLeftDelayNanos ( ) ; assertThat ( delay , equalTo ( cachedDelay ) ) ; assertThat ( delay , equalTo ( TimeValue . timeValueHours ( <int> ) . nanos ( ) - <int> ) ) ; } public void testUnassignedDelayOnlyNodeLeftNonNodeLeftReason ( ) throws Exception { EnumSet < UnassignedInfo . Reason > reasons = EnumSet . allOf ( UnassignedInfo . Reason . class ) ; reasons . remove ( UnassignedInfo . Reason . NODE_LEFT ) ; UnassignedInfo unassignedInfo = new UnassignedInfo ( RandomPicks . randomFrom ( getRandom ( ) , reasons ) , null ) ; long delay = unassignedInfo . updateDelay ( unassignedInfo . getUnassignedTimeInNanos ( ) + <int> , Settings . builder ( ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , <str> ) . build ( ) , Settings . EMPTY ) ; assertThat ( delay , equalTo ( <int> l ) ) ; delay = unassignedInfo . getLastComputedLeftDelayNanos ( ) ; assertThat ( delay , equalTo ( <int> l ) ) ; } public void testLeftDelayCalculation ( ) throws Exception { final long baseTime = System . nanoTime ( ) ; final UnassignedInfo unassignedInfo = new UnassignedInfo ( UnassignedInfo . Reason . NODE_LEFT , <str> , null , baseTime , System . currentTimeMillis ( ) ) ; final long totalDelayNanos = TimeValue . timeValueMillis ( <int> ) . nanos ( ) ; final Settings settings = Settings . builder ( ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , TimeValue . timeValueNanos ( totalDelayNanos ) ) . build ( ) ; long delay = unassignedInfo . updateDelay ( baseTime , settings , Settings . EMPTY ) ; assertThat ( delay , equalTo ( totalDelayNanos ) ) ; assertThat ( delay , equalTo ( unassignedInfo . getLastComputedLeftDelayNanos ( ) ) ) ; long delta1 = randomIntBetween ( <int> , ( int ) ( totalDelayNanos - <int> ) ) ; delay = unassignedInfo . updateDelay ( baseTime + delta1 , settings , Settings . EMPTY ) ; assertThat ( delay , equalTo ( totalDelayNanos - delta1 ) ) ; assertThat ( delay , equalTo ( unassignedInfo . getLastComputedLeftDelayNanos ( ) ) ) ; delay = unassignedInfo . updateDelay ( baseTime + totalDelayNanos , settings , Settings . EMPTY ) ; assertThat ( delay , equalTo ( <int> L ) ) ; assertThat ( delay , equalTo ( unassignedInfo . getLastComputedLeftDelayNanos ( ) ) ) ; delay = unassignedInfo . updateDelay ( baseTime + totalDelayNanos + randomIntBetween ( <int> , <int> ) , settings , Settings . EMPTY ) ; assertThat ( delay , equalTo ( <int> L ) ) ; assertThat ( delay , equalTo ( unassignedInfo . getLastComputedLeftDelayNanos ( ) ) ) ; } public void testNumberOfDelayedUnassigned ( ) throws Exception { MockAllocationService allocation = createAllocationService ( Settings . EMPTY , new DelayedShardsMockGatewayAllocator ( ) ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; assertThat ( UnassignedInfo . getNumberOfDelayedUnassigned ( clusterState ) , equalTo ( <int> ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) > <int> , equalTo ( false ) ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . remove ( <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; assertThat ( clusterState . prettyPrint ( ) , UnassignedInfo . getNumberOfDelayedUnassigned ( clusterState ) , equalTo ( <int> ) ) ; } public void testFindNextDelayedAllocation ( ) { MockAllocationService allocation = createAllocationService ( Settings . EMPTY , new DelayedShardsMockGatewayAllocator ( ) ) ; final long baseTime = System . nanoTime ( ) ; allocation . setNanoTimeOverride ( baseTime ) ; final TimeValue delayTest1 = TimeValue . timeValueMillis ( randomIntBetween ( <int> , <int> ) ) ; final TimeValue delayTest2 = TimeValue . timeValueMillis ( randomIntBetween ( <int> , <int> ) ) ; final long expectMinDelaySettingsNanos = Math . min ( delayTest1 . nanos ( ) , delayTest2 . nanos ( ) ) ; MetaData metaData = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , delayTest1 ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) . put ( UnassignedInfo . INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING , delayTest2 ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; ClusterState clusterState = ClusterState . builder ( ClusterName . DEFAULT ) . metaData ( metaData ) . routingTable ( RoutingTable . builder ( ) . addAsNew ( metaData . index ( <str> ) ) . addAsNew ( metaData . index ( <str> ) ) . build ( ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( ) . put ( newNode ( <str> ) ) . put ( newNode ( <str> ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; assertThat ( UnassignedInfo . getNumberOfDelayedUnassigned ( clusterState ) , equalTo ( <int> ) ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . applyStartedShards ( clusterState , clusterState . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) ) . build ( ) ; assertThat ( clusterState . getRoutingNodes ( ) . unassigned ( ) . size ( ) > <int> , equalTo ( false ) ) ; clusterState = ClusterState . builder ( clusterState ) . nodes ( DiscoveryNodes . builder ( clusterState . nodes ( ) ) . remove ( <str> ) ) . build ( ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; final long delta = randomBoolean ( ) ? <int> : randomInt ( ( int ) expectMinDelaySettingsNanos ) ; if ( delta > <int> ) { allocation . setNanoTimeOverride ( baseTime + delta ) ; clusterState = ClusterState . builder ( clusterState ) . routingResult ( allocation . reroute ( clusterState , <str> ) ) . build ( ) ; } long minDelaySetting = UnassignedInfo . findSmallestDelayedAllocationSettingNanos ( Settings . EMPTY , clusterState ) ; assertThat ( minDelaySetting , equalTo ( expectMinDelaySettingsNanos ) ) ; long nextDelay = UnassignedInfo . findNextDelayedAllocationIn ( clusterState ) ; assertThat ( nextDelay , equalTo ( expectMinDelaySettingsNanos - delta ) ) ; } } 
