package org . elasticsearch . search . rescore ; import org . apache . lucene . index . Term ; import org . apache . lucene . search . Explanation ; import org . apache . lucene . search . Query ; import org . apache . lucene . search . ScoreDoc ; import org . apache . lucene . search . TopDocs ; import org . elasticsearch . common . ParseField ; import org . elasticsearch . common . xcontent . ObjectParser ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . ParsedQuery ; import org . elasticsearch . search . internal . ContextIndexSearcher ; import org . elasticsearch . search . internal . SearchContext ; import java . io . IOException ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Set ; public final class QueryRescorer implements Rescorer { private static enum ScoreMode { Avg { @Override public float combine ( float primary , float secondary ) { return ( primary + secondary ) / <int> ; } @Override public String toString ( ) { return <str> ; } } , Max { @Override public float combine ( float primary , float secondary ) { return Math . max ( primary , secondary ) ; } @Override public String toString ( ) { return <str> ; } } , Min { @Override public float combine ( float primary , float secondary ) { return Math . min ( primary , secondary ) ; } @Override public String toString ( ) { return <str> ; } } , Total { @Override public float combine ( float primary , float secondary ) { return primary + secondary ; } @Override public String toString ( ) { return <str> ; } } , Multiply { @Override public float combine ( float primary , float secondary ) { return primary * secondary ; } @Override public String toString ( ) { return <str> ; } } ; public abstract float combine ( float primary , float secondary ) ; } public static final Rescorer INSTANCE = new QueryRescorer ( ) ; public static final String NAME = <str> ; @Override public String name ( ) { return NAME ; } @Override public TopDocs rescore ( TopDocs topDocs , SearchContext context , RescoreSearchContext rescoreContext ) throws IOException { assert rescoreContext ! = null ; if ( topDocs = = null | | topDocs . totalHits = = <int> | | topDocs . scoreDocs . length = = <int> ) { return topDocs ; } final QueryRescoreContext rescore = ( QueryRescoreContext ) rescoreContext ; org . apache . lucene . search . Rescorer rescorer = new org . apache . lucene . search . QueryRescorer ( rescore . query ( ) ) { @Override protected float combine ( float firstPassScore , boolean secondPassMatches , float secondPassScore ) { if ( secondPassMatches ) { return rescore . scoreMode . combine ( firstPassScore * rescore . queryWeight ( ) , secondPassScore * rescore . rescoreQueryWeight ( ) ) ; } return firstPassScore * rescore . queryWeight ( ) ; } } ; TopDocs topNFirstPass = topN ( topDocs , rescoreContext . window ( ) ) ; TopDocs rescored = rescorer . rescore ( context . searcher ( ) , topNFirstPass , rescoreContext . window ( ) ) ; return combine ( topDocs , rescored , ( QueryRescoreContext ) rescoreContext ) ; } @Override public Explanation explain ( int topLevelDocId , SearchContext context , RescoreSearchContext rescoreContext , Explanation sourceExplanation ) throws IOException { QueryRescoreContext rescore = ( QueryRescoreContext ) rescoreContext ; ContextIndexSearcher searcher = context . searcher ( ) ; if ( sourceExplanation = = null ) { return Explanation . noMatch ( <str> ) ; } Explanation rescoreExplain = searcher . explain ( rescore . query ( ) , topLevelDocId ) ; float primaryWeight = rescore . queryWeight ( ) ; Explanation prim ; if ( sourceExplanation . isMatch ( ) ) { prim = Explanation . match ( sourceExplanation . getValue ( ) * primaryWeight , <str> , sourceExplanation , Explanation . match ( primaryWeight , <str> ) ) ; } else { prim = Explanation . noMatch ( <str> , sourceExplanation ) ; } if ( rescoreExplain ! = null & & rescoreExplain . isMatch ( ) ) { float secondaryWeight = rescore . rescoreQueryWeight ( ) ; Explanation sec = Explanation . match ( rescoreExplain . getValue ( ) * secondaryWeight , <str> , rescoreExplain , Explanation . match ( secondaryWeight , <str> ) ) ; ScoreMode scoreMode = rescore . scoreMode ( ) ; return Explanation . match ( scoreMode . combine ( prim . getValue ( ) , sec . getValue ( ) ) , scoreMode + <str> , prim , sec ) ; } else { return prim ; } } private static final ObjectParser < QueryRescoreContext , SearchContext > RESCORE_PARSER = new ObjectParser < > ( <str> , null ) ; static { RESCORE_PARSER . declareObject ( QueryRescoreContext : : setParsedQuery , ( p , c ) - > c . indexShard ( ) . getQueryShardContext ( ) . parse ( p ) , new ParseField ( <str> ) ) ; RESCORE_PARSER . declareFloat ( QueryRescoreContext : : setQueryWeight , new ParseField ( <str> ) ) ; RESCORE_PARSER . declareFloat ( QueryRescoreContext : : setRescoreQueryWeight , new ParseField ( <str> ) ) ; RESCORE_PARSER . declareString ( QueryRescoreContext : : setScoreMode , new ParseField ( <str> ) ) ; } @Override public RescoreSearchContext parse ( XContentParser parser , SearchContext context ) throws IOException { return RESCORE_PARSER . parse ( parser , new QueryRescoreContext ( this ) , context ) ; } private final static Comparator < ScoreDoc > SCORE_DOC_COMPARATOR = new Comparator < ScoreDoc > ( ) { @Override public int compare ( ScoreDoc o1 , ScoreDoc o2 ) { int cmp = Float . compare ( o2 . score , o1 . score ) ; return cmp = = <int> ? Integer . compare ( o1 . doc , o2 . doc ) : cmp ; } } ; private TopDocs topN ( TopDocs in , int topN ) { if ( in . totalHits < topN ) { assert in . scoreDocs . length = = in . totalHits ; return in ; } ScoreDoc [ ] subset = new ScoreDoc [ topN ] ; System . arraycopy ( in . scoreDocs , <int> , subset , <int> , topN ) ; return new TopDocs ( in . totalHits , subset , in . getMaxScore ( ) ) ; } private TopDocs combine ( TopDocs in , TopDocs resorted , QueryRescoreContext ctx ) { System . arraycopy ( resorted . scoreDocs , <int> , in . scoreDocs , <int> , resorted . scoreDocs . length ) ; if ( in . scoreDocs . length > resorted . scoreDocs . length ) { for ( int i = resorted . scoreDocs . length ; i < in . scoreDocs . length ; i + + ) { in . scoreDocs [ i ] . score * = ctx . queryWeight ( ) ; } Arrays . sort ( in . scoreDocs , SCORE_DOC_COMPARATOR ) ; } return in ; } public static class QueryRescoreContext extends RescoreSearchContext { public QueryRescoreContext ( QueryRescorer rescorer ) { super ( NAME , <int> , rescorer ) ; this . scoreMode = ScoreMode . Total ; } private ParsedQuery parsedQuery ; private float queryWeight = <float> ; private float rescoreQueryWeight = <float> ; private ScoreMode scoreMode ; public void setParsedQuery ( ParsedQuery parsedQuery ) { this . parsedQuery = parsedQuery ; } public Query query ( ) { return parsedQuery . query ( ) ; } public float queryWeight ( ) { return queryWeight ; } public float rescoreQueryWeight ( ) { return rescoreQueryWeight ; } public ScoreMode scoreMode ( ) { return scoreMode ; } public void setRescoreQueryWeight ( float rescoreQueryWeight ) { this . rescoreQueryWeight = rescoreQueryWeight ; } public void setQueryWeight ( float queryWeight ) { this . queryWeight = queryWeight ; } public void setScoreMode ( ScoreMode scoreMode ) { this . scoreMode = scoreMode ; } public void setScoreMode ( String scoreMode ) { if ( <str> . equals ( scoreMode ) ) { setScoreMode ( ScoreMode . Avg ) ; } else if ( <str> . equals ( scoreMode ) ) { setScoreMode ( ScoreMode . Max ) ; } else if ( <str> . equals ( scoreMode ) ) { setScoreMode ( ScoreMode . Min ) ; } else if ( <str> . equals ( scoreMode ) ) { setScoreMode ( ScoreMode . Total ) ; } else if ( <str> . equals ( scoreMode ) ) { setScoreMode ( ScoreMode . Multiply ) ; } else { throw new IllegalArgumentException ( <str> + scoreMode + <str> ) ; } } } @Override public void extractTerms ( SearchContext context , RescoreSearchContext rescoreContext , Set < Term > termsSet ) { try { context . searcher ( ) . createNormalizedWeight ( ( ( QueryRescoreContext ) rescoreContext ) . query ( ) , false ) . extractTerms ( termsSet ) ; } catch ( IOException e ) { throw new IllegalStateException ( <str> , e ) ; } } } 
