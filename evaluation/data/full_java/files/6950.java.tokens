package org . elasticsearch . rest ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . component . AbstractLifecycleComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . path . PathTrie ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . rest . support . RestUtils ; import java . io . IOException ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashSet ; import java . util . Set ; import java . util . concurrent . atomic . AtomicInteger ; import static java . util . Collections . emptySet ; import static java . util . Collections . unmodifiableSet ; import static org . elasticsearch . rest . RestStatus . BAD_REQUEST ; import static org . elasticsearch . rest . RestStatus . OK ; public class RestController extends AbstractLifecycleComponent < RestController > { private final PathTrie < RestHandler > getHandlers = new PathTrie < > ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > postHandlers = new PathTrie < > ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > putHandlers = new PathTrie < > ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > deleteHandlers = new PathTrie < > ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > headHandlers = new PathTrie < > ( RestUtils . REST_DECODER ) ; private final PathTrie < RestHandler > optionsHandlers = new PathTrie < > ( RestUtils . REST_DECODER ) ; private final RestHandlerFilter handlerFilter = new RestHandlerFilter ( ) ; private Set < String > relevantHeaders = emptySet ( ) ; private RestFilter [ ] filters = new RestFilter [ <int> ] ; @Inject public RestController ( Settings settings ) { super ( settings ) ; } @Override protected void doStart ( ) { } @Override protected void doStop ( ) { } @Override protected void doClose ( ) { for ( RestFilter filter : filters ) { filter . close ( ) ; } } public synchronized void registerRelevantHeaders ( String . . . headers ) { Set < String > newRelevantHeaders = new HashSet < > ( relevantHeaders . size ( ) + headers . length ) ; newRelevantHeaders . addAll ( relevantHeaders ) ; Collections . addAll ( newRelevantHeaders , headers ) ; relevantHeaders = unmodifiableSet ( newRelevantHeaders ) ; } public Set < String > relevantHeaders ( ) { return relevantHeaders ; } public synchronized void registerFilter ( RestFilter preProcessor ) { RestFilter [ ] copy = new RestFilter [ filters . length + <int> ] ; System . arraycopy ( filters , <int> , copy , <int> , filters . length ) ; copy [ filters . length ] = preProcessor ; Arrays . sort ( copy , new Comparator < RestFilter > ( ) { @Override public int compare ( RestFilter o1 , RestFilter o2 ) { return Integer . compare ( o1 . order ( ) , o2 . order ( ) ) ; } } ) ; filters = copy ; } public void registerHandler ( RestRequest . Method method , String path , RestHandler handler ) { switch ( method ) { case GET : getHandlers . insert ( path , handler ) ; break ; case DELETE : deleteHandlers . insert ( path , handler ) ; break ; case POST : postHandlers . insert ( path , handler ) ; break ; case PUT : putHandlers . insert ( path , handler ) ; break ; case OPTIONS : optionsHandlers . insert ( path , handler ) ; break ; case HEAD : headHandlers . insert ( path , handler ) ; break ; default : throw new IllegalArgumentException ( <str> + method + <str> + path + <str> ) ; } } @Nullable public RestFilterChain filterChainOrNull ( RestFilter executionFilter ) { if ( filters . length = = <int> ) { return null ; } return new ControllerFilterChain ( executionFilter ) ; } public RestFilterChain filterChain ( RestFilter executionFilter ) { return new ControllerFilterChain ( executionFilter ) ; } public void dispatchRequest ( final RestRequest request , final RestChannel channel ) { if ( ! checkRequestParameters ( request , channel ) ) { return ; } if ( filters . length = = <int> ) { try { executeHandler ( request , channel ) ; } catch ( Throwable e ) { try { channel . sendResponse ( new BytesRestResponse ( channel , e ) ) ; } catch ( Throwable e1 ) { logger . error ( <str> + request . uri ( ) + <str> , e1 ) ; } } } else { ControllerFilterChain filterChain = new ControllerFilterChain ( handlerFilter ) ; filterChain . continueProcessing ( request , channel ) ; } } boolean checkRequestParameters ( final RestRequest request , final RestChannel channel ) { if ( channel . detailedErrorsEnabled ( ) = = false & & request . paramAsBoolean ( <str> , false ) ) { try { XContentBuilder builder = channel . newErrorBuilder ( ) ; builder . startObject ( ) . field ( <str> , <str> ) . endObject ( ) . string ( ) ; RestResponse response = new BytesRestResponse ( BAD_REQUEST , builder ) ; response . addHeader ( <str> , <str> ) ; channel . sendResponse ( response ) ; } catch ( IOException e ) { logger . warn ( <str> , e ) ; } return false ; } return true ; } void executeHandler ( RestRequest request , RestChannel channel ) throws Exception { final RestHandler handler = getHandler ( request ) ; if ( handler ! = null ) { handler . handleRequest ( request , channel ) ; } else { if ( request . method ( ) = = RestRequest . Method . OPTIONS ) { channel . sendResponse ( new BytesRestResponse ( OK ) ) ; } else { channel . sendResponse ( new BytesRestResponse ( BAD_REQUEST , <str> + request . uri ( ) + <str> + request . method ( ) + <str> ) ) ; } } } private RestHandler getHandler ( RestRequest request ) { String path = getPath ( request ) ; RestRequest . Method method = request . method ( ) ; if ( method = = RestRequest . Method . GET ) { return getHandlers . retrieve ( path , request . params ( ) ) ; } else if ( method = = RestRequest . Method . POST ) { return postHandlers . retrieve ( path , request . params ( ) ) ; } else if ( method = = RestRequest . Method . PUT ) { return putHandlers . retrieve ( path , request . params ( ) ) ; } else if ( method = = RestRequest . Method . DELETE ) { return deleteHandlers . retrieve ( path , request . params ( ) ) ; } else if ( method = = RestRequest . Method . HEAD ) { return headHandlers . retrieve ( path , request . params ( ) ) ; } else if ( method = = RestRequest . Method . OPTIONS ) { return optionsHandlers . retrieve ( path , request . params ( ) ) ; } else { return null ; } } private String getPath ( RestRequest request ) { return request . rawPath ( ) ; } class ControllerFilterChain implements RestFilterChain { private final RestFilter executionFilter ; private final AtomicInteger index = new AtomicInteger ( ) ; ControllerFilterChain ( RestFilter executionFilter ) { this . executionFilter = executionFilter ; } @Override public void continueProcessing ( RestRequest request , RestChannel channel ) { try { int loc = index . getAndIncrement ( ) ; if ( loc > filters . length ) { throw new IllegalStateException ( <str> ) ; } else if ( loc = = filters . length ) { executionFilter . process ( request , channel , this ) ; } else { RestFilter preProcessor = filters [ loc ] ; preProcessor . process ( request , channel , this ) ; } } catch ( Exception e ) { try { channel . sendResponse ( new BytesRestResponse ( channel , e ) ) ; } catch ( IOException e1 ) { logger . error ( <str> + request . uri ( ) + <str> , e1 ) ; } } } } class RestHandlerFilter extends RestFilter { @Override public void process ( RestRequest request , RestChannel channel , RestFilterChain filterChain ) throws Exception { executeHandler ( request , channel ) ; } } } 
