package io . netty . example . http2 . tiles ; import io . netty . bootstrap . ServerBootstrap ; import io . netty . channel . Channel ; import io . netty . channel . ChannelFuture ; import io . netty . channel . ChannelInitializer ; import io . netty . channel . ChannelOption ; import io . netty . channel . EventLoopGroup ; import io . netty . channel . socket . SocketChannel ; import io . netty . channel . socket . nio . NioServerSocketChannel ; import io . netty . handler . codec . http . HttpObjectAggregator ; import io . netty . handler . codec . http . HttpRequestDecoder ; import io . netty . handler . codec . http . HttpResponseEncoder ; import io . netty . handler . logging . LogLevel ; import io . netty . handler . logging . LoggingHandler ; public final class HttpServer { public static final int PORT = Integer . parseInt ( System . getProperty ( <str> , <str> ) ) ; private static final int MAX_CONTENT_LENGTH = <int> * <int> ; private final EventLoopGroup group ; public HttpServer ( EventLoopGroup eventLoopGroup ) { group = eventLoopGroup ; } public ChannelFuture start ( ) throws Exception { ServerBootstrap b = new ServerBootstrap ( ) ; b . option ( ChannelOption . SO_BACKLOG , <int> ) ; b . group ( group ) . channel ( NioServerSocketChannel . class ) . handler ( new LoggingHandler ( LogLevel . INFO ) ) . childHandler ( new ChannelInitializer < SocketChannel > ( ) { @Override protected void initChannel ( SocketChannel ch ) throws Exception { ch . pipeline ( ) . addLast ( new HttpRequestDecoder ( ) , new HttpResponseEncoder ( ) , new HttpObjectAggregator ( MAX_CONTENT_LENGTH ) , new Http1RequestHandler ( ) ) ; } } ) ; Channel ch = b . bind ( PORT ) . sync ( ) . channel ( ) ; return ch . closeFuture ( ) ; } } 
