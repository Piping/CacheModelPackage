package org . gradle . launcher . daemon . server ; import org . gradle . api . Action ; import org . gradle . internal . concurrent . CompositeStoppable ; import org . gradle . internal . concurrent . ExecutorFactory ; import org . gradle . internal . id . UUIDGenerator ; import org . gradle . internal . serialize . Serializers ; import org . gradle . launcher . daemon . protocol . DaemonMessageSerializer ; import org . gradle . launcher . daemon . protocol . Message ; import org . gradle . messaging . remote . Address ; import org . gradle . messaging . remote . ConnectionAcceptor ; import org . gradle . messaging . remote . internal . ConnectCompletion ; import org . gradle . messaging . remote . internal . IncomingConnector ; import org . gradle . messaging . remote . internal . KryoBackedMessageSerializer ; import org . gradle . messaging . remote . internal . MessageSerializer ; import org . gradle . messaging . remote . internal . inet . InetAddressFactory ; import org . gradle . messaging . remote . internal . inet . TcpIncomingConnector ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class DaemonTcpServerConnector implements DaemonServerConnector { final private IncomingConnector incomingConnector ; private boolean started ; private boolean stopped ; private final Lock lifecycleLock = new ReentrantLock ( ) ; private ConnectionAcceptor acceptor ; public DaemonTcpServerConnector ( ExecutorFactory executorFactory , InetAddressFactory inetAddressFactory ) { this . incomingConnector = new TcpIncomingConnector ( executorFactory , inetAddressFactory , new UUIDGenerator ( ) ) ; } public Address start ( final IncomingConnectionHandler handler ) { lifecycleLock . lock ( ) ; try { if ( stopped ) { throw new IllegalStateException ( <str> ) ; } if ( started ) { throw new IllegalStateException ( <str> ) ; } Action < ConnectCompletion > connectEvent = new Action < ConnectCompletion > ( ) { public void execute ( ConnectCompletion completion ) { MessageSerializer < Message > serializer = new KryoBackedMessageSerializer < Message > ( Serializers . stateful ( DaemonMessageSerializer . create ( ) ) ) ; handler . handle ( new SynchronizedDispatchConnection < Message > ( completion . create ( serializer ) ) ) ; } } ; acceptor = incomingConnector . accept ( connectEvent , false ) ; started = true ; return acceptor . getAddress ( ) ; } finally { lifecycleLock . unlock ( ) ; } } public void stop ( ) { lifecycleLock . lock ( ) ; try { stopped = true ; } finally { lifecycleLock . unlock ( ) ; } CompositeStoppable . stoppable ( acceptor , incomingConnector ) . stop ( ) ; } } 
