package com . badlogic . gdx . graphics . g2d ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Pixmap ; import com . badlogic . gdx . graphics . Pixmap . Blending ; import com . badlogic . gdx . graphics . Pixmap . Format ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . Texture . TextureFilter ; import com . badlogic . gdx . graphics . glutils . PixmapTextureData ; import com . badlogic . gdx . math . Rectangle ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . OrderedMap ; public class PixmapPacker implements Disposable { static private final boolean debug = false ; static private final String ANONYMOUS = <str> ; final int pageWidth , pageHeight ; final Format pageFormat ; final int padding ; final boolean duplicateBorder ; final Array < Page > pages = new Array ( ) ; Page current ; boolean packToTexture ; boolean disposed ; public PixmapPacker ( int pageWidth , int pageHeight , Format pageFormat , int padding , boolean duplicateBorder ) { this . pageWidth = pageWidth ; this . pageHeight = pageHeight ; this . pageFormat = pageFormat ; this . padding = padding ; this . duplicateBorder = duplicateBorder ; newPage ( ) ; } public synchronized Rectangle pack ( Pixmap image ) { return pack ( null , image ) ; } public synchronized Rectangle pack ( String name , Pixmap image ) { if ( disposed ) return null ; if ( name ! = null & & getRect ( name ) ! = null ) throw new GdxRuntimeException ( <str> + name ) ; int borderPixels = ( padding + ( duplicateBorder ? <int> : <int> ) ) < < <int> ; Rectangle rect = new Rectangle ( <int> , <int> , image . getWidth ( ) + borderPixels , image . getHeight ( ) + borderPixels ) ; if ( rect . getWidth ( ) > pageWidth | | rect . getHeight ( ) > pageHeight ) { if ( name = = null ) throw new GdxRuntimeException ( <str> ) ; throw new GdxRuntimeException ( <str> + name ) ; } Node node = insert ( current . root , rect ) ; if ( node = = null ) { newPage ( ) ; return pack ( name , image ) ; } node . leafName = name = = null ? ANONYMOUS : name ; rect = new Rectangle ( node . rect ) ; rect . width - = borderPixels ; rect . height - = borderPixels ; borderPixels > > = <int> ; rect . x + = borderPixels ; rect . y + = borderPixels ; if ( name ! = null ) { current . rects . put ( name , rect ) ; current . addedRects . add ( name ) ; } int rectX = ( int ) rect . x , rectY = ( int ) rect . y , rectWidth = ( int ) rect . width , rectHeight = ( int ) rect . height ; if ( packToTexture & & ! duplicateBorder & & current . texture ! = null & & ! current . dirty ) { if ( debug ) System . out . println ( <str> ) ; current . texture . bind ( ) ; Gdx . gl . glTexSubImage2D ( current . texture . glTarget , <int> , rectX , rectY , rectWidth , rectHeight , image . getGLFormat ( ) , image . getGLType ( ) , image . getPixels ( ) ) ; } else current . dirty = true ; Blending blending = Pixmap . getBlending ( ) ; Pixmap . setBlending ( Blending . None ) ; current . image . drawPixmap ( image , rectX , rectY ) ; if ( duplicateBorder ) { int imageWidth = image . getWidth ( ) , imageHeight = image . getHeight ( ) ; current . image . drawPixmap ( image , <int> , <int> , <int> , <int> , rectX - <int> , rectY - <int> , <int> , <int> ) ; current . image . drawPixmap ( image , imageWidth - <int> , <int> , <int> , <int> , rectX + rectWidth , rectY - <int> , <int> , <int> ) ; current . image . drawPixmap ( image , <int> , imageHeight - <int> , <int> , <int> , rectX - <int> , rectY + rectHeight , <int> , <int> ) ; current . image . drawPixmap ( image , imageWidth - <int> , imageHeight - <int> , <int> , <int> , rectX + rectWidth , rectY + rectHeight , <int> , <int> ) ; current . image . drawPixmap ( image , <int> , <int> , imageWidth , <int> , rectX , rectY - <int> , rectWidth , <int> ) ; current . image . drawPixmap ( image , <int> , imageHeight - <int> , imageWidth , <int> , rectX , rectY + rectHeight , rectWidth , <int> ) ; current . image . drawPixmap ( image , <int> , <int> , <int> , imageHeight , rectX - <int> , rectY , <int> , rectHeight ) ; current . image . drawPixmap ( image , imageWidth - <int> , <int> , <int> , imageHeight , rectX + rectWidth , rectY , <int> , rectHeight ) ; } Pixmap . setBlending ( blending ) ; return rect ; } private void newPage ( ) { Page page = new Page ( ) ; page . image = new Pixmap ( pageWidth , pageHeight , pageFormat ) ; page . root = new Node ( <int> , <int> , pageWidth , pageHeight , null , null , null ) ; page . rects = new OrderedMap ( ) ; pages . add ( page ) ; current = page ; } private Node insert ( Node node , Rectangle rect ) { if ( node . leafName = = null & & node . leftChild ! = null & & node . rightChild ! = null ) { Node newNode = insert ( node . leftChild , rect ) ; if ( newNode = = null ) newNode = insert ( node . rightChild , rect ) ; return newNode ; } else { if ( node . leafName ! = null ) return null ; if ( node . rect . width = = rect . width & & node . rect . height = = rect . height ) return node ; if ( node . rect . width < rect . width | | node . rect . height < rect . height ) return null ; node . leftChild = new Node ( ) ; node . rightChild = new Node ( ) ; int deltaWidth = ( int ) node . rect . width - ( int ) rect . width ; int deltaHeight = ( int ) node . rect . height - ( int ) rect . height ; if ( deltaWidth > deltaHeight ) { node . leftChild . rect . x = node . rect . x ; node . leftChild . rect . y = node . rect . y ; node . leftChild . rect . width = rect . width ; node . leftChild . rect . height = node . rect . height ; node . rightChild . rect . x = node . rect . x + rect . width ; node . rightChild . rect . y = node . rect . y ; node . rightChild . rect . width = node . rect . width - rect . width ; node . rightChild . rect . height = node . rect . height ; } else { node . leftChild . rect . x = node . rect . x ; node . leftChild . rect . y = node . rect . y ; node . leftChild . rect . width = node . rect . width ; node . leftChild . rect . height = rect . height ; node . rightChild . rect . x = node . rect . x ; node . rightChild . rect . y = node . rect . y + rect . height ; node . rightChild . rect . width = node . rect . width ; node . rightChild . rect . height = node . rect . height - rect . height ; } return insert ( node . leftChild , rect ) ; } } public Array < Page > getPages ( ) { return pages ; } public synchronized Rectangle getRect ( String name ) { for ( Page page : pages ) { Rectangle rect = page . rects . get ( name ) ; if ( rect ! = null ) return rect ; } return null ; } public synchronized Page getPage ( String name ) { for ( Page page : pages ) { Rectangle rect = page . rects . get ( name ) ; if ( rect ! = null ) return page ; } return null ; } public synchronized int getPageIndex ( String name ) { for ( int i = <int> ; i < pages . size ; i + + ) { Rectangle rect = pages . get ( i ) . rects . get ( name ) ; if ( rect ! = null ) return i ; } return - <int> ; } public synchronized void dispose ( ) { for ( Page page : pages ) { if ( page . texture = = null ) { page . image . dispose ( ) ; } } disposed = true ; } public synchronized TextureAtlas generateTextureAtlas ( TextureFilter minFilter , TextureFilter magFilter , boolean useMipMaps ) { TextureAtlas atlas = new TextureAtlas ( ) ; updateTextureAtlas ( atlas , minFilter , magFilter , useMipMaps ) ; return atlas ; } public synchronized void updateTextureAtlas ( TextureAtlas atlas , TextureFilter minFilter , TextureFilter magFilter , boolean useMipMaps ) { updatePageTextures ( minFilter , magFilter , useMipMaps ) ; for ( Page page : pages ) { if ( page . addedRects . size > <int> ) { for ( String name : page . addedRects ) { Rectangle rect = page . rects . get ( name ) ; TextureRegion region = new TextureRegion ( page . texture , ( int ) rect . x , ( int ) rect . y , ( int ) rect . width , ( int ) rect . height ) ; atlas . addRegion ( name , region ) ; } page . addedRects . clear ( ) ; atlas . getTextures ( ) . add ( page . texture ) ; } } } public synchronized void updateTextureRegions ( Array < TextureRegion > regions , TextureFilter minFilter , TextureFilter magFilter , boolean useMipMaps ) { updatePageTextures ( minFilter , magFilter , useMipMaps ) ; while ( regions . size < pages . size ) regions . add ( new TextureRegion ( pages . get ( regions . size ) . texture ) ) ; } public synchronized void updatePageTextures ( TextureFilter minFilter , TextureFilter magFilter , boolean useMipMaps ) { for ( Page page : pages ) page . updateTexture ( minFilter , magFilter , useMipMaps ) ; } public int getPageWidth ( ) { return pageWidth ; } public int getPageHeight ( ) { return pageHeight ; } public int getPadding ( ) { return padding ; } public boolean getDuplicateBorder ( ) { return duplicateBorder ; } public boolean getPackToTexture ( ) { return packToTexture ; } public void setPackToTexture ( boolean packToTexture ) { this . packToTexture = packToTexture ; } static final class Node { public Node leftChild ; public Node rightChild ; public Rectangle rect ; public String leafName ; public Node ( int x , int y , int width , int height , Node leftChild , Node rightChild , String leafName ) { rect = new Rectangle ( x , y , width , height ) ; this . leftChild = leftChild ; this . rightChild = rightChild ; this . leafName = leafName ; } public Node ( ) { rect = new Rectangle ( ) ; } } static public class Page { Node root ; OrderedMap < String , Rectangle > rects ; Pixmap image ; Texture texture ; final Array < String > addedRects = new Array ( ) ; boolean dirty ; public Pixmap getPixmap ( ) { return image ; } public OrderedMap < String , Rectangle > getRects ( ) { return rects ; } public Texture getTexture ( ) { return texture ; } public boolean updateTexture ( TextureFilter minFilter , TextureFilter magFilter , boolean useMipMaps ) { if ( texture ! = null ) { if ( ! dirty ) return false ; if ( debug ) System . out . println ( <str> ) ; texture . load ( texture . getTextureData ( ) ) ; } else { if ( debug ) System . out . println ( <str> ) ; texture = new Texture ( new PixmapTextureData ( image , image . getFormat ( ) , useMipMaps , false , true ) ) { @Override public void dispose ( ) { super . dispose ( ) ; image . dispose ( ) ; } } ; texture . setFilter ( minFilter , magFilter ) ; } dirty = false ; return true ; } } } 
