package org . gradle . foundation . ipc . gradle ; import org . gradle . BuildListener ; import org . gradle . BuildResult ; import org . gradle . api . Task ; import org . gradle . api . execution . TaskExecutionGraph ; import org . gradle . api . execution . TaskExecutionGraphListener ; import org . gradle . api . execution . TaskExecutionListener ; import org . gradle . api . initialization . Settings ; import org . gradle . api . invocation . Gradle ; import org . gradle . api . logging . Logger ; import org . gradle . api . logging . Logging ; import org . gradle . api . logging . StandardOutputListener ; import org . gradle . api . tasks . TaskState ; import org . gradle . foundation . ipc . basic . ClientProcess ; import org . gradle . foundation . ipc . basic . MessageObject ; import org . gradle . foundation . ipc . basic . Server ; import org . gradle . gradleplugin . foundation . GradlePluginLord ; import java . net . Socket ; import java . util . List ; import java . util . Timer ; import java . util . TimerTask ; public class ExecuteGradleCommandClientProtocol implements ClientProcess . Protocol { private final Logger logger = Logging . getLogger ( ExecuteGradleCommandClientProtocol . class ) ; private ClientProcess client ; private boolean continueConnection = true ; private Gradle gradle ; private Server localServer ; public ExecuteGradleCommandClientProtocol ( Gradle gradle ) { this . gradle = gradle ; } public void initialize ( ClientProcess client ) { this . client = client ; gradle . addListener ( new IPCExecutionListener ( client ) ) ; } public boolean serverConnected ( Socket clientSocket ) { MessageObject message = client . readMessage ( ) ; if ( message = = null ) { return false ; } if ( ! ProtocolConstants . HANDSHAKE_TYPE . equalsIgnoreCase ( message . getMessageType ( ) ) ) { logger . error ( <str> ) ; return false ; } localServer = new Server ( new KillGradleServerProtocol ( ) ) ; localServer . start ( ) ; client . sendMessage ( ProtocolConstants . HANDSHAKE_TYPE , ProtocolConstants . HANDSHAKE_CLIENT , localServer . getPort ( ) ) ; return true ; } public boolean continueConnection ( ) { return continueConnection ; } public void shutdown ( ) { continueConnection = false ; } private class IPCExecutionListener implements BuildListener , StandardOutputListener , TaskExecutionGraphListener , TaskExecutionListener { private ClientProcess client ; private StringBuffer allOutputText = new StringBuffer ( ) ; private StringBuffer bufferedLiveOutput = new StringBuffer ( ) ; private Timer liveOutputTimer ; private float totalTasksToExecute ; private float totalTasksExecuted ; private float percentComplete ; public IPCExecutionListener ( ClientProcess client ) { this . client = client ; liveOutputTimer = new Timer ( ) ; liveOutputTimer . scheduleAtFixedRate ( new TimerTask ( ) { @Override public void run ( ) { sendLiveOutput ( ) ; } } , <int> , <int> ) ; } public void buildStarted ( Gradle build ) { } public void graphPopulated ( TaskExecutionGraph taskExecutionGraph ) { List < Task > taskList = taskExecutionGraph . getAllTasks ( ) ; this . totalTasksToExecute = taskList . size ( ) ; client . sendMessage ( ProtocolConstants . NUMBER_OF_TASKS_TO_EXECUTE , null , new Integer ( taskList . size ( ) ) ) ; } public void settingsEvaluated ( Settings settings ) { } public void projectsLoaded ( Gradle gradle ) { } public void projectsEvaluated ( Gradle gradle ) { } public void beforeExecute ( Task task ) { String currentTaskName = task . getProject ( ) . getName ( ) + <str> + task . getName ( ) ; client . sendMessage ( ProtocolConstants . TASK_STARTED_TYPE , currentTaskName , new Float ( percentComplete ) ) ; } public void afterExecute ( Task task , TaskState state ) { totalTasksExecuted + + ; percentComplete = ( totalTasksExecuted / totalTasksToExecute ) * <int> ; String currentTaskName = task . getProject ( ) . getName ( ) + <str> + task . getName ( ) ; client . sendMessage ( ProtocolConstants . TASK_COMPLETE_TYPE , currentTaskName , new Float ( percentComplete ) ) ; } public synchronized void onOutput ( CharSequence output ) { this . allOutputText . append ( output ) ; this . bufferedLiveOutput . append ( output ) ; } private synchronized void sendLiveOutput ( ) { if ( bufferedLiveOutput . length ( ) = = <int> ) { return ; } String text = bufferedLiveOutput . toString ( ) ; bufferedLiveOutput = new StringBuffer ( ) ; client . sendMessage ( ProtocolConstants . LIVE_OUTPUT_TYPE , text ) ; } public void buildFinished ( BuildResult buildResult ) { boolean wasSuccessful = buildResult . getFailure ( ) = = null ; String output = allOutputText . toString ( ) ; liveOutputTimer . cancel ( ) ; sendLiveOutput ( ) ; String details = GradlePluginLord . getGradleExceptionMessage ( buildResult . getFailure ( ) , gradle . getStartParameter ( ) . getShowStacktrace ( ) ) ; output + = details ; client . sendMessage ( ProtocolConstants . EXECUTION_COMPLETED_TYPE , output , wasSuccessful ) ; client . sendMessage ( ProtocolConstants . EXITING , null , null ) ; client . stop ( ) ; } } } 
