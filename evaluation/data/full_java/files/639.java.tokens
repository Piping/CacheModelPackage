package org . apache . cassandra . hints ; import java . io . File ; import java . io . IOException ; import java . nio . ByteBuffer ; import java . util . * ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . cql3 . QueryProcessor ; import org . apache . cassandra . cql3 . UntypedResultSet ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . db . marshal . UUIDType ; import org . apache . cassandra . db . partitions . PartitionUpdate ; import org . apache . cassandra . io . FSWriteError ; import org . apache . cassandra . io . sstable . Descriptor ; import org . apache . cassandra . io . util . DataInputBuffer ; import org . apache . cassandra . io . util . FileUtils ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . FBUtilities ; @SuppressWarnings ( <str> ) public final class LegacyHintsMigrator { private static final Logger logger = LoggerFactory . getLogger ( LegacyHintsMigrator . class ) ; private final File hintsDirectory ; private final long maxHintsFileSize ; private final ColumnFamilyStore legacyHintsTable ; private final int pageSize ; public LegacyHintsMigrator ( File hintsDirectory , long maxHintsFileSize ) { this . hintsDirectory = hintsDirectory ; this . maxHintsFileSize = maxHintsFileSize ; legacyHintsTable = Keyspace . open ( SystemKeyspace . NAME ) . getColumnFamilyStore ( SystemKeyspace . LEGACY_HINTS ) ; pageSize = calculatePageSize ( legacyHintsTable ) ; } private static int calculatePageSize ( ColumnFamilyStore legacyHintsTable ) { int size = <int> ; int meanCellCount = legacyHintsTable . getMeanColumns ( ) ; double meanPartitionSize = legacyHintsTable . getMeanPartitionSize ( ) ; if ( meanCellCount ! = <int> & & meanPartitionSize ! = <int> ) { int avgHintSize = ( int ) meanPartitionSize / meanCellCount ; size = Math . max ( <int> , Math . min ( size , ( <int> < < <int> ) / avgHintSize ) ) ; } return size ; } public void migrate ( ) { if ( legacyHintsTable . isEmpty ( ) ) return ; logger . info ( <str> ) ; logger . info ( <str> , SystemKeyspace . NAME , SystemKeyspace . LEGACY_HINTS ) ; compactLegacyHints ( ) ; logger . info ( <str> ) ; migrateLegacyHints ( ) ; logger . info ( <str> , SystemKeyspace . NAME , SystemKeyspace . LEGACY_HINTS ) ; legacyHintsTable . truncateBlocking ( ) ; } private void compactLegacyHints ( ) { Collection < Descriptor > descriptors = new ArrayList < > ( ) ; legacyHintsTable . getTracker ( ) . getUncompacting ( ) . forEach ( sstable - > descriptors . add ( sstable . descriptor ) ) ; if ( ! descriptors . isEmpty ( ) ) forceCompaction ( descriptors ) ; } private void forceCompaction ( Collection < Descriptor > descriptors ) { try { CompactionManager . instance . submitUserDefined ( legacyHintsTable , descriptors , FBUtilities . nowInSeconds ( ) ) . get ( ) ; } catch ( InterruptedException | ExecutionException e ) { throw new RuntimeException ( e ) ; } } private void migrateLegacyHints ( ) { ByteBuffer buffer = ByteBuffer . allocateDirect ( <int> * <int> ) ; String query = String . format ( <str> , SystemKeyspace . NAME , SystemKeyspace . LEGACY_HINTS ) ; QueryProcessor . executeInternal ( query ) . forEach ( row - > migrateLegacyHints ( row . getUUID ( <str> ) , buffer ) ) ; FileUtils . clean ( buffer ) ; } private void migrateLegacyHints ( UUID hostId , ByteBuffer buffer ) { String query = String . format ( <str> + <str> + <str> , SystemKeyspace . NAME , SystemKeyspace . LEGACY_HINTS ) ; UntypedResultSet rows = QueryProcessor . executeInternalWithPaging ( query , pageSize , hostId ) ; migrateLegacyHints ( hostId , rows , buffer ) ; deleteLegacyHintsPartition ( hostId ) ; } private void migrateLegacyHints ( UUID hostId , UntypedResultSet rows , ByteBuffer buffer ) { migrateLegacyHints ( hostId , rows . iterator ( ) , buffer ) ; } private void migrateLegacyHints ( UUID hostId , Iterator < UntypedResultSet . Row > iterator , ByteBuffer buffer ) { do { migrateLegacyHintsInternal ( hostId , iterator , buffer ) ; } while ( iterator . hasNext ( ) ) ; } private void migrateLegacyHintsInternal ( UUID hostId , Iterator < UntypedResultSet . Row > iterator , ByteBuffer buffer ) { HintsDescriptor descriptor = new HintsDescriptor ( hostId , System . currentTimeMillis ( ) ) ; try ( HintsWriter writer = HintsWriter . create ( hintsDirectory , descriptor ) ) { try ( HintsWriter . Session session = writer . newSession ( buffer ) ) { while ( iterator . hasNext ( ) ) { Hint hint = convertLegacyHint ( iterator . next ( ) ) ; if ( hint ! = null ) session . append ( hint ) ; if ( session . position ( ) > = maxHintsFileSize ) break ; } } } catch ( IOException e ) { throw new FSWriteError ( e , descriptor . fileName ( ) ) ; } } private static Hint convertLegacyHint ( UntypedResultSet . Row row ) { Mutation mutation = deserializeLegacyMutation ( row ) ; if ( mutation = = null ) return null ; long creationTime = row . getLong ( <str> ) ; int expirationTime = FBUtilities . nowInSeconds ( ) + row . getInt ( <str> ) ; int originalGCGS = expirationTime - ( int ) TimeUnit . MILLISECONDS . toSeconds ( creationTime ) ; int gcgs = Math . min ( originalGCGS , mutation . smallestGCGS ( ) ) ; return Hint . create ( mutation , creationTime , gcgs ) ; } private static Mutation deserializeLegacyMutation ( UntypedResultSet . Row row ) { try ( DataInputBuffer dib = new DataInputBuffer ( row . getBlob ( <str> ) , true ) ) { Mutation mutation = Mutation . serializer . deserialize ( dib , row . getInt ( <str> ) ) ; mutation . getPartitionUpdates ( ) . forEach ( PartitionUpdate : : validate ) ; return mutation ; } catch ( IOException e ) { logger . error ( <str> , row . getUUID ( <str> ) , SystemKeyspace . NAME , SystemKeyspace . LEGACY_HINTS , e ) ; return null ; } catch ( MarshalException e ) { logger . warn ( <str> , row . getUUID ( <str> ) , SystemKeyspace . NAME , SystemKeyspace . LEGACY_HINTS , e ) ; return null ; } } private static void deleteLegacyHintsPartition ( UUID hostId ) { Mutation mutation = new Mutation ( PartitionUpdate . fullPartitionDelete ( SystemKeyspace . LegacyHints , UUIDType . instance . decompose ( hostId ) , System . currentTimeMillis ( ) , FBUtilities . nowInSeconds ( ) ) ) ; mutation . applyUnsafe ( ) ; } } 
