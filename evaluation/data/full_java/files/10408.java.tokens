package com . google . common . collect ; import com . google . common . util . concurrent . Uninterruptibles ; import junit . framework . TestCase ; import java . util . Collection ; import java . util . List ; import java . util . concurrent . ArrayBlockingQueue ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Executors ; import java . util . concurrent . Future ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . PriorityBlockingQueue ; import java . util . concurrent . SynchronousQueue ; import java . util . concurrent . TimeUnit ; public class QueuesTest extends TestCase { public static List < BlockingQueue < Object > > blockingQueues ( ) { return ImmutableList . < BlockingQueue < Object > > of ( new LinkedBlockingQueue < Object > ( ) , new LinkedBlockingQueue < Object > ( <int> ) , new SynchronousQueue < Object > ( ) , new ArrayBlockingQueue < Object > ( <int> ) , new PriorityBlockingQueue < Object > ( <int> , Ordering . arbitrary ( ) ) ) ; } private ExecutorService threadPool ; @Override public void setUp ( ) { threadPool = Executors . newCachedThreadPool ( ) ; } @Override public void tearDown ( ) throws InterruptedException { threadPool . shutdown ( ) ; assertTrue ( <str> , threadPool . awaitTermination ( <int> , TimeUnit . SECONDS ) ) ; } private static < T > int drain ( BlockingQueue < T > q , Collection < ? super T > buffer , int maxElements , long timeout , TimeUnit unit , boolean interruptibly ) throws InterruptedException { return interruptibly ? Queues . drain ( q , buffer , maxElements , timeout , unit ) : Queues . drainUninterruptibly ( q , buffer , maxElements , timeout , unit ) ; } public void testMultipleProducers ( ) throws Exception { for ( BlockingQueue < Object > q : blockingQueues ( ) ) { testMultipleProducers ( q ) ; } } private void testMultipleProducers ( BlockingQueue < Object > q ) throws InterruptedException { for ( boolean interruptibly : new boolean [ ] { true , false } ) { threadPool . submit ( new Producer ( q , <int> ) ) ; threadPool . submit ( new Producer ( q , <int> ) ) ; threadPool . submit ( new Producer ( q , <int> ) ) ; threadPool . submit ( new Producer ( q , <int> ) ) ; threadPool . submit ( new Producer ( q , <int> ) ) ; List < Object > buf = Lists . newArrayList ( ) ; int elements = drain ( q , buf , <int> , Long . MAX_VALUE , TimeUnit . NANOSECONDS , interruptibly ) ; assertEquals ( <int> , elements ) ; assertEquals ( <int> , buf . size ( ) ) ; assertDrained ( q ) ; } } public void testDrainTimesOut ( ) throws Exception { for ( BlockingQueue < Object > q : blockingQueues ( ) ) { testDrainTimesOut ( q ) ; } } private void testDrainTimesOut ( BlockingQueue < Object > q ) throws Exception { for ( boolean interruptibly : new boolean [ ] { true , false } ) { assertEquals ( <int> , Queues . drain ( q , ImmutableList . of ( ) , <int> , <int> , TimeUnit . MILLISECONDS ) ) ; Future < ? > submitter = threadPool . submit ( new Producer ( q , <int> ) ) ; long startTime = System . nanoTime ( ) ; int drained = drain ( q , Lists . newArrayList ( ) , <int> , <int> , TimeUnit . MILLISECONDS , interruptibly ) ; assertTrue ( drained < = <int> ) ; assertTrue ( ( System . nanoTime ( ) - startTime ) > = TimeUnit . MILLISECONDS . toNanos ( <int> ) ) ; submitter . get ( ) ; if ( drained = = <int> ) { assertNotNull ( q . poll ( ) ) ; } } } public void testZeroElements ( ) throws Exception { for ( BlockingQueue < Object > q : blockingQueues ( ) ) { testZeroElements ( q ) ; } } private void testZeroElements ( BlockingQueue < Object > q ) throws InterruptedException { for ( boolean interruptibly : new boolean [ ] { true , false } ) { assertEquals ( <int> , drain ( q , ImmutableList . of ( ) , <int> , <int> , TimeUnit . MILLISECONDS , interruptibly ) ) ; } } public void testEmpty ( ) throws Exception { for ( BlockingQueue < Object > q : blockingQueues ( ) ) { testEmpty ( q ) ; } } private void testEmpty ( BlockingQueue < Object > q ) { assertDrained ( q ) ; } public void testNegativeMaxElements ( ) throws Exception { for ( BlockingQueue < Object > q : blockingQueues ( ) ) { testNegativeMaxElements ( q ) ; } } private void testNegativeMaxElements ( BlockingQueue < Object > q ) throws InterruptedException { threadPool . submit ( new Producer ( q , <int> ) ) ; List < Object > buf = Lists . newArrayList ( ) ; int elements = Queues . drain ( q , buf , - <int> , Long . MAX_VALUE , TimeUnit . NANOSECONDS ) ; assertEquals ( elements , <int> ) ; assertTrue ( buf . isEmpty ( ) ) ; Queues . drain ( q , buf , <int> , Long . MAX_VALUE , TimeUnit . NANOSECONDS ) ; } public void testDrain_throws ( ) throws Exception { for ( BlockingQueue < Object > q : blockingQueues ( ) ) { testDrain_throws ( q ) ; } } private void testDrain_throws ( BlockingQueue < Object > q ) { threadPool . submit ( new Interrupter ( Thread . currentThread ( ) ) ) ; try { Queues . drain ( q , ImmutableList . of ( ) , <int> , Long . MAX_VALUE , TimeUnit . NANOSECONDS ) ; fail ( ) ; } catch ( InterruptedException expected ) { } } public void testDrainUninterruptibly_doesNotThrow ( ) throws Exception { for ( BlockingQueue < Object > q : blockingQueues ( ) ) { testDrainUninterruptibly_doesNotThrow ( q ) ; } } private void testDrainUninterruptibly_doesNotThrow ( final BlockingQueue < Object > q ) { final Thread mainThread = Thread . currentThread ( ) ; threadPool . submit ( new Runnable ( ) { public void run ( ) { new Producer ( q , <int> ) . run ( ) ; new Interrupter ( mainThread ) . run ( ) ; new Producer ( q , <int> ) . run ( ) ; } } ) ; List < Object > buf = Lists . newArrayList ( ) ; int elements = Queues . drainUninterruptibly ( q , buf , <int> , Long . MAX_VALUE , TimeUnit . NANOSECONDS ) ; assertTrue ( Thread . interrupted ( ) ) ; assertEquals ( <int> , elements ) ; assertEquals ( <int> , buf . size ( ) ) ; } public void testNewLinkedBlockingDequeCapacity ( ) { try { Queues . newLinkedBlockingDeque ( <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( <int> , Queues . newLinkedBlockingDeque ( <int> ) . remainingCapacity ( ) ) ; assertEquals ( <int> , Queues . newLinkedBlockingDeque ( <int> ) . remainingCapacity ( ) ) ; } public void testNewLinkedBlockingQueueCapacity ( ) { try { Queues . newLinkedBlockingQueue ( <int> ) ; fail ( <str> ) ; } catch ( IllegalArgumentException expected ) { } assertEquals ( <int> , Queues . newLinkedBlockingQueue ( <int> ) . remainingCapacity ( ) ) ; assertEquals ( <int> , Queues . newLinkedBlockingQueue ( <int> ) . remainingCapacity ( ) ) ; } private void assertDrained ( BlockingQueue < Object > q ) { assertNull ( q . peek ( ) ) ; assertInterruptibleDrained ( q ) ; assertUninterruptibleDrained ( q ) ; } private void assertInterruptibleDrained ( BlockingQueue < Object > q ) { try { assertEquals ( <int> , Queues . drain ( q , ImmutableList . of ( ) , <int> , <int> , TimeUnit . MILLISECONDS ) ) ; } catch ( InterruptedException e ) { throw new AssertionError ( ) ; } threadPool . submit ( new Interrupter ( Thread . currentThread ( ) ) ) ; try { Queues . drain ( q , Lists . newArrayList ( ) , <int> , Long . MAX_VALUE , TimeUnit . NANOSECONDS ) ; fail ( ) ; } catch ( InterruptedException expected ) { } } private void assertUninterruptibleDrained ( BlockingQueue < Object > q ) { assertEquals ( <int> , Queues . drainUninterruptibly ( q , ImmutableList . of ( ) , <int> , <int> , TimeUnit . MILLISECONDS ) ) ; threadPool . submit ( new Interrupter ( Thread . currentThread ( ) ) ) ; long startTime = System . nanoTime ( ) ; Queues . drainUninterruptibly ( q , Lists . newArrayList ( ) , <int> , <int> , TimeUnit . MILLISECONDS ) ; assertTrue ( ( System . nanoTime ( ) - startTime ) > = TimeUnit . MILLISECONDS . toNanos ( <int> ) ) ; while ( ! Thread . interrupted ( ) ) { Thread . yield ( ) ; } } private static class Producer implements Runnable { final BlockingQueue < Object > q ; final int elements ; Producer ( BlockingQueue < Object > q , int elements ) { this . q = q ; this . elements = elements ; } @Override public void run ( ) { try { for ( int i = <int> ; i < elements ; i + + ) { q . put ( new Object ( ) ) ; } } catch ( InterruptedException e ) { e . printStackTrace ( ) ; Uninterruptibles . sleepUninterruptibly ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } } } private static class Interrupter implements Runnable { final Thread threadToInterrupt ; Interrupter ( Thread threadToInterrupt ) { this . threadToInterrupt = threadToInterrupt ; } @Override public void run ( ) { try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { throw new AssertionError ( ) ; } finally { threadToInterrupt . interrupt ( ) ; } } } } 
