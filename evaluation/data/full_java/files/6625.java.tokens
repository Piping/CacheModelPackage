package org . elasticsearch . index . query ; import org . apache . lucene . queries . TermsQuery ; import org . apache . lucene . search . Query ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . search . Queries ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . mapper . Uid ; import org . elasticsearch . index . mapper . internal . UidFieldMapper ; import java . io . IOException ; import java . util . * ; public class IdsQueryBuilder extends AbstractQueryBuilder < IdsQueryBuilder > { public static final String NAME = <str> ; private final Set < String > ids = new HashSet < > ( ) ; private final String [ ] types ; static final IdsQueryBuilder PROTOTYPE = new IdsQueryBuilder ( ) ; public IdsQueryBuilder ( ) { this . types = new String [ <int> ] ; } public IdsQueryBuilder ( String . . . types ) { if ( types = = null ) { throw new IllegalArgumentException ( <str> ) ; } this . types = types ; } public String [ ] types ( ) { return this . types ; } public IdsQueryBuilder addIds ( String . . . ids ) { if ( ids = = null ) { throw new IllegalArgumentException ( <str> ) ; } Collections . addAll ( this . ids , ids ) ; return this ; } public Set < String > ids ( ) { return this . ids ; } @Override protected void doXContent ( XContentBuilder builder , Params params ) throws IOException { builder . startObject ( NAME ) ; builder . array ( IdsQueryParser . TYPE_FIELD . getPreferredName ( ) , types ) ; builder . startArray ( IdsQueryParser . VALUES_FIELD . getPreferredName ( ) ) ; for ( String value : ids ) { builder . value ( value ) ; } builder . endArray ( ) ; printBoostAndQueryName ( builder ) ; builder . endObject ( ) ; } @Override public String getWriteableName ( ) { return NAME ; } @Override protected Query doToQuery ( QueryShardContext context ) throws IOException { Query query ; if ( this . ids . isEmpty ( ) ) { query = Queries . newMatchNoDocsQuery ( ) ; } else { Collection < String > typesForQuery ; if ( types . length = = <int> ) { typesForQuery = context . queryTypes ( ) ; } else if ( types . length = = <int> & & MetaData . ALL . equals ( types [ <int> ] ) ) { typesForQuery = context . getMapperService ( ) . types ( ) ; } else { typesForQuery = new HashSet < > ( ) ; Collections . addAll ( typesForQuery , types ) ; } query = new TermsQuery ( UidFieldMapper . NAME , Uid . createUidsForTypesAndIds ( typesForQuery , ids ) ) ; } return query ; } @Override protected IdsQueryBuilder doReadFrom ( StreamInput in ) throws IOException { IdsQueryBuilder idsQueryBuilder = new IdsQueryBuilder ( in . readStringArray ( ) ) ; idsQueryBuilder . addIds ( in . readStringArray ( ) ) ; return idsQueryBuilder ; } @Override protected void doWriteTo ( StreamOutput out ) throws IOException { out . writeStringArray ( types ) ; out . writeStringArray ( ids . toArray ( new String [ ids . size ( ) ] ) ) ; } @Override protected int doHashCode ( ) { return Objects . hash ( ids , Arrays . hashCode ( types ) ) ; } @Override protected boolean doEquals ( IdsQueryBuilder other ) { return Objects . equals ( ids , other . ids ) & & Arrays . equals ( types , other . types ) ; } } 
