package org . gradle . api . internal . resolve ; import com . google . common . base . Function ; import com . google . common . base . Joiner ; import com . google . common . base . Predicate ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import com . google . common . collect . Ordering ; import org . gradle . api . artifacts . component . LibraryComponentSelector ; import org . gradle . platform . base . BinarySpec ; import org . gradle . platform . base . LibrarySpec ; import java . util . Collection ; import java . util . List ; import java . util . Map ; public interface LibraryResolutionErrorMessageBuilder { String multipleCompatibleVariantsErrorMessage ( String libraryName , Collection < ? extends BinarySpec > binaries ) ; String noCompatibleVariantErrorMessage ( String libraryName , Collection < BinarySpec > allBinaries ) ; class LibraryResolutionResult { private static final LibraryResolutionResult EMPTY = new LibraryResolutionResult ( ) ; private static final LibraryResolutionResult PROJECT_NOT_FOUND = new LibraryResolutionResult ( ) ; private final Map < String , LibrarySpec > libsMatchingRequirements ; private final Map < String , LibrarySpec > libsNotMatchingRequirements ; private LibrarySpec selectedLibrary ; private LibrarySpec nonMatchingLibrary ; private LibraryResolutionResult ( ) { this . libsMatchingRequirements = Maps . newHashMap ( ) ; this . libsNotMatchingRequirements = Maps . newHashMap ( ) ; } private LibrarySpec getSingleMatchingLibrary ( ) { if ( libsMatchingRequirements . size ( ) = = <int> ) { return libsMatchingRequirements . values ( ) . iterator ( ) . next ( ) ; } return null ; } private void resolve ( String libraryName ) { if ( libraryName = = null ) { LibrarySpec singleMatchingLibrary = getSingleMatchingLibrary ( ) ; if ( singleMatchingLibrary = = null ) { return ; } libraryName = singleMatchingLibrary . getName ( ) ; } selectedLibrary = libsMatchingRequirements . get ( libraryName ) ; nonMatchingLibrary = libsNotMatchingRequirements . get ( libraryName ) ; } public boolean isProjectNotFound ( ) { return PROJECT_NOT_FOUND = = this ; } public boolean hasLibraries ( ) { return ! libsMatchingRequirements . isEmpty ( ) | | ! libsNotMatchingRequirements . isEmpty ( ) ; } public LibrarySpec getSelectedLibrary ( ) { return selectedLibrary ; } public LibrarySpec getNonMatchingLibrary ( ) { return nonMatchingLibrary ; } public List < String > getCandidateLibraries ( ) { return Lists . newArrayList ( libsMatchingRequirements . keySet ( ) ) ; } public String toResolutionErrorMessage ( Class < ? extends BinarySpec > binaryType , LibraryComponentSelector selector ) { List < String > candidateLibraries = formatLibraryNames ( getCandidateLibraries ( ) ) ; String projectPath = selector . getProjectPath ( ) ; String libraryName = selector . getLibraryName ( ) ; StringBuilder sb = new StringBuilder ( <str> ) . append ( projectPath ) . append ( <str> ) ; if ( libraryName = = null | | ! hasLibraries ( ) ) { if ( isProjectNotFound ( ) ) { sb . append ( <str> ) ; } else if ( ! hasLibraries ( ) ) { sb . append ( <str> ) ; } else { sb . append ( <str> ) ; Joiner . on ( <str> ) . appendTo ( sb , candidateLibraries ) ; } } else { LibrarySpec notMatchingRequirements = getNonMatchingLibrary ( ) ; if ( notMatchingRequirements ! = null ) { sb . append ( <str> ) . append ( libraryName ) . append ( <str> ) . append ( binaryType . getSimpleName ( ) ) ; } else { sb . append ( <str> ) . append ( libraryName ) . append ( <str> ) ; if ( candidateLibraries . size ( ) = = <int> ) { sb . append ( candidateLibraries . get ( <int> ) ) ; } else { sb . append ( <str> ) ; Joiner . on ( <str> ) . appendTo ( sb , candidateLibraries ) ; } sb . append ( <str> ) ; } } return sb . toString ( ) ; } public static LibraryResolutionResult of ( Collection < ? extends LibrarySpec > libraries , String libraryName , Predicate < ? super LibrarySpec > libraryFilter ) { LibraryResolutionResult result = new LibraryResolutionResult ( ) ; for ( LibrarySpec librarySpec : libraries ) { if ( libraryFilter . apply ( librarySpec ) ) { result . libsMatchingRequirements . put ( librarySpec . getName ( ) , librarySpec ) ; } else { result . libsNotMatchingRequirements . put ( librarySpec . getName ( ) , librarySpec ) ; } } result . resolve ( libraryName ) ; return result ; } public static LibraryResolutionResult projectNotFound ( ) { return LibraryResolutionResult . PROJECT_NOT_FOUND ; } public static LibraryResolutionResult emptyResolutionResult ( ) { return LibraryResolutionResult . EMPTY ; } private static List < String > formatLibraryNames ( List < String > libs ) { List < String > list = Lists . transform ( libs , new Function < String , String > ( ) { @Override public String apply ( String input ) { return String . format ( <str> , input ) ; } } ) ; return Ordering . natural ( ) . sortedCopy ( list ) ; } } } 
