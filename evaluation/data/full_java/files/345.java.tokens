package org . apache . cassandra . db ; import java . util . * ; import java . util . concurrent . TimeUnit ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . lifecycle . SSTableSet ; import org . apache . cassandra . db . lifecycle . View ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . service . MigrationListener ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . service . StorageService ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . Pair ; import org . apache . cassandra . utils . concurrent . Refs ; public class SizeEstimatesRecorder extends MigrationListener implements Runnable { private static final Logger logger = LoggerFactory . getLogger ( SizeEstimatesRecorder . class ) ; public static final SizeEstimatesRecorder instance = new SizeEstimatesRecorder ( ) ; private SizeEstimatesRecorder ( ) { MigrationManager . instance . register ( this ) ; } public void run ( ) { if ( ! StorageService . instance . getTokenMetadata ( ) . isMember ( FBUtilities . getBroadcastAddress ( ) ) ) { logger . debug ( <str> ) ; return ; } logger . trace ( <str> ) ; Collection < Token > localTokens = StorageService . instance . getLocalTokens ( ) ; Collection < Range < Token > > localRanges = StorageService . instance . getTokenMetadata ( ) . getPrimaryRangesFor ( localTokens ) ; for ( Keyspace keyspace : Keyspace . nonSystem ( ) ) { for ( ColumnFamilyStore table : keyspace . getColumnFamilyStores ( ) ) { long start = System . nanoTime ( ) ; recordSizeEstimates ( table , localRanges ) ; long passed = System . nanoTime ( ) - start ; logger . trace ( <str> , TimeUnit . NANOSECONDS . toMillis ( passed ) , table . metadata . ksName , table . metadata . cfName ) ; } } } @SuppressWarnings ( <str> ) private void recordSizeEstimates ( ColumnFamilyStore table , Collection < Range < Token > > localRanges ) { List < Range < Token > > unwrappedRanges = Range . normalize ( localRanges ) ; Map < Range < Token > , Pair < Long , Long > > estimates = new HashMap < > ( localRanges . size ( ) ) ; for ( Range < Token > range : unwrappedRanges ) { Refs < SSTableReader > refs = null ; long partitionsCount , meanPartitionSize ; try { while ( refs = = null ) { ColumnFamilyStore . ViewFragment view = table . select ( View . select ( SSTableSet . CANONICAL , Range . makeRowRange ( range ) ) ) ; refs = Refs . tryRef ( view . sstables ) ; } partitionsCount = estimatePartitionsCount ( refs , range ) ; meanPartitionSize = estimateMeanPartitionSize ( refs ) ; } finally { if ( refs ! = null ) refs . release ( ) ; } estimates . put ( range , Pair . create ( partitionsCount , meanPartitionSize ) ) ; } SystemKeyspace . updateSizeEstimates ( table . metadata . ksName , table . metadata . cfName , estimates ) ; } private long estimatePartitionsCount ( Collection < SSTableReader > sstables , Range < Token > range ) { long count = <int> ; for ( SSTableReader sstable : sstables ) count + = sstable . estimatedKeysForRanges ( Collections . singleton ( range ) ) ; return count ; } private long estimateMeanPartitionSize ( Collection < SSTableReader > sstables ) { long sum = <int> , count = <int> ; for ( SSTableReader sstable : sstables ) { long n = sstable . getEstimatedPartitionSize ( ) . count ( ) ; sum + = sstable . getEstimatedPartitionSize ( ) . mean ( ) * n ; count + = n ; } return count > <int> ? sum / count : <int> ; } @Override public void onDropColumnFamily ( String keyspace , String table ) { SystemKeyspace . clearSizeEstimates ( keyspace , table ) ; } } 
