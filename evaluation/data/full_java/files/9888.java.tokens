package com . google . common . collect . testing ; import static java . util . Collections . disjoint ; import static java . util . logging . Level . FINER ; import com . google . common . collect . testing . features . ConflictingRequirementsException ; import com . google . common . collect . testing . features . Feature ; import com . google . common . collect . testing . features . FeatureUtil ; import com . google . common . collect . testing . features . TesterRequirements ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . lang . reflect . Method ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collection ; import java . util . Collections ; import java . util . Enumeration ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Set ; import java . util . logging . Logger ; public abstract class FeatureSpecificTestSuiteBuilder < B extends FeatureSpecificTestSuiteBuilder < B , G > , G > { @SuppressWarnings ( <str> ) protected B self ( ) { return ( B ) this ; } private G subjectGenerator ; private Runnable setUp ; private Runnable tearDown ; protected B usingGenerator ( G subjectGenerator ) { this . subjectGenerator = subjectGenerator ; return self ( ) ; } public G getSubjectGenerator ( ) { return subjectGenerator ; } public B withSetUp ( Runnable setUp ) { this . setUp = setUp ; return self ( ) ; } protected Runnable getSetUp ( ) { return setUp ; } public B withTearDown ( Runnable tearDown ) { this . tearDown = tearDown ; return self ( ) ; } protected Runnable getTearDown ( ) { return tearDown ; } private Set < Feature < ? > > features = new LinkedHashSet < Feature < ? > > ( ) ; public B withFeatures ( Feature < ? > . . . features ) { return withFeatures ( Arrays . asList ( features ) ) ; } public B withFeatures ( Iterable < ? extends Feature < ? > > features ) { for ( Feature < ? > feature : features ) { this . features . add ( feature ) ; } return self ( ) ; } public Set < Feature < ? > > getFeatures ( ) { return Collections . unmodifiableSet ( features ) ; } private String name ; public B named ( String name ) { if ( name . contains ( <str> ) ) { throw new IllegalArgumentException ( <str> + <str> ) ; } this . name = name ; return self ( ) ; } public String getName ( ) { return name ; } private Set < Method > suppressedTests = new HashSet < Method > ( ) ; public B suppressing ( Method . . . methods ) { return suppressing ( Arrays . asList ( methods ) ) ; } public B suppressing ( Collection < Method > methods ) { suppressedTests . addAll ( methods ) ; return self ( ) ; } public Set < Method > getSuppressedTests ( ) { return suppressedTests ; } private static final Logger logger = Logger . getLogger ( FeatureSpecificTestSuiteBuilder . class . getName ( ) ) ; @SuppressWarnings ( <str> ) public TestSuite createTestSuite ( ) { checkCanCreate ( ) ; logger . fine ( <str> + name ) ; logger . fine ( <str> + formatFeatureSet ( features ) ) ; FeatureUtil . addImpliedFeatures ( features ) ; logger . fine ( <str> + formatFeatureSet ( features ) ) ; List < Class < ? extends AbstractTester > > testers = getTesters ( ) ; TestSuite suite = new TestSuite ( name ) ; for ( Class < ? extends AbstractTester > testerClass : testers ) { final TestSuite testerSuite = makeSuiteForTesterClass ( ( Class < ? extends AbstractTester < ? > > ) testerClass ) ; if ( testerSuite . countTestCases ( ) > <int> ) { suite . addTest ( testerSuite ) ; } } return suite ; } protected void checkCanCreate ( ) { if ( subjectGenerator = = null ) { throw new IllegalStateException ( <str> ) ; } if ( name = = null ) { throw new IllegalStateException ( <str> ) ; } if ( features = = null ) { throw new IllegalStateException ( <str> ) ; } } protected abstract List < Class < ? extends AbstractTester > > getTesters ( ) ; private boolean matches ( Test test ) { final Method method ; try { method = extractMethod ( test ) ; } catch ( IllegalArgumentException e ) { logger . finer ( Platform . format ( <str> , test , e . getMessage ( ) ) ) ; return true ; } if ( suppressedTests . contains ( method ) ) { logger . finer ( Platform . format ( <str> , test ) ) ; return false ; } final TesterRequirements requirements ; try { requirements = FeatureUtil . getTesterRequirements ( method ) ; } catch ( ConflictingRequirementsException e ) { throw new RuntimeException ( e ) ; } if ( ! features . containsAll ( requirements . getPresentFeatures ( ) ) ) { if ( logger . isLoggable ( FINER ) ) { Set < Feature < ? > > missingFeatures = Helpers . copyToSet ( requirements . getPresentFeatures ( ) ) ; missingFeatures . removeAll ( features ) ; logger . finer ( Platform . format ( <str> , method , missingFeatures ) ) ; } return false ; } if ( intersect ( features , requirements . getAbsentFeatures ( ) ) ) { if ( logger . isLoggable ( FINER ) ) { Set < Feature < ? > > unwantedFeatures = Helpers . copyToSet ( requirements . getAbsentFeatures ( ) ) ; unwantedFeatures . retainAll ( features ) ; logger . finer ( Platform . format ( <str> , method , unwantedFeatures ) ) ; } return false ; } return true ; } private static boolean intersect ( Set < ? > a , Set < ? > b ) { return ! disjoint ( a , b ) ; } private static Method extractMethod ( Test test ) { if ( test instanceof AbstractTester ) { AbstractTester < ? > tester = ( AbstractTester < ? > ) test ; return Helpers . getMethod ( tester . getClass ( ) , tester . getTestMethodName ( ) ) ; } else if ( test instanceof TestCase ) { TestCase testCase = ( TestCase ) test ; return Helpers . getMethod ( testCase . getClass ( ) , testCase . getName ( ) ) ; } else { throw new IllegalArgumentException ( <str> ) ; } } protected TestSuite makeSuiteForTesterClass ( Class < ? extends AbstractTester < ? > > testerClass ) { final TestSuite candidateTests = new TestSuite ( testerClass ) ; final TestSuite suite = filterSuite ( candidateTests ) ; Enumeration < ? > allTests = suite . tests ( ) ; while ( allTests . hasMoreElements ( ) ) { Object test = allTests . nextElement ( ) ; if ( test instanceof AbstractTester ) { @SuppressWarnings ( <str> ) AbstractTester < ? super G > tester = ( AbstractTester < ? super G > ) test ; tester . init ( subjectGenerator , name , setUp , tearDown ) ; } } return suite ; } private TestSuite filterSuite ( TestSuite suite ) { TestSuite filtered = new TestSuite ( suite . getName ( ) ) ; final Enumeration < ? > tests = suite . tests ( ) ; while ( tests . hasMoreElements ( ) ) { Test test = ( Test ) tests . nextElement ( ) ; if ( matches ( test ) ) { filtered . addTest ( test ) ; } } return filtered ; } protected static String formatFeatureSet ( Set < ? extends Feature < ? > > features ) { List < String > temp = new ArrayList < String > ( ) ; for ( Feature < ? > feature : features ) { Object featureAsObject = feature ; if ( featureAsObject instanceof Enum ) { Enum < ? > f = ( Enum < ? > ) featureAsObject ; temp . add ( f . getDeclaringClass ( ) . getSimpleName ( ) + <str> + feature ) ; } else { temp . add ( feature . toString ( ) ) ; } } return temp . toString ( ) ; } } 
