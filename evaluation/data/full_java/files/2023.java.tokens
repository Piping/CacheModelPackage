package org . nd4j . linalg . api . ops . impl . accum ; import org . apache . commons . math3 . util . FastMath ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . util . ArrayUtil ; public class StandardDeviation extends Variance { public StandardDeviation ( ) { } public StandardDeviation ( INDArray x , INDArray y , int n ) { super ( x , y , n ) ; } public StandardDeviation ( INDArray x ) { super ( x ) ; } public StandardDeviation ( INDArray x , INDArray y ) { super ( x , y ) ; } @Override public String name ( ) { return <str> ; } @Override public Op opForDimension ( int index , int dimension ) { INDArray xAlongDimension = x . vectorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new StandardDeviation ( xAlongDimension , y . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new StandardDeviation ( xAlongDimension ) ; } @Override public Op opForDimension ( int index , int . . . dimension ) { INDArray xAlongDimension = x . tensorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new StandardDeviation ( xAlongDimension , y . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new StandardDeviation ( xAlongDimension ) ; } @Override public void exec ( ) { super . exec ( ) ; } @Override public void exec ( int . . . dimension ) { if ( dimension . length = = <int> & & dimension [ <int> ] = = Integer . MAX_VALUE ) { exec ( ) ; this . z = Nd4j . scalar ( this . finalResult ) ; return ; } int [ ] retShape = ArrayUtil . removeIndex ( x . shape ( ) , dimension ) ; int nOps = x . tensorssAlongDimension ( dimension ) ; z = Nd4j . create ( retShape ) ; for ( int i = <int> ; i < nOps ; i + + ) { double d = Nd4j . getExecutioner ( ) . execAndReturn ( ( StandardDeviation ) opForDimension ( i , dimension ) ) . getFinalResult ( ) . doubleValue ( ) ; z . putScalar ( i , d ) ; } } @Override public double getAndSetFinalResult ( double accum ) { double d = FastMath . sqrt ( super . getAndSetFinalResult ( accum ) ) ; this . finalResult = d ; return d ; } @Override public float getAndSetFinalResult ( float accum ) { float f = ( float ) FastMath . sqrt ( super . getAndSetFinalResult ( accum ) ) ; this . finalResult = f ; return f ; } @Override public IComplexNumber getAndSetFinalResult ( IComplexNumber accum ) { finalResultComplex = super . getAndSetFinalResult ( accum ) . sqrt ( ) ; return finalResultComplex ; } @Override public double calculateFinalResult ( double accum , int n ) { return FastMath . sqrt ( super . calculateFinalResult ( accum , n ) ) ; } @Override public float calculateFinalResult ( float accum , int n ) { return ( float ) FastMath . sqrt ( super . calculateFinalResult ( accum , n ) ) ; } } 
