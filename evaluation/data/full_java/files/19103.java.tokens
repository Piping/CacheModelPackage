package io . netty . handler . codec . http ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . FileRegion ; import io . netty . handler . codec . MessageToMessageEncoder ; import io . netty . util . CharsetUtil ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import java . util . Iterator ; import java . util . List ; import java . util . Map . Entry ; import static io . netty . buffer . Unpooled . EMPTY_BUFFER ; import static io . netty . buffer . Unpooled . directBuffer ; import static io . netty . buffer . Unpooled . unreleasableBuffer ; import static io . netty . handler . codec . http . HttpConstants . CR ; import static io . netty . handler . codec . http . HttpConstants . LF ; public abstract class HttpObjectEncoder < H extends HttpMessage > extends MessageToMessageEncoder < Object > { private static final byte [ ] CRLF = { CR , LF } ; private static final byte [ ] ZERO_CRLF = { <str> , CR , LF } ; private static final byte [ ] ZERO_CRLF_CRLF = { <str> , CR , LF , CR , LF } ; private static final ByteBuf CRLF_BUF = unreleasableBuffer ( directBuffer ( CRLF . length ) . writeBytes ( CRLF ) ) ; private static final ByteBuf ZERO_CRLF_CRLF_BUF = unreleasableBuffer ( directBuffer ( ZERO_CRLF_CRLF . length ) . writeBytes ( ZERO_CRLF_CRLF ) ) ; private static final int ST_INIT = <int> ; private static final int ST_CONTENT_NON_CHUNK = <int> ; private static final int ST_CONTENT_CHUNK = <int> ; @SuppressWarnings ( <str> ) private int state = ST_INIT ; @Override protected void encode ( ChannelHandlerContext ctx , Object msg , List < Object > out ) throws Exception { ByteBuf buf = null ; if ( msg instanceof HttpMessage ) { if ( state ! = ST_INIT ) { throw new IllegalStateException ( <str> + StringUtil . simpleClassName ( msg ) ) ; } @SuppressWarnings ( { <str> , <str> } ) H m = ( H ) msg ; buf = ctx . alloc ( ) . buffer ( ) ; encodeInitialLine ( buf , m ) ; encodeHeaders ( m . headers ( ) , buf ) ; buf . writeBytes ( CRLF ) ; state = HttpUtil . isTransferEncodingChunked ( m ) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK ; } if ( msg instanceof ByteBuf & & ! ( ( ByteBuf ) msg ) . isReadable ( ) ) { out . add ( EMPTY_BUFFER ) ; return ; } if ( msg instanceof HttpContent | | msg instanceof ByteBuf | | msg instanceof FileRegion ) { if ( state = = ST_INIT ) { throw new IllegalStateException ( <str> + StringUtil . simpleClassName ( msg ) ) ; } final long contentLength = contentLength ( msg ) ; if ( state = = ST_CONTENT_NON_CHUNK ) { if ( contentLength > <int> ) { if ( buf ! = null & & buf . writableBytes ( ) > = contentLength & & msg instanceof HttpContent ) { buf . writeBytes ( ( ( HttpContent ) msg ) . content ( ) ) ; out . add ( buf ) ; } else { if ( buf ! = null ) { out . add ( buf ) ; } out . add ( encodeAndRetain ( msg ) ) ; } } else { if ( buf ! = null ) { out . add ( buf ) ; } else { out . add ( EMPTY_BUFFER ) ; } } if ( msg instanceof LastHttpContent ) { state = ST_INIT ; } } else if ( state = = ST_CONTENT_CHUNK ) { if ( buf ! = null ) { out . add ( buf ) ; } encodeChunkedContent ( ctx , msg , contentLength , out ) ; } else { throw new Error ( ) ; } } else { if ( buf ! = null ) { out . add ( buf ) ; } } } protected void encodeHeaders ( HttpHeaders headers , ByteBuf buf ) throws Exception { Iterator < Entry < CharSequence , CharSequence > > iter = headers . iteratorCharSequence ( ) ; while ( iter . hasNext ( ) ) { Entry < CharSequence , CharSequence > header = iter . next ( ) ; HttpHeadersEncoder . encoderHeader ( header . getKey ( ) , header . getValue ( ) , buf ) ; } } private void encodeChunkedContent ( ChannelHandlerContext ctx , Object msg , long contentLength , List < Object > out ) { if ( contentLength > <int> ) { byte [ ] length = Long . toHexString ( contentLength ) . getBytes ( CharsetUtil . US_ASCII ) ; ByteBuf buf = ctx . alloc ( ) . buffer ( length . length + <int> ) ; buf . writeBytes ( length ) ; buf . writeBytes ( CRLF ) ; out . add ( buf ) ; out . add ( encodeAndRetain ( msg ) ) ; out . add ( CRLF_BUF . duplicate ( ) ) ; } if ( msg instanceof LastHttpContent ) { HttpHeaders headers = ( ( LastHttpContent ) msg ) . trailingHeaders ( ) ; if ( headers . isEmpty ( ) ) { out . add ( ZERO_CRLF_CRLF_BUF . duplicate ( ) ) ; } else { ByteBuf buf = ctx . alloc ( ) . buffer ( ) ; buf . writeBytes ( ZERO_CRLF ) ; try { encodeHeaders ( headers , buf ) ; } catch ( Exception ex ) { buf . release ( ) ; PlatformDependent . throwException ( ex ) ; } buf . writeBytes ( CRLF ) ; out . add ( buf ) ; } state = ST_INIT ; } else { if ( contentLength = = <int> ) { out . add ( EMPTY_BUFFER ) ; } } } @Override public boolean acceptOutboundMessage ( Object msg ) throws Exception { return msg instanceof HttpObject | | msg instanceof ByteBuf | | msg instanceof FileRegion ; } private static Object encodeAndRetain ( Object msg ) { if ( msg instanceof ByteBuf ) { return ( ( ByteBuf ) msg ) . retain ( ) ; } if ( msg instanceof HttpContent ) { return ( ( HttpContent ) msg ) . content ( ) . retain ( ) ; } if ( msg instanceof FileRegion ) { return ( ( FileRegion ) msg ) . retain ( ) ; } throw new IllegalStateException ( <str> + StringUtil . simpleClassName ( msg ) ) ; } private static long contentLength ( Object msg ) { if ( msg instanceof HttpContent ) { return ( ( HttpContent ) msg ) . content ( ) . readableBytes ( ) ; } if ( msg instanceof ByteBuf ) { return ( ( ByteBuf ) msg ) . readableBytes ( ) ; } if ( msg instanceof FileRegion ) { return ( ( FileRegion ) msg ) . count ( ) ; } throw new IllegalStateException ( <str> + StringUtil . simpleClassName ( msg ) ) ; } @Deprecated protected static void encodeAscii ( String s , ByteBuf buf ) { HttpUtil . encodeAscii0 ( s , buf ) ; } protected abstract void encodeInitialLine ( ByteBuf buf , H message ) throws Exception ; } 
