package org . elasticsearch . common . logging . support ; import java . util . HashMap ; import java . util . Map ; public class LoggerMessageFormat { static final char DELIM_START = <str> ; static final char DELIM_STOP = <str> ; static final String DELIM_STR = <str> ; private static final char ESCAPE_CHAR = <str> ; public static String format ( final String messagePattern , final Object . . . argArray ) { return format ( null , messagePattern , argArray ) ; } public static String format ( final String prefix , final String messagePattern , final Object . . . argArray ) { if ( messagePattern = = null ) { return null ; } if ( argArray = = null ) { if ( prefix = = null ) { return messagePattern ; } else { return prefix + messagePattern ; } } int i = <int> ; int j ; final StringBuilder sbuf = new StringBuilder ( messagePattern . length ( ) + <int> ) ; if ( prefix ! = null ) { sbuf . append ( prefix ) ; } for ( int L = <int> ; L < argArray . length ; L + + ) { j = messagePattern . indexOf ( DELIM_STR , i ) ; if ( j = = - <int> ) { if ( i = = <int> ) { return messagePattern ; } else { sbuf . append ( messagePattern . substring ( i , messagePattern . length ( ) ) ) ; return sbuf . toString ( ) ; } } else { if ( isEscapedDelimiter ( messagePattern , j ) ) { if ( ! isDoubleEscaped ( messagePattern , j ) ) { L - - ; sbuf . append ( messagePattern . substring ( i , j - <int> ) ) ; sbuf . append ( DELIM_START ) ; i = j + <int> ; } else { sbuf . append ( messagePattern . substring ( i , j - <int> ) ) ; deeplyAppendParameter ( sbuf , argArray [ L ] , new HashMap ( ) ) ; i = j + <int> ; } } else { sbuf . append ( messagePattern . substring ( i , j ) ) ; deeplyAppendParameter ( sbuf , argArray [ L ] , new HashMap ( ) ) ; i = j + <int> ; } } } sbuf . append ( messagePattern . substring ( i , messagePattern . length ( ) ) ) ; return sbuf . toString ( ) ; } static boolean isEscapedDelimiter ( String messagePattern , int delimiterStartIndex ) { if ( delimiterStartIndex = = <int> ) { return false ; } char potentialEscape = messagePattern . charAt ( delimiterStartIndex - <int> ) ; if ( potentialEscape = = ESCAPE_CHAR ) { return true ; } else { return false ; } } static boolean isDoubleEscaped ( String messagePattern , int delimiterStartIndex ) { if ( delimiterStartIndex > = <int> & & messagePattern . charAt ( delimiterStartIndex - <int> ) = = ESCAPE_CHAR ) { return true ; } else { return false ; } } private static void deeplyAppendParameter ( StringBuilder sbuf , Object o , Map seenMap ) { if ( o = = null ) { sbuf . append ( <str> ) ; return ; } if ( ! o . getClass ( ) . isArray ( ) ) { safeObjectAppend ( sbuf , o ) ; } else { if ( o instanceof boolean [ ] ) { booleanArrayAppend ( sbuf , ( boolean [ ] ) o ) ; } else if ( o instanceof byte [ ] ) { byteArrayAppend ( sbuf , ( byte [ ] ) o ) ; } else if ( o instanceof char [ ] ) { charArrayAppend ( sbuf , ( char [ ] ) o ) ; } else if ( o instanceof short [ ] ) { shortArrayAppend ( sbuf , ( short [ ] ) o ) ; } else if ( o instanceof int [ ] ) { intArrayAppend ( sbuf , ( int [ ] ) o ) ; } else if ( o instanceof long [ ] ) { longArrayAppend ( sbuf , ( long [ ] ) o ) ; } else if ( o instanceof float [ ] ) { floatArrayAppend ( sbuf , ( float [ ] ) o ) ; } else if ( o instanceof double [ ] ) { doubleArrayAppend ( sbuf , ( double [ ] ) o ) ; } else { objectArrayAppend ( sbuf , ( Object [ ] ) o , seenMap ) ; } } } private static void safeObjectAppend ( StringBuilder sbuf , Object o ) { try { String oAsString = o . toString ( ) ; sbuf . append ( oAsString ) ; } catch ( Throwable t ) { sbuf . append ( <str> ) ; } } private static void objectArrayAppend ( StringBuilder sbuf , Object [ ] a , Map seenMap ) { sbuf . append ( <str> ) ; if ( ! seenMap . containsKey ( a ) ) { seenMap . put ( a , null ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { deeplyAppendParameter ( sbuf , a [ i ] , seenMap ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } seenMap . remove ( a ) ; } else { sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void booleanArrayAppend ( StringBuilder sbuf , boolean [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void byteArrayAppend ( StringBuilder sbuf , byte [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void charArrayAppend ( StringBuilder sbuf , char [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void shortArrayAppend ( StringBuilder sbuf , short [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void intArrayAppend ( StringBuilder sbuf , int [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void longArrayAppend ( StringBuilder sbuf , long [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void floatArrayAppend ( StringBuilder sbuf , float [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } private static void doubleArrayAppend ( StringBuilder sbuf , double [ ] a ) { sbuf . append ( <str> ) ; final int len = a . length ; for ( int i = <int> ; i < len ; i + + ) { sbuf . append ( a [ i ] ) ; if ( i ! = len - <int> ) sbuf . append ( <str> ) ; } sbuf . append ( <str> ) ; } } 
