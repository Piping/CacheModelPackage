package org . gradle . model . internal . core ; import com . google . common . base . Objects ; import com . google . common . base . Preconditions ; import net . jcip . annotations . ThreadSafe ; import org . gradle . api . Nullable ; import org . gradle . model . internal . type . ModelType ; @ThreadSafe public class ModelReference < T > { @Nullable private final ModelPath path ; private final ModelType < T > type ; @Nullable private final ModelPath scope ; private final ModelNode . State state ; @Nullable private final String description ; private ModelReference ( @Nullable ModelPath path , ModelType < T > type , @Nullable ModelPath scope , @Nullable ModelNode . State state , @Nullable String description ) { this . path = path ; this . type = Preconditions . checkNotNull ( type , <str> ) ; this . scope = scope ; this . description = description ; this . state = state ! = null ? state : ModelNode . State . GraphClosed ; } public static ModelReference < Object > any ( ) { return of ( ModelType . untyped ( ) ) ; } public static < T > ModelReference < T > of ( ModelPath path , ModelType < T > type , String description ) { return new ModelReference < T > ( path , type , null , null , description ) ; } public static < T > ModelReference < T > of ( String path , ModelType < T > type , String description ) { return of ( ModelPath . path ( path ) , type , description ) ; } public static < T > ModelReference < T > of ( ModelPath path , ModelType < T > type ) { return new ModelReference < T > ( path , type , null , null , null ) ; } public static < T > ModelReference < T > of ( ModelPath path , ModelType < T > type , ModelNode . State state ) { return new ModelReference < T > ( path , type , null , state , null ) ; } public static < T > ModelReference < T > of ( ModelPath path , Class < T > type ) { return of ( path , ModelType . of ( type ) ) ; } public static < T > ModelReference < T > of ( String path , Class < T > type ) { return of ( ModelPath . path ( path ) , ModelType . of ( type ) ) ; } public static < T > ModelReference < T > of ( String path , ModelType < T > type ) { return of ( path = = null ? null : ModelPath . path ( path ) , type ) ; } public static < T > ModelReference < T > of ( Class < T > type ) { return of ( ( ModelPath ) null , ModelType . of ( type ) ) ; } public static < T > ModelReference < T > of ( ModelType < T > type ) { return of ( ( ModelPath ) null , type ) ; } public static ModelReference < Object > of ( String path ) { return of ( ModelPath . path ( path ) , ModelType . UNTYPED ) ; } public static ModelReference < Object > of ( ModelPath path ) { return of ( path , ModelType . UNTYPED ) ; } public static ModelReference < Object > untyped ( ModelPath path ) { return untyped ( path , null ) ; } public static ModelReference < Object > untyped ( ModelPath path , String description ) { return of ( path , ModelType . UNTYPED , description ) ; } @Nullable public ModelPath getPath ( ) { return path ; } @Nullable public ModelPath getScope ( ) { return scope ; } @Nullable public String getDescription ( ) { return description ; } public ModelType < T > getType ( ) { return type ; } public ModelNode . State getState ( ) { return state ; } public boolean isUntyped ( ) { return type . equals ( ModelType . UNTYPED ) ; } public ModelReference < T > inScope ( ModelPath scope ) { if ( scope . equals ( this . scope ) ) { return this ; } return new ModelReference < T > ( path , type , scope , state , description ) ; } public ModelReference < T > withPath ( ModelPath path ) { return new ModelReference < T > ( path , type , scope , state , description ) ; } public ModelReference < T > atState ( ModelNode . State state ) { if ( state . equals ( this . state ) ) { return this ; } return new ModelReference < T > ( path , type , scope , state , description ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) { return false ; } ModelReference < ? > that = ( ModelReference < ? > ) o ; return Objects . equal ( path , that . path ) & & Objects . equal ( scope , that . scope ) & & type . equals ( that . type ) & & state . equals ( that . state ) ; } @Override public int hashCode ( ) { int result = path = = null ? <int> : path . hashCode ( ) ; result = <int> * result + ( scope = = null ? <int> : scope . hashCode ( ) ) ; result = <int> * result + type . hashCode ( ) ; result = <int> * result + state . hashCode ( ) ; return result ; } @Override public String toString ( ) { return <str> + path + <str> + scope + <str> + type + <str> + state + <str> ; } } 
