package clojure . asm ; final class AnnotationWriter extends AnnotationVisitor { private final ClassWriter cw ; private int size ; private final boolean named ; private final ByteVector bv ; private final ByteVector parent ; private final int offset ; AnnotationWriter next ; AnnotationWriter prev ; AnnotationWriter ( final ClassWriter cw , final boolean named , final ByteVector bv , final ByteVector parent , final int offset ) { super ( Opcodes . ASM4 ) ; this . cw = cw ; this . named = named ; this . bv = bv ; this . parent = parent ; this . offset = offset ; } @Override public void visit ( final String name , final Object value ) { + + size ; if ( named ) { bv . putShort ( cw . newUTF8 ( name ) ) ; } if ( value instanceof String ) { bv . put12 ( <str> , cw . newUTF8 ( ( String ) value ) ) ; } else if ( value instanceof Byte ) { bv . put12 ( <str> , cw . newInteger ( ( ( Byte ) value ) . byteValue ( ) ) . index ) ; } else if ( value instanceof Boolean ) { int v = ( ( Boolean ) value ) . booleanValue ( ) ? <int> : <int> ; bv . put12 ( <str> , cw . newInteger ( v ) . index ) ; } else if ( value instanceof Character ) { bv . put12 ( <str> , cw . newInteger ( ( ( Character ) value ) . charValue ( ) ) . index ) ; } else if ( value instanceof Short ) { bv . put12 ( <str> , cw . newInteger ( ( ( Short ) value ) . shortValue ( ) ) . index ) ; } else if ( value instanceof Type ) { bv . put12 ( <str> , cw . newUTF8 ( ( ( Type ) value ) . getDescriptor ( ) ) ) ; } else if ( value instanceof byte [ ] ) { byte [ ] v = ( byte [ ] ) value ; bv . put12 ( <str> , v . length ) ; for ( int i = <int> ; i < v . length ; i + + ) { bv . put12 ( <str> , cw . newInteger ( v [ i ] ) . index ) ; } } else if ( value instanceof boolean [ ] ) { boolean [ ] v = ( boolean [ ] ) value ; bv . put12 ( <str> , v . length ) ; for ( int i = <int> ; i < v . length ; i + + ) { bv . put12 ( <str> , cw . newInteger ( v [ i ] ? <int> : <int> ) . index ) ; } } else if ( value instanceof short [ ] ) { short [ ] v = ( short [ ] ) value ; bv . put12 ( <str> , v . length ) ; for ( int i = <int> ; i < v . length ; i + + ) { bv . put12 ( <str> , cw . newInteger ( v [ i ] ) . index ) ; } } else if ( value instanceof char [ ] ) { char [ ] v = ( char [ ] ) value ; bv . put12 ( <str> , v . length ) ; for ( int i = <int> ; i < v . length ; i + + ) { bv . put12 ( <str> , cw . newInteger ( v [ i ] ) . index ) ; } } else if ( value instanceof int [ ] ) { int [ ] v = ( int [ ] ) value ; bv . put12 ( <str> , v . length ) ; for ( int i = <int> ; i < v . length ; i + + ) { bv . put12 ( <str> , cw . newInteger ( v [ i ] ) . index ) ; } } else if ( value instanceof long [ ] ) { long [ ] v = ( long [ ] ) value ; bv . put12 ( <str> , v . length ) ; for ( int i = <int> ; i < v . length ; i + + ) { bv . put12 ( <str> , cw . newLong ( v [ i ] ) . index ) ; } } else if ( value instanceof float [ ] ) { float [ ] v = ( float [ ] ) value ; bv . put12 ( <str> , v . length ) ; for ( int i = <int> ; i < v . length ; i + + ) { bv . put12 ( <str> , cw . newFloat ( v [ i ] ) . index ) ; } } else if ( value instanceof double [ ] ) { double [ ] v = ( double [ ] ) value ; bv . put12 ( <str> , v . length ) ; for ( int i = <int> ; i < v . length ; i + + ) { bv . put12 ( <str> , cw . newDouble ( v [ i ] ) . index ) ; } } else { Item i = cw . newConstItem ( value ) ; bv . put12 ( <str> . charAt ( i . type ) , i . index ) ; } } @Override public void visitEnum ( final String name , final String desc , final String value ) { + + size ; if ( named ) { bv . putShort ( cw . newUTF8 ( name ) ) ; } bv . put12 ( <str> , cw . newUTF8 ( desc ) ) . putShort ( cw . newUTF8 ( value ) ) ; } @Override public AnnotationVisitor visitAnnotation ( final String name , final String desc ) { + + size ; if ( named ) { bv . putShort ( cw . newUTF8 ( name ) ) ; } bv . put12 ( <str> , cw . newUTF8 ( desc ) ) . putShort ( <int> ) ; return new AnnotationWriter ( cw , true , bv , bv , bv . length - <int> ) ; } @Override public AnnotationVisitor visitArray ( final String name ) { + + size ; if ( named ) { bv . putShort ( cw . newUTF8 ( name ) ) ; } bv . put12 ( <str> , <int> ) ; return new AnnotationWriter ( cw , false , bv , bv , bv . length - <int> ) ; } @Override public void visitEnd ( ) { if ( parent ! = null ) { byte [ ] data = parent . data ; data [ offset ] = ( byte ) ( size > > > <int> ) ; data [ offset + <int> ] = ( byte ) size ; } } int getSize ( ) { int size = <int> ; AnnotationWriter aw = this ; while ( aw ! = null ) { size + = aw . bv . length ; aw = aw . next ; } return size ; } void put ( final ByteVector out ) { int n = <int> ; int size = <int> ; AnnotationWriter aw = this ; AnnotationWriter last = null ; while ( aw ! = null ) { + + n ; size + = aw . bv . length ; aw . visitEnd ( ) ; aw . prev = last ; last = aw ; aw = aw . next ; } out . putInt ( size ) ; out . putShort ( n ) ; aw = last ; while ( aw ! = null ) { out . putByteArray ( aw . bv . data , <int> , aw . bv . length ) ; aw = aw . prev ; } } static void put ( final AnnotationWriter [ ] panns , final int off , final ByteVector out ) { int size = <int> + <int> * ( panns . length - off ) ; for ( int i = off ; i < panns . length ; + + i ) { size + = panns [ i ] = = null ? <int> : panns [ i ] . getSize ( ) ; } out . putInt ( size ) . putByte ( panns . length - off ) ; for ( int i = off ; i < panns . length ; + + i ) { AnnotationWriter aw = panns [ i ] ; AnnotationWriter last = null ; int n = <int> ; while ( aw ! = null ) { + + n ; aw . visitEnd ( ) ; aw . prev = last ; last = aw ; aw = aw . next ; } out . putShort ( n ) ; aw = last ; while ( aw ! = null ) { out . putByteArray ( aw . bv . data , <int> , aw . bv . length ) ; aw = aw . prev ; } } } } 
