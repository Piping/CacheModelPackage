package org . apache . cassandra . cql3 . statements ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import org . apache . cassandra . auth . Permission ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . cql3 . CQL3Type ; import org . apache . cassandra . cql3 . functions . * ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . exceptions . UnauthorizedException ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . thrift . ThriftValidation ; import org . apache . cassandra . transport . Event ; public final class DropAggregateStatement extends SchemaAlteringStatement { private FunctionName functionName ; private final boolean ifExists ; private final List < CQL3Type . Raw > argRawTypes ; private final boolean argsPresent ; public DropAggregateStatement ( FunctionName functionName , List < CQL3Type . Raw > argRawTypes , boolean argsPresent , boolean ifExists ) { this . functionName = functionName ; this . argRawTypes = argRawTypes ; this . argsPresent = argsPresent ; this . ifExists = ifExists ; } public void prepareKeyspace ( ClientState state ) throws InvalidRequestException { if ( ! functionName . hasKeyspace ( ) & & state . getRawKeyspace ( ) ! = null ) functionName = new FunctionName ( state . getKeyspace ( ) , functionName . name ) ; if ( ! functionName . hasKeyspace ( ) ) throw new InvalidRequestException ( <str> ) ; ThriftValidation . validateKeyspaceNotSystem ( functionName . keyspace ) ; } public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException { state . hasKeyspaceAccess ( functionName . keyspace , Permission . DROP ) ; } public void validate ( ClientState state ) throws RequestValidationException { } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws RequestValidationException { Collection < Function > olds = Schema . instance . getFunctions ( functionName ) ; if ( ! argsPresent & & olds ! = null & & olds . size ( ) > <int> ) throw new InvalidRequestException ( String . format ( <str> + <str> + <str> + <str> , functionName , functionName , functionName ) ) ; Function old = null ; if ( argsPresent ) { if ( Schema . instance . getKSMetaData ( functionName . keyspace ) ! = null ) { List < AbstractType < ? > > argTypes = new ArrayList < > ( argRawTypes . size ( ) ) ; for ( CQL3Type . Raw rawType : argRawTypes ) argTypes . add ( prepareType ( <str> , rawType ) ) ; old = Schema . instance . findFunction ( functionName , argTypes ) . orElse ( null ) ; } if ( old = = null | | ! ( old instanceof AggregateFunction ) ) { if ( ifExists ) return null ; StringBuilder sb = new StringBuilder ( ) ; for ( CQL3Type . Raw rawType : argRawTypes ) { if ( sb . length ( ) > <int> ) sb . append ( <str> ) ; sb . append ( rawType ) ; } throw new InvalidRequestException ( String . format ( <str> , functionName , sb ) ) ; } } else { if ( olds = = null | | olds . isEmpty ( ) | | ! ( olds . iterator ( ) . next ( ) instanceof AggregateFunction ) ) { if ( ifExists ) return null ; throw new InvalidRequestException ( String . format ( <str> , functionName ) ) ; } old = olds . iterator ( ) . next ( ) ; } if ( old . isNative ( ) ) throw new InvalidRequestException ( String . format ( <str> + <str> , functionName ) ) ; MigrationManager . announceAggregateDrop ( ( UDAggregate ) old , isLocalOnly ) ; return new Event . SchemaChange ( Event . SchemaChange . Change . DROPPED , Event . SchemaChange . Target . AGGREGATE , old . name ( ) . keyspace , old . name ( ) . name , AbstractType . asCQLTypeStringList ( old . argTypes ( ) ) ) ; } private AbstractType < ? > prepareType ( String typeName , CQL3Type . Raw rawType ) { if ( rawType . isFrozen ( ) ) throw new InvalidRequestException ( String . format ( <str> , typeName ) ) ; if ( ! rawType . canBeNonFrozen ( ) ) rawType . freeze ( ) ; AbstractType < ? > type = rawType . prepare ( functionName . keyspace ) . getType ( ) ; return type ; } } 
