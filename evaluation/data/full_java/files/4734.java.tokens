package org . eclipse . debug . ui . actions ; import org . eclipse . core . resources . IWorkspaceRunnable ; import org . eclipse . core . runtime . CoreException ; import org . eclipse . core . runtime . IProgressMonitor ; import org . eclipse . core . runtime . IStatus ; import org . eclipse . core . runtime . Status ; import org . eclipse . core . runtime . jobs . Job ; import org . eclipse . debug . core . DebugEvent ; import org . eclipse . debug . core . DebugException ; import org . eclipse . debug . core . DebugPlugin ; import org . eclipse . debug . core . IBreakpointManager ; import org . eclipse . debug . core . IBreakpointManagerListener ; import org . eclipse . debug . core . IDebugEventSetListener ; import org . eclipse . debug . core . model . IBreakpoint ; import org . eclipse . debug . core . model . IDebugTarget ; import org . eclipse . debug . core . model . ISuspendResume ; import org . eclipse . debug . core . model . IThread ; import org . eclipse . debug . internal . ui . actions . ActionMessages ; import org . eclipse . debug . ui . DebugUITools ; import org . eclipse . debug . ui . IDebugUIConstants ; public class RunToLineHandler implements IDebugEventSetListener , IBreakpointManagerListener , IWorkspaceRunnable { private IDebugTarget fTarget ; private ISuspendResume fResumee ; private IBreakpoint fBreakpoint ; private boolean fAutoSkip = false ; public RunToLineHandler ( IDebugTarget target , ISuspendResume suspendResume , IBreakpoint breakpoint ) { fResumee = suspendResume ; fTarget = target ; fBreakpoint = breakpoint ; } @Override public void handleDebugEvents ( DebugEvent [ ] events ) { for ( int i = <int> ; i < events . length ; i + + ) { DebugEvent event = events [ i ] ; Object source = event . getSource ( ) ; if ( source instanceof IThread & & event . getKind ( ) = = DebugEvent . SUSPEND & & event . getDetail ( ) = = DebugEvent . BREAKPOINT ) { IThread thread = ( IThread ) source ; IDebugTarget suspendee = thread . getAdapter ( IDebugTarget . class ) ; if ( fTarget . equals ( suspendee ) ) { cancel ( ) ; } } else if ( source instanceof IDebugTarget & & event . getKind ( ) = = DebugEvent . TERMINATE ) { if ( source . equals ( fTarget ) ) { cancel ( ) ; } } } } @Override public void breakpointManagerEnablementChanged ( boolean enabled ) { fAutoSkip = false ; } private IBreakpointManager getBreakpointManager ( ) { return getDebugPlugin ( ) . getBreakpointManager ( ) ; } private DebugPlugin getDebugPlugin ( ) { return DebugPlugin . getDefault ( ) ; } public void cancel ( ) { IBreakpointManager manager = getBreakpointManager ( ) ; try { getDebugPlugin ( ) . removeDebugEventListener ( this ) ; manager . removeBreakpointManagerListener ( this ) ; fTarget . breakpointRemoved ( fBreakpoint , null ) ; } finally { if ( fAutoSkip ) { manager . setEnabled ( true ) ; } } } @Override public void run ( IProgressMonitor monitor ) throws CoreException { getDebugPlugin ( ) . addDebugEventListener ( this ) ; IBreakpointManager breakpointManager = getBreakpointManager ( ) ; fAutoSkip = DebugUITools . getPreferenceStore ( ) . getBoolean ( IDebugUIConstants . PREF_SKIP_BREAKPOINTS_DURING_RUN_TO_LINE ) & & breakpointManager . isEnabled ( ) ; if ( fAutoSkip ) { getBreakpointManager ( ) . setEnabled ( false ) ; breakpointManager . addBreakpointManagerListener ( this ) ; } Job job = new Job ( ActionMessages . RunToLineHandler_0 ) { @Override protected IStatus run ( IProgressMonitor jobMonitor ) { if ( ! jobMonitor . isCanceled ( ) ) { fTarget . breakpointAdded ( fBreakpoint ) ; try { fResumee . resume ( ) ; } catch ( DebugException e ) { cancel ( ) ; return e . getStatus ( ) ; } } return Status . OK_STATUS ; } } ; job . schedule ( ) ; } } 
