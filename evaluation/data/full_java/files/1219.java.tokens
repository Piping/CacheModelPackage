package org . apache . cassandra . utils ; import java . util . Arrays ; public class HistogramBuilder { public HistogramBuilder ( ) { } public HistogramBuilder ( long [ ] values ) { for ( long value : values ) { add ( value ) ; } } private long [ ] values = new long [ <int> ] ; int count = <int> ; public void add ( long value ) { if ( count = = values . length ) values = Arrays . copyOf ( values , values . length < < <int> ) ; values [ count + + ] = value ; } public EstimatedHistogram buildWithStdevRangesAroundMean ( ) { return buildWithStdevRangesAroundMean ( <int> ) ; } public EstimatedHistogram buildWithStdevRangesAroundMean ( int maxdevs ) { if ( maxdevs < <int> ) throw new IllegalArgumentException ( <str> ) ; final int count = this . count ; final long [ ] values = this . values ; if ( count = = <int> ) return new EstimatedHistogram ( new long [ ] { } , new long [ ] { <int> } ) ; long min = Long . MAX_VALUE , max = Long . MIN_VALUE ; double sum = <int> , sumsq = <int> ; for ( int i = <int> ; i < count ; i + + ) { final long value = values [ i ] ; sum + = value ; sumsq + = value * value ; if ( value < min ) min = value ; if ( value > max ) max = value ; } final long mean = Math . round ( sum / count ) ; final double stdev = Math . sqrt ( ( sumsq / count ) - ( mean * ( double ) mean ) ) ; final long [ ] lowhalf = buildRange ( mean , min , true , stdev , maxdevs ) ; final long [ ] highhalf = buildRange ( mean , max , false , stdev , maxdevs ) ; final long [ ] ranges = new long [ lowhalf . length + highhalf . length + <int> ] ; System . arraycopy ( lowhalf , <int> , ranges , <int> , lowhalf . length ) ; ranges [ lowhalf . length ] = mean ; System . arraycopy ( highhalf , <int> , ranges , lowhalf . length + <int> , highhalf . length ) ; final EstimatedHistogram hist = new EstimatedHistogram ( ranges , new long [ ranges . length + <int> ] ) ; for ( int i = <int> ; i < count ; i + + ) hist . add ( values [ i ] ) ; return hist ; } private static long [ ] buildRange ( long mean , long minormax , boolean ismin , double stdev , int maxdevs ) { if ( minormax = = mean ) return ismin ? new long [ ] { mean - <int> } : new long [ <int> ] ; if ( stdev < <int> ) { return ismin ? new long [ ] { minormax - <int> , mean - <int> } : new long [ ] { minormax } ; } long larger , smaller ; if ( ismin ) { larger = mean ; smaller = minormax ; } else { larger = minormax ; smaller = mean ; } double stdevsTo = ( larger - smaller ) / stdev ; if ( stdevsTo > <int> & & stdevsTo < <int> ) stdevsTo = <int> ; else stdevsTo = Math . round ( stdevsTo ) ; final int len = Math . min ( maxdevs + <int> , ( int ) stdevsTo ) ; final long [ ] range = new long [ len ] ; long next = ismin ? minormax - <int> : minormax ; for ( int i = <int> ; i < range . length ; i + + ) { long delta = ( range . length - ( i + <int> ) ) * ( long ) stdev ; if ( ismin ) { range [ i ] = next ; next = mean - delta ; } else { range [ len - <int> - i ] = next ; next = mean + delta ; } } return range ; } } 
