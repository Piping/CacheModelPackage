package org . apache . cassandra . utils ; import java . io . IOException ; import java . util . Arrays ; import java . util . concurrent . atomic . AtomicLongArray ; import com . google . common . base . Objects ; import org . apache . cassandra . db . TypeSizes ; import org . apache . cassandra . io . ISerializer ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . slf4j . Logger ; public class EstimatedHistogram { public static final EstimatedHistogramSerializer serializer = new EstimatedHistogramSerializer ( ) ; private final long [ ] bucketOffsets ; final AtomicLongArray buckets ; public EstimatedHistogram ( ) { this ( <int> ) ; } public EstimatedHistogram ( int bucketCount ) { this ( bucketCount , false ) ; } public EstimatedHistogram ( int bucketCount , boolean considerZeroes ) { bucketOffsets = newOffsets ( bucketCount , considerZeroes ) ; buckets = new AtomicLongArray ( bucketOffsets . length + <int> ) ; } public EstimatedHistogram ( long [ ] offsets , long [ ] bucketData ) { assert bucketData . length = = offsets . length + <int> ; bucketOffsets = offsets ; buckets = new AtomicLongArray ( bucketData ) ; } private static long [ ] newOffsets ( int size , boolean considerZeroes ) { long [ ] result = new long [ size + ( considerZeroes ? <int> : <int> ) ] ; int i = <int> ; if ( considerZeroes ) result [ i + + ] = <int> ; long last = <int> ; result [ i + + ] = last ; for ( ; i < result . length ; i + + ) { long next = Math . round ( last * <float> ) ; if ( next = = last ) next + + ; result [ i ] = next ; last = next ; } return result ; } public long [ ] getBucketOffsets ( ) { return bucketOffsets ; } public void add ( long n ) { int index = Arrays . binarySearch ( bucketOffsets , n ) ; if ( index < <int> ) { index = - index - <int> ; } buckets . incrementAndGet ( index ) ; } long get ( int bucket ) { return buckets . get ( bucket ) ; } public long [ ] getBuckets ( boolean reset ) { final int len = buckets . length ( ) ; long [ ] rv = new long [ len ] ; if ( reset ) for ( int i = <int> ; i < len ; i + + ) rv [ i ] = buckets . getAndSet ( i , <int> L ) ; else for ( int i = <int> ; i < len ; i + + ) rv [ i ] = buckets . get ( i ) ; return rv ; } public long min ( ) { for ( int i = <int> ; i < buckets . length ( ) ; i + + ) { if ( buckets . get ( i ) > <int> ) return i = = <int> ? <int> : <int> + bucketOffsets [ i - <int> ] ; } return <int> ; } public long max ( ) { int lastBucket = buckets . length ( ) - <int> ; if ( buckets . get ( lastBucket ) > <int> ) return Long . MAX_VALUE ; for ( int i = lastBucket - <int> ; i > = <int> ; i - - ) { if ( buckets . get ( i ) > <int> ) return bucketOffsets [ i ] ; } return <int> ; } public long percentile ( double percentile ) { assert percentile > = <int> & & percentile < = <float> ; int lastBucket = buckets . length ( ) - <int> ; if ( buckets . get ( lastBucket ) > <int> ) throw new IllegalStateException ( <str> ) ; long pcount = ( long ) Math . ceil ( count ( ) * percentile ) ; if ( pcount = = <int> ) return <int> ; long elements = <int> ; for ( int i = <int> ; i < lastBucket ; i + + ) { elements + = buckets . get ( i ) ; if ( elements > = pcount ) return bucketOffsets [ i ] ; } return <int> ; } public long mean ( ) { return ( long ) Math . ceil ( rawMean ( ) ) ; } public double rawMean ( ) { int lastBucket = buckets . length ( ) - <int> ; if ( buckets . get ( lastBucket ) > <int> ) throw new IllegalStateException ( <str> ) ; long elements = <int> ; long sum = <int> ; for ( int i = <int> ; i < lastBucket ; i + + ) { long bCount = buckets . get ( i ) ; elements + = bCount ; sum + = bCount * bucketOffsets [ i ] ; } return ( double ) sum / elements ; } public long count ( ) { long sum = <int> L ; for ( int i = <int> ; i < buckets . length ( ) ; i + + ) sum + = buckets . get ( i ) ; return sum ; } public boolean isOverflowed ( ) { return buckets . get ( buckets . length ( ) - <int> ) > <int> ; } public void log ( Logger log ) { int nameCount ; if ( buckets . get ( buckets . length ( ) - <int> ) = = <int> ) nameCount = buckets . length ( ) - <int> ; else nameCount = buckets . length ( ) ; String [ ] names = new String [ nameCount ] ; int maxNameLength = <int> ; for ( int i = <int> ; i < nameCount ; i + + ) { names [ i ] = nameOfRange ( bucketOffsets , i ) ; maxNameLength = Math . max ( maxNameLength , names [ i ] . length ( ) ) ; } String formatstr = <str> + maxNameLength + <str> ; for ( int i = <int> ; i < nameCount ; i + + ) { long count = buckets . get ( i ) ; if ( i = = <int> & & count = = <int> ) continue ; log . debug ( String . format ( formatstr , names [ i ] , count ) ) ; } } private static String nameOfRange ( long [ ] bucketOffsets , int index ) { StringBuilder sb = new StringBuilder ( ) ; appendRange ( sb , bucketOffsets , index ) ; return sb . toString ( ) ; } private static void appendRange ( StringBuilder sb , long [ ] bucketOffsets , int index ) { sb . append ( <str> ) ; if ( index = = <int> ) if ( bucketOffsets [ <int> ] > <int> ) sb . append ( <str> ) ; else sb . append ( <str> ) ; else sb . append ( bucketOffsets [ index - <int> ] + <int> ) ; sb . append ( <str> ) ; if ( index = = bucketOffsets . length ) sb . append ( <str> ) ; else sb . append ( bucketOffsets [ index ] ) ; sb . append ( <str> ) ; } @Override public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( ! ( o instanceof EstimatedHistogram ) ) return false ; EstimatedHistogram that = ( EstimatedHistogram ) o ; return Arrays . equals ( getBucketOffsets ( ) , that . getBucketOffsets ( ) ) & & Arrays . equals ( getBuckets ( false ) , that . getBuckets ( false ) ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( getBucketOffsets ( ) , getBuckets ( false ) ) ; } public static class EstimatedHistogramSerializer implements ISerializer < EstimatedHistogram > { public void serialize ( EstimatedHistogram eh , DataOutputPlus out ) throws IOException { long [ ] offsets = eh . getBucketOffsets ( ) ; long [ ] buckets = eh . getBuckets ( false ) ; out . writeInt ( buckets . length ) ; for ( int i = <int> ; i < buckets . length ; i + + ) { out . writeLong ( offsets [ i = = <int> ? <int> : i - <int> ] ) ; out . writeLong ( buckets [ i ] ) ; } } public EstimatedHistogram deserialize ( DataInputPlus in ) throws IOException { int size = in . readInt ( ) ; long [ ] offsets = new long [ size - <int> ] ; long [ ] buckets = new long [ size ] ; for ( int i = <int> ; i < size ; i + + ) { offsets [ i = = <int> ? <int> : i - <int> ] = in . readLong ( ) ; buckets [ i ] = in . readLong ( ) ; } return new EstimatedHistogram ( offsets , buckets ) ; } public long serializedSize ( EstimatedHistogram eh ) { int size = <int> ; long [ ] offsets = eh . getBucketOffsets ( ) ; long [ ] buckets = eh . getBuckets ( false ) ; size + = TypeSizes . sizeof ( buckets . length ) ; for ( int i = <int> ; i < buckets . length ; i + + ) { size + = TypeSizes . sizeof ( offsets [ i = = <int> ? <int> : i - <int> ] ) ; size + = TypeSizes . sizeof ( buckets [ i ] ) ; } return size ; } } } 
