package com . google . common . math ; import static com . google . common . truth . Truth . assertThat ; import static com . google . common . truth . Truth . assertWithMessage ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Sets ; import junit . framework . TestCase ; import java . util . Map ; import java . util . Random ; import java . util . Set ; public class QuantilesAlgorithmTest extends TestCase { private static final Random RNG = new Random ( <int> ) ; private static final int DATASET_SIZE = <int> ; private static final double ALLOWED_ERROR = <float> ; private static final QuantilesAlgorithm REFERENCE_ALGORITHM = QuantilesAlgorithm . SORTING ; private static final Set < QuantilesAlgorithm > NON_REFERENCE_ALGORITHMS = Sets . difference ( ImmutableSet . copyOf ( QuantilesAlgorithm . values ( ) ) , ImmutableSet . of ( REFERENCE_ALGORITHM ) ) ; private double [ ] dataset ; @Override protected void setUp ( ) { dataset = new double [ DATASET_SIZE ] ; for ( int i = <int> ; i < DATASET_SIZE ; i + + ) { dataset [ i ] = RNG . nextDouble ( ) ; } } public void testSingleQuantile_median ( ) { double referenceValue = REFERENCE_ALGORITHM . singleQuantile ( <int> , <int> , dataset . clone ( ) ) ; for ( QuantilesAlgorithm algorithm : NON_REFERENCE_ALGORITHMS ) { assertWithMessage ( <str> , algorithm , REFERENCE_ALGORITHM ) . that ( algorithm . singleQuantile ( <int> , <int> , dataset . clone ( ) ) ) . isWithin ( ALLOWED_ERROR ) . of ( referenceValue ) ; } } public void testSingleQuantile_percentile99 ( ) { double referenceValue = REFERENCE_ALGORITHM . singleQuantile ( <int> , <int> , dataset . clone ( ) ) ; for ( QuantilesAlgorithm algorithm : NON_REFERENCE_ALGORITHMS ) { assertWithMessage ( <str> , algorithm , REFERENCE_ALGORITHM ) . that ( algorithm . singleQuantile ( <int> , <int> , dataset . clone ( ) ) ) . isWithin ( ALLOWED_ERROR ) . of ( referenceValue ) ; } } public void testMultipleQuantile ( ) { ImmutableSet < Integer > indexes = ImmutableSet . of ( <int> , <int> , <int> ) ; Map < Integer , Double > referenceQuantiles = REFERENCE_ALGORITHM . multipleQuantiles ( indexes , <int> , dataset . clone ( ) ) ; assertThat ( referenceQuantiles . keySet ( ) ) . isEqualTo ( indexes ) ; for ( QuantilesAlgorithm algorithm : NON_REFERENCE_ALGORITHMS ) { Map < Integer , Double > quantiles = algorithm . multipleQuantiles ( indexes , <int> , dataset . clone ( ) ) ; assertWithMessage ( <str> + algorithm ) . that ( quantiles . keySet ( ) ) . isEqualTo ( indexes ) ; for ( int i : indexes ) { assertWithMessage ( <str> , algorithm , REFERENCE_ALGORITHM , i ) . that ( quantiles . get ( i ) ) . isWithin ( ALLOWED_ERROR ) . of ( referenceQuantiles . get ( i ) ) ; } } } } 
