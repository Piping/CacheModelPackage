package io . netty . util . concurrent ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . lang . Thread . State ; import java . util . ArrayList ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Queue ; import java . util . Set ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . Executor ; import java . util . concurrent . LinkedBlockingQueue ; import java . util . concurrent . RejectedExecutionException ; import java . util . concurrent . Semaphore ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import java . util . concurrent . atomic . AtomicReferenceFieldUpdater ; public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( SingleThreadEventExecutor . class ) ; private static final int ST_NOT_STARTED = <int> ; private static final int ST_STARTED = <int> ; private static final int ST_SHUTTING_DOWN = <int> ; private static final int ST_SHUTDOWN = <int> ; private static final int ST_TERMINATED = <int> ; private static final Runnable WAKEUP_TASK = new Runnable ( ) { @Override public void run ( ) { } } ; private static final Runnable NOOP_TASK = new Runnable ( ) { @Override public void run ( ) { } } ; private static final AtomicIntegerFieldUpdater < SingleThreadEventExecutor > STATE_UPDATER ; private static final AtomicReferenceFieldUpdater < SingleThreadEventExecutor , ThreadProperties > PROPERTIES_UPDATER ; static { AtomicIntegerFieldUpdater < SingleThreadEventExecutor > updater = PlatformDependent . newAtomicIntegerFieldUpdater ( SingleThreadEventExecutor . class , <str> ) ; if ( updater = = null ) { updater = AtomicIntegerFieldUpdater . newUpdater ( SingleThreadEventExecutor . class , <str> ) ; } STATE_UPDATER = updater ; AtomicReferenceFieldUpdater < SingleThreadEventExecutor , ThreadProperties > propertiesUpdater = PlatformDependent . newAtomicReferenceFieldUpdater ( SingleThreadEventExecutor . class , <str> ) ; if ( propertiesUpdater = = null ) { propertiesUpdater = AtomicReferenceFieldUpdater . newUpdater ( SingleThreadEventExecutor . class , ThreadProperties . class , <str> ) ; } PROPERTIES_UPDATER = propertiesUpdater ; } private final Queue < Runnable > taskQueue ; private volatile Thread thread ; private volatile ThreadProperties threadProperties ; private final Executor executor ; private volatile boolean interrupted ; private final Semaphore threadLock = new Semaphore ( <int> ) ; private final Set < Runnable > shutdownHooks = new LinkedHashSet < Runnable > ( ) ; private final boolean addTaskWakesUp ; private long lastExecutionTime ; @SuppressWarnings ( { <str> , <str> } ) private volatile int state = ST_NOT_STARTED ; private volatile long gracefulShutdownQuietPeriod ; private volatile long gracefulShutdownTimeout ; private long gracefulShutdownStartTime ; private final Promise < ? > terminationFuture = new DefaultPromise < Void > ( GlobalEventExecutor . INSTANCE ) ; protected SingleThreadEventExecutor ( EventExecutorGroup parent , ThreadFactory threadFactory , boolean addTaskWakesUp ) { this ( parent , new ThreadPerTaskExecutor ( threadFactory ) , addTaskWakesUp ) ; } protected SingleThreadEventExecutor ( EventExecutorGroup parent , Executor executor , boolean addTaskWakesUp ) { super ( parent ) ; if ( executor = = null ) { throw new NullPointerException ( <str> ) ; } this . addTaskWakesUp = addTaskWakesUp ; this . executor = executor ; taskQueue = newTaskQueue ( ) ; } protected Queue < Runnable > newTaskQueue ( ) { return new LinkedBlockingQueue < Runnable > ( ) ; } protected void interruptThread ( ) { Thread currentThread = thread ; if ( currentThread = = null ) { interrupted = true ; } else { currentThread . interrupt ( ) ; } } protected Runnable pollTask ( ) { assert inEventLoop ( ) ; for ( ; ; ) { Runnable task = taskQueue . poll ( ) ; if ( task = = WAKEUP_TASK ) { continue ; } return task ; } } protected Runnable takeTask ( ) { assert inEventLoop ( ) ; if ( ! ( taskQueue instanceof BlockingQueue ) ) { throw new UnsupportedOperationException ( ) ; } BlockingQueue < Runnable > taskQueue = ( BlockingQueue < Runnable > ) this . taskQueue ; for ( ; ; ) { ScheduledFutureTask < ? > scheduledTask = peekScheduledTask ( ) ; if ( scheduledTask = = null ) { Runnable task = null ; try { task = taskQueue . take ( ) ; if ( task = = WAKEUP_TASK ) { task = null ; } } catch ( InterruptedException e ) { } return task ; } else { long delayNanos = scheduledTask . delayNanos ( ) ; Runnable task = null ; if ( delayNanos > <int> ) { try { task = taskQueue . poll ( delayNanos , TimeUnit . NANOSECONDS ) ; } catch ( InterruptedException e ) { return null ; } } if ( task = = null ) { fetchFromScheduledTaskQueue ( ) ; task = taskQueue . poll ( ) ; } if ( task ! = null ) { return task ; } } } } private void fetchFromScheduledTaskQueue ( ) { if ( hasScheduledTasks ( ) ) { long nanoTime = AbstractScheduledEventExecutor . nanoTime ( ) ; for ( ; ; ) { Runnable scheduledTask = pollScheduledTask ( nanoTime ) ; if ( scheduledTask = = null ) { break ; } taskQueue . add ( scheduledTask ) ; } } } protected Runnable peekTask ( ) { assert inEventLoop ( ) ; return taskQueue . peek ( ) ; } protected boolean hasTasks ( ) { assert inEventLoop ( ) ; return ! taskQueue . isEmpty ( ) ; } public final int pendingTasks ( ) { return taskQueue . size ( ) ; } protected void addTask ( Runnable task ) { if ( task = = null ) { throw new NullPointerException ( <str> ) ; } if ( isShutdown ( ) ) { reject ( ) ; } taskQueue . add ( task ) ; } protected boolean removeTask ( Runnable task ) { if ( task = = null ) { throw new NullPointerException ( <str> ) ; } return taskQueue . remove ( task ) ; } protected boolean runAllTasks ( ) { fetchFromScheduledTaskQueue ( ) ; Runnable task = pollTask ( ) ; if ( task = = null ) { return false ; } for ( ; ; ) { try { task . run ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } task = pollTask ( ) ; if ( task = = null ) { lastExecutionTime = ScheduledFutureTask . nanoTime ( ) ; return true ; } } } protected boolean runAllTasks ( long timeoutNanos ) { fetchFromScheduledTaskQueue ( ) ; Runnable task = pollTask ( ) ; if ( task = = null ) { return false ; } final long deadline = ScheduledFutureTask . nanoTime ( ) + timeoutNanos ; long runTasks = <int> ; long lastExecutionTime ; for ( ; ; ) { try { task . run ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } runTasks + + ; if ( ( runTasks & <hex> ) = = <int> ) { lastExecutionTime = ScheduledFutureTask . nanoTime ( ) ; if ( lastExecutionTime > = deadline ) { break ; } } task = pollTask ( ) ; if ( task = = null ) { lastExecutionTime = ScheduledFutureTask . nanoTime ( ) ; break ; } } this . lastExecutionTime = lastExecutionTime ; return true ; } protected long delayNanos ( long currentTimeNanos ) { ScheduledFutureTask < ? > scheduledTask = peekScheduledTask ( ) ; if ( scheduledTask = = null ) { return SCHEDULE_PURGE_INTERVAL ; } return scheduledTask . delayNanos ( currentTimeNanos ) ; } protected void updateLastExecutionTime ( ) { lastExecutionTime = ScheduledFutureTask . nanoTime ( ) ; } protected abstract void run ( ) ; protected void cleanup ( ) { } protected void wakeup ( boolean inEventLoop ) { if ( ! inEventLoop | | STATE_UPDATER . get ( this ) = = ST_SHUTTING_DOWN ) { taskQueue . add ( WAKEUP_TASK ) ; } } @Override public boolean inEventLoop ( Thread thread ) { return thread = = this . thread ; } public void addShutdownHook ( final Runnable task ) { if ( inEventLoop ( ) ) { shutdownHooks . add ( task ) ; } else { execute ( new Runnable ( ) { @Override public void run ( ) { shutdownHooks . add ( task ) ; } } ) ; } } public void removeShutdownHook ( final Runnable task ) { if ( inEventLoop ( ) ) { shutdownHooks . remove ( task ) ; } else { execute ( new Runnable ( ) { @Override public void run ( ) { shutdownHooks . remove ( task ) ; } } ) ; } } private boolean runShutdownHooks ( ) { boolean ran = false ; while ( ! shutdownHooks . isEmpty ( ) ) { List < Runnable > copy = new ArrayList < Runnable > ( shutdownHooks ) ; shutdownHooks . clear ( ) ; for ( Runnable task : copy ) { try { task . run ( ) ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } finally { ran = true ; } } } if ( ran ) { lastExecutionTime = ScheduledFutureTask . nanoTime ( ) ; } return ran ; } @Override public Future < ? > shutdownGracefully ( long quietPeriod , long timeout , TimeUnit unit ) { if ( quietPeriod < <int> ) { throw new IllegalArgumentException ( <str> + quietPeriod + <str> ) ; } if ( timeout < quietPeriod ) { throw new IllegalArgumentException ( <str> + timeout + <str> + quietPeriod + <str> ) ; } if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } if ( isShuttingDown ( ) ) { return terminationFuture ( ) ; } boolean inEventLoop = inEventLoop ( ) ; boolean wakeup ; int oldState ; for ( ; ; ) { if ( isShuttingDown ( ) ) { return terminationFuture ( ) ; } int newState ; wakeup = true ; oldState = STATE_UPDATER . get ( this ) ; if ( inEventLoop ) { newState = ST_SHUTTING_DOWN ; } else { switch ( oldState ) { case ST_NOT_STARTED : case ST_STARTED : newState = ST_SHUTTING_DOWN ; break ; default : newState = oldState ; wakeup = false ; } } if ( STATE_UPDATER . compareAndSet ( this , oldState , newState ) ) { break ; } } gracefulShutdownQuietPeriod = unit . toNanos ( quietPeriod ) ; gracefulShutdownTimeout = unit . toNanos ( timeout ) ; if ( oldState = = ST_NOT_STARTED ) { doStartThread ( ) ; } if ( wakeup ) { wakeup ( inEventLoop ) ; } return terminationFuture ( ) ; } @Override public Future < ? > terminationFuture ( ) { return terminationFuture ; } @Override @Deprecated public void shutdown ( ) { if ( isShutdown ( ) ) { return ; } boolean inEventLoop = inEventLoop ( ) ; boolean wakeup ; int oldState ; for ( ; ; ) { if ( isShuttingDown ( ) ) { return ; } int newState ; wakeup = true ; oldState = STATE_UPDATER . get ( this ) ; if ( inEventLoop ) { newState = ST_SHUTDOWN ; } else { switch ( oldState ) { case ST_NOT_STARTED : case ST_STARTED : case ST_SHUTTING_DOWN : newState = ST_SHUTDOWN ; break ; default : newState = oldState ; wakeup = false ; } } if ( STATE_UPDATER . compareAndSet ( this , oldState , newState ) ) { break ; } } if ( oldState = = ST_NOT_STARTED ) { doStartThread ( ) ; } if ( wakeup ) { wakeup ( inEventLoop ) ; } } @Override public boolean isShuttingDown ( ) { return STATE_UPDATER . get ( this ) > = ST_SHUTTING_DOWN ; } @Override public boolean isShutdown ( ) { return STATE_UPDATER . get ( this ) > = ST_SHUTDOWN ; } @Override public boolean isTerminated ( ) { return STATE_UPDATER . get ( this ) = = ST_TERMINATED ; } protected boolean confirmShutdown ( ) { if ( ! isShuttingDown ( ) ) { return false ; } if ( ! inEventLoop ( ) ) { throw new IllegalStateException ( <str> ) ; } cancelScheduledTasks ( ) ; if ( gracefulShutdownStartTime = = <int> ) { gracefulShutdownStartTime = ScheduledFutureTask . nanoTime ( ) ; } if ( runAllTasks ( ) | | runShutdownHooks ( ) ) { if ( isShutdown ( ) ) { return true ; } wakeup ( true ) ; return false ; } final long nanoTime = ScheduledFutureTask . nanoTime ( ) ; if ( isShutdown ( ) | | nanoTime - gracefulShutdownStartTime > gracefulShutdownTimeout ) { return true ; } if ( nanoTime - lastExecutionTime < = gracefulShutdownQuietPeriod ) { wakeup ( true ) ; try { Thread . sleep ( <int> ) ; } catch ( InterruptedException e ) { } return false ; } return true ; } @Override public boolean awaitTermination ( long timeout , TimeUnit unit ) throws InterruptedException { if ( unit = = null ) { throw new NullPointerException ( <str> ) ; } if ( inEventLoop ( ) ) { throw new IllegalStateException ( <str> ) ; } if ( threadLock . tryAcquire ( timeout , unit ) ) { threadLock . release ( ) ; } return isTerminated ( ) ; } @Override public void execute ( Runnable task ) { if ( task = = null ) { throw new NullPointerException ( <str> ) ; } boolean inEventLoop = inEventLoop ( ) ; if ( inEventLoop ) { addTask ( task ) ; } else { startThread ( ) ; addTask ( task ) ; if ( isShutdown ( ) & & removeTask ( task ) ) { reject ( ) ; } } if ( ! addTaskWakesUp & & wakesUpForTask ( task ) ) { wakeup ( inEventLoop ) ; } } public final ThreadProperties threadProperties ( ) { ThreadProperties threadProperties = this . threadProperties ; if ( threadProperties = = null ) { Thread thread = this . thread ; if ( thread = = null ) { assert ! inEventLoop ( ) ; submit ( NOOP_TASK ) . syncUninterruptibly ( ) ; thread = this . thread ; assert thread ! = null ; } threadProperties = new DefaultThreadProperties ( thread ) ; if ( ! PROPERTIES_UPDATER . compareAndSet ( this , null , threadProperties ) ) { threadProperties = this . threadProperties ; } } return threadProperties ; } @SuppressWarnings ( <str> ) protected boolean wakesUpForTask ( Runnable task ) { return true ; } protected static void reject ( ) { throw new RejectedExecutionException ( <str> ) ; } private static final long SCHEDULE_PURGE_INTERVAL = TimeUnit . SECONDS . toNanos ( <int> ) ; private void startThread ( ) { if ( STATE_UPDATER . get ( this ) = = ST_NOT_STARTED ) { if ( STATE_UPDATER . compareAndSet ( this , ST_NOT_STARTED , ST_STARTED ) ) { doStartThread ( ) ; } } } private void doStartThread ( ) { assert thread = = null ; executor . execute ( new Runnable ( ) { @Override public void run ( ) { thread = Thread . currentThread ( ) ; if ( interrupted ) { thread . interrupt ( ) ; } boolean success = false ; updateLastExecutionTime ( ) ; try { SingleThreadEventExecutor . this . run ( ) ; success = true ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; } finally { for ( ; ; ) { int oldState = STATE_UPDATER . get ( SingleThreadEventExecutor . this ) ; if ( oldState > = ST_SHUTTING_DOWN | | STATE_UPDATER . compareAndSet ( SingleThreadEventExecutor . this , oldState , ST_SHUTTING_DOWN ) ) { break ; } } if ( success & & gracefulShutdownStartTime = = <int> ) { logger . error ( <str> + EventExecutor . class . getSimpleName ( ) + <str> + SingleThreadEventExecutor . class . getSimpleName ( ) + <str> + <str> ) ; } try { for ( ; ; ) { if ( confirmShutdown ( ) ) { break ; } } } finally { try { cleanup ( ) ; } finally { STATE_UPDATER . set ( SingleThreadEventExecutor . this , ST_TERMINATED ) ; threadLock . release ( ) ; if ( ! taskQueue . isEmpty ( ) ) { logger . warn ( <str> + <str> + taskQueue . size ( ) + <str> ) ; } terminationFuture . setSuccess ( null ) ; } } } } } ) ; } private static final class DefaultThreadProperties implements ThreadProperties { private final Thread t ; DefaultThreadProperties ( Thread t ) { this . t = t ; } @Override public State state ( ) { return t . getState ( ) ; } @Override public int priority ( ) { return t . getPriority ( ) ; } @Override public boolean isInterrupted ( ) { return t . isInterrupted ( ) ; } @Override public boolean isDaemon ( ) { return t . isDaemon ( ) ; } @Override public String name ( ) { return t . getName ( ) ; } @Override public long id ( ) { return t . getId ( ) ; } @Override public StackTraceElement [ ] stackTrace ( ) { return t . getStackTrace ( ) ; } @Override public boolean isAlive ( ) { return t . isAlive ( ) ; } } } 
