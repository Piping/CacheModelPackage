package org . eclipse . debug . internal . ui . views . memory . renderings ; import java . math . BigInteger ; import org . eclipse . debug . core . model . MemoryByte ; import org . eclipse . debug . internal . ui . DebugUIPlugin ; import org . eclipse . debug . ui . IDebugUIConstants ; public class SignedIntegerRendering extends AbstractIntegerRendering { private int fColSize ; private BigInteger fMax ; private BigInteger fMin ; public SignedIntegerRendering ( String renderingId ) { super ( renderingId ) ; } private String convertToString ( byte [ ] byteArray , int columnSize , int endianess ) { String ret ; long result = <int> ; if ( columnSize = = <int> ) { result = byteArray [ <int> ] ; } else if ( columnSize = = <int> ) { result = RenderingsUtil . convertByteArrayToShort ( byteArray , endianess ) ; } else if ( columnSize = = <int> ) { result = RenderingsUtil . convertByteArrayToInt ( byteArray , endianess ) ; } else if ( columnSize = = <int> ) { result = RenderingsUtil . convertByteArrayToLong ( byteArray , endianess ) ; } else if ( columnSize = = <int> ) { BigInteger bigRet = RenderingsUtil . convertByteArrayToSignedBigInt ( byteArray , endianess ) ; return bigRet . toString ( ) ; } else { BigInteger bigRet = RenderingsUtil . convertByteArrayToSignedBigInt ( byteArray , endianess , columnSize ) ; return bigRet . toString ( ) ; } ret = new Long ( result ) . toString ( ) ; return ret ; } private byte [ ] convertToBytes ( int colSize , String newValue , int endianess ) { try { byte [ ] bytes ; if ( colSize = = <int> ) { byte x = Byte . parseByte ( newValue ) ; bytes = new byte [ <int> ] ; bytes [ <int> ] = x ; } else if ( colSize = = <int> ) { short i = Short . parseShort ( newValue ) ; bytes = RenderingsUtil . convertShortToByteArray ( i , endianess ) ; } else if ( colSize = = <int> ) { int i = Integer . parseInt ( newValue ) ; bytes = RenderingsUtil . convertIntToByteArray ( i , endianess ) ; } else if ( colSize = = <int> ) { long i = Long . parseLong ( newValue ) ; bytes = RenderingsUtil . convertLongToByteArray ( i , endianess ) ; } else if ( colSize = = <int> ) { BigInteger i = new BigInteger ( newValue ) ; bytes = RenderingsUtil . convertBigIntegerToByteArray ( i , endianess ) ; return bytes ; } else { BigInteger i = new BigInteger ( newValue ) ; if ( fColSize ! = colSize ) { fColSize = colSize ; fMax = BigInteger . valueOf ( <int> ) ; fMax = fMax . pow ( colSize * <int> - <int> ) ; fMin = fMax . multiply ( BigInteger . valueOf ( - <int> ) ) ; fMax = fMax . subtract ( BigInteger . valueOf ( <int> ) ) ; } if ( i . compareTo ( fMax ) > <int> | | i . compareTo ( fMin ) < <int> ) throw new NumberFormatException ( ) ; bytes = RenderingsUtil . convertSignedBigIntToByteArray ( i , endianess , colSize ) ; return bytes ; } return bytes ; } catch ( NumberFormatException e ) { throw e ; } } @Override public String getString ( String dataType , BigInteger address , MemoryByte [ ] data ) { boolean invalid = false ; String paddedStr = DebugUIPlugin . getDefault ( ) . getPreferenceStore ( ) . getString ( IDebugUIConstants . PREF_PADDED_STR ) ; for ( int i = <int> ; i < data . length ; i + + ) { if ( ! data [ i ] . isReadable ( ) ) { invalid = true ; break ; } } if ( invalid ) { StringBuffer strBuf = new StringBuffer ( ) ; for ( int i = <int> ; i < data . length ; i + + ) { strBuf . append ( paddedStr ) ; } return strBuf . toString ( ) ; } int columnSize = getBytesPerColumn ( ) ; int endianess = getDisplayEndianess ( ) ; if ( endianess = = RenderingsUtil . ENDIANESS_UNKNOWN ) endianess = getBytesEndianess ( data ) ; byte [ ] byteArray = new byte [ data . length ] ; for ( int i = <int> ; i < byteArray . length ; i + + ) { byteArray [ i ] = data [ i ] . getValue ( ) ; } if ( RenderingsUtil . ENDIANESS_UNKNOWN = = endianess ) { StringBuffer strBuf = new StringBuffer ( ) ; for ( int i = <int> ; i < byteArray . length ; i + + ) { strBuf . append ( paddedStr ) ; } return strBuf . toString ( ) ; } return convertToString ( byteArray , columnSize , endianess ) ; } @Override public byte [ ] getBytes ( String dataType , BigInteger address , MemoryByte [ ] currentValues , String data ) { int columnSize = getBytesPerColumn ( ) ; int endianess = getDisplayEndianess ( ) ; if ( endianess = = RenderingsUtil . ENDIANESS_UNKNOWN ) endianess = getBytesEndianess ( currentValues ) ; if ( endianess = = RenderingsUtil . ENDIANESS_UNKNOWN ) { byte [ ] retBytes = new byte [ currentValues . length ] ; for ( int i = <int> ; i < currentValues . length ; i + + ) retBytes [ i ] = currentValues [ i ] . getValue ( ) ; return retBytes ; } return convertToBytes ( columnSize , data , endianess ) ; } } 
