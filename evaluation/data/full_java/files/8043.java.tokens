package org . elasticsearch . gateway ; import org . elasticsearch . Version ; import org . elasticsearch . cluster . ClusterChangedEvent ; import org . elasticsearch . cluster . ClusterState ; import org . elasticsearch . cluster . metadata . IndexMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . cluster . node . DiscoveryNodes ; import org . elasticsearch . cluster . routing . RoutingTable ; import org . elasticsearch . cluster . routing . allocation . AllocationService ; import org . elasticsearch . cluster . routing . allocation . decider . ClusterRebalanceAllocationDecider ; import org . elasticsearch . test . ESAllocationTestCase ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; import java . util . Set ; import static java . util . Collections . emptySet ; import static org . elasticsearch . cluster . routing . ShardRoutingState . INITIALIZING ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . hamcrest . Matchers . equalTo ; public class GatewayMetaStateTests extends ESAllocationTestCase { ClusterChangedEvent generateEvent ( boolean initializing , boolean versionChanged , boolean masterEligible ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ) ; ClusterState newClusterState , previousClusterState ; MetaData metaDataOldClusterState = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTableOldClusterState = RoutingTable . builder ( ) . addAsNew ( metaDataOldClusterState . index ( <str> ) ) . build ( ) ; ClusterState init = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaDataOldClusterState ) . routingTable ( routingTableOldClusterState ) . nodes ( generateDiscoveryNodes ( masterEligible ) ) . build ( ) ; RoutingTable routingTableNewClusterState = strategy . reroute ( init , <str> ) . routingTable ( ) ; if ( initializing = = false ) { ClusterState temp = ClusterState . builder ( init ) . routingTable ( routingTableNewClusterState ) . metaData ( metaDataOldClusterState ) . build ( ) ; routingTableNewClusterState = strategy . applyStartedShards ( temp , temp . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; routingTableOldClusterState = routingTableNewClusterState ; } else { } MetaData metaDataNewClusterState = MetaData . builder ( ) . put ( init . metaData ( ) . index ( <str> ) , versionChanged ) . build ( ) ; previousClusterState = ClusterState . builder ( init ) . metaData ( metaDataOldClusterState ) . routingTable ( routingTableOldClusterState ) . nodes ( generateDiscoveryNodes ( masterEligible ) ) . build ( ) ; newClusterState = ClusterState . builder ( previousClusterState ) . routingTable ( routingTableNewClusterState ) . metaData ( metaDataNewClusterState ) . version ( previousClusterState . getVersion ( ) + <int> ) . build ( ) ; ClusterChangedEvent event = new ClusterChangedEvent ( <str> , newClusterState , previousClusterState ) ; assertThat ( event . state ( ) . version ( ) , equalTo ( event . previousState ( ) . version ( ) + <int> ) ) ; return event ; } ClusterChangedEvent generateCloseEvent ( boolean masterEligible ) { AllocationService strategy = createAllocationService ( settingsBuilder ( ) . put ( <str> , <int> ) . put ( ClusterRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ALLOW_REBALANCE , <str> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ) ; ClusterState newClusterState , previousClusterState ; MetaData metaDataIndexCreated = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . build ( ) ; RoutingTable routingTableIndexCreated = RoutingTable . builder ( ) . addAsNew ( metaDataIndexCreated . index ( <str> ) ) . build ( ) ; ClusterState init = ClusterState . builder ( org . elasticsearch . cluster . ClusterName . DEFAULT ) . metaData ( metaDataIndexCreated ) . routingTable ( routingTableIndexCreated ) . nodes ( generateDiscoveryNodes ( masterEligible ) ) . build ( ) ; RoutingTable routingTableInitializing = strategy . reroute ( init , <str> ) . routingTable ( ) ; ClusterState temp = ClusterState . builder ( init ) . routingTable ( routingTableInitializing ) . build ( ) ; RoutingTable routingTableStarted = strategy . applyStartedShards ( temp , temp . getRoutingNodes ( ) . shardsWithState ( INITIALIZING ) ) . routingTable ( ) ; MetaData metaDataStarted = MetaData . builder ( ) . put ( init . metaData ( ) . index ( <str> ) , true ) . build ( ) ; MetaData metaDataClosed = MetaData . builder ( ) . put ( IndexMetaData . builder ( <str> ) . settings ( settings ( Version . CURRENT ) ) . state ( IndexMetaData . State . CLOSE ) . numberOfShards ( <int> ) . numberOfReplicas ( <int> ) ) . version ( metaDataStarted . version ( ) + <int> ) . build ( ) ; previousClusterState = ClusterState . builder ( init ) . metaData ( metaDataStarted ) . routingTable ( routingTableStarted ) . nodes ( generateDiscoveryNodes ( masterEligible ) ) . build ( ) ; newClusterState = ClusterState . builder ( previousClusterState ) . routingTable ( routingTableIndexCreated ) . metaData ( metaDataClosed ) . version ( previousClusterState . getVersion ( ) + <int> ) . build ( ) ; ClusterChangedEvent event = new ClusterChangedEvent ( <str> , newClusterState , previousClusterState ) ; assertThat ( event . state ( ) . version ( ) , equalTo ( event . previousState ( ) . version ( ) + <int> ) ) ; return event ; } private DiscoveryNodes . Builder generateDiscoveryNodes ( boolean masterEligible ) { Map < String , String > masterNodeAttributes = new HashMap < > ( ) ; masterNodeAttributes . put ( <str> , <str> ) ; masterNodeAttributes . put ( <str> , <str> ) ; Map < String , String > dataNodeAttributes = new HashMap < > ( ) ; dataNodeAttributes . put ( <str> , <str> ) ; dataNodeAttributes . put ( <str> , <str> ) ; return DiscoveryNodes . builder ( ) . put ( newNode ( <str> , masterEligible ? masterNodeAttributes : dataNodeAttributes ) ) . put ( newNode ( <str> , masterNodeAttributes ) ) . localNodeId ( <str> ) . masterNodeId ( masterEligible ? <str> : <str> ) ; } public void assertState ( ClusterChangedEvent event , boolean stateInMemory , boolean expectMetaData ) throws Exception { MetaData inMemoryMetaData = null ; Set < String > oldIndicesList = emptySet ( ) ; if ( stateInMemory ) { inMemoryMetaData = event . previousState ( ) . metaData ( ) ; oldIndicesList = GatewayMetaState . getRelevantIndices ( event . previousState ( ) , event . previousState ( ) , oldIndicesList ) ; } Set < String > newIndicesList = GatewayMetaState . getRelevantIndices ( event . state ( ) , event . previousState ( ) , oldIndicesList ) ; Iterator < GatewayMetaState . IndexMetaWriteInfo > indices = GatewayMetaState . resolveStatesToBeWritten ( oldIndicesList , newIndicesList , inMemoryMetaData , event . state ( ) . metaData ( ) ) . iterator ( ) ; if ( expectMetaData ) { assertThat ( indices . hasNext ( ) , equalTo ( true ) ) ; assertThat ( indices . next ( ) . getNewMetaData ( ) . getIndex ( ) , equalTo ( <str> ) ) ; assertThat ( indices . hasNext ( ) , equalTo ( false ) ) ; } else { assertThat ( indices . hasNext ( ) , equalTo ( false ) ) ; } } public void testVersionChangeIsAlwaysWritten ( ) throws Exception { boolean initializing = randomBoolean ( ) ; boolean versionChanged = true ; boolean stateInMemory = randomBoolean ( ) ; boolean masterEligible = randomBoolean ( ) ; boolean expectMetaData = true ; ClusterChangedEvent event = generateEvent ( initializing , versionChanged , masterEligible ) ; assertState ( event , stateInMemory , expectMetaData ) ; } public void testNewShardsAlwaysWritten ( ) throws Exception { boolean initializing = true ; boolean versionChanged = randomBoolean ( ) ; boolean stateInMemory = randomBoolean ( ) ; boolean masterEligible = false ; boolean expectMetaData = true ; ClusterChangedEvent event = generateEvent ( initializing , versionChanged , masterEligible ) ; assertState ( event , stateInMemory , expectMetaData ) ; } public void testAllUpToDateNothingWritten ( ) throws Exception { boolean initializing = false ; boolean versionChanged = false ; boolean stateInMemory = true ; boolean masterEligible = randomBoolean ( ) ; boolean expectMetaData = false ; ClusterChangedEvent event = generateEvent ( initializing , versionChanged , masterEligible ) ; assertState ( event , stateInMemory , expectMetaData ) ; } public void testNoWriteIfNothingChanged ( ) throws Exception { boolean initializing = false ; boolean versionChanged = false ; boolean stateInMemory = true ; boolean masterEligible = randomBoolean ( ) ; boolean expectMetaData = false ; ClusterChangedEvent event = generateEvent ( initializing , versionChanged , masterEligible ) ; ClusterChangedEvent newEventWithNothingChanged = new ClusterChangedEvent ( <str> , event . state ( ) , event . state ( ) ) ; assertState ( newEventWithNothingChanged , stateInMemory , expectMetaData ) ; } public void testWriteClosedIndex ( ) throws Exception { boolean masterEligible = randomBoolean ( ) ; boolean expectMetaData = true ; boolean stateInMemory = true ; ClusterChangedEvent event = generateCloseEvent ( masterEligible ) ; assertState ( event , stateInMemory , expectMetaData ) ; } } 
