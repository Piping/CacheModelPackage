package org . elasticsearch . common . joda ; import org . elasticsearch . ElasticsearchParseException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . test . ESTestCase ; import org . joda . time . DateTimeZone ; import java . util . TimeZone ; import java . util . concurrent . Callable ; import java . util . concurrent . atomic . AtomicBoolean ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; public class DateMathParserTests extends ESTestCase { FormatDateTimeFormatter formatter = Joda . forPattern ( <str> ) ; DateMathParser parser = new DateMathParser ( formatter ) ; private static Callable < Long > callable ( final long value ) { return new Callable < Long > ( ) { @Override public Long call ( ) throws Exception { return value ; } } ; } void assertDateMathEquals ( String toTest , String expected ) { assertDateMathEquals ( toTest , expected , <int> , false , null ) ; } void assertDateMathEquals ( String toTest , String expected , final long now , boolean roundUp , DateTimeZone timeZone ) { long gotMillis = parser . parse ( toTest , callable ( now ) , roundUp , timeZone ) ; assertDateEquals ( gotMillis , toTest , expected ) ; } void assertDateEquals ( long gotMillis , String original , String expected ) { long expectedMillis = parser . parse ( expected , callable ( <int> ) ) ; if ( gotMillis ! = expectedMillis ) { fail ( <str> + <str> + original + <str> + <str> + formatter . printer ( ) . print ( gotMillis ) + <str> + <str> + expected + <str> + <str> + expectedMillis + <str> + <str> + gotMillis + <str> ) ; } } public void testBasicDates ( ) { assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; } public void testRoundingDoesNotAffectExactDate ( ) { assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; } public void testTimezone ( ) { assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; } public void testBasicMath ( ) { assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; } public void testLenientEmptyMath ( ) { assertDateMathEquals ( <str> , <str> ) ; } public void testMultipleAdjustments ( ) { assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; } public void testNow ( ) { final long now = parser . parse ( <str> , callable ( <int> ) , false , null ) ; assertDateMathEquals ( <str> , <str> , now , false , null ) ; assertDateMathEquals ( <str> , <str> , now , false , null ) ; assertDateMathEquals ( <str> , <str> , now , false , null ) ; assertDateMathEquals ( <str> , <str> , now , false , null ) ; assertDateMathEquals ( <str> , <str> , now , false , DateTimeZone . forID ( <str> ) ) ; } public void testRounding ( ) { assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , true , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , true , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , true , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , false , DateTimeZone . forID ( <str> ) ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; assertDateMathEquals ( <str> , <str> , <int> , false , null ) ; assertDateMathEquals ( <str> , <str> , <int> , true , null ) ; } public void testTimestamps ( ) { assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; DateMathParser parser = new DateMathParser ( Joda . forPattern ( <str> ) ) ; long datetime = parser . parse ( <str> , callable ( <int> ) ) ; assertDateEquals ( datetime , <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; assertDateMathEquals ( <str> , <str> ) ; } void assertParseException ( String msg , String date , String exc ) { try { parser . parse ( date , callable ( <int> ) ) ; fail ( <str> + date + <str> + msg ) ; } catch ( ElasticsearchParseException e ) { assertThat ( ExceptionsHelper . detailedMessage ( e ) . contains ( exc ) , equalTo ( true ) ) ; } } public void testIllegalMathFormat ( ) { assertParseException ( <str> , <str> , <str> ) ; assertParseException ( <str> , <str> , <str> ) ; assertParseException ( <str> , <str> , <str> ) ; assertParseException ( <str> , <str> , <str> ) ; assertParseException ( <str> , <str> , <str> ) ; } public void testIllegalDateFormat ( ) { assertParseException ( <str> , Long . toString ( Long . MAX_VALUE ) + <str> , <str> ) ; assertParseException ( <str> , <str> , <str> ) ; } public void testOnlyCallsNowIfNecessary ( ) { final AtomicBoolean called = new AtomicBoolean ( ) ; final Callable < Long > now = new Callable < Long > ( ) { @Override public Long call ( ) throws Exception { called . set ( true ) ; return <int> ; } } ; parser . parse ( <str> , now , false , null ) ; assertFalse ( called . get ( ) ) ; parser . parse ( <str> , now , false , null ) ; assertTrue ( called . get ( ) ) ; } public void testThatUnixTimestampMayNotHaveTimeZone ( ) { DateMathParser parser = new DateMathParser ( Joda . forPattern ( <str> ) ) ; try { parser . parse ( <str> , callable ( <int> ) , false , DateTimeZone . forTimeZone ( TimeZone . getTimeZone ( <str> ) ) ) ; fail ( <str> ) ; } catch ( ElasticsearchParseException e ) { assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; assertThat ( e . getMessage ( ) , containsString ( <str> ) ) ; } } } 
