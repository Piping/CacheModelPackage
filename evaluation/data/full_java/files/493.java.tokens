package org . apache . cassandra . db . rows ; import java . io . IOException ; import java . nio . ByteBuffer ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . context . CounterContext ; import org . apache . cassandra . db . marshal . ByteType ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . ObjectSizes ; import org . apache . cassandra . utils . FBUtilities ; import org . apache . cassandra . utils . memory . AbstractAllocator ; public class BufferCell extends AbstractCell { private static final long EMPTY_SIZE = ObjectSizes . measure ( new BufferCell ( ColumnDefinition . regularDef ( <str> , <str> , <str> , ByteType . instance ) , <int> L , <int> , <int> , ByteBufferUtil . EMPTY_BYTE_BUFFER , null ) ) ; private final long timestamp ; private final int ttl ; private final int localDeletionTime ; private final ByteBuffer value ; private final CellPath path ; public BufferCell ( ColumnDefinition column , long timestamp , int ttl , int localDeletionTime , ByteBuffer value , CellPath path ) { super ( column ) ; assert column . isComplex ( ) = = ( path ! = null ) ; this . timestamp = timestamp ; this . ttl = ttl ; this . localDeletionTime = localDeletionTime ; this . value = value ; this . path = path ; } public static BufferCell live ( CFMetaData metadata , ColumnDefinition column , long timestamp , ByteBuffer value ) { return live ( metadata , column , timestamp , value , null ) ; } public static BufferCell live ( CFMetaData metadata , ColumnDefinition column , long timestamp , ByteBuffer value , CellPath path ) { if ( metadata . params . defaultTimeToLive ! = NO_TTL ) return expiring ( column , timestamp , metadata . params . defaultTimeToLive , FBUtilities . nowInSeconds ( ) , value , path ) ; return new BufferCell ( column , timestamp , NO_TTL , NO_DELETION_TIME , value , path ) ; } public static BufferCell expiring ( ColumnDefinition column , long timestamp , int ttl , int nowInSec , ByteBuffer value ) { return expiring ( column , timestamp , ttl , nowInSec , value , null ) ; } public static BufferCell expiring ( ColumnDefinition column , long timestamp , int ttl , int nowInSec , ByteBuffer value , CellPath path ) { assert ttl ! = NO_TTL ; return new BufferCell ( column , timestamp , ttl , nowInSec + ttl , value , path ) ; } public static BufferCell tombstone ( ColumnDefinition column , long timestamp , int nowInSec ) { return tombstone ( column , timestamp , nowInSec , null ) ; } public static BufferCell tombstone ( ColumnDefinition column , long timestamp , int nowInSec , CellPath path ) { return new BufferCell ( column , timestamp , NO_TTL , nowInSec , ByteBufferUtil . EMPTY_BYTE_BUFFER , path ) ; } public boolean isCounterCell ( ) { return ! isTombstone ( ) & & column . cellValueType ( ) . isCounter ( ) ; } public boolean isLive ( int nowInSec ) { return localDeletionTime = = NO_DELETION_TIME | | ( ttl ! = NO_TTL & & nowInSec < localDeletionTime ) ; } public boolean isTombstone ( ) { return localDeletionTime ! = NO_DELETION_TIME & & ttl = = NO_TTL ; } public boolean isExpiring ( ) { return ttl ! = NO_TTL ; } public long timestamp ( ) { return timestamp ; } public int ttl ( ) { return ttl ; } public int localDeletionTime ( ) { return localDeletionTime ; } public ByteBuffer value ( ) { return value ; } public CellPath path ( ) { return path ; } public Cell withUpdatedValue ( ByteBuffer newValue ) { return new BufferCell ( column , timestamp , ttl , localDeletionTime , newValue , path ) ; } public Cell copy ( AbstractAllocator allocator ) { if ( ! value . hasRemaining ( ) ) return this ; return new BufferCell ( column , timestamp , ttl , localDeletionTime , allocator . clone ( value ) , path = = null ? null : path . copy ( allocator ) ) ; } public Cell markCounterLocalToBeCleared ( ) { if ( ! isCounterCell ( ) ) return this ; ByteBuffer marked = CounterContext . instance ( ) . markLocalToBeCleared ( value ( ) ) ; return marked = = value ( ) ? this : new BufferCell ( column , timestamp , ttl , localDeletionTime , marked , path ) ; } public Cell purge ( DeletionPurger purger , int nowInSec ) { if ( ! isLive ( nowInSec ) ) { if ( purger . shouldPurge ( timestamp , localDeletionTime ) ) return null ; if ( isExpiring ( ) ) { return BufferCell . tombstone ( column , timestamp , localDeletionTime - ttl ) ; } } return this ; } public Cell updateAllTimestamp ( long newTimestamp ) { return new BufferCell ( column , isTombstone ( ) ? newTimestamp - <int> : newTimestamp , ttl , localDeletionTime , value , path ) ; } public int dataSize ( ) { return TypeSizes . sizeof ( timestamp ) + TypeSizes . sizeof ( ttl ) + TypeSizes . sizeof ( localDeletionTime ) + value . remaining ( ) + ( path = = null ? <int> : path . dataSize ( ) ) ; } public long unsharedHeapSizeExcludingData ( ) { return EMPTY_SIZE + ObjectSizes . sizeOnHeapExcludingData ( value ) + ( path = = null ? <int> : path . unsharedHeapSizeExcludingData ( ) ) ; } static class Serializer implements Cell . Serializer { private final static int IS_DELETED_MASK = <hex> ; private final static int IS_EXPIRING_MASK = <hex> ; private final static int HAS_EMPTY_VALUE_MASK = <hex> ; private final static int USE_ROW_TIMESTAMP_MASK = <hex> ; private final static int USE_ROW_TTL_MASK = <hex> ; public void serialize ( Cell cell , DataOutputPlus out , LivenessInfo rowLiveness , SerializationHeader header ) throws IOException { assert cell ! = null ; boolean hasValue = cell . value ( ) . hasRemaining ( ) ; boolean isDeleted = cell . isTombstone ( ) ; boolean isExpiring = cell . isExpiring ( ) ; boolean useRowTimestamp = ! rowLiveness . isEmpty ( ) & & cell . timestamp ( ) = = rowLiveness . timestamp ( ) ; boolean useRowTTL = isExpiring & & rowLiveness . isExpiring ( ) & & cell . ttl ( ) = = rowLiveness . ttl ( ) & & cell . localDeletionTime ( ) = = rowLiveness . localExpirationTime ( ) ; int flags = <int> ; if ( ! hasValue ) flags | = HAS_EMPTY_VALUE_MASK ; if ( isDeleted ) flags | = IS_DELETED_MASK ; else if ( isExpiring ) flags | = IS_EXPIRING_MASK ; if ( useRowTimestamp ) flags | = USE_ROW_TIMESTAMP_MASK ; if ( useRowTTL ) flags | = USE_ROW_TTL_MASK ; out . writeByte ( ( byte ) flags ) ; if ( ! useRowTimestamp ) header . writeTimestamp ( cell . timestamp ( ) , out ) ; if ( ( isDeleted | | isExpiring ) & & ! useRowTTL ) header . writeLocalDeletionTime ( cell . localDeletionTime ( ) , out ) ; if ( isExpiring & & ! useRowTTL ) header . writeTTL ( cell . ttl ( ) , out ) ; if ( cell . column ( ) . isComplex ( ) ) cell . column ( ) . cellPathSerializer ( ) . serialize ( cell . path ( ) , out ) ; if ( hasValue ) header . getType ( cell . column ( ) ) . writeValue ( cell . value ( ) , out ) ; } public Cell deserialize ( DataInputPlus in , LivenessInfo rowLiveness , ColumnDefinition column , SerializationHeader header , SerializationHelper helper ) throws IOException { int flags = in . readUnsignedByte ( ) ; boolean hasValue = ( flags & HAS_EMPTY_VALUE_MASK ) = = <int> ; boolean isDeleted = ( flags & IS_DELETED_MASK ) ! = <int> ; boolean isExpiring = ( flags & IS_EXPIRING_MASK ) ! = <int> ; boolean useRowTimestamp = ( flags & USE_ROW_TIMESTAMP_MASK ) ! = <int> ; boolean useRowTTL = ( flags & USE_ROW_TTL_MASK ) ! = <int> ; long timestamp = useRowTimestamp ? rowLiveness . timestamp ( ) : header . readTimestamp ( in ) ; int localDeletionTime = useRowTTL ? rowLiveness . localExpirationTime ( ) : ( isDeleted | | isExpiring ? header . readLocalDeletionTime ( in ) : NO_DELETION_TIME ) ; int ttl = useRowTTL ? rowLiveness . ttl ( ) : ( isExpiring ? header . readTTL ( in ) : NO_TTL ) ; CellPath path = column . isComplex ( ) ? column . cellPathSerializer ( ) . deserialize ( in ) : null ; boolean isCounter = localDeletionTime = = NO_DELETION_TIME & & column . type . isCounter ( ) ; ByteBuffer value = ByteBufferUtil . EMPTY_BYTE_BUFFER ; if ( hasValue ) { if ( helper . canSkipValue ( column ) | | ( path ! = null & & helper . canSkipValue ( path ) ) ) { header . getType ( column ) . skipValue ( in ) ; } else { value = header . getType ( column ) . readValue ( in ) ; if ( isCounter ) value = helper . maybeClearCounterValue ( value ) ; } } return new BufferCell ( column , timestamp , ttl , localDeletionTime , value , path ) ; } public long serializedSize ( Cell cell , LivenessInfo rowLiveness , SerializationHeader header ) { long size = <int> ; boolean hasValue = cell . value ( ) . hasRemaining ( ) ; boolean isDeleted = cell . isTombstone ( ) ; boolean isExpiring = cell . isExpiring ( ) ; boolean useRowTimestamp = ! rowLiveness . isEmpty ( ) & & cell . timestamp ( ) = = rowLiveness . timestamp ( ) ; boolean useRowTTL = isExpiring & & rowLiveness . isExpiring ( ) & & cell . ttl ( ) = = rowLiveness . ttl ( ) & & cell . localDeletionTime ( ) = = rowLiveness . localExpirationTime ( ) ; if ( ! useRowTimestamp ) size + = header . timestampSerializedSize ( cell . timestamp ( ) ) ; if ( ( isDeleted | | isExpiring ) & & ! useRowTTL ) size + = header . localDeletionTimeSerializedSize ( cell . localDeletionTime ( ) ) ; if ( isExpiring & & ! useRowTTL ) size + = header . ttlSerializedSize ( cell . ttl ( ) ) ; if ( cell . column ( ) . isComplex ( ) ) size + = cell . column ( ) . cellPathSerializer ( ) . serializedSize ( cell . path ( ) ) ; if ( hasValue ) size + = header . getType ( cell . column ( ) ) . writtenLength ( cell . value ( ) ) ; return size ; } public boolean skip ( DataInputPlus in , ColumnDefinition column , SerializationHeader header ) throws IOException { int flags = in . readUnsignedByte ( ) ; boolean hasValue = ( flags & HAS_EMPTY_VALUE_MASK ) = = <int> ; boolean isDeleted = ( flags & IS_DELETED_MASK ) ! = <int> ; boolean isExpiring = ( flags & IS_EXPIRING_MASK ) ! = <int> ; boolean useRowTimestamp = ( flags & USE_ROW_TIMESTAMP_MASK ) ! = <int> ; boolean useRowTTL = ( flags & USE_ROW_TTL_MASK ) ! = <int> ; if ( ! useRowTimestamp ) header . skipTimestamp ( in ) ; if ( ! useRowTTL & & ( isDeleted | | isExpiring ) ) header . skipLocalDeletionTime ( in ) ; if ( ! useRowTTL & & isExpiring ) header . skipTTL ( in ) ; if ( column . isComplex ( ) ) column . cellPathSerializer ( ) . skip ( in ) ; if ( hasValue ) header . getType ( column ) . skipValue ( in ) ; return true ; } } } 
