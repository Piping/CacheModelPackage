package org . gradle . plugin . use . resolve . service . internal ; import com . google . common . base . Function ; import com . google . common . base . Joiner ; import com . google . common . collect . Iterables ; import org . gradle . api . internal . initialization . ClassLoaderScope ; import org . gradle . api . internal . plugins . DefaultPluginRegistry ; import org . gradle . api . internal . plugins . PluginImplementation ; import org . gradle . api . internal . plugins . PluginInspector ; import org . gradle . api . internal . plugins . PluginRegistry ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . plugin . internal . PluginId ; import org . gradle . plugin . use . internal . InvalidPluginRequestException ; import org . gradle . plugin . use . internal . PluginRequest ; import org . gradle . plugin . use . resolve . internal . PluginResolution ; import org . gradle . plugin . use . resolve . internal . PluginResolutionResult ; import org . gradle . plugin . use . resolve . internal . PluginResolveContext ; import org . gradle . plugin . use . resolve . internal . PluginResolver ; import java . io . File ; public class InjectedClasspathPluginResolver implements PluginResolver { private final ClassPath injectedClasspath ; private final PluginRegistry pluginRegistry ; public InjectedClasspathPluginResolver ( ClassLoaderScope parentScope , PluginInspector pluginInspector , ClassPath injectedClasspath ) { this . injectedClasspath = injectedClasspath ; this . pluginRegistry = new DefaultPluginRegistry ( pluginInspector , parentScope . createChild ( <str> ) . local ( injectedClasspath ) . lock ( ) ) ; } public void resolve ( PluginRequest pluginRequest , PluginResolutionResult result ) throws InvalidPluginRequestException { PluginImplementation < ? > plugin = pluginRegistry . lookup ( pluginRequest . getId ( ) ) ; if ( plugin = = null ) { String classpathStr = Joiner . on ( File . pathSeparator ) . join ( Iterables . transform ( injectedClasspath . getAsFiles ( ) , new Function < File , String > ( ) { @Override public String apply ( File input ) { return input . getAbsolutePath ( ) ; } } ) ) ; result . notFound ( getDescription ( ) , <str> + classpathStr ) ; } else { result . found ( getDescription ( ) , new InjectedClasspathPluginResolution ( plugin ) ) ; } } public String getDescription ( ) { return <str> ; } public boolean isClasspathEmpty ( ) { return injectedClasspath . isEmpty ( ) ; } private class InjectedClasspathPluginResolution implements PluginResolution { private final PluginImplementation < ? > plugin ; public InjectedClasspathPluginResolution ( PluginImplementation < ? > plugin ) { this . plugin = plugin ; } public PluginId getPluginId ( ) { return plugin . getPluginId ( ) ; } public void execute ( PluginResolveContext pluginResolveContext ) { pluginResolveContext . addFromDifferentLoader ( plugin ) ; } } } 
