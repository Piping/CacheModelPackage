package org . nd4j . linalg . shape ; import org . junit . Test ; import org . nd4j . linalg . BaseNd4jTest ; import org . nd4j . linalg . api . buffer . DataBuffer ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . shape . Shape ; import org . nd4j . linalg . api . shape . loop . coordinatefunction . CoordinateFunction ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . factory . Nd4jBackend ; import java . util . Arrays ; import java . util . concurrent . atomic . AtomicInteger ; import static org . junit . Assert . * ; public class ShapeTestsC extends BaseNd4jTest { public ShapeTestsC ( String name , Nd4jBackend backend ) { super ( name , backend ) ; } public ShapeTestsC ( Nd4jBackend backend ) { super ( backend ) ; } public ShapeTestsC ( ) { } public ShapeTestsC ( String name ) { super ( name ) ; } @Test public void testIterateOffsets ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray tad = arr . tensorAlongDimension ( <int> , <int> , <int> ) ; final int [ ] assertions = { <int> , <int> , <int> , <int> } ; final AtomicInteger atomicInteger = new AtomicInteger ( <int> ) ; CoordinateFunction function = new CoordinateFunction ( ) { @Override public void process ( int [ ] . . . coord ) { assertEquals ( assertions [ atomicInteger . getAndIncrement ( ) ] , coord [ <int> ] [ <int> ] ) ; } } ; Shape . forEachOffset ( tad , function ) ; INDArray tensor2 = tad . tensorAlongDimension ( <int> , <int> ) ; INDArray tad3 = tad . tensorAlongDimension ( <int> , <int> ) ; Shape . forEachOffset ( new INDArray [ ] { tensor2 , tad3 } , new CoordinateFunction ( ) { @Override public void process ( int [ ] . . . coord ) { for ( int i = <int> ; i < coord . length ; i + + ) { System . out . println ( Arrays . toString ( coord [ i ] ) ) ; } } } ) ; System . out . println ( <str> ) ; } @Test public void testSixteenZeroOne ( ) { INDArray baseArr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; assertEquals ( <int> , baseArr . tensorssAlongDimension ( <int> , <int> ) ) ; INDArray columnVectorFirst = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray columnVectorSecond = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray columnVectorThird = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray columnVectorFourth = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray [ ] assertions = new INDArray [ ] { columnVectorFirst , columnVectorSecond , columnVectorThird , columnVectorFourth } ; for ( int i = <int> ; i < baseArr . tensorssAlongDimension ( <int> , <int> ) ; i + + ) { INDArray test = baseArr . tensorAlongDimension ( i , <int> , <int> ) ; assertEquals ( <str> + i , assertions [ i ] , test ) ; } } @Test public void testSixteenSecondDim ( ) { INDArray baseArr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; INDArray [ ] assertions = new INDArray [ ] { Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , } ; for ( int i = <int> ; i < baseArr . tensorssAlongDimension ( <int> ) ; i + + ) { INDArray arr = baseArr . tensorAlongDimension ( i , <int> ) ; assertEquals ( <str> + i , assertions [ i ] , arr ) ; } } @Test public void testThreeTwoTwo ( ) { INDArray threeTwoTwo = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray [ ] assertions = new INDArray [ ] { Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , } ; assertEquals ( assertions . length , threeTwoTwo . tensorssAlongDimension ( <int> ) ) ; for ( int i = <int> ; i < assertions . length ; i + + ) { INDArray arr = threeTwoTwo . tensorAlongDimension ( i , <int> ) ; assertEquals ( assertions [ i ] , arr ) ; } } @Test public void testThreeTwoTwoTwo ( ) { INDArray threeTwoTwo = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray [ ] assertions = new INDArray [ ] { Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , } ; assertEquals ( assertions . length , threeTwoTwo . tensorssAlongDimension ( <int> ) ) ; for ( int i = <int> ; i < assertions . length ; i + + ) { assertEquals ( assertions [ i ] , threeTwoTwo . tensorAlongDimension ( i , <int> ) ) ; } } @Test public void testPutRow ( ) { INDArray matrix = Nd4j . create ( new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } } ) ; for ( int i = <int> ; i < matrix . rows ( ) ; i + + ) { INDArray row = matrix . getRow ( i ) ; System . out . println ( matrix . getRow ( i ) ) ; } matrix . putRow ( <int> , Nd4j . create ( new double [ ] { <int> , <int> } ) ) ; assertEquals ( matrix . getRow ( <int> ) , matrix . getRow ( <int> ) ) ; } @Test public void testSixteenFirstDim ( ) { INDArray baseArr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; INDArray [ ] assertions = new INDArray [ ] { Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , Nd4j . create ( new double [ ] { <int> , <int> } ) , } ; for ( int i = <int> ; i < baseArr . tensorssAlongDimension ( <int> ) ; i + + ) { INDArray arr = baseArr . tensorAlongDimension ( i , <int> ) ; assertEquals ( <str> + i , assertions [ i ] , arr ) ; } } @Test public void testReshapePermute ( ) { INDArray arrNoPermute = Nd4j . ones ( <int> , <int> , <int> ) ; INDArray reshaped2dNoPermute = arrNoPermute . reshape ( <int> * <int> , <int> ) ; assertArrayEquals ( reshaped2dNoPermute . shape ( ) , new int [ ] { <int> * <int> , <int> } ) ; INDArray arr = Nd4j . ones ( <int> , <int> , <int> ) ; INDArray permuted = arr . permute ( <int> , <int> , <int> ) ; assertArrayEquals ( arrNoPermute . shape ( ) , permuted . shape ( ) ) ; INDArray reshaped2D = permuted . reshape ( <int> * <int> , <int> ) ; assertArrayEquals ( reshaped2D . shape ( ) , new int [ ] { <int> * <int> , <int> } ) ; } @Test public void testEight ( ) { INDArray baseArr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; assertEquals ( <int> , baseArr . tensorssAlongDimension ( <int> , <int> ) ) ; INDArray columnVectorFirst = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray columnVectorSecond = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray test1 = baseArr . tensorAlongDimension ( <int> , <int> , <int> ) ; assertEquals ( columnVectorFirst , test1 ) ; INDArray test2 = baseArr . tensorAlongDimension ( <int> , <int> , <int> ) ; assertEquals ( columnVectorSecond , test2 ) ; } @Test public void testOtherReshape ( ) { INDArray nd = Nd4j . create ( new double [ ] { <int> , <int> , <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray slice = nd . slice ( <int> , <int> ) ; INDArray vector = slice . reshape ( <int> , <int> ) ; for ( int i = <int> ; i < vector . length ( ) ; i + + ) { System . out . println ( vector . getDouble ( i ) ) ; } assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , vector ) ; } @Test public void testVectorAlongDimension ( ) { INDArray arr = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray vectorDimensionTest = arr . vectorAlongDimension ( <int> , <int> ) ; assertEquals ( assertion , vectorDimensionTest ) ; int vectorsAlongDimension1 = arr . vectorsAlongDimension ( <int> ) ; assertEquals ( <int> , vectorsAlongDimension1 ) ; INDArray zeroOne = arr . vectorAlongDimension ( <int> , <int> ) ; assertEquals ( zeroOne , Nd4j . create ( new float [ ] { <int> , <int> , <int> } ) ) ; INDArray testColumn2Assertion = Nd4j . create ( new float [ ] { <int> , <int> , <int> } ) ; INDArray testColumn2 = arr . vectorAlongDimension ( <int> , <int> ) ; assertEquals ( testColumn2Assertion , testColumn2 ) ; INDArray testColumn3Assertion = Nd4j . create ( new float [ ] { <int> , <int> , <int> } ) ; INDArray testColumn3 = arr . vectorAlongDimension ( <int> , <int> ) ; assertEquals ( testColumn3Assertion , testColumn3 ) ; INDArray v1 = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( new int [ ] { <int> , <int> } ) ; INDArray testColumnV1 = v1 . vectorAlongDimension ( <int> , <int> ) ; INDArray testColumnV1Assertion = Nd4j . create ( new float [ ] { <int> , <int> } ) ; assertEquals ( testColumnV1Assertion , testColumnV1 ) ; INDArray testRowV1 = v1 . vectorAlongDimension ( <int> , <int> ) ; INDArray testRowV1Assertion = Nd4j . create ( new float [ ] { <int> , <int> } ) ; assertEquals ( testRowV1Assertion , testRowV1 ) ; INDArray n = Nd4j . create ( Nd4j . linspace ( <int> , <int> , <int> ) . data ( ) , new int [ ] { <int> , <int> , <int> } ) ; INDArray vectorOne = n . vectorAlongDimension ( <int> , <int> ) ; INDArray assertionVectorOne = Nd4j . create ( new double [ ] { <int> , <int> } ) ; assertEquals ( assertionVectorOne , vectorOne ) ; INDArray oneThroughSixteen = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; assertEquals ( <int> , oneThroughSixteen . vectorsAlongDimension ( <int> ) ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , oneThroughSixteen . vectorAlongDimension ( <int> , <int> ) ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , oneThroughSixteen . vectorAlongDimension ( <int> , <int> ) ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , oneThroughSixteen . vectorAlongDimension ( <int> , <int> ) ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , oneThroughSixteen . vectorAlongDimension ( <int> , <int> ) ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , oneThroughSixteen . vectorAlongDimension ( <int> , <int> ) ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , oneThroughSixteen . vectorAlongDimension ( <int> , <int> ) ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , oneThroughSixteen . vectorAlongDimension ( <int> , <int> ) ) ; assertEquals ( Nd4j . create ( new double [ ] { <int> , <int> } ) , oneThroughSixteen . vectorAlongDimension ( <int> , <int> ) ) ; INDArray fourdTest = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; double [ ] [ ] assertionsArr = new double [ ] [ ] { { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , { <int> , <int> } , } ; assertEquals ( assertionsArr . length , fourdTest . vectorsAlongDimension ( <int> ) ) ; for ( int i = <int> ; i < assertionsArr . length ; i + + ) { INDArray test = fourdTest . vectorAlongDimension ( i , <int> ) ; INDArray assertionEntry = Nd4j . create ( assertionsArr [ i ] ) ; assertEquals ( assertionEntry , test ) ; } } @Test public void testColumnSum ( ) { INDArray twoByThree = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray columnVar = twoByThree . sum ( <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } ) ; assertEquals ( getFailureMessage ( ) , assertion , columnVar ) ; } @Test public void testRowMean ( ) { INDArray twoByThree = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray rowMean = twoByThree . mean ( <int> ) ; INDArray assertion = Nd4j . create ( new double [ ] { <float> , <float> } ) ; assertEquals ( getFailureMessage ( ) , assertion , rowMean ) ; } @Test public void testRowStd ( ) { INDArray twoByThree = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray rowStd = twoByThree . std ( <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <float> , <float> } ) ; assertEquals ( getFailureMessage ( ) , assertion , rowStd ) ; } @Test public void testColumnSumDouble ( ) { Nd4j . dtype = DataBuffer . Type . DOUBLE ; INDArray twoByThree = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray columnVar = twoByThree . sum ( <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <float> , <float> , <float> , <float> } ) ; assertEquals ( getFailureMessage ( ) , assertion , columnVar ) ; } @Test public void testColumnVariance ( ) { INDArray twoByThree = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray columnVar = twoByThree . var ( <int> ) ; INDArray assertion = Nd4j . create ( new float [ ] { <float> , <float> } ) ; assertEquals ( assertion , columnVar ) ; } @Test public void testCumSum ( ) { INDArray n = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray cumSumAnswer = Nd4j . create ( new float [ ] { <int> , <int> , <int> , <int> } , new int [ ] { <int> , <int> } ) ; INDArray cumSumTest = n . cumsum ( <int> ) ; assertEquals ( getFailureMessage ( ) , cumSumAnswer , cumSumTest ) ; INDArray n2 = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray axis0assertion = Nd4j . create ( new double [ ] { <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> , <float> } , n2 . shape ( ) ) ; INDArray axis0Test = n2 . cumsum ( <int> ) ; assertEquals ( getFailureMessage ( ) , axis0assertion , axis0Test ) ; } @Test public void testSumRow ( ) { INDArray rowVector10 = Nd4j . ones ( <int> ) ; INDArray sum1 = rowVector10 . sum ( <int> ) ; assertArrayEquals ( sum1 . shape ( ) , new int [ ] { <int> , <int> } ) ; assertTrue ( sum1 . getDouble ( <int> ) = = <int> ) ; } @Test public void testSumColumn ( ) { INDArray colVector10 = Nd4j . ones ( <int> , <int> ) ; INDArray sum0 = colVector10 . sum ( <int> ) ; assertArrayEquals ( sum0 . shape ( ) , new int [ ] { <int> , <int> } ) ; assertTrue ( sum0 . getDouble ( <int> ) = = <int> ) ; } @Test public void testSum2d ( ) { INDArray arr = Nd4j . ones ( <int> , <int> ) ; INDArray sum0 = arr . sum ( <int> ) ; assertArrayEquals ( sum0 . shape ( ) , new int [ ] { <int> , <int> } ) ; INDArray sum1 = arr . sum ( <int> ) ; assertArrayEquals ( sum1 . shape ( ) , new int [ ] { <int> , <int> } ) ; } @Test public void testSum2dv2 ( ) { INDArray arr = Nd4j . ones ( <int> , <int> ) ; INDArray sumBoth = arr . sum ( <int> , <int> ) ; assertArrayEquals ( sumBoth . shape ( ) , new int [ ] { <int> , <int> } ) ; assertTrue ( sumBoth . getDouble ( <int> ) = = <int> ) ; } @Test public void testPermuteReshape ( ) { INDArray arrTest = Nd4j . arange ( <int> ) . reshape ( <int> , <int> , <int> ) ; INDArray permute = arrTest . permute ( <int> , <int> , <int> ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> } , permute . shape ( ) ) ; assertArrayEquals ( new int [ ] { <int> , <int> , <int> } , permute . stride ( ) ) ; INDArray reshapedPermute = permute . reshape ( - <int> , <int> ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , reshapedPermute . shape ( ) ) ; assertArrayEquals ( new int [ ] { <int> , <int> } , reshapedPermute . stride ( ) ) ; } @Test public void testRavel ( ) { INDArray linspace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> ) ; INDArray asseriton = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray raveled = linspace . ravel ( ) ; assertEquals ( asseriton , raveled ) ; INDArray tensorLinSpace = Nd4j . linspace ( <int> , <int> , <int> ) . reshape ( <int> , <int> , <int> , <int> ) ; INDArray linspaced = Nd4j . linspace ( <int> , <int> , <int> ) ; INDArray tensorLinspaceRaveled = tensorLinSpace . ravel ( ) ; assertEquals ( linspaced , tensorLinspaceRaveled ) ; } @Override public char ordering ( ) { return <str> ; } } 
