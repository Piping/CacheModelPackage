package org . elasticsearch . index . fielddata ; import org . apache . lucene . index . DirectoryReader ; import org . apache . lucene . index . LeafReaderContext ; import org . apache . lucene . search . DocIdSet ; import org . apache . lucene . search . DocIdSetIterator ; import org . apache . lucene . search . FieldComparatorSource ; import org . apache . lucene . search . SortField ; import org . apache . lucene . search . Weight ; import org . apache . lucene . search . join . BitSetProducer ; import org . apache . lucene . util . BitDocIdSet ; import org . apache . lucene . util . BitSet ; import org . apache . lucene . util . BytesRef ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . index . IndexComponent ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . index . fielddata . IndexFieldData . XFieldComparatorSource . Nested ; import org . elasticsearch . index . mapper . MappedFieldType ; import org . elasticsearch . index . mapper . MapperService ; import org . elasticsearch . indices . breaker . CircuitBreakerService ; import org . elasticsearch . search . MultiValueMode ; import java . io . IOException ; public interface IndexFieldData < FD extends AtomicFieldData > extends IndexComponent { public static class CommonSettings { public static final String SETTING_MEMORY_STORAGE_HINT = <str> ; public enum MemoryStorageFormat { ORDINALS , PACKED , PAGED ; public static MemoryStorageFormat fromString ( String string ) { for ( MemoryStorageFormat e : MemoryStorageFormat . values ( ) ) { if ( e . name ( ) . equalsIgnoreCase ( string ) ) { return e ; } } return null ; } } public static MemoryStorageFormat getMemoryStorageHint ( FieldDataType fieldDataType ) { String s = fieldDataType . getSettings ( ) . get ( <str> ) ; if ( s ! = null ) { return <str> . equals ( s ) ? MemoryStorageFormat . ORDINALS : null ; } return MemoryStorageFormat . fromString ( fieldDataType . getSettings ( ) . get ( SETTING_MEMORY_STORAGE_HINT ) ) ; } } MappedFieldType . Names getFieldNames ( ) ; FieldDataType getFieldDataType ( ) ; FD load ( LeafReaderContext context ) ; FD loadDirect ( LeafReaderContext context ) throws Exception ; XFieldComparatorSource comparatorSource ( @Nullable Object missingValue , MultiValueMode sortMode , Nested nested ) ; void clear ( ) ; abstract class XFieldComparatorSource extends FieldComparatorSource { public static class Nested { private final BitSetProducer rootFilter ; private final Weight innerFilter ; public Nested ( BitSetProducer rootFilter , Weight innerFilter ) { this . rootFilter = rootFilter ; this . innerFilter = innerFilter ; } public BitSet rootDocs ( LeafReaderContext ctx ) throws IOException { return rootFilter . getBitSet ( ctx ) ; } public DocIdSetIterator innerDocs ( LeafReaderContext ctx ) throws IOException { return innerFilter . scorer ( ctx ) ; } } protected final boolean sortMissingFirst ( Object missingValue ) { return <str> . equals ( missingValue ) ; } protected final boolean sortMissingLast ( Object missingValue ) { return missingValue = = null | | <str> . equals ( missingValue ) ; } protected final Object missingObject ( Object missingValue , boolean reversed ) { if ( sortMissingFirst ( missingValue ) | | sortMissingLast ( missingValue ) ) { final boolean min = sortMissingFirst ( missingValue ) ^ reversed ; switch ( reducedType ( ) ) { case INT : return min ? Integer . MIN_VALUE : Integer . MAX_VALUE ; case LONG : return min ? Long . MIN_VALUE : Long . MAX_VALUE ; case FLOAT : return min ? Float . NEGATIVE_INFINITY : Float . POSITIVE_INFINITY ; case DOUBLE : return min ? Double . NEGATIVE_INFINITY : Double . POSITIVE_INFINITY ; case STRING : case STRING_VAL : return null ; default : throw new UnsupportedOperationException ( <str> + reducedType ( ) ) ; } } else { switch ( reducedType ( ) ) { case INT : if ( missingValue instanceof Number ) { return ( ( Number ) missingValue ) . intValue ( ) ; } else { return Integer . parseInt ( missingValue . toString ( ) ) ; } case LONG : if ( missingValue instanceof Number ) { return ( ( Number ) missingValue ) . longValue ( ) ; } else { return Long . parseLong ( missingValue . toString ( ) ) ; } case FLOAT : if ( missingValue instanceof Number ) { return ( ( Number ) missingValue ) . floatValue ( ) ; } else { return Float . parseFloat ( missingValue . toString ( ) ) ; } case DOUBLE : if ( missingValue instanceof Number ) { return ( ( Number ) missingValue ) . doubleValue ( ) ; } else { return Double . parseDouble ( missingValue . toString ( ) ) ; } case STRING : case STRING_VAL : if ( missingValue instanceof BytesRef ) { return ( BytesRef ) missingValue ; } else if ( missingValue instanceof byte [ ] ) { return new BytesRef ( ( byte [ ] ) missingValue ) ; } else { return new BytesRef ( missingValue . toString ( ) ) ; } default : throw new UnsupportedOperationException ( <str> + reducedType ( ) ) ; } } } public abstract SortField . Type reducedType ( ) ; public Object missingValue ( boolean reversed ) { return null ; } } interface Builder { IndexFieldData < ? > build ( IndexSettings indexSettings , MappedFieldType fieldType , IndexFieldDataCache cache , CircuitBreakerService breakerService , MapperService mapperService ) ; } interface Global < FD extends AtomicFieldData > extends IndexFieldData < FD > { IndexFieldData < FD > loadGlobal ( DirectoryReader indexReader ) ; IndexFieldData < FD > localGlobalDirect ( DirectoryReader indexReader ) throws Exception ; } } 
