package org . eclipse . debug . tests . viewer . model ; import junit . framework . TestCase ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . core . runtime . Platform ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDeltaVisitor ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . PresentationContext ; import org . eclipse . debug . internal . ui . viewers . model . provisional . TreeModelViewer ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . swt . SWT ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; public class JFaceViewerTopIndexTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; TreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public JFaceViewerTopIndexTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setSize ( <int> , <int> ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , false , false ) ; fShell . open ( ) ; } @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } @Override protected void runTest ( ) throws Throwable { try { super . runTest ( ) ; } catch ( Throwable t ) { throw new ExecutionException ( <str> + t . getMessage ( ) + <str> + fListener . toString ( ) , t ) ; } } protected IInternalTreeModelViewer getCTargetViewer ( ) { return fViewer ; } protected TreeModelViewer createViewer ( Display display , Shell shell ) { return new TreeModelViewer ( fShell , SWT . VIRTUAL | SWT . MULTI , new PresentationContext ( <str> ) ) ; } public void testRestoreTopIndex ( ) throws InterruptedException { TreeModelViewerAutopopulateAgent autopopulateAgent = new TreeModelViewerAutopopulateAgent ( fViewer ) ; TestModel model = new TestModel ( ) ; TestElement [ ] elements = new TestElement [ <int> ] ; for ( int i = <int> ; i < elements . length ; i + + ) { String text = Integer . toString ( i + <int> ) ; elements [ i ] = new TestElement ( model , text , new TestElement [ <int> ] ) ; } model . setRoot ( new TestElement ( model , <str> , elements ) ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; autopopulateAgent . dispose ( ) ; int indexRevealElem = <int> ; getCTargetViewer ( ) . reveal ( TreePath . EMPTY , indexRevealElem ) ; while ( fDisplay . readAndDispatch ( ) ) { } final TreePath originalTopPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , originalTopPath ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( true , false ) ; fListener . addStateUpdates ( getCTargetViewer ( ) , originalState , IModelDelta . EXPAND | IModelDelta . SELECT | IModelDelta . REVEAL ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE | STATE_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } while ( fDisplay . readAndDispatch ( ) ) { } final TreePath topPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , topPath ) ; TreePathWrapper . assertEqual ( originalTopPath , topPath ) ; } public void testRestoreTopAndExpand ( ) throws InterruptedException { TreeModelViewerAutopopulateAgent autopopulateAgent = new TreeModelViewerAutopopulateAgent ( fViewer ) ; TestModel model = new TestModel ( ) ; TestElement [ ] elements = new TestElement [ <int> ] ; for ( int i = <int> ; i < elements . length ; i + + ) { String text = Integer . toString ( i + <int> ) ; if ( i = = <int> ) { elements [ i ] = new TestElement ( model , text , new TestElement [ ] { new TestElement ( model , text + <str> , new TestElement [ <int> ] ) , new TestElement ( model , text + <str> , new TestElement [ <int> ] ) } ) ; } else { elements [ i ] = new TestElement ( model , text , new TestElement [ <int> ] ) ; } } model . setRoot ( new TestElement ( model , <str> , elements ) ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( false ) ; int indexFirstElem = <int> ; TestElement firstElem = elements [ indexFirstElem ] ; ModelDelta rootDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; ModelDelta delta = model . getBaseDelta ( rootDelta ) ; TreePath firstElemPath = model . findElement ( firstElem . getLabel ( ) ) ; fListener . addUpdates ( firstElemPath , firstElem , <int> , CHILD_COUNT_UPDATES | CHILDREN_UPDATES ) ; delta . addNode ( firstElem , indexFirstElem , IModelDelta . EXPAND , firstElem . getChildren ( ) . length ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } assertTrue ( getCTargetViewer ( ) . getExpandedState ( firstElemPath ) = = true ) ; autopopulateAgent . dispose ( ) ; getCTargetViewer ( ) . reveal ( TreePath . EMPTY , <int> ) ; while ( fDisplay . readAndDispatch ( ) ) { } final TreePath originalTopPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , originalTopPath ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( true , false ) ; fListener . addStateUpdates ( getCTargetViewer ( ) , originalState , IModelDelta . EXPAND | IModelDelta . SELECT | IModelDelta . REVEAL ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } while ( fDisplay . readAndDispatch ( ) ) { } final TreePath topPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , topPath ) ; TreePathWrapper . assertEqual ( originalTopPath , topPath ) ; } public void testRestoreTopTriggersExpand ( ) throws InterruptedException { TreeModelViewerAutopopulateAgent autopopulateAgent = new TreeModelViewerAutopopulateAgent ( fViewer ) ; TestModel model = new TestModel ( ) ; TestElement [ ] elements = new TestElement [ <int> ] ; for ( int i = <int> ; i < elements . length ; i + + ) { String text = Integer . toString ( i + <int> ) ; if ( i = = elements . length - <int> ) { elements [ i ] = new TestElement ( model , text , new TestElement [ ] { new TestElement ( model , text + <str> , new TestElement [ <int> ] ) , new TestElement ( model , text + <str> , new TestElement [ <int> ] ) } ) ; } else { elements [ i ] = new TestElement ( model , text , new TestElement [ <int> ] ) ; } } fViewer . setAutoExpandLevel ( - <int> ) ; model . setRoot ( new TestElement ( model , <str> , elements ) ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; int indexLastElem = elements . length - <int> ; TestElement lastElem = elements [ indexLastElem ] ; TreePath lastElemePath = model . findElement ( lastElem . getLabel ( ) ) ; assertTrue ( getCTargetViewer ( ) . getExpandedState ( lastElemePath ) = = true ) ; fViewer . setAutoExpandLevel ( <int> ) ; autopopulateAgent . dispose ( ) ; getCTargetViewer ( ) . reveal ( TreePath . EMPTY , indexLastElem - <int> ) ; while ( fDisplay . readAndDispatch ( ) ) { } final TreePath originalTopPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , originalTopPath ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( true , false ) ; fListener . addStateUpdates ( getCTargetViewer ( ) , originalState , IModelDelta . EXPAND | IModelDelta . SELECT | IModelDelta . REVEAL ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE | STATE_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } while ( fDisplay . readAndDispatch ( ) ) { } final TreePath topPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , topPath ) ; TreePathWrapper . assertEqual ( originalTopPath , topPath ) ; } public void testRestoreRevealAfterRevealCancel ( ) throws InterruptedException { TreeModelViewerAutopopulateAgent autopopulateAgent = new TreeModelViewerAutopopulateAgent ( fViewer ) ; TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; autopopulateAgent . dispose ( ) ; getCTargetViewer ( ) . reveal ( TreePath . EMPTY , <int> ) ; while ( fDisplay . readAndDispatch ( ) ) { } fListener . reset ( ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE ) ) { Thread . sleep ( <int> ) ; } fListener . reset ( ) ; TreePath elementPath = model . findElement ( <str> ) ; fListener . addUpdates ( fViewer , elementPath , model . getElement ( elementPath ) , <int> , STATE_UPDATES ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | STATE_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ModelDelta revealDelta = model . makeElementDelta ( model . findElement ( <str> ) , IModelDelta . REVEAL ) ; fListener . reset ( ) ; model . postDelta ( revealDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE ) ) { Thread . sleep ( <int> ) ; } autopopulateAgent = new TreeModelViewerAutopopulateAgent ( fViewer ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( STATE_RESTORE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } autopopulateAgent . dispose ( ) ; } public void testRestoreRevealAfterRevealCancel2 ( ) throws InterruptedException { if ( Platform . getOS ( ) . equals ( Platform . OS_MACOSX ) ) { return ; } TreeModelViewerAutopopulateAgent autopopulateAgent = new TreeModelViewerAutopopulateAgent ( fViewer ) ; TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fViewer . setAutoExpandLevel ( <int> ) ; autopopulateAgent . dispose ( ) ; getCTargetViewer ( ) . reveal ( TreePath . EMPTY , <int> ) ; while ( fDisplay . readAndDispatch ( ) ) { } fListener . reset ( ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE ) ) { Thread . sleep ( <int> ) ; } fListener . reset ( ) ; TreePath elementPath = model . findElement ( <str> ) ; fListener . addUpdates ( fViewer , elementPath , model . getElement ( elementPath ) , <int> , STATE_UPDATES | CHILDREN_UPDATES | LABEL_UPDATES ) ; elementPath = model . findElement ( <str> ) ; fListener . addUpdates ( fViewer , elementPath , model . getElement ( elementPath ) , <int> , STATE_UPDATES ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( STATE_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TreePath pathToBeRevealed = model . findElement ( <str> ) ; ModelDelta revealDelta = model . makeElementDelta ( pathToBeRevealed , IModelDelta . REVEAL ) ; revealDelta . accept ( new IModelDeltaVisitor ( ) { @Override public boolean visit ( IModelDelta delta , int depth ) { ( ( ModelDelta ) delta ) . setFlags ( delta . getFlags ( ) | IModelDelta . EXPAND ) ; return true ; } } ) ; model . postDelta ( revealDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CHILDREN_UPDATES | LABEL_UPDATES ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TreePath topPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , topPath ) ; TreePathWrapper . assertEqual ( pathToBeRevealed , topPath ) ; } public void testRestoreDeepTreeAndReveal ( ) throws InterruptedException { TreeModelViewerAutopopulateAgent autopopulateAgent = new TreeModelViewerAutopopulateAgent ( fViewer ) ; TestModel model = TestModel . simpleDeepMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; autopopulateAgent . dispose ( ) ; getCTargetViewer ( ) . reveal ( model . findElement ( <str> ) , <int> ) ; while ( fDisplay . readAndDispatch ( ) ) { } final TreePath originalTopPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , originalTopPath ) ; ModelDelta originalState = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE ) ; fViewer . saveElementState ( TreePath . EMPTY , originalState , IModelDelta . EXPAND | IModelDelta . SELECT ) ; fListener . reset ( true , false ) ; fListener . addStateUpdates ( getCTargetViewer ( ) , originalState , IModelDelta . EXPAND | IModelDelta . SELECT | IModelDelta . REVEAL ) ; fViewer . setInput ( null ) ; while ( ! fListener . isFinished ( STATE_SAVE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( false , false ) ; fListener . addUpdates ( getCTargetViewer ( ) , originalTopPath , ( TestElement ) originalTopPath . getLastSegment ( ) , <int> , STATE_UPDATES ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( STATE_UPDATES | CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } while ( fDisplay . readAndDispatch ( ) ) { } final TreePath topPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , topPath ) ; TreePathWrapper . assertEqual ( originalTopPath , topPath ) ; } public void testRevealWithContentChanges ( ) throws InterruptedException { @SuppressWarnings ( <str> ) TreeModelViewerAutopopulateAgent autopopulateAgent = new TreeModelViewerAutopopulateAgent ( fViewer ) ; TestModel model = TestModel . simpleDeepMultiLevel ( ) ; fViewer . setAutoExpandLevel ( <int> ) ; fListener . reset ( false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; getCTargetViewer ( ) . reveal ( TreePath . EMPTY , <int> ) ; while ( fDisplay . readAndDispatch ( ) ) { } TreePath element2Path = model . findElement ( <str> ) ; TreePath pathToBeRevealed = element2Path ; TreePath topPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , topPath ) ; TreePathWrapper . assertEqual ( pathToBeRevealed , topPath ) ; pathToBeRevealed = model . findElement ( <str> ) ; ModelDelta revealDelta = model . makeElementDelta ( pathToBeRevealed , IModelDelta . REVEAL ) ; ModelDelta element2Delta = model . makeElementDelta ( element2Path , IModelDelta . CONTENT ) ; element2Delta = ( ModelDelta ) element2Delta . getChildDeltas ( ) [ <int> ] ; revealDelta . addNode ( element2Delta . getElement ( ) , element2Delta . getIndex ( ) , element2Delta . getFlags ( ) , element2Delta . getChildCount ( ) ) ; model . removeElementChild ( element2Path , <int> ) ; model . removeElementChild ( element2Path , <int> ) ; fListener . reset ( ) ; model . setQeueueingUpdate ( true ) ; model . postDelta ( revealDelta ) ; while ( ! fListener . isFinished ( CHILD_COUNT_UPDATES_STARTED ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . setQeueueingUpdate ( false ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } topPath = getCTargetViewer ( ) . getTopElementPath ( ) ; assertNotNull ( <str> , topPath ) ; TreePathWrapper . assertEqual ( pathToBeRevealed , topPath ) ; } } 
