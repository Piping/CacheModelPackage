package io . netty . handler . codec ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . channel . embedded . EmbeddedChannel ; import io . netty . util . ReferenceCountUtil ; import org . junit . Assert ; import org . junit . Test ; import java . util . List ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . LinkedBlockingDeque ; public class ByteToMessageDecoderTest { @Test public void testRemoveItself ( ) { EmbeddedChannel channel = new EmbeddedChannel ( new ByteToMessageDecoder ( ) { private boolean removed ; @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { Assert . assertFalse ( removed ) ; in . readByte ( ) ; ctx . pipeline ( ) . remove ( this ) ; removed = true ; } } ) ; ByteBuf buf = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> } ) ; channel . writeInbound ( buf . copy ( ) ) ; ByteBuf b = channel . readInbound ( ) ; Assert . assertEquals ( b , buf . skipBytes ( <int> ) ) ; b . release ( ) ; buf . release ( ) ; } @Test public void testRemoveItselfWriteBuffer ( ) { final ByteBuf buf = Unpooled . buffer ( ) . writeBytes ( new byte [ ] { <str> , <str> , <str> } ) ; EmbeddedChannel channel = new EmbeddedChannel ( new ByteToMessageDecoder ( ) { private boolean removed ; @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { Assert . assertFalse ( removed ) ; in . readByte ( ) ; ctx . pipeline ( ) . remove ( this ) ; buf . writeByte ( <str> ) ; removed = true ; } } ) ; channel . writeInbound ( buf . copy ( ) ) ; ByteBuf b = channel . readInbound ( ) ; Assert . assertEquals ( b , Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> } ) ) ; buf . release ( ) ; b . release ( ) ; } @Test public void testInternalBufferClearReadAll ( ) { final ByteBuf buf = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( ) . writeBytes ( new byte [ ] { <str> } ) ) ; EmbeddedChannel channel = new EmbeddedChannel ( new ByteToMessageDecoder ( ) { @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { ByteBuf byteBuf = internalBuffer ( ) ; Assert . assertEquals ( <int> , byteBuf . refCnt ( ) ) ; in . readByte ( ) ; ctx . pipeline ( ) . remove ( this ) ; Assert . assertEquals ( <int> , byteBuf . refCnt ( ) ) ; } } ) ; Assert . assertFalse ( channel . writeInbound ( buf ) ) ; Assert . assertFalse ( channel . finish ( ) ) ; } @Test public void testInternalBufferClearReadPartly ( ) { final ByteBuf buf = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( ) . writeBytes ( new byte [ ] { <str> , <str> } ) ) ; EmbeddedChannel channel = new EmbeddedChannel ( new ByteToMessageDecoder ( ) { @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { ByteBuf byteBuf = internalBuffer ( ) ; Assert . assertEquals ( <int> , byteBuf . refCnt ( ) ) ; in . readByte ( ) ; ctx . pipeline ( ) . remove ( this ) ; Assert . assertEquals ( <int> , byteBuf . refCnt ( ) ) ; } } ) ; Assert . assertTrue ( channel . writeInbound ( buf ) ) ; Assert . assertTrue ( channel . finish ( ) ) ; Assert . assertEquals ( channel . readInbound ( ) , Unpooled . wrappedBuffer ( new byte [ ] { <str> } ) ) ; Assert . assertNull ( channel . readInbound ( ) ) ; } @Test public void testFireChannelReadCompleteOnInactive ( ) throws InterruptedException { final BlockingQueue < Integer > queue = new LinkedBlockingDeque < Integer > ( ) ; final ByteBuf buf = ReferenceCountUtil . releaseLater ( Unpooled . buffer ( ) . writeBytes ( new byte [ ] { <str> , <str> } ) ) ; EmbeddedChannel channel = new EmbeddedChannel ( new ByteToMessageDecoder ( ) { @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { in . skipBytes ( in . readableBytes ( ) ) ; if ( ! ctx . channel ( ) . isActive ( ) ) { out . add ( <str> ) ; } } } , new ChannelInboundHandlerAdapter ( ) { @Override public void channelInactive ( ChannelHandlerContext ctx ) throws Exception { queue . add ( <int> ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { queue . add ( <int> ) ; } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { if ( ! ctx . channel ( ) . isActive ( ) ) { queue . add ( <int> ) ; } } } ) ; Assert . assertFalse ( channel . writeInbound ( buf ) ) ; channel . finish ( ) ; Assert . assertEquals ( <int> , ( int ) queue . take ( ) ) ; Assert . assertEquals ( <int> , ( int ) queue . take ( ) ) ; Assert . assertEquals ( <int> , ( int ) queue . take ( ) ) ; Assert . assertTrue ( queue . isEmpty ( ) ) ; } } 
