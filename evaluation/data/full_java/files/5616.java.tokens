package org . elasticsearch . cluster . routing . allocation . allocator ; import org . elasticsearch . cluster . routing . RoutingNode ; import org . elasticsearch . cluster . routing . ShardRouting ; import org . elasticsearch . cluster . routing . allocation . FailedRerouteAllocation ; import org . elasticsearch . cluster . routing . allocation . RoutingAllocation ; import org . elasticsearch . cluster . routing . allocation . StartedRerouteAllocation ; import org . elasticsearch . common . component . AbstractComponent ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . gateway . GatewayAllocator ; public class ShardsAllocators extends AbstractComponent implements ShardsAllocator { private final GatewayAllocator gatewayAllocator ; private final ShardsAllocator allocator ; public ShardsAllocators ( GatewayAllocator allocator ) { this ( Settings . Builder . EMPTY_SETTINGS , allocator ) ; } public ShardsAllocators ( Settings settings , GatewayAllocator allocator ) { this ( settings , allocator , new BalancedShardsAllocator ( settings ) ) ; } @Inject public ShardsAllocators ( Settings settings , GatewayAllocator gatewayAllocator , ShardsAllocator allocator ) { super ( settings ) ; this . gatewayAllocator = gatewayAllocator ; this . allocator = allocator ; } @Override public void applyStartedShards ( StartedRerouteAllocation allocation ) { gatewayAllocator . applyStartedShards ( allocation ) ; allocator . applyStartedShards ( allocation ) ; } @Override public void applyFailedShards ( FailedRerouteAllocation allocation ) { gatewayAllocator . applyFailedShards ( allocation ) ; allocator . applyFailedShards ( allocation ) ; } @Override public boolean allocateUnassigned ( RoutingAllocation allocation ) { boolean changed = false ; changed | = gatewayAllocator . allocateUnassigned ( allocation ) ; changed | = allocator . allocateUnassigned ( allocation ) ; return changed ; } protected long nanoTime ( ) { return System . nanoTime ( ) ; } @Override public boolean rebalance ( RoutingAllocation allocation ) { if ( allocation . hasPendingAsyncFetch ( ) = = false ) { return allocator . rebalance ( allocation ) ; } else { logger . debug ( <str> ) ; return false ; } } @Override public boolean move ( ShardRouting shardRouting , RoutingNode node , RoutingAllocation allocation ) { return allocator . move ( shardRouting , node , allocation ) ; } } 
