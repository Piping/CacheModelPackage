package org . jbox2d . dynamics . joints ; import org . jbox2d . common . MathUtils ; import org . jbox2d . common . Rot ; import org . jbox2d . common . Settings ; import org . jbox2d . common . Vec2 ; import org . jbox2d . dynamics . SolverData ; import org . jbox2d . pooling . IWorldPool ; public class PulleyJoint extends Joint { public static final float MIN_PULLEY_LENGTH = <float> ; private final Vec2 m_groundAnchorA = new Vec2 ( ) ; private final Vec2 m_groundAnchorB = new Vec2 ( ) ; private float m_lengthA ; private float m_lengthB ; private final Vec2 m_localAnchorA = new Vec2 ( ) ; private final Vec2 m_localAnchorB = new Vec2 ( ) ; private float m_constant ; private float m_ratio ; private float m_impulse ; private int m_indexA ; private int m_indexB ; private final Vec2 m_uA = new Vec2 ( ) ; private final Vec2 m_uB = new Vec2 ( ) ; private final Vec2 m_rA = new Vec2 ( ) ; private final Vec2 m_rB = new Vec2 ( ) ; private final Vec2 m_localCenterA = new Vec2 ( ) ; private final Vec2 m_localCenterB = new Vec2 ( ) ; private float m_invMassA ; private float m_invMassB ; private float m_invIA ; private float m_invIB ; private float m_mass ; protected PulleyJoint ( IWorldPool argWorldPool , PulleyJointDef def ) { super ( argWorldPool , def ) ; m_groundAnchorA . set ( def . groundAnchorA ) ; m_groundAnchorB . set ( def . groundAnchorB ) ; m_localAnchorA . set ( def . localAnchorA ) ; m_localAnchorB . set ( def . localAnchorB ) ; assert ( def . ratio ! = <float> ) ; m_ratio = def . ratio ; m_lengthA = def . lengthA ; m_lengthB = def . lengthB ; m_constant = def . lengthA + m_ratio * def . lengthB ; m_impulse = <float> ; } public float getLengthA ( ) { return m_lengthA ; } public float getLengthB ( ) { return m_lengthB ; } public float getCurrentLengthA ( ) { final Vec2 p = pool . popVec2 ( ) ; m_bodyA . getWorldPointToOut ( m_localAnchorA , p ) ; p . subLocal ( m_groundAnchorA ) ; float length = p . length ( ) ; pool . pushVec2 ( <int> ) ; return length ; } public float getCurrentLengthB ( ) { final Vec2 p = pool . popVec2 ( ) ; m_bodyB . getWorldPointToOut ( m_localAnchorB , p ) ; p . subLocal ( m_groundAnchorB ) ; float length = p . length ( ) ; pool . pushVec2 ( <int> ) ; return length ; } public Vec2 getLocalAnchorA ( ) { return m_localAnchorA ; } public Vec2 getLocalAnchorB ( ) { return m_localAnchorB ; } @Override public void getAnchorA ( Vec2 argOut ) { m_bodyA . getWorldPointToOut ( m_localAnchorA , argOut ) ; } @Override public void getAnchorB ( Vec2 argOut ) { m_bodyB . getWorldPointToOut ( m_localAnchorB , argOut ) ; } @Override public void getReactionForce ( float inv_dt , Vec2 argOut ) { argOut . set ( m_uB ) . mulLocal ( m_impulse ) . mulLocal ( inv_dt ) ; } @Override public float getReactionTorque ( float inv_dt ) { return <float> ; } public Vec2 getGroundAnchorA ( ) { return m_groundAnchorA ; } public Vec2 getGroundAnchorB ( ) { return m_groundAnchorB ; } public float getLength1 ( ) { final Vec2 p = pool . popVec2 ( ) ; m_bodyA . getWorldPointToOut ( m_localAnchorA , p ) ; p . subLocal ( m_groundAnchorA ) ; float len = p . length ( ) ; pool . pushVec2 ( <int> ) ; return len ; } public float getLength2 ( ) { final Vec2 p = pool . popVec2 ( ) ; m_bodyB . getWorldPointToOut ( m_localAnchorB , p ) ; p . subLocal ( m_groundAnchorB ) ; float len = p . length ( ) ; pool . pushVec2 ( <int> ) ; return len ; } public float getRatio ( ) { return m_ratio ; } @Override public void initVelocityConstraints ( final SolverData data ) { m_indexA = m_bodyA . m_islandIndex ; m_indexB = m_bodyB . m_islandIndex ; m_localCenterA . set ( m_bodyA . m_sweep . localCenter ) ; m_localCenterB . set ( m_bodyB . m_sweep . localCenter ) ; m_invMassA = m_bodyA . m_invMass ; m_invMassB = m_bodyB . m_invMass ; m_invIA = m_bodyA . m_invI ; m_invIB = m_bodyB . m_invI ; Vec2 cA = data . positions [ m_indexA ] . c ; float aA = data . positions [ m_indexA ] . a ; Vec2 vA = data . velocities [ m_indexA ] . v ; float wA = data . velocities [ m_indexA ] . w ; Vec2 cB = data . positions [ m_indexB ] . c ; float aB = data . positions [ m_indexB ] . a ; Vec2 vB = data . velocities [ m_indexB ] . v ; float wB = data . velocities [ m_indexB ] . w ; final Rot qA = pool . popRot ( ) ; final Rot qB = pool . popRot ( ) ; final Vec2 temp = pool . popVec2 ( ) ; qA . set ( aA ) ; qB . set ( aB ) ; Rot . mulToOutUnsafe ( qA , temp . set ( m_localAnchorA ) . subLocal ( m_localCenterA ) , m_rA ) ; Rot . mulToOutUnsafe ( qB , temp . set ( m_localAnchorB ) . subLocal ( m_localCenterB ) , m_rB ) ; m_uA . set ( cA ) . addLocal ( m_rA ) . subLocal ( m_groundAnchorA ) ; m_uB . set ( cB ) . addLocal ( m_rB ) . subLocal ( m_groundAnchorB ) ; float lengthA = m_uA . length ( ) ; float lengthB = m_uB . length ( ) ; if ( lengthA > <int> f * Settings . linearSlop ) { m_uA . mulLocal ( <float> / lengthA ) ; } else { m_uA . setZero ( ) ; } if ( lengthB > <int> f * Settings . linearSlop ) { m_uB . mulLocal ( <float> / lengthB ) ; } else { m_uB . setZero ( ) ; } float ruA = Vec2 . cross ( m_rA , m_uA ) ; float ruB = Vec2 . cross ( m_rB , m_uB ) ; float mA = m_invMassA + m_invIA * ruA * ruA ; float mB = m_invMassB + m_invIB * ruB * ruB ; m_mass = mA + m_ratio * m_ratio * mB ; if ( m_mass > <float> ) { m_mass = <float> / m_mass ; } if ( data . step . warmStarting ) { m_impulse * = data . step . dtRatio ; final Vec2 PA = pool . popVec2 ( ) ; final Vec2 PB = pool . popVec2 ( ) ; PA . set ( m_uA ) . mulLocal ( - m_impulse ) ; PB . set ( m_uB ) . mulLocal ( - m_ratio * m_impulse ) ; vA . x + = m_invMassA * PA . x ; vA . y + = m_invMassA * PA . y ; wA + = m_invIA * Vec2 . cross ( m_rA , PA ) ; vB . x + = m_invMassB * PB . x ; vB . y + = m_invMassB * PB . y ; wB + = m_invIB * Vec2 . cross ( m_rB , PB ) ; pool . pushVec2 ( <int> ) ; } else { m_impulse = <float> ; } data . velocities [ m_indexA ] . w = wA ; data . velocities [ m_indexB ] . w = wB ; pool . pushVec2 ( <int> ) ; pool . pushRot ( <int> ) ; } @Override public void solveVelocityConstraints ( final SolverData data ) { Vec2 vA = data . velocities [ m_indexA ] . v ; float wA = data . velocities [ m_indexA ] . w ; Vec2 vB = data . velocities [ m_indexB ] . v ; float wB = data . velocities [ m_indexB ] . w ; final Vec2 vpA = pool . popVec2 ( ) ; final Vec2 vpB = pool . popVec2 ( ) ; final Vec2 PA = pool . popVec2 ( ) ; final Vec2 PB = pool . popVec2 ( ) ; Vec2 . crossToOutUnsafe ( wA , m_rA , vpA ) ; vpA . addLocal ( vA ) ; Vec2 . crossToOutUnsafe ( wB , m_rB , vpB ) ; vpB . addLocal ( vB ) ; float Cdot = - Vec2 . dot ( m_uA , vpA ) - m_ratio * Vec2 . dot ( m_uB , vpB ) ; float impulse = - m_mass * Cdot ; m_impulse + = impulse ; PA . set ( m_uA ) . mulLocal ( - impulse ) ; PB . set ( m_uB ) . mulLocal ( - m_ratio * impulse ) ; vA . x + = m_invMassA * PA . x ; vA . y + = m_invMassA * PA . y ; wA + = m_invIA * Vec2 . cross ( m_rA , PA ) ; vB . x + = m_invMassB * PB . x ; vB . y + = m_invMassB * PB . y ; wB + = m_invIB * Vec2 . cross ( m_rB , PB ) ; data . velocities [ m_indexA ] . w = wA ; data . velocities [ m_indexB ] . w = wB ; pool . pushVec2 ( <int> ) ; } @Override public boolean solvePositionConstraints ( final SolverData data ) { final Rot qA = pool . popRot ( ) ; final Rot qB = pool . popRot ( ) ; final Vec2 rA = pool . popVec2 ( ) ; final Vec2 rB = pool . popVec2 ( ) ; final Vec2 uA = pool . popVec2 ( ) ; final Vec2 uB = pool . popVec2 ( ) ; final Vec2 temp = pool . popVec2 ( ) ; final Vec2 PA = pool . popVec2 ( ) ; final Vec2 PB = pool . popVec2 ( ) ; Vec2 cA = data . positions [ m_indexA ] . c ; float aA = data . positions [ m_indexA ] . a ; Vec2 cB = data . positions [ m_indexB ] . c ; float aB = data . positions [ m_indexB ] . a ; qA . set ( aA ) ; qB . set ( aB ) ; Rot . mulToOutUnsafe ( qA , temp . set ( m_localAnchorA ) . subLocal ( m_localCenterA ) , rA ) ; Rot . mulToOutUnsafe ( qB , temp . set ( m_localAnchorB ) . subLocal ( m_localCenterB ) , rB ) ; uA . set ( cA ) . addLocal ( rA ) . subLocal ( m_groundAnchorA ) ; uB . set ( cB ) . addLocal ( rB ) . subLocal ( m_groundAnchorB ) ; float lengthA = uA . length ( ) ; float lengthB = uB . length ( ) ; if ( lengthA > <float> * Settings . linearSlop ) { uA . mulLocal ( <float> / lengthA ) ; } else { uA . setZero ( ) ; } if ( lengthB > <float> * Settings . linearSlop ) { uB . mulLocal ( <float> / lengthB ) ; } else { uB . setZero ( ) ; } float ruA = Vec2 . cross ( rA , uA ) ; float ruB = Vec2 . cross ( rB , uB ) ; float mA = m_invMassA + m_invIA * ruA * ruA ; float mB = m_invMassB + m_invIB * ruB * ruB ; float mass = mA + m_ratio * m_ratio * mB ; if ( mass > <float> ) { mass = <float> / mass ; } float C = m_constant - lengthA - m_ratio * lengthB ; float linearError = MathUtils . abs ( C ) ; float impulse = - mass * C ; PA . set ( uA ) . mulLocal ( - impulse ) ; PB . set ( uB ) . mulLocal ( - m_ratio * impulse ) ; cA . x + = m_invMassA * PA . x ; cA . y + = m_invMassA * PA . y ; aA + = m_invIA * Vec2 . cross ( rA , PA ) ; cB . x + = m_invMassB * PB . x ; cB . y + = m_invMassB * PB . y ; aB + = m_invIB * Vec2 . cross ( rB , PB ) ; data . positions [ m_indexA ] . a = aA ; data . positions [ m_indexB ] . a = aB ; pool . pushRot ( <int> ) ; pool . pushVec2 ( <int> ) ; return linearError < Settings . linearSlop ; } } 
