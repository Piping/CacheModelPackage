package org . gradle . api . internal . file ; import org . gradle . api . UncheckedIOException ; import org . gradle . internal . exceptions . DiagnosticsVisitor ; import org . gradle . internal . nativeintegration . filesystem . FileSystem ; import org . gradle . internal . typeconversion . * ; import java . io . File ; import java . net . URI ; import java . net . URISyntaxException ; import java . net . URL ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class FileOrUriNotationConverter implements NotationConverter < Object , Object > { private static final Pattern URI_SCHEME = Pattern . compile ( <str> ) ; private static final Pattern ENCODED_URI = Pattern . compile ( <str> ) ; private final FileSystem fileSystem ; public FileOrUriNotationConverter ( FileSystem fileSystem ) { this . fileSystem = fileSystem ; } public static NotationParser < Object , Object > parser ( FileSystem fileSystem ) { return NotationParserBuilder . toType ( Object . class ) . typeDisplayName ( <str> ) . converter ( new FileOrUriNotationConverter ( fileSystem ) ) . toComposite ( ) ; } @Override public void describe ( DiagnosticsVisitor visitor ) { visitor . candidate ( <str> ) . example ( <str> ) ; visitor . candidate ( <str> ) . example ( <str> ) ; visitor . candidate ( <str> ) ; visitor . candidate ( <str> ) ; } public void convert ( Object notation , NotationConvertResult < ? super Object > result ) throws TypeConversionException { if ( notation instanceof File ) { result . converted ( notation ) ; return ; } if ( notation instanceof URL ) { try { notation = ( ( URL ) notation ) . toURI ( ) ; } catch ( URISyntaxException e ) { throw new UncheckedIOException ( e ) ; } } if ( notation instanceof URI ) { URI uri = ( URI ) notation ; if ( uri . getScheme ( ) . equals ( <str> ) ) { result . converted ( new File ( uri . getPath ( ) ) ) ; } else { result . converted ( uri ) ; } return ; } if ( notation instanceof CharSequence ) { String notationString = notation . toString ( ) ; if ( notationString . startsWith ( <str> ) ) { result . converted ( new File ( uriDecode ( notationString . substring ( <int> ) ) ) ) ; return ; } for ( File file : File . listRoots ( ) ) { String rootPath = file . getAbsolutePath ( ) ; String normalisedStr = notationString ; if ( ! fileSystem . isCaseSensitive ( ) ) { rootPath = rootPath . toLowerCase ( ) ; normalisedStr = normalisedStr . toLowerCase ( ) ; } if ( normalisedStr . startsWith ( rootPath ) | | normalisedStr . startsWith ( rootPath . replace ( File . separatorChar , <str> ) ) ) { result . converted ( new File ( notationString ) ) ; return ; } } if ( URI_SCHEME . matcher ( notationString ) . matches ( ) ) { try { result . converted ( new URI ( notationString ) ) ; return ; } catch ( URISyntaxException e ) { throw new UncheckedIOException ( e ) ; } } result . converted ( new File ( notationString ) ) ; } } private String uriDecode ( String path ) { StringBuffer builder = new StringBuffer ( ) ; Matcher matcher = ENCODED_URI . matcher ( path ) ; while ( matcher . find ( ) ) { String val = matcher . group ( <int> ) ; matcher . appendReplacement ( builder , String . valueOf ( ( char ) ( Integer . parseInt ( val , <int> ) ) ) ) ; } matcher . appendTail ( builder ) ; return builder . toString ( ) ; } } 
