package org . elasticsearch . common . network ; import java . util . Arrays ; import java . util . Locale ; import java . util . Objects ; public final class Cidrs { private Cidrs ( ) { } public static long [ ] cidrMaskToMinMax ( String cidr ) { Objects . requireNonNull ( cidr , <str> ) ; String [ ] fields = cidr . split ( <str> ) ; if ( fields . length ! = <int> ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , Arrays . toString ( fields ) , cidr ) ) ; } if ( fields [ <int> ] . contains ( <str> ) ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , Arrays . toString ( fields ) , cidr ) ) ; } byte [ ] addressBytes ; try { addressBytes = InetAddresses . forString ( fields [ <int> ] ) . getAddress ( ) ; } catch ( Throwable t ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , fields [ <int> ] ) , t ) ; } long accumulator = ( ( addressBytes [ <int> ] & <hex> ) < < <int> ) + ( ( addressBytes [ <int> ] & <hex> ) < < <int> ) + ( ( addressBytes [ <int> ] & <hex> ) < < <int> ) + ( ( addressBytes [ <int> ] & <hex> ) ) ; int networkMask ; try { networkMask = Integer . parseInt ( fields [ <int> ] ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , fields [ <int> ] , cidr ) , e ) ; } if ( networkMask < <int> | | networkMask > <int> ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , fields [ <int> ] , cidr ) ) ; } long blockSize = <int> < < ( <int> - networkMask ) ; if ( ( accumulator & ( blockSize - <int> ) ) ! = <int> ) { throw new IllegalArgumentException ( String . format ( Locale . ROOT , <str> , cidr , octetsToCIDR ( longToOctets ( accumulator - ( accumulator & ( blockSize - <int> ) ) ) , networkMask ) ) ) ; } return new long [ ] { accumulator , accumulator + blockSize } ; } static int [ ] longToOctets ( long value ) { assert value > = <int> & & value < = ( <int> < < <int> ) : value ; int [ ] octets = new int [ <int> ] ; octets [ <int> ] = ( int ) ( ( value > > <int> ) & <hex> ) ; octets [ <int> ] = ( int ) ( ( value > > <int> ) & <hex> ) ; octets [ <int> ] = ( int ) ( ( value > > <int> ) & <hex> ) ; octets [ <int> ] = ( int ) ( value & <hex> ) ; return octets ; } static String octetsToString ( int [ ] octets ) { assert octets ! = null ; assert octets . length = = <int> ; return String . format ( Locale . ROOT , <str> , octets [ <int> ] , octets [ <int> ] , octets [ <int> ] , octets [ <int> ] ) ; } static String octetsToCIDR ( int [ ] octets , int networkMask ) { assert octets ! = null ; assert octets . length = = <int> ; return octetsToString ( octets ) + <str> + networkMask ; } } 
