package org . elasticsearch . percolator ; import org . elasticsearch . action . admin . indices . stats . IndicesStatsResponse ; import org . elasticsearch . action . get . GetResponse ; import org . elasticsearch . action . percolate . PercolateResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . index . AlreadyExpiredException ; import org . elasticsearch . index . mapper . MapperParsingException ; import org . elasticsearch . test . ESIntegTestCase ; import org . elasticsearch . test . ESIntegTestCase . ClusterScope ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . util . concurrent . TimeUnit ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . percolator . PercolatorTestUtil . convertFromTextArray ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertMatchCount ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; import static org . hamcrest . Matchers . arrayContaining ; import static org . hamcrest . Matchers . emptyArray ; import static org . hamcrest . Matchers . equalTo ; @ClusterScope ( scope = ESIntegTestCase . Scope . TEST ) public class TTLPercolatorIT extends ESIntegTestCase { private static final long PURGE_INTERVAL = <int> ; @Override protected void beforeIndexDeletion ( ) { } @Override protected Settings nodeSettings ( int nodeOrdinal ) { return settingsBuilder ( ) . put ( super . nodeSettings ( nodeOrdinal ) ) . put ( <str> , PURGE_INTERVAL , TimeUnit . MILLISECONDS ) . build ( ) ; } public void testPercolatingWithTimeToLive ( ) throws Exception { final Client client = client ( ) ; ensureGreen ( ) ; String percolatorMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( PercolatorService . TYPE_NAME ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; String typeMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; client . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . addMapping ( PercolatorService . TYPE_NAME , percolatorMapping ) . addMapping ( <str> , typeMapping ) . execute ( ) . actionGet ( ) ; ensureGreen ( ) ; final NumShards test = getNumShards ( <str> ) ; long ttl = <int> ; long now = System . currentTimeMillis ( ) ; client . prepareIndex ( <str> , PercolatorService . TYPE_NAME , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ) . setRefresh ( true ) . setTTL ( ttl ) . execute ( ) . actionGet ( ) ; IndicesStatsResponse response = client . admin ( ) . indices ( ) . prepareStats ( <str> ) . clear ( ) . setIndexing ( true ) . execute ( ) . actionGet ( ) ; assertThat ( response . getIndices ( ) . get ( <str> ) . getTotal ( ) . getIndexing ( ) . getTotal ( ) . getIndexCount ( ) , equalTo ( ( long ) test . dataCopies ) ) ; PercolateResponse percolateResponse = client . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; assertNoFailures ( percolateResponse ) ; if ( percolateResponse . getMatches ( ) . length = = <int> ) { GetResponse getResponse = client . prepareGet ( <str> , PercolatorService . TYPE_NAME , <str> ) . execute ( ) . actionGet ( ) ; assertThat ( getResponse . isExists ( ) , equalTo ( false ) ) ; response = client . admin ( ) . indices ( ) . prepareStats ( <str> ) . clear ( ) . setIndexing ( true ) . execute ( ) . actionGet ( ) ; long currentDeleteCount = response . getIndices ( ) . get ( <str> ) . getTotal ( ) . getIndexing ( ) . getTotal ( ) . getDeleteCount ( ) ; assertThat ( currentDeleteCount , equalTo ( ( long ) test . dataCopies ) ) ; return ; } assertThat ( convertFromTextArray ( percolateResponse . getMatches ( ) , <str> ) , arrayContaining ( <str> ) ) ; long timeSpent = System . currentTimeMillis ( ) - now ; long waitTime = ttl + PURGE_INTERVAL - timeSpent ; if ( waitTime > = <int> ) { Thread . sleep ( waitTime ) ; } logger . info ( <str> ) ; assertTrue ( awaitBusy ( ( ) - > { IndicesStatsResponse indicesStatsResponse = client . admin ( ) . indices ( ) . prepareStats ( <str> ) . clear ( ) . setIndexing ( true ) . get ( ) ; return indicesStatsResponse . getIndices ( ) . get ( <str> ) . getTotal ( ) . getIndexing ( ) . getTotal ( ) . getDeleteCount ( ) = = test . dataCopies ; } , <int> , TimeUnit . SECONDS ) ) ; percolateResponse = client . preparePercolate ( ) . setIndices ( <str> ) . setDocumentType ( <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) ) . execute ( ) . actionGet ( ) ; assertMatchCount ( percolateResponse , <int> l ) ; assertThat ( percolateResponse . getMatches ( ) , emptyArray ( ) ) ; } public void testEnsureTTLDoesNotCreateIndex ( ) throws IOException , InterruptedException { ensureGreen ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( <str> , <int> , TimeUnit . SECONDS ) . build ( ) ) . get ( ) ; String typeMapping = XContentFactory . jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , true ) . endObject ( ) . endObject ( ) . endObject ( ) . string ( ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . setSettings ( settingsBuilder ( ) . put ( <str> , <int> ) ) . addMapping ( <str> , typeMapping ) . execute ( ) . actionGet ( ) ; ensureGreen ( ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( settingsBuilder ( ) . put ( <str> , <int> , TimeUnit . SECONDS ) . build ( ) ) . get ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { logger . debug ( <str> , i ) ; try { client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( jsonBuilder ( ) . startObject ( ) . startObject ( <str> ) . startObject ( <str> ) . field ( <str> , <str> ) . endObject ( ) . endObject ( ) . endObject ( ) ) . setTTL ( randomIntBetween ( <int> , <int> ) ) . execute ( ) . actionGet ( ) ; } catch ( MapperParsingException e ) { logger . info ( <str> , i , e ) ; assertThat ( e . getCause ( ) , Matchers . instanceOf ( AlreadyExpiredException . class ) ) ; } } refresh ( ) ; assertTrue ( awaitBusy ( ( ) - > { IndicesStatsResponse indicesStatsResponse = client ( ) . admin ( ) . indices ( ) . prepareStats ( <str> ) . clear ( ) . setIndexing ( true ) . get ( ) ; logger . debug ( <str> , indicesStatsResponse . getIndices ( ) . get ( <str> ) . getTotal ( ) . getIndexing ( ) . getTotal ( ) . getDeleteCount ( ) ) ; return indicesStatsResponse . getIndices ( ) . get ( <str> ) . getTotal ( ) . getIndexing ( ) . getTotal ( ) . getDeleteCount ( ) ! = <int> ; } , <int> , TimeUnit . SECONDS ) ) ; internalCluster ( ) . wipeIndices ( <str> ) ; client ( ) . admin ( ) . indices ( ) . prepareCreate ( <str> ) . addMapping ( <str> , typeMapping ) . execute ( ) . actionGet ( ) ; } } 
