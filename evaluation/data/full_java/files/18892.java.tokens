package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ByteToMessageDecoder ; import io . netty . util . internal . EmptyArrays ; import java . util . List ; import java . util . zip . Adler32 ; import java . util . zip . Checksum ; import static io . netty . handler . codec . compression . FastLz . * ; public class FastLzFrameDecoder extends ByteToMessageDecoder { private enum State { INIT_BLOCK , INIT_BLOCK_PARAMS , DECOMPRESS_DATA , CORRUPTED } private State currentState = State . INIT_BLOCK ; private final Checksum checksum ; private int chunkLength ; private int originalLength ; private boolean isCompressed ; private boolean hasChecksum ; private int currentChecksum ; public FastLzFrameDecoder ( ) { this ( false ) ; } public FastLzFrameDecoder ( boolean validateChecksums ) { this ( validateChecksums ? new Adler32 ( ) : null ) ; } public FastLzFrameDecoder ( Checksum checksum ) { this . checksum = checksum ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { try { switch ( currentState ) { case INIT_BLOCK : if ( in . readableBytes ( ) < <int> ) { break ; } final int magic = in . readUnsignedMedium ( ) ; if ( magic ! = MAGIC_NUMBER ) { throw new DecompressionException ( <str> ) ; } final byte options = in . readByte ( ) ; isCompressed = ( options & <hex> ) = = BLOCK_TYPE_COMPRESSED ; hasChecksum = ( options & <hex> ) = = BLOCK_WITH_CHECKSUM ; currentState = State . INIT_BLOCK_PARAMS ; case INIT_BLOCK_PARAMS : if ( in . readableBytes ( ) < <int> + ( isCompressed ? <int> : <int> ) + ( hasChecksum ? <int> : <int> ) ) { break ; } currentChecksum = hasChecksum ? in . readInt ( ) : <int> ; chunkLength = in . readUnsignedShort ( ) ; originalLength = isCompressed ? in . readUnsignedShort ( ) : chunkLength ; currentState = State . DECOMPRESS_DATA ; case DECOMPRESS_DATA : final int chunkLength = this . chunkLength ; if ( in . readableBytes ( ) < chunkLength ) { break ; } final int idx = in . readerIndex ( ) ; final int originalLength = this . originalLength ; final ByteBuf uncompressed ; final byte [ ] output ; final int outputPtr ; if ( originalLength ! = <int> ) { uncompressed = ctx . alloc ( ) . heapBuffer ( originalLength , originalLength ) ; output = uncompressed . array ( ) ; outputPtr = uncompressed . arrayOffset ( ) + uncompressed . writerIndex ( ) ; } else { uncompressed = null ; output = EmptyArrays . EMPTY_BYTES ; outputPtr = <int> ; } boolean success = false ; try { if ( isCompressed ) { final byte [ ] input ; final int inputPtr ; if ( in . hasArray ( ) ) { input = in . array ( ) ; inputPtr = in . arrayOffset ( ) + idx ; } else { input = new byte [ chunkLength ] ; in . getBytes ( idx , input ) ; inputPtr = <int> ; } final int decompressedBytes = decompress ( input , inputPtr , chunkLength , output , outputPtr , originalLength ) ; if ( originalLength ! = decompressedBytes ) { throw new DecompressionException ( String . format ( <str> , originalLength , decompressedBytes ) ) ; } } else { in . getBytes ( idx , output , outputPtr , chunkLength ) ; } final Checksum checksum = this . checksum ; if ( hasChecksum & & checksum ! = null ) { checksum . reset ( ) ; checksum . update ( output , outputPtr , originalLength ) ; final int checksumResult = ( int ) checksum . getValue ( ) ; if ( checksumResult ! = currentChecksum ) { throw new DecompressionException ( String . format ( <str> , checksumResult , currentChecksum ) ) ; } } if ( uncompressed ! = null ) { uncompressed . writerIndex ( uncompressed . writerIndex ( ) + originalLength ) ; out . add ( uncompressed ) ; } in . skipBytes ( chunkLength ) ; currentState = State . INIT_BLOCK ; success = true ; } finally { if ( ! success ) { uncompressed . release ( ) ; } } break ; case CORRUPTED : in . skipBytes ( in . readableBytes ( ) ) ; break ; default : throw new IllegalStateException ( ) ; } } catch ( Exception e ) { currentState = State . CORRUPTED ; throw e ; } } } 
