package com . google . common . collect ; import static com . google . common . testing . SerializableTester . reserialize ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . base . Joiner ; import com . google . common . collect . ImmutableMap . Builder ; import com . google . common . collect . testing . AnEnum ; import com . google . common . collect . testing . CollectionTestSuiteBuilder ; import com . google . common . collect . testing . ListTestSuiteBuilder ; import com . google . common . collect . testing . MapInterfaceTest ; import com . google . common . collect . testing . MapTestSuiteBuilder ; import com . google . common . collect . testing . MinimalSet ; import com . google . common . collect . testing . SampleElements . Colliders ; import com . google . common . collect . testing . SampleElements . Unhashables ; import com . google . common . collect . testing . UnhashableObject ; import com . google . common . collect . testing . features . CollectionFeature ; import com . google . common . collect . testing . features . CollectionSize ; import com . google . common . collect . testing . features . MapFeature ; import com . google . common . collect . testing . google . MapGenerators . ImmutableMapCopyOfEntriesGenerator ; import com . google . common . collect . testing . google . MapGenerators . ImmutableMapCopyOfEnumMapGenerator ; import com . google . common . collect . testing . google . MapGenerators . ImmutableMapCopyOfGenerator ; import com . google . common . collect . testing . google . MapGenerators . ImmutableMapEntryListGenerator ; import com . google . common . collect . testing . google . MapGenerators . ImmutableMapGenerator ; import com . google . common . collect . testing . google . MapGenerators . ImmutableMapKeyListGenerator ; import com . google . common . collect . testing . google . MapGenerators . ImmutableMapUnhashableValuesGenerator ; import com . google . common . collect . testing . google . MapGenerators . ImmutableMapValueListGenerator ; import com . google . common . testing . EqualsTester ; import com . google . common . testing . NullPointerTester ; import com . google . common . testing . SerializableTester ; import junit . framework . Test ; import junit . framework . TestCase ; import junit . framework . TestSuite ; import java . io . Serializable ; import java . util . Collection ; import java . util . Collections ; import java . util . EnumMap ; import java . util . LinkedHashMap ; import java . util . Map ; import java . util . Map . Entry ; @GwtCompatible ( emulated = true ) public class ImmutableMapTest extends TestCase { @GwtIncompatible ( <str> ) public static Test suite ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( ImmutableMapTest . class ) ; suite . addTest ( MapTestSuiteBuilder . using ( new ImmutableMapGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE_INCLUDING_VIEWS , CollectionFeature . KNOWN_ORDER , MapFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MapTestSuiteBuilder . using ( new ImmutableMapCopyOfGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE_INCLUDING_VIEWS , CollectionFeature . KNOWN_ORDER , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MapTestSuiteBuilder . using ( new ImmutableMapCopyOfEntriesGenerator ( ) ) . withFeatures ( CollectionSize . ANY , MapFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . SERIALIZABLE_INCLUDING_VIEWS , CollectionFeature . KNOWN_ORDER , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( MapTestSuiteBuilder . using ( new ImmutableMapCopyOfEnumMapGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE_INCLUDING_VIEWS , CollectionFeature . KNOWN_ORDER , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( CollectionTestSuiteBuilder . using ( new ImmutableMapUnhashableValuesGenerator ( ) ) . withFeatures ( CollectionSize . ANY , CollectionFeature . KNOWN_ORDER , CollectionFeature . ALLOWS_NULL_QUERIES ) . named ( <str> ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableMapKeyListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableMapEntryListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . REJECTS_DUPLICATES_AT_CREATION , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; suite . addTest ( ListTestSuiteBuilder . using ( new ImmutableMapValueListGenerator ( ) ) . named ( <str> ) . withFeatures ( CollectionSize . ANY , CollectionFeature . SERIALIZABLE , CollectionFeature . ALLOWS_NULL_QUERIES ) . createTestSuite ( ) ) ; return suite ; } public abstract static class AbstractMapTests < K , V > extends MapInterfaceTest < K , V > { public AbstractMapTests ( ) { super ( false , false , false , false , false ) ; } @Override protected Map < K , V > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ; } private static final Joiner joiner = Joiner . on ( <str> ) ; @Override protected void assertMoreInvariants ( Map < K , V > map ) { for ( Entry < K , V > entry : map . entrySet ( ) ) { assertEquals ( entry . getKey ( ) + <str> + entry . getValue ( ) , entry . toString ( ) ) ; } assertEquals ( <str> + joiner . join ( map . entrySet ( ) ) + <str> , map . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . entrySet ( ) ) + <str> , map . entrySet ( ) . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . keySet ( ) ) + <str> , map . keySet ( ) . toString ( ) ) ; assertEquals ( <str> + joiner . join ( map . values ( ) ) + <str> , map . values ( ) . toString ( ) ) ; assertEquals ( MinimalSet . from ( map . entrySet ( ) ) , map . entrySet ( ) ) ; assertEquals ( Sets . newHashSet ( map . keySet ( ) ) , map . keySet ( ) ) ; } } public static class MapTests extends AbstractMapTests < String , Integer > { @Override protected Map < String , Integer > makeEmptyMap ( ) { return ImmutableMap . of ( ) ; } @Override protected Map < String , Integer > makePopulatedMap ( ) { return ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return - <int> ; } } public static class SingletonMapTests extends AbstractMapTests < String , Integer > { @Override protected Map < String , Integer > makePopulatedMap ( ) { return ImmutableMap . of ( <str> , <int> ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return - <int> ; } } @GwtIncompatible ( <str> ) public static class ReserializedMapTests extends AbstractMapTests < String , Integer > { @Override protected Map < String , Integer > makePopulatedMap ( ) { return SerializableTester . reserialize ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; } @Override protected String getKeyNotInPopulatedMap ( ) { return <str> ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return - <int> ; } } public static class MapTestsWithBadHashes extends AbstractMapTests < Object , Integer > { @Override protected Map < Object , Integer > makeEmptyMap ( ) { throw new UnsupportedOperationException ( ) ; } @Override protected Map < Object , Integer > makePopulatedMap ( ) { Colliders colliders = new Colliders ( ) ; return ImmutableMap . of ( colliders . e0 ( ) , <int> , colliders . e1 ( ) , <int> , colliders . e2 ( ) , <int> , colliders . e3 ( ) , <int> ) ; } @Override protected Object getKeyNotInPopulatedMap ( ) { return new Colliders ( ) . e4 ( ) ; } @Override protected Integer getValueNotInPopulatedMap ( ) { return <int> ; } } @GwtIncompatible ( <str> ) public static class MapTestsWithUnhashableValues extends AbstractMapTests < Integer , UnhashableObject > { @Override protected Map < Integer , UnhashableObject > makeEmptyMap ( ) { return ImmutableMap . of ( ) ; } @Override protected Map < Integer , UnhashableObject > makePopulatedMap ( ) { Unhashables unhashables = new Unhashables ( ) ; return ImmutableMap . of ( <int> , unhashables . e0 ( ) , <int> , unhashables . e1 ( ) , <int> , unhashables . e2 ( ) ) ; } @Override protected Integer getKeyNotInPopulatedMap ( ) { return <int> ; } @Override protected UnhashableObject getValueNotInPopulatedMap ( ) { return new Unhashables ( ) . e3 ( ) ; } } @GwtIncompatible ( <str> ) public static class MapTestsWithSingletonUnhashableValue extends MapTestsWithUnhashableValues { @Override protected Map < Integer , UnhashableObject > makePopulatedMap ( ) { Unhashables unhashables = new Unhashables ( ) ; return ImmutableMap . of ( <int> , unhashables . e0 ( ) ) ; } } public static class CreationTests extends TestCase { public void testEmptyBuilder ( ) { ImmutableMap < String , Integer > map = new Builder < String , Integer > ( ) . build ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , map ) ; } public void testSingletonBuilder ( ) { ImmutableMap < String , Integer > map = new Builder < String , Integer > ( ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> ) ; } public void testBuilder ( ) { ImmutableMap < String , Integer > map = new Builder < String , Integer > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testBuilder_orderEntriesByValue ( ) { ImmutableMap < String , Integer > map = new Builder < String , Integer > ( ) . orderEntriesByValue ( Ordering . natural ( ) ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testBuilder_orderEntriesByValueAfterExactSizeBuild ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( <int> ) . put ( <str> , <int> ) . put ( <str> , <int> ) ; ImmutableMap < String , Integer > keyOrdered = builder . build ( ) ; ImmutableMap < String , Integer > valueOrdered = builder . orderEntriesByValue ( Ordering . natural ( ) ) . build ( ) ; assertMapEquals ( keyOrdered , <str> , <int> , <str> , <int> ) ; assertMapEquals ( valueOrdered , <str> , <int> , <str> , <int> ) ; } public void testBuilder_orderEntriesByValue_usedTwiceFails ( ) { ImmutableMap . Builder < String , Integer > builder = new Builder < String , Integer > ( ) . orderEntriesByValue ( Ordering . natural ( ) ) ; try { builder . orderEntriesByValue ( Ordering . natural ( ) ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } } public void testBuilder_withImmutableEntry ( ) { ImmutableMap < String , Integer > map = new Builder < String , Integer > ( ) . put ( Maps . immutableEntry ( <str> , <int> ) ) . build ( ) ; assertMapEquals ( map , <str> , <int> ) ; } public void testBuilder_withImmutableEntryAndNullContents ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . put ( Maps . immutableEntry ( <str> , ( Integer ) null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { builder . put ( Maps . immutableEntry ( ( String ) null , <int> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } private static class StringHolder { String string ; } public void testBuilder_withMutableEntry ( ) { ImmutableMap . Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; final StringHolder holder = new StringHolder ( ) ; holder . string = <str> ; Entry < String , Integer > entry = new AbstractMapEntry < String , Integer > ( ) { @Override public String getKey ( ) { return holder . string ; } @Override public Integer getValue ( ) { return <int> ; } } ; builder . put ( entry ) ; holder . string = <str> ; assertMapEquals ( builder . build ( ) , <str> , <int> ) ; } public void testBuilderPutAllWithEmptyMap ( ) { ImmutableMap < String , Integer > map = new Builder < String , Integer > ( ) . putAll ( Collections . < String , Integer > emptyMap ( ) ) . build ( ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , map ) ; } public void testBuilderPutAll ( ) { Map < String , Integer > toPut = new LinkedHashMap < String , Integer > ( ) ; toPut . put ( <str> , <int> ) ; toPut . put ( <str> , <int> ) ; toPut . put ( <str> , <int> ) ; Map < String , Integer > moreToPut = new LinkedHashMap < String , Integer > ( ) ; moreToPut . put ( <str> , <int> ) ; moreToPut . put ( <str> , <int> ) ; ImmutableMap < String , Integer > map = new Builder < String , Integer > ( ) . putAll ( toPut ) . putAll ( moreToPut ) . build ( ) ; assertMapEquals ( map , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testBuilderReuse ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; ImmutableMap < String , Integer > mapOne = builder . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; ImmutableMap < String , Integer > mapTwo = builder . put ( <str> , <int> ) . put ( <str> , <int> ) . build ( ) ; assertMapEquals ( mapOne , <str> , <int> , <str> , <int> ) ; assertMapEquals ( mapTwo , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testBuilderPutNullKeyFailsAtomically ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . put ( null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } builder . put ( <str> , <int> ) ; assertMapEquals ( builder . build ( ) , <str> , <int> ) ; } public void testBuilderPutImmutableEntryWithNullKeyFailsAtomically ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . put ( Maps . immutableEntry ( ( String ) null , <int> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } builder . put ( <str> , <int> ) ; assertMapEquals ( builder . build ( ) , <str> , <int> ) ; } static class SimpleEntry < K , V > extends AbstractMapEntry < K , V > { public K key ; public V value ; SimpleEntry ( K key , V value ) { this . key = key ; this . value = value ; } @Override public K getKey ( ) { return key ; } @Override public V getValue ( ) { return value ; } } public void testBuilderPutMutableEntryWithNullKeyFailsAtomically ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . put ( new SimpleEntry < String , Integer > ( null , <int> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } builder . put ( <str> , <int> ) ; assertMapEquals ( builder . build ( ) , <str> , <int> ) ; } public void testBuilderPutNullKey ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . put ( null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullValue ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . put ( <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullKeyViaPutAll ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . putAll ( Collections . < String , Integer > singletonMap ( null , <int> ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testBuilderPutNullValueViaPutAll ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) ; try { builder . putAll ( Collections . < String , Integer > singletonMap ( <str> , null ) ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testPuttingTheSameKeyTwiceThrowsOnBuild ( ) { Builder < String , Integer > builder = new Builder < String , Integer > ( ) . put ( <str> , <int> ) . put ( <str> , <int> ) ; try { builder . build ( ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testOf ( ) { assertMapEquals ( ImmutableMap . of ( <str> , <int> ) , <str> , <int> ) ; assertMapEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertMapEquals ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; } public void testOfNullKey ( ) { try { ImmutableMap . of ( null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { ImmutableMap . of ( <str> , <int> , null , <int> ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testOfNullValue ( ) { try { ImmutableMap . of ( <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } try { ImmutableMap . of ( <str> , <int> , <str> , null ) ; fail ( ) ; } catch ( NullPointerException expected ) { } } public void testOfWithDuplicateKey ( ) { try { ImmutableMap . of ( <str> , <int> , <str> , <int> ) ; fail ( ) ; } catch ( IllegalArgumentException expected ) { } } public void testCopyOfEmptyMap ( ) { ImmutableMap < String , Integer > copy = ImmutableMap . copyOf ( Collections . < String , Integer > emptyMap ( ) ) ; assertEquals ( Collections . < String , Integer > emptyMap ( ) , copy ) ; assertSame ( copy , ImmutableMap . copyOf ( copy ) ) ; } public void testCopyOfSingletonMap ( ) { ImmutableMap < String , Integer > copy = ImmutableMap . copyOf ( Collections . singletonMap ( <str> , <int> ) ) ; assertMapEquals ( copy , <str> , <int> ) ; assertSame ( copy , ImmutableMap . copyOf ( copy ) ) ; } public void testCopyOf ( ) { Map < String , Integer > original = new LinkedHashMap < String , Integer > ( ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; original . put ( <str> , <int> ) ; ImmutableMap < String , Integer > copy = ImmutableMap . copyOf ( original ) ; assertMapEquals ( copy , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertSame ( copy , ImmutableMap . copyOf ( copy ) ) ; } } public void testNullGet ( ) { ImmutableMap < String , Integer > map = ImmutableMap . of ( <str> , <int> ) ; assertNull ( map . get ( null ) ) ; } public void testAsMultimap ( ) { ImmutableMap < String , Integer > map = ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; ImmutableSetMultimap < String , Integer > expected = ImmutableSetMultimap . of ( <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> , <str> , <int> ) ; assertEquals ( expected , map . asMultimap ( ) ) ; } public void testAsMultimapWhenEmpty ( ) { ImmutableMap < String , Integer > map = ImmutableMap . of ( ) ; ImmutableSetMultimap < String , Integer > expected = ImmutableSetMultimap . of ( ) ; assertEquals ( expected , map . asMultimap ( ) ) ; } public void testAsMultimapCaches ( ) { ImmutableMap < String , Integer > map = ImmutableMap . of ( <str> , <int> ) ; ImmutableSetMultimap < String , Integer > multimap1 = map . asMultimap ( ) ; ImmutableSetMultimap < String , Integer > multimap2 = map . asMultimap ( ) ; assertEquals ( <int> , multimap1 . asMap ( ) . size ( ) ) ; assertSame ( multimap1 , multimap2 ) ; } @GwtIncompatible ( <str> ) public void testNullPointers ( ) { NullPointerTester tester = new NullPointerTester ( ) ; tester . testAllPublicStaticMethods ( ImmutableMap . class ) ; tester . testAllPublicInstanceMethods ( new ImmutableMap . Builder < Object , Object > ( ) ) ; tester . testAllPublicInstanceMethods ( ImmutableMap . of ( ) ) ; tester . testAllPublicInstanceMethods ( ImmutableMap . of ( <str> , <int> ) ) ; tester . testAllPublicInstanceMethods ( ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ) ; } private static < K , V > void assertMapEquals ( Map < K , V > map , Object . . . alternatingKeysAndValues ) { assertEquals ( map . size ( ) , alternatingKeysAndValues . length / <int> ) ; int i = <int> ; for ( Entry < K , V > entry : map . entrySet ( ) ) { assertEquals ( alternatingKeysAndValues [ i + + ] , entry . getKey ( ) ) ; assertEquals ( alternatingKeysAndValues [ i + + ] , entry . getValue ( ) ) ; } } private static class IntHolder implements Serializable { public int value ; public IntHolder ( int value ) { this . value = value ; } @Override public boolean equals ( Object o ) { return ( o instanceof IntHolder ) & & ( ( IntHolder ) o ) . value = = value ; } @Override public int hashCode ( ) { return value ; } private static final long serialVersionUID = <int> ; } public void testMutableValues ( ) { IntHolder holderA = new IntHolder ( <int> ) ; IntHolder holderB = new IntHolder ( <int> ) ; Map < String , IntHolder > map = ImmutableMap . of ( <str> , holderA , <str> , holderB ) ; holderA . value = <int> ; assertTrue ( map . entrySet ( ) . contains ( Maps . immutableEntry ( <str> , new IntHolder ( <int> ) ) ) ) ; Map < String , Integer > intMap = ImmutableMap . of ( <str> , <int> , <str> , <int> ) ; assertEquals ( intMap . hashCode ( ) , map . entrySet ( ) . hashCode ( ) ) ; assertEquals ( intMap . hashCode ( ) , map . hashCode ( ) ) ; } public void testCopyOfEnumMap ( ) { EnumMap < AnEnum , String > map = new EnumMap < AnEnum , String > ( AnEnum . class ) ; map . put ( AnEnum . B , <str> ) ; map . put ( AnEnum . C , <str> ) ; assertTrue ( ImmutableMap . copyOf ( map ) instanceof ImmutableEnumMap ) ; } @GwtIncompatible ( <str> ) public void testViewSerialization ( ) { Map < String , Integer > map = ImmutableMap . of ( <str> , <int> , <str> , <int> , <str> , <int> ) ; LenientSerializableTester . reserializeAndAssertLenient ( map . entrySet ( ) ) ; LenientSerializableTester . reserializeAndAssertLenient ( map . keySet ( ) ) ; Collection < Integer > reserializedValues = reserialize ( map . values ( ) ) ; assertEquals ( Lists . newArrayList ( map . values ( ) ) , Lists . newArrayList ( reserializedValues ) ) ; assertTrue ( reserializedValues instanceof ImmutableCollection ) ; } public void testEquals ( ) { new EqualsTester ( ) . addEqualityGroup ( ImmutableList . of ( ) , ImmutableList . of ( ) ) . addEqualityGroup ( ImmutableList . of ( <int> ) , ImmutableList . of ( <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> ) , ImmutableList . of ( <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . addEqualityGroup ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) . testEquals ( ) ; } } 
