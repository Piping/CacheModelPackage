package org . apache . cassandra . cql3 . functions ; import java . nio . ByteBuffer ; import java . util . ArrayList ; import java . util . List ; import java . util . stream . Collectors ; import com . google . common . collect . Iterables ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . statements . RequestValidations ; import org . apache . cassandra . db . marshal . * ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . serializers . MarshalException ; import org . apache . cassandra . utils . ByteBufferUtil ; public class FunctionCall extends Term . NonTerminal { private final ScalarFunction fun ; private final List < Term > terms ; private FunctionCall ( ScalarFunction fun , List < Term > terms ) { this . fun = fun ; this . terms = terms ; } public Iterable < Function > getFunctions ( ) { return Iterables . concat ( Terms . getFunctions ( terms ) , fun . getFunctions ( ) ) ; } public void collectMarkerSpecification ( VariableSpecifications boundNames ) { for ( Term t : terms ) t . collectMarkerSpecification ( boundNames ) ; } public Term . Terminal bind ( QueryOptions options ) throws InvalidRequestException { return makeTerminal ( fun , bindAndGet ( options ) , options . getProtocolVersion ( ) ) ; } public ByteBuffer bindAndGet ( QueryOptions options ) throws InvalidRequestException { List < ByteBuffer > buffers = new ArrayList < > ( terms . size ( ) ) ; for ( Term t : terms ) { ByteBuffer functionArg = t . bindAndGet ( options ) ; RequestValidations . checkBindValueSet ( functionArg , <str> , fun . name ( ) . name ) ; buffers . add ( functionArg ) ; } return executeInternal ( options . getProtocolVersion ( ) , fun , buffers ) ; } private static ByteBuffer executeInternal ( int protocolVersion , ScalarFunction fun , List < ByteBuffer > params ) throws InvalidRequestException { ByteBuffer result = fun . execute ( protocolVersion , params ) ; try { if ( result ! = null ) fun . returnType ( ) . validate ( result ) ; return result ; } catch ( MarshalException e ) { throw new RuntimeException ( String . format ( <str> , fun , ByteBufferUtil . bytesToHex ( result ) , fun . returnType ( ) . asCQL3Type ( ) ) , e ) ; } } public boolean containsBindMarker ( ) { for ( Term t : terms ) { if ( t . containsBindMarker ( ) ) return true ; } return false ; } private static Term . Terminal makeTerminal ( Function fun , ByteBuffer result , int version ) throws InvalidRequestException { if ( ! ( fun . returnType ( ) instanceof CollectionType ) ) return new Constants . Value ( result ) ; switch ( ( ( CollectionType ) fun . returnType ( ) ) . kind ) { case LIST : return Lists . Value . fromSerialized ( result , ( ListType ) fun . returnType ( ) , version ) ; case SET : return Sets . Value . fromSerialized ( result , ( SetType ) fun . returnType ( ) , version ) ; case MAP : return Maps . Value . fromSerialized ( result , ( MapType ) fun . returnType ( ) , version ) ; } throw new AssertionError ( ) ; } public static class Raw extends Term . Raw { private FunctionName name ; private final List < Term . Raw > terms ; public Raw ( FunctionName name , List < Term . Raw > terms ) { this . name = name ; this . terms = terms ; } public Term prepare ( String keyspace , ColumnSpecification receiver ) throws InvalidRequestException { Function fun = FunctionResolver . get ( keyspace , name , terms , receiver . ksName , receiver . cfName , receiver . type ) ; if ( fun = = null ) throw new InvalidRequestException ( String . format ( <str> , name ) ) ; if ( fun . isAggregate ( ) ) throw new InvalidRequestException ( <str> ) ; ScalarFunction scalarFun = ( ScalarFunction ) fun ; if ( ! scalarFun . testAssignment ( keyspace , receiver ) . isAssignable ( ) ) throw new InvalidRequestException ( String . format ( <str> , scalarFun . name ( ) , scalarFun . returnType ( ) . asCQL3Type ( ) , receiver . name , receiver . type . asCQL3Type ( ) ) ) ; if ( fun . argTypes ( ) . size ( ) ! = terms . size ( ) ) throw new InvalidRequestException ( String . format ( <str> , fun , fun . argTypes ( ) . size ( ) , terms . size ( ) ) ) ; List < Term > parameters = new ArrayList < > ( terms . size ( ) ) ; for ( int i = <int> ; i < terms . size ( ) ; i + + ) { Term t = terms . get ( i ) . prepare ( keyspace , FunctionResolver . makeArgSpec ( receiver . ksName , receiver . cfName , scalarFun , i ) ) ; parameters . add ( t ) ; } return new FunctionCall ( scalarFun , parameters ) ; } public AssignmentTestable . TestResult testAssignment ( String keyspace , ColumnSpecification receiver ) { try { Function fun = FunctionResolver . get ( keyspace , name , terms , receiver . ksName , receiver . cfName , receiver . type ) ; if ( fun ! = null & & fun . name ( ) . equals ( FromJsonFct . NAME ) ) return TestResult . WEAKLY_ASSIGNABLE ; if ( fun ! = null & & receiver . type . equals ( fun . returnType ( ) ) ) return AssignmentTestable . TestResult . EXACT_MATCH ; else if ( fun = = null | | receiver . type . isValueCompatibleWith ( fun . returnType ( ) ) ) return AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; else return AssignmentTestable . TestResult . NOT_ASSIGNABLE ; } catch ( InvalidRequestException e ) { return AssignmentTestable . TestResult . WEAKLY_ASSIGNABLE ; } } public String getText ( ) { return name + terms . stream ( ) . map ( Term . Raw : : getText ) . collect ( Collectors . joining ( <str> , <str> , <str> ) ) ; } } } 
