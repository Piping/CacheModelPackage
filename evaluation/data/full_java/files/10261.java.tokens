package com . google . common . base ; import static com . google . common . testing . SerializableTester . reserialize ; import com . google . common . annotations . GwtCompatible ; import com . google . common . annotations . GwtIncompatible ; import com . google . common . collect . Lists ; import com . google . common . testing . ClassSanityTester ; import com . google . common . testing . EqualsTester ; import junit . framework . TestCase ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . List ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . TimeoutException ; import java . util . concurrent . atomic . AtomicInteger ; import java . util . concurrent . atomic . AtomicReference ; @GwtCompatible ( emulated = true ) public class SuppliersTest extends TestCase { public void testCompose ( ) { Supplier < Integer > fiveSupplier = new Supplier < Integer > ( ) { @Override public Integer get ( ) { return <int> ; } } ; Function < Number , Integer > intValueFunction = new Function < Number , Integer > ( ) { @Override public Integer apply ( Number x ) { return x . intValue ( ) ; } } ; Supplier < Integer > squareSupplier = Suppliers . compose ( intValueFunction , fiveSupplier ) ; assertEquals ( Integer . valueOf ( <int> ) , squareSupplier . get ( ) ) ; } public void testComposeWithLists ( ) { Supplier < ArrayList < Integer > > listSupplier = new Supplier < ArrayList < Integer > > ( ) { @Override public ArrayList < Integer > get ( ) { return Lists . newArrayList ( <int> ) ; } } ; Function < List < Integer > , List < Integer > > addElementFunction = new Function < List < Integer > , List < Integer > > ( ) { @Override public List < Integer > apply ( List < Integer > list ) { ArrayList < Integer > result = Lists . newArrayList ( list ) ; result . add ( <int> ) ; return result ; } } ; Supplier < List < Integer > > addSupplier = Suppliers . compose ( addElementFunction , listSupplier ) ; List < Integer > result = addSupplier . get ( ) ; assertEquals ( Integer . valueOf ( <int> ) , result . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , result . get ( <int> ) ) ; } static class CountingSupplier implements Supplier < Integer > , Serializable { private static final long serialVersionUID = <int> L ; transient int calls = <int> ; @Override public Integer get ( ) { calls + + ; return calls * <int> ; } } public void testMemoize ( ) { CountingSupplier countingSupplier = new CountingSupplier ( ) ; Supplier < Integer > memoizedSupplier = Suppliers . memoize ( countingSupplier ) ; checkMemoize ( countingSupplier , memoizedSupplier ) ; } public void testMemoize_redudantly ( ) { CountingSupplier countingSupplier = new CountingSupplier ( ) ; Supplier < Integer > memoizedSupplier = Suppliers . memoize ( countingSupplier ) ; assertSame ( memoizedSupplier , Suppliers . memoize ( memoizedSupplier ) ) ; } @GwtIncompatible ( <str> ) public void testMemoizeSerialized ( ) { CountingSupplier countingSupplier = new CountingSupplier ( ) ; Supplier < Integer > memoizedSupplier = Suppliers . memoize ( countingSupplier ) ; checkMemoize ( countingSupplier , memoizedSupplier ) ; memoizedSupplier . get ( ) ; Supplier < Integer > copy = reserialize ( memoizedSupplier ) ; memoizedSupplier . get ( ) ; CountingSupplier countingCopy = ( CountingSupplier ) ( ( Suppliers . MemoizingSupplier < Integer > ) copy ) . delegate ; checkMemoize ( countingCopy , copy ) ; } private void checkMemoize ( CountingSupplier countingSupplier , Supplier < Integer > memoizedSupplier ) { assertEquals ( <int> , countingSupplier . calls ) ; assertEquals ( <int> , ( int ) memoizedSupplier . get ( ) ) ; assertEquals ( <int> , countingSupplier . calls ) ; assertEquals ( <int> , ( int ) memoizedSupplier . get ( ) ) ; assertEquals ( <int> , countingSupplier . calls ) ; } public void testMemoizeExceptionThrown ( ) { Supplier < Integer > exceptingSupplier = new Supplier < Integer > ( ) { @Override public Integer get ( ) { throw new NullPointerException ( ) ; } } ; Supplier < Integer > memoizedSupplier = Suppliers . memoize ( exceptingSupplier ) ; for ( int i = <int> ; i < <int> ; i + + ) { try { memoizedSupplier . get ( ) ; fail ( <str> ) ; } catch ( NullPointerException e ) { } } } @GwtIncompatible ( <str> ) public void testMemoizeWithExpiration ( ) throws InterruptedException { CountingSupplier countingSupplier = new CountingSupplier ( ) ; Supplier < Integer > memoizedSupplier = Suppliers . memoizeWithExpiration ( countingSupplier , <int> , TimeUnit . MILLISECONDS ) ; checkExpiration ( countingSupplier , memoizedSupplier ) ; } @GwtIncompatible ( <str> ) public void testMemoizeWithExpirationSerialized ( ) throws InterruptedException { CountingSupplier countingSupplier = new CountingSupplier ( ) ; Supplier < Integer > memoizedSupplier = Suppliers . memoizeWithExpiration ( countingSupplier , <int> , TimeUnit . MILLISECONDS ) ; memoizedSupplier . get ( ) ; Supplier < Integer > copy = reserialize ( memoizedSupplier ) ; memoizedSupplier . get ( ) ; CountingSupplier countingCopy = ( CountingSupplier ) ( ( Suppliers . ExpiringMemoizingSupplier < Integer > ) copy ) . delegate ; checkExpiration ( countingCopy , copy ) ; } @GwtIncompatible ( <str> ) private void checkExpiration ( CountingSupplier countingSupplier , Supplier < Integer > memoizedSupplier ) throws InterruptedException { assertEquals ( <int> , countingSupplier . calls ) ; assertEquals ( <int> , ( int ) memoizedSupplier . get ( ) ) ; assertEquals ( <int> , countingSupplier . calls ) ; assertEquals ( <int> , ( int ) memoizedSupplier . get ( ) ) ; assertEquals ( <int> , countingSupplier . calls ) ; Thread . sleep ( <int> ) ; assertEquals ( <int> , ( int ) memoizedSupplier . get ( ) ) ; assertEquals ( <int> , countingSupplier . calls ) ; assertEquals ( <int> , ( int ) memoizedSupplier . get ( ) ) ; assertEquals ( <int> , countingSupplier . calls ) ; } public void testOfInstanceSuppliesSameInstance ( ) { Object toBeSupplied = new Object ( ) ; Supplier < Object > objectSupplier = Suppliers . ofInstance ( toBeSupplied ) ; assertSame ( toBeSupplied , objectSupplier . get ( ) ) ; assertSame ( toBeSupplied , objectSupplier . get ( ) ) ; } public void testOfInstanceSuppliesNull ( ) { Supplier < Integer > nullSupplier = Suppliers . ofInstance ( null ) ; assertNull ( nullSupplier . get ( ) ) ; } @GwtIncompatible ( <str> ) public void testExpiringMemoizedSupplierThreadSafe ( ) throws Throwable { Function < Supplier < Boolean > , Supplier < Boolean > > memoizer = new Function < Supplier < Boolean > , Supplier < Boolean > > ( ) { @Override public Supplier < Boolean > apply ( Supplier < Boolean > supplier ) { return Suppliers . memoizeWithExpiration ( supplier , Long . MAX_VALUE , TimeUnit . NANOSECONDS ) ; } } ; testSupplierThreadSafe ( memoizer ) ; } @GwtIncompatible ( <str> ) public void testMemoizedSupplierThreadSafe ( ) throws Throwable { Function < Supplier < Boolean > , Supplier < Boolean > > memoizer = new Function < Supplier < Boolean > , Supplier < Boolean > > ( ) { @Override public Supplier < Boolean > apply ( Supplier < Boolean > supplier ) { return Suppliers . memoize ( supplier ) ; } } ; testSupplierThreadSafe ( memoizer ) ; } @GwtIncompatible ( <str> ) public void testSupplierThreadSafe ( Function < Supplier < Boolean > , Supplier < Boolean > > memoizer ) throws Throwable { final AtomicInteger count = new AtomicInteger ( <int> ) ; final AtomicReference < Throwable > thrown = new AtomicReference < Throwable > ( null ) ; final int numThreads = <int> ; final Thread [ ] threads = new Thread [ numThreads ] ; final long timeout = TimeUnit . SECONDS . toNanos ( <int> ) ; final Supplier < Boolean > supplier = new Supplier < Boolean > ( ) { boolean isWaiting ( Thread thread ) { switch ( thread . getState ( ) ) { case BLOCKED : case WAITING : case TIMED_WAITING : return true ; default : return false ; } } int waitingThreads ( ) { int waitingThreads = <int> ; for ( Thread thread : threads ) { if ( isWaiting ( thread ) ) { waitingThreads + + ; } } return waitingThreads ; } @Override public Boolean get ( ) { long t0 = System . nanoTime ( ) ; while ( waitingThreads ( ) ! = numThreads - <int> ) { if ( System . nanoTime ( ) - t0 > timeout ) { thrown . set ( new TimeoutException ( <str> + <str> ) ) ; break ; } Thread . yield ( ) ; } count . getAndIncrement ( ) ; return Boolean . TRUE ; } } ; final Supplier < Boolean > memoizedSupplier = memoizer . apply ( supplier ) ; for ( int i = <int> ; i < numThreads ; i + + ) { threads [ i ] = new Thread ( ) { @Override public void run ( ) { assertSame ( Boolean . TRUE , memoizedSupplier . get ( ) ) ; } } ; } for ( Thread t : threads ) { t . start ( ) ; } for ( Thread t : threads ) { t . join ( ) ; } if ( thrown . get ( ) ! = null ) { throw thrown . get ( ) ; } assertEquals ( <int> , count . get ( ) ) ; } @GwtIncompatible ( <str> ) public void testSynchronizedSupplierThreadSafe ( ) throws InterruptedException { final Supplier < Integer > nonThreadSafe = new Supplier < Integer > ( ) { int counter = <int> ; @Override public Integer get ( ) { int nextValue = counter + <int> ; Thread . yield ( ) ; counter = nextValue ; return counter ; } } ; final int numThreads = <int> ; final int iterations = <int> ; Thread [ ] threads = new Thread [ numThreads ] ; for ( int i = <int> ; i < numThreads ; i + + ) { threads [ i ] = new Thread ( ) { @Override public void run ( ) { for ( int j = <int> ; j < iterations ; j + + ) { Suppliers . synchronizedSupplier ( nonThreadSafe ) . get ( ) ; } } } ; } for ( Thread t : threads ) { t . start ( ) ; } for ( Thread t : threads ) { t . join ( ) ; } assertEquals ( numThreads * iterations + <int> , ( int ) nonThreadSafe . get ( ) ) ; } public void testSupplierFunction ( ) { Supplier < Integer > supplier = Suppliers . ofInstance ( <int> ) ; Function < Supplier < Integer > , Integer > supplierFunction = Suppliers . supplierFunction ( ) ; assertEquals ( <int> , ( int ) supplierFunction . apply ( supplier ) ) ; } @GwtIncompatible ( <str> ) public void testSerialization ( ) { assertEquals ( Integer . valueOf ( <int> ) , reserialize ( Suppliers . ofInstance ( <int> ) ) . get ( ) ) ; assertEquals ( Integer . valueOf ( <int> ) , reserialize ( Suppliers . compose ( Functions . identity ( ) , Suppliers . ofInstance ( <int> ) ) ) . get ( ) ) ; assertEquals ( Integer . valueOf ( <int> ) , reserialize ( Suppliers . memoize ( Suppliers . ofInstance ( <int> ) ) ) . get ( ) ) ; assertEquals ( Integer . valueOf ( <int> ) , reserialize ( Suppliers . memoizeWithExpiration ( Suppliers . ofInstance ( <int> ) , <int> , TimeUnit . SECONDS ) ) . get ( ) ) ; assertEquals ( Integer . valueOf ( <int> ) , reserialize ( Suppliers . synchronizedSupplier ( Suppliers . ofInstance ( <int> ) ) ) . get ( ) ) ; } @GwtIncompatible ( <str> ) public void testSuppliersNullChecks ( ) throws Exception { new ClassSanityTester ( ) . forAllPublicStaticMethods ( Suppliers . class ) . testNulls ( ) ; } @GwtIncompatible ( <str> ) @AndroidIncompatible public void testSuppliersSerializable ( ) throws Exception { new ClassSanityTester ( ) . forAllPublicStaticMethods ( Suppliers . class ) . testSerializable ( ) ; } public void testOfInstance_equals ( ) { new EqualsTester ( ) . addEqualityGroup ( Suppliers . ofInstance ( <str> ) , Suppliers . ofInstance ( <str> ) ) . addEqualityGroup ( Suppliers . ofInstance ( <str> ) ) . testEquals ( ) ; } public void testCompose_equals ( ) { new EqualsTester ( ) . addEqualityGroup ( Suppliers . compose ( Functions . constant ( <int> ) , Suppliers . ofInstance ( <str> ) ) , Suppliers . compose ( Functions . constant ( <int> ) , Suppliers . ofInstance ( <str> ) ) ) . addEqualityGroup ( Suppliers . compose ( Functions . constant ( <int> ) , Suppliers . ofInstance ( <str> ) ) ) . addEqualityGroup ( Suppliers . compose ( Functions . constant ( <int> ) , Suppliers . ofInstance ( <str> ) ) ) . testEquals ( ) ; } } 
