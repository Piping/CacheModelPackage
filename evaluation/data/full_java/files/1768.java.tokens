package org . apache . cassandra . stress . settings ; import java . io . Serializable ; import java . util . Arrays ; import java . util . List ; import java . util . Map ; import com . google . common . collect . ImmutableList ; import org . apache . cassandra . stress . generate . DistributionFactory ; import org . apache . cassandra . stress . generate . PartitionGenerator ; public class SettingsPopulation implements Serializable { public final DistributionFactory distribution ; public final DistributionFactory readlookback ; public final PartitionGenerator . Order order ; public final boolean wrap ; public final long [ ] sequence ; public static enum GenerateOrder { ARBITRARY , SHUFFLED , SORTED } private SettingsPopulation ( GenerateOptions options , DistributionOptions dist , SequentialOptions pop ) { this . order = ! options . contents . setByUser ( ) ? PartitionGenerator . Order . ARBITRARY : PartitionGenerator . Order . valueOf ( options . contents . value ( ) . toUpperCase ( ) ) ; if ( dist ! = null ) { this . distribution = dist . seed . get ( ) ; this . sequence = null ; this . readlookback = null ; this . wrap = false ; } else { this . distribution = null ; String [ ] bounds = pop . populate . value ( ) . split ( <str> ) ; this . sequence = new long [ ] { OptionDistribution . parseLong ( bounds [ <int> ] ) , OptionDistribution . parseLong ( bounds [ <int> ] ) } ; this . readlookback = pop . lookback . get ( ) ; this . wrap = ! pop . nowrap . setByUser ( ) ; } } public SettingsPopulation ( DistributionOptions options ) { this ( options , options , null ) ; } public SettingsPopulation ( SequentialOptions options ) { this ( options , null , options ) ; } private static class GenerateOptions extends GroupedOptions { final OptionSimple contents = new OptionSimple ( <str> , <str> , null , <str> , false ) ; @Override public List < ? extends Option > options ( ) { return Arrays . asList ( contents ) ; } } private static final class DistributionOptions extends GenerateOptions { final OptionDistribution seed ; public DistributionOptions ( String defaultLimit ) { seed = new OptionDistribution ( <str> , <str> + defaultLimit + <str> , <str> ) ; } @Override public List < ? extends Option > options ( ) { return ImmutableList . < Option > builder ( ) . add ( seed ) . addAll ( super . options ( ) ) . build ( ) ; } } private static final class SequentialOptions extends GenerateOptions { final OptionSimple populate ; final OptionDistribution lookback = new OptionDistribution ( <str> , null , <str> , false ) ; final OptionSimple nowrap = new OptionSimple ( <str> , <str> , null , <str> , false ) ; public SequentialOptions ( String defaultLimit ) { populate = new OptionSimple ( <str> , <str> , <str> + defaultLimit , <str> , true ) ; } @Override public List < ? extends Option > options ( ) { return ImmutableList . < Option > builder ( ) . add ( populate , nowrap , lookback ) . addAll ( super . options ( ) ) . build ( ) ; } } public static SettingsPopulation get ( Map < String , String [ ] > clArgs , SettingsCommand command ) { String defaultLimit = command . count < = <int> ? <str> : Long . toString ( command . count ) ; String [ ] params = clArgs . remove ( <str> ) ; if ( params = = null ) { if ( command instanceof SettingsCommandUser & & ( ( SettingsCommandUser ) command ) . hasInsertOnly ( ) ) { return new SettingsPopulation ( new SequentialOptions ( defaultLimit ) ) ; } switch ( command . type ) { case WRITE : case COUNTER_WRITE : return new SettingsPopulation ( new SequentialOptions ( defaultLimit ) ) ; default : return new SettingsPopulation ( new DistributionOptions ( defaultLimit ) ) ; } } GroupedOptions options = GroupedOptions . select ( params , new SequentialOptions ( defaultLimit ) , new DistributionOptions ( defaultLimit ) ) ; if ( options = = null ) { printHelp ( ) ; System . out . println ( <str> ) ; System . exit ( <int> ) ; } return options instanceof SequentialOptions ? new SettingsPopulation ( ( SequentialOptions ) options ) : new SettingsPopulation ( ( DistributionOptions ) options ) ; } public static void printHelp ( ) { GroupedOptions . printOptions ( System . out , <str> , new SequentialOptions ( <str> ) , new DistributionOptions ( <str> ) ) ; } public static Runnable helpPrinter ( ) { return new Runnable ( ) { @Override public void run ( ) { printHelp ( ) ; } } ; } } 
