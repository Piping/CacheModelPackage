package org . elasticsearch . search . aggregations . bucket . terms ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . search . aggregations . Aggregator ; import org . elasticsearch . search . aggregations . InternalMultiBucketAggregation ; import org . elasticsearch . search . aggregations . bucket . MultiBucketsAggregation ; import java . util . Arrays ; import java . util . Comparator ; import java . util . List ; public interface Terms extends MultiBucketsAggregation { static enum ValueType { STRING ( org . elasticsearch . search . aggregations . support . ValueType . STRING ) , LONG ( org . elasticsearch . search . aggregations . support . ValueType . LONG ) , DOUBLE ( org . elasticsearch . search . aggregations . support . ValueType . DOUBLE ) ; final org . elasticsearch . search . aggregations . support . ValueType scriptValueType ; private ValueType ( org . elasticsearch . search . aggregations . support . ValueType scriptValueType ) { this . scriptValueType = scriptValueType ; } static ValueType resolveType ( String type ) { if ( <str> . equals ( type ) ) { return STRING ; } if ( <str> . equals ( type ) | | <str> . equals ( type ) ) { return DOUBLE ; } if ( <str> . equals ( type ) | | <str> . equals ( type ) | | <str> . equals ( type ) | | <str> . equals ( type ) ) { return LONG ; } return null ; } } static abstract class Bucket extends InternalMultiBucketAggregation . InternalBucket { public abstract Number getKeyAsNumber ( ) ; abstract int compareTerm ( Terms . Bucket other ) ; public abstract long getDocCountError ( ) ; } @Override List < Bucket > getBuckets ( ) ; Bucket getBucketByKey ( String term ) ; long getDocCountError ( ) ; long getSumOfOtherDocCounts ( ) ; static abstract class Order implements ToXContent { public static Order count ( boolean asc ) { return asc ? InternalOrder . COUNT_ASC : InternalOrder . COUNT_DESC ; } public static Order term ( boolean asc ) { return asc ? InternalOrder . TERM_ASC : InternalOrder . TERM_DESC ; } public static Order aggregation ( String path , boolean asc ) { return new InternalOrder . Aggregation ( path , asc ) ; } public static Order aggregation ( String aggregationName , String metricName , boolean asc ) { return new InternalOrder . Aggregation ( aggregationName + <str> + metricName , asc ) ; } public static Order compound ( List < Order > orders ) { return new InternalOrder . CompoundOrder ( orders ) ; } public static Order compound ( Order . . . orders ) { return compound ( Arrays . asList ( orders ) ) ; } protected abstract Comparator < Bucket > comparator ( Aggregator aggregator ) ; abstract byte id ( ) ; } } 
