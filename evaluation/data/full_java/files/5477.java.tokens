package org . elasticsearch . bootstrap ; import org . apache . lucene . util . Constants ; import org . apache . lucene . util . StringHelper ; import org . elasticsearch . Version ; import org . elasticsearch . common . PidFile ; import org . elasticsearch . common . SuppressForbidden ; import org . elasticsearch . common . cli . CliTool ; import org . elasticsearch . common . cli . Terminal ; import org . elasticsearch . common . inject . CreationException ; import org . elasticsearch . common . lease . Releasables ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . logging . log4j . LogConfigurator ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . monitor . jvm . JvmInfo ; import org . elasticsearch . monitor . os . OsProbe ; import org . elasticsearch . monitor . process . ProcessProbe ; import org . elasticsearch . node . Node ; import org . elasticsearch . node . internal . InternalSettingsPreparer ; import java . io . ByteArrayOutputStream ; import java . io . PrintStream ; import java . nio . file . Path ; import java . util . Locale ; import java . util . concurrent . CountDownLatch ; import static org . elasticsearch . common . settings . Settings . Builder . EMPTY_SETTINGS ; final class Bootstrap { private static volatile Bootstrap INSTANCE ; private volatile Node node ; private final CountDownLatch keepAliveLatch = new CountDownLatch ( <int> ) ; private final Thread keepAliveThread ; Bootstrap ( ) { keepAliveThread = new Thread ( new Runnable ( ) { @Override public void run ( ) { try { keepAliveLatch . await ( ) ; } catch ( InterruptedException e ) { } } } , <str> + Version . CURRENT + <str> ) ; keepAliveThread . setDaemon ( false ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { @Override public void run ( ) { keepAliveLatch . countDown ( ) ; } } ) ; } public static void initializeNatives ( Path tmpFile , boolean mlockAll , boolean seccomp , boolean ctrlHandler ) { final ESLogger logger = Loggers . getLogger ( Bootstrap . class ) ; if ( Natives . definitelyRunningAsRoot ( ) ) { if ( Boolean . parseBoolean ( System . getProperty ( <str> ) ) ) { logger . warn ( <str> ) ; } else { throw new RuntimeException ( <str> ) ; } } if ( seccomp ) { Natives . trySeccomp ( tmpFile ) ; } if ( mlockAll ) { if ( Constants . WINDOWS ) { Natives . tryVirtualLock ( ) ; } else { Natives . tryMlockall ( ) ; } } if ( ctrlHandler ) { Natives . addConsoleCtrlHandler ( new ConsoleCtrlHandler ( ) { @Override public boolean handle ( int code ) { if ( CTRL_CLOSE_EVENT = = code ) { logger . info ( <str> ) ; Bootstrap . stop ( ) ; return true ; } return false ; } } ) ; } try { JNAKernel32Library . getInstance ( ) ; } catch ( Throwable ignored ) { } StringHelper . randomId ( ) ; } static void initializeProbes ( ) { ProcessProbe . getInstance ( ) ; OsProbe . getInstance ( ) ; JvmInfo . jvmInfo ( ) ; } private void setup ( boolean addShutdownHook , Settings settings , Environment environment ) throws Exception { initializeNatives ( environment . tmpFile ( ) , settings . getAsBoolean ( <str> , false ) , settings . getAsBoolean ( <str> , true ) , settings . getAsBoolean ( <str> , true ) ) ; initializeProbes ( ) ; if ( addShutdownHook ) { Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { @Override public void run ( ) { if ( node ! = null ) { node . close ( ) ; } } } ) ; } JarHell . checkJarHell ( ) ; setupSecurity ( settings , environment ) ; Settings nodeSettings = Settings . settingsBuilder ( ) . put ( settings ) . put ( InternalSettingsPreparer . IGNORE_SYSTEM_PROPERTIES_SETTING , true ) . build ( ) ; node = new Node ( nodeSettings ) ; } static final String SECURITY_SETTING = <str> ; static final String SECURITY_FILTER_BAD_DEFAULTS_SETTING = <str> ; private void setupSecurity ( Settings settings , Environment environment ) throws Exception { if ( settings . getAsBoolean ( SECURITY_SETTING , true ) ) { Security . configure ( environment , settings . getAsBoolean ( SECURITY_FILTER_BAD_DEFAULTS_SETTING , true ) ) ; } } @SuppressForbidden ( reason = <str> ) private static void setupLogging ( Settings settings , Environment environment ) { try { Class . forName ( <str> ) ; LogConfigurator . configure ( settings , true ) ; } catch ( ClassNotFoundException e ) { } catch ( NoClassDefFoundError e ) { } catch ( Exception e ) { sysError ( <str> , false ) ; e . printStackTrace ( ) ; } } private static Environment initialSettings ( boolean foreground ) { Terminal terminal = foreground ? Terminal . DEFAULT : null ; return InternalSettingsPreparer . prepareEnvironment ( EMPTY_SETTINGS , terminal ) ; } private void start ( ) { node . start ( ) ; keepAliveThread . start ( ) ; } static void stop ( ) { try { Releasables . close ( INSTANCE . node ) ; } finally { INSTANCE . keepAliveLatch . countDown ( ) ; } } @SuppressForbidden ( reason = <str> ) static void initLoggerPrefix ( ) { System . setProperty ( <str> , <str> ) ; } static void init ( String [ ] args ) throws Throwable { initLoggerPrefix ( ) ; BootstrapCLIParser bootstrapCLIParser = new BootstrapCLIParser ( ) ; CliTool . ExitStatus status = bootstrapCLIParser . execute ( args ) ; if ( CliTool . ExitStatus . OK ! = status ) { exit ( status . status ( ) ) ; } INSTANCE = new Bootstrap ( ) ; boolean foreground = ! <str> . equals ( System . getProperty ( <str> , System . getProperty ( <str> ) ) ) ; if ( System . getProperty ( <str> , <str> ) . equalsIgnoreCase ( <str> ) ) { foreground = false ; } Environment environment = initialSettings ( foreground ) ; Settings settings = environment . settings ( ) ; setupLogging ( settings , environment ) ; checkForCustomConfFile ( ) ; if ( environment . pidFile ( ) ! = null ) { PidFile . create ( environment . pidFile ( ) , true ) ; } if ( System . getProperty ( <str> , <str> ) . equals ( <str> ) ) { ESLogger logger = Loggers . getLogger ( Bootstrap . class ) ; logger . info ( <str> , ProcessProbe . getInstance ( ) . getMaxFileDescriptorCount ( ) ) ; } if ( JvmInfo . jvmInfo ( ) . getVmName ( ) . toLowerCase ( Locale . ROOT ) . contains ( <str> ) ) { ESLogger logger = Loggers . getLogger ( Bootstrap . class ) ; logger . warn ( <str> ) ; } try { if ( ! foreground ) { Loggers . disableConsoleLogging ( ) ; closeSystOut ( ) ; } JVMCheck . check ( ) ; INSTANCE . setup ( true , settings , environment ) ; INSTANCE . start ( ) ; if ( ! foreground ) { closeSysError ( ) ; } } catch ( Throwable e ) { if ( foreground ) { Loggers . disableConsoleLogging ( ) ; } ESLogger logger = Loggers . getLogger ( Bootstrap . class ) ; if ( INSTANCE . node ! = null ) { logger = Loggers . getLogger ( Bootstrap . class , INSTANCE . node . settings ( ) . get ( <str> ) ) ; } if ( e instanceof CreationException ) { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( os , false , <str> ) ; new StartupError ( e ) . printStackTrace ( ps ) ; ps . flush ( ) ; logger . error ( <str> , os . toString ( <str> ) ) ; } else { logger . error ( <str> , e ) ; } if ( foreground ) { Loggers . enableConsoleLogging ( ) ; } throw e ; } } @SuppressForbidden ( reason = <str> ) private static void closeSystOut ( ) { System . out . close ( ) ; } @SuppressForbidden ( reason = <str> ) private static void closeSysError ( ) { System . err . close ( ) ; } @SuppressForbidden ( reason = <str> ) private static void sysError ( String line , boolean flush ) { System . err . println ( line ) ; if ( flush ) { System . err . flush ( ) ; } } private static void checkForCustomConfFile ( ) { String confFileSetting = System . getProperty ( <str> ) ; checkUnsetAndMaybeExit ( confFileSetting , <str> ) ; confFileSetting = System . getProperty ( <str> ) ; checkUnsetAndMaybeExit ( confFileSetting , <str> ) ; confFileSetting = System . getProperty ( <str> ) ; checkUnsetAndMaybeExit ( confFileSetting , <str> ) ; } private static void checkUnsetAndMaybeExit ( String confFileSetting , String settingName ) { if ( confFileSetting ! = null & & confFileSetting . isEmpty ( ) = = false ) { ESLogger logger = Loggers . getLogger ( Bootstrap . class ) ; logger . info ( <str> , settingName ) ; exit ( <int> ) ; } } @SuppressForbidden ( reason = <str> ) private static void exit ( int status ) { System . exit ( status ) ; } } 
