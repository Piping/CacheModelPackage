package io . netty . handler . codec . compression ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . CompositeByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import org . junit . Before ; import org . junit . Test ; import static io . netty . util . ReferenceCountUtil . * ; import static org . junit . Assert . * ; public class SnappyFrameEncoderTest { private EmbeddedChannel channel ; @Before public void setUp ( ) { channel = new EmbeddedChannel ( new SnappyFrameEncoder ( ) ) ; } @Test public void testSmallAmountOfDataIsUncompressed ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> , <str> , <str> } ) ; channel . writeOutbound ( in ) ; assertTrue ( channel . finish ( ) ) ; ByteBuf expected = Unpooled . wrappedBuffer ( new byte [ ] { ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , - <hex> , - <hex> , - <hex> , <str> , <str> , <str> , <str> , <str> } ) ; assertEquals ( releaseLater ( expected ) , releaseLater ( channel . readOutbound ( ) ) ) ; } @Test public void testLargeAmountOfDataIsCompressed ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ) ; channel . writeOutbound ( in ) ; assertTrue ( channel . finish ( ) ) ; ByteBuf expected = Unpooled . wrappedBuffer ( new byte [ ] { ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , - <hex> , <hex> , <hex> , <hex> , <str> , <str> , <str> , <str> , <str> , <hex> , <hex> , <hex> } ) ; assertEquals ( releaseLater ( expected ) , releaseLater ( channel . readOutbound ( ) ) ) ; } @Test public void testStreamStartIsOnlyWrittenOnce ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <str> , <str> , <str> , <str> , <str> } ) ; channel . writeOutbound ( in . retain ( ) ) ; in . resetReaderIndex ( ) ; channel . writeOutbound ( in ) ; assertTrue ( channel . finish ( ) ) ; ByteBuf expected = Unpooled . wrappedBuffer ( new byte [ ] { ( byte ) <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , <hex> , - <hex> , - <hex> , - <hex> , <str> , <str> , <str> , <str> , <str> , <hex> , <hex> , <hex> , <hex> , <hex> , - <hex> , - <hex> , - <hex> , <str> , <str> , <str> , <str> , <str> , } ) ; CompositeByteBuf actual = Unpooled . compositeBuffer ( ) ; for ( ; ; ) { ByteBuf m = channel . readOutbound ( ) ; if ( m = = null ) { break ; } actual . addComponent ( m ) ; actual . writerIndex ( actual . writerIndex ( ) + m . readableBytes ( ) ) ; } assertEquals ( releaseLater ( expected ) , releaseLater ( actual ) ) ; } @Test public void testInputBufferOverseek ( ) throws Exception { ByteBuf in = Unpooled . wrappedBuffer ( new byte [ ] { <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> , - <int> , <int> , - <int> , <int> , - <int> , - <int> , <int> , <int> , <int> , - <int> , <int> , - <int> , <int> , - <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , <int> , - <int> , <int> , - <int> , <int> , <int> , <int> , <int> , <int> , - <int> , <int> , <int> , - <int> , - <int> , <int> , - <int> , - <int> , - <int> , <int> , <int> , - <int> , - <int> , <int> , <int> , - <int> , <int> , <int> , - <int> , - <int> , <int> , - <int> , <int> , - <int> , <int> , <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , <int> , - <int> , - <int> , <int> , - <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , - <int> , - <int> , - <int> , <int> , - <int> , - <int> , <int> , <int> , - <int> , <int> , <int> , - <int> , <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , - <int> , - <int> , <int> , <int> , - <int> , <int> , - <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , - <int> , <int> , - <int> , <int> , - <int> , - <int> , - <int> , - <int> , <int> , <int> , <int> , <int> , <int> , - <int> , <int> , <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , - <int> , <int> } ) ; channel . writeOutbound ( in ) ; assertTrue ( channel . finish ( ) ) ; ByteBuf out = channel . readOutbound ( ) ; out . release ( ) ; } } 
