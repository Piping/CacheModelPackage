package io . netty . handler . ssl ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . Unpooled ; import io . netty . util . internal . EmptyArrays ; import io . netty . util . internal . PlatformDependent ; import io . netty . util . internal . StringUtil ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import org . apache . tomcat . jni . Buffer ; import org . apache . tomcat . jni . SSL ; import javax . net . ssl . SSLEngine ; import javax . net . ssl . SSLEngineResult ; import javax . net . ssl . SSLEngineResult . HandshakeStatus ; import javax . net . ssl . SSLException ; import javax . net . ssl . SSLHandshakeException ; import javax . net . ssl . SSLParameters ; import javax . net . ssl . SSLPeerUnverifiedException ; import javax . net . ssl . SSLSession ; import javax . net . ssl . SSLSessionBindingEvent ; import javax . net . ssl . SSLSessionBindingListener ; import javax . net . ssl . SSLSessionContext ; import javax . security . cert . X509Certificate ; import java . nio . ByteBuffer ; import java . nio . ReadOnlyBufferException ; import java . security . Principal ; import java . security . cert . Certificate ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . Map ; import java . util . Set ; import java . util . concurrent . atomic . AtomicIntegerFieldUpdater ; import static io . netty . handler . ssl . ApplicationProtocolConfig . SelectedListenerFailureBehavior ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; import static javax . net . ssl . SSLEngineResult . HandshakeStatus . * ; import static javax . net . ssl . SSLEngineResult . Status . * ; public final class OpenSslEngine extends SSLEngine { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( OpenSslEngine . class ) ; private static final Certificate [ ] EMPTY_CERTIFICATES = EmptyArrays . EMPTY_CERTIFICATES ; private static final X509Certificate [ ] EMPTY_X509_CERTIFICATES = EmptyArrays . EMPTY_JAVAX_X509_CERTIFICATES ; private static final SSLException ENGINE_CLOSED = new SSLException ( <str> ) ; private static final SSLException RENEGOTIATION_UNSUPPORTED = new SSLException ( <str> ) ; private static final SSLException ENCRYPTED_PACKET_OVERSIZED = new SSLException ( <str> ) ; static { ENGINE_CLOSED . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; RENEGOTIATION_UNSUPPORTED . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; ENCRYPTED_PACKET_OVERSIZED . setStackTrace ( EmptyArrays . EMPTY_STACK_TRACE ) ; AtomicIntegerFieldUpdater < OpenSslEngine > destroyedUpdater = PlatformDependent . newAtomicIntegerFieldUpdater ( OpenSslEngine . class , <str> ) ; if ( destroyedUpdater = = null ) { destroyedUpdater = AtomicIntegerFieldUpdater . newUpdater ( OpenSslEngine . class , <str> ) ; } DESTROYED_UPDATER = destroyedUpdater ; } private static final int MAX_PLAINTEXT_LENGTH = <int> * <int> ; private static final int MAX_COMPRESSED_LENGTH = MAX_PLAINTEXT_LENGTH + <int> ; private static final int MAX_CIPHERTEXT_LENGTH = MAX_COMPRESSED_LENGTH + <int> ; private static final String PROTOCOL_SSL_V2_HELLO = <str> ; private static final String PROTOCOL_SSL_V2 = <str> ; private static final String PROTOCOL_SSL_V3 = <str> ; private static final String PROTOCOL_TLS_V1 = <str> ; private static final String PROTOCOL_TLS_V1_1 = <str> ; private static final String PROTOCOL_TLS_V1_2 = <str> ; private static final String [ ] SUPPORTED_PROTOCOLS = { PROTOCOL_SSL_V2_HELLO , PROTOCOL_SSL_V2 , PROTOCOL_SSL_V3 , PROTOCOL_TLS_V1 , PROTOCOL_TLS_V1_1 , PROTOCOL_TLS_V1_2 } ; private static final Set < String > SUPPORTED_PROTOCOLS_SET = new HashSet < String > ( Arrays . asList ( SUPPORTED_PROTOCOLS ) ) ; static final int MAX_ENCRYPTED_PACKET_LENGTH = MAX_CIPHERTEXT_LENGTH + <int> + <int> + <int> ; static final int MAX_ENCRYPTION_OVERHEAD_LENGTH = MAX_ENCRYPTED_PACKET_LENGTH - MAX_PLAINTEXT_LENGTH ; private static final AtomicIntegerFieldUpdater < OpenSslEngine > DESTROYED_UPDATER ; private static final String INVALID_CIPHER = <str> ; private static final long EMPTY_ADDR = Buffer . address ( Unpooled . EMPTY_BUFFER . nioBuffer ( ) ) ; private static final SSLEngineResult NEED_UNWRAP_OK = new SSLEngineResult ( OK , NEED_UNWRAP , <int> , <int> ) ; private static final SSLEngineResult NEED_UNWRAP_CLOSED = new SSLEngineResult ( CLOSED , NEED_UNWRAP , <int> , <int> ) ; private static final SSLEngineResult NEED_WRAP_OK = new SSLEngineResult ( OK , NEED_WRAP , <int> , <int> ) ; private static final SSLEngineResult NEED_WRAP_CLOSED = new SSLEngineResult ( CLOSED , NEED_WRAP , <int> , <int> ) ; private static final SSLEngineResult CLOSED_NOT_HANDSHAKING = new SSLEngineResult ( CLOSED , NOT_HANDSHAKING , <int> , <int> ) ; private long ssl ; private long networkBIO ; private enum HandshakeState { NOT_STARTED , STARTED_IMPLICITLY , STARTED_EXPLICITLY , FINISHED } private HandshakeState handshakeState = HandshakeState . NOT_STARTED ; private boolean receivedShutdown ; @SuppressWarnings ( <str> ) private volatile int destroyed ; private volatile ClientAuth clientAuth = ClientAuth . NONE ; private volatile String endPointIdentificationAlgorithm ; private volatile Object algorithmConstraints ; private boolean isInboundDone ; private boolean isOutboundDone ; private boolean engineClosed ; private final boolean clientMode ; private final ByteBufAllocator alloc ; private final OpenSslEngineMap engineMap ; private final OpenSslApplicationProtocolNegotiator apn ; private final boolean rejectRemoteInitiatedRenegation ; private final OpenSslSession session ; private final java . security . cert . Certificate [ ] localCerts ; private final ByteBuffer [ ] singleSrcBuffer = new ByteBuffer [ <int> ] ; private final ByteBuffer [ ] singleDstBuffer = new ByteBuffer [ <int> ] ; SSLHandshakeException handshakeException ; @Deprecated public OpenSslEngine ( long sslCtx , ByteBufAllocator alloc , @SuppressWarnings ( <str> ) String fallbackApplicationProtocol ) { this ( sslCtx , alloc , false , null , OpenSslContext . NONE_PROTOCOL_NEGOTIATOR , OpenSslEngineMap . EMPTY , false , ClientAuth . NONE ) ; } OpenSslEngine ( long sslCtx , ByteBufAllocator alloc , boolean clientMode , OpenSslSessionContext sessionContext , OpenSslApplicationProtocolNegotiator apn , OpenSslEngineMap engineMap , boolean rejectRemoteInitiatedRenegation , ClientAuth clientAuth ) { this ( sslCtx , alloc , clientMode , sessionContext , apn , engineMap , rejectRemoteInitiatedRenegation , null , - <int> , null , clientAuth ) ; } OpenSslEngine ( long sslCtx , ByteBufAllocator alloc , boolean clientMode , OpenSslSessionContext sessionContext , OpenSslApplicationProtocolNegotiator apn , OpenSslEngineMap engineMap , boolean rejectRemoteInitiatedRenegation , String peerHost , int peerPort , java . security . cert . Certificate [ ] localCerts , ClientAuth clientAuth ) { super ( peerHost , peerPort ) ; OpenSsl . ensureAvailability ( ) ; if ( sslCtx = = <int> ) { throw new NullPointerException ( <str> ) ; } this . alloc = checkNotNull ( alloc , <str> ) ; this . apn = checkNotNull ( apn , <str> ) ; this . clientAuth = clientMode ? ClientAuth . NONE : checkNotNull ( clientAuth , <str> ) ; ssl = SSL . newSSL ( sslCtx , ! clientMode ) ; session = new OpenSslSession ( sessionContext ) ; networkBIO = SSL . makeNetworkBIO ( ssl ) ; this . clientMode = clientMode ; this . engineMap = engineMap ; this . rejectRemoteInitiatedRenegation = rejectRemoteInitiatedRenegation ; this . localCerts = localCerts ; } @Override public SSLSession getHandshakeSession ( ) { if ( handshakeState ! = HandshakeState . NOT_STARTED ) { return session ; } return null ; } public synchronized long sslPointer ( ) { return ssl ; } public synchronized void shutdown ( ) { if ( DESTROYED_UPDATER . compareAndSet ( this , <int> , <int> ) ) { engineMap . remove ( ssl ) ; SSL . freeSSL ( ssl ) ; SSL . freeBIO ( networkBIO ) ; ssl = networkBIO = <int> ; isInboundDone = isOutboundDone = engineClosed = true ; } SSL . clearError ( ) ; } private int writePlaintextData ( final ByteBuffer src ) { final int pos = src . position ( ) ; final int limit = src . limit ( ) ; final int len = Math . min ( limit - pos , MAX_PLAINTEXT_LENGTH ) ; final int sslWrote ; if ( src . isDirect ( ) ) { final long addr = Buffer . address ( src ) + pos ; sslWrote = SSL . writeToSSL ( ssl , addr , len ) ; if ( sslWrote > <int> ) { src . position ( pos + sslWrote ) ; } } else { ByteBuf buf = alloc . directBuffer ( len ) ; try { final long addr = memoryAddress ( buf ) ; src . limit ( pos + len ) ; buf . setBytes ( <int> , src ) ; src . limit ( limit ) ; sslWrote = SSL . writeToSSL ( ssl , addr , len ) ; if ( sslWrote > <int> ) { src . position ( pos + sslWrote ) ; } else { src . position ( pos ) ; } } finally { buf . release ( ) ; } } return sslWrote ; } private int writeEncryptedData ( final ByteBuffer src ) { final int pos = src . position ( ) ; final int len = src . remaining ( ) ; final int netWrote ; if ( src . isDirect ( ) ) { final long addr = Buffer . address ( src ) + pos ; netWrote = SSL . writeToBIO ( networkBIO , addr , len ) ; if ( netWrote > = <int> ) { src . position ( pos + netWrote ) ; } } else { final ByteBuf buf = alloc . directBuffer ( len ) ; try { final long addr = memoryAddress ( buf ) ; buf . setBytes ( <int> , src ) ; netWrote = SSL . writeToBIO ( networkBIO , addr , len ) ; if ( netWrote > = <int> ) { src . position ( pos + netWrote ) ; } else { src . position ( pos ) ; } } finally { buf . release ( ) ; } } return netWrote ; } private int readPlaintextData ( final ByteBuffer dst ) { final int sslRead ; if ( dst . isDirect ( ) ) { final int pos = dst . position ( ) ; final long addr = Buffer . address ( dst ) + pos ; final int len = dst . limit ( ) - pos ; sslRead = SSL . readFromSSL ( ssl , addr , len ) ; if ( sslRead > <int> ) { dst . position ( pos + sslRead ) ; } } else { final int pos = dst . position ( ) ; final int limit = dst . limit ( ) ; final int len = Math . min ( MAX_ENCRYPTED_PACKET_LENGTH , limit - pos ) ; final ByteBuf buf = alloc . directBuffer ( len ) ; try { final long addr = memoryAddress ( buf ) ; sslRead = SSL . readFromSSL ( ssl , addr , len ) ; if ( sslRead > <int> ) { dst . limit ( pos + sslRead ) ; buf . getBytes ( <int> , dst ) ; dst . limit ( limit ) ; } } finally { buf . release ( ) ; } } return sslRead ; } private int readEncryptedData ( final ByteBuffer dst , final int pending ) { final int bioRead ; if ( dst . isDirect ( ) & & dst . remaining ( ) > = pending ) { final int pos = dst . position ( ) ; final long addr = Buffer . address ( dst ) + pos ; bioRead = SSL . readFromBIO ( networkBIO , addr , pending ) ; if ( bioRead > <int> ) { dst . position ( pos + bioRead ) ; return bioRead ; } } else { final ByteBuf buf = alloc . directBuffer ( pending ) ; try { final long addr = memoryAddress ( buf ) ; bioRead = SSL . readFromBIO ( networkBIO , addr , pending ) ; if ( bioRead > <int> ) { int oldLimit = dst . limit ( ) ; dst . limit ( dst . position ( ) + bioRead ) ; buf . getBytes ( <int> , dst ) ; dst . limit ( oldLimit ) ; return bioRead ; } } finally { buf . release ( ) ; } } return bioRead ; } private SSLEngineResult readPendingBytesFromBIO ( ByteBuffer dst , int bytesConsumed , int bytesProduced , HandshakeStatus status ) throws SSLException { int pendingNet = SSL . pendingWrittenBytesInBIO ( networkBIO ) ; if ( pendingNet > <int> ) { int capacity = dst . remaining ( ) ; if ( capacity < pendingNet ) { return new SSLEngineResult ( BUFFER_OVERFLOW , mayFinishHandshake ( status ! = FINISHED ? getHandshakeStatus ( pendingNet ) : status ) , bytesConsumed , bytesProduced ) ; } int produced = readEncryptedData ( dst , pendingNet ) ; if ( produced < = <int> ) { SSL . clearError ( ) ; } else { bytesProduced + = produced ; pendingNet - = produced ; } if ( isOutboundDone ) { shutdown ( ) ; } return new SSLEngineResult ( getEngineStatus ( ) , mayFinishHandshake ( status ! = FINISHED ? getHandshakeStatus ( pendingNet ) : status ) , bytesConsumed , bytesProduced ) ; } return null ; } @Override public synchronized SSLEngineResult wrap ( final ByteBuffer [ ] srcs , final int offset , final int length , final ByteBuffer dst ) throws SSLException { if ( isDestroyed ( ) ) { return CLOSED_NOT_HANDSHAKING ; } if ( srcs = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( dst = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( offset > = srcs . length | | offset + length > srcs . length ) { throw new IndexOutOfBoundsException ( <str> + offset + <str> + length + <str> + srcs . length + <str> ) ; } if ( dst . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } HandshakeStatus status = NOT_HANDSHAKING ; if ( handshakeState ! = HandshakeState . FINISHED ) { if ( handshakeState ! = HandshakeState . STARTED_EXPLICITLY ) { handshakeState = HandshakeState . STARTED_IMPLICITLY ; } status = handshake ( ) ; if ( status = = NEED_UNWRAP ) { return NEED_UNWRAP_OK ; } if ( engineClosed ) { return NEED_UNWRAP_CLOSED ; } } int bytesProduced = <int> ; int bytesConsumed = <int> ; int endOffset = offset + length ; for ( int i = offset ; i < endOffset ; + + i ) { final ByteBuffer src = srcs [ i ] ; if ( src = = null ) { throw new IllegalArgumentException ( <str> + i + <str> ) ; } while ( src . hasRemaining ( ) ) { int result = writePlaintextData ( src ) ; if ( result > <int> ) { bytesConsumed + = result ; } else { int sslError = SSL . getError ( ssl , result ) ; switch ( sslError ) { case SSL . SSL_ERROR_ZERO_RETURN : if ( ! receivedShutdown ) { closeAll ( ) ; } case SSL . SSL_ERROR_WANT_READ : case SSL . SSL_ERROR_WANT_WRITE : break ; default : shutdownWithError ( <str> ) ; } } SSLEngineResult pendingNetResult = readPendingBytesFromBIO ( dst , bytesConsumed , bytesProduced , status ) ; if ( pendingNetResult ! = null ) { return pendingNetResult ; } } } if ( bytesConsumed = = <int> ) { SSLEngineResult pendingNetResult = readPendingBytesFromBIO ( dst , <int> , bytesProduced , status ) ; if ( pendingNetResult ! = null ) { return pendingNetResult ; } } return newResult ( bytesConsumed , bytesProduced , status ) ; } private void checkPendingHandshakeException ( ) throws SSLHandshakeException { if ( handshakeException ! = null ) { SSLHandshakeException exception = handshakeException ; handshakeException = null ; shutdown ( ) ; throw exception ; } } private void shutdownWithError ( String operations ) throws SSLException { String err = SSL . getLastError ( ) ; shutdownWithError ( operations , err ) ; } private void shutdownWithError ( String operation , String err ) throws SSLException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , operation , err ) ; } shutdown ( ) ; if ( handshakeState = = HandshakeState . FINISHED ) { throw new SSLException ( err ) ; } throw new SSLHandshakeException ( err ) ; } public synchronized SSLEngineResult unwrap ( final ByteBuffer [ ] srcs , int srcsOffset , final int srcsLength , final ByteBuffer [ ] dsts , final int dstsOffset , final int dstsLength ) throws SSLException { if ( isDestroyed ( ) ) { return CLOSED_NOT_HANDSHAKING ; } if ( srcs = = null ) { throw new NullPointerException ( <str> ) ; } if ( srcsOffset > = srcs . length | | srcsOffset + srcsLength > srcs . length ) { throw new IndexOutOfBoundsException ( <str> + srcsOffset + <str> + srcsLength + <str> + srcs . length + <str> ) ; } if ( dsts = = null ) { throw new IllegalArgumentException ( <str> ) ; } if ( dstsOffset > = dsts . length | | dstsOffset + dstsLength > dsts . length ) { throw new IndexOutOfBoundsException ( <str> + dstsOffset + <str> + dstsLength + <str> + dsts . length + <str> ) ; } long capacity = <int> ; final int endOffset = dstsOffset + dstsLength ; for ( int i = dstsOffset ; i < endOffset ; i + + ) { ByteBuffer dst = dsts [ i ] ; if ( dst = = null ) { throw new IllegalArgumentException ( <str> + i + <str> ) ; } if ( dst . isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } capacity + = dst . remaining ( ) ; } HandshakeStatus status = NOT_HANDSHAKING ; if ( handshakeState ! = HandshakeState . FINISHED ) { if ( handshakeState ! = HandshakeState . STARTED_EXPLICITLY ) { handshakeState = HandshakeState . STARTED_IMPLICITLY ; } status = handshake ( ) ; if ( status = = NEED_WRAP ) { return NEED_WRAP_OK ; } if ( engineClosed ) { return NEED_WRAP_CLOSED ; } } final int srcsEndOffset = srcsOffset + srcsLength ; long len = <int> ; for ( int i = srcsOffset ; i < srcsEndOffset ; i + + ) { ByteBuffer src = srcs [ i ] ; if ( src = = null ) { throw new IllegalArgumentException ( <str> + i + <str> ) ; } len + = src . remaining ( ) ; } if ( len > MAX_ENCRYPTED_PACKET_LENGTH ) { isInboundDone = true ; isOutboundDone = true ; engineClosed = true ; shutdown ( ) ; throw ENCRYPTED_PACKET_OVERSIZED ; } int bytesConsumed = <int> ; if ( srcsOffset < srcsEndOffset ) { do { ByteBuffer src = srcs [ srcsOffset ] ; int remaining = src . remaining ( ) ; if ( remaining = = <int> ) { srcsOffset + + ; continue ; } int written = writeEncryptedData ( src ) ; if ( written > <int> ) { bytesConsumed + = written ; if ( written = = remaining ) { srcsOffset + + ; } else { break ; } } else { SSL . clearError ( ) ; break ; } } while ( srcsOffset < srcsEndOffset ) ; } rejectRemoteInitiatedRenegation ( ) ; int bytesProduced = <int> ; if ( capacity > <int> ) { int idx = dstsOffset ; while ( idx < endOffset ) { ByteBuffer dst = dsts [ idx ] ; if ( ! dst . hasRemaining ( ) ) { idx + + ; continue ; } int bytesRead = readPlaintextData ( dst ) ; rejectRemoteInitiatedRenegation ( ) ; if ( bytesRead > <int> ) { bytesProduced + = bytesRead ; if ( ! dst . hasRemaining ( ) ) { idx + + ; } else { return newResult ( bytesConsumed , bytesProduced , status ) ; } } else { int sslError = SSL . getError ( ssl , bytesRead ) ; switch ( sslError ) { case SSL . SSL_ERROR_ZERO_RETURN : if ( ! receivedShutdown ) { closeAll ( ) ; } case SSL . SSL_ERROR_WANT_READ : case SSL . SSL_ERROR_WANT_WRITE : return newResult ( bytesConsumed , bytesProduced , status ) ; default : shutdownWithError ( <str> ) ; } } } } else { if ( SSL . readFromSSL ( ssl , EMPTY_ADDR , <int> ) < = <int> ) { int err = SSL . getLastErrorNumber ( ) ; if ( OpenSsl . isError ( err ) ) { shutdownWithError ( <str> , SSL . getErrorString ( err ) ) ; } } } if ( pendingAppData ( ) > <int> ) { return new SSLEngineResult ( BUFFER_OVERFLOW , mayFinishHandshake ( status ! = FINISHED ? getHandshakeStatus ( ) : status ) , bytesConsumed , bytesProduced ) ; } if ( ! receivedShutdown & & ( SSL . getShutdown ( ssl ) & SSL . SSL_RECEIVED_SHUTDOWN ) = = SSL . SSL_RECEIVED_SHUTDOWN ) { closeAll ( ) ; } return newResult ( bytesConsumed , bytesProduced , status ) ; } private int pendingAppData ( ) { return handshakeState = = HandshakeState . FINISHED ? SSL . pendingReadableBytesInSSL ( ssl ) : <int> ; } private SSLEngineResult newResult ( int bytesConsumed , int bytesProduced , HandshakeStatus status ) throws SSLException { return new SSLEngineResult ( getEngineStatus ( ) , mayFinishHandshake ( status ! = FINISHED ? getHandshakeStatus ( ) : status ) , bytesConsumed , bytesProduced ) ; } private void closeAll ( ) throws SSLException { receivedShutdown = true ; closeOutbound ( ) ; closeInbound ( ) ; } private void rejectRemoteInitiatedRenegation ( ) throws SSLHandshakeException { if ( rejectRemoteInitiatedRenegation & & SSL . getHandshakeCount ( ssl ) > <int> ) { shutdown ( ) ; throw new SSLHandshakeException ( <str> ) ; } } public SSLEngineResult unwrap ( final ByteBuffer [ ] srcs , final ByteBuffer [ ] dsts ) throws SSLException { return unwrap ( srcs , <int> , srcs . length , dsts , <int> , dsts . length ) ; } private ByteBuffer [ ] singleSrcBuffer ( ByteBuffer src ) { singleSrcBuffer [ <int> ] = src ; return singleSrcBuffer ; } private void resetSingleSrcBuffer ( ) { singleSrcBuffer [ <int> ] = null ; } private ByteBuffer [ ] singleDstBuffer ( ByteBuffer src ) { singleDstBuffer [ <int> ] = src ; return singleDstBuffer ; } private void resetSingleDstBuffer ( ) { singleDstBuffer [ <int> ] = null ; } @Override public synchronized SSLEngineResult unwrap ( final ByteBuffer src , final ByteBuffer [ ] dsts , final int offset , final int length ) throws SSLException { try { return unwrap ( singleSrcBuffer ( src ) , <int> , <int> , dsts , offset , length ) ; } finally { resetSingleSrcBuffer ( ) ; } } @Override public synchronized SSLEngineResult wrap ( ByteBuffer src , ByteBuffer dst ) throws SSLException { try { return wrap ( singleSrcBuffer ( src ) , dst ) ; } finally { resetSingleSrcBuffer ( ) ; } } @Override public synchronized SSLEngineResult unwrap ( ByteBuffer src , ByteBuffer dst ) throws SSLException { try { return unwrap ( singleSrcBuffer ( src ) , singleDstBuffer ( dst ) ) ; } finally { resetSingleSrcBuffer ( ) ; resetSingleDstBuffer ( ) ; } } @Override public synchronized SSLEngineResult unwrap ( ByteBuffer src , ByteBuffer [ ] dsts ) throws SSLException { try { return unwrap ( singleSrcBuffer ( src ) , dsts ) ; } finally { resetSingleSrcBuffer ( ) ; } } @Override public Runnable getDelegatedTask ( ) { return null ; } @Override public synchronized void closeInbound ( ) throws SSLException { if ( isInboundDone ) { return ; } isInboundDone = true ; engineClosed = true ; shutdown ( ) ; if ( handshakeState ! = HandshakeState . NOT_STARTED & & ! receivedShutdown ) { throw new SSLException ( <str> ) ; } } @Override public synchronized boolean isInboundDone ( ) { return isInboundDone | | engineClosed ; } @Override public synchronized void closeOutbound ( ) { if ( isOutboundDone ) { return ; } isOutboundDone = true ; engineClosed = true ; if ( handshakeState ! = HandshakeState . NOT_STARTED & & ! isDestroyed ( ) ) { int mode = SSL . getShutdown ( ssl ) ; if ( ( mode & SSL . SSL_SENT_SHUTDOWN ) ! = SSL . SSL_SENT_SHUTDOWN ) { int err = SSL . shutdownSSL ( ssl ) ; if ( err < <int> ) { int sslErr = SSL . getError ( ssl , err ) ; switch ( sslErr ) { case SSL . SSL_ERROR_NONE : case SSL . SSL_ERROR_WANT_ACCEPT : case SSL . SSL_ERROR_WANT_CONNECT : case SSL . SSL_ERROR_WANT_WRITE : case SSL . SSL_ERROR_WANT_READ : case SSL . SSL_ERROR_WANT_X509_LOOKUP : case SSL . SSL_ERROR_ZERO_RETURN : break ; case SSL . SSL_ERROR_SYSCALL : case SSL . SSL_ERROR_SSL : if ( logger . isDebugEnabled ( ) ) { logger . debug ( <str> , SSL . getLastError ( ) ) ; } shutdown ( ) ; break ; default : SSL . clearError ( ) ; break ; } } } } else { shutdown ( ) ; } } @Override public synchronized boolean isOutboundDone ( ) { return isOutboundDone ; } @Override public String [ ] getSupportedCipherSuites ( ) { Set < String > availableCipherSuites = OpenSsl . availableCipherSuites ( ) ; return availableCipherSuites . toArray ( new String [ availableCipherSuites . size ( ) ] ) ; } @Override public String [ ] getEnabledCipherSuites ( ) { final String [ ] enabled ; synchronized ( this ) { if ( ! isDestroyed ( ) ) { enabled = SSL . getCiphers ( ssl ) ; } else { return EmptyArrays . EMPTY_STRINGS ; } } if ( enabled = = null ) { return EmptyArrays . EMPTY_STRINGS ; } else { for ( int i = <int> ; i < enabled . length ; i + + ) { String mapped = toJavaCipherSuite ( enabled [ i ] ) ; if ( mapped ! = null ) { enabled [ i ] = mapped ; } } return enabled ; } } @Override public void setEnabledCipherSuites ( String [ ] cipherSuites ) { checkNotNull ( cipherSuites , <str> ) ; final StringBuilder buf = new StringBuilder ( ) ; for ( String c : cipherSuites ) { if ( c = = null ) { break ; } String converted = CipherSuiteConverter . toOpenSsl ( c ) ; if ( converted = = null ) { converted = c ; } if ( ! OpenSsl . isCipherSuiteAvailable ( converted ) ) { throw new IllegalArgumentException ( <str> + c + <str> + converted + <str> ) ; } buf . append ( converted ) ; buf . append ( <str> ) ; } if ( buf . length ( ) = = <int> ) { throw new IllegalArgumentException ( <str> ) ; } buf . setLength ( buf . length ( ) - <int> ) ; final String cipherSuiteSpec = buf . toString ( ) ; synchronized ( this ) { if ( ! isDestroyed ( ) ) { try { SSL . setCipherSuites ( ssl , cipherSuiteSpec ) ; } catch ( Exception e ) { throw new IllegalStateException ( <str> + cipherSuiteSpec , e ) ; } } else { throw new IllegalStateException ( <str> + cipherSuiteSpec ) ; } } } @Override public String [ ] getSupportedProtocols ( ) { return SUPPORTED_PROTOCOLS . clone ( ) ; } @Override public String [ ] getEnabledProtocols ( ) { List < String > enabled = new ArrayList < String > ( ) ; enabled . add ( PROTOCOL_SSL_V2_HELLO ) ; int opts ; synchronized ( this ) { if ( ! isDestroyed ( ) ) { opts = SSL . getOptions ( ssl ) ; } else { return enabled . toArray ( new String [ <int> ] ) ; } } if ( ( opts & SSL . SSL_OP_NO_TLSv1 ) = = <int> ) { enabled . add ( PROTOCOL_TLS_V1 ) ; } if ( ( opts & SSL . SSL_OP_NO_TLSv1_1 ) = = <int> ) { enabled . add ( PROTOCOL_TLS_V1_1 ) ; } if ( ( opts & SSL . SSL_OP_NO_TLSv1_2 ) = = <int> ) { enabled . add ( PROTOCOL_TLS_V1_2 ) ; } if ( ( opts & SSL . SSL_OP_NO_SSLv2 ) = = <int> ) { enabled . add ( PROTOCOL_SSL_V2 ) ; } if ( ( opts & SSL . SSL_OP_NO_SSLv3 ) = = <int> ) { enabled . add ( PROTOCOL_SSL_V3 ) ; } return enabled . toArray ( new String [ enabled . size ( ) ] ) ; } @Override public void setEnabledProtocols ( String [ ] protocols ) { if ( protocols = = null ) { throw new IllegalArgumentException ( ) ; } boolean sslv2 = false ; boolean sslv3 = false ; boolean tlsv1 = false ; boolean tlsv1_1 = false ; boolean tlsv1_2 = false ; for ( String p : protocols ) { if ( ! SUPPORTED_PROTOCOLS_SET . contains ( p ) ) { throw new IllegalArgumentException ( <str> + p + <str> ) ; } if ( p . equals ( PROTOCOL_SSL_V2 ) ) { sslv2 = true ; } else if ( p . equals ( PROTOCOL_SSL_V3 ) ) { sslv3 = true ; } else if ( p . equals ( PROTOCOL_TLS_V1 ) ) { tlsv1 = true ; } else if ( p . equals ( PROTOCOL_TLS_V1_1 ) ) { tlsv1_1 = true ; } else if ( p . equals ( PROTOCOL_TLS_V1_2 ) ) { tlsv1_2 = true ; } } synchronized ( this ) { if ( ! isDestroyed ( ) ) { SSL . setOptions ( ssl , SSL . SSL_OP_ALL ) ; if ( ! sslv2 ) { SSL . setOptions ( ssl , SSL . SSL_OP_NO_SSLv2 ) ; } if ( ! sslv3 ) { SSL . setOptions ( ssl , SSL . SSL_OP_NO_SSLv3 ) ; } if ( ! tlsv1 ) { SSL . setOptions ( ssl , SSL . SSL_OP_NO_TLSv1 ) ; } if ( ! tlsv1_1 ) { SSL . setOptions ( ssl , SSL . SSL_OP_NO_TLSv1_1 ) ; } if ( ! tlsv1_2 ) { SSL . setOptions ( ssl , SSL . SSL_OP_NO_TLSv1_2 ) ; } } else { throw new IllegalStateException ( <str> + Arrays . asList ( protocols ) ) ; } } } @Override public SSLSession getSession ( ) { return session ; } @Override public synchronized void beginHandshake ( ) throws SSLException { switch ( handshakeState ) { case STARTED_IMPLICITLY : checkEngineClosed ( ) ; handshakeState = HandshakeState . STARTED_EXPLICITLY ; break ; case STARTED_EXPLICITLY : break ; case FINISHED : if ( clientMode ) { throw RENEGOTIATION_UNSUPPORTED ; } if ( SSL . renegotiate ( ssl ) ! = <int> | | SSL . doHandshake ( ssl ) ! = <int> ) { shutdownWithError ( <str> ) ; } SSL . setState ( ssl , SSL . SSL_ST_ACCEPT ) ; case NOT_STARTED : handshakeState = HandshakeState . STARTED_EXPLICITLY ; handshake ( ) ; break ; default : throw new Error ( ) ; } } private void checkEngineClosed ( ) throws SSLException { if ( engineClosed | | isDestroyed ( ) ) { throw ENGINE_CLOSED ; } } private static HandshakeStatus pendingStatus ( int pendingStatus ) { return pendingStatus > <int> ? NEED_WRAP : NEED_UNWRAP ; } private HandshakeStatus handshake ( ) throws SSLException { if ( handshakeState = = HandshakeState . FINISHED ) { return FINISHED ; } checkEngineClosed ( ) ; int code = SSL . doHandshake ( ssl ) ; if ( code < = <int> ) { checkPendingHandshakeException ( ) ; int sslError = SSL . getError ( ssl , code ) ; switch ( sslError ) { case SSL . SSL_ERROR_WANT_READ : case SSL . SSL_ERROR_WANT_WRITE : return pendingStatus ( SSL . pendingWrittenBytesInBIO ( networkBIO ) ) ; default : shutdownWithError ( <str> ) ; } } session . handshakeFinished ( ) ; return FINISHED ; } private static long memoryAddress ( ByteBuf buf ) { if ( buf . hasMemoryAddress ( ) ) { return buf . memoryAddress ( ) ; } else { return Buffer . address ( buf . nioBuffer ( ) ) ; } } private SSLEngineResult . Status getEngineStatus ( ) { return engineClosed ? CLOSED : OK ; } private SSLEngineResult . HandshakeStatus mayFinishHandshake ( SSLEngineResult . HandshakeStatus status ) throws SSLException { if ( status = = NOT_HANDSHAKING & & handshakeState ! = HandshakeState . FINISHED ) { return handshake ( ) ; } return status ; } @Override public synchronized SSLEngineResult . HandshakeStatus getHandshakeStatus ( ) { if ( needPendingStatus ( ) ) { return pendingStatus ( SSL . pendingWrittenBytesInBIO ( networkBIO ) ) ; } return NOT_HANDSHAKING ; } private SSLEngineResult . HandshakeStatus getHandshakeStatus ( int pending ) { if ( needPendingStatus ( ) ) { return pendingStatus ( pending ) ; } return NOT_HANDSHAKING ; } private boolean needPendingStatus ( ) { return handshakeState ! = HandshakeState . NOT_STARTED & & ! isDestroyed ( ) & & ( handshakeState ! = HandshakeState . FINISHED | | engineClosed ) ; } private String toJavaCipherSuite ( String openSslCipherSuite ) { if ( openSslCipherSuite = = null ) { return null ; } String prefix = toJavaCipherSuitePrefix ( SSL . getVersion ( ssl ) ) ; return CipherSuiteConverter . toJava ( openSslCipherSuite , prefix ) ; } private static String toJavaCipherSuitePrefix ( String protocolVersion ) { final char c ; if ( protocolVersion = = null | | protocolVersion . length ( ) = = <int> ) { c = <int> ; } else { c = protocolVersion . charAt ( <int> ) ; } switch ( c ) { case <str> : return <str> ; case <str> : return <str> ; default : return <str> ; } } @Override public void setUseClientMode ( boolean clientMode ) { if ( clientMode ! = this . clientMode ) { throw new UnsupportedOperationException ( ) ; } } @Override public boolean getUseClientMode ( ) { return clientMode ; } @Override public void setNeedClientAuth ( boolean b ) { setClientAuth ( b ? ClientAuth . REQUIRE : ClientAuth . NONE ) ; } @Override public boolean getNeedClientAuth ( ) { return clientAuth = = ClientAuth . REQUIRE ; } @Override public void setWantClientAuth ( boolean b ) { setClientAuth ( b ? ClientAuth . OPTIONAL : ClientAuth . NONE ) ; } @Override public boolean getWantClientAuth ( ) { return clientAuth = = ClientAuth . OPTIONAL ; } private void setClientAuth ( ClientAuth mode ) { if ( clientMode ) { return ; } synchronized ( this ) { if ( clientAuth = = mode ) { return ; } switch ( mode ) { case NONE : SSL . setVerify ( ssl , SSL . SSL_CVERIFY_NONE , OpenSslContext . VERIFY_DEPTH ) ; break ; case REQUIRE : SSL . setVerify ( ssl , SSL . SSL_CVERIFY_REQUIRE , OpenSslContext . VERIFY_DEPTH ) ; break ; case OPTIONAL : SSL . setVerify ( ssl , SSL . SSL_CVERIFY_OPTIONAL , OpenSslContext . VERIFY_DEPTH ) ; break ; } clientAuth = mode ; } } @Override public void setEnableSessionCreation ( boolean b ) { if ( b ) { throw new UnsupportedOperationException ( ) ; } } @Override public boolean getEnableSessionCreation ( ) { return false ; } @Override public SSLParameters getSSLParameters ( ) { SSLParameters sslParameters = super . getSSLParameters ( ) ; if ( PlatformDependent . javaVersion ( ) > = <int> ) { sslParameters . setEndpointIdentificationAlgorithm ( endPointIdentificationAlgorithm ) ; SslParametersUtils . setAlgorithmConstraints ( sslParameters , algorithmConstraints ) ; } return sslParameters ; } @Override public void setSSLParameters ( SSLParameters sslParameters ) { super . setSSLParameters ( sslParameters ) ; if ( PlatformDependent . javaVersion ( ) > = <int> ) { endPointIdentificationAlgorithm = sslParameters . getEndpointIdentificationAlgorithm ( ) ; algorithmConstraints = sslParameters . getAlgorithmConstraints ( ) ; } } @Override @SuppressWarnings ( <str> ) protected void finalize ( ) throws Throwable { super . finalize ( ) ; shutdown ( ) ; } private boolean isDestroyed ( ) { return destroyed ! = <int> ; } private final class OpenSslSession implements SSLSession , ApplicationProtocolAccessor { private final OpenSslSessionContext sessionContext ; private X509Certificate [ ] x509PeerCerts ; private String protocol ; private String applicationProtocol ; private Certificate [ ] peerCerts ; private String cipher ; private byte [ ] id ; private long creationTime ; private Map < String , Object > values ; OpenSslSession ( OpenSslSessionContext sessionContext ) { this . sessionContext = sessionContext ; } @Override public byte [ ] getId ( ) { synchronized ( OpenSslEngine . this ) { if ( id = = null ) { return EmptyArrays . EMPTY_BYTES ; } return id . clone ( ) ; } } @Override public SSLSessionContext getSessionContext ( ) { return sessionContext ; } @Override public long getCreationTime ( ) { synchronized ( OpenSslEngine . this ) { if ( creationTime = = <int> & & ! isDestroyed ( ) ) { creationTime = SSL . getTime ( ssl ) * <int> ; } } return creationTime ; } @Override public long getLastAccessedTime ( ) { return getCreationTime ( ) ; } @Override public void invalidate ( ) { synchronized ( OpenSslEngine . this ) { if ( ! isDestroyed ( ) ) { SSL . setTimeout ( ssl , <int> ) ; } } } @Override public boolean isValid ( ) { synchronized ( OpenSslEngine . this ) { if ( ! isDestroyed ( ) ) { return System . currentTimeMillis ( ) - ( SSL . getTimeout ( ssl ) * <int> ) < ( SSL . getTime ( ssl ) * <int> ) ; } } return false ; } @Override public void putValue ( String name , Object value ) { if ( name = = null ) { throw new NullPointerException ( <str> ) ; } if ( value = = null ) { throw new NullPointerException ( <str> ) ; } Map < String , Object > values = this . values ; if ( values = = null ) { values = this . values = new HashMap < String , Object > ( <int> ) ; } Object old = values . put ( name , value ) ; if ( value instanceof SSLSessionBindingListener ) { ( ( SSLSessionBindingListener ) value ) . valueBound ( new SSLSessionBindingEvent ( this , name ) ) ; } notifyUnbound ( old , name ) ; } @Override public Object getValue ( String name ) { if ( name = = null ) { throw new NullPointerException ( <str> ) ; } if ( values = = null ) { return null ; } return values . get ( name ) ; } @Override public void removeValue ( String name ) { if ( name = = null ) { throw new NullPointerException ( <str> ) ; } Map < String , Object > values = this . values ; if ( values = = null ) { return ; } Object old = values . remove ( name ) ; notifyUnbound ( old , name ) ; } @Override public String [ ] getValueNames ( ) { Map < String , Object > values = this . values ; if ( values = = null | | values . isEmpty ( ) ) { return EmptyArrays . EMPTY_STRINGS ; } return values . keySet ( ) . toArray ( new String [ values . size ( ) ] ) ; } private void notifyUnbound ( Object value , String name ) { if ( value instanceof SSLSessionBindingListener ) { ( ( SSLSessionBindingListener ) value ) . valueUnbound ( new SSLSessionBindingEvent ( this , name ) ) ; } } void handshakeFinished ( ) throws SSLException { synchronized ( OpenSslEngine . this ) { if ( ! isDestroyed ( ) ) { id = SSL . getSessionId ( ssl ) ; cipher = toJavaCipherSuite ( SSL . getCipherForSSL ( ssl ) ) ; protocol = SSL . getVersion ( ssl ) ; initPeerCerts ( ) ; selectApplicationProtocol ( ) ; handshakeState = HandshakeState . FINISHED ; } else { throw new SSLException ( <str> ) ; } } } private void initPeerCerts ( ) { byte [ ] [ ] chain = SSL . getPeerCertChain ( ssl ) ; final byte [ ] clientCert ; if ( ! clientMode ) { clientCert = SSL . getPeerCertificate ( ssl ) ; } else { clientCert = null ; } if ( chain = = null & & clientCert = = null ) { peerCerts = EMPTY_CERTIFICATES ; x509PeerCerts = EMPTY_X509_CERTIFICATES ; } else { int len = chain ! = null ? chain . length : <int> ; int i = <int> ; Certificate [ ] peerCerts ; if ( clientCert ! = null ) { len + + ; peerCerts = new Certificate [ len ] ; peerCerts [ i + + ] = new OpenSslX509Certificate ( clientCert ) ; } else { peerCerts = new Certificate [ len ] ; } if ( chain ! = null ) { X509Certificate [ ] pCerts = new X509Certificate [ chain . length ] ; for ( int a = <int> ; a < pCerts . length ; + + i , + + a ) { byte [ ] bytes = chain [ a ] ; pCerts [ a ] = new OpenSslJavaxX509Certificate ( bytes ) ; peerCerts [ i ] = new OpenSslX509Certificate ( bytes ) ; } x509PeerCerts = pCerts ; } else { x509PeerCerts = EMPTY_X509_CERTIFICATES ; } this . peerCerts = peerCerts ; } } private void selectApplicationProtocol ( ) throws SSLException { SelectedListenerFailureBehavior behavior = apn . selectedListenerFailureBehavior ( ) ; List < String > protocols = apn . protocols ( ) ; String applicationProtocol ; switch ( apn . protocol ( ) ) { case NONE : break ; case ALPN : applicationProtocol = SSL . getAlpnSelected ( ssl ) ; if ( applicationProtocol ! = null ) { this . applicationProtocol = selectApplicationProtocol ( protocols , behavior , applicationProtocol ) ; } break ; case NPN : applicationProtocol = SSL . getNextProtoNegotiated ( ssl ) ; if ( applicationProtocol ! = null ) { this . applicationProtocol = selectApplicationProtocol ( protocols , behavior , applicationProtocol ) ; } break ; case NPN_AND_ALPN : applicationProtocol = SSL . getAlpnSelected ( ssl ) ; if ( applicationProtocol = = null ) { applicationProtocol = SSL . getNextProtoNegotiated ( ssl ) ; } if ( applicationProtocol ! = null ) { this . applicationProtocol = selectApplicationProtocol ( protocols , behavior , applicationProtocol ) ; } break ; default : throw new Error ( ) ; } } private String selectApplicationProtocol ( List < String > protocols , SelectedListenerFailureBehavior behavior , String applicationProtocol ) throws SSLException { if ( behavior = = SelectedListenerFailureBehavior . ACCEPT ) { return applicationProtocol ; } else { int size = protocols . size ( ) ; assert size > <int> ; if ( protocols . contains ( applicationProtocol ) ) { return applicationProtocol ; } else { if ( behavior = = SelectedListenerFailureBehavior . CHOOSE_MY_LAST_PROTOCOL ) { return protocols . get ( size - <int> ) ; } else { throw new SSLException ( <str> + applicationProtocol ) ; } } } } @Override public Certificate [ ] getPeerCertificates ( ) throws SSLPeerUnverifiedException { synchronized ( OpenSslEngine . this ) { if ( peerCerts = = null | | peerCerts . length = = <int> ) { throw new SSLPeerUnverifiedException ( <str> ) ; } return peerCerts ; } } @Override public Certificate [ ] getLocalCertificates ( ) { if ( localCerts = = null ) { return null ; } return localCerts . clone ( ) ; } @Override public X509Certificate [ ] getPeerCertificateChain ( ) throws SSLPeerUnverifiedException { synchronized ( OpenSslEngine . this ) { if ( x509PeerCerts = = null | | x509PeerCerts . length = = <int> ) { throw new SSLPeerUnverifiedException ( <str> ) ; } return x509PeerCerts ; } } @Override public Principal getPeerPrincipal ( ) throws SSLPeerUnverifiedException { Certificate [ ] peer = getPeerCertificates ( ) ; return ( ( java . security . cert . X509Certificate ) peer [ <int> ] ) . getSubjectX500Principal ( ) ; } @Override public Principal getLocalPrincipal ( ) { Certificate [ ] local = localCerts ; if ( local = = null | | local . length = = <int> ) { return null ; } return ( ( java . security . cert . X509Certificate ) local [ <int> ] ) . getIssuerX500Principal ( ) ; } @Override public String getCipherSuite ( ) { synchronized ( OpenSslEngine . this ) { if ( cipher = = null ) { return INVALID_CIPHER ; } return cipher ; } } @Override public String getProtocol ( ) { String protocol = this . protocol ; if ( protocol = = null ) { synchronized ( OpenSslEngine . this ) { if ( ! isDestroyed ( ) ) { protocol = SSL . getVersion ( ssl ) ; } else { protocol = StringUtil . EMPTY_STRING ; } } } return protocol ; } @Override public String getApplicationProtocol ( ) { synchronized ( OpenSslEngine . this ) { return applicationProtocol ; } } @Override public String getPeerHost ( ) { return OpenSslEngine . this . getPeerHost ( ) ; } @Override public int getPeerPort ( ) { return OpenSslEngine . this . getPeerPort ( ) ; } @Override public int getPacketBufferSize ( ) { return MAX_ENCRYPTED_PACKET_LENGTH ; } @Override public int getApplicationBufferSize ( ) { return MAX_PLAINTEXT_LENGTH ; } } } 
