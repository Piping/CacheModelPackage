package org . gradle . model . internal . manage . schema . extract ; import com . google . common . cache . CacheBuilder ; import com . google . common . cache . CacheLoader ; import com . google . common . cache . LoadingCache ; import org . gradle . api . Action ; import org . gradle . internal . UncheckedException ; import org . gradle . model . ModelMap ; import org . gradle . model . internal . core . NodeBackedModelMap ; import org . gradle . model . internal . manage . schema . ModelSchema ; import org . gradle . model . internal . manage . schema . SpecializedMapSchema ; import org . gradle . model . internal . type . ModelType ; import java . lang . reflect . ParameterizedType ; import java . lang . reflect . Type ; import java . util . concurrent . ExecutionException ; public class SpecializedMapStrategy implements ModelSchemaExtractionStrategy { private final ManagedCollectionProxyClassGenerator generator = new ManagedCollectionProxyClassGenerator ( ) ; private final LoadingCache < ModelType < ? > , Class < ? > > generatedImplementationTypes = CacheBuilder . newBuilder ( ) . weakValues ( ) . build ( new CacheLoader < ModelType < ? > , Class < ? > > ( ) { @Override public Class < ? > load ( ModelType < ? > contractType ) throws Exception { return generator . generate ( NodeBackedModelMap . class , contractType . getConcreteClass ( ) ) ; } } ) ; @Override public < T > void extract ( ModelSchemaExtractionContext < T > extractionContext ) { ModelType < T > modelType = extractionContext . getType ( ) ; Type type = modelType . getType ( ) ; if ( ! ( type instanceof Class ) ) { return ; } Class < ? > contractType = ( Class < ? > ) type ; if ( ! contractType . isInterface ( ) ) { return ; } if ( contractType . getGenericInterfaces ( ) . length ! = <int> ) { return ; } Type superType = contractType . getGenericInterfaces ( ) [ <int> ] ; if ( ! ( superType instanceof ParameterizedType ) ) { return ; } ParameterizedType parameterizedSuperType = ( ParameterizedType ) superType ; if ( ! parameterizedSuperType . getRawType ( ) . equals ( ModelMap . class ) ) { return ; } ModelType < ? > elementType = ModelType . of ( parameterizedSuperType . getActualTypeArguments ( ) [ <int> ] ) ; Class < ? > proxyImpl ; try { proxyImpl = generatedImplementationTypes . get ( modelType ) ; } catch ( ExecutionException e ) { throw UncheckedException . throwAsUncheckedException ( e ) ; } extractionContext . found ( getModelSchema ( extractionContext , elementType , proxyImpl ) ) ; } private < T , E > SpecializedMapSchema < T , E > getModelSchema ( ModelSchemaExtractionContext < T > extractionContext , ModelType < E > elementType , Class < ? > implementationType ) { final SpecializedMapSchema < T , E > schema = new SpecializedMapSchema < T , E > ( extractionContext . getType ( ) , elementType , implementationType ) ; extractionContext . child ( elementType , <str> , new Action < ModelSchema < E > > ( ) { @Override public void execute ( ModelSchema < E > elementTypeSchema ) { schema . setElementTypeSchema ( elementTypeSchema ) ; } } ) ; return schema ; } } 
