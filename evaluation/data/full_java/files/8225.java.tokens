package org . elasticsearch . index . query ; import org . apache . lucene . search . * ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentType ; import org . hamcrest . Matchers ; import java . io . IOException ; import java . util . * ; import static org . elasticsearch . index . query . QueryBuilders . * ; import static org . hamcrest . CoreMatchers . equalTo ; import static org . hamcrest . CoreMatchers . instanceOf ; public class BoolQueryBuilderTests extends AbstractQueryTestCase < BoolQueryBuilder > { @Override protected BoolQueryBuilder doCreateTestQueryBuilder ( ) { BoolQueryBuilder query = new BoolQueryBuilder ( ) ; if ( randomBoolean ( ) ) { query . adjustPureNegative ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { query . disableCoord ( randomBoolean ( ) ) ; } if ( randomBoolean ( ) ) { query . minimumNumberShouldMatch ( randomMinimumShouldMatch ( ) ) ; } int mustClauses = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < mustClauses ; i + + ) { query . must ( RandomQueryBuilder . createQuery ( random ( ) ) ) ; } int mustNotClauses = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < mustNotClauses ; i + + ) { query . mustNot ( RandomQueryBuilder . createQuery ( random ( ) ) ) ; } int shouldClauses = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < shouldClauses ; i + + ) { query . should ( RandomQueryBuilder . createQuery ( random ( ) ) ) ; } int filterClauses = randomIntBetween ( <int> , <int> ) ; for ( int i = <int> ; i < filterClauses ; i + + ) { query . filter ( RandomQueryBuilder . createQuery ( random ( ) ) ) ; } return query ; } @Override protected void doAssertLuceneQuery ( BoolQueryBuilder queryBuilder , Query query , QueryShardContext context ) throws IOException { if ( ! queryBuilder . hasClauses ( ) ) { assertThat ( query , instanceOf ( MatchAllDocsQuery . class ) ) ; } else { List < BooleanClause > clauses = new ArrayList < > ( ) ; clauses . addAll ( getBooleanClauses ( queryBuilder . must ( ) , BooleanClause . Occur . MUST , context ) ) ; clauses . addAll ( getBooleanClauses ( queryBuilder . mustNot ( ) , BooleanClause . Occur . MUST_NOT , context ) ) ; clauses . addAll ( getBooleanClauses ( queryBuilder . should ( ) , BooleanClause . Occur . SHOULD , context ) ) ; clauses . addAll ( getBooleanClauses ( queryBuilder . filter ( ) , BooleanClause . Occur . FILTER , context ) ) ; if ( clauses . isEmpty ( ) ) { assertThat ( query , instanceOf ( MatchAllDocsQuery . class ) ) ; } else { assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery booleanQuery = ( BooleanQuery ) query ; assertThat ( booleanQuery . isCoordDisabled ( ) , equalTo ( queryBuilder . disableCoord ( ) ) ) ; if ( queryBuilder . adjustPureNegative ( ) ) { boolean isNegative = true ; for ( BooleanClause clause : clauses ) { if ( clause . isProhibited ( ) = = false ) { isNegative = false ; break ; } } if ( isNegative ) { clauses . add ( new BooleanClause ( new MatchAllDocsQuery ( ) , BooleanClause . Occur . MUST ) ) ; } } assertThat ( booleanQuery . clauses ( ) . size ( ) , equalTo ( clauses . size ( ) ) ) ; Iterator < BooleanClause > clauseIterator = clauses . iterator ( ) ; for ( BooleanClause booleanClause : booleanQuery . getClauses ( ) ) { assertThat ( booleanClause , instanceOf ( clauseIterator . next ( ) . getClass ( ) ) ) ; } } } } private static List < BooleanClause > getBooleanClauses ( List < QueryBuilder > queryBuilders , BooleanClause . Occur occur , QueryShardContext context ) throws IOException { List < BooleanClause > clauses = new ArrayList < > ( ) ; for ( QueryBuilder query : queryBuilders ) { Query innerQuery = query . toQuery ( context ) ; if ( innerQuery ! = null ) { clauses . add ( new BooleanClause ( innerQuery , occur ) ) ; } } return clauses ; } @Override protected Map < String , BoolQueryBuilder > getAlternateVersions ( ) { Map < String , BoolQueryBuilder > alternateVersions = new HashMap < > ( ) ; BoolQueryBuilder tempQueryBuilder = createTestQueryBuilder ( ) ; BoolQueryBuilder expectedQuery = new BoolQueryBuilder ( ) ; String contentString = <str> + <str> ; if ( tempQueryBuilder . must ( ) . size ( ) > <int> ) { QueryBuilder must = tempQueryBuilder . must ( ) . get ( <int> ) ; contentString + = <str> + must . toString ( ) + <str> ; expectedQuery . must ( must ) ; } if ( tempQueryBuilder . mustNot ( ) . size ( ) > <int> ) { QueryBuilder mustNot = tempQueryBuilder . mustNot ( ) . get ( <int> ) ; contentString + = ( randomBoolean ( ) ? <str> : <str> ) + mustNot . toString ( ) + <str> ; expectedQuery . mustNot ( mustNot ) ; } if ( tempQueryBuilder . should ( ) . size ( ) > <int> ) { QueryBuilder should = tempQueryBuilder . should ( ) . get ( <int> ) ; contentString + = <str> + should . toString ( ) + <str> ; expectedQuery . should ( should ) ; } if ( tempQueryBuilder . filter ( ) . size ( ) > <int> ) { QueryBuilder filter = tempQueryBuilder . filter ( ) . get ( <int> ) ; contentString + = <str> + filter . toString ( ) + <str> ; expectedQuery . filter ( filter ) ; } contentString = contentString . substring ( <int> , contentString . length ( ) - <int> ) ; contentString + = <str> + <str> ; alternateVersions . put ( contentString , expectedQuery ) ; return alternateVersions ; } public void testIllegalArguments ( ) { BoolQueryBuilder booleanQuery = new BoolQueryBuilder ( ) ; try { booleanQuery . must ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { booleanQuery . mustNot ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { booleanQuery . filter ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } try { booleanQuery . should ( null ) ; fail ( <str> ) ; } catch ( IllegalArgumentException e ) { } } public void testEmptyBooleanQuery ( ) throws Exception { XContentBuilder contentBuilder = XContentFactory . contentBuilder ( randomFrom ( XContentType . values ( ) ) ) ; BytesReference query = contentBuilder . startObject ( ) . startObject ( <str> ) . endObject ( ) . endObject ( ) . bytes ( ) ; Query parsedQuery = parseQuery ( query ) . toQuery ( createShardContext ( ) ) ; assertThat ( parsedQuery , Matchers . instanceOf ( MatchAllDocsQuery . class ) ) ; } public void testDefaultMinShouldMatch ( ) throws Exception { BooleanQuery bq = ( BooleanQuery ) parseQuery ( boolQuery ( ) . must ( termQuery ( <str> , <str> ) ) . buildAsBytes ( ) ) . toQuery ( createShardContext ( ) ) ; assertEquals ( <int> , bq . getMinimumNumberShouldMatch ( ) ) ; bq = ( BooleanQuery ) parseQuery ( boolQuery ( ) . should ( termQuery ( <str> , <str> ) ) . buildAsBytes ( ) ) . toQuery ( createShardContext ( ) ) ; assertEquals ( <int> , bq . getMinimumNumberShouldMatch ( ) ) ; ConstantScoreQuery csq = ( ConstantScoreQuery ) parseQuery ( constantScoreQuery ( boolQuery ( ) . must ( termQuery ( <str> , <str> ) ) ) . buildAsBytes ( ) ) . toQuery ( createShardContext ( ) ) ; bq = ( BooleanQuery ) csq . getQuery ( ) ; assertEquals ( <int> , bq . getMinimumNumberShouldMatch ( ) ) ; csq = ( ConstantScoreQuery ) parseQuery ( constantScoreQuery ( boolQuery ( ) . should ( termQuery ( <str> , <str> ) ) ) . buildAsBytes ( ) ) . toQuery ( createShardContext ( ) ) ; bq = ( BooleanQuery ) csq . getQuery ( ) ; assertEquals ( <int> , bq . getMinimumNumberShouldMatch ( ) ) ; } public void testMinShouldMatchFilterWithoutShouldClauses ( ) throws Exception { BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder ( ) ; boolQueryBuilder . filter ( new BoolQueryBuilder ( ) . must ( new MatchAllQueryBuilder ( ) ) ) ; Query query = boolQueryBuilder . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery booleanQuery = ( BooleanQuery ) query ; assertThat ( booleanQuery . getMinimumNumberShouldMatch ( ) , equalTo ( <int> ) ) ; assertThat ( booleanQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; BooleanClause booleanClause = booleanQuery . clauses ( ) . get ( <int> ) ; assertThat ( booleanClause . getOccur ( ) , equalTo ( BooleanClause . Occur . FILTER ) ) ; assertThat ( booleanClause . getQuery ( ) , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery innerBooleanQuery = ( BooleanQuery ) booleanClause . getQuery ( ) ; assertThat ( innerBooleanQuery . getMinimumNumberShouldMatch ( ) , equalTo ( <int> ) ) ; assertThat ( innerBooleanQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; BooleanClause innerBooleanClause = innerBooleanQuery . clauses ( ) . get ( <int> ) ; assertThat ( innerBooleanClause . getOccur ( ) , equalTo ( BooleanClause . Occur . MUST ) ) ; assertThat ( innerBooleanClause . getQuery ( ) , instanceOf ( MatchAllDocsQuery . class ) ) ; } public void testMinShouldMatchFilterWithShouldClauses ( ) throws Exception { BoolQueryBuilder boolQueryBuilder = new BoolQueryBuilder ( ) ; boolQueryBuilder . filter ( new BoolQueryBuilder ( ) . must ( new MatchAllQueryBuilder ( ) ) . should ( new MatchAllQueryBuilder ( ) ) ) ; Query query = boolQueryBuilder . toQuery ( createShardContext ( ) ) ; assertThat ( query , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery booleanQuery = ( BooleanQuery ) query ; assertThat ( booleanQuery . getMinimumNumberShouldMatch ( ) , equalTo ( <int> ) ) ; assertThat ( booleanQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; BooleanClause booleanClause = booleanQuery . clauses ( ) . get ( <int> ) ; assertThat ( booleanClause . getOccur ( ) , equalTo ( BooleanClause . Occur . FILTER ) ) ; assertThat ( booleanClause . getQuery ( ) , instanceOf ( BooleanQuery . class ) ) ; BooleanQuery innerBooleanQuery = ( BooleanQuery ) booleanClause . getQuery ( ) ; assertThat ( innerBooleanQuery . getMinimumNumberShouldMatch ( ) , equalTo ( <int> ) ) ; assertThat ( innerBooleanQuery . clauses ( ) . size ( ) , equalTo ( <int> ) ) ; BooleanClause innerBooleanClause1 = innerBooleanQuery . clauses ( ) . get ( <int> ) ; assertThat ( innerBooleanClause1 . getOccur ( ) , equalTo ( BooleanClause . Occur . MUST ) ) ; assertThat ( innerBooleanClause1 . getQuery ( ) , instanceOf ( MatchAllDocsQuery . class ) ) ; BooleanClause innerBooleanClause2 = innerBooleanQuery . clauses ( ) . get ( <int> ) ; assertThat ( innerBooleanClause2 . getOccur ( ) , equalTo ( BooleanClause . Occur . SHOULD ) ) ; assertThat ( innerBooleanClause2 . getQuery ( ) , instanceOf ( MatchAllDocsQuery . class ) ) ; } public void testFromJson ( ) throws IOException { String query = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; BoolQueryBuilder queryBuilder = ( BoolQueryBuilder ) parseQuery ( query ) ; checkGeneratedJson ( query , queryBuilder ) ; assertEquals ( query , <int> , queryBuilder . boost , <float> ) ; assertEquals ( query , <str> , queryBuilder . minimumShouldMatch ( ) ) ; assertEquals ( query , <str> , ( ( TermQueryBuilder ) queryBuilder . must ( ) . get ( <int> ) ) . value ( ) ) ; } } 
