package org . nd4j . linalg . api . ops . impl . accum ; import org . apache . commons . math3 . util . FastMath ; import org . nd4j . linalg . api . complex . IComplexNumber ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . ops . BaseAccumulation ; import org . nd4j . linalg . api . ops . Op ; import org . nd4j . linalg . factory . Nd4j ; import org . nd4j . linalg . util . ArrayUtil ; import org . nd4j . linalg . util . ComplexUtil ; public class Variance extends BaseAccumulation { protected double mean , bias ; protected boolean biasCorrected = true ; public Variance ( ) { } public Variance ( INDArray x , INDArray y , INDArray z , int n ) { super ( x , y , z , n ) ; passThrough = true ; } public Variance ( INDArray x , INDArray y , int n ) { this ( x , y , x , n ) ; } public Variance ( INDArray x ) { this ( x , null , x , x . length ( ) , true ) ; } public Variance ( INDArray x , INDArray y ) { super ( x , y ) ; passThrough = true ; } public Variance ( INDArray x , INDArray y , INDArray z , int n , boolean biasCorrected ) { super ( x , y , z , n ) ; this . biasCorrected = biasCorrected ; init ( x , y , z , n ) ; passThrough = true ; } public Variance ( INDArray x , INDArray y , int n , boolean biasCorrected ) { super ( x , y , n ) ; this . biasCorrected = biasCorrected ; init ( x , y , z , n ) ; passThrough = true ; } public Variance ( INDArray x , boolean biasCorrected ) { super ( x ) ; this . biasCorrected = biasCorrected ; init ( x , y , z , n ) ; passThrough = true ; } public Variance ( INDArray x , INDArray y , boolean biasCorrected ) { super ( x , y ) ; this . biasCorrected = biasCorrected ; init ( x , y , x , x . length ( ) ) ; passThrough = true ; } @Override public double op ( double origin ) { return origin - mean ; } @Override public float op ( float origin ) { return ( float ) ( origin - mean ) ; } @Override public double update ( double accum , double x ) { return accum + x * x ; } @Override public double update ( double accum , double x , double y ) { return accum + x * x ; } @Override public float update ( float accum , float x ) { return accum + x * x ; } @Override public float update ( float accum , float x , float y ) { return accum + x * x ; } @Override public IComplexNumber update ( IComplexNumber accum , double x ) { double dev = x - mean ; return accum . add ( dev * dev ) ; } @Override public IComplexNumber update ( IComplexNumber accum , double x , double y ) { double dev = x - mean ; return accum . add ( dev * dev ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x ) { IComplexNumber dev = x . sub ( mean ) ; return accum . add ( dev . mul ( dev ) ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x , IComplexNumber y ) { IComplexNumber dev = x . sub ( mean ) ; return accum . add ( dev . mul ( dev ) ) ; } @Override public IComplexNumber update ( IComplexNumber accum , IComplexNumber x , double y ) { IComplexNumber dev = x . sub ( mean ) ; return accum . add ( dev . mul ( dev ) ) ; } @Override public String name ( ) { return <str> ; } @Override public Op opForDimension ( int index , int dimension ) { INDArray xAlongDimension = x . vectorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new Variance ( xAlongDimension , y . vectorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new Variance ( x . vectorAlongDimension ( index , dimension ) ) ; } @Override public Op opForDimension ( int index , int . . . dimension ) { INDArray xAlongDimension = x . tensorAlongDimension ( index , dimension ) ; if ( y ( ) ! = null ) return new Variance ( xAlongDimension , y . tensorAlongDimension ( index , dimension ) , xAlongDimension . length ( ) ) ; else return new Variance ( x . tensorAlongDimension ( index , dimension ) ) ; } @Override public void init ( INDArray x , INDArray y , INDArray z , int n ) { super . init ( x , y , z , n ) ; } @Override public void exec ( ) { if ( biasCorrected ) this . bias = Nd4j . getExecutioner ( ) . execAndReturn ( new Bias ( x ) ) . getFinalResult ( ) . doubleValue ( ) ; this . mean = Nd4j . getExecutioner ( ) . execAndReturn ( new Mean ( x ) ) . getFinalResult ( ) . doubleValue ( ) ; INDArray xSubMean = x . sub ( mean ) ; INDArray squared = xSubMean . muli ( xSubMean ) ; double accum = Nd4j . getExecutioner ( ) . execAndReturn ( new Sum ( squared ) ) . getFinalResult ( ) . doubleValue ( ) ; getAndSetFinalResult ( accum ) ; } @Override public void exec ( int . . . dimension ) { if ( dimension . length = = <int> & & dimension [ <int> ] = = Integer . MAX_VALUE ) { exec ( ) ; this . z = Nd4j . scalar ( this . finalResult ) ; return ; } int [ ] retShape = ArrayUtil . removeIndex ( x . shape ( ) , dimension ) ; int nOps = x . tensorssAlongDimension ( dimension ) ; z = Nd4j . create ( retShape ) ; for ( int i = <int> ; i < nOps ; i + + ) { double d = Nd4j . getExecutioner ( ) . execAndReturn ( ( Variance ) opForDimension ( i , dimension ) ) . getFinalResult ( ) . doubleValue ( ) ; z . putScalar ( i , d ) ; } } @Override public double combineSubResults ( double first , double second ) { return first + second ; } @Override public float combineSubResults ( float first , float second ) { return first + second ; } @Override public IComplexNumber combineSubResults ( IComplexNumber first , IComplexNumber second ) { return first . add ( second ) ; } @Override public double getAndSetFinalResult ( double accum ) { double result ; if ( biasCorrected ) result = ( accum - ( FastMath . pow ( bias , <float> ) / n ( ) ) ) / ( n ( ) - <float> ) ; else result = accum / ( double ) n ; this . finalResult = result ; return result ; } @Override public float getAndSetFinalResult ( float accum ) { double result ; if ( biasCorrected ) result = ( accum - ( FastMath . pow ( bias , <float> ) / n ( ) ) ) / ( n ( ) - <float> ) ; else result = accum / ( double ) n ; this . finalResult = result ; return ( float ) result ; } @Override public IComplexNumber getAndSetFinalResult ( IComplexNumber accum ) { if ( biasCorrected ) finalResultComplex = ( accum . sub ( ComplexUtil . pow ( Nd4j . createComplexNumber ( bias , <int> ) , <float> ) . div ( Nd4j . createComplexNumber ( n ( ) , <int> ) ) ) . div ( Nd4j . createComplexNumber ( n ( ) - <float> , <float> ) ) ) ; else finalResultComplex = accum . divi ( n - <int> ) ; return finalResultComplex ; } @Override public double calculateFinalResult ( double accum , int n ) { if ( biasCorrected ) throw new UnsupportedOperationException ( <str> ) ; else return accum / n ; } @Override public float calculateFinalResult ( float accum , int n ) { if ( biasCorrected ) throw new UnsupportedOperationException ( <str> ) ; else return accum / n ; } } 
