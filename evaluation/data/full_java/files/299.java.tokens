package org . apache . cassandra . db ; import java . io . IOException ; import java . util . * ; import java . util . function . Predicate ; import java . nio . ByteBuffer ; import java . security . MessageDigest ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . Iterators ; import net . nicoulaj . compilecommand . annotations . DontInline ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . cql3 . ColumnIdentifier ; import org . apache . cassandra . db . marshal . SetType ; import org . apache . cassandra . db . marshal . UTF8Type ; import org . apache . cassandra . io . util . DataInputPlus ; import org . apache . cassandra . io . util . DataOutputPlus ; import org . apache . cassandra . utils . ByteBufferUtil ; import org . apache . cassandra . utils . SearchIterator ; import org . apache . cassandra . utils . btree . BTree ; import org . apache . cassandra . utils . btree . BTreeSearchIterator ; import org . apache . cassandra . utils . btree . UpdateFunction ; public class Columns extends AbstractCollection < ColumnDefinition > implements Collection < ColumnDefinition > { public static final Serializer serializer = new Serializer ( ) ; public static final Columns NONE = new Columns ( BTree . empty ( ) , <int> ) ; public static final ColumnDefinition FIRST_COMPLEX = new ColumnDefinition ( <str> , <str> , ColumnIdentifier . getInterned ( ByteBufferUtil . EMPTY_BYTE_BUFFER , UTF8Type . instance ) , SetType . getInstance ( UTF8Type . instance , true ) , ColumnDefinition . NO_POSITION , ColumnDefinition . Kind . REGULAR ) ; private final Object [ ] columns ; private final int complexIdx ; private Columns ( Object [ ] columns , int complexIdx ) { assert complexIdx < = BTree . size ( columns ) ; this . columns = columns ; this . complexIdx = complexIdx ; } private Columns ( Object [ ] columns ) { this ( columns , findFirstComplexIdx ( columns ) ) ; } public static Columns of ( ColumnDefinition c ) { return new Columns ( BTree . singleton ( c ) , c . isComplex ( ) ? <int> : <int> ) ; } public static Columns from ( Collection < ColumnDefinition > s ) { Object [ ] tree = BTree . < ColumnDefinition > builder ( Comparator . naturalOrder ( ) ) . addAll ( s ) . build ( ) ; return new Columns ( tree , findFirstComplexIdx ( tree ) ) ; } private static int findFirstComplexIdx ( Object [ ] tree ) { int size = BTree . size ( tree ) ; if ( ! BTree . isEmpty ( tree ) & & BTree . < ColumnDefinition > findByIndex ( tree , size - <int> ) . isSimple ( ) ) return size ; return BTree . ceilIndex ( tree , Comparator . naturalOrder ( ) , FIRST_COMPLEX ) ; } public boolean isEmpty ( ) { return BTree . isEmpty ( columns ) ; } public int simpleColumnCount ( ) { return complexIdx ; } public int complexColumnCount ( ) { return BTree . size ( columns ) - complexIdx ; } public int size ( ) { return BTree . size ( columns ) ; } public boolean hasSimple ( ) { return complexIdx > <int> ; } public boolean hasComplex ( ) { return complexIdx < BTree . size ( columns ) ; } public ColumnDefinition getSimple ( int i ) { return BTree . findByIndex ( columns , i ) ; } public ColumnDefinition getComplex ( int i ) { return BTree . findByIndex ( columns , complexIdx + i ) ; } public int simpleIdx ( ColumnDefinition c ) { return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) ; } public int complexIdx ( ColumnDefinition c ) { return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) - complexIdx ; } public boolean contains ( ColumnDefinition c ) { return BTree . findIndex ( columns , Comparator . naturalOrder ( ) , c ) > = <int> ; } public Columns mergeTo ( Columns other ) { if ( this = = other | | other = = NONE ) return this ; if ( this = = NONE ) return other ; Object [ ] tree = BTree . < ColumnDefinition > merge ( this . columns , other . columns , Comparator . naturalOrder ( ) , UpdateFunction . noOp ( ) ) ; if ( tree = = this . columns ) return this ; if ( tree = = other . columns ) return other ; return new Columns ( tree , findFirstComplexIdx ( tree ) ) ; } public boolean containsAll ( Collection < ? > other ) { if ( other = = this ) return true ; if ( other . size ( ) > this . size ( ) ) return false ; BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = BTree . slice ( columns , Comparator . naturalOrder ( ) , BTree . Dir . ASC ) ; for ( Object def : other ) if ( iter . next ( ( ColumnDefinition ) def ) = = null ) return false ; return true ; } public Iterator < ColumnDefinition > simpleColumns ( ) { return BTree . iterator ( columns , <int> , complexIdx - <int> , BTree . Dir . ASC ) ; } public Iterator < ColumnDefinition > complexColumns ( ) { return BTree . iterator ( columns , complexIdx , BTree . size ( columns ) - <int> , BTree . Dir . ASC ) ; } public BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iterator ( ) { return BTree . < ColumnDefinition , ColumnDefinition > slice ( columns , Comparator . naturalOrder ( ) , BTree . Dir . ASC ) ; } public Iterator < ColumnDefinition > selectOrderIterator ( ) { return Iterators . < ColumnDefinition > mergeSorted ( ImmutableList . of ( simpleColumns ( ) , complexColumns ( ) ) , ( s , c ) - > { assert ! s . kind . isPrimaryKeyKind ( ) ; return s . name . bytes . compareTo ( c . name . bytes ) ; } ) ; } public Columns without ( ColumnDefinition column ) { if ( ! contains ( column ) ) return this ; Object [ ] newColumns = BTree . < ColumnDefinition > transformAndFilter ( columns , ( c ) - > c . equals ( column ) ? null : c ) ; return new Columns ( newColumns ) ; } public Predicate < ColumnDefinition > inOrderInclusionTester ( ) { SearchIterator < ColumnDefinition , ColumnDefinition > iter = BTree . slice ( columns , Comparator . naturalOrder ( ) , BTree . Dir . ASC ) ; return column - > iter . next ( column ) ! = null ; } public void digest ( MessageDigest digest ) { for ( ColumnDefinition c : this ) digest . update ( c . name . bytes . duplicate ( ) ) ; } @Override public boolean equals ( Object other ) { if ( other = = this ) return true ; if ( ! ( other instanceof Columns ) ) return false ; Columns that = ( Columns ) other ; return this . complexIdx = = that . complexIdx & & BTree . equals ( this . columns , that . columns ) ; } @Override public int hashCode ( ) { return Objects . hash ( complexIdx , BTree . hashCode ( columns ) ) ; } @Override public String toString ( ) { StringBuilder sb = new StringBuilder ( <str> ) ; boolean first = true ; for ( ColumnDefinition def : this ) { if ( first ) first = false ; else sb . append ( <str> ) ; sb . append ( def . name ) ; } return sb . append ( <str> ) . toString ( ) ; } public static class Serializer { public void serialize ( Columns columns , DataOutputPlus out ) throws IOException { out . writeUnsignedVInt ( columns . size ( ) ) ; for ( ColumnDefinition column : columns ) ByteBufferUtil . writeWithVIntLength ( column . name . bytes , out ) ; } public long serializedSize ( Columns columns ) { long size = TypeSizes . sizeofUnsignedVInt ( columns . size ( ) ) ; for ( ColumnDefinition column : columns ) size + = ByteBufferUtil . serializedSizeWithVIntLength ( column . name . bytes ) ; return size ; } public Columns deserialize ( DataInputPlus in , CFMetaData metadata ) throws IOException { int length = ( int ) in . readUnsignedVInt ( ) ; BTree . Builder < ColumnDefinition > builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; builder . auto ( false ) ; for ( int i = <int> ; i < length ; i + + ) { ByteBuffer name = ByteBufferUtil . readWithVIntLength ( in ) ; ColumnDefinition column = metadata . getColumnDefinition ( name ) ; if ( column = = null ) { column = metadata . getDroppedColumnDefinition ( name ) ; if ( column = = null ) throw new RuntimeException ( <str> + UTF8Type . instance . getString ( name ) + <str> ) ; } builder . add ( column ) ; } return new Columns ( builder . build ( ) ) ; } public void serializeSubset ( Collection < ColumnDefinition > columns , Columns superset , DataOutputPlus out ) throws IOException { int columnCount = columns . size ( ) ; int supersetCount = superset . size ( ) ; if ( columnCount = = supersetCount ) { out . writeUnsignedVInt ( <int> ) ; } else if ( supersetCount < <int> ) { out . writeUnsignedVInt ( encodeBitmap ( columns , superset , supersetCount ) ) ; } else { serializeLargeSubset ( columns , columnCount , superset , supersetCount , out ) ; } } public long serializedSubsetSize ( Collection < ColumnDefinition > columns , Columns superset ) { int columnCount = columns . size ( ) ; int supersetCount = superset . size ( ) ; if ( columnCount = = supersetCount ) { return TypeSizes . sizeofUnsignedVInt ( <int> ) ; } else if ( supersetCount < <int> ) { return TypeSizes . sizeofUnsignedVInt ( encodeBitmap ( columns , superset , supersetCount ) ) ; } else { return serializeLargeSubsetSize ( columns , columnCount , superset , supersetCount ) ; } } public Columns deserializeSubset ( Columns superset , DataInputPlus in ) throws IOException { long encoded = in . readUnsignedVInt ( ) ; if ( encoded = = <int> L ) { return superset ; } else if ( superset . size ( ) > = <int> ) { return deserializeLargeSubset ( in , superset , ( int ) encoded ) ; } else { BTree . Builder < ColumnDefinition > builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; int firstComplexIdx = <int> ; for ( ColumnDefinition column : superset ) { if ( ( encoded & <int> ) = = <int> ) { builder . add ( column ) ; if ( column . isSimple ( ) ) + + firstComplexIdx ; } encoded > > > = <int> ; } return new Columns ( builder . build ( ) , firstComplexIdx ) ; } } private static long encodeBitmap ( Collection < ColumnDefinition > columns , Columns superset , int supersetCount ) { long bitmap = <int> L ; BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = superset . iterator ( ) ; int expectIndex = <int> ; for ( ColumnDefinition column : columns ) { if ( iter . next ( column ) = = null ) throw new IllegalStateException ( columns + <str> + superset ) ; int currentIndex = iter . indexOfCurrent ( ) ; int count = currentIndex - expectIndex ; bitmap | = ( ( <int> < < count ) - <int> ) < < expectIndex ; expectIndex = currentIndex + <int> ; } int count = supersetCount - expectIndex ; bitmap | = ( ( <int> < < count ) - <int> ) < < expectIndex ; return bitmap ; } @DontInline private void serializeLargeSubset ( Collection < ColumnDefinition > columns , int columnCount , Columns superset , int supersetCount , DataOutputPlus out ) throws IOException { out . writeUnsignedVInt ( supersetCount - columnCount ) ; BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = superset . iterator ( ) ; if ( columnCount < supersetCount / <int> ) { for ( ColumnDefinition column : columns ) { if ( iter . next ( column ) = = null ) throw new IllegalStateException ( ) ; out . writeUnsignedVInt ( iter . indexOfCurrent ( ) ) ; } } else { int prev = - <int> ; for ( ColumnDefinition column : columns ) { if ( iter . next ( column ) = = null ) throw new IllegalStateException ( ) ; int cur = iter . indexOfCurrent ( ) ; while ( + + prev ! = cur ) out . writeUnsignedVInt ( prev ) ; } while ( + + prev ! = supersetCount ) out . writeUnsignedVInt ( prev ) ; } } @DontInline private Columns deserializeLargeSubset ( DataInputPlus in , Columns superset , int delta ) throws IOException { int supersetCount = superset . size ( ) ; int columnCount = supersetCount - delta ; BTree . Builder < ColumnDefinition > builder = BTree . builder ( Comparator . naturalOrder ( ) ) ; if ( columnCount < supersetCount / <int> ) { for ( int i = <int> ; i < columnCount ; i + + ) { int idx = ( int ) in . readUnsignedVInt ( ) ; builder . add ( BTree . findByIndex ( superset . columns , idx ) ) ; } } else { Iterator < ColumnDefinition > iter = superset . iterator ( ) ; int idx = <int> ; int skipped = <int> ; while ( true ) { int nextMissingIndex = skipped < delta ? ( int ) in . readUnsignedVInt ( ) : supersetCount ; while ( idx < nextMissingIndex ) { ColumnDefinition def = iter . next ( ) ; builder . add ( def ) ; idx + + ; } if ( idx = = supersetCount ) break ; iter . next ( ) ; idx + + ; skipped + + ; } } return new Columns ( builder . build ( ) ) ; } @DontInline private int serializeLargeSubsetSize ( Collection < ColumnDefinition > columns , int columnCount , Columns superset , int supersetCount ) { int size = TypeSizes . sizeofUnsignedVInt ( supersetCount - columnCount ) ; BTreeSearchIterator < ColumnDefinition , ColumnDefinition > iter = superset . iterator ( ) ; if ( columnCount < supersetCount / <int> ) { for ( ColumnDefinition column : columns ) { if ( iter . next ( column ) = = null ) throw new IllegalStateException ( ) ; size + = TypeSizes . sizeofUnsignedVInt ( iter . indexOfCurrent ( ) ) ; } } else { int prev = - <int> ; for ( ColumnDefinition column : columns ) { if ( iter . next ( column ) = = null ) throw new IllegalStateException ( ) ; int cur = iter . indexOfCurrent ( ) ; while ( + + prev ! = cur ) size + = TypeSizes . sizeofUnsignedVInt ( prev ) ; } while ( + + prev ! = supersetCount ) size + = TypeSizes . sizeofUnsignedVInt ( prev ) ; } return size ; } } } 
