package org . eclipse . debug . tests . viewer . model ; import java . util . Arrays ; import java . util . List ; import junit . framework . TestCase ; import org . eclipse . core . commands . ExecutionException ; import org . eclipse . debug . internal . ui . viewers . model . IInternalTreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . IModelDelta ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ITreeModelViewer ; import org . eclipse . debug . internal . ui . viewers . model . provisional . ModelDelta ; import org . eclipse . debug . tests . viewer . model . TestModel . TestElement ; import org . eclipse . jface . viewers . ISelection ; import org . eclipse . jface . viewers . ITreeSelection ; import org . eclipse . jface . viewers . TreePath ; import org . eclipse . swt . layout . FillLayout ; import org . eclipse . swt . widgets . Display ; import org . eclipse . swt . widgets . Shell ; import org . eclipse . ui . PlatformUI ; abstract public class DeltaTests extends TestCase implements ITestModelUpdatesListenerConstants { Display fDisplay ; Shell fShell ; ITreeModelViewer fViewer ; TestModelUpdatesListener fListener ; public DeltaTests ( String name ) { super ( name ) ; } @Override protected void setUp ( ) throws Exception { fDisplay = PlatformUI . getWorkbench ( ) . getDisplay ( ) ; fShell = new Shell ( fDisplay ) ; fShell . setMaximized ( true ) ; fShell . setLayout ( new FillLayout ( ) ) ; fViewer = createViewer ( fDisplay , fShell ) ; fListener = new TestModelUpdatesListener ( fViewer , false , false ) ; fShell . open ( ) ; } abstract protected IInternalTreeModelViewer createViewer ( Display display , Shell shell ) ; @Override protected void tearDown ( ) throws Exception { fListener . dispose ( ) ; fViewer . getPresentationContext ( ) . dispose ( ) ; fShell . close ( ) ; while ( ! fShell . isDisposed ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } } @Override protected void runTest ( ) throws Throwable { try { super . runTest ( ) ; } catch ( Throwable t ) { throw new ExecutionException ( <str> + t . getMessage ( ) + <str> + fListener . toString ( ) , t ) ; } } public void testUpdateLabel ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestElement element = model . getRootElement ( ) . getChildren ( ) [ <int> ] ; TreePath elementPath = new TreePath ( new Object [ ] { element } ) ; ModelDelta delta = model . appendElementLabel ( elementPath , <str> ) ; fListener . reset ( elementPath , element , - <int> , true , false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( LABEL_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testRefreshStruct ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestElement element = model . getRootElement ( ) . getChildren ( ) [ <int> ] ; TreePath elementPath = new TreePath ( new Object [ ] { element } ) ; TestElement [ ] newChildren = new TestElement [ ] { new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , new TestElement ( model , <str> , new TestElement [ <int> ] ) , } ; ModelDelta delta = model . setElementChildren ( elementPath , newChildren ) ; fListener . reset ( elementPath , element , - <int> , true , false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testRefreshStruct2 ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; String prefix = <str> ; model . setElementChildren ( TreePath . EMPTY , new TestElement [ ] { new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , true , false , new TestElement [ ] { new TestElement ( model , prefix + <str> , true , true , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , false , true , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , true , false , new TestElement [ <int> ] ) , } ) , new TestElement ( model , prefix + <str> , new TestElement [ ] { new TestElement ( model , prefix + <str> , new TestElement [ ] { new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , prefix + <str> , new TestElement [ ] { new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , } ) , new TestElement ( model , prefix + <str> , new TestElement [ ] { new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , new TestElement ( model , prefix + <str> , new TestElement [ <int> ] ) , } ) , } ) } ) ; TestElement element = model . getRootElement ( ) ; fListener . reset ( TreePath . EMPTY , element , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( element , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testRefreshCoalesceStruct ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; TestElement [ ] rootChildren = model . getRootElement ( ) . getChildren ( ) ; for ( int i = <int> ; i < rootChildren . length ; i + + ) { model . setElementChildren ( new TreePath ( new Object [ ] { rootChildren [ i ] } ) , new TestElement [ ] { new TestElement ( model , i + <str> , new TestElement [ <int> ] ) } ) ; } fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; model . postDelta ( new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; assertTrue ( fListener . checkCoalesced ( TreePath . EMPTY , <int> , <int> ) ) ; } public void testInsert ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestElement element = new TestElement ( model , <str> , new TestElement [ <int> ] ) ; TreePath elementPath = new TreePath ( new Object [ ] { element } ) ; ModelDelta delta = model . insertElementChild ( TreePath . EMPTY , <int> , element ) ; fListener . reset ( ) ; fListener . addChildreUpdate ( TreePath . EMPTY , <int> ) ; fListener . addHasChildrenUpdate ( elementPath ) ; fListener . addLabelUpdate ( elementPath ) ; fListener . setFailOnRedundantUpdates ( false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testInsertAndSelect ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestElement element0 = new TestElement ( model , <str> , new TestElement [ ] { } ) ; TestElement element1 = new TestElement ( model , <str> , new TestElement [ ] { } ) ; TreePath elementPath0 = new TreePath ( new Object [ ] { element0 } ) ; TreePath elementPath1 = new TreePath ( new Object [ ] { element1 } ) ; ModelDelta rootDelta = model . insertElementChild ( TreePath . EMPTY , <int> , element0 ) ; rootDelta = model . insertElementChild ( rootDelta , TreePath . EMPTY , <int> , element1 ) ; ModelDelta delta0 = rootDelta . getChildDelta ( element0 ) ; delta0 . setFlags ( delta0 . getFlags ( ) | IModelDelta . SELECT ) ; fListener . reset ( ) ; fListener . addHasChildrenUpdate ( elementPath0 ) ; fListener . addHasChildrenUpdate ( elementPath1 ) ; fListener . addLabelUpdate ( elementPath0 ) ; fListener . addLabelUpdate ( elementPath1 ) ; fListener . setFailOnRedundantUpdates ( false ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testInsertAndRemove ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; IModelDelta removeDelta = model . removeElementChild ( TreePath . EMPTY , <int> ) . getChildDeltas ( ) [ <int> ] ; TestElement element = new TestElement ( model , <str> , new TestElement [ ] { } ) ; TreePath elementPath = new TreePath ( new Object [ ] { element } ) ; IModelDelta insertDelta = model . insertElementChild ( TreePath . EMPTY , <int> , element ) . getChildDeltas ( ) [ <int> ] ; ModelDelta combinedDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . NO_CHANGE , <int> , model . getRootElement ( ) . getChildren ( ) . length ) ; combinedDelta . addNode ( insertDelta . getElement ( ) , insertDelta . getIndex ( ) , insertDelta . getFlags ( ) , insertDelta . getChildCount ( ) ) ; combinedDelta . addNode ( removeDelta . getElement ( ) , removeDelta . getIndex ( ) , removeDelta . getFlags ( ) , removeDelta . getChildCount ( ) ) ; fListener . reset ( ) ; fListener . addHasChildrenUpdate ( elementPath ) ; fListener . addLabelUpdate ( elementPath ) ; fListener . setFailOnRedundantUpdates ( false ) ; model . postDelta ( combinedDelta ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testAddElement ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; TestElement element = new TestElement ( model , <str> , new TestElement [ <int> ] ) ; TreePath elementPath = new TreePath ( new Object [ ] { element } ) ; ModelDelta delta = model . addElementChild ( TreePath . EMPTY , null , <int> , element ) ; fListener . reset ( elementPath , element , - <int> , true , false ) ; fListener . addChildreUpdate ( TreePath . EMPTY , <int> ) ; fListener . setFailOnRedundantUpdates ( false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void _x_testAddUnexpandedElement ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TreePath parentPath = model . findElement ( <str> ) ; ModelDelta rootDelta = model . addElementChild ( parentPath , null , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . addElementChild ( parentPath , rootDelta , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . addElementChild ( parentPath , rootDelta , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; model . addElementChild ( parentPath , rootDelta , <int> , new TestElement ( model , <str> , new TestElement [ <int> ] ) ) ; fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( false ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( ) ; fListener . addUpdates ( ( IInternalTreeModelViewer ) fViewer , TreePath . EMPTY , model . getRootElement ( ) , - <int> , ALL_UPDATES_COMPLETE ) ; rootDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ; model . getElementDelta ( rootDelta , model . findElement ( <str> ) , true ) . setFlags ( IModelDelta . CONTENT ) ; model . getElementDelta ( rootDelta , model . findElement ( <str> ) , true ) . setFlags ( IModelDelta . CONTENT ) ; model . getElementDelta ( rootDelta , model . findElement ( <str> ) , true ) . setFlags ( IModelDelta . CONTENT ) ; model . getElementDelta ( rootDelta , model . findElement ( <str> ) , true ) . setFlags ( IModelDelta . CONTENT ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( parentPath , model . getElement ( parentPath ) , <int> , false , true ) ; ( ( IInternalTreeModelViewer ) fViewer ) . expandToLevel ( parentPath , <int> ) ; while ( fListener . isFinished ( CONTENT_SEQUENCE_STARTED ) & & ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , parentPath ) ; } public void _x_testRefreshUnexpandedElementsChildren ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fViewer . setAutoExpandLevel ( <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } TreePath parentPath = model . findElement ( <str> ) ; fListener . reset ( parentPath , model . getElement ( parentPath ) , <int> , false , true ) ; ( ( IInternalTreeModelViewer ) fViewer ) . expandToLevel ( parentPath , <int> ) ; while ( fListener . isFinished ( CONTENT_SEQUENCE_STARTED ) & & ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } ( ( IInternalTreeModelViewer ) fViewer ) . setExpandedState ( parentPath , false ) ; fListener . reset ( ) ; fListener . addUpdates ( ( IInternalTreeModelViewer ) fViewer , TreePath . EMPTY , model . getRootElement ( ) , - <int> , ALL_UPDATES_COMPLETE ) ; ModelDelta rootDelta = new ModelDelta ( model . getRootElement ( ) , IModelDelta . CONTENT ) ; model . getElementDelta ( rootDelta , model . findElement ( <str> ) , true ) . setFlags ( IModelDelta . CONTENT ) ; model . getElementDelta ( rootDelta , model . findElement ( <str> ) , true ) . setFlags ( IModelDelta . CONTENT ) ; model . getElementDelta ( rootDelta , model . findElement ( <str> ) , true ) . setFlags ( IModelDelta . CONTENT ) ; model . postDelta ( rootDelta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | ALL_UPDATES_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } fListener . reset ( parentPath , model . getElement ( parentPath ) , <int> , false , true ) ; ( ( IInternalTreeModelViewer ) fViewer ) . expandToLevel ( parentPath , <int> ) ; while ( fListener . isFinished ( CONTENT_SEQUENCE_STARTED ) & & ! fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , parentPath , true ) ; } public void testRemove ( ) throws InterruptedException { TestModel model = TestModel . simpleSingleLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; ModelDelta delta = model . removeElementChild ( TreePath . EMPTY , <int> ) ; fListener . reset ( ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testExpandAndSelect ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( false ) ; TestElement element = model . getRootElement ( ) ; TreePath path_root = TreePath . EMPTY ; ModelDelta delta = new ModelDelta ( model . getRootElement ( ) , - <int> , IModelDelta . EXPAND , element . getChildren ( ) . length ) ; ModelDelta deltaRoot = delta ; element = element . getChildren ( ) [ <int> ] ; TreePath path_root_3 = path_root . createChildPath ( element ) ; delta = delta . addNode ( element , <int> , IModelDelta . EXPAND , element . fChildren . length ) ; fListener . addChildreUpdate ( path_root_3 , <int> ) ; TreePath path_root_3_1 = path_root_3 . createChildPath ( element . getChildren ( ) [ <int> ] ) ; fListener . addHasChildrenUpdate ( path_root_3_1 ) ; fListener . addLabelUpdate ( path_root_3_1 ) ; TreePath path_root_3_3 = path_root_3 . createChildPath ( element . getChildren ( ) [ <int> ] ) ; fListener . addHasChildrenUpdate ( path_root_3_3 ) ; fListener . addLabelUpdate ( path_root_3_3 ) ; fListener . addChildreUpdate ( path_root_3 , <int> ) ; element = element . getChildren ( ) [ <int> ] ; TreePath path_root_3_2 = path_root_3 . createChildPath ( element ) ; delta = delta . addNode ( element , <int> , IModelDelta . EXPAND , element . fChildren . length ) ; fListener . addLabelUpdate ( path_root_3_2 ) ; TreePath path_root_3_2_1 = path_root_3_2 . createChildPath ( element . getChildren ( ) [ <int> ] ) ; fListener . addHasChildrenUpdate ( path_root_3_2_1 ) ; fListener . addLabelUpdate ( path_root_3_2_1 ) ; TreePath path_root_3_2_3 = path_root_3_2 . createChildPath ( element . getChildren ( ) [ <int> ] ) ; fListener . addHasChildrenUpdate ( path_root_3_2_3 ) ; fListener . addLabelUpdate ( path_root_3_2_3 ) ; fListener . addChildreUpdate ( path_root_3_2 , <int> ) ; fListener . addChildreUpdate ( path_root_3_2 , <int> ) ; element = element . getChildren ( ) [ <int> ] ; TreePath path_root_3_2_2 = path_root_3_2 . createChildPath ( element ) ; delta = delta . addNode ( element , <int> , IModelDelta . SELECT , element . fChildren . length ) ; fListener . addLabelUpdate ( path_root_3_2_2 ) ; fListener . addHasChildrenUpdate ( path_root_3_2_2 ) ; IInternalTreeModelViewer contentProviderViewer = ( IInternalTreeModelViewer ) fViewer ; assertFalse ( contentProviderViewer . getExpandedState ( path_root_3 ) ) ; assertFalse ( contentProviderViewer . getExpandedState ( path_root_3_2 ) ) ; assertFalse ( contentProviderViewer . getExpandedState ( path_root_3_2_2 ) ) ; model . postDelta ( deltaRoot ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( contentProviderViewer . getExpandedState ( path_root_3 ) ) ; assertTrue ( contentProviderViewer . getExpandedState ( path_root_3_2 ) ) ; assertFalse ( contentProviderViewer . getExpandedState ( path_root_3_2_2 ) ) ; ISelection selection = fViewer . getSelection ( ) ; if ( selection instanceof ITreeSelection ) { List < TreePath > selectionPathsList = Arrays . asList ( ( ( ITreeSelection ) selection ) . getPaths ( ) ) ; assertTrue ( selectionPathsList . contains ( path_root_3_2_2 ) ) ; } else { fail ( <str> ) ; } } public void testExpandAndSelect_simple ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; fListener . reset ( ) ; fListener . setFailOnRedundantUpdates ( false ) ; TestElement element = model . getRootElement ( ) ; TreePath path_root = TreePath . EMPTY ; ModelDelta delta = new ModelDelta ( model . getRootElement ( ) , - <int> , IModelDelta . EXPAND , element . getChildren ( ) . length ) ; ModelDelta deltaRoot = delta ; element = element . getChildren ( ) [ <int> ] ; TreePath path_root_3 = path_root . createChildPath ( element ) ; delta . addNode ( element , <int> , IModelDelta . SELECT | IModelDelta . EXPAND , element . fChildren . length ) ; IInternalTreeModelViewer contentProviderViewer = ( IInternalTreeModelViewer ) fViewer ; assertFalse ( contentProviderViewer . getExpandedState ( path_root_3 ) ) ; model . postDelta ( deltaRoot ) ; while ( true ) { if ( fListener . isFinished ( MODEL_CHANGED_COMPLETE ) ) { if ( fListener . isFinished ( CONTENT_SEQUENCE_COMPLETE | LABEL_SEQUENCE_COMPLETE ) ) { break ; } } if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; assertTrue ( contentProviderViewer . getExpandedState ( path_root_3 ) ) ; ISelection selection = fViewer . getSelection ( ) ; if ( selection instanceof ITreeSelection ) { List < TreePath > selectionPathsList = Arrays . asList ( ( ( ITreeSelection ) selection ) . getPaths ( ) ) ; assertTrue ( selectionPathsList . contains ( path_root_3 ) ) ; } else { fail ( <str> ) ; } } public void testCompositeModelRefreshStruct ( ) throws InterruptedException { TestModel model = TestModel . compositeMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; TreePath m4_2_1Path = model . findElement ( <str> ) ; TestElement m4_2_1 = model . getElement ( m4_2_1Path ) ; TestModel m4 = m4_2_1 . getModel ( ) ; TestElement [ ] newChildren = new TestElement [ ] { new TestElement ( m4 , <str> , new TestElement [ <int> ] ) , new TestElement ( m4 , <str> , new TestElement [ <int> ] ) , new TestElement ( m4 , <str> , new TestElement [ <int> ] ) , } ; ModelDelta delta = m4 . setElementChildren ( m4_2_1Path , newChildren ) ; fListener . reset ( m4_2_1Path , m4_2_1 , - <int> , true , false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testCompositeModelAddElement ( ) throws InterruptedException { TestModel model = TestModel . compositeMultiLevel ( ) ; fViewer . setAutoExpandLevel ( - <int> ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , - <int> , false , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; TreePath m3_1Path = model . findElement ( <str> ) ; TestElement m3_1 = model . getElement ( m3_1Path ) ; TestModel m3 = m3_1 . getModel ( ) ; TestElement m3_1_new = new TestElement ( m3 , <str> , new TestElement [ <int> ] ) ; TreePath m3_1_newPath = m3_1Path . createChildPath ( m3_1_new ) ; ModelDelta delta = m3 . addElementChild ( m3_1Path , null , <int> , m3_1_new ) ; fListener . reset ( m3_1_newPath , m3_1_new , - <int> , true , false ) ; fListener . addChildreUpdate ( m3_1Path , <int> ) ; fListener . setFailOnRedundantUpdates ( false ) ; m3 . postDelta ( delta ) ; while ( ! fListener . isFinished ( ALL_UPDATES_COMPLETE | MODEL_CHANGED_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY ) ; } public void testBug292322 ( ) throws InterruptedException { TestModel model = TestModel . simpleMultiLevel ( ) ; fListener . reset ( TreePath . EMPTY , model . getRootElement ( ) , <int> , true , false ) ; fViewer . setInput ( model . getRootElement ( ) ) ; while ( ! fListener . isFinished ( ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; TreePath parentPath = model . findElement ( <str> ) ; TestElement parentElement = model . getElement ( parentPath ) ; ModelDelta delta = model . removeElementChild ( parentPath , <int> ) ; fListener . reset ( parentPath , parentElement , <int> , false , false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CONTENT_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; model . removeElementChild ( parentPath , <int> ) ; fListener . reset ( parentPath , parentElement , <int> , false , false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CONTENT_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; model . removeElementChild ( parentPath , <int> ) ; fListener . reset ( parentPath , parentElement , <int> , false , false ) ; model . postDelta ( delta ) ; while ( ! fListener . isFinished ( MODEL_CHANGED_COMPLETE | CONTENT_COMPLETE ) ) { if ( ! fDisplay . readAndDispatch ( ) ) { Thread . sleep ( <int> ) ; } } model . validateData ( fViewer , TreePath . EMPTY , true ) ; } } 
