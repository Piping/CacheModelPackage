package org . apache . cassandra . cql3 . statements ; import java . util . * ; import java . util . stream . Collectors ; import com . google . common . collect . Iterables ; import org . apache . cassandra . auth . Permission ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . config . ColumnDefinition ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . config . ViewDefinition ; import org . apache . cassandra . cql3 . * ; import org . apache . cassandra . cql3 . restrictions . StatementRestrictions ; import org . apache . cassandra . cql3 . selection . RawSelector ; import org . apache . cassandra . cql3 . selection . Selectable ; import org . apache . cassandra . db . marshal . AbstractType ; import org . apache . cassandra . db . marshal . ReversedType ; import org . apache . cassandra . db . view . View ; import org . apache . cassandra . exceptions . AlreadyExistsException ; import org . apache . cassandra . exceptions . InvalidRequestException ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . exceptions . UnauthorizedException ; import org . apache . cassandra . schema . TableParams ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . service . ClientWarn ; import org . apache . cassandra . service . MigrationManager ; import org . apache . cassandra . thrift . ThriftValidation ; import org . apache . cassandra . transport . Event ; public class CreateViewStatement extends SchemaAlteringStatement { private final CFName baseName ; private final List < RawSelector > selectClause ; private final WhereClause whereClause ; private final List < ColumnIdentifier . Raw > partitionKeys ; private final List < ColumnIdentifier . Raw > clusteringKeys ; public final CFProperties properties = new CFProperties ( ) ; private final boolean ifNotExists ; public CreateViewStatement ( CFName viewName , CFName baseName , List < RawSelector > selectClause , WhereClause whereClause , List < ColumnIdentifier . Raw > partitionKeys , List < ColumnIdentifier . Raw > clusteringKeys , boolean ifNotExists ) { super ( viewName ) ; this . baseName = baseName ; this . selectClause = selectClause ; this . whereClause = whereClause ; this . partitionKeys = partitionKeys ; this . clusteringKeys = clusteringKeys ; this . ifNotExists = ifNotExists ; } public void checkAccess ( ClientState state ) throws UnauthorizedException , InvalidRequestException { if ( ! baseName . hasKeyspace ( ) ) baseName . setKeyspace ( keyspace ( ) , true ) ; state . hasColumnFamilyAccess ( keyspace ( ) , baseName . getColumnFamily ( ) , Permission . ALTER ) ; } public void validate ( ClientState state ) throws RequestValidationException { } private interface AddColumn { void add ( ColumnIdentifier identifier , AbstractType < ? > type ) ; } private void add ( CFMetaData baseCfm , Iterable < ColumnIdentifier > columns , AddColumn adder ) { for ( ColumnIdentifier column : columns ) { AbstractType < ? > type = baseCfm . getColumnDefinition ( column ) . type ; if ( properties . definedOrdering . containsKey ( column ) ) { boolean desc = properties . definedOrdering . get ( column ) ; if ( ! desc & & type . isReversed ( ) ) { type = ( ( ReversedType ) type ) . baseType ; } else if ( desc & & ! type . isReversed ( ) ) { type = ReversedType . getInstance ( type ) ; } } adder . add ( column , type ) ; } } public Event . SchemaChange announceMigration ( boolean isLocalOnly ) throws RequestValidationException { properties . validate ( ) ; if ( properties . useCompactStorage ) throw new InvalidRequestException ( <str> ) ; if ( ! baseName . getKeyspace ( ) . equals ( keyspace ( ) ) ) throw new InvalidRequestException ( <str> ) ; CFMetaData cfm = ThriftValidation . validateColumnFamily ( baseName . getKeyspace ( ) , baseName . getColumnFamily ( ) ) ; if ( cfm . isCounter ( ) ) throw new InvalidRequestException ( <str> ) ; if ( cfm . isView ( ) ) throw new InvalidRequestException ( <str> ) ; if ( cfm . params . gcGraceSeconds = = <int> ) { throw new InvalidRequestException ( String . format ( <str> + <str> + <str> + <str> + <str> , cfName . getColumnFamily ( ) , baseName . getColumnFamily ( ) ) ) ; } Set < ColumnIdentifier > included = new HashSet < > ( ) ; for ( RawSelector selector : selectClause ) { Selectable . Raw selectable = selector . selectable ; if ( selectable instanceof Selectable . WithFieldSelection . Raw ) throw new InvalidRequestException ( <str> ) ; if ( selectable instanceof Selectable . WithFunction . Raw ) throw new InvalidRequestException ( <str> ) ; if ( selectable instanceof Selectable . WritetimeOrTTL . Raw ) throw new InvalidRequestException ( <str> ) ; ColumnIdentifier identifier = ( ColumnIdentifier ) selectable . prepare ( cfm ) ; if ( selector . alias ! = null ) throw new InvalidRequestException ( String . format ( <str> , identifier . toString ( ) , selector . alias . toString ( ) ) ) ; ColumnDefinition cdef = cfm . getColumnDefinition ( identifier ) ; if ( cdef = = null ) throw new InvalidRequestException ( <str> + identifier ) ; if ( cdef . isStatic ( ) ) ClientWarn . warn ( String . format ( <str> , identifier ) ) ; else included . add ( identifier ) ; } Set < ColumnIdentifier . Raw > targetPrimaryKeys = new HashSet < > ( ) ; for ( ColumnIdentifier . Raw identifier : Iterables . concat ( partitionKeys , clusteringKeys ) ) { if ( ! targetPrimaryKeys . add ( identifier ) ) throw new InvalidRequestException ( <str> + identifier ) ; ColumnDefinition cdef = cfm . getColumnDefinition ( identifier . prepare ( cfm ) ) ; if ( cdef = = null ) throw new InvalidRequestException ( <str> + identifier ) ; if ( cfm . getColumnDefinition ( identifier . prepare ( cfm ) ) . type . isMultiCell ( ) ) throw new InvalidRequestException ( String . format ( <str> , identifier ) ) ; if ( cdef . isStatic ( ) ) throw new InvalidRequestException ( String . format ( <str> , identifier ) ) ; } Map < ColumnIdentifier . Raw , Boolean > orderings = Collections . emptyMap ( ) ; SelectStatement . Parameters parameters = new SelectStatement . Parameters ( orderings , false , true , false ) ; SelectStatement . RawStatement rawSelect = new SelectStatement . RawStatement ( baseName , parameters , selectClause , whereClause , null ) ; ClientState state = ClientState . forInternalCalls ( ) ; state . setKeyspace ( keyspace ( ) ) ; rawSelect . prepareKeyspace ( state ) ; rawSelect . setBoundVariables ( getBoundVariables ( ) ) ; ParsedStatement . Prepared prepared = rawSelect . prepare ( true ) ; SelectStatement select = ( SelectStatement ) prepared . statement ; StatementRestrictions restrictions = select . getRestrictions ( ) ; if ( ! prepared . boundNames . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; if ( ! restrictions . nonPKRestrictedColumns ( false ) . isEmpty ( ) ) { throw new InvalidRequestException ( String . format ( <str> + <str> , restrictions . nonPKRestrictedColumns ( false ) . stream ( ) . map ( def - > def . name . toString ( ) ) . collect ( Collectors . joining ( <str> ) ) ) ) ; } String whereClauseText = View . relationsToWhereClause ( whereClause . relations ) ; Set < ColumnIdentifier > basePrimaryKeyCols = new HashSet < > ( ) ; for ( ColumnDefinition definition : Iterables . concat ( cfm . partitionKeyColumns ( ) , cfm . clusteringColumns ( ) ) ) basePrimaryKeyCols . add ( definition . name ) ; List < ColumnIdentifier > targetClusteringColumns = new ArrayList < > ( ) ; List < ColumnIdentifier > targetPartitionKeys = new ArrayList < > ( ) ; boolean hasNonPKColumn = false ; for ( ColumnIdentifier . Raw raw : partitionKeys ) hasNonPKColumn = getColumnIdentifier ( cfm , basePrimaryKeyCols , hasNonPKColumn , raw , targetPartitionKeys , restrictions ) ; for ( ColumnIdentifier . Raw raw : clusteringKeys ) hasNonPKColumn = getColumnIdentifier ( cfm , basePrimaryKeyCols , hasNonPKColumn , raw , targetClusteringColumns , restrictions ) ; boolean missingClusteringColumns = false ; StringBuilder columnNames = new StringBuilder ( ) ; List < ColumnIdentifier > includedColumns = new ArrayList < > ( ) ; for ( ColumnDefinition def : cfm . allColumns ( ) ) { ColumnIdentifier identifier = def . name ; if ( ( included . isEmpty ( ) | | included . contains ( identifier ) ) & & ! targetClusteringColumns . contains ( identifier ) & & ! targetPartitionKeys . contains ( identifier ) & & ! def . isStatic ( ) ) { includedColumns . add ( identifier ) ; } if ( ! def . isPrimaryKeyColumn ( ) ) continue ; if ( ! targetClusteringColumns . contains ( identifier ) & & ! targetPartitionKeys . contains ( identifier ) ) { if ( missingClusteringColumns ) columnNames . append ( <str> ) ; else missingClusteringColumns = true ; columnNames . append ( identifier ) ; } } if ( missingClusteringColumns ) throw new InvalidRequestException ( String . format ( <str> , columnFamily ( ) , baseName . getColumnFamily ( ) , columnNames . toString ( ) ) ) ; if ( targetPartitionKeys . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; if ( targetClusteringColumns . isEmpty ( ) ) throw new InvalidRequestException ( <str> ) ; CFMetaData . Builder cfmBuilder = CFMetaData . Builder . createView ( keyspace ( ) , columnFamily ( ) ) ; add ( cfm , targetPartitionKeys , cfmBuilder : : addPartitionKey ) ; add ( cfm , targetClusteringColumns , cfmBuilder : : addClusteringColumn ) ; add ( cfm , includedColumns , cfmBuilder : : addRegularColumn ) ; TableParams params = properties . properties . asNewTableParams ( ) ; CFMetaData viewCfm = cfmBuilder . build ( ) . params ( params ) ; ViewDefinition definition = new ViewDefinition ( keyspace ( ) , columnFamily ( ) , Schema . instance . getId ( keyspace ( ) , baseName . getColumnFamily ( ) ) , baseName . getColumnFamily ( ) , included . isEmpty ( ) , rawSelect , whereClauseText , viewCfm ) ; try { MigrationManager . announceNewView ( definition , isLocalOnly ) ; return new Event . SchemaChange ( Event . SchemaChange . Change . CREATED , Event . SchemaChange . Target . TABLE , keyspace ( ) , columnFamily ( ) ) ; } catch ( AlreadyExistsException e ) { if ( ifNotExists ) return null ; throw e ; } } private static boolean getColumnIdentifier ( CFMetaData cfm , Set < ColumnIdentifier > basePK , boolean hasNonPKColumn , ColumnIdentifier . Raw raw , List < ColumnIdentifier > columns , StatementRestrictions restrictions ) { ColumnIdentifier identifier = raw . prepare ( cfm ) ; ColumnDefinition def = cfm . getColumnDefinition ( identifier ) ; boolean isPk = basePK . contains ( identifier ) ; if ( ! isPk & & hasNonPKColumn ) throw new InvalidRequestException ( String . format ( <str> , identifier ) ) ; boolean isSinglePartitionKey = cfm . getColumnDefinition ( identifier ) . isPartitionKey ( ) & & cfm . partitionKeyColumns ( ) . size ( ) = = <int> ; if ( ! isSinglePartitionKey & & ! restrictions . isRestricted ( def ) ) throw new InvalidRequestException ( String . format ( <str> , identifier ) ) ; columns . add ( identifier ) ; return ! isPk ; } } 
