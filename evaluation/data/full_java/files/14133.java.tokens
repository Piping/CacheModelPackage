package org . gradle . messaging . remote . internal ; import org . gradle . messaging . remote . internal . protocol . ChannelAvailable ; import org . gradle . messaging . remote . internal . protocol . ChannelUnavailable ; import org . gradle . messaging . remote . internal . protocol . DiscoveryMessage ; import org . gradle . messaging . remote . internal . protocol . LookupRequest ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import java . util . HashMap ; import java . util . Map ; import java . util . concurrent . TimeUnit ; public class ChannelLookupProtocol implements Protocol < DiscoveryMessage > { private static final Logger LOGGER = LoggerFactory . getLogger ( ChannelLookupProtocol . class ) ; private final Map < String , RequestDetails > channels = new HashMap < String , RequestDetails > ( ) ; private ProtocolContext < DiscoveryMessage > context ; public void start ( ProtocolContext < DiscoveryMessage > context ) { this . context = context ; } public void handleOutgoing ( DiscoveryMessage message ) { if ( message instanceof LookupRequest ) { LookupRequest lookupRequest = ( LookupRequest ) message ; LOGGER . info ( <str> , lookupRequest ) ; RequestDetails request = new RequestDetails ( lookupRequest ) ; channels . put ( lookupRequest . getChannel ( ) , request ) ; request . run ( ) ; } else { throw new UnsupportedOperationException ( ) ; } } public void handleIncoming ( DiscoveryMessage message ) { if ( message instanceof ChannelAvailable ) { ChannelAvailable channelAvailable = ( ChannelAvailable ) message ; LOGGER . info ( <str> , channelAvailable ) ; RequestDetails request = channels . get ( channelAvailable . getChannel ( ) ) ; if ( request ! = null ) { LOGGER . info ( <str> , request . lookupRequest ) ; request . handleResponse ( channelAvailable ) ; } else { LOGGER . info ( <str> ) ; } } else if ( ! ( message instanceof LookupRequest ) & & ! ( message instanceof ChannelUnavailable ) ) { LOGGER . info ( <str> , message ) ; } else { LOGGER . info ( <str> , message ) ; } } public void stopRequested ( ) { context . stopped ( ) ; } private class RequestDetails implements Runnable { private final LookupRequest lookupRequest ; ProtocolContext . Callback timeout ; int attempts ; public RequestDetails ( LookupRequest lookupRequest ) { this . lookupRequest = lookupRequest ; } public void handleResponse ( ChannelAvailable channelAvailable ) { timeout . cancel ( ) ; context . dispatchIncoming ( channelAvailable ) ; } public void run ( ) { attempts + + ; timeout = context . callbackLater ( getTimeoutSeconds ( ) , TimeUnit . SECONDS , this ) ; context . dispatchOutgoing ( lookupRequest ) ; } private int getTimeoutSeconds ( ) { if ( attempts > <int> ) { return <int> ; } if ( attempts > <int> ) { return <int> ; } return <int> ; } } } 
