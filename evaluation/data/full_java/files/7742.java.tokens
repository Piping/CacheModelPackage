package org . elasticsearch . action . admin . indices . upgrade ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . Version ; import org . elasticsearch . action . admin . indices . segments . IndexSegments ; import org . elasticsearch . action . admin . indices . segments . IndexShardSegments ; import org . elasticsearch . action . admin . indices . segments . IndicesSegmentResponse ; import org . elasticsearch . action . admin . indices . segments . ShardSegments ; import org . elasticsearch . action . admin . indices . upgrade . get . IndexUpgradeStatus ; import org . elasticsearch . action . admin . indices . upgrade . get . UpgradeStatusResponse ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . client . Client ; import org . elasticsearch . cluster . routing . allocation . decider . ConcurrentRebalanceAllocationDecider ; import org . elasticsearch . cluster . routing . allocation . decider . EnableAllocationDecider ; import org . elasticsearch . common . logging . ESLogger ; import org . elasticsearch . common . logging . Loggers ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . index . engine . Segment ; import org . elasticsearch . test . ESBackcompatTestCase ; import org . elasticsearch . test . ESIntegTestCase ; import org . junit . BeforeClass ; import java . util . ArrayList ; import java . util . Collection ; import java . util . List ; import java . util . function . Predicate ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertNoFailures ; @ESIntegTestCase.ClusterScope ( scope = ESIntegTestCase . Scope . TEST ) public class UpgradeIT extends ESBackcompatTestCase { @BeforeClass public static void checkUpgradeVersion ( ) { final boolean luceneVersionMatches = ( globalCompatibilityVersion ( ) . luceneVersion . major = = Version . CURRENT . luceneVersion . major & & globalCompatibilityVersion ( ) . luceneVersion . minor = = Version . CURRENT . luceneVersion . minor ) ; assumeFalse ( <str> , luceneVersionMatches ) ; } @Override protected int minExternalNodes ( ) { return <int> ; } public void testUpgrade ( ) throws Exception { Settings . Builder builder = Settings . builder ( ) ; builder . put ( ConcurrentRebalanceAllocationDecider . CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE , <int> ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setPersistentSettings ( builder ) . get ( ) ; int numIndexes = randomIntBetween ( <int> , <int> ) ; String [ ] indexNames = new String [ numIndexes ] ; for ( int i = <int> ; i < numIndexes ; + + i ) { final String indexName = <str> + i ; indexNames [ i ] = indexName ; Settings settings = Settings . builder ( ) . put ( <str> , backwardsCluster ( ) . newNodePattern ( ) ) . put ( <str> , <int> f ) . put ( indexSettings ( ) ) . build ( ) ; assertAcked ( prepareCreate ( indexName ) . setSettings ( settings ) ) ; ensureGreen ( indexName ) ; assertAllShardsOnNodes ( indexName , backwardsCluster ( ) . backwardsNodePattern ( ) ) ; int numDocs = scaledRandomIntBetween ( <int> , <int> ) ; List < IndexRequestBuilder > docs = new ArrayList < > ( ) ; for ( int j = <int> ; j < numDocs ; + + j ) { String id = Integer . toString ( j ) ; docs . add ( client ( ) . prepareIndex ( indexName , <str> , id ) . setSource ( <str> , <str> ) ) ; } indexRandom ( true , docs ) ; ensureGreen ( indexName ) ; if ( globalCompatibilityVersion ( ) . before ( Version . V_1_4_0_Beta1 ) ) { assertTrue ( awaitBusy ( ( ) - > flush ( indexName ) . getFailedShards ( ) = = <int> ) ) ; } else { assertEquals ( <int> , flush ( indexName ) . getFailedShards ( ) ) ; } numDocs = scaledRandomIntBetween ( <int> , <int> ) ; docs = new ArrayList < > ( ) ; for ( int j = <int> ; j < numDocs ; + + j ) { String id = Integer . toString ( j ) ; docs . add ( client ( ) . prepareIndex ( indexName , <str> , id ) . setSource ( <str> , <str> ) ) ; } indexRandom ( true , docs ) ; ensureGreen ( indexName ) ; } logger . debug ( <str> ) ; backwardsCluster ( ) . allowOnAllNodes ( indexNames ) ; ensureGreen ( ) ; builder = Settings . builder ( ) ; builder . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , EnableAllocationDecider . Allocation . NONE ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( builder ) . get ( ) ; backwardsCluster ( ) . upgradeAllNodes ( ) ; builder = Settings . builder ( ) ; builder . put ( EnableAllocationDecider . CLUSTER_ROUTING_REBALANCE_ENABLE , EnableAllocationDecider . Rebalance . NONE ) ; builder . put ( EnableAllocationDecider . CLUSTER_ROUTING_ALLOCATION_ENABLE , EnableAllocationDecider . Allocation . ALL ) ; client ( ) . admin ( ) . cluster ( ) . prepareUpdateSettings ( ) . setTransientSettings ( builder ) . get ( ) ; ensureGreen ( ) ; logger . info ( <str> ) ; logSegmentsState ( ) ; assertNotUpgraded ( client ( ) ) ; final String indexToUpgrade = <str> + randomInt ( numIndexes - <int> ) ; assertFalse ( hasAncientSegments ( client ( ) , indexToUpgrade ) ) ; logger . info ( <str> + indexToUpgrade ) ; assertNoFailures ( client ( ) . admin ( ) . indices ( ) . prepareUpgrade ( indexToUpgrade ) . get ( ) ) ; awaitBusy ( ( ) - > { try { return isUpgraded ( client ( ) , indexToUpgrade ) ; } catch ( Exception e ) { throw ExceptionsHelper . convertToRuntime ( e ) ; } } ) ; logger . info ( <str> ) ; logger . info ( <str> ) ; assertNoFailures ( client ( ) . admin ( ) . indices ( ) . prepareUpgrade ( ) . get ( ) ) ; logSegmentsState ( ) ; logger . info ( <str> ) ; assertUpgraded ( client ( ) ) ; } public static void assertNotUpgraded ( Client client , String . . . index ) throws Exception { for ( IndexUpgradeStatus status : getUpgradeStatus ( client , index ) ) { assertTrue ( <str> + status . getIndex ( ) + <str> , status . getTotalBytes ( ) ! = <int> ) ; assertTrue ( <str> + status . getIndex ( ) + <str> , status . getTotalBytes ( ) > = status . getToUpgradeBytes ( ) ) ; assertTrue ( <str> + status . getIndex ( ) + <str> , status . getToUpgradeBytes ( ) ! = <int> ) ; } } public static void assertNoAncientSegments ( Client client , String . . . index ) throws Exception { for ( IndexUpgradeStatus status : getUpgradeStatus ( client , index ) ) { assertTrue ( <str> + status . getIndex ( ) + <str> , status . getTotalBytes ( ) ! = <int> ) ; assertTrue ( <str> + status . getIndex ( ) + <str> , status . getToUpgradeBytesAncient ( ) = = <int> ) ; assertTrue ( <str> + status . getIndex ( ) + <str> , status . getTotalBytes ( ) > = status . getToUpgradeBytes ( ) ) ; assertTrue ( <str> + status . getIndex ( ) + <str> , status . getToUpgradeBytes ( ) ! = <int> ) ; } } public static boolean hasAncientSegments ( Client client , String index ) throws Exception { for ( IndexUpgradeStatus status : getUpgradeStatus ( client , index ) ) { if ( status . getToUpgradeBytesAncient ( ) ! = <int> ) { return true ; } } return false ; } public static boolean hasOldButNotAncientSegments ( Client client , String index ) throws Exception { for ( IndexUpgradeStatus status : getUpgradeStatus ( client , index ) ) { if ( status . getToUpgradeBytes ( ) > status . getToUpgradeBytesAncient ( ) ) { return true ; } } return false ; } public static void assertUpgraded ( Client client , String . . . index ) throws Exception { for ( IndexUpgradeStatus status : getUpgradeStatus ( client , index ) ) { assertTrue ( <str> + status . getIndex ( ) + <str> , status . getTotalBytes ( ) ! = <int> ) ; assertEquals ( <str> + status . getIndex ( ) + <str> , <int> , status . getToUpgradeBytes ( ) ) ; } IndicesSegmentResponse segsRsp ; if ( index = = null ) { segsRsp = client ( ) . admin ( ) . indices ( ) . prepareSegments ( ) . execute ( ) . actionGet ( ) ; } else { segsRsp = client ( ) . admin ( ) . indices ( ) . prepareSegments ( index ) . execute ( ) . actionGet ( ) ; } for ( IndexSegments indexSegments : segsRsp . getIndices ( ) . values ( ) ) { for ( IndexShardSegments shard : indexSegments ) { for ( ShardSegments segs : shard . getShards ( ) ) { for ( Segment seg : segs . getSegments ( ) ) { assertEquals ( <str> + indexSegments . getIndex ( ) + <str> + seg . toString ( ) , Version . CURRENT . luceneVersion . major , seg . version . major ) ; assertEquals ( <str> + indexSegments . getIndex ( ) + <str> + seg . toString ( ) , Version . CURRENT . luceneVersion . minor , seg . version . minor ) ; } } } } } static boolean isUpgraded ( Client client , String index ) throws Exception { ESLogger logger = Loggers . getLogger ( UpgradeIT . class ) ; int toUpgrade = <int> ; for ( IndexUpgradeStatus status : getUpgradeStatus ( client , index ) ) { logger . info ( <str> + status . getIndex ( ) + <str> + status . getTotalBytes ( ) + <str> + status . getToUpgradeBytes ( ) ) ; toUpgrade + = status . getToUpgradeBytes ( ) ; } return toUpgrade = = <int> ; } static class UpgradeStatus { public final String indexName ; public final int totalBytes ; public final int toUpgradeBytes ; public final int toUpgradeBytesAncient ; public UpgradeStatus ( String indexName , int totalBytes , int toUpgradeBytes , int toUpgradeBytesAncient ) { this . indexName = indexName ; this . totalBytes = totalBytes ; this . toUpgradeBytes = toUpgradeBytes ; this . toUpgradeBytesAncient = toUpgradeBytesAncient ; assert toUpgradeBytesAncient < = toUpgradeBytes ; } } @SuppressWarnings ( <str> ) static Collection < IndexUpgradeStatus > getUpgradeStatus ( Client client , String . . . indices ) throws Exception { UpgradeStatusResponse upgradeStatusResponse = client . admin ( ) . indices ( ) . prepareUpgradeStatus ( indices ) . get ( ) ; assertNoFailures ( upgradeStatusResponse ) ; return upgradeStatusResponse . getIndices ( ) . values ( ) ; } } 
