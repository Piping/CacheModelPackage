package com . badlogic . gdx . graphics . g2d ; import static com . badlogic . gdx . graphics . g2d . Sprite . SPRITE_SIZE ; import static com . badlogic . gdx . graphics . g2d . Sprite . VERTEX_SIZE ; import java . nio . FloatBuffer ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . Texture ; import com . badlogic . gdx . graphics . VertexAttribute ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . glutils . ShaderProgram ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Disposable ; import com . badlogic . gdx . utils . GdxRuntimeException ; import com . badlogic . gdx . utils . IntArray ; import com . badlogic . gdx . utils . NumberUtils ; public class SpriteCache implements Disposable { static private final float [ ] tempVertices = new float [ VERTEX_SIZE * <int> ] ; private final Mesh mesh ; private boolean drawing ; private final Matrix4 transformMatrix = new Matrix4 ( ) ; private final Matrix4 projectionMatrix = new Matrix4 ( ) ; private Array < Cache > caches = new Array ( ) ; private final Matrix4 combinedMatrix = new Matrix4 ( ) ; private final ShaderProgram shader ; private Cache currentCache ; private final Array < Texture > textures = new Array ( <int> ) ; private final IntArray counts = new IntArray ( <int> ) ; private float color = Color . WHITE . toFloatBits ( ) ; private Color tempColor = new Color ( <int> , <int> , <int> , <int> ) ; private ShaderProgram customShader = null ; public int renderCalls = <int> ; public int totalRenderCalls = <int> ; public SpriteCache ( ) { this ( <int> , false ) ; } public SpriteCache ( int size , boolean useIndices ) { this ( size , createDefaultShader ( ) , useIndices ) ; } public SpriteCache ( int size , ShaderProgram shader , boolean useIndices ) { this . shader = shader ; if ( useIndices & & size > <int> ) throw new IllegalArgumentException ( <str> + size ) ; mesh = new Mesh ( true , size * ( useIndices ? <int> : <int> ) , useIndices ? size * <int> : <int> , new VertexAttribute ( Usage . Position , <int> , ShaderProgram . POSITION_ATTRIBUTE ) , new VertexAttribute ( Usage . ColorPacked , <int> , ShaderProgram . COLOR_ATTRIBUTE ) , new VertexAttribute ( Usage . TextureCoordinates , <int> , ShaderProgram . TEXCOORD_ATTRIBUTE + <str> ) ) ; mesh . setAutoBind ( false ) ; if ( useIndices ) { int length = size * <int> ; short [ ] indices = new short [ length ] ; short j = <int> ; for ( int i = <int> ; i < length ; i + = <int> , j + = <int> ) { indices [ i + <int> ] = ( short ) j ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) ( j + <int> ) ; indices [ i + <int> ] = ( short ) j ; } mesh . setIndices ( indices ) ; } projectionMatrix . setToOrtho2D ( <int> , <int> , Gdx . graphics . getWidth ( ) , Gdx . graphics . getHeight ( ) ) ; } public void setColor ( Color tint ) { color = tint . toFloatBits ( ) ; } public void setColor ( float r , float g , float b , float a ) { int intBits = ( int ) ( <int> * a ) < < <int> | ( int ) ( <int> * b ) < < <int> | ( int ) ( <int> * g ) < < <int> | ( int ) ( <int> * r ) ; color = NumberUtils . intToFloatColor ( intBits ) ; } public void setColor ( float color ) { this . color = color ; } public Color getColor ( ) { int intBits = NumberUtils . floatToIntColor ( color ) ; Color color = this . tempColor ; color . r = ( intBits & <hex> ) / <int> f ; color . g = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; color . b = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; color . a = ( ( intBits > > > <int> ) & <hex> ) / <int> f ; return color ; } public void beginCache ( ) { if ( currentCache ! = null ) throw new IllegalStateException ( <str> ) ; int verticesPerImage = mesh . getNumIndices ( ) > <int> ? <int> : <int> ; currentCache = new Cache ( caches . size , mesh . getVerticesBuffer ( ) . limit ( ) ) ; caches . add ( currentCache ) ; mesh . getVerticesBuffer ( ) . compact ( ) ; } public void beginCache ( int cacheID ) { if ( currentCache ! = null ) throw new IllegalStateException ( <str> ) ; if ( cacheID = = caches . size - <int> ) { Cache oldCache = caches . removeIndex ( cacheID ) ; mesh . getVerticesBuffer ( ) . limit ( oldCache . offset ) ; beginCache ( ) ; return ; } currentCache = caches . get ( cacheID ) ; mesh . getVerticesBuffer ( ) . position ( currentCache . offset ) ; } public int endCache ( ) { if ( currentCache = = null ) throw new IllegalStateException ( <str> ) ; Cache cache = currentCache ; int cacheCount = mesh . getVerticesBuffer ( ) . position ( ) - cache . offset ; if ( cache . textures = = null ) { cache . maxCount = cacheCount ; cache . textureCount = textures . size ; cache . textures = textures . toArray ( Texture . class ) ; cache . counts = new int [ cache . textureCount ] ; for ( int i = <int> , n = counts . size ; i < n ; i + + ) cache . counts [ i ] = counts . get ( i ) ; mesh . getVerticesBuffer ( ) . flip ( ) ; } else { if ( cacheCount > cache . maxCount ) { throw new GdxRuntimeException ( <str> + cacheCount + <str> + cache . maxCount + <str> ) ; } cache . textureCount = textures . size ; if ( cache . textures . length < cache . textureCount ) cache . textures = new Texture [ cache . textureCount ] ; for ( int i = <int> , n = cache . textureCount ; i < n ; i + + ) cache . textures [ i ] = textures . get ( i ) ; if ( cache . counts . length < cache . textureCount ) cache . counts = new int [ cache . textureCount ] ; for ( int i = <int> , n = cache . textureCount ; i < n ; i + + ) cache . counts [ i ] = counts . get ( i ) ; FloatBuffer vertices = mesh . getVerticesBuffer ( ) ; vertices . position ( <int> ) ; Cache lastCache = caches . get ( caches . size - <int> ) ; vertices . limit ( lastCache . offset + lastCache . maxCount ) ; } currentCache = null ; textures . clear ( ) ; counts . clear ( ) ; return cache . id ; } public void clear ( ) { caches . clear ( ) ; mesh . getVerticesBuffer ( ) . clear ( ) . flip ( ) ; } public void add ( Texture texture , float [ ] vertices , int offset , int length ) { if ( currentCache = = null ) throw new IllegalStateException ( <str> ) ; int verticesPerImage = mesh . getNumIndices ( ) > <int> ? <int> : <int> ; int count = length / ( verticesPerImage * VERTEX_SIZE ) * <int> ; int lastIndex = textures . size - <int> ; if ( lastIndex < <int> | | textures . get ( lastIndex ) ! = texture ) { textures . add ( texture ) ; counts . add ( count ) ; } else counts . incr ( lastIndex , count ) ; mesh . getVerticesBuffer ( ) . put ( vertices , offset , length ) ; } public void add ( Texture texture , float x , float y ) { final float fx2 = x + texture . getWidth ( ) ; final float fy2 = y + texture . getHeight ( ) ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = <int> ; if ( mesh . getNumIndices ( ) > <int> ) { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = <int> ; add ( texture , tempVertices , <int> , <int> ) ; } else { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = <int> ; tempVertices [ <int> ] = <int> ; add ( texture , tempVertices , <int> , <int> ) ; } } public void add ( Texture texture , float x , float y , int srcWidth , int srcHeight , float u , float v , float u2 , float v2 , float color ) { final float fx2 = x + srcWidth ; final float fy2 = y + srcHeight ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; if ( mesh . getNumIndices ( ) > <int> ) { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; add ( texture , tempVertices , <int> , <int> ) ; } else { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; add ( texture , tempVertices , <int> , <int> ) ; } } public void add ( Texture texture , float x , float y , int srcX , int srcY , int srcWidth , int srcHeight ) { float invTexWidth = <float> / texture . getWidth ( ) ; float invTexHeight = <float> / texture . getHeight ( ) ; final float u = srcX * invTexWidth ; final float v = ( srcY + srcHeight ) * invTexHeight ; final float u2 = ( srcX + srcWidth ) * invTexWidth ; final float v2 = srcY * invTexHeight ; final float fx2 = x + srcWidth ; final float fy2 = y + srcHeight ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; if ( mesh . getNumIndices ( ) > <int> ) { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; add ( texture , tempVertices , <int> , <int> ) ; } else { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; add ( texture , tempVertices , <int> , <int> ) ; } } public void add ( Texture texture , float x , float y , float width , float height , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { float invTexWidth = <float> / texture . getWidth ( ) ; float invTexHeight = <float> / texture . getHeight ( ) ; float u = srcX * invTexWidth ; float v = ( srcY + srcHeight ) * invTexHeight ; float u2 = ( srcX + srcWidth ) * invTexWidth ; float v2 = srcY * invTexHeight ; final float fx2 = x + width ; final float fy2 = y + height ; if ( flipX ) { float tmp = u ; u = u2 ; u2 = tmp ; } if ( flipY ) { float tmp = v ; v = v2 ; v2 = tmp ; } tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; if ( mesh . getNumIndices ( ) > <int> ) { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; add ( texture , tempVertices , <int> , <int> ) ; } else { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; add ( texture , tempVertices , <int> , <int> ) ; } } public void add ( Texture texture , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation , int srcX , int srcY , int srcWidth , int srcHeight , boolean flipX , boolean flipY ) { final float worldOriginX = x + originX ; final float worldOriginY = y + originY ; float fx = - originX ; float fy = - originY ; float fx2 = width - originX ; float fy2 = height - originY ; if ( scaleX ! = <int> | | scaleY ! = <int> ) { fx * = scaleX ; fy * = scaleY ; fx2 * = scaleX ; fy2 * = scaleY ; } final float p1x = fx ; final float p1y = fy ; final float p2x = fx ; final float p2y = fy2 ; final float p3x = fx2 ; final float p3y = fy2 ; final float p4x = fx2 ; final float p4y = fy ; float x1 ; float y1 ; float x2 ; float y2 ; float x3 ; float y3 ; float x4 ; float y4 ; if ( rotation ! = <int> ) { final float cos = MathUtils . cosDeg ( rotation ) ; final float sin = MathUtils . sinDeg ( rotation ) ; x1 = cos * p1x - sin * p1y ; y1 = sin * p1x + cos * p1y ; x2 = cos * p2x - sin * p2y ; y2 = sin * p2x + cos * p2y ; x3 = cos * p3x - sin * p3y ; y3 = sin * p3x + cos * p3y ; x4 = x1 + ( x3 - x2 ) ; y4 = y3 - ( y2 - y1 ) ; } else { x1 = p1x ; y1 = p1y ; x2 = p2x ; y2 = p2y ; x3 = p3x ; y3 = p3y ; x4 = p4x ; y4 = p4y ; } x1 + = worldOriginX ; y1 + = worldOriginY ; x2 + = worldOriginX ; y2 + = worldOriginY ; x3 + = worldOriginX ; y3 + = worldOriginY ; x4 + = worldOriginX ; y4 + = worldOriginY ; float invTexWidth = <float> / texture . getWidth ( ) ; float invTexHeight = <float> / texture . getHeight ( ) ; float u = srcX * invTexWidth ; float v = ( srcY + srcHeight ) * invTexHeight ; float u2 = ( srcX + srcWidth ) * invTexWidth ; float v2 = srcY * invTexHeight ; if ( flipX ) { float tmp = u ; u = u2 ; u2 = tmp ; } if ( flipY ) { float tmp = v ; v = v2 ; v2 = tmp ; } tempVertices [ <int> ] = x1 ; tempVertices [ <int> ] = y1 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x2 ; tempVertices [ <int> ] = y2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = x3 ; tempVertices [ <int> ] = y3 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; if ( mesh . getNumIndices ( ) > <int> ) { tempVertices [ <int> ] = x4 ; tempVertices [ <int> ] = y4 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; add ( texture , tempVertices , <int> , <int> ) ; } else { tempVertices [ <int> ] = x3 ; tempVertices [ <int> ] = y3 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = x4 ; tempVertices [ <int> ] = y4 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x1 ; tempVertices [ <int> ] = y1 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; add ( texture , tempVertices , <int> , <int> ) ; } } public void add ( TextureRegion region , float x , float y ) { add ( region , x , y , region . getRegionWidth ( ) , region . getRegionHeight ( ) ) ; } public void add ( TextureRegion region , float x , float y , float width , float height ) { final float fx2 = x + width ; final float fy2 = y + height ; final float u = region . u ; final float v = region . v2 ; final float u2 = region . u2 ; final float v2 = region . v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; if ( mesh . getNumIndices ( ) > <int> ) { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; add ( region . texture , tempVertices , <int> , <int> ) ; } else { tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = fy2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = fx2 ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x ; tempVertices [ <int> ] = y ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; add ( region . texture , tempVertices , <int> , <int> ) ; } } public void add ( TextureRegion region , float x , float y , float originX , float originY , float width , float height , float scaleX , float scaleY , float rotation ) { final float worldOriginX = x + originX ; final float worldOriginY = y + originY ; float fx = - originX ; float fy = - originY ; float fx2 = width - originX ; float fy2 = height - originY ; if ( scaleX ! = <int> | | scaleY ! = <int> ) { fx * = scaleX ; fy * = scaleY ; fx2 * = scaleX ; fy2 * = scaleY ; } final float p1x = fx ; final float p1y = fy ; final float p2x = fx ; final float p2y = fy2 ; final float p3x = fx2 ; final float p3y = fy2 ; final float p4x = fx2 ; final float p4y = fy ; float x1 ; float y1 ; float x2 ; float y2 ; float x3 ; float y3 ; float x4 ; float y4 ; if ( rotation ! = <int> ) { final float cos = MathUtils . cosDeg ( rotation ) ; final float sin = MathUtils . sinDeg ( rotation ) ; x1 = cos * p1x - sin * p1y ; y1 = sin * p1x + cos * p1y ; x2 = cos * p2x - sin * p2y ; y2 = sin * p2x + cos * p2y ; x3 = cos * p3x - sin * p3y ; y3 = sin * p3x + cos * p3y ; x4 = x1 + ( x3 - x2 ) ; y4 = y3 - ( y2 - y1 ) ; } else { x1 = p1x ; y1 = p1y ; x2 = p2x ; y2 = p2y ; x3 = p3x ; y3 = p3y ; x4 = p4x ; y4 = p4y ; } x1 + = worldOriginX ; y1 + = worldOriginY ; x2 + = worldOriginX ; y2 + = worldOriginY ; x3 + = worldOriginX ; y3 + = worldOriginY ; x4 + = worldOriginX ; y4 + = worldOriginY ; final float u = region . u ; final float v = region . v2 ; final float u2 = region . u2 ; final float v2 = region . v ; tempVertices [ <int> ] = x1 ; tempVertices [ <int> ] = y1 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x2 ; tempVertices [ <int> ] = y2 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = x3 ; tempVertices [ <int> ] = y3 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; if ( mesh . getNumIndices ( ) > <int> ) { tempVertices [ <int> ] = x4 ; tempVertices [ <int> ] = y4 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; add ( region . texture , tempVertices , <int> , <int> ) ; } else { tempVertices [ <int> ] = x3 ; tempVertices [ <int> ] = y3 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v2 ; tempVertices [ <int> ] = x4 ; tempVertices [ <int> ] = y4 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u2 ; tempVertices [ <int> ] = v ; tempVertices [ <int> ] = x1 ; tempVertices [ <int> ] = y1 ; tempVertices [ <int> ] = color ; tempVertices [ <int> ] = u ; tempVertices [ <int> ] = v ; add ( region . texture , tempVertices , <int> , <int> ) ; } } public void add ( Sprite sprite ) { if ( mesh . getNumIndices ( ) > <int> ) { add ( sprite . getTexture ( ) , sprite . getVertices ( ) , <int> , SPRITE_SIZE ) ; return ; } float [ ] spriteVertices = sprite . getVertices ( ) ; System . arraycopy ( spriteVertices , <int> , tempVertices , <int> , <int> * VERTEX_SIZE ) ; System . arraycopy ( spriteVertices , <int> * VERTEX_SIZE , tempVertices , <int> * VERTEX_SIZE , VERTEX_SIZE ) ; System . arraycopy ( spriteVertices , <int> * VERTEX_SIZE , tempVertices , <int> * VERTEX_SIZE , VERTEX_SIZE ) ; System . arraycopy ( spriteVertices , <int> , tempVertices , <int> * VERTEX_SIZE , VERTEX_SIZE ) ; add ( sprite . getTexture ( ) , tempVertices , <int> , <int> ) ; } public void begin ( ) { if ( drawing ) throw new IllegalStateException ( <str> ) ; renderCalls = <int> ; combinedMatrix . set ( projectionMatrix ) . mul ( transformMatrix ) ; Gdx . gl20 . glDepthMask ( false ) ; if ( customShader ! = null ) { customShader . begin ( ) ; customShader . setUniformMatrix ( <str> , projectionMatrix ) ; customShader . setUniformMatrix ( <str> , transformMatrix ) ; customShader . setUniformMatrix ( <str> , combinedMatrix ) ; customShader . setUniformi ( <str> , <int> ) ; mesh . bind ( customShader ) ; } else { shader . begin ( ) ; shader . setUniformMatrix ( <str> , combinedMatrix ) ; shader . setUniformi ( <str> , <int> ) ; mesh . bind ( shader ) ; } drawing = true ; } public void end ( ) { if ( ! drawing ) throw new IllegalStateException ( <str> ) ; drawing = false ; shader . end ( ) ; GL20 gl = Gdx . gl20 ; gl . glDepthMask ( true ) ; if ( customShader ! = null ) mesh . unbind ( customShader ) ; else mesh . unbind ( shader ) ; } public void draw ( int cacheID ) { if ( ! drawing ) throw new IllegalStateException ( <str> ) ; Cache cache = caches . get ( cacheID ) ; int verticesPerImage = mesh . getNumIndices ( ) > <int> ? <int> : <int> ; int offset = cache . offset / ( verticesPerImage * VERTEX_SIZE ) * <int> ; Texture [ ] textures = cache . textures ; int [ ] counts = cache . counts ; int textureCount = cache . textureCount ; for ( int i = <int> ; i < textureCount ; i + + ) { int count = counts [ i ] ; textures [ i ] . bind ( ) ; if ( customShader ! = null ) mesh . render ( customShader , GL20 . GL_TRIANGLES , offset , count ) ; else mesh . render ( shader , GL20 . GL_TRIANGLES , offset , count ) ; offset + = count ; } renderCalls + = textureCount ; totalRenderCalls + = textureCount ; } public void draw ( int cacheID , int offset , int length ) { if ( ! drawing ) throw new IllegalStateException ( <str> ) ; Cache cache = caches . get ( cacheID ) ; offset = offset * <int> + cache . offset ; length * = <int> ; Texture [ ] textures = cache . textures ; int [ ] counts = cache . counts ; int textureCount = cache . textureCount ; for ( int i = <int> ; i < textureCount ; i + + ) { textures [ i ] . bind ( ) ; int count = counts [ i ] ; if ( count > length ) { i = textureCount ; count = length ; } else length - = count ; if ( customShader ! = null ) mesh . render ( customShader , GL20 . GL_TRIANGLES , offset , count ) ; else mesh . render ( shader , GL20 . GL_TRIANGLES , offset , count ) ; offset + = count ; } renderCalls + = cache . textureCount ; totalRenderCalls + = textureCount ; } public void dispose ( ) { mesh . dispose ( ) ; if ( shader ! = null ) shader . dispose ( ) ; } public Matrix4 getProjectionMatrix ( ) { return projectionMatrix ; } public void setProjectionMatrix ( Matrix4 projection ) { if ( drawing ) throw new IllegalStateException ( <str> ) ; projectionMatrix . set ( projection ) ; } public Matrix4 getTransformMatrix ( ) { return transformMatrix ; } public void setTransformMatrix ( Matrix4 transform ) { if ( drawing ) throw new IllegalStateException ( <str> ) ; transformMatrix . set ( transform ) ; } static private class Cache { final int id ; final int offset ; int maxCount ; int textureCount ; Texture [ ] textures ; int [ ] counts ; public Cache ( int id , int offset ) { this . id = id ; this . offset = offset ; } } static ShaderProgram createDefaultShader ( ) { String vertexShader = <str> + ShaderProgram . POSITION_ATTRIBUTE + <str> + <str> + ShaderProgram . COLOR_ATTRIBUTE + <str> + <str> + ShaderProgram . TEXCOORD_ATTRIBUTE + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + ShaderProgram . COLOR_ATTRIBUTE + <str> + <str> + <str> + ShaderProgram . TEXCOORD_ATTRIBUTE + <str> + <str> + ShaderProgram . POSITION_ATTRIBUTE + <str> + <str> ; String fragmentShader = <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> + <str> ; ShaderProgram shader = new ShaderProgram ( vertexShader , fragmentShader ) ; if ( shader . isCompiled ( ) = = false ) throw new IllegalArgumentException ( <str> + shader . getLog ( ) ) ; return shader ; } public void setShader ( ShaderProgram shader ) { customShader = shader ; } } 
