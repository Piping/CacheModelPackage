package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . Unpooled ; import io . netty . channel . embedded . EmbeddedChannel ; import org . junit . Assert ; import org . junit . Test ; public class WebSocket08EncoderDecoderTest { private ByteBuf binTestData ; private String strTestData ; private static final int MAX_TESTDATA_LENGTH = <int> * <int> ; private void initTestData ( ) { binTestData = Unpooled . buffer ( MAX_TESTDATA_LENGTH ) ; byte j = <int> ; for ( int i = <int> ; i < MAX_TESTDATA_LENGTH ; i + + ) { binTestData . array ( ) [ i ] = j ; j + + ; } StringBuilder s = new StringBuilder ( ) ; char c = <str> ; for ( int i = <int> ; i < MAX_TESTDATA_LENGTH ; i + + ) { s . append ( c ) ; c + + ; if ( c = = <str> ) { c = <str> ; } } strTestData = s . toString ( ) ; } @Test public void testWebSocketEncodingAndDecoding ( ) { initTestData ( ) ; EmbeddedChannel outChannel = new EmbeddedChannel ( new WebSocket08FrameEncoder ( false ) ) ; EmbeddedChannel inChannel = new EmbeddedChannel ( new WebSocket08FrameDecoder ( false , false , <int> * <int> , false ) ) ; executeTests ( outChannel , inChannel ) ; outChannel = new EmbeddedChannel ( new WebSocket08FrameEncoder ( true ) ) ; inChannel = new EmbeddedChannel ( new WebSocket08FrameDecoder ( true , false , <int> * <int> , false ) ) ; executeTests ( outChannel , inChannel ) ; outChannel = new EmbeddedChannel ( new WebSocket08FrameEncoder ( true ) ) ; inChannel = new EmbeddedChannel ( new WebSocket08FrameDecoder ( false , false , <int> * <int> , true ) ) ; executeTests ( outChannel , inChannel ) ; binTestData . release ( ) ; } private void executeTests ( EmbeddedChannel outChannel , EmbeddedChannel inChannel ) { executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; executeTests ( outChannel , inChannel , <int> ) ; } private void executeTests ( EmbeddedChannel outChannel , EmbeddedChannel inChannel , int testDataLength ) { testTextWithLen ( outChannel , inChannel , testDataLength ) ; testBinaryWithLen ( outChannel , inChannel , testDataLength ) ; } private void testTextWithLen ( EmbeddedChannel outChannel , EmbeddedChannel inChannel , int testDataLength ) { String testStr = strTestData . substring ( <int> , testDataLength ) ; outChannel . writeOutbound ( new TextWebSocketFrame ( testStr ) ) ; while ( true ) { ByteBuf encoded = outChannel . readOutbound ( ) ; if ( encoded ! = null ) { inChannel . writeInbound ( encoded ) ; } else { break ; } } Object decoded = inChannel . readInbound ( ) ; Assert . assertNotNull ( decoded ) ; Assert . assertTrue ( decoded instanceof TextWebSocketFrame ) ; TextWebSocketFrame txt = ( TextWebSocketFrame ) decoded ; Assert . assertEquals ( txt . text ( ) , testStr ) ; txt . release ( ) ; } private void testBinaryWithLen ( EmbeddedChannel outChannel , EmbeddedChannel inChannel , int testDataLength ) { binTestData . retain ( ) ; binTestData . setIndex ( <int> , testDataLength ) ; outChannel . writeOutbound ( new BinaryWebSocketFrame ( binTestData ) ) ; while ( true ) { ByteBuf encoded = outChannel . readOutbound ( ) ; if ( encoded ! = null ) { inChannel . writeInbound ( encoded ) ; } else { break ; } } Object decoded = inChannel . readInbound ( ) ; Assert . assertNotNull ( decoded ) ; Assert . assertTrue ( decoded instanceof BinaryWebSocketFrame ) ; BinaryWebSocketFrame binFrame = ( BinaryWebSocketFrame ) decoded ; int readable = binFrame . content ( ) . readableBytes ( ) ; Assert . assertEquals ( readable , testDataLength ) ; for ( int i = <int> ; i < testDataLength ; i + + ) { Assert . assertEquals ( binTestData . getByte ( i ) , binFrame . content ( ) . getByte ( i ) ) ; } binFrame . release ( ) ; } } 
