package org . apache . cassandra . dht ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Set ; import com . google . common . collect . Iterators ; import com . google . common . collect . Lists ; import com . google . common . collect . PeekingIterator ; import com . google . common . collect . Sets ; import org . apache . cassandra . db . PartitionPosition ; import org . apache . cassandra . utils . Pair ; public class Bounds < T extends RingPosition < T > > extends AbstractBounds < T > { public Bounds ( T left , T right ) { super ( left , right ) ; assert ! strictlyWrapsAround ( left , right ) : <str> + left + <str> + right + <str> ; } public boolean contains ( T position ) { return left . equals ( position ) | | ( ( right . isMinimum ( ) | | ! left . equals ( right ) ) & & Range . contains ( left , right , position ) ) ; } public Pair < AbstractBounds < T > , AbstractBounds < T > > split ( T position ) { assert contains ( position ) ; if ( position . equals ( right ) ) return null ; AbstractBounds < T > lb = new Bounds < T > ( left , position ) ; AbstractBounds < T > rb = new Range < T > ( position , right ) ; return Pair . create ( lb , rb ) ; } public boolean inclusiveLeft ( ) { return true ; } public boolean inclusiveRight ( ) { return true ; } public boolean intersects ( Bounds < T > that ) { return contains ( that . left ) | | contains ( that . right ) | | that . contains ( left ) ; } public List < ? extends AbstractBounds < T > > unwrap ( ) { return Collections . < AbstractBounds < T > > singletonList ( this ) ; } @Override public boolean equals ( Object o ) { if ( ! ( o instanceof Bounds ) ) return false ; Bounds < ? > rhs = ( Bounds < ? > ) o ; return left . equals ( rhs . left ) & & right . equals ( rhs . right ) ; } @Override public String toString ( ) { return <str> + left + <str> + right + <str> ; } protected String getOpeningString ( ) { return <str> ; } protected String getClosingString ( ) { return <str> ; } public static < T extends RingPosition < T > > boolean isInBounds ( T token , Iterable < Bounds < T > > bounds ) { assert bounds ! = null ; for ( Bounds < T > bound : bounds ) { if ( bound . contains ( token ) ) { return true ; } } return false ; } public boolean isStartInclusive ( ) { return true ; } public boolean isEndInclusive ( ) { return true ; } public static Bounds < PartitionPosition > makeRowBounds ( Token left , Token right ) { return new Bounds < PartitionPosition > ( left . minKeyBound ( ) , right . maxKeyBound ( ) ) ; } public AbstractBounds < T > withNewRight ( T newRight ) { return new Bounds < T > ( left , newRight ) ; } public static < T extends RingPosition < T > > Set < Bounds < T > > getNonOverlappingBounds ( Iterable < Bounds < T > > bounds ) { ArrayList < Bounds < T > > sortedBounds = Lists . newArrayList ( bounds ) ; Collections . sort ( sortedBounds , new Comparator < Bounds < T > > ( ) { public int compare ( Bounds < T > o1 , Bounds < T > o2 ) { return o1 . left . compareTo ( o2 . left ) ; } } ) ; Set < Bounds < T > > nonOverlappingBounds = Sets . newHashSet ( ) ; PeekingIterator < Bounds < T > > it = Iterators . peekingIterator ( sortedBounds . iterator ( ) ) ; while ( it . hasNext ( ) ) { Bounds < T > beginBound = it . next ( ) ; Bounds < T > endBound = beginBound ; while ( it . hasNext ( ) & & endBound . right . compareTo ( it . peek ( ) . left ) > = <int> ) endBound = it . next ( ) ; nonOverlappingBounds . add ( new Bounds < > ( beginBound . left , endBound . right ) ) ; } return nonOverlappingBounds ; } } 
