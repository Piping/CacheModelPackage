package org . nd4j . linalg . api . rng . distribution . impl ; import java . util . Iterator ; import org . apache . commons . math3 . exception . NotPositiveException ; import org . apache . commons . math3 . exception . NumberIsTooLargeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . util . LocalizedFormats ; import org . apache . commons . math3 . random . RandomGenerator ; import org . apache . commons . math3 . special . Beta ; import org . apache . commons . math3 . util . FastMath ; import org . nd4j . linalg . api . iter . NdIndexIterator ; import org . nd4j . linalg . api . ndarray . INDArray ; import org . nd4j . linalg . api . rng . Random ; import org . nd4j . linalg . api . rng . distribution . BaseDistribution ; import org . nd4j . linalg . factory . Nd4j ; public class BinomialDistribution extends BaseDistribution { private final int numberOfTrials ; private double probabilityOfSuccess ; private INDArray p ; public BinomialDistribution ( int trials , double p ) { this ( Nd4j . getRandom ( ) , trials , p ) ; } public BinomialDistribution ( Random rng , int trials , double p ) { super ( rng ) ; if ( trials < <int> ) { throw new NotPositiveException ( LocalizedFormats . NUMBER_OF_TRIALS , trials ) ; } if ( p < <int> | | p > <int> ) { throw new OutOfRangeException ( p , <int> , <int> ) ; } probabilityOfSuccess = p ; numberOfTrials = trials ; } public BinomialDistribution ( int n , INDArray p ) { this . random = Nd4j . getRandom ( ) ; this . numberOfTrials = n ; this . p = p ; } public int getNumberOfTrials ( ) { return numberOfTrials ; } public double getProbabilityOfSuccess ( ) { return probabilityOfSuccess ; } public double probability ( int x ) { double ret ; if ( x < <int> | | x > numberOfTrials ) { ret = <float> ; } else { ret = FastMath . exp ( SaddlePointExpansion . logBinomialProbability ( x , numberOfTrials , probabilityOfSuccess , <float> - probabilityOfSuccess ) ) ; } return ret ; } public double cumulativeProbability ( int x ) { double ret ; if ( x < <int> ) { ret = <float> ; } else if ( x > = numberOfTrials ) { ret = <float> ; } else { ret = <float> - Beta . regularizedBeta ( probabilityOfSuccess , x + <float> , numberOfTrials - x ) ; } return ret ; } @Override public double density ( double x ) { return <int> ; } @Override public double cumulativeProbability ( double x ) { double ret ; if ( x < <int> ) { ret = <float> ; } else if ( x > = this . numberOfTrials ) { ret = <float> ; } else { ret = <float> - Beta . regularizedBeta ( this . probabilityOfSuccess , x + <float> , ( this . numberOfTrials - x ) ) ; } return ret ; } @Override public double cumulativeProbability ( double x0 , double x1 ) throws NumberIsTooLargeException { return <int> ; } public double getNumericalMean ( ) { return numberOfTrials * probabilityOfSuccess ; } public double getNumericalVariance ( ) { final double p = probabilityOfSuccess ; return numberOfTrials * p * ( <int> - p ) ; } @Override public double getSupportLowerBound ( ) { return probabilityOfSuccess < <float> ? <int> : numberOfTrials ; } @Override public double getSupportUpperBound ( ) { return probabilityOfSuccess > <float> ? numberOfTrials : <int> ; } @Override public boolean isSupportLowerBoundInclusive ( ) { return false ; } @Override public boolean isSupportUpperBoundInclusive ( ) { return false ; } public boolean isSupportConnected ( ) { return true ; } private void ensureConsistent ( int i ) { probabilityOfSuccess = p . linearView ( ) . getDouble ( i ) ; } @Override public INDArray sample ( int [ ] shape ) { INDArray ret = Nd4j . create ( shape ) ; Iterator < int [ ] > idxIter = new NdIndexIterator ( shape ) ; int len = ret . length ( ) ; if ( p ! = null ) { for ( int i = <int> ; i < len ; i + + ) { int [ ] idx = idxIter . next ( ) ; org . apache . commons . math3 . distribution . BinomialDistribution binomialDistribution = new org . apache . commons . math3 . distribution . BinomialDistribution ( ( RandomGenerator ) Nd4j . getRandom ( ) , numberOfTrials , p . getDouble ( idx ) ) ; ret . putScalar ( idx , binomialDistribution . sample ( ) ) ; } } else { org . apache . commons . math3 . distribution . BinomialDistribution binomialDistribution = new org . apache . commons . math3 . distribution . BinomialDistribution ( ( RandomGenerator ) Nd4j . getRandom ( ) , numberOfTrials , probabilityOfSuccess ) ; for ( int i = <int> ; i < len ; i + + ) { ret . putScalar ( idxIter . next ( ) , binomialDistribution . sample ( ) ) ; } } return ret ; } } 
