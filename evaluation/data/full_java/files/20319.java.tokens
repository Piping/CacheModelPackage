package io . netty . channel . socket . oio ; import io . netty . channel . ChannelException ; import io . netty . channel . ChannelMetadata ; import io . netty . channel . ChannelOutboundBuffer ; import io . netty . channel . oio . AbstractOioMessageChannel ; import io . netty . channel . socket . ServerSocketChannel ; import io . netty . util . internal . logging . InternalLogger ; import io . netty . util . internal . logging . InternalLoggerFactory ; import java . io . IOException ; import java . net . InetSocketAddress ; import java . net . ServerSocket ; import java . net . Socket ; import java . net . SocketAddress ; import java . net . SocketTimeoutException ; import java . util . List ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; public class OioServerSocketChannel extends AbstractOioMessageChannel implements ServerSocketChannel { private static final InternalLogger logger = InternalLoggerFactory . getInstance ( OioServerSocketChannel . class ) ; private static final ChannelMetadata METADATA = new ChannelMetadata ( false , <int> ) ; private static ServerSocket newServerSocket ( ) { try { return new ServerSocket ( ) ; } catch ( IOException e ) { throw new ChannelException ( <str> , e ) ; } } final ServerSocket socket ; final Lock shutdownLock = new ReentrantLock ( ) ; private final OioServerSocketChannelConfig config ; public OioServerSocketChannel ( ) { this ( newServerSocket ( ) ) ; } public OioServerSocketChannel ( ServerSocket socket ) { super ( null ) ; if ( socket = = null ) { throw new NullPointerException ( <str> ) ; } boolean success = false ; try { socket . setSoTimeout ( SO_TIMEOUT ) ; success = true ; } catch ( IOException e ) { throw new ChannelException ( <str> , e ) ; } finally { if ( ! success ) { try { socket . close ( ) ; } catch ( IOException e ) { if ( logger . isWarnEnabled ( ) ) { logger . warn ( <str> , e ) ; } } } } this . socket = socket ; config = new DefaultOioServerSocketChannelConfig ( this , socket ) ; } @Override public InetSocketAddress localAddress ( ) { return ( InetSocketAddress ) super . localAddress ( ) ; } @Override public ChannelMetadata metadata ( ) { return METADATA ; } @Override public OioServerSocketChannelConfig config ( ) { return config ; } @Override public InetSocketAddress remoteAddress ( ) { return null ; } @Override public boolean isOpen ( ) { return ! socket . isClosed ( ) ; } @Override public boolean isActive ( ) { return isOpen ( ) & & socket . isBound ( ) ; } @Override protected SocketAddress localAddress0 ( ) { return socket . getLocalSocketAddress ( ) ; } @Override protected void doBind ( SocketAddress localAddress ) throws Exception { socket . bind ( localAddress , config . getBacklog ( ) ) ; } @Override protected void doClose ( ) throws Exception { socket . close ( ) ; } @Override protected int doReadMessages ( List < Object > buf ) throws Exception { if ( socket . isClosed ( ) ) { return - <int> ; } try { Socket s = socket . accept ( ) ; try { buf . add ( new OioSocketChannel ( this , s ) ) ; return <int> ; } catch ( Throwable t ) { logger . warn ( <str> , t ) ; try { s . close ( ) ; } catch ( Throwable t2 ) { logger . warn ( <str> , t2 ) ; } } } catch ( SocketTimeoutException e ) { } return <int> ; } @Override protected void doWrite ( ChannelOutboundBuffer in ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected Object filterOutboundMessage ( Object msg ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected void doConnect ( SocketAddress remoteAddress , SocketAddress localAddress ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected SocketAddress remoteAddress0 ( ) { return null ; } @Override protected void doDisconnect ( ) throws Exception { throw new UnsupportedOperationException ( ) ; } @Override protected void setReadPending ( boolean readPending ) { super . setReadPending ( readPending ) ; } } 
