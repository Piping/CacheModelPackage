package com . google . common . util . concurrent ; import com . google . common . base . Joiner ; import com . google . common . util . concurrent . CycleDetectingLockFactory . Policies ; import com . google . common . util . concurrent . CycleDetectingLockFactory . Policy ; import com . google . common . util . concurrent . CycleDetectingLockFactory . PotentialDeadlockException ; import junit . framework . TestCase ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . TimeUnit ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; import java . util . concurrent . locks . ReentrantReadWriteLock ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class CycleDetectingLockFactoryTest extends TestCase { private ReentrantLock lockA ; private ReentrantLock lockB ; private ReentrantLock lockC ; private ReentrantReadWriteLock . ReadLock readLockA ; private ReentrantReadWriteLock . ReadLock readLockB ; private ReentrantReadWriteLock . ReadLock readLockC ; private ReentrantReadWriteLock . WriteLock writeLockA ; private ReentrantReadWriteLock . WriteLock writeLockB ; private ReentrantReadWriteLock . WriteLock writeLockC ; private ReentrantLock lock1 ; private ReentrantLock lock2 ; private ReentrantLock lock3 ; private ReentrantLock lock01 ; private ReentrantLock lock02 ; private ReentrantLock lock03 ; @Override protected void setUp ( ) throws Exception { super . setUp ( ) ; CycleDetectingLockFactory factory = CycleDetectingLockFactory . newInstance ( Policies . THROW ) ; lockA = factory . newReentrantLock ( <str> ) ; lockB = factory . newReentrantLock ( <str> ) ; lockC = factory . newReentrantLock ( <str> ) ; ReentrantReadWriteLock readWriteLockA = factory . newReentrantReadWriteLock ( <str> ) ; ReentrantReadWriteLock readWriteLockB = factory . newReentrantReadWriteLock ( <str> ) ; ReentrantReadWriteLock readWriteLockC = factory . newReentrantReadWriteLock ( <str> ) ; readLockA = readWriteLockA . readLock ( ) ; readLockB = readWriteLockB . readLock ( ) ; readLockC = readWriteLockC . readLock ( ) ; writeLockA = readWriteLockA . writeLock ( ) ; writeLockB = readWriteLockB . writeLock ( ) ; writeLockC = readWriteLockC . writeLock ( ) ; CycleDetectingLockFactory . WithExplicitOrdering < MyOrder > factory2 = newInstanceWithExplicitOrdering ( MyOrder . class , Policies . THROW ) ; lock1 = factory2 . newReentrantLock ( MyOrder . FIRST ) ; lock2 = factory2 . newReentrantLock ( MyOrder . SECOND ) ; lock3 = factory2 . newReentrantLock ( MyOrder . THIRD ) ; CycleDetectingLockFactory . WithExplicitOrdering < OtherOrder > factory3 = newInstanceWithExplicitOrdering ( OtherOrder . class , Policies . THROW ) ; lock01 = factory3 . newReentrantLock ( OtherOrder . FIRST ) ; lock02 = factory3 . newReentrantLock ( OtherOrder . SECOND ) ; lock03 = factory3 . newReentrantLock ( OtherOrder . THIRD ) ; } private < E extends Enum < E > > CycleDetectingLockFactory . WithExplicitOrdering < E > newInstanceWithExplicitOrdering ( Class < E > enumClass , Policy policy ) { return new CycleDetectingLockFactory . WithExplicitOrdering < E > ( policy , CycleDetectingLockFactory . createNodes ( enumClass ) ) ; } public void testDeadlock_twoLocks ( ) { lockA . lock ( ) ; lockB . lock ( ) ; lockA . unlock ( ) ; lockB . unlock ( ) ; PotentialDeadlockException firstException = null ; lockB . lock ( ) ; try { lockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> ) ; firstException = expected ; } try { lockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> ) ; assertSame ( firstException . getCause ( ) , expected . getCause ( ) ) ; } lockB . unlock ( ) ; lockA . lock ( ) ; } public void testDeadlock_threeLocks ( ) { lockA . lock ( ) ; lockB . lock ( ) ; lockB . unlock ( ) ; lockA . unlock ( ) ; lockB . lock ( ) ; lockC . lock ( ) ; lockB . unlock ( ) ; try { lockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> , <str> ) ; } } public void testReentrancy_noDeadlock ( ) { lockA . lock ( ) ; lockB . lock ( ) ; lockA . lock ( ) ; } public void testExplicitOrdering_noViolations ( ) { lock1 . lock ( ) ; lock3 . lock ( ) ; lock3 . unlock ( ) ; lock2 . lock ( ) ; lock3 . lock ( ) ; } public void testExplicitOrdering_violations ( ) { lock3 . lock ( ) ; try { lock2 . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> ) ; } try { lock1 . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> ) ; } lock3 . unlock ( ) ; lock2 . lock ( ) ; try { lock1 . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> ) ; } } public void testDifferentOrderings_noViolations ( ) { lock3 . lock ( ) ; lock01 . lock ( ) ; } public void testExplicitOrderings_generalCycleDetection ( ) { lock3 . lock ( ) ; lock01 . lock ( ) ; lock3 . unlock ( ) ; try { lock3 . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> ) ; } lockA . lock ( ) ; lock01 . unlock ( ) ; lockB . lock ( ) ; lockA . unlock ( ) ; try { lock01 . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> , <str> ) ; } } public void testExplicitOrdering_cycleWithUnorderedLock ( ) { Lock myLock = CycleDetectingLockFactory . newInstance ( Policies . THROW ) . newReentrantLock ( <str> ) ; lock03 . lock ( ) ; myLock . lock ( ) ; lock03 . unlock ( ) ; try { lock01 . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> , <str> ) ; } } public void testExplicitOrdering_reentrantAcquisition ( ) { CycleDetectingLockFactory . WithExplicitOrdering < OtherOrder > factory = newInstanceWithExplicitOrdering ( OtherOrder . class , Policies . THROW ) ; Lock lockA = factory . newReentrantReadWriteLock ( OtherOrder . FIRST ) . readLock ( ) ; Lock lockB = factory . newReentrantLock ( OtherOrder . SECOND ) ; lockA . lock ( ) ; lockA . lock ( ) ; lockB . lock ( ) ; lockB . lock ( ) ; lockA . unlock ( ) ; lockA . unlock ( ) ; lockB . unlock ( ) ; lockB . unlock ( ) ; } public void testExplicitOrdering_acquiringMultipleLocksWithSameRank ( ) { CycleDetectingLockFactory . WithExplicitOrdering < OtherOrder > factory = newInstanceWithExplicitOrdering ( OtherOrder . class , Policies . THROW ) ; Lock lockA = factory . newReentrantLock ( OtherOrder . FIRST ) ; Lock lockB = factory . newReentrantReadWriteLock ( OtherOrder . FIRST ) . readLock ( ) ; lockA . lock ( ) ; try { lockB . lock ( ) ; fail ( <str> ) ; } catch ( IllegalStateException expected ) { } lockA . unlock ( ) ; lockB . lock ( ) ; } public void testReadLock_deadlock ( ) { readLockA . lock ( ) ; lockB . lock ( ) ; lockB . unlock ( ) ; readLockA . unlock ( ) ; lockB . lock ( ) ; try { readLockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> ) ; } } public void testReadLock_transitive ( ) { readLockA . lock ( ) ; lockB . lock ( ) ; lockB . unlock ( ) ; readLockA . unlock ( ) ; lockB . lock ( ) ; readLockC . lock ( ) ; lockB . unlock ( ) ; readLockC . unlock ( ) ; readLockC . lock ( ) ; try { readLockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> , <str> ) ; } } public void testWriteLock_threeLockDeadLock ( ) { writeLockA . lock ( ) ; writeLockB . lock ( ) ; writeLockB . unlock ( ) ; writeLockA . unlock ( ) ; writeLockB . lock ( ) ; writeLockC . lock ( ) ; writeLockB . unlock ( ) ; try { writeLockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> , <str> ) ; } } public void testWriteToReadLockDowngrading ( ) { writeLockA . lock ( ) ; readLockA . lock ( ) ; writeLockA . unlock ( ) ; lockB . lock ( ) ; readLockA . unlock ( ) ; try { writeLockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> ) ; } } public void testReadWriteLockDeadlock ( ) { writeLockA . lock ( ) ; lockB . lock ( ) ; writeLockA . unlock ( ) ; lockB . unlock ( ) ; lockB . lock ( ) ; try { readLockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> ) ; } } public void testReadWriteLockDeadlock_transitive ( ) { readLockA . lock ( ) ; lockB . lock ( ) ; readLockA . unlock ( ) ; lockB . unlock ( ) ; lockB . lock ( ) ; lockC . lock ( ) ; lockB . unlock ( ) ; lockC . unlock ( ) ; lockC . lock ( ) ; try { writeLockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> , <str> ) ; } } public void testReadWriteLockDeadlock_treatedEquivalently ( ) { readLockA . lock ( ) ; writeLockB . lock ( ) ; readLockA . unlock ( ) ; writeLockB . unlock ( ) ; readLockB . lock ( ) ; try { writeLockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> ) ; } } public void testDifferentLockFactories ( ) { CycleDetectingLockFactory otherFactory = CycleDetectingLockFactory . newInstance ( Policies . WARN ) ; ReentrantLock lockD = otherFactory . newReentrantLock ( <str> ) ; lockA . lock ( ) ; lockD . lock ( ) ; lockA . unlock ( ) ; lockD . unlock ( ) ; lockD . lock ( ) ; try { lockA . lock ( ) ; fail ( <str> ) ; } catch ( PotentialDeadlockException expected ) { checkMessage ( expected , <str> , <str> ) ; } } public void testDifferentLockFactories_policyExecution ( ) { CycleDetectingLockFactory otherFactory = CycleDetectingLockFactory . newInstance ( Policies . WARN ) ; ReentrantLock lockD = otherFactory . newReentrantLock ( <str> ) ; lockD . lock ( ) ; lockA . lock ( ) ; lockA . unlock ( ) ; lockD . unlock ( ) ; lockA . lock ( ) ; lockD . lock ( ) ; } public void testReentrantLock_tryLock ( ) throws Exception { LockingThread thread = new LockingThread ( lockA ) ; thread . start ( ) ; thread . waitUntilHoldingLock ( ) ; assertFalse ( lockA . tryLock ( ) ) ; thread . releaseLockAndFinish ( ) ; assertTrue ( lockA . tryLock ( ) ) ; } public void testReentrantWriteLock_tryLock ( ) throws Exception { LockingThread thread = new LockingThread ( writeLockA ) ; thread . start ( ) ; thread . waitUntilHoldingLock ( ) ; assertFalse ( writeLockA . tryLock ( ) ) ; assertFalse ( readLockA . tryLock ( ) ) ; thread . releaseLockAndFinish ( ) ; assertTrue ( writeLockA . tryLock ( ) ) ; assertTrue ( readLockA . tryLock ( ) ) ; } public void testReentrantReadLock_tryLock ( ) throws Exception { LockingThread thread = new LockingThread ( readLockA ) ; thread . start ( ) ; thread . waitUntilHoldingLock ( ) ; assertFalse ( writeLockA . tryLock ( ) ) ; assertTrue ( readLockA . tryLock ( ) ) ; readLockA . unlock ( ) ; thread . releaseLockAndFinish ( ) ; assertTrue ( writeLockA . tryLock ( ) ) ; assertTrue ( readLockA . tryLock ( ) ) ; } private static class LockingThread extends Thread { final CountDownLatch locked = new CountDownLatch ( <int> ) ; final CountDownLatch finishLatch = new CountDownLatch ( <int> ) ; final Lock lock ; LockingThread ( Lock lock ) { this . lock = lock ; } @Override public void run ( ) { lock . lock ( ) ; try { locked . countDown ( ) ; finishLatch . await ( <int> , TimeUnit . MINUTES ) ; } catch ( InterruptedException e ) { fail ( e . toString ( ) ) ; } finally { lock . unlock ( ) ; } } void waitUntilHoldingLock ( ) throws InterruptedException { locked . await ( <int> , TimeUnit . MINUTES ) ; } void releaseLockAndFinish ( ) throws InterruptedException { finishLatch . countDown ( ) ; this . join ( <int> ) ; assertFalse ( this . isAlive ( ) ) ; } } public void testReentrantReadWriteLock_implDoesNotExposeShadowedLocks ( ) { assertEquals ( <str> + <str> + <str> + <str> + <str> + <str> , <int> , ReentrantReadWriteLock . class . getMethods ( ) . length ) ; } private enum MyOrder { FIRST , SECOND , THIRD ; } private enum OtherOrder { FIRST , SECOND , THIRD ; } private void checkMessage ( IllegalStateException exception , String . . . expectedLockCycle ) { String regex = Joiner . on ( <str> ) . join ( expectedLockCycle ) ; assertContainsRegex ( regex , exception . getMessage ( ) ) ; } private static void assertContainsRegex ( String expectedRegex , String actual ) { Pattern pattern = Pattern . compile ( expectedRegex ) ; Matcher matcher = pattern . matcher ( actual ) ; if ( ! matcher . find ( ) ) { String actualDesc = ( actual = = null ) ? <str> : ( <str> + actual + <str> ) ; fail ( <str> + expectedRegex + <str> + actualDesc ) ; } } } 
