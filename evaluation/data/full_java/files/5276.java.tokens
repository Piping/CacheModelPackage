package org . elasticsearch . action . bulk ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . ExceptionsHelper ; import org . elasticsearch . action . ActionRequest ; import org . elasticsearch . action . RoutingMissingException ; import org . elasticsearch . action . delete . DeleteRequest ; import org . elasticsearch . action . delete . DeleteResponse ; import org . elasticsearch . action . delete . TransportDeleteAction ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . index . IndexResponse ; import org . elasticsearch . action . index . TransportIndexAction ; import org . elasticsearch . action . support . ActionFilters ; import org . elasticsearch . action . support . replication . TransportReplicationAction ; import org . elasticsearch . action . update . UpdateHelper ; import org . elasticsearch . action . update . UpdateRequest ; import org . elasticsearch . action . update . UpdateResponse ; import org . elasticsearch . cluster . ClusterService ; import org . elasticsearch . cluster . action . index . MappingUpdatedAction ; import org . elasticsearch . cluster . action . shard . ShardStateAction ; import org . elasticsearch . cluster . metadata . IndexNameExpressionResolver ; import org . elasticsearch . cluster . metadata . MappingMetaData ; import org . elasticsearch . cluster . metadata . MetaData ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . collect . Tuple ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . xcontent . XContentHelper ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . IndexService ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . index . engine . Engine ; import org . elasticsearch . index . engine . VersionConflictEngineException ; import org . elasticsearch . index . shard . IndexShard ; import org . elasticsearch . index . shard . ShardId ; import org . elasticsearch . index . translog . Translog ; import org . elasticsearch . indices . IndicesService ; import org . elasticsearch . rest . RestStatus ; import org . elasticsearch . threadpool . ThreadPool ; import org . elasticsearch . transport . TransportRequestOptions ; import org . elasticsearch . transport . TransportService ; import java . util . Map ; public class TransportShardBulkAction extends TransportReplicationAction < BulkShardRequest , BulkShardRequest , BulkShardResponse > { private final static String OP_TYPE_UPDATE = <str> ; private final static String OP_TYPE_DELETE = <str> ; public static final String ACTION_NAME = BulkAction . NAME + <str> ; private final UpdateHelper updateHelper ; private final boolean allowIdGeneration ; @Inject public TransportShardBulkAction ( Settings settings , TransportService transportService , ClusterService clusterService , IndicesService indicesService , ThreadPool threadPool , ShardStateAction shardStateAction , MappingUpdatedAction mappingUpdatedAction , UpdateHelper updateHelper , ActionFilters actionFilters , IndexNameExpressionResolver indexNameExpressionResolver ) { super ( settings , ACTION_NAME , transportService , clusterService , indicesService , threadPool , shardStateAction , mappingUpdatedAction , actionFilters , indexNameExpressionResolver , BulkShardRequest : : new , BulkShardRequest : : new , ThreadPool . Names . BULK ) ; this . updateHelper = updateHelper ; this . allowIdGeneration = settings . getAsBoolean ( <str> , true ) ; } @Override protected TransportRequestOptions transportOptions ( ) { return BulkAction . INSTANCE . transportOptions ( settings ) ; } @Override protected BulkShardResponse newResponseInstance ( ) { return new BulkShardResponse ( ) ; } @Override protected boolean resolveIndex ( ) { return false ; } @Override protected Tuple < BulkShardResponse , BulkShardRequest > shardOperationOnPrimary ( MetaData metaData , BulkShardRequest request ) { final IndexService indexService = indicesService . indexServiceSafe ( request . index ( ) ) ; final IndexShard indexShard = indexService . getShard ( request . shardId ( ) . id ( ) ) ; long [ ] preVersions = new long [ request . items ( ) . length ] ; VersionType [ ] preVersionTypes = new VersionType [ request . items ( ) . length ] ; Translog . Location location = null ; for ( int requestIndex = <int> ; requestIndex < request . items ( ) . length ; requestIndex + + ) { BulkItemRequest item = request . items ( ) [ requestIndex ] ; if ( item . request ( ) instanceof IndexRequest ) { IndexRequest indexRequest = ( IndexRequest ) item . request ( ) ; preVersions [ requestIndex ] = indexRequest . version ( ) ; preVersionTypes [ requestIndex ] = indexRequest . versionType ( ) ; try { WriteResult < IndexResponse > result = shardIndexOperation ( request , indexRequest , metaData , indexShard , true ) ; location = locationToSync ( location , result . location ) ; IndexResponse indexResponse = result . response ( ) ; setResponse ( item , new BulkItemResponse ( item . id ( ) , indexRequest . opType ( ) . lowercase ( ) , indexResponse ) ) ; } catch ( Throwable e ) { if ( retryPrimaryException ( e ) ) { for ( int j = <int> ; j < requestIndex ; j + + ) { applyVersion ( request . items ( ) [ j ] , preVersions [ j ] , preVersionTypes [ j ] ) ; } throw ( ElasticsearchException ) e ; } if ( ExceptionsHelper . status ( e ) = = RestStatus . CONFLICT ) { logger . trace ( <str> , e , request . shardId ( ) , indexRequest ) ; } else { logger . debug ( <str> , e , request . shardId ( ) , indexRequest ) ; } if ( item . getPrimaryResponse ( ) ! = null & & isConflictException ( e ) ) { setResponse ( item , item . getPrimaryResponse ( ) ) ; } else { setResponse ( item , new BulkItemResponse ( item . id ( ) , indexRequest . opType ( ) . lowercase ( ) , new BulkItemResponse . Failure ( request . index ( ) , indexRequest . type ( ) , indexRequest . id ( ) , e ) ) ) ; } } } else if ( item . request ( ) instanceof DeleteRequest ) { DeleteRequest deleteRequest = ( DeleteRequest ) item . request ( ) ; preVersions [ requestIndex ] = deleteRequest . version ( ) ; preVersionTypes [ requestIndex ] = deleteRequest . versionType ( ) ; try { final WriteResult < DeleteResponse > writeResult = TransportDeleteAction . executeDeleteRequestOnPrimary ( deleteRequest , indexShard ) ; DeleteResponse deleteResponse = writeResult . response ( ) ; location = locationToSync ( location , writeResult . location ) ; setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_DELETE , deleteResponse ) ) ; } catch ( Throwable e ) { if ( retryPrimaryException ( e ) ) { for ( int j = <int> ; j < requestIndex ; j + + ) { applyVersion ( request . items ( ) [ j ] , preVersions [ j ] , preVersionTypes [ j ] ) ; } throw ( ElasticsearchException ) e ; } if ( ExceptionsHelper . status ( e ) = = RestStatus . CONFLICT ) { logger . trace ( <str> , e , request . shardId ( ) , deleteRequest ) ; } else { logger . debug ( <str> , e , request . shardId ( ) , deleteRequest ) ; } if ( item . getPrimaryResponse ( ) ! = null & & isConflictException ( e ) ) { setResponse ( item , item . getPrimaryResponse ( ) ) ; } else { setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_DELETE , new BulkItemResponse . Failure ( request . index ( ) , deleteRequest . type ( ) , deleteRequest . id ( ) , e ) ) ) ; } } } else if ( item . request ( ) instanceof UpdateRequest ) { UpdateRequest updateRequest = ( UpdateRequest ) item . request ( ) ; preVersions [ requestIndex ] = updateRequest . version ( ) ; preVersionTypes [ requestIndex ] = updateRequest . versionType ( ) ; for ( int updateAttemptsCount = <int> ; updateAttemptsCount < = updateRequest . retryOnConflict ( ) ; updateAttemptsCount + + ) { UpdateResult updateResult ; try { updateResult = shardUpdateOperation ( metaData , request , updateRequest , indexShard ) ; } catch ( Throwable t ) { updateResult = new UpdateResult ( null , null , false , t , null ) ; } if ( updateResult . success ( ) ) { if ( updateResult . writeResult ! = null ) { location = locationToSync ( location , updateResult . writeResult . location ) ; } switch ( updateResult . result . operation ( ) ) { case UPSERT : case INDEX : WriteResult < IndexResponse > result = updateResult . writeResult ; IndexRequest indexRequest = updateResult . request ( ) ; BytesReference indexSourceAsBytes = indexRequest . source ( ) ; IndexResponse indexResponse = result . response ( ) ; UpdateResponse updateResponse = new UpdateResponse ( indexResponse . getShardInfo ( ) , indexResponse . getShardId ( ) , indexResponse . getType ( ) , indexResponse . getId ( ) , indexResponse . getVersion ( ) , indexResponse . isCreated ( ) ) ; if ( updateRequest . fields ( ) ! = null & & updateRequest . fields ( ) . length > <int> ) { Tuple < XContentType , Map < String , Object > > sourceAndContent = XContentHelper . convertToMap ( indexSourceAsBytes , true ) ; updateResponse . setGetResult ( updateHelper . extractGetResult ( updateRequest , request . index ( ) , indexResponse . getVersion ( ) , sourceAndContent . v2 ( ) , sourceAndContent . v1 ( ) , indexSourceAsBytes ) ) ; } item = request . items ( ) [ requestIndex ] = new BulkItemRequest ( request . items ( ) [ requestIndex ] . id ( ) , indexRequest ) ; setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_UPDATE , updateResponse ) ) ; break ; case DELETE : WriteResult < DeleteResponse > writeResult = updateResult . writeResult ; DeleteResponse response = writeResult . response ( ) ; DeleteRequest deleteRequest = updateResult . request ( ) ; updateResponse = new UpdateResponse ( response . getShardInfo ( ) , response . getShardId ( ) , response . getType ( ) , response . getId ( ) , response . getVersion ( ) , false ) ; updateResponse . setGetResult ( updateHelper . extractGetResult ( updateRequest , request . index ( ) , response . getVersion ( ) , updateResult . result . updatedSourceAsMap ( ) , updateResult . result . updateSourceContentType ( ) , null ) ) ; item = request . items ( ) [ requestIndex ] = new BulkItemRequest ( request . items ( ) [ requestIndex ] . id ( ) , deleteRequest ) ; setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_UPDATE , updateResponse ) ) ; break ; case NONE : setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_UPDATE , updateResult . noopResult ) ) ; item . setIgnoreOnReplica ( ) ; break ; } break ; } else if ( updateResult . failure ( ) ) { Throwable t = updateResult . error ; if ( updateResult . retry ) { if ( updateAttemptsCount > = updateRequest . retryOnConflict ( ) ) { setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_UPDATE , new BulkItemResponse . Failure ( request . index ( ) , updateRequest . type ( ) , updateRequest . id ( ) , t ) ) ) ; } } else { if ( retryPrimaryException ( t ) ) { for ( int j = <int> ; j < requestIndex ; j + + ) { applyVersion ( request . items ( ) [ j ] , preVersions [ j ] , preVersionTypes [ j ] ) ; } throw ( ElasticsearchException ) t ; } if ( item . getPrimaryResponse ( ) ! = null & & isConflictException ( t ) ) { setResponse ( item , item . getPrimaryResponse ( ) ) ; } else if ( updateResult . result = = null ) { setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_UPDATE , new BulkItemResponse . Failure ( request . index ( ) , updateRequest . type ( ) , updateRequest . id ( ) , t ) ) ) ; } else { switch ( updateResult . result . operation ( ) ) { case UPSERT : case INDEX : IndexRequest indexRequest = updateResult . request ( ) ; if ( ExceptionsHelper . status ( t ) = = RestStatus . CONFLICT ) { logger . trace ( <str> , t , request . shardId ( ) , indexRequest ) ; } else { logger . debug ( <str> , t , request . shardId ( ) , indexRequest ) ; } setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_UPDATE , new BulkItemResponse . Failure ( request . index ( ) , indexRequest . type ( ) , indexRequest . id ( ) , t ) ) ) ; break ; case DELETE : DeleteRequest deleteRequest = updateResult . request ( ) ; if ( ExceptionsHelper . status ( t ) = = RestStatus . CONFLICT ) { logger . trace ( <str> , t , request . shardId ( ) , deleteRequest ) ; } else { logger . debug ( <str> , t , request . shardId ( ) , deleteRequest ) ; } setResponse ( item , new BulkItemResponse ( item . id ( ) , OP_TYPE_DELETE , new BulkItemResponse . Failure ( request . index ( ) , deleteRequest . type ( ) , deleteRequest . id ( ) , t ) ) ) ; break ; } } break ; } } } } else { throw new IllegalStateException ( <str> + item . request ( ) ) ; } assert item . getPrimaryResponse ( ) ! = null ; assert preVersionTypes [ requestIndex ] ! = null ; } processAfterWrite ( request . refresh ( ) , indexShard , location ) ; BulkItemResponse [ ] responses = new BulkItemResponse [ request . items ( ) . length ] ; BulkItemRequest [ ] items = request . items ( ) ; for ( int i = <int> ; i < items . length ; i + + ) { responses [ i ] = items [ i ] . getPrimaryResponse ( ) ; } return new Tuple < > ( new BulkShardResponse ( request . shardId ( ) , responses ) , request ) ; } private void setResponse ( BulkItemRequest request , BulkItemResponse response ) { request . setPrimaryResponse ( response ) ; if ( response . isFailed ( ) ) { request . setIgnoreOnReplica ( ) ; } } private WriteResult shardIndexOperation ( BulkShardRequest request , IndexRequest indexRequest , MetaData metaData , IndexShard indexShard , boolean processed ) throws Throwable { MappingMetaData mappingMd = metaData . index ( request . index ( ) ) . mappingOrDefault ( indexRequest . type ( ) ) ; if ( mappingMd ! = null & & mappingMd . routing ( ) . required ( ) ) { if ( indexRequest . routing ( ) = = null ) { throw new RoutingMissingException ( request . index ( ) , indexRequest . type ( ) , indexRequest . id ( ) ) ; } } if ( ! processed ) { indexRequest . process ( metaData , mappingMd , allowIdGeneration , request . index ( ) ) ; } return TransportIndexAction . executeIndexRequestOnPrimary ( indexRequest , indexShard , mappingUpdatedAction ) ; } static class UpdateResult { final UpdateHelper . Result result ; final ActionRequest actionRequest ; final boolean retry ; final Throwable error ; final WriteResult writeResult ; final UpdateResponse noopResult ; UpdateResult ( UpdateHelper . Result result , ActionRequest actionRequest , boolean retry , Throwable error , WriteResult writeResult ) { this . result = result ; this . actionRequest = actionRequest ; this . retry = retry ; this . error = error ; this . writeResult = writeResult ; this . noopResult = null ; } UpdateResult ( UpdateHelper . Result result , ActionRequest actionRequest , WriteResult writeResult ) { this . result = result ; this . actionRequest = actionRequest ; this . writeResult = writeResult ; this . retry = false ; this . error = null ; this . noopResult = null ; } public UpdateResult ( UpdateHelper . Result result , UpdateResponse updateResponse ) { this . result = result ; this . noopResult = updateResponse ; this . actionRequest = null ; this . writeResult = null ; this . retry = false ; this . error = null ; } boolean failure ( ) { return error ! = null ; } boolean success ( ) { return noopResult ! = null | | writeResult ! = null ; } @SuppressWarnings ( <str> ) < T extends ActionRequest > T request ( ) { return ( T ) actionRequest ; } } private UpdateResult shardUpdateOperation ( MetaData metaData , BulkShardRequest bulkShardRequest , UpdateRequest updateRequest , IndexShard indexShard ) { UpdateHelper . Result translate = updateHelper . prepare ( updateRequest , indexShard ) ; switch ( translate . operation ( ) ) { case UPSERT : case INDEX : IndexRequest indexRequest = translate . action ( ) ; try { WriteResult result = shardIndexOperation ( bulkShardRequest , indexRequest , metaData , indexShard , false ) ; return new UpdateResult ( translate , indexRequest , result ) ; } catch ( Throwable t ) { t = ExceptionsHelper . unwrapCause ( t ) ; boolean retry = false ; if ( t instanceof VersionConflictEngineException ) { retry = true ; } return new UpdateResult ( translate , indexRequest , retry , t , null ) ; } case DELETE : DeleteRequest deleteRequest = translate . action ( ) ; try { WriteResult < DeleteResponse > result = TransportDeleteAction . executeDeleteRequestOnPrimary ( deleteRequest , indexShard ) ; return new UpdateResult ( translate , deleteRequest , result ) ; } catch ( Throwable t ) { t = ExceptionsHelper . unwrapCause ( t ) ; boolean retry = false ; if ( t instanceof VersionConflictEngineException ) { retry = true ; } return new UpdateResult ( translate , deleteRequest , retry , t , null ) ; } case NONE : UpdateResponse updateResponse = translate . action ( ) ; indexShard . indexingService ( ) . noopUpdate ( updateRequest . type ( ) ) ; return new UpdateResult ( translate , updateResponse ) ; default : throw new IllegalStateException ( <str> + translate . operation ( ) ) ; } } @Override protected void shardOperationOnReplica ( BulkShardRequest request ) { final ShardId shardId = request . shardId ( ) ; IndexService indexService = indicesService . indexServiceSafe ( shardId . getIndex ( ) ) ; IndexShard indexShard = indexService . getShard ( shardId . id ( ) ) ; Translog . Location location = null ; for ( int i = <int> ; i < request . items ( ) . length ; i + + ) { BulkItemRequest item = request . items ( ) [ i ] ; if ( item = = null | | item . isIgnoreOnReplica ( ) ) { continue ; } if ( item . request ( ) instanceof IndexRequest ) { IndexRequest indexRequest = ( IndexRequest ) item . request ( ) ; try { Engine . Index operation = TransportIndexAction . executeIndexRequestOnReplica ( indexRequest , indexShard ) ; location = locationToSync ( location , operation . getTranslogLocation ( ) ) ; } catch ( Throwable e ) { if ( ! ignoreReplicaException ( e ) ) { throw e ; } } } else if ( item . request ( ) instanceof DeleteRequest ) { DeleteRequest deleteRequest = ( DeleteRequest ) item . request ( ) ; try { Engine . Delete delete = TransportDeleteAction . executeDeleteRequestOnReplica ( deleteRequest , indexShard ) ; indexShard . delete ( delete ) ; location = locationToSync ( location , delete . getTranslogLocation ( ) ) ; } catch ( Throwable e ) { if ( ! ignoreReplicaException ( e ) ) { throw e ; } } } else { throw new IllegalStateException ( <str> + item . request ( ) ) ; } } processAfterWrite ( request . refresh ( ) , indexShard , location ) ; } private void applyVersion ( BulkItemRequest item , long version , VersionType versionType ) { if ( item . request ( ) instanceof IndexRequest ) { ( ( IndexRequest ) item . request ( ) ) . version ( version ) . versionType ( versionType ) ; } else if ( item . request ( ) instanceof DeleteRequest ) { ( ( DeleteRequest ) item . request ( ) ) . version ( version ) . versionType ( ) ; } else if ( item . request ( ) instanceof UpdateRequest ) { ( ( UpdateRequest ) item . request ( ) ) . version ( version ) . versionType ( ) ; } else { } } private Translog . Location locationToSync ( Translog . Location current , Translog . Location next ) { assert next ! = null : <str> ; assert current = = null | | current . compareTo ( next ) < <int> : <str> ; return next ; } } 
