package org . elasticsearch . messy . tests ; import com . carrotsearch . hppc . LongHashSet ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . plugins . Plugin ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . groovy . GroovyPlugin ; import org . elasticsearch . search . aggregations . Aggregator . SubAggCollectionMode ; import org . elasticsearch . search . aggregations . bucket . filter . Filter ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram ; import org . elasticsearch . search . aggregations . bucket . histogram . Histogram . Bucket ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . metrics . max . Max ; import org . elasticsearch . search . aggregations . metrics . stats . Stats ; import org . elasticsearch . search . aggregations . metrics . sum . Sum ; import org . elasticsearch . test . ESIntegTestCase ; import org . hamcrest . Matchers ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . Iterator ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . index . query . QueryBuilders . matchAllQuery ; import static org . elasticsearch . search . aggregations . AggregationBuilders . filter ; import static org . elasticsearch . search . aggregations . AggregationBuilders . histogram ; import static org . elasticsearch . search . aggregations . AggregationBuilders . max ; import static org . elasticsearch . search . aggregations . AggregationBuilders . stats ; import static org . elasticsearch . search . aggregations . AggregationBuilders . sum ; import static org . elasticsearch . search . aggregations . AggregationBuilders . terms ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . containsString ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . greaterThanOrEqualTo ; import static org . hamcrest . Matchers . is ; import static org . hamcrest . Matchers . lessThanOrEqualTo ; import static org . hamcrest . core . IsNull . notNullValue ; @ESIntegTestCase.SuiteScopeTestCase public class HistogramTests extends ESIntegTestCase { private static final String SINGLE_VALUED_FIELD_NAME = <str> ; private static final String MULTI_VALUED_FIELD_NAME = <str> ; static int numDocs ; static int interval ; static int numValueBuckets , numValuesBuckets ; static long [ ] valueCounts , valuesCounts ; @Override protected Collection < Class < ? extends Plugin > > nodePlugins ( ) { return Collections . singleton ( GroovyPlugin . class ) ; } @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; createIndex ( <str> ) ; numDocs = randomIntBetween ( <int> , <int> ) ; interval = randomIntBetween ( <int> , <int> ) ; numValueBuckets = numDocs / interval + <int> ; valueCounts = new long [ numValueBuckets ] ; for ( int i = <int> ; i < numDocs ; i + + ) { final int bucket = ( i + <int> ) / interval ; valueCounts [ bucket ] + + ; } numValuesBuckets = ( numDocs + <int> ) / interval + <int> ; valuesCounts = new long [ numValuesBuckets ] ; for ( int i = <int> ; i < numDocs ; i + + ) { final int bucket1 = ( i + <int> ) / interval ; final int bucket2 = ( i + <int> ) / interval ; valuesCounts [ bucket1 ] + + ; if ( bucket1 ! = bucket2 ) { valuesCounts [ bucket2 ] + + ; } } List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < numDocs ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( SINGLE_VALUED_FIELD_NAME , i + <int> ) . startArray ( MULTI_VALUED_FIELD_NAME ) . value ( i + <int> ) . value ( i + <int> ) . endArray ( ) . field ( <str> , <str> + i ) . endObject ( ) ) ) ; } assertAcked ( prepareCreate ( <str> ) . addMapping ( <str> , SINGLE_VALUED_FIELD_NAME , <str> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> , <str> + i ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( SINGLE_VALUED_FIELD_NAME , i * <int> ) . endObject ( ) ) ) ; } indexRandom ( true , builders ) ; ensureSearchable ( ) ; } public void testSingleValuedField ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValueBuckets ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; } } public void singleValuedField_withOffset ( ) throws Exception { int interval1 = <int> ; int offset = <int> ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval1 ) . offset ( offset ) ) . execute ( ) . actionGet ( ) ; int expectedNumberOfBuckets = ( offset > = ( numDocs % interval + <int> ) ) ? numValueBuckets : numValueBuckets + <int> ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( expectedNumberOfBuckets ) ) ; Histogram . Bucket bucket = histo . getBuckets ( ) . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( - <int> ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; bucket = histo . getBuckets ( ) . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( numDocs % interval1 + <int> ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( ( numDocs % interval ) + <int> ) ) ; } public void testSingleValuedFieldWithRandomOffset ( ) throws Exception { int offset = randomIntBetween ( <int> , interval ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . offset ( offset ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; int expectedNumberOfBuckets = ( offset > = ( numDocs % interval + <int> ) ) ? numValueBuckets : numValueBuckets + <int> ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( expectedNumberOfBuckets ) ) ; int docsCounted = <int> ; for ( int i = <int> ; i < expectedNumberOfBuckets ; + + i ) { Histogram . Bucket bucket = histo . getBuckets ( ) . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) ( ( i - <int> ) * interval + offset ) ) ) ; if ( i = = <int> ) { long expectedFirstBucketCount = offset - <int> ; assertThat ( bucket . getDocCount ( ) , equalTo ( expectedFirstBucketCount ) ) ; docsCounted + = expectedFirstBucketCount ; } else if ( i < expectedNumberOfBuckets - <int> ) { assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) interval ) ) ; docsCounted + = interval ; } else { assertThat ( bucket . getDocCount ( ) , equalTo ( ( long ) numDocs - docsCounted ) ) ; } } } public void testSingleValuedFieldOrderedByKeyAsc ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . KEY_ASC ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; } } public void testsingleValuedFieldOrderedByKeyDesc ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . KEY_DESC ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( numValueBuckets - i - <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; } } public void testSingleValuedFieldOrderedByCountAsc ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . COUNT_ASC ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; LongHashSet buckets = new LongHashSet ( ) ; List < Histogram . Bucket > histoBuckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; long previousCount = Long . MIN_VALUE ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = histoBuckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; long key = ( ( Number ) bucket . getKey ( ) ) . longValue ( ) ; assertEquals ( <int> , key % interval ) ; assertTrue ( buckets . add ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ ( int ) ( key / interval ) ] ) ) ; assertThat ( bucket . getDocCount ( ) , greaterThanOrEqualTo ( previousCount ) ) ; previousCount = bucket . getDocCount ( ) ; } } public void testSingleValuedFieldOrderedByCountDesc ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . COUNT_DESC ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; LongHashSet buckets = new LongHashSet ( ) ; List < Histogram . Bucket > histoBuckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; long previousCount = Long . MAX_VALUE ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = histoBuckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; long key = ( ( Number ) bucket . getKey ( ) ) . longValue ( ) ; assertEquals ( <int> , key % interval ) ; assertTrue ( buckets . add ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ ( int ) ( key / interval ) ] ) ) ; assertThat ( bucket . getDocCount ( ) , lessThanOrEqualTo ( previousCount ) ) ; previousCount = bucket . getDocCount ( ) ; } } public void testSingleValuedFieldWithSubAggregation ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; Object [ ] propertiesKeys = ( Object [ ] ) histo . getProperty ( <str> ) ; Object [ ] propertiesDocCounts = ( Object [ ] ) histo . getProperty ( <str> ) ; Object [ ] propertiesCounts = ( Object [ ] ) histo . getProperty ( <str> ) ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; long s = <int> ; for ( int j = <int> ; j < numDocs ; + + j ) { if ( ( j + <int> ) / interval = = i ) { s + = j + <int> ; } } assertThat ( sum . getValue ( ) , equalTo ( ( double ) s ) ) ; assertThat ( ( long ) propertiesKeys [ i ] , equalTo ( ( long ) i * interval ) ) ; assertThat ( ( long ) propertiesDocCounts [ i ] , equalTo ( valueCounts [ i ] ) ) ; assertThat ( ( double ) propertiesCounts [ i ] , equalTo ( ( double ) s ) ) ; } } public void testSingleValuedFieldWithSubAggregationInherited ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . subAggregation ( sum ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; long s = <int> ; for ( int j = <int> ; j < numDocs ; + + j ) { if ( ( j + <int> ) / interval = = i ) { s + = j + <int> ; } } assertThat ( sum . getValue ( ) , equalTo ( ( double ) s ) ) ; } } public void testSingleValuedFieldOrderedBySubAggregationAsc ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . aggregation ( <str> , true ) ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; LongHashSet visited = new LongHashSet ( ) ; double previousSum = Double . NEGATIVE_INFINITY ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; long key = ( ( Number ) bucket . getKey ( ) ) . longValue ( ) ; assertTrue ( visited . add ( key ) ) ; int b = ( int ) ( key / interval ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ b ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; long s = <int> ; for ( int j = <int> ; j < numDocs ; + + j ) { if ( ( j + <int> ) / interval = = b ) { s + = j + <int> ; } } assertThat ( sum . getValue ( ) , equalTo ( ( double ) s ) ) ; assertThat ( sum . getValue ( ) , greaterThanOrEqualTo ( previousSum ) ) ; previousSum = s ; } } public void testSingleValuedFieldOrderedBySubAggregationDesc ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . aggregation ( <str> , false ) ) . subAggregation ( sum ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; LongHashSet visited = new LongHashSet ( ) ; double previousSum = Double . POSITIVE_INFINITY ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; long key = ( ( Number ) bucket . getKey ( ) ) . longValue ( ) ; assertTrue ( visited . add ( key ) ) ; int b = ( int ) ( key / interval ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ b ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; long s = <int> ; for ( int j = <int> ; j < numDocs ; + + j ) { if ( ( j + <int> ) / interval = = b ) { s + = j + <int> ; } } assertThat ( sum . getValue ( ) , equalTo ( ( double ) s ) ) ; assertThat ( sum . getValue ( ) , lessThanOrEqualTo ( previousSum ) ) ; previousSum = s ; } } public void testSingleValuedFieldOrderedByMultiValuedSubAggregationAscInherited ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . aggregation ( <str> , true ) ) . subAggregation ( stats ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; LongHashSet visited = new LongHashSet ( ) ; double previousSum = Double . NEGATIVE_INFINITY ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; long key = ( ( Number ) bucket . getKey ( ) ) . longValue ( ) ; assertTrue ( visited . add ( key ) ) ; int b = ( int ) ( key / interval ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ b ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Stats stats = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( stats , notNullValue ( ) ) ; long s = <int> ; for ( int j = <int> ; j < numDocs ; + + j ) { if ( ( j + <int> ) / interval = = b ) { s + = j + <int> ; } } assertThat ( stats . getSum ( ) , equalTo ( ( double ) s ) ) ; assertThat ( stats . getSum ( ) , greaterThanOrEqualTo ( previousSum ) ) ; previousSum = s ; } } public void testSingleValuedFieldOrderedByMultiValuedSubAggregationDesc ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . aggregation ( <str> , false ) ) . subAggregation ( stats ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; LongHashSet visited = new LongHashSet ( ) ; double previousSum = Double . POSITIVE_INFINITY ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; long key = ( ( Number ) bucket . getKey ( ) ) . longValue ( ) ; assertTrue ( visited . add ( key ) ) ; int b = ( int ) ( key / interval ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ b ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Stats stats = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( stats , notNullValue ( ) ) ; long s = <int> ; for ( int j = <int> ; j < numDocs ; + + j ) { if ( ( j + <int> ) / interval = = b ) { s + = j + <int> ; } } assertThat ( stats . getSum ( ) , equalTo ( ( double ) s ) ) ; assertThat ( stats . getSum ( ) , lessThanOrEqualTo ( previousSum ) ) ; previousSum = s ; } } public void testSingleValuedFieldOrderedBySubAggregationDescDeepOrderPath ( ) throws Exception { boolean asc = randomBoolean ( ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . aggregation ( <str> , asc ) ) . subAggregation ( filter ( <str> ) . filter ( matchAllQuery ( ) ) . subAggregation ( max ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; LongHashSet visited = new LongHashSet ( ) ; double prevMax = asc ? Double . NEGATIVE_INFINITY : Double . POSITIVE_INFINITY ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; long key = ( ( Number ) bucket . getKey ( ) ) . longValue ( ) ; assertTrue ( visited . add ( key ) ) ; int b = ( int ) ( key / interval ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ b ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Filter filter = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( filter , notNullValue ( ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( filter . getDocCount ( ) ) ) ; Max max = filter . getAggregations ( ) . get ( <str> ) ; assertThat ( max , Matchers . notNullValue ( ) ) ; assertThat ( max . getValue ( ) , asc ? greaterThanOrEqualTo ( prevMax ) : lessThanOrEqualTo ( prevMax ) ) ; prevMax = max . getValue ( ) ; } } public void testSingleValuedFieldWithValueScript ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . script ( new Script ( <str> ) ) . interval ( interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; final int numBuckets = ( numDocs + <int> ) / interval - <int> / interval + <int> ; final long [ ] counts = new long [ ( numDocs + <int> ) / interval + <int> ] ; for ( int i = <int> ; i < numDocs ; + + i ) { + + counts [ ( i + <int> ) / interval ] ; } Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numBuckets ) ) ; for ( int i = <int> ; i < numBuckets ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; int key = ( ( <int> / interval ) + i ) * interval ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( counts [ key / interval ] ) ) ; } } public void testMultiValuedField ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( MULTI_VALUED_FIELD_NAME ) . interval ( interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValuesBuckets ) ) ; for ( int i = <int> ; i < numValuesBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valuesCounts [ i ] ) ) ; } } public void testMultiValuedFieldOrderedByKeyDesc ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( MULTI_VALUED_FIELD_NAME ) . interval ( interval ) . order ( Histogram . Order . KEY_DESC ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValuesBuckets ) ) ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValuesBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( numValuesBuckets - i - <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valuesCounts [ i ] ) ) ; } } public void testMultiValuedFieldWithValueScript ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( MULTI_VALUED_FIELD_NAME ) . script ( new Script ( <str> ) ) . interval ( interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; final int numBuckets = ( numDocs + <int> ) / interval - <int> / interval + <int> ; final long [ ] counts = new long [ ( numDocs + <int> ) / interval + <int> ] ; for ( int i = <int> ; i < numDocs ; + + i ) { final int bucket1 = ( i + <int> ) / interval ; final int bucket2 = ( i + <int> ) / interval ; + + counts [ bucket1 ] ; if ( bucket1 ! = bucket2 ) { + + counts [ bucket2 ] ; } } Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numBuckets ) ) ; for ( int i = <int> ; i < numBuckets ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; int key = ( ( <int> / interval ) + i ) * interval ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( counts [ key / interval ] ) ) ; } } public void testMultiValuedFieldWithValueScriptWithInheritedSubAggregator ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( MULTI_VALUED_FIELD_NAME ) . script ( new Script ( <str> ) ) . interval ( interval ) . subAggregation ( terms ( MULTI_VALUED_FIELD_NAME ) . collectMode ( randomFrom ( SubAggCollectionMode . values ( ) ) ) . order ( Terms . Order . term ( true ) ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; final int numBuckets = ( numDocs + <int> ) / interval - <int> / interval + <int> ; final long [ ] counts = new long [ ( numDocs + <int> ) / interval + <int> ] ; for ( int i = <int> ; i < numDocs ; + + i ) { final int bucket1 = ( i + <int> ) / interval ; final int bucket2 = ( i + <int> ) / interval ; + + counts [ bucket1 ] ; if ( bucket1 ! = bucket2 ) { + + counts [ bucket2 ] ; } } Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numBuckets ) ) ; for ( int i = <int> ; i < numBuckets ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; int key = ( ( <int> / interval ) + i ) * interval ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( counts [ key / interval ] ) ) ; Terms terms = bucket . getAggregations ( ) . get ( MULTI_VALUED_FIELD_NAME ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( MULTI_VALUED_FIELD_NAME ) ) ; int minTerm = Math . max ( <int> , key - <int> ) ; int maxTerm = Math . min ( numDocs + <int> , ( key / interval + <int> ) * interval ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( maxTerm - minTerm + <int> ) ) ; Iterator < Terms . Bucket > iter = terms . getBuckets ( ) . iterator ( ) ; for ( int j = minTerm ; j < = maxTerm ; + + j ) { assertThat ( iter . next ( ) . getKeyAsNumber ( ) . longValue ( ) , equalTo ( ( long ) j ) ) ; } } } public void testScriptSingleValue ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . script ( new Script ( <str> + SINGLE_VALUED_FIELD_NAME + <str> ) ) . interval ( interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValueBuckets ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; } } public void testScriptSingleValueWithSubAggregatorInherited ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . script ( new Script ( <str> + SINGLE_VALUED_FIELD_NAME + <str> ) ) . interval ( interval ) . subAggregation ( sum ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( numValueBuckets ) ) ; List < Histogram . Bucket > buckets = new ArrayList < Histogram . Bucket > ( histo . getBuckets ( ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; long s = <int> ; for ( int j = <int> ; j < numDocs ; + + j ) { if ( ( j + <int> ) / interval = = i ) { s + = j + <int> ; } } assertThat ( sum . getValue ( ) , equalTo ( ( double ) s ) ) ; } } public void testScriptMultiValued ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . script ( new Script ( <str> + MULTI_VALUED_FIELD_NAME + <str> ) ) . interval ( interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValuesBuckets ) ) ; for ( int i = <int> ; i < numValuesBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valuesCounts [ i ] ) ) ; } } public void testScriptMultiValuedWithAggregatorInherited ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . script ( new Script ( <str> + MULTI_VALUED_FIELD_NAME + <str> ) ) . interval ( interval ) . subAggregation ( sum ( <str> ) ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValuesBuckets ) ) ; for ( int i = <int> ; i < numValuesBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valuesCounts [ i ] ) ) ; assertThat ( bucket . getAggregations ( ) . asList ( ) . isEmpty ( ) , is ( false ) ) ; Sum sum = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( sum , notNullValue ( ) ) ; long s = <int> ; for ( int j = <int> ; j < numDocs ; + + j ) { if ( ( j + <int> ) / interval = = i | | ( j + <int> ) / interval = = i ) { s + = j + <int> ; s + = j + <int> ; } } assertThat ( sum . getValue ( ) , equalTo ( ( double ) s ) ) ; } } public void testUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; } public void testPartiallyUnmapped ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValueBuckets ) ) ; for ( int i = <int> ; i < numValueBuckets ; + + i ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) i * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i ] ) ) ; } } public void testPartiallyUnmappedWithExtendedBounds ( ) throws Exception { SearchResponse response = client ( ) . prepareSearch ( <str> , <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . extendedBounds ( ( long ) - <int> * <int> * interval , ( long ) valueCounts . length * interval ) ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( numValueBuckets + <int> ) ) ; Histogram . Bucket bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) - <int> * <int> * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> l ) ) ; bucket = buckets . get ( <int> ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) - <int> * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> l ) ) ; for ( int i = <int> ; i < numValueBuckets + <int> ; + + i ) { bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( ( long ) ( i - <int> ) * interval ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( valueCounts [ i - <int> ] ) ) ; } } public void testEmptyAggregation ( ) throws Exception { SearchResponse searchResponse = client ( ) . prepareSearch ( <str> ) . setQuery ( matchAllQuery ( ) ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( <int> ) . minDocCount ( <int> ) . subAggregation ( histogram ( <str> ) . interval ( <int> ) ) ) . execute ( ) . actionGet ( ) ; assertThat ( searchResponse . getHits ( ) . getTotalHits ( ) , equalTo ( <int> ) ) ; Histogram histo = searchResponse . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , Matchers . notNullValue ( ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; Histogram . Bucket bucket = buckets . get ( <int> ) ; assertThat ( bucket , Matchers . notNullValue ( ) ) ; histo = bucket . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , Matchers . notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; assertThat ( histo . getBuckets ( ) . isEmpty ( ) , is ( true ) ) ; } public void testSingleValuedFieldWithExtendedBounds ( ) throws Exception { int lastDataBucketKey = ( numValueBuckets - <int> ) * interval ; int addedBucketsLeft = randomIntBetween ( <int> , numValueBuckets ) ; long boundsMinKey = addedBucketsLeft * interval ; if ( frequently ( ) ) { boundsMinKey = - boundsMinKey ; } else { addedBucketsLeft = <int> ; } long boundsMin = boundsMinKey + randomIntBetween ( <int> , interval - <int> ) ; int addedBucketsRight = randomIntBetween ( <int> , numValueBuckets ) ; long boundsMaxKeyDelta = addedBucketsRight * interval ; if ( rarely ( ) ) { addedBucketsRight = <int> ; boundsMaxKeyDelta = - boundsMaxKeyDelta ; } long boundsMaxKey = lastDataBucketKey + boundsMaxKeyDelta ; long boundsMax = boundsMaxKey + randomIntBetween ( <int> , interval - <int> ) ; boolean invalidBoundsError = boundsMin > boundsMax ; int bucketsCount = numValueBuckets + addedBucketsLeft + addedBucketsRight ; long [ ] extendedValueCounts = new long [ bucketsCount ] ; System . arraycopy ( valueCounts , <int> , extendedValueCounts , addedBucketsLeft , valueCounts . length ) ; SearchResponse response = null ; try { response = client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( interval ) . minDocCount ( <int> ) . extendedBounds ( boundsMin , boundsMax ) ) . execute ( ) . actionGet ( ) ; if ( invalidBoundsError ) { fail ( <str> ) ; return ; } } catch ( Exception e ) { if ( invalidBoundsError ) { return ; } else { throw e ; } } assertSearchResponse ( response ) ; Histogram histo = response . getAggregations ( ) . get ( <str> ) ; assertThat ( histo , notNullValue ( ) ) ; assertThat ( histo . getName ( ) , equalTo ( <str> ) ) ; List < ? extends Bucket > buckets = histo . getBuckets ( ) ; assertThat ( buckets . size ( ) , equalTo ( bucketsCount ) ) ; long key = Math . min ( boundsMinKey , <int> ) ; for ( int i = <int> ; i < bucketsCount ; i + + ) { Histogram . Bucket bucket = buckets . get ( i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( ( ( Number ) bucket . getKey ( ) ) . longValue ( ) , equalTo ( key ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( extendedValueCounts [ i ] ) ) ; key + = interval ; } } public void testExeptionOnNegativerInterval ( ) { try { client ( ) . prepareSearch ( <str> ) . addAggregation ( histogram ( <str> ) . field ( SINGLE_VALUED_FIELD_NAME ) . interval ( - <int> ) . minDocCount ( <int> ) ) . execute ( ) . actionGet ( ) ; fail ( ) ; } catch ( SearchPhaseExecutionException e ) { assertThat ( e . toString ( ) , containsString ( <str> ) ) ; } } } 
