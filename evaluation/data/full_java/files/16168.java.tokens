package org . gradle . tooling . internal . provider . runner ; import com . google . common . base . Strings ; import com . google . common . collect . Lists ; import com . google . common . collect . Maps ; import org . gradle . api . execution . internal . InternalTaskExecutionListener ; import org . gradle . api . execution . internal . TaskOperationInternal ; import org . gradle . api . internal . tasks . testing . TestCompleteEvent ; import org . gradle . api . internal . tasks . testing . TestDescriptorInternal ; import org . gradle . api . internal . tasks . testing . TestStartEvent ; import org . gradle . api . internal . tasks . testing . results . TestListenerInternal ; import org . gradle . api . tasks . testing . TestExecutionException ; import org . gradle . api . tasks . testing . TestOutputEvent ; import org . gradle . api . tasks . testing . TestResult ; import org . gradle . internal . progress . OperationResult ; import org . gradle . internal . progress . OperationStartEvent ; import org . gradle . tooling . internal . protocol . events . InternalTestDescriptor ; import org . gradle . tooling . internal . protocol . test . InternalJvmTestRequest ; import org . gradle . tooling . internal . provider . TestExecutionRequestAction ; import org . gradle . tooling . internal . provider . events . DefaultTestDescriptor ; import java . util . Collection ; import java . util . List ; import java . util . Map ; class TestExecutionResultEvaluator implements TestListenerInternal , InternalTaskExecutionListener { private static final String INDENT = <str> ; private long resultCount ; private Map < Object , String > runningTasks = Maps . newHashMap ( ) ; private TestExecutionRequestAction internalTestExecutionRequest ; private List < FailedTest > failedTests = Lists . newArrayList ( ) ; public TestExecutionResultEvaluator ( TestExecutionRequestAction internalTestExecutionRequest ) { this . internalTestExecutionRequest = internalTestExecutionRequest ; } public boolean hasUnmatchedTests ( ) { return resultCount = = <int> ; } public boolean hasFailedTests ( ) { return ! failedTests . isEmpty ( ) ; } public void evaluate ( ) { if ( hasUnmatchedTests ( ) ) { String formattedTestRequest = formatInternalTestExecutionRequest ( ) ; throw new TestExecutionException ( <str> + formattedTestRequest ) ; } if ( hasFailedTests ( ) ) { StringBuilder failedTestsMessage = new StringBuilder ( <str> ) . append ( INDENT ) . append ( <str> ) ; for ( FailedTest failedTest : failedTests ) { failedTestsMessage . append ( <str> ) . append ( Strings . repeat ( INDENT , <int> ) ) . append ( failedTest . getDescription ( ) ) ; } throw new TestExecutionException ( failedTestsMessage . toString ( ) ) ; } } private String formatInternalTestExecutionRequest ( ) { StringBuilder requestDetails = new StringBuilder ( INDENT ) . append ( <str> ) ; for ( InternalTestDescriptor internalTestDescriptor : internalTestExecutionRequest . getTestExecutionDescriptors ( ) ) { requestDetails . append ( <str> ) . append ( Strings . repeat ( INDENT , <int> ) ) . append ( internalTestDescriptor . getDisplayName ( ) ) ; requestDetails . append ( <str> ) . append ( ( ( DefaultTestDescriptor ) internalTestDescriptor ) . getTaskPath ( ) ) . append ( <str> ) ; } final Collection < InternalJvmTestRequest > internalJvmTestRequests = internalTestExecutionRequest . getInternalJvmTestRequests ( ) ; for ( InternalJvmTestRequest internalJvmTestRequest : internalJvmTestRequests ) { final String className = internalJvmTestRequest . getClassName ( ) ; final String methodName = internalJvmTestRequest . getMethodName ( ) ; if ( methodName = = null ) { requestDetails . append ( <str> ) . append ( Strings . repeat ( INDENT , <int> ) ) . append ( <str> ) . append ( className ) ; } else { requestDetails . append ( <str> ) . append ( Strings . repeat ( INDENT , <int> ) ) . append ( <str> ) . append ( className ) . append ( <str> ) . append ( methodName ) . append ( <str> ) ; } } return requestDetails . toString ( ) ; } @Override public void started ( TestDescriptorInternal testDescriptor , TestStartEvent startEvent ) { } @Override public void completed ( TestDescriptorInternal testDescriptor , TestResult testResult , TestCompleteEvent completeEvent ) { if ( testDescriptor . getParent ( ) = = null ) { resultCount = resultCount + testResult . getTestCount ( ) ; } if ( ! testDescriptor . isComposite ( ) & & testResult . getFailedTestCount ( ) ! = <int> ) { failedTests . add ( new FailedTest ( testDescriptor . getName ( ) , testDescriptor . getClassName ( ) , getTaskPath ( testDescriptor ) ) ) ; } } private String getTaskPath ( TestDescriptorInternal givenDescriptor ) { TestDescriptorInternal descriptor = givenDescriptor ; while ( descriptor . getOwnerBuildOperationId ( ) = = null & & descriptor . getParent ( ) ! = null ) { descriptor = descriptor . getParent ( ) ; } return runningTasks . get ( descriptor . getOwnerBuildOperationId ( ) ) ; } @Override public void output ( TestDescriptorInternal testDescriptor , TestOutputEvent event ) { } @Override public void beforeExecute ( TaskOperationInternal taskOperation , OperationStartEvent startEvent ) { runningTasks . put ( taskOperation . getId ( ) , taskOperation . getTask ( ) . getPath ( ) ) ; } @Override public void afterExecute ( TaskOperationInternal taskOperation , OperationResult result ) { runningTasks . remove ( taskOperation . getId ( ) ) ; } private static class FailedTest { final String name ; final String className ; final String taskPath ; public FailedTest ( String name , String className , String taskPath ) { this . name = name ; this . className = className ; this . taskPath = taskPath ; } public String getDescription ( ) { StringBuilder stringBuilder = new StringBuilder ( <str> ) . append ( className ) . append ( <str> ) . append ( name ) . append ( <str> ) . append ( taskPath ) . append ( <str> ) ; return stringBuilder . toString ( ) ; } } } 
