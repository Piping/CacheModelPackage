package io . netty . util . internal ; import org . junit . Test ; import java . util . Date ; import static org . junit . Assert . * ; public class TypeParameterMatcherTest { @Test public void testConcreteClass ( ) throws Exception { TypeParameterMatcher m = TypeParameterMatcher . find ( new TypeQ ( ) , TypeX . class , <str> ) ; assertFalse ( m . match ( new Object ( ) ) ) ; assertFalse ( m . match ( new A ( ) ) ) ; assertFalse ( m . match ( new AA ( ) ) ) ; assertTrue ( m . match ( new AAA ( ) ) ) ; assertFalse ( m . match ( new B ( ) ) ) ; assertFalse ( m . match ( new BB ( ) ) ) ; assertFalse ( m . match ( new BBB ( ) ) ) ; assertFalse ( m . match ( new C ( ) ) ) ; assertFalse ( m . match ( new CC ( ) ) ) ; } @Test ( expected = IllegalStateException . class ) public void testUnsolvedParameter ( ) throws Exception { TypeParameterMatcher . find ( new TypeQ ( ) , TypeX . class , <str> ) ; } @Test public void testAnonymousClass ( ) throws Exception { TypeParameterMatcher m = TypeParameterMatcher . find ( new TypeQ < BBB > ( ) { } , TypeX . class , <str> ) ; assertFalse ( m . match ( new Object ( ) ) ) ; assertFalse ( m . match ( new A ( ) ) ) ; assertFalse ( m . match ( new AA ( ) ) ) ; assertFalse ( m . match ( new AAA ( ) ) ) ; assertFalse ( m . match ( new B ( ) ) ) ; assertFalse ( m . match ( new BB ( ) ) ) ; assertTrue ( m . match ( new BBB ( ) ) ) ; assertFalse ( m . match ( new C ( ) ) ) ; assertFalse ( m . match ( new CC ( ) ) ) ; } @Test public void testAbstractClass ( ) throws Exception { TypeParameterMatcher m = TypeParameterMatcher . find ( new TypeQ ( ) , TypeX . class , <str> ) ; assertFalse ( m . match ( new Object ( ) ) ) ; assertFalse ( m . match ( new A ( ) ) ) ; assertFalse ( m . match ( new AA ( ) ) ) ; assertFalse ( m . match ( new AAA ( ) ) ) ; assertFalse ( m . match ( new B ( ) ) ) ; assertFalse ( m . match ( new BB ( ) ) ) ; assertFalse ( m . match ( new BBB ( ) ) ) ; assertFalse ( m . match ( new C ( ) ) ) ; assertTrue ( m . match ( new CC ( ) ) ) ; } public static class TypeX < A , B , C > { A a ; B b ; C c ; } public static class TypeY < D extends C , E extends A , F extends B > extends TypeX < E , F , D > { } public abstract static class TypeZ < G extends AA , H extends BB > extends TypeY < CC , G , H > { } public static class TypeQ < I extends BBB > extends TypeZ < AAA , I > { } public static class A { } public static class AA extends A { } public static class AAA extends AA { } public static class B { } public static class BB extends B { } public static class BBB extends BB { } public static class C { } public static class CC extends C { } @Test public void testInaccessibleClass ( ) throws Exception { TypeParameterMatcher m = TypeParameterMatcher . find ( new U < T > ( ) { } , U . class , <str> ) ; assertFalse ( m . match ( new Object ( ) ) ) ; assertTrue ( m . match ( new T ( ) ) ) ; } private static class T { } private static class U < E > { E a ; } @Test public void testArrayAsTypeParam ( ) throws Exception { TypeParameterMatcher m = TypeParameterMatcher . find ( new U < byte [ ] > ( ) { } , U . class , <str> ) ; assertFalse ( m . match ( new Object ( ) ) ) ; assertTrue ( m . match ( new byte [ <int> ] ) ) ; } @Test public void testRawType ( ) throws Exception { TypeParameterMatcher m = TypeParameterMatcher . find ( new U ( ) { } , U . class , <str> ) ; assertTrue ( m . match ( new Object ( ) ) ) ; } private static class V < E > { U < E > u = new U < E > ( ) { } ; } @Test public void testInnerClass ( ) throws Exception { TypeParameterMatcher m = TypeParameterMatcher . find ( new V < String > ( ) . u , U . class , <str> ) ; assertTrue ( m . match ( new Object ( ) ) ) ; } private abstract static class W < E > { E e ; } private static class X < T , E > extends W < E > { T t ; } @Test ( expected = IllegalStateException . class ) public void testErasure ( ) throws Exception { TypeParameterMatcher m = TypeParameterMatcher . find ( new X < String , Date > ( ) , W . class , <str> ) ; assertTrue ( m . match ( new Date ( ) ) ) ; assertFalse ( m . match ( new Object ( ) ) ) ; } } 
