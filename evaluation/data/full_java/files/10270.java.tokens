package com . google . common . cache ; import com . google . common . annotations . GwtCompatible ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . Sets ; import com . google . common . testing . FakeTicker ; import junit . framework . TestCase ; import java . util . Iterator ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Set ; import java . util . concurrent . Callable ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . TimeUnit ; @GwtCompatible public class CacheBuilderGwtTest extends TestCase { private FakeTicker fakeTicker ; @Override protected void setUp ( ) throws Exception { super . setUp ( ) ; fakeTicker = new FakeTicker ( ) ; } public void testLoader ( ) throws ExecutionException { final Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . build ( ) ; Callable < Integer > loader = new Callable < Integer > ( ) { private int i = <int> ; @Override public Integer call ( ) throws Exception { return + + i ; } } ; cache . put ( <int> , <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . get ( <int> , loader ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . get ( <int> , loader ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . get ( <int> , loader ) ) ; cache . invalidate ( <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . get ( <int> , loader ) ) ; cache . put ( <int> , <int> ) ; cache . invalidateAll ( ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . get ( <int> , loader ) ) ; } public void testSizeConstraint ( ) { final Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . maximumSize ( <int> ) . build ( ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; cache . put ( <int> , <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; } public void testLoadingCache ( ) throws ExecutionException { CacheLoader < Integer , Integer > loader = new CacheLoader < Integer , Integer > ( ) { int i = <int> ; @Override public Integer load ( Integer key ) throws Exception { return i + + ; } } ; LoadingCache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . build ( loader ) ; cache . put ( <int> , <int> ) ; Map < Integer , Integer > map = cache . getAll ( ImmutableList . of ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , map . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , map . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , map . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , map . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , map . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , map . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . apply ( <int> ) ) ; } public void testExpireAfterAccess ( ) { final Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterAccess ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; } public void testExpireAfterWrite ( ) { final Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; cache . put ( <int> , <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; } public void testExpireAfterWriteAndAccess ( ) { final Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . expireAfterAccess ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; cache . put ( <int> , <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; } public void testMapMethods ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . build ( ) ; ConcurrentMap < Integer , Integer > asMap = cache . asMap ( ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; asMap . replace ( <int> , <int> ) ; asMap . replace ( <int> , <int> ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; assertEquals ( null , asMap . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , asMap . get ( <int> ) ) ; asMap . replace ( <int> , <int> , <int> ) ; asMap . replace ( <int> , <int> , <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , asMap . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , asMap . get ( <int> ) ) ; asMap . remove ( <int> , <int> ) ; asMap . remove ( <int> , <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , asMap . get ( <int> ) ) ; assertEquals ( null , cache . getIfPresent ( <int> ) ) ; assertEquals ( null , asMap . get ( <int> ) ) ; asMap . putIfAbsent ( <int> , <int> ) ; asMap . putIfAbsent ( <int> , <int> ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , asMap . get ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , asMap . get ( <int> ) ) ; } public void testRemovalListener ( ) { final int [ ] stats = new int [ <int> ] ; RemovalListener < Integer , Integer > countingListener = new RemovalListener < Integer , Integer > ( ) { @Override public void onRemoval ( RemovalNotification < Integer , Integer > notification ) { switch ( notification . getCause ( ) ) { case EXPIRED : stats [ <int> ] + + ; break ; case EXPLICIT : stats [ <int> ] + + ; break ; case REPLACED : stats [ <int> ] + + ; break ; case SIZE : stats [ <int> ] + + ; break ; default : throw new IllegalStateException ( <str> ) ; } } } ; Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . removalListener ( countingListener ) . ticker ( fakeTicker ) . maximumSize ( <int> ) . build ( ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; cache . getIfPresent ( <int> ) ; cache . getIfPresent ( <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . invalidateAll ( ) ; assertEquals ( <int> , stats [ <int> ] ) ; assertEquals ( <int> , stats [ <int> ] ) ; assertEquals ( <int> , stats [ <int> ] ) ; assertEquals ( <int> , stats [ <int> ] ) ; } public void testPutAll ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . build ( ) ; cache . putAll ( ImmutableMap . of ( <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; cache . asMap ( ) . putAll ( ImmutableMap . of ( <int> , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; assertEquals ( Integer . valueOf ( <int> ) , cache . getIfPresent ( <int> ) ) ; } public void testInvalidate ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . build ( ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . invalidate ( <int> ) ; assertFalse ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertTrue ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertTrue ( cache . asMap ( ) . containsKey ( <int> ) ) ; } public void testInvalidateAll ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . build ( ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . invalidateAll ( ) ; assertFalse ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( <int> ) ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; cache . invalidateAll ( ImmutableSet . of ( <int> , <int> ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertTrue ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertTrue ( cache . asMap ( ) . containsKey ( <int> ) ) ; } public void testAsMap_containsValue ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertTrue ( cache . asMap ( ) . containsValue ( <int> ) ) ; assertTrue ( cache . asMap ( ) . containsValue ( <int> ) ) ; assertFalse ( cache . asMap ( ) . containsValue ( <int> ) ) ; } public void testAsMap_containsKey ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertTrue ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertTrue ( cache . asMap ( ) . containsKey ( <int> ) ) ; assertFalse ( cache . asMap ( ) . containsKey ( <int> ) ) ; } public void testAsMapValues_contains ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertTrue ( cache . asMap ( ) . values ( ) . contains ( <int> ) ) ; assertTrue ( cache . asMap ( ) . values ( ) . contains ( <int> ) ) ; assertFalse ( cache . asMap ( ) . values ( ) . contains ( <int> ) ) ; } public void testAsMapKeySet ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; Set < Integer > foundKeys = Sets . newHashSet ( ) ; for ( Integer current : cache . asMap ( ) . keySet ( ) ) { foundKeys . add ( current ) ; } assertEquals ( ImmutableSet . of ( <int> , <int> ) , foundKeys ) ; } public void testAsMapKeySet_contains ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; assertTrue ( cache . asMap ( ) . keySet ( ) . contains ( <int> ) ) ; assertTrue ( cache . asMap ( ) . keySet ( ) . contains ( <int> ) ) ; assertFalse ( cache . asMap ( ) . keySet ( ) . contains ( <int> ) ) ; } public void testAsMapEntrySet ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; cache . put ( <int> , <int> ) ; cache . put ( <int> , <int> ) ; fakeTicker . advance ( <int> , TimeUnit . MILLISECONDS ) ; int sum = <int> ; for ( Entry < Integer , Integer > current : cache . asMap ( ) . entrySet ( ) ) { sum + = current . getKey ( ) + current . getValue ( ) ; } assertEquals ( <int> , sum ) ; } public void testAsMapValues_iteratorRemove ( ) { Cache < Integer , Integer > cache = CacheBuilder . newBuilder ( ) . expireAfterWrite ( <int> , TimeUnit . MILLISECONDS ) . ticker ( fakeTicker ) . build ( ) ; cache . put ( <int> , <int> ) ; Iterator < Integer > iterator = cache . asMap ( ) . values ( ) . iterator ( ) ; iterator . next ( ) ; iterator . remove ( ) ; assertEquals ( <int> , cache . size ( ) ) ; } } 
