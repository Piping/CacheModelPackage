package io . netty . handler . codec . http . websocketx ; import io . netty . buffer . ByteBuf ; import io . netty . channel . ChannelHandlerContext ; import io . netty . handler . codec . ReplayingDecoder ; import io . netty . handler . codec . TooLongFrameException ; import java . util . List ; import static io . netty . buffer . ByteBufUtil . readBytes ; public class WebSocket00FrameDecoder extends ReplayingDecoder < Void > implements WebSocketFrameDecoder { static final int DEFAULT_MAX_FRAME_SIZE = <int> ; private final long maxFrameSize ; private boolean receivedClosingHandshake ; public WebSocket00FrameDecoder ( ) { this ( DEFAULT_MAX_FRAME_SIZE ) ; } public WebSocket00FrameDecoder ( int maxFrameSize ) { this . maxFrameSize = maxFrameSize ; } @Override protected void decode ( ChannelHandlerContext ctx , ByteBuf in , List < Object > out ) throws Exception { if ( receivedClosingHandshake ) { in . skipBytes ( actualReadableBytes ( ) ) ; return ; } byte type = in . readByte ( ) ; WebSocketFrame frame ; if ( ( type & <hex> ) = = <hex> ) { frame = decodeBinaryFrame ( ctx , type , in ) ; } else { frame = decodeTextFrame ( ctx , in ) ; } if ( frame ! = null ) { out . add ( frame ) ; } } private WebSocketFrame decodeBinaryFrame ( ChannelHandlerContext ctx , byte type , ByteBuf buffer ) { long frameSize = <int> ; int lengthFieldSize = <int> ; byte b ; do { b = buffer . readByte ( ) ; frameSize < < = <int> ; frameSize | = b & <hex> ; if ( frameSize > maxFrameSize ) { throw new TooLongFrameException ( ) ; } lengthFieldSize + + ; if ( lengthFieldSize > <int> ) { throw new TooLongFrameException ( ) ; } } while ( ( b & <hex> ) = = <hex> ) ; if ( type = = ( byte ) <hex> & & frameSize = = <int> ) { receivedClosingHandshake = true ; return new CloseWebSocketFrame ( ) ; } ByteBuf payload = readBytes ( ctx . alloc ( ) , buffer , ( int ) frameSize ) ; return new BinaryWebSocketFrame ( payload ) ; } private WebSocketFrame decodeTextFrame ( ChannelHandlerContext ctx , ByteBuf buffer ) { int ridx = buffer . readerIndex ( ) ; int rbytes = actualReadableBytes ( ) ; int delimPos = buffer . indexOf ( ridx , ridx + rbytes , ( byte ) <hex> ) ; if ( delimPos = = - <int> ) { if ( rbytes > maxFrameSize ) { throw new TooLongFrameException ( ) ; } else { return null ; } } int frameSize = delimPos - ridx ; if ( frameSize > maxFrameSize ) { throw new TooLongFrameException ( ) ; } ByteBuf binaryData = readBytes ( ctx . alloc ( ) , buffer , frameSize ) ; buffer . skipBytes ( <int> ) ; int ffDelimPos = binaryData . indexOf ( binaryData . readerIndex ( ) , binaryData . writerIndex ( ) , ( byte ) <hex> ) ; if ( ffDelimPos > = <int> ) { binaryData . release ( ) ; throw new IllegalArgumentException ( <str> ) ; } return new TextWebSocketFrame ( binaryData ) ; } } 
