package org . elasticsearch . index . shard ; import org . apache . lucene . mockfile . FilterFileSystemProvider ; import org . elasticsearch . common . io . PathUtils ; import org . elasticsearch . common . io . PathUtilsForTesting ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . env . Environment ; import org . elasticsearch . env . NodeEnvironment ; import org . elasticsearch . env . NodeEnvironment . NodePath ; import org . elasticsearch . index . Index ; import org . elasticsearch . index . IndexSettings ; import org . elasticsearch . test . ESTestCase ; import org . elasticsearch . test . IndexSettingsModule ; import org . junit . AfterClass ; import org . junit . BeforeClass ; import java . io . IOException ; import java . nio . file . FileStore ; import java . nio . file . FileSystem ; import java . nio . file . Path ; import java . nio . file . attribute . FileAttributeView ; import java . nio . file . attribute . FileStoreAttributeView ; import java . nio . file . spi . FileSystemProvider ; import java . util . * ; public class NewPathForShardTests extends ESTestCase { private static final IndexSettings INDEX_SETTINGS = IndexSettingsModule . newIndexSettings ( new Index ( <str> ) , Settings . EMPTY ) ; private static MockFileStore aFileStore = new MockFileStore ( <str> ) ; private static MockFileStore bFileStore = new MockFileStore ( <str> ) ; private static String aPathPart ; private static String bPathPart ; @BeforeClass public static void installMockUsableSpaceFS ( ) throws Exception { FileSystem current = PathUtils . getDefaultFileSystem ( ) ; aPathPart = current . getSeparator ( ) + <str> + current . getSeparator ( ) ; bPathPart = current . getSeparator ( ) + <str> + current . getSeparator ( ) ; FileSystemProvider mock = new MockUsableSpaceFileSystemProvider ( current ) ; PathUtilsForTesting . installMock ( mock . getFileSystem ( null ) ) ; } @AfterClass public static void removeMockUsableSpaceFS ( ) throws Exception { PathUtilsForTesting . teardown ( ) ; aFileStore = null ; bFileStore = null ; } static class MockUsableSpaceFileSystemProvider extends FilterFileSystemProvider { public MockUsableSpaceFileSystemProvider ( FileSystem inner ) { super ( <str> , inner ) ; final List < FileStore > fileStores = new ArrayList < > ( ) ; fileStores . add ( aFileStore ) ; fileStores . add ( bFileStore ) ; } @Override public FileStore getFileStore ( Path path ) throws IOException { if ( path . toString ( ) . contains ( aPathPart ) ) { return aFileStore ; } else { return bFileStore ; } } } static class MockFileStore extends FileStore { public long usableSpace ; private final String desc ; public MockFileStore ( String desc ) { this . desc = desc ; } @Override public String type ( ) { return <str> ; } @Override public String name ( ) { return desc ; } @Override public String toString ( ) { return desc ; } @Override public boolean isReadOnly ( ) { return false ; } @Override public long getTotalSpace ( ) throws IOException { return usableSpace * <int> ; } @Override public long getUsableSpace ( ) throws IOException { return usableSpace ; } @Override public long getUnallocatedSpace ( ) throws IOException { return usableSpace * <int> ; } @Override public boolean supportsFileAttributeView ( Class < ? extends FileAttributeView > type ) { return false ; } @Override public boolean supportsFileAttributeView ( String name ) { return false ; } @Override public < V extends FileStoreAttributeView > V getFileStoreAttributeView ( Class < V > type ) { return null ; } @Override public Object getAttribute ( String attribute ) throws IOException { return null ; } } public void testSelectNewPathForShard ( ) throws Exception { Path path = PathUtils . get ( createTempDir ( ) . toString ( ) ) ; String [ ] paths = new String [ ] { path . resolve ( <str> ) . toString ( ) , path . resolve ( <str> ) . toString ( ) } ; Settings settings = Settings . builder ( ) . put ( <str> , path ) . putArray ( <str> , paths ) . build ( ) ; NodeEnvironment nodeEnv = new NodeEnvironment ( settings , new Environment ( settings ) ) ; NodePath [ ] nodePaths = nodeEnv . nodePaths ( ) ; assertEquals ( <int> , nodePaths . length ) ; assertEquals ( <str> , nodePaths [ <int> ] . fileStore . name ( ) ) ; assertEquals ( <str> , nodePaths [ <int> ] . fileStore . name ( ) ) ; aFileStore . usableSpace = <int> ; bFileStore . usableSpace = <int> ; ShardId shardId = new ShardId ( <str> , <int> ) ; ShardPath result = ShardPath . selectNewPathForShard ( nodeEnv , shardId , INDEX_SETTINGS , <int> , Collections . < Path , Integer > emptyMap ( ) ) ; assertTrue ( result . getDataPath ( ) . toString ( ) . contains ( aPathPart ) ) ; aFileStore . usableSpace = <int> ; bFileStore . usableSpace = <int> ; shardId = new ShardId ( <str> , <int> ) ; result = ShardPath . selectNewPathForShard ( nodeEnv , shardId , INDEX_SETTINGS , <int> , Collections . < Path , Integer > emptyMap ( ) ) ; assertTrue ( result . getDataPath ( ) . toString ( ) . contains ( bPathPart ) ) ; aFileStore . usableSpace = <int> ; bFileStore . usableSpace = <int> ; Map < Path , Integer > dataPathToShardCount = new HashMap < > ( ) ; ShardPath result1 = ShardPath . selectNewPathForShard ( nodeEnv , shardId , INDEX_SETTINGS , <int> , dataPathToShardCount ) ; dataPathToShardCount . put ( NodeEnvironment . shardStatePathToDataPath ( result1 . getDataPath ( ) ) , <int> ) ; ShardPath result2 = ShardPath . selectNewPathForShard ( nodeEnv , shardId , INDEX_SETTINGS , <int> , dataPathToShardCount ) ; assertNotEquals ( result1 . getDataPath ( ) , result2 . getDataPath ( ) ) ; nodeEnv . close ( ) ; } } 
