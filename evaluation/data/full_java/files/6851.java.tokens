package org . elasticsearch . indices . cache . query . terms ; import org . elasticsearch . common . ParsingException ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . io . stream . Writeable ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . index . query . TermsQueryBuilder ; import java . io . IOException ; import java . util . Objects ; public class TermsLookup implements Writeable < TermsLookup > , ToXContent { static final TermsLookup PROTOTYPE = new TermsLookup ( <str> , <str> , <str> , <str> ) ; private String index ; private final String type ; private final String id ; private final String path ; private String routing ; public TermsLookup ( TermsLookup copy ) { this ( copy . index , copy . type , copy . id , copy . path ) ; this . routing = copy . routing ; } public TermsLookup ( String index , String type , String id , String path ) { if ( id = = null ) { throw new IllegalArgumentException ( <str> + TermsQueryBuilder . NAME + <str> ) ; } if ( type = = null ) { throw new IllegalArgumentException ( <str> + TermsQueryBuilder . NAME + <str> ) ; } if ( path = = null ) { throw new IllegalArgumentException ( <str> + TermsQueryBuilder . NAME + <str> ) ; } this . index = index ; this . type = type ; this . id = id ; this . path = path ; } public String index ( ) { return index ; } public TermsLookup index ( String index ) { this . index = index ; return this ; } public String type ( ) { return type ; } public String id ( ) { return id ; } public String path ( ) { return path ; } public String routing ( ) { return routing ; } public TermsLookup routing ( String routing ) { this . routing = routing ; return this ; } public static TermsLookup parseTermsLookup ( XContentParser parser ) throws IOException { String index = null ; String type = null ; String id = null ; String path = null ; String routing = null ; XContentParser . Token token ; String currentFieldName = <str> ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( token . isValue ( ) ) { switch ( currentFieldName ) { case <str> : index = parser . textOrNull ( ) ; break ; case <str> : type = parser . text ( ) ; break ; case <str> : id = parser . text ( ) ; break ; case <str> : routing = parser . textOrNull ( ) ; break ; case <str> : path = parser . text ( ) ; break ; default : throw new ParsingException ( parser . getTokenLocation ( ) , <str> + TermsQueryBuilder . NAME + <str> + currentFieldName + <str> ) ; } } else { throw new ParsingException ( parser . getTokenLocation ( ) , <str> + TermsQueryBuilder . NAME + <str> + token + <str> + currentFieldName + <str> ) ; } } return new TermsLookup ( index , type , id , path ) . routing ( routing ) ; } @Override public String toString ( ) { return index + <str> + type + <str> + id + <str> + path ; } @Override public TermsLookup readFrom ( StreamInput in ) throws IOException { String type = in . readString ( ) ; String id = in . readString ( ) ; String path = in . readString ( ) ; String index = in . readOptionalString ( ) ; TermsLookup termsLookup = new TermsLookup ( index , type , id , path ) ; termsLookup . routing = in . readOptionalString ( ) ; return termsLookup ; } public static TermsLookup readTermsLookupFrom ( StreamInput in ) throws IOException { return PROTOTYPE . readFrom ( in ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { out . writeString ( type ) ; out . writeString ( id ) ; out . writeString ( path ) ; out . writeOptionalString ( index ) ; out . writeOptionalString ( routing ) ; } @Override public XContentBuilder toXContent ( XContentBuilder builder , Params params ) throws IOException { if ( index ! = null ) { builder . field ( <str> , index ) ; } builder . field ( <str> , type ) ; builder . field ( <str> , id ) ; builder . field ( <str> , path ) ; if ( routing ! = null ) { builder . field ( <str> , routing ) ; } return builder ; } @Override public int hashCode ( ) { return Objects . hash ( index , type , id , path , routing ) ; } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( obj = = null | | getClass ( ) ! = obj . getClass ( ) ) { return false ; } TermsLookup other = ( TermsLookup ) obj ; return Objects . equals ( index , other . index ) & & Objects . equals ( type , other . type ) & & Objects . equals ( id , other . id ) & & Objects . equals ( path , other . path ) & & Objects . equals ( routing , other . routing ) ; } } 
