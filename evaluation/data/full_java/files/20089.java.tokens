package io . netty . microbenchmark . common ; import java . util . Random ; import org . openjdk . jmh . annotations . Benchmark ; import org . openjdk . jmh . annotations . Level ; import org . openjdk . jmh . annotations . Measurement ; import org . openjdk . jmh . annotations . Param ; import org . openjdk . jmh . annotations . Setup ; import org . openjdk . jmh . annotations . Threads ; import org . openjdk . jmh . annotations . Warmup ; import io . netty . microbench . util . AbstractMicrobenchmark ; @Threads ( <int> ) @Warmup ( iterations = <int> ) @Measurement ( iterations = <int> ) public class AppendableCharSequenceBenchmark extends AbstractMicrobenchmark { @Param ( { <str> , <str> , <str> , <str> } ) private int charsInitSize ; @Param ( { <str> , <str> , <str> , <str> } ) private int simulatedDataSize ; private static final Random rand = new Random ( ) ; private char [ ] chars ; private char simulatedData ; private int pos ; @Setup ( Level . Trial ) public void setup ( ) { chars = new char [ charsInitSize ] ; simulatedData = ( char ) rand . nextInt ( ) ; } @Benchmark public void appendCheckBeforeCopy ( ) { checkReset ( ) ; if ( pos = = chars . length ) { expand ( ) ; } chars [ pos + + ] = simulatedData ; } @Benchmark public void appendCatchExceptionAfter ( ) { checkReset ( ) ; try { chars [ pos + + ] = simulatedData ; } catch ( IndexOutOfBoundsException e ) { expand ( ) ; chars [ pos - <int> ] = simulatedData ; } } private void checkReset ( ) { if ( pos = = simulatedDataSize ) { pos = <int> ; chars = new char [ charsInitSize ] ; } } private void expand ( ) { char [ ] old = chars ; int len = old . length < < <int> ; if ( len < <int> ) { throw new IllegalStateException ( ) ; } chars = new char [ len ] ; System . arraycopy ( old , <int> , chars , <int> , old . length ) ; } } 
