package org . elasticsearch . search . basic ; import org . elasticsearch . ElasticsearchException ; import org . elasticsearch . action . WriteConsistencyLevel ; import org . elasticsearch . action . admin . cluster . health . ClusterHealthResponse ; import org . elasticsearch . cluster . health . ClusterHealthStatus ; import org . elasticsearch . action . admin . indices . refresh . RefreshResponse ; import org . elasticsearch . action . search . SearchPhaseExecutionException ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . client . Requests ; import org . elasticsearch . common . Priority ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . index . query . GeohashCellQuery ; import org . elasticsearch . search . builder . SearchSourceBuilder ; import org . elasticsearch . test . ESIntegTestCase ; import java . io . IOException ; import static org . elasticsearch . client . Requests . clusterHealthRequest ; import static org . elasticsearch . client . Requests . refreshRequest ; import static org . elasticsearch . client . Requests . searchRequest ; import static org . elasticsearch . common . settings . Settings . settingsBuilder ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertAcked ; import static org . hamcrest . Matchers . anyOf ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . Matchers . instanceOf ; public class TransportSearchFailuresIT extends ESIntegTestCase { @Override protected int maximumNumberOfReplicas ( ) { return <int> ; } public void testFailedSearchWithWrongQuery ( ) throws Exception { logger . info ( <str> ) ; assertAcked ( prepareCreate ( <str> , <int> , settingsBuilder ( ) . put ( <str> , <str> ) ) ) ; ensureYellow ( ) ; NumShards test = getNumShards ( <str> ) ; for ( int i = <int> ; i < <int> ; i + + ) { index ( client ( ) , Integer . toString ( i ) , <str> , i ) ; } RefreshResponse refreshResponse = client ( ) . admin ( ) . indices ( ) . refresh ( refreshRequest ( <str> ) ) . actionGet ( ) ; assertThat ( refreshResponse . getTotalShards ( ) , equalTo ( test . totalNumShards ) ) ; assertThat ( refreshResponse . getSuccessfulShards ( ) , equalTo ( test . numPrimaries ) ) ; assertThat ( refreshResponse . getFailedShards ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { try { SearchResponse searchResponse = client ( ) . search ( searchRequest ( <str> ) . source ( new SearchSourceBuilder ( ) . query ( new GeohashCellQuery . Builder ( <str> , <str> ) ) ) ) . actionGet ( ) ; assertThat ( searchResponse . getTotalShards ( ) , equalTo ( test . numPrimaries ) ) ; assertThat ( searchResponse . getSuccessfulShards ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getFailedShards ( ) , equalTo ( test . numPrimaries ) ) ; fail ( <str> ) ; } catch ( ElasticsearchException e ) { assertThat ( e . unwrapCause ( ) , instanceOf ( SearchPhaseExecutionException . class ) ) ; } } allowNodes ( <str> , <int> ) ; assertThat ( client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . setWaitForEvents ( Priority . LANGUID ) . setWaitForNodes ( <str> ) . execute ( ) . actionGet ( ) . isTimedOut ( ) , equalTo ( false ) ) ; logger . info ( <str> ) ; ClusterHealthResponse clusterHealth = client ( ) . admin ( ) . cluster ( ) . health ( clusterHealthRequest ( <str> ) . waitForYellowStatus ( ) . waitForRelocatingShards ( <int> ) . waitForActiveShards ( test . totalNumShards ) ) . actionGet ( ) ; logger . info ( <str> + clusterHealth . getStatus ( ) ) ; assertThat ( clusterHealth . isTimedOut ( ) , equalTo ( false ) ) ; assertThat ( clusterHealth . getStatus ( ) , anyOf ( equalTo ( ClusterHealthStatus . YELLOW ) , equalTo ( ClusterHealthStatus . GREEN ) ) ) ; assertThat ( clusterHealth . getActiveShards ( ) , equalTo ( test . totalNumShards ) ) ; refreshResponse = client ( ) . admin ( ) . indices ( ) . refresh ( refreshRequest ( <str> ) ) . actionGet ( ) ; assertThat ( refreshResponse . getTotalShards ( ) , equalTo ( test . totalNumShards ) ) ; assertThat ( refreshResponse . getSuccessfulShards ( ) , equalTo ( test . totalNumShards ) ) ; assertThat ( refreshResponse . getFailedShards ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { try { SearchResponse searchResponse = client ( ) . search ( searchRequest ( <str> ) . source ( new SearchSourceBuilder ( ) . query ( new GeohashCellQuery . Builder ( <str> , <str> ) ) ) ) . actionGet ( ) ; assertThat ( searchResponse . getTotalShards ( ) , equalTo ( test . numPrimaries ) ) ; assertThat ( searchResponse . getSuccessfulShards ( ) , equalTo ( <int> ) ) ; assertThat ( searchResponse . getFailedShards ( ) , equalTo ( test . numPrimaries ) ) ; fail ( <str> ) ; } catch ( ElasticsearchException e ) { assertThat ( e . unwrapCause ( ) , instanceOf ( SearchPhaseExecutionException . class ) ) ; } } logger . info ( <str> ) ; } private void index ( Client client , String id , String nameValue , int age ) throws IOException { client . index ( Requests . indexRequest ( <str> ) . type ( <str> ) . id ( id ) . source ( source ( id , nameValue , age ) ) . consistencyLevel ( WriteConsistencyLevel . ONE ) ) . actionGet ( ) ; } private XContentBuilder source ( String id , String nameValue , int age ) throws IOException { StringBuilder multi = new StringBuilder ( ) . append ( nameValue ) ; for ( int i = <int> ; i < age ; i + + ) { multi . append ( <str> ) . append ( nameValue ) ; } return jsonBuilder ( ) . startObject ( ) . field ( <str> , id ) . field ( <str> , nameValue + id ) . field ( <str> , age ) . field ( <str> , multi . toString ( ) ) . endObject ( ) ; } } 
