package org . elasticsearch . search . aggregations ; import org . apache . lucene . index . LeafReaderContext ; import org . elasticsearch . search . aggregations . bucket . BestBucketsDeferringCollector ; import org . elasticsearch . search . aggregations . bucket . DeferringBucketCollector ; import org . elasticsearch . search . aggregations . pipeline . PipelineAggregator ; import org . elasticsearch . search . aggregations . support . AggregationContext ; import org . elasticsearch . search . internal . SearchContext . Lifetime ; import org . elasticsearch . search . query . QueryPhaseExecutionException ; import java . io . IOException ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public abstract class AggregatorBase extends Aggregator { protected final String name ; protected final Aggregator parent ; protected final AggregationContext context ; private final Map < String , Object > metaData ; protected final Aggregator [ ] subAggregators ; protected BucketCollector collectableSubAggregators ; private Map < String , Aggregator > subAggregatorbyName ; private DeferringBucketCollector recordingWrapper ; private final List < PipelineAggregator > pipelineAggregators ; protected AggregatorBase ( String name , AggregatorFactories factories , AggregationContext context , Aggregator parent , List < PipelineAggregator > pipelineAggregators , Map < String , Object > metaData ) throws IOException { this . name = name ; this . pipelineAggregators = pipelineAggregators ; this . metaData = metaData ; this . parent = parent ; this . context = context ; assert factories ! = null : <str> ; this . subAggregators = factories . createSubAggregators ( this ) ; context . searchContext ( ) . addReleasable ( this , Lifetime . PHASE ) ; collectableSubAggregators = new BucketCollector ( ) { void badState ( ) { throw new QueryPhaseExecutionException ( AggregatorBase . this . context . searchContext ( ) , <str> , null ) ; } @Override public LeafBucketCollector getLeafCollector ( LeafReaderContext reader ) { badState ( ) ; assert false ; return null ; } @Override public void preCollection ( ) throws IOException { badState ( ) ; } @Override public void postCollection ( ) throws IOException { badState ( ) ; } @Override public boolean needsScores ( ) { badState ( ) ; return false ; } } ; } @Override public boolean needsScores ( ) { for ( Aggregator agg : subAggregators ) { if ( agg . needsScores ( ) ) { return true ; } } return false ; } public Map < String , Object > metaData ( ) { return this . metaData ; } public List < PipelineAggregator > pipelineAggregators ( ) { return this . pipelineAggregators ; } protected abstract LeafBucketCollector getLeafCollector ( LeafReaderContext ctx , LeafBucketCollector sub ) throws IOException ; @Override public final LeafBucketCollector getLeafCollector ( LeafReaderContext ctx ) throws IOException { final LeafBucketCollector sub = collectableSubAggregators . getLeafCollector ( ctx ) ; return getLeafCollector ( ctx , sub ) ; } protected void doPreCollection ( ) throws IOException { } @Override public final void preCollection ( ) throws IOException { List < BucketCollector > collectors = new ArrayList < > ( ) ; List < BucketCollector > deferredCollectors = new ArrayList < > ( ) ; for ( int i = <int> ; i < subAggregators . length ; + + i ) { if ( shouldDefer ( subAggregators [ i ] ) ) { if ( recordingWrapper = = null ) { recordingWrapper = getDeferringCollector ( ) ; } deferredCollectors . add ( subAggregators [ i ] ) ; subAggregators [ i ] = recordingWrapper . wrap ( subAggregators [ i ] ) ; } else { collectors . add ( subAggregators [ i ] ) ; } } if ( recordingWrapper ! = null ) { recordingWrapper . setDeferredCollector ( deferredCollectors ) ; collectors . add ( recordingWrapper ) ; } collectableSubAggregators = BucketCollector . wrap ( collectors ) ; doPreCollection ( ) ; collectableSubAggregators . preCollection ( ) ; } public DeferringBucketCollector getDeferringCollector ( ) { return new BestBucketsDeferringCollector ( ) ; } protected boolean shouldDefer ( Aggregator aggregator ) { return false ; } protected final void runDeferredCollections ( long . . . bucketOrds ) throws IOException { if ( recordingWrapper ! = null ) { recordingWrapper . replay ( bucketOrds ) ; } } @Override public String name ( ) { return name ; } @Override public Aggregator parent ( ) { return parent ; } public Aggregator [ ] subAggregators ( ) { return subAggregators ; } @Override public Aggregator subAggregator ( String aggName ) { if ( subAggregatorbyName = = null ) { subAggregatorbyName = new HashMap < > ( subAggregators . length ) ; for ( int i = <int> ; i < subAggregators . length ; i + + ) { subAggregatorbyName . put ( subAggregators [ i ] . name ( ) , subAggregators [ i ] ) ; } } return subAggregatorbyName . get ( aggName ) ; } @Override public AggregationContext context ( ) { return context ; } @Override public final void postCollection ( ) throws IOException { doPostCollection ( ) ; collectableSubAggregators . postCollection ( ) ; } @Override public void close ( ) { doClose ( ) ; } protected void doClose ( ) { } protected void doPostCollection ( ) throws IOException { } protected final InternalAggregations buildEmptySubAggregations ( ) { List < InternalAggregation > aggs = new ArrayList < > ( ) ; for ( Aggregator aggregator : subAggregators ) { aggs . add ( aggregator . buildEmptyAggregation ( ) ) ; } return new InternalAggregations ( aggs ) ; } @Override public String toString ( ) { return name ; } } 
