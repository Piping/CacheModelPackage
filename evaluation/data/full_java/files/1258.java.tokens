package org . apache . cassandra . utils . btree ; import java . util . Arrays ; import java . util . Comparator ; import static org . apache . cassandra . utils . btree . BTree . * ; class NodeCursor < K > { final NodeCursor < K > parent , child ; final Comparator < ? super K > comparator ; boolean inChild ; int position ; Object [ ] node ; int nodeOffset ; NodeCursor ( Object [ ] node , NodeCursor < K > parent , Comparator < ? super K > comparator ) { this . node = node ; this . parent = parent ; this . comparator = comparator ; this . child = BTree . isLeaf ( node ) ? null : new NodeCursor < > ( ( Object [ ] ) node [ getChildStart ( node ) ] , this , comparator ) ; } void resetNode ( Object [ ] node , int nodeOffset ) { this . node = node ; this . nodeOffset = nodeOffset ; } void safeAdvanceIntoBranchFromChild ( boolean forwards ) { if ( ! forwards ) - - position ; } boolean advanceIntoBranchFromChild ( boolean forwards ) { return forwards ? position < getBranchKeyEnd ( node ) : - - position > = <int> ; } boolean advanceLeafNode ( boolean forwards ) { return forwards ? + + position < getLeafKeyEnd ( node ) : - - position > = <int> ; } K bound ( boolean upper ) { return ( K ) node [ position - ( upper ? <int> : <int> ) ] ; } NodeCursor < K > boundIterator ( boolean upper ) { NodeCursor < K > bound = this . parent ; while ( bound ! = null & & ( upper ? bound . position > = getChildCount ( bound . node ) - <int> : bound . position < = <int> ) ) bound = bound . parent ; return bound ; } boolean seekInNode ( K key , boolean forwards ) { int position = this . position ; int lb , ub ; if ( forwards ) { lb = position + <int> ; ub = getKeyEnd ( node ) ; } else { ub = position ; lb = <int> ; } int find = Arrays . binarySearch ( ( K [ ] ) node , lb , ub , key , comparator ) ; if ( find > = <int> ) { this . position = find ; inChild = false ; return true ; } int delta = isLeaf ( ) & ! forwards ? - <int> : <int> ; this . position = delta - <int> - find ; return false ; } NodeCursor < K > descendToFirstChild ( boolean forwards ) { if ( isLeaf ( ) ) { position = forwards ? <int> : getLeafKeyEnd ( node ) - <int> ; return null ; } inChild = true ; position = forwards ? <int> : getChildCount ( node ) - <int> ; return descend ( ) ; } NodeCursor < K > descend ( ) { Object [ ] childNode = ( Object [ ] ) node [ position + getChildStart ( node ) ] ; int childOffset = nodeOffset + treeIndexOffsetOfChild ( node , position ) ; child . resetNode ( childNode , childOffset ) ; inChild = true ; return child ; } boolean isLeaf ( ) { return child = = null ; } int globalIndex ( ) { return nodeOffset + treeIndexOfKey ( node , position ) ; } int globalLeafIndex ( ) { return nodeOffset + treeIndexOfLeafKey ( position ) ; } int globalBranchIndex ( ) { return nodeOffset + treeIndexOfBranchKey ( node , position ) ; } K value ( ) { return ( K ) node [ position ] ; } } 
