package org . elasticsearch . search . aggregations ; import org . apache . lucene . util . LuceneTestCase . AwaitsFix ; import org . elasticsearch . action . index . IndexRequestBuilder ; import org . elasticsearch . action . search . SearchResponse ; import org . elasticsearch . client . Requests ; import org . elasticsearch . common . xcontent . ToXContent ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . json . JsonXContent ; import org . elasticsearch . search . aggregations . bucket . terms . Terms ; import org . elasticsearch . search . aggregations . bucket . terms . Terms . Bucket ; import org . elasticsearch . search . aggregations . bucket . terms . TermsBuilder ; import org . elasticsearch . test . ESIntegTestCase ; import java . util . ArrayList ; import java . util . List ; import static org . elasticsearch . common . xcontent . XContentFactory . jsonBuilder ; import static org . elasticsearch . test . hamcrest . ElasticsearchAssertions . assertSearchResponse ; import static org . hamcrest . Matchers . equalTo ; import static org . hamcrest . core . IsNull . notNullValue ; @ESIntegTestCase.SuiteScopeTestCase @AwaitsFix ( bugUrl = <str> ) public class AggregationsBinaryIT extends ESIntegTestCase { private static final String STRING_FIELD_NAME = <str> ; private static final String INT_FIELD_NAME = <str> ; @Override public void setupSuiteScopeCluster ( ) throws Exception { createIndex ( <str> ) ; List < IndexRequestBuilder > builders = new ArrayList < > ( ) ; for ( int i = <int> ; i < <int> ; i + + ) { builders . add ( client ( ) . prepareIndex ( <str> , <str> ) . setSource ( jsonBuilder ( ) . startObject ( ) . field ( STRING_FIELD_NAME , <str> + i ) . field ( INT_FIELD_NAME , i ) . endObject ( ) ) ) ; } indexRandom ( true , builders ) ; ensureSearchable ( ) ; } public void testAggregationsBinary ( ) throws Exception { TermsBuilder termsBuilder = AggregationBuilders . terms ( <str> ) . field ( STRING_FIELD_NAME ) ; TermsBuilder subTerm = AggregationBuilders . terms ( <str> ) . field ( INT_FIELD_NAME ) ; XContentBuilder subTermContentBuilder = JsonXContent . contentBuilder ( ) . startObject ( ) ; subTerm . toXContent ( subTermContentBuilder , ToXContent . EMPTY_PARAMS ) ; subTermContentBuilder . endObject ( ) ; termsBuilder . subAggregation ( subTermContentBuilder ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( termsBuilder ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Terms . Bucket bucket = terms . getBucketByKey ( <str> + i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsString ( ) , equalTo ( <str> + i ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Aggregations subAggs = bucket . getAggregations ( ) ; assertThat ( subAggs , notNullValue ( ) ) ; assertThat ( subAggs . asList ( ) . size ( ) , equalTo ( <int> ) ) ; Terms subTerms = subAggs . get ( <str> ) ; assertThat ( subTerms , notNullValue ( ) ) ; List < Bucket > subTermsBuckets = subTerms . getBuckets ( ) ; assertThat ( subTermsBuckets , notNullValue ( ) ) ; assertThat ( subTermsBuckets . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Number ) subTermsBuckets . get ( <int> ) . getKey ( ) ) . intValue ( ) , equalTo ( i ) ) ; assertThat ( subTermsBuckets . get ( <int> ) . getDocCount ( ) , equalTo ( <int> ) ) ; } } public void testAggregationsBinarySameContentType ( ) throws Exception { TermsBuilder termsBuilder = AggregationBuilders . terms ( <str> ) . field ( STRING_FIELD_NAME ) ; TermsBuilder subTerm = AggregationBuilders . terms ( <str> ) . field ( INT_FIELD_NAME ) ; XContentBuilder subTermContentBuilder = XContentFactory . contentBuilder ( Requests . CONTENT_TYPE ) ; subTermContentBuilder . startObject ( ) ; subTerm . toXContent ( subTermContentBuilder , ToXContent . EMPTY_PARAMS ) ; subTermContentBuilder . endObject ( ) ; termsBuilder . subAggregation ( subTermContentBuilder ) ; SearchResponse response = client ( ) . prepareSearch ( <str> ) . setTypes ( <str> ) . addAggregation ( termsBuilder ) . execute ( ) . actionGet ( ) ; assertSearchResponse ( response ) ; Terms terms = response . getAggregations ( ) . get ( <str> ) ; assertThat ( terms , notNullValue ( ) ) ; assertThat ( terms . getName ( ) , equalTo ( <str> ) ) ; assertThat ( terms . getBuckets ( ) . size ( ) , equalTo ( <int> ) ) ; for ( int i = <int> ; i < <int> ; i + + ) { Terms . Bucket bucket = terms . getBucketByKey ( <str> + i ) ; assertThat ( bucket , notNullValue ( ) ) ; assertThat ( bucket . getKeyAsString ( ) , equalTo ( <str> + i ) ) ; assertThat ( bucket . getDocCount ( ) , equalTo ( <int> ) ) ; Aggregations subAggs = bucket . getAggregations ( ) ; assertThat ( subAggs , notNullValue ( ) ) ; assertThat ( subAggs . asList ( ) . size ( ) , equalTo ( <int> ) ) ; Terms subTerms = subAggs . get ( <str> ) ; assertThat ( subTerms , notNullValue ( ) ) ; List < Bucket > subTermsBuckets = subTerms . getBuckets ( ) ; assertThat ( subTermsBuckets , notNullValue ( ) ) ; assertThat ( subTermsBuckets . size ( ) , equalTo ( <int> ) ) ; assertThat ( ( ( Number ) subTermsBuckets . get ( <int> ) . getKey ( ) ) . intValue ( ) , equalTo ( i ) ) ; assertThat ( subTermsBuckets . get ( <int> ) . getDocCount ( ) , equalTo ( <int> ) ) ; } } } 
