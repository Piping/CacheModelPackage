package com . badlogic . gdx . graphics . g3d . utils ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . Mesh ; import com . badlogic . gdx . graphics . VertexAttributes ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g2d . TextureRegion ; import com . badlogic . gdx . graphics . g3d . model . MeshPart ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector2 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . utils . Pool . Poolable ; public interface MeshPartBuilder { public MeshPart getMeshPart ( ) ; public VertexAttributes getAttributes ( ) ; public void setColor ( final Color color ) ; public void setColor ( float r , float g , float b , float a ) ; public void setUVRange ( float u1 , float v1 , float u2 , float v2 ) ; public void setUVRange ( TextureRegion r ) ; public Matrix4 getVertexTransform ( Matrix4 out ) ; public void setVertexTransform ( Matrix4 transform ) ; public boolean isVertexTransformationEnabled ( ) ; public void setVertexTransformationEnabled ( boolean enabled ) ; public short vertex ( final float . . . values ) ; public short vertex ( Vector3 pos , Vector3 nor , Color col , Vector2 uv ) ; public short vertex ( final VertexInfo info ) ; public short lastIndex ( ) ; public void index ( final short value ) ; public void index ( short value1 , short value2 ) ; public void index ( short value1 , short value2 , short value3 ) ; public void index ( short value1 , short value2 , short value3 , short value4 ) ; public void index ( short value1 , short value2 , short value3 , short value4 , short value5 , short value6 ) ; public void index ( short value1 , short value2 , short value3 , short value4 , short value5 , short value6 , short value7 , short value8 ) ; public void line ( short index1 , short index2 ) ; public void line ( VertexInfo p1 , VertexInfo p2 ) ; public void line ( Vector3 p1 , Vector3 p2 ) ; public void line ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) ; public void line ( Vector3 p1 , Color c1 , Vector3 p2 , Color c2 ) ; public void triangle ( short index1 , short index2 , short index3 ) ; public void triangle ( VertexInfo p1 , VertexInfo p2 , VertexInfo p3 ) ; public void triangle ( Vector3 p1 , Vector3 p2 , Vector3 p3 ) ; public void triangle ( Vector3 p1 , Color c1 , Vector3 p2 , Color c2 , Vector3 p3 , Color c3 ) ; public void rect ( short corner00 , short corner10 , short corner11 , short corner01 ) ; public void rect ( VertexInfo corner00 , VertexInfo corner10 , VertexInfo corner11 , VertexInfo corner01 ) ; public void rect ( Vector3 corner00 , Vector3 corner10 , Vector3 corner11 , Vector3 corner01 , Vector3 normal ) ; public void rect ( float x00 , float y00 , float z00 , float x10 , float y10 , float z10 , float x11 , float y11 , float z11 , float x01 , float y01 , float z01 , float normalX , float normalY , float normalZ ) ; public void patch ( VertexInfo corner00 , VertexInfo corner10 , VertexInfo corner11 , VertexInfo corner01 , int divisionsU , int divisionsV ) ; public void patch ( Vector3 corner00 , Vector3 corner10 , Vector3 corner11 , Vector3 corner01 , Vector3 normal , int divisionsU , int divisionsV ) ; public void patch ( float x00 , float y00 , float z00 , float x10 , float y10 , float z10 , float x11 , float y11 , float z11 , float x01 , float y01 , float z01 , float normalX , float normalY , float normalZ , int divisionsU , int divisionsV ) ; public void box ( VertexInfo corner000 , VertexInfo corner010 , VertexInfo corner100 , VertexInfo corner110 , VertexInfo corner001 , VertexInfo corner011 , VertexInfo corner101 , VertexInfo corner111 ) ; public void box ( Vector3 corner000 , Vector3 corner010 , Vector3 corner100 , Vector3 corner110 , Vector3 corner001 , Vector3 corner011 , Vector3 corner101 , Vector3 corner111 ) ; public void box ( Matrix4 transform ) ; public void box ( float width , float height , float depth ) ; public void box ( float x , float y , float z , float width , float height , float depth ) ; public void circle ( float radius , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ ) ; public void circle ( float radius , int divisions , final Vector3 center , final Vector3 normal ) ; public void circle ( float radius , int divisions , final Vector3 center , final Vector3 normal , final Vector3 tangent , final Vector3 binormal ) ; public void circle ( float radius , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ , float tangentX , float tangentY , float tangentZ , float binormalX , float binormalY , float binormalZ ) ; public void circle ( float radius , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ , float angleFrom , float angleTo ) ; public void circle ( float radius , int divisions , final Vector3 center , final Vector3 normal , float angleFrom , float angleTo ) ; public void circle ( float radius , int divisions , final Vector3 center , final Vector3 normal , final Vector3 tangent , final Vector3 binormal , float angleFrom , float angleTo ) ; public void circle ( float radius , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ , float tangentX , float tangentY , float tangentZ , float binormalX , float binormalY , float binormalZ , float angleFrom , float angleTo ) ; public void ellipse ( float width , float height , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ ) ; public void ellipse ( float width , float height , int divisions , final Vector3 center , final Vector3 normal ) ; public void ellipse ( float width , float height , int divisions , final Vector3 center , final Vector3 normal , final Vector3 tangent , final Vector3 binormal ) ; public void ellipse ( float width , float height , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ , float tangentX , float tangentY , float tangentZ , float binormalX , float binormalY , float binormalZ ) ; public void ellipse ( float width , float height , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ , float angleFrom , float angleTo ) ; public void ellipse ( float width , float height , int divisions , final Vector3 center , final Vector3 normal , float angleFrom , float angleTo ) ; public void ellipse ( float width , float height , int divisions , final Vector3 center , final Vector3 normal , final Vector3 tangent , final Vector3 binormal , float angleFrom , float angleTo ) ; public void ellipse ( float width , float height , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ , float tangentX , float tangentY , float tangentZ , float binormalX , float binormalY , float binormalZ , float angleFrom , float angleTo ) ; public void ellipse ( float width , float height , float innerWidth , float innerHeight , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ , float tangentX , float tangentY , float tangentZ , float binormalX , float binormalY , float binormalZ , float angleFrom , float angleTo ) ; public void ellipse ( float width , float height , float innerWidth , float innerHeight , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ , float angleFrom , float angleTo ) ; public void ellipse ( float width , float height , float innerWidth , float innerHeight , int divisions , float centerX , float centerY , float centerZ , float normalX , float normalY , float normalZ ) ; public void ellipse ( float width , float height , float innerWidth , float innerHeight , int divisions , Vector3 center , Vector3 normal ) ; public void cylinder ( float width , float height , float depth , int divisions ) ; public void cylinder ( float width , float height , float depth , int divisions , float angleFrom , float angleTo ) ; public void cylinder ( float width , float height , float depth , int divisions , float angleFrom , float angleTo , boolean close ) ; public void cone ( float width , float height , float depth , int divisions ) ; public void cone ( float width , float height , float depth , int divisions , float angleFrom , float angleTo ) ; public void sphere ( float width , float height , float depth , int divisionsU , int divisionsV ) ; public void sphere ( final Matrix4 transform , float width , float height , float depth , int divisionsU , int divisionsV ) ; public void sphere ( float width , float height , float depth , int divisionsU , int divisionsV , float angleUFrom , float angleUTo , float angleVFrom , float angleVTo ) ; public void sphere ( final Matrix4 transform , float width , float height , float depth , int divisionsU , int divisionsV , float angleUFrom , float angleUTo , float angleVFrom , float angleVTo ) ; public void capsule ( float radius , float height , int divisions ) ; public void arrow ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float capLength , float stemThickness , int divisions ) ; public void addMesh ( Mesh mesh ) ; public void addMesh ( MeshPart meshpart ) ; public void addMesh ( Mesh mesh , int indexOffset , int numIndices ) ; public void addMesh ( float [ ] vertices , short [ ] indices ) ; public void addMesh ( float [ ] vertices , short [ ] indices , int indexOffset , int numIndices ) ; public static class VertexInfo implements Poolable { public final Vector3 position = new Vector3 ( ) ; public boolean hasPosition ; public final Vector3 normal = new Vector3 ( <int> , <int> , <int> ) ; public boolean hasNormal ; public final Color color = new Color ( <int> , <int> , <int> , <int> ) ; public boolean hasColor ; public final Vector2 uv = new Vector2 ( ) ; public boolean hasUV ; @Override public void reset ( ) { position . set ( <int> , <int> , <int> ) ; normal . set ( <int> , <int> , <int> ) ; color . set ( <int> , <int> , <int> , <int> ) ; uv . set ( <int> , <int> ) ; } public VertexInfo set ( Vector3 pos , Vector3 nor , Color col , Vector2 uv ) { reset ( ) ; if ( ( hasPosition = pos ! = null ) = = true ) position . set ( pos ) ; if ( ( hasNormal = nor ! = null ) = = true ) normal . set ( nor ) ; if ( ( hasColor = col ! = null ) = = true ) color . set ( col ) ; if ( ( hasUV = uv ! = null ) = = true ) this . uv . set ( uv ) ; return this ; } public VertexInfo set ( final VertexInfo other ) { if ( other = = null ) return set ( null , null , null , null ) ; hasPosition = other . hasPosition ; position . set ( other . position ) ; hasNormal = other . hasNormal ; normal . set ( other . normal ) ; hasColor = other . hasColor ; color . set ( other . color ) ; hasUV = other . hasUV ; uv . set ( other . uv ) ; return this ; } public VertexInfo setPos ( float x , float y , float z ) { position . set ( x , y , z ) ; hasPosition = true ; return this ; } public VertexInfo setPos ( Vector3 pos ) { if ( ( hasPosition = pos ! = null ) = = true ) position . set ( pos ) ; return this ; } public VertexInfo setNor ( float x , float y , float z ) { normal . set ( x , y , z ) ; hasNormal = true ; return this ; } public VertexInfo setNor ( Vector3 nor ) { if ( ( hasNormal = nor ! = null ) = = true ) normal . set ( nor ) ; return this ; } public VertexInfo setCol ( float r , float g , float b , float a ) { color . set ( r , g , b , a ) ; hasColor = true ; return this ; } public VertexInfo setCol ( Color col ) { if ( ( hasColor = col ! = null ) = = true ) color . set ( col ) ; return this ; } public VertexInfo setUV ( float u , float v ) { uv . set ( u , v ) ; hasUV = true ; return this ; } public VertexInfo setUV ( Vector2 uv ) { if ( ( hasUV = uv ! = null ) = = true ) this . uv . set ( uv ) ; return this ; } public VertexInfo lerp ( final VertexInfo target , float alpha ) { if ( hasPosition & & target . hasPosition ) position . lerp ( target . position , alpha ) ; if ( hasNormal & & target . hasNormal ) normal . lerp ( target . normal , alpha ) ; if ( hasColor & & target . hasColor ) color . lerp ( target . color , alpha ) ; if ( hasUV & & target . hasUV ) uv . lerp ( target . uv , alpha ) ; return this ; } } } 
