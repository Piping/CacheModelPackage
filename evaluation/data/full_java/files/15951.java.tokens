package org . gradle . tooling . internal . consumer ; import com . google . common . base . Preconditions ; import org . gradle . api . internal . classpath . EffectiveClassPath ; import org . gradle . initialization . BuildCancellationToken ; import org . gradle . initialization . layout . BuildLayout ; import org . gradle . initialization . layout . BuildLayoutFactory ; import org . gradle . internal . Factory ; import org . gradle . internal . UncheckedException ; import org . gradle . internal . classpath . ClassPath ; import org . gradle . internal . classpath . DefaultClassPath ; import org . gradle . logging . ProgressLogger ; import org . gradle . logging . ProgressLoggerFactory ; import org . gradle . tooling . BuildCancelledException ; import org . gradle . tooling . GradleConnectionException ; import org . gradle . util . DistributionLocator ; import org . gradle . util . GradleVersion ; import org . gradle . wrapper . * ; import java . io . File ; import java . io . FileNotFoundException ; import java . net . URI ; import java . util . LinkedHashSet ; import java . util . concurrent . Callable ; import java . util . concurrent . CancellationException ; import java . util . concurrent . ExecutionException ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . Future ; public class DistributionFactory { private final Factory < ? extends ExecutorService > executorFactory ; private File distributionBaseDir ; public DistributionFactory ( Factory < ? extends ExecutorService > executorFactory ) { this . executorFactory = Preconditions . checkNotNull ( executorFactory ) ; } public void setDistributionBaseDir ( File distributionBaseDir ) { this . distributionBaseDir = distributionBaseDir ; } public Distribution getDefaultDistribution ( File projectDir , boolean searchUpwards ) { BuildLayout layout = new BuildLayoutFactory ( ) . getLayoutFor ( projectDir , searchUpwards ) ; WrapperExecutor wrapper = WrapperExecutor . forProjectDirectory ( layout . getRootDirectory ( ) , System . out ) ; if ( wrapper . getDistribution ( ) ! = null ) { return new ZippedDistribution ( wrapper . getConfiguration ( ) , executorFactory , distributionBaseDir ) ; } return getDownloadedDistribution ( GradleVersion . current ( ) . getVersion ( ) ) ; } public Distribution getDistribution ( File gradleHomeDir ) { return new InstalledDistribution ( gradleHomeDir , String . format ( <str> , gradleHomeDir ) , String . format ( <str> , gradleHomeDir ) ) ; } public Distribution getDistribution ( String gradleVersion ) { return getDownloadedDistribution ( gradleVersion ) ; } public Distribution getDistribution ( URI gradleDistribution ) { WrapperConfiguration configuration = new WrapperConfiguration ( ) ; configuration . setDistribution ( gradleDistribution ) ; return new ZippedDistribution ( configuration , executorFactory , distributionBaseDir ) ; } public Distribution getClasspathDistribution ( ) { return new ClasspathDistribution ( ) ; } private Distribution getDownloadedDistribution ( String gradleVersion ) { URI distUri = new DistributionLocator ( ) . getDistributionFor ( GradleVersion . version ( gradleVersion ) ) ; return getDistribution ( distUri ) ; } private static class ZippedDistribution implements Distribution { private InstalledDistribution installedDistribution ; private final WrapperConfiguration wrapperConfiguration ; private final Factory < ? extends ExecutorService > executorFactory ; private final File distributionBaseDir ; private ZippedDistribution ( WrapperConfiguration wrapperConfiguration , Factory < ? extends ExecutorService > executorFactory , File distributionBaseDir ) { this . wrapperConfiguration = wrapperConfiguration ; this . executorFactory = executorFactory ; this . distributionBaseDir = distributionBaseDir ; } public String getDisplayName ( ) { return String . format ( <str> , wrapperConfiguration . getDistribution ( ) ) ; } public ClassPath getToolingImplementationClasspath ( final ProgressLoggerFactory progressLoggerFactory , final File userHomeDir , BuildCancellationToken cancellationToken ) { if ( installedDistribution = = null ) { Callable < File > installDistroTask = new Callable < File > ( ) { public File call ( ) throws Exception { File installDir ; try { File realUserHomeDir = determineRealUserHomeDir ( userHomeDir ) ; Install install = new Install ( new Logger ( false ) , new ProgressReportingDownload ( progressLoggerFactory ) , new PathAssembler ( realUserHomeDir ) ) ; installDir = install . createDist ( wrapperConfiguration ) ; } catch ( FileNotFoundException e ) { throw new IllegalArgumentException ( String . format ( <str> , getDisplayName ( ) ) , e ) ; } catch ( CancellationException e ) { throw new BuildCancelledException ( String . format ( <str> , wrapperConfiguration . getDistribution ( ) ) , e ) ; } catch ( Exception e ) { throw new GradleConnectionException ( String . format ( <str> , wrapperConfiguration . getDistribution ( ) ) , e ) ; } return installDir ; } } ; File installDir ; ExecutorService executor = null ; try { executor = executorFactory . create ( ) ; final Future < File > installDirFuture = executor . submit ( installDistroTask ) ; cancellationToken . addCallback ( new Runnable ( ) { public void run ( ) { installDirFuture . cancel ( true ) ; } } ) ; installDir = installDirFuture . get ( ) ; } catch ( CancellationException e ) { throw new BuildCancelledException ( String . format ( <str> , wrapperConfiguration . getDistribution ( ) ) , e ) ; } catch ( InterruptedException e ) { throw new GradleConnectionException ( String . format ( <str> , wrapperConfiguration . getDistribution ( ) ) , e ) ; } catch ( ExecutionException e ) { if ( e . getCause ( ) ! = null ) { UncheckedException . throwAsUncheckedException ( e . getCause ( ) ) ; } throw new GradleConnectionException ( String . format ( <str> , wrapperConfiguration . getDistribution ( ) ) , e ) ; } finally { if ( executor ! = null ) { executor . shutdown ( ) ; } } installedDistribution = new InstalledDistribution ( installDir , getDisplayName ( ) , getDisplayName ( ) ) ; } return installedDistribution . getToolingImplementationClasspath ( progressLoggerFactory , userHomeDir , cancellationToken ) ; } private File determineRealUserHomeDir ( final File userHomeDir ) { if ( distributionBaseDir ! = null ) { return distributionBaseDir ; } return userHomeDir ! = null ? userHomeDir : GradleUserHomeLookup . gradleUserHome ( ) ; } } private static class ProgressReportingDownload implements IDownload { private final ProgressLoggerFactory progressLoggerFactory ; private ProgressReportingDownload ( ProgressLoggerFactory progressLoggerFactory ) { this . progressLoggerFactory = progressLoggerFactory ; } public void download ( URI address , File destination ) throws Exception { ProgressLogger progressLogger = progressLoggerFactory . newOperation ( DistributionFactory . class ) ; progressLogger . setDescription ( String . format ( <str> , address ) ) ; progressLogger . started ( ) ; try { new Download ( new Logger ( false ) , <str> , GradleVersion . current ( ) . getVersion ( ) ) . download ( address , destination ) ; } finally { progressLogger . completed ( ) ; } } } private static class InstalledDistribution implements Distribution { private final File gradleHomeDir ; private final String displayName ; private final String locationDisplayName ; public InstalledDistribution ( File gradleHomeDir , String displayName , String locationDisplayName ) { this . gradleHomeDir = gradleHomeDir ; this . displayName = displayName ; this . locationDisplayName = locationDisplayName ; } public String getDisplayName ( ) { return displayName ; } public ClassPath getToolingImplementationClasspath ( ProgressLoggerFactory progressLoggerFactory , File userHomeDir , BuildCancellationToken cancellationToken ) { ProgressLogger progressLogger = progressLoggerFactory . newOperation ( DistributionFactory . class ) ; progressLogger . setDescription ( <str> ) ; progressLogger . started ( ) ; try { return getToolingImpl ( ) ; } finally { progressLogger . completed ( ) ; } } private ClassPath getToolingImpl ( ) { if ( ! gradleHomeDir . exists ( ) ) { throw new IllegalArgumentException ( String . format ( <str> , locationDisplayName ) ) ; } if ( ! gradleHomeDir . isDirectory ( ) ) { throw new IllegalArgumentException ( String . format ( <str> , locationDisplayName ) ) ; } File libDir = new File ( gradleHomeDir , <str> ) ; if ( ! libDir . isDirectory ( ) ) { throw new IllegalArgumentException ( String . format ( <str> , locationDisplayName ) ) ; } LinkedHashSet < File > files = new LinkedHashSet < File > ( ) ; for ( File file : libDir . listFiles ( ) ) { if ( file . getName ( ) . endsWith ( <str> ) ) { files . add ( file ) ; } } return new DefaultClassPath ( files ) ; } } private static class ClasspathDistribution implements Distribution { public String getDisplayName ( ) { return <str> ; } public ClassPath getToolingImplementationClasspath ( ProgressLoggerFactory progressLoggerFactory , File userHomeDir , BuildCancellationToken cancellationToken ) { return new EffectiveClassPath ( getClass ( ) . getClassLoader ( ) ) ; } } } 
