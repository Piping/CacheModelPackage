package org . elasticsearch . rest . action . cat ; import com . carrotsearch . hppc . ObjectLongMap ; import com . carrotsearch . hppc . ObjectLongHashMap ; import org . elasticsearch . action . admin . cluster . node . stats . NodeStats ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsRequest ; import org . elasticsearch . action . admin . cluster . node . stats . NodesStatsResponse ; import org . elasticsearch . client . Client ; import org . elasticsearch . common . Table ; import org . elasticsearch . common . inject . Inject ; import org . elasticsearch . common . settings . Settings ; import org . elasticsearch . common . unit . ByteSizeValue ; import org . elasticsearch . rest . * ; import org . elasticsearch . rest . action . support . RestResponseListener ; import org . elasticsearch . rest . action . support . RestTable ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Set ; import static org . elasticsearch . rest . RestRequest . Method . GET ; public class RestFielddataAction extends AbstractCatAction { @Inject public RestFielddataAction ( Settings settings , RestController controller , Client client ) { super ( settings , controller , client ) ; controller . registerHandler ( GET , <str> , this ) ; controller . registerHandler ( GET , <str> , this ) ; } @Override protected void doRequest ( final RestRequest request , final RestChannel channel , final Client client ) { final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest ( <str> ) ; nodesStatsRequest . clear ( ) ; nodesStatsRequest . indices ( true ) ; String [ ] fields = request . paramAsStringArray ( <str> , null ) ; nodesStatsRequest . indices ( ) . fieldDataFields ( fields = = null ? new String [ ] { <str> } : fields ) ; client . admin ( ) . cluster ( ) . nodesStats ( nodesStatsRequest , new RestResponseListener < NodesStatsResponse > ( channel ) { @Override public RestResponse buildResponse ( NodesStatsResponse nodeStatses ) throws Exception { return RestTable . buildResponse ( buildTable ( request , nodeStatses ) , channel ) ; } } ) ; } @Override protected void documentation ( StringBuilder sb ) { sb . append ( <str> ) ; sb . append ( <str> ) ; } @Override protected Table getTableWithHeader ( RestRequest request ) { Table table = new Table ( ) ; table . startHeaders ( ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . endHeaders ( ) ; return table ; } private Table buildTable ( final RestRequest request , final NodesStatsResponse nodeStatses ) { Set < String > fieldNames = new HashSet < > ( ) ; Map < NodeStats , ObjectLongMap < String > > nodesFields = new HashMap < > ( ) ; for ( NodeStats ns : nodeStatses . getNodes ( ) ) { ObjectLongHashMap < String > fields = ns . getIndices ( ) . getFieldData ( ) . getFields ( ) ; nodesFields . put ( ns , fields ) ; if ( fields ! = null ) { for ( String key : fields . keys ( ) . toArray ( String . class ) ) { fieldNames . add ( key ) ; } } } Table table = new Table ( ) ; table . startHeaders ( ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) . addCell ( <str> , <str> ) ; for ( String fieldName : fieldNames ) { table . addCell ( fieldName , <str> + fieldName + <str> ) ; } table . endHeaders ( ) ; for ( Map . Entry < NodeStats , ObjectLongMap < String > > statsEntry : nodesFields . entrySet ( ) ) { table . startRow ( ) ; NodeStats ns = statsEntry . getKey ( ) ; table . addCell ( ns . getNode ( ) . id ( ) ) ; table . addCell ( ns . getNode ( ) . getHostName ( ) ) ; table . addCell ( ns . getNode ( ) . getHostAddress ( ) ) ; table . addCell ( ns . getNode ( ) . getName ( ) ) ; table . addCell ( ns . getIndices ( ) . getFieldData ( ) . getMemorySize ( ) ) ; ObjectLongMap < String > fields = statsEntry . getValue ( ) ; for ( String fieldName : fieldNames ) { table . addCell ( new ByteSizeValue ( fields = = null ? <int> L : fields . getOrDefault ( fieldName , <int> L ) ) ) ; } table . endRow ( ) ; } return table ; } } 
