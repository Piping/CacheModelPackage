package org . apache . cassandra . service . pager ; import org . apache . cassandra . config . CFMetaData ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . filter . * ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . service . ClientState ; import org . apache . cassandra . transport . Server ; public class QueryPagers { private QueryPagers ( ) { } ; public static int countPaged ( CFMetaData metadata , DecoratedKey key , ColumnFilter columnFilter , ClusteringIndexFilter filter , DataLimits limits , ConsistencyLevel consistencyLevel , ClientState state , final int pageSize , int nowInSec , boolean isForThrift ) throws RequestValidationException , RequestExecutionException { SinglePartitionReadCommand command = SinglePartitionReadCommand . create ( isForThrift , metadata , nowInSec , columnFilter , RowFilter . NONE , limits , key , filter ) ; final SinglePartitionPager pager = new SinglePartitionPager ( command , null , Server . CURRENT_VERSION ) ; int count = <int> ; while ( ! pager . isExhausted ( ) ) { try ( PartitionIterator iter = pager . fetchPage ( pageSize , consistencyLevel , state ) ) { DataLimits . Counter counter = limits . newCounter ( nowInSec , true ) ; PartitionIterators . consume ( counter . applyTo ( iter ) ) ; count + = counter . counted ( ) ; } } return count ; } } 
